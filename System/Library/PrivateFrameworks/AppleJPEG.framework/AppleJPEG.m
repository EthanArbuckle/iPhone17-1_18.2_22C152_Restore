uint64_t applejpeg_decode_open_file(uint64_t a1, unint64_t a2, unsigned __int8 a3)
{
  return decode_open(a1, a2, 0, a3, 0);
}

_OWORD *applejpeg_decode_create(void *a1)
{
  if (!a1 || !*a1 || !a1[1]) {
    return 0;
  }
  v2 = (_OWORD *)((uint64_t (*)(uint64_t, void))*a1)(13120, a1[2]);
  v3 = v2;
  if (v2)
  {
    bzero(v2, 0x3340uLL);
    bzero(v3, 0x3340uLL);
    os_log_object = aj_get_os_log_object();
    if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG)) {
      applejpeg_decode_create_cold_1((uint64_t)v3, os_log_object, v5, v6, v7, v8, v9, v10);
    }
    long long v11 = *(_OWORD *)a1;
    *((void *)v3 + 2) = a1[2];
    _OWORD *v3 = v11;
    *((void *)v3 + 1625) = v3;
    *((void *)v3 + 1631) = v3;
    *((void *)v3 + 448) = 0x100000001;
    *((_DWORD *)v3 + 898) = 0;
    *(void *)((char *)v3 + 3596) = -1;
    *(void *)((char *)v3 + 3604) = -1;
    *((_DWORD *)v3 + 903) = 0;
    *((void *)v3 + 452) = 0;
    *((void *)v3 + 459) = 0;
    *((void *)v3 + 458) = 0;
    *((void *)v3 + 457) = 0x1FF000000;
    v3[230] = xmmword_210410570;
    *(_OWORD *)((char *)v3 + 3624) = 0u;
    *(_OWORD *)((char *)v3 + 3640) = 0u;
    *((_DWORD *)v3 + 924) = 0;
    *((_DWORD *)v3 + 931) = 0;
    *((void *)v3 + 464) = 0;
    *((void *)v3 + 463) = 0;
    *((unsigned char *)v3 + 3720) = 0;
    *((unsigned char *)v3 + 3728) = 1;
    *((unsigned char *)v3 + 12697) = 0;
    *((_DWORD *)v3 + 3232) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Could not allocate memory for session object");
  }
  return v3;
}

void applejpeg_decode_destroy(void *a1)
{
  os_log_object = aj_get_os_log_object();
  if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG))
  {
    applejpeg_decode_destroy_cold_1((uint64_t)a1, os_log_object, v3, v4, v5, v6, v7, v8);
    if (!a1) {
      return;
    }
  }
  else if (!a1)
  {
    return;
  }
  uint64_t v10 = (void (*)(void *, uint64_t))a1[1];
  uint64_t v9 = a1[2];
  dec_free_allocations((uint64_t)(a1 + 524), (uint64_t)a1, (uint64_t)(a1 + 1625), (uint64_t)(a1 + 1396));
  uint64_t v11 = 0;
  char v12 = 1;
  do
  {
    uint64_t v13 = 0;
    char v14 = v12;
    uint64_t v15 = (uint64_t)&a1[v11 + 469];
    do
    {
      if (!aj_huffman_decode_is_static_table(*(char **)(v15 + v13)))
      {
        v16 = *(void **)(v15 + v13);
        if (v16)
        {
          v10(v16, v9);
          *(void *)(v15 + v13) = 0;
        }
      }
      v13 += 16;
    }
    while (v13 != 64);
    char v12 = 0;
    uint64_t v11 = 1;
  }
  while ((v14 & 1) != 0);
  v17 = (void *)a1[1632];
  if (v17)
  {
    v10(v17, v9);
    a1[1632] = 0;
  }
  v18 = (void *)a1[1633];
  if (v18)
  {
    v10(v18, v9);
    a1[1633] = 0;
  }
  v19 = (void *)a1[1634];
  if (v19)
  {
    v10(v19, v9);
    a1[1634] = 0;
  }
  v20 = (void *)a1[1635];
  if (v20)
  {
    v10(v20, v9);
    a1[1635] = 0;
  }
  v21 = (void *)a1[1636];
  if (v21)
  {
    v10(v21, v9);
    a1[1636] = 0;
  }
  v22 = (void *)a1[1637];
  if (v22)
  {
    v10(v22, v9);
    a1[1637] = 0;
  }
  v23 = (void *)a1[1638];
  if (v23)
  {
    v10(v23, v9);
    a1[1638] = 0;
  }
  v10(a1, v9);
}

BOOL aj_huffman_decode_is_static_table(char *a1)
{
  uint64_t v1 = 0;
  char v2 = 1;
  do
  {
    BOOL v4 = (char *)&std_huffman_luma + 4500 * v1 == a1 || (char *)&std_huffman_chroma + 4500 * v1 == a1;
    if ((v2 & 1) == 0) {
      break;
    }
    char v2 = 0;
    uint64_t v1 = 1;
  }
  while (!v4);
  return v4;
}

uint64_t aj_get_os_log_object()
{
  if (aj_get_os_log_object_onceToken != -1) {
    dispatch_once(&aj_get_os_log_object_onceToken, &__block_literal_global);
  }
  return aj_get_os_log_object_s_logger;
}

uint64_t aj_read_jfif (uint64_t a1)
{
  unsigned int v4 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v4, 2);
  if (!result)
  {
    unsigned int v3 = v4;
    if (v4 <= 0xF) {
      aj_log_error((uint64_t)"Read", "Illegal JFIF header. Length of header is %u, must be >= 16.", v4);
    }
    return aj_istream_skip_bytes(a1, v3 - 2);
  }
  return result;
}

uint64_t decode_open(uint64_t a1, unint64_t a2, uint64_t *a3, int a4, int a5)
{
  if (!a1) {
    return 8;
  }
  if (!a2 || !a3)
  {
    if (!(a2 | (unint64_t)a3))
    {
      aj_log_error((uint64_t)"Decode", "Input cannot be NULL");
      return 8;
    }
    if (a2)
    {
      if (!*(void *)a2 || !*(void *)(a2 + 16))
      {
        aj_log_error((uint64_t)"Decode", "Read/Skip callbacks not set");
        return 8;
      }
      unint64_t v10 = *(void *)(a2 + 40);
      if (v10)
      {
        if (v10 <= 0xFFF)
        {
          aj_log_error((uint64_t)"Decode", "The read buffer size must be larger than %d");
          return 8;
        }
        if (v10 >> 31)
        {
          aj_log_error((uint64_t)"Decode", "The read buffer size can't be larger than %d");
          return 8;
        }
      }
      if (*(void *)(a2 + 48) >> 31)
      {
        aj_log_error((uint64_t)"Decode", "The file size can't be larger than %d");
        return 8;
      }
    }
    else
    {
      if (!*a3 || (unint64_t v11 = a3[1]) == 0)
      {
        aj_log_error((uint64_t)"Decode", "NULL fields in the memory input struct not allowed");
        return 8;
      }
      if (v11 >> 31)
      {
        aj_log_error((uint64_t)"Decode", "The input buffer size can't be larger than %d");
        return 8;
      }
    }
    int v14 = *(_DWORD *)(a1 + 12928);
    if (v14 == 1)
    {
      BOOL v22 = 0;
      int v20 = 0;
    }
    else
    {
      if (v14) {
        goto LABEL_55;
      }
      uint64_t v12 = aj_istream_move_to_position(a1 + 24, 0);
      if (v12) {
        return v12;
      }
      uint64_t v15 = *(void *)(a1 + 3576);
      if (v15) {
        (*(void (**)(uint64_t, void))(a1 + 8))(v15, *(void *)(a1 + 16));
      }
      v16 = (void *)(*(uint64_t (**)(uint64_t, void))a1)(800, *(void *)(a1 + 16));
      *(void *)(a1 + 13056) = v16;
      *(void *)(a1 + 3576) = v16;
      if (!v16 || (bzero(v16, 0x320uLL), !*(void *)(a1 + 3576)))
      {
        aj_log_error((uint64_t)"Decode", "Could not allocate segment info buffer");
        return 6;
      }
      *(_DWORD *)(a1 + 3568) = 50;
      if (a2)
      {
        *(_DWORD *)(a1 + 12996) = a4;
        uint64_t v17 = *(void *)(a2 + 40);
        unint64_t v18 = *(void *)(a2 + 48);
        if (!v17) {
          LODWORD(v17) = 4096;
        }
        if (v18 >= (int)v17 || v18 == 0) {
          int v20 = v17;
        }
        else {
          int v20 = *(void *)(a2 + 48);
        }
        uint64_t v21 = *(void *)(a1 + 13064);
        if (!v21)
        {
          v24 = (void *)(*(uint64_t (**)(void, void))a1)(v20, *(void *)(a1 + 16));
          *(void *)(a1 + 13064) = v24;
          if (!v24 || (bzero(v24, v20), (uint64_t v21 = *(void *)(a1 + 13064)) == 0))
          {
            aj_log_error((uint64_t)"Decode", "Could not allocate read buffer for file input");
            uint64_t v12 = 6;
            goto LABEL_61;
          }
        }
        *(_DWORD *)(a1 + 12992) = 1;
        aj_istream_init_file(a1 + 24, (void *)a2, v21, v20, a4, 0);
        *(_DWORD *)(a1 + 12928) = 1;
        BOOL v22 = v20 > 6144;
        if (v20 >= 6145 && *(_DWORD *)(a1 + 12992))
        {
          *(_DWORD *)(a1 + 60) = 6144;
          BOOL v22 = 1;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 12996) = 0;
        aj_istream_init_mem(a1 + 24, a3, 0, 0);
        BOOL v22 = 0;
        int v20 = 0;
        *(_DWORD *)(a1 + 12928) = 1;
      }
    }
    kdebug_trace();
    uint64_t v12 = aj_parse_jpeg((void *)(a1 + 13048), a1 + 24, a1 + 144, (_DWORD *)(a1 + 12936), (int *)(a1 + 3568), 0, *(_DWORD *)(a1 + 12996), a5, *(unsigned char *)(a1 + 12696));
    kdebug_trace();
    if (v22 && *(_DWORD *)(a1 + 12992)) {
      *(_DWORD *)(a1 + 60) = v20;
    }
    if (v12)
    {
      if (v12 == -2 && *(_DWORD *)(a1 + 12996)) {
        return 4294967294;
      }
      aj_log_error((uint64_t)"Decode", "Parse returned error code %d", v12);
LABEL_56:
      if (v12 == -2) {
        return 4294967294;
      }
LABEL_61:
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      return v12;
    }
    int v23 = *(_DWORD *)(a1 + 176);
    if (*(int *)(a1 + 160) > 2 || v23 >= 3)
    {
      aj_log_error((uint64_t)"Decode", "Unsupported subsampling %dx%d", *(_DWORD *)(a1 + 160), v23);
      uint64_t v12 = 3;
      goto LABEL_61;
    }
LABEL_55:
    uint64_t v12 = aj_imageinfo_init((unsigned int *)(a1 + 144), a1 + 3744, a1);
    if (!v12)
    {
      *(_DWORD *)(a1 + 12928) = 2;
      return v12;
    }
    goto LABEL_56;
  }
  aj_log_error((uint64_t)"Decode", "Cannot have both file input AND memory input");
  return 8;
}

uint64_t aj_istream_move_to_position(uint64_t a1, uint64_t a2)
{
  if ((a2 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Istream", "Attempting to move to %d which is < 0");
    return 8;
  }
  if (!*(void *)(a1 + 80))
  {
    *(void *)(a1 + 8) = *(void *)(a1 + 40) + a2;
    int v7 = *(_DWORD *)(a1 + 52) - a2;
    goto LABEL_8;
  }
  int v4 = *(_DWORD *)(a1 + 32);
  unsigned int v5 = a2 - (*(_DWORD *)(a1 + 48) - v4);
  if (!v5) {
    return 0;
  }
  if ((v5 & 0x80000000) != 0)
  {
    uint64_t v11 = (*(_DWORD *)(a1 + 48) - v4 - a2);
    uint64_t v12 = *(void *)(a1 + 8);
    if (v12 - *(void *)(a1 + 40) < v11)
    {
      uint64_t v13 = *(uint64_t (**)(void))(a1 + 88);
      if (v13)
      {
        uint64_t result = v13(*(void *)(a1 + 64));
        if (result) {
          return result;
        }
        *(_DWORD *)(a1 + 56) = 0;
        *(_DWORD *)(a1 + 48) = 0;
        uint64_t result = (*(uint64_t (**)(uint64_t, void))(a1 + 72))(a2, *(void *)(a1 + 64));
        if (result) {
          return result;
        }
        *(_DWORD *)(a1 + 48) += a2;
        int v21 = 0;
        uint64_t result = read_bytes_with_callback(a1, *(void *)(a1 + 40), *(_DWORD *)(a1 + 36), &v21);
        if (result) {
          return result;
        }
        *(void *)(a1 + 8) = *(void *)(a1 + 40);
        int v7 = v21;
        goto LABEL_8;
      }
      aj_log_error((uint64_t)"Istream", "No rewind or skip function provided");
      return 8;
    }
    *(void *)(a1 + 8) = v12 - v11;
    int v7 = v4 - v5;
LABEL_8:
    *(_DWORD *)(a1 + 32) = v7;
    goto LABEL_9;
  }
  if (v4 >= (int)v5)
  {
    *(void *)(a1 + 8) += v5;
    int v14 = v4 - v5;
    *(_DWORD *)(a1 + 32) = v14;
    if (!v14)
    {
      uint64_t result = aj_istream_move_forward(a1);
      if (result) {
        return result;
      }
    }
LABEL_9:
    uint64_t result = 0;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)a1 = 0;
    *(void *)(a1 + 24) = 0x1FFFFFFF7;
    return result;
  }
  uint64_t v8 = (a2 - *(_DWORD *)(a1 + 48));
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(a1 + 72))(v8, *(void *)(a1 + 64));
  if (!result)
  {
    int v9 = *(_DWORD *)(a1 + 48) + v8;
    *(_DWORD *)(a1 + 48) = v9;
    if (*(_DWORD *)(a1 + 56) == 2)
    {
      int v10 = 0;
LABEL_44:
      *(_DWORD *)(a1 + 32) = v10;
      *(void *)(a1 + 8) = *(void *)(a1 + 40);
      goto LABEL_9;
    }
    int v10 = 0;
    uint64_t v15 = *(void *)(a1 + 40);
    int v16 = *(_DWORD *)(a1 + 36);
    while (1)
    {
      int v17 = *(_DWORD *)(a1 + 52);
      if (v17) {
        BOOL v18 = v9 < v17;
      }
      else {
        BOOL v18 = 1;
      }
      if (!v18)
      {
        *(_DWORD *)(a1 + 56) = 2;
LABEL_37:
        if ((v9 & 0x80000000) == 0) {
          goto LABEL_44;
        }
        aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
        return 9;
      }
      if (*(_DWORD *)(a1 + 56) == 1) {
        *(_DWORD *)(a1 + 56) = 0;
      }
      int v19 = (*(uint64_t (**)(uint64_t, void, void))(a1 + 80))(v15 + v10, (v16 - v10), *(void *)(a1 + 64));
      if (v19 <= 0) {
        break;
      }
      int v9 = *(_DWORD *)(a1 + 48) + v19;
      *(_DWORD *)(a1 + 48) = v9;
      v10 += v19;
      if (v10 >= 8) {
        goto LABEL_37;
      }
    }
    if (!v19)
    {
      int v20 = 1;
      goto LABEL_43;
    }
    if (v19 == -1)
    {
      int v20 = 2;
LABEL_43:
      *(_DWORD *)(a1 + 56) = v20;
      goto LABEL_44;
    }
    aj_log_error((uint64_t)"Istream", "File read error");
    return 9;
  }
  return result;
}

uint64_t aj_init_huffman(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  if (!*((unsigned char *)a1 + 84))
  {
    uint64_t v6 = 0;
    v24 = a1 + 839;
    int v23 = a1 + 843;
    char v7 = 1;
    while (2)
    {
      uint64_t v8 = 0;
      int v10 = v7 & 1;
      BOOL v9 = v10 == 0;
      unsigned __int8 v27 = v10;
      if (v10) {
        uint64_t v11 = 839;
      }
      else {
        uint64_t v11 = 843;
      }
      uint64_t v12 = v24;
      if (v9) {
        uint64_t v12 = v23;
      }
      v26 = v12;
      do
      {
        BOOL v13 = v8 == a1[v11];
        if (*((unsigned char *)a1 + 2 * v8 + v6 + 3320))
        {
          uint64_t v14 = a2 + 16 * v8 + 8 * v6;
          uint64_t v16 = *(void *)(v14 + 8);
          uint64_t v15 = (char **)(v14 + 8);
          if (!v16)
          {
            if (aj_huffman_is_standard_table(&a1[8 * v8 + 286 + 4 * v6], &a1[128 * v8 + 318 + 64 * v6], v13, v27))
            {
              *uint64_t v15 = aj_huffman_decode_get_standard_table(v13, v27);
            }
            else
            {
              if (*v15) {
                (*(void (**)(char *, void))(a3 + 8))(*v15, *(void *)(a3 + 16));
              }
              int v17 = (char *)(*(uint64_t (**)(uint64_t, void))a3)(4500, *(void *)(a3 + 16));
              *uint64_t v15 = v17;
              if (!v17 || (bzero(v17, 0x1194uLL), !*v15))
              {
                aj_log_error((uint64_t)"DecodeInit", "Could not allocate memory for huffman table");
                return 6;
              }
              uint64_t v18 = aj_huffman_decode_init();
              if (v18)
              {
                uint64_t v3 = v18;
                aj_log_error((uint64_t)"DecodeInit", "Make tables returned error code %d", v18);
                return v3;
              }
              uint64_t v19 = *a1;
              int v20 = (int *)v26;
              if ((int)v19 >= 1)
              {
                while (1)
                {
                  int v21 = *v20++;
                  if (v8 == v21) {
                    break;
                  }
                  if (!--v19) {
                    goto LABEL_15;
                  }
                }
                if (!*((_WORD *)*v15 + 2248))
                {
                  aj_log_error((uint64_t)"DecodeInit", "Huffman table (class %d, ind %d) is being used but contains no symbols", v6, v8);
                  return 4;
                }
              }
            }
          }
        }
LABEL_15:
        ++v8;
      }
      while (v8 != 4);
      char v7 = 0;
      uint64_t v6 = 1;
      if (v27) {
        continue;
      }
      break;
    }
  }
  return 0;
}

BOOL aj_huffman_is_standard_table(void *a1, const void *a2, int a3, int a4)
{
  int v4 = (char *)&std_huffman_luma;
  if (!a3) {
    int v4 = (char *)&std_huffman_chroma;
  }
  unsigned int v5 = &v4[4500 * (a4 == 0)];
  uint64_t v7 = *(void *)v5;
  uint64_t v6 = *((void *)v5 + 1);
  BOOL v8 = v7 == *a1 && v6 == a1[1];
  BOOL result = 0;
  if (v8)
  {
    size_t v9 = a4 ? 16 : 256;
    if (!memcmp(&v4[4500 * (a4 == 0) + 16], a2, v9)) {
      return 1;
    }
  }
  return result;
}

char *aj_huffman_decode_get_standard_table(int a1, int a2)
{
  char v2 = (char *)&std_huffman_luma;
  if (!a1) {
    char v2 = (char *)&std_huffman_chroma;
  }
  return &v2[4500 * (a2 == 0)];
}

uint64_t aj_imageinfo_init(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a2 + 72) = 0;
  unsigned int v3 = *a1;
  if ((int)*a1 < 1)
  {
    int v4 = 0;
    signed int v5 = 0;
  }
  else
  {
    int v4 = 0;
    signed int v5 = 0;
    uint64_t v6 = a1 + 8;
    uint64_t v7 = *a1;
    do
    {
      if (v5 <= (int)*(v6 - 4)) {
        signed int v5 = *(v6 - 4);
      }
      *(_DWORD *)(a2 + 72) = v5;
      int v9 = *v6++;
      int v8 = v9;
      if (v4 <= v9) {
        int v4 = v8;
      }
      *(_DWORD *)(a2 + 76) = v4;
      --v7;
    }
    while (v7);
  }
  if (!*((unsigned char *)a1 + 86))
  {
    v5 *= 8;
    v4 *= 8;
    *(_DWORD *)(a2 + 72) = v5;
    *(_DWORD *)(a2 + 76) = v4;
  }
  unsigned int v10 = a1[4] * a1[8];
  *(_DWORD *)(a2 + 88) = v10;
  *(_DWORD *)(a2 + 92) = v3 + v10 - 1;
  int v11 = (int)(v4 + a1[3] - 1) / v4;
  *(_DWORD *)(a2 + 80) = (int)(v5 + a1[2] - 1) / v5;
  *(_DWORD *)(a2 + 84) = v11;
  return aj_init_huffman(a1, a2, a3);
}

uint64_t aj_istream_skip_bytes(uint64_t a1, int a2)
{
  int v2 = a2;
  if (*(unsigned char *)(a1 + 112) && *(void *)(a1 + 104) && *(_DWORD *)(a1 + 32) < a2)
  {
    if (a2 < 1)
    {
      return 0;
    }
    else
    {
      while (1)
      {
        uint64_t result = aj_istream_move_forward(a1);
        if (result) {
          break;
        }
        int v5 = *(_DWORD *)(a1 + 32);
        if (!v5)
        {
          uint64_t result = 7;
          if (*(unsigned char *)(a1 + 112))
          {
            if (*(_DWORD *)(a1 + 56) == 1) {
              return 4294967294;
            }
            else {
              return 7;
            }
          }
          return result;
        }
        if (v5 >= v2) {
          int v6 = v2;
        }
        else {
          int v6 = *(_DWORD *)(a1 + 32);
        }
        *(void *)(a1 + 8) += v6;
        *(_DWORD *)(a1 + 32) = v5 - v6;
        BOOL v7 = __OFSUB__(v2, v6);
        v2 -= v6;
        if ((v2 < 0) ^ v7 | (v2 == 0)) {
          return 0;
        }
      }
    }
  }
  else
  {
    uint64_t v8 = (*(_DWORD *)(a1 + 48) + a2 - *(_DWORD *)(a1 + 32));
    return aj_istream_move_to_position(a1, v8);
  }
  return result;
}

double aj_istream_init_file(uint64_t a1, void *a2, uint64_t a3, int a4, char a5, int a6)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = a4;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 24) = -9;
  uint64_t v7 = a2[2];
  uint64_t v8 = a2[3];
  *(void *)(a1 + 80) = *a2;
  *(void *)(a1 + 88) = v8;
  *(void *)(a1 + 64) = a2[4];
  *(void *)(a1 + 72) = v7;
  *(_DWORD *)(a1 + 56) = a6;
  uint64_t v9 = a2[6];
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = v9;
  *(_DWORD *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 112) = a5;
  return result;
}

uint64_t aj_read_sos(uint64_t a1, int *a2)
{
  unsigned int v27 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 2);
  if (!result)
  {
    unsigned int v5 = v27;
    uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
    if (!result)
    {
      unint64_t v6 = v27;
      a2[834] = v27;
      int v7 = *a2;
      if ((int)v6 < 1 || (int)v6 > v7)
      {
        aj_log_error((uint64_t)"Read", "Component count is %d, only 1 to %d supported.");
        return 3;
      }
      if (v5 == 2 * v6 + 6)
      {
        if (v7 == v6)
        {
          if (!*((unsigned char *)a2 + 84)) {
            goto LABEL_19;
          }
        }
        else
        {
          *((unsigned char *)a2 + 84) = 1;
        }
        if (*((unsigned char *)a2 + 86))
        {
          aj_log_error((uint64_t)"Read", "Lossless multiscan images are not supported");
          return 3;
        }
LABEL_19:
        uint64_t v9 = 0;
        BOOL v10 = 1;
        while (1)
        {
          uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if (result) {
            return result;
          }
          uint64_t v11 = *a2;
          if ((int)v11 < 1) {
            break;
          }
          uint64_t v12 = 0;
          while (a2[v12 + 16] != v27)
          {
            if (v11 == ++v12) {
              goto LABEL_33;
            }
          }
          a2[v9 + 835] = v12;
          uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if (result) {
            goto LABEL_31;
          }
          unsigned int v13 = v27;
          uint64_t v14 = (unsigned int *)&a2[v12];
          v14[839] = v27 >> 4;
          v14[843] = v13 & 0xF;
          if (v13 > 0x3F || (v13 & 0xF) >= 4)
          {
            aj_log_error((uint64_t)"Read", "Corrupt scan, invalid huffman table indices. DC: %d, AC: %d");
            goto LABEL_34;
          }
          BOOL v10 = ++v9 < v6;
          if (v9 == v6)
          {
            uint64_t result = 0;
LABEL_31:
            if (v10) {
              return result;
            }
            goto LABEL_35;
          }
        }
LABEL_33:
        aj_log_error((uint64_t)"Read", "Component ID %d not found among declared components");
LABEL_34:
        if (v10) {
          return 4;
        }
LABEL_35:
        if ((int)v6 >= 2)
        {
          uint64_t v15 = 0;
          while (1)
          {
            uint64_t v16 = v15 + 1;
            if (v15 + 1 < v6) {
              break;
            }
LABEL_41:
            ++v15;
            if (v16 == v6 - 1) {
              goto LABEL_42;
            }
          }
          uint64_t v17 = v15;
          while (a2[v15 + 835] != a2[v17 + 836])
          {
            if (v6 - 1 == ++v17) {
              goto LABEL_41;
            }
          }
          aj_log_error((uint64_t)"Read", "SOS components IDs are not unique. id[%d] == id[%d] == %d");
          return 4;
        }
LABEL_42:
        uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
        if (!result)
        {
          a2[847] = v27;
          uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
          if (!result)
          {
            a2[848] = v27;
            uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v27, 1);
            if (!result)
            {
              char v18 = v27;
              int v19 = v27 >> 4;
              a2[850] = v19;
              unsigned int v20 = v18 & 0xF;
              a2[849] = v20;
              unsigned int v21 = a2[20];
              if (v21 == 194)
              {
                int v22 = a2[847];
                int v23 = a2[848];
                if (!v22 && v23 || v22 > v23 || v23 >= 64)
                {
                  aj_log_error((uint64_t)"Read", "Bad spectral selection. Ss = %d, Se = %d.");
                  return 4;
                }
                if (v20 > 0xD || v19 && v19 != v20 + 1)
                {
                  aj_log_error((uint64_t)"Read", "Bad successive approximation. Ah = %d, Al = %d.");
                  return 4;
                }
              }
              else
              {
                v24 = a2 + 847;
                if (*((unsigned char *)a2 + 84))
                {
                  unsigned int v25 = a2[848];
                  if (a2[847] || v25 != 63)
                  {
                    aj_log_error((uint64_t)"Read", "Bad spectral selection for baseline multiscan image. Ss = %d, Se = %d. Assuming Ss = 0, Se = 63.", a2[847], v25);
                    *(void *)v24 = 0x3F00000000;
                    unsigned int v20 = a2[849];
                    int v19 = a2[850];
                  }
                  if (v20 | v19) {
                    aj_log_error((uint64_t)"Read", "Bad successive approximation for baseline multiscan image. Al = %d, Ah = %d. Assuming Al = 0, Ah = 63.", v20, v19);
                  }
                }
                else if (v21 == 195 && *v24 >= 8)
                {
                  aj_log_error((uint64_t)"Read", "Bad lossless JPEG predictor %d.");
                  return 4;
                }
              }
              unsigned int pos = aj_istream_get_pos(a1);
              uint64_t result = 0;
              a2[855] = pos;
            }
          }
        }
        return result;
      }
      aj_log_error((uint64_t)"Read", "Illegal length of SOS segment.");
      return 4;
    }
  }
  return result;
}

uint64_t aj_parse_jpeg(void *a1, uint64_t a2, uint64_t a3, _DWORD *a4, int *a5, int a6, int a7, int a8, char a9)
{
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  uint64_t v16 = a4 + 8;
  long long v46 = 0u;
  while (!a4[3])
  {
    uint64_t v45 = 0;
    int v44 = 0;
    if (a7) {
      *(void *)(a2 + 104) = *(void *)(a2 + 8);
    }
    long long v17 = *(_OWORD *)(a2 + 80);
    long long v50 = *(_OWORD *)(a2 + 64);
    long long v51 = v17;
    long long v52 = *(_OWORD *)(a2 + 96);
    uint64_t v53 = *(void *)(a2 + 112);
    long long v18 = *(_OWORD *)(a2 + 16);
    long long v46 = *(_OWORD *)a2;
    long long v47 = v18;
    long long v19 = *(_OWORD *)(a2 + 48);
    long long v48 = *(_OWORD *)(a2 + 32);
    long long v49 = v19;
    uint64_t segment_id_and_length = aj_get_segment_id_and_length((uint64_t)&v46, (unsigned int *)&v45 + 1, &v45, &v44, v16, a6);
    if (segment_id_and_length == -2) {
      uint64_t segment_id_and_length = handle_suspension(a1, a7, a2, (uint64_t)&v46, a5, v44, v45, SHIDWORD(v45), *v16);
    }
    if (segment_id_and_length) {
      return segment_id_and_length;
    }
    int v21 = v44;
    if (!(*a4 | a6) && v44 != 216)
    {
      aj_log_error((uint64_t)"Parse", "File does not begin with SOI, first segment is 0x%02X");
      return 4;
    }
    switch(v44)
    {
      case 192:
      case 193:
      case 194:
      case 195:
        if (a9 && a4[4])
        {
          aj_log_error((uint64_t)"Parse", "Found multiple SOF segments. Ignoring any segment after the first.");
          goto LABEL_12;
        }
        uint64_t segment_id_and_length = aj_read_sof((uint64_t)&v46, (unsigned int *)a3, v44);
        if (segment_id_and_length) {
          goto LABEL_14;
        }
        a4[4] = 1;
        goto LABEL_46;
      case 196:
        uint64_t segment_id_and_length = aj_read_dht((uint64_t)&v46, a3);
        if (segment_id_and_length) {
          goto LABEL_14;
        }
        a4[6] = 1;
        goto LABEL_46;
      case 197:
      case 198:
      case 199:
      case 201:
      case 202:
      case 203:
      case 205:
      case 206:
      case 207:
        a4[7] = 1;
        goto LABEL_12;
      case 200:
      case 204:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
      case 217:
      case 220:
      case 222:
      case 223:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
        goto LABEL_12;
      case 216:
        HIDWORD(v45) = 0;
        a4[8] = aj_istream_get_pos((uint64_t)&v46);
        *a4 = 1;
        goto LABEL_46;
      case 218:
        if (!a4[4])
        {
          aj_log_error((uint64_t)"Parse", "No supported SOF segment found.");
          if (a4[7]) {
            return 3;
          }
          else {
            return 4;
          }
        }
        uint64_t segment_id_and_length = aj_read_sos((uint64_t)&v46, (int *)a3);
        if (!segment_id_and_length)
        {
          a4[3] = 1;
LABEL_46:
          uint64_t segment_id_and_length = 0;
          long long v35 = v52;
          *(_OWORD *)(a2 + 80) = v51;
          *(_OWORD *)(a2 + 96) = v35;
          long long v36 = v50;
          uint64_t v37 = v53;
          long long v38 = v47;
          *(_OWORD *)a2 = v46;
          *(_OWORD *)(a2 + 16) = v38;
          long long v39 = v49;
          *(_OWORD *)(a2 + 32) = v48;
          *(_OWORD *)(a2 + 48) = v39;
          *(_OWORD *)(a2 + 64) = v36;
          *(void *)(a2 + 104) = 0;
          *(void *)(a2 + 112) = v37;
LABEL_47:
          uint64_t v40 = add_segment_info(a1, a5, v21, v45, SHIDWORD(v45));
          if (v40) {
            return v40;
          }
          goto LABEL_48;
        }
LABEL_14:
        if (segment_id_and_length == -2)
        {
          uint64_t segment_id_and_length = handle_suspension(a1, a7, a2, (uint64_t)&v46, a5, v21, v45, SHIDWORD(v45), *v16);
          goto LABEL_48;
        }
        long long v23 = v52;
        *(_OWORD *)(a2 + 80) = v51;
        *(_OWORD *)(a2 + 96) = v23;
        long long v24 = v50;
        uint64_t v25 = v53;
        long long v26 = v47;
        *(_OWORD *)a2 = v46;
        *(_OWORD *)(a2 + 16) = v26;
        long long v27 = v49;
        *(_OWORD *)(a2 + 32) = v48;
        *(_OWORD *)(a2 + 48) = v27;
        *(_OWORD *)(a2 + 64) = v24;
        *(void *)(a2 + 104) = 0;
        *(void *)(a2 + 112) = v25;
        if (v21 != 255) {
          goto LABEL_47;
        }
        goto LABEL_48;
      case 219:
        uint64_t segment_id_and_length = aj_read_dqt((uint64_t)&v46, a3);
        if (segment_id_and_length) {
          goto LABEL_14;
        }
        a4[5] = 1;
        goto LABEL_46;
      case 221:
        uint64_t dri = aj_read_dri((uint64_t)&v46, a3);
        goto LABEL_13;
      case 224:
        uint64_t jfif = aj_read_jfif ((uint64_t)&v46);
        if (jfif != 11)
        {
          uint64_t segment_id_and_length = jfif;
          if (jfif) {
            goto LABEL_14;
          }
        }
        a4[1] = 1;
        goto LABEL_46;
      case 225:
        if (a4[2]) {
          goto LABEL_12;
        }
        uint64_t exif = aj_read_exif ((uint64_t)a1, (uint64_t)&v46, a3, (uint64_t)a4);
        if (exif != 11)
        {
          uint64_t segment_id_and_length = exif;
          if (exif) {
            goto LABEL_14;
          }
        }
        a4[2] = 1;
        goto LABEL_46;
      case 238:
        uint64_t segment_id_and_length = aj_read_app14((uint64_t)&v46, a3);
        if (segment_id_and_length == 11) {
          goto LABEL_46;
        }
        goto LABEL_14;
      default:
        if (v44 == 254)
        {
          uint64_t dri = aj_read_com((uint64_t)&v46);
          goto LABEL_13;
        }
        if (v44 != 255)
        {
LABEL_12:
          uint64_t dri = aj_read_unknown_segment((uint64_t)&v46);
LABEL_13:
          uint64_t segment_id_and_length = dri;
          goto LABEL_14;
        }
        uint64_t segment_id_and_length = 0;
        long long v28 = v52;
        *(_OWORD *)(a2 + 80) = v51;
        *(_OWORD *)(a2 + 96) = v28;
        long long v29 = v50;
        uint64_t v30 = v53;
        long long v31 = v47;
        *(_OWORD *)a2 = v46;
        *(_OWORD *)(a2 + 16) = v31;
        long long v32 = v49;
        *(_OWORD *)(a2 + 32) = v48;
        *(_OWORD *)(a2 + 48) = v32;
        *(_OWORD *)(a2 + 64) = v29;
        *(void *)(a2 + 104) = 0;
        *(void *)(a2 + 112) = v30;
LABEL_48:
        if (segment_id_and_length) {
          return segment_id_and_length;
        }
        break;
    }
  }
  if (!a4[6])
  {
    if (!a8)
    {
      aj_log_error((uint64_t)"Parse", "JPEG headers incomplete, no DHT segments found.", v42);
      return 4;
    }
    *(_WORD *)(a3 + 3324) = 257;
    *(_DWORD *)(a3 + 3320) = 16843009;
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1144), (void *)(a3 + 1272), 1, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1176), (void *)(a3 + 1784), 0, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1208), (void *)(a3 + 2296), 0, 1);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1160), (void *)(a3 + 1528), 1, 0);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1192), (void *)(a3 + 2040), 0, 0);
    aj_huffman_fill_standard_counts_values((_OWORD *)(a3 + 1224), (void *)(a3 + 2552), 0, 0);
    a4[6] = 1;
  }
  if (!a4[5] && !*(unsigned char *)(a3 + 86))
  {
    aj_log_error((uint64_t)"Parse", "JPEG headers incomplete.");
    return 4;
  }
  uint64_t segment_id_and_length = aj_check_components_and_decimation((int *)a3);
  if (!segment_id_and_length) {
    return aj_check_huffman_tables(a3);
  }
  return segment_id_and_length;
}

uint64_t aj_get_segment_id_and_length(uint64_t a1, unsigned int *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int a6)
{
  int v17 = 0;
  unsigned __int16 v16 = 0;
  *a3 = aj_istream_get_pos(a1);
  unsigned __int16 v15 = 0;
  uint64_t result = aj_istream_peek_short(a1, &v15);
  if (!result)
  {
    uint64_t result = aj_istream_read_bytes_be(a1, &v17, 1);
    if (!result)
    {
      if (v17 == 255 && v15 != 0xFFFF) {
        goto LABEL_6;
      }
      if (a6)
      {
        aj_log_error((uint64_t)"Parse", "Not a valid segment marker: 0x%02X%02X", v17, HIBYTE(v15));
        return 4;
      }
      if ((v15 & 0xFF00) == 0xD800)
      {
LABEL_6:
        uint64_t result = aj_istream_read_bytes_be(a1, &v17, 1);
        if (!result)
        {
          *a4 = v17;
          uint64_t result = aj_istream_peek_short(a1, &v16);
          if (!result)
          {
            *a2 = bswap32(v16) >> 16;
            int pos = aj_istream_get_pos(a1);
            uint64_t result = 0;
            *a5 = *a2 + pos;
          }
        }
      }
      else
      {
        int v14 = aj_istream_get_pos(a1);
        uint64_t result = 0;
        *a3 = v14;
        *a4 = 255;
      }
    }
  }
  return result;
}

uint64_t aj_istream_get_pos(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32));
}

uint64_t aj_istream_peek_short(uint64_t a1, _WORD *a2)
{
  if (*(int *)(a1 + 32) > 1) {
    goto LABEL_8;
  }
  uint64_t result = aj_istream_move_forward(a1);
  if (result) {
    return result;
  }
  if (*(int *)(a1 + 32) > 1)
  {
LABEL_8:
    uint64_t result = 0;
    *a2 = **(_WORD **)(a1 + 8);
  }
  else
  {
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t add_segment_info(void *a1, int *a2, int a3, int a4, int a5)
{
  if (!a2) {
    return 0;
  }
  int v9 = a2[1];
  if (v9 < *a2)
  {
    BOOL v10 = (char *)*((void *)a2 + 1);
LABEL_14:
    uint64_t result = 0;
    unsigned __int16 v16 = &v10[16 * v9];
    *((void *)v16 + 1) = a4;
    *(_DWORD *)unsigned __int16 v16 = a3;
    *((_DWORD *)v16 + 1) = a5;
    a2[1] = v9 + 1;
    return result;
  }
  if (2 * *a2 >= 2000) {
    int v12 = 2000;
  }
  else {
    int v12 = 2 * *a2;
  }
  if (v9 < 2000)
  {
    int v14 = (char *)(*(uint64_t (**)(uint64_t, void))*a1)(16 * v12, *(void *)(*a1 + 16));
    if (v14)
    {
      BOOL v10 = v14;
      bzero(v14, 16 * v12);
      memcpy(v10, *((const void **)a2 + 1), 16 * *a2);
      uint64_t v15 = *((void *)a2 + 1);
      if (v15) {
        (*(void (**)(uint64_t, void))(*a1 + 8))(v15, *(void *)(*a1 + 16));
      }
      *((void *)a2 + 1) = v10;
      a1[1] = v10;
      *a2 = v12;
      int v9 = a2[1];
      goto LABEL_14;
    }
    aj_log_error((uint64_t)"Parse", "Could not allocate memory for segment %d");
  }
  else
  {
    aj_log_error((uint64_t)"Parse", "Number of segments exceed the maximum allowable number (%d)");
  }
  return 6;
}

uint64_t aj_read_dqt(uint64_t a1, uint64_t a2)
{
  unsigned int v18 = 0;
  uint64_t bytes_be = aj_istream_read_bytes_be(a1, (int *)&v18, 2);
  if (!bytes_be)
  {
    if ((int)v18 < 3)
    {
      return 0;
    }
    else
    {
      unsigned int v5 = v18 - 2;
      uint64_t v6 = a2 + 88;
LABEL_4:
      uint64_t v7 = aj_istream_read_bytes_be(a1, (int *)&v18, 1);
      if (!v7)
      {
        uint64_t v8 = v18 & 0xF;
        if (v8 >= 4)
        {
          uint64_t bytes_be = 3;
          aj_log_error((uint64_t)"Read", "Index of quantization table is %d. Only indices 0..%d are allowed.", v18 & 0xF, 3);
          return bytes_be;
        }
        unsigned int v9 = v18 >> 4;
        if (v18 >= 0x10 && v9 != 1)
        {
          aj_log_error((uint64_t)"Read", "Bad precision value (%d), only 0 and 1 are defined.");
          return 4;
        }
        signed int v11 = v5 - 1;
        if (v18 <= 0xF) {
          int v12 = 1;
        }
        else {
          int v12 = 2;
        }
        int v13 = v12 << 6;
        if (v5 <= v12 << 6)
        {
          aj_log_error((uint64_t)"Read", "Not enough bytes left in header for quantization table. %d bytes remaining, requires >= %d.");
          return 4;
        }
        uint64_t v14 = 0;
        uint64_t v15 = v6 + (v8 << 8);
        while (1)
        {
          uint64_t v7 = aj_istream_read_bytes_be(a1, (int *)&v18, v12);
          if (v7) {
            break;
          }
          *(_DWORD *)(v15 + v14) = v18;
          v14 += 4;
          if (v14 == 256)
          {
            uint64_t bytes_be = 0;
            uint64_t v16 = a2 + 4 * v8;
            *(_DWORD *)(v16 + 1112) = 1;
            *(_DWORD *)(v16 + 1128) = v9;
            unsigned int v5 = v11 - v13;
            uint64_t v6 = a2 + 88;
            if (v11 > v13) {
              goto LABEL_4;
            }
            return bytes_be;
          }
        }
      }
      return v7;
    }
  }
  return bytes_be;
}

uint64_t aj_read_dht(uint64_t a1, uint64_t a2)
{
  v22[1] = *MEMORY[0x263EF8340];
  unsigned int v20 = 0;
  v22[0] = 0;
  memset(v21, 0, sizeof(v21));
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v20, 2);
  if (result) {
    return result;
  }
  if ((int)v20 < 3)
  {
LABEL_20:
    uint64_t v14 = 0;
    char v15 = 1;
    do
    {
      uint64_t v16 = 0;
      char v17 = v15;
      *(_DWORD *)(a2 + 4 * v14 + 3328) += *((_DWORD *)v22 + v14);
      unsigned int v18 = (char *)v21 + 4 * v14;
      uint64_t v19 = a2 + 3320 + v14;
      do
      {
        if (*(_DWORD *)&v18[4 * v16]) {
          *(unsigned char *)(v19 + v16) = 1;
        }
        v16 += 2;
      }
      while (v16 != 8);
      char v15 = 0;
      uint64_t v14 = 1;
    }
    while ((v17 & 1) != 0);
    return 0;
  }
  int v5 = v20 - 2;
LABEL_4:
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
  if (!result)
  {
    if (v5 <= 0x10)
    {
      aj_log_error((uint64_t)"Read", "Not enough bytes in header for Huffman table. %d bytes remaining, requires >= 17.");
    }
    else
    {
      unint64_t v6 = (unint64_t)v20 >> 4;
      if (v20 < 0x20)
      {
        uint64_t v7 = v20 & 0xF;
        if (v7 >= 4)
        {
          aj_log_error((uint64_t)"Read", "Huffman table index is %d, only values 0 to 3 are allowed.", v7);
          return 3;
        }
        else
        {
          if (!*(unsigned char *)(a2 + 2 * v7 + v6 + 3320) && !*((_DWORD *)v21 + 2 * v7 + v6)) {
            ++*((_DWORD *)v22 + v6);
          }
          uint64_t v8 = 0;
          LODWORD(v9) = 0;
          uint64_t v10 = a2 + 32 * v7 + 16 * v6 + 1144;
          signed int v11 = (unsigned char *)(a2 + (v7 << 9) + (v6 << 8) + 1272);
          *((_DWORD *)v21 + 2 * v7 + v6) = 1;
          while (1)
          {
            uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
            if (result) {
              break;
            }
            unsigned int v12 = v20;
            *(unsigned char *)(v10 + v8) = v20;
            uint64_t v9 = v12 + v9;
            if (++v8 == 16)
            {
              int v13 = v5 - 17;
              int v5 = v5 - 17 - v9;
              if (v13 < (int)v9)
              {
                aj_log_error((uint64_t)"Read", "Too few bytes in Huffman header. %d bytes left, requires %d bytes.");
                return 4;
              }
              if ((int)v9 > 256)
              {
                aj_log_error((uint64_t)"Read", "Too many codes in Huffman table: %d codes.");
                return 4;
              }
              if ((int)v9 >= 1)
              {
                do
                {
                  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v20, 1);
                  if (result) {
                    return result;
                  }
                  *v11++ = v20;
                }
                while (--v9);
              }
              if (v5 > 0) {
                goto LABEL_4;
              }
              goto LABEL_20;
            }
          }
        }
        return result;
      }
      aj_log_error((uint64_t)"Read", "Huffman table class is %d, only values 0 and 1 are allowed.");
    }
    return 4;
  }
  return result;
}

uint64_t aj_istream_read_bytes_be(uint64_t a1, int *a2, int a3)
{
  int v3 = a3;
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    uint64_t result = aj_istream_move_forward(a1);
    if (result) {
      return result;
    }
    int v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= v3)
  {
    int v8 = 0;
    if (v3)
    {
      uint64_t v9 = *(void *)(a1 + 8) + 1;
      int v10 = v6 - 1;
      do
      {
        *(_DWORD *)(a1 + 32) = v10;
        *(void *)(a1 + 8) = v9;
        int v8 = *(unsigned __int8 *)(v9++ - 1) | (v8 << 8);
        --v10;
        --v3;
      }
      while (v3);
    }
    uint64_t result = 0;
    *a2 = v8;
  }
  else
  {
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t aj_read_sof(uint64_t a1, unsigned int *a2, int a3)
{
  if ((a3 - 196) <= 0xFFFFFFFB)
  {
    aj_log_error((uint64_t)"Read", "Unsupported SOFn type");
    return 3;
  }
  unsigned int v13 = 0;
  a2[20] = a3;
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
  if (!result)
  {
    unsigned int v7 = v13;
    *((unsigned char *)a2 + 84) = a3 == 194;
    *((unsigned char *)a2 + 85) = (a3 & 0xFFFFFFFE) == 192;
    *((unsigned char *)a2 + 86) = a3 == 195;
    uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
    if (!result)
    {
      unsigned int v8 = v13;
      a2[1] = v13;
      if ((v8 | 4) != 0xC && (v8 - 2 > 0xE || !*((unsigned char *)a2 + 86)))
      {
        aj_log_error((uint64_t)"Read", "Precision is %d bits, only 8- and 12-bit input is supported.");
        return 3;
      }
      uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
      if (!result)
      {
        a2[3] = v13;
        uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 2);
        if (!result)
        {
          a2[2] = v13;
          uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
          if (!result)
          {
            unsigned int v9 = v13;
            *a2 = v13;
            if ((int)a2[2] < 1 || (int)a2[3] <= 0)
            {
              aj_log_error((uint64_t)"Read", "Width or height is <= 0 : %dx%d");
              return 3;
            }
            if (v9 - 3 >= 2 && v9 != 1)
            {
              if (v9 != 2)
              {
                aj_log_error((uint64_t)"Read", "Component count is %d, only 1, 3 or 4 supported.");
                return 3;
              }
              if (a2[20] != 195)
              {
                aj_log_error((uint64_t)"Read", "Component count 2 only supported for lossless JPEG.");
                return 3;
              }
            }
            if (v7 == 3 * v9 + 8)
            {
              uint64_t v10 = 0;
              signed int v11 = (int *)(a2 + 8);
              do
              {
                uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if (result) {
                  break;
                }
                v11[8] = v13;
                uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if (result) {
                  break;
                }
                char v12 = v13;
                *(v11 - 4) = v13 >> 4;
                *signed int v11 = v12 & 0xF;
                uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v13, 1);
                if (result) {
                  break;
                }
                v11[4] = v13;
                if (v10)
                {
                  if (*v11 != 1 || *(v11 - 4) != 1)
                  {
                    aj_log_error((uint64_t)"Read", "Unsupported subsampling. Y must be undecimated");
                    return 3;
                  }
                }
                else if ((*(v11 - 4) - 1) > 1 || (*v11 - 1) >= 2)
                {
                  aj_log_error((uint64_t)"Read", "Unsupported subsampling");
                  return 3;
                }
                uint64_t result = 0;
                ++v10;
                ++v11;
              }
              while (v10 < (int)*a2);
            }
            else
            {
              aj_log_error((uint64_t)"Read", "Illegal length of SOF-segment.");
              return 4;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_istream_move_forward(uint64_t a1)
{
  if (!*(void *)(a1 + 80)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v2)
  {
    int v4 = *(const void **)(a1 + 104);
  }
  else
  {
    int v4 = *(const void **)(a1 + 16);
    if (!v3) {
      int v4 = *(const void **)(a1 + 8);
    }
  }
  int v6 = *(void **)(a1 + 40);
  uint64_t v7 = *(int *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = v7 + (int)v8 - (int)v4;
  *(void *)(a1 + 8) = v8 - ((int)v4 - (int)v6);
  if (v3) {
    *(void *)(a1 + 16) = v3 - ((int)v4 - (int)v6);
  }
  if (v2) {
    *(void *)(a1 + 104) = v2 - ((int)v4 - (int)v6);
  }
  memmove(v6, v4, v7 + (int)v8 - (int)v4);
  if (*(_DWORD *)(a1 + 56) == 2)
  {
    int v10 = 0;
LABEL_29:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 32) += v10;
    return result;
  }
  int v10 = 0;
  uint64_t v11 = *(void *)(a1 + 40) + v9;
  int v12 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    int v13 = *(_DWORD *)(a1 + 52);
    if (v13)
    {
      int v14 = *(_DWORD *)(a1 + 48);
      if (v14 >= v13)
      {
        *(_DWORD *)(a1 + 56) = 2;
        if ((v14 & 0x80000000) == 0) {
          goto LABEL_29;
        }
        goto LABEL_26;
      }
    }
    if (*(_DWORD *)(a1 + 56) == 1) {
      *(_DWORD *)(a1 + 56) = 0;
    }
    int v15 = (*(uint64_t (**)(uint64_t, void, void))(a1 + 80))(v11 + v10, (v12 - (v9 + v10)), *(void *)(a1 + 64));
    if (v15 <= 0) {
      break;
    }
    int v16 = *(_DWORD *)(a1 + 48) + v15;
    *(_DWORD *)(a1 + 48) = v16;
    v10 += v15;
    if (v10 >= 8)
    {
      if ((v16 & 0x80000000) == 0) {
        goto LABEL_29;
      }
LABEL_26:
      aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
      return 9;
    }
  }
  if (!v15)
  {
    int v17 = 1;
    goto LABEL_28;
  }
  if (v15 == -1)
  {
    int v17 = 2;
LABEL_28:
    *(_DWORD *)(a1 + 56) = v17;
    goto LABEL_29;
  }
  aj_log_error((uint64_t)"Istream", "File read error");
  return 9;
}

uint64_t aj_check_huffman_tables(uint64_t a1)
{
  uint64_t v2 = 0;
LABEL_2:
  uint64_t v3 = 0;
  char v4 = 1;
  while (1)
  {
    char v5 = v4;
    if (*(unsigned char *)(a1 + 2 * v2 + v3 + 3320))
    {
      uint64_t result = aj_check_single_huffman_table((uint8x16_t *)(a1 + 32 * v2 + 16 * v3 + 1144), (char *)(a1 + (v2 << 9) + (v3 << 8) + 1272), v3, a1);
      if (result) {
        return result;
      }
    }
    char v4 = 0;
    uint64_t v3 = 1;
    if ((v5 & 1) == 0)
    {
      if (++v2 != 4) {
        goto LABEL_2;
      }
      return 0;
    }
  }
}

uint64_t aj_check_single_huffman_table(uint8x16_t *a1, char *a2, int a3, uint64_t a4)
{
  int v4 = *(_DWORD *)(a4 + 4);
  uint16x8_t v5 = vmovl_high_u8(*a1);
  uint16x8_t v6 = vmovl_u8(*(uint8x8_t *)a1->i8);
  uint64_t v7 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v6.i8, *(uint16x4_t *)v5.i8), (int32x4_t)vaddl_high_u16(v6, v5)));
  if (!a3)
  {
    if (v4 == 8) {
      int v10 = 11;
    }
    else {
      int v10 = 15;
    }
    if (*(unsigned char *)(a4 + 86)) {
      int v11 = v4 + 1;
    }
    else {
      int v11 = v10;
    }
    if (v7)
    {
      while (1)
      {
        int v12 = *a2++;
        if (v11 < v12) {
          break;
        }
        if (!--v7) {
          return 0;
        }
      }
      aj_log_error((uint64_t)"Parse", "Bogus huffman table. 0x%02X is not a legal symbol for %d-bit DC.");
      return 4;
    }
    return 0;
  }
  if (v4 == 8) {
    unsigned int v8 = 10;
  }
  else {
    unsigned int v8 = 14;
  }
  if (!v7) {
    return 0;
  }
  while (1)
  {
    char v9 = *a2++;
    if ((v9 & 0xFu) > v8) {
      break;
    }
    if (!--v7) {
      return 0;
    }
  }
  aj_log_error((uint64_t)"Parse", "Bogus huffman table. 0x%02X is not a legal symbol for %d-bit AC.");
  return 4;
}

uint64_t aj_check_components_and_decimation(int *a1)
{
  int v2 = *a1;
  if (*a1 < 1)
  {
    LOBYTE(v9) = 0;
  }
  else
  {
    int v3 = 0;
    int v4 = (unsigned int *)(a1 + 8);
    uint64_t v5 = *a1;
    uint16x8_t v6 = a1 + 8;
    do
    {
      int v7 = *v6++;
      BOOL v8 = v7 > 1 || (int)*(v4 - 4) > 1;
      v3 |= v8;
      int v4 = (unsigned int *)v6;
      --v5;
    }
    while (v5);
    BOOL v9 = v3 != 0;
    if (v3 && v2 > 3)
    {
      aj_log_error((uint64_t)"Parse", "Images with 4 components and decimation not supported");
      return 3;
    }
  }
  if ((v2 - 5) <= 0xFFFFFFFB && a1[1] >= 9)
  {
    aj_log_error((uint64_t)"Parse", "Only 1-4 component 12-bit jpegs are supported");
    return 3;
  }
  if (a1[852])
  {
    int v11 = a1[853];
    if (v11)
    {
      if (v11 >= 3)
      {
        aj_log_error((uint64_t)"Parse", "Unknown/unsupported APP14 transform");
        return 3;
      }
    }
    else
    {
      char v13 = !v9;
      if (v2 == 1) {
        char v13 = 1;
      }
      if ((v13 & 1) == 0)
      {
        aj_log_error((uint64_t)"Parse", "Unsupported decimation with APP14 transform");
        return 3;
      }
    }
  }
  if (*((unsigned char *)a1 + 86))
  {
    if (v2 >= 1)
    {
      for (uint64_t i = 0; i < v2; ++i)
      {
        int v15 = (unsigned int *)&a1[i];
        if (v15[12])
        {
          aj_log_error((uint64_t)"Parse", "Quantization table index %d for component %d is out of bounds for lossless JPEG, setting to 0", v15[12], i);
          v15[12] = 0;
          int v2 = *a1;
        }
      }
    }
  }
  else if (v2 >= 1)
  {
    for (uint64_t j = 0; j < v2; ++j)
    {
      uint64_t v17 = a1[j + 12];
      if (v17 >= 4)
      {
        aj_log_error((uint64_t)"Parse", "Quantization table index for component %d is out of bounds: %d");
        return 4;
      }
      if (!a1[v17 + 278])
      {
        aj_log_error((uint64_t)"Parse", "Trying to use quantization table that is uninitialized");
        return 4;
      }
      if (a1[20] == 192 && a1[v17 + 282])
      {
        aj_log_error((uint64_t)"Parse", "16-bit quantization tables not allowed for Baseline DCT JPEG (SOF0). Attempting to decode anyway.");
        int v2 = *a1;
      }
    }
  }
  uint64_t v18 = a1[834];
  if ((int)v18 < 1)
  {
LABEL_55:
    if (v2 != 1 || a1[4] <= 1 && a1[8] < 2) {
      return 0;
    }
    uint64_t result = 0;
    a1[8] = 1;
    a1[4] = 1;
    return result;
  }
  uint64_t v19 = a1 + 835;
  while (1)
  {
    uint64_t v21 = *v19++;
    uint64_t v20 = v21;
    if (*((unsigned char *)a1 + 85)
      || (int v22 = *((unsigned __int8 *)a1 + 84), *((unsigned char *)a1 + 84)) && !a1[847]
      || *((unsigned char *)a1 + 86))
    {
      uint64_t v23 = a1[v20 + 839];
      if (v23 >= 4)
      {
        aj_log_error((uint64_t)"Parse", "Huffman DC index for component %d is out of bounds: %d");
        return 4;
      }
      if (!*((unsigned char *)a1 + 2 * v23 + 3320))
      {
        aj_log_error((uint64_t)"Parse", "Trying to use DC huffman table #%d that is uninitialized");
        return 4;
      }
      if (*((unsigned char *)a1 + 85)) {
        goto LABEL_52;
      }
      int v22 = *((unsigned __int8 *)a1 + 84);
    }
    if (!v22 || a1[847] < 1) {
      goto LABEL_54;
    }
LABEL_52:
    uint64_t v24 = a1[v20 + 843];
    if (v24 >= 4)
    {
      aj_log_error((uint64_t)"Parse", "Huffman AC index for component %d is out of bounds: %d");
      return 4;
    }
    if (!*((unsigned char *)a1 + 2 * v24 + 3321)) {
      break;
    }
LABEL_54:
    if (!--v18) {
      goto LABEL_55;
    }
  }
  aj_log_error((uint64_t)"Parse", "Trying to use AC huffman table #%d that is uninitialized");
  return 4;
}

uint64_t dec_free_allocations(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(result + 16))
  {
    uint64_t v7 = result;
    aj_bufferprocessor_free_chain(result, a4, a2);
    aj_rowbuffer_destroy((int *)(a4 + 152), a2);
    uint64_t v8 = *(void *)(v7 + 6952);
    if (v8 && *(int *)(v7 + 6948) >= 2)
    {
      uint64_t v9 = 0;
      int v10 = (int *)(v8 + 168);
      do
      {
        aj_bufferprocessor_free_chain(v7, (uint64_t)(v10 - 38), a2);
        aj_rowbuffer_destroy(v10, a2);
        ++v9;
        v10 += 418;
      }
      while (v9 < *(int *)(v7 + 6948) - 1);
    }
    unint64_t v11 = a3 + 40;
    int v12 = (uint64_t *)(a3 + 16);
    do
    {
      uint64_t result = *v12;
      if (*v12)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void))(a2 + 8))(result, *(void *)(a2 + 16));
        *int v12 = 0;
      }
      ++v12;
    }
    while ((unint64_t)v12 < v11);
    *(unsigned char *)(v7 + 16) = 0;
  }
  return result;
}

uint64_t aj_read_dri(uint64_t a1, uint64_t a2)
{
  int v5 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, &v5, 2);
  if (!result)
  {
    if (v5 == 4)
    {
      uint64_t result = aj_istream_read_bytes_be(a1, &v5, 2);
      if (!result) {
        *(_DWORD *)(a2 + 3404) = v5;
      }
    }
    else
    {
      aj_log_error((uint64_t)"Read", "Illegal DRI segment length.");
      return 4;
    }
  }
  return result;
}

uint64_t aj_huffman_decode_init()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  uint64_t v2 = v1;
  char v4 = v3;
  int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = (_OWORD *)v0;
  uint64_t v80 = *MEMORY[0x263EF8340];
  bzero(v79, 0x400uLL);
  bzero(v78, 0x400uLL);
  bzero(v77, 0x800uLL);
  uint64_t v10 = 0;
  unsigned __int16 v11 = 0;
  *(unsigned char *)(v2 + 4498) = v4;
  *(_OWORD *)uint64_t v2 = *v9;
  *(_WORD *)(v2 + 4496) = 0;
  do
  {
    v11 += *(unsigned __int8 *)(v2 + v10);
    *(_WORD *)(v2 + 4496) = v11;
    ++v10;
  }
  while (v10 != 16);
  if ((unsigned __int16)(v11 - 256) < 0xFF01u)
  {
    aj_log_error((uint64_t)"Huff", "Illegal number of symbols in huffman table. nsyms = %d");
    return 7;
  }
  memcpy((void *)(v2 + 16), v8, v11);
  int v12 = 0;
  for (uint64_t i = 1; i != 17; ++i)
  {
    int v14 = *(unsigned __int8 *)(i + v2 - 1);
    if (*(unsigned char *)(i + v2 - 1))
    {
      int v15 = &v79[v12];
      v12 += v14;
      do
      {
        *v15++ = i;
        --v14;
      }
      while (v14);
    }
  }
  int v16 = v79[0];
  if (v79[0])
  {
    int v17 = 0;
    int v18 = 0;
    int v19 = 0;
    int v20 = v79[0];
    while (1)
    {
      if (v20 == v18)
      {
        uint64_t v21 = &v78[v17];
        int v22 = &v79[v17 + 1];
        do
        {
          *v21++ = v19++;
          int v24 = *v22++;
          int v23 = v24;
          ++v17;
        }
        while (v24 == v20);
        int v20 = v23;
      }
      if (v19 > 1 << v18)
      {
        aj_log_error((uint64_t)"Huff", "Illegal huffmann code: too large for length (0x%08x > 0x%08x)");
        return 7;
      }
      if (v19 == 1 << v18)
      {
        BOOL v25 = v17 >= 256 || v20 == 0;
        BOOL v26 = !v25;
        if (!v6 || v26) {
          break;
        }
      }
      v19 *= 2;
      ++v18;
      int v20 = v79[v17];
      if (!v20) {
        goto LABEL_27;
      }
    }
    aj_log_error((uint64_t)"Huff", "Illegal huffmann code: may not be all ones");
    return 7;
  }
LABEL_27:
  uint64_t v27 = 0;
  int v28 = 0;
  int v29 = 0;
  int v30 = 30;
  do
  {
    uint64_t v31 = v2 + 4 * v27;
    *(_DWORD *)(v31 + 336) = v29;
    int v32 = *(unsigned __int8 *)(v2 + v27);
    v29 += v32;
    v28 += v32 << v30;
    *(_DWORD *)(v31 + 272) = v28;
    ++v27;
    --v30;
  }
  while (v27 != 16);
  uint64_t v33 = 0;
  do
  {
    uint64_t v34 = v33 - 1;
    if (v33 == -15) {
      break;
    }
  }
  while (!*(unsigned __int8 *)(v2 + v33-- + 15));
  if (v34 != -1)
  {
    uint64_t v36 = v2 + v34;
    do
      *(_DWORD *)(v2 + 404 + 4 * v34++) += *(unsigned __int8 *)(v36 + 16);
    while (v34 != -1);
  }
  *(_DWORD *)(v2 + 332) = 0x80000000;
  memset_pattern16((void *)(v2 + 400), &unk_21040F510, 0x800uLL);
  for (uint64_t j = 0; j != 2048; j += 16)
  {
    long long v38 = (void *)(v2 + 2448 + j);
    *long long v38 = 0;
    v38[1] = 0;
  }
  uint64_t v39 = 0;
  uint64_t v40 = v2 + 400;
  int v41 = *(unsigned __int8 *)(v2 + 4498);
  do
  {
    int v42 = v79[v39];
    if (!v42) {
      break;
    }
    v43 = (unsigned __int8 *)(v2 + v39 + 16);
    unsigned int v44 = *v43;
    if (!v41 || v44 <= 0xF)
    {
      if (v42 > 9) {
        break;
      }
      int v45 = v44 & 0xF;
      int v46 = v42 + v45;
      int v47 = v78[v39] << (9 - v42);
      if (v42 + v45 > 9)
      {
        if (v42 != -22)
        {
          v54 = (int *)(v40 + 4 * v47);
          int v55 = (1 << (9 - v42)) + 1;
          do
          {
            *v54++ = (v42 << 8) | (*v43 << 18) | (*v43 >> 4) | 0x20000;
            --v55;
          }
          while (v55 > 1);
        }
      }
      else
      {
        unsigned int v48 = 0;
        do
        {
          if (v46 != -22)
          {
            if (v48 >> (v45 - 1)) {
              int v49 = 0;
            }
            else {
              int v49 = (0x7FFFFFFF << v45) | 1;
            }
            int v50 = (v49 + v48) << 18;
            if (!v45) {
              int v50 = 0;
            }
            int v51 = v50 | (v46 << 8);
            long long v52 = (int *)(v40 + 4 * (int)((v48 << (9 - v46)) + v47));
            int v53 = (1 << (9 - v46)) + 1;
            do
            {
              *v52++ = v51 | (*v43 >> 4);
              --v53;
            }
            while (v53 > 1);
          }
          ++v48;
        }
        while (!(v48 >> v45));
      }
    }
    ++v39;
  }
  while (v39 != 256);
  if (!v41)
  {
    LODWORD(v56) = 0;
    for (uint64_t k = 1; k != 10; ++k)
    {
      int v58 = *(unsigned __int8 *)(k + v2 - 1);
      if (*(unsigned char *)(k + v2 - 1))
      {
        int v59 = 0;
        uint64_t v56 = (int)v56;
        do
        {
          int v60 = k + (*(unsigned __int8 *)(v2 + v56 + 16) << 8);
          v61 = &v77[v78[v56] << (9 - k)];
          int v62 = (1 << (9 - k)) + 1;
          do
          {
            *v61++ = v60;
            --v62;
          }
          while (v62 > 1);
          ++v59;
          ++v56;
        }
        while (v59 != v58);
      }
    }
    unsigned int v63 = 0;
    do
    {
      if (v16 <= 9)
      {
        int v64 = 0;
        int v65 = 0;
        unsigned int v68 = v63 << 23;
        int v67 = 9;
        while (1)
        {
          int v69 = v77[v68 >> 23];
          if (v69 - 1 >= v67)
          {
            LOBYTE(v67) = 0;
LABEL_75:
            int v66 = 0;
            goto LABEL_77;
          }
          if (v69 <= 0xFF) {
            break;
          }
          int v70 = ((v69 >> 8) & 0xF) + v69;
          v64 += (v69 >> 12) + 1;
          int v67 = (v67 - v70) & ~((v67 - v70) >> 31);
          v68 <<= v70;
          v65 += v70;
          if (v67 < v16) {
            goto LABEL_75;
          }
        }
        int v67 = (v67 - v69) & ~((v67 - v69) >> 31);
        v65 += v69;
        int v66 = 0x10000;
      }
      else
      {
        int v64 = 0;
        int v65 = 0;
        int v66 = 0;
        LOBYTE(v67) = 9;
      }
LABEL_77:
      uint64_t v71 = 0;
      int v72 = v64 + (v65 << 8) + v66;
      uint64_t v73 = v63;
      uint64_t v74 = v2 + 2448 + 4 * v63;
      do
      {
        unint64_t v75 = v73 + v71;
        *(_DWORD *)(v74 + 4 * v71++) = v72;
      }
      while (v75 <= 0x1FE && !(v71 >> v67));
      unsigned int v63 = v73 + v71;
    }
    while ((v73 + v71) <= 0x1FF);
  }
  return 0;
}

uint64_t aj_read_exif (uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = 0;
  uint64_t result = aj_istream_read_bytes_be(a2, (int *)&v11 + 1, 2);
  if (!result)
  {
    int pos = aj_istream_get_pos(a2);
    unsigned int v9 = HIDWORD(v11);
    uint64_t v10 = (pos + HIDWORD(v11) - 2);
    *(_DWORD *)(a4 + 32) = v10;
    if (v9 <= 0xB)
    {
LABEL_3:
      *(void *)(a2 + 104) = 0;
      LODWORD(result) = aj_istream_move_to_position(a2, v10);
      if (result) {
        return result;
      }
      else {
        return 11;
      }
    }
    uint64_t result = aj_istream_read_bytes_be(a2, (int *)&v11 + 1, 4);
    if (!result)
    {
      uint64_t result = aj_istream_read_bytes_be(a2, (int *)&v11, 2);
      if (!result)
      {
        if (v11 == 0x4578696600000000)
        {
          uint64_t result = read_tiff(a2, a3, v10, a4);
          if (result == -2) {
            return result;
          }
          if (!result)
          {
            *(void *)(a2 + 104) = 0;
            return aj_istream_move_to_position(a2, v10);
          }
        }
        goto LABEL_3;
      }
    }
  }
  return result;
}

uint64_t read_tiff(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int pos = aj_istream_get_pos(a1);
  if (pos + 8 > a3)
  {
    aj_log_error((uint64_t)"Read", "Not enough data in Exif segment");
    return 4;
  }
  int v10 = pos;
  int v17 = 0;
  __int16 v16 = 0;
  int v15 = 0;
  uint64_t v9 = aj_istream_read_bytes_be(a1, &v17, 2);
  if (v9) {
    return v9;
  }
  int v12 = geth_little;
  char v13 = getw_little;
  if (v17 != 18761)
  {
    if (v17 != 19789)
    {
      aj_log_error((uint64_t)"Read", "Byte order not specified correctly in Exif->TIFF header");
      return 4;
    }
    int v12 = geth_big;
    char v13 = getw_big;
  }
  *(void *)(a4 + 40) = v13;
  *(void *)(a4 + 48) = v12;
  uint64_t v9 = v12(a1, &v16);
  if (v9) {
    return v9;
  }
  if (v16 != 42)
  {
    aj_log_error((uint64_t)"Read", "Byte order is wrong in Exif->TIFF header");
    return 4;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, int *))(a4 + 40))(a1, &v15);
  if (v9) {
    return v9;
  }
  if (v15 > (v10 ^ 0x7FFFFFFF))
  {
    aj_log_error((uint64_t)"Read", "Too large IFD offset: %d");
    return 4;
  }
  uint64_t v14 = read_IFD(a1, (v15 + v10), &v15, *(uint64_t (**)(uint64_t, int *))(a4 + 40), *(uint64_t (**)(uint64_t, __int16 *))(a4 + 48), (_DWORD *)(a2 + 3416), a3);
  uint64_t v9 = v14;
  if (v14 != -2 && v14) {
    aj_log_error((uint64_t)"Read", "Unknown error while reading IFD");
  }
  return v9;
}

uint64_t read_IFD(uint64_t a1, uint64_t a2, int *a3, uint64_t (*a4)(uint64_t, int *), uint64_t (*a5)(uint64_t, __int16 *), _DWORD *a6, int a7)
{
  if (a7 - 2 < (int)a2) {
    goto LABEL_2;
  }
  if ((a2 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Read", "Corrupt IFD position: %d", a2);
    return 11;
  }
  int pos = aj_istream_get_pos(a1);
  if (pos != a2)
  {
    if (*(void *)(a1 + 104))
    {
      if (pos >= (int)a2)
      {
        aj_log_error((uint64_t)"Read", "Exif segment with offsets that move backwards not supported with suspension");
        return 3;
      }
      int v16 = aj_istream_get_pos(a1);
      uint64_t result = aj_istream_skip_bytes(a1, (int)a2 - v16);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = aj_istream_move_to_position(a1, a2);
      if (result) {
        return result;
      }
    }
  }
  __int16 v22 = 0;
  __int16 v21 = 0;
  uint64_t result = a5(a1, &v22);
  if (!result)
  {
    int v17 = aj_istream_get_pos(a1);
    if (v17 + 12 * v22 + 4 > a7)
    {
LABEL_2:
      aj_log_error((uint64_t)"Read", "Exif segment ended abruply");
      return 4;
    }
    if (v22 >= 1)
    {
      for (int i = 0; i < v22; ++i)
      {
        uint64_t result = a5(a1, &v21);
        if (result) {
          return result;
        }
        if (v21 != 274)
        {
          uint64_t result = aj_istream_skip_bytes(a1, 10);
          goto LABEL_25;
        }
        int v24 = 0;
        unsigned __int16 v23 = 0;
        uint64_t result = a5(a1, (__int16 *)&v23);
        if (!result)
        {
          if (v23 - 13 <= 0xFFFFFFF3)
          {
            aj_log_error((uint64_t)"Read", "erroneous data format");
LABEL_24:
            uint64_t result = 4;
            goto LABEL_25;
          }
          if (v23 == 10 || v23 == 5)
          {
            aj_log_error((uint64_t)"Read", "Rationale data format not supported");
            goto LABEL_24;
          }
          if (v23 - 11 <= 1)
          {
            aj_log_error((uint64_t)"Read", "Floating point format not supported");
            goto LABEL_24;
          }
          uint64_t result = a4(a1, &v24);
          if (result) {
            goto LABEL_25;
          }
          if (v24 != 1)
          {
            aj_log_error((uint64_t)"Read", "Multiple data not supported");
            goto LABEL_24;
          }
          *a6 = 0;
          if ((0xC6uLL >> v23))
          {
            int v25 = 0;
            uint64_t result = aj_istream_read_bytes_be(a1, &v25, 1);
            if (result) {
              goto LABEL_25;
            }
            *(unsigned char *)a6 = v25;
            uint64_t v19 = a1;
            int v20 = 3;
LABEL_40:
            uint64_t result = aj_istream_skip_bytes(v19, v20);
            if (!result) {
              goto LABEL_45;
            }
            goto LABEL_25;
          }
          if (v23 == 8 || v23 == 3)
          {
            uint64_t result = a5(a1, (__int16 *)&v23);
            if (result) {
              goto LABEL_25;
            }
            *(_WORD *)a6 = v23;
            uint64_t v19 = a1;
            int v20 = 2;
            goto LABEL_40;
          }
          if (((0xA10uLL >> v23) & 1) == 0) {
            goto LABEL_45;
          }
          uint64_t result = a4(a1, &v24);
          if (!result)
          {
            *a6 = v24;
LABEL_45:
            uint64_t result = 0;
          }
        }
LABEL_25:
        if (result) {
          return result;
        }
      }
    }
    return a4(a1, a3);
  }
  return result;
}

uint64_t geth_big(uint64_t a1, _WORD *a2)
{
  int v4 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, &v4, 2);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t getw_big(uint64_t a1, _DWORD *a2)
{
  int v4 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, &v4, 4);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t aj_read_unknown_segment(uint64_t a1)
{
  int v5 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, &v5, 2);
  if (!result)
  {
    *(void *)(a1 + 104) = 0;
    int v3 = v5;
    if (v5 < 3) {
      return 0;
    }
    int pos = aj_istream_get_pos(a1);
    uint64_t result = aj_istream_move_to_position(a1, (v3 + pos - 2));
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t aj_read_app14(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
  if (!result)
  {
    int v5 = HIDWORD(v8);
    uint64_t v6 = v5 + aj_istream_get_pos(a1) - 2;
    if (v5 <= 13) {
      goto LABEL_3;
    }
    uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 4);
    if (!result)
    {
      uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8, 1);
      if (!result)
      {
        if (v8 != 0x41646F6200000065)
        {
LABEL_3:
          aj_log_error((uint64_t)"Read", "Unknown APP14 marker");
          LODWORD(result) = aj_istream_move_to_position(a1, v6);
          if (result) {
            return result;
          }
          else {
            return 11;
          }
        }
        uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
        if (!result)
        {
          uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
          if (!result)
          {
            uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 2);
            if (!result)
            {
              uint64_t result = aj_istream_read_bytes_be(a1, (int *)&v8 + 1, 1);
              if (!result)
              {
                int v7 = HIDWORD(v8);
                if (HIDWORD(v8) < 3)
                {
                  *(_DWORD *)(a2 + 3408) = 1;
                  *(_DWORD *)(a2 + 3412) = v7;
                  return aj_istream_move_to_position(a1, v6);
                }
                else
                {
                  aj_log_error((uint64_t)"Read", "Illegal APP14 transform");
                  return 11;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t applejpeg_decode_get_chroma_subsampling(_DWORD *a1)
{
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  if (!a1)
  {
    aj_log_error((uint64_t)"Decode", "Image session is NULL");
    return 0xFFFFFFFFLL;
  }
  if (a1[3232] != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 0xFFFFFFFFLL;
  }
  if (applejpeg_decode_get_image_info((uint64_t)a1, (uint64_t)&v8))
  {
    aj_log_error((uint64_t)"Decode", "get_image_info returned error: %d");
    return 0xFFFFFFFFLL;
  }
  if (!DWORD1(v9)) {
    return 4;
  }
  int v3 = a1[44];
  if (v3 == 2)
  {
    int v6 = a1[40];
    if (v6 == 2) {
      unsigned int v7 = 3;
    }
    else {
      unsigned int v7 = -1;
    }
    if (v6 == 1) {
      return 2;
    }
    else {
      return v7;
    }
  }
  else
  {
    if (v3 != 1) {
      return 0xFFFFFFFFLL;
    }
    int v4 = a1[40];
    if (v4 == 2) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = -1;
    }
    if (v4 == 1) {
      return 0;
    }
    else {
      return v5;
    }
  }
}

uint64_t applejpeg_decode_get_image_info(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      *(_DWORD *)a2 = *(_DWORD *)(a1 + 3572);
      *(void *)(a2 + 8) = *(void *)(a1 + 152);
      *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 144);
      *(_DWORD *)(a2 + 16) = aj_convert_SOF_type_to_jpeg_type(*(_DWORD *)(a1 + 224));
      int internal_format = aj_get_internal_format(*(_DWORD *)(a1 + 144), *(unsigned __int8 *)(a1 + 3552), *(_DWORD *)(a1 + 3556));
      uint64_t result = 0;
      int v6 = *(_DWORD *)(a1 + 3548);
      *(_DWORD *)(a2 + 20) = internal_format;
      *(_DWORD *)(a2 + 24) = v6;
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t aj_get_internal_format(int a1, int a2, int a3)
{
  if (a2)
  {
    int v3 = a1 - 1;
    uint64_t result = 0;
    switch(v3)
    {
      case 0:
        return result;
      case 1:
        uint64_t result = 6;
        break;
      case 2:
        if (a3) {
          uint64_t result = 1;
        }
        else {
          uint64_t result = 2;
        }
        break;
      case 3:
        if (a3) {
          uint64_t result = 5;
        }
        else {
          uint64_t result = 4;
        }
        break;
      default:
        return 1;
    }
  }
  else if ((a1 - 1) >= 4)
  {
    return 1;
  }
  else
  {
    return dword_210410580[a1 - 1];
  }
  return result;
}

uint64_t aj_convert_SOF_type_to_jpeg_type(int a1)
{
  if (a1 == 194) {
    return 1;
  }
  else {
    return 2 * (a1 == 195);
  }
}

uint64_t applejpeg_decode_get_precision(uint64_t a1)
{
  if (a1 && *(_DWORD *)(a1 + 12928) == 2) {
    return *(unsigned int *)(a1 + 148);
  }
  aj_log_error((uint64_t)"Decode", "Invalid session");
  return 0;
}

os_log_t __aj_get_os_log_object_block_invoke()
{
  os_log_t result = os_log_create("com.apple.applejpeg", "default");
  aj_get_os_log_object_s_logger = (uint64_t)result;
  return result;
}

uint64_t applejpeg_decode_get_ra_table_sz(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if ((*(_DWORD *)(a1 + 3880) & 0xFFFFFFFE) != 2 || !*(void *)(a1 + 3840) || !*(void *)(a1 + 3848)) {
    return 0;
  }
  int v3 = *(_DWORD *)(a1 + 3860);
  if (v3 < *a3) {
    v3 *= (v3 + *a3 - 1) / v3;
  }
  *a3 = v3;
  int v4 = *(_DWORD *)(a1 + 3856);
  if (v4 < *a2) {
    v4 *= (v4 + *a2 - 1) / v4;
  }
  *a2 = v4;
  int v5 = *(_DWORD *)(a1 + 3824);
  int v6 = *(_DWORD *)(a1 + 3828);
  int v7 = (v4 + v6 - 1) / v4;
  BOOL v8 = v5 < 4 || v6 < 4;
  int v9 = v7 * ((v5 + *a3 - 1) / *a3);
  if (v8) {
    int v10 = v9 + 1;
  }
  else {
    int v10 = v9 + 9;
  }
  return v10 * aj_istream_state_serialized_size() + 52;
}

void aj_log_error(uint64_t a1, char *__format, ...)
{
  va_start(va, __format);
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (aj_logging_enabled_g_aj_check_once != -1) {
    dispatch_once(&aj_logging_enabled_g_aj_check_once, &__block_literal_global_7);
  }
  if (aj_logging_enabled_s_should_log)
  {
    vsnprintf(__str, 0x400uLL, __format, va);
    int v4 = (FILE *)*MEMORY[0x263EF8348];
    if (a1) {
      fprintf(v4, "AppleJPEG, %s: %s\n");
    }
    else {
      fprintf(v4, "AppleJPEG: %s\n");
    }
  }
}

uint64_t aj_idct_s4_2x4_nearest(unsigned int *a1, void *a2, uint64_t a3)
{
  v3.i64[0] = 0x400040004000400;
  v3.i64[1] = 0x400040004000400;
  unsigned int v4 = a1[4];
  int v5 = (_DWORD *)(a2[1] + a3);
  int64x2_t v6 = (int64x2_t)vaddq_s16((int16x8_t)*a1, (int16x8_t)v4);
  int32x2_t v7 = (int32x2_t)vsubq_s16(vtrn1q_s16((int16x8_t)*a1, (int16x8_t)v4), vtrn2q_s16((int16x8_t)*a1, (int16x8_t)v4)).u64[0];
  int16x8_t v8 = vsubq_s16((int16x8_t)*a1, (int16x8_t)v4);
  LODWORD(v9) = 0;
  WORD2(v9) = 0;
  HIWORD(v9) = v7.i16[1];
  v8.i16[2] = v7.i16[0];
  *(int32x2_t *)v6.i8 = vzip1_s32(*(int32x2_t *)v6.i8, v7);
  int16x8_t v10 = (int16x8_t)vzip1q_s64(v6, (int64x2_t)vsubq_s16(v8, (int16x8_t)v9));
  *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vpaddq_s16(v10, v10), v3), 3uLL);
  *(int8x8_t *)v10.i8 = vzip1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8);
  *(_DWORD *)(*a2 + a3) = v10.i32[0];
  *int v5 = v10.i32[1];
  return 4;
}

uint64_t aj_block_pack(uint64_t *a1, uint64_t a2, int *a3)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  int64x2_t v6 = a1 + 5578;
  long long v77 = xmmword_264130230;
  v78 = &zero_block;
  uint64_t v7 = *a1;
  *(_OWORD *)(v7 + 50) = 0u;
  *(_OWORD *)(v7 + 35) = 0u;
  *(_OWORD *)(v7 + 19) = 0u;
  *(_OWORD *)(v7 + 3) = 0u;
  *(_DWORD *)a1[5614] = 0;
  int16x8_t v8 = (__int16 *)a1[1];
  if (v8) {
    *(void *)&long long v77 = a1[1];
  }
  else {
    int16x8_t v8 = &zero_block;
  }
  unint64_t v9 = (__int16 *)a1[2];
  if (v9) {
    *((void *)&v77 + 1) = a1[2];
  }
  else {
    unint64_t v9 = &zero_block;
  }
  int16x8_t v10 = (__int16 *)a1[3];
  if (v10) {
    v78 = (__int16 *)a1[3];
  }
  else {
    int16x8_t v10 = &zero_block;
  }
  uint64_t v11 = a1[5615];
  int v74 = 0;
  LODWORD(v75) = 0;
  uint64_t result = aj_huffman_decode_val(*(void *)(v11 + 32), a2, 0, (int *)&v75);
  if (result) {
    return result;
  }
  int v15 = *a3 + SWORD1(v75);
  *a3 = v15;
  LODWORD(v75) = v15;
  uint64_t result = aj_huffman_decode_ac_s1(v11, a2, v76, &v74, v13, v14);
  if (result) {
    return result;
  }
  __int16 v16 = v75;
  v76[0] = v75;
  *(_WORD *)uint64_t v7 = v75;
  if (v16 >= 0) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = -v16;
  }
  if (v17 < 0x800)
  {
    int v18 = 63;
    while (!v76[v18])
    {
      BOOL v26 = v18-- != 0;
      if (v18 == 0 || !v26)
      {
        int v18 = 0;
        break;
      }
    }
    *(unsigned char *)(v7 + 2) = v18;
    unsigned int v19 = *((unsigned __int8 *)v8 + 2);
    unsigned int v20 = *((unsigned __int8 *)v9 + 2);
    unsigned int v21 = *((unsigned __int8 *)v10 + 2);
    unsigned int v22 = v20 + v19 - v21;
    if ((int)v19 <= (int)v20) {
      unsigned int v23 = *((unsigned __int8 *)v9 + 2);
    }
    else {
      unsigned int v23 = *((unsigned __int8 *)v8 + 2);
    }
    if (v21 <= v19 && v21 <= v20) {
      unsigned int v22 = v23;
    }
    if ((int)v19 >= (int)v20) {
      unsigned int v25 = *((unsigned __int8 *)v9 + 2);
    }
    else {
      unsigned int v25 = *((unsigned __int8 *)v8 + 2);
    }
    BOOL v26 = v21 >= v19 && v21 >= v20;
    if (v26) {
      unsigned int v27 = v25;
    }
    else {
      unsigned int v27 = v22;
    }
    uint64_t v75 = a1[((int)(v27 + ((unsigned __int16)(v27 & 0xC000) >> 14)) >> 2) + 18];
    unsigned int v28 = (v21 & 0xFFFFFFF8) + 8;
    int v29 = 11 * (v18 / 8);
    BOOL v30 = v18 == 0;
    if (v18) {
      char v31 = v18 / 8 + 1;
    }
    else {
      char v31 = 0;
    }
    if (v30) {
      int v32 = 88;
    }
    else {
      int v32 = v29;
    }
    if (v30) {
      int v33 = 1;
    }
    else {
      int v33 = v28;
    }
    LOBYTE(v74) = v31;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, int *, uint64_t))(a1[5] + 40))(a1[4], &v75, &v74, 1);
    if (!result)
    {
      int v34 = *v8;
      int v35 = *v9;
      int v36 = *v10;
      if (v36 < v34 || v36 < v35)
      {
        if ((__int16)v36 > v34 || (__int16)v36 > v35)
        {
          LOWORD(v35) = v35 + v34 - v36;
        }
        else if (v34 > v35)
        {
          LOWORD(v35) = *v8;
        }
      }
      else if (v34 < v35)
      {
        LOWORD(v35) = *v8;
      }
      int v37 = v76[0];
      int v38 = (__int16)(v76[0] - v35);
      v76[0] -= v35;
      int v39 = *v10;
      int v40 = v34 - v39;
      if (v40 < 0) {
        int v40 = -v40;
      }
      int v41 = *v9 - v39;
      if (v41 < 0) {
        int v41 = -v41;
      }
      unsigned int v42 = v41 + v40;
      unsigned int v43 = 32 - __clz(v42 >> 1);
      unsigned int v44 = v42 >= 2 ? v43 : 0;
      uint64_t v75 = a1[v44 + 6];
      signed int v45 = *(_DWORD *)v6;
      signed int v46 = v38 >= 0 ? v38 : -v38;
      unsigned int v47 = __clz(v46);
      unsigned int v48 = 32 - v47;
      int v49 = (-1 << -(char)v47) | v46;
      unsigned int v50 = v38 < 0 ? ~v49 : v46;
      uint64_t v51 = v37 == (unsigned __int16)v35 ? 0 : v50;
      unsigned int v52 = v37 == (unsigned __int16)v35 ? 0 : v48;
      if (v46 >= v45)
      {
        signed int v46 = v45 + v52 + ~*((_DWORD *)v6 + 1);
      }
      else
      {
        uint64_t v51 = v38 >> 31;
        unsigned int v52 = v37 != (unsigned __int16)v35;
      }
      LOBYTE(v74) = v46;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, int *, uint64_t))(a1[5] + 40))(a1[4], &v75, &v74, 1);
      if (!result)
      {
        if (!v52
          || (uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1[5] + 56))(a1[4], v51, v52), !result))
        {
          if (v33 >= 2)
          {
            uint64_t v53 = 0;
            int v54 = 0;
            uint64_t v55 = (v33 - 1);
            uint64_t v56 = a1 + 34;
            int v57 = 32;
            do
            {
              int v58 = (__int16)v76[v53 + 1];
              if (v58 >= 0) {
                signed int v59 = (__int16)v76[v53 + 1];
              }
              else {
                signed int v59 = -v58;
              }
              if (v59 >= 0x400)
              {
                aj_log_error(0, "Illegal ac value: %d");
                return 7;
              }
              uint64_t v60 = v56[v32 + *(unsigned __int8 *)(*((void *)&v77 + nbr_ind[v53]) + v53 + 3)];
              signed int v61 = *((_DWORD *)v6 + 2);
              uint64_t v62 = v58 >> 31;
              unsigned int v63 = __clz(v59);
              unsigned int v64 = 32 - v63;
              int v65 = (-1 << -(char)v63) | v59;
              if (v58 < 0) {
                int v66 = ~v65;
              }
              else {
                int v66 = v59;
              }
              if (!v76[v53 + 1])
              {
                int v66 = 0;
                unsigned int v64 = 0;
              }
              BOOL v67 = v58 != 0;
              if (v59 < v61) {
                BOOL v68 = v67;
              }
              else {
                BOOL v68 = v64;
              }
              if (v59 < v61) {
                unsigned int v69 = v62;
              }
              else {
                unsigned int v69 = v66;
              }
              if (v59 >= v61) {
                LOBYTE(v59) = v61 + v64 + ~*((_DWORD *)v6 + 3);
              }
              *(unsigned char *)(v7 + 3 + v53) = v64;
              *(unsigned char *)(v6[34] + v53) = v59;
              *(void *)(v6[35] + 8 * v53) = v60;
              if (v68)
              {
                char v70 = v68;
                uint64_t v71 = v6[36];
                uint64_t v72 = v54;
                uint64_t v62 = *(unsigned int *)(v71 + 4 * v54);
                if (v57 >= v68)
                {
                  v57 -= v68;
                }
                else
                {
                  *(_DWORD *)(v71 + 4 * v54) = (v62 << v57) | (v69 >> (v68 - v57));
                  uint64_t v72 = v54 + 1;
                  *(_DWORD *)(v71 + 4 * v72) = 0;
                  char v70 = v68 - v57;
                  int v57 = 32 - (v68 - v57);
                  v69 &= 0xFFFFFFFF >> -v70;
                  ++v54;
                  uint64_t v62 = 0;
                }
                *(_DWORD *)(v71 + 4 * v72) = (v62 << v70) | v69;
              }
              ++v53;
              v56 += 88;
            }
            while (v55 != v53);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1[5] + 40))(a1[4], v6[35], v6[34], v55, v62);
            if (result) {
              return result;
            }
            if (v54 >= 1)
            {
              uint64_t v73 = 0;
              do
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[5] + 56))(a1[4], *(unsigned int *)(v6[36] + v73), 32);
                if (result) {
                  return result;
                }
                v73 += 4;
              }
              while (4 * v54 != v73);
            }
            if (v57 <= 31)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(a1[5] + 56))(a1[4], *(unsigned int *)(v6[36] + 4 * v54), (32 - v57));
              if (result) {
                return result;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  else
  {
    aj_log_error(0, "Illegal dc value: %d");
    return 7;
  }
  return result;
}

uint64_t aj_block_unpack(uint64_t *a1, int32x2_t *a2, _DWORD *a3)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  int v66 = &zero_block;
  uint64_t v6 = *a1;
  long long v65 = xmmword_264130230;
  memset(v64, 0, sizeof(v64));
  *(_OWORD *)(v6 + 50) = 0u;
  *(_OWORD *)(v6 + 35) = 0u;
  *(_OWORD *)(v6 + 19) = 0u;
  *(_OWORD *)(v6 + 3) = 0u;
  uint64_t v7 = (__int16 *)a1[1];
  if (v7) {
    *(void *)&long long v65 = a1[1];
  }
  else {
    uint64_t v7 = &zero_block;
  }
  int16x8_t v8 = (__int16 *)a1[2];
  if (v8) {
    *((void *)&v65 + 1) = a1[2];
  }
  else {
    int16x8_t v8 = &zero_block;
  }
  unint64_t v9 = (__int16 *)a1[3];
  if (v9) {
    int v66 = (__int16 *)a1[3];
  }
  else {
    unint64_t v9 = &zero_block;
  }
  unsigned int v10 = *((unsigned __int8 *)v7 + 2);
  unsigned int v11 = *((unsigned __int8 *)v8 + 2);
  unsigned int v12 = *((unsigned __int8 *)v9 + 2);
  if (v12 < v10 || v12 < v11)
  {
    if (v12 > v10 || v12 > v11)
    {
      unsigned int v10 = v11 + v10 - v12;
    }
    else if ((int)v10 <= (int)v11)
    {
      unsigned int v10 = *((unsigned __int8 *)v8 + 2);
    }
  }
  else if ((int)v10 >= (int)v11)
  {
    unsigned int v10 = *((unsigned __int8 *)v8 + 2);
  }
  LOBYTE(v62) = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t))(a1[5] + 48))(a1[4], &a1[((int)(v10 + ((unsigned __int16)(v10 & 0xC000) >> 14)) >> 2) + 18], &v62, 1);
  if (!result)
  {
    unint64_t v14 = v62;
    if ((_BYTE)v62)
    {
      unsigned __int8 v15 = 8 * v62;
      if ((8 * v62) >= 0x41u) {
        return 7;
      }
    }
    else
    {
      unsigned __int8 v15 = 1;
    }
    uint64_t v60 = a3;
    unsigned __int8 v61 = 0;
    int v16 = *v9;
    int v17 = *v7 - v16;
    if (v17 < 0) {
      int v17 = v16 - *v7;
    }
    int v18 = *v8 - v16;
    if (v18 < 0) {
      int v18 = -v18;
    }
    unsigned int v19 = v18 + v17;
    unsigned int v20 = v19 >> 1;
    unsigned int v21 = 32 - __clz(v19 >> 1);
    unsigned int v22 = v19 >= 2 ? v21 : 0;
    unsigned int v63 = v20;
    uint64_t v62 = a1[v22 + 6];
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, unsigned __int8 *, uint64_t))(a1[5] + 48))(a1[4], &v62, &v61, 1);
    if (!result)
    {
      unsigned int v23 = (int *)(a1 + 5578);
      LOWORD(v24) = v61;
      if (v61)
      {
        if (v61 < *v23)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t))(a1[5] + 64))(a1[4], &v63, 1);
          if (result) {
            return result;
          }
          if (v63) {
            int v24 = -v61;
          }
          else {
            LOWORD(v24) = v61;
          }
        }
        else
        {
          int v25 = *((_DWORD *)a1 + 11157) + v61 - *v23;
          uint64_t result = (*(uint64_t (**)(uint64_t, unsigned int *, void))(a1[5] + 64))(a1[4], &v63, (v25 + 1));
          if (result) {
            return result;
          }
          if (v63 >> v25) {
            __int16 v26 = 0;
          }
          else {
            __int16 v26 = (-2 << v25) | 1;
          }
          LOWORD(v24) = v26 + v63;
        }
      }
      int v27 = *v7;
      int v28 = *v8;
      int v29 = *v9;
      if (v29 < v27 || v29 < v28)
      {
        if ((__int16)v29 > v27 || (__int16)v29 > v28)
        {
          LOWORD(v27) = v28 + v27 - v29;
        }
        else if (v27 <= v28)
        {
          LOWORD(v27) = *v8;
        }
      }
      else if (v27 >= v28)
      {
        LOWORD(v27) = *v8;
      }
      LOWORD(v64[0]) = v24 + v27;
      *(_WORD *)uint64_t v6 = v24 + v27;
      BOOL v30 = (unsigned __int8 *)a1[5612];
      LODWORD(v62) = 0;
      uint64_t v31 = a1[5614];
      if (v15 >= 2u)
      {
        uint64_t v32 = 0;
        if (v14 <= 1) {
          unsigned int v33 = 1;
        }
        else {
          unsigned int v33 = v14;
        }
        uint64_t v34 = (uint64_t)&a1[11 * v33 + 23];
        do
        {
          *(void *)(a1[5613] + 8 * v32) = *(void *)(v34
                                                      + 8
                                                      * *(unsigned __int8 *)(*((void *)&v65
                                                                             + nbr_ind[v32])
                                                                           + v32
                                                                           + 3));
          ++v32;
          v34 += 704;
        }
        while (v15 - 1 != v32);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *, void))(a1[5] + 48))(a1[4], a1[5613], v30, v15 - 1);
      if (!result)
      {
        if (v15 <= 1u)
        {
          *(unsigned char *)(v6 + 2) = 0;
LABEL_94:
          aj_block_encode(a1[5615], (__int16 *)v64, a2, v60);
          return 0;
        }
        uint64_t v35 = 0;
        int v36 = 0;
        uint64_t v37 = 0;
        uint64_t v38 = v6 + 3;
        do
        {
          signed int v39 = v30[v35];
          if (v30[v35])
          {
            *((_WORD *)v64 + v35 + 1) = v39;
            signed int v40 = *((_DWORD *)a1 + 11158);
            int v36 = v35 + 1;
            if (v40 <= v39)
            {
              signed int v39 = v39 - v40 + *((_DWORD *)a1 + 11159) + 1;
              *(unsigned char *)(v38 + v35) = v39;
              uint64_t v37 = (v39 + v37);
            }
            else
            {
              LODWORD(v62) = v39;
              *(unsigned char *)(v38 + v35) = 32 - __clz(v39);
              uint64_t v37 = (v37 + 1);
              LOBYTE(v39) = 1;
            }
          }
          v30[v35++] = v39;
        }
        while (v15 - 1 != v35);
        *(unsigned char *)(v6 + 2) = v36;
        if (!v37)
        {
LABEL_79:
          if (v36 >= 1)
          {
            LODWORD(v45) = 0;
            uint64_t v46 = (v36 + 1) - 1;
            unsigned int v47 = (unsigned char *)(v6 + 3);
            unsigned int v48 = (__int16 *)v64 + 1;
            int v49 = 32;
            do
            {
              int v50 = *v48;
              if (*v48)
              {
                int v51 = *v30;
                uint64_t v52 = (int)v45;
                unsigned int v53 = *(_DWORD *)(v31 + 4 * (int)v45);
                unsigned int v54 = v53 >> -(char)v51;
                if (v49 >= v51)
                {
                  *(_DWORD *)(v31 + 4 * (int)v45) = v53 << v51;
                  v49 -= v51;
                }
                else
                {
                  uint64_t v45 = (int)v45 + 1;
                  unsigned int v55 = *(_DWORD *)(v31 + 4 * (v52 + 1));
                  int v56 = v51 - v49;
                  int v49 = 32 - v56;
                  v54 |= v55 >> -(char)v56;
                  *(_DWORD *)(v31 + 4 * v45) = v55 << v56;
                }
                if (*((_DWORD *)a1 + 11158) <= v50)
                {
                  char v57 = *v47 - 1;
                  unsigned int v58 = v54 >> v57;
                  int v50 = v54 + (-2 << v57);
                  if (v58) {
                    LOWORD(v50) = v54;
                  }
                  else {
                    LOWORD(v50) = v50 + 1;
                  }
                }
                else if (v54)
                {
                  int v50 = -v50;
                }
                *unsigned int v48 = v50;
              }
              ++v47;
              ++v30;
              ++v48;
              --v46;
            }
            while (v46);
          }
          goto LABEL_94;
        }
        int v59 = v36;
        if ((int)v37 >= 33)
        {
          uint64_t v41 = 0;
          int v42 = v37;
          while (1)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1[5] + 64))(a1[4], &v62, 32);
            if (result) {
              return result;
            }
            uint64_t v43 = v41 + 1;
            *(_DWORD *)(v31 + 4 * v41) = v62;
            uint64_t v37 = (v42 - 32);
            ++v41;
            BOOL v44 = v42 <= 64;
            v42 -= 32;
            if (v44) {
              goto LABEL_77;
            }
          }
        }
        uint64_t v43 = 0;
LABEL_77:
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t))(a1[5] + 64))(a1[4], &v62, v37);
        if (!result)
        {
          *(_DWORD *)(v31 + 4 * v43) = v62 << -(char)v37;
          int v36 = v59;
          goto LABEL_79;
        }
      }
    }
  }
  return result;
}

uint64_t AJReducerGetAPIVersionNumber()
{
  return 1;
}

BOOL AJReducerIsFilePacked(const __CFURL *a1)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to resolve url");
    return 0;
  }
  uint64_t v1 = fopen((const char *)buffer, "rb");
  if (!v1)
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to open file: %s");
    return 0;
  }
  uint64_t v2 = v1;
  BOOL v3 = fread(&__ptr, 1uLL, 4uLL, v1) == 4 && applejpeg_reduce_is_reduced_jpeg(&__ptr, 4uLL);
  fclose(v2);
  return v3;
}

BOOL AJReducerIsDataPacked(const __CFData *a1)
{
  BytePtr = (UInt8 *)CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  return applejpeg_reduce_is_reduced_jpeg(BytePtr, Length);
}

void *AJReducerCreate()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1060040C12426CFuLL);
}

void AJReducerRelease(void *a1)
{
  AJReducerCloseSource((uint64_t)a1);
  free(a1);
}

uint64_t AJReducerCloseSource(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t *)result;
    uint64_t v2 = *(void **)(result + 32);
    if (v2)
    {
      applejpeg_reduce_close(v2);
      v1[4] = 0;
    }
    BOOL v3 = (const void *)v1[3];
    if (v3)
    {
      CFRelease(v3);
      v1[3] = 0;
    }
    uint64_t result = *v1;
    if (*v1)
    {
      uint64_t result = fclose((FILE *)result);
      *uint64_t v1 = 0;
    }
  }
  return result;
}

uint64_t AJReducerOpenSourceData(uint64_t a1, CFTypeRef cf, int *a3)
{
  BytePtr = 0;
  CFIndex Length = 0;
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL", BytePtr, Length);
LABEL_10:
    int v6 = 4;
    goto LABEL_11;
  }
  if (!cf)
  {
    aj_log_error((uint64_t)"CFReduce", "Input source is NULL", BytePtr, Length);
    goto LABEL_10;
  }
  if (*(void *)(a1 + 32) || *(void *)(a1 + 24) || *(void *)a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Source is already open. Close must be called before source can be reopened.", BytePtr, Length);
    uint64_t result = 0;
    if (a3) {
      *a3 = 17;
    }
    return result;
  }
  *(void *)(a1 + 24) = cf;
  CFRetain(cf);
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
  v11[0] = mallocCallback;
  v11[1] = freeCallback;
  v11[2] = 0;
  unsigned int v10 = 0;
  uint64_t v7 = applejpeg_reduce_open_mem(v11, (uint64_t *)&BytePtr, a1 + 40, (int *)&v10);
  int v6 = translateErrorCode(v10);
  *(void *)(a1 + 32) = v7;
  if (v7)
  {
    if (a3) {
      *a3 = 0;
    }
    return 1;
  }
LABEL_11:
  if (a3) {
    *a3 = v6;
  }
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    CFRelease((CFTypeRef)result);
    uint64_t result = 0;
    *(void *)(a1 + 24) = 0;
  }
  return result;
}

FILE *AJReducerOpenSourceURLWithOptions(uint64_t a1, const __CFURL *a2, int *a3, const __CFDictionary *a4)
{
  uint64_t v12 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL", v9, v10, v11, v12);
LABEL_10:
    int v7 = 4;
    goto LABEL_11;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Input source is NULL", v9, v10, v11, v12);
    goto LABEL_10;
  }
  if (*(void *)(a1 + 32) || *(void *)(a1 + 24) || *(void *)a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Source is already open. Close must be called before source can be reopened.", v9, v10, v11, v12);
    uint64_t result = 0;
    if (a3) {
      *a3 = 17;
    }
    return result;
  }
  int v7 = setupFileManager(a2, 1, a4, (uint64_t (**)(void *, int, uint64_t))&v9, (FILE **)a1);
  if (!v7)
  {
    v14[0] = mallocCallback;
    v14[1] = freeCallback;
    v14[2] = 0;
    unsigned int v13 = 0;
    int16x8_t v8 = applejpeg_reduce_open_file(v14, (unint64_t)&v9, a1 + 40, (int *)&v13);
    int v7 = translateErrorCode(v13);
    *(void *)(a1 + 32) = v8;
    if (v8)
    {
      if (a3) {
        *a3 = 0;
      }
      return (FILE *)1;
    }
  }
LABEL_11:
  if (a3) {
    *a3 = v7;
  }
  uint64_t result = *(FILE **)a1;
  if (*(void *)a1)
  {
    fclose(result);
    uint64_t result = 0;
    *(void *)a1 = 0;
  }
  return result;
}

uint64_t setupFileManager(const __CFURL *a1, int a2, const __CFDictionary *a3, uint64_t (**a4)(void *a1, int a2, uint64_t a3), FILE **a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "URL may not be null");
    return 4;
  }
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to resolve url");
    return 7;
  }
  if (a2)
  {
    long long v9 = "rb";
  }
  else
  {
    int v15 = access((const char *)buffer, 0);
    long long v9 = "wb";
    if (a3 && v15 != -1)
    {
      CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a3, @"DoNotOverwriteOutputFile");
      if (Value && CFBooleanGetValue(Value))
      {
        aj_log_error((uint64_t)"CFReduce", "Output file already exists: %s", (const char *)buffer);
        return 16;
      }
      long long v9 = "wb";
    }
  }
  long long v10 = fopen((const char *)buffer, v9);
  if (!v10)
  {
    aj_log_error((uint64_t)"CFReduce", "Unable to open file: %s");
    return 7;
  }
  long long v11 = v10;
  a4[4] = (uint64_t (*)(void *, int, uint64_t))a5;
  fseek(v10, 0, 2);
  uint64_t v12 = MEMORY[0x21056E220](v11);
  fseek(v11, 0, 0);
  a4[2] = (uint64_t (*)(void *, int, uint64_t))fskipCallback;
  a4[3] = (uint64_t (*)(void *, int, uint64_t))frewindCallback;
  a4[5] = (uint64_t (*)(void *, int, uint64_t))0x2000;
  a4[6] = (uint64_t (*)(void *, int, uint64_t))v12;
  if (a2)
  {
    *a4 = freadCallback;
    unsigned int v13 = @"SimulateReadFailAfterXBytes";
  }
  else
  {
    a4[1] = (uint64_t (*)(void *, int, uint64_t))fwriteCallback;
    unsigned int v13 = @"SimulateWriteFailAfterXBytes";
  }
  CFDictionaryRef CFIndexFromDictionary = getCFIndexFromDictionary(a3, v13);
  uint64_t result = 0;
  a5[1] = 0;
  a5[2] = (FILE *)CFIndexFromDictionary;
  *a5 = v11;
  return result;
}

FILE *AJReducerOpenSourceURL(uint64_t a1, const __CFURL *a2, int *a3)
{
  return AJReducerOpenSourceURLWithOptions(a1, a2, a3, 0);
}

uint64_t AJReducerIsSourcePacked(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 40);
  }
  return result;
}

uint64_t AJReducerSourceUnpackedFileSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 48);
  }
  return result;
}

uint64_t AJReducerPackToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToData(a1, a2, a3, a4, 0);
}

uint64_t performTaskToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4, int a5)
{
  int v16 = 0;
  long long v10 = (const void **)AJMemoryWriterCreate();
  long long v11 = v10;
  if (!v10)
  {
    aj_log_error((uint64_t)"CFReduce", "Could not create memory writer");
    int v15 = 6;
LABEL_9:
    int v16 = v15;
    goto LABEL_10;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Destination pointer may not be null");
    int v15 = 4;
    goto LABEL_9;
  }
  unint64_t IOFile = AJMemoryWriterGetIOFile((uint64_t)v10);
  if (performReducerTask(a1, IOFile, a3, &v16, a5))
  {
    DataRef = (const void *)AJMemoryWriterGetDataRef((uint64_t)v11);
    *a2 = CFRetain(DataRef);
    AJMemoryWriterRelease(v11);
    if (a4) {
      *a4 = 0;
    }
    return 1;
  }
LABEL_10:
  if (a4) {
    *a4 = v16;
  }
  AJMemoryWriterRelease(v11);
  return 0;
}

uint64_t AJReducerUnpackToData(uint64_t a1, CFTypeRef *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToData(a1, a2, a3, a4, 1);
}

FILE *AJReducerPackToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToURL(a1, a2, a3, a4, 0);
}

FILE *performTaskToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4, int a5)
{
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  memset(v10, 0, sizeof(v10));
  int v13 = setupFileManager(a2, 0, a3, (uint64_t (**)(void *, int, uint64_t))v11, v10);
  if (v13 || !performReducerTask(a1, (unint64_t)v11, a3, &v13, a5))
  {
    if (a4) {
      *a4 = v13;
    }
    uint64_t result = v10[0];
    if (v10[0])
    {
      fclose(v10[0]);
      return 0;
    }
  }
  else
  {
    if (v10[0]) {
      fclose(v10[0]);
    }
    if (a4) {
      *a4 = 0;
    }
    return (FILE *)1;
  }
  return result;
}

FILE *AJReducerUnpackToURL(uint64_t a1, const __CFURL *a2, const __CFDictionary *a3, _DWORD *a4)
{
  return performTaskToURL(a1, a2, a3, a4, 1);
}

uint64_t AJReducerDestinationBytesWritten(uint64_t result)
{
  if (result) {
    return *(int *)(result + 72);
  }
  return result;
}

void *mallocCallback(size_t a1)
{
  return malloc_type_malloc(a1, 0x37F67C75uLL);
}

uint64_t translateErrorCode(unsigned int a1)
{
  if (a1 > 0xB) {
    return 1;
  }
  else {
    return dword_21040A964[a1];
  }
}

uint64_t fskipCallback(int a1, uint64_t a2)
{
  uint64_t v2 = *(FILE **)a2;
  *(void *)(a2 + 8) += a1;
  return fseek(v2, a1, 1);
}

uint64_t frewindCallback(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  return fseek(*(FILE **)a1, 0, 0);
}

uint64_t freadCallback(void *a1, int a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v4 = *(void *)(a3 + 16);
  if (v4)
  {
    uint64_t v5 = *(void *)(a3 + 8);
    if (v5 + a2 >= v4)
    {
      aj_log_error((uint64_t)"CFReduce", "Simulated read fail when reading %d bytes at position %zu", a2, v5);
      return 4294967294;
    }
  }
  size_t v6 = fread(a1, 1uLL, a2, *(FILE **)a3);
  if (!v6)
  {
    if (feof(*(FILE **)a3)) {
      return 0xFFFFFFFFLL;
    }
    if (ferror(*(FILE **)a3)) {
      return 4294967294;
    }
  }
  *(void *)(a3 + 8) += (int)v6;
  return v6;
}

uint64_t fwriteCallback(const void *a1, int a2, uint64_t a3)
{
  unint64_t v5 = *(void *)(a3 + 16);
  if (v5)
  {
    if (*(void *)(a3 + 8) + a2 >= v5)
    {
      aj_log_error((uint64_t)"CFReduce", "Simulated write fail when writing %d bytes at position %zu");
      return 1;
    }
    size_t v6 = a2;
  }
  else
  {
    size_t v6 = a2;
  }
  int v7 = fwrite(a1, 1uLL, v6, *(FILE **)a3);
  if (v7 == a2)
  {
    uint64_t result = 0;
    *(void *)(a3 + 8) += v7;
    return result;
  }
  aj_log_error((uint64_t)"CFReduce", "Requested write of %d, wrote: %d");
  return 1;
}

CFDictionaryRef getCFIndexFromDictionary(const __CFDictionary *result, const void *a2)
{
  if (result)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(result, a2);
    if (Value && (uint64_t valuePtr = 0, CFNumberGetValue(Value, kCFNumberCFIndexType, &valuePtr))) {
      return (const __CFDictionary *)valuePtr;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t performReducerTask(uint64_t a1, unint64_t a2, const __CFDictionary *a3, int *a4, int a5)
{
  if (!a1)
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer session is NULL");
LABEL_12:
    int v12 = 4;
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 32))
  {
    aj_log_error((uint64_t)"CFReduce", "Reducer input is NULL. Call AJReducerOpenSource first.");
    goto LABEL_12;
  }
  if (!a2)
  {
    aj_log_error((uint64_t)"CFReduce", "Destination is NULL");
    goto LABEL_12;
  }
  uint64_t v19 = 0;
  applejpeg_reduce_options_init((uint64_t)&v19);
  if (!a3) {
    goto LABEL_18;
  }
  CFNumberRef Value = (__CFString *)CFDictionaryGetValue(a3, @"CompressionMethod");
  if (Value != @"AdaptiveArithmetic")
  {
    if (Value == @"SemistaticArithmetic")
    {
      int v11 = 1;
      goto LABEL_17;
    }
    if (!Value) {
      goto LABEL_18;
    }
  }
  int v11 = 0;
LABEL_17:
  LODWORD(v19) = v11;
LABEL_18:
  unsigned int v15 = applejpeg_reduce_set_options(*(void *)(a1 + 32), (uint64_t)&v19);
  if (v15)
  {
    int v12 = translateErrorCode(v15);
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 32);
    int v17 = (_DWORD *)(a1 + 72);
    if (a5) {
      unsigned int v18 = applejpeg_reduce_unpack_file(v16, a2, v17);
    }
    else {
      unsigned int v18 = applejpeg_reduce_pack_file(v16, a2, v17);
    }
    int v12 = translateErrorCode(v18);
    if (!v12)
    {
      uint64_t v13 = 1;
      if (!a4) {
        return v13;
      }
      int v12 = 0;
      goto LABEL_14;
    }
  }
LABEL_13:
  uint64_t v13 = 0;
  if (a4) {
LABEL_14:
  }
    *a4 = v12;
  return v13;
}

int16x4_t *aj_block_dequantize_s1(int16x4_t *a1, int32x4_t *a2)
{
  int32x4_t v3 = *a2;
  int32x4_t v4 = a2[1];
  uint64_t v2 = a2 + 2;
  int32x4_t v5 = *v2;
  int32x4_t v6 = v2[1];
  v2 += 2;
  int32x4_t v7 = *v2;
  int32x4_t v8 = v2[1];
  v2 += 2;
  int32x4_t v9 = *v2;
  int32x4_t v10 = v2[1];
  v2 += 2;
  int16x8_t v11 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[2]), v5), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[2].i8), v6), 0xCuLL);
  int16x8_t v12 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[4]), v7), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[4].i8), v8), 0xCuLL);
  int16x8_t v13 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(a1[6]), v9), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1[6].i8), v10), 0xCuLL);
  *(int16x8_t *)a1->i8 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(*a1), v3), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)a1->i8), v4), 0xCuLL);
  *(int16x8_t *)a1[2].i8 = v11;
  unint64_t v14 = a1 + 4;
  *(int16x8_t *)v14->i8 = v12;
  *(int16x8_t *)v14[2].i8 = v13;
  v14 += 4;
  int32x4_t v15 = *v2;
  int32x4_t v16 = v2[1];
  v2 += 2;
  int32x4_t v17 = *v2;
  int32x4_t v18 = v2[1];
  v2 += 2;
  int16x8_t v19 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[2]), v17), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[2].i8), v18), 0xCuLL);
  int16x8_t v20 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[4]), *v2), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[4].i8), v2[1]), 0xCuLL);
  int16x8_t v21 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(v14[6]), v2[2]), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14[6].i8), v2[3]), 0xCuLL);
  *(int16x8_t *)v14->i8 = vqrshrn_high_n_s32(vqrshrn_n_s32(vmulq_s32(vmovl_s16(*v14), v15), 0xCuLL), vmulq_s32(vmovl_high_s16(*(int16x8_t *)v14->i8), v16), 0xCuLL);
  *(int16x8_t *)v14[2].i8 = v19;
  v14 += 4;
  *(int16x8_t *)v14->i8 = v20;
  *(int16x8_t *)v14[2].i8 = v21;
  return v14 + 4;
}

uint64_t aj_idct_s1_4x8(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  unsigned int v63 = a2 + 2;
  int16x8_t v66 = vaddq_s16(v60, v59);
  int16x8_t v67 = vaddq_s16(v55, v56);
  int16x8_t v68 = vsubq_s16(v55, v56);
  int16x8_t v69 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v70 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v71 = vaddq_s16(v61, v58);
  int16x8_t v72 = vsubq_s16(v58, v61);
  int16x8_t v73 = vaddq_s16(v57, v70);
  int16x8_t v74 = vsubq_s16(v57, v70);
  int16x8_t v75 = vaddq_s16(v66, v69);
  int16x8_t v76 = vqrdmulhq_lane_s16(vaddq_s16(v72, v74), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v77 = vqrdmulhq_lane_s16(vsubq_s16(v73, v71), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v78 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v74, (int16x4_t)0x30FC273D5A824546, 2), v74), v76);
  int16x8_t v79 = vaddq_s16(vqrdmulhq_lane_s16(v72, (int16x4_t)0x30FC273D5A824546, 0), v76);
  _X3 = (int8x8_t *)(v64 + a3);
  _X4 = (int8x8_t *)(v65 + a3);
  _X5 = (int8x8_t *)(*v63 + a3);
  _X6 = (int8x8_t *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16(vaddq_s16(vaddq_s16(v67, v75), vaddq_s16(vaddq_s16(v73, v71), v78)), 5uLL), (int8x8_t)0x8080808080808080);
  *_X4 = vadd_s8(vqrshrn_n_s16(vaddq_s16(vsubq_s16(v68, v69), vaddq_s16(v79, v77)), 5uLL), (int8x8_t)0x8080808080808080);
  *_X5 = vadd_s8(vqrshrn_n_s16(vsubq_s16(vsubq_s16(v67, v75), v79), 5uLL), (int8x8_t)0x8080808080808080);
  *_X6 = vadd_s8(vqrshrn_n_s16(vsubq_s16(vaddq_s16(v68, v69), vaddq_s16(v78, v77)), 5uLL), (int8x8_t)0x8080808080808080);
  return 8;
}

uint8x8_t **aj_icol_row_444_to_rgba(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, int16x8_t *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  int8x16_t v13 = vdupq_n_s8(0xFFu);
  int16x8_t v14 = *result;
  int16x8_t v15 = *a2;
  int16x8_t v16 = *a3;
  for (unsigned int i = a12 >> 3; i; --i)
  {
    uint8x8_t v18 = *v14++;
    uint8x8_t v19 = *v15++;
    uint8x8_t v20 = *v16++;
    int16x8_t v21 = (int16x8_t)vshll_n_u8(v18, 7uLL);
    int16x8_t v22 = (int16x8_t)vsubl_u8(v19, v12);
    int16x8_t v23 = (int16x8_t)vsubl_u8(v20, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_n_s16(v23, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v21, vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    int16x8_t v24 = (int16x8_t)vzip1q_s8((int8x16_t)a7, (int8x16_t)a8);
    int16x8_t v25 = (int16x8_t)vzip1q_s8((int8x16_t)a9, v13);
    *a4 = vzip1q_s16(v24, v25);
    a4[1] = vzip2q_s16(v24, v25);
    a4 += 2;
  }
  if ((a12 & 7) != 0)
  {
    int16x8_t v26 = (int16x8_t)vshll_n_u8(*v14, 7uLL);
    int16x8_t v27 = (int16x8_t)vsubl_u8(*v15, v12);
    int16x8_t v28 = (int16x8_t)vsubl_u8(*v16, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_n_s16(v28, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v26, vqaddq_s16(vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v28, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    int v29 = a12 & 7;
    do
    {
      a4->i8[0] = a7.i8[0];
      a4->i8[1] = a8.i8[0];
      a4->i8[2] = a9.i8[0];
      a4->i8[3] = v13.i8[0];
      a4 = (int16x8_t *)((char *)a4 + 4);
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v29;
    }
    while (v29);
  }
  return result;
}

void *AJMemoryWriterCreate()
{
  uint64_t v0 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A00409DD6F009uLL);
  v0[1] = 0;
  CFMutableDataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0);
  *uint64_t v0 = Mutable;
  if (Mutable)
  {
    v0[3] = AJCFDataWriteCallback;
    v0[4] = AJCFDataSkipCallback;
    v0[5] = AJCFDataRewindCallback;
    v0[6] = v0;
  }
  else
  {
    free(v0);
    return 0;
  }
  return v0;
}

uint64_t AJCFDataWriteCallback(const UInt8 *a1, int a2, uint64_t a3)
{
  if (a2)
  {
    LODWORD(v4) = a2;
    int16x8_t v6 = *(__CFData **)a3;
    uint64_t v7 = *(void *)(a3 + 8);
    if (v7 == CFDataGetLength(*(CFDataRef *)a3))
    {
      CFIndex v4 = (int)v4;
      CFDataAppendBytes(v6, a1, (int)v4);
    }
    else
    {
      v9.location = *(void *)(a3 + 8);
      CFIndex v4 = (int)v4;
      v9.length = v4;
      CFDataReplaceBytes(v6, v9, a1, (int)v4);
    }
    *(void *)(a3 + 8) += v4;
  }
  return 0;
}

uint64_t AJCFDataSkipCallback(int a1, uint64_t a2)
{
  *(void *)(a2 + 8) += a1;
  return 0;
}

uint64_t AJCFDataRewindCallback(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  return 0;
}

void AJMemoryWriterRelease(const void **a1)
{
  if (a1)
  {
    uint64_t v2 = *a1;
    if (v2) {
      CFRelease(v2);
    }
    free(a1);
  }
}

uint64_t AJMemoryWriterGetDataRef(uint64_t a1)
{
  return *(void *)a1;
}

CFIndex AJMemoryWriterGetLength(CFDataRef *a1)
{
  return CFDataGetLength(*a1);
}

uint64_t AJMemoryWriterGetIOFile(uint64_t a1)
{
  return a1 + 16;
}

uint8x16_t **aj_icol_row_420_to_rgb(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint8x8_t v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    uint8x8_t v12 = *result;
    int8x16_t v13 = *a2;
    int16x8_t v14 = *a3;
    if (a6 == 1)
    {
      for (unsigned int i = a7 >> 4; i; --i)
      {
        uint8x16_t v57 = *v12++;
        uint8x8_t v58 = *v13++;
        uint8x8_t v59 = *v14++;
        int16x8_t v60 = (int16x8_t)vsubl_u8(v58, v11);
        int16x8_t v61 = (int16x8_t)vsubl_u8(v59, v11);
        int16x8_t v62 = vmulq_lane_s16(v60, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v63 = vmulq_n_s16(v61, 179);
        int16x8_t v64 = vqaddq_s16(vmulq_lane_s16(v60, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v65 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v57.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v65, vzip1q_s16(v62, v62)), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v65, vzip1q_s16(v63, v63)), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v65, vzip1q_s16(v64, v64)), 7uLL);
        vst3_s8(a4, v85);
        int16x8_t v66 = a4 + 24;
        int16x8_t v67 = (int16x8_t)vshll_high_n_u8(v57, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v67, vzip2q_s16(v62, v62)), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v67, vzip2q_s16(v63, v63)), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v67, vzip2q_s16(v64, v64)), 7uLL);
        vst3_s8(v66, v85);
        a4 = v66 + 24;
      }
      unsigned int v68 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v69 = *(uint64x2_t *)v12;
        int16x8_t v70 = (int16x8_t)vsubl_u8(*v13, v11);
        int16x8_t v71 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v72 = vmulq_lane_s16(v70, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v73 = vmulq_n_s16(v71, 179);
        int16x8_t v74 = vqaddq_s16(vmulq_lane_s16(v70, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v75 = vzip2q_s16(v72, v72);
        int16x8_t v76 = vzip2q_s16(v73, v73);
        int16x8_t v77 = vzip2q_s16(v74, v74);
        int16x8_t v78 = vzip1q_s16(v72, v72);
        int16x8_t v79 = vzip1q_s16(v73, v73);
        int16x8_t v80 = vzip1q_s16(v74, v74);
        if (!(v68 >> 3)) {
          goto LABEL_16;
        }
        int16x8_t v81 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v69.i8, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v81, v78), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v81, v79), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v81, v80), 7uLL);
        vst3_s8(a4, v86);
        a4 += 24;
        int16x8_t v78 = v75;
        int16x8_t v79 = v76;
        int16x8_t v80 = v77;
        v69.i64[0] = v69.i64[1];
        v68 -= 8;
        if (v68)
        {
LABEL_16:
          int16x8_t v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v69.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v82, v78), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v82, v80), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4 += 3;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            --v68;
          }
          while (v68);
        }
      }
    }
    else
    {
      unsigned int v15 = a7 >> 4;
      for (uint64_t j = result[1]; v15; --v15)
      {
        uint8x16_t v17 = *v12++;
        uint8x16_t v18 = *j++;
        uint8x8_t v19 = *v13++;
        uint8x8_t v20 = *v14++;
        int16x8_t v21 = (int16x8_t)vsubl_u8(v19, v11);
        int16x8_t v22 = (int16x8_t)vsubl_u8(v20, v11);
        int16x8_t v23 = vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v24 = vmulq_n_s16(v22, 179);
        int16x8_t v25 = vqaddq_s16(vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v26 = vzip2q_s16(v23, v23);
        int16x8_t v27 = vzip2q_s16(v24, v24);
        int16x8_t v28 = vzip2q_s16(v25, v25);
        int16x8_t v29 = vzip1q_s16(v23, v23);
        int16x8_t v30 = vzip1q_s16(v24, v24);
        int16x8_t v31 = vzip1q_s16(v25, v25);
        int16x8_t v32 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v17.i8, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v32, v29), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v32, v30), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v32, v31), 7uLL);
        vst3_s8(a4, v83);
        int16x8_t v33 = a4 + 24;
        int16x8_t v34 = (int16x8_t)vshll_high_n_u8(v17, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v34, v26), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v34, v28), 7uLL);
        vst3_s8(v33, v83);
        a4 = v33 + 24;
        int16x8_t v35 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v29), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v30), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v31), 7uLL);
        vst3_s8(a5, v83);
        int16x8_t v36 = a5 + 24;
        int16x8_t v37 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v83.val[2] = vqrshrun_n_s16(vqaddq_s16(v37, v26), 7uLL);
        v83.val[0] = vqrshrun_n_s16(vqaddq_s16(v37, v27), 7uLL);
        v83.val[1] = vqrshrun_n_s16(vqsubq_s16(v37, v28), 7uLL);
        vst3_s8(v36, v83);
        a5 = v36 + 24;
      }
      unsigned int v38 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v39 = *(uint64x2_t *)v12;
        uint64x2_t v40 = *(uint64x2_t *)j;
        int16x8_t v41 = (int16x8_t)vsubl_u8(*v13, v11);
        int16x8_t v42 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v43 = vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v44 = vmulq_n_s16(v42, 179);
        int16x8_t v45 = vqaddq_s16(vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v46 = vzip2q_s16(v43, v43);
        int16x8_t v47 = vzip2q_s16(v44, v44);
        int16x8_t v48 = vzip2q_s16(v45, v45);
        int16x8_t v49 = vzip1q_s16(v43, v43);
        int16x8_t v50 = vzip1q_s16(v44, v44);
        int16x8_t v51 = vzip1q_s16(v45, v45);
        if (!(v38 >> 3)) {
          goto LABEL_8;
        }
        int16x8_t v52 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v52, v49), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v52, v50), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v52, v51), 7uLL);
        vst3_s8(a4, v84);
        a4 += 24;
        int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v51), 7uLL);
        vst3_s8(a5, v84);
        a5 += 24;
        int16x8_t v49 = v46;
        int16x8_t v50 = v47;
        int16x8_t v51 = v48;
        v39.i64[0] = v39.i64[1];
        v40.i64[0] = v40.i64[1];
        v38 -= 8;
        if (v38)
        {
LABEL_8:
          int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v54, v51), 7uLL);
          int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v49), 7uLL);
          *(int8x8_t *)v39.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v51), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4 += 3;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v39.i8[0];
            a5[1] = v40.i8[0];
            a5[2] = v10.i8[0];
            a5 += 3;
            uint64x2_t v39 = vshrq_n_u64(v39, 8uLL);
            uint64x2_t v40 = vshrq_n_u64(v40, 8uLL);
            uint64x2_t v10 = vshrq_n_u64(v10, 8uLL);
            --v38;
          }
          while (v38);
        }
      }
    }
  }
  return result;
}

uint64_t (*aj_block_dct(uint8x8_t **a1, int8x16_t *a2, int16x8_t *a3))()
{
  int16x8_t v3 = a1[1];
  CFIndex v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  uint64x2_t v7 = a1[5];
  uint64x2_t v8 = a1[6];
  uint64x2_t v9 = a1[7];
  v10.i64[0] = 0x80008000800080;
  v10.i64[1] = 0x80008000800080;
  uint16x8_t v11 = (uint16x8_t)vnegq_s16(v10);
  int16x8_t v12 = (int16x8_t)vaddw_u8(v11, **a1);
  int16x8_t v13 = (int16x8_t)vaddw_u8(v11, *v3);
  int16x8_t v14 = (int16x8_t)vaddw_u8(v11, *v4);
  int16x8_t v15 = (int16x8_t)vaddw_u8(v11, *v5);
  int16x8_t v16 = (int16x8_t)vaddw_u8(v11, *v6);
  int16x8_t v17 = (int16x8_t)vaddw_u8(v11, *v7);
  int16x8_t v18 = (int16x8_t)vaddw_u8(v11, *v8);
  int16x8_t v19 = (int16x8_t)vaddw_u8(v11, *v9);
  ++*a1;
  a1[1] = v3 + 1;
  a1[2] = v4 + 1;
  a1[3] = v5 + 1;
  a1[4] = v6 + 1;
  a1[5] = v7 + 1;
  a1[6] = v8 + 1;
  a1[7] = v9 + 1;
  int16x8_t v20 = vaddq_s16(v12, v19);
  int16x8_t v21 = vsubq_s16(v12, v19);
  int16x8_t v22 = vaddq_s16(v13, v18);
  int16x8_t v23 = vsubq_s16(v13, v18);
  int16x8_t v24 = vaddq_s16(v14, v17);
  int16x8_t v25 = vsubq_s16(v14, v17);
  int16x8_t v26 = vaddq_s16(v15, v16);
  int16x8_t v27 = vsubq_s16(v22, v24);
  int16x8_t v28 = vaddq_s16(v22, v24);
  int16x8_t v29 = vaddq_s16(vsubq_s16(v15, v16), v25);
  int16x8_t v30 = vaddq_s16(v23, v21);
  int16x8_t v31 = vaddq_s16(v20, v26);
  int16x8_t v32 = vsubq_s16(v20, v26);
  int16x8_t v33 = vqrdmulhq_lane_s16(vsubq_s16(v30, v29), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v34 = vqrdmulhq_lane_s16(vaddq_s16(v25, v23), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v35 = vqrdmulhq_lane_s16(vaddq_s16(v27, v32), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v36 = vsubq_s16(vqrdmulhq_lane_s16(v29, (int16x4_t)0x30FC273D5A824546, 0), v33);
  int16x8_t v37 = vsubq_s16(v31, v28);
  int16x8_t v38 = vaddq_s16(v31, v28);
  int16x8_t v39 = vaddq_s16(vqrdmulhq_lane_s16(v30, (int16x4_t)0x30FC273D5A824546, 2), vsubq_s16(v30, v33));
  int16x8_t v40 = vaddq_s16(v34, v21);
  int16x8_t v41 = vsubq_s16(v21, v34);
  int16x8_t v42 = vaddq_s16(v40, v39);
  int16x8_t v43 = vsubq_s16(v40, v39);
  int16x8_t v44 = vaddq_s16(v36, v41);
  int16x8_t v45 = vsubq_s16(v41, v36);
  int16x8_t v46 = vsubq_s16(v32, v35);
  int16x8_t v47 = vaddq_s16(v35, v32);
  int32x4_t v48 = (int32x4_t)vtrn1q_s16(v38, v42);
  int32x4_t v49 = (int32x4_t)vtrn2q_s16(v38, v42);
  int32x4_t v50 = (int32x4_t)vtrn1q_s16(v47, v45);
  int32x4_t v51 = (int32x4_t)vtrn2q_s16(v47, v45);
  int32x4_t v52 = (int32x4_t)vtrn1q_s16(v37, v44);
  int32x4_t v53 = (int32x4_t)vtrn2q_s16(v37, v44);
  int32x4_t v54 = (int32x4_t)vtrn1q_s16(v46, v43);
  int32x4_t v55 = (int32x4_t)vtrn2q_s16(v46, v43);
  int64x2_t v56 = (int64x2_t)vtrn1q_s32(v48, v50);
  int64x2_t v57 = (int64x2_t)vtrn2q_s32(v48, v50);
  int64x2_t v58 = (int64x2_t)vtrn1q_s32(v49, v51);
  int64x2_t v59 = (int64x2_t)vtrn2q_s32(v49, v51);
  int64x2_t v60 = (int64x2_t)vtrn1q_s32(v52, v54);
  int64x2_t v61 = (int64x2_t)vtrn2q_s32(v52, v54);
  int64x2_t v62 = (int64x2_t)vtrn1q_s32(v53, v55);
  int64x2_t v63 = (int64x2_t)vtrn2q_s32(v53, v55);
  int16x8_t v64 = (int16x8_t)vtrn1q_s64(v56, v60);
  int16x8_t v65 = (int16x8_t)vtrn2q_s64(v56, v60);
  int16x8_t v66 = (int16x8_t)vtrn1q_s64(v58, v62);
  int16x8_t v67 = (int16x8_t)vtrn2q_s64(v58, v62);
  int16x8_t v68 = (int16x8_t)vtrn1q_s64(v57, v61);
  int16x8_t v69 = (int16x8_t)vtrn2q_s64(v57, v61);
  int16x8_t v70 = (int16x8_t)vtrn1q_s64(v59, v63);
  int16x8_t v71 = (int16x8_t)vtrn2q_s64(v59, v63);
  int16x8_t v72 = vaddq_s16(v64, v71);
  int16x8_t v73 = vsubq_s16(v64, v71);
  int16x8_t v74 = vaddq_s16(v66, v69);
  int16x8_t v75 = vsubq_s16(v66, v69);
  int16x8_t v76 = vaddq_s16(v68, v67);
  int16x8_t v77 = vsubq_s16(v68, v67);
  int16x8_t v78 = vaddq_s16(v70, v65);
  int16x8_t v79 = vsubq_s16(v74, v76);
  int16x8_t v80 = vaddq_s16(v74, v76);
  int16x8_t v81 = vaddq_s16(vsubq_s16(v70, v65), v77);
  int16x8_t v82 = vaddq_s16(v75, v73);
  int16x8_t v83 = vaddq_s16(v72, v78);
  int16x8_t v84 = vsubq_s16(v72, v78);
  int16x8_t v85 = vqrdmulhq_lane_s16(vsubq_s16(v82, v81), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v86 = vqrdmulhq_lane_s16(vaddq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v87 = vqrdmulhq_lane_s16(vaddq_s16(v79, v84), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v88 = vsubq_s16(vqrdmulhq_lane_s16(v81, (int16x4_t)0x30FC273D5A824546, 0), v85);
  int16x8_t v89 = vsubq_s16(v83, v80);
  int16x8_t v90 = vaddq_s16(v83, v80);
  int16x8_t v91 = vaddq_s16(vqrdmulhq_lane_s16(v82, (int16x4_t)0x30FC273D5A824546, 2), vsubq_s16(v82, v85));
  int16x8_t v92 = vaddq_s16(v86, v73);
  int16x8_t v93 = vsubq_s16(v73, v86);
  int16x8_t v94 = vaddq_s16(v92, v91);
  int16x8_t v95 = vsubq_s16(v92, v91);
  int16x8_t v96 = vaddq_s16(v88, v93);
  int16x8_t v97 = vsubq_s16(v93, v88);
  int16x8_t v98 = vsubq_s16(v84, v87);
  int16x8_t v99 = vaddq_s16(v87, v84);
  int32x4_t v100 = (int32x4_t)vtrn1q_s16(v90, v94);
  int32x4_t v101 = (int32x4_t)vtrn2q_s16(v90, v94);
  int32x4_t v102 = (int32x4_t)vtrn1q_s16(v99, v97);
  int32x4_t v103 = (int32x4_t)vtrn2q_s16(v99, v97);
  int32x4_t v104 = (int32x4_t)vtrn1q_s16(v89, v96);
  int32x4_t v105 = (int32x4_t)vtrn2q_s16(v89, v96);
  int32x4_t v106 = (int32x4_t)vtrn1q_s16(v98, v95);
  int32x4_t v107 = (int32x4_t)vtrn2q_s16(v98, v95);
  int64x2_t v108 = (int64x2_t)vtrn1q_s32(v100, v102);
  int64x2_t v109 = (int64x2_t)vtrn2q_s32(v100, v102);
  int64x2_t v110 = (int64x2_t)vtrn1q_s32(v101, v103);
  int64x2_t v111 = (int64x2_t)vtrn2q_s32(v101, v103);
  int64x2_t v112 = (int64x2_t)vtrn1q_s32(v104, v106);
  int64x2_t v113 = (int64x2_t)vtrn2q_s32(v104, v106);
  int64x2_t v114 = (int64x2_t)vtrn1q_s32(v105, v107);
  int64x2_t v115 = (int64x2_t)vtrn2q_s32(v105, v107);
  int16x8_t v116 = (int16x8_t)vtrn1q_s64(v108, v112);
  int16x8_t v117 = (int16x8_t)vtrn2q_s64(v108, v112);
  int16x8_t v118 = (int16x8_t)vtrn1q_s64(v110, v114);
  int16x8_t v119 = (int16x8_t)vtrn2q_s64(v110, v114);
  int16x8_t v120 = (int16x8_t)vtrn1q_s64(v109, v113);
  int16x8_t v121 = (int16x8_t)vtrn2q_s64(v109, v113);
  int16x8_t v122 = (int16x8_t)vtrn1q_s64(v111, v115);
  int16x8_t v123 = (int16x8_t)vtrn2q_s64(v111, v115);
  int16x8_t v125 = *a3;
  int16x8_t v126 = a3[1];
  v124 = a3 + 2;
  int16x8_t v127 = *v124;
  int16x8_t v128 = v124[1];
  v124 += 2;
  int16x8_t v129 = *v124;
  int16x8_t v130 = v124[1];
  v124 += 2;
  v134.val[0] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v116, 1uLL), v125);
  v134.val[1] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v118, 1uLL), v126);
  v134.val[2] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v120, 1uLL), v127);
  v134.val[3] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v122, 1uLL), v128);
  v135.val[0] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v117, 1uLL), v129);
  v135.val[1] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v119, 1uLL), v130);
  v135.val[2] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v121, 1uLL), *v124);
  v135.val[3] = (int8x16_t)vqrdmulhq_s16(vshlq_n_s16(v123, 1uLL), v124[1]);
  v131.i64[1] = -1;
  v109.i64[0] = 0xFFFF0100FFFFFFFFLL;
  v131.i64[0] = -3907647224;
  v109.i64[1] = -1;
  *a2 = vqtbx4q_s8(v134, (int8x16_t)xmmword_2103D50B8);
  a2[1] = vqtbx1q_s8(v135.val[0], (int8x16_t)v109);
  v132 = a2 + 2;
  int8x16_t *v132 = vqtbx2q_s8(*(int8x16x2_t *)v134.val[1].i8, v131);
  v132[1] = vqtbx4q_s8(v134, (int8x16_t)xmmword_2103D50F8);
  v132 += 2;
  v130.i64[0] = 0x1F1E0F0E1D1CFFFFLL;
  uint64_t result = aj_block_dct;
  v131.i64[0] = -4177132284;
  v130.i64[1] = -1;
  int8x16_t *v132 = vqtbx4q_s8(v135, *(int8x16_t *)&qword_2103D5108);
  v132[1] = vqtbx2q_s8(*(int8x16x2_t *)v134.val[1].i8, (int8x16_t)v130);
  v132 += 2;
  int8x16_t *v132 = vqtbx1q_s8(v135.val[3], v131);
  v132[1] = vqtbx3q_s8(*(int8x16x3_t *)v135.val[1].i8, *(int8x16_t *)&qword_2103D5148);
  return result;
}

uint64_t aj_idct_s1(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  int64x2_t v63 = a2 + 2;
  uint64_t v66 = *v63;
  uint64_t v67 = v63[1];
  v63 += 2;
  uint64_t v68 = *v63;
  uint64_t v69 = v63[1];
  v63 += 2;
  int16x8_t v70 = vaddq_s16(v60, v59);
  int16x8_t v71 = vaddq_s16(v55, v56);
  int16x8_t v72 = vsubq_s16(v55, v56);
  int16x8_t v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v74 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v75 = vaddq_s16(v61, v58);
  int16x8_t v76 = vsubq_s16(v58, v61);
  int16x8_t v77 = vaddq_s16(v57, v74);
  int16x8_t v78 = vsubq_s16(v57, v74);
  int16x8_t v79 = vaddq_s16(v77, v75);
  int16x8_t v80 = vaddq_s16(v70, v73);
  int16x8_t v81 = vaddq_s16(v71, v80);
  int16x8_t v82 = vsubq_s16(v71, v80);
  int16x8_t v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v85 = vsubq_s16(v72, v73);
  int16x8_t v86 = vaddq_s16(v72, v73);
  int16x8_t v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  int16x8_t v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  int16x8_t v89 = vaddq_s16(v79, v87);
  int16x8_t v90 = vaddq_s16(v87, v84);
  int16x8_t v91 = vaddq_s16(v88, v84);
  _X3 = (int8x8_t *)(v64 + a3);
  _X4 = (int8x8_t *)(v65 + a3);
  _X5 = (int8x8_t *)(v66 + a3);
  _X6 = (int8x8_t *)(v67 + a3);
  _X7 = (int8x8_t *)(v68 + a3);
  _X9 = (int8x8_t *)(v69 + a3);
  _X10 = (int8x8_t *)(*v63 + a3);
  _X11 = (int8x8_t *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *_X4 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *_X5 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *_X6 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *_X7 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *_X9 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *_X10 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *_X11 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  return 8;
}

uint64_t aj_huffman_decode_skip_block(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((int)a3 >= 64) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)a2;
  uint64_t v5 = 612;
  unsigned int v6 = *(_DWORD *)(a2 + 28);
  int v7 = *(_DWORD *)(a2 + 24);
  do
  {
    while (1)
    {
      while (1)
      {
        while (v6)
        {
          int v23 = 0;
LABEL_26:
          *(_DWORD *)(a2 + 24) = v7;
          *(_DWORD *)a2 = v4;
          uint64_t v27 = a1;
          int16x8_t v28 = (unsigned int *)a2;
          uint64_t v25 = a3;
          uint64_t v26 = v5;
          uint64_t v24 = 0;
          uint64_t result = aj_huffman_decode_skip_val_slow(a1, a2, &v25, v23, (int *)&v24);
          if (result) {
            return result;
          }
          uint64_t v5 = v26;
          a1 = v27;
          a2 = (uint64_t)v28;
          int v7 = v28[6];
          unsigned int v4 = *v28;
          unsigned int v6 = v28[7];
          a3 = (v25 + (v24 << 6));
          if ((int)a3 >= 64) {
            goto LABEL_10;
          }
        }
        unsigned int v8 = *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
        if (!v8)
        {
          int v23 = 9;
          goto LABEL_26;
        }
        int v9 = a3 + *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
        if (v9 >= 64)
        {
          a3 = v9 - *(_DWORD *)(a1 + 4 * (v5 + (v4 >> 23)));
          int v23 = 0;
          goto LABEL_26;
        }
        a3 = v9 + (HIWORD(v8) << 6);
        int v10 = BYTE1(v8);
        if (v7 < BYTE1(v8) - 9)
        {
          *(_DWORD *)(a2 + 24) = v7;
          *(_DWORD *)a2 = v4;
          uint64_t v27 = a1;
          int16x8_t v28 = (unsigned int *)a2;
          uint64_t v25 = a3;
          uint64_t v26 = v5;
          uint64_t v24 = BYTE1(v8);
          uint64_t result = aj_istream_fill_buf(a2, BYTE1(v8) - 9);
          int v10 = v24;
          if (result) {
            return result;
          }
          a3 = v25;
          uint64_t v5 = v26;
          a1 = v27;
          a2 = (uint64_t)v28;
          int v7 = v28[6];
          unsigned int v4 = *v28;
          unsigned int v6 = v28[7];
        }
        v4 <<= v10;
        v7 -= v10;
        if (v7 < 0) {
          break;
        }
        if ((int)a3 >= 64) {
          goto LABEL_10;
        }
      }
      int v11 = *(_DWORD *)(a2 + 32);
      if (v6) {
        goto LABEL_21;
      }
      int16x8_t v12 = *(unsigned __int8 **)(a2 + 8);
      if (v11 >= 8)
      {
        int v13 = *v12;
        int v14 = v12[1];
        BOOL v16 = v13 == 255;
        int v15 = v14 + (v13 << 8);
        BOOL v16 = v16 || v14 == 255;
        int v17 = v12[2];
        int16x8_t v18 = v12 + 3;
        int v19 = v11 - 3;
        int v20 = v17 + (v15 << 8);
        if (!v16 && v17 != 255) {
          break;
        }
      }
      *(_DWORD *)a2 = v4;
      *(_DWORD *)(a2 + 24) = v7;
      uint64_t v27 = a1;
      int16x8_t v28 = (unsigned int *)a2;
      uint64_t v25 = a3;
      uint64_t v26 = v5;
      uint64_t result = aj_istream_fill_buf(a2, -9);
      if (result) {
        return result;
      }
      a3 = v25;
      uint64_t v5 = v26;
      a1 = v27;
      a2 = (uint64_t)v28;
      int v7 = v28[6];
      unsigned int v4 = *v28;
      unsigned int v6 = v28[7];
      if ((int)v25 >= 64)
      {
LABEL_10:
        *(_DWORD *)a2 = v4;
        *(_DWORD *)(a2 + 24) = v7;
        return 0;
      }
    }
    int v22 = ~v7;
    *(_DWORD *)(a2 + 32) = v19;
    *(void *)(a2 + 8) = v18;
    v4 |= v20 << v22;
    int v7 = 23 - v22;
LABEL_21:
    ;
  }
  while ((int)a3 < 64);
  *(_DWORD *)a2 = v4;
  *(_DWORD *)(a2 + 24) = v7;
  return 0;
}

void __aj_logging_enabled_block_invoke()
{
  CFStringRef v0 = (const __CFString *)CFPreferencesCopyAppValue(@"aj_log_errors", @"com.apple.applejpeg");
  if (v0)
  {
    CFStringRef v1 = v0;
    CFTypeID v2 = CFGetTypeID(v0);
    if (v2 == CFStringGetTypeID())
    {
      BOOL v3 = CFStringGetIntValue(v1) == 0;
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(v1);
      if (v5 != CFNumberGetTypeID())
      {
        CFTypeID v6 = CFGetTypeID(v1);
        if (v6 == CFBooleanGetTypeID()) {
          Boolean Value = CFBooleanGetValue((CFBooleanRef)v1);
        }
        else {
          Boolean Value = 0;
        }
        goto LABEL_10;
      }
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v1, kCFNumberIntType, &valuePtr);
      BOOL v3 = valuePtr == 0;
    }
    Boolean Value = !v3;
LABEL_10:
    CFRelease(v1);
    goto LABEL_11;
  }
  Boolean Value = 0;
LABEL_11:
  aj_logging_enabled_s_should_log = Value;
}

uint8x8_t **aj_icol_row_444_to_bgr565(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64_t a9, uint64_t a10, unsigned int a11)
{
  uint8x8_t v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  int16x8_t v12 = *result;
  int v13 = *a2;
  int v14 = *a3;
  for (unsigned int i = a11 >> 3; i; --i)
  {
    uint8x8_t v16 = *v12++;
    uint8x8_t v17 = *v13++;
    uint8x8_t v18 = *v14++;
    int16x8_t v19 = (int16x8_t)vshll_n_u8(v16, 7uLL);
    int16x8_t v20 = (int16x8_t)vsubl_u8(v17, v11);
    int16x8_t v21 = (int16x8_t)vsubl_u8(v18, v11);
    int8x8_t v22 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v19, vqaddq_s16(vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    v28.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v22, 5uLL));
    v28.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v22, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_n_s16(v21, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    vst2_s8(a4, v28);
    a4 += 16;
  }
  if ((a11 & 7) != 0)
  {
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*v12, 7uLL);
    int16x8_t v24 = (int16x8_t)vsubl_u8(*v13, v11);
    int16x8_t v25 = (int16x8_t)vsubl_u8(*v14, v11);
    int8x8_t v26 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    *(int8x8_t *)a7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v26, 5uLL));
    *(int8x8_t *)a8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v26, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    int v27 = a11 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4 += 2;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      --v27;
    }
    while (v27);
  }
  return result;
}

uint64_t (**aj_select_semistatic_coder(uint64_t (**result)(int a1)))(int a1)
{
  result[3] = (uint64_t (*)(int))arithmetic_context_init;
  result[4] = (uint64_t (*)(int))arithmetic_context_init_prob;
  result[10] = (uint64_t (*)(int))arithmetic_decode_close;
  result[8] = (uint64_t (*)(int))arithmetic_decode_static_data;
  result[2] = (uint64_t (*)(int))arithmetic_decode_init;
  result[6] = (uint64_t (*)(int))arithmetic_decode_symbols;
  result[9] = (uint64_t (*)(int))arithmetic_encode_close;
  result[7] = (uint64_t (*)(int))arithmetic_encode_static_data;
  result[1] = (uint64_t (*)(int))arithmetic_encode_init;
  result[5] = (uint64_t (*)(int))arithmetic_encode_symbols;
  *uint64_t result = arithmetic_prob_table_size;
  return result;
}

void arithmetic_context_init(uint64_t a1, unsigned __int16 *a2, int a3, int a4)
{
}

void arithmetic_context_init_prob(uint64_t a1, unsigned __int16 *a2, int a3, int a4, unsigned __int8 *a5)
{
}

uint64_t arithmetic_decode_close()
{
  return 0;
}

uint64_t arithmetic_decode_static_data(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  char v3 = a3;
  if (a3 - 33 <= 0xFFFFFFDF)
  {
    aj_log_error(0, "Illegal number of data bits: %d", a3);
    return 7;
  }
  *a2 = 0;
  if (a3 < 0x11) {
    goto LABEL_9;
  }
  unsigned int v7 = HIWORD(*(_DWORD *)a1);
  if (*(_DWORD *)(a1 + 8) / v7 >= 0xFFFF) {
    int v8 = 0xFFFF;
  }
  else {
    int v8 = *(_DWORD *)(a1 + 8) / v7;
  }
  uint64_t result = arithmetic_decode((int *)a1, *(void *)(a1 + 24), v8, v8 + 1, v7);
  if (!result)
  {
    v3 -= 16;
    *a2 = v8 << v3;
LABEL_9:
    unsigned int v9 = *(_DWORD *)a1 >> v3;
    if (*(_DWORD *)(a1 + 8) / v9 >= ~(-1 << v3)) {
      int v10 = ~(-1 << v3);
    }
    else {
      int v10 = *(_DWORD *)(a1 + 8) / v9;
    }
    uint64_t result = arithmetic_decode((int *)a1, *(void *)(a1 + 24), v10, v10 + 1, v9);
    if (!result) {
      *a2 |= v10;
    }
  }
  return result;
}

uint64_t arithmetic_decode_init(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  int v3 = 4;
  do
  {
    unsigned int v5 = 0;
    uint64_t result = aj_istream_read_bytes_le(v2, &v5, 1);
    if (result) {
      break;
    }
    *(_DWORD *)(a1 + 8) = v5 | (*(_DWORD *)(a1 + 8) << 8);
    --v3;
  }
  while (v3);
  return result;
}

uint64_t arithmetic_decode_symbols(uint64_t a1, unsigned __int16 **a2, unsigned char *a3, int a4)
{
  if (!a4) {
    return 0;
  }
  int v4 = a4;
  uint64_t v32 = a1;
  while (1)
  {
    unsigned int v7 = *a2;
    uint64_t v8 = (uint64_t)(*a2 + 2);
    uint64_t v9 = **a2;
    unsigned int v10 = *(_DWORD *)a1 >> 15;
    int16x8_t v33 = a2 + 1;
    if (**a2)
    {
      uint64_t v11 = 0;
      unsigned int v12 = *(_DWORD *)(a1 + 8) / v10;
      if (v12 >= 0x7FFF) {
        LOWORD(v12) = 0x7FFF;
      }
      while (*(unsigned __int16 *)(v8 + 2 * v11) <= (unsigned __int16)v12)
      {
        if (v9 == ++v11)
        {
          uint64_t v13 = **a2;
          LODWORD(v11) = **a2;
          goto LABEL_11;
        }
      }
      uint64_t v13 = **a2;
    }
    else
    {
      uint64_t v13 = 0;
      LODWORD(v11) = 0;
    }
LABEL_11:
    int v14 = &v7[v13 + 2];
    int v15 = &v14[v13];
    unsigned int v16 = v15[2];
    if ((int)v11 >= (int)v16) {
      break;
    }
    uint8x8_t v17 = v7 + 1;
    uint8x8_t v18 = (_WORD *)(v8 + 2 * (int)v11);
    int v19 = (unsigned __int16)*(v18 - 1);
    LOWORD(v18) = *v18 - v19;
    ++v14[(int)v11];
    uint64_t v20 = *(void *)(a1 + 24);
    ++*v15;
    ++v15[1];
    uint64_t result = arithmetic_decode((int *)a1, v20, v19, v19 + (unsigned __int16)v18, v10);
    if (result) {
      return result;
    }
    *a3 = v11;
    unsigned int v22 = v15[1];
    a1 = v32;
    a2 = v33;
    if (v22 >= 0x800)
    {
      unsigned int v22 = 0;
      if (v9)
      {
        do
        {
          unsigned int v23 = *v14 + 1;
          *v14++ = v23 >> 1;
          v22 += v23 >> 1;
          --v13;
        }
        while (v13);
      }
      v15[1] = v22;
    }
    unsigned int v24 = *v15;
    if ((unsigned __int16)v22 <= 0x7Fu)
    {
      int16x8_t v25 = v17;
      if ((v22 & 1) == 0 && v24 <= 0x80) {
        goto LABEL_42;
      }
LABEL_40:
      int v31 = v15[2];
LABEL_41:
      renormalize_probs(v25, v9, v31);
      a1 = v32;
      goto LABEL_42;
    }
    int16x8_t v25 = v17;
    if (v24 >= 0x81) {
      goto LABEL_40;
    }
LABEL_42:
    ++a3;
    if (!--v4) {
      return 0;
    }
  }
  uint64_t result = arithmetic_decode((int *)a1, *(void *)(a1 + 24), *(unsigned __int16 *)(v8 + 2 * v11 - 2), v7[v11 + 2], v10);
  if (result) {
    return result;
  }
  unsigned int v26 = -1;
  do
    ++v26;
  while (v26 <= 0x1F && 1 << v26 < (int)v9);
  unsigned int v27 = *(_DWORD *)v32 >> v26;
  int v28 = *(_DWORD *)(v32 + 8) / v27 >= ~(-1 << v26) ? ~(-1 << v26) : *(_DWORD *)(v32 + 8) / v27;
  uint64_t result = arithmetic_decode((int *)v32, *(void *)(v32 + 24), v28, v28 + 1, v27);
  if (result) {
    return result;
  }
  *a3 = v28;
  if (v28 < v9)
  {
    if (v28 > v16)
    {
      unint64_t v29 = v28 - (unint64_t)v16;
      int16x8_t v30 = &v7[v13 + 3 + v16];
      do
      {
        ++*v30++;
        ++v15[1];
        --v29;
      }
      while (v29);
    }
    if (v28 + 1 < v9)
    {
      ++v14[v28 + 1];
      ++v15[1];
    }
    ++v14[v28];
    ++v15[1];
    if (v28 + 2 == v9) {
      int v31 = v9;
    }
    else {
      int v31 = v28 + 1;
    }
    v15[2] = v31;
    a2 = v33;
    int16x8_t v25 = v7 + 1;
    goto LABEL_41;
  }
  aj_log_error(0, "Symbol is too large. %d > %d", v28, v9);
  return 7;
}

uint64_t arithmetic_encode_close(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  int v4 = 4;
  while (1)
  {
    uint64_t result = byte_plus_prev(a1, v2, HIBYTE(v3));
    if (result) {
      return result;
    }
    unsigned int v3 = *(_DWORD *)(a1 + 4) << 8;
    *(_DWORD *)(a1 + 4) = v3;
    if (!--v4)
    {
      uint64_t result = aj_ostream_write_bytes(v2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            uint64_t result = aj_ostream_write_bytes(v2, 255, 1);
            if (result) {
              break;
            }
            int v6 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v6;
            if (!v6) {
              goto LABEL_8;
            }
          }
        }
        else
        {
LABEL_8:
          uint64_t result = 0;
          *(unsigned char *)(a1 + 33) = 0;
        }
      }
      return result;
    }
  }
}

uint64_t arithmetic_encode_static_data(uint64_t a1, unsigned int a2, int a3)
{
  char v3 = a3;
  int v4 = a2;
  if (a3 >= 17)
  {
    char v3 = a3 - 16;
    uint64_t result = arithmetic_encode(a1, *(void *)(a1 + 16), a2 >> (a3 - 16), (a2 >> (a3 - 16)) + 1, 16);
    if (result) {
      return result;
    }
    v4 &= ~(-1 << v3);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  return arithmetic_encode(a1, v7, v4, v4 + 1, v3);
}

uint64_t arithmetic_encode_init(uint64_t a1)
{
  *(void *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t arithmetic_encode_symbols(uint64_t a1, unsigned __int16 **a2, unsigned __int8 *a3, int a4)
{
  if (!a4) {
    return 0;
  }
  int v4 = a4;
  while (1)
  {
    uint64_t v8 = *a2++;
    uint64_t v7 = v8;
    uint64_t v9 = v8 + 1;
    uint64_t v10 = *v8;
    LODWORD(v8) = *a3;
    uint64_t v11 = a3 + 1;
    uint64_t v12 = v8;
    if (v8 >= v10) {
      break;
    }
    int v31 = v11;
    uint64_t v13 = &v9[v10 + 1];
    int v14 = &v13[v10];
    uint64_t v15 = v14[2];
    if (v15 <= v12)
    {
      uint64_t result = arithmetic_encode(a1, *(void *)(a1 + 16), v7[v14[2] + 1], v9[v14[2] + 1], 15);
      if (result) {
        return result;
      }
      int v29 = v4;
      unsigned int v24 = -1;
      do
        ++v24;
      while (v24 <= 0x1F && 1 << v24 < (int)v10);
      uint64_t v25 = v12 + 1;
      uint64_t result = arithmetic_encode(a1, *(void *)(a1 + 16), v12, (int)v12 + 1, v24);
      if (result) {
        return result;
      }
      if (v15 < v12)
      {
        uint64_t v26 = v12 - v15;
        unsigned int v27 = &v7[v10 + 3 + v15];
        do
        {
          ++*v27++;
          ++v14[1];
          --v26;
        }
        while (v26);
      }
      if (v25 < v10)
      {
        ++v13[v25];
        ++v14[1];
      }
      ++v13[v12];
      ++v14[1];
      if (v12 + 2 == v10) {
        int v28 = v10;
      }
      else {
        int v28 = v12 + 1;
      }
      v14[2] = v28;
      int v4 = v29;
      a3 = v31;
      goto LABEL_30;
    }
    int v16 = v7[v12 + 1];
    unsigned __int16 v17 = v7[v12 + 2] - v16;
    ++v13[v12];
    uint64_t v18 = *(void *)(a1 + 16);
    ++*v14;
    ++v14[1];
    uint64_t result = arithmetic_encode(a1, v18, v16, v16 + v17, 15);
    if (result) {
      return result;
    }
    unsigned int v20 = v14[1];
    if (v20 >= 0x800)
    {
      unsigned int v20 = 0;
      uint64_t v21 = v10;
      do
      {
        unsigned int v22 = *v13 + 1;
        *v13++ = v22 >> 1;
        v20 += v22 >> 1;
        --v21;
      }
      while (v21);
      v14[1] = v20;
    }
    unsigned int v23 = *v14;
    if ((unsigned __int16)v20 <= 0x7Fu)
    {
      a3 = v31;
      if ((v20 & 1) == 0 && v23 <= 0x80) {
        goto LABEL_31;
      }
LABEL_29:
      int v28 = v14[2];
LABEL_30:
      renormalize_probs(v9, v10, v28);
      goto LABEL_31;
    }
    a3 = v31;
    if (v23 >= 0x81) {
      goto LABEL_29;
    }
LABEL_31:
    if (!--v4) {
      return 0;
    }
  }
  aj_log_error(0, "Illegal symbol to be encoded (%d). Num syms in this context is %d.", v12, v10);
  return 7;
}

uint64_t arithmetic_prob_table_size(int a1)
{
  return (4 * a1 + 10);
}

void init_cum_prob(unsigned __int16 *a1, int a2, unsigned __int8 *a3, int a4)
{
  LODWORD(v4) = a4;
  bzero(a1, 4 * a2 + 10);
  *a1 = a2;
  uint64_t v8 = (uint64_t)&a1[a2 + 1];
  uint64_t v9 = (_WORD *)(v8 + 2);
  if (a2 - 1 <= (int)v4) {
    uint64_t v4 = a2;
  }
  else {
    uint64_t v4 = v4;
  }
  uint64_t v10 = &v9[a2];
  v10[2] = v4;
  if (a3)
  {
    __int16 v11 = 0;
    if ((int)v4 >= 1)
    {
      uint64_t v12 = v4;
      uint64_t v13 = v9;
      do
      {
        *v13++ = *a3;
        __int16 v14 = *a3++;
        v11 += v14;
        --v12;
      }
      while (v12);
    }
    if ((int)v4 >= a2) {
      goto LABEL_15;
    }
LABEL_14:
    v9[(int)v4] = 1;
    ++v11;
    goto LABEL_15;
  }
  if ((int)v4 >= 1) {
    memset_pattern16((void *)(v8 + 2), &unk_21040A9A0, 2 * v4);
  }
  __int16 v11 = v4;
  if ((int)v4 < a2)
  {
    bzero(&a1[a2 + 2 + (uint64_t)(int)v4], 2 * (a2 - 1 - v4) + 2);
    __int16 v11 = v4;
    goto LABEL_14;
  }
LABEL_15:
  v10[1] = v11;
  renormalize_probs(a1 + 1, a2, v4);
}

void renormalize_probs(unsigned __int16 *a1, int a2, int a3)
{
  uint64_t v5 = (uint64_t)&a1[a2 + a2];
  int v6 = a1 + 1;
  unsigned int v7 = *(unsigned __int16 *)(v5 + 4);
  *(_WORD *)(v5 + 2) = 0;
  if (a3 >= a2) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = (a3 + 1);
  }
  if ((int)v8 < 1)
  {
    uint64_t v10 = 0;
    __int16 v15 = 0x8000;
  }
  else
  {
    uint64_t v9 = 0;
    LODWORD(v10) = 0;
    __int16 v11 = 0;
    int v12 = v7 - 1;
    unsigned int v13 = 0x80000000 / v7;
    do
    {
      unint64_t v14 = (v13 * (unint64_t)(v12 + ((unsigned __int16)v6[a2 + v9] << 15))) >> 31;
      v6[v9] = v14;
      v11 += v14;
      if ((unsigned __int16)v14 <= (unsigned __int16)v6[v10]) {
        uint64_t v10 = v10;
      }
      else {
        uint64_t v10 = v9;
      }
      ++v9;
    }
    while (v8 != v9);
    __int16 v15 = (v11 ^ 0x7FFF) + 1;
  }
  if ((int)v8 < a2)
  {
    uint64_t v16 = a3;
    if (a3 < a2) {
      uint64_t v16 = a3 + 1;
    }
    bzero(&a1[v16 + 1], 2 * (~a3 + a2 - (a3 < a2)) + 2);
  }
  v6[v10] += v15;
  if (a2 >= 1)
  {
    uint64_t v17 = a2;
    int v18 = *a1;
    do
    {
      v18 += (unsigned __int16)*v6;
      *v6++ = v18;
      --v17;
    }
    while (v17);
  }
}

uint64_t arithmetic_decode(int *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v6 = (a4 - a3) * a5;
  *a1 = v6;
  a1[2] -= a5 * a3;
  if ((v6 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      unsigned int v10 = 0;
      uint64_t result = aj_istream_read_bytes_le(a2, &v10, 1);
      if (result) {
        break;
      }
      a1[2] = v10 | (a1[2] << 8);
      int v9 = *a1;
      int v6 = *a1 << 8;
      *a1 = v6;
      if (((v9 << 8) - 16777217) >> 24 != 255) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    uint64_t result = 0;
    if (!v6) {
      *a1 = -1;
    }
  }
  return result;
}

uint64_t byte_plus_prev(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = a3;
  if (*(unsigned char *)(a1 + 32))
  {
    if (a3 == 255)
    {
      uint64_t result = 0;
      ++*(_DWORD *)(a1 + 12);
    }
    else
    {
      uint64_t result = aj_ostream_write_bytes(a2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            uint64_t result = aj_ostream_write_bytes(a2, 255, 1);
            if (result) {
              break;
            }
            int v7 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v7;
            if (!v7) {
              goto LABEL_7;
            }
          }
        }
        else
        {
LABEL_7:
          uint64_t result = 0;
          *(unsigned char *)(a1 + 33) = v3;
        }
      }
    }
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 32) = 1;
    *(unsigned char *)(a1 + 33) = a3;
    *(_DWORD *)(a1 + 12) = 0;
  }
  return result;
}

uint64_t arithmetic_encode(uint64_t a1, uint64_t a2, int a3, int a4, char a5)
{
  int v7 = *(_DWORD *)(a1 + 4);
  int v8 = *(_DWORD *)a1 >> a5;
  int v9 = v8 * (a4 - a3);
  *(_DWORD *)a1 = v9;
  int v10 = v8 * a3;
  unsigned int v11 = v10 + v7;
  if (__CFADD__(v10, v7) && (unsigned __int8 v12 = *(unsigned char *)(a1 + 33) + 1, *(unsigned char *)(a1 + 33) = v12, *(_DWORD *)(a1 + 12)))
  {
    int v13 = v12;
    while (1)
    {
      uint64_t result = aj_ostream_write_bytes(a2, v13, 1);
      if (result) {
        break;
      }
      int v13 = 0;
      *(unsigned char *)(a1 + 33) = 0;
      int v15 = *(_DWORD *)(a1 + 12) - 1;
      *(_DWORD *)(a1 + 12) = v15;
      if (!v15)
      {
        int v9 = *(_DWORD *)a1;
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    *(_DWORD *)(a1 + 4) = v11;
    if ((v9 - 16777217) >> 24 == 255)
    {
      while (1)
      {
        uint64_t result = byte_plus_prev(a1, a2, HIBYTE(v11));
        if (result) {
          break;
        }
        int v16 = *(_DWORD *)a1;
        unsigned int v11 = *(_DWORD *)(a1 + 4) << 8;
        int v9 = *(_DWORD *)a1 << 8;
        *(_DWORD *)a1 = v9;
        *(_DWORD *)(a1 + 4) = v11;
        if (((v16 << 8) - 16777217) >> 24 != 255) {
          goto LABEL_11;
        }
      }
    }
    else
    {
LABEL_11:
      uint64_t result = 0;
      if (!v9) {
        *(_DWORD *)a1 = -1;
      }
    }
  }
  return result;
}

BOOL aj_allow_multithread_encode(_DWORD *a1, uint64_t a2, int a3)
{
  return a3 >= 2 && a1[3359] >= a3 && (int)a1[3358] <= 65534 && a1[3340] != 14 && a1[4952] < 2;
}

uint64_t aj_encode_buffers_baseline(int *a1, _DWORD *a2)
{
  if (a1[3358] < 1) {
    return 0;
  }
  int v4 = 0;
  while (1)
  {
    uint64_t result = aj_mcu_dct(a1, a2);
    if (result) {
      break;
    }
    if (++v4 >= a1[3358]) {
      return 0;
    }
  }
  return result;
}

uint64_t aj_encode_buffers_progressive(int *a1, uint8x8_t **a2, int a3)
{
  char v3 = a2;
  v45[2] = *MEMORY[0x263EF8340];
  uint64_t v5 = a1 + 3360;
  v45[0] = 0;
  v45[1] = 0;
  memset(v44, 0, sizeof(v44));
  int v6 = a1[2];
  int v7 = v6 + 7;
  if (v6 < -7) {
    int v7 = v6 + 14;
  }
  int v8 = v7 >> 3;
  if (a1[8] == 2)
  {
    LODWORD(v45[0]) = 8;
    aj_fill_prog_coeff_buf((uint64_t (*)())a1, a2);
    if (v6 >= 1)
    {
      int v9 = 0;
      uint64_t v10 = *((void *)a1 + 2478);
      if (v8 <= 1) {
        int v11 = 1;
      }
      else {
        int v11 = v8;
      }
      int v12 = v5[1592];
      do
      {
        if (v12 >= 1)
        {
          uint64_t v13 = 0;
          for (uint64_t i = 0; i < v12; ++i)
          {
            uint64_t v15 = *((void *)a1 + 2477);
            if (*(_DWORD *)(v15 + v13) == 1 && !*(_DWORD *)(v15 + v13 + 4))
            {
              uint64_t result = (*(uint64_t (**)(void))(v15 + v13 + 232))();
              if (result) {
                return result;
              }
              int v12 = v5[1592];
            }
            v13 += 304;
          }
        }
        ++v9;
        v10 += 128;
      }
      while (v9 != v11);
    }
  }
  if (a1[3358] < 1) {
    return 0;
  }
  int v17 = 0;
  uint64_t v18 = *((void *)a1 + 2478);
  do
  {
    if (a1[8] == 2)
    {
      int v19 = a1[4];
      if (v19 >= 1)
      {
        int v20 = 0;
        int v21 = v5[1592];
        do
        {
          if (v21 >= 1)
          {
            uint64_t v22 = 0;
            for (uint64_t j = 0; j < v21; ++j)
            {
              uint64_t v24 = *((void *)a1 + 2477);
              if (*(int *)(v24 + v22) >= 2 && !*(_DWORD *)(v24 + v22 + 4))
              {
                uint64_t result = (*(uint64_t (**)(void))(v24 + v22 + 232))();
                if (result) {
                  return result;
                }
                int v21 = v5[1592];
              }
              v22 += 304;
            }
            int v19 = a1[4];
          }
          ++v20;
          v18 += 128;
        }
        while (v20 < v19);
      }
    }
    int v25 = *a1;
    if (*a1 >= 1)
    {
      uint64_t v26 = 0;
      int32x4_t v40 = v3;
      int v39 = v17;
      do
      {
        unsigned int v27 = &a1[v26];
        int v29 = v27[4];
        int v28 = v27 + 4;
        if (v29 >= 1)
        {
          int v30 = 0;
          int32x4_t v43 = &(&v3[16 * v26])[*((int *)v45 + v26)];
          if (v26) {
            int v31 = 0;
          }
          else {
            int v31 = -1;
          }
          int v42 = v31;
          do
          {
            aj_block_dct(v43, v44, (int16x8_t *)&a1[392 * v26 + 3503]);
            if (v26)
            {
              BOOL v32 = 0;
            }
            else
            {
              BOOL v32 = v8 == 0;
              if (v8 && a3) {
                BOOL v32 = *(unsigned char *)v5 != 0;
              }
            }
            int v33 = v5[1592];
            if (v33 >= 1)
            {
              int v34 = 0;
              int16x8_t v35 = (uint64_t (**)(unsigned int *, int8x16_t *, uint64_t))*((void *)a1 + 2477);
              do
              {
                uint64_t v36 = *(unsigned int *)v35;
                if ((int)v36 >= 1)
                {
                  uint64_t v37 = 0;
                  while (v26 != *((_DWORD *)v35 + v37 + 1))
                  {
                    if (v36 == ++v37) {
                      goto LABEL_56;
                    }
                  }
                  if (v36 != 1 || !v32)
                  {
                    uint64_t result = v35[29]((unsigned int *)v35, v44, (uint64_t)v35[v37 + 25] + 12);
                    if (result) {
                      return result;
                    }
                    int v33 = v5[1592];
                  }
                }
LABEL_56:
                ++v34;
                v35 += 38;
              }
              while (v34 < v33);
            }
            v8 += v42;
            ++v30;
          }
          while (v30 < *v28);
          int v25 = *a1;
          char v3 = v40;
          int v17 = v39;
        }
        ++v26;
      }
      while (v26 < v25);
    }
    uint64_t result = 0;
    ++v17;
  }
  while (v17 < a1[3358]);
  return result;
}

uint64_t aj_encode_row(uint64_t a1, void *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 13360) == 14)
  {
    a2[224] = a2[229];
    a2[225] = a2[231];
    a2[226] = a2[233];
    aj_reset_row_ptrs((unsigned int *)a1, a2, (uint64_t)(a2 + 224));
    int v6 = *(uint64_t (**)(uint64_t, void *, uint64_t))(a1 + 19752);
    return v6(a1, a2, a3);
  }
  else
  {
    aj_col_trans_row((int *)a1, (uint64_t)a2, (uint64_t)a2, *(unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 13284));
    int v8 = *(_DWORD *)(a1 + 13284) + 1;
    *(_DWORD *)(a1 + 13284) = v8;
    if (v8 == *(_DWORD *)(a1 + 13280))
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *, uint64_t))(a1 + 19752))(a1, a2, a3);
      if (result) {
        return result;
      }
      *(_DWORD *)(a1 + 13284) = 0;
      aj_reset_row_ptrs((unsigned int *)a1, a2, (uint64_t)(a2 + 224));
    }
    return 0;
  }
}

uint64_t aj_encode_row_close(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 13360) == 14) {
    goto LABEL_9;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 13276);
  int v5 = *(_DWORD *)(a1 + 13284);
  if (v4)
  {
    aj_col_trans_row((int *)a1, a2, a2, v4, v5);
    int v5 = *(_DWORD *)(a1 + 13284) + 1;
    *(_DWORD *)(a1 + 13284) = v5;
    *(_DWORD *)(a1 + 13276) = 0;
  }
  if (!v5) {
    goto LABEL_9;
  }
  while (v5 < *(_DWORD *)(a1 + 13280))
  {
    aj_col_trans_row((int *)a1, a2, a2, 0, v5);
    int v6 = *(_DWORD *)(a1 + 13284);
    int v5 = v6 + 1;
    *(_DWORD *)(a1 + 13284) = v6 + 1;
    if (v6 == -1) {
      goto LABEL_9;
    }
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 19752))(a1, a2, 1);
  if (!result)
  {
LABEL_9:
    if (*(_DWORD *)(a1 + 19800)) {
      aj_concatenate_scans(a1, a2);
    }
    uint64_t result = aj_ostream_write_bytes(a2 + 1928, 65497, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_flush_buffer(a2 + 1928);
      if (!result) {
        *(_DWORD *)(a2 + 2016) = *(_DWORD *)(a2 + 1944);
      }
    }
  }
  return result;
}

uint64_t aj_concatenate_scans(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(a1 + 19808);
  if (*(int *)(a1 + 19808) < 1) {
    return 0;
  }
  int v4 = 0;
  uint64_t v5 = a2 + 1928;
  for (uint64_t i = *(void *)(a1 + 19816); ; i += 304)
  {
    if (v4)
    {
      int v7 = *(_DWORD *)i;
      if (*(int *)i >= 1)
      {
        uint64_t v8 = 0;
        do
        {
          int v9 = *(uint8x16_t **)(i + 8 * v8 + 240);
          if (v9 && !v9[17].i8[1])
          {
            uint64_t v10 = i + 4 * v8;
            uint64_t result = aj_write_single_dht(v5, v9, 1, *(_DWORD *)(v10 + 4) != 0);
            if (result) {
              return result;
            }
            int v12 = (unsigned char *)(a1 + 274 * (*(_DWORD *)(v10 + 4) != 0) + 10937);
            if (*(_DWORD *)(i + 64)) {
              int v12 = (unsigned char *)(a1 + 548 * (*(_DWORD *)(v10 + 4) != 0) + 3971);
            }
            *int v12 = 0;
            int v7 = *(_DWORD *)i;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      uint64_t result = aj_write_sos_progressive(v5, a1, (int *)i);
      if (result) {
        break;
      }
    }
    uint64_t result = aj_prog_encode_close(i);
    if (result) {
      break;
    }
    uint64_t result = aj_ostream_flush_bitreg((unsigned int *)(i + 88));
    if (result) {
      break;
    }
    uint64_t v13 = *(char **)(i + 168);
    if (v13)
    {
      uint64_t v14 = *(unsigned int *)(i + 180);
      if (v14)
      {
        uint64_t result = aj_ostream_write_buf(v5, v13, v14);
        if (result) {
          break;
        }
      }
    }
    uint64_t v15 = *(char **)(i + 96);
    int v16 = *(char **)(i + 112);
    if (v15 != v16)
    {
      uint64_t result = aj_ostream_write_buf(v5, v16, (v15 - v16));
      if (result) {
        break;
      }
    }
    if (++v4 >= *v2) {
      return 0;
    }
  }
  return result;
}

uint64_t aj_encode_all(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (_DWORD *)(a1 + 19800);
  uint64_t v6 = *(int *)(a1 + 32);
  int v7 = *(_DWORD *)(a1 + 19844);
  uint64_t v8 = *(void *)(a1 + 19776);
  if (v7 <= (int)v6) {
    v8 *= (int)v6 / v7;
  }
  uint64_t v9 = *(void *)(a1 + 19768);
  *(_OWORD *)(a2 + 2000) = 0u;
  if (*(_DWORD *)(a1 + 13360) == 14)
  {
    uint64_t v26 = *(void *)(a2 + 1832) + *(void *)(a1 + 13296) * *(int *)(a1 + 13316) + *(int *)(a1 + 13312);
    uint64_t v10 = *(void *)(a1 + 13328) * *(int *)(a1 + 13348);
    uint64_t v11 = *(int *)(a1 + 13344);
    uint64_t v12 = *(void *)(a2 + 1848) + v11 + v10;
    uint64_t v13 = *(void *)(a2 + 1864) + v11 + v10;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
  }
  uint64_t v14 = *(int *)(a2 + 1824);
  if ((int)v14 >= *(_DWORD *)(a2 + 1828))
  {
LABEL_24:
    if (!*v5 || (uint64_t result = aj_concatenate_scans(a1, a2), !result))
    {
      if (a3 == 217 && *(unsigned char *)(a2 + 2096))
      {
        uint64_t result = aj_ostream_flush_buffer(a2 + 1928);
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t result = aj_ostream_write_bytes(a2 + 1928, a3 | 0xFF00u, 2);
        if (result) {
          return result;
        }
        if (a3 != 217)
        {
          uint64_t v22 = *(void *)(a2 + 2072);
          if (v22)
          {
            int v23 = *(_DWORD *)(a2 + 2080) + *(_DWORD *)(a2 + 1944) - *(_DWORD *)(a2 + 2020) - 2;
            uint64_t v24 = *(int *)(a2 + 2088);
            *(_DWORD *)(a2 + 2088) = v24 + 1;
            *(_DWORD *)(v22 + 4 * v24) = v23;
          }
        }
      }
      if (*(_DWORD *)(a2 + 2024))
      {
        (*(void (**)(void))(a2 + 2032))(*(void *)(a2 + 2040));
        uint64_t result = 0;
        *(_DWORD *)(a2 + 2048) = *(_DWORD *)(a2 + 2024);
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    uint64_t v15 = v9 * v6;
    while (1)
    {
      if (*(_DWORD *)(a2 + 2024))
      {
        int v16 = *(_DWORD *)(a2 + 2048);
        if (!v16)
        {
          (*(void (**)(void))(a2 + 2032))(*(void *)(a2 + 2040));
          int v16 = *(_DWORD *)(a2 + 2024);
        }
        *(_DWORD *)(a2 + 2048) = v16 - 1;
      }
      if (*(_DWORD *)(a1 + 13360) == 14)
      {
        *(void *)(a2 + 1792) = v26 + 8 * v14 * *(void *)(a1 + 13296) * *(int *)(a1 + 32);
        uint64_t v17 = 8 * v14 * *(void *)(a1 + 13328);
        *(void *)(a2 + 1800) = v12 + v17;
        *(void *)(a2 + 1808) = v13 + v17;
      }
      aj_reset_row_ptrs((unsigned int *)a1, (void *)a2, a2 + 1792);
      if (*(_DWORD *)(a1 + 13360) != 14)
      {
        for (int i = 0; i != 8; ++i)
        {
          aj_col_trans_row((int *)a1, a2, a2, (*(_DWORD *)(a1 + 12) - *(_DWORD *)(a1 + 32) * i - *(_DWORD *)(a1 + 13428) * v14), i);
          *(void *)(a2 + 1832) += v15;
          *(void *)(a2 + 1840) += v15;
          if (v5[8])
          {
            if (v5[11] <= *(_DWORD *)(a1 + 32)) {
              uint64_t v19 = 1;
            }
            else {
              uint64_t v19 = i & 1;
            }
            uint64_t v20 = v8 * v19;
            *(void *)(a2 + 1848) += v20;
            *(void *)(a2 + 1856) += v20;
          }
        }
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, BOOL))(a1 + 19752))(a1, a2, *(_DWORD *)(a1 + 13436) - 1 == v14);
      if (result) {
        break;
      }
      if (++v14 >= *(int *)(a2 + 1828)) {
        goto LABEL_24;
      }
    }
  }
  return result;
}

uint64_t aj_encode_all_mt(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4)
{
  v74[309] = *MEMORY[0x263EF8340];
  uint64_t v8 = (int *)(a1 + 19760);
  bzero(v70, 0xA78uLL);
  uint64_t v66 = 0;
  size_t v67 = 0;
  uint64_t v65 = 0;
  long long v64 = 0u;
  memset(v63, 0, sizeof(v63));
  memset(v68, 0, sizeof(v68));
  int v9 = *(_DWORD *)(a1 + 13436);
  int16x8_t v62 = v8;
  if (v9 % *v8) {
    int v10 = v9 / *v8 + 1;
  }
  else {
    int v10 = v9 / *v8;
  }
  if (v10 / a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = v10;
  }
  if ((v10 / a3) <= 1) {
    int v12 = 1;
  }
  else {
    int v12 = v10 / a3;
  }
  *((void *)&v63[0] + 1) = mt_write_callback;
  v71[0] = a2;
  uint64_t v69 = a1;
  v70[2] = 0;
  v70[3] = v12;
  unint64_t v13 = estimate_jpeg_size(*(_DWORD *)(a1 + 8), *(_DWORD *)(a1 + 12));
  LODWORD(v14) = v11 << 10;
  if (v13 <= (int)(v11 << 10)) {
    unint64_t v14 = (int)v14;
  }
  else {
    unint64_t v14 = v13;
  }
  if ((int)v11 > 1)
  {
    int v15 = 0;
    int v16 = v72;
    uint64_t v17 = v11 - 1;
    size_t v61 = (int)(v14 / v11);
    uint64_t v18 = v11 - 1;
    while (1)
    {
      uint64_t v19 = *((void *)v16 + 4);
      if (v19) {
        (*(void (**)(uint64_t, void))(a4 + 8))(v19, *(void *)(a4 + 16));
      }
      uint64_t v20 = (void *)(*(uint64_t (**)(uint64_t, void))a4)(2112, *(void *)(a4 + 16));
      *((void *)v16 + 4) = v20;
      if (!v20 || (bzero(v20, 0x840uLL), (int v21 = (void *)*((void *)v16 + 4)) == 0))
      {
LABEL_59:
        uint64_t v36 = 6;
        goto LABEL_63;
      }
      uint64_t enc_buffers = aj_allocate_enc_buffers((unsigned int *)a1, v21, a4);
      if (enc_buffers)
      {
        uint64_t v36 = enc_buffers;
        goto LABEL_63;
      }
      uint64_t v66 = 0;
      size_t v67 = v61;
      int v23 = (void *)(*(uint64_t (**)(void))a4)();
      uint64_t v66 = v23;
      if (!v23) {
        goto LABEL_59;
      }
      bzero(v23, v67);
      if (!v66) {
        goto LABEL_59;
      }
      *(void *)int v16 = a1;
      *((void *)v16 + 1) = a4;
      *((_DWORD *)v16 + 4) = v12 + v15;
      *((_DWORD *)v16 + 5) = 2 * v12 + v15;
      uint64_t v24 = *((void *)v16 + 4);
      *(_DWORD *)(v24 + 2056) = *(_DWORD *)(a2 + 2056);
      *(_DWORD *)(v24 + 2068) = *(_DWORD *)(a2 + 2068);
      *(void *)(v24 + 2072) = *(void *)(a2 + 2072);
      *(_DWORD *)(v24 + 2080) = *(_DWORD *)(a2 + 2080);
      *(unsigned char *)(v24 + 2096) = *(unsigned char *)(a2 + 2096);
      *(_DWORD *)(v24 + 2020) = 0;
      if (*(_DWORD *)(a1 + 13360) == 14) {
        return 3;
      }
      uint64_t v25 = *v62 * (uint64_t)(v12 + v15);
      uint64_t v26 = *(void *)(a1 + 19768);
      *(void *)(v24 + 1832) = *(void *)(a2 + 1832) + v26 * v25 * *(int *)(a1 + 13428);
      *(void *)(*((void *)v16 + 4) + 1840) = *(void *)(*((void *)v16 + 4) + 1832) + v26;
      if (!v62[18]) {
        goto LABEL_33;
      }
      int v27 = v62[21];
      if (v27 == 1) {
        break;
      }
      if (v27 == 2)
      {
        BOOL v28 = *(_DWORD *)(a1 + 32) == 1;
        int v29 = 4;
        goto LABEL_28;
      }
      int v30 = 8;
LABEL_32:
      uint64_t v31 = v30 * (int)v25;
      uint64_t v32 = *(void *)(a1 + 19776);
      *(void *)(*((void *)v16 + 4) + 1848) = *(void *)(a2 + 1848) + v32 * v31;
      *(void *)(*((void *)v16 + 4) + 1856) = *(void *)(*((void *)v16 + 4) + 1848) + v32;
LABEL_33:
      *(void *)&long long v64 = v16;
      aj_init_out_stream(*((void *)v16 + 4) + 1928, (uint64_t)v63, (uint64_t *)&v66);
      v15 += v12;
      v16 += 168;
      if (!--v18)
      {
        int v33 = v72;
        int v34 = (pthread_t *)v68 + 1;
        do
        {
          pthread_create(v34, 0, (void *(__cdecl *)(void *))enc_job, v33);
          v33 += 168;
          ++v34;
          --v17;
        }
        while (v17);
        goto LABEL_36;
      }
    }
    BOOL v28 = *(_DWORD *)(a1 + 32) == 2;
    int v29 = 16;
LABEL_28:
    if (v28) {
      int v30 = v29;
    }
    else {
      int v30 = 8;
    }
    goto LABEL_32;
  }
LABEL_36:
  enc_job((uint64_t)&v69);
  if ((int)v11 < 1) {
    goto LABEL_57;
  }
  uint64_t v35 = 0;
  LODWORD(v36) = 0;
  uint64_t v37 = (pthread_t *)v68;
  do
  {
    if (v35 * 4) {
      pthread_join(*v37, 0);
    }
    unsigned int v38 = v70[v35 + 4];
    if (v38) {
      uint64_t v36 = v38;
    }
    else {
      uint64_t v36 = v36;
    }
    v35 += 42;
    ++v37;
  }
  while (42 * v11 != v35);
  if (v36) {
    goto LABEL_63;
  }
  if ((int)v11 < 2) {
    goto LABEL_57;
  }
  int v39 = (unsigned int *)v74;
  uint64_t v40 = 1;
  while (2)
  {
    uint64_t v41 = *(void *)(a2 + 2072);
    if (v41)
    {
      uint64_t v42 = v71[21 * v40];
      uint64_t v43 = *(int *)(v42 + 2084);
      if ((int)v43 < *(_DWORD *)(v42 + 2088))
      {
        int v44 = *(_DWORD *)(a2 + 1944) - *(_DWORD *)(a2 + 2020);
        do
          *(_DWORD *)(v41 + 4 * v43++) += v44;
        while (v43 < *(int *)(v42 + 2088));
      }
    }
    uint64_t v45 = 0;
    int32x4_t v46 = v39;
    do
    {
      int64x2_t v47 = (char *)*((void *)v46 - 1);
      if (!v47) {
        break;
      }
      uint64_t v48 = aj_ostream_write_buf(a2 + 1928, v47, *v46);
      if (v48)
      {
        uint64_t v36 = v48;
        aj_log_error((uint64_t)"Enc", "IO error when copying buffer %d from thread %d");
        goto LABEL_63;
      }
      ++v45;
      v46 += 4;
    }
    while (v45 != 8);
    int64x2_t v49 = &v70[42 * v40 - 2];
    uint64_t v51 = *((void *)v49 + 4);
    int64x2_t v50 = v49 + 8;
    uint64_t v52 = aj_ostream_write_buf(a2 + 1928, *(char **)(v51 + 1952), *(_DWORD *)(v51 + 1936) - *(void *)(v51 + 1952));
    if (!v52)
    {
      *(_DWORD *)(a2 + 2016) += *(_DWORD *)(*(void *)v50 + 2016);
      ++v40;
      v39 += 42;
      if (v40 != v11) {
        continue;
      }
LABEL_57:
      uint64_t v36 = aj_ostream_flush_buffer(a2 + 1928);
      if (v36) {
        aj_log_error((uint64_t)"Enc", "IO error when flushing thread buffers");
      }
      goto LABEL_63;
    }
    break;
  }
  uint64_t v36 = v52;
  aj_log_error((uint64_t)"Enc", "IO error when copying buffer from thread %d");
LABEL_63:
  if ((int)v11 >= 2)
  {
    int64x2_t v53 = &v73;
    for (uint64_t i = 1; i != v11; ++i)
    {
      int16x8_t v55 = &v70[42 * i - 2];
      uint64_t v57 = *((void *)v55 + 4);
      int16x8_t v56 = v55 + 8;
      if (v57)
      {
        for (uint64_t j = 0; j != 16; j += 2)
        {
          uint64_t v59 = v53[j];
          if (!v59) {
            break;
          }
          (*(void (**)(uint64_t, void))(a4 + 8))(v59, *(void *)(a4 + 16));
          v53[j] = 0;
        }
        (*(void (**)(void, void))(a4 + 8))(*(void *)(*v56 + 1952), *(void *)(a4 + 16));
        (*(void (**)(void, void))(a4 + 8))(*(void *)(*v56 + 1792), *(void *)(a4 + 16));
        (*(void (**)(void, void))(a4 + 8))(*v56, *(void *)(a4 + 16));
        *int16x8_t v56 = 0;
      }
      v53 += 21;
    }
  }
  return v36;
}

uint64_t mt_write_callback(const void *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = a3 + v5;
    if (!*(void *)(a3 + v5 + 40)) {
      break;
    }
    v5 += 16;
    if (v5 == 128)
    {
      aj_log_error((uint64_t)"Enc", "Max number of allocations used in thread job.");
      return 1;
    }
  }
  size_t v7 = a2;
  *(void *)(v6 + 48) = a2;
  uint64_t v8 = *(void *)(v6 + 40);
  if (v8) {
    (*(void (**)(uint64_t, void))(*(void *)(a3 + 8) + 8))(v8, *(void *)(*(void *)(a3 + 8) + 16));
  }
  int v9 = (void *)(**(uint64_t (***)(size_t, void))(a3 + 8))(v7, *(void *)(*(void *)(a3 + 8) + 16));
  *(void *)(v6 + 40) = v9;
  if (v9)
  {
    bzero(v9, v7);
    int v10 = *(void **)(v6 + 40);
    if (v10)
    {
      memcpy(v10, a1, v7);
      return 0;
    }
  }
  return 1;
}

uint64_t enc_job(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)a1;
  int v4 = *(_DWORD *)(a1 + 16);
  uint64_t v5 = (int *)(*(void *)a1 + 19760);
  while (v4 < *(_DWORD *)(a1 + 20))
  {
    int v6 = *v5;
    int v7 = *v5 * v4;
    *(_DWORD *)(v2 + 1824) = v7;
    int v8 = v6 + v7;
    *(_DWORD *)(v2 + 1828) = v8;
    *(_DWORD *)(v2 + 2060) = 0;
    int v9 = *(_DWORD *)(v3 + 13432) * v7;
    int v10 = *(_DWORD *)(v2 + 2056);
    int v11 = v9 / v10;
    int v12 = *(_DWORD *)(v2 + 2068);
    *(_DWORD *)(v2 + 2064) = ((_BYTE)v11 + (_BYTE)v12 - 1) & 7;
    if (v4 == *(_DWORD *)(a1 + 16)) {
      *(_DWORD *)(v2 + 2084) = v11;
    }
    *(_DWORD *)(v2 + 2088) = v11;
    *(void *)(v2 + 2000) = 0;
    *(void *)(v2 + 2008) = 0;
    int v13 = *(_DWORD *)(v3 + 13436);
    if (v8 >= v13)
    {
      *(_DWORD *)(v2 + 1828) = v13;
      LOBYTE(v14) = -39;
    }
    else
    {
      unsigned int v14 = (*(_DWORD *)(v3 + 13432) * v8 / v10 + v12 - 1) & 7 | 0xFFFFFFD0;
    }
    int v15 = aj_encode_all(v3, v2, v14);
    *(_DWORD *)(a1 + 24) = v15;
    ++v4;
    if (v15)
    {
      aj_log_error((uint64_t)"Enc", "IO error in MT encode job, mcu rows %d to %d", *(_DWORD *)(v2 + 1824), *(_DWORD *)(v2 + 1828));
      return 0;
    }
  }
  return 0;
}

int *plugin_iosaccelerator_create(uint64_t a1, int *a2, uint64_t a3, int *a4)
{
  keys[1] = *(void **)MEMORY[0x263EF8340];
  int v7 = (int *)malloc_type_calloc(1uLL, 0xE8uLL, 0x106004020B7C528uLL);
  if (!v7)
  {
    int v12 = 6;
    goto LABEL_25;
  }
  mach_port_t v8 = *MEMORY[0x263F0EC88];
  CFDictionaryRef v9 = IOServiceMatching("AppleM2ScalerCSCDriver");
  io_service_t MatchingService = IOServiceGetMatchingService(v8, v9);
  CFDictionaryRef v11 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"IOSurfaceAcceleratorCapabilitiesDict", 0, 0);
  IOObjectRelease(MatchingService);
  if (!v11)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to get scaler capabilities");
    goto LABEL_24;
  }
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFilterVerticalTapsCount", keys)) {
    goto LABEL_21;
  }
  v7[2] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFilterHorizontalTapsCount", keys)) {
    goto LABEL_21;
  }
  v7[3] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFormatIn2Planes420", keys)) {
    goto LABEL_21;
  }
  *((unsigned char *)v7 + 16) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFormatOut2Planes420", keys)) {
    goto LABEL_21;
  }
  *((unsigned char *)v7 + 17) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFormatIn2Planes422", keys)) {
    goto LABEL_21;
  }
  *((unsigned char *)v7 + 18) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorFormatOut2Planes422", keys)) {
    goto LABEL_21;
  }
  *((unsigned char *)v7 + 19) = keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMinSourceWidth", keys)) {
    goto LABEL_21;
  }
  v7[5] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMinSourceHeight", keys)) {
    goto LABEL_21;
  }
  v7[6] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxSourceWidth", keys)) {
    goto LABEL_21;
  }
  v7[7] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxSourceHeight", keys)) {
    goto LABEL_21;
  }
  v7[8] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMinDestWidth", keys)) {
    goto LABEL_21;
  }
  v7[9] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMinDestHeight", keys)) {
    goto LABEL_21;
  }
  v7[10] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxDestWidth", keys)) {
    goto LABEL_21;
  }
  v7[11] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxDestHeight", keys)) {
    goto LABEL_21;
  }
  v7[12] = (int)keys[0];
  keys[0] = 0;
  if (get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxHUpscale", keys)
    || (v7[13] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxHDownscale", keys))
    || (v7[14] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxVUpscale", keys))
    || (v7[15] = (int)keys[0],
        keys[0] = 0,
        get_Int64_value(v11, @"IOSurfaceAcceleratorCapabilitiesMaxVDownscale", keys)))
  {
LABEL_21:
    aj_log_error((uint64_t)"IOSAPlugin", "Bailing from get_scaler_setup");
    CFRelease(v11);
LABEL_24:
    int v12 = 1;
    goto LABEL_25;
  }
  v7[16] = (int)keys[0];
  if (v7[2] != 9) {
    aj_log_error((uint64_t)"IOSAPlugin", "WARNING: Device is reporting v_taps != 9. This not fatal but may lead to artifacts in image. Please file a radar to CoreMedia JPEG Software|All with device and OS versions for verification.");
  }
  CFRelease(v11);
  if (v7[2] <= 0)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "vTaps is negative or zero: %d");
    goto LABEL_24;
  }
  if (v7[3] <= 0)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "hTaps is negative or zero: %d");
    goto LABEL_24;
  }
  int v14 = a2[4];
  int v12 = 3;
  if (v14 > 9)
  {
    if (v14 != 15)
    {
      if (v14 != 10) {
        goto LABEL_25;
      }
      if (!*((unsigned char *)v7 + 17) || !*((unsigned char *)v7 + 16))
      {
        aj_log_error((uint64_t)"IOSAPlugin", "Unsupported format: 420f");
        goto LABEL_25;
      }
    }
  }
  else if ((v14 - 3) >= 2)
  {
    if (v14 != 8) {
      goto LABEL_25;
    }
    if (!*((unsigned char *)v7 + 19) || !*((unsigned char *)v7 + 18))
    {
      aj_log_error((uint64_t)"IOSAPlugin", "Unsupported format: 422f");
      goto LABEL_25;
    }
  }
  int v15 = *a2;
  if (*a2 > v7[7] || v15 < v7[5])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Input width is outside the supported range: %d");
    goto LABEL_25;
  }
  int v16 = a2[2];
  if (v16 > v7[11] || v16 < v7[9])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Output width is outside the supported range: %d");
    goto LABEL_25;
  }
  if (v15 > v16 && v15 > v7[14] * v16 || v15 < v16 && v7[13] * v15 < v16)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Horizontal scaling factor is beyond the supported range: %d -> %d");
    goto LABEL_25;
  }
  int v17 = a2[1];
  if (v17 < v7[6])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Input height is smaller than the supported min: %d");
    goto LABEL_25;
  }
  int v18 = a2[3];
  if (v18 < v7[10])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Output height is smaller than the supported min: %d");
    goto LABEL_25;
  }
  if (a2[5] > v7[8])
  {
    aj_log_error((uint64_t)"IOSAPlugin", "max-input-rows is larger than the supported max: %d");
    goto LABEL_25;
  }
  if (v17 < v18)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Up-scaling vertically is currently not supported");
    goto LABEL_25;
  }
  if (v17 <= v18 || v17 <= v7[16] * v18)
  {
    int v19 = 0;
    if (v14 > 9)
    {
      if (v14 == 10)
      {
        uint64_t v20 = 0x234323066;
LABEL_74:
        int v19 = 1;
        int v21 = 2;
        goto LABEL_75;
      }
    }
    else if ((v14 - 3) >= 2)
    {
      if (v14 != 8) {
        goto LABEL_76;
      }
      uint64_t v20 = 0x134323266;
      goto LABEL_74;
    }
    int v19 = 0;
    uint64_t v20 = 0x142475241;
    int v21 = 1;
LABEL_75:
    *((void *)v7 + 18) = v20;
    v7[38] = v21;
LABEL_76:
    CFAllocatorRef v22 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    if (IOSurfaceAcceleratorCreate())
    {
      aj_log_error((uint64_t)"IOSAPlugin", "Unable to create the IOSurfaceAcceleratorRef");
    }
    else
    {
      unint64_t v23 = a2[3];
      unint64_t v24 = a2[1];
      unint64_t v25 = (v23 << 20) / v24;
      unint64_t v26 = (v24 << 20) / v23;
      *((void *)v7 + 24) = v25;
      *((void *)v7 + 25) = v26;
      *((void *)v7 + 26) = 0;
      int v27 = v7[6];
      if (v27 <= (int)((v26 * v7[10] + 0xFFFFF) >> 20)) {
        int v27 = (v26 * v7[10] + 0xFFFFF) >> 20;
      }
      int v28 = ((4 * v26 + 0xFFFFF) >> 20) + ((2 * v26 + 0xFFFFF) >> 20) + v27;
      v7[40] = v28;
      if (v7[37] == 2)
      {
        uint64_t v29 = v26 & 0x1FFFFF;
        if ((v26 & 0x1FFFFF) > 0x100000) {
          uint64_t v29 = 0x200000 - (v26 & 0x1FFFFF);
        }
        if (v29) {
          uint64_t v30 = 0x100000 / v29 + 1;
        }
        else {
          uint64_t v30 = 1;
        }
        int v32 = (((v30 * v26 + 0xFFFFF) >> 20) & 1) + ((v30 * v26 + 0xFFFFF) >> 20);
        int v31 = a2[5];
        if (v31 >= 0) {
          int v33 = a2[5];
        }
        else {
          int v33 = v31 + 1;
        }
        if (v32 <= v33 >> 1)
        {
          *((unsigned char *)v7 + 224) = 1;
          v28 += v32;
          v7[40] = v28;
        }
        else
        {
          *((unsigned char *)v7 + 224) = 0;
        }
      }
      else
      {
        *((unsigned char *)v7 + 224) = 0;
        int v31 = a2[5];
      }
      uint64_t v34 = v28 + v31;
      v7[39] = (v25 * v34 + 0xFFFFF) >> 20;
      if (v19) {
        unsigned int v35 = a2[2] & 1;
      }
      else {
        unsigned int v35 = 0;
      }
      IOSurfaceRef IOSurface = create_IOSurface(*a2, v34, v7[36]);
      *((void *)v7 + 21) = IOSurface;
      if (IOSurface)
      {
        IOSurfaceRef v37 = create_IOSurface(a2[2] + (unint64_t)v35, v7[39], v7[36]);
        *((void *)v7 + 22) = v37;
        if (v37)
        {
          v7[55] = 0;
          *((void *)v7 + 16) = *(void *)a2;
          *((void *)v7 + 17) = *((void *)a2 + 1);
          int valuePtr = 0;
          CFNumberRef v38 = CFNumberCreate(v22, kCFNumberIntType, &valuePtr);
          int v39 = (void *)*MEMORY[0x263F4B210];
          values = v38;
          keys[0] = v39;
          *((void *)v7 + 15) = CFDictionaryCreate(v22, (const void **)keys, (const void **)&values, 1, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
          CFRelease(v38);
          v7[28] = a2[2] + v35;
          v7[29] = 0;
          *((void *)v7 + 13) = 0;
          *((void *)v7 + 11) = (uint64_t)*a2 << 16;
          *((void *)v7 + 12) = 0;
          *((void *)v7 + 9) = 0;
          *((void *)v7 + 10) = 0;
          set_plugin_config((uint64_t)v7, a3);
          int v12 = 0;
          if (!a4) {
            return v7;
          }
          goto LABEL_26;
        }
        aj_log_error((uint64_t)"IOSAPlugin", "Couldn't create destination IOSurface");
      }
      else
      {
        aj_log_error((uint64_t)"IOSAPlugin", "Couldn't create source IOSurface");
      }
      if (*(void *)v7)
      {
        CFRelease(*(CFTypeRef *)v7);
        *(void *)int v7 = 0;
      }
      uint64_t v40 = (const void *)*((void *)v7 + 21);
      if (v40)
      {
        CFRelease(v40);
        *((void *)v7 + 21) = 0;
      }
      uint64_t v41 = (const void *)*((void *)v7 + 22);
      if (v41)
      {
        CFRelease(v41);
        *((void *)v7 + 22) = 0;
      }
      uint64_t v42 = (const void *)*((void *)v7 + 15);
      if (v42)
      {
        CFRelease(v42);
        *((void *)v7 + 15) = 0;
      }
    }
    goto LABEL_24;
  }
  aj_log_error((uint64_t)"IOSAPlugin", "Vertical scaling factor is beyond the supported range: %d -> %d");
LABEL_25:
  plugin_iosaccelerator_destroy(v7);
  int v7 = 0;
  if (a4) {
LABEL_26:
  }
    *a4 = v12;
  return v7;
}

size_t set_plugin_config(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = *(void *)(a1 + 156);
  *(_DWORD *)(a2 + 8) = 1;
  *(_DWORD *)(a2 + 80) = 1;
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
  *(unsigned char *)(a1 + 184) = 1;
  size_t result = IOSurfaceLock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
  *(unsigned char *)(a1 + 185) = 1;
  if (*(int *)(a1 + 152) >= 1)
  {
    int64_t v5 = 0;
    do
    {
      int v6 = (void *)(a2 + 8 * v5);
      v6[2] = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 168), v5);
      v6[6] = (int)IOSurfaceGetBytesPerRowOfPlane(*(IOSurfaceRef *)(a1 + 168), v5);
      v6[11] = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 176), v5);
      size_t result = IOSurfaceGetBytesPerRowOfPlane(*(IOSurfaceRef *)(a1 + 176), v5);
      v6[15] = (int)result;
      ++v5;
    }
    while (v5 < *(int *)(a1 + 152));
  }
  return result;
}

void plugin_iosaccelerator_destroy(void *a1)
{
  if (a1)
  {
    if (*((unsigned char *)a1 + 184))
    {
      uint64_t v2 = (__IOSurface *)a1[21];
      if (v2)
      {
        IOSurfaceUnlock(v2, 0, 0);
        *((unsigned char *)a1 + 184) = 0;
      }
    }
    if (*((unsigned char *)a1 + 185))
    {
      uint64_t v3 = (__IOSurface *)a1[22];
      if (v3)
      {
        IOSurfaceUnlock(v3, 1u, 0);
        *((unsigned char *)a1 + 185) = 0;
      }
    }
    if (*a1)
    {
      CFRelease((CFTypeRef)*a1);
      *a1 = 0;
    }
    int v4 = (const void *)a1[21];
    if (v4)
    {
      CFRelease(v4);
      a1[21] = 0;
    }
    int64_t v5 = (const void *)a1[22];
    if (v5)
    {
      CFRelease(v5);
      a1[22] = 0;
    }
    int v6 = (const void *)a1[15];
    if (v6) {
      CFRelease(v6);
    }
    free(a1);
  }
}

uint64_t plugin_iosaccelerator_resize(uint64_t a1, int *a2, _DWORD *a3, int a4)
{
  if (!a1) {
    return 1;
  }
  int v7 = *a2;
  int v8 = a2[1];
  int v9 = *(_DWORD *)(a1 + 220) + *a2;
  *(_DWORD *)(a1 + 220) = v9;
  int v10 = v8 + v7;
  if (a4)
  {
    LODWORD(v11) = *(_DWORD *)(a1 + 140) - *(_DWORD *)(a1 + 216);
    unint64_t v12 = *(void *)(a1 + 208);
    unint64_t v13 = ((uint64_t)v10 << 20) - v12;
  }
  else
  {
    int v15 = *(_DWORD *)(a1 + 132) - v9;
    int v16 = *(_DWORD *)(a1 + 24);
    BOOL v17 = __OFSUB__(v16, v15);
    int v18 = v16 - v15;
    if ((v18 < 0) ^ v17 | (v18 == 0)) {
      int v19 = 0;
    }
    else {
      int v19 = v18;
    }
    uint64_t v20 = *(void *)(a1 + 192);
    unint64_t v21 = *(int *)(a1 + 40);
    if (v21 > (unint64_t)(v20 * (v19 + v15)) >> 20) {
      int v19 = ((*(void *)(a1 + 200) * v21 + 0xFFFFF) >> 20) - v15;
    }
    LODWORD(v11) = ((unint64_t)(v20 * (v9 - v19) + 0x80000) >> 20) - *(_DWORD *)(a1 + 216);
    if (*(int *)(a1 + 148) >= 2)
    {
      LODWORD(v11) = v11 & 0xFFFFFFFE;
      if (*(unsigned char *)(a1 + 224))
      {
        int v22 = v11 + 2;
        do
          v22 -= 2;
        while (((*(void *)(a1 + 200) * v22) & 0x100000) != 0);
        if (v22) {
          LODWORD(v11) = v22;
        }
      }
    }
    unint64_t v12 = *(void *)(a1 + 208);
    unint64_t v13 = *(void *)(a1 + 200) * (int)v11;
  }
  *(void *)(a1 + 96) = v13 >> 4;
  *(_DWORD *)(a1 + 116) = v11;
  *(void *)(a1 + 80) = v12 >> 4;
  if (*(unsigned char *)(a1 + 184))
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
    *(unsigned char *)(a1 + 184) = 0;
  }
  if (*(unsigned char *)(a1 + 185))
  {
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
    *(unsigned char *)(a1 + 185) = 0;
  }
  uint64_t v23 = IOSurfaceAcceleratorTransformSurface();
  if (v23)
  {
    uint64_t v40 = v23;
    unint64_t v24 = "Rescaling error: 0x%X";
LABEL_23:
    aj_log_error((uint64_t)"IOSAPlugin", v24, v40);
    return 1;
  }
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 168), 0, 0);
  *(unsigned char *)(a1 + 184) = 1;
  IOSurfaceLock(*(IOSurfaceRef *)(a1 + 176), 1u, 0);
  *(unsigned char *)(a1 + 185) = 1;
  if (a4 || (int)v11 < 5)
  {
    unint64_t v25 = *(void *)(a1 + 208) + v13;
    *(void *)(a1 + 208) = v25;
    *(_DWORD *)(a1 + 216) += v11;
    if (a4)
    {
      int v26 = 0;
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v11 = (v11 - 4);
    unint64_t v25 = *(void *)(a1 + 208) + *(void *)(a1 + 200) * v11;
    *(_DWORD *)(a1 + 216) += v11;
  }
  int v27 = *(_DWORD *)(a1 + 148);
  if (v27 <= 1) {
    int v28 = v25 >> 20;
  }
  else {
    int v28 = (v25 >> 20) & 0xFFFFFFFE;
  }
  *(void *)(a1 + 208) = v25 - ((uint64_t)v28 << 20);
  int v26 = v10 - v28;
  uint64_t v29 = *(__IOSurface **)(a1 + 168);
  int PlaneCount = IOSurfaceGetPlaneCount(v29);
  if (v28) {
    BOOL v31 = v26 == 0;
  }
  else {
    BOOL v31 = 1;
  }
  if (!v31)
  {
    if (v27 == 2)
    {
      if (v26)
      {
        unint64_t v24 = "nrows is not even";
        goto LABEL_23;
      }
      if (v28)
      {
        unint64_t v24 = "Offset is not even";
        goto LABEL_23;
      }
    }
    if (PlaneCount >= 1)
    {
      uint64_t v41 = a3;
      size_t v32 = 0;
      int v33 = v27 >> 1;
      uint64_t v34 = PlaneCount;
      do
      {
        if (v32) {
          char v35 = v33;
        }
        else {
          char v35 = 0;
        }
        int v36 = v26 >> v35;
        int v37 = v28 >> v35;
        size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v29, v32);
        BaseAddressOfPlane = (char *)IOSurfaceGetBaseAddressOfPlane(v29, v32);
        memmove(BaseAddressOfPlane, &BaseAddressOfPlane[BytesPerRowOfPlane * v37], BytesPerRowOfPlane * v36);
        ++v32;
      }
      while (v34 != v32);
      a3 = v41;
    }
  }
LABEL_46:
  uint64_t result = 0;
  *a3 = v11;
  a3[1] = v26;
  return result;
}

uint64_t get_Int64_value(const __CFDictionary *a1, const void *a2, void *a3)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, a2);
  if (Value)
  {
    CFNumberGetValue(Value, kCFNumberSInt64Type, a3);
    return 0;
  }
  else
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to get value for key.");
    return 1;
  }
}

IOSurfaceRef create_IOSurface(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 > 1111970368)
  {
    if (a3 != 1111970369 && a3 != 1380401729) {
      goto LABEL_34;
    }
    int v6 = 0;
    int v9 = 0;
    unint64_t v7 = 1;
    CFIndex v8 = 1;
  }
  else
  {
    if (a3 != 875704422)
    {
      if (a3 == 875704934)
      {
        int v6 = 0;
        unint64_t v7 = 1;
        CFIndex v8 = 2;
        int v9 = 1;
        goto LABEL_9;
      }
LABEL_34:
      aj_log_error((uint64_t)"IOSAPlugin", "Only 420f, 422f and RGBA/BGRA are supported");
      return 0;
    }
    int v6 = 1;
    unint64_t v7 = 2;
    int v9 = 1;
    CFIndex v8 = 2;
  }
LABEL_9:
  CFMutableDataRef Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (!Mutable)
  {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to create options dictionary");
    return 0;
  }
  uint64_t v11 = Mutable;
  unint64_t v12 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
  set_int_value(Mutable, (const void *)*MEMORY[0x263F0EE48], a3);
  set_int_value(v11, (const void *)*MEMORY[0x263F0EF50], a1);
  set_int_value(v11, (const void *)*MEMORY[0x263F0EDF8], a2);
  CFMutableArrayRef v14 = CFArrayCreateMutable(0, v8, MEMORY[0x263EFFF70]);
  if (v14)
  {
    int v15 = v14;
    int v16 = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    if (v16)
    {
      BOOL v17 = v16;
      set_int_value(v16, (const void *)*MEMORY[0x263F0EF20], a1);
      set_int_value(v17, (const void *)*MEMORY[0x263F0EEE8], a2);
      if (v9) {
        int v18 = 1;
      }
      else {
        int v18 = 4;
      }
      char v19 = 2;
      if (v9) {
        char v20 = 0;
      }
      else {
        char v20 = 2;
      }
      if (v9) {
        char v19 = 0;
      }
      char v33 = v19;
      set_int_value(v17, (const void *)*MEMORY[0x263F0EE68], v18);
      int v34 = v6;
      int v21 = v9;
      unint64_t v22 = v7;
      uint64_t v23 = (const void *)*MEMORY[0x263F0EE70];
      set_int_value(v17, (const void *)*MEMORY[0x263F0EF08], 0);
      int v24 = v12 << v20;
      unint64_t v25 = (const void *)*MEMORY[0x263F0EF10];
      int v26 = v23;
      unint64_t v7 = v22;
      int v9 = v21;
      int v6 = v34;
      set_int_value(v17, v26, v24);
      int v27 = v25;
      unint64_t v13 = (a2 + 7) & 0xFFFFFFFFFFFFFFF8;
      set_int_value(v17, v27, (((a2 + 7) & 0xFFFFFFF8) * v12) << v33);
      CFArrayAppendValue(v15, v17);
      CFRelease(v17);
    }
    if (v9)
    {
      int v28 = CFDictionaryCreateMutable(0, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
      if (v28)
      {
        uint64_t v29 = v28;
        if (v6) {
          LODWORD(a2) = (unint64_t)(a2 + 1) >> 1;
        }
        set_int_value(v28, (const void *)*MEMORY[0x263F0EF20], (unint64_t)(a1 + 1) >> 1);
        set_int_value(v29, (const void *)*MEMORY[0x263F0EEE8], a2);
        set_int_value(v29, (const void *)*MEMORY[0x263F0EE68], 2);
        set_int_value(v29, (const void *)*MEMORY[0x263F0EF08], v13 * v12);
        set_int_value(v29, (const void *)*MEMORY[0x263F0EE70], v12);
        set_int_value(v29, (const void *)*MEMORY[0x263F0EF10], v13 / v7 * v12);
        CFArrayAppendValue(v15, v29);
        CFRelease(v29);
      }
    }
    CFDictionarySetValue(v11, (const void *)*MEMORY[0x263F0EF00], v15);
    CFRelease(v15);
  }
  if (v9) {
    unint64_t v30 = (v13 / v7 + v13) * v12;
  }
  else {
    LODWORD(v30) = 4 * v13 * v12;
  }
  set_int_value(v11, (const void *)*MEMORY[0x263F0ED30], v30);
  IOSurfaceRef v31 = IOSurfaceCreate(v11);
  if (!v31) {
    aj_log_error((uint64_t)"IOSAPlugin", "Unable to create an output surface");
  }
  CFRelease(v11);
  return v31;
}

void set_int_value(__CFDictionary *a1, const void *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  if (v5) {
    CFRelease(v5);
  }
}

void *aj_reset_mcustate(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0x700000000;
  return result;
}

uint64_t aj_init_component(uint64_t result, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v7 = result;
  uint64_t v8 = *(void *)result;
  uint64_t v9 = *(void *)result + 4 * a3;
  uint64_t v10 = *(void *)(result + 8) + 8;
  *(void *)(a2 + 32) = *(void *)(v10 + 16 * *(int *)(v9 + 3356));
  *(void *)(a2 + 40) = *(void *)(v10 + 16 * *(int *)(v9 + 3372) + 8);
  int v11 = *(_DWORD *)(result + 168);
  *(_DWORD *)(a2 + 712) = v11;
  if (a3 && !a5)
  {
    if (*(_DWORD *)(result + 6884) || v11 == 8)
    {
      if (!*(_DWORD *)(result + 6612) && *(unsigned char *)(result + 6888) && v11 != 1)
      {
        v11 >>= 1;
        goto LABEL_12;
      }
    }
    else if (*(_DWORD *)(v8 + 16) == 1 && *(_DWORD *)(v8 + 32) == 1)
    {
      v11 *= 2;
LABEL_12:
      *(_DWORD *)(a2 + 712) = v11;
    }
  }
  *(_DWORD *)(a2 + 536) = 8 / v11;
  if (*(unsigned char *)(v8 + 86)) {
    goto LABEL_32;
  }
  if (a4)
  {
    *(void *)(a2 + 704) = &glob_non_zigzag;
    *(void *)(a2 + 696) = &glob_non_zigzag_pm;
    uint64_t result = aj_init_QT_as_no_op(a2 + 48, 1);
    goto LABEL_32;
  }
  unint64_t v12 = (int *)(v8 + ((uint64_t)*(int *)(v8 + 4 * a3 + 48) << 8) + 88);
  if (v11 == 1) {
    unint64_t v13 = (int *)&aj_glob_zigzag_trans;
  }
  else {
    unint64_t v13 = aj_glob_zigzag;
  }
  CFMutableArrayRef v14 = &aj_glob_zigzag_pm;
  if (v11 == 1) {
    CFMutableArrayRef v14 = &aj_glob_zigzag_trans_pm;
  }
  *(void *)(a2 + 704) = v13;
  *(void *)(a2 + 696) = v14;
  int v15 = (_DWORD *)(a2 + 48);
  if (*(_DWORD *)(v8 + 4) == 12)
  {
    aj_init_QT_as_no_op(a2 + 48, v11);
    uint64_t result = (uint64_t)aj_init_QT_aanIDCT(v12, (_DWORD *)(a2 + 720), *(_DWORD *)(a2 + 712), v13);
    goto LABEL_32;
  }
  if (*(unsigned char *)(v8 + 84)) {
    int v16 = v13;
  }
  else {
    int v16 = (int *)&glob_non_zigzag;
  }
  uint64_t result = (uint64_t)aj_init_QT_aanIDCT(v12, v15, v11, v16);
  int v17 = *(_DWORD *)(v7 + 6680);
  if (v17 == 1)
  {
    if (a3) {
      goto LABEL_33;
    }
    goto LABEL_35;
  }
  if (v17 == 2 && *v12 >= 4 && *(int *)(*(void *)v7 + 8) <= 640 && !a3 && *(int *)(*(void *)v7 + 12) < 641)
  {
LABEL_35:
    if (*(_DWORD *)(a2 + 712) == 1) {
      uint64_t result = aj_mosquito_spray_enable(a2);
    }
    goto LABEL_37;
  }
LABEL_32:
  if (!a3)
  {
LABEL_37:
    int v18 = *(_DWORD *)(*(void *)(v7 + 8) + 88);
    goto LABEL_38;
  }
LABEL_33:
  int v18 = 1;
LABEL_38:
  *(_DWORD *)(a2 + 8) = v18;
  uint64_t v19 = v8 + 4 * a3;
  *(_DWORD *)a2 = *(_DWORD *)(v19 + 16);
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(v19 + 32);
  *(_DWORD *)(a2 + 12) = 0;
  return result;
}

uint64_t aj_compute_helpers(uint64_t a1)
{
  uint64_t v2 = *(int **)a1;
  uint64_t result = aj_get_format_description(*(_DWORD *)(a1 + 6580), a1 + 20);
  if (!result)
  {
    int v4 = *(unsigned __int8 *)(a1 + 6937);
    if (*(unsigned char *)(a1 + 6937)) {
      int v4 = *(_DWORD *)(a1 + 6940) == 0;
    }
    if (*(_DWORD *)(a1 + 20) == 1 && v4 == 0) {
      int v6 = 1;
    }
    else {
      int v6 = **(_DWORD **)a1;
    }
    *(_DWORD *)(a1 + 6464) = v6;
    *(_DWORD *)(a1 + 6468) = 0;
    unsigned int v7 = *(_DWORD *)(*(void *)(a1 + 8) + 88);
    *(_DWORD *)(a1 + 6472) = v7;
    *(int32x2_t *)(a1 + 6476) = vadd_s32(vdup_n_s32(v7), (int32x2_t)0x200000001);
    uint64_t v8 = *(unsigned int *)(a1 + 6484);
    int v9 = *(_DWORD *)(a1 + 6484) & 1;
    int v10 = *(_DWORD *)(a1 + 44);
    int v11 = *(_DWORD *)(a1 + 48);
    if (v10 <= 1) {
      int v9 = 0;
    }
    *(_DWORD *)(a1 + 6492) = v8 + v9;
    int v12 = *(_DWORD *)(a1 + 6488);
    if (v11 <= 1)
    {
      *(_DWORD *)(a1 + 6496) = v12;
    }
    else
    {
      *(_DWORD *)(a1 + 6496) = (*(_DWORD *)(a1 + 6488) & 1) + *(_DWORD *)(a1 + 6488);
      int v13 = *(_DWORD *)(a1 + 6504);
      if ((v13 & 1) != 0 && v13 < v12) {
        *(_DWORD *)(a1 + 6504) = v13 + 1;
      }
    }
    int v14 = *(_DWORD *)(a1 + 6500);
    if (v10 >= 2 && (v14 & 1) != 0 && v14 < (int)v8) {
      *(_DWORD *)(a1 + 6500) = ++v14;
    }
    compute_padding(v8, v14, v10, (unsigned int *)(a1 + 6592));
    *(_DWORD *)(a1 + 6596) = *(_DWORD *)(a1 + 6492) - (*(_DWORD *)(a1 + 6500) + *(_DWORD *)(a1 + 6592));
    compute_padding(*(unsigned int *)(a1 + 6488), *(_DWORD *)(a1 + 6504), *(_DWORD *)(a1 + 48), (unsigned int *)(a1 + 6584));
    int v15 = *(_DWORD *)(a1 + 6504);
    *(_DWORD *)(a1 + 6588) = *(_DWORD *)(a1 + 6496) - (v15 + *(_DWORD *)(a1 + 6584));
    int v16 = (const float *)(a1 + 28);
    int32x2_t v17 = (int32x2_t)vld1_dup_f32(v16);
    *(int32x2_t *)(a1 + 6600) = vmul_s32(*(int32x2_t *)(a1 + 6592), v17);
    int v18 = *(_DWORD **)(a1 + 8);
    int v19 = *(_DWORD *)(a1 + 168);
    int v21 = v18[18];
    int v20 = v18[19];
    *(_DWORD *)(a1 + 172) = v20 / v19;
    *(_DWORD *)(a1 + 176) = v21 / v19;
    int v22 = *(_DWORD *)(a1 + 6612);
    if (v22) {
      int v23 = 1 << (v22 + 3);
    }
    else {
      int v23 = v19;
    }
    int v24 = *(_DWORD *)(a1 + 6828) / v23;
    int v25 = *(_DWORD *)(a1 + 6832) / v23;
    int v26 = *(_DWORD *)(a1 + 6824);
    int v27 = v26 / v20;
    int v28 = v26 % v20;
    int v29 = (v23 - 1 + v20 - v26 % v20) / v23;
    if (v29 >= v25) {
      int v30 = *(_DWORD *)(a1 + 6832) / v23;
    }
    else {
      int v30 = v29;
    }
    int v31 = *(_DWORD *)(a1 + 6820);
    int v32 = v31 / v21;
    int v33 = v31 % v21;
    int v34 = (v23 - 1 + v21 - v31 % v21) / v23;
    if (v34 >= v24) {
      int v35 = *(_DWORD *)(a1 + 6828) / v23;
    }
    else {
      int v35 = v34;
    }
    int v36 = v25 - v30;
    int v37 = v24 - v35;
    int v38 = (v21 - 1 + (v24 - v35) * v23) / v21;
    int v39 = v38 + v32 + (v23 + v21 - 1) / v21;
    *(_DWORD *)(a1 + 6836) = v27;
    *(_DWORD *)(a1 + 6840) = (v20 - 1 + v36 * v23) / v20 + v27 + (v23 + v20 - 1) / v20;
    *(_DWORD *)(a1 + 6844) = v32;
    *(_DWORD *)(a1 + 6848) = v39;
    unint64_t v40 = (v38 + (v23 + v21 - 1) / v21) * v21;
    if (v39 == v18[20])
    {
      int v41 = *(_DWORD *)(*(void *)a1 + 8) % v21;
      if (v41) {
        v40 -= v21 - v41;
      }
    }
    *(_DWORD *)(a1 + 6900) = v40 / v23;
    *(_DWORD *)(a1 + 6616) = v24;
    *(_DWORD *)(a1 + 6620) = v25;
    *(_DWORD *)(a1 + 6624) = v22;
    int v42 = 1;
    if (v22 >= 1) {
      int v42 = (1 << v22) / *(_DWORD *)(*(void *)a1 + 32);
    }
    *(_DWORD *)(a1 + 6628) = v42;
    int v43 = v33 / v23;
    *(_DWORD *)(a1 + 6852) = v43;
    *(_DWORD *)(a1 + 6856) = v28 / v23;
    if (v21 <= v23)
    {
      int v44 = 1;
    }
    else if (v24 <= v34)
    {
      int v44 = v43 + v24;
    }
    else
    {
      int v44 = v21 / v23;
      if (v37 % v44) {
        int v44 = v37 % v44;
      }
    }
    *(_DWORD *)(a1 + 6860) = v44;
    if (v20 <= v23)
    {
      int v45 = 1;
    }
    else if (v25 <= v29)
    {
      int v45 = v28 / v23 + v25;
    }
    else
    {
      int v45 = v20 / v23;
      if (v36 % v45) {
        int v45 = v36 % v45;
      }
    }
    *(_DWORD *)(a1 + 6864) = v45;
    int v46 = *(_DWORD *)(a1 + 6500);
    *(unsigned char *)(a1 + 6577) = v24 != v46;
    *(unsigned char *)(a1 + 6576) = v25 != v15;
    int v47 = *(_DWORD *)(*(void *)a1 + 4);
    if (v47 <= 8)
    {
      BOOL v49 = v24 != v46 || v25 != v15;
      if (*(unsigned char *)(*(void *)a1 + 86) && v49) {
        goto LABEL_59;
      }
    }
    else if (v24 != v46 || v25 != v15)
    {
LABEL_59:
      aj_log_error((uint64_t)"DecodeInit", "Resizing is not supported for 12-bit or lossless jpegs");
      return 3;
    }
    BOOL v50 = *v2 == 3 && v2[4] == 2 && v2[8] == 2;
    uint64_t result = 0;
    *(unsigned char *)(a1 + 18) = v50;
    if (v47 <= 8) {
      int v51 = 1;
    }
    else {
      int v51 = 2;
    }
    *(_DWORD *)(a1 + 6800) = v51;
  }
  return result;
}

uint64_t compute_padding(uint64_t result, int a2, int a3, unsigned int *a4)
{
  int v4 = result - a2;
  int v5 = result - a2 + 1;
  if (v5 >= 0) {
    int v6 = v4 + 1;
  }
  else {
    int v6 = result - a2 + 2;
  }
  int v7 = v6 >> 1;
  if (v4 >= 0) {
    int v8 = result - a2;
  }
  else {
    int v8 = v4 + 1;
  }
  int v9 = ((v8 >> 1) & 1) + (v8 >> 1);
  if (a3 >= 2) {
    int v7 = v9;
  }
  if (v4 >= 0) {
    int v10 = result - a2;
  }
  else {
    int v10 = v4 + 1;
  }
  int v11 = v10 >> 1;
  if (v5 >= 0) {
    int v12 = v4 + 1;
  }
  else {
    int v12 = result - a2 + 2;
  }
  unsigned int v13 = (v12 >> 1) & 0xFFFFFFFE;
  if (a3 < 2) {
    unsigned int v13 = v11;
  }
  if ((result & 1) == 0) {
    unsigned int v13 = v7;
  }
  *a4 = v13;
  return result;
}

int *aj_calc_crop(int *result, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  if (a6)
  {
    unsigned int v7 = result[2];
    unsigned int v6 = result[3];
    int v9 = *result;
    int v8 = result[1];
    BOOL v12 = v6 == -1 && v7 == -1 && v9 == -1 && v8 == -1;
    if (v12) {
      int v8 = 0;
    }
    if (v12) {
      int v9 = 0;
    }
    if (v12) {
      unsigned int v7 = a2;
    }
    if (v12) {
      unsigned int v6 = a3;
    }
    int v13 = (int)(v7 << 15) / a4;
    int v14 = a4 + 2;
    if (a4 >= -1) {
      int v14 = a4 + 1;
    }
    unsigned int v15 = v7 * a5 + (v14 >> 1);
    int v16 = a5 + 2;
    if (a5 >= -1) {
      int v16 = a5 + 1;
    }
    unsigned int v17 = v6 * a4 + (v16 >> 1);
    int v18 = (int)(v6 << 15) / a5;
    int v19 = v17 / a5;
    BOOL v20 = v13 <= v18;
    if (v13 > v18) {
      unsigned int v21 = v19;
    }
    else {
      unsigned int v21 = v7;
    }
    unsigned int v22 = v15 / a4;
    if (!v20) {
      unsigned int v22 = v6;
    }
    if (v21 <= 1) {
      unsigned int v21 = 1;
    }
    if (v22 <= 1) {
      unsigned int v22 = 1;
    }
    BOOL v23 = __OFSUB__(v7, v21);
    int v24 = v7 - v21;
    signed int v25 = v6 - v22;
    if (v24 < 0 != v23) {
      ++v24;
    }
    *a6 = v9 + (v24 >> 1);
    a6[1] = v8 + v25 / 2;
    a6[2] = v21;
    a6[3] = v22;
  }
  return result;
}

uint64_t aj_calculate_dimensions(_DWORD *a1, uint64_t a2, int *a3, int *a4, int *a5, int *a6, _OWORD *a7, int *a8, int *a9)
{
  int v16 = a1 + 5;
  int v17 = a1[5];
  int v18 = a1 + 3;
  BOOL v20 = v16 + 1;
  int v19 = v16[1];
  if (v19 == -1 && v17 == -1)
  {
    if (*v18 == -1 && a1[4] == -1)
    {
      int v22 = *(_DWORD *)(a2 + 8);
      int v23 = *(_DWORD *)(a2 + 12);
      *(void *)&long long v61 = 0;
      *((void *)&v61 + 1) = __PAIR64__(v23, v22);
      int v17 = -1;
      goto LABEL_10;
    }
    int v17 = -1;
  }
  long long v61 = *(_OWORD *)v18;
  int v22 = v17;
  int v23 = v19;
LABEL_10:
  int v24 = a1[7];
  if (!v24 || (int v25 = a1[8]) == 0)
  {
    int v26 = a1[19];
    int v24 = v22 / v26;
    int v25 = v23 / v26;
LABEL_21:
    if (v26 >= 3)
    {
      if (v26 == 3)
      {
        int v28 = 0;
        int v26 = 2;
      }
      else if (v26 >= 8)
      {
        if (v26 > 0xF)
        {
          int v32 = v24;
          int v36 = v25;
LABEL_91:
          if (v32 <= v22 >> 5)
          {
            int v49 = 5;
            while (1)
            {
              int v28 = v49 - 4;
              if ((v49 - 4) > 9 || v36 > v23 >> v49) {
                break;
              }
              if (v32 > v22 >> ++v49)
              {
                int v28 = v49 - 4;
                goto LABEL_87;
              }
            }
          }
          else
          {
            int v28 = 1;
          }
          goto LABEL_87;
        }
        int v28 = 0;
        int v26 = 8;
      }
      else
      {
        int v28 = 0;
        int v26 = 4;
      }
    }
    else
    {
      int v28 = 0;
    }
    int v32 = v24;
    int v36 = v25;
    goto LABEL_103;
  }
  if (v22 >= v24)
  {
    int v26 = 1;
    int v27 = v22;
    do
    {
      if (v26 > 8 || v23 / v26 < v25) {
        break;
      }
      if (v27 == v24 && v23 / v26 == v25) {
        goto LABEL_21;
      }
      v26 *= 2;
      int v27 = v22 / v26;
    }
    while (v22 / v26 >= v24);
    if (v22 >= v24)
    {
      int v26 = 1;
      int v29 = v22;
      while (v23 / v26 >= v25)
      {
        if (v29 == v24 && v23 / v26 == v25) {
          goto LABEL_21;
        }
        ++v26;
        int v29 = v22 / v26;
        if (v22 / v26 < v24) {
          break;
        }
      }
    }
  }
  int v30 = a1[9];
  if (v30 == 1)
  {
    if (v19 == -1 && v17 == -1 && *v18 == -1 && a1[4] == -1)
    {
      int v52 = *(_DWORD *)(a2 + 8);
      int v53 = *(_DWORD *)(a2 + 12);
      if ((v52 << 15) / v24 <= (v53 << 15) / v25)
      {
        int v58 = v52 * v25;
        int v59 = v53 + 2;
        if (v53 >= -1) {
          int v59 = v53 + 1;
        }
        unsigned int v60 = v58 + (v59 >> 1);
        int v36 = v25;
        unsigned int v57 = v60 / v53;
      }
      else
      {
        int v54 = v53 * v24;
        int v55 = v52 + 2;
        if (v52 >= -1) {
          int v55 = v52 + 1;
        }
        unsigned int v56 = v54 + (v55 >> 1);
        unsigned int v57 = v24;
        int v36 = v56 / v52;
      }
      if (v57 <= 1) {
        int v32 = 1;
      }
      else {
        int v32 = v57;
      }
      if (v36 <= 1) {
        int v36 = 1;
      }
    }
    else
    {
      if ((v17 << 15) / v24 <= (v19 << 15) / v25)
      {
        int v37 = v19 + 2;
        if (v19 >= -1) {
          int v37 = v19 + 1;
        }
        unsigned int v38 = v17 * v25 + (v37 >> 1);
        unsigned int v33 = v25;
        int v32 = v38 / v19;
      }
      else
      {
        int v31 = v17 + 2;
        if (v17 >= -1) {
          int v31 = v17 + 1;
        }
        int v32 = a1[7];
        unsigned int v33 = (v24 * v19 + (v31 >> 1)) / v17;
      }
      if (v32 <= 1) {
        int v32 = 1;
      }
      if (v33 <= 1) {
        int v36 = 1;
      }
      else {
        int v36 = v33;
      }
    }
  }
  else
  {
    if (v30 == 3)
    {
      if (v19 == -1 && v17 == -1 && *v18 == -1 && a1[4] == -1)
      {
        int v16 = (unsigned int *)(a2 + 8);
        BOOL v20 = (unsigned int *)(a2 + 12);
      }
      unsigned int v34 = *v20;
      unsigned int v35 = *v16;
      if ((int)(*v16 << 15) / v24 <= (int)(*v20 << 15) / v25) {
        int v24 = v35 * v25 / v34;
      }
      else {
        int v25 = v34 * v24 / v35;
      }
      if (v24 <= 1) {
        int v24 = 1;
      }
      if (v25 <= 1) {
        int v25 = 1;
      }
    }
    else if (v30 == 2)
    {
      aj_calc_crop(v18, *(_DWORD *)(a2 + 8), *(_DWORD *)(a2 + 12), v24, v25, &v61);
      int v22 = DWORD2(v61);
      int v23 = HIDWORD(v61);
    }
    int v32 = v24;
    int v36 = v25;
  }
  int v39 = (v22 << 15) / v32;
  int v40 = (v23 << 15) / v36;
  BOOL v41 = v39 <= v40;
  if (v39 <= v40) {
    int v42 = v23;
  }
  else {
    int v42 = v22;
  }
  if (v41) {
    int v43 = v36;
  }
  else {
    int v43 = v32;
  }
  if (v41) {
    int v44 = v22;
  }
  else {
    int v44 = v23;
  }
  char v45 = -1;
  do
  {
    int v46 = v42 >> (v45 + 2);
    int v47 = v44 >> (v45 + 2);
    ++v45;
  }
  while (v46 >= v43 && v47 > 0);
  int v26 = 1 << v45;
  if (1 << v45 < 9)
  {
    int v28 = 0;
    goto LABEL_103;
  }
  if (v22 / v24 > 15 && v23 / v25 >= 16) {
    goto LABEL_91;
  }
  int v28 = 0;
LABEL_87:
  int v26 = 8;
LABEL_103:
  if (v24 < 1 || v25 < 1 || v32 < 1 || v36 < 1 || v32 > v24 || v36 > v25)
  {
    aj_log_error((uint64_t)"DecodeInit", "Out dimensions are invalid, check options", (void)v61);
    return 5;
  }
  else
  {
    if (a3) {
      *a3 = v24;
    }
    if (a4) {
      *a4 = v25;
    }
    if (a5) {
      *a5 = v32;
    }
    if (a6) {
      *a6 = v36;
    }
    if (a7) {
      *a7 = v61;
    }
    if (a8) {
      *a8 = v26;
    }
    uint64_t result = 0;
    if (a9) {
      *a9 = v28;
    }
  }
  return result;
}

uint64_t aj_init_decode_jobs(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v7 = a5;
  int v9 = a2;
  uint64_t v107 = *MEMORY[0x263EF8340];
  uint64_t v106 = 0;
  memset(v105, 0, sizeof(v105));
  int32x4_t v104 = a2;
  int v11 = *(_DWORD *)(a1 + 6948);
  if (v11 < 2) {
    goto LABEL_9;
  }
  uint64_t v13 = (v11 - 1);
  uint64_t v14 = *(void *)(a4 + 32);
  if (v14) {
    (*(void (**)(uint64_t, void))(a5 + 8))(v14, *(void *)(a5 + 16));
  }
  unsigned int v15 = (void *)(*(uint64_t (**)(uint64_t, void))v7)(1672 * v13, *(void *)(v7 + 16));
  *(void *)(a1 + 6952) = v15;
  *(void *)(a4 + 32) = v15;
  if (v15)
  {
    bzero(v15, 1672 * v13);
    uint64_t v16 = *(void *)(a1 + 6952);
    if (v16)
    {
      int v17 = (_DWORD *)(v16 + 16);
      int v18 = v105;
      do
      {
        *((void *)v17 - 1) = a1;
        _DWORD *v17 = *v9;
        *v18++ = v17;
        v17 += 418;
        --v13;
      }
      while (v13);
      int v11 = *(_DWORD *)(a1 + 6948);
LABEL_9:
      int v19 = *(_DWORD *)(a1 + 6840);
      int v20 = *(_DWORD *)(a1 + 6836);
      int v21 = v19 - v20;
      if (*(_DWORD *)(a1 + 6960) == 1)
      {
        int v22 = *(_DWORD *)(a1 + 168);
        if (v22 <= 8) {
          int v23 = (_DWORD *)((char *)&unk_21040AC58 + 4 * v22 - 4);
        }
        else {
          int v23 = &unk_21040AC74;
        }
        int v24 = *v23 * v21 / 100;
      }
      else
      {
        int v24 = v21 / v11;
      }
      if (*(_DWORD *)(a1 + 6612)) {
        int v25 = 1;
      }
      else {
        int v25 = *(_DWORD *)(a1 + 172);
      }
      v9[6] = v20;
      uint64_t v27 = v11;
      if (v11 >= 2)
      {
        int v28 = v24 + v20;
        uint64_t v29 = v11 - 1;
        int v30 = v105;
        do
        {
          v9[7] = v28;
          int v31 = (_DWORD *)*v30++;
          int v9 = v31;
          v31[6] = v28;
          v28 += v24;
          --v29;
        }
        while (v29);
      }
      BOOL v32 = __OFSUB__(v11, 1);
      uint64_t v33 = (v11 - 1);
      (&v104)[(int)v33][7] = v19;
      if ((int)v33 < 0 == v32)
      {
        uint64_t v34 = 0;
        int v35 = *(_DWORD *)(a1 + 6844);
        int v36 = *(_DWORD *)(a1 + 6628);
        uint64_t v37 = a3 + 140;
        do
        {
          int v38 = 0;
          int v39 = (&v104)[v34];
          int v40 = v39[6];
          int v41 = v39[7];
          v39[20] = v40;
          v39[21] = v35;
          unsigned int v42 = (v41 - v40) / v36;
          *(void *)(v39 + 15) = v42;
          if (!v34) {
            int v38 = *(_DWORD *)(a1 + 6856);
          }
          int v43 = v42 * v25;
          v39[18] = v38;
          v39[19] = v43;
          if (v34 == v33)
          {
            v39[19] = v43 - v25 + *(_DWORD *)(a1 + 6864);
            if (!v34) {
              int v40 = 0;
            }
            v39[2] = v40;
            int v41 = *(_DWORD *)(*(void *)(a1 + 8) + 84);
          }
          else
          {
            if (!v34) {
              int v40 = 0;
            }
            v39[2] = v40;
          }
          v39[3] = v41;
          if (*v39)
          {
            int v44 = *(_DWORD *)(a3 + 112);
            unsigned int v45 = (v40 + v44 - 1) / v44;
            *(void *)(v39 + 13) = v45;
            v39[11] = v45 * v44;
            v39[12] = 0;
            *((void *)v39 + 2) = 0;
            if (*(_DWORD *)(a3 + 136) == 1)
            {
              uint64_t v46 = 0;
              while (1)
              {
                int v47 = *(unsigned __int16 *)(v37 + v46);
                if (v40 <= v47 && v41 > v47) {
                  break;
                }
                v46 += 24;
                if (v46 == 216) {
                  goto LABEL_43;
                }
              }
              *((void *)v39 + 2) = v37 + v46;
            }
          }
LABEL_43:
          v39[380] = v39[374];
          ++v34;
        }
        while (v34 != v27);
      }
      if (a6) {
        return 0;
      }
      int v49 = (void *)(a1 + 6892);
      BOOL v50 = *(_DWORD *)(a1 + 24) == 2 && *(_DWORD *)(a1 + 48) > 1;
      BOOL v88 = *(unsigned char *)(a1 + 6937) && !*(_DWORD *)(a1 + 6940) && *(_DWORD *)(a1 + 6464) == 3;
      int v51 = *(_DWORD *)(a1 + 6584);
      int v52 = aj_highest_set_bit(*(_DWORD *)(a1 + 6892));
      int v53 = aj_highest_set_bit(*(_DWORD *)(a1 + 6896));
      int v54 = *(_DWORD *)(a1 + 6612) ? 1 : *(_DWORD *)(a1 + 172);
      int v91 = v54;
      unsigned int v55 = *(_DWORD *)(a1 + 6900);
      uint64_t v103 = 0;
      LODWORD(v56) = *(_DWORD *)(a1 + 6948);
      if ((int)v56 <= 0) {
        return 0;
      }
      uint64_t v57 = 0;
      int16x8_t v92 = (unsigned char *)(a1 + 6576);
      int v90 = v53 - 1;
      int v58 = (int)(v55 + v52 - 1) >> (v52 - 1);
      BOOL v59 = v88;
      BOOL v87 = v50;
      unsigned int v89 = v55;
      while (1)
      {
        uint64_t v60 = (uint64_t)(&v104)[v57];
        int v61 = *(_DWORD *)(v60 + 60) * v91;
        *(void *)&long long v96 = *v49;
        *((void *)&v96 + 1) = __PAIR64__(v58, v55);
        int v97 = v58;
        int v98 = v58;
        int v99 = v61;
        int v100 = (v61 + v90) >> v90;
        int v101 = v100;
        int v102 = v100;
        *(_DWORD *)(v60 + 32) = v51;
        *(_DWORD *)(v60 + 36) = v51;
        if (v57)
        {
          if (v50)
          {
            int v62 = HIDWORD(v103);
            if (v51 & 1 | HIDWORD(v103)) {
              goto LABEL_64;
            }
          }
          else
          {
            int v62 = HIDWORD(v103);
            if (HIDWORD(v103))
            {
LABEL_64:
              uint64_t v63 = v7;
              if (v62 <= 1) {
                int v64 = 1;
              }
              else {
                int v64 = v62;
              }
              if (*(int *)(a1 + 6464) >= 1)
              {
                uint64_t v65 = 0;
                do
                {
                  if (v65) {
                    int v66 = aj_highest_set_bit(DWORD1(v96)) - 1;
                  }
                  else {
                    int v66 = 0;
                  }
                  *(_DWORD *)(v60 + 1100 + 4 * v65++) = (v66 + v64) >> v66;
                }
                while (v65 < *(int *)(a1 + 6464));
              }
              uint64_t v7 = v63;
              uint64_t v67 = aj_bufferprocessor_append(a1, v60, v63, &aj_savefirst_processor, &v96);
              int v49 = (void *)(a1 + 6892);
              BOOL v50 = v87;
              BOOL v59 = v88;
              if (!v67) {
                return 6;
              }
            }
          }
        }
        if (*(unsigned char *)(a1 + 6889) && !aj_bufferprocessor_append(a1, v60, v7, &aj_upsample422_processor, &v96)) {
          return 6;
        }
        if (*(int *)(v60 + 72) > 0 || *(_DWORD *)(v60 + 76) < *(_DWORD *)(v60 + 60) * v91 || *(_DWORD *)(a1 + 6868))
        {
          if (!aj_bufferprocessor_append(a1, v60, v7, &aj_crop_processor, &v96)) {
            return 6;
          }
        }
        else if (DWORD2(v96) != *(_DWORD *)(a1 + 6616))
        {
          DWORD2(v96) = *(_DWORD *)(a1 + 6616);
          int v71 = aj_highest_set_bit(v96);
          uint64_t v72 = 0;
          int v73 = (*(_DWORD *)(a1 + 6616) + v71 - 1) >> (v71 - 1);
          do
          {
            *(_DWORD *)((char *)&v96 + v72 + 12) = v73;
            v72 += 4;
          }
          while (v72 != 12);
        }
        if (v59 && !aj_bufferprocessor_append(a1, v60, v7, &aj_rgb2yuv_processor, &v96)) {
          return 6;
        }
        if (*(unsigned char *)(a1 + 6577) || *v92)
        {
          uint64_t v68 = aj_bufferprocessor_append(a1, v60, v7, aj_resize_processor, &v96);
          if (!v68) {
            return 6;
          }
          aj_bufferproc_resize_get_blendrows(v68, a1, v60, (_DWORD *)&v103 + 1, &v103);
        }
        *(void *)&long long v93 = *(void *)(a1 + 6928);
        *((void *)&v93 + 1) = aj_icol_max_rows_out;
        uint64_t v94 = 0;
        uint64_t v95 = 0;
        if (!aj_bufferprocessor_append(a1, v60, v7, &v93, &v96)) {
          return 6;
        }
        v51 += v99 + v103;
        if (v57 == v56 - 1)
        {
          char v69 = 1;
          unsigned int v55 = v89;
        }
        else
        {
          unsigned int v55 = v89;
          BOOL v70 = (v50 & v51 & 1) != 0 || *v92 != 0;
          char v69 = !v70;
        }
        *(unsigned char *)(v60 + 1083) = v69;
        ++v57;
        uint64_t v56 = *(int *)(a1 + 6948);
        if (v57 >= v56)
        {
          if ((int)v56 >= 1)
          {
            uint64_t v74 = 0;
LABEL_101:
            int v75 = *(_DWORD *)(a1 + 6464);
            if (v75 >= 1)
            {
              uint64_t v76 = 0;
              int16x8_t v77 = (&v104)[v74];
              int16x8_t v78 = v77 + 38;
              int16x8_t v79 = v77 + 275;
              int16x8_t v80 = (uint64_t *)(a1 + 6712);
              do
              {
                uint64_t v81 = *(v80 - 1) + (int)v79[v76];
                if (v81)
                {
                  uint64_t result = aj_rowbuffer_add_block(v78, (uint64_t (**)(size_t, void))v7, *v80, v81, 0x10uLL);
                  if (result) {
                    return result;
                  }
                  int v75 = *(_DWORD *)(a1 + 6464);
                }
                ++v76;
                v80 += 2;
              }
              while (v76 < v75);
            }
            uint64_t v82 = 0;
            char v83 = 1;
            while (1)
            {
              char v84 = v83;
              uint64_t v85 = a1 + 16 * v82;
              uint64_t v86 = *(void *)(v85 + 6768);
              if (v86)
              {
                uint64_t result = aj_rowbuffer_add_block((&v104)[v74] + 38, (uint64_t (**)(size_t, void))v7, *(void *)(v85 + 6776), v86, 4uLL);
                if (result) {
                  return result;
                }
              }
              char v83 = 0;
              uint64_t v82 = 1;
              if ((v84 & 1) == 0)
              {
                uint64_t result = 0;
                if (++v74 < *(int *)(a1 + 6948)) {
                  goto LABEL_101;
                }
                return result;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  aj_log_error((uint64_t)"DecodeInit", "Could not allocate thread instances");
  return 6;
}

uint64_t aj_decode_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10, int a11, char a12, unsigned int a13)
{
  uint64_t v111 = a1;
  uint64_t v112 = a2;
  uint64_t v132 = *MEMORY[0x263EF8340];
  uint64_t v18 = a3 + 6888;
  unsigned __int8 v113 = 0;
  reset_decode_job(a5);
  bzero((void *)a3, 0x1B40uLL);
  *(unsigned char *)(a3 + 17) = a12;
  BOOL v19 = 1;
  *(unsigned char *)(a3 + 16) = 1;
  *(void *)a3 = a6;
  *(void *)(a3 + 8) = a4;
  if (*(_DWORD *)(a8 + 24) == -1 && *(_DWORD *)(a8 + 20) == -1 && *(_DWORD *)(a8 + 12) == -1) {
    BOOL v19 = *(_DWORD *)(a8 + 16) != -1;
  }
  *(void *)(v18 + 4) = 0x100000001;
  *(unsigned char *)(v18 + 16) = *(unsigned char *)(a8 + 152);
  if (a6[852])
  {
    *(unsigned char *)(v18 + 49) = 1;
    int v20 = *(unsigned __int8 *)(a8 + 136);
  }
  else
  {
    int v20 = *(unsigned __int8 *)(a8 + 136);
    *(unsigned char *)(v18 + 49) = *(unsigned char *)(a8 + 136) != 0;
    if (!v20) {
      goto LABEL_12;
    }
  }
  if (v20) {
    int v21 = (_DWORD *)(a8 + 140);
  }
  else {
    int v21 = a6 + 853;
  }
  *(_DWORD *)(a3 + 6940) = *v21;
LABEL_12:
  *(unsigned char *)(v18 + 56) = *(unsigned char *)(a8 + 144);
  int v22 = *(_DWORD *)(a8 + 80);
  *(_DWORD *)(a3 + 6808) = v22;
  unsigned int v23 = *(_DWORD *)(a3 + 6804) & 0xFFFFFFFC | (v22 / 90);
  *(_DWORD *)(a3 + 6804) = v23;
  if (*(_DWORD *)(a8 + 84))
  {
    v23 |= 4u;
    *(_DWORD *)(a3 + 6804) = v23;
  }
  if (*(_DWORD *)(a8 + 88)) {
    *(_DWORD *)(a3 + 6804) = v23 | 8;
  }
  *(_DWORD *)(a3 + 6608) = *(_DWORD *)(a8 + 72);
  int v24 = (_DWORD *)(a3 + 168);
  uint64_t result = aj_calculate_dimensions((_DWORD *)a8, (uint64_t)a6, (int *)(a3 + 6484), (int *)(a3 + 6488), (int *)(a3 + 6500), (int *)(a3 + 6504), (_OWORD *)(a3 + 6820), (int *)(a3 + 168), (int *)(a3 + 6612));
  if (!result)
  {
    *(_DWORD *)(a3 + 6812) = v19;
    if (*(_DWORD *)(a3 + 6828) == a6[2] && *(_DWORD *)(a3 + 6832) == a6[3])
    {
      *(_DWORD *)(a3 + 6816) = 0;
    }
    else
    {
      *(_DWORD *)(a3 + 6816) = 1;
      if (*((unsigned char *)a6 + 86))
      {
        aj_log_error((uint64_t)"DecodeInit", "Cropping is not supported for lossless JPEG");
        return 5;
      }
    }
    *(_DWORD *)a5 = *(_DWORD *)(a8 + 100);
    if (*((unsigned char *)a6 + 84) || *((unsigned char *)a6 + 86)) {
      *(_DWORD *)a5 = 0;
    }
    for (uint64_t i = 0; i != 32; i += 8)
      *(void *)(a3 + i + 128) = *(void *)(a8 + i + 40);
    int v28 = *(_DWORD *)(a8 + 8);
    *(_DWORD *)(a3 + 6580) = v28;
    uint64_t v29 = *(int *)(a8 + 96);
    if (v29 < 5)
    {
      *(_DWORD *)(a3 + 6884) = dword_21040AC78[v29];
      *(_DWORD *)(a3 + 6680) = *(_DWORD *)(a8 + 148);
      *(_DWORD *)(a5 + 1496) = *(_DWORD *)(a8 + 112);
      *(_OWORD *)(a5 + 1504) = *(_OWORD *)(a8 + 120);
      if (v28 == 14)
      {
        uint64_t result = aj_get_texture_size(a6, a8, a3 + 6512, *(unsigned __int8 *)(*(void *)(a3 + 8) + 356), 0, 0, 0);
        if (result) {
          return result;
        }
      }
      uint64_t result = aj_compute_helpers(a3);
      if (result) {
        return result;
      }
      if (a11 != 1)
      {
        int v30 = *(_DWORD *)(a3 + 24);
        if (v30 != a11)
        {
          aj_log_error((uint64_t)"DecodeInit", "Number of output planes (%d) must be either 1 or %d\n", a11, v30);
          return 8;
        }
      }
      int v31 = *(_DWORD *)(a3 + 6808);
      int v32 = *(_DWORD *)(a3 + 6580);
      if ((v32 - 25) > 1)
      {
        int v41 = *(_DWORD *)(a3 + 24);
        if (v41 == 3)
        {
          unsigned int v42 = *(_DWORD **)a3;
          if (*(_DWORD *)(a3 + 168) == 8 || *v42 == 1)
          {
            *(_DWORD *)(a3 + 44) = v42[4];
            int v43 = v42[8];
          }
          else
          {
            int v43 = 2;
            *(_DWORD *)(a3 + 44) = 2;
          }
          *(_DWORD *)(a3 + 48) = v43;
          uint64_t v48 = *(void *)(a3 + 128);
          if (!v48) {
            uint64_t v48 = *(void *)(a3 + 6512);
          }
          *(void *)(a3 + 96) = v48;
          uint64_t v49 = *(void *)(a3 + 136);
          if (!v49) {
            uint64_t v49 = *(void *)(a3 + 6544);
          }
          *(void *)(a3 + 104) = v49;
          uint64_t v50 = *(void *)(a3 + 144);
          if (!v50) {
            uint64_t v50 = *(void *)(a3 + 6544);
          }
          *(void *)(a3 + 112) = v50;
        }
        else
        {
          if (v31 == 270 || v31 == 90) {
            uint64_t v44 = 6496;
          }
          else {
            uint64_t v44 = 6492;
          }
          unint64_t v45 = *(int *)(a3 + v44);
          uint64_t v46 = *(void *)(a3 + 128);
          if (!v46) {
            uint64_t v46 = *(int *)(a3 + 28) * (uint64_t)(int)v45;
          }
          *(void *)(a3 + 96) = v46;
          if (v41 == 2)
          {
            unint64_t v47 = *(void *)(a3 + 136);
            if (!v47) {
              unint64_t v47 = v45 / *(int *)(a3 + 44) * *(int *)(a3 + 32);
            }
            *(void *)(a3 + 104) = v47;
          }
        }
      }
      else
      {
        uint64_t v33 = 0;
        uint64_t v34 = *(_DWORD **)a3;
        uint64_t v35 = *(void *)(a3 + 8);
        *(_DWORD *)(a3 + 44) = *(_DWORD *)(*(void *)a3 + 16);
        *(_DWORD *)(a3 + 48) = v34[8];
        int v36 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))*(int *)(v35 + 80);
        int64x2_t v114 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))(*(int *)(v35 + 72) * (uint64_t)(int)v36);
        int64x2_t v115 = v36;
        int16x8_t v116 = v36;
        uint64_t v37 = (uint64_t *)(a3 + 128);
        int v38 = (uint64_t *)(a3 + 128);
        do
        {
          uint64_t v40 = *v38++;
          uint64_t v39 = v40;
          if (!v40) {
            uint64_t v39 = (void)*(&v114 + v33) * *(int *)(a3 + 28 + 4 * v33);
          }
          *(v37 - 4) = v39;
          ++v33;
          uint64_t v37 = v38;
        }
        while (v33 != 3);
      }
      if (a11 >= 1)
      {
        int v51 = (void *)(a3 + 64);
        uint64_t v52 = a11;
        do
        {
          uint64_t v53 = *a10;
          a10 += 2;
          *v51++ = v53;
          --v52;
        }
        while (v52);
      }
      int v54 = *(_DWORD *)(a3 + 24);
      if (v54 > a11)
      {
        if (v54 == 2)
        {
          if (v31 == 270 || v31 == 90) {
            uint64_t v55 = 6492;
          }
          else {
            uint64_t v55 = 6496;
          }
          *(void *)(a3 + 72) = *(void *)(a3 + 64) + *(void *)(a3 + 96) * *(int *)(a3 + v55);
LABEL_93:
          BOOL v70 = *(_DWORD **)a3;
          int v71 = *(_DWORD *)(*(void *)a3 + 16);
          int v72 = *(_DWORD *)(*(void *)a3 + 32);
          BOOL v74 = v71 == 2 && v72 == 2;
          BOOL v75 = *(_DWORD *)(a3 + 44) == 2 && *(_DWORD *)(a3 + 48) == 2;
          int v76 = *(_DWORD *)(a3 + 6580);
          if ((v76 - 25) < 2) {
            goto LABEL_124;
          }
          if (*(unsigned char *)(v18 + 49) && *(_DWORD *)(a3 + 6940) != 1 || v76 == 15 || *v70 == 4) {
            *(_DWORD *)(a3 + 6884) = 2;
          }
          if (v76 == 14) {
            *(_DWORD *)(a3 + 6884) = 0;
          }
          if (!v74) {
            goto LABEL_244;
          }
          if (*(_DWORD *)(a3 + 6884) != 2) {
            *(_DWORD *)(a3 + 6884) = 0;
          }
          if (v75)
          {
            int v77 = 0;
          }
          else
          {
LABEL_244:
            if (*v24 != 8 || *(_DWORD *)(a3 + 6884)) {
              goto LABEL_119;
            }
            int v77 = 1;
          }
          *(_DWORD *)(a3 + 6884) = v77;
LABEL_119:
          if (*(_DWORD *)(a3 + 6612))
          {
            *(_DWORD *)(a3 + 6884) = 2;
LABEL_123:
            *(unsigned char *)uint64_t v18 = 1;
            goto LABEL_124;
          }
          int v78 = *(_DWORD *)(a3 + 6884);
          if (v78 == 2 && v72 == 2) {
            goto LABEL_123;
          }
          if (v78 == 2 && v71 == 2 && *(_DWORD *)(a3 + 20) != 1)
          {
            *(unsigned char *)(v18 + 1) = 1;
            *(void *)(a3 + 6704) += 2;
          }
LABEL_124:
          long long v130 = 0u;
          long long v131 = 0u;
          if (v70[1] == 12)
          {
            int16x8_t v79 = aj_idct_s1_12bit;
            *(void *)&long long v130 = aj_idct_s1_12bit;
            *((void *)&v130 + 1) = aj_idct_s2_12bit;
            *(void *)&long long v131 = aj_idct_s4_12bit;
            *((void *)&v131 + 1) = aj_idct_s8_12bit;
            int v80 = *(_DWORD *)(a3 + 6884);
            if (v80) {
              uint64_t v81 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_12bit;
            }
            else {
              uint64_t v81 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s2_12bit;
            }
            if (v80) {
              uint64_t v82 = aj_idct_s2_12bit;
            }
            else {
              uint64_t v82 = aj_idct_s4_12bit;
            }
            int64x2_t v114 = v81;
            if (v80) {
              char v83 = aj_idct_s4_12bit;
            }
            else {
              char v83 = aj_idct_s8_12bit;
            }
            int16x8_t v121 = v81;
            int16x8_t v122 = v83;
            int16x8_t v125 = v82;
            int16x8_t v126 = aj_idct_s8_12bit;
            char v84 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_16x16_bilinear_12bit;
            if (!v80) {
              char v84 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_12bit;
            }
            int16x8_t v117 = v84;
            int16x8_t v118 = v82;
            int16x8_t v128 = aj_idct_s8_12bit;
            int16x8_t v129 = (uint64_t (*)(unsigned int *, void *, uint64_t))v83;
            if (!v80) {
              int16x8_t v79 = aj_idct_s1_4x8_12bit;
            }
            int16x8_t v116 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))v79;
            if (v80) {
              uint64_t v85 = aj_idct_s2_12bit;
            }
            else {
              uint64_t v85 = aj_idct_s2_2x4_12bit;
            }
            int16x8_t v120 = v85;
            if (v80) {
              uint64_t v86 = aj_idct_s4_12bit;
            }
            else {
              uint64_t v86 = aj_idct_s4_1x2_12bit;
            }
            v124 = v86;
            BOOL v87 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_16x8_bilinear_12bit;
            BOOL v88 = aj_idct_s1_8x4_12bit;
            if (!v80) {
              BOOL v87 = (uint64_t (*)(int16x8_t *, uint64_t *, uint64_t))aj_idct_s1_8x4_12bit;
            }
            int64x2_t v115 = v87;
            unsigned int v89 = aj_idct_s2_4x2_12bit;
            if (!v80) {
              BOOL v88 = aj_idct_s2_4x2_12bit;
            }
            int16x8_t v119 = v88;
            if (v80)
            {
              int v90 = (uint64_t (*)(__int16 *, void *, int))aj_idct_s4_2x1_12bit;
            }
            else
            {
              unsigned int v89 = aj_idct_s4_2x1_12bit;
              int v90 = (uint64_t (*)(__int16 *, void *, int))aj_idct_s8_12bit;
            }
            int16x8_t v123 = v89;
            int16x8_t v127 = v90;
            if (v80)
            {
              int v91 = 1;
              int v92 = 1;
              if (v70[8] == 1)
              {
                if (v70[4] == 2) {
                  int v92 = 2;
                }
                else {
                  int v92 = 1;
                }
              }
            }
            else if (*v24 == 8)
            {
              int v91 = v70[8];
              int v92 = v70[4];
            }
            else
            {
              int v91 = 2;
              int v92 = 2;
            }
          }
          else
          {
            *(void *)&long long v130 = aj_idct_s1;
            *((void *)&v130 + 1) = aj_idct_s2;
            *(void *)&long long v131 = aj_idct_s4;
            *((void *)&v131 + 1) = aj_idct_s8;
            int v93 = *(_DWORD *)(a3 + 6884);
            if (v93)
            {
              int64x2_t v114 = aj_idct_s1;
              int16x8_t v118 = aj_idct_s2;
              int16x8_t v122 = aj_idct_s4;
              int16x8_t v126 = aj_idct_s8;
              int v91 = v70[8];
              int v92 = 1;
              if (v93 == 2)
              {
                if (v91 == 1)
                {
                  if (v70[4] == 2) {
                    int v92 = 2;
                  }
                  else {
                    int v92 = 1;
                  }
                }
                int64x2_t v115 = aj_idct_s1_16x8_bilinear;
                int16x8_t v116 = aj_idct_s1;
                int16x8_t v117 = aj_idct_s1_16x16_bilinear;
                int16x8_t v119 = aj_idct_s1_8x4;
                int16x8_t v120 = aj_idct_s2;
                int16x8_t v121 = aj_idct_s1;
                int16x8_t v123 = aj_idct_s2_4x2;
                v124 = aj_idct_s4;
                int16x8_t v125 = aj_idct_s2;
                int16x8_t v127 = aj_idct_s4_2x1;
                int16x8_t v128 = aj_idct_s8;
                int16x8_t v129 = aj_idct_s4;
                int v91 = 1;
                goto LABEL_181;
              }
              if (v76 == 14 && *v24 == 8) {
                int v92 = v70[4];
              }
              int64x2_t v115 = aj_idct_s1;
              int16x8_t v116 = aj_idct_s1_8x16_nearest;
              int16x8_t v117 = aj_idct_s1_8x16_nearest;
              int16x8_t v119 = aj_idct_s2;
              int16x8_t v120 = aj_idct_s2_4x8_nearest;
              int16x8_t v121 = aj_idct_s2_4x8_nearest;
              int16x8_t v123 = aj_idct_s4;
              v124 = aj_idct_s4_2x4_nearest;
              int16x8_t v125 = aj_idct_s4_2x4_nearest;
              uint64_t v94 = aj_idct_s8;
              int16x8_t v127 = aj_idct_s8;
              if (v76 != 14) {
                uint64_t v94 = aj_idct_s8_1x2_nearest;
              }
            }
            else
            {
              if (*v24 == 8)
              {
                int v91 = v70[8];
                int v92 = v70[4];
              }
              else
              {
                int v91 = 2;
                int v92 = 2;
              }
              int64x2_t v114 = aj_idct_s2;
              int64x2_t v115 = aj_idct_s1_8x4;
              int16x8_t v116 = aj_idct_s1_4x8;
              int16x8_t v117 = aj_idct_s1;
              int16x8_t v118 = aj_idct_s4;
              int16x8_t v119 = aj_idct_s2_4x2;
              int16x8_t v120 = aj_idct_s2_2x4;
              int16x8_t v121 = aj_idct_s2;
              uint64_t v94 = aj_idct_s8;
              int16x8_t v122 = aj_idct_s8;
              int16x8_t v123 = aj_idct_s4_2x1;
              v124 = aj_idct_s4_1x2;
              int16x8_t v125 = aj_idct_s4;
              int16x8_t v126 = aj_idct_s8;
              int16x8_t v127 = aj_idct_s8;
            }
            int16x8_t v128 = v94;
            int16x8_t v129 = (uint64_t (*)(unsigned int *, void *, uint64_t))v94;
          }
LABEL_181:
          uint64_t v95 = (int)aj_highest_set_bit(*(_DWORD *)(a3 + 168)) - 1;
          int v96 = aj_highest_set_bit(*(_DWORD *)(*(void *)a3 + 16));
          int v97 = aj_highest_set_bit(*(_DWORD *)(*(void *)a3 + 32));
          *(void *)(a3 + 712) = *((void *)&v130 + v95);
          int v98 = aj_idct_s8;
          if (*(_DWORD *)(a3 + 6612))
          {
            int v91 = 1;
            int v92 = 1;
          }
          else
          {
            int v98 = (uint64_t (*)(__int16 *, void *, int))*(&v114 + 4 * v95 + 2 * v96 + v97 - 3);
          }
          *(_DWORD *)(a3 + 6892) = v92;
          *(_DWORD *)(a3 + 6896) = v91;
          uint64_t v99 = *(unsigned int *)(a3 + 6464);
          if ((int)v99 > 1)
          {
            uint64_t v100 = v99 - 1;
            int v101 = (void *)(a3 + 2280);
            do
            {
              *int v101 = v98;
              v101 += 196;
              --v100;
            }
            while (v100);
          }
          if ((int)v99 >= 1)
          {
            int v102 = (int *)(a3 + 908);
            do
            {
              uint64_t v103 = *(uint64_t (**)(__int16 *, void *, int))(v102 - 49);
              if ((char *)v103 == (char *)aj_idct_s1_16x16_bilinear_12bit)
              {
                int v104 = 32;
              }
              else
              {
                int v104 = 16;
                if ((char *)v103 != (char *)aj_idct_s1_4x8_12bit
                  && (char *)v103 != (char *)aj_idct_s1_16x8_bilinear_12bit
                  && (char *)v103 != (char *)aj_idct_s1_12bit
                  && (char *)v103 != (char *)aj_idct_s1_8x16_nearest
                  && (char *)v103 != (char *)aj_idct_s1_16x16_bilinear)
                {
                  int v104 = 8;
                  if ((char *)v103 != (char *)aj_idct_s2_2x4_12bit
                    && (char *)v103 != (char *)aj_idct_s2_12bit
                    && (char *)v103 != (char *)aj_idct_s1_8x4_12bit
                    && (char *)v103 != (char *)aj_idct_s2_4x8_nearest
                    && (char *)v103 != (char *)aj_idct_s1_16x8_bilinear
                    && (char *)v103 != (char *)aj_idct_s1
                    && (char *)v103 != (char *)aj_idct_s1_4x8)
                  {
                    int v104 = 4;
                    if ((char *)v103 != (char *)aj_idct_s4_1x2_12bit
                      && (char *)v103 != (char *)aj_idct_s4_12bit
                      && (char *)v103 != (char *)aj_idct_s2_4x2_12bit
                      && (char *)v103 != (char *)aj_idct_s4_2x4_nearest
                      && (char *)v103 != (char *)aj_idct_s2_2x4
                      && (char *)v103 != (char *)aj_idct_s1_8x4
                      && (char *)v103 != (char *)aj_idct_s2)
                    {
                      int v104 = 2;
                      if ((char *)v103 != (char *)aj_idct_s8_12bit
                        && (char *)v103 != (char *)aj_idct_s4_2x1_12bit
                        && v103 != aj_idct_s8_1x2_nearest
                        && v103 != aj_idct_s4_1x2
                        && (char *)v103 != (char *)aj_idct_s2_4x2
                        && (char *)v103 != (char *)aj_idct_s4)
                      {
                        int v104 = v103 == aj_idct_s4_2x1 || v103 == aj_idct_s8;
                      }
                    }
                  }
                }
              }
              *int v102 = v104;
              v102 += 392;
              --v99;
            }
            while (v99);
          }
          uint64_t result = init_ra_table(a4, a5, a9, *(_DWORD *)(a8 + 104), *(_DWORD *)(a8 + 108), v112);
          if (!result)
          {
            set_crop_offset(a3);
            uint64_t result = init_invcol((uint64_t *)a3);
            if (!result)
            {
              uint64_t result = aj_compute_buffer_sizes(v111, a3, a5, a9);
              if (!result)
              {
                int v106 = *(_DWORD *)a8;
                if (*(int *)a8 >= 8) {
                  int v106 = 8;
                }
                if (v106 <= 1) {
                  uint64_t v107 = 1;
                }
                else {
                  uint64_t v107 = v106;
                }
                *(_DWORD *)(a3 + 6948) = aj_get_numthreads_decode(a3, a8, *(void *)(a7 + 80) == 0, v107, (_DWORD *)(a3 + 6960));
                uint64_t result = aj_init_decode_jobs(a3, (_DWORD *)a5, a4, v111, a9, 0);
                if (!result)
                {
                  uint64_t result = aj_init_input_states(a3, a5, a7, a13, (char *)&v113);
                  if (!result)
                  {
                    if (*(_DWORD *)(a8 + 36) == 1 && !*(unsigned char *)(a3 + 17)) {
                      fill_image_edges(a3);
                    }
                    if (*a6 >= 1)
                    {
                      uint64_t v108 = 0;
                      uint64_t v109 = a3 + 192;
                      do
                      {
                        aj_init_component(a3, v109, v108++, 0, 0);
                        v109 += 1568;
                      }
                      while (v108 < *a6);
                    }
                    if (!*((unsigned char *)a6 + 84)
                      || (uint64_t result = init_prog_scans(v112, (uint64_t *)a3, a5, a9, v113), !result))
                    {
                      init_blockdec(a3, 0);
                      return 0;
                    }
                  }
                }
              }
            }
          }
          return result;
        }
        if (v32 == 14)
        {
          uint64_t v56 = *(void *)(a3 + 64);
          uint64_t v57 = *(void *)(a3 + 96);
          if (*(unsigned char *)(a3 + 17))
          {
            uint64_t v58 = *(int *)(a3 + 172);
            uint64_t v59 = v56 + v57 * v58;
            uint64_t v60 = (int)v58 / *(_DWORD *)(a3 + 48);
          }
          else
          {
            uint64_t v59 = v56 + *(void *)(a3 + 6520) * v57;
            uint64_t v60 = *(void *)(a3 + 6552);
          }
          uint64_t v61 = v59 + *(void *)(a3 + 104) * v60;
          *(void *)(a3 + 72) = v59;
          *(void *)(a3 + 80) = v61;
        }
        else if (v54 == 3)
        {
          uint64_t v63 = *(_DWORD **)a3;
          int v62 = *(int **)(a3 + 8);
          uint64_t v64 = v62[21];
          uint64_t v65 = *(void *)(a3 + 64) + *(void *)(a3 + 96) * v64 * v62[19];
          uint64_t v66 = v65 + *(void *)(a3 + 104) * v64;
          *(void *)(a3 + 72) = v65;
          *(void *)(a3 + 80) = v66;
          if (*v63 != 1) {
            goto LABEL_93;
          }
          goto LABEL_89;
        }
      }
      if (v54 != 3 || **(_DWORD **)a3 != 1) {
        goto LABEL_93;
      }
      int v62 = *(int **)(a3 + 8);
LABEL_89:
      if (v62[89])
      {
        uint64_t v68 = (void *)(*(void *)(a3 + 64) + 8 * *(void *)(a3 + 96) * *(int *)(a3 + 48));
        size_t v69 = 8 * (*(void *)(a3 + 112) + *(void *)(a3 + 104));
      }
      else
      {
        memset(*(void **)(a3 + 72), 128, *(void *)(a3 + 6552) * *(void *)(a3 + 104));
        uint64_t v68 = *(void **)(a3 + 80);
        size_t v69 = *(void *)(a3 + 6552) * *(void *)(a3 + 112);
      }
      memset(v68, 128, v69);
      goto LABEL_93;
    }
    aj_log_error((uint64_t)"DecodeInit", "Unsupported decoding quality.");
    return 5;
  }
  return result;
}

__n128 reset_decode_job(uint64_t a1)
{
  __n128 v3 = *(__n128 *)(a1 + 112);
  long long v4 = *(_OWORD *)(a1 + 128);
  uint64_t v5 = *(void *)(a1 + 144);
  bzero((void *)a1, 0x5F8uLL);
  __n128 result = v3;
  *(__n128 *)(a1 + 112) = v3;
  *(_OWORD *)(a1 + 128) = v4;
  *(void *)(a1 + 144) = v5;
  return result;
}

uint64_t init_ra_table(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  if (!*(_DWORD *)a2)
  {
    uint64_t result = 0;
    goto LABEL_11;
  }
  if ((a4 - 0x10000) < 0xFFFF0001 || (a5 - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"DecodeInit", "Unsupported RA-table sampling frequency");
    *(_DWORD *)a2 = 0;
    *(void *)(a2 + 16) = 0;
    return 8;
  }
  else
  {
    if ((*(_DWORD *)(a1 + 136) & 0xFFFFFFFE) == 2 && *(void *)(a1 + 96) && *(void *)(a1 + 104))
    {
      int v11 = *(_DWORD *)(a1 + 112);
      int v10 = *(_DWORD *)(a1 + 116);
      if (v10 == a5 && v11 == a4)
      {
        uint64_t result = 0;
        *(_DWORD *)a2 = 0;
LABEL_11:
        *(void *)(a2 + 16) = 0;
        return result;
      }
      uint64_t v13 = *(void *)(a6 + 32);
      *(void *)(a6 + 32) = 0;
    }
    else
    {
      uint64_t v13 = 0;
      int v10 = 0;
      int v11 = 0;
    }
    *(_DWORD *)(a1 + 112) = a4;
    *(_DWORD *)(a1 + 116) = a5;
    uint64_t v14 = (int *)(a1 + 112);
    int v15 = *(_DWORD *)(a1 + 80);
    int v16 = (a5 + v15 - 1) / a5;
    int v17 = (a4 + *(_DWORD *)(a1 + 84) - 1) / a4;
    *(_DWORD *)(a1 + 128) = v17;
    *(_DWORD *)(a1 + 132) = v16;
    int v18 = 8 * v17;
    while (1)
    {
      int v19 = 20 * v16;
      if (20 * v16 * v17 < 41943041) {
        break;
      }
      int v20 = v15 + a5++;
      *(_DWORD *)(a1 + 116) = a5;
      int v16 = v20 / a5;
      *(_DWORD *)(a1 + 132) = v16;
      if (v16 == 1)
      {
        int v19 = 20;
        break;
      }
    }
    uint64_t v21 = *(void *)(a6 + 32);
    if (v21)
    {
      (*(void (**)(uint64_t, void))(a3 + 8))(v21, *(void *)(a3 + 16));
      int v17 = *(_DWORD *)(a1 + 128);
    }
    int v22 = (void *)(*(uint64_t (**)(void, void))a3)(v18 + v17 * v19, *(void *)(a3 + 16));
    *(void *)(a6 + 32) = v22;
    if (v22 && (bzero(v22, v18 + *(_DWORD *)(a1 + 128) * v19), (uint64_t v23 = *(void *)(a6 + 32)) != 0))
    {
LABEL_22:
      *(void *)(a1 + 96) = v23;
      *(void *)(a1 + 104) = v23;
      uint64_t v24 = *(unsigned int *)(a1 + 128);
      if ((int)v24 >= 1)
      {
        uint64_t v25 = 0;
        uint64_t v26 = v23 + v18;
        uint64_t v27 = 8 * v24;
        uint64_t v28 = 20 * *(int *)(a1 + 132);
        do
        {
          *(void *)(*(void *)(a1 + 104) + v25) = v26;
          v25 += 8;
          v26 += v28;
        }
        while (v27 != v25);
      }
      if (v13)
      {
        int v29 = *(_DWORD *)(a1 + 116);
        if (v10 >= v29) {
          int v30 = *(_DWORD *)(a1 + 116);
        }
        else {
          int v30 = v10;
        }
        if (v10 <= v29) {
          int v31 = *(_DWORD *)(a1 + 116);
        }
        else {
          int v31 = v10;
        }
        if (v30)
        {
          do
          {
            int v32 = v30;
            int v30 = v31 % v30;
            int v31 = v32;
          }
          while (v30);
        }
        else
        {
          int v32 = v31;
        }
        int v48 = v29 * v10;
        int v49 = *v14;
        if (v11 >= *v14) {
          int v50 = *v14;
        }
        else {
          int v50 = v11;
        }
        if (v11 <= v49) {
          int v51 = *v14;
        }
        else {
          int v51 = v11;
        }
        int v52 = v48 / v32;
        if (v50)
        {
          do
          {
            int v53 = v50;
            int v50 = v51 % v50;
            int v51 = v53;
          }
          while (v50);
        }
        else
        {
          int v53 = v51;
        }
        int v54 = v49 * v11 / v53;
        *(_DWORD *)(a1 + 120) = v54;
        *(_DWORD *)(a1 + 124) = v52;
        int v55 = *(_DWORD *)(a1 + 84);
        if (v55 >= 1)
        {
          int v56 = 0;
          int v57 = *(_DWORD *)(a1 + 80);
          do
          {
            if (v57 >= 1)
            {
              int v58 = 0;
              do
              {
                uint64_t v59 = *(void *)(v13 + 8 * (v56 / v11)) + 20 * (v58 / v10);
                uint64_t v60 = *(void *)(*(void *)(a1 + 104) + 8 * (v56 / *(_DWORD *)(a1 + 112)))
                    + 20 * (v58 / *(_DWORD *)(a1 + 116));
                long long v61 = *(_OWORD *)v59;
                *(_DWORD *)(v60 + 16) = *(_DWORD *)(v59 + 16);
                *(_OWORD *)uint64_t v60 = v61;
                v58 += v52;
                int v57 = *(_DWORD *)(a1 + 80);
              }
              while (v58 < v57);
              int v55 = *(_DWORD *)(a1 + 84);
            }
            v56 += v54;
          }
          while (v56 < v55);
        }
        *(_DWORD *)(a1 + 136) = 2;
        *(void *)(a2 + 16) = 0;
        (*(void (**)(uint64_t, void))(a3 + 8))(v13, *(void *)(a3 + 16));
        return 0;
      }
      else
      {
        uint64_t v42 = 0;
        int v43 = *(_DWORD *)(a1 + 80);
        int v44 = *(_DWORD *)(a1 + 84);
        do
        {
          uint64_t v45 = a1 + v42;
          *(_WORD *)(v45 + 140) = v44;
          *(_WORD *)(v45 + 142) = v43;
          v42 += 24;
        }
        while (v42 != 216);
        if (v43 < 4 || v44 < 4)
        {
          *(_WORD *)(a1 + 140) = v44 / 2;
          *(_WORD *)(a1 + 142) = v43 / 2;
        }
        else
        {
          uint64_t v46 = 0;
          unint64_t v47 = (_WORD *)(a1 + 142);
          do
          {
            *(v47 - 1) = (int)(v44 + v44 * (v46 / 3u)) / 4;
            *unint64_t v47 = v43 * (v46 % 3u + 1) / 4;
            v47 += 12;
            ++v46;
          }
          while (v46 != 9);
        }
        uint64_t result = 0;
        *(void *)(a2 + 16) = a1 + 140;
        *(_DWORD *)(a1 + 136) = 1;
      }
    }
    else
    {
      while (1)
      {
        int v36 = *(_DWORD *)(a1 + 80);
        int v37 = *(_DWORD *)(a1 + 116);
        if (!(v36 / v37)) {
          break;
        }
        *(_DWORD *)(a1 + 116) = v37 + 1;
        int v33 = (v37 + v36) / (v37 + 1);
        *(_DWORD *)(a1 + 132) = v33;
        int v34 = 20 * v33;
        uint64_t v35 = (void *)(*(uint64_t (**)(void, void))a3)(v18 + *(_DWORD *)(a1 + 128) * 20 * v33, *(void *)(a3 + 16));
        *(void *)(a6 + 32) = v35;
        if (v35)
        {
          bzero(v35, v18 + *(_DWORD *)(a1 + 128) * v34);
          uint64_t v23 = *(void *)(a6 + 32);
          if (v23) {
            goto LABEL_22;
          }
        }
      }
      aj_log_error((uint64_t)"DecodeInit", "Failed to allocate RA-table");
      if (v13) {
        (*(void (**)(uint64_t, void))(a3 + 8))(v13, *(void *)(a3 + 16));
      }
      uint64_t v38 = 0;
      *(_DWORD *)a2 = 0;
      *(void *)uint64_t v14 = 0;
      *(void *)(a1 + 120) = 0;
      *(_DWORD *)(a1 + 136) = 0;
      *(void *)(a1 + 128) = 0;
      int v40 = *(_DWORD *)(a1 + 80);
      int v39 = *(_DWORD *)(a1 + 84);
      do
      {
        uint64_t v41 = a1 + v38;
        *(_WORD *)(v41 + 140) = v39;
        *(_WORD *)(v41 + 142) = v40;
        v38 += 24;
      }
      while (v38 != 216);
      return 6;
    }
  }
  return result;
}

int32x4_t set_crop_offset(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 6852);
  if (*(_DWORD *)(a1 + 6884) || *(_DWORD *)(a1 + 6464) != 3)
  {
    *(_DWORD *)(a1 + 6868) = v1;
    int v2 = v1;
  }
  else
  {
    int v2 = 0;
    *(_DWORD *)(a1 + 6868) = v1;
    v1 /= 2;
  }
  *(_DWORD *)(a1 + 6872) = v1;
  *(_DWORD *)(a1 + 6876) = v1;
  *(_DWORD *)(a1 + 6880) = v2;
  __n128 v3 = (const float *)(a1 + 6800);
  int32x4_t v4 = (int32x4_t)vld1q_dup_f32(v3);
  int32x4_t result = vmulq_s32(*(int32x4_t *)(a1 + 6868), v4);
  *(int32x4_t *)(a1 + 6868) = result;
  return result;
}

uint64_t init_invcol(uint64_t *a1)
{
  int v1 = *((_DWORD *)a1 + 1645);
  if (v1 == 14) {
    return 0;
  }
  int v2 = (int *)*a1;
  *((_OWORD *)a1 + 432) = 0u;
  if (v1 == 15)
  {
    __n128 v3 = a1 + 867;
    a1[866] = (uint64_t)aj_icol_mcurow_cmyk;
    if (*(_DWORD *)(a1[1] + 356))
    {
      uint64_t result = 0;
      unsigned char *v3 = 0;
    }
    else
    {
      char v9 = *((unsigned char *)a1 + 6937);
      if (v9) {
        char v9 = *((_DWORD *)a1 + 1735) == 2;
      }
      uint64_t result = 0;
      unsigned char *v3 = v9;
    }
    return result;
  }
  a1[866] = (uint64_t)aj_icol_mcurow_default;
  switch(v1)
  {
    case 0:
      uint64_t v7 = 0;
      uint64_t v5 = aj_icol_row_444_to_rgb;
      if (!*((_DWORD *)a1 + 1721)) {
        uint64_t v5 = aj_icol_row_420_to_rgb;
      }
      BOOL v10 = *v2 == 1;
      int v11 = aj_icol_row_gray_to_rgb;
      goto LABEL_47;
    case 1:
      uint64_t v7 = 0;
      int v12 = *v2;
      BOOL v13 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_rgb565;
      uint64_t v14 = aj_icol_row_420_to_rgb565;
      goto LABEL_21;
    case 2:
      uint64_t v7 = 0;
      int v12 = *v2;
      BOOL v13 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_bgr565;
      uint64_t v14 = aj_icol_row_420_to_bgr565;
LABEL_21:
      if (v13) {
        uint64_t v5 = v14;
      }
      BOOL v10 = v12 == 1;
      int v11 = aj_icol_row_gray_to_rgb565;
      goto LABEL_47;
    case 3:
      uint64_t v7 = 0;
      int v15 = *v2;
      BOOL v16 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_rgba;
      int v17 = aj_icol_row_420_to_rgba;
      goto LABEL_26;
    case 4:
      uint64_t v7 = 0;
      int v15 = *v2;
      BOOL v16 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_bgra;
      int v17 = aj_icol_row_420_to_bgra;
LABEL_26:
      if (v16) {
        uint64_t v5 = v17;
      }
      BOOL v10 = v15 == 1;
      int v11 = aj_icol_row_gray_to_rgba;
      goto LABEL_47;
    case 5:
      uint64_t v7 = 0;
      int v18 = aj_icol_row_all_to_gray;
      goto LABEL_51;
    case 6:
      uint64_t v7 = 0;
      uint64_t v5 = aj_icol_row_444_to_yuv;
      if (!*((_DWORD *)a1 + 1721)) {
        uint64_t v5 = aj_icol_row_420_to_yuv;
      }
      BOOL v10 = *v2 == 1;
      int v11 = aj_icol_row_gray_to_yuv;
      goto LABEL_47;
    case 7:
      uint64_t v7 = 0;
      uint64_t v5 = aj_icol_row_444_to_yuyv;
      if (!*((_DWORD *)a1 + 1721)) {
        uint64_t v5 = aj_icol_row_420_to_yuyv;
      }
      BOOL v10 = *v2 == 1;
      int v11 = aj_icol_row_gray_to_yuyv;
      goto LABEL_47;
    case 8:
    case 9:
      uint64_t v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar422;
      BOOL v6 = *v2 == 3;
      uint64_t v7 = aj_icol_row_gray_to_422biplanar;
      int v8 = aj_icol_row_422_to_biplanar;
      goto LABEL_53;
    case 10:
    case 11:
      uint64_t v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      BOOL v6 = *v2 == 3;
      uint64_t v7 = aj_icol_row_gray_to_420biplanar;
      int v8 = aj_icol_row_420_to_biplanar;
      goto LABEL_53;
    case 12:
    case 13:
      uint64_t v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      BOOL v6 = *v2 == 3;
      uint64_t v7 = aj_icol_row_gray_to_440biplanar;
      int v8 = aj_icol_row_440_to_biplanar;
      goto LABEL_53;
    case 16:
      uint64_t v7 = 0;
      int v19 = *v2;
      BOOL v20 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_rgba_12bit;
      uint64_t v21 = aj_icol_row_420_to_rgba_12bit;
      goto LABEL_39;
    case 17:
      uint64_t v7 = 0;
      int v19 = *v2;
      BOOL v20 = *((_DWORD *)a1 + 1721) == 0;
      uint64_t v5 = aj_icol_row_444_to_bgra_12bit;
      uint64_t v21 = aj_icol_row_420_to_bgra_12bit;
LABEL_39:
      if (v20) {
        uint64_t v5 = v21;
      }
      BOOL v10 = v19 == 1;
      int v11 = aj_icol_row_gray_to_rgba_12bit;
      goto LABEL_47;
    case 18:
      uint64_t v7 = 0;
      int v18 = aj_icol_row_all_to_gray_12bit;
      goto LABEL_51;
    case 19:
      uint64_t v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar4X0;
      BOOL v6 = *v2 == 3;
      uint64_t v7 = aj_icol_row_gray_to_420biplanar_12bit;
      int v8 = aj_icol_row_420_to_biplanar_12bit;
      goto LABEL_53;
    case 20:
      uint64_t v7 = 0;
      uint64_t v5 = aj_icol_row_444_to_bgr_12bit;
      if (!*((_DWORD *)a1 + 1721)) {
        uint64_t v5 = aj_icol_row_420_to_bgr_12bit;
      }
      BOOL v10 = *v2 == 1;
      int v11 = aj_icol_row_gray_to_rgb_12bit;
LABEL_47:
      if (v10) {
        uint64_t v5 = v11;
      }
      a1[864] = (uint64_t)v5;
      goto LABEL_56;
    case 21:
      uint64_t v7 = 0;
      int v18 = aj_icol_row_gray_to_rgba_12bit;
LABEL_51:
      uint64_t v5 = v18;
      a1[864] = (uint64_t)v18;
      goto LABEL_56;
    case 22:
    case 23:
      if (*((unsigned char *)v2 + 86)) {
        goto LABEL_15;
      }
      aj_log_error((uint64_t)"DecodeInit", "Two component output only supported for lossless images");
      return 5;
    case 24:
      uint64_t v5 = 0;
      a1[866] = (uint64_t)aj_icol_mcurow_semiplanar444;
      BOOL v6 = *v2 == 3;
      uint64_t v7 = aj_icol_row_gray_to_444biplanar;
      int v8 = aj_icol_row_444_to_biplanar;
LABEL_53:
      if (v6) {
        uint64_t v7 = v8;
      }
      a1[865] = (uint64_t)v7;
      goto LABEL_56;
    case 25:
    case 26:
      if (*((unsigned char *)v2 + 86))
      {
LABEL_15:
        uint64_t v7 = 0;
        uint64_t v5 = 0;
LABEL_56:
        if (*((unsigned char *)v2 + 86)) {
          return 0;
        }
        int v22 = *((_DWORD *)a1 + 6);
        if (v5)
        {
          uint64_t result = 0;
          if (v22 != 2 || v7) {
            return result;
          }
        }
        else
        {
          if (v22 != 2)
          {
            aj_log_error((uint64_t)"DecodeInit", "No pixel-row inverse color transform set");
            return 1;
          }
          if (v7) {
            return 0;
          }
        }
        aj_log_error((uint64_t)"DecodeInit", "No pixel-row semiplanar transform set");
        return 1;
      }
      aj_log_error((uint64_t)"DecodeInit", "Tri-planar output only supported for lossless images");
      return 5;
    default:
      aj_log_error((uint64_t)"DecodeInit", "Unknown output format");
      return 5;
  }
}

uint64_t aj_compute_buffer_sizes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a2 + 6612))
  {
    int v8 = *(_DWORD *)(*(void *)a2 + 16) * *(_DWORD *)(*(void *)(a2 + 8) + 80);
    if (*(_DWORD *)(a2 + 6464) == 1) {
      int v9 = 0;
    }
    else {
      int v9 = *(_DWORD *)(*(void *)(a2 + 8) + 80);
    }
    int v10 = v8 + v9 * (*(_DWORD *)(a2 + 6464) - 1);
    *(_DWORD *)(a2 + 6640) = v10;
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      (*(void (**)(uint64_t, void))(a4 + 8))(v11, *(void *)(a4 + 16));
      int v10 = *(_DWORD *)(a2 + 6640);
    }
    int v12 = (void *)(*(uint64_t (**)(uint64_t, void))a4)(4 * v10, *(void *)(a4 + 16));
    *(void *)(a2 + 6632) = v12;
    *(void *)(a1 + 24) = v12;
    if (!v12) {
      return 6;
    }
    bzero(v12, 4 * *(int *)(a2 + 6640));
    if (!*(void *)(a1 + 24)) {
      return 6;
    }
    uint64_t v13 = *(void *)(a2 + 6632);
    *(void *)(a2 + 6648) = v13;
    uint64_t v14 = v13 + 4 * v8;
    *(void *)(a2 + 6656) = v14;
    uint64_t v15 = v14 + 4 * v9;
    *(void *)(a2 + 6664) = v15;
    *(void *)(a2 + 6672) = v15 + 4 * v9;
  }
  int v16 = *(_DWORD *)(a2 + 6580);
  if ((v16 - 25) < 2) {
    return 0;
  }
  if (v16 == 14)
  {
    aj_reset_texture_buffer_ptrs((unsigned int **)a2, a3 + 568, a2 + 64);
    uint64_t result = 0;
    *(unsigned char *)(a2 + 6945) = 0;
  }
  else
  {
    *(unsigned char *)(a2 + 6945) = 1;
    uint64_t v19 = *(int *)(a2 + 172);
    uint64_t v18 = *(int *)(a2 + 176);
    *(_DWORD *)(a2 + 6684) = v19;
    uint64_t v20 = *(int *)(a2 + 6848) - (uint64_t)*(int *)(a2 + 6844);
    uint64_t v21 = *(void *)(a2 + 6704) + v19;
    *(void *)(a2 + 6704) = v21;
    unint64_t v22 = v20 * v18 * *(int *)(a2 + 6800);
    *(void *)(a2 + 6712) = v22;
    uint64_t v23 = *(unsigned int *)(a2 + 6464);
    if ((int)v23 >= 2)
    {
      uint64_t v24 = (int *)(a2 + 6688);
      uint64_t v25 = (void *)(a2 + 6720);
      uint64_t v26 = v23 - 1;
      do
      {
        int v27 = (int)v19 / *(_DWORD *)(a2 + 6896);
        *v24++ = v27;
        unint64_t v28 = v22 / *(int *)(a2 + 6892);
        *v25 += v27;
        v25[1] = v28;
        v25 += 2;
        --v26;
      }
      while (v26);
    }
    if (*(_DWORD *)(a2 + 24) == 2)
    {
      uint64_t v29 = *(int *)(a2 + 48);
      if ((int)v29 >= 2)
      {
        *(void *)(a2 + 6704) = v21 + 1;
        if (v23 == 3)
        {
          if (*(unsigned char *)(a2 + 6889))
          {
            *(void *)(a2 + 6704) = v21 + 3;
          }
          else
          {
            ++*(void *)(a2 + 6720);
            ++*(void *)(a2 + 6736);
          }
        }
      }
      if (!*(_DWORD *)(a2 + 6804)) {
        return 0;
      }
      uint64_t result = 0;
      *(void *)(a2 + 6768) = v29;
      uint64_t v31 = *(int *)(a2 + 6492);
      *(void *)(a2 + 6776) = v31;
      *(void *)(a2 + 6784) = 1;
      *(void *)(a2 + 6792) = 2 * ((int)v31 / *(_DWORD *)(a2 + 44));
    }
    else
    {
      if (!*(_DWORD *)(a2 + 6804)) {
        return 0;
      }
      *(void *)(a2 + 6768) = 1;
      if (v23 == 3 && !*(_DWORD *)(a2 + 6884)) {
        *(void *)(a2 + 6768) = 2;
      }
      uint64_t result = 0;
      if (*(_DWORD *)(a2 + 44) == 2) {
        int v30 = *(_DWORD *)(a2 + 6500) & 1;
      }
      else {
        int v30 = 0;
      }
      *(void *)(a2 + 6776) = *(int *)(a2 + 28) * (uint64_t)(*(_DWORD *)(a2 + 6500) + v30);
    }
  }
  return result;
}

uint64_t aj_init_input_states(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5)
{
  if (*(_DWORD *)a2) {
    BOOL v8 = 0;
  }
  else {
    BOOL v8 = *(unsigned char *)(*(void *)(a1 + 8) + 400) == 0;
  }
  uint64_t result = init_mcustate(a2, a3, a4, v8, a5);
  if (!result)
  {
    if (*(int *)(a1 + 6948) < 2)
    {
      return 0;
    }
    else
    {
      uint64_t v10 = 0;
      for (uint64_t i = *(void *)(a1 + 6952); ; i += 1672)
      {
        int v12 = *(long long **)(a2 + 112);
        long long v13 = *v12;
        long long v14 = v12[1];
        long long v15 = v12[2];
        *(_OWORD *)(i + 1600) = v12[3];
        *(_OWORD *)(i + 1584) = v15;
        *(_OWORD *)(i + 1568) = v14;
        *(_OWORD *)(i + 1552) = v13;
        long long v16 = v12[4];
        long long v17 = v12[5];
        long long v18 = v12[6];
        *(void *)(i + 1664) = *((void *)v12 + 14);
        *(_OWORD *)(i + 1648) = v18;
        *(_OWORD *)(i + 1632) = v17;
        *(_OWORD *)(i + 1616) = v16;
        *(void *)(i + 128) = i + 1552;
        *(void *)(i + 136) = 0;
        *(void *)(i + 144) = 0;
        *(void *)(i + 152) = 0;
        *(void *)(i + 160) = 0x700000000;
        uint64_t result = aj_istream_move_to_position(i + 1552, a4);
        if (result) {
          break;
        }
        if (++v10 >= *(int *)(a1 + 6948) - 1) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t fill_image_edges(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v51 = *MEMORY[0x263EF8340];
  unsigned int v2 = *(_DWORD *)(result + 6608);
  int v46 = 0;
  if (*(_DWORD *)(result + 6592)
    || *(_DWORD *)(result + 6596)
    || *(_DWORD *)(result + 6584)
    || *(_DWORD *)(result + 6588))
  {
    unsigned int v3 = BYTE2(v2);
    unsigned int v4 = BYTE1(v2);
    unsigned int v5 = v2;
    uint64_t result = 16448;
    unsigned int v6 = (BYTE2(v2) << 6)
       - (((340992 * v2 + 0x4000) >> 15)
        + ((1756160 * BYTE1(v2) + 0x4000) >> 15))
       + 16448;
    unsigned int v7 = v6 >> 7;
    unsigned int v8 = (v2 << 6)
       - (((1389568 * BYTE1(v2) + 0x4000) >> 15)
        + ((707584 * BYTE2(v2) + 0x4000) >> 15))
       + 16448;
    if (v8 >= 0x8000) {
      LOBYTE(v9) = -1;
    }
    else {
      unsigned int v9 = v8 >> 7;
    }
    if (v6 >= 0x8000) {
      LOBYTE(v7) = -1;
    }
    unsigned int v10 = ((478208 * v2 + 0x4000) >> 15)
        + ((2462080 * BYTE1(v2) + 0x4000) >> 15)
        + ((1254144 * BYTE2(v2) + 0x4000) >> 15)
        + 64;
    int v11 = *(_DWORD *)(v1 + 6580);
    if (v11 == 7)
    {
      LOBYTE(v46) = v10 >> 7;
      BYTE1(v46) = v9;
      BYTE2(v46) = v46;
      HIBYTE(v46) = v7;
      int v12 = 4;
      int v13 = 2;
      int v14 = *(_DWORD *)(v1 + 24);
    }
    else
    {
      int v14 = *(_DWORD *)(v1 + 24);
      if (v14 == 2)
      {
        LOBYTE(v46) = v10 >> 7;
        BYTE1(v46) = v46;
        BYTE2(v46) = v9;
        HIBYTE(v46) = v7;
      }
      else if ((v11 - 1) < 2)
      {
        unsigned int v15 = (BYTE1(v2) + 2) >> 2;
        if (v3 >= 0xFC) {
          LOWORD(v16) = 31;
        }
        else {
          unsigned int v16 = (v3 + 4) >> 3;
        }
        unsigned int v17 = (v5 + 4) >> 3;
        if (v4 >= 0xFE) {
          LOWORD(v15) = 63;
        }
        if (v5 >= 0xFC) {
          LOWORD(v17) = 31;
        }
        __int16 v18 = 32 * v15;
        if (v11 == 1) {
          __int16 v19 = v18 | ((_WORD)v17 << 11) | v16;
        }
        else {
          __int16 v19 = v18 | ((_WORD)v16 << 11) | v17;
        }
        LOWORD(v46) = v19;
      }
      else if (v11 == 15)
      {
        int v20 = (BYTE2(v2) | BYTE1(v2) | v2) == 0;
        if (*(unsigned char *)(v1 + 6937))
        {
          if (*(_DWORD *)(v1 + 6940) && *(_DWORD *)(*(void *)(v1 + 8) + 356))
          {
            LOBYTE(v46) = ~(v10 >> 7);
            BYTE1(v46) = ~(_BYTE)v9;
            LOBYTE(v2) = ~(_BYTE)v7;
          }
          else
          {
            LOBYTE(v46) = BYTE2(v2);
            BYTE1(v46) = BYTE1(v2);
          }
          BYTE2(v46) = v2;
          LOBYTE(v2) = v20 - 1;
        }
        else
        {
          LOBYTE(v46) = ~HIWORD(v2);
          BYTE1(v46) = ~(v2 >> 8);
          BYTE2(v46) = ~(_BYTE)v2;
          unsigned int v2 = v20 << 31 >> 31;
        }
        HIBYTE(v46) = v2;
      }
      else if (v11 == 6)
      {
        LOBYTE(v46) = v10 >> 7;
        BYTE1(v46) = v9;
        BYTE2(v46) = v7;
      }
      else
      {
        LOBYTE(v46) = BYTE2(v2);
        BYTE1(v46) = BYTE1(v2);
        BYTE2(v46) = v2;
        HIBYTE(v46) = HIBYTE(v2);
      }
      int v12 = *(_DWORD *)(v1 + 28);
      int v13 = 1;
    }
    int v21 = *(_DWORD *)(v1 + 32);
    v50[0] = v12;
    v50[1] = v21;
    int v22 = *(_DWORD *)(v1 + 44);
    int v23 = *(_DWORD *)(v1 + 48);
    v49[0] = v13;
    v49[1] = v22;
    v48[0] = 1;
    v48[1] = v23;
    v47[0] = &v46;
    v47[1] = (char *)&v46 + 2;
    if (v14 >= 1)
    {
      uint64_t v24 = 0;
      do
      {
        int v25 = v49[v24];
        int v26 = *(_DWORD *)(v1 + 6492) / v25;
        int v27 = *(_DWORD *)(v1 + 6496);
        int v28 = v48[v24];
        int v29 = *(_DWORD *)(v1 + 6584);
        int v30 = *(_DWORD *)(v1 + 6588);
        int v31 = v27 / v28;
        if (*(void *)(v1 + 6584))
        {
          *(_DWORD *)&v43[8] = 0;
          int v44 = v26;
          int v45 = v29 / v28;
          int v40 = 0;
          int v41 = (v27 - v30) / v28;
          int v42 = v26;
          *(void *)int v43 = (v30 / v28);
          uint64_t v32 = v1 + 8 * v24;
          int v33 = (char *)v47[v24];
          int v34 = v50[v24];
          aj_paint_region(*(void **)(v32 + 64), *(_DWORD *)(v1 + 6808), v33, v34, v26, *(void *)(v32 + 96), v31, (int *)&v43[4]);
          uint64_t result = (uint64_t)aj_paint_region(*(void **)(v32 + 64), *(_DWORD *)(v1 + 6808), v33, v34, v26, *(void *)(v32 + 96), v31, &v40);
        }
        int v35 = *(_DWORD *)(v1 + 6592);
        int v36 = *(_DWORD *)(v1 + 6596);
        if (*(void *)(v1 + 6592))
        {
          *(void *)&v43[4] = 0;
          int v44 = v35 / v25;
          int v45 = v31;
          int v40 = (*(_DWORD *)(v1 + 6492) - v36) / v25;
          int v41 = 0;
          int v42 = v36 / v25;
          *(_DWORD *)int v43 = v31;
          uint64_t v37 = v1 + 8 * v24;
          uint64_t v38 = (char *)v47[v24];
          int v39 = v50[v24];
          aj_paint_region(*(void **)(v37 + 64), *(_DWORD *)(v1 + 6808), v38, v39, v26, *(void *)(v37 + 96), v31, (int *)&v43[4]);
          uint64_t result = (uint64_t)aj_paint_region(*(void **)(v37 + 64), *(_DWORD *)(v1 + 6808), v38, v39, v26, *(void *)(v37 + 96), v31, &v40);
        }
        ++v24;
      }
      while (v24 < *(int *)(v1 + 24));
    }
  }
  return result;
}

uint64_t init_prog_scans(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a3 + 112);
  memset(v86, 0, sizeof(v86));
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*(unsigned char *)(v8 + 401))
  {
    if (a5)
    {
      int v9 = *(_DWORD *)(v8 + 404);
      if (v9 >= 1)
      {
        unsigned int v10 = *(int **)(v8 + 408);
        int v11 = &v10[72 * v9];
        do
        {
          v10[70] = scan_is_needed((uint64_t)a2, v10);
          v10 += 72;
        }
        while (v10 < v11);
      }
    }
    else if (*(int *)(v8 + 404) >= 1)
    {
      unint64_t v34 = *(void *)(v8 + 408);
      while (1)
      {
        *(void *)(v34 + 72) = 7;
        *(_DWORD *)(v34 + 80) = 0;
        *(_DWORD *)(v34 + 280) = scan_is_needed((uint64_t)a2, (int *)v34);
        uint64_t v35 = aj_istream_move_to_position(v34 + 96, 0);
        if (v35) {
          break;
        }
        v34 += 288;
        if (v34 >= *(void *)(v8 + 408) + 288 * *(int *)(v8 + 404)) {
          return 0;
        }
      }
      return v35;
    }
    return 0;
  }
  unsigned int v15 = *(unsigned __int8 **)(v6 + 8);
  uint64_t v84 = 0;
  uint64_t v85 = v15;
  unsigned int v16 = &v15[*(int *)(v6 + 32)];
  int v17 = *(_DWORD *)(v7 + 3332) + *(_DWORD *)(v7 + 3328);
  uint64_t v18 = 1;
  *(_DWORD *)(v8 + 404) = 1;
  unint64_t v19 = (unint64_t)(v16 - 3);
  if (v15 >= v16 - 3) {
    goto LABEL_43;
  }
  uint64_t v18 = 1;
  while (1)
  {
    if (*v15 != 255 || (int v20 = v15[1]) == 0)
    {
      ++v15;
      goto LABEL_11;
    }
    if ((v20 - 208) < 9) {
      goto LABEL_16;
    }
    int v21 = v15 + 2;
    unsigned int v22 = __rev16(*((unsigned __int16 *)v15 + 1));
    if (v15[1] > 0xD9u)
    {
      if (v20 == 255)
      {
LABEL_16:
        uint64_t v85 = ++v15;
        goto LABEL_12;
      }
      if (v20 == 218)
      {
        if (&v21[v22] > v16) {
          goto LABEL_41;
        }
        uint64_t v18 = (v18 + 1);
        *(_DWORD *)(v8 + 404) = v18;
      }
LABEL_33:
      v15 += v22 + 2;
LABEL_11:
      uint64_t v85 = v15;
      goto LABEL_12;
    }
    if (v20 != 196) {
      break;
    }
    int v23 = &v21[v22];
    if (v23 > v16) {
      goto LABEL_41;
    }
    uint64_t v85 = v15 + 2;
    unsigned int v24 = __rev16(*((unsigned __int16 *)v15 + 1));
    if (v24 < 0x13)
    {
      int v25 = 0;
    }
    else
    {
      int v25 = 0;
      int v26 = v24 - 2;
      int v27 = v15 + 4;
      do
      {
        uint8x16_t v28 = *(uint8x16_t *)(v27 + 1);
        uint16x8_t v29 = vmovl_high_u8(v28);
        uint16x8_t v30 = vmovl_u8(*(uint8x8_t *)v28.i8);
        v30.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v30.i8, *(uint16x4_t *)v29.i8), (int32x4_t)vaddl_high_u16(v30, v29)));
        ++v25;
        int v31 = v26 - 17;
        v27 += v30.u32[0] + 17;
        BOOL v32 = __OFSUB__(v31, v30.i32[0]);
        int v26 = v31 - v30.i32[0];
      }
      while (v26 < 0 == v32 && v26 > 16);
    }
    v17 += v25;
    uint64_t v85 = v23;
    unsigned int v15 = v23;
LABEL_12:
    if ((unint64_t)v15 >= v19) {
      goto LABEL_41;
    }
  }
  if (v20 != 217) {
    goto LABEL_33;
  }
LABEL_41:
  if ((int)v18 >= 1025)
  {
    aj_log_error((uint64_t)"DecodeInit", "The number of scans exceed the allowed limit, %d > %d", v18, 1024);
    return 7;
  }
LABEL_43:
  uint64_t v37 = *(void *)(a1 + 40);
  if (v37)
  {
    (*(void (**)(uint64_t, void))(a4 + 8))(v37, *(void *)(a4 + 16));
    uint64_t v18 = *(unsigned int *)(v8 + 404);
  }
  uint64_t v38 = (*(void *(**)(uint64_t __return_ptr, uint64_t, void))a4)(v18, 288 * (int)v18, *(void *)(a4 + 16));
  *(void *)(v8 + 408) = v38;
  *(void *)(a1 + 40) = v38;
  if (!v38) {
    return 6;
  }
  bzero(v38, 288 * *(int *)(v8 + 404));
  if (!*(void *)(v8 + 408)) {
    return 6;
  }
  uint64_t v39 = *(void *)(a1 + 48);
  if (v39) {
    (*(void (**)(uint64_t, void))(a4 + 8))(v39, *(void *)(a4 + 16));
  }
  size_t v40 = 792 * v17;
  int v41 = (void *)(*(uint64_t (**)(size_t, void))a4)(v40, *(void *)(a4 + 16));
  *(void *)(v8 + 416) = v41;
  *(void *)(a1 + 48) = v41;
  if (!v41) {
    return 6;
  }
  unint64_t v83 = (unint64_t)v16;
  bzero(v41, v40);
  int v42 = *(_OWORD **)(v8 + 416);
  if (!v42) {
    return 6;
  }
  uint64_t v81 = a3;
  uint64_t v82 = v6;
  uint64_t v80 = a1;
  int v43 = *(int **)(v8 + 408);
  int v44 = *(_DWORD *)(v7 + 3336);
  int *v43 = v44;
  if (v44 >= 1)
  {
    uint64_t v45 = 0;
    do
    {
      uint64_t v46 = *(int *)(v7 + 3340 + 4 * v45);
      v43[v45 + 1] = v46;
      uint64_t v47 = v7 + 4 * v46;
      int v48 = &v43[v46];
      v48[5] = *(_DWORD *)(v47 + 3356);
      v48[9] = *(_DWORD *)(v47 + 3372);
      ++v45;
    }
    while (v45 < *v43);
  }
  uint64_t v49 = 0;
  *(_OWORD *)(v43 + 13) = *(_OWORD *)(v7 + 3388);
  while (2)
  {
    uint64_t v50 = 0;
    char v51 = 1;
    do
    {
      char v52 = v51;
      if (*(unsigned char *)(v7 + 2 * v49 + v50 + 3320))
      {
        *((void *)&v86[v49] + v50) = v42;
        *int v42 = *(_OWORD *)(v7 + 32 * v49 + 16 * v50 + 1144);
        int v53 = (long long *)(v7 + (v49 << 9) + (v50 << 8) + 1272);
        long long v54 = v53[7];
        long long v56 = v53[4];
        long long v55 = v53[5];
        v42[7] = v53[6];
        v42[8] = v54;
        v42[5] = v56;
        v42[6] = v55;
        long long v57 = v53[11];
        long long v59 = v53[8];
        long long v58 = v53[9];
        v42[11] = v53[10];
        v42[12] = v57;
        v42[9] = v59;
        v42[10] = v58;
        long long v60 = v53[15];
        long long v62 = v53[12];
        long long v61 = v53[13];
        v42[15] = v53[14];
        v42[16] = v60;
        v42[13] = v62;
        v42[14] = v61;
        long long v63 = *v53;
        long long v64 = v53[1];
        long long v65 = v53[3];
        v42[3] = v53[2];
        v42[4] = v65;
        v42[1] = v63;
        v42[2] = v64;
        uint64_t inited = aj_init_lookup((uint64_t)v42);
        if (inited)
        {
          uint64_t v36 = inited;
          aj_log_error((uint64_t)"DecodeInit", "Corrupt huffman table before scan. Error code: %d", inited);
          return v36;
        }
        int v42 = (_OWORD *)((char *)v42 + 792);
      }
      char v51 = 0;
      uint64_t v50 = 1;
    }
    while ((v52 & 1) != 0);
    if (++v49 != 4) {
      continue;
    }
    break;
  }
  uint64_t v67 = init_scan(a2, a3, v43, (uint64_t)v86, *(void *)(v82 + 8), *(void *)(v82 + 40), *(_DWORD *)(v82 + 36), *(_DWORD *)(v7 + 3404));
  if (v67)
  {
    uint64_t v36 = v67;
    aj_log_error((uint64_t)"DecodeInit", "First scan corrupt, cannot decode image. Error code: %d", v67);
    return v36;
  }
  uint64_t v68 = *(void *)(v8 + 408);
  uint64_t v84 = *(void *)(v8 + 416) + 792 * *(int *)(v7 + 3328) + 792 * *(int *)(v7 + 3332);
  size_t v69 = *(unsigned __int8 **)(v82 + 8);
  uint64_t v85 = v69;
  if ((unint64_t)v69 < v19)
  {
    int v70 = *(_DWORD *)(v7 + 3404);
    int v71 = (unsigned int *)(v68 + 288);
    int v72 = 1;
    do
    {
      if (*v69 == 255 && v69[1])
      {
        BOOL v74 = v69 + 2;
        unsigned int v75 = __rev16(*((unsigned __int16 *)v69 + 1));
        switch(v69[1])
        {
          case 0xC4u:
            if ((unint64_t)&v74[v75] > v83) {
              goto LABEL_87;
            }
            uint64_t v85 = v69 + 2;
            if (aj_read_dht_prog(&v85, &v84, (uint64_t)v86)) {
              goto LABEL_96;
            }
            break;
          case 0xC5u:
          case 0xC6u:
          case 0xC7u:
          case 0xC8u:
          case 0xC9u:
          case 0xCAu:
          case 0xCBu:
          case 0xCCu:
          case 0xCDu:
          case 0xCEu:
          case 0xCFu:
          case 0xDBu:
          case 0xDCu:
            goto LABEL_76;
          case 0xD0u:
          case 0xD1u:
          case 0xD2u:
          case 0xD3u:
          case 0xD4u:
          case 0xD5u:
          case 0xD6u:
          case 0xD7u:
          case 0xD8u:
            goto LABEL_74;
          case 0xD9u:
            goto LABEL_87;
          case 0xDAu:
            if ((unint64_t)&v74[v75] > v83) {
              goto LABEL_87;
            }
            uint64_t v85 = v69 + 2;
            if (aj_read_sos_prog((unsigned __int16 **)&v85, v71, (int *)v7)
              || init_scan(a2, v81, (int *)v71, (uint64_t)v86, (uint64_t)v85, *(void *)(v82 + 40), *(_DWORD *)(v82 + 36), v70))
            {
LABEL_96:
              *(unsigned char *)(v8 + 400) = 1;
              *(_DWORD *)(v8 + 404) = v72;
              goto LABEL_88;
            }
            v71 += 72;
            ++v72;
            break;
          case 0xDDu:
            if ((unint64_t)(v69 + 6) > v83) {
              goto LABEL_87;
            }
            if (v75 != 4)
            {
              aj_log_error((uint64_t)"DecodeInit", "Illegal DRI segment length.");
              return 4;
            }
            int v70 = __rev16(*((unsigned __int16 *)v69 + 2));
            uint64_t v85 = v69 + 6;
            break;
          default:
            if (v69[1] == 255)
            {
LABEL_74:
              uint64_t v85 = v69 + 1;
              break;
            }
LABEL_76:
            int v73 = &v69[v75 + 2];
            goto LABEL_69;
        }
      }
      else
      {
        int v73 = v69 + 1;
LABEL_69:
        uint64_t v85 = v73;
      }
      size_t v69 = v85;
    }
    while ((unint64_t)v85 < v19);
  }
LABEL_87:
  *(unsigned char *)(v8 + 400) = 0;
LABEL_88:
  if (*(_DWORD *)(v7 + 32) == 2)
  {
    int v76 = (*(_DWORD *)(a2[1] + 80) * *(_DWORD *)(a2[1] + 92)) << 7;
    *(_DWORD *)(v8 + 432) = v76;
    uint64_t v77 = *(void *)(v80 + 56);
    if (v77)
    {
      (*(void (**)(uint64_t, void))(a4 + 8))(v77, *(void *)(a4 + 16));
      int v76 = *(_DWORD *)(v8 + 432);
    }
    int v78 = (void *)(*(uint64_t (**)(void, void))a4)(v76, *(void *)(a4 + 16));
    *(void *)(v8 + 424) = v78;
    *(void *)(v80 + 56) = v78;
    if (!v78) {
      return 6;
    }
    bzero(v78, *(int *)(v8 + 432));
    if (!*(void *)(v8 + 424)) {
      return 6;
    }
  }
  uint64_t v36 = 0;
  *(unsigned char *)(v8 + 401) = 1;
  return v36;
}

uint64_t init_blockdec(uint64_t result, int a2)
{
  unsigned int v2 = (unsigned int **)result;
  v16[5] = *MEMORY[0x263EF8340];
  if (a2)
  {
    *(void *)(result + 160) = aj_mcu_decode_index;
    uint64_t v3 = **(unsigned int **)result;
    if ((int)v3 >= 1)
    {
      unsigned int v4 = (void *)(result + 720);
      do
      {
        *unsigned int v4 = aj_block_decode_skip;
        v4 += 196;
        --v3;
      }
      while (v3);
    }
  }
  else
  {
    uint64_t v5 = *(void *)result;
    uint64_t v6 = aj_mcu_decode_progressive;
    if (!*(unsigned char *)(*(void *)result + 84)) {
      uint64_t v6 = aj_mcu_decode;
    }
    *(void *)(result + 160) = v6;
    uint64_t v7 = aj_block_decode_12bit;
    if (*(_DWORD *)(v5 + 4) == 12)
    {
      uint64_t v8 = aj_block_decode_12bit;
      int v9 = aj_block_decode_12bit;
      unsigned int v10 = aj_block_decode_12bit;
    }
    else
    {
      unsigned int v10 = aj_block_decode_S8;
      int v9 = aj_block_decode_S4;
      uint64_t v8 = aj_block_decode_S2;
      uint64_t v7 = aj_block_decode;
    }
    v16[0] = v7;
    v16[1] = v8;
    v16[2] = v9;
    v16[3] = v10;
    v16[4] = aj_block_decode_skip;
    uint64_t result = aj_highest_set_bit(*(_DWORD *)(result + 168));
    uint64_t v11 = (int)result - 1;
    v2[90] = (unsigned int *)v16[v11];
    if (*((_DWORD *)v2 + 1616) == 1)
    {
      uint64_t result = 4;
    }
    else if (*((_DWORD *)v2 + 1721) || (*v2)[4] != 1 || (*v2)[8] != 1 || *((_DWORD *)v2 + 42) == 8)
    {
      if (*((_DWORD *)v2 + 1653) || !*((unsigned char *)v2 + 6888))
      {
        uint64_t result = (int)result - 1;
      }
      else if (*((int *)v2 + 42) <= 1)
      {
        uint64_t result = v11;
      }
      else
      {
        uint64_t result = (result - 2);
      }
    }
    uint64_t v12 = **v2;
    if ((int)v12 >= 2)
    {
      uint64_t v13 = v16[(int)result];
      int v14 = v2 + 286;
      uint64_t v15 = v12 - 1;
      do
      {
        *int v14 = v13;
        v14 += 196;
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t aj_decode_init_index(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10)
{
  reset_decode_job(a5);
  bzero(a3, 0x1B40uLL);
  *((unsigned char *)a3 + 16) = 1;
  *a3 = a6;
  a3[1] = a4;
  *(_DWORD *)a5 = *((unsigned char *)a6 + 84) == 0;
  *(void *)((char *)a3 + 6804) = 0;
  *((_DWORD *)a3 + 42) = 8;
  *((_DWORD *)a3 + 1653) = 0;
  *((_DWORD *)a3 + 1657) = 1;
  *(void *)((char *)a3 + 6484) = *((void *)a6 + 1);
  *((_DWORD *)a3 + 1704) = 0;
  *((_DWORD *)a3 + 1645) = 0;
  *((_DWORD *)a3 + 1721) = 1;
  *(void *)((char *)a3 + 6892) = 0x100000001;
  if (a8)
  {
    int v18 = *(_DWORD *)(a8 + 112);
    long long v19 = *(_OWORD *)(a8 + 120);
  }
  else
  {
    int v18 = 0;
    long long v19 = 0uLL;
  }
  *(_DWORD *)(a5 + 1496) = v18;
  *(_OWORD *)(a5 + 1504) = v19;
  if (!*(_DWORD *)a5) {
    return 0;
  }
  uint64_t result = init_ra_table(a4, a5, a9, *(_DWORD *)(a8 + 104), *(_DWORD *)(a8 + 108), a2);
  if (!result)
  {
    if (*a6 >= 1)
    {
      uint64_t v21 = 0;
      uint64_t v22 = (uint64_t)(a3 + 24);
      do
      {
        aj_init_component((uint64_t)a3, v22, v21++, 0, 1);
        v22 += 1568;
      }
      while (v21 < *a6);
    }
    a3[20] = aj_mcu_decode_index;
    uint64_t v23 = *(unsigned int *)*a3;
    if ((int)v23 >= 1)
    {
      unsigned int v24 = a3 + 90;
      do
      {
        void *v24 = aj_block_decode_skip;
        v24 += 196;
        --v23;
      }
      while (v23);
    }
    int v25 = *(_DWORD *)a8;
    if (*(int *)a8 >= 8) {
      int v25 = 8;
    }
    if (v25 <= 1) {
      int v26 = 1;
    }
    else {
      int v26 = v25;
    }
    *((_DWORD *)a3 + 1737) = aj_get_numthreads_ratbl(a3, *(void *)(a7 + 80) == 0, v26);
    uint64_t result = aj_init_decode_jobs((uint64_t)a3, (_DWORD *)a5, a4, a1, a9, 1);
    if (!result)
    {
      return aj_init_input_states((uint64_t)a3, a5, a7, a10, 0);
    }
  }
  return result;
}

uint64_t init_mcustate(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char *a5)
{
  if (!a4
    || *(void *)(a1 + 112) != a2
    || (int v8 = *(_DWORD *)(a1 + 136), v9 = *(_DWORD *)(a1 + 80), v8 >= v9)
    && (v8 == v9 ? (BOOL v10 = *(_DWORD *)(a1 + 140) <= *(_DWORD *)(a1 + 84)) : (BOOL v10 = 0), !v10))
  {
    *(void *)(a1 + 112) = a2;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(void *)(a1 + 144) = 0x700000000;
    uint64_t result = aj_istream_move_to_position(a2, a3);
    if (result) {
      return result;
    }
    char v7 = 0;
    if (!a5) {
      return 0;
    }
LABEL_14:
    uint64_t result = 0;
    *a5 = v7;
    return result;
  }
  if (a5)
  {
    char v7 = 1;
    goto LABEL_14;
  }
  return 0;
}

uint64_t scan_is_needed(uint64_t a1, int *a2)
{
  if (*a2 > 1) {
    return 1;
  }
  int v3 = a2[1];
  int v4 = *(_DWORD *)(a1 + 1568 * v3 + 904);
  if (a2[16])
  {
    int v5 = a2[13];
    if (v5 >= 1)
    {
      BOOL v6 = v4 == 2 && v5 > 0x19;
      if (!v6 && v4 != 8 && (v4 != 4 || v5 <= 4)) {
        return *a2 != 1 || *(_DWORD *)(a1 + 6464) != 1 || v3 == 0;
      }
      return 0;
    }
  }
  if (v4 == 8 && a2[13] > 0) {
    return 0;
  }
  return *a2 != 1 || *(_DWORD *)(a1 + 6464) != 1 || v3 == 0;
}

uint64_t init_scan(uint64_t *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  if (*(unsigned char *)(*a1 + 84)) {
    BOOL v12 = *(unsigned __int8 *)(*a1 + 85) != 0;
  }
  else {
    BOOL v12 = 0;
  }
  int v13 = a3[13];
  LODWORD(v14) = *a3;
  if (*a3 >= 1)
  {
    int v32 = a6;
    uint64_t v33 = a5;
    int v34 = a7;
    uint64_t v35 = a2;
    uint64_t v15 = 1;
    while (1)
    {
      unsigned int v16 = &a3[a3[v15]];
      if (v12)
      {
        int v17 = *(uint8x16_t **)(a4 + 16 * v16[5]);
        if (!v17)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use DC huffman table #%d that is uninitialized");
          return 4;
        }
        int v18 = *(uint8x16_t **)(a4 + 16 * v16[9] + 8);
        if (!v18)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use AC huffman table #%d that is uninitialized");
          return 4;
        }
        uint64_t result = aj_check_single_huffman_table(v17, v17[1].i8, 0, *a1);
        if (result) {
          return result;
        }
        i8 = v18[1].i8;
        uint64_t v21 = *a1;
        uint64_t v22 = v18;
        BOOL v23 = 1;
      }
      else
      {
        unsigned int v24 = v16 + 9;
        int v25 = v16 + 5;
        if (v13) {
          int v25 = v24;
        }
        uint64_t v22 = *(uint8x16_t **)(a4 + 16 * *v25 + 8 * (v13 != 0));
        if (!v22)
        {
          aj_log_error((uint64_t)"DecodeInit", "Trying to use huffman table #%d that is uninitialized");
          return 4;
        }
        i8 = v22[1].i8;
        uint64_t v21 = *a1;
        BOOL v23 = v13 != 0;
      }
      uint64_t result = aj_check_single_huffman_table(v22, i8, v23, v21);
      if (result) {
        return result;
      }
      ++v15;
      uint64_t v14 = *a3;
      if (v15 - 1 >= v14)
      {
        a2 = v35;
        a7 = v34;
        a6 = v32;
        a5 = v33;
        break;
      }
    }
  }
  for (uint64_t i = 0; i != 16; i += 4)
  {
    int v27 = &a3[i];
    *((void *)v27 + 27) = *(void *)(a4 + i * 4);
    *((void *)v27 + 28) = *(void *)(a4 + i * 4 + 8);
  }
  a3[17] = a8;
  int v28 = a3[16];
  if (!v28 || v28 == a3[15] + 1)
  {
    if ((int)v14 < 1 || (int)v14 > *(_DWORD *)*a1)
    {
      aj_log_error((uint64_t)"DecodeInit", "Illegal number of components in scan: %d");
      return 4;
    }
    if (v12)
    {
      uint16x8_t v29 = aj_baseline_multiscan_decode_scan;
LABEL_27:
      *((void *)a3 + 11) = v29;
      uint64_t v36 = a5;
      uint64_t v37 = a6 - (int)a5 + a7;
      aj_istream_init_mem((uint64_t)(a3 + 24), &v36, *(unsigned char *)(*(void *)(a2 + 112) + 112), *(_DWORD *)(*(void *)(a2 + 112) + 56));
      *((void *)a3 + 9) = 7;
      a3[20] = 0;
      a3[70] = scan_is_needed((uint64_t)a1, a3);
      return aj_istream_move_to_position((uint64_t)(a3 + 24), 0);
    }
    int v30 = a3[13];
    if (v30)
    {
      if (v14 == 1 && (v30 - 64) >= 0xFFFFFFC1)
      {
        int v31 = a3[14];
        if (v31 >= v30 && v31 < 64)
        {
          if (v28) {
            uint16x8_t v29 = aj_prog_decode_AC_refine;
          }
          else {
            uint16x8_t v29 = aj_prog_decode_AC_first;
          }
          goto LABEL_27;
        }
      }
    }
    else if (!a3[14])
    {
      if (v28) {
        uint16x8_t v29 = aj_prog_decode_DC_refine;
      }
      else {
        uint16x8_t v29 = aj_prog_decode_DC_first;
      }
      goto LABEL_27;
    }
  }
  aj_log_error((uint64_t)"DecodeInit", "Faulty scan format");
  return 4;
}

uint64_t (***aj_bufferproc_crop(uint64_t (***result)(void), uint64_t a2, uint64_t a3, int a4, int a5))(void)
{
  int v5 = a4;
  int v8 = result;
  uint64_t v45 = *MEMORY[0x263EF8340];
  v43[0] = 0;
  v43[1] = 0;
  int v9 = *(_DWORD *)(a3 + 72);
  int v10 = v9 - a5;
  if (v9 <= a5) {
    goto LABEL_22;
  }
  if (a5 + a4 <= v9) {
    return result;
  }
  int v5 = a4 - v10;
  int v11 = *(_DWORD *)(a2 + 6464);
  if (v11 >= 2)
  {
    if (*((_DWORD *)result + 11) == 2 && (v10 & 1) != 0) {
      *(unsigned char *)(a3 + 1080) = 1;
    }
    goto LABEL_10;
  }
  if (v11 == 1)
  {
LABEL_10:
    uint64_t v13 = 0;
    uint64_t v14 = (void *)(a3 + 568);
    uint64_t v15 = __src;
    do
    {
      if (v13) {
        int v16 = aj_highest_set_bit(*((_DWORD *)v8 + 11)) - 1;
      }
      else {
        int v16 = 0;
      }
      LODWORD(v17) = (v16 + v5) >> v16;
      if (v13) {
        uint64_t v17 = v17;
      }
      else {
        uint64_t v17 = v5;
      }
      *((_DWORD *)v43 + v13) = v17;
      if ((int)v17 >= 1)
      {
        uint64_t v18 = v10 >> v16;
        long long v19 = v15;
        int v20 = v14;
        do
        {
          *v19++ = *v20;
          void *v20 = v20[v18];
          ++v20;
          --v17;
        }
        while (v17);
      }
      ++v13;
      v14 += 16;
      v15 += 128;
    }
    while (v13 < *(int *)(a2 + 6464));
  }
  a5 = v9;
LABEL_22:
  int v21 = *(_DWORD *)(a3 + 76);
  if (v5 + a5 > v21)
  {
    int v22 = v21 - a5;
    if (!*(unsigned char *)(a3 + 1082)) {
      int v5 = v22;
    }
  }
  uint64_t v23 = *(unsigned int *)(a2 + 6464);
  if ((int)v23 >= 1)
  {
    uint64_t v24 = 0;
    int v25 = (void *)(a3 + 568);
    do
    {
      uint64_t v26 = *(int *)(a2 + 4 * v24 + 6868);
      if (v26) {
        BOOL v27 = v5 < 1;
      }
      else {
        BOOL v27 = 1;
      }
      if (!v27)
      {
        uint64_t v28 = v5;
        uint16x8_t v29 = v25;
        do
        {
          *v29++ += v26;
          --v28;
        }
        while (v28);
      }
      ++v24;
      v25 += 16;
    }
    while (v24 != v23);
    if (int)v23 > 1 && *((_DWORD *)v8 + 10) == 2 && (*(unsigned char *)(a2 + 6868)) {
      *(unsigned char *)(a3 + 1081) = 1;
    }
  }
  uint64_t result = (uint64_t (***)(void))(*v8[10])();
  v8[4] = (uint64_t (**)(void))((char *)v8[4] + v5);
  uint64_t v30 = *(unsigned int *)(a2 + 6464);
  if ((int)v30 < 1)
  {
    if (LODWORD(v43[0])) {
      *(unsigned char *)(a3 + 1080) = 0;
    }
  }
  else
  {
    uint64_t v31 = 0;
    int v32 = (void *)(a3 + 568);
    do
    {
      uint64_t v33 = *(int *)(a2 + 4 * v31 + 6868);
      if (v33) {
        BOOL v34 = v5 < 1;
      }
      else {
        BOOL v34 = 1;
      }
      if (!v34)
      {
        uint64_t v35 = -v33;
        uint64_t v36 = v5;
        uint64_t v37 = v32;
        do
        {
          *v37++ += v35;
          --v36;
        }
        while (v36);
      }
      ++v31;
      v32 += 16;
    }
    while (v31 != v30);
    if (LODWORD(v43[0]))
    {
      *(unsigned char *)(a3 + 1080) = 0;
      uint64_t v38 = (char *)(a3 + 568);
      uint64_t v39 = (int *)v43;
      size_t v40 = __src;
      do
      {
        int v42 = *v39++;
        uint64_t v41 = v42;
        if (v42 >= 1) {
          uint64_t result = (uint64_t (***)(void))memcpy(v38, v40, 8 * v41);
        }
        v40 += 128;
        v38 += 128;
        --v30;
      }
      while (v30);
    }
  }
  return result;
}

uint64_t aj_bufferproc_crop_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  long long v7 = *(_OWORD *)(a1 + 40);
  long long v8 = *(_OWORD *)(a1 + 56);
  *(void *)(a5 + 32) = *(void *)(a1 + 72);
  *(_OWORD *)a5 = v7;
  *(_OWORD *)(a5 + 16) = v8;
  int v10 = *(_DWORD *)(a3 + 72);
  int v9 = *(_DWORD *)(a3 + 76);
  int v11 = *(_DWORD *)(a2 + 6616);
  int v12 = aj_highest_set_bit(*(_DWORD *)(a1 + 44));
  LODWORD(v13) = v9 - v10;
  DWORD1(v13) = (v12 - 1 + v9 - v10) >> (v12 - 1);
  DWORD2(v13) = DWORD1(v13);
  HIDWORD(v13) = DWORD1(v13);
  *(_OWORD *)(a5 + 24) = v13;
  int v14 = aj_highest_set_bit(*(_DWORD *)(a1 + 40));
  LODWORD(v15) = v11;
  DWORD1(v15) = (v14 - 1 + v11) >> (v14 - 1);
  DWORD2(v15) = DWORD1(v15);
  HIDWORD(v15) = DWORD1(v15);
  *(_OWORD *)(a5 + 8) = v15;
  *(void *)(a1 + 32) = 0;
  return 0;
}

uint8x8_t **aj_icol_row_444_to_bgra(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, int16x8_t *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  int8x16_t v13 = vdupq_n_s8(0xFFu);
  int v14 = *result;
  long long v15 = *a2;
  int v16 = *a3;
  for (unsigned int i = a12 >> 3; i; --i)
  {
    uint8x8_t v18 = *v14++;
    uint8x8_t v19 = *v15++;
    uint8x8_t v20 = *v16++;
    int16x8_t v21 = (int16x8_t)vshll_n_u8(v18, 7uLL);
    int16x8_t v22 = (int16x8_t)vsubl_u8(v19, v12);
    int16x8_t v23 = (int16x8_t)vsubl_u8(v20, v12);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v21, vmulq_n_s16(v23, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v21, vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    int16x8_t v24 = (int16x8_t)vzip1q_s8((int8x16_t)a7, (int8x16_t)a8);
    int16x8_t v25 = (int16x8_t)vzip1q_s8((int8x16_t)a9, v13);
    *a4 = vzip1q_s16(v24, v25);
    a4[1] = vzip2q_s16(v24, v25);
    a4 += 2;
  }
  if ((a12 & 7) != 0)
  {
    int16x8_t v26 = (int16x8_t)vshll_n_u8(*v14, 7uLL);
    int16x8_t v27 = (int16x8_t)vsubl_u8(*v15, v12);
    int16x8_t v28 = (int16x8_t)vsubl_u8(*v16, v12);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v26, vmulq_n_s16(v28, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v26, vqaddq_s16(vmulq_lane_s16(v27, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v28, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    int v29 = a12 & 7;
    do
    {
      a4->i8[0] = a7.i8[0];
      a4->i8[1] = a8.i8[0];
      a4->i8[2] = a9.i8[0];
      a4->i8[3] = v13.i8[0];
      a4 = (int16x8_t *)((char *)a4 + 4);
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v29;
    }
    while (v29);
  }
  return result;
}

uint64_t aj_RGBA8888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  int v4 = *a2;
  int v5 = *(int8x8_t **)a3;
  BOOL v6 = *(uint8x8_t **)(a3 + 16);
  long long v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  int16x8_t v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (unsigned int i = a4 >> 4; i; --i)
  {
    int8x8x4_t v21 = vld4_s8(v4);
    uint8x8_t v12 = v4 + 32;
    int8x8x4_t v22 = vld4_s8(v12);
    int v4 = v12 + 32;
    int16x8_t v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *int v5 = v21.val[0];
    uint8x8_t v19 = v5 + 1;
    int8x8_t *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    int v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[2], v22.val[2]), (uint8x8_t)vuzp2_s8(v21.val[2], v22.val[2]));
  }
  if ((a4 & 8) == 0) {
    JUMPOUT(0x2103DD974);
  }
  return sub_2103DD8F0();
}

uint64_t sub_2103DD8F0(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, void *a9)
{
  int8x8x4_t v32 = vld4_s8(a3);
  int16x8_t v13 = (__int8 *)(a3 + 32);
  int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[2], v32.val[2]), (uint8x8_t)vuzp2_s8(v32.val[2], v32.val[2]));
  *a9 = v9.i64[0];
  int16x8_t v17 = a9 + 1;
  *a7 = v10.i32[0];
  int16x8_t v18 = a7 + 1;
  *a8 = v11.i32[0];
  uint8x8_t v19 = a8 + 1;
  int v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 4;
      --v20;
    }
    while (v20);
    int v21 = a5 & 7;
    int v22 = 8 - v21;
    unsigned int v23 = (v21 + 1) >> 1;
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    int16x8_t v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
      int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
      int64x2_t v11 = vsliq_n_s64(v11, v11, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8));
    do
    {
      *v17++ = v9.i8[7];
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v11.i8[3];
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      --v23;
    }
    while (v23);
  }
  uint64_t result = (a6 - a5);
  if (a6 != a5)
  {
    unsigned int v28 = result >> 1;
    char v29 = *(v17 - 1);
    char v30 = *(v18 - 1);
    char v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_bufferprocessor_free_chain(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 1488);
  *(void *)(a2 + 1488) = 0;
  if (v3)
  {
    uint64_t v6 = result;
    do
    {
      uint64_t v7 = *(void *)(v3 + 80);
      int16x8_t v8 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v3 + 24);
      if (v8) {
        v8(v3, v6, a2, a3);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(a3 + 8))(v3, *(void *)(a3 + 16));
      uint64_t v3 = v7;
    }
    while (v7);
  }
  return result;
}

uint64_t aj_bufferprocessor_append(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, long long *a5)
{
  uint64_t v10 = (*(uint64_t (**)(uint64_t, void))a3)(88, *(void *)(a3 + 16));
  uint64_t v11 = v10;
  if (v10)
  {
    *(_OWORD *)(v10 + 48) = 0u;
    *(_OWORD *)(v10 + 64) = 0u;
    *(_OWORD *)(v10 + 16) = 0u;
    *(_OWORD *)(v10 + 32) = 0u;
    *(_OWORD *)uint64_t v10 = 0u;
    *(void *)(v10 + 80) = 0;
    long long v12 = a4[1];
    *(_OWORD *)uint64_t v10 = *a4;
    *(_OWORD *)(v10 + 16) = v12;
    if (!*(void *)(v10 + 8)) {
      *(void *)(v10 + 8) = aj_bufferprocessor_maxoutrows_default;
    }
    long long v13 = *a5;
    long long v14 = a5[1];
    *(void *)(v10 + 72) = *((void *)a5 + 4);
    *(_OWORD *)(v10 + 56) = v14;
    *(_OWORD *)(v10 + 40) = v13;
    int16x8_t v15 = (uint64_t *)(a2 + 1488);
    do
    {
      int16x8_t v16 = v15;
      uint64_t v17 = *v15;
      int16x8_t v15 = (uint64_t *)(*v15 + 80);
    }
    while (v17);
    uint64_t *v16 = v10;
    int16x8_t v18 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, long long *))(v10 + 16);
    if (v18 && v18(v10, a1, a2, a3, a5)) {
      return 0;
    }
  }
  return v11;
}

uint64_t aj_bufferprocessor_maxoutrows_default(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    return (*(uint64_t (**)(void))(v4 + 8))();
  }
  else {
    return a4;
  }
}

void *aj_huffman_encode_init_baseline(uint64_t a1, int a2, int a3)
{
  *(_WORD *)(a1 + 272) = a3;
  return aj_huffman_fill_standard_counts_values((_OWORD *)a1, (void *)(a1 + 16), a2, a3);
}

void *aj_huffman_fill_standard_counts_values(_OWORD *a1, void *__dst, int a3, int a4)
{
  uint64_t v4 = (char *)&std_huffman_luma;
  if (!a3) {
    uint64_t v4 = (char *)&std_huffman_chroma;
  }
  int v5 = &v4[4500 * (a4 == 0)];
  *a1 = *(_OWORD *)v5;
  if (a4) {
    size_t v6 = 16;
  }
  else {
    size_t v6 = 256;
  }
  return memcpy(__dst, v5 + 16, v6);
}

void aj_huffman_encode_init_progressive(uint64_t a1, int a2, int a3, int a4)
{
  *(unsigned char *)(a1 + 272) = a3;
  *(unsigned char *)(a1 + 273) = 0;
  BOOL v4 = a3 == 0;
  *(_OWORD *)a1 = *(_OWORD *)*(&aj_huffman_encode_init_progressive_countvecs + 4 * v4 + 2 * (a2 == 0) + (a4 == 0));
  uint64_t v5 = a1 + 16;
  size_t v6 = aj_huffman_encode_init_progressive_nsyms[2 * v4 + (a4 == 0)];
  memcpy((void *)(a1 + 16), *(&aj_huffman_encode_init_progressive_valuevecs + 4 * v4 + 2 * (a2 == 0) + (a4 == 0)), v6);
  bzero((void *)(v5 + v6), 256 - v6);
}

void *plugin_vimage_create(uint64_t a1, uint64_t *a2, _DWORD *a3, int *a4)
{
  uint64_t v7 = malloc_type_calloc(1uLL, 0x28uLL, 0x1010040139C5EC2uLL);
  int16x8_t v8 = v7;
  if (!v7)
  {
    aj_log_error(0, "Unable to allocate session");
LABEL_14:
    int v11 = 6;
    goto LABEL_15;
  }
  unsigned int v9 = *((_DWORD *)a2 + 4);
  if (v9 > 0xF || ((1 << v9) & 0x8018) == 0)
  {
    aj_log_error(0, "Unsupported dataformat: %d", *((_DWORD *)a2 + 4));
    int v11 = 3;
    goto LABEL_15;
  }
  if (*((_DWORD *)a2 + 5) > *((_DWORD *)a2 + 1))
  {
    aj_log_error(0, "Max_input_rows is larger than input height");
    int v11 = 1;
LABEL_15:
    if (a4) {
      *a4 = v11;
    }
    if (v8)
    {
      plugin_vimage_destroy(v8);
      return 0;
    }
    return v8;
  }
  uint64_t v12 = a2[1];
  v7[1] = v12;
  uint64_t v13 = *a2;
  *uint64_t v7 = *a2;
  LODWORD(v12) = 4 * v12;
  v7[4] = (int)v12;
  long long v14 = malloc_type_malloc(SHIDWORD(v13) * (uint64_t)(int)v12, 0x9B906E5DuLL);
  v8[3] = v14;
  if (!v14)
  {
    aj_log_error(0, "Unable to allocate temp buffer");
    goto LABEL_14;
  }
  int v15 = *((_DWORD *)a2 + 3);
  a3[20] = 0;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = v15;
  if (a4) {
    *a4 = 0;
  }
  return v8;
}

void plugin_vimage_destroy(void *a1)
{
  if (a1)
  {
    unsigned int v2 = (void *)a1[3];
    if (v2) {
      free(v2);
    }
    free(a1);
  }
}

vImage_Error plugin_vimage_resize(int *a1, unsigned int *a2, uint64_t a3, int a4)
{
  vImagePixelCount v4 = *a2;
  uint64_t v5 = a1[4];
  int v6 = v5 + v4;
  if ((int)v5 + (int)v4 <= a1[1])
  {
    if ((int)v4 >= 1)
    {
      size_t v11 = *((void *)a2 + 1);
      uint64_t v12 = (void *)(*((void *)a2 + 5) + v11 * (int)a2[1]);
      size_t v13 = *((void *)a1 + 4);
      long long v14 = (void *)(*((void *)a1 + 3) + v13 * v5);
      src.width = *a1;
      src.rowBytes = v11;
      src.data = v12;
      src.height = v4;
      dest.width = a1[2];
      dest.rowBytes = v13;
      dest.data = v14;
      dest.height = v4;
      if (vImageScale_ARGB8888(&src, &dest, 0, 8u))
      {
LABEL_8:
        aj_log_error(0, "Error from vImage: %d");
        return 1;
      }
      int v6 = a1[4] + v4;
    }
    a1[4] = v6;
    if (!a4)
    {
      vImage_Error result = 0;
      *(void *)a3 = 0;
      return result;
    }
    int v15 = (void *)*((void *)a1 + 3);
    size_t v16 = *((void *)a1 + 4);
    vImagePixelCount v17 = a1[1];
    src.width = a1[2];
    src.rowBytes = v16;
    src.data = v15;
    src.height = v17;
    int16x8_t v18 = (void *)*((void *)a2 + 13);
    size_t v19 = *((void *)a2 + 9);
    dest.width = src.width;
    dest.rowBytes = v19;
    vImagePixelCount v20 = a1[3];
    dest.data = v18;
    dest.height = v20;
    vImage_Error result = vImageScale_ARGB8888(&src, &dest, 0, 8u);
    if (!result)
    {
      *(_DWORD *)(a3 + 4) = 0;
      *(_DWORD *)a3 = a1[3];
      return result;
    }
    goto LABEL_8;
  }
  aj_log_error(0, "Got too many rows from the recoder");
  return 1;
}

uint64_t aj_idct_s4(unsigned int *a1, void *a2, uint64_t a3)
{
  v3.i64[0] = 0x400040004000400;
  v3.i64[1] = 0x400040004000400;
  unsigned int v4 = a1[4];
  uint64_t v5 = (_WORD *)(a2[1] + a3);
  int64x2_t v6 = (int64x2_t)vaddq_s16((int16x8_t)*a1, (int16x8_t)v4);
  int32x2_t v7 = (int32x2_t)vsubq_s16(vtrn1q_s16((int16x8_t)*a1, (int16x8_t)v4), vtrn2q_s16((int16x8_t)*a1, (int16x8_t)v4)).u64[0];
  int16x8_t v8 = vsubq_s16((int16x8_t)*a1, (int16x8_t)v4);
  LODWORD(v9) = 0;
  WORD2(v9) = 0;
  HIWORD(v9) = v7.i16[1];
  v8.i16[2] = v7.i16[0];
  *(int32x2_t *)v6.i8 = vzip1_s32(*(int32x2_t *)v6.i8, v7);
  int16x8_t v10 = (int16x8_t)vzip1q_s64(v6, (int64x2_t)vsubq_s16(v8, (int16x8_t)v9));
  v10.i32[0] = vqrshrun_n_s16(vaddq_s16(vpaddq_s16(v10, v10), v3), 3uLL).u32[0];
  *(_WORD *)(*a2 + a3) = v10.i16[0];
  *uint64_t v5 = v10.i16[1];
  return 2;
}

uint64_t aj_find_and_handle_markers(int **a1, uint64_t *a2, int *a3)
{
  if (a3)
  {
    unsigned int v4 = a3 + 1;
    uint64_t v5 = a3 + 18;
    int64x2_t v6 = a3 + 19;
    int v7 = a3[17];
    int v8 = *a3;
    uint64_t v9 = (uint64_t)(a3 + 24);
    BOOL v10 = !a3[13] && !a3[16];
  }
  else
  {
    uint64_t v5 = (int *)a2 + 9;
    int64x2_t v6 = a2 + 4;
    uint64_t v9 = *a2;
    int v7 = (*a1)[851];
    int v8 = **a1;
    BOOL v10 = 1;
    unsigned int v4 = &comp_ind_table;
  }
  if (!*(void *)(v9 + 16) && *(int *)(v9 + 24) <= 6)
  {
    uint64_t result = aj_istream_fill_buf(v9, -9);
    if (result) {
      return result;
    }
  }
  if (v7 < 1 || *v6 != v7) {
    return 0;
  }
  int v12 = *v5 + 1;
  BOOL v13 = -v12 < 0;
  int v14 = -v12 & 7;
  int v15 = v12 & 7;
  if (!v13) {
    int v15 = -v14;
  }
  size_t v16 = *(unsigned __int8 **)(v9 + 16);
  if (v16)
  {
    int v17 = *v16;
    if ((v15 | 0xD0) == v17)
    {
      if (v8 > 0 && v10)
      {
        uint64_t v19 = v8;
        do
        {
          uint64_t v20 = *v4++;
          *((_DWORD *)a2 + v20 + 2) = 0;
          --v19;
        }
        while (v19);
      }
      uint64_t result = 0;
      *(_DWORD *)uint64_t v9 = 0;
      *(_DWORD *)(v9 + 24) = -9;
      *int64x2_t v6 = 0;
      *uint64_t v5 = v15 & 0xF;
      *(void *)(v9 + 16) = 0;
      if (*(int *)(v9 + 24) <= 6)
      {
        return aj_istream_fill_buf(v9, -9);
      }
      return result;
    }
    aj_log_error(0, "Bitstream corrupt: Wrong marker (%02X) found.", v17);
    return 7;
  }
  if (*(int *)(v9 + 32) > 1) {
    return 7;
  }
  uint64_t result = 7;
  if (*(unsigned char *)(v9 + 112))
  {
    if (*(_DWORD *)(v9 + 56) == 1) {
      return 4294967294;
    }
    else {
      return 7;
    }
  }
  return result;
}

uint64_t aj_mcu_decode(int **a1, uint64_t a2, uint64_t *a3, int a4, int a5, uint64_t a6, unsigned int *a7)
{
  uint64_t v112 = *MEMORY[0x263EF8340];
  int v14 = a1[1];
  uint64_t v110 = 0;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v103 = 0u;
  uint64_t v102 = 0;
  long long v100 = 0u;
  long long v101 = 0u;
  if (v14[91])
  {
    long long v15 = *((_OWORD *)a3 + 1);
    uint64_t v16 = a3[4];
    *((void *)&v100 + 1) = a3[1];
    long long v101 = v15;
    int v17 = &v103;
    uint64_t v102 = v16;
    *(void *)&long long v100 = &v103;
    int16x8_t v18 = (long long *)*a3;
    unint64_t v19 = *(void *)(*a3 + 16);
    if (v19 >= *(void *)(*a3 + 8) || v19 == 0) {
      unint64_t v19 = *(void *)(*a3 + 8);
    }
    *((void *)v18 + 13) = v19;
    long long v22 = v18[2];
    long long v21 = v18[3];
    long long v23 = v18[1];
    long long v103 = *v18;
    long long v104 = v23;
    long long v105 = v22;
    long long v106 = v21;
    long long v24 = v18[4];
    uint64_t v25 = *((void *)v18 + 14);
    long long v26 = v18[6];
    long long v108 = v18[5];
    long long v109 = v26;
    uint64_t v110 = v25;
    long long v107 = v24;
    int16x8_t v27 = (uint64_t *)&v100;
  }
  else
  {
    int v17 = (long long *)*a3;
    int16x8_t v27 = a3;
  }
  int v97 = (int *)(a1 + 24);
  unsigned int v28 = aj_find_and_handle_markers(a1, v27, 0);
  if (v28) {
    goto LABEL_11;
  }
  uint64_t v99 = v27;
  if (!*(_DWORD *)a2)
  {
LABEL_56:
    if (*((unsigned char *)a1 + 18))
    {
      char v30 = v97;
      uint64_t v66 = v99 + 1;
      unsigned int v28 = ((uint64_t (*)(int *, long long *, uint64_t *, uint64_t, void))a1[90])(v97, v17, v99 + 1, a6, *a7);
      if (v28)
      {
        int v29 = 1;
        goto LABEL_13;
      }
      unsigned int v28 = ((uint64_t (*)(int *, long long *, uint64_t *, uint64_t, void))a1[90])(v97, v17, v66, a6, *((_DWORD *)a1 + 227) + *a7);
      if (v28)
      {
        int v29 = 2;
        goto LABEL_13;
      }
      unsigned int v28 = ((uint64_t (*)(int *, long long *, uint64_t *, uint64_t, void))a1[90])(v97, v17, v66, a6 + 8 * *((int *)a1 + 182), *a7);
      if (v28)
      {
        int v29 = 3;
        goto LABEL_13;
      }
      unsigned int v28 = ((uint64_t (*)(int *, long long *, uint64_t *, uint64_t, void))a1[90])(v97, v17, v66, a6 + 8 * *((int *)a1 + 182), *((_DWORD *)a1 + 227) + *a7);
      if (v28)
      {
        int v29 = 4;
        goto LABEL_13;
      }
      unsigned int v28 = ((uint64_t (*)(int **, long long *, uint64_t, uint64_t, void))a1[286])(a1 + 220, v17, (uint64_t)v99 + 12, a6 + 128, a7[1]);
      if (v28)
      {
        int v29 = 5;
        goto LABEL_13;
      }
      unsigned int v28 = ((uint64_t (*)(int **, long long *, uint64_t *, uint64_t, void))a1[482])(a1 + 416, v17, v99 + 2, a6 + 256, a7[2]);
      if (v28)
      {
        int v29 = 6;
        goto LABEL_13;
      }
      unsigned int v89 = a7[1];
      *a7 += 2 * *((_DWORD *)a1 + 227);
      a7[1] = v89 + *((_DWORD *)a1 + 619);
      a7[2] += *((_DWORD *)a1 + 1011);
    }
    else
    {
      int v67 = *((_DWORD *)a1 + 49);
      char v30 = v97;
      if (v67 >= 1)
      {
        int v68 = 0;
        int v69 = 0;
        int v70 = *((_DWORD *)a1 + 48);
        int v96 = v14;
        while (v70 < 1)
        {
LABEL_66:
          if (++v68 >= v67) {
            goto LABEL_72;
          }
        }
        int v71 = 0;
        while (1)
        {
          unsigned int v28 = ((uint64_t (*)(int *, long long *, uint64_t *, uint64_t, void))a1[90])(v97, v17, v99 + 1, a6 + 8 * *((_DWORD *)a1 + 182) * v68, *a7 + *((_DWORD *)a1 + 227) * v71);
          if (v28) {
            break;
          }
          ++v71;
          int v70 = *v97;
          if (v71 >= *v97)
          {
            int v67 = *((_DWORD *)a1 + 49);
            v69 += v71;
            int v14 = v96;
            goto LABEL_66;
          }
        }
        int v29 = v69 + v71 + 1;
        int v14 = v96;
        goto LABEL_13;
      }
      int v69 = 0;
LABEL_72:
      int v72 = *a1;
      if (**a1 > 1)
      {
        int v94 = v69;
        uint64_t v73 = a6 + 128;
        BOOL v74 = a1 + 220;
        unsigned int v75 = (char *)v99 + 12;
        uint64_t v76 = 1;
        while (1)
        {
          unsigned int v28 = ((uint64_t (*)(int **, long long *, char *, uint64_t, void))v74[66])(v74, v17, v75, v73, a7[v76]);
          if (v28) {
            break;
          }
          ++v76;
          int v72 = *a1;
          v73 += 128;
          v74 += 196;
          v75 += 4;
          if (v76 >= **a1) {
            goto LABEL_76;
          }
        }
        int v29 = v94 + v76;
        goto LABEL_12;
      }
LABEL_76:
      *a7 += *((_DWORD *)a1 + 48) * *((_DWORD *)a1 + 227);
      if (*v72 >= 2)
      {
        uint64_t v77 = (_DWORD *)a1 + 619;
        uint64_t v78 = 1;
        do
        {
          a7[v78++] += *v77;
          v77 += 392;
        }
        while (v78 < *v72);
      }
    }
    if (v14[91])
    {
      uint64_t v79 = *a3;
      long long v80 = v101;
      *(_OWORD *)a3 = v100;
      *((_OWORD *)a3 + 1) = v80;
      a3[4] = v102;
      *a3 = v79;
      uint64_t v81 = v100;
      long long v83 = *(_OWORD *)v100;
      long long v82 = *(_OWORD *)(v100 + 16);
      long long v84 = *(_OWORD *)(v100 + 48);
      *(_OWORD *)(v79 + 32) = *(_OWORD *)(v100 + 32);
      *(_OWORD *)(v79 + 48) = v84;
      *(_OWORD *)uint64_t v79 = v83;
      long long v86 = *(_OWORD *)(v81 + 80);
      long long v85 = *(_OWORD *)(v81 + 96);
      long long v87 = *(_OWORD *)(v81 + 64);
      *(void *)(v79 + 112) = *(void *)(v81 + 112);
      *(_OWORD *)(v79 + 80) = v86;
      *(_OWORD *)(v79 + 96) = v85;
      *(_OWORD *)(v79 + 64) = v87;
      *(_OWORD *)(v79 + 16) = v82;
      *(void *)(*a3 + 104) = 0;
    }
    int32x2_t v88 = vadd_s32(*(int32x2_t *)((char *)a3 + 28), (int32x2_t)0x100000001);
    *(uint64_t *)((char *)a3 + 28) = (uint64_t)v88;
    uint64_t result = 0;
    if (v88.i32[0] >= v14[20]) {
      a3[3] = (*((_DWORD *)a3 + 6) + 1);
    }
    return result;
  }
  if (*(_DWORD *)(a2 + 48) == a5 && *(_DWORD *)(a2 + 44) == a4)
  {
    uint64_t v57 = *(int *)(a2 + 52);
    int v58 = *(_DWORD *)(a2 + 56);
    uint64_t v93 = *(void *)(*((void *)v14 + 13) + 8 * v57);
    *(_DWORD *)(a2 + 56) = v58 + 1;
    int v59 = v14[29] + a5;
    *(_DWORD *)(a2 + 48) = v59;
    if (v59 >= v14[20])
    {
      *(_DWORD *)(a2 + 48) = 0;
      *(_DWORD *)(a2 + 52) = v57 + 1;
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 44) = v14[28] + a4;
    }
    unsigned int v28 = aj_istream_state_save((uint64_t)v17, v93 + 20 * v58);
    if (v28) {
      goto LABEL_11;
    }
    if (**a1 >= 1)
    {
      uint64_t v60 = 0;
      do
      {
        *(_WORD *)(v93 + 20 * v58 + 8 + 2 * v60) = *((_DWORD *)v99 + v60 + 2);
        ++v60;
      }
      while (v60 < **a1);
    }
  }
  long long v61 = *(unsigned __int16 **)(a2 + 16);
  if (!v61 || *v61 != a4 || v61[1] != a5) {
    goto LABEL_56;
  }
  unsigned int v28 = aj_istream_state_save((uint64_t)v17, (uint64_t)(v61 + 2));
  if (!v28)
  {
    for (uint64_t i = 0; i != 4; ++i)
    {
      if (i >= *((int *)v17 + 8)) {
        break;
      }
      *((unsigned char *)v61 + i + 12) = *(unsigned char *)(*((void *)v17 + 1) + i);
    }
    *((unsigned char *)v61 + 16) = i;
    unint64_t v63 = *(void *)(a2 + 16);
    if (v63 >= (unint64_t)(a1[1] + 83))
    {
      unint64_t v64 = 0;
    }
    else
    {
      int v65 = *(unsigned __int16 *)(v63 + 24);
      unint64_t v64 = v63 + 24;
      if (*(_DWORD *)(a2 + 12) <= v65) {
        unint64_t v64 = 0;
      }
    }
    *(void *)(a2 + 16) = v64;
    goto LABEL_56;
  }
LABEL_11:
  int v29 = 0;
LABEL_12:
  char v30 = v97;
LABEL_13:
  int v31 = v14[91];
  if (v28 == -2)
  {
    if (v31)
    {
      restore_mcustate(a3, (uint64_t)&v100);
      return 4294967294;
    }
  }
  else if (v31)
  {
    uint64_t v33 = *a3;
    long long v34 = v101;
    *(_OWORD *)a3 = v100;
    *((_OWORD *)a3 + 1) = v34;
    a3[4] = v102;
    *a3 = v33;
    uint64_t v35 = v100;
    long long v37 = *(_OWORD *)v100;
    long long v36 = *(_OWORD *)(v100 + 16);
    long long v38 = *(_OWORD *)(v100 + 48);
    *(_OWORD *)(v33 + 32) = *(_OWORD *)(v100 + 32);
    *(_OWORD *)(v33 + 48) = v38;
    *(_OWORD *)uint64_t v33 = v37;
    long long v40 = *(_OWORD *)(v35 + 80);
    long long v39 = *(_OWORD *)(v35 + 96);
    long long v41 = *(_OWORD *)(v35 + 64);
    *(void *)(v33 + 112) = *(void *)(v35 + 112);
    *(_OWORD *)(v33 + 80) = v40;
    *(_OWORD *)(v33 + 96) = v39;
    *(_OWORD *)(v33 + 64) = v41;
    *(_OWORD *)(v33 + 16) = v36;
    *(void *)(*a3 + 104) = 0;
  }
  unsigned int v91 = v28;
  uint64_t v42 = *((unsigned int *)a1 + 1616);
  memset(v111, 0, sizeof(v111));
  if (v29 && (int)v42 >= 1)
  {
    uint64_t v92 = a6;
    uint64_t v95 = v42;
    int v90 = a1;
    int v98 = a7;
    uint64_t v43 = 0;
    int v44 = 0;
    do
    {
      uint64_t v45 = &v30[392 * v43];
      int v46 = v45[1];
      if (v46 >= 1)
      {
        int v47 = 0;
        int v48 = &v30[392 * v43];
        uint64_t v49 = (void (**)(_OWORD *, uint64_t, void))(v48 + 130);
        uint64_t v50 = v48 + 134;
        char v51 = v48 + 179;
        int v52 = *v45;
        do
        {
          if (v52 >= 1)
          {
            for (int j = 0; j < v52; ++j)
            {
              if (v44 + j >= v29)
              {
                (*v49)(v111, v92 + (v43 << 7) + 8 * *v50 * v47, (v98[v43] + *v51 * j));
                int v52 = *v45;
              }
            }
            int v46 = v45[1];
            v44 += j;
          }
          ++v47;
        }
        while (v47 < v46);
      }
      ++v43;
      uint64_t v54 = v95;
      char v30 = v97;
    }
    while (v43 != v95);
    long long v55 = v98;
    long long v56 = v90;
    do
    {
      *v55++ += *((_DWORD *)v56 + 48) * *((_DWORD *)v56 + 227);
      v56 += 196;
      --v54;
    }
    while (v54);
  }
  return v91;
}

uint64_t *restore_mcustate(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  uint64_t v3 = *(void *)(*result + 104);
  int v4 = v3 - *(_DWORD *)(*(void *)a2 + 104);
  int v5 = *(_DWORD *)(*(void *)a2 + 48);
  *(void *)(v2 + 104) = v3 - v4;
  uint64_t v6 = *(void *)(v2 + 16);
  *(void *)(v2 + 8) -= v4;
  int v7 = *(_DWORD *)(v2 + 48);
  if (v6) {
    *(void *)(v2 + 16) = v6 - v4;
  }
  *(_DWORD *)(v2 + 48) = v5;
  *(_DWORD *)(v2 + 32) += v5 - v7;
  return result;
}

uint64_t aj_mcu_decode_index(int **a1, uint64_t a2, uint64_t *a3, int a4, int a5)
{
  BOOL v10 = (unsigned int *)a1[1];
  uint64_t v11 = **a1;
  uint64_t v66 = 0;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v59 = 0u;
  uint64_t v58 = 0;
  long long v56 = 0u;
  long long v57 = 0u;
  if (v10[91])
  {
    long long v12 = *((_OWORD *)a3 + 1);
    uint64_t v13 = a3[4];
    *((void *)&v56 + 1) = a3[1];
    long long v57 = v12;
    int v14 = &v59;
    uint64_t v58 = v13;
    *(void *)&long long v56 = &v59;
    long long v15 = (long long *)*a3;
    unint64_t v16 = *(void *)(*a3 + 16);
    if (v16 >= *(void *)(*a3 + 8) || v16 == 0) {
      unint64_t v16 = *(void *)(*a3 + 8);
    }
    *((void *)v15 + 13) = v16;
    long long v19 = v15[2];
    long long v18 = v15[3];
    long long v20 = v15[1];
    long long v59 = *v15;
    long long v60 = v20;
    long long v61 = v19;
    long long v62 = v18;
    long long v21 = v15[4];
    uint64_t v22 = *((void *)v15 + 14);
    long long v23 = v15[6];
    long long v64 = v15[5];
    long long v65 = v23;
    uint64_t v66 = v22;
    long long v63 = v21;
    long long v24 = &v56;
  }
  else
  {
    int v14 = (long long *)*a3;
    long long v24 = (long long *)a3;
  }
  uint64_t v25 = aj_find_and_handle_markers(a1, (uint64_t *)v24, 0);
  if (v25) {
    goto LABEL_11;
  }
  if (*(_DWORD *)a2 && *(_DWORD *)(a2 + 48) == a5 && *(_DWORD *)(a2 + 44) == a4)
  {
    uint64_t v27 = *(int *)(a2 + 52);
    int v28 = *(_DWORD *)(a2 + 56);
    uint64_t v29 = *(void *)(*((void *)v10 + 13) + 8 * v27);
    *(_DWORD *)(a2 + 56) = v28 + 1;
    signed int v30 = v10[29] + a5;
    *(_DWORD *)(a2 + 48) = v30;
    if (v30 >= (int)v10[20])
    {
      *(_DWORD *)(a2 + 48) = 0;
      *(_DWORD *)(a2 + 52) = v27 + 1;
      *(_DWORD *)(a2 + 56) = 0;
      *(_DWORD *)(a2 + 44) = v10[28] + a4;
    }
    if (v29)
    {
      uint64_t v54 = v29;
      int v55 = v28;
      uint64_t v25 = aj_istream_state_save((uint64_t)v14, v29 + 20 * v28);
      if (v25) {
        goto LABEL_11;
      }
      if ((int)v11 >= 1)
      {
        int v31 = (_WORD *)(v54 + 20 * v55 + 8);
        int8x8x4_t v32 = (int *)v24 + 2;
        do
        {
          int v33 = *v32++;
          *v31++ = v33;
          --v11;
        }
        while (v11);
      }
    }
  }
  long long v34 = *(unsigned __int16 **)(a2 + 16);
  if (v34 && *v34 == a4 && v34[1] == a5)
  {
    uint64_t v25 = aj_istream_state_save((uint64_t)v14, (uint64_t)(v34 + 2));
    if (v25) {
      goto LABEL_11;
    }
    for (uint64_t i = 0; i != 4; ++i)
    {
      if (i >= *((int *)v14 + 8)) {
        break;
      }
      *((unsigned char *)v34 + i + 12) = *(unsigned char *)(*((void *)v14 + 1) + i);
    }
    *((unsigned char *)v34 + 16) = i;
    unint64_t v36 = *(void *)(a2 + 16);
    if (v36 >= (unint64_t)(a1[1] + 83))
    {
      unint64_t v37 = 0;
    }
    else
    {
      int v38 = *(unsigned __int16 *)(v36 + 24);
      unint64_t v37 = v36 + 24;
      if (*(_DWORD *)(a2 + 12) <= v38) {
        unint64_t v37 = 0;
      }
    }
    *(void *)(a2 + 16) = v37;
  }
  if ((int)v10[22] >= 1)
  {
    int v39 = 0;
    do
    {
      uint64_t v40 = aj_block_decode_skip((uint64_t)(a1 + 24), (uint64_t)v14, (_DWORD *)v24 + 2);
      if (v40) {
        goto LABEL_49;
      }
    }
    while (++v39 < (int)v10[22]);
  }
  if (**a1 > 1)
  {
    uint64_t v41 = (uint64_t)(a1 + 220);
    uint64_t v42 = (_DWORD *)v24 + 3;
    uint64_t v43 = 1;
    while (1)
    {
      uint64_t v40 = aj_block_decode_skip(v41, (uint64_t)v14, v42);
      if (v40) {
        break;
      }
      ++v43;
      v41 += 1568;
      ++v42;
      if (v43 >= **a1) {
        goto LABEL_45;
      }
    }
LABEL_49:
    uint64_t v25 = v40;
LABEL_11:
    if (v10[91]) {
      restore_mcustate(a3, (uint64_t)&v56);
    }
    return v25;
  }
LABEL_45:
  if (v10[91])
  {
    uint64_t v44 = *a3;
    long long v45 = v57;
    *(_OWORD *)a3 = v56;
    *((_OWORD *)a3 + 1) = v45;
    a3[4] = v58;
    *a3 = v44;
    uint64_t v46 = v56;
    long long v48 = *(_OWORD *)v56;
    long long v47 = *(_OWORD *)(v56 + 16);
    long long v49 = *(_OWORD *)(v56 + 48);
    *(_OWORD *)(v44 + 32) = *(_OWORD *)(v56 + 32);
    *(_OWORD *)(v44 + 48) = v49;
    *(_OWORD *)uint64_t v44 = v48;
    long long v51 = *(_OWORD *)(v46 + 80);
    long long v50 = *(_OWORD *)(v46 + 96);
    long long v52 = *(_OWORD *)(v46 + 64);
    *(void *)(v44 + 112) = *(void *)(v46 + 112);
    *(_OWORD *)(v44 + 80) = v51;
    *(_OWORD *)(v44 + 96) = v50;
    *(_OWORD *)(v44 + 64) = v52;
    *(_OWORD *)(v44 + 16) = v47;
    *(void *)(*a3 + 104) = 0;
  }
  int32x2_t v53 = vadd_s32(*(int32x2_t *)((char *)a3 + 28), (int32x2_t)0x100000001);
  *(uint64_t *)((char *)a3 + 28) = (uint64_t)v53;
  uint64_t v25 = 0;
  if (v53.i32[0] >= (int)v10[20]) {
    a3[3] = (*((_DWORD *)a3 + 6) + 1);
  }
  return v25;
}

uint64_t aj_mcu_decode_progressive(void *a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v117 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  int v12 = *(_DWORD *)(*a1 + 8);
  int v14 = v12 + 7;
  BOOL v13 = v12 < -7;
  int v15 = v12 + 14;
  if (!v13) {
    int v15 = v14;
  }
  if (*(_DWORD *)(v10 + 16) + *(_DWORD *)(v10 + 16) * a5 > v15 >> 3) {
    int v16 = 1;
  }
  else {
    int v16 = *(_DWORD *)(v10 + 16);
  }
  int v17 = *(_DWORD *)(v11 + 404);
  uint64_t v110 = v17;
  uint64_t v111 = a1[1];
  if (*(_DWORD *)(v10 + 32) == 2)
  {
    if (!a5)
    {
      bzero(*(void **)(v11 + 424), *(int *)(v11 + 432));
      if (v17 >= 1)
      {
        uint64_t v64 = 0;
        int v107 = a4 + 1;
        uint64_t v65 = 280;
        do
        {
          uint64_t v66 = *(void *)(v11 + 408);
          uint64_t v67 = v66 + 288 * v64;
          if (*(_DWORD *)(v67 + 280))
          {
            unsigned __int8 v113 = (_DWORD *)(v67 + 280);
            int v68 = (int *)(v66 + 288 * v64);
            uint64_t v69 = a1[1];
            if (*v68 != 1)
            {
              int v71 = (int *)*a1;
LABEL_101:
              if (v71[20] == 194 && v68[13] >= 1) {
                uint64_t v89 = *(void *)(v69 + 424) + ((uint64_t)*((int *)a1 + v68[1] + 1617) << 7);
              }
              else {
                uint64_t v89 = *(void *)(v69 + 424);
              }
              if (*(int *)(v69 + 80) >= 1)
              {
                int v90 = 0;
                unsigned int v91 = (uint64_t (**)(void *, uint64_t, int *, uint64_t))(v66 + 288 * v64 + 88);
                do
                {
                  if (!*v113) {
                    break;
                  }
                  uint64_t result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v68);
                  if (result) {
                    return result;
                  }
                  int v92 = (*v91)(a1, a3, v68, v89);
                  uint64_t v93 = a1[1];
                  if (v92)
                  {
                    if (!v64) {
                      goto LABEL_117;
                    }
                    *(unsigned char *)(v93 + 400) = 1;
                    uint64_t v94 = *(int *)(v93 + 404);
                    if (v64 < v94)
                    {
                      uint64_t v95 = (_DWORD *)(*(void *)(v93 + 408) + v65);
                      do
                      {
                        *uint64_t v95 = 0;
                        --v94;
                        v95 += 72;
                      }
                      while (v64 != v94);
                    }
                  }
                  ++v90;
                  v89 += (uint64_t)*(int *)(v93 + 92) << 7;
                }
                while (v90 < *(_DWORD *)(v93 + 80));
              }
              goto LABEL_115;
            }
            int v70 = v68[1];
            int v71 = (int *)*a1;
            if (v70) {
              goto LABEL_101;
            }
            int v72 = v71[3];
            int v73 = v72 + 7;
            BOOL v13 = v72 < -7;
            int v74 = v72 + 14;
            if (!v13) {
              int v74 = v73;
            }
            int v102 = v74 >> 3;
            int v101 = v71[8] * v107;
            long long v108 = (unsigned int (**)(void *, uint64_t, int *, uint64_t))(v66 + 288 * v64 + 88);
            char v75 = 1;
            uint64_t v76 = a1[1];
            uint64_t v103 = v76;
            do
            {
              if (!*v113) {
                break;
              }
              char v104 = v75;
              if (*(int *)(v76 + 80) >= 1)
              {
                int v77 = 0;
                int v78 = *(_DWORD *)(*a1 + 8);
                int v79 = v78 + 7;
                BOOL v13 = v78 < -7;
                int v80 = v78 + 14;
                if (!v13) {
                  int v80 = v79;
                }
                int v81 = v80 >> 3;
                uint64_t v82 = *(void *)(v69 + 424) + ((*(int *)(*a1 + 16) * (uint64_t)v70) << 7);
                do
                {
                  int v83 = *(_DWORD *)(*a1 + 16);
                  if (v83 >= v81) {
                    uint64_t v84 = v81;
                  }
                  else {
                    uint64_t v84 = v83;
                  }
                  if ((int)v84 >= 1)
                  {
                    uint64_t v85 = 0;
                    int v105 = v81 - v84;
                    int v106 = v77;
                    while (*v113)
                    {
                      uint64_t result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v68);
                      if (result) {
                        return result;
                      }
                      if ((*v108)(a1, a3, v68, v82 + (v85 << 7)))
                      {
                        if (!v64) {
                          goto LABEL_117;
                        }
                        uint64_t v86 = a1[1];
                        *(unsigned char *)(v86 + 400) = 1;
                        uint64_t v87 = *(int *)(v86 + 404);
                        if (v64 < v87)
                        {
                          uint64_t v88 = *(void *)(v86 + 408);
                          do
                          {
                            *(_DWORD *)(v88 + v65) = 0;
                            --v87;
                            v88 += 288;
                          }
                          while (v64 != v87);
                        }
                      }
                      ++v85;
                      --v81;
                      if (v85 == v84)
                      {
                        int v81 = v105;
                        break;
                      }
                    }
                    uint64_t v76 = a1[1];
                    int v77 = v106;
                  }
                  if (++v77 >= *(_DWORD *)(v76 + 80)) {
                    break;
                  }
                  v82 += (uint64_t)*(int *)(v76 + 92) << 7;
                }
                while (*v113);
              }
              int v70 = 1;
              char v75 = 0;
              uint64_t v69 = v103;
            }
            while (((v101 <= v102) & v104) != 0);
          }
LABEL_115:
          ++v64;
          v65 += 288;
          uint64_t v11 = v111;
        }
        while (v64 != v110);
      }
    }
    __memcpy_chk();
    goto LABEL_28;
  }
  int v112 = v16;
  aj_clear_blocks(v116, *(_DWORD *)(v11 + 92));
  if (v17 < 1)
  {
LABEL_28:
    int v32 = *(_DWORD *)(a3 + 28) + 1;
    *(_DWORD *)(a3 + 28) = v32;
    if (v32 >= *(_DWORD *)(a1[1] + 80)) {
      *(void *)(a3 + 24) = (*(_DWORD *)(a3 + 24) + 1);
    }
    uint64_t result = 0;
    if (a6 && a7)
    {
      if (*(_DWORD *)(*a1 + 4) == 8)
      {
        int v33 = *((_DWORD *)a1 + 1616);
        if (v33 >= 1)
        {
          uint64_t v34 = 0;
          uint64_t v35 = (int32x4_t *)(a1 + 30);
          unint64_t v36 = (int16x4_t *)v116;
          do
          {
            if (v34) {
              int v37 = 1;
            }
            else {
              int v37 = *(_DWORD *)(a1[1] + 88);
            }
            int v38 = (int32x4_t *)&a1[196 * v34];
            int v39 = v38 + 15;
            switch(v38[56].i32[2])
            {
              case 1:
                if (v37 >= 1)
                {
                  do
                  {
                    uint64_t v40 = v36;
                    v36 += 16;
                    aj_block_dequantize_s1(v40, v39);
                    --v37;
                  }
                  while (v37);
                  int v33 = *((_DWORD *)a1 + 1616);
                }
                break;
              case 2:
                if (v37 >= 1)
                {
                  for (int i = 0; i != v37; ++i)
                  {
                    unint64_t v42 = -8;
                    uint64_t v43 = v36;
                    uint64_t v44 = v35;
                    do
                    {
                      int32x4_t v45 = *v44;
                      v44 += 2;
                      int16x4_t *v43 = vmul_s16(*v43, vmovn_s32(v45));
                      v43 += 2;
                      v42 += 8;
                    }
                    while (v42 < 0x11);
                    v36 += 16;
                  }
                }
                break;
              case 4:
                if (v37 >= 1)
                {
                  __int32 v46 = v39->i32[0];
                  __int32 v47 = v39->i32[1];
                  __int32 v48 = v39[2].i32[0];
                  __int32 v49 = v39[2].i32[1];
                  do
                  {
                    long long v50 = v36 + 16;
                    v36->i16[0] *= (_WORD)v46;
                    v36->i16[1] *= (_WORD)v47;
                    v36[2].i16[0] *= (_WORD)v48;
                    v36[2].i16[1] *= (_WORD)v49;
                    v36 += 16;
                    --v37;
                  }
                  while (v37);
                  unint64_t v36 = v50;
                }
                break;
              case 8:
                if (v37 >= 1)
                {
                  __int32 v51 = v39->i32[0];
                  do
                  {
                    v36->i16[0] *= (_WORD)v51;
                    v36 += 16;
                    --v37;
                  }
                  while (v37);
                }
                break;
              default:
                break;
            }
            ++v34;
            v35 += 98;
          }
          while (v34 < v33);
        }
      }
      long long v52 = a7;
      int v53 = *a7;
      v115[0] = v53;
      v115[1] = v53;
      int v54 = *((_DWORD *)a1 + 49);
      if (v54 < 1)
      {
        int v56 = 0;
      }
      else
      {
        uint64_t v55 = 0;
        int v56 = 0;
        int v57 = *((_DWORD *)a1 + 48);
        do
        {
          if (v57 >= 1)
          {
            int v58 = 0;
            long long v59 = (__int16 *)&v116[128 * (uint64_t)v56];
            do
            {
              if (*(_DWORD *)(*a1 + 4) == 12)
              {
                aj_block_dequantize_12bit((_DWORD *)a1 + 48, v59, v114);
                unsigned int v60 = v115[v55];
                v115[v55] = ((uint64_t (*)(_DWORD *, uint64_t, void))a1[89])(v114, a6 + 8 * *((_DWORD *)a1 + 182) * (int)v55, v60)+ v60;
              }
              else
              {
                uint64_t v61 = v115[v55];
                long long v62 = (uint64_t *)(a6 + 8 * *((_DWORD *)a1 + 182) * (int)v55);
                v115[v55] = ((uint64_t (*)(__int16 *, uint64_t *, uint64_t))a1[89])(v59, v62, v61) + v61;
                if (*((unsigned char *)a1 + 1232)) {
                  aj_mosquito_spray((uint64_t)(a1 + 24), (uint64_t)v59, v62, v61);
                }
              }
              ++v58;
              int v57 = *((_DWORD *)a1 + 48);
              v59 += 64;
            }
            while (v58 < v57);
            v56 += v58;
            int v54 = *((_DWORD *)a1 + 49);
          }
          ++v55;
        }
        while (v55 < v54);
        int v53 = v115[0];
        long long v52 = a7;
      }
      *long long v52 = v53;
      if (*((int *)a1 + 1616) > 1)
      {
        int v96 = (__int16 *)&v116[128 * (uint64_t)v56];
        uint64_t v97 = a6 + 128;
        int v98 = a1 + 220;
        uint64_t v99 = 1;
        do
        {
          if (*(_DWORD *)(*a1 + 4) == 12)
          {
            aj_block_dequantize_12bit(v98, v96, v114);
            int v100 = ((uint64_t (*)(_DWORD *, uint64_t, void))v98[65])(v114, v97, v52[v99]);
          }
          else
          {
            int v100 = ((uint64_t (*)(__int16 *, uint64_t, void))v98[65])(v96, v97, v52[v99]);
          }
          v52[v99++] += v100;
          v96 += 64;
          v97 += 128;
          v98 += 196;
        }
        while (v99 < *((int *)a1 + 1616));
      }
      return 0;
    }
    return result;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 280;
  while (1)
  {
    uint64_t v20 = *(void *)(v11 + 408);
    long long v21 = (int *)(v20 + 288 * v18);
    if (v21[70])
    {
      if (*v21 == 1)
      {
        int v22 = v112;
        if (v21[1]) {
          int v22 = 1;
        }
      }
      else
      {
        int v22 = 1;
      }
      int v23 = v21[13];
      if (v23) {
        int v23 = *((_DWORD *)a1 + v21[1] + 1617);
      }
      if (v22 >= 1) {
        break;
      }
    }
LABEL_27:
    ++v18;
    v19 += 288;
    uint64_t v11 = v111;
    if (v18 == v110) {
      goto LABEL_28;
    }
  }
  uint64_t v24 = 0;
  uint64_t v25 = &v116[128 * (uint64_t)v23];
  long long v26 = (unsigned int (**)(void *, uint64_t, int *, unsigned char *))(v20 + 288 * v18 + 88);
  uint64_t v27 = v22;
  while (1)
  {
    uint64_t result = aj_find_and_handle_markers((int **)a1, (uint64_t *)a3, v21);
    if (result) {
      return result;
    }
    if ((*v26)(a1, a3, v21, &v25[128 * v24]))
    {
      if (!v18)
      {
LABEL_117:
        aj_log_error(0, "First scan failed, abort decode");
        return 7;
      }
      uint64_t v29 = a1[1];
      *(unsigned char *)(v29 + 400) = 1;
      uint64_t v30 = *(int *)(v29 + 404);
      if (v18 < v30)
      {
        int v31 = (_DWORD *)(*(void *)(v29 + 408) + v19);
        do
        {
          *int v31 = 0;
          --v30;
          v31 += 72;
        }
        while (v18 != v30);
      }
    }
    if (++v24 == v27) {
      goto LABEL_27;
    }
  }
}

uint64_t aj_pack_all(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return loop_through_image(*(_DWORD *)(*(void *)(a1 + 8) + 80), *(_DWORD *)(*(void *)(a1 + 8) + 84), 0, a2, a3, a1, 0);
}

uint64_t loop_through_image(int a1, int a2, int a3, uint64_t *a4, uint64_t a5, uint64_t a6, int32x2_t *a7)
{
  if (a2 < 1) {
    return 0;
  }
  for (int i = 0; i != a2; ++i)
  {
    for (uint64_t j = 0; j != 3; ++j)
    {
      int v16 = &a4[j];
      uint64_t v17 = a4[j];
      uint64_t *v16 = a4[j + 3];
      v16[3] = v17;
    }
    if (a1 >= 1)
    {
      int v18 = a1;
      do
      {
        if (a3)
        {
          uint64_t result = aj_mcu_unpack(a4, a5, a7);
          if (result) {
            return result;
          }
        }
        else
        {
          uint64_t result = aj_mcu_pack(a4, a6, a5);
          if (result) {
            return result;
          }
        }
        --v18;
      }
      while (v18);
    }
  }
  return 0;
}

uint64_t aj_unpack_all(uint64_t *a1, uint64_t a2, int32x2_t *a3)
{
  return loop_through_image(*(_DWORD *)(a1[17718] + 80), *(_DWORD *)(a1[17718] + 84), 1, a1, a2, 0, a3);
}

unint64_t aj_RGBA8888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  if (a1 == 1)
  {
    aj_RGBA8888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    int v12 = a2[1];
    BOOL v13 = *a2;
    int v14 = *(int8x8_t **)a3;
    int v15 = *(unsigned char **)(a3 + 8);
    int v16 = *(unsigned char **)(a3 + 16);
    uint64_t v17 = *(unsigned char **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    int16x8_t v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (unsigned int i = a4 >> 4; i; --i)
    {
      int8x8x4_t v66 = vld4_s8(v13);
      int v22 = v13 + 32;
      int8x8x4_t v68 = vld4_s8(v22);
      BOOL v13 = v22 + 32;
      int16x8_t v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      int16x8_t v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      int16x8_t v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      int16x8_t v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      int16x8_t v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      int16x8_t v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[2];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *int v14 = v66.val[0];
      int v31 = v14 + 1;
      *int v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      int v14 = v31 + 1;
      int8x8x4_t v67 = vld4_s8(v12);
      int v32 = v12 + 32;
      int8x8x4_t v69 = vld4_s8(v32);
      int v12 = v32 + 32;
      int16x8_t v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      int16x8_t v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      int16x8_t v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      int16x8_t v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      int16x8_t v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      int16x8_t v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(void *)int v15 = v5.i64[0];
      int v39 = v15 + 8;
      *int v39 = v8.i64[0];
      int v15 = v39 + 1;
      uint64_t v40 = v9.i64[0];
      uint64_t v41 = v10.i64[0];
      int64x2_t v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      int64x2_t v7 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[2].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(void *)int v16 = v6.i64[0];
      v16 += 8;
      *(void *)uint64_t v17 = v7.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x4_t *)((char *)&v6 - 8) = vld4_s8(v13);
      v13 += 32;
      int8x8x4_t v70 = vld4_s8(v12);
      v12 += 32;
      int16x8_t v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      int16x8_t v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      int16x8_t v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      int16x8_t v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      int16x8_t v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v5.i8;
      *(void *)int v15 = v8.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v10.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), *(int16x4_t *)v10.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_DWORD *)int v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)uint64_t v17 = v7.i32[0];
      v17 += 4;
    }
    int v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        int64x2_t v8 = vshlq_n_s64(v8, 8uLL);
        int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
        int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 4;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 4;
        --v49;
      }
      while (v49);
      int v50 = a4 & 7;
      int v51 = 8 - v50;
      unsigned int v52 = (v50 + 1) >> 1;
      int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      int16x8_t v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      int16x8_t v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        int64x2_t v5 = vsliq_n_s64(v5, v5, 8uLL);
        int64x2_t v6 = vsliq_n_s64(v6, v6, 8uLL);
        int64x2_t v7 = vsliq_n_s64(v7, v7, 8uLL);
        int64x2_t v8 = vsliq_n_s64(v8, v8, 8uLL);
        int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
        int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v10.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      do
      {
        v14->i8[0] = v5.i8[7];
        int v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v8.i8[7];
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        int64x2_t v8 = vshlq_n_s64(v8, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v7.i8[3];
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        --v52;
      }
      while (v52);
    }
    unint64_t result = a5 - a4;
    if (a5 != a4)
    {
      unsigned int v59 = result >> 1;
      __int8 v60 = v14[-1].i8[7];
      char v61 = *(v15 - 1);
      char v62 = *(v16 - 1);
      char v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        int v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        unint64_t result = (result - 1);
      }
      while (result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t aj_handle_partial_progressive_decode(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  memset(v17, 0, sizeof(v17));
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(int *)(v2 + 404) >= 1)
  {
    uint64_t v3 = 0;
    for (uint64_t i = 0; i < *(int *)(v2 + 404); ++i)
    {
      int64x2_t v5 = (unsigned int *)(*(void *)(v2 + 408) + v3);
      if (v5[70])
      {
        if (aj_fill_coeffblock_from_scan_info(v5, (uint64_t)v17, *(_DWORD *)(a1 + 6464))) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v2 = *(void *)(a1 + 8);
      }
      v3 += 288;
    }
  }
  unint64_t v6 = *(unsigned int *)(a1 + 6464);
  if ((int)v6 < 1)
  {
    int v8 = 0;
  }
  else
  {
    uint64_t v7 = 0;
    int v8 = 1;
    for (uint64_t j = (__int16 *)v17; ; j += 64)
    {
      uint64_t v10 = *(unsigned int *)(a1 + 1568 * v7 + 728);
      if ((int)v10 >= 1) {
        break;
      }
LABEL_15:
      int v8 = ++v7 < v6;
      if (v7 == v6) {
        return (v8 << 31 >> 31);
      }
    }
    uint64_t v11 = 0;
    int v12 = j;
LABEL_11:
    uint64_t v13 = *(unsigned int *)(a1 + 1568 * v7 + 728);
    int v14 = v12;
    while (1)
    {
      int v15 = *v14++;
      if (v15 != -1) {
        break;
      }
      if (!--v13)
      {
        ++v11;
        v12 += 8;
        if (v11 != v10) {
          goto LABEL_11;
        }
        goto LABEL_15;
      }
    }
  }
  return (v8 << 31 >> 31);
}

uint64_t aj_decode_all(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(*(void *)a1 + 86))
  {
    int64x2_t v5 = *(void (***)(void, uint64_t, uint64_t, uint64_t, void))(a2 + 1488);
    if (*(_DWORD *)(a1 + 6612))
    {
      unint64_t v6 = (uint64_t (*)(uint64_t, uint64_t, int *))get_row_lpf;
      uint64_t v7 = 1;
    }
    else
    {
      uint64_t v7 = *(unsigned int *)(a1 + 172);
      unint64_t v6 = fill_coeff_buffer;
    }
    uint64_t v8 = *(unsigned int *)(a2 + 80);
    uint64_t v9 = *(unsigned int *)(a2 + 84);
    int v10 = *(_DWORD *)(a1 + 6848);
    if ((int)v9 + *(_DWORD *)(*(void *)(a1 + 8) + 80) * (int)v8 >= v10
                                                                      + (*(_DWORD *)(a2 + 28) - 1)
                                                                      * *(_DWORD *)(*(void *)(a1 + 8) + 80))
    {
LABEL_21:
      if (!*(_DWORD *)a2
        || (uint64_t v16 = move_to_mcu((int **)a1, a2, a2 + 112, *(unsigned int *)(a2 + 12), 0), !v16))
      {
        uint64_t v17 = *(void *)(a1 + 8);
        if ((*(_DWORD *)(v17 + 136) - 1) <= 1)
        {
          *(_DWORD *)(v17 + 136) = 3;
          *(_DWORD *)a2 = 0;
        }
        if (*(_DWORD *)(a2 + 1496))
        {
          int v18 = (*(uint64_t (**)(void))(a2 + 1504))(*(void *)(a2 + 1512));
          *(_DWORD *)(a2 + 1520) = *(_DWORD *)(a2 + 1496);
          if (v18) {
            uint64_t v16 = 10;
          }
          else {
            uint64_t v16 = 0;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
      }
LABEL_44:
      if (*(unsigned char *)(a2 + 560)) {
        BOOL v22 = v16 == -2;
      }
      else {
        BOOL v22 = 1;
      }
      if (!v22) {
        aj_return_rowptrs(a1, a2, (unint64_t *)(a2 + 568));
      }
      if (*(unsigned char *)(*(void *)(a1 + 8) + 400)) {
        BOOL v23 = v16 == 0;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23) {
        return aj_handle_partial_progressive_decode(a1);
      }
      return v16;
    }
    if (*(_DWORD *)(a2 + 1088))
    {
LABEL_10:
      int v24 = v8;
      if (*(_DWORD *)(a2 + 64) < *(_DWORD *)(a2 + 60))
      {
        do
        {
          if (*(_DWORD *)(a2 + 1496))
          {
            int v11 = *(_DWORD *)(a2 + 1520);
            if (!v11)
            {
              int v12 = (*(uint64_t (**)(void))(a2 + 1504))(*(void *)(a2 + 1512));
              int v11 = *(_DWORD *)(a2 + 1496);
              if (v12)
              {
                *(_DWORD *)(a2 + 1520) = v11 - 1;
                uint64_t v16 = 10;
                goto LABEL_44;
              }
            }
            *(_DWORD *)(a2 + 1520) = v11 - 1;
          }
          uint64_t v13 = v6(a1, a2, &v24);
          if (v13)
          {
            uint64_t v16 = v13;
            goto LABEL_44;
          }
          if (*(unsigned char *)(a1 + 6945))
          {
            (*v5)(v5, a1, a2, v7, *(unsigned int *)(a2 + 104));
            *(_DWORD *)(a2 + 104) += v7;
            aj_return_rowptrs(a1, a2, (unint64_t *)(a2 + 568));
            if (!*(_DWORD *)(a2 + 1088)) {
              *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 36);
            }
          }
          int v14 = *(_DWORD *)(a2 + 60);
          int v15 = *(_DWORD *)(a2 + 64) + 1;
          *(_DWORD *)(a2 + 64) = v15;
        }
        while (v15 < v14);
      }
      uint64_t v16 = *(unsigned int *)(a2 + 1084);
      if (v16) {
        goto LABEL_44;
      }
      goto LABEL_21;
    }
    uint64_t v19 = *(unsigned int *)(a2 + 24);
    if ((int)v8 >= (int)v19)
    {
      uint64_t v20 = *(unsigned int *)(a1 + 6844);
      if ((int)v9 >= (int)v20)
      {
        if ((int)v9 < v10) {
          goto LABEL_36;
        }
        uint64_t v8 = (v8 + 1);
        *(_DWORD *)(a2 + 80) = v8;
      }
    }
    else
    {
      *(_DWORD *)(a2 + 80) = v19;
      uint64_t v20 = *(unsigned int *)(a1 + 6844);
      uint64_t v8 = v19;
    }
    *(_DWORD *)(a2 + 84) = v20;
    uint64_t v9 = v20;
LABEL_36:
    uint64_t v21 = move_to_mcu((int **)a1, a2, a2 + 112, v8, v9);
    uint64_t v16 = v21;
    if (v21 != -2)
    {
      if (v21)
      {
        if (!*(_DWORD *)(a2 + 1084))
        {
          *(_DWORD *)(a2 + 1084) = v21;
          uint64_t v16 = do_error_recovery(a1, a2, *(_DWORD *)(a2 + 84), v21);
          if (v16 == -2)
          {
            *(_DWORD *)(a2 + 1084) = 0;
            return v16;
          }
        }
      }
    }
    if (v16) {
      goto LABEL_44;
    }
    LODWORD(v8) = *(_DWORD *)(a2 + 80);
    goto LABEL_10;
  }
  return aj_lossless_decode_all((int **)a1, a2);
}

uint64_t get_row_lpf(void **a1, uint64_t a2, _DWORD *a3)
{
  int v6 = (1 << *((_DWORD *)a1 + 1656)) / *((_DWORD *)*a1 + 8);
  int v7 = *((_DWORD *)a1 + 1712) - *((_DWORD *)a1 + 1711);
  int v8 = *((_DWORD *)*a1 + 4);
  int v9 = *(_DWORD *)(a2 + 68);
  if (!v9)
  {
    bzero(a1[829], 4 * *((int *)a1 + 1660));
    int v9 = *(_DWORD *)(a2 + 68);
  }
  int v10 = v7 * v8;
  if (v9 < v6)
  {
    do
    {
      if (*(_DWORD *)(a2 + 1496))
      {
        int v11 = *(_DWORD *)(a2 + 1520);
        if (!v11)
        {
          int v12 = (*(uint64_t (**)(void))(a2 + 1504))(*(void *)(a2 + 1512));
          int v11 = *(_DWORD *)(a2 + 1496);
          if (v12)
          {
            *(_DWORD *)(a2 + 1520) = v11 - 1;
            return 10;
          }
        }
        *(_DWORD *)(a2 + 1520) = v11 - 1;
      }
      uint64_t result = fill_coeff_buffer((uint64_t)a1, a2, a3);
      if (result) {
        return result;
      }
      int v14 = *a1;
      int v15 = *((_DWORD *)*a1 + 8);
      if (v15 >= 1)
      {
        uint64_t v16 = 0;
        uint64_t v17 = a1[831];
        do
        {
          if (v10 >= 1)
          {
            int v18 = *(unsigned __int8 **)(a2 + 568 + 8 * v16);
            unsigned int v19 = v10 + 1;
            uint64_t v20 = v17;
            do
            {
              int v21 = *v18++;
              *v20++ += v21;
              --v19;
            }
            while (v19 > 1);
            int v15 = v14[8];
          }
          ++v16;
        }
        while (v16 < v15);
      }
      int v22 = *((_DWORD *)a1 + 1616);
      if (v22 > 1)
      {
        for (uint64_t i = 1; i < v22; ++i)
        {
          if (v7 >= 1)
          {
            int v24 = a1[i + 831];
            int16x8_t v25 = *(unsigned __int8 **)(a2 + (i << 7) + 568);
            unsigned int v26 = v7 + 1;
            do
            {
              int v27 = *v25++;
              *v24++ += v27;
              --v26;
            }
            while (v26 > 1);
            int v22 = *((_DWORD *)a1 + 1616);
          }
        }
      }
      aj_return_rowptrs((uint64_t)a1, a2, (unint64_t *)(a2 + 568));
      int v28 = *(_DWORD *)(a2 + 68) + 1;
      *(_DWORD *)(a2 + 68) = v28;
    }
    while (v28 < v6);
  }
  *(_DWORD *)(a2 + 68) = 0;
  aj_get_rowptrs((uint64_t)a1, a2, (void *)(a2 + 568));
  lpf_row(*(unsigned char **)(a2 + 568), (int *)a1[831], v10, *((_DWORD *)a1 + 1656), *((_DWORD *)a1 + 1656));
  uint64_t result = 0;
  if (*((int *)a1 + 1616) >= 2)
  {
    int v29 = *((_DWORD *)a1 + 1656);
    int v30 = v29 - (*((_DWORD *)*a1 + 4) == 2);
    int v31 = v29 - (*((_DWORD *)*a1 + 8) == 2);
    int v32 = (unsigned char **)(a2 + 696);
    uint64_t v33 = 832;
    do
    {
      int16x8_t v34 = *v32;
      v32 += 16;
      lpf_row(v34, (int *)a1[v33], v7, v30, v31);
      uint64_t v35 = v33 - 830;
      ++v33;
    }
    while (v35 < *((int *)a1 + 1616));
    return 0;
  }
  return result;
}

uint64_t fill_coeff_buffer(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 6580) == 14)
  {
    int v6 = *(_DWORD *)(a2 + 24);
    int v7 = *a3 - v6;
    if (*a3 > v6)
    {
      if (*(unsigned char *)(a1 + 17))
      {
        *(_DWORD *)(a2 + 96) = 0;
        *(void *)(a2 + 88) = 0;
      }
      else
      {
        *(_DWORD *)(a2 + 88) = v7 * *(_DWORD *)(a1 + 96) * *(_DWORD *)(a1 + 172);
        *(_DWORD *)(a2 + 92) = v7 * *(_DWORD *)(a1 + 104) * (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 48));
        *(_DWORD *)(a2 + 96) = v7 * *(_DWORD *)(a1 + 112) * (*(_DWORD *)(a1 + 172) / *(_DWORD *)(a1 + 48));
      }
    }
    goto LABEL_12;
  }
  if (*(unsigned char *)(a2 + 560)) {
    goto LABEL_12;
  }
  if (*(int *)(a1 + 6464) >= 1)
  {
    uint64_t v8 = 0;
    do
      *(_DWORD *)(a2 + 88 + 4 * v8++) = 0;
    while (v8 < *(int *)(a1 + 6464));
  }
  uint64_t result = aj_get_rowptrs(a1, a2, (void *)(a2 + 568));
  if (!result)
  {
LABEL_12:
    uint64_t v10 = *(unsigned int *)(a2 + 84);
    int v11 = *(_DWORD *)(a2 + 1088);
    if (v11)
    {
      if (v11 == 1)
      {
        uint64_t result = do_error_recovery(a1, a2, *(_DWORD *)(a2 + 84), *(unsigned int *)(a2 + 1084));
        if (result) {
          return result;
        }
      }
      if (*a3 != *(_DWORD *)(a2 + 1092))
      {
LABEL_32:
        fill_mcu_row_with_gray((int *)a1, a2, *(_DWORD *)(a1 + 6848));
        goto LABEL_33;
      }
      if (*(_DWORD *)(a2 + 1096) >= *(_DWORD *)(a1 + 6848)) {
        int v12 = *(_DWORD *)(a1 + 6848);
      }
      else {
        int v12 = *(_DWORD *)(a2 + 1096);
      }
      fill_mcu_row_with_gray((int *)a1, a2, v12);
      *(_DWORD *)(a2 + 1088) = 0;
      uint64_t v10 = *(unsigned int *)(a2 + 1096);
    }
    for (; (int)v10 < *(_DWORD *)(a1 + 6848); uint64_t v10 = (v10 + 1))
    {
      *(_DWORD *)(a2 + 84) = *(_DWORD *)(a1 + 6844);
      uint64_t v13 = move_to_mcu((int **)a1, a2, a2 + 112, *a3, v10);
      if (!v13)
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t))(a1 + 160))(a1, a2, a2 + 112, *a3, v10, a2 + 568, a2 + 88);
        if (!v13) {
          continue;
        }
      }
      if (v13 == -2)
      {
        *(_DWORD *)(a2 + 80) = *a3;
        *(_DWORD *)(a2 + 84) = v10;
        return 4294967294;
      }
      *(_DWORD *)(a2 + 1084) = v13;
      uint64_t result = do_error_recovery(a1, a2, v10, v13);
      if (result)
      {
        if (result == -2)
        {
          *(_DWORD *)(a2 + 80) = *a3;
          *(_DWORD *)(a2 + 84) = v10;
        }
        return result;
      }
      if (*a3 != *(_DWORD *)(a2 + 1092)) {
        goto LABEL_32;
      }
      if (*(_DWORD *)(a2 + 1096) >= *(_DWORD *)(a1 + 6848)) {
        int v14 = *(_DWORD *)(a1 + 6848);
      }
      else {
        int v14 = *(_DWORD *)(a2 + 1096);
      }
      fill_mcu_row_with_gray((int *)a1, a2, v14);
      LODWORD(v10) = *(_DWORD *)(a2 + 1096) - 1;
      *(_DWORD *)(a2 + 1088) = 0;
    }
LABEL_33:
    uint64_t result = 0;
    ++*a3;
  }
  return result;
}

uint64_t move_to_mcu(int **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a3 + 24);
  int v6 = *(_DWORD *)(a3 + 28);
  if (v5 == a4 && v6 == a5) {
    return 0;
  }
  int v8 = a5;
  BOOL v10 = v5 == a4;
  if (v6 <= (int)a5) {
    BOOL v10 = 0;
  }
  if (v5 > (int)a4 || v10)
  {
    aj_log_error((uint64_t)"Dec", "Trying to move backwards in the stream");
    return 3;
  }
  uint64_t v16 = a1[20];
  BOOL v17 = v5 == a4 && v6 == a5;
  uint64_t v18 = a5;
  uint64_t v19 = a4;
  if (v17) {
    goto LABEL_65;
  }
  int v20 = a4;
  int v21 = a5;
  if (!*(_DWORD *)a2) {
    goto LABEL_40;
  }
  if (v5 < *(_DWORD *)(a2 + 8))
  {
    int v20 = a4;
    int v21 = a5;
    if (*(_DWORD *)(a2 + 12) <= (int)a4) {
      goto LABEL_40;
    }
  }
  int v22 = *(_DWORD *)(a2 + 44);
  int v21 = a5;
  int v20 = a4;
  if (v5 <= v22)
  {
    int v21 = a5;
    int v20 = a4;
    if (v22 <= (int)a4)
    {
      int v23 = *(_DWORD *)(a2 + 48);
      if (v22 < (int)a4)
      {
        if (v5 < v22)
        {
LABEL_30:
          if (v5 == v22)
          {
            int v21 = *(_DWORD *)(a2 + 48);
            int v20 = *(_DWORD *)(a2 + 44);
            if (v6 == v23) {
              goto LABEL_64;
            }
          }
          else
          {
            int v21 = *(_DWORD *)(a2 + 48);
            int v20 = *(_DWORD *)(a2 + 44);
          }
          goto LABEL_34;
        }
        BOOL v24 = 1;
      }
      else
      {
        BOOL v24 = v23 <= (int)a5;
        if (v5 < v22)
        {
          int v21 = a5;
          int v20 = a4;
          if (v23 > (int)a5) {
            goto LABEL_34;
          }
          goto LABEL_30;
        }
      }
      int v21 = a5;
      int v20 = a4;
      if (v6 > v23) {
        goto LABEL_34;
      }
      int v21 = a5;
      int v20 = a4;
      if (!v24) {
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
LABEL_34:
  int16x8_t v25 = *(unsigned __int16 **)(a2 + 16);
  if (!v25) {
    goto LABEL_40;
  }
  int v26 = *v25;
  if (v5 > v26 || v20 < v26) {
    goto LABEL_40;
  }
  int v57 = v25[1];
  if (v20 <= v26)
  {
    BOOL v58 = v21 >= v57;
    if (v5 < v26)
    {
      if (v21 < v57) {
        goto LABEL_40;
      }
      goto LABEL_97;
    }
    goto LABEL_95;
  }
  if (v5 >= v26)
  {
    BOOL v58 = 1;
LABEL_95:
    if (v6 > v57 || !v58) {
      goto LABEL_40;
    }
  }
LABEL_97:
  int v20 = v26;
  if (v5 == v26)
  {
    int v21 = v57;
    if (v6 == v57) {
      goto LABEL_64;
    }
  }
  else
  {
    int v21 = v57;
  }
LABEL_40:
  int v28 = a1[1];
  int v29 = v28[34];
  if ((v29 & 0xFFFFFFFE) == 2)
  {
    if (*((void *)v28 + 12))
    {
      uint64_t v30 = *((void *)v28 + 13);
      if (v30)
      {
        if ((v29 != 2 || !*((_DWORD *)a1 + 1703)) && (v21 || v28[21] != v20))
        {
          int v31 = v28[28];
          int v32 = v20 / v31;
          uint64_t v19 = (v20 / v31 * v31);
          if ((int)v19 >= v5)
          {
            int v33 = v28[29];
            int v34 = v21 / v33;
            uint64_t v18 = (v21 / v33 * v33);
            if (v19 != v5 || (int)v18 > v6)
            {
              uint64_t v36 = *(void *)(v30 + 8 * v32);
              if (*(unsigned char *)(v36 + 20 * v34 + 17))
              {
                int v71 = v21 / v33;
                uint64_t v12 = aj_istream_state_restore(*(void *)a3, v36 + 20 * v34);
                if (!v12)
                {
                  int16x8_t v37 = *a1;
                  if (**a1 >= 1)
                  {
                    uint64_t v38 = 0;
                    do
                    {
                      *(_DWORD *)(a3 + 8 + 4 * v38) = *(__int16 *)(v36 + 20 * v71 + 8 + 2 * v38);
                      ++v38;
                    }
                    while (v38 < *v37);
                  }
                  int v39 = v37[851];
                  if (v39)
                  {
                    int v40 = v18 + a1[1][20] * v19;
                    int v41 = v40 % v39;
                    int v42 = v40 % (8 * v39) / v39;
                    BOOL v43 = __OFSUB__(v42, 1);
                    int v44 = v42 - 1;
                    if (v44 < 0 != v43) {
                      int v44 = 7;
                    }
                    *(_DWORD *)(a3 + 32) = v41;
                    *(_DWORD *)(a3 + 36) = v44;
                  }
                  *(_DWORD *)(a3 + 24) = v19;
                  *(_DWORD *)(a3 + 28) = v18;
                  goto LABEL_65;
                }
                goto LABEL_127;
              }
            }
          }
        }
      }
    }
  }
  int v45 = (*a1)[851];
  if (!v45
    || *((unsigned char *)*a1 + 84)
    || (int v48 = v28[20], v49 = (v21 + v48 * v20) / v45, v50 = v49 - 1, v49 < 1)
    || (uint64_t v51 = (v49 * v45 / v48), (int)v51 < v5))
  {
LABEL_64:
    uint64_t v18 = *(unsigned int *)(a3 + 28);
    uint64_t v19 = *(unsigned int *)(a3 + 24);
    goto LABEL_65;
  }
  BOOL v52 = v51 == v5 && v49 * v45 % v48 <= v6;
  uint64_t v18 = *(unsigned int *)(a3 + 28);
  uint64_t v19 = *(unsigned int *)(a3 + 24);
  if (v52) {
    goto LABEL_65;
  }
  uint64_t v53 = *(void *)a3;
  int v54 = (v6 + v48 * v5) / v45;
  int v55 = v54 - 1;
  int16x8_t v56 = *(unsigned __int8 **)(*(void *)a3 + 16);
  if (v56 && *(_DWORD *)(a3 + 32) == v45)
  {
    if ((v55 & 7 | 0xD0) == *v56)
    {
      int v55 = v54 - 2;
      goto LABEL_107;
    }
    aj_log_error((uint64_t)"Dec", "Current restart marker does not have expected value (0x%02X != 0x%02X)");
LABEL_126:
    uint64_t v12 = 7;
LABEL_127:
    aj_log_error((uint64_t)"Dec", "Jump to MCU failed with error: %d", v12);
    return v12;
  }
  if (*(_DWORD *)(a3 + 36) != (v55 & 7))
  {
    aj_log_error((uint64_t)"Dec", "Previous restart marker does not have expected value (0x%02X != 0x%02X)");
    goto LABEL_126;
  }
LABEL_107:
  if (v55 == v50)
  {
    aj_log_error((uint64_t)"Dec", "Already at requested restart marker");
    uint64_t v19 = *(unsigned int *)(a3 + 24);
    uint64_t v18 = *(unsigned int *)(a3 + 28);
    goto LABEL_65;
  }
  uint64_t v18 = (v49 * v45 % v48);
  if (v55 >= v50)
  {
LABEL_121:
    if (v55 == v50 && *(void *)(v53 + 16)) {
      goto LABEL_123;
    }
    aj_log_error((uint64_t)"Dec", "Unable to go to the correct RST position");
    goto LABEL_126;
  }
  uint64_t v60 = 0;
  int8x8x4_t v67 = (void *)(a3 + 8);
  uint64_t v68 = *(void *)a3;
  uint64_t v72 = (v49 * v45 / v48);
  char v70 = v49;
  int v69 = v49 - 1;
  while (1)
  {
    char v61 = *(unsigned __int8 **)(v53 + 16);
    if (v61) {
      break;
    }
    uint64_t v63 = v60;
    uint64_t next_marker = find_next_marker((uint64_t *)a3);
    uint64_t v60 = v63;
    uint64_t v12 = next_marker;
    if (next_marker == -2 && v60)
    {
      *int8x8x4_t v67 = 0;
      v67[1] = 0;
      int v65 = v45 + v45 * v55;
      *(_DWORD *)(a3 + 32) = 0;
      *(_DWORD *)(a3 + 36) = v55 & 7;
      int v66 = a1[1][20];
      *(_DWORD *)(a3 + 24) = v65 / v66;
      *(_DWORD *)(a3 + 28) = v65 % v66;
      uint64_t v12 = 4294967294;
      goto LABEL_127;
    }
    uint64_t v51 = v72;
    LOBYTE(v49) = v70;
    int v50 = v69;
    uint64_t v53 = v68;
    if (next_marker) {
      goto LABEL_127;
    }
LABEL_120:
    if (v55 >= v50) {
      goto LABEL_121;
    }
  }
  *(_DWORD *)uint64_t v53 = 0;
  *(_DWORD *)(v53 + 24) = -9;
  ++v55;
  int v62 = *v61;
  if ((v55 & 7 | 0xD0) == v62)
  {
    if (v55 == v50) {
      goto LABEL_123;
    }
    *(void *)(v53 + 16) = 0;
    uint64_t v60 = 1;
    goto LABEL_120;
  }
  if (v62 != 217)
  {
    aj_log_error((uint64_t)"Dec", "Incorrect restart marker found (0x%02X != 0x%02X). Skipping jump.");
    goto LABEL_126;
  }
  if (v55 != v50 || v18 || a1[1][21] != v51)
  {
    aj_log_error((uint64_t)"Dec", "Encountered EOI while trying to jump to [%d,%d]. Skipping jump.");
    goto LABEL_126;
  }
LABEL_123:
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(_DWORD *)(a3 + 32) = v45;
  *(_DWORD *)(a3 + 36) = ((_BYTE)v49 + 6) & 7;
  *(_DWORD *)(a3 + 24) = v51;
  *(_DWORD *)(a3 + 28) = v18;
  uint64_t v19 = v51;
LABEL_65:
  if (v19 == a4 && v18 == v8) {
    return 0;
  }
  if (v16 == (int *)aj_mcu_decode_progressive) {
    int16x8_t v46 = aj_mcu_decode_progressive;
  }
  else {
    int16x8_t v46 = aj_mcu_decode_index;
  }
  if ((int)v19 >= (int)a4)
  {
LABEL_100:
    if ((int)v18 < v8)
    {
      while (1)
      {
        uint64_t v12 = ((uint64_t (*)(int **, uint64_t, uint64_t, uint64_t, uint64_t, void, void))v46)(a1, a2, a3, v19, v18, 0, 0);
        if (v12) {
          break;
        }
        uint64_t v18 = (v18 + 1);
        if (v8 == v18) {
          return v12;
        }
      }
      goto LABEL_77;
    }
    return 0;
  }
  while (1)
  {
    while ((int)v18 >= a1[1][20])
    {
      uint64_t v18 = 0;
      uint64_t v19 = (v19 + 1);
      if (v19 == a4)
      {
        uint64_t v19 = a4;
        goto LABEL_100;
      }
    }
    uint64_t v47 = ((uint64_t (*)(int **, uint64_t, uint64_t, uint64_t, uint64_t, void, void))v46)(a1, a2, a3, v19, v18, 0, 0);
    if (v47) {
      break;
    }
    uint64_t v18 = (v18 + 1);
  }
  uint64_t v12 = v47;
LABEL_77:
  if (v12 == -2)
  {
    *(_DWORD *)(a2 + 80) = v19;
    *(_DWORD *)(a2 + 84) = v18;
    return 4294967294;
  }
  return v12;
}

uint64_t aj_decode_row(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 60) = 1;
  if (*(_DWORD *)(a2 + 80) == *(_DWORD *)(a2 + 24)
    || (*(void *)(a2 + 88) = 0,
        *(void *)(a2 + 96) = 0,
        uint64_t result = aj_get_rowptrs(a1, a2, (void *)(a2 + 568)),
        !result))
  {
    uint64_t result = aj_decode_all(a1, a2);
    *(void *)(a2 + 80) = (*(_DWORD *)(a2 + 80) + *(_DWORD *)(a1 + 6628));
  }
  return result;
}

uint64_t aj_create_ra_table(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 28);
  if (!*a2) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(_DWORD *)(v4 + 136);
  if (v5 == 2)
  {
    uint64_t result = extend_ra_table(a1, (uint64_t)a2, v2, 0, *(unsigned int *)(v4 + 84));
    if (result) {
      return result;
    }
    goto LABEL_8;
  }
  if (v5 == 1)
  {
    uint64_t result = build_ra_table(a1, (uint64_t)a2);
    if (result) {
      return result;
    }
LABEL_8:
    uint64_t result = 0;
    *(_DWORD *)(*(void *)(a1 + 8) + 136) = 3;
    return result;
  }
  aj_log_error((uint64_t)"Dec", "Illegal ra-state", v2);
  return 5;
}

uint64_t build_ra_table(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a2 + 112);
  int v5 = *(_DWORD **)(a1 + 8);
  uint64_t v6 = ((v5[21] - 1) / v5[28] * v5[28]);
  unsigned int v7 = (v5[20] - 1) / v5[29] * v5[29];
  uint64_t result = move_to_mcu((int **)a1, a2, a2 + 112, v6, v7);
  if (!result)
  {
    return aj_mcu_decode_index((int **)a1, a2, v4, v6, v7);
  }
  return result;
}

uint64_t extend_ra_table(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a2 + 1496))
  {
    int v10 = *(_DWORD *)(a2 + 1520);
    if (!v10)
    {
      int v21 = (*(uint64_t (**)(void))(a2 + 1504))(*(void *)(a2 + 1512));
      int v10 = *(_DWORD *)(a2 + 1496);
      if (v21)
      {
        *(_DWORD *)(a2 + 1520) = v10 - 1;
        return 10;
      }
    }
    *(_DWORD *)(a2 + 1520) = v10 - 1;
  }
  if ((int)a4 >= (int)a5)
  {
LABEL_18:
    return move_to_mcu((int **)a1, a2, a2 + 112, a5, 0);
  }
  else
  {
    int v11 = *(_DWORD **)(a1 + 8);
    int v13 = v11[28];
    int v12 = v11[29];
    int v14 = v11[20];
    while (v14 < 1)
    {
LABEL_17:
      a4 = (a4 + v13);
      if ((int)a4 >= (int)a5) {
        goto LABEL_18;
      }
    }
    uint64_t v15 = 0;
    while (1)
    {
      uint64_t result = move_to_mcu((int **)a1, a2, (uint64_t)a3, a4, v15);
      if (result) {
        break;
      }
      if (*(_DWORD *)a2 && a4 == *(_DWORD *)(a2 + 44) && v15 == *(_DWORD *)(a2 + 48))
      {
        uint64_t v17 = *(void *)(a1 + 8);
        uint64_t v18 = *(int *)(a2 + 52);
        int v19 = *(_DWORD *)(a2 + 56);
        if (*(unsigned char *)(*(void *)(*(void *)(v17 + 104) + 8 * v18) + 20 * v19 + 17))
        {
          *(_DWORD *)(a2 + 56) = v19 + 1;
          int v20 = v15 + *(_DWORD *)(v17 + 116);
          *(_DWORD *)(a2 + 48) = v20;
          if (v20 >= *(_DWORD *)(v17 + 80))
          {
            *(void *)(a2 + 52) = (v18 + 1);
            *(void *)(a2 + 44) = (*(_DWORD *)(v17 + 112) + a4);
          }
        }
        else
        {
          uint64_t result = aj_mcu_decode_index((int **)a1, a2, a3, a4, v15);
          if (result) {
            return result;
          }
        }
      }
      uint64_t v15 = (v15 + v12);
      if ((int)v15 >= v14) {
        goto LABEL_17;
      }
    }
  }
  return result;
}

uint64_t aj_get_numthreads_decode(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  *a5 = 0;
  int v5 = *(_DWORD *)(a1 + 6504);
  if (v5 / 32 < (int)a4)
  {
    a4 = (v5 / 32);
    if (v5 < 64) {
      return 1;
    }
  }
  if (*(_DWORD *)(a1 + 6580) == 14 || *(unsigned char *)(*(void *)a1 + 84)) {
    return 1;
  }
  uint64_t v6 = 1;
  if (a3 && !*(unsigned char *)(a1 + 17) && (int)a4 >= 2 && !*(_DWORD *)(a1 + 6612))
  {
    uint64_t v8 = *(void *)(a1 + 8);
    int v9 = *(_DWORD *)(v8 + 136);
    if ((v9 & 0xFFFFFFFE) == 2 && *(void *)(v8 + 96) && *(void *)(v8 + 104))
    {
      BOOL v10 = v9 == 2;
      int v11 = *(_DWORD *)(v8 + 128);
      int v13 = v10 || v11 < 3;
      int v14 = *(_DWORD *)(a1 + 6812);
      if (v14) {
        int v14 = *(_DWORD *)(v8 + 112) > 1;
      }
      if (!(v14 | v13))
      {
        if (v11 <= (int)a4) {
          a4 = (v11 - 1);
        }
        else {
          a4 = a4;
        }
        LODWORD(v6) = 3;
        goto LABEL_41;
      }
    }
    int v15 = *(_DWORD *)(*(void *)a1 + 3404);
    if (!v15) {
      goto LABEL_26;
    }
    int v16 = *(_DWORD *)(v8 + 80);
    if (*(_DWORD *)(a1 + 6812))
    {
      if (v16 < v15)
      {
LABEL_26:
        if (!*(_DWORD *)(a2 + 4)) {
          return 1;
        }
        uint64_t v6 = 1;
        if (*(_DWORD *)(a1 + 6812) | (*(_DWORD *)(a1 + 168) > 8)) {
          return v6;
        }
        a4 = 2;
LABEL_41:
        *a5 = v6;
        return a4;
      }
    }
    else
    {
      int v17 = *(_DWORD *)(v8 + 84) * v16 / v15;
      BOOL v18 = v17 < (int)a4;
      if (v17 >= (int)a4) {
        a4 = a4;
      }
      else {
        a4 = v17;
      }
      if (v18 && v17 <= 1) {
        goto LABEL_26;
      }
    }
    LODWORD(v6) = 2;
    goto LABEL_41;
  }
  return v6;
}

uint64_t aj_get_numthreads_ratbl(void *a1, int a2, int a3)
{
  uint64_t v3 = a1[1];
  if ((*(_DWORD *)(v3 + 136) & 0xFFFFFFFE) != 2) {
    return 1;
  }
  if (!*(void *)(v3 + 96)) {
    return 1;
  }
  if (!a2) {
    return 1;
  }
  if (!*(void *)(v3 + 104)) {
    return 1;
  }
  if (*(unsigned char *)(*a1 + 84)) {
    return 1;
  }
  int v5 = *(_DWORD *)(v3 + 120);
  if (!v5 || !*(_DWORD *)(v3 + 124)) {
    return 1;
  }
  int v6 = (v5 + *(_DWORD *)(v3 + 84) - 1) / v5;
  if (v6 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v6;
  }
  if (v6 >= a3) {
    int v8 = a3;
  }
  else {
    int v8 = v7;
  }
  if (v8 <= 1) {
    return 1;
  }
  else {
    return v8;
  }
}

uint64_t aj_decode_all_mt(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 6948);
  uint64_t v5 = (v4 - 1);
  if (v4 <= 1) {
    return aj_decode_all(a1, a2);
  }
  int v41 = *(_DWORD *)(a1 + 6948);
  int v6 = *(pthread_t **)(a1 + 6952);
  uint64_t v7 = (v4 - 1);
  int v8 = v6;
  do
  {
    pthread_create(v8 + 193, 0, (void *(__cdecl *)(void *))job, v8);
    v8 += 209;
    --v7;
  }
  while (v7);
  uint64_t v9 = v5;
  BOOL v10 = v6;
  unsigned int v39 = aj_decode_all(a1, v2);
  unsigned int v11 = v39;
  do
  {
    pthread_join(v10[193], 0);
    if (v11) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = *(_DWORD *)v10 == 0;
    }
    if (!v12) {
      unsigned int v11 = *(_DWORD *)v10;
    }
    v10 += 209;
    --v9;
  }
  while (v9);
  unsigned int v40 = v11;
  uint64_t v13 = 0;
  int v14 = v6 + 144;
  uint64_t v42 = v5;
  uint64_t v43 = v2;
  do
  {
    int v15 = &v6[209 * v13];
    if (v13) {
      uint64_t v16 = (uint64_t)(v15 - 207);
    }
    else {
      uint64_t v16 = v2;
    }
    if (*((_DWORD *)v15 + 283))
    {
      uint64_t v17 = *(unsigned int *)(a1 + 6464);
      if ((int)v17 >= 1)
      {
        uint64_t v18 = 0;
        int v19 = (void *)(v16 + 568);
        int v20 = v14;
        do
        {
          uint64_t v21 = *((unsigned int *)&v6[209 * v13 + 141] + v18 + 1);
          int v22 = v19;
          int v23 = (uint64_t *)v20;
          if ((int)v21 >= 1)
          {
            do
            {
              uint64_t v24 = *v23++;
              *v22++ = v24;
              --v21;
            }
            while (v21);
          }
          ++v18;
          v20 += 10;
          v19 += 16;
        }
        while (v18 != v17);
      }
      int16x8_t v25 = (_DWORD *)v15 + 283;
      *(unsigned char *)(v16 + 1082) = 1;
      (**(void (***)(void))(v16 + 1488))();
      *(_DWORD *)(v16 + 104) += *v25;
      *(unsigned char *)(v16 + 1082) = 0;
      int v26 = *(_DWORD *)(a1 + 6464);
      if (v26 >= 1)
      {
        uint64_t v27 = 0;
        int v28 = v14;
        do
        {
          uint64_t v29 = (uint64_t)&v6[209 * v13] + 4 * v27;
          if (*(int *)(v29 + 1132) >= 1)
          {
            uint64_t v30 = 0;
            int v31 = (int *)(v29 + 1132);
            do
              aj_rowbuffer_return_buffer((unsigned int *)&v6[209 * v13 + 21], (unint64_t)v28[v30++]);
            while (v30 < *v31);
            int v26 = *(_DWORD *)(a1 + 6464);
          }
          ++v27;
          v28 += 10;
        }
        while (v27 < v26);
      }
    }
    uint64_t v32 = v42;
    uint64_t v2 = v43;
    int v33 = *(_DWORD *)(v43 + 40);
    if (v33 <= SLODWORD(v6[209 * v13 + 7])) {
      int v33 = (int)v6[209 * v13 + 7];
    }
    *(_DWORD *)(v43 + 40) = v33;
    ++v13;
    v14 += 209;
  }
  while (v13 != v42);
  uint64_t v34 = v40;
  if (v40 && !v39)
  {
    uint64_t v35 = v6;
    while (!*(_DWORD *)v35)
    {
      v35 += 209;
      if (!--v32) {
        goto LABEL_39;
      }
    }
    *(_DWORD *)(v43 + 36) = *((_DWORD *)v35 + 13);
  }
LABEL_39:
  uint64_t v36 = *(void *)(v43 + 112);
  uint64_t pos = aj_istream_get_pos((uint64_t)v6[209 * (v41 - 2) + 16]);
  uint64_t result = aj_istream_move_to_position(v36, pos);
  if (!result) {
    return v34;
  }
  return result;
}

uint64_t job(uint64_t a1)
{
  *(_DWORD *)a1 = aj_decode_all(*(void *)(a1 + 8), a1 + 16);
  return 0;
}

uint64_t aj_create_ra_table_mt(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = (uint64_t *)(a2 + 28);
  if (!*a2) {
    return 0;
  }
  uint64_t v5 = *(unsigned int **)(a1 + 8);
  unsigned int v6 = v5[34];
  if (v6 == 2)
  {
    uint64_t v9 = *(unsigned int **)(a1 + 6952);
    int v10 = *(_DWORD *)(a1 + 6948);
    int numthreads_ratbl = aj_get_numthreads_ratbl((void *)a1, *(void *)(*v2 + 80) == 0, v10);
    uint64_t v12 = v5[21];
    if (numthreads_ratbl != 1)
    {
      signed int v13 = v5[30];
      int v14 = ((int)v12 + v13 - 1) / v13 / v10;
      int v15 = v14 * v13;
      signed int v16 = v5[28];
      if (v10 < 2)
      {
        int v18 = 0;
      }
      else
      {
        int v17 = 0;
        int v18 = v10 - 1;
        int v19 = v13 * v14;
        int v20 = (int *)(v9 + 17);
        uint64_t v21 = (v10 - 1);
        do
        {
          *(v20 - 7) = v17;
          int v22 = v16 + v17;
          v17 += v19;
          *(v20 - 6) = v17;
          int v23 = (v22 - 1) / v16;
          int *v20 = v23;
          *(v20 - 2) = v23 * v16;
          v20 += 418;
          --v21;
        }
        while (v21);
      }
      uint64_t v24 = (v18 * v15);
      a2[6] = v24;
      a2[7] = v12;
      int v25 = ((int)v24 + v16 - 1) / v16;
      a2[13] = v25;
      a2[11] = v25 * v16;
      if (v10 >= 2)
      {
        uint64_t v26 = 0;
        uint64_t v27 = (pthread_t *)v9;
        do
        {
          pthread_create(v27 + 193, 0, (void *(__cdecl *)(void *))ra_job, v27);
          ++v26;
          v27 += 209;
        }
        while (v26 < *(int *)(a1 + 6948) - 1);
        uint64_t v24 = a2[6];
        uint64_t v12 = a2[7];
      }
      uint64_t v8 = extend_ra_table(a1, (uint64_t)a2, v2, v24, v12);
      if (*(int *)(a1 + 6948) >= 2)
      {
        uint64_t v28 = 0;
        do
        {
          pthread_join(*((pthread_t *)v9 + 193), 0);
          if (*v9) {
            uint64_t v8 = *v9;
          }
          else {
            uint64_t v8 = v8;
          }
          ++v28;
          v9 += 418;
        }
        while (v28 < *(int *)(a1 + 6948) - 1);
      }
      if (!v8) {
        goto LABEL_27;
      }
      return v8;
    }
    uint64_t v7 = extend_ra_table(a1, (uint64_t)a2, v2, 0, v12);
  }
  else
  {
    if (v6 != 1)
    {
      aj_log_error((uint64_t)"Dec", "Illegal ra-state");
      return 5;
    }
    uint64_t v7 = build_ra_table(a1, (uint64_t)a2);
  }
  uint64_t v8 = v7;
  if (!v7)
  {
LABEL_27:
    uint64_t v8 = 0;
    *(_DWORD *)(*(void *)(a1 + 8) + 136) = 3;
  }
  return v8;
}

uint64_t ra_job(uint64_t a1)
{
  *(_DWORD *)a1 = extend_ra_table(*(void *)(a1 + 8), a1 + 16, (uint64_t *)(a1 + 128), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44));
  return 0;
}

unsigned char *lpf_row(unsigned char *result, int *a2, int a3, int a4, int a5)
{
  for (int i = a5 + a4; a4; --a4)
  {
    if (a3 >= 2)
    {
      unsigned int v6 = a3 + 2;
      uint64_t v7 = a2;
      uint64_t v8 = a2;
      do
      {
        int v9 = *v8;
        int v10 = v8[1];
        v8 += 2;
        *v7++ = v10 + v9;
        v6 -= 2;
      }
      while (v6 > 3);
    }
    a3 >>= 1;
  }
  if (i)
  {
    if (a3 >= 1)
    {
      unsigned int v11 = a3 + 1;
      do
      {
        int v12 = *a2++;
        *result++ = (v12 + (1 << (i - 1))) >> i;
        --v11;
      }
      while (v11 > 1);
    }
  }
  else if (a3 >= 1)
  {
    unsigned int v13 = a3 + 1;
    do
    {
      int v14 = *a2++;
      *result++ = v14;
      --v13;
    }
    while (v13 > 1);
  }
  return result;
}

uint64_t do_error_recovery(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v8 = (uint64_t *)(a2 + 112);
  uint64_t v9 = *(void *)(a2 + 112);
  *(_DWORD *)(a2 + 1088) = 2;
  int v10 = *(_DWORD *)(*(void *)a1 + 3404);
  if (!v10 || *(unsigned char *)(*(void *)a1 + 84))
  {
    unsigned int v11 = "No RST markers or image is multiscan, can't do recovery";
LABEL_4:
    aj_log_error((uint64_t)"Dec", v11);
LABEL_5:
    if (a4)
    {
      if (a4 == -2)
      {
        *(_DWORD *)(a2 + 1088) = 1;
      }
      else
      {
LABEL_29:
        if (*(_DWORD *)(a2 + 36) == *(_DWORD *)(a2 + 32)
          && *(_DWORD *)(a1 + 6844) == a3
          && *(_DWORD *)(a1 + 6836) == *(_DWORD *)(a2 + 24))
        {
          *(_DWORD *)(a2 + 1084) = 0;
        }
        else if (*(unsigned char *)(a1 + 6944))
        {
          a4 = 0;
          *(_DWORD *)(a2 + 1096) = *(_DWORD *)(a1 + 6844);
          *(_DWORD *)(a2 + 1092) = *(_DWORD *)(a1 + 6840) + 1;
        }
      }
    }
    return a4;
  }
  *(void *)(v9 + 104) = 0;
  int v12 = *(_DWORD *)(a2 + 140) + *(_DWORD *)(*(void *)(a1 + 8) + 80) * *(_DWORD *)(a2 + 136);
  int v13 = v12 / v10 - 1;
  if (v12 && !(v12 % v10) && *(_DWORD *)(a2 + 144) == v10) {
    int v13 = v12 / v10 - 2;
  }
  int v14 = *(_DWORD *)(a2 + 148);
  uint64_t next_marker = find_next_marker((uint64_t *)(a2 + 112));
  if (next_marker)
  {
    a4 = next_marker;
    aj_log_error((uint64_t)"Dec", "Could not find next marker");
    goto LABEL_5;
  }
  int v33 = v13;
  int v34 = a3;
  int v35 = ((_BYTE)v14 + 2) & 7;
  int v16 = ((_BYTE)v14 + 3) & 7;
  int v17 = v14 & 7;
  int v18 = (v14 - 1) & 7;
  unsigned int v11 = "Could not find next marker";
  while (1)
  {
    int v19 = *(char **)(v9 + 16);
    if (!v19)
    {
      aj_log_error((uint64_t)"Dec", "No marker found");
      a4 = 7;
      a3 = v34;
      goto LABEL_29;
    }
    char v20 = *v19;
    if ((v20 & 0xF8) != 0xD0) {
      goto LABEL_26;
    }
    int v21 = v20 & 0xF;
    if (v35 == v21 || v16 == v21) {
      break;
    }
    if (v17 != v21 && v18 != v21)
    {
      int v26 = 1;
      goto LABEL_37;
    }
LABEL_26:
    *(void *)(v9 + 16) = 0;
    uint64_t v24 = find_next_marker(v8);
    if (v24)
    {
      a4 = v24;
      a3 = v34;
      goto LABEL_4;
    }
  }
  int v26 = ((_BYTE)v21 - *(_DWORD *)(a2 + 148)) & 7;
LABEL_37:
  a4 = 0;
  int v27 = v26 + v33;
  int v28 = v10 + v10 * v27;
  int v29 = *(_DWORD *)(*(void *)(a1 + 8) + 80);
  int v30 = v28 / v29;
  int v31 = v28 % v29;
  *(_DWORD *)(a2 + 1092) = v30;
  int v32 = *(_DWORD *)(a1 + 6844);
  if (v31 > v32) {
    int v32 = v31;
  }
  *(_DWORD *)(a2 + 1096) = v32;
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(v9 + 16) = 0;
  *(_DWORD *)(a2 + 144) = 0;
  *(_DWORD *)(a2 + 148) = v27 & 7;
  *(_DWORD *)(a2 + 136) = v30;
  *(_DWORD *)(a2 + 140) = v31;
  return a4;
}

int *fill_mcu_row_with_gray(int *result, uint64_t a2, int a3)
{
  if (result[1616] >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    uint64_t v7 = a2 + 568;
    do
    {
      uint64_t v8 = a2 + 4 * v6;
      int v11 = *(_DWORD *)(v8 + 88);
      int v10 = (int *)(v8 + 88);
      int v9 = v11;
      int v12 = (a3 - v5[1711]) * v5[392 * v6 + 227] * v5[392 * v6 + 48] - v11;
      int v13 = &v5[v6];
      if (v13[1671] >= 1)
      {
        uint64_t v14 = 0;
        int v15 = v13 + 1671;
        do
          uint64_t result = (int *)memset((void *)(*(void *)(v7 + 8 * v14++) + *v10), 128, v12);
        while (v14 < *v15);
        int v9 = *v10;
      }
      *int v10 = v9 + v12;
      ++v6;
      v7 += 128;
    }
    while (v6 < v5[1616]);
  }
  return result;
}

uint64_t find_next_marker(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*(void *)(*a1 + 16))
  {
    uint64_t next_val = aj_istream_find_next_val(*a1, 255);
    int v4 = *(_DWORD *)(v1 + 32);
    if (v4 <= 1 && next_val == 0)
    {
LABEL_15:
      if (*(unsigned char *)(v1 + 112) && *(_DWORD *)(v1 + 56) == 1) {
        return 4294967294;
      }
      uint64_t v2 = 7;
    }
    else
    {
      uint64_t v2 = next_val;
      while (!v2)
      {
        uint64_t v6 = *(void *)(v1 + 8);
        int v8 = *(unsigned __int8 *)(v6 + 1);
        uint64_t v7 = v6 + 1;
        if (v8)
        {
          if (**(unsigned __int8 **)(v1 + 8) == 255)
          {
            uint64_t v12 = aj_istream_fill_buf(v1, -9);
            uint64_t v2 = v12;
            if (v12) {
              aj_log_error((uint64_t)"Dec", "Error when reading from inputstream: %d", v12);
            }
          }
          else
          {
            aj_log_error((uint64_t)"Dec", "Could not find next marker");
            return 7;
          }
          return v2;
        }
        *(void *)(v1 + 8) = v7;
        *(_DWORD *)(v1 + 32) = v4 - 1;
        uint64_t v9 = aj_istream_find_next_val(v1, 255);
        uint64_t v2 = v9;
        int v4 = *(_DWORD *)(v1 + 32);
        if (v4 <= 1 && v9 == 0) {
          goto LABEL_15;
        }
      }
      if (v2 == -2) {
        return v2;
      }
    }
    aj_log_error((uint64_t)"Dec", "Encountered error %d while searching for next marker", v2);
    return v2;
  }
  uint64_t v2 = 0;
  *(_DWORD *)uint64_t v1 = 0;
  *(_DWORD *)(v1 + 24) = -9;
  return v2;
}

uint64_t aj_write_app0(uint64_t a1)
{
  uint64_t result = aj_ostream_write_bytes(a1, 65504, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 16, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, 4867657, 3);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a1, 17920, 2);
        if (!result)
        {
          uint64_t result = aj_ostream_write_bytes(a1, 258, 2);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a1, 1, 1);
            if (!result)
            {
              uint64_t result = aj_ostream_write_bytes(a1, 72, 2);
              if (!result)
              {
                uint64_t result = aj_ostream_write_bytes(a1, 72, 2);
                if (!result)
                {
                  return aj_ostream_write_bytes(a1, 0, 2);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sof(uint64_t a1, int *a2, int a3)
{
  int v3 = a3;
  if (!a3) {
    int v3 = a2[3];
  }
  int v6 = *a2;
  uint64_t result = aj_ostream_write_bytes(a1, a2[20] + 65280, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 3 * v6 + 8, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, a2[1], 1);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a1, v3, 2);
        if (!result)
        {
          uint64_t result = aj_ostream_write_bytes(a1, a2[2], 2);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a1, *a2, 1);
            if (!result)
            {
              if (*a2 < 1)
              {
                return 0;
              }
              else
              {
                uint64_t v8 = 0;
                do
                {
                  uint64_t v9 = &a2[v8];
                  int v10 = v9[4];
                  int v11 = v9[8];
                  uint64_t result = aj_ostream_write_bytes(a1, v9[16], 1);
                  if (result) {
                    break;
                  }
                  uint64_t result = aj_ostream_write_bytes(a1, v11 + 16 * v10, 1);
                  if (result) {
                    break;
                  }
                  uint64_t result = aj_ostream_write_bytes(a1, a2[v8 + 12], 1);
                  if (result) {
                    break;
                  }
                  ++v8;
                }
                while (v8 < *a2);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_dht(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t result = aj_ostream_write_bytes(a1, 65476, 2);
  if (!result)
  {
    uint64_t v7 = a3 + 274;
    uint8x16_t v8 = *(uint8x16_t *)(a3 + 274);
    uint16x8_t v9 = vaddl_high_u8(*(uint8x16_t *)a3, v8);
    uint16x8_t v10 = vaddl_u8(*(uint8x8_t *)a3, *(uint8x8_t *)v8.i8);
    int v11 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v10.i8, *(uint16x4_t *)v9.i8), (int32x4_t)vaddl_high_u16(v10, v9)));
    if (*a2 == 3)
    {
      uint8x16_t v12 = *(uint8x16_t *)(a3 + 548);
      uint8x16_t v13 = *(uint8x16_t *)(a3 + 822);
      uint16x8_t v14 = vaddl_high_u8(v12, v13);
      uint16x8_t v15 = vaddl_u8(*(uint8x8_t *)v12.i8, *(uint8x8_t *)v13.i8);
      int v16 = v11
          + vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v15.i8, *(uint16x4_t *)v14.i8), (int32x4_t)vaddl_high_u16(v15, v14)))+ 70;
    }
    else
    {
      int v16 = v11 + 36;
    }
    uint64_t result = aj_ostream_write_bytes(a1, v16, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, 0, 1);
      if (!result)
      {
        uint64_t v17 = 0;
        LODWORD(v18) = 0;
        while (1)
        {
          uint64_t result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(a3 + v17), 1);
          if (result) {
            break;
          }
          uint64_t v18 = v18 + *(unsigned __int8 *)(a3 + v17++);
          if (v17 == 16)
          {
            if (v18)
            {
              int v19 = (unsigned __int8 *)(a3 + 16);
              while (1)
              {
                int v20 = *v19++;
                uint64_t result = aj_ostream_write_bytes(a1, v20, 1);
                if (result) {
                  break;
                }
                if (!--v18) {
                  goto LABEL_15;
                }
              }
            }
            else
            {
LABEL_15:
              *(unsigned char *)(a3 + 273) = 1;
              uint64_t result = aj_ostream_write_bytes(a1, 16, 1);
              if (!result)
              {
                uint64_t v21 = 0;
                LODWORD(v22) = 0;
                while (1)
                {
                  uint64_t result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v7 + v21), 1);
                  if (result) {
                    break;
                  }
                  uint64_t v22 = v22 + *(unsigned __int8 *)(v7 + v21++);
                  if (v21 == 16)
                  {
                    if (v22)
                    {
                      int v23 = (unsigned __int8 *)(a3 + 290);
                      while (1)
                      {
                        int v24 = *v23++;
                        uint64_t result = aj_ostream_write_bytes(a1, v24, 1);
                        if (result) {
                          break;
                        }
                        if (!--v22) {
                          goto LABEL_23;
                        }
                      }
                    }
                    else
                    {
LABEL_23:
                      *(unsigned char *)(a3 + 547) = 1;
                      if (*a2 == 3)
                      {
                        uint64_t result = aj_ostream_write_bytes(a1, 1, 1);
                        if (!result)
                        {
                          uint64_t v25 = 0;
                          LODWORD(v26) = 0;
                          uint64_t v27 = a3 + 548;
                          while (1)
                          {
                            uint64_t result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v27 + v25), 1);
                            if (result) {
                              break;
                            }
                            uint64_t v26 = v26 + *(unsigned __int8 *)(v27 + v25++);
                            if (v25 == 16)
                            {
                              if (v26)
                              {
                                int v28 = (unsigned __int8 *)(a3 + 564);
                                while (1)
                                {
                                  int v29 = *v28++;
                                  uint64_t result = aj_ostream_write_bytes(a1, v29, 1);
                                  if (result) {
                                    break;
                                  }
                                  if (!--v26) {
                                    goto LABEL_32;
                                  }
                                }
                              }
                              else
                              {
LABEL_32:
                                *(unsigned char *)(a3 + 821) = 1;
                                uint64_t result = aj_ostream_write_bytes(a1, 17, 1);
                                if (!result)
                                {
                                  uint64_t v30 = 0;
                                  LODWORD(v31) = 0;
                                  uint64_t v32 = a3 + 822;
                                  while (1)
                                  {
                                    uint64_t result = aj_ostream_write_bytes(a1, *(unsigned __int8 *)(v32 + v30), 1);
                                    if (result) {
                                      break;
                                    }
                                    uint64_t v31 = v31 + *(unsigned __int8 *)(v32 + v30++);
                                    if (v30 == 16)
                                    {
                                      if (v31)
                                      {
                                        int v33 = (unsigned __int8 *)(a3 + 838);
                                        while (1)
                                        {
                                          int v34 = *v33++;
                                          uint64_t result = aj_ostream_write_bytes(a1, v34, 1);
                                          if (result) {
                                            break;
                                          }
                                          if (!--v31) {
                                            goto LABEL_40;
                                          }
                                        }
                                      }
                                      else
                                      {
LABEL_40:
                                        uint64_t result = 0;
                                        *(unsigned char *)(a3 + 1095) = 1;
                                      }
                                      return result;
                                    }
                                  }
                                }
                              }
                              return result;
                            }
                          }
                        }
                      }
                      else
                      {
                        return 0;
                      }
                    }
                    return result;
                  }
                }
              }
            }
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_single_dht(uint64_t a1, uint8x16_t *a2, int a3, int a4)
{
  uint64_t result = aj_ostream_write_bytes(a1, 65476, 2);
  if (!result)
  {
    uint16x8_t v9 = vmovl_high_u8(*a2);
    uint16x8_t v10 = vmovl_u8(*(uint8x8_t *)a2->i8);
    uint64_t result = aj_ostream_write_bytes(a1, vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v10.i8, *(uint16x4_t *)v9.i8), (int32x4_t)vaddl_high_u16(v10, v9)))+ 19, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, a4 + 16 * a3, 1);
      if (!result)
      {
        uint64_t v11 = 0;
        LODWORD(v12) = 0;
        while (1)
        {
          uint64_t result = aj_ostream_write_bytes(a1, a2->u8[v11], 1);
          if (result) {
            break;
          }
          uint64_t v12 = v12 + a2->u8[v11++];
          if (v11 == 16)
          {
            if (v12)
            {
              uint8x16_t v13 = a2 + 1;
              while (1)
              {
                int v14 = v13->u8[0];
                uint8x16_t v13 = (uint8x16_t *)((char *)v13 + 1);
                uint64_t result = aj_ostream_write_bytes(a1, v14, 1);
                if (result) {
                  break;
                }
                if (!--v12) {
                  goto LABEL_12;
                }
              }
            }
            else
            {
LABEL_12:
              uint64_t result = 0;
              a2[17].i8[1] = 1;
            }
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_dqt(uint64_t a1, int *a2)
{
  v11[2] = *MEMORY[0x263EF8340];
  v11[0] = 0;
  v11[1] = 0;
  int v2 = *a2;
  if (*a2 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  while (1)
  {
    int v6 = &a2[v5];
    uint64_t v8 = v6[12];
    uint64_t v7 = v6 + 12;
    if (!*((_DWORD *)v11 + v8)) {
      break;
    }
LABEL_11:
    if (++v5 >= v2) {
      return 0;
    }
  }
  uint64_t result = aj_ostream_write_bytes(a1, 65499, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 67, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, *v7, 1);
      if (!result)
      {
        uint64_t v10 = 0;
        while (1)
        {
          uint64_t result = aj_ostream_write_bytes(a1, LOBYTE(a2[64 * (uint64_t)*v7 + 22 + aj_glob_zigzag[v10]]), 1);
          if (result) {
            break;
          }
          if (++v10 == 64)
          {
            *((_DWORD *)v11 + *v7) = 1;
            int v2 = *a2;
            goto LABEL_11;
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sos_baseline(uint64_t a1, int *a2)
{
  int v4 = *a2;
  uint64_t result = aj_ostream_write_bytes(a1, 65498, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 2 * v4 + 6, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, *a2, 1);
      if (!result)
      {
        if (*a2 < 1)
        {
LABEL_10:
          return aj_ostream_write_bytes(a1, 16128, 3);
        }
        else
        {
          uint64_t v6 = 0;
          while (1)
          {
            uint64_t v7 = &a2[v6];
            int v8 = v7[839];
            int v9 = v7[843];
            uint64_t result = aj_ostream_write_bytes(a1, v7[16], 1);
            if (result) {
              break;
            }
            uint64_t result = aj_ostream_write_bytes(a1, v9 + 16 * v8, 1);
            if (result) {
              break;
            }
            if (++v6 >= *a2) {
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_sos_progressive(uint64_t a1, uint64_t a2, int *a3)
{
  int v6 = *a3;
  uint64_t result = aj_ostream_write_bytes(a1, 65498, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 2 * v6 + 6, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, *a3, 1);
      if (!result)
      {
        if (*a3 < 1)
        {
LABEL_10:
          uint64_t result = aj_ostream_write_bytes(a1, a3[13], 1);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a1, a3[14], 1);
            if (!result)
            {
              int v10 = a3[15] + 16 * a3[16];
              return aj_ostream_write_bytes(a1, v10, 1);
            }
          }
        }
        else
        {
          uint64_t v8 = 0;
          while (1)
          {
            int v9 = &a3[v8];
            uint64_t result = aj_ostream_write_bytes(a1, *(_DWORD *)(a2 + 4 * v9[1] + 64), 1);
            if (result) {
              break;
            }
            uint64_t result = aj_ostream_write_bytes(a1, v9[9] + 16 * v9[5], 1);
            if (result) {
              break;
            }
            if (++v8 >= *a3) {
              goto LABEL_10;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_exif (uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 3416);
  uint64_t result = aj_ostream_write_bytes(a1, 65505, 2);
  if (!result)
  {
    int v6 = v4 ? 34 : 22;
    uint64_t result = aj_ostream_write_bytes(a1, v6, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, 1165519206, 4);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a1, 0, 2);
        if (!result)
        {
          uint64_t result = aj_ostream_write_bytes(a1, 19789, 2);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a1, 42, 2);
            if (!result)
            {
              uint64_t result = aj_ostream_write_bytes(a1, 8, 4);
              if (!result)
              {
                uint64_t result = aj_ostream_write_bytes(a1, v4 != 0, 2);
                if (!result)
                {
                  int v7 = *(_DWORD *)(a2 + 3416);
                  if (v7) {
                    write_ifd_field(a1, v7);
                  }
                  return aj_ostream_write_bytes(a1, 0, 4);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_ifd_field(uint64_t a1, int a2)
{
  uint64_t result = aj_ostream_write_bytes(a1, 274, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 3, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a1, 1, 4);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a1, a2, 2);
        if (!result)
        {
          return aj_ostream_write_bytes(a1, 0, 2);
        }
      }
    }
  }
  return result;
}

uint64_t aj_write_jpeg_headers(int *a1, uint64_t a2, uint64_t a3, int *a4, int a5, int a6, uint64_t a7, char *__src, int a9)
{
  if (a6
    || (uint64_t result = aj_ostream_write_bytes(a2, 65496, 2), !result) && (uint64_t result = aj_write_app0(a2), !result))
  {
    if (!a7 || (uint64_t result = aj_ostream_write_buf(a2, __src, a7), !result))
    {
      uint64_t result = aj_write_sof(a2, a1, a9);
      if (!result)
      {
        if (*a1 < 1)
        {
LABEL_12:
          uint64_t result = aj_write_dqt(a2, a1);
          if (!result)
          {
            if (!a5 || (uint64_t result = write_dri(a2, (__int16)a5), !result))
            {
              if (a1[20] == 192)
              {
                return aj_write_sos_baseline(a2, a1);
              }
              else
              {
                return aj_write_sos_progressive(a2, (uint64_t)a1, a4);
              }
            }
          }
        }
        else
        {
          uint64_t v17 = 0;
          while (1)
          {
            uint64_t v18 = &a1[v17];
            int v19 = v18[839];
            int v20 = (uint8x16_t *)(a3 + 548 * v19);
            int v21 = v18[843];
            if (!v20[17].i8[1])
            {
              uint64_t result = aj_write_single_dht(a2, v20, 0, v19);
              if (result) {
                break;
              }
            }
            if (!*(unsigned char *)(a3 + 548 * v21 + 547))
            {
              uint64_t result = aj_write_single_dht(a2, (uint8x16_t *)(a3 + 548 * v21 + 274), 1, v18[843]);
              if (result) {
                break;
              }
            }
            if (++v17 >= *a1) {
              goto LABEL_12;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_dri(uint64_t a1, int a2)
{
  uint64_t result = aj_ostream_write_bytes(a1, 65501, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a1, 4, 2);
    if (!result)
    {
      return aj_ostream_write_bytes(a1, a2, 2);
    }
  }
  return result;
}

uint64_t aj_huffman_decode_ac_s4(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  LODWORD(v6) = 1;
  uint64_t v7 = a1 + 48;
  uint64_t v8 = *(void *)(a1 + 696);
  unsigned int v9 = *(_DWORD *)a2;
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  uint64_t v11 = *(void *)(a1 + 40) + 400;
  int v12 = *(_DWORD *)(a2 + 24);
  uint64_t v13 = *(_DWORD *)a2 >> 23;
  uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_38:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            uint64_t v41 = v11;
            uint64_t v42 = (unsigned int *)a2;
            unsigned int v39 = a3;
            unsigned int v40 = a4;
            uint64_t v37 = a6;
            uint64_t v38 = v7;
            uint64_t v35 = v13;
            uint64_t v36 = v8;
            uint64_t result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if (result) {
              return result;
            }
            LODWORD(v6) = v33;
            int v32 = (int)v33 >> 16;
            uint64_t v13 = v35;
            uint64_t v8 = v36;
            uint64_t v7 = v38;
            a3 = v39;
            a4 = v40;
            uint64_t v11 = v41;
            a2 = (uint64_t)v42;
            unsigned int v10 = v42[7];
            int v12 = v42[6];
            unsigned int v9 = *v42;
            goto LABEL_31;
          }
          int v15 = (int)v14 >> 18;
          unsigned int v16 = v6 + v14;
          if ((v14 & 0x20000) != 0) {
            break;
          }
          if (v15)
          {
            int v17 = *(_DWORD *)(v7 + 4 * v16) * v15;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            uint64_t v13 = v9 >> 23;
            uint64_t v6 = v16 + 1;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17;
            if (v12 < 0) {
              goto LABEL_15;
            }
LABEL_6:
            if ((int)v6 >= 5)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
          else
          {
            if ((_BYTE)v14) {
              uint64_t v6 = v16 + 1;
            }
            else {
              uint64_t v6 = 64;
            }
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0) {
              goto LABEL_15;
            }
            uint64_t v13 = v9 >> 23;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 5)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0) {
          goto LABEL_38;
        }
        int v28 = BYTE1(v14);
        unsigned int v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        uint64_t v6 = v6 + (v29 >> 4);
        uint64_t v14 = v29 & 0xF;
        if (!v14) {
          goto LABEL_32;
        }
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          uint64_t v41 = v11;
          uint64_t v42 = (unsigned int *)a2;
          unsigned int v39 = a3;
          unsigned int v40 = a4;
          uint64_t v37 = (v12 + 9);
          uint64_t v38 = v7;
          uint64_t v35 = v6;
          uint64_t v36 = v13;
          uint64_t v33 = v8;
          uint64_t v34 = v14;
          uint64_t result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if (result) {
            return result;
          }
          uint64_t v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          uint64_t v13 = v36;
          uint64_t v7 = v38;
          a3 = v39;
          a4 = v40;
          uint64_t v11 = v41;
          a2 = (uint64_t)v42;
          unsigned int v10 = v42[7];
          int v12 = v42[6];
          unsigned int v9 = *v42;
        }
        v12 -= v14;
        signed int v30 = v9 >> (32 - v14);
        v9 <<= v14;
        int v31 = 1 << (v14 - 1);
        LOWORD(v32) = v30 < v31 ? v30 + 1 - 2 * v31 : (unsigned __int16)v30;
LABEL_31:
        uint64_t v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        uint64_t v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = v14 * v32;
LABEL_32:
        if (v12 < 0) {
          break;
        }
        uint64_t v13 = v9 >> 23;
        uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 5)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
      }
      if (v10) {
        goto LABEL_6;
      }
LABEL_15:
      a6 = *(unsigned int *)(a2 + 32);
      int v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8) {
        break;
      }
      int v20 = *v19;
      int v21 = v19[1];
      BOOL v23 = v20 == 255;
      int v22 = v21 + (v20 << 8);
      BOOL v23 = v23 || v21 == 255;
      int v24 = v19[2];
      uint64_t v25 = v19 + 3;
      a6 = (a6 - 3);
      uint64_t v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255) {
        break;
      }
      int v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(void *)(a2 + 8) = v25;
      v9 |= v14 << v27;
      int v12 = 23 - v27;
      uint64_t v13 = v9 >> 23;
      uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 5)
      {
        *(_DWORD *)a2 = v9;
        *(_DWORD *)(a2 + 24) = v12;
        *a4 = v6;
        return 0;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    uint64_t v41 = v11;
    uint64_t v42 = (unsigned int *)a2;
    unsigned int v39 = a3;
    unsigned int v40 = a4;
    uint64_t v37 = a6;
    uint64_t v38 = v7;
    uint64_t v35 = v6;
    uint64_t v36 = v13;
    uint64_t v33 = v8;
    uint64_t v34 = v14;
    uint64_t result = aj_istream_fill_buf(a2, -9);
    if (result) {
      return result;
    }
    uint64_t v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    uint64_t v7 = v38;
    a3 = v39;
    a4 = v40;
    uint64_t v11 = v41;
    a2 = (uint64_t)v42;
    unsigned int v10 = v42[7];
    int v12 = v42[6];
    unsigned int v9 = *v42;
    uint64_t v13 = *v42 >> 23;
    uint64_t v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 5);
  *uint64_t v42 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 0;
}

uint64_t sub_2103E2C7C(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, int a5, uint64_t a6, int a7)
{
  *a2 = a7;
  a2[6] = a5;
  *a4 = v7;
  return 7;
}

uint64_t aj_BGRA8888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9 = *a6;
  unsigned int v10 = *(unsigned char **)a7;
  uint64_t v11 = *(unsigned char **)(a7 + 16);
  int v12 = *(unsigned char **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  int16x8_t v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (unsigned int i = a8 >> 3; i; --i)
  {
    int8x8x4_t v30 = vld4_s8((const char *)v9);
    v9 += 32;
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    int16x8_t v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(void *)unsigned int v10 = a4.i64[0];
    v10 += 8;
    *(void *)uint64_t v11 = a3.i64[0];
    v11 += 8;
    *(void *)int v12 = a2.i64[0];
    v12 += 8;
  }
  int v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      a2.i8[0] = *(unsigned char *)v9;
      a3.i8[0] = *(unsigned char *)(v9 + 1);
      a4.i8[0] = *(unsigned char *)(v9 + 2);
      v9 += 4;
      --v20;
    }
    while (v20);
    int v21 = a8 & 7;
    int v22 = 8 - v21;
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a4.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a2.i8[7];
      a4 = vshlq_n_s64(a4, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a2 = vshlq_n_s64(a2, 8uLL);
      --v21;
    }
    while (v21);
  }
  uint64_t result = a9 - a8;
  if (a9 != a8)
  {
    char v27 = *(v10 - 1);
    char v28 = *(v11 - 1);
    char v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t aj_huffman_decode_val_slow(uint64_t a1, unsigned int *a2, int a3, unsigned int a4, int *a5)
{
  if ((int)a2[6] <= 6)
  {
    uint64_t error_code_eod = aj_istream_fill_buf((uint64_t)a2, -8);
    if (error_code_eod) {
      return error_code_eod;
    }
  }
  unsigned int v11 = *a2;
  unsigned int v12 = *a2 >> 1;
  do
  {
    unsigned int v13 = a4;
    unsigned int v14 = *(_DWORD *)(a1 + 4 * a4++ + 272);
  }
  while (v12 >= v14);
  if (a4 != 1) {
    v12 -= *(_DWORD *)(a1 + 4 * (a4 - 2) + 272);
  }
  unsigned int v15 = (v12 >> ~(_BYTE)a4) + *(_DWORD *)(a1 + 4 * v13 + 336);
  if (v15 >= *(unsigned __int16 *)(a1 + 4496))
  {
    aj_log_error((uint64_t)"HuffDec", "Bad huffman code in bitstream");
    return 7;
  }
  unsigned int v16 = *(unsigned __int8 *)(a1 + v15 + 16);
  int v17 = a2[6] - a4;
  a2[6] = v17;
  if (v17 <= -10) {
    goto LABEL_9;
  }
  unsigned int v18 = v11 << a4;
  *a2 = v18;
  int v19 = a3 + (v16 >> 4);
  if (v16 == 16)
  {
    if (*(unsigned char *)(a1 + 4498))
    {
      int v19 = 0;
      int v20 = 0x8000;
      goto LABEL_24;
    }
LABEL_22:
    int v20 = 0;
    if (v16 < 0x10) {
      int v19 = 63;
    }
    goto LABEL_24;
  }
  int v21 = v16 & 0xF;
  if ((v16 & 0xF) == 0) {
    goto LABEL_22;
  }
  if (v17 < v21 - 9)
  {
    uint64_t error_code_eod = aj_istream_fill_buf((uint64_t)a2, v21 - 9);
    if (error_code_eod) {
      return error_code_eod;
    }
    unsigned int v18 = *a2;
    int v17 = a2[6];
  }
  *a2 = v18 << v21;
  v17 -= v21;
  a2[6] = v17;
  if (v17 <= -10)
  {
LABEL_9:
    uint64_t error_code_eod = aj_istream_get_error_code_eod((uint64_t)a2);
    if (error_code_eod != -2) {
      aj_log_error((uint64_t)"HuffDec", "Not enough data in bitstream");
    }
    return error_code_eod;
  }
  int v20 = v18 >> -(char)v21;
  if ((v18 & 0x80000000) == 0) {
    v20 += (0x7FFFFFFF << v21) | 1;
  }
LABEL_24:
  if ((v17 & 0x80000000) == 0 || (uint64_t error_code_eod = aj_istream_fill_buf((uint64_t)a2, -9), !error_code_eod))
  {
    uint64_t error_code_eod = 0;
    *a5 = v19 | (v20 << 16);
  }
  return error_code_eod;
}

uint64_t aj_huffman_decode_skip_val_slow(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int *a5)
{
  int v10 = *(_DWORD *)(a2 + 24);
  if (v10 > 6) {
    goto LABEL_5;
  }
  uint64_t error_code_eod = aj_istream_fill_buf(a2, -9);
  if (error_code_eod) {
    return error_code_eod;
  }
  int v10 = *(_DWORD *)(a2 + 24);
  if (v10 > 6 || *(void *)(a2 + 16))
  {
LABEL_5:
    int v12 = *(_DWORD *)a2;
    int v13 = *(_DWORD *)a2 >> 1;
    uint64_t v14 = ((uint64_t)a4 << 32) - 0x200000000;
    unsigned int v15 = (unsigned int *)(a1 + 4 * a4 + 272);
    do
    {
      unsigned int v16 = *v15++;
      v14 += 0x100000000;
      ++a4;
    }
    while (v13 >= v16);
    if (a4 != 1) {
      v13 -= *(_DWORD *)(a1 + (v14 >> 30) + 272);
    }
    int v17 = (v13 >> ~(_BYTE)a4) + v15[15];
    if (v17 >= *(unsigned __int16 *)(a1 + 4496))
    {
      aj_log_error((uint64_t)"HuffDec", "Bad huffman code in bitstream");
      return 7;
    }
    unsigned int v18 = *(unsigned __int8 *)(a1 + v17 + 16);
    int v19 = v10 - a4;
    *(_DWORD *)(a2 + 24) = v19;
    if (v19 <= -10) {
      goto LABEL_11;
    }
    *(_DWORD *)a2 = v12 << a4;
    if (v18)
    {
      int v21 = v18 & 0xF;
      if (v19 < v21 - 9)
      {
        uint64_t error_code_eod = aj_istream_fill_buf(a2, v21 - 9);
        if (error_code_eod) {
          return error_code_eod;
        }
        int v19 = *(_DWORD *)(a2 + 24);
      }
      int v22 = v19 - v21;
      *(_DWORD *)(a2 + 24) = v22;
      if (v22 <= -10)
      {
LABEL_11:
        uint64_t error_code_eod = aj_istream_get_error_code_eod(a2);
        if (error_code_eod != -2) {
          aj_log_error((uint64_t)"HuffDec", "Not enough data in bitstream");
        }
        return error_code_eod;
      }
      *(_DWORD *)a2 <<= v21;
      *a3 += (v18 >> 4) + 1;
      if ((*(_DWORD *)(a2 + 24) & 0x80000000) != 0)
      {
        uint64_t error_code_eod = aj_istream_fill_buf(a2, -9);
        if (error_code_eod) {
          return error_code_eod;
        }
      }
      int v23 = 0;
    }
    else
    {
      if (v19 < 0)
      {
        uint64_t error_code_eod = aj_istream_fill_buf(a2, -9);
        if (error_code_eod) {
          return error_code_eod;
        }
      }
      int v23 = 1;
    }
    uint64_t error_code_eod = 0;
    *a5 = v23;
    return error_code_eod;
  }
  uint64_t error_code_eod = 7;
  if (*(unsigned char *)(a2 + 112))
  {
    if (*(_DWORD *)(a2 + 56) == 1) {
      return 4294967294;
    }
    else {
      return 7;
    }
  }
  return error_code_eod;
}

uint64_t aj_block_encode(uint64_t a1, __int16 *a2, int32x2_t *a3, _DWORD *a4)
{
  int v7 = *a2;
  int v8 = v7 - *a4;
  *a4 = v7;
  uint64_t result = aj_huffman_encode_val_lkup(*(void *)(a1 + 672), 0, v8, a3);
  if (!result)
  {
    return aj_block_encode_ac(a1, (uint64_t)a2, (uint64_t)a3);
  }
  return result;
}

uint64_t aj_prog_encode_DC_first(int32x2_t *a1, __int16 *a2, int *a3, int a4)
{
  int v4 = *a2 >> a1[7].i32[1];
  int v5 = v4 - *a3;
  *a3 = v4;
  return aj_huffman_encode_val_lkup(*(void *)&a1[a4 + 34], 0, v5, a1 + 11);
}

uint64_t aj_prog_encode_DC_refine(int32x2_t *a1, __int16 *a2)
{
  unsigned int v2 = (*a2 >> a1[7].i32[1]) & 1;
  if (a1[13].i32[1] >= 9 && (int v3 = a1[11].i32[1], v3 < 32))
  {
    unsigned int v5 = a1[11].i32[0] | (v2 << ~(_BYTE)v3);
    a1[11].i32[0] = v5;
    a1[11].i32[1] = v3 + 1;
    if (v3 >= 7)
    {
      do
      {
        unsigned int v6 = HIBYTE(v5);
        int v7 = (unsigned char *)a1[12];
        a1[12] = (int32x2_t)(v7 + 1);
        *int v7 = v6;
        a1[13] = vadd_s32(a1[13], (int32x2_t)0xFFFFFFFF00000001);
        if (v6 == 255)
        {
          int v8 = (unsigned char *)a1[12];
          a1[12] = (int32x2_t)(v8 + 1);
          *int v8 = 0;
          a1[13] = vadd_s32(a1[13], (int32x2_t)0xFFFFFFFF00000001);
        }
        int v9 = a1[11].i32[1];
        unsigned int v5 = a1[11].i32[0] << 8;
        a1[11].i32[0] = v5;
        a1[11].i32[1] = v9 - 8;
      }
      while (v9 > 15);
    }
  }
  else
  {
    uint64_t result = aj_ostream_write((unsigned int *)&a1[11], v2, 1);
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t aj_prog_encode_AC_first(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int *)(a1 + 52);
  if ((int)v2 > *(_DWORD *)(a1 + 56)) {
    return 0;
  }
  int v6 = 0;
  int v7 = (int32x2_t *)(a1 + 88);
  do
  {
    unsigned int v8 = *(__int16 *)(a2 + 2 * v2);
    if (!*(_WORD *)(a2 + 2 * v2))
    {
LABEL_15:
      ++v6;
      continue;
    }
    if ((v8 & 0x80000000) != 0)
    {
      unsigned int v9 = -v8 >> *(_DWORD *)(a1 + 60);
      int v10 = ~v9;
      if (!v9) {
        goto LABEL_15;
      }
    }
    else
    {
      unsigned int v9 = v8 >> *(_DWORD *)(a1 + 60);
      int v10 = v9;
      if (!v9) {
        goto LABEL_15;
      }
    }
    if (*(_DWORD *)(a1 + 80))
    {
      uint64_t result = write_eobn(a1);
      if (result) {
        return result;
      }
    }
    int v11 = 16 * v6;
    int v12 = v6 + 16;
    while (1)
    {
      v12 -= 16;
      if (v12 < 16) {
        break;
      }
      v11 -= 256;
      uint64_t result = aj_huffman_encode_sym_lkup(*(void *)(a1 + 272), 240, v7);
      if (result) {
        return result;
      }
    }
    int v13 = aj_highest_set_bit(v9);
    uint64_t result = aj_huffman_encode_sym_lkup(*(void *)(a1 + 272), v13 + v11, v7);
    if (result) {
      return result;
    }
    unsigned int v14 = (0xFFFFFFFF >> -(char)v13) & v10;
    if (*(int *)(a1 + 108) < 9 || (int v15 = *(_DWORD *)(a1 + 92), v16 = v15 + v13, v15 + v13 >= 33))
    {
      uint64_t result = aj_ostream_write((unsigned int *)v7, v14, v13);
      if (result) {
        return result;
      }
LABEL_20:
      int v6 = 0;
      continue;
    }
    unsigned int v18 = *(_DWORD *)(a1 + 88) | (v14 << (32 - v13 - v15));
    *(_DWORD *)(a1 + 88) = v18;
    *(_DWORD *)(a1 + 92) = v16;
    if (v16 < 8) {
      goto LABEL_20;
    }
    do
    {
      unsigned int v19 = HIBYTE(v18);
      int v20 = *(unsigned char **)(a1 + 96);
      *(void *)(a1 + 96) = v20 + 1;
      unsigned char *v20 = v19;
      *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
      if (v19 == 255)
      {
        int v21 = *(unsigned char **)(a1 + 96);
        *(void *)(a1 + 96) = v21 + 1;
        unsigned char *v21 = 0;
        *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
      }
      int v6 = 0;
      int v22 = *(_DWORD *)(a1 + 92);
      unsigned int v18 = *(_DWORD *)(a1 + 88) << 8;
      *(_DWORD *)(a1 + 88) = v18;
      *(_DWORD *)(a1 + 92) = v22 - 8;
    }
    while (v22 > 15);
  }
  while (v2++ < *(int *)(a1 + 56));
  if (v6 < 1) {
    return 0;
  }
  unsigned int v23 = *(_DWORD *)(a1 + 80) + 1;
  *(_DWORD *)(a1 + 80) = v23;
  if (v23 < 0x7FFF) {
    return 0;
  }
  uint64_t result = write_eobn(a1);
  if (!result) {
    return 0;
  }
  return result;
}

uint64_t write_eobn(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 80);
  if (!v1) {
    return 0;
  }
  int v3 = aj_highest_set_bit(*(_DWORD *)(a1 + 80));
  int v4 = v3 - 1;
  *(_DWORD *)(a1 + 80) = 0;
  uint64_t result = aj_huffman_encode_sym_lkup(*(void *)(a1 + 272), 16 * (v3 - 1), (int32x2_t *)(a1 + 88));
  if (result) {
    return result;
  }
  if (v3 != 1)
  {
    unsigned int v6 = (0xFFFFFFFF >> (33 - v3)) & v1;
    if (*(int *)(a1 + 108) >= 9 && (int v7 = *(_DWORD *)(a1 + 92), v8 = v7 + v4, v7 + v4 < 33))
    {
      unsigned int v9 = *(_DWORD *)(a1 + 88) | (v6 << (33 - v3 - v7));
      *(_DWORD *)(a1 + 88) = v9;
      *(_DWORD *)(a1 + 92) = v8;
      if (v8 >= 8)
      {
        do
        {
          unsigned int v10 = HIBYTE(v9);
          int v11 = *(unsigned char **)(a1 + 96);
          *(void *)(a1 + 96) = v11 + 1;
          *int v11 = v10;
          *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
          if (v10 == 255)
          {
            int v12 = *(unsigned char **)(a1 + 96);
            *(void *)(a1 + 96) = v12 + 1;
            *int v12 = 0;
            *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
          }
          int v13 = *(_DWORD *)(a1 + 92);
          unsigned int v9 = *(_DWORD *)(a1 + 88) << 8;
          *(_DWORD *)(a1 + 88) = v9;
          *(_DWORD *)(a1 + 92) = v13 - 8;
        }
        while (v13 > 15);
      }
    }
    else
    {
      uint64_t result = aj_ostream_write((unsigned int *)(a1 + 88), v6, v4);
      if (result) {
        return result;
      }
    }
  }
  int v14 = *(_DWORD *)(a1 + 196);
  if (!v14) {
    return 0;
  }
  int v15 = *(unsigned __int8 **)(a1 + 184);
  while (1)
  {
    BOOL v16 = __OFSUB__(v14--, 1);
    if (v14 < 0 != v16) {
      break;
    }
    unsigned int v17 = *v15++;
    uint64_t result = aj_ostream_write((unsigned int *)(a1 + 88), v17, 1);
    if (result) {
      return result;
    }
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 196) = 0;
  return result;
}

uint64_t aj_prog_encode_AC_refine(uint64_t a1, uint64_t a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 52);
  int v4 = *(_DWORD *)(a1 + 56);
  if (v3 <= v4)
  {
    int v10 = 0;
    uint64_t v11 = v3;
    int v12 = *(_DWORD *)(a1 + 60);
    int v13 = v4 + 1;
    int v14 = (__int16 *)(a2 + 2 * v3);
    int v15 = &v36[v3];
    do
    {
      int v17 = *v14++;
      unsigned int v16 = v17;
      if (v17 < 0) {
        unsigned int v16 = -v16;
      }
      unsigned int v18 = v16 >> v12;
      *v15++ = v18;
      if (v18 == 1) {
        int v10 = v3;
      }
      ++v3;
    }
    while (v13 != v3);
    int v6 = 0;
    uint64_t v19 = 0;
    uint64_t v35 = v10;
    int v20 = (unsigned __int8 *)(*(void *)(a1 + 184) + *(int *)(a1 + 196));
    while (1)
    {
      int v21 = v36[v11];
      if (v21)
      {
        if ((int)v19 < 16)
        {
          uint64_t v5 = v19;
          int v22 = v6;
        }
        else
        {
          uint64_t v5 = v19;
          int v22 = v6;
          if (v11 <= v35)
          {
            do
            {
              if (*(_DWORD *)(a1 + 80))
              {
                uint64_t result = write_eobn(a1);
                if (result) {
                  return result;
                }
              }
              uint64_t result = aj_huffman_encode_sym_lkup(*(void *)(a1 + 272), 240, (int32x2_t *)(a1 + 88));
              if (result) {
                return result;
              }
              uint64_t v5 = (v19 - 16);
              while (1)
              {
                BOOL v23 = __OFSUB__(v6--, 1);
                if (v6 < 0 != v23) {
                  break;
                }
                unsigned int v24 = *v20++;
                uint64_t result = aj_ostream_write((unsigned int *)(a1 + 88), v24, 1);
                if (result) {
                  return result;
                }
              }
              int v6 = 0;
              int v22 = 0;
              int v20 = *(unsigned __int8 **)(a1 + 184);
              BOOL v25 = (int)v19 <= 31;
              LODWORD(v19) = v19 - 16;
            }
            while (!v25);
          }
        }
        if (v21 < 2)
        {
          if (!*(_DWORD *)(a1 + 80) || (uint64_t result = write_eobn(a1), !result))
          {
            uint64_t result = aj_huffman_encode_sym_lkup(*(void *)(a1 + 272), (16 * v5) | 1, (int32x2_t *)(a1 + 88));
            if (!result)
            {
              unsigned int v26 = (*(unsigned __int16 *)(a2 + 2 * v11) >> 15) ^ 1;
              if (*(int *)(a1 + 108) >= 9)
              {
                int v27 = *(_DWORD *)(a1 + 92);
                if (v27 < 32)
                {
                  unsigned int v28 = *(_DWORD *)(a1 + 88) | (v26 << ~(_BYTE)v27);
                  *(_DWORD *)(a1 + 88) = v28;
                  *(_DWORD *)(a1 + 92) = v27 + 1;
                  if (v27 >= 7)
                  {
                    do
                    {
                      unsigned int v29 = HIBYTE(v28);
                      int8x8x4_t v30 = *(unsigned char **)(a1 + 96);
                      *(void *)(a1 + 96) = v30 + 1;
                      *int8x8x4_t v30 = v29;
                      *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
                      if (v29 == 255)
                      {
                        int v31 = *(unsigned char **)(a1 + 96);
                        *(void *)(a1 + 96) = v31 + 1;
                        *int v31 = 0;
                        *(int32x2_t *)(a1 + 104) = vadd_s32(*(int32x2_t *)(a1 + 104), (int32x2_t)0xFFFFFFFF00000001);
                      }
                      int v32 = *(_DWORD *)(a1 + 92);
                      unsigned int v28 = *(_DWORD *)(a1 + 88) << 8;
                      *(_DWORD *)(a1 + 88) = v28;
                      *(_DWORD *)(a1 + 92) = v32 - 8;
                    }
                    while (v32 > 15);
                  }
                  goto LABEL_44;
                }
              }
              while (1)
              {
                uint64_t result = aj_ostream_write((unsigned int *)(a1 + 88), v26, 1);
                if (result) {
                  break;
                }
LABEL_44:
                BOOL v23 = __OFSUB__(v22--, 1);
                if (v22 < 0 != v23)
                {
                  uint64_t v5 = 0;
                  int v6 = 0;
                  int v20 = *(unsigned __int8 **)(a1 + 184);
                  goto LABEL_47;
                }
                unsigned int v33 = *v20++;
                unsigned int v26 = v33;
              }
            }
          }
          return result;
        }
        int v6 = v22 + 1;
        v20[v22] = v21 & 1;
      }
      else
      {
        uint64_t v5 = (v19 + 1);
      }
LABEL_47:
      ++v11;
      uint64_t v19 = v5;
      if (v13 == v11) {
        goto LABEL_3;
      }
    }
  }
  LODWORD(v5) = 0;
  int v6 = 0;
LABEL_3:
  if (!(v5 | v6)) {
    return 0;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 80) + 1;
  *(_DWORD *)(a1 + 80) = v7;
  int v8 = *(_DWORD *)(a1 + 196) + v6;
  *(_DWORD *)(a1 + 196) = v8;
  if (v7 <= 0x7FFE && v8 < 961) {
    return 0;
  }
  uint64_t result = write_eobn(a1);
  if (!result) {
    return 0;
  }
  return result;
}

uint64_t aj_prog_encode_close(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 80)) {
    return write_eobn(a1);
  }
  else {
    return 0;
  }
}

uint8x16_t **aj_icol_row_420_to_rgb565(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint8x8_t v9 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    int v10 = *result;
    uint64_t v11 = *a2;
    int v12 = *a3;
    if (a6 == 1)
    {
      for (unsigned int i = a7 >> 4; i; --i)
      {
        uint8x16_t v59 = *v10++;
        uint8x8_t v60 = *v11++;
        uint8x8_t v61 = *v12++;
        int16x8_t v62 = (int16x8_t)vsubl_u8(v60, v9);
        int16x8_t v63 = (int16x8_t)vsubl_u8(v61, v9);
        int16x8_t v64 = vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v65 = vmulq_n_s16(v63, 179);
        int16x8_t v66 = vqaddq_s16(vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v63, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v67 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v59.i8, 7uLL);
        int8x8_t v68 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v67, vzip1q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v68, 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v68, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v90);
        int v69 = a4 + 16;
        int16x8_t v70 = (int16x8_t)vshll_high_n_u8(v59, 7uLL);
        v90.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v70, vzip2q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v90.val[1], 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v90.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v69, v90);
        a4 = v69 + 16;
      }
      unsigned int v71 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v72 = *(uint64x2_t *)v10;
        int16x8_t v73 = (int16x8_t)vsubl_u8(*v11, v9);
        int16x8_t v74 = (int16x8_t)vsubl_u8(*v12, v9);
        int16x8_t v75 = vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v76 = vmulq_n_s16(v74, 179);
        int16x8_t v77 = vqaddq_s16(vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v74, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v78 = vzip2q_s16(v75, v75);
        int16x8_t v79 = vzip2q_s16(v76, v76);
        int16x8_t v80 = vzip2q_s16(v77, v77);
        int16x8_t v81 = vzip1q_s16(v75, v75);
        int16x8_t v82 = vzip1q_s16(v76, v76);
        int16x8_t v83 = vzip1q_s16(v77, v77);
        if (!(v71 >> 3)) {
          goto LABEL_16;
        }
        int16x8_t v84 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
        int8x8_t v85 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v84, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v91.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v85, 5uLL));
        v91.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v85, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v91);
        a4 += 16;
        int16x8_t v81 = v78;
        int16x8_t v82 = v79;
        int16x8_t v83 = v80;
        v72.i64[0] = v72.i64[1];
        v71 -= 8;
        if (v71)
        {
LABEL_16:
          int16x8_t v86 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
          int8x8_t v87 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v86, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v87, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v87, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            --v71;
          }
          while (v71);
        }
      }
    }
    else
    {
      unsigned int v13 = a7 >> 4;
      for (uint64_t j = result[1]; v13; --v13)
      {
        uint8x16_t v15 = *v10++;
        uint8x16_t v16 = *j++;
        uint8x8_t v17 = *v11++;
        uint8x8_t v18 = *v12++;
        int16x8_t v19 = (int16x8_t)vsubl_u8(v17, v9);
        int16x8_t v20 = (int16x8_t)vsubl_u8(v18, v9);
        int16x8_t v21 = vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v22 = vmulq_n_s16(v20, 179);
        int16x8_t v23 = vqaddq_s16(vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v24 = vzip2q_s16(v21, v21);
        int16x8_t v25 = vzip2q_s16(v22, v22);
        int16x8_t v26 = vzip2q_s16(v23, v23);
        int16x8_t v27 = vzip1q_s16(v21, v21);
        int16x8_t v28 = vzip1q_s16(v22, v22);
        int16x8_t v29 = vzip1q_s16(v23, v23);
        int16x8_t v30 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v15.i8, 7uLL);
        int8x8_t v31 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v30, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v31, 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v31, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v88);
        int v32 = a4 + 16;
        int16x8_t v33 = (int16x8_t)vshll_high_n_u8(v15, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v33, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v32, v88);
        a4 = v32 + 16;
        int16x8_t v34 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v16.i8, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v34, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v88);
        uint64_t v35 = a5 + 16;
        int16x8_t v36 = (int16x8_t)vshll_high_n_u8(v16, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v36, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v35, v88);
        a5 = v35 + 16;
      }
      unsigned int v37 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v38 = *(uint64x2_t *)v10;
        uint64x2_t v39 = *(uint64x2_t *)j;
        int16x8_t v40 = (int16x8_t)vsubl_u8(*v11, v9);
        int16x8_t v41 = (int16x8_t)vsubl_u8(*v12, v9);
        int16x8_t v42 = vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v43 = vmulq_n_s16(v41, 179);
        int16x8_t v44 = vqaddq_s16(vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v45 = vzip2q_s16(v42, v42);
        int16x8_t v46 = vzip2q_s16(v43, v43);
        int16x8_t v47 = vzip2q_s16(v44, v44);
        int16x8_t v48 = vzip1q_s16(v42, v42);
        int16x8_t v49 = vzip1q_s16(v43, v43);
        int16x8_t v50 = vzip1q_s16(v44, v44);
        if (!(v37 >> 3)) {
          goto LABEL_8;
        }
        int16x8_t v51 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
        int8x8_t v52 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v51, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v52, 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v52, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v89);
        a4 += 16;
        int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v89.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v53, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v89.val[1], 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v89.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v89);
        a5 += 16;
        int16x8_t v48 = v45;
        int16x8_t v49 = v46;
        int16x8_t v50 = v47;
        v38.i64[0] = v38.i64[1];
        v39.i64[0] = v39.i64[1];
        v37 -= 8;
        if (v37)
        {
LABEL_8:
          int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
          int8x8_t v55 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v54, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v55, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v55, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          int8x8_t v57 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v56, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v38.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v57, 5uLL));
          *(int8x8_t *)v39.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v57, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            *a5 = v38.i8[0];
            a5[1] = v39.i8[0];
            a5 += 2;
            uint64x2_t v38 = vshrq_n_u64(v38, 8uLL);
            uint64x2_t v39 = vshrq_n_u64(v39, 8uLL);
            --v37;
          }
          while (v37);
        }
      }
    }
  }
  return result;
}

uint8x16_t **aj_icol_row_420_to_bgra(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint8x8_t v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  unint64_t v12 = vdupq_n_s8(0xFFu).u64[0];
  if (a6 >= 1)
  {
    unsigned int v13 = *result;
    int v14 = *a2;
    uint8x16_t v15 = *a3;
    if (a6 == 1)
    {
      for (unsigned int i = a7 >> 4; i; --i)
      {
        uint8x16_t v58 = *v13++;
        uint8x8_t v59 = *v14++;
        uint8x8_t v60 = *v15++;
        int16x8_t v61 = (int16x8_t)vsubl_u8(v59, v11);
        int16x8_t v62 = (int16x8_t)vsubl_u8(v60, v11);
        int16x8_t v63 = vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v64 = vmulq_n_s16(v62, 179);
        int16x8_t v65 = vqaddq_s16(vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v66 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v58.i8, 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v63, v63)), 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v66, vzip1q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v86);
        int16x8_t v67 = a4 + 32;
        int16x8_t v68 = (int16x8_t)vshll_high_n_u8(v58, 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v63, v63)), 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v68, vzip2q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(v67, v86);
        a4 = v67 + 32;
      }
      unsigned int v69 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v70 = *(uint64x2_t *)v13;
        int16x8_t v71 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v72 = (int16x8_t)vsubl_u8(*v15, v11);
        int16x8_t v73 = vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v74 = vmulq_n_s16(v72, 179);
        int16x8_t v75 = vqaddq_s16(vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v72, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v76 = vzip2q_s16(v73, v73);
        int16x8_t v77 = vzip2q_s16(v74, v74);
        int16x8_t v78 = vzip2q_s16(v75, v75);
        int16x8_t v79 = vzip1q_s16(v73, v73);
        int16x8_t v80 = vzip1q_s16(v74, v74);
        int16x8_t v81 = vzip1q_s16(v75, v75);
        if (!(v69 >> 3)) {
          goto LABEL_16;
        }
        int16x8_t v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
        v87.val[0] = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
        v87.val[2] = vqrshrun_n_s16(vqaddq_s16(v82, v80), 7uLL);
        v87.val[1] = vqrshrun_n_s16(vqsubq_s16(v82, v81), 7uLL);
        v87.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v87);
        a4 += 32;
        int16x8_t v79 = v76;
        int16x8_t v80 = v77;
        int16x8_t v81 = v78;
        v70.i64[0] = v70.i64[1];
        v69 -= 8;
        if (v69)
        {
LABEL_16:
          int16x8_t v83 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v79), 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v80), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v83, v81), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            --v69;
          }
          while (v69);
        }
      }
    }
    else
    {
      unsigned int v16 = a7 >> 4;
      for (uint64_t j = result[1]; v16; --v16)
      {
        uint8x16_t v18 = *v13++;
        uint8x16_t v19 = *j++;
        uint8x8_t v20 = *v14++;
        uint8x8_t v21 = *v15++;
        int16x8_t v22 = (int16x8_t)vsubl_u8(v20, v11);
        int16x8_t v23 = (int16x8_t)vsubl_u8(v21, v11);
        int16x8_t v24 = vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v25 = vmulq_n_s16(v23, 179);
        int16x8_t v26 = vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v27 = vzip2q_s16(v24, v24);
        int16x8_t v28 = vzip2q_s16(v25, v25);
        int16x8_t v29 = vzip2q_s16(v26, v26);
        int16x8_t v30 = vzip1q_s16(v24, v24);
        int16x8_t v31 = vzip1q_s16(v25, v25);
        int16x8_t v32 = vzip1q_s16(v26, v26);
        int16x8_t v33 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v33, v30), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v33, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v33, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v84);
        int16x8_t v34 = a4 + 32;
        int16x8_t v35 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v27), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v34, v84);
        a4 = v34 + 32;
        int16x8_t v36 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v19.i8, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v36, v30), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v36, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v36, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v84);
        unsigned int v37 = a5 + 32;
        int16x8_t v38 = (int16x8_t)vshll_high_n_u8(v19, 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v38, v27), 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v38, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v38, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v37, v84);
        a5 = v37 + 32;
      }
      unsigned int v39 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v40 = *(uint64x2_t *)v13;
        uint64x2_t v41 = *(uint64x2_t *)j;
        int16x8_t v42 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v43 = (int16x8_t)vsubl_u8(*v15, v11);
        int16x8_t v44 = vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v45 = vmulq_n_s16(v43, 179);
        int16x8_t v46 = vqaddq_s16(vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v43, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v47 = vzip2q_s16(v44, v44);
        int16x8_t v48 = vzip2q_s16(v45, v45);
        int16x8_t v49 = vzip2q_s16(v46, v46);
        int16x8_t v50 = vzip1q_s16(v44, v44);
        int16x8_t v51 = vzip1q_s16(v45, v45);
        int16x8_t v52 = vzip1q_s16(v46, v46);
        if (!(v39 >> 3)) {
          goto LABEL_8;
        }
        int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v85);
        a4 += 32;
        int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v54, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v54, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v85);
        a5 += 32;
        int16x8_t v50 = v47;
        int16x8_t v51 = v48;
        int16x8_t v52 = v49;
        v40.i64[0] = v40.i64[1];
        v41.i64[0] = v41.i64[1];
        v39 -= 8;
        if (v39)
        {
LABEL_8:
          int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v51), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v52), 7uLL);
          int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v50), 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v51), 7uLL);
          *(int8x8_t *)v41.i8 = vqrshrun_n_s16(vqsubq_s16(v56, v52), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v40.i8[0];
            a5[1] = v41.i8[0];
            a5[2] = v10.i8[0];
            a5[3] = v12;
            a5 += 4;
            uint64x2_t v40 = vshrq_n_u64(v40, 8uLL);
            uint64x2_t v41 = vshrq_n_u64(v41, 8uLL);
            uint64x2_t v10 = vshrq_n_u64(v10, 8uLL);
            --v39;
          }
          while (v39);
        }
      }
    }
  }
  return result;
}

uint64_t aj_idct_s2_4x8_nearest(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = vqrdmulhq_lane_s16(vaddq_s16(v3, v5), (int16x4_t)0x6C8361F84546, 0);
  int16x8_t v7 = vaddq_s16(*a1, v4);
  int16x8_t v8 = vsubq_s16(*a1, v4);
  int16x8_t v9 = vaddq_s16(vqrdmulhq_lane_s16(v3, (int16x4_t)0x6C8361F84546, 1), v6);
  int16x8_t v10 = vsubq_s16(vsubq_s16(v6, vqrdmulhq_lane_s16(v5, (int16x4_t)0x6C8361F84546, 2)), v5);
  int16x8_t v11 = vaddq_s16(v7, v9);
  int16x8_t v12 = vaddq_s16(v8, v10);
  int16x8_t v13 = vsubq_s16(v8, v10);
  int16x8_t v14 = vsubq_s16(v7, v9);
  int32x4_t v15 = (int32x4_t)vtrn1q_s16(v11, v12);
  int32x4_t v16 = (int32x4_t)vtrn2q_s16(v11, v12);
  int32x4_t v17 = (int32x4_t)vtrn1q_s16(v13, v14);
  int32x4_t v18 = (int32x4_t)vtrn2q_s16(v13, v14);
  int16x8_t v19 = (int16x8_t)vtrn1q_s32(v15, v17);
  int16x8_t v20 = (int16x8_t)vtrn2q_s32(v15, v17);
  int16x8_t v21 = (int16x8_t)vtrn1q_s32(v16, v18);
  int16x8_t v22 = (int16x8_t)vtrn2q_s32(v16, v18);
  int16x8_t v23 = vqrdmulhq_lane_s16(vaddq_s16(v21, v22), (int16x4_t)0x6C8361F84546, 0);
  int16x8_t v24 = vaddq_s16(v19, v20);
  int16x8_t v25 = vsubq_s16(v19, v20);
  int16x8_t v26 = vaddq_s16(vqrdmulhq_lane_s16(v21, (int16x4_t)0x6C8361F84546, 1), v23);
  int16x8_t v27 = vsubq_s16(vsubq_s16(v23, vqrdmulhq_lane_s16(v22, (int16x4_t)0x6C8361F84546, 2)), v22);
  int16x8_t v28 = vaddq_s16(v24, v26);
  int16x8_t v29 = vaddq_s16(v25, v27);
  int16x8_t v30 = vsubq_s16(v25, v27);
  int16x8_t v31 = vsubq_s16(v24, v26);
  int32x4_t v32 = (int32x4_t)vtrn1q_s16(v28, v29);
  int32x4_t v33 = (int32x4_t)vtrn2q_s16(v28, v29);
  int32x4_t v34 = (int32x4_t)vtrn1q_s16(v30, v31);
  int32x4_t v35 = (int32x4_t)vtrn2q_s16(v30, v31);
  uint64_t v37 = *a2;
  uint64_t v38 = a2[1];
  int16x8_t v36 = a2 + 2;
  _X3 = (int8x8_t *)(v37 + a3);
  _X4 = (int8x8_t *)(v38 + a3);
  _X5 = (int8x8_t *)(*v36 + a3);
  _X6 = (int8x8_t *)(v36[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *(int8x8_t *)v28.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v29.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v30.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v31.i8 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080);
  *_X3 = vzip1_s8(*(int8x8_t *)v28.i8, *(int8x8_t *)v28.i8);
  *_X4 = vzip1_s8(*(int8x8_t *)v29.i8, *(int8x8_t *)v29.i8);
  *_X5 = vzip1_s8(*(int8x8_t *)v30.i8, *(int8x8_t *)v30.i8);
  *_X6 = vzip1_s8(*(int8x8_t *)v31.i8, *(int8x8_t *)v31.i8);
  return 8;
}

uint64_t aj_RGBA8888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9 = *a6;
  int16x8_t v10 = *(unsigned char **)a7;
  int16x8_t v11 = *(unsigned char **)(a7 + 16);
  int16x8_t v12 = *(unsigned char **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  int16x8_t v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (unsigned int i = a8 >> 3; i; --i)
  {
    int8x8x4_t v30 = vld4_s8((const char *)v9);
    v9 += 32;
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    int16x8_t v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(void *)int16x8_t v10 = a2.i64[0];
    v10 += 8;
    *(void *)int16x8_t v11 = a3.i64[0];
    v11 += 8;
    *(void *)int16x8_t v12 = a4.i64[0];
    v12 += 8;
  }
  int v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      a2.i8[0] = *(unsigned char *)v9;
      a3.i8[0] = *(unsigned char *)(v9 + 1);
      a4.i8[0] = *(unsigned char *)(v9 + 2);
      v9 += 4;
      --v20;
    }
    while (v20);
    int v21 = a8 & 7;
    int v22 = 8 - v21;
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a2.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a4.i8[7];
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v21;
    }
    while (v21);
  }
  uint64_t result = a9 - a8;
  if (a9 != a8)
  {
    char v27 = *(v10 - 1);
    char v28 = *(v11 - 1);
    char v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

uint64_t aj_ostream_write(unsigned int *a1, unsigned int a2, int a3)
{
  if (!a3) {
    return 0;
  }
  if (a1[16] && (int)a1[5] <= 8)
  {
    unsigned int v22 = a2;
    int v23 = a3;
    int v21 = a1;
    unsigned __int8 v20 = (*((uint64_t (**)(void, void, void))a1 + 5))(*((void *)a1 + 3), a1[2] - *((void *)a1 + 3), *((void *)a1 + 4));
    if (v20)
    {
      aj_log_error(0, "Output callback returned error code %d.", v20);
      return 9;
    }
    a1 = v21;
    *((void *)v21 + 1) = *((void *)v21 + 3);
    v21[5] = v21[16];
    a2 = v22;
    a3 = v23;
  }
  unsigned int v3 = *a1;
  int v4 = a1[1];
  int v5 = v4 + a3;
  if (v4 + a3 >= 33)
  {
    a3 = v5 - 32;
    unsigned int v15 = v3 | (a2 >> v5);
    *a1 = v15;
    a2 &= 0xFFFFFFFF >> -(char)v5;
    unsigned int v16 = HIBYTE(v15);
    int16x8_t v17 = (unsigned char *)*((void *)a1 + 1);
    *((void *)a1 + 1) = v17 + 1;
    unsigned char *v17 = v16;
    unsigned int v18 = a1[4];
    a1[4] = v18 + 1;
    if (v16 == 255)
    {
      a1[4] = v18 + 2;
      int16x8_t v19 = (unsigned char *)*((void *)a1 + 1);
      *((void *)a1 + 1) = v19 + 1;
      unsigned char *v19 = 0;
    }
    unsigned int v3 = *a1 << 8;
    int v4 = 24;
  }
  int v6 = v4 + a3;
  unsigned int v7 = (a2 << -(char)v6) | v3;
  *a1 = v7;
  a1[1] = v6;
  if (v6 >= 8)
  {
    do
    {
      unsigned int v8 = HIBYTE(v7);
      uint64_t v9 = (unsigned char *)*((void *)a1 + 1);
      *((void *)a1 + 1) = v9 + 1;
      *uint64_t v9 = v8;
      ++a1[4];
      if (v8 == 255)
      {
        int16x8_t v10 = (unsigned char *)*((void *)a1 + 1);
        *((void *)a1 + 1) = v10 + 1;
        *int16x8_t v10 = 0;
        ++a1[4];
      }
      int v11 = a1[1];
      unsigned int v7 = *a1 << 8;
      *a1 = v7;
      a1[1] = v11 - 8;
    }
    while (v11 > 15);
  }
  unsigned int v12 = a1[16];
  uint64_t v13 = 0;
  if (v12) {
    a1[5] = v12 + a1[6] - a1[2];
  }
  return v13;
}

uint64_t aj_ostream_write_bytes(uint64_t a1, int a2, int a3)
{
  if (!a3) {
    return 0;
  }
  int v3 = a3;
  int v6 = *(_DWORD *)(a1 + 4);
  if (!v6 || (uint64_t result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v6, 8 - v6), !result))
  {
    if (*(_DWORD *)(a1 + 64) && *(int *)(a1 + 20) <= 8)
    {
      int v11 = (*(uint64_t (**)(void, void, void))(a1 + 40))(*(void *)(a1 + 24), *(_DWORD *)(a1 + 8) - *(void *)(a1 + 24), *(void *)(a1 + 32));
      if (v11)
      {
        aj_log_error(0, "Output callback returned error code %d.", v11);
        return 9;
      }
      *(void *)(a1 + 8) = *(void *)(a1 + 24);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 64);
    }
    int v8 = a2 << (-8 * v3);
    do
    {
      uint64_t v9 = *(unsigned char **)(a1 + 8);
      *(void *)(a1 + 8) = v9 + 1;
      *uint64_t v9 = HIBYTE(v8);
      v8 <<= 8;
      ++*(_DWORD *)(a1 + 16);
      --v3;
    }
    while (v3);
    int v10 = *(_DWORD *)(a1 + 64);
    if (v10)
    {
      uint64_t result = 0;
      *(_DWORD *)(a1 + 20) = v10 + *(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 8);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t aj_ostream_write_buf(uint64_t a1, char *__src, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a3;
  int v6 = *(_DWORD *)(a1 + 4);
  if (v6)
  {
    uint64_t result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v6, 8 - v6);
    if (result) {
      return result;
    }
  }
  int v8 = *(_DWORD *)(a1 + 20);
  if (v8 <= (int)v3)
  {
    int v10 = *(_DWORD *)(a1 + 64);
    if (!v10) {
      goto LABEL_12;
    }
LABEL_9:
    if (v8 != v10)
    {
      LODWORD(result) = (*(uint64_t (**)(void, void, void))(a1 + 40))(*(void *)(a1 + 24), *(_DWORD *)(a1 + 8) - *(void *)(a1 + 24), *(void *)(a1 + 32));
      if (result)
      {
LABEL_14:
        aj_log_error(0, "Output callback returned error code %d.", result);
        return 9;
      }
      *(void *)(a1 + 8) = *(void *)(a1 + 24);
      *(_DWORD *)(a1 + 20) = *(_DWORD *)(a1 + 64);
    }
    goto LABEL_12;
  }
  memcpy(*(void **)(a1 + 8), __src, (int)v3);
  uint64_t v9 = *(void *)(a1 + 8) + (int)v3;
  *(void *)(a1 + 8) = v9;
  __src += (int)v3;
  int v10 = *(_DWORD *)(a1 + 64);
  int v8 = v10 + *(_DWORD *)(a1 + 24) - v9;
  *(_DWORD *)(a1 + 16) += v3;
  *(_DWORD *)(a1 + 20) = v8;
  uint64_t v3 = 0;
  if (v10) {
    goto LABEL_9;
  }
LABEL_12:
  if (!v3) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(char *, uint64_t, void))(a1 + 40))(__src, v3, *(void *)(a1 + 32));
  if (result) {
    goto LABEL_14;
  }
  *(_DWORD *)(a1 + 16) += v3;
  return result;
}

uint64_t aj_ostream_flush_bitreg(unsigned int *a1)
{
  unsigned int v1 = a1[1];
  if (v1) {
    return aj_ostream_write(a1, 0xFFu >> v1, 8 - v1);
  }
  else {
    return 0;
  }
}

uint64_t aj_ostream_flush_buffer(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 64)) {
    return 0;
  }
  int v2 = *(_DWORD *)(a1 + 4);
  if (!v2 || (uint64_t result = aj_ostream_write((unsigned int *)a1, 0xFFu >> v2, 8 - v2), !result))
  {
    unint64_t v4 = *(void *)(a1 + 8);
    unint64_t v5 = *(void *)(a1 + 24);
    if (v4 > v5)
    {
      uint64_t result = (*(uint64_t (**)(unint64_t, void, void))(a1 + 40))(v5, (v4 - v5), *(void *)(a1 + 32));
      if (result)
      {
        aj_log_error(0, "Output callback returned error code %d.", result);
        return 9;
      }
      else
      {
        *(void *)(a1 + 8) = *(void *)(a1 + 24);
      }
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t aj_idct_s1_16x8_bilinear(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  int16x8_t v63 = a2 + 2;
  uint64_t v66 = *v63;
  uint64_t v67 = v63[1];
  v63 += 2;
  uint64_t v68 = *v63;
  uint64_t v69 = v63[1];
  v63 += 2;
  uint64_t v70 = *v63;
  uint64_t v71 = v63[1];
  v63 += 2;
  int16x8_t v72 = vaddq_s16(v60, v59);
  int16x8_t v73 = vaddq_s16(v55, v56);
  int16x8_t v74 = vsubq_s16(v55, v56);
  int16x8_t v75 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v76 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v77 = vaddq_s16(v61, v58);
  int16x8_t v78 = vsubq_s16(v58, v61);
  int16x8_t v79 = vaddq_s16(v57, v76);
  int16x8_t v80 = vsubq_s16(v57, v76);
  int16x8_t v81 = vaddq_s16(v79, v77);
  int16x8_t v82 = vaddq_s16(v72, v75);
  int16x8_t v83 = vaddq_s16(v73, v82);
  int16x8_t v84 = vsubq_s16(v73, v82);
  int16x8_t v85 = vqrdmulhq_lane_s16(vaddq_s16(v78, v80), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v86 = vqrdmulhq_lane_s16(vsubq_s16(v79, v77), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v87 = vsubq_s16(v74, v75);
  int16x8_t v88 = vaddq_s16(v74, v75);
  int16x8_t v89 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v80, (int16x4_t)0x30FC273D5A824546, 2), v80), v85);
  int16x8_t v90 = vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 0), v85);
  int16x8_t v91 = vaddq_s16(v81, v89);
  int16x8_t v92 = vaddq_s16(v89, v86);
  int16x8_t v93 = vaddq_s16(v90, v86);
  _X3 = (void *)(v64 + a3);
  _X4 = (uint8x8_t *)(v65 + a3);
  _X5 = (uint8x8_t *)(v66 + a3);
  _X6 = (uint8x8_t *)(v67 + a3);
  _X7 = (uint8x8_t *)(v68 + a3);
  _X9 = (uint8x8_t *)(v69 + a3);
  _X10 = (uint8x8_t *)(v70 + a3);
  _X11 = (uint8x8_t *)(v71 + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v83, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v86.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v88, v92), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v75.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v87, v93), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v81.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v84, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v74.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v84, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v90.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v87, v93), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v84.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v88, v92), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v92.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v83, v91), 5uLL), (int8x8_t)0x8080808080808080);
  v91.i64[0] = 0x1000100010001;
  v91.i64[1] = 0x1000100010001;
  *_X3 = v55.i64[0];
  uint16x8_t v114 = vmull_u8(*(uint8x8_t *)v86.i8, (uint8x8_t)0x303030303030303);
  uint16x8_t v115 = vmull_u8(*(uint8x8_t *)v75.i8, (uint8x8_t)0x303030303030303);
  *_X4 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(vmull_u8(*(uint8x8_t *)v55.i8, (uint8x8_t)0x303030303030303), *(uint8x8_t *)v86.i8), v91), 2uLL);
  *_X5 = vqrshrn_n_u16(vaddw_u8(v114, *(uint8x8_t *)v55.i8), 2uLL);
  *_X6 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v114, *(uint8x8_t *)v75.i8), v91), 2uLL);
  *_X7 = vqrshrn_n_u16(vaddw_u8(v115, *(uint8x8_t *)v86.i8), 2uLL);
  uint64_t v116 = *v63;
  uint64_t v117 = v63[1];
  v63 += 2;
  uint64_t v118 = *v63;
  uint64_t v119 = v63[1];
  v63 += 2;
  uint16x8_t v120 = vmull_u8(*(uint8x8_t *)v81.i8, (uint8x8_t)0x303030303030303);
  uint16x8_t v121 = vmull_u8(*(uint8x8_t *)v74.i8, (uint8x8_t)0x303030303030303);
  *_X9 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v115, *(uint8x8_t *)v81.i8), v91), 2uLL);
  *_X10 = vqrshrn_n_u16(vaddw_u8(v120, *(uint8x8_t *)v75.i8), 2uLL);
  *_X11 = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v120, *(uint8x8_t *)v74.i8), v91), 2uLL);
  *(uint8x8_t *)(v116 + a3) = vqrshrn_n_u16(vaddw_u8(v121, *(uint8x8_t *)v81.i8), 2uLL);
  uint64_t v122 = *v63;
  uint64_t v123 = v63[1];
  v63 += 2;
  uint64_t v124 = *v63;
  uint64_t v125 = v63[1];
  uint16x8_t v126 = vmull_u8(*(uint8x8_t *)v90.i8, (uint8x8_t)0x303030303030303);
  uint16x8_t v127 = vmull_u8(*(uint8x8_t *)v84.i8, (uint8x8_t)0x303030303030303);
  *(uint8x8_t *)(v117 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v121, *(uint8x8_t *)v90.i8), v91), 2uLL);
  *(uint8x8_t *)(v118 + a3) = vqrshrn_n_u16(vaddw_u8(v126, *(uint8x8_t *)v74.i8), 2uLL);
  *(uint8x8_t *)(v119 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v126, *(uint8x8_t *)v84.i8), v91), 2uLL);
  *(uint8x8_t *)(v122 + a3) = vqrshrn_n_u16(vaddw_u8(v127, *(uint8x8_t *)v90.i8), 2uLL);
  *(uint8x8_t *)(v123 + a3) = vqshrn_n_u16((uint16x8_t)vaddq_s16((int16x8_t)vaddw_u8(v127, *(uint8x8_t *)v92.i8), v91), 2uLL);
  *(uint8x8_t *)(v124 + a3) = vqrshrn_n_u16(vaddw_u8(vmull_u8(*(uint8x8_t *)v92.i8, (uint8x8_t)0x303030303030303), *(uint8x8_t *)v84.i8), 2uLL);
  *(void *)(v125 + a3) = v92.i64[0];
  return 8;
}

uint64_t aj_idct_s1_8x4(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  int16x8_t v63 = a2 + 2;
  uint64_t v66 = *v63;
  uint64_t v67 = v63[1];
  v63 += 2;
  uint64_t v68 = *v63;
  uint64_t v69 = v63[1];
  v63 += 2;
  int16x8_t v70 = vaddq_s16(v60, v59);
  int16x8_t v71 = vaddq_s16(v55, v56);
  int16x8_t v72 = vsubq_s16(v55, v56);
  int16x8_t v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v74 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v75 = vaddq_s16(v61, v58);
  int16x8_t v76 = vsubq_s16(v58, v61);
  int16x8_t v77 = vaddq_s16(v57, v74);
  int16x8_t v78 = vsubq_s16(v57, v74);
  int16x8_t v79 = vaddq_s16(v77, v75);
  int16x8_t v80 = vaddq_s16(v70, v73);
  int16x8_t v81 = vaddq_s16(v71, v80);
  int16x8_t v82 = vsubq_s16(v71, v80);
  int16x8_t v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v85 = vsubq_s16(v72, v73);
  int16x8_t v86 = vaddq_s16(v72, v73);
  int16x8_t v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  int16x8_t v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  int16x8_t v89 = vaddq_s16(v79, v87);
  int16x8_t v90 = vaddq_s16(v87, v84);
  int16x8_t v91 = vaddq_s16(v88, v84);
  _X3 = (_DWORD *)(v64 + a3);
  _X4 = (_DWORD *)(v65 + a3);
  _X5 = (_DWORD *)(v66 + a3);
  _X6 = (_DWORD *)(v67 + a3);
  _X7 = (_DWORD *)(v68 + a3);
  _X9 = (_DWORD *)(v69 + a3);
  _X10 = (_DWORD *)(*v63 + a3);
  _X11 = (_DWORD *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v84.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v73.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v79.i8 = vadd_s8(vqrshrn_n_s16(vaddq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v72.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v82, v88), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v88.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v85, v91), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v82.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v86, v90), 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v90.i8 = vadd_s8(vqrshrn_n_s16(vsubq_s16(v81, v89), 5uLL), (int8x8_t)0x8080808080808080);
  *(uint8x8_t *)v55.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v84.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v55.i8, *(int8x8_t *)v84.i8));
  *(uint8x8_t *)v84.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v73.i8, *(int8x8_t *)v79.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v73.i8, *(int8x8_t *)v79.i8));
  *(uint8x8_t *)v73.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v72.i8, *(int8x8_t *)v88.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v72.i8, *(int8x8_t *)v88.i8));
  *(uint8x8_t *)v79.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v82.i8, *(int8x8_t *)v90.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v82.i8, *(int8x8_t *)v90.i8));
  *_X3 = v55.i32[0];
  *_X4 = v55.i32[1];
  *_X5 = v84.i32[0];
  *_X6 = v84.i32[1];
  *_X7 = v73.i32[0];
  *_X9 = v73.i32[1];
  *_X10 = v79.i32[0];
  *_X11 = v79.i32[1];
  return 4;
}

uint64_t huffman_gen(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (*(int *)(a1 + 20) >= 1)
  {
    uint64_t v1 = 0;
    do
    {
      int v2 = 0;
      int16x8_t v3 = (unsigned int *)(a1 + 68 * v1 + 148);
      v27[0] = 0;
      v27[1] = 0;
      int16x8_t v4 = &v28;
      do
      {
        unsigned int v5 = *v3;
        *((_DWORD *)v4 + 6) = v2;
        *((_DWORD *)v4 + 7) = v5;
        *((void *)v4 + 2) = v5;
        *((void *)v4 + 1) = 0;
        int16x8_t v6 = (char *)v27;
        while (1)
        {
          int16x8_t v7 = (char **)v6;
          int16x8_t v6 = *(char **)v6;
          if (!v6) {
            break;
          }
          if ((signed int)v5 <= *((_DWORD *)v6 + 7))
          {
            *(void *)int16x8_t v4 = v6;
            *int16x8_t v7 = v4;
            goto LABEL_9;
          }
        }
        *int16x8_t v7 = v4;
        *(void *)int16x8_t v4 = 0;
LABEL_9:
        ++v2;
        v4 += 32;
        ++v3;
      }
      while (v2 != 17);
      int v8 = 0;
      *(_DWORD *)(v27[0] + 20) = 1;
      do
      {
        uint64_t v9 = v27[0];
        uint64_t v10 = *(void *)v27[0];
        uint64_t v11 = *(void *)(*(void *)v27[0] + 8);
        v27[0] = **(void **)v27[0];
        int v12 = *(_DWORD *)(v10 + 28) + *(_DWORD *)(v9 + 28);
        *(_DWORD *)(v10 + 28) = v12;
        ++*(_DWORD *)(v10 + 20);
        for (i = v10; v11; uint64_t v11 = *(void *)(v11 + 8))
        {
          uint64_t i = v11;
          ++*(_DWORD *)(v11 + 20);
        }
        *(void *)(i + 8) = v9;
        *(void *)uint64_t v9 = 0;
        do
        {
          ++*(_DWORD *)(v9 + 20);
          uint64_t v9 = *(void *)(v9 + 8);
        }
        while (v9);
        int16x8_t v14 = v27;
        while (1)
        {
          int16x8_t v15 = v14;
          int16x8_t v14 = (void *)*v14;
          if (!v14) {
            break;
          }
          if (v12 <= *((_DWORD *)v14 + 7))
          {
            *(void *)uint64_t v10 = v14;
            *int16x8_t v15 = v10;
            goto LABEL_20;
          }
        }
        *int16x8_t v15 = v10;
        *(void *)uint64_t v10 = 0;
LABEL_20:
        ++v8;
      }
      while (v8 != 16);
      uint64_t v16 = a1 + 16 * v1 + 48;
      for (uint64_t j = v27[0]; j; uint64_t j = *(void *)(j + 8))
      {
        if (*(_DWORD *)(j + 16))
        {
          uint64_t v18 = *(int *)(j + 20);
          if ((int)v18 <= 16) {
            ++*(unsigned char *)(v18 + v16 - 1);
          }
        }
      }
      uint64_t v19 = 0;
      int16x8_t v20 = (unsigned char *)(a1 + 17 * v1 + 96);
      do
      {
        uint64_t v21 = v27[0];
        uint64_t v22 = v19 + 1;
        if (*(unsigned char *)(v16 + v19)) {
          BOOL v23 = v27[0] == 0;
        }
        else {
          BOOL v23 = 1;
        }
        if (!v23)
        {
          int v24 = 0;
          int16x8_t v25 = v27;
          do
          {
            if (v22 == *(_DWORD *)(v21 + 20))
            {
              *v20++ = *(_DWORD *)(v21 + 24);
              v25[1] = *(void *)(v21 + 8);
              if (*(unsigned __int8 *)(v16 + v19) == ++v24) {
                break;
              }
            }
            int16x8_t v25 = (void *)v21;
            uint64_t v21 = *(void *)(v21 + 8);
          }
          while (v21);
        }
        ++v19;
      }
      while (v22 != 16);
      ++v1;
    }
    while (v1 < *(int *)(a1 + 20));
  }
  return 0;
}

uint64_t do_encode_lossless(uint64_t a1)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  uint64_t v2 = a1 + 20184;
  int v4 = *(_DWORD *)(a1 + 56);
  int v3 = *(_DWORD *)(a1 + 60);
  int v5 = *(_DWORD *)(a1 + 13408);
  uint64_t v65 = *(void *)(a1 + 19816);
  int v6 = *(_DWORD *)(a1 + 13492);
  int v7 = *(_DWORD *)(a1 + 20184);
  int v8 = *(_DWORD *)(a1 + 20188);
  uint64_t v9 = a1 + 22360;
  int16x8_t v75 = 0;
  int16x8_t v76 = 0;
  bzero(&v67, 0x228uLL);
  uint64_t v66 = v9;
  *(_DWORD *)&v70[8] = 4;
  int v71 = v4;
  uint64_t v10 = 1;
  if (!(!v16 & v11))
  {
    switch(v5)
    {
      case 0:
        long long v67 = xmmword_21040F570;
        int v69 = 0;
        if (v6 != 3) {
          return v10;
        }
        goto LABEL_16;
      case 1:
      case 2:
        return v10;
      case 3:
        long long v67 = xmmword_21040F560;
        int v69 = 0;
        *(_DWORD *)&v70[4] = 0x7FFFFFFF;
        goto LABEL_15;
      case 4:
        long long v67 = xmmword_21040F560;
        int v68 = 2;
        *(void *)int16x8_t v70 = 0x7FFFFFFFFFFFFFFELL;
LABEL_15:
        if (v6 != 4) {
          return v10;
        }
LABEL_16:
        int v63 = v3;
        BOOL v12 = 0;
        char v15 = 0;
        int v14 = 8;
        goto LABEL_23;
      case 5:
        long long v67 = xmmword_21040F590;
        *(_DWORD *)&v70[8] = 7;
        if (v6 != 1) {
          return v10;
        }
        int v63 = v3;
        BOOL v12 = 0;
        int v13 = 0;
        int v14 = 8;
        goto LABEL_11;
      default:
        JUMPOUT(0);
    }
  }
  switch(v5)
  {
    case 16:
      long long v67 = xmmword_21040F540;
      int v69 = 0;
      BOOL v12 = (v4 & 7) == 0;
      *(void *)&v70[4] = 0x77FFFFFFFLL;
      if (v6 == 8)
      {
        int v63 = v3;
        int v13 = 0;
        int v14 = 16;
LABEL_11:
        char v15 = 1;
        if (v7) {
          goto LABEL_24;
        }
        goto LABEL_26;
      }
      return v10;
    case 17:
      long long v67 = xmmword_21040F540;
      int v68 = 2;
      *(void *)int16x8_t v70 = 0x7FFFFFFFFFFFFFFELL;
      if (v6 == 8) {
        goto LABEL_22;
      }
      return v10;
    case 18:
      long long v67 = xmmword_21040F580;
      if (v6 == 2) {
        goto LABEL_22;
      }
      return v10;
    case 20:
      long long v67 = xmmword_21040F550;
      int v69 = 0;
      if (v6 != 6) {
        return v10;
      }
LABEL_22:
      int v63 = v3;
      BOOL v12 = 0;
      char v15 = 0;
      int v14 = 16;
LABEL_23:
      int v13 = 1;
      if (!v7) {
        goto LABEL_26;
      }
LABEL_24:
      if (v7 > v14) {
        return v10;
      }
      DWORD1(v67) = v7;
LABEL_26:
      uint64_t v64 = 0;
      BOOL v16 = v6 != 1 || v8 == 0;
      if (v16) {
        int v17 = v8;
      }
      else {
        int v17 = 0;
      }
      if (v12) {
        int v18 = v13;
      }
      else {
        int v18 = 1;
      }
      int v62 = v17;
      if (v17)
      {
        uint64_t v19 = v65;
        if (v18)
        {
          int v20 = v13;
          uint64_t v21 = (char *)(*(uint64_t (**)(uint64_t, void))a1)(2 * v65, *(void *)(a1 + 16));
          int16x8_t v75 = v21;
          if (!v21)
          {
            aj_log_error(0, "Could not allocate memory for LLJPEG buffer");
            return 6;
          }
          uint64_t v22 = v21;
          bzero(v21, 2 * v65);
          uint64_t v64 = v22;
          int16x8_t v76 = &v22[v65];
          int v13 = v20;
        }
        if (v13)
        {
LABEL_40:
          if (v15) {
            goto LABEL_63;
          }
LABEL_49:
          if (v67 != 2)
          {
            v72[0] = (uint8x16_t)g_huff8_n;
            char v74 = 16;
            long long v73 = g_huff8_v;
            goto LABEL_63;
          }
          if (SDWORD1(v67) > 11)
          {
            if (DWORD1(v67) == 12)
            {
              v72[0] = (uint8x16_t)g_huff16_n_12;
              char v74 = 16;
              long long v73 = g_huff16_v_12;
LABEL_59:
              uint64_t v27 = 0;
              int v28 = 0;
              int v29 = DWORD1(v67) + 2;
              do
              {
                int v30 = v72[0].u8[v27];
                v28 += v30;
                if (v28 - v29 >= 1)
                {
                  v72[0].i8[v27] = v30 - (v28 - v29);
                  int v28 = v29;
                }
                ++v27;
              }
              while (v27 != 16);
              goto LABEL_63;
            }
            v72[0] = (uint8x16_t)g_huff16_n;
            int16x8_t v26 = &g_huff16_v;
          }
          else
          {
            v72[0].i64[0] = 0x101010101010101;
            v72[0].i64[1] = 0x101010101010101;
            int16x8_t v26 = &g_huff8_v;
          }
          long long v73 = *v26;
          char v74 = *((unsigned char *)v26 + 16);
          if (!DWORD1(v67) || SDWORD1(v67) >= 16) {
            goto LABEL_63;
          }
          if (SDWORD1(v67) < 9)
          {
LABEL_80:
            uint64_t v10 = 1;
            goto LABEL_128;
          }
          goto LABEL_59;
        }
      }
      else
      {
        uint64_t v19 = v65;
        if (v13) {
          goto LABEL_40;
        }
      }
      int v23 = v13;
      int v24 = *(uint16x8_t **)(a1 + 22264);
      if (v12) {
        uint64_t v25 = do_compress_lossless_neon(v24, &v66, v63, v19, v62, 1);
      }
      else {
        uint64_t v25 = do_compress_lossless((uint64_t)v24, (uint64_t)&v66, (uint64_t)&v75, v63, v4, v19, v62, 0, 1);
      }
      uint64_t v10 = v25;
      if (v25) {
        goto LABEL_128;
      }
      huffman_gen((uint64_t)&v66);
      int v13 = v23;
      if ((v15 & 1) == 0) {
        goto LABEL_49;
      }
LABEL_63:
      unint64_t v31 = HIDWORD(v67);
      if (SHIDWORD(v67) >= 1)
      {
        unint64_t v32 = 0;
        int16x8_t v33 = (_OWORD *)v72;
        BOOL v34 = 1;
        while (1)
        {
          uint8x16_t v35 = v72[v32];
          uint16x8_t v36 = vmovl_high_u8(v35);
          uint16x8_t v37 = vmovl_u8(*(uint8x8_t *)v35.i8);
          int v38 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v37.i8, *(uint16x4_t *)v36.i8), (int32x4_t)vaddl_high_u16(v37, v36)));
          if (v38) {
            break;
          }
LABEL_77:
          ++v32;
          ++v33;
          BOOL v34 = v32 < v31;
          if (v32 == v31) {
            goto LABEL_81;
          }
        }
        uint64_t v39 = 0;
        LODWORD(v40) = 0;
        int v41 = 0;
        int v42 = 0;
        while (v39 < (int)v40)
        {
LABEL_74:
          if (v41 >= ~(-1 << v42)) {
            goto LABEL_79;
          }
          int64x2_t v47 = (char *)&v66 + 68 * v32 + 4 * *((unsigned __int8 *)&v66 + 17 * v32 + v39 + 96);
          if (*((_WORD *)v47 + 176)) {
            goto LABEL_79;
          }
          int64x2_t v48 = v47 + 352;
          *int64x2_t v48 = v42;
          v48[1] = v41;
          ++v39;
          ++v41;
          if (v39 == v38) {
            goto LABEL_77;
          }
        }
        uint64_t v43 = v42 <= 17 ? 17 : v42;
        int32x4_t v44 = (unsigned __int8 *)v33 + v42;
        uint64_t v45 = v43 - v42;
        while (v45)
        {
          unsigned int v46 = *v44++;
          uint64_t v40 = v46 + (uint64_t)(int)v40;
          v41 *= 2;
          ++v42;
          --v45;
          if (v39 < v40) {
            goto LABEL_74;
          }
        }
LABEL_79:
        if (v34) {
          goto LABEL_80;
        }
      }
LABEL_81:
      char v49 = v18;
      int v50 = v13;
      uint64_t v10 = aj_ostream_write_bytes(v9, 65496, 2);
      if (!v10)
      {
        uint64_t v10 = aj_ostream_write_bytes(v9, 65504, 2);
        if (!v10)
        {
          uint64_t v10 = aj_ostream_write_bytes(v9, 16, 2);
          if (!v10)
          {
            uint64_t v10 = aj_ostream_write_bytes(v9, 19014, 2);
            if (!v10)
            {
              uint64_t v10 = aj_ostream_write_bytes(v9, 18758, 2);
              if (!v10)
              {
                uint64_t v10 = aj_ostream_write_bytes(v9, 0, 1);
                if (!v10)
                {
                  uint64_t v10 = aj_ostream_write_bytes(v9, 258, 2);
                  if (!v10)
                  {
                    uint64_t v10 = aj_ostream_write_bytes(v9, 1, 1);
                    if (!v10)
                    {
                      uint64_t v10 = aj_ostream_write_bytes(v9, 72, 2);
                      if (!v10)
                      {
                        uint64_t v10 = aj_ostream_write_bytes(v9, 72, 2);
                        if (!v10)
                        {
                          uint64_t v10 = aj_ostream_write_bytes(v9, 0, 2);
                          if (!v10)
                          {
                            uint64_t v10 = aj_ostream_write_bytes(v9, 65475, 2);
                            if (!v10)
                            {
                              uint64_t v10 = aj_ostream_write_bytes(v9, 3 * HIDWORD(v67) + 8, 2);
                              if (!v10)
                              {
                                uint64_t v10 = aj_ostream_write_bytes(v9, SDWORD1(v67), 1);
                                if (!v10)
                                {
                                  uint64_t v10 = aj_ostream_write_bytes(v9, v63, 2);
                                  if (!v10)
                                  {
                                    uint64_t v10 = aj_ostream_write_bytes(v9, v4, 2);
                                    if (!v10)
                                    {
                                      uint64_t v10 = aj_ostream_write_bytes(v9, SHIDWORD(v67), 1);
                                      if (!v10)
                                      {
                                        if (SHIDWORD(v67) >= 1)
                                        {
                                          int v51 = 0;
                                          do
                                          {
                                            uint64_t v52 = aj_ostream_write_bytes(v9, v51, 1);
                                            if (v52) {
                                              goto LABEL_127;
                                            }
                                            uint64_t v52 = aj_ostream_write_bytes(v9, 17, 1);
                                            if (v52) {
                                              goto LABEL_127;
                                            }
                                            uint64_t v52 = aj_ostream_write_bytes(v9, 0, 1);
                                            if (v52) {
                                              goto LABEL_127;
                                            }
                                          }
                                          while (++v51 < SHIDWORD(v67));
                                        }
                                        uint64_t v53 = encodeWriteHuffTable(&v66, 0);
                                        if (SHIDWORD(v67) < 2) {
                                          char v54 = 1;
                                        }
                                        else {
                                          char v54 = v50;
                                        }
                                        if ((v54 & 1) == 0)
                                        {
                                          int v55 = 1;
                                          do
                                            uint64_t v53 = encodeWriteHuffTable(&v66, v55++);
                                          while (v55 < SHIDWORD(v67));
                                        }
                                        uint64_t v10 = v53;
                                        if (!v53)
                                        {
                                          uint64_t v10 = aj_ostream_write_bytes(v9, 65498, 2);
                                          if (!v10)
                                          {
                                            uint64_t v10 = aj_ostream_write_bytes(v9, 2 * HIDWORD(v67) + 6, 2);
                                            if (!v10)
                                            {
                                              uint64_t v10 = aj_ostream_write_bytes(v9, SHIDWORD(v67), 1);
                                              if (!v10)
                                              {
                                                if (SHIDWORD(v67) >= 1)
                                                {
                                                  int v56 = 0;
                                                  int v57 = 0;
                                                  while (1)
                                                  {
                                                    uint64_t v52 = aj_ostream_write_bytes(v9, v57, 1);
                                                    if (v52) {
                                                      break;
                                                    }
                                                    int v58 = v50 ? 0 : v56;
                                                    uint64_t v52 = aj_ostream_write_bytes(v9, v58, 1);
                                                    if (v52) {
                                                      break;
                                                    }
                                                    ++v57;
                                                    v56 += 16;
                                                    if (v57 >= SHIDWORD(v67)) {
                                                      goto LABEL_122;
                                                    }
                                                  }
LABEL_127:
                                                  uint64_t v10 = v52;
                                                  goto LABEL_128;
                                                }
LABEL_122:
                                                uint64_t v10 = aj_ostream_write_bytes(v9, *(int *)&v70[8], 1);
                                                if (!v10)
                                                {
                                                  uint64_t v10 = aj_ostream_write_bytes(v9, 0, 1);
                                                  if (!v10)
                                                  {
                                                    uint64_t v10 = aj_ostream_write_bytes(v9, 0, 1);
                                                    if (!v10)
                                                    {
                                                      int16x8_t v59 = *(uint16x8_t **)(a1 + 22264);
                                                      uint64_t v60 = (v49 & 1) != 0
                                                          ? do_compress_lossless((uint64_t)v59, (uint64_t)&v66, (uint64_t)&v75, v63, v4, v65, v62, v50, 0): do_compress_lossless_neon(v59, &v66, v63, v65, v62, 0);
                                                      uint64_t v10 = v60;
                                                      if (!v60)
                                                      {
                                                        uint64_t v10 = aj_ostream_write_bytes(v9, 65497, 2);
                                                        if (!v10)
                                                        {
                                                          uint64_t v10 = aj_ostream_flush_buffer(v9);
                                                          if (!v10) {
                                                            *(_DWORD *)(v2 + 2264) = *(_DWORD *)(v2 + 2192);
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
LABEL_128:
      if (v64) {
        (*(void (**)(char *, void))(a1 + 8))(v64, *(void *)(a1 + 16));
      }
      return v10;
    default:
      return v10;
  }
}

uint64_t do_compress_lossless_neon(uint16x8_t *a1, _DWORD *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  if (a3 < 1) {
    return 0;
  }
  int v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = a2 + 37;
  char v11 = a2 + 54;
  BOOL v12 = a2 + 71;
  int v13 = a2 + 88;
  int v14 = a2 + 105;
  uint16x8_t v15 = (uint16x8_t)vdupq_n_s16(-a5);
  BOOL v16 = a2 + 122;
  v17.i64[0] = 0x10001000100010;
  v17.i64[1] = 0x10001000100010;
  v18.i64[0] = 0x1000100010001;
  v18.i64[1] = 0x1000100010001;
  v19.i64[0] = -1;
  v19.i64[1] = -1;
  int v20 = (int32x2_t *)&unk_21040F000;
  uint64_t v21 = (int32x2_t *)&unk_21040F000;
  v213 = a2 + 105;
  uint16x8_t v212 = v15;
  v210 = a2 + 88;
  v211 = a2 + 122;
  while (1)
  {
    int v208 = v8;
    if (v9)
    {
      uint64_t v22 = v9 + 5;
      int8x16_t v23 = (int8x16_t)vshlq_u16(*v9, v15);
      int8x16_t v24 = (int8x16_t)vshlq_u16(v9[1], v15);
      int8x16_t v25 = (int8x16_t)vshlq_u16(v9[2], v15);
      int8x16_t v26 = (int8x16_t)vshlq_u16(v9[3], v15);
      int8x16_t v27 = (int8x16_t)vshlq_u16(v9[4], v15);
      v6.i64[0] = v23.i64[0];
    }
    else
    {
      uint64_t v22 = 0;
      *(int16x4_t *)v6.i8 = vdup_n_s16(1 << (a2[3] - 1));
      int8x16_t v26 = 0uLL;
      int8x16_t v25 = 0uLL;
      int8x16_t v24 = 0uLL;
      int8x16_t v23 = 0uLL;
      int8x16_t v27 = 0uLL;
    }
    uint64_t v28 = *(void *)a2;
    int v29 = *(_DWORD *)(*(void *)a2 + 4);
    unint64_t v30 = (unint64_t)**(unsigned int **)a2 << 32;
    unint64_t v31 = *(unsigned char **)(*(void *)a2 + 8);
    __int32 v33 = *(_DWORD *)(*(void *)a2 + 16);
    int v32 = *(_DWORD *)(*(void *)a2 + 20);
    if ((int)a2[11] >= 8) {
      break;
    }
LABEL_308:
    *(_DWORD *)uint64_t v28 = HIDWORD(v30);
    *(_DWORD *)(v28 + 4) = v29;
    *(void *)(v28 + 8) = v31;
    uint64_t v9 = a1;
    int v8 = v208 + 1;
    a1 = (uint16x8_t *)((char *)a1 + a4);
    *(_DWORD *)(v28 + 16) = v33;
    *(_DWORD *)(v28 + 20) = v32;
    if (v208 + 1 == a3) {
      return 0;
    }
  }
  int v34 = 0;
  int v35 = a2[10];
  uint16x8_t v36 = a1 + 4;
  int8x16_t v37 = (int8x16_t)vshlq_u16(*a1, v15);
  int8x16_t v38 = (int8x16_t)vshlq_u16(a1[1], v15);
  int8x16_t v39 = (int8x16_t)vshlq_u16(a1[2], v15);
  int8x16_t v40 = (int8x16_t)vshlq_u16(a1[3], v15);
  v215 = v9;
  char v214 = v35;
  while (1)
  {
    if (v9)
    {
      if (v35 == 3)
      {
        v6.i64[1] = v23.i64[0];
        int16x8_t v41 = (int16x8_t)vextq_s8(v23, v24, 8uLL);
        int16x8_t v42 = (int16x8_t)vextq_s8(v24, v25, 8uLL);
        int16x8_t v43 = (int16x8_t)vextq_s8(v25, v26, 8uLL);
        int16x8_t v44 = v6;
        unint64_t v45 = vextq_s8(v26, v26, 8uLL).u64[0];
        goto LABEL_24;
      }
      if (v35 == 2)
      {
        int16x8_t v44 = (int16x8_t)v23;
        int16x8_t v41 = (int16x8_t)v24;
        int16x8_t v42 = (int16x8_t)v25;
        int16x8_t v43 = (int16x8_t)v26;
        goto LABEL_25;
      }
      if (v35 != 1)
      {
        int16x8_t v46 = (int16x8_t)vextq_s8(v23, v24, 8uLL);
        int16x8_t v47 = (int16x8_t)vextq_s8(v24, v25, 8uLL);
        int16x8_t v48 = (int16x8_t)vextq_s8(v25, v26, 8uLL);
        int16x8_t v49 = (int16x8_t)vextq_s8(v26, v27, 8uLL);
        switch(v35)
        {
          case 6u:
            int8x16_t v50 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v37, (uint16x8_t)v23), v46);
            int8x16_t v51 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v38, (uint16x8_t)v24), v47);
            int8x16_t v52 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v39, (uint16x8_t)v25), v48);
            int8x16_t v54 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v40, (uint16x8_t)v26), v49);
            break;
          case 5u:
            int16x8_t v53 = (int16x8_t)vhsubq_u16((uint16x8_t)v49, (uint16x8_t)v26);
            int8x16_t v50 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v46, (uint16x8_t)v23), (int16x8_t)v37);
            int8x16_t v51 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v47, (uint16x8_t)v24), (int16x8_t)v38);
            int8x16_t v52 = (int8x16_t)vaddq_s16((int16x8_t)vhsubq_u16((uint16x8_t)v48, (uint16x8_t)v25), (int16x8_t)v39);
LABEL_21:
            int8x16_t v54 = (int8x16_t)vaddq_s16(v53, (int16x8_t)v40);
            break;
          case 4u:
            int8x16_t v50 = (int8x16_t)vaddq_s16(vsubq_s16(v46, (int16x8_t)v23), (int16x8_t)v37);
            int8x16_t v51 = (int8x16_t)vaddq_s16(vsubq_s16(v47, (int16x8_t)v24), (int16x8_t)v38);
            int8x16_t v52 = (int8x16_t)vaddq_s16(vsubq_s16(v48, (int16x8_t)v25), (int16x8_t)v39);
            int16x8_t v53 = vsubq_s16(v49, (int16x8_t)v26);
            goto LABEL_21;
          default:
            int8x16_t v50 = (int8x16_t)vhaddq_u16((uint16x8_t)v37, (uint16x8_t)v46);
            int8x16_t v51 = (int8x16_t)vhaddq_u16((uint16x8_t)v38, (uint16x8_t)v47);
            int8x16_t v52 = (int8x16_t)vhaddq_u16((uint16x8_t)v39, (uint16x8_t)v48);
            int8x16_t v54 = (int8x16_t)vhaddq_u16((uint16x8_t)v40, (uint16x8_t)v49);
            break;
        }
        v6.i64[1] = v50.i64[0];
        int16x8_t v41 = (int16x8_t)vextq_s8(v50, v51, 8uLL);
        int16x8_t v42 = (int16x8_t)vextq_s8(v51, v52, 8uLL);
        int16x8_t v43 = (int16x8_t)vextq_s8(v52, v54, 8uLL);
        int16x8_t v44 = v6;
        unint64_t v45 = vextq_s8(v54, v54, 8uLL).u64[0];
        goto LABEL_24;
      }
    }
    v6.i64[1] = v37.i64[0];
    int16x8_t v41 = (int16x8_t)vextq_s8(v37, v38, 8uLL);
    int16x8_t v42 = (int16x8_t)vextq_s8(v38, v39, 8uLL);
    int16x8_t v43 = (int16x8_t)vextq_s8(v39, v40, 8uLL);
    int16x8_t v44 = v6;
    unint64_t v45 = vextq_s8(v40, v40, 8uLL).u64[0];
LABEL_24:
    v6.i64[0] = v45;
LABEL_25:
    int16x8_t v55 = vsubq_s16((int16x8_t)v37, v44);
    int16x8_t v56 = vsubq_s16((int16x8_t)v38, v41);
    int16x8_t v57 = vsubq_s16((int16x8_t)v39, v42);
    int16x8_t v58 = vsubq_s16((int16x8_t)v40, v43);
    uint16x8_t v59 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v55)));
    uint16x8_t v60 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v56)));
    uint16x8_t v61 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v57)));
    uint16x8_t v62 = (uint16x8_t)vsubq_s16(v17, vclzq_s16(vabsq_s16(v58)));
    if (!a6) {
      break;
    }
    ++v10[v59.i16[0]];
    ++v11[v59.i16[1]];
    ++v12[v59.i16[2]];
    ++v10[v59.i16[4]];
    ++v11[v59.i16[5]];
    ++v12[v59.i16[6]];
    ++v10[v60.i16[0]];
    ++v11[v60.i16[1]];
    ++v12[v60.i16[2]];
    ++v10[v60.i16[4]];
    ++v11[v60.i16[5]];
    ++v12[v60.i16[6]];
    ++v10[v61.i16[0]];
    ++v11[v61.i16[1]];
    ++v12[v61.i16[2]];
    ++v10[v61.i16[4]];
    ++v11[v61.i16[5]];
    ++v12[v61.i16[6]];
    ++v10[v62.i16[0]];
    v63.i64[0] = v62.u16[1];
    v63.i64[1] = v62.u16[5];
    int64x2_t v64 = vshrq_n_s64(vshlq_n_s64(v63, 0x30uLL), 0x30uLL);
    uint64_t v65 = v64.i64[1];
    ++v11[v64.i64[0]];
    v63.i64[0] = v62.u16[2];
    v63.i64[1] = v62.u16[6];
    int64x2_t v66 = vshrq_n_s64(vshlq_n_s64(v63, 0x30uLL), 0x30uLL);
    ++v12[v66.i64[0]];
    ++v10[v62.i16[4]];
    ++v11[v65];
    ++v12[v66.i64[1]];
LABEL_300:
    int v198 = a2[11] / 8;
    if (v34 < v198 - 1)
    {
      if (v9)
      {
        if (v34 >= v198 - 2)
        {
          v200 = v22 + 3;
          uint16x8_t v199 = (uint16x8_t)v27;
        }
        else
        {
          uint16x8_t v199 = v22[3];
          v200 = v22 + 4;
        }
        int8x16_t v24 = (int8x16_t)vshlq_u16(*v22, v15);
        int8x16_t v25 = (int8x16_t)vshlq_u16(v22[1], v15);
        int8x16_t v26 = (int8x16_t)vshlq_u16(v22[2], v15);
        int8x16_t v23 = v27;
        int8x16_t v27 = (int8x16_t)vshlq_u16(v199, v15);
        uint64_t v22 = v200;
      }
      uint16x8_t v201 = *v36;
      uint16x8_t v202 = v36[1];
      uint16x8_t v203 = v36[2];
      uint16x8_t v204 = v36[3];
      v36 += 4;
      int8x16_t v37 = (int8x16_t)vshlq_u16(v201, v15);
      int8x16_t v38 = (int8x16_t)vshlq_u16(v202, v15);
      int8x16_t v39 = (int8x16_t)vshlq_u16(v203, v15);
      int8x16_t v40 = (int8x16_t)vshlq_u16(v204, v15);
    }
    if (++v34 >= v198) {
      goto LABEL_308;
    }
  }
  if (v32 > 95)
  {
LABEL_30:
    int8x16_t v70 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v59), v19), (int8x16_t)vsraq_n_s16(v55, v55, 0xFuLL));
    int v71 = (unsigned __int16 *)&v13[v59.i16[0]];
    int v72 = v29 + *v71;
    unint64_t v73 = ((unint64_t)v71[1] << -(char)(v29 + *v71)) | v30;
    LODWORD(v71) = (unsigned __int16)(v59.i16[0] - 1);
    BOOL v74 = v71 > 0xE;
    if (v71 <= 0xE) {
      int v75 = v72 + v59.u16[0];
    }
    else {
      int v75 = v72;
    }
    if (v74) {
      unint64_t v76 = v73;
    }
    else {
      unint64_t v76 = v73 | ((unint64_t)v70.u16[0] << -(char)(v72 + v59.i8[0]));
    }
    int32x2_t v77 = (int32x2_t)__PAIR64__(v32, v33);
    if (v75 < 8)
    {
      int v78 = v75;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v76);
        if (HIBYTE(v76) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v76 <<= 8;
        int v78 = v75 - 8;
        BOOL v74 = v75 <= 15;
        v75 -= 8;
      }
      while (!v74);
    }
    int16x8_t v79 = (unsigned __int16 *)&v14[v59.i16[1]];
    int v80 = v78 + *v79;
    unint64_t v81 = ((unint64_t)v79[1] << -(char)v80) | v76;
    int v82 = v80 + v59.u16[1];
    if ((unsigned __int16)(v59.i16[1] - 1) <= 0xEu) {
      v81 |= (unint64_t)v70.u16[1] << -(char)(v80 + v59.i8[2]);
    }
    else {
      int v82 = v80;
    }
    if (v82 < 8)
    {
      int v83 = v82;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v81);
        if (HIBYTE(v81) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v81 <<= 8;
        int v83 = v82 - 8;
        BOOL v74 = v82 <= 15;
        v82 -= 8;
      }
      while (!v74);
    }
    int16x8_t v84 = (unsigned __int16 *)&v16[v59.i16[2]];
    int v85 = v83 + *v84;
    unint64_t v86 = ((unint64_t)v84[1] << -(char)v85) | v81;
    int v87 = v85 + v59.u16[2];
    if ((unsigned __int16)(v59.i16[2] - 1) <= 0xEu) {
      v86 |= (unint64_t)v70.u16[2] << -(char)(v85 + v59.i8[4]);
    }
    else {
      int v87 = v85;
    }
    if (v87 < 8)
    {
      int v88 = v87;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v86);
        if (HIBYTE(v86) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v86 <<= 8;
        int v88 = v87 - 8;
        BOOL v74 = v87 <= 15;
        v87 -= 8;
      }
      while (!v74);
    }
    int16x8_t v89 = (unsigned __int16 *)&v13[v59.i16[4]];
    int v90 = v88 + *v89;
    unint64_t v91 = ((unint64_t)v89[1] << -(char)v90) | v86;
    int v92 = v90 + v59.u16[4];
    if ((unsigned __int16)(v59.i16[4] - 1) <= 0xEu) {
      v91 |= (unint64_t)v70.u16[4] << -(char)(v90 + v59.i8[8]);
    }
    else {
      int v92 = v90;
    }
    if (v92 < 8)
    {
      int v93 = v92;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v91);
        if (HIBYTE(v91) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v91 <<= 8;
        int v93 = v92 - 8;
        BOOL v74 = v92 <= 15;
        v92 -= 8;
      }
      while (!v74);
    }
    uint64_t v94 = (unsigned __int16 *)&v14[v59.i16[5]];
    int v95 = v93 + *v94;
    unint64_t v96 = ((unint64_t)v94[1] << -(char)v95) | v91;
    int v97 = v95 + v59.u16[5];
    if ((unsigned __int16)(v59.i16[5] - 1) <= 0xEu) {
      v96 |= (unint64_t)v70.u16[5] << -(char)(v95 + v59.i8[10]);
    }
    else {
      int v97 = v95;
    }
    if (v97 < 8)
    {
      int v98 = v97;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v96);
        if (HIBYTE(v96) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v96 <<= 8;
        int v98 = v97 - 8;
        BOOL v74 = v97 <= 15;
        v97 -= 8;
      }
      while (!v74);
    }
    uint64_t v99 = (unsigned __int16 *)&v16[v59.i16[6]];
    int v100 = v98 + *v99;
    unint64_t v101 = ((unint64_t)v99[1] << -(char)v100) | v96;
    int v102 = v100 + v59.u16[6];
    if ((unsigned __int16)(v59.i16[6] - 1) <= 0xEu) {
      v101 |= (unint64_t)v70.u16[6] << -(char)(v100 + v59.i8[12]);
    }
    else {
      int v102 = v100;
    }
    if (v102 < 8)
    {
      int v103 = v102;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v101);
        if (HIBYTE(v101) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v101 <<= 8;
        int v103 = v102 - 8;
        BOOL v74 = v102 <= 15;
        v102 -= 8;
      }
      while (!v74);
    }
    int8x16_t v104 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v60), v19), (int8x16_t)vsraq_n_s16(v56, v56, 0xFuLL));
    int v105 = (unsigned __int16 *)&v13[v60.i16[0]];
    int v106 = v103 + *v105;
    unint64_t v107 = ((unint64_t)v105[1] << -(char)v106) | v101;
    int v108 = v106 + v60.u16[0];
    if ((unsigned __int16)(v60.i16[0] - 1) <= 0xEu) {
      v107 |= (unint64_t)v104.u16[0] << -(char)(v106 + v60.i8[0]);
    }
    else {
      int v108 = v106;
    }
    if (v108 < 8)
    {
      int v109 = v108;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v107);
        if (HIBYTE(v107) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v107 <<= 8;
        int v109 = v108 - 8;
        BOOL v74 = v108 <= 15;
        v108 -= 8;
      }
      while (!v74);
    }
    uint64_t v110 = (unsigned __int16 *)&v14[v60.i16[1]];
    int v111 = v109 + *v110;
    unint64_t v112 = ((unint64_t)v110[1] << -(char)v111) | v107;
    int v113 = v111 + v60.u16[1];
    if ((unsigned __int16)(v60.i16[1] - 1) <= 0xEu) {
      v112 |= (unint64_t)v104.u16[1] << -(char)(v111 + v60.i8[2]);
    }
    else {
      int v113 = v111;
    }
    if (v113 < 8)
    {
      int v114 = v113;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v112);
        if (HIBYTE(v112) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v112 <<= 8;
        int v114 = v113 - 8;
        BOOL v74 = v113 <= 15;
        v113 -= 8;
      }
      while (!v74);
    }
    uint16x8_t v115 = (unsigned __int16 *)&v16[v60.i16[2]];
    int v116 = v114 + *v115;
    unint64_t v117 = ((unint64_t)v115[1] << -(char)v116) | v112;
    int v118 = v116 + v60.u16[2];
    if ((unsigned __int16)(v60.i16[2] - 1) <= 0xEu) {
      v117 |= (unint64_t)v104.u16[2] << -(char)(v116 + v60.i8[4]);
    }
    else {
      int v118 = v116;
    }
    if (v118 < 8)
    {
      int v119 = v118;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v117);
        if (HIBYTE(v117) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v117 <<= 8;
        int v119 = v118 - 8;
        BOOL v74 = v118 <= 15;
        v118 -= 8;
      }
      while (!v74);
    }
    uint16x8_t v120 = (unsigned __int16 *)&v13[v60.i16[4]];
    int v121 = v119 + *v120;
    unint64_t v122 = ((unint64_t)v120[1] << -(char)v121) | v117;
    int v123 = v121 + v60.u16[4];
    if ((unsigned __int16)(v60.i16[4] - 1) <= 0xEu) {
      v122 |= (unint64_t)v104.u16[4] << -(char)(v121 + v60.i8[8]);
    }
    else {
      int v123 = v121;
    }
    if (v123 < 8)
    {
      int v124 = v123;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v122);
        if (HIBYTE(v122) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          int32x2_t v77 = vadd_s32(v77, v21[182]);
        }
        else
        {
          int32x2_t v77 = vadd_s32(v77, v20[167]);
          ++v31;
        }
        v122 <<= 8;
        int v124 = v123 - 8;
        BOOL v74 = v123 <= 15;
        v123 -= 8;
      }
      while (!v74);
    }
    uint64_t v125 = (unsigned __int16 *)&v14[v60.i16[5]];
    int v126 = v124 + *v125;
    unint64_t v127 = ((unint64_t)v125[1] << -(char)v126) | v122;
    int v128 = v126 + v60.u16[5];
    if ((unsigned __int16)(v60.i16[5] - 1) <= 0xEu) {
      v127 |= (unint64_t)v104.u16[5] << -(char)(v126 + v60.i8[10]);
    }
    else {
      int v128 = v126;
    }
    __int32 v33 = v77.i32[0];
    int v32 = v77.i32[1];
    if (v128 < 8)
    {
      int v129 = v128;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v127);
        if (HIBYTE(v127) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v127 <<= 8;
        int v129 = v128 - 8;
        BOOL v74 = v128 <= 15;
        v128 -= 8;
      }
      while (!v74);
    }
    long long v130 = (unsigned __int16 *)&v16[v60.i16[6]];
    int v131 = v129 + *v130;
    unint64_t v132 = ((unint64_t)v130[1] << -(char)v131) | v127;
    int v133 = v131 + v60.u16[6];
    if ((unsigned __int16)(v60.i16[6] - 1) <= 0xEu) {
      v132 |= (unint64_t)v104.u16[6] << -(char)(v131 + v60.i8[12]);
    }
    else {
      int v133 = v131;
    }
    if (v133 < 8)
    {
      int v134 = v133;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v132);
        if (HIBYTE(v132) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v132 <<= 8;
        int v134 = v133 - 8;
        BOOL v74 = v133 <= 15;
        v133 -= 8;
      }
      while (!v74);
    }
    int8x16_t v135 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v61), v19), (int8x16_t)vsraq_n_s16(v57, v57, 0xFuLL));
    v136 = (unsigned __int16 *)&v13[v61.i16[0]];
    int v137 = v134 + *v136;
    unint64_t v138 = ((unint64_t)v136[1] << -(char)v137) | v132;
    int v139 = v137 + v61.u16[0];
    if ((unsigned __int16)(v61.i16[0] - 1) <= 0xEu) {
      v138 |= (unint64_t)v135.u16[0] << -(char)(v137 + v61.i8[0]);
    }
    else {
      int v139 = v137;
    }
    if (v139 < 8)
    {
      int v140 = v139;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v138);
        if (HIBYTE(v138) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v138 <<= 8;
        int v140 = v139 - 8;
        BOOL v74 = v139 <= 15;
        v139 -= 8;
      }
      while (!v74);
    }
    v141 = (unsigned __int16 *)&v14[v61.i16[1]];
    int v142 = v140 + *v141;
    unint64_t v143 = ((unint64_t)v141[1] << -(char)v142) | v138;
    int v144 = v142 + v61.u16[1];
    if ((unsigned __int16)(v61.i16[1] - 1) <= 0xEu) {
      v143 |= (unint64_t)v135.u16[1] << -(char)(v142 + v61.i8[2]);
    }
    else {
      int v144 = v142;
    }
    if (v144 < 8)
    {
      int v145 = v144;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v143);
        if (HIBYTE(v143) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v143 <<= 8;
        int v145 = v144 - 8;
        BOOL v74 = v144 <= 15;
        v144 -= 8;
      }
      while (!v74);
    }
    v146 = (unsigned __int16 *)&v16[v61.i16[2]];
    int v147 = v145 + *v146;
    unint64_t v148 = ((unint64_t)v146[1] << -(char)v147) | v143;
    int v149 = v147 + v61.u16[2];
    if ((unsigned __int16)(v61.i16[2] - 1) <= 0xEu) {
      v148 |= (unint64_t)v135.u16[2] << -(char)(v147 + v61.i8[4]);
    }
    else {
      int v149 = v147;
    }
    if (v149 < 8)
    {
      int v150 = v149;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v148);
        if (HIBYTE(v148) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v148 <<= 8;
        int v150 = v149 - 8;
        BOOL v74 = v149 <= 15;
        v149 -= 8;
      }
      while (!v74);
    }
    v151 = (unsigned __int16 *)&v13[v61.i16[4]];
    int v152 = v150 + *v151;
    unint64_t v153 = ((unint64_t)v151[1] << -(char)v152) | v148;
    int v154 = v152 + v61.u16[4];
    if ((unsigned __int16)(v61.i16[4] - 1) <= 0xEu) {
      v153 |= (unint64_t)v135.u16[4] << -(char)(v152 + v61.i8[8]);
    }
    else {
      int v154 = v152;
    }
    if (v154 < 8)
    {
      int v155 = v154;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v153);
        if (HIBYTE(v153) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v153 <<= 8;
        int v155 = v154 - 8;
        BOOL v74 = v154 <= 15;
        v154 -= 8;
      }
      while (!v74);
    }
    v156 = (unsigned __int16 *)&v14[v61.i16[5]];
    int v157 = v155 + *v156;
    unint64_t v158 = ((unint64_t)v156[1] << -(char)v157) | v153;
    int v159 = v157 + v61.u16[5];
    if ((unsigned __int16)(v61.i16[5] - 1) <= 0xEu) {
      v158 |= (unint64_t)v135.u16[5] << -(char)(v157 + v61.i8[10]);
    }
    else {
      int v159 = v157;
    }
    if (v159 < 8)
    {
      int v160 = v159;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v158);
        if (HIBYTE(v158) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v158 <<= 8;
        int v160 = v159 - 8;
        BOOL v74 = v159 <= 15;
        v159 -= 8;
      }
      while (!v74);
    }
    v161 = (unsigned __int16 *)&v16[v61.i16[6]];
    int v162 = v160 + *v161;
    unint64_t v163 = ((unint64_t)v161[1] << -(char)v162) | v158;
    int v164 = v162 + v61.u16[6];
    if ((unsigned __int16)(v61.i16[6] - 1) <= 0xEu) {
      v163 |= (unint64_t)v135.u16[6] << -(char)(v162 + v61.i8[12]);
    }
    else {
      int v164 = v162;
    }
    if (v164 < 8)
    {
      int v165 = v164;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v163);
        if (HIBYTE(v163) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v163 <<= 8;
        int v165 = v164 - 8;
        BOOL v74 = v164 <= 15;
        v164 -= 8;
      }
      while (!v74);
    }
    int8x16_t v166 = vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vshlq_u16(v18, v62), v19), (int8x16_t)vsraq_n_s16(v58, v58, 0xFuLL));
    v167 = (unsigned __int16 *)&v13[v62.i16[0]];
    int v168 = v165 + *v167;
    unint64_t v169 = ((unint64_t)v167[1] << -(char)v168) | v163;
    int v170 = v168 + v62.u16[0];
    if ((unsigned __int16)(v62.i16[0] - 1) <= 0xEu) {
      v169 |= (unint64_t)v166.u16[0] << -(char)(v168 + v62.i8[0]);
    }
    else {
      int v170 = v168;
    }
    if (v170 < 8)
    {
      int v171 = v170;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v169);
        if (HIBYTE(v169) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v169 <<= 8;
        int v171 = v170 - 8;
        BOOL v74 = v170 <= 15;
        v170 -= 8;
      }
      while (!v74);
    }
    v172 = (unsigned __int16 *)&v14[v62.i16[1]];
    int v173 = v171 + *v172;
    unint64_t v174 = ((unint64_t)v172[1] << -(char)v173) | v169;
    int v175 = v173 + v62.u16[1];
    if ((unsigned __int16)(v62.i16[1] - 1) <= 0xEu) {
      v174 |= (unint64_t)v166.u16[1] << -(char)(v173 + v62.i8[2]);
    }
    else {
      int v175 = v173;
    }
    if (v175 < 8)
    {
      int v176 = v175;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v174);
        if (HIBYTE(v174) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v174 <<= 8;
        int v176 = v175 - 8;
        BOOL v74 = v175 <= 15;
        v175 -= 8;
      }
      while (!v74);
    }
    v177 = (unsigned __int16 *)&v16[v62.i16[2]];
    int v178 = v176 + *v177;
    unint64_t v179 = ((unint64_t)v177[1] << -(char)v178) | v174;
    int v180 = v178 + v62.u16[2];
    if ((unsigned __int16)(v62.i16[2] - 1) <= 0xEu) {
      v179 |= (unint64_t)v166.u16[2] << -(char)(v178 + v62.i8[4]);
    }
    else {
      int v180 = v178;
    }
    if (v180 < 8)
    {
      int v181 = v180;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v179);
        if (HIBYTE(v179) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v179 <<= 8;
        int v181 = v180 - 8;
        BOOL v74 = v180 <= 15;
        v180 -= 8;
      }
      while (!v74);
    }
    v182 = (unsigned __int16 *)&v13[v62.i16[4]];
    int v183 = v181 + *v182;
    unint64_t v184 = ((unint64_t)v182[1] << -(char)v183) | v179;
    int v185 = v183 + v62.u16[4];
    if ((unsigned __int16)(v62.i16[4] - 1) <= 0xEu) {
      v184 |= (unint64_t)v166.u16[4] << -(char)(v183 + v62.i8[8]);
    }
    else {
      int v185 = v183;
    }
    if (v185 < 8)
    {
      int v186 = v185;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v184);
        if (HIBYTE(v184) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v184 <<= 8;
        int v186 = v185 - 8;
        BOOL v74 = v185 <= 15;
        v185 -= 8;
      }
      while (!v74);
    }
    v187 = (unsigned __int16 *)&v14[v62.i16[5]];
    int v188 = v186 + *v187;
    unint64_t v189 = ((unint64_t)v187[1] << -(char)v188) | v184;
    int v190 = v188 + v62.u16[5];
    if ((unsigned __int16)(v62.i16[5] - 1) <= 0xEu) {
      v189 |= (unint64_t)v166.u16[5] << -(char)(v188 + v62.i8[10]);
    }
    else {
      int v190 = v188;
    }
    if (v190 < 8)
    {
      int v191 = v190;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v189);
        if (HIBYTE(v189) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v189 <<= 8;
        int v191 = v190 - 8;
        BOOL v74 = v190 <= 15;
        v190 -= 8;
      }
      while (!v74);
    }
    v192 = (unsigned __int16 *)&v16[v62.i16[6]];
    int v193 = v191 + *v192;
    unint64_t v194 = ((unint64_t)v192[1] << -(char)v193) | v189;
    unsigned int v195 = (unsigned __int16)(v62.i16[6] - 1);
    BOOL v196 = v195 > 0xE;
    if (v195 <= 0xE) {
      int v197 = v193 + v62.u16[6];
    }
    else {
      int v197 = v193;
    }
    if (v196) {
      unint64_t v30 = v194;
    }
    else {
      unint64_t v30 = v194 | ((unint64_t)v166.u16[6] << -(char)(v193 + v62.i8[12]));
    }
    if (v197 < 8)
    {
      int v29 = v197;
    }
    else
    {
      do
      {
        *unint64_t v31 = HIBYTE(v30);
        if (HIBYTE(v30) == 255)
        {
          v31[1] = 0;
          v31 += 2;
          v33 += 2;
          v32 -= 2;
        }
        else
        {
          ++v33;
          --v32;
          ++v31;
        }
        v30 <<= 8;
        int v29 = v197 - 8;
        BOOL v74 = v197 <= 15;
        v197 -= 8;
      }
      while (!v74);
    }
    goto LABEL_300;
  }
  uint16x8_t v216 = v59;
  int16x8_t v217 = v56;
  uint16x8_t v218 = v60;
  int16x8_t v219 = v57;
  uint16x8_t v220 = v61;
  int16x8_t v221 = v58;
  uint16x8_t v222 = v62;
  int8x16_t v223 = v40;
  int8x16_t v224 = v39;
  int8x16_t v225 = v38;
  int8x16_t v226 = v37;
  v227 = v36;
  int v228 = v34;
  int8x16_t v229 = v23;
  int8x16_t v230 = v26;
  int8x16_t v231 = v25;
  int8x16_t v232 = v24;
  int16x8_t v233 = v6;
  int8x16_t v234 = v27;
  v235 = v22;
  long long v67 = v12;
  uint64_t v68 = a6;
  int v32 = *(_DWORD *)(v28 + 64);
  int v69 = (*(uint64_t (**)(void, void, void, int32x2_t *, int32x2_t *))(v28 + 40))(*(void *)(v28 + 24), v31 - *(void *)(v28 + 24), *(void *)(v28 + 32), v20, v21);
  if (!v69)
  {
    unint64_t v31 = *(unsigned char **)(v28 + 24);
    a6 = v68;
    BOOL v12 = v67;
    int v13 = v210;
    BOOL v16 = v211;
    int v14 = v213;
    uint16x8_t v15 = v212;
    v17.i64[0] = 0x10001000100010;
    v17.i64[1] = 0x10001000100010;
    v18.i64[0] = 0x1000100010001;
    v18.i64[1] = 0x1000100010001;
    v19.i64[0] = -1;
    v19.i64[1] = -1;
    int v20 = (int32x2_t *)&unk_21040F000;
    uint64_t v21 = (int32x2_t *)&unk_21040F000;
    uint64_t v9 = v215;
    uint64_t v22 = v235;
    int16x8_t v6 = v233;
    int8x16_t v27 = v234;
    int8x16_t v25 = v231;
    int8x16_t v24 = v232;
    int8x16_t v23 = v229;
    int8x16_t v26 = v230;
    int v34 = v228;
    LOBYTE(v35) = v214;
    uint16x8_t v36 = v227;
    int8x16_t v38 = v225;
    int8x16_t v37 = v226;
    int8x16_t v40 = v223;
    int8x16_t v39 = v224;
    int16x8_t v58 = v221;
    uint16x8_t v62 = v222;
    int16x8_t v57 = v219;
    uint16x8_t v61 = v220;
    int16x8_t v56 = v217;
    uint16x8_t v60 = v218;
    uint16x8_t v59 = v216;
    goto LABEL_30;
  }
  aj_log_error(0, "Output callback returned error code %d.", v69);
  return 9;
}

uint64_t do_compress_lossless(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, int a7, int a8, char a9)
{
  if (a4 >= 1)
  {
    uint64_t v10 = a1;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = a1;
    uint64_t v74 = a4;
    int v73 = a7;
    do
    {
      uint64_t v76 = v11;
      if (*(_DWORD *)(a2 + 8) == 2)
      {
        if (a7)
        {
          uint64_t v13 = *(void *)(a3 + 8 * (v11 & 1));
          if (*(_DWORD *)(a2 + 16) * a5 >= 1)
          {
            uint64_t v14 = 0;
            uint64_t v15 = 2 * (*(_DWORD *)(a2 + 16) * a5);
            do
            {
              *(_WORD *)(v13 + v14) = *(unsigned __int16 *)(v10 + v14) >> a7;
              v14 += 2;
            }
            while (v15 != v14);
          }
        }
        if (!*(_DWORD *)(a2 + 40)) {
          return 3;
        }
        if (v12) {
          int v16 = *(_DWORD *)(a2 + 40);
        }
        else {
          int v16 = 1;
        }
        int v17 = *(_DWORD *)(a2 + 44);
        int v18 = *(_DWORD *)(a2 + 16);
        if (v18 < 1)
        {
          LODWORD(v19) = 0;
          LOWORD(v20) = 0;
        }
        else
        {
          int v69 = *(_DWORD *)(a2 + 44);
          uint64_t v19 = 0;
          LOWORD(v20) = 0;
          do
          {
            int v21 = *(_DWORD *)(a2 + 4 * v19 + 24);
            if (v21 != 0x7FFFFFFF)
            {
              int v22 = v19 + v21;
              if (v12)
              {
                uint64_t v23 = v22;
                LOWORD(v20) = *(_WORD *)(v12 + 2 * v22);
              }
              else
              {
                unsigned int v20 = 1 << (*(_DWORD *)(a2 + 12) - 1);
                uint64_t v23 = v22;
              }
              int v24 = *(unsigned __int16 *)(v13 + 2 * v23);
              LOWORD(v25) = v24 - v20;
              if (a9)
              {
                unsigned int v25 = (__int16)v25;
                if ((v25 & 0x8000u) != 0) {
                  unsigned int v25 = -(__int16)v25;
                }
                uint64_t v26 = 32 - __clz(v25);
                if (v24 == (unsigned __int16)v20) {
                  uint64_t v27 = 0;
                }
                else {
                  uint64_t v27 = v26;
                }
                uint64_t v28 = a2 + 68 * (int)v23 + 4 * v27;
                ++*(_DWORD *)(v28 + 148);
              }
              else
              {
                uint64_t result = encode_symbol((unsigned int **)a2, (__int16)v25, v22, a8);
                if (result) {
                  return result;
                }
              }
            }
            ++v19;
          }
          while (v19 < *(int *)(a2 + 16));
          int v17 = v69;
        }
        int v43 = v18 * v17;
        if ((int)v19 < v43)
        {
          do
          {
            int v44 = *(_DWORD *)(a2 + 16);
            int v45 = *(_DWORD *)(a2 + 4 * ((int)v19 % v44) + 24);
            if (v45 != 0x7FFFFFFF)
            {
              int v46 = v19 + v45;
              int v47 = v46 - v44;
              switch(v16)
              {
                case 1:
                  LOWORD(v20) = *(_WORD *)(v13 + 2 * v47);
                  break;
                case 2:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v46);
                  break;
                case 3:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v47);
                  break;
                case 4:
                  LOWORD(v20) = *(_WORD *)(v12 + 2 * v46) + *(_WORD *)(v13 + 2 * v47) - *(_WORD *)(v12 + 2 * v47);
                  break;
                case 5:
                  int v48 = *(unsigned __int16 *)(v13 + 2 * v47);
                  int v49 = *(unsigned __int16 *)(v12 + 2 * v46);
                  goto LABEL_58;
                case 6:
                  int v48 = *(unsigned __int16 *)(v12 + 2 * v46);
                  int v49 = *(unsigned __int16 *)(v13 + 2 * v47);
LABEL_58:
                  unsigned int v20 = v48 + ((v49 - *(unsigned __int16 *)(v12 + 2 * v47)) >> 1);
                  break;
                case 7:
                  unsigned int v20 = (*(unsigned __int16 *)(v12 + 2 * v46) + *(unsigned __int16 *)(v13 + 2 * v47)) >> 1;
                  break;
                default:
                  break;
              }
              int v50 = *(unsigned __int16 *)(v13 + 2 * v46);
              __int16 v51 = v50 - v20;
              int v52 = v46 % v44;
              if (a9)
              {
                unsigned int v53 = v51;
                if (v51 < 0) {
                  unsigned int v53 = -v51;
                }
                uint64_t v54 = 32 - __clz(v53);
                if (v50 == (unsigned __int16)v20) {
                  uint64_t v54 = 0;
                }
                uint64_t v55 = a2 + 68 * v52 + 4 * v54;
                ++*(_DWORD *)(v55 + 148);
              }
              else
              {
                uint64_t result = encode_symbol((unsigned int **)a2, v51, v52, a8);
                if (result) {
                  return result;
                }
              }
            }
            LODWORD(v19) = v19 + 1;
          }
          while (v43 != v19);
        }
      }
      else
      {
        if (!*(_DWORD *)(a2 + 40)) {
          return 3;
        }
        if (v12) {
          int v30 = *(_DWORD *)(a2 + 40);
        }
        else {
          int v30 = 1;
        }
        int v31 = *(_DWORD *)(a2 + 44);
        int v32 = *(_DWORD *)(a2 + 16);
        if (v32 < 1)
        {
          LODWORD(v33) = 0;
          LOWORD(v34) = 0;
        }
        else
        {
          int v70 = *(_DWORD *)(a2 + 44);
          uint64_t v33 = 0;
          LOWORD(v34) = 0;
          do
          {
            int v35 = *(_DWORD *)(a2 + 4 * v33 + 24);
            if (v35 != 0x7FFFFFFF)
            {
              int v36 = v33 + v35;
              if (v12)
              {
                uint64_t v37 = v36;
                LOWORD(v34) = *(unsigned __int8 *)(v12 + v36);
              }
              else
              {
                unsigned int v34 = 1 << (*(_DWORD *)(a2 + 12) - 1);
                uint64_t v37 = v36;
              }
              int v38 = *(unsigned __int8 *)(v13 + v37);
              LOWORD(v39) = v38 - v34;
              if (a9)
              {
                unsigned int v39 = (__int16)v39;
                if ((v39 & 0x8000u) != 0) {
                  unsigned int v39 = -(__int16)v39;
                }
                uint64_t v40 = 32 - __clz(v39);
                if (v38 == (unsigned __int16)v34) {
                  uint64_t v41 = 0;
                }
                else {
                  uint64_t v41 = v40;
                }
                uint64_t v42 = a2 + 68 * (int)v37 + 4 * v41;
                ++*(_DWORD *)(v42 + 148);
              }
              else
              {
                uint64_t result = encode_symbol((unsigned int **)a2, (__int16)v39, v36, a8);
                if (result) {
                  return result;
                }
              }
            }
            ++v33;
          }
          while (v33 < *(int *)(a2 + 16));
          int v31 = v70;
        }
        int v56 = v32 * v31;
        if ((int)v33 < v56)
        {
          do
          {
            int v57 = *(_DWORD *)(a2 + 16);
            int v58 = *(_DWORD *)(a2 + 4 * ((int)v33 % v57) + 24);
            if (v58 != 0x7FFFFFFF)
            {
              int v59 = v33 + v58;
              int v60 = v59 - v57;
              switch(v30)
              {
                case 1:
                  LOWORD(v34) = *(unsigned __int8 *)(v13 + v60);
                  break;
                case 2:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v59);
                  break;
                case 3:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v60);
                  break;
                case 4:
                  LOWORD(v34) = *(unsigned __int8 *)(v12 + v59)
                              + *(unsigned __int8 *)(v13 + v60)
                              - *(unsigned __int8 *)(v12 + v60);
                  break;
                case 5:
                  int v61 = *(unsigned __int8 *)(v13 + v60);
                  int v62 = *(unsigned __int8 *)(v12 + v59);
                  goto LABEL_79;
                case 6:
                  int v61 = *(unsigned __int8 *)(v12 + v59);
                  int v62 = *(unsigned __int8 *)(v13 + v60);
LABEL_79:
                  unsigned int v34 = v61 + ((v62 - *(unsigned __int8 *)(v12 + v60)) >> 1);
                  break;
                case 7:
                  unsigned int v34 = (*(unsigned __int8 *)(v12 + v59) + *(unsigned __int8 *)(v13 + v60)) >> 1;
                  break;
                default:
                  break;
              }
              int v63 = *(unsigned __int8 *)(v13 + v59);
              __int16 v64 = v63 - v34;
              int v65 = v59 % v57;
              if (a9)
              {
                unsigned int v66 = v64;
                if (v64 < 0) {
                  unsigned int v66 = -v64;
                }
                uint64_t v67 = 32 - __clz(v66);
                if (v63 == (unsigned __int16)v34) {
                  uint64_t v67 = 0;
                }
                uint64_t v68 = a2 + 68 * v65 + 4 * v67;
                ++*(_DWORD *)(v68 + 148);
              }
              else
              {
                uint64_t result = encode_symbol((unsigned int **)a2, v64, v65, a8);
                if (result) {
                  return result;
                }
              }
            }
            LODWORD(v33) = v33 + 1;
          }
          while (v56 != v33);
        }
      }
      a7 = v73;
      uint64_t v12 = v13;
      v13 += a6;
      uint64_t v11 = v76 + 1;
      v10 += a6;
    }
    while (v76 + 1 != v74);
  }
  return 0;
}

uint64_t encodeWriteHuffTable(uint64_t *a1, int a2)
{
  uint8x16_t v2 = *(uint8x16_t *)&a1[2 * a2 + 6];
  uint16x8_t v3 = vmovl_high_u8(v2);
  uint16x8_t v4 = vmovl_u8(*(uint8x8_t *)v2.i8);
  v4.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v4.i8, *(uint16x4_t *)v3.i8), (int32x4_t)vaddl_high_u16(v4, v3)));
  uint64_t v5 = v4.u32[0];
  if (v4.i32[0] > 0x11u) {
    return 1;
  }
  uint64_t v9 = *a1;
  uint64_t result = aj_ostream_write_bytes(*a1, 65476, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(v9, (int)v5 + 19, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(v9, a2, 1);
      if (!result)
      {
        uint64_t v10 = 0;
        while (1)
        {
          uint64_t result = aj_ostream_write_bytes(v9, *((unsigned __int8 *)&a1[2 * a2 + 6] + v10), 1);
          if (result) {
            break;
          }
          if (++v10 == 16)
          {
            if (!v5) {
              return 0;
            }
            uint64_t v11 = (unsigned __int8 *)a1 + 17 * a2 + 96;
            do
            {
              int v12 = *v11++;
              uint64_t result = aj_ostream_write_bytes(v9, v12, 1);
              if (result) {
                break;
              }
              --v5;
            }
            while (v5);
            return result;
          }
        }
      }
    }
  }
  return result;
}

uint64_t encode_symbol(unsigned int **a1, int a2, int a3, int a4)
{
  uint64_t v5 = (int32x2_t *)*a1;
  uint64_t v6 = a3;
  if (a2 >= 0) {
    unsigned int v7 = a2;
  }
  else {
    unsigned int v7 = -a2;
  }
  unsigned int v8 = __clz(v7);
  if (a2) {
    int v9 = v8;
  }
  else {
    int v9 = 32;
  }
  unsigned int v10 = 32 - v9;
  if (a4) {
    uint64_t v6 = 0;
  }
  uint64_t v11 = (uint64_t)a1 + 68 * v6 + 4 * v10;
  int v12 = *(unsigned __int16 *)(v11 + 352);
  unsigned int v13 = *(unsigned __int16 *)(v11 + 354);
  if (v5[2].i32[1] >= 9 && (int v14 = v5->i32[1] + v12, v14 < 33))
  {
    unsigned int v16 = v5->i32[0] | (v13 << -(char)v14);
    v5->i32[0] = v16;
    v5->i32[1] = v14;
    if (v14 >= 8)
    {
      do
      {
        unsigned int v17 = HIBYTE(v16);
        int v18 = (unsigned char *)v5[1];
        v5[1] = (int32x2_t)(v18 + 1);
        unsigned char *v18 = v17;
        v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v17 == 255)
        {
          uint64_t v19 = (unsigned char *)v5[1];
          v5[1] = (int32x2_t)(v19 + 1);
          unsigned char *v19 = 0;
          v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        int v20 = v5->i32[1];
        unsigned int v16 = v5->i32[0] << 8;
        v5->i32[0] = v16;
        v5->i32[1] = v20 - 8;
      }
      while (v20 > 15);
    }
  }
  else
  {
    uint64_t result = aj_ostream_write(*a1, v13, v12);
    if (result) {
      return result;
    }
  }
  if ((v9 - 17) <= 0xE)
  {
    unsigned int v21 = (__int16)(a2 + (a2 >> 15)) & ~(-1 << v10);
    if (v5[2].i32[1] >= 9 && (__int32 v22 = v5->i32[1], v23 = v22 + v10, (int)(v22 + v10) < 33))
    {
      unsigned int v24 = v5->i32[0] | (v21 << (v9 - v22));
      v5->i32[0] = v24;
      v5->i32[1] = v23;
      if (v23 >= 8)
      {
        do
        {
          unsigned int v25 = HIBYTE(v24);
          uint64_t v26 = (unsigned char *)v5[1];
          v5[1] = (int32x2_t)(v26 + 1);
          unsigned char *v26 = v25;
          v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
          if (v25 == 255)
          {
            uint64_t v27 = (unsigned char *)v5[1];
            v5[1] = (int32x2_t)(v27 + 1);
            *uint64_t v27 = 0;
            v5[2] = vadd_s32(v5[2], (int32x2_t)0xFFFFFFFF00000001);
          }
          int v28 = v5->i32[1];
          unsigned int v24 = v5->i32[0] << 8;
          v5->i32[0] = v24;
          v5->i32[1] = v28 - 8;
        }
        while (v28 > 15);
      }
    }
    else
    {
      uint64_t result = aj_ostream_write((unsigned int *)v5, v21, v10);
      if (result) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t aj_block_decode(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v18 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t v10 = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, &v18);
  if (v10)
  {
    uint64_t v13 = v10;
    LOWORD(v14) = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
  }
  else
  {
    int v17 = 0;
    int v18 = SHIWORD(v18);
    int v15 = *a3 + v18;
    unsigned int v14 = (v15 * *(_DWORD *)(a1 + 48) + 2048) >> 12;
    *a3 = v15;
    uint64_t v13 = aj_huffman_decode_ac_s1(a1, a2, &v19, &v17, v11, v12);
  }
  LOWORD(v19) = v14;
  (*(void (**)(long long *, uint64_t *, uint64_t))(a1 + 520))(&v19, a4, a5);
  if (*(unsigned char *)(a1 + 1040)) {
    aj_mosquito_spray(a1, (uint64_t)&v19, a4, a5);
  }
  return v13;
}

uint64_t aj_mosquito_spray(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  if (*(uint64_t (**)(int16x8_t *, uint64_t *, uint64_t))(result + 520) == aj_idct_s1)
  {
    int8x16_t v5 = vorrq_s8(*(int8x16_t *)(a2 + 88), *(int8x16_t *)(a2 + 104));
    if (*(void *)&vorr_s8(*(int8x8_t *)v5.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v5, v5, 8uLL)) | *(void *)(a2 + 40) | *(void *)(a2 + 56) | *(void *)(a2 + 72) | *(void *)(a2 + 120) | *(unsigned int *)(a2 + 12) | *(unsigned __int16 *)(a2 + 54) | (*(void *)(a2 + 24) >> 16) | *(unsigned int *)(a2 + 68) | (*(void *)(a2 + 80) >> 16))
    {
      uint8x8_t v8 = *(uint8x8_t *)(*a3 + (int)a4);
      uint8x8_t v9 = *(uint8x8_t *)(a3[1] + (int)a4);
      *(uint8x8_t *)&long long v69 = v8;
      *((uint8x8_t *)&v69 + 1) = v9;
      uint8x8_t v10 = *(uint8x8_t *)(a3[2] + (int)a4);
      uint8x8_t v11 = *(uint8x8_t *)(a3[3] + (int)a4);
      *(uint8x8_t *)&long long v70 = v10;
      *((uint8x8_t *)&v70 + 1) = v11;
      uint8x8_t v12 = *(uint8x8_t *)(a3[4] + (int)a4);
      uint8x8_t v13 = *(uint8x8_t *)(a3[5] + (int)a4);
      *(uint8x8_t *)&long long v71 = v12;
      *((uint8x8_t *)&v71 + 1) = v13;
      uint8x8_t v14 = *(uint8x8_t *)(a3[6] + (int)a4);
      uint8x8_t v15 = *(uint8x8_t *)(a3[7] + (int)a4);
      *(uint8x8_t *)&long long v72 = v14;
      *((uint8x8_t *)&v72 + 1) = v15;
      uint8x8_t v16 = vmin_u8(vmin_u8(vmin_u8(v8, v9), vmin_u8(v10, v11)), vmin_u8(vmin_u8(v12, v13), vmin_u8(v14, v15)));
      uint8x8_t v17 = vpmin_u8(v16, v16);
      uint8x8_t v18 = vpmin_u8(v17, v17);
      unsigned __int8 v19 = vpmin_u8(v18, v18).u8[0];
      uint8x8_t v20 = vmax_u8(vmax_u8(vmax_u8(v8, v9), vmax_u8(v10, v11)), vmax_u8(vmax_u8(v12, v13), vmax_u8(v14, v15)));
      uint8x8_t v21 = vpmax_u8(v20, v20);
      uint8x8_t v22 = vpmax_u8(v21, v21);
      int v23 = vpmax_u8(v22, v22).u8[0];
      if (v23 - v19 >= 32)
      {
        uint8x8_t v24 = (uint8x8_t)vdup_n_s8((v23 + v19) >> 1);
        int8x8_t v25 = (int8x8_t)vcgt_u8(v8, v24);
        int8x8_t v26 = (int8x8_t)vcgt_u8(v9, v24);
        int8x8_t v27 = (int8x8_t)vcgt_u8(v10, v24);
        int8x8_t v28 = (int8x8_t)vcgt_u8(v11, v24);
        int8x8_t v29 = (int8x8_t)vcgt_u8(v12, v24);
        int8x8_t v30 = (int8x8_t)vcgt_u8(v13, v24);
        int8x8_t v31 = (int8x8_t)vcgt_u8(v14, v24);
        int8x8_t v32 = (int8x8_t)vcgt_u8(v15, v24);
        int8x8_t v33 = vadd_s8(vadd_s8(vadd_s8(veor_s8(v27, v26), veor_s8(v25, v26)), vadd_s8(veor_s8(v27, v28), veor_s8(v29, v28))), vadd_s8(vadd_s8(veor_s8(v29, v30), veor_s8(v31, v30)), veor_s8(v31, v32)));
        int8x8_t v34 = vpadd_s8(v33, v33);
        int8x8_t v35 = vpadd_s8(v34, v34);
        if (vpadd_s8(v35, v35).i8[0] >= -12)
        {
          uint64_t v36 = result;
          int v37 = 0;
          int8x8_t v75 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v25), v25);
          int8x8_t v76 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v26), v26);
          int8x8_t v77 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v27), v27);
          int8x8_t v78 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v28), v28);
          int8x8_t v79 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v29), v29);
          int8x8_t v80 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v30), v30);
          int8x8_t v81 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v31), v31);
          int8x8_t v82 = vsub_s8(vbic_s8((int8x8_t)0x202020202020202, v32), v32);
          __int8 v58 = v75.i8[1];
          long long v83 = v69;
          long long v84 = v70;
          __int8 v62 = v75.i8[7];
          __int8 v63 = v75.i8[6];
          __int8 v38 = v75.i8[0];
          __int8 v61 = v76.i8[7];
          __int8 v39 = v76.i8[0];
          unint64_t v40 = (unint64_t)&v83 | 9;
          uint64_t v41 = (char *)&v70 + 1;
          uint64_t result = 1;
          long long v85 = v71;
          long long v86 = v72;
          __int8 v42 = v82.i8[0];
          __int8 v59 = v81.i8[0];
          __int8 v60 = v82.i8[1];
          __int8 v43 = v75.i8[0];
          __int8 v66 = v82.i8[6];
          __int8 v67 = v82.i8[7];
          int8x8_t v44 = v76;
          int8x8_t v45 = v75;
          __int8 v64 = v82.i8[0];
          __int8 v65 = v81.i8[7];
          do
          {
            int8x8_t v46 = v45;
            int8x8_t v45 = v44;
            uint64_t v47 = result + 1;
            uint64_t v48 = 8 * (result + 1);
            int8x8_t v44 = *(int8x8_t *)((char *)&v75 + v48);
            unint64_t v49 = *(void *)&v46 | (*(void *)&v45 >> 8) | (*(void *)&v45 << 8) | *(void *)&v45 | *(void *)&v44;
            if ((v46.i8[0] | v45.i8[1] | v45.i8[0] | v44.i8[0]) != 3)
            {
              *((unsigned char *)&v83 + 8 * result) = (*((unsigned __int8 *)&v69 + 8 * result - 8)
                                             + *((unsigned __int8 *)&v69 + 8 * result)
                                             + *((unsigned __int8 *)&v69 + v48)
                                             + *((unsigned __int8 *)&v69 + ((8 * result) | 1))
                                             + 2) >> 2;
              ++v37;
            }
            for (uint64_t i = 0; i != 6; ++i)
            {
              int v51 = v49;
              if ((v49 & 0xFF00) != 0x300)
              {
                *(unsigned char *)(v40 + i) = (13108
                                     * (v41[i - 16]
                                      + v41[i - 9]
                                      + v41[i - 8]
                                      + v41[i - 7]
                                      + v41[i])
                                     + 26216) >> 16;
                ++v37;
              }
              v49 >>= 8;
            }
            if ((*(void *)&v51 & 0xFF0000) != 0x30000)
            {
              *((unsigned char *)&v83 + ((8 * result) | 7)) = (*((unsigned __int8 *)&v69 + 8 * result - 1)
                                                     + *((unsigned __int8 *)&v69 + ((8 * result) | 7))
                                                     + *((unsigned __int8 *)&v69 + (v48 | 7))
                                                     + *((unsigned __int8 *)&v69 + ((8 * result) | 6))
                                                     + 2) >> 2;
              ++v37;
            }
            __int8 v52 = v75.i8[result];
            if ((v43 | v75.i8[v47] | *((unsigned char *)&v75 + result + 8) | v52) != 3)
            {
              *((unsigned char *)&v83 + result) = (*((unsigned __int8 *)&v69 + result - 1)
                                         + *((unsigned __int8 *)&v69 + result)
                                         + *((unsigned __int8 *)&v69 + v47)
                                         + *((unsigned __int8 *)&v69 + result + 8)
                                         + 2) >> 2;
              ++v37;
            }
            __int8 v53 = *((unsigned char *)&v75 + result + 56);
            if ((v42 | *((unsigned char *)&v75 + result + 57) | *((unsigned char *)&v75 + result + 48) | v53) != 3)
            {
              *((unsigned char *)&v83 + result + 56) = (*((unsigned __int8 *)&v69 + result + 55)
                                              + *((unsigned __int8 *)&v69 + result + 56)
                                              + *((unsigned __int8 *)&v69 + result + 57)
                                              + *((unsigned __int8 *)&v69 + result + 48)
                                              + 2) >> 2;
              ++v37;
            }
            v40 += 8;
            v41 += 8;
            __int8 v42 = v53;
            __int8 v43 = v52;
            ++result;
          }
          while (v47 != 7);
          if ((v58 | v39 | v38) != 3)
          {
            LOBYTE(v83) = (21846 * (v8.u8[0] + v8.u8[1] + v9.u8[0]) + 21846) >> 16;
            ++v37;
          }
          if ((v62 | v63 | v61) != 3)
          {
            BYTE7(v83) = (21846 * (v8.u8[6] + v8.u8[7] + v9.u8[7]) + 21846) >> 16;
            ++v37;
          }
          if ((v60 | v59 | v64) != 3)
          {
            BYTE8(v86) = (21846 * (v15.u8[0] + v15.u8[1] + v14.u8[0]) + 21846) >> 16;
            ++v37;
          }
          if ((v66 | v67 | v65) != 3)
          {
            HIBYTE(v86) = (21846 * (v15.u8[7] + v15.u8[6] + v14.u8[7]) + 21846) >> 16;
            ++v37;
          }
          if (v37 >= 33)
          {
            v68[0] = (uint8x8_t *)&v83;
            v68[1] = (uint8x8_t *)&v83 + 1;
            v68[2] = (uint8x8_t *)&v84;
            v68[3] = (uint8x8_t *)&v84 + 1;
            v68[4] = (uint8x8_t *)&v85;
            v68[5] = (uint8x8_t *)&v85 + 1;
            v68[6] = (uint8x8_t *)&v86;
            v68[7] = (uint8x8_t *)&v86 + 1;
            aj_block_dct(v68, &v73, (int16x8_t *)(v36 + 1300));
            uint64_t v54 = 0;
            uint64_t v55 = *(void *)(v36 + 704);
            do
            {
              v74[0].i16[*(int *)(v55 + 4 * v54)] = (*(_DWORD *)(v36 + 4 * *(int *)(v55 + 4 * v54) + 1044)
                                                                 * v73.i16[v54]
                                                                 + 2048) >> 12;
              ++v54;
            }
            while (v54 != 64);
            unint64_t v56 = 0;
            unint64_t v57 = -8;
            do
            {
              v74[v56 / 0x10] = vaddq_s16(vmaxq_s16(vminq_s16(vsubq_s16(v74[v56 / 0x10], *(int16x8_t *)(a2 + v56)), *(int16x8_t *)(v36 + 1440 + v56)), vnegq_s16(*(int16x8_t *)(v36 + 1440 + v56))), *(int16x8_t *)(a2 + v56));
              v57 += 8;
              v56 += 16;
            }
            while (v57 < 0x38);
            v74[0].i16[0] = *(_WORD *)a2;
            return aj_idct_s1(v74, a3, a4);
          }
        }
      }
    }
  }
  return result;
}

uint64_t aj_block_decode_S2(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v19 = 0;
  uint64_t v10 = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, (int *)&v19 + 1);
  if (v10)
  {
    uint64_t v13 = v10;
    LOWORD(v14) = 0;
    memset(v27, 0, sizeof(v27));
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    long long v21 = 0u;
  }
  else
  {
    int v15 = HIDWORD(v19);
    LODWORD(v19) = WORD2(v19);
    SHIDWORD(v19) >>= 16;
    int v16 = *a3 + (v15 >> 16);
    int v14 = v16 * *(_DWORD *)(a1 + 48);
    *a3 = v16;
    uint64_t v17 = aj_huffman_decode_ac_s2(a1, a2, &v20, &v19, v11, v12);
    if (!v17) {
      uint64_t v17 = aj_huffman_decode_skip_block(*(void *)(a1 + 40), a2, v19);
    }
    uint64_t v13 = v17;
  }
  __int16 v20 = v14;
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_S4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v19 = 0;
  uint64_t v10 = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, (int *)&v19 + 1);
  if (v10)
  {
    uint64_t v13 = v10;
    LOWORD(v14) = 0;
    memset(v27, 0, sizeof(v27));
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    long long v21 = 0u;
  }
  else
  {
    int v15 = HIDWORD(v19);
    LODWORD(v19) = WORD2(v19);
    SHIDWORD(v19) >>= 16;
    int v16 = *a3 + (v15 >> 16);
    int v14 = v16 * *(_DWORD *)(a1 + 48);
    *a3 = v16;
    uint64_t v17 = aj_huffman_decode_ac_s4(a1, a2, &v20, &v19, v11, v12);
    if (!v17) {
      uint64_t v17 = aj_huffman_decode_skip_block(*(void *)(a1 + 40), a2, v19);
    }
    uint64_t v13 = v17;
  }
  __int16 v20 = v14;
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_S8(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  int v14 = 0;
  __int16 v13 = 0;
  uint64_t v10 = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, &v14);
  if (!v10)
  {
    int v14 = SHIWORD(v14);
    int v11 = *a3 + v14;
    __int16 v13 = (*(_WORD *)a3 + v14) * *(_WORD *)(a1 + 48);
    *a3 = v11;
    uint64_t v10 = aj_huffman_decode_skip_block(*(void *)(a1 + 40), a2, 1);
  }
  (*(void (**)(__int16 *, uint64_t, uint64_t))(a1 + 520))(&v13, a4, a5);
  return v10;
}

_DWORD *aj_block_dequantize_12bit(_DWORD *result, __int16 *a2, _DWORD *a3)
{
  int v3 = result[178];
  switch(v3)
  {
    case 1:
      for (uint64_t i = 0; i != 64; ++i)
        a3[i] = (unint64_t)((int)result[i + 180] * (uint64_t)a2[i] + 2048) >> 12;
      break;
    case 2:
      uint8x8_t v8 = a3 + 2;
      uint8x8_t v9 = a2 + 2;
      uint64_t v10 = result + 183;
      unint64_t v11 = -8;
      do
      {
        *(v8 - 2) = *(v10 - 3) * *(v9 - 2);
        *(v8 - 1) = *(v10 - 2) * *(v9 - 1);
        *uint8x8_t v8 = *(v10 - 1) * *v9;
        int v12 = *v10;
        v10 += 8;
        v11 += 8;
        v8[1] = v12 * v9[1];
        v8 += 8;
        v9 += 8;
      }
      while (v11 < 0x11);
      break;
    case 4:
      uint64_t v4 = 0;
      char v5 = 1;
      do
      {
        a3[v4] = result[v4 + 180] * a2[v4];
        char v6 = v5;
        a3[v4 | 1] = result[(v4 | 1) + 180] * a2[v4 | 1];
        uint64_t v4 = 8;
        char v5 = 0;
      }
      while ((v6 & 1) != 0);
      break;
    default:
      *a3 = result[180] * *a2;
      break;
  }
  return result;
}

uint64_t aj_block_decode_12bit(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v19 = 0;
  uint64_t v10 = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, &v19);
  if (v10)
  {
    uint64_t v13 = v10;
    __int16 v14 = 0;
    memset(v28, 0, sizeof(v28));
    long long v27 = 0u;
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    goto LABEL_14;
  }
  __int16 v14 = *a3 + HIWORD(v19);
  *a3 = v14;
  unsigned int v18 = 0;
  int v15 = *(_DWORD *)(a1 + 712);
  switch(v15)
  {
    case 4:
      uint64_t v16 = aj_huffman_decode_ac_s4(a1, a2, &v21, &v18, v11, v12);
      goto LABEL_9;
    case 2:
      uint64_t v16 = aj_huffman_decode_ac_s2(a1, a2, &v21, &v18, v11, v12);
      goto LABEL_9;
    case 1:
      uint64_t v16 = aj_huffman_decode_ac_s1(a1, a2, &v21, &v18, v11, v12);
LABEL_9:
      uint64_t v13 = v16;
      if (v16) {
        goto LABEL_14;
      }
      int v15 = *(_DWORD *)(a1 + 712);
      break;
  }
  if (v15 < 2) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = aj_huffman_decode_skip_block(*(void *)(a1 + 40), a2, v18);
  }
LABEL_14:
  __int16 v21 = v14;
  aj_block_dequantize_12bit((_DWORD *)a1, &v21, v20);
  (*(void (**)(_DWORD *, uint64_t, uint64_t))(a1 + 520))(v20, a4, a5);
  return v13;
}

uint64_t aj_block_decode_skip(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v7 = 0;
  uint64_t result = aj_huffman_decode_val(*(void *)(a1 + 32), a2, 0, &v7);
  if (!result)
  {
    int v7 = SHIWORD(v7);
    *a3 += v7;
    return aj_huffman_decode_skip_block(*(void *)(a1 + 40), a2, 1);
  }
  return result;
}

uint64_t aj_prog_decode_DC_first(void *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  char v6 = a3 + 24;
  int v5 = *a3;
  char v33 = 0;
  if (v5 >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v29 = a1;
    uint64_t v30 = a2;
    do
    {
      uint64_t v8 = (int)a3[v7 + 1];
      uint64_t v9 = *(void *)&a3[4 * a3[v8 + 5] + 54];
      if (v5 == 1)
      {
        int v10 = 1;
LABEL_6:
        uint64_t v31 = v7;
        int v11 = 0;
        uint64_t v12 = (int *)(a2 + 4 * v8 + 8);
        uint64_t v13 = (int *)a1 + v8 + 1617;
        while (1)
        {
          int v14 = *v13;
          int v15 = a3[30];
          if (v15 <= -2)
          {
            uint64_t v16 = aj_istream_fill_buf((uint64_t)v6, -9);
            if (v16)
            {
              uint64_t v27 = v16;
LABEL_34:
              aj_log_error(0, "Unable to read more data");
              return v27;
            }
            int v15 = a3[30];
            if (v15 <= -9)
            {
              uint64_t v27 = 7;
              goto LABEL_34;
            }
          }
          unint64_t v17 = *v6;
          unsigned int v18 = *(unsigned __int16 *)(v9 + ((v17 >> 23) & 0x1FE) + 272);
          if (*(_WORD *)(v9 + ((v17 >> 23) & 0x1FE) + 272))
          {
            unsigned int v19 = v15 + 9;
            if (v15 >= 0) {
              unsigned int v19 = 8;
            }
            if (v19 < v18 >> 8) {
              return 7;
            }
            a3[24] = v17 << SBYTE1(v18);
            a3[30] = v15 - (v18 >> 8);
            char v33 = v18;
          }
          else
          {
            uint64_t v20 = prog_huff_decode_loop(v9, v6, &v33);
            if (v20) {
              return v20;
            }
            LOBYTE(v18) = v33;
          }
          if ((_BYTE)v18)
          {
            int v21 = a3[30];
            int v22 = v18;
            int v23 = v18 - 9;
            if (v21 < v23)
            {
              if (aj_istream_fill_buf((uint64_t)v6, -9)) {
                return 9;
              }
              int v21 = a3[30];
              if (v21 < v23) {
                return 9;
              }
            }
            int v24 = a3[24];
            a3[24] = v24 << v22;
            a3[30] = v21 - v22;
            if (v24 >= 0) {
              int v25 = (-1 << v22) + 1;
            }
            else {
              int v25 = 0;
            }
            int v26 = ((v25 + (v24 >> -(char)v22)) << a3[15]) + *v12;
          }
          else
          {
            int v26 = *v12;
          }
          *(_WORD *)(a4 + ((uint64_t)(v11 + v14) << 7)) = v26;
          *uint64_t v12 = (__int16)v26;
          if (v10 == ++v11)
          {
            int v5 = *a3;
            a1 = v29;
            a2 = v30;
            uint64_t v7 = v31;
            goto LABEL_28;
          }
        }
      }
      int v10 = *(_DWORD *)(*a1 + 4 * v8 + 32) * *(_DWORD *)(*a1 + 4 * v8 + 16);
      if (v10 >= 1) {
        goto LABEL_6;
      }
LABEL_28:
      ++v7;
    }
    while (v7 < v5);
  }
  uint64_t v27 = 0;
  ++a3[19];
  return v27;
}

uint64_t prog_huff_decode_loop(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  int v6 = *(_DWORD *)(a1 + 784);
  int v7 = *(_DWORD *)(a1 + 788);
  int v8 = a2[6];
  if (v8 > 6) {
    goto LABEL_4;
  }
  uint64_t result = aj_istream_fill_buf((uint64_t)a2, -9);
  if (result) {
    return result;
  }
  int v8 = a2[6];
  if (v8 < 0)
  {
LABEL_16:
    aj_log_error(0, "No huffman code found.");
    return 7;
  }
  else
  {
LABEL_4:
    unsigned int v10 = *a2;
    if (v8 >= 7) {
      int v11 = 7;
    }
    else {
      int v11 = v8;
    }
    uint64_t v12 = (v11 + 10);
    uint64_t v13 = 9;
    while (!*(unsigned char *)(v13 + a1 - 1) || v7 > 255)
    {
LABEL_15:
      v6 *= 2;
      if (++v13 == v12) {
        goto LABEL_16;
      }
    }
    uint64_t v14 = 0;
    while ((v10 >> -(char)v13) - v6 != v14)
    {
      int v15 = v14 + 1;
      if ((int)v14 + 1 < *(unsigned __int8 *)(v13 + a1 - 1))
      {
        int v16 = v7 + v14++;
        if (v16 <= 254) {
          continue;
        }
      }
      v7 += v15;
      v6 += v15;
      goto LABEL_15;
    }
    uint64_t result = 0;
    *a2 = v10 << v13;
    a2[6] = v8 - v13;
    *a3 = *(unsigned char *)(a1 + v7 + v14 + 16);
  }
  return result;
}

uint64_t aj_prog_decode_DC_refine(void *a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v6 = (uint64_t)(a3 + 24);
  LODWORD(v5) = *a3;
  if (*a3 < 1)
  {
LABEL_15:
    uint64_t result = 0;
    ++a3[19];
  }
  else
  {
    uint64_t v9 = 0;
    int v10 = 1 << a3[15];
    while (1)
    {
      uint64_t v11 = a3[v9 + 1];
      int v12 = v5 == 1 ? 1 : *(_DWORD *)(*a1 + 4 * v11 + 32) * *(_DWORD *)(*a1 + 4 * v11 + 16);
      int v13 = a3[30];
      if (v13 < v12 - 9)
      {
        if (aj_istream_fill_buf(v6, -9)) {
          return 9;
        }
        int v13 = a3[30];
        if (v13 < v12 - 9) {
          return 9;
        }
      }
      int v14 = a3[24];
      a3[24] = v14 << v12;
      a3[30] = v13 - v12;
      if (v12 >= 1)
      {
        uint64_t v15 = 0;
        int v16 = v14 & (-1 << -(char)v12);
        do
        {
          if (v16 < 0)
          {
            uint64_t v17 = (v15 + *((int *)a1 + v11 + 1617)) << 7;
            *(_WORD *)(a4 + v17) |= v10;
          }
          v16 *= 2;
          ++v15;
        }
        while (v12 != v15);
      }
      ++v9;
      uint64_t v5 = *a3;
      if (v9 >= v5) {
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t aj_prog_decode_AC_first(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v5 = (int)a3[1];
  uint64_t v6 = *(void *)&a3[4 * a3[v5 + 9] + 56];
  char v28 = 0;
  int v7 = a3[20];
  if (v7) {
    goto LABEL_2;
  }
  int v8 = a3[13];
  if (v8 <= a3[14])
  {
    int v12 = a3 + 24;
    uint64_t v13 = *(void *)(a1 + 1568 * (int)v5 + 896);
    do
    {
      int v14 = a3[30];
      if (v14 <= -2)
      {
        uint64_t v15 = aj_istream_fill_buf((uint64_t)(a3 + 24), -9);
        if (v15)
        {
          uint64_t v9 = v15;
LABEL_31:
          aj_log_error(0, "Unable to read more data");
          return v9;
        }
        int v14 = a3[30];
        if (v14 <= -9)
        {
          uint64_t v9 = 7;
          goto LABEL_31;
        }
      }
      unint64_t v16 = *v12;
      unsigned int v17 = *(unsigned __int16 *)(v6 + ((v16 >> 23) & 0x1FE) + 272);
      if (*(_WORD *)(v6 + ((v16 >> 23) & 0x1FE) + 272))
      {
        unsigned int v18 = v14 + 9;
        if (v14 >= 0) {
          unsigned int v18 = 8;
        }
        if (v18 < v17 >> 8) {
          return 7;
        }
        a3[24] = v16 << SBYTE1(v17);
        a3[30] = v14 - (v17 >> 8);
        char v28 = v17;
      }
      else
      {
        uint64_t v19 = prog_huff_decode_loop(v6, a3 + 24, &v28);
        if (v19) {
          return v19;
        }
        LOBYTE(v17) = v28;
      }
      int v20 = v17 >> 4;
      int v21 = v17 & 0xF;
      if ((v17 & 0xF) != 0)
      {
        int v22 = a3[30];
        if (v22 < v21 - 9)
        {
          if (aj_istream_fill_buf((uint64_t)(a3 + 24), -9)) {
            return 9;
          }
          int v22 = a3[30];
          if (v22 < v21 - 9) {
            return 9;
          }
        }
        int v23 = v20 + v8;
        int v24 = a3[24];
        a3[24] = v24 << v21;
        a3[30] = v22 - v21;
        int v25 = (-1 << v21) | 1;
        if (v24 < 0) {
          int v25 = 0;
        }
        *(_WORD *)(a4 + 2 * *(int *)(v13 + 4 * v23)) = (v25 + (v24 >> -(char)v21)) << a3[15];
      }
      else
      {
        if (v20 != 15)
        {
          int v7 = 1 << v20;
          a3[20] = 1 << v20;
          if (v17 >= 0x10u)
          {
            int v26 = a3[30];
            if (v26 < v20 - 9)
            {
              if (aj_istream_fill_buf((uint64_t)(a3 + 24), -9)) {
                return 9;
              }
              int v26 = a3[30];
              if (v26 < v20 - 9) {
                return 9;
              }
              int v7 = a3[20];
            }
            unsigned int v27 = a3[24];
            a3[24] = v27 << v20;
            a3[30] = v26 - v20;
            v7 += v27 >> -(char)v20;
          }
LABEL_2:
          a3[20] = v7 - 1;
          break;
        }
        int v23 = v8 + 15;
      }
      int v8 = v23 + 1;
    }
    while (v23 < a3[14]);
  }
  uint64_t v9 = 0;
  ++a3[19];
  return v9;
}

uint64_t aj_prog_decode_AC_refine(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v6 = a3[1];
  uint64_t v7 = *(void *)&a3[4 * a3[v6 + 9] + 56];
  int v8 = (unsigned int *)(a3 + 24);
  char v53 = 0;
  uint64_t v9 = *(void *)(a1 + 1568 * (int)v6 + 896);
  uint64_t v11 = a3[13];
  uint64_t v10 = a3[14];
  int v12 = (int *)(v9 + 4 * v10);
  uint64_t v13 = (int *)(v9 + 4 * v11);
  if (a3[20]) {
    goto LABEL_2;
  }
  if ((int)v11 > (int)v10) {
    goto LABEL_28;
  }
  do
  {
    int v26 = a3[30];
    if (v26 > -2) {
      goto LABEL_32;
    }
    uint64_t v27 = aj_istream_fill_buf((uint64_t)v8, -9);
    if (v27)
    {
      uint64_t v25 = v27;
LABEL_81:
      aj_log_error(0, "Unable to read more data");
      return v25;
    }
    int v26 = a3[30];
    if (v26 <= -9)
    {
      uint64_t v25 = 7;
      goto LABEL_81;
    }
LABEL_32:
    unint64_t v28 = *v8;
    unsigned int v29 = *(unsigned __int16 *)(v7 + ((v28 >> 23) & 0x1FE) + 272);
    if (*(_WORD *)(v7 + ((v28 >> 23) & 0x1FE) + 272))
    {
      unsigned int v30 = v26 + 9;
      if (v26 >= 0) {
        unsigned int v30 = 8;
      }
      if (v30 < v29 >> 8) {
        return 7;
      }
      a3[24] = v28 << SBYTE1(v29);
      a3[30] = v26 - (v29 >> 8);
      char v53 = v29;
    }
    else
    {
      uint64_t v31 = prog_huff_decode_loop(v7, v8, &v53);
      if (v31) {
        return v31;
      }
      LOBYTE(v29) = v53;
    }
    int v32 = v29 >> 4;
    if ((v29 & 0xF) == 0)
    {
      if (v32 == 15)
      {
        int v36 = 0;
        goto LABEL_49;
      }
      int v48 = 1 << v32;
      a3[20] = 1 << v32;
      if (v29 >= 0x10u)
      {
        int v49 = a3[30];
        if (v49 < v32 - 9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9)) {
            return 9;
          }
          int v49 = a3[30];
          if (v49 < v32 - 9) {
            return 9;
          }
          int v48 = a3[20];
        }
        unsigned int v51 = a3[24];
        a3[24] = v51 << v32;
        a3[30] = v49 - v32;
        int v52 = v48 | (v51 >> -(char)v32);
        a3[20] = v52;
        if (!v52) {
          goto LABEL_28;
        }
      }
LABEL_2:
      if (v13 < v12)
      {
        do
        {
          int v14 = v13;
          uint64_t v16 = *v13;
          uint64_t v15 = v13[1];
          if (*(_WORD *)(a4 + 2 * v16))
          {
            int v17 = a3[30];
            if (v17 <= -9)
            {
              if (aj_istream_fill_buf((uint64_t)v8, -9)) {
                return 9;
              }
              int v17 = a3[30];
              if (v17 < -8) {
                return 9;
              }
            }
            unsigned int v18 = *v8;
            if ((*v8 & 0x80000000) != 0)
            {
              int v19 = *(__int16 *)(a4 + 2 * v16);
              if (v19 > 0) {
                __int16 v20 = 1;
              }
              else {
                __int16 v20 = -1;
              }
              *(_WORD *)(a4 + 2 * v16) = v19 + (v20 << a3[15]);
            }
            a3[24] = 2 * v18;
            a3[30] = v17 - 1;
          }
          if (*(_WORD *)(a4 + 2 * v15))
          {
            int v21 = a3[30];
            if (v21 <= -9)
            {
              if (aj_istream_fill_buf((uint64_t)v8, -9)) {
                return 9;
              }
              int v21 = a3[30];
              if (v21 < -8) {
                return 9;
              }
            }
            unsigned int v22 = *v8;
            if ((*v8 & 0x80000000) != 0)
            {
              int v23 = *(__int16 *)(a4 + 2 * v15);
              if (v23 > 0) {
                __int16 v24 = 1;
              }
              else {
                __int16 v24 = -1;
              }
              *(_WORD *)(a4 + 2 * v15) = v23 + (v24 << a3[15]);
            }
            a3[24] = 2 * v22;
            a3[30] = v21 - 1;
          }
          uint64_t v13 = v14 + 2;
        }
        while (v14 + 2 < v12);
        uint64_t v13 = v14 + 2;
      }
      if (v13 == v12 && *(_WORD *)(a4 + 2 * *v12))
      {
        int v43 = a3[30];
        if (v43 <= -9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9)) {
            return 9;
          }
          int v43 = a3[30];
          if (v43 < -8) {
            return 9;
          }
        }
        unsigned int v44 = *v8;
        if ((*v8 & 0x80000000) != 0)
        {
          uint64_t v45 = *v12;
          int v46 = *(__int16 *)(a4 + 2 * v45);
          if (v46 > 0) {
            __int16 v47 = 1;
          }
          else {
            __int16 v47 = -1;
          }
          *(_WORD *)(a4 + 2 * v45) = v46 + (v47 << a3[15]);
        }
        a3[24] = 2 * v44;
        a3[30] = v43 - 1;
      }
      --a3[20];
      goto LABEL_28;
    }
    int v33 = a3[30];
    if (v33 <= -9)
    {
      if (aj_istream_fill_buf((uint64_t)v8, -9)) {
        return 9;
      }
      int v33 = a3[30];
      if (v33 < -8) {
        return 9;
      }
    }
    int v34 = a3[24];
    if (v34 >= 0) {
      int v35 = -1;
    }
    else {
      int v35 = 1;
    }
    int v36 = v35 << a3[15];
    a3[24] = 2 * v34;
    a3[30] = v33 - 1;
    do
    {
LABEL_49:
      if (*(_WORD *)(a4 + 2 * *v13))
      {
        int v37 = a3[30];
        if (v37 <= -9)
        {
          if (aj_istream_fill_buf((uint64_t)v8, -9)) {
            return 9;
          }
          int v37 = a3[30];
          if (v37 < -8) {
            return 9;
          }
        }
        unsigned int v38 = *v8;
        if ((*v8 & 0x80000000) != 0)
        {
          uint64_t v39 = *v13;
          int v40 = *(__int16 *)(a4 + 2 * v39);
          if (v40 > 0) {
            __int16 v41 = 1;
          }
          else {
            __int16 v41 = -1;
          }
          *(_WORD *)(a4 + 2 * v39) = v40 + (v41 << a3[15]);
        }
        a3[24] = 2 * v38;
        a3[30] = v37 - 1;
      }
      else
      {
        BOOL v42 = __OFSUB__(v32--, 1);
        if (v32 < 0 != v42) {
          break;
        }
      }
      ++v13;
    }
    while (v13 <= v12);
    if (v36)
    {
      if (v13 > v12) {
        uint64_t v13 = v12;
      }
      *(_WORD *)(a4 + 2 * *v13) = v36;
    }
    ++v13;
  }
  while (v13 <= v12);
  if (a3[20]) {
    goto LABEL_2;
  }
LABEL_28:
  uint64_t v25 = 0;
  ++a3[19];
  return v25;
}

uint64_t aj_baseline_multiscan_decode_scan(void *a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v6 = a3 + 24;
  int v5 = *a3;
  if ((int)*a3 < 1)
  {
LABEL_50:
    uint64_t v42 = 0;
    ++a3[19];
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v46 = a4;
    uint64_t v44 = a2;
    while (1)
    {
      uint64_t v9 = (int)a3[v8 + 1];
      uint64_t v10 = a1[196 * (int)v9 + 112];
      if (v5 == 1) {
        break;
      }
      int v50 = *(_DWORD *)(*a1 + 4 * v9 + 32) * *(_DWORD *)(*a1 + 4 * v9 + 16);
      if (v50 >= 1) {
        goto LABEL_6;
      }
LABEL_49:
      if (++v8 >= v5) {
        goto LABEL_50;
      }
    }
    int v50 = 1;
LABEL_6:
    uint64_t v45 = v8;
    int v11 = 0;
    int v12 = (_DWORD *)(a2 + 4 * v9 + 8);
    uint64_t v13 = (int *)a1 + v9 + 1617;
    int v14 = &a3[v9];
    uint64_t v15 = v14 + 5;
    uint64_t v16 = v14 + 9;
    unsigned int v51 = v12;
    int v48 = v14 + 5;
    int v49 = v13;
    __int16 v47 = v14 + 9;
LABEL_7:
    int v17 = (__int16 *)(a4 + ((*v13 + (uint64_t)v11) << 7));
    uint64_t v18 = *(void *)&a3[4 * *v15 + 54];
    uint64_t v19 = *(void *)&a3[4 * *v16 + 56];
    __int16 *v17 = *v12;
    int v20 = a3[30];
    if (v20 <= -2)
    {
      uint64_t v21 = aj_istream_fill_buf((uint64_t)v6, -9);
      if (v21)
      {
LABEL_53:
        uint64_t v42 = v21;
LABEL_55:
        aj_log_error(0, "Unable to read more data");
        return v42;
      }
      int v20 = a3[30];
      int v12 = v51;
      if (v20 < -8)
      {
LABEL_54:
        uint64_t v42 = 7;
        goto LABEL_55;
      }
    }
    char v52 = 0;
    unint64_t v22 = *v6;
    unsigned int v23 = *(unsigned __int16 *)(v18 + ((v22 >> 23) & 0x1FE) + 272);
    if (*(_WORD *)(v18 + ((v22 >> 23) & 0x1FE) + 272))
    {
      unsigned int v24 = v20 + 9;
      if (v20 >= 0) {
        unsigned int v24 = 8;
      }
      if (v24 < v23 >> 8) {
        return 7;
      }
      a3[24] = v22 << SBYTE1(v23);
      a3[30] = v20 - (v23 >> 8);
      char v52 = v23;
    }
    else
    {
      uint64_t v25 = prog_huff_decode_loop(v18, v6, &v52);
      if (v25) {
        return v25;
      }
      LOBYTE(v23) = v52;
      int v12 = v51;
    }
    if (!(_BYTE)v23)
    {
      __int16 v31 = *v17;
      goto LABEL_26;
    }
    int v26 = a3[30];
    int v27 = v23;
    int v28 = v23 - 9;
    if (v26 >= v28 || !aj_istream_fill_buf((uint64_t)v6, -9) && (int v26 = a3[30], v26 >= v28))
    {
      int v29 = a3[24];
      a3[24] = v29 << v27;
      a3[30] = v26 - v27;
      if (v29 >= 0) {
        int v30 = (-1 << v27) + 1;
      }
      else {
        LOWORD(v30) = 0;
      }
      __int16 v31 = *v17 + v30 + (v29 >> -(char)v27);
      __int16 *v17 = v31;
      int v12 = v51;
LABEL_26:
      *int v12 = v31;
      int v32 = 1;
      while (1)
      {
        int v33 = a3[30];
        if (v33 <= -2)
        {
          uint64_t v21 = aj_istream_fill_buf((uint64_t)v6, -9);
          if (v21) {
            goto LABEL_53;
          }
          int v33 = a3[30];
          if (v33 < -8) {
            goto LABEL_54;
          }
        }
        unint64_t v34 = *v6;
        unsigned int v35 = *(unsigned __int16 *)(v19 + ((v34 >> 23) & 0x1FE) + 272);
        if (*(_WORD *)(v19 + ((v34 >> 23) & 0x1FE) + 272))
        {
          unsigned int v36 = v33 + 9;
          if (v33 >= 0) {
            unsigned int v36 = 8;
          }
          if (v36 < v35 >> 8) {
            return 7;
          }
          a3[24] = v34 << SBYTE1(v35);
          a3[30] = v33 - (v35 >> 8);
          char v52 = v35;
        }
        else
        {
          uint64_t v25 = prog_huff_decode_loop(v19, v6, &v52);
          if (v25) {
            return v25;
          }
          LOBYTE(v35) = v52;
        }
        int v37 = v32 + ((v35 & 0xF0) >> 4);
        int v38 = v35 & 0xF;
        if ((v35 & 0xF) != 0)
        {
          int v39 = a3[30];
          if (v39 < v38 - 9)
          {
            if (aj_istream_fill_buf((uint64_t)v6, -9)) {
              return 9;
            }
            int v39 = a3[30];
            if (v39 < v38 - 9) {
              return 9;
            }
          }
          int v40 = a3[24];
          a3[24] = v40 << v38;
          a3[30] = v39 - v38;
          int v41 = (-1 << v38) | 1;
          if (v40 < 0) {
            LOWORD(v41) = 0;
          }
          v17[*(int *)(v10 + 4 * v37)] = v41 + (v40 >> -(char)v38);
        }
        else
        {
          if (v35 < 0x10u) {
            goto LABEL_47;
          }
          if (v35 >> 4 != 15)
          {
            uint64_t v42 = 7;
            aj_log_error(0, "Illegal huffman symbol.");
            return v42;
          }
        }
        int v32 = v37 + 1;
        if (v37 >= 63)
        {
LABEL_47:
          ++v11;
          a4 = v46;
          uint64_t v16 = v47;
          int v12 = v51;
          uint64_t v15 = v48;
          uint64_t v13 = v49;
          if (v11 != v50) {
            goto LABEL_7;
          }
          int v5 = *a3;
          a2 = v44;
          uint64_t v8 = v45;
          goto LABEL_49;
        }
      }
    }
    return 9;
  }
  return v42;
}

uint64_t aj_mosquito_spray_enable(uint64_t a1)
{
  aj_init_QT_aanIDCT(aj_mosquito_spray_enable_qt_100, (_DWORD *)(a1 + 1044), 1, *(int **)(a1 + 704));
  uint64_t result = aj_dct_prescale_qtable((uint64_t)aj_mosquito_spray_enable_qt_100, a1 + 1300);
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(a1 + 704);
  do
  {
    *(_WORD *)(a1 + 2 * *(int *)(v4 + v3) + 1440) = ((*(_DWORD *)(a1 + 48 + v3) + 2048) >> 12) / 2;
    v3 += 4;
  }
  while (v3 != 256);
  *(unsigned char *)(a1 + 1040) = 1;
  return result;
}

void aj_rotate_ip(char *a1, void *a2, int a3, int a4, int a5, int a6)
{
  if (a5 == 180)
  {
    switch(a6)
    {
      case 1:
        rotate180_1bpp(a1, a3, a4);
        break;
      case 2:
        rotate180_2bpp(a1, a3, a4);
        break;
      case 3:
        rotate180_3bpp(a1, a3, a4);
        break;
      case 4:
        rotate180_4bpp(a1, a3, a4);
        break;
      default:
        return;
    }
  }
  else
  {
    bzero(a2, a4 * a3 / 8 + 1);
    int v14 = a6 - 1;
    switch(v14)
    {
      case 0:
        transpose_1bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 1:
        transpose_2bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 2:
        transpose_3bpp((uint64_t)a1, (uint64_t)a2, a3, a4);
        break;
      case 3:
        transpose_4bpp((uint64_t)a1, (uint64_t)a2, a3, a4, v12, v13);
        break;
      default:
        break;
    }
    if (a5 == 90)
    {
      switch(v14)
      {
        case 0:
          if (a4 >= 1)
          {
            uint64_t v15 = 0;
            if (a3 >= 0) {
              int v16 = a3;
            }
            else {
              int v16 = a3 + 1;
            }
            int v17 = v16 >> 1;
            uint64_t v18 = (uint64_t)&a1[a3 - 1];
            do
            {
              if (a3 >= 2)
              {
                uint64_t v19 = &a1[v15 * a3];
                int v20 = (char *)v18;
                int v21 = v17;
                do
                {
                  char v22 = *v19;
                  *v19++ = *v20;
                  *v20-- = v22;
                  --v21;
                }
                while (v21);
              }
              ++v15;
              v18 += a3;
            }
            while (v15 != a4);
          }
          break;
        case 1:
          mirror_horizontal_2bpp((uint64_t)a1, a4, a3);
          break;
        case 2:
          mirror_horizontal_3bpp((uint64_t)a1, a4, a3);
          break;
        case 3:
          mirror_horizontal_4bpp((uint64_t)a1, a4, a3);
          break;
        default:
          return;
      }
    }
    else
    {
      switch(v14)
      {
        case 0:
          mirror_vertical_1bpp((uint64_t)a1, a4, a3);
          break;
        case 1:
          mirror_vertical_2bpp((uint64_t)a1, a4, a3);
          break;
        case 2:
          mirror_vertical_3bpp((uint64_t)a1, a4, a3);
          break;
        case 3:
          mirror_vertical_4bpp((uint64_t)a1, a4, a3);
          break;
        default:
          return;
      }
    }
  }
}

char *rotate180_1bpp(char *result, int a2, int a3)
{
  uint64_t v3 = &result[a3 * a2 - 1];
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 1;
  }
  if (a2 >= 2)
  {
    int v5 = 0;
    int v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        int v7 = a3;
        do
        {
          char v8 = *result;
          *result++ = *v3;
          *v3-- = v8;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if (a2)
  {
    if (a3 >= 0) {
      int v9 = a3;
    }
    else {
      int v9 = a3 + 1;
    }
    if (a3 >= 2)
    {
      int v10 = v9 >> 1;
      do
      {
        char v11 = *result;
        *result++ = *v3;
        *v3-- = v11;
        --v10;
      }
      while (v10);
    }
  }
  return result;
}

char *rotate180_2bpp(char *result, int a2, int a3)
{
  uint64_t v3 = &result[2 * a2 * a3 - 2];
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 1;
  }
  if (a2 >= 2)
  {
    int v5 = 0;
    int v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        int v7 = a3;
        do
        {
          char v8 = *result;
          *uint64_t result = *v3;
          char *v3 = v8;
          char v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          result += 2;
          v3 -= 2;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if (a2)
  {
    if (a3 >= 0) {
      int v10 = a3;
    }
    else {
      int v10 = a3 + 1;
    }
    if (a3 >= 2)
    {
      int v11 = v10 >> 1;
      do
      {
        char v12 = *result;
        *uint64_t result = *v3;
        char *v3 = v12;
        char v13 = result[1];
        result[1] = v3[1];
        v3[1] = v13;
        result += 2;
        v3 -= 2;
        --v11;
      }
      while (v11);
    }
  }
  return result;
}

char *rotate180_3bpp(char *result, int a2, int a3)
{
  uint64_t v3 = &result[3 * a2 * a3 - 3];
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 1;
  }
  if (a2 >= 2)
  {
    int v5 = 0;
    int v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        int v7 = a3;
        do
        {
          char v8 = *result;
          *uint64_t result = *v3;
          char *v3 = v8;
          char v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          char v10 = result[2];
          result[2] = v3[2];
          v3[2] = v10;
          result += 3;
          v3 -= 3;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if (a2)
  {
    if (a3 >= 0) {
      int v11 = a3;
    }
    else {
      int v11 = a3 + 1;
    }
    if (a3 >= 2)
    {
      int v12 = v11 >> 1;
      do
      {
        char v13 = *result;
        *uint64_t result = *v3;
        char *v3 = v13;
        char v14 = result[1];
        result[1] = v3[1];
        v3[1] = v14;
        char v15 = result[2];
        result[2] = v3[2];
        v3[2] = v15;
        result += 3;
        v3 -= 3;
        --v12;
      }
      while (v12);
    }
  }
  return result;
}

char *rotate180_4bpp(char *result, int a2, int a3)
{
  uint64_t v3 = &result[4 * a2 * a3 - 4];
  if (a2 >= 0) {
    int v4 = a2;
  }
  else {
    int v4 = a2 + 1;
  }
  if (a2 >= 2)
  {
    int v5 = 0;
    int v6 = v4 >> 1;
    do
    {
      if (a3 >= 1)
      {
        int v7 = a3;
        do
        {
          char v8 = *result;
          *uint64_t result = *v3;
          char *v3 = v8;
          char v9 = result[1];
          result[1] = v3[1];
          v3[1] = v9;
          char v10 = result[2];
          result[2] = v3[2];
          v3[2] = v10;
          char v11 = result[3];
          result[3] = v3[3];
          v3[3] = v11;
          result += 4;
          v3 -= 4;
          --v7;
        }
        while (v7);
      }
      ++v5;
    }
    while (v5 != v6);
  }
  if (a2)
  {
    if (a3 >= 0) {
      int v12 = a3;
    }
    else {
      int v12 = a3 + 1;
    }
    if (a3 >= 2)
    {
      int v13 = v12 >> 1;
      do
      {
        char v14 = *result;
        *uint64_t result = *v3;
        char *v3 = v14;
        char v15 = result[1];
        result[1] = v3[1];
        v3[1] = v15;
        char v16 = result[2];
        result[2] = v3[2];
        v3[2] = v16;
        char v17 = result[3];
        result[3] = v3[3];
        v3[3] = v17;
        result += 4;
        v3 -= 4;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t transpose_1bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = v4 * a4;
        do
        {
          uint64_t v8 = v6 + v7;
          uint64_t v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7)) {
            uint64_t v9 = v6 + v7;
          }
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            char v10 = *(unsigned char *)(result + v8);
            uint64_t v11 = v6 + v7;
            do
            {
              uint64_t v12 = a4 * a3 - 1;
              if (v11 != v5) {
                uint64_t v12 = v11 * a3 % v5;
              }
              char v13 = *(unsigned char *)(result + v12);
              *(unsigned char *)(result + v12) = v10;
              *(unsigned char *)(a2 + v12 / 8) |= 1 << (v12 % 8);
              uint64_t v11 = v12;
              char v10 = v13;
            }
            while (v12 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_2bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = v4 * a4;
        do
        {
          uint64_t v8 = v6 + v7;
          uint64_t v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7)) {
            uint64_t v9 = v6 + v7;
          }
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            char v10 = (char *)(result + 2 * v8);
            char v11 = *v10;
            char v12 = v10[1];
            uint64_t v13 = v6 + v7;
            do
            {
              uint64_t v14 = a4 * a3 - 1;
              if (v13 != v5) {
                uint64_t v14 = v13 * a3 % v5;
              }
              char v15 = (char *)(result + 2 * v14);
              char v16 = *v15;
              char v17 = v15[1];
              *char v15 = v11;
              v15[1] = v12;
              *(unsigned char *)(a2 + v14 / 8) |= 1 << (v14 % 8);
              uint64_t v13 = v14;
              char v11 = v16;
              char v12 = v17;
            }
            while (v14 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_3bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = v4 * a4;
        do
        {
          uint64_t v8 = v6 + v7;
          uint64_t v9 = v6 + v7 + 7;
          if (v6 + v7 < 0 == __OFADD__(v6, v7)) {
            uint64_t v9 = v6 + v7;
          }
          if (((*(unsigned __int8 *)(a2 + (v9 >> 3)) >> (v8 - 8 * (v9 >> 3))) & 1) == 0)
          {
            char v10 = (char *)(result + 3 * v8);
            char v11 = *v10;
            char v12 = v10[1];
            char v13 = v10[2];
            uint64_t v14 = v6 + v7;
            do
            {
              uint64_t v15 = a4 * a3 - 1;
              if (v14 != v5) {
                uint64_t v15 = v14 * a3 % v5;
              }
              char v16 = (char *)(result + 3 * v15);
              char v17 = *v16;
              char v18 = v16[1];
              char v19 = v16[2];
              char *v16 = v11;
              v16[1] = v12;
              v16[2] = v13;
              *(unsigned char *)(a2 + v15 / 8) |= 1 << (v15 % 8);
              uint64_t v14 = v15;
              char v11 = v17;
              char v12 = v18;
              char v13 = v19;
            }
            while (v15 != v8);
          }
          ++v6;
        }
        while (v6 != a4);
      }
      ++v4;
    }
    while (v4 != a3);
  }
  return result;
}

uint64_t transpose_4bpp(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int16x8_t a5, uint8x8_t a6)
{
  if (a3 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a4 * a3 - 1;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v8 = 0;
        uint64_t v9 = v6 * a4;
        do
        {
          uint64_t v10 = v8 + v9;
          uint64_t v11 = v8 + v9 + 7;
          if (v8 + v9 < 0 == __OFADD__(v8, v9)) {
            uint64_t v11 = v8 + v9;
          }
          if (((*(unsigned __int8 *)(a2 + (v11 >> 3)) >> (v10 - 8 * (v11 >> 3))) & 1) == 0)
          {
            a5.i32[0] = *(_DWORD *)(result + 4 * v10);
            a5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a5.i8);
            uint64_t v12 = v8 + v9;
            do
            {
              uint64_t v13 = a4 * a3 - 1;
              if (v12 != v7) {
                uint64_t v13 = v12 * a3 % v7;
              }
              a6.i32[0] = *(_DWORD *)(result + 4 * v13);
              *(_DWORD *)(result + 4 * v13) = vmovn_s16(a5).u32[0];
              a5 = (int16x8_t)vmovl_u8(a6);
              *(unsigned char *)(a2 + v13 / 8) |= 1 << (v13 % 8);
              uint64_t v12 = v13;
            }
            while (v13 != v10);
          }
          ++v8;
        }
        while (v8 != a4);
      }
      ++v6;
    }
    while (v6 != a3);
  }
  return result;
}

uint64_t mirror_horizontal_1bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = 0;
    if (a3 >= 0) {
      int v4 = a3;
    }
    else {
      int v4 = a3 + 1;
    }
    int v5 = v4 >> 1;
    uint64_t v6 = result + a3 - 1;
    do
    {
      if (a3 >= 2)
      {
        uint64_t v7 = (char *)(result + v3 * a3);
        uint64_t v8 = (char *)v6;
        int v9 = v5;
        do
        {
          char v10 = *v7;
          *v7++ = *v8;
          *v8-- = v10;
          --v9;
        }
        while (v9);
      }
      ++v3;
      v6 += a3;
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_2bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = 0;
    int v4 = 2 * a3;
    if (a3 >= 0) {
      int v5 = a3;
    }
    else {
      int v5 = a3 + 1;
    }
    int v6 = v5 >> 1;
    do
    {
      int v7 = v3++;
      if (a3 >= 2)
      {
        uint64_t v8 = (char *)(result + v4 * (int)v3 - 2);
        int v9 = (char *)(result + v4 * v7);
        int v10 = v6;
        do
        {
          char v11 = *v9;
          *int v9 = *v8;
          *uint64_t v8 = v11;
          char v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          v9 += 2;
          v8 -= 2;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_3bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = 0;
    int v4 = 3 * a3;
    if (a3 >= 0) {
      int v5 = a3;
    }
    else {
      int v5 = a3 + 1;
    }
    int v6 = v5 >> 1;
    do
    {
      int v7 = v3++;
      if (a3 >= 2)
      {
        uint64_t v8 = (char *)(result + v4 * (int)v3 - 3);
        int v9 = (char *)(result + v4 * v7);
        int v10 = v6;
        do
        {
          char v11 = *v9;
          *int v9 = *v8;
          *uint64_t v8 = v11;
          char v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          char v13 = v9[2];
          v9[2] = v8[2];
          v8[2] = v13;
          v9 += 3;
          v8 -= 3;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_horizontal_4bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 1)
  {
    uint64_t v3 = 0;
    int v4 = 4 * a3;
    if (a3 >= 0) {
      int v5 = a3;
    }
    else {
      int v5 = a3 + 1;
    }
    int v6 = v5 >> 1;
    do
    {
      int v7 = v3++;
      if (a3 >= 2)
      {
        uint64_t v8 = (char *)(result + v4 * (int)v3 - 4);
        int v9 = (char *)(result + v4 * v7);
        int v10 = v6;
        do
        {
          char v11 = *v9;
          *int v9 = *v8;
          *uint64_t v8 = v11;
          char v12 = v9[1];
          v9[1] = v8[1];
          v8[1] = v12;
          char v13 = v9[2];
          v9[2] = v8[2];
          v8[2] = v13;
          char v14 = v9[3];
          v9[3] = v8[3];
          v8[3] = v14;
          v9 += 4;
          v8 -= 4;
          --v10;
        }
        while (v10);
      }
    }
    while (v3 != a2);
  }
  return result;
}

uint64_t mirror_vertical_1bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = 0;
    do
    {
      if (a3 >= 1)
      {
        int v4 = (char *)(result + (~v3 + a2) * a3);
        int v5 = (char *)(result + v3 * a3);
        int v6 = a3;
        do
        {
          char v7 = *v5;
          *v5++ = *v4;
          *v4++ = v7;
          --v6;
        }
        while (v6);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_2bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = 0;
    int v4 = 2 * a3;
    do
    {
      if (a3 >= 1)
      {
        int v5 = (char *)(result + v4 * (~v3 + a2));
        int v6 = (char *)(result + v4 * (int)v3);
        int v7 = a3;
        do
        {
          char v8 = *v6;
          *int v6 = *v5;
          *int v5 = v8;
          char v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          v6 += 2;
          v5 += 2;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_3bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = 0;
    int v4 = 3 * a3;
    do
    {
      if (a3 >= 1)
      {
        int v5 = (char *)(result + v4 * (~v3 + a2));
        int v6 = (char *)(result + v4 * (int)v3);
        int v7 = a3;
        do
        {
          char v8 = *v6;
          *int v6 = *v5;
          *int v5 = v8;
          char v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          char v10 = v6[2];
          v6[2] = v5[2];
          v5[2] = v10;
          v6 += 3;
          v5 += 3;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t mirror_vertical_4bpp(uint64_t result, int a2, int a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = 0;
    int v4 = 4 * a3;
    do
    {
      if (a3 >= 1)
      {
        int v5 = (char *)(result + v4 * (~v3 + a2));
        int v6 = (char *)(result + v4 * (int)v3);
        int v7 = a3;
        do
        {
          char v8 = *v6;
          *int v6 = *v5;
          *int v5 = v8;
          char v9 = v6[1];
          v6[1] = v5[1];
          v5[1] = v9;
          char v10 = v6[2];
          v6[2] = v5[2];
          v5[2] = v10;
          char v11 = v6[3];
          v6[3] = v5[3];
          v5[3] = v11;
          v6 += 4;
          v5 += 4;
          --v7;
        }
        while (v7);
      }
      ++v3;
    }
    while (v3 != a2 >> 1);
  }
  return result;
}

uint64_t applejpeg_bitmap_rotate_inplace(void *a1, int32x2_t *a2, uint64_t a3)
{
  if (!a1 || !*a1 || !a1[1])
  {
    aj_log_error(0, "Cannot accept NULL arguments");
    return 8;
  }
  uint64_t v6 = check_rotinput((uint64_t)a2, a3);
  if (!v6)
  {
    if (a3 == 180)
    {
      if (!a2)
      {
        aj_log_error(0, "bitmap struct pointer is NULL");
        return 8;
      }
    }
    else
    {
      int v8 = a2[5].i32[0];
      int v9 = a2[5].i32[1];
      if (v8 >= -1) {
        unsigned int v10 = v8 + 1;
      }
      else {
        unsigned int v10 = v8 + 2;
      }
      unsigned int v11 = v10 >> 1;
      if (v9 >= -1) {
        unsigned int v12 = v9 + 1;
      }
      else {
        unsigned int v12 = v9 + 2;
      }
      int v13 = (int)(4 * v11 * (v12 >> 1)) / 8;
      BOOL v14 = __CFADD__(v13, 1);
      int v15 = v13 + 1;
      if (!v14)
      {
        size_t v17 = v15;
        char v18 = (void *)((uint64_t (*)(void, void))*a1)(v15, a1[2]);
        if (!v18)
        {
          aj_log_error(0, "Could not allocate rotation workmemory");
          return 6;
        }
        char v16 = v18;
        bzero(v18, v17);
LABEL_22:
        uint64_t v19 = 0;
        int v20 = (char *)*a2;
        int v21 = a2[5].i32[0];
        int v22 = a2[5].i32[1];
        int v23 = v21 + 2;
        if (v21 >= -1) {
          int v23 = v21 + 1;
        }
        int v24 = v23 >> 1;
        int v25 = 2 * v24;
        int v26 = v22 + 2;
        if (v22 >= -1) {
          int v26 = v22 + 1;
        }
        int v27 = 2 * (v26 >> 1);
        unsigned int v28 = a2[6].u32[0];
        if (v28 <= 0xD)
        {
          if (((1 << v28) & 0x300) != 0)
          {
            uint64_t v19 = (uint64_t)&v20[v25 * (uint64_t)v22];
          }
          else if (((1 << v28) & 0xC00) != 0)
          {
            uint64_t v19 = (uint64_t)&v20[v27 * (uint64_t)v25];
          }
          else if (((1 << v28) & 0x3000) != 0)
          {
            uint64_t v19 = (uint64_t)&v20[v27 * v21];
          }
        }
        if ((int)a3 > 179)
        {
          if (a3 == 270)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_3bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_vertical_3bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 1u:
              case 2u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_2bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                int v62 = a2[5].i32[0];
                int v63 = a2[5].i32[1];
                uint64_t v64 = (uint64_t)v20;
                goto LABEL_117;
              case 3u:
              case 4u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_4bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0], v65, v66);
                mirror_vertical_4bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 5u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_vertical_1bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 7u:
LABEL_96:
                aj_log_error(0, "Format not yet supported.");
                uint64_t v6 = 3;
                goto LABEL_131;
              case 8u:
              case 9u:
                size_t v67 = v27 * v25 / 8 + 1;
                bzero(v16, v67);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], v25);
                mirror_vertical_1bpp((uint64_t)v20, v25, a2[5].i32[1]);
                bzero(v16, v67);
                int v68 = a2[5].i32[0];
                if (v68 >= -1) {
                  int v69 = v68 + 1;
                }
                else {
                  int v69 = v68 + 2;
                }
                transpose_2bpp(v19, (uint64_t)v16, a2[5].i32[1], (uint64_t)v69 >> 1);
                int v70 = a2[5].i32[0];
                if (v70 >= -1) {
                  int v71 = v70 + 1;
                }
                else {
                  int v71 = v70 + 2;
                }
                mirror_vertical_2bpp(v19, v71 >> 1, a2[5].i32[1]);
LABEL_104:
                if (a2[6].i32[0] == 8) {
                  int v72 = 12;
                }
                else {
                  int v72 = 13;
                }
                goto LABEL_129;
              case 0xAu:
              case 0xBu:
                size_t v73 = v27 * v25 / 8 + 1;
                bzero(v16, v73);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, v25);
                mirror_vertical_1bpp((uint64_t)v20, v25, v27);
                bzero(v16, v73);
                int v75 = a2[5].i32[0];
                int v74 = a2[5].i32[1];
                if (v74 >= -1) {
                  int v76 = v74 + 1;
                }
                else {
                  int v76 = v74 + 2;
                }
                uint64_t v77 = (uint64_t)v76 >> 1;
                int v78 = v75 + 2;
                if (v75 >= -1) {
                  int v78 = v75 + 1;
                }
                transpose_2bpp(v19, (uint64_t)v16, v77, (uint64_t)v78 >> 1);
                int v79 = a2[5].i32[0];
                int v80 = a2[5].i32[1];
                if (v79 >= -1) {
                  int v81 = v79 + 1;
                }
                else {
                  int v81 = v79 + 2;
                }
                int v62 = v81 >> 1;
                int v82 = v80 + 2;
                if (v80 >= -1) {
                  int v82 = v80 + 1;
                }
                int v63 = v82 >> 1;
                uint64_t v64 = v19;
LABEL_117:
                mirror_vertical_2bpp(v64, v62, v63);
                goto LABEL_130;
              case 0xCu:
              case 0xDu:
                size_t v83 = v27 * v25 / 8 + 1;
                bzero(v16, v83);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, a2[5].i32[0]);
                mirror_vertical_1bpp((uint64_t)v20, a2[5].i32[0], v27);
                bzero(v16, v83);
                int v84 = a2[5].i32[1];
                if (v84 >= -1) {
                  int v85 = v84 + 1;
                }
                else {
                  int v85 = v84 + 2;
                }
                transpose_2bpp(v19, (uint64_t)v16, (uint64_t)v85 >> 1, a2[5].i32[0]);
                int v86 = a2[5].i32[1];
                if (v86 >= -1) {
                  int v87 = v86 + 1;
                }
                else {
                  int v87 = v86 + 2;
                }
                mirror_vertical_2bpp(v19, a2[5].i32[0], v87 >> 1);
LABEL_125:
                if (a2[6].i32[0] == 12) {
                  int v72 = 8;
                }
                else {
                  int v72 = 9;
                }
LABEL_129:
                a2[6].i32[0] = v72;
                goto LABEL_130;
              default:
LABEL_47:
                aj_log_error(0, "Unrecognized or unimplemented format.");
                uint64_t v6 = 4;
                goto LABEL_131;
            }
          }
          if (a3 == 180)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                rotate180_3bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 1u:
              case 2u:
                uint64_t v54 = (char *)*a2;
                goto LABEL_92;
              case 3u:
              case 4u:
                rotate180_4bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 5u:
                rotate180_1bpp(*(char **)a2, v22, v21);
                goto LABEL_93;
              case 7u:
                rotate180_4bpp(*(char **)a2, v22, v24);
                int v88 = a2[5].i32[1];
                if (v88 < 1) {
                  goto LABEL_93;
                }
                int v89 = 0;
                int v90 = a2[5].i32[0];
                int v91 = v90 + 2;
                if (v90 >= -1) {
                  int v91 = v90 + 1;
                }
                int v92 = v91 >> 1;
                if (v92 <= 1) {
                  int v92 = 1;
                }
                do
                {
                  if (v90 >= 1)
                  {
                    int v93 = v92;
                    do
                    {
                      char v94 = *v20;
                      char *v20 = v20[2];
                      v20[2] = v94;
                      v20 += 4;
                      --v93;
                    }
                    while (v93);
                  }
                  uint64_t v6 = 0;
                  ++v89;
                }
                while (v89 != v88);
                goto LABEL_131;
              case 8u:
              case 9u:
                rotate180_1bpp(*(char **)a2, v22, 2 * v24);
                int v55 = a2[5].i32[0];
                int v22 = a2[5].i32[1];
                if (v55 >= -1) {
                  int v56 = v55 + 1;
                }
                else {
                  int v56 = v55 + 2;
                }
                goto LABEL_86;
              case 0xAu:
              case 0xBu:
                rotate180_1bpp(*(char **)a2, v27, 2 * v24);
                int v58 = a2[5].i32[0];
                int v57 = a2[5].i32[1];
                if (v57 >= -1) {
                  int v59 = v57 + 1;
                }
                else {
                  int v59 = v57 + 2;
                }
                int v22 = v59 >> 1;
                int v56 = v58 + 2;
                if (v58 >= -1) {
                  int v56 = v58 + 1;
                }
LABEL_86:
                int v21 = v56 >> 1;
                goto LABEL_91;
              case 0xCu:
              case 0xDu:
                rotate180_1bpp(*(char **)a2, v27, v21);
                int v21 = a2[5].i32[0];
                int v60 = a2[5].i32[1];
                if (v60 >= -1) {
                  int v61 = v60 + 1;
                }
                else {
                  int v61 = v60 + 2;
                }
                int v22 = v61 >> 1;
LABEL_91:
                uint64_t v54 = (char *)v19;
LABEL_92:
                rotate180_2bpp(v54, v22, v21);
LABEL_93:
                uint64_t v6 = 0;
                break;
              default:
                goto LABEL_47;
            }
            goto LABEL_131;
          }
        }
        else
        {
          if (!a3)
          {
            uint64_t v6 = a3;
            goto LABEL_131;
          }
          if (a3 == 90)
          {
            switch(v28)
            {
              case 0u:
              case 6u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_3bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_horizontal_3bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 1u:
              case 2u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_2bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                int v29 = a2[5].i32[0];
                int v30 = a2[5].i32[1];
                uint64_t v31 = (uint64_t)v20;
                break;
              case 3u:
              case 4u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_4bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0], v32, v33);
                mirror_horizontal_4bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 5u:
                bzero(v16, v22 * v21 / 8 + 1);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], a2[5].i32[0]);
                mirror_horizontal_1bpp((uint64_t)v20, a2[5].i32[0], a2[5].i32[1]);
                goto LABEL_130;
              case 7u:
                goto LABEL_96;
              case 8u:
              case 9u:
                size_t v34 = v27 * v25 / 8 + 1;
                bzero(v16, v34);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, a2[5].i32[1], v25);
                mirror_horizontal_1bpp((uint64_t)v20, v25, a2[5].i32[1]);
                bzero(v16, v34);
                int v35 = a2[5].i32[0];
                if (v35 >= -1) {
                  int v36 = v35 + 1;
                }
                else {
                  int v36 = v35 + 2;
                }
                transpose_2bpp(v19, (uint64_t)v16, a2[5].i32[1], (uint64_t)v36 >> 1);
                int v37 = a2[5].i32[0];
                if (v37 >= -1) {
                  int v38 = v37 + 1;
                }
                else {
                  int v38 = v37 + 2;
                }
                mirror_horizontal_2bpp(v19, v38 >> 1, a2[5].i32[1]);
                goto LABEL_104;
              case 0xAu:
              case 0xBu:
                size_t v39 = v27 * v25 / 8 + 1;
                bzero(v16, v39);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, v25);
                mirror_horizontal_1bpp((uint64_t)v20, v25, v27);
                bzero(v16, v39);
                int v41 = a2[5].i32[0];
                int v40 = a2[5].i32[1];
                if (v40 >= -1) {
                  int v42 = v40 + 1;
                }
                else {
                  int v42 = v40 + 2;
                }
                uint64_t v43 = (uint64_t)v42 >> 1;
                int v44 = v41 + 2;
                if (v41 >= -1) {
                  int v44 = v41 + 1;
                }
                transpose_2bpp(v19, (uint64_t)v16, v43, (uint64_t)v44 >> 1);
                int v45 = a2[5].i32[0];
                int v46 = a2[5].i32[1];
                if (v45 >= -1) {
                  int v47 = v45 + 1;
                }
                else {
                  int v47 = v45 + 2;
                }
                int v29 = v47 >> 1;
                int v48 = v46 + 2;
                if (v46 >= -1) {
                  int v48 = v46 + 1;
                }
                int v30 = v48 >> 1;
                uint64_t v31 = v19;
                break;
              case 0xCu:
              case 0xDu:
                size_t v49 = v27 * v25 / 8 + 1;
                bzero(v16, v49);
                transpose_1bpp((uint64_t)v20, (uint64_t)v16, v27, a2[5].i32[0]);
                mirror_horizontal_1bpp((uint64_t)v20, a2[5].i32[0], v27);
                bzero(v16, v49);
                int v50 = a2[5].i32[1];
                if (v50 >= -1) {
                  int v51 = v50 + 1;
                }
                else {
                  int v51 = v50 + 2;
                }
                transpose_2bpp(v19, (uint64_t)v16, (uint64_t)v51 >> 1, a2[5].i32[0]);
                int v52 = a2[5].i32[1];
                if (v52 >= -1) {
                  int v53 = v52 + 1;
                }
                else {
                  int v53 = v52 + 2;
                }
                mirror_horizontal_2bpp(v19, a2[5].i32[0], v53 >> 1);
                goto LABEL_125;
              default:
                goto LABEL_47;
            }
            mirror_horizontal_2bpp(v31, v29, v30);
LABEL_130:
            uint64_t v6 = 0;
            a2[5] = vrev64_s32(a2[5]);
            goto LABEL_131;
          }
        }
        aj_log_error(0, "Rotation must be 0, 90, 180 or 270 degrees.");
        uint64_t v6 = 5;
LABEL_131:
        if (v16) {
          ((void (*)(void *, void))a1[1])(v16, a1[2]);
        }
        return v6;
      }
    }
    char v16 = 0;
    goto LABEL_22;
  }
  return v6;
}

uint64_t check_rotinput(uint64_t a1, uint64_t a2)
{
  if (!a1 || !*(void *)a1)
  {
    uint64_t v3 = 8;
    int v4 = "Cannot accept NULL arguments";
LABEL_8:
    aj_log_error(0, v4);
    return v3;
  }
  uint64_t v3 = 5;
  int v4 = "Unsupported rotation";
  if ((int)a2 > 179)
  {
    if (a2 != 270 && a2 != 180) {
      goto LABEL_8;
    }
    goto LABEL_13;
  }
  if (a2)
  {
    if (a2 != 90) {
      goto LABEL_8;
    }
LABEL_13:
    if (*(_DWORD *)(a1 + 48) != 7) {
      return 0;
    }
    uint64_t v3 = 3;
    aj_log_error(0, "Unsupported format for rotation");
    return v3;
  }
  return a2;
}

uint64_t applejpeg_bitmap_rotate_to_dst(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a3;
  uint64_t result = check_rotinput(a1, a3);
  if (!result)
  {
    if (a2 && *(void *)a2)
    {
      int v7 = (int *)(a1 + 40);
      int v8 = 4;
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
          int v8 = 3;
          goto LABEL_20;
        case 1:
        case 2:
          int v8 = 2;
          goto LABEL_20;
        case 3:
        case 4:
          goto LABEL_20;
        case 5:
          int v8 = 1;
LABEL_20:
          int v22 = *v7;
          goto LABEL_21;
        case 7:
          int v22 = (*v7 & 1) + *v7;
          int v8 = 2;
LABEL_21:
          int v23 = *(_DWORD *)(a1 + 44);
          if (v23 >= 1)
          {
            int v24 = 0;
            int v25 = *(char **)a1;
            do
            {
              aj_row_translate(v3, v8, v22, 0, 0, v22, v23, v24, v25, *(void *)a2);
              v25 += v22 * v8;
              ++v24;
            }
            while (v23 != v24);
          }
          goto LABEL_24;
        case 8:
        case 9:
          char v9 = 0;
          int v10 = *(_DWORD *)(a1 + 44);
          int v11 = (*(_DWORD *)(a1 + 40) & 1) + *(_DWORD *)(a1 + 40);
          char v33 = 1;
          goto LABEL_11;
        case 0xA:
        case 0xB:
          int v11 = (*v7 & 1) + *v7;
          char v33 = 1;
          goto LABEL_10;
        case 0xC:
        case 0xD:
          char v33 = 0;
          int v11 = *v7;
LABEL_10:
          int v10 = (*(_DWORD *)(a1 + 44) & 1) + *(_DWORD *)(a1 + 44);
          char v9 = 1;
LABEL_11:
          unsigned int v12 = *(char **)a1;
          int v34 = v11;
          uint64_t v13 = v11;
          if (v10 >= 1)
          {
            int v14 = 0;
            int v15 = *(char **)a1;
            do
            {
              aj_row_translate(v3, 0, v13, 0, 0, v13, v10, v14, v15, *(void *)a2);
              v15 += v13;
              ++v14;
            }
            while (v10 != v14);
          }
          int v16 = v10 >> v9;
          if (v10 >> v9 >= 1)
          {
            size_t v17 = 0;
            int v18 = 0;
            unint64_t v19 = (unint64_t)&v12[v34 * (uint64_t)v10];
            int v20 = (int)v13 >> v33;
            uint64_t v21 = 2 * ((int)v13 >> v33);
            do
            {
              aj_row_translate(v3, 2, v20, 0, 0, v20, v16, v18, v17, v19);
              v17 += v21;
              ++v18;
            }
            while (v16 != v18);
          }
LABEL_24:
          long long v26 = *(_OWORD *)v7;
          long long v27 = *(_OWORD *)(a1 + 56);
          *(_OWORD *)(a2 + 72) = *(_OWORD *)(a1 + 72);
          *(_OWORD *)(a2 + 56) = v27;
          *(_OWORD *)(a2 + 40) = v26;
          long long v28 = *(_OWORD *)(a1 + 88);
          long long v29 = *(_OWORD *)(a1 + 104);
          long long v30 = *(_OWORD *)(a1 + 120);
          *(_OWORD *)(a2 + 136) = *(_OWORD *)(a1 + 136);
          *(_OWORD *)(a2 + 120) = v30;
          *(_OWORD *)(a2 + 104) = v29;
          *(_OWORD *)(a2 + 88) = v28;
          if (v3 == 180 || v3 == 90)
          {
            uint64_t result = 0;
            int v31 = *(_DWORD *)(a1 + 48);
            *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 44);
            *(_DWORD *)(a2 + 44) = *(_DWORD *)(a1 + 40);
            switch(v31)
            {
              case 8:
                uint64_t result = 0;
                int v32 = 12;
                goto LABEL_32;
              case 9:
                uint64_t result = 0;
                int v32 = 13;
                goto LABEL_32;
              case 12:
                uint64_t result = 0;
                int v32 = 8;
                goto LABEL_32;
              case 13:
                uint64_t result = 0;
                int v32 = 9;
LABEL_32:
                *(_DWORD *)(a2 + 48) = v32;
                break;
              default:
                return result;
            }
          }
          else
          {
            uint64_t result = 0;
          }
          break;
        default:
          aj_log_error(0, "Unsupported output format");
          uint64_t result = 5;
          break;
      }
    }
    else
    {
      aj_log_error(0, "Output cannot be NULL");
      return 8;
    }
  }
  return result;
}

uint64_t aj_huffman_decode_ac_s2(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  a3[6] = 0;
  a3[7] = 0;
  LODWORD(v6) = 1;
  uint64_t v7 = a1 + 48;
  uint64_t v8 = *(void *)(a1 + 696);
  unsigned int v9 = *(_DWORD *)a2;
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  uint64_t v11 = *(void *)(a1 + 40) + 400;
  int v12 = *(_DWORD *)(a2 + 24);
  uint64_t v13 = *(_DWORD *)a2 >> 23;
  uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_38:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            uint64_t v41 = v11;
            int v42 = (unsigned int *)a2;
            size_t v39 = a3;
            int v40 = a4;
            uint64_t v37 = a6;
            uint64_t v38 = v7;
            uint64_t v35 = v13;
            uint64_t v36 = v8;
            uint64_t result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if (result) {
              return result;
            }
            LODWORD(v6) = v33;
            int v32 = (int)v33 >> 16;
            uint64_t v13 = v35;
            uint64_t v8 = v36;
            uint64_t v7 = v38;
            a3 = v39;
            a4 = v40;
            uint64_t v11 = v41;
            a2 = (uint64_t)v42;
            unsigned int v10 = v42[7];
            int v12 = v42[6];
            unsigned int v9 = *v42;
            goto LABEL_31;
          }
          int v15 = (int)v14 >> 18;
          unsigned int v16 = v6 + v14;
          if ((v14 & 0x20000) != 0) {
            break;
          }
          if (v15)
          {
            int v17 = *(_DWORD *)(v7 + 4 * v16) * v15;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            uint64_t v13 = v9 >> 23;
            uint64_t v6 = v16 + 1;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17;
            if (v12 < 0) {
              goto LABEL_15;
            }
LABEL_6:
            if ((int)v6 >= 25)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
          else
          {
            if ((_BYTE)v14) {
              uint64_t v6 = v16 + 1;
            }
            else {
              uint64_t v6 = 64;
            }
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0) {
              goto LABEL_15;
            }
            uint64_t v13 = v9 >> 23;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 25)
            {
              *(_DWORD *)a2 = v9;
              *(_DWORD *)(a2 + 24) = v12;
              *a4 = v6;
              return 0;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0) {
          goto LABEL_38;
        }
        int v28 = BYTE1(v14);
        unsigned int v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        uint64_t v6 = v6 + (v29 >> 4);
        uint64_t v14 = v29 & 0xF;
        if (!v14) {
          goto LABEL_32;
        }
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          uint64_t v41 = v11;
          int v42 = (unsigned int *)a2;
          size_t v39 = a3;
          int v40 = a4;
          uint64_t v37 = (v12 + 9);
          uint64_t v38 = v7;
          uint64_t v35 = v6;
          uint64_t v36 = v13;
          uint64_t v33 = v8;
          uint64_t v34 = v14;
          uint64_t result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if (result) {
            return result;
          }
          uint64_t v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          uint64_t v13 = v36;
          uint64_t v7 = v38;
          a3 = v39;
          a4 = v40;
          uint64_t v11 = v41;
          a2 = (uint64_t)v42;
          unsigned int v10 = v42[7];
          int v12 = v42[6];
          unsigned int v9 = *v42;
        }
        v12 -= v14;
        signed int v30 = v9 >> (32 - v14);
        v9 <<= v14;
        int v31 = 1 << (v14 - 1);
        LOWORD(v32) = v30 < v31 ? v30 + 1 - 2 * v31 : (unsigned __int16)v30;
LABEL_31:
        uint64_t v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        uint64_t v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = v14 * v32;
LABEL_32:
        if (v12 < 0) {
          break;
        }
        uint64_t v13 = v9 >> 23;
        uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 25)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
      }
      if (v10) {
        goto LABEL_6;
      }
LABEL_15:
      a6 = *(unsigned int *)(a2 + 32);
      unint64_t v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8) {
        break;
      }
      int v20 = *v19;
      int v21 = v19[1];
      BOOL v23 = v20 == 255;
      int v22 = v21 + (v20 << 8);
      BOOL v23 = v23 || v21 == 255;
      int v24 = v19[2];
      int v25 = v19 + 3;
      a6 = (a6 - 3);
      uint64_t v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255) {
        break;
      }
      int v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(void *)(a2 + 8) = v25;
      v9 |= v14 << v27;
      int v12 = 23 - v27;
      uint64_t v13 = v9 >> 23;
      uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 25)
      {
        *(_DWORD *)a2 = v9;
        *(_DWORD *)(a2 + 24) = v12;
        *a4 = v6;
        return 0;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    uint64_t v41 = v11;
    int v42 = (unsigned int *)a2;
    size_t v39 = a3;
    int v40 = a4;
    uint64_t v37 = a6;
    uint64_t v38 = v7;
    uint64_t v35 = v6;
    uint64_t v36 = v13;
    uint64_t v33 = v8;
    uint64_t v34 = v14;
    uint64_t result = aj_istream_fill_buf(a2, -9);
    if (result) {
      return result;
    }
    uint64_t v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    uint64_t v7 = v38;
    a3 = v39;
    a4 = v40;
    uint64_t v11 = v41;
    a2 = (uint64_t)v42;
    unsigned int v10 = v42[7];
    int v12 = v42[6];
    unsigned int v9 = *v42;
    uint64_t v13 = *v42 >> 23;
    uint64_t v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 25);
  *int v42 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 0;
}

uint64_t sub_2103EBAC0(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, int a5, uint64_t a6, int a7)
{
  *a2 = a7;
  a2[6] = a5;
  *a4 = v7;
  return 7;
}

uint64_t aj_fill_coeffblock_from_scan_properties(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *a1;
  if ((int)v3 >= 1 && (int)v3 <= a3)
  {
    unint64_t v7 = 0;
    while (1)
    {
      signed int v8 = a1[v7 + 1];
      if (v8 > 3
        || v7 && (v8 <= (int)a1[1] || v7 >= 2 && (v8 <= (int)a1[2] || v7 >= 3 && v8 <= (int)a1[3])))
      {
        break;
      }
      if (v3 == ++v7)
      {
        uint64_t v9 = a1[5];
        if (v9 <= 0x3F)
        {
          unsigned int v10 = a1[6];
          if (v10 <= 0x3F)
          {
            BOOL v11 = v10 && v9 == 0;
            if ((!v9 || v3 == 1) && v9 <= v10 && !v11)
            {
              unsigned int v13 = a1[8];
              if (v13 <= 0xD)
              {
                unsigned int v14 = a1[7];
                if (v14 <= 0xD && (!v14 || v14 == v13 + 1))
                {
                  uint64_t v15 = 0;
                  int v16 = (unsigned __int16)(0xFFFF << v13);
                  int v17 = 1 << v13;
                  if (v14) {
                    int v18 = v17;
                  }
                  else {
                    int v18 = v16;
                  }
                  while (v9 > v10)
                  {
LABEL_39:
                    uint64_t v5 = 0;
                    if (++v15 == v3) {
                      return v5;
                    }
                  }
                  unint64_t v19 = (_WORD *)(a2 + 2 * v9 + ((uint64_t)(int)a1[v15 + 1] << 7));
                  int v20 = v10 - v9 + 1;
                  while (1)
                  {
                    int v21 = (unsigned __int16)*v19;
                    if ((v18 & v21) != 0) {
                      break;
                    }
                    *v19++ = v21 | v18;
                    if (!--v20) {
                      goto LABEL_39;
                    }
                  }
                }
              }
            }
          }
        }
        break;
      }
    }
  }
  aj_log_error((uint64_t)"Utils", "The progressive scan set-up is illegal or contains errors");
  return 4;
}

uint64_t aj_fill_coeffblock_from_scan_info(unsigned int *a1, uint64_t a2, int a3)
{
  v9[0] = 0;
  v9[1] = 0;
  uint64_t v5 = *a1;
  unsigned int v8 = v5;
  int32x4_t v6 = vrev64q_s32(*(int32x4_t *)(a1 + 13));
  v6.i64[0] = *(void *)(a1 + 13);
  int32x4_t v10 = v6;
  if ((int)v5 >= 1) {
    memcpy(v9, a1 + 1, 4 * v5);
  }
  return aj_fill_coeffblock_from_scan_properties(&v8, a2, a3);
}

uint64_t estimate_jpeg_size(int a1, int a2)
{
  unint64_t v2 = a2 * (uint64_t)a1;
  if (v2 <= 1) {
    return 1;
  }
  else {
    return v2 >> 1;
  }
}

uint64_t aj_highest_set_bit(unsigned int a1)
{
  unsigned int v1 = 32 - __clz(a1);
  if (a1) {
    return v1;
  }
  else {
    return 0;
  }
}

void aj_clear_blocks(void *a1, int a2)
{
}

uint64_t aj_row_translate(unsigned int a1, int a2, int a3, uint64_t a4, signed int a5, int a6, int a7, int a8, char *a9, unint64_t a10)
{
  BOOL v10 = (a1 & 3) > 1;
  if ((a1 & 2) != 0) {
    int v11 = 90 * (a1 & 3) - 180;
  }
  else {
    int v11 = 90 * (a1 & 3);
  }
  if (v11 == 90) {
    int v12 = a7;
  }
  else {
    int v12 = a3;
  }
  uint64_t v13 = v12 * (uint64_t)a2;
  if (a4) {
    uint64_t v13 = a4;
  }
  if (v11 == 90) {
    int v14 = a3;
  }
  else {
    int v14 = a7;
  }
  if (a5 < 0 || (LODWORD(v15) = a3 - a6, a3 < a6))
  {
    aj_log_error((uint64_t)"Utils", "%d %d %d", a5, a6, a3);
    return 8;
  }
  int v17 = a9;
  int v18 = (a1 >> 2) & 1 ^ v10;
  int v19 = (a1 >> 3) & 1 ^ v10;
  if (!v11)
  {
    if (v18 && v19)
    {
      a8 = ~a8 + a7;
    }
    else if (!v18)
    {
      if (v19) {
        uint64_t v34 = ~a8 + a7;
      }
      else {
        uint64_t v34 = a8;
      }
      memcpy((void *)(a10 + v13 * v34 + a5 * (uint64_t)a2), a9, (a6 - a5) * a2);
      return 0;
    }
    uint64_t v22 = v13 * a8 + a3 * a2;
    uint64_t v13 = -a2;
    goto LABEL_28;
  }
  unint64_t v20 = a10 + v13 * v14;
  if ((unint64_t)&a9[a3 * (uint64_t)a2] >= a10 && v20 >= (unint64_t)a9) {
    return 8;
  }
  if (v11 != 90) {
    return 3;
  }
  if (v18 && v19)
  {
    uint64_t v26 = v13 * (a3 - 1) + a8 * a2;
    goto LABEL_58;
  }
  if (v18)
  {
    uint64_t v26 = a8 * a2;
    goto LABEL_58;
  }
  uint64_t v35 = (~a8 + a7) * a2;
  if (v19)
  {
    uint64_t v26 = v35 + v13 * (a3 - 1);
LABEL_58:
    if (v19) {
      uint64_t v13 = -v13;
    }
    uint64_t v22 = v26 - v13;
    if (!v19) {
      goto LABEL_63;
    }
LABEL_28:
    uint64_t v15 = (int)v15;
    goto LABEL_29;
  }
  uint64_t v22 = v35 - v13;
LABEL_63:
  uint64_t v15 = a5;
LABEL_29:
  switch(a2)
  {
    case 1:
      int v23 = a6 - a5;
      if (a6 <= a5) {
        return 0;
      }
      int v24 = (unsigned char *)(a10 + v13 + v13 * v15 + v22);
      uint64_t result = 0;
      do
      {
        char v25 = *v17++;
        unsigned char *v24 = v25;
        v24 += v13;
        --v23;
      }
      while (v23);
      break;
    case 2:
      int v28 = a6 - a5;
      if (a6 <= a5) {
        return 0;
      }
      unsigned int v29 = (unsigned char *)(v22 + v13 + v13 * v15 + a10 + 1);
      uint64_t result = 0;
      do
      {
        *(v29 - 1) = *v17;
        *unsigned int v29 = v17[1];
        v29 += v13;
        v17 += 2;
        --v28;
      }
      while (v28);
      break;
    case 3:
      int v30 = a6 - a5;
      if (a6 <= a5) {
        return 0;
      }
      int v31 = (unsigned char *)(v22 + v13 + v13 * v15 + a10 + 2);
      uint64_t result = 0;
      do
      {
        *(v31 - 2) = *v17;
        *(v31 - 1) = v17[1];
        *int v31 = v17[2];
        v31 += v13;
        v17 += 3;
        --v30;
      }
      while (v30);
      break;
    case 4:
      int v32 = a6 - a5;
      if (a6 <= a5) {
        return 0;
      }
      uint64_t v33 = (unsigned char *)(v22 + v13 + v13 * v15 + a10 + 1);
      uint64_t result = 0;
      do
      {
        *(v33 - 1) = *v17;
        *uint64_t v33 = v17[1];
        v33[1] = v17[2];
        v33[2] = v17[3];
        v33 += v13;
        v17 += 4;
        --v32;
      }
      while (v32);
      break;
    default:
      return 0;
  }
  return result;
}

void *aj_paint_region(void *result, int a2, char *a3, int a4, int a5, uint64_t a6, int a7, int *a8)
{
  int v10 = *a8;
  int v11 = a8[1];
  int v12 = a8[2] + *a8;
  int v13 = a8[3] + v11;
  int v14 = a7 - v13;
  int v15 = a7 - v11;
  int v16 = a5 - v12;
  int v17 = a5 - *a8;
  if (a2 == 270) {
    int v18 = a5 - v12;
  }
  else {
    int v18 = 0;
  }
  if (a2 == 270) {
    int v19 = a5 - *a8;
  }
  else {
    int v19 = 0;
  }
  if (a2 == 270) {
    int v20 = a8[1];
  }
  else {
    int v20 = 0;
  }
  if (a2 == 270) {
    int v21 = a8[3] + v11;
  }
  else {
    int v21 = 0;
  }
  if (a2 == 180)
  {
    int v18 = a7 - v13;
    int v19 = a7 - v11;
    int v20 = v16;
  }
  else
  {
    int v17 = v21;
  }
  if (a2 == 90) {
    int v22 = *a8;
  }
  else {
    int v22 = 0;
  }
  if (a2 == 90) {
    int v23 = a8[2] + *a8;
  }
  else {
    int v23 = 0;
  }
  if (a2 != 90)
  {
    int v14 = 0;
    int v15 = 0;
  }
  if (a2)
  {
    int v11 = v22;
    int v13 = v23;
    int v10 = v14;
    int v12 = v15;
  }
  if (a2 <= 179) {
    LODWORD(v24) = v11;
  }
  else {
    LODWORD(v24) = v18;
  }
  if (a2 <= 179) {
    int v25 = v13;
  }
  else {
    int v25 = v19;
  }
  if (a2 <= 179)
  {
    int v26 = v12;
  }
  else
  {
    int v10 = v20;
    int v26 = v17;
  }
  if (a4 < 2) {
    goto LABEL_42;
  }
  int v27 = *a3;
  unint64_t v28 = 1;
  do
    int v29 = a3[v28++];
  while (v28 < a4 && v29 == v27);
  if (v29 == v27)
  {
LABEL_42:
    int v31 = v25 - v24;
    if (v25 > (int)v24)
    {
      size_t v32 = (v26 - v10) * a4;
      uint64_t v33 = (char *)result + a6 * (int)v24 + v10 * a4;
      do
      {
        uint64_t result = memset(v33, *a3, v32);
        v33 += a6;
        --v31;
      }
      while (v31);
    }
  }
  else if (v25 > (int)v24)
  {
    uint64_t v24 = (int)v24;
    uint64_t v34 = (char *)result + a6 * (int)v24 + v10 * (uint64_t)a4;
    do
    {
      uint64_t v35 = v34;
      uint64_t result = (void *)v10;
      if (v26 > v10)
      {
        do
        {
          uint64_t v36 = a4;
          uint64_t v37 = a3;
          uint64_t v38 = v35;
          do
          {
            char v39 = *v37++;
            *v38++ = v39;
            --v36;
          }
          while (v36);
          uint64_t result = (char *)result + 1;
          v35 += a4;
        }
        while (result != (void *)v26);
      }
      ++v24;
      v34 += a6;
    }
    while (v24 != v25);
  }
  return result;
}

uint64_t aj_get_texture_size(_DWORD *a1, uint64_t a2, uint64_t a3, int a4, void *a5, uint64_t a6, void *a7)
{
  int v7 = *(_DWORD *)(a2 + 76);
  int v9 = a1[2];
  int v8 = a1[3];
  int v10 = *(_DWORD *)(a2 + 24);
  if (v10 == -1)
  {
    int v12 = *(_DWORD *)(a2 + 20);
    int v11 = *(_DWORD *)(a2 + 12);
    if (v12 == -1)
    {
      if (v11 == -1)
      {
        int v12 = -1;
        if (*(_DWORD *)(a2 + 16) == -1)
        {
          int v16 = 0;
          int v11 = 0;
          int v13 = -1;
          int v14 = a1[2];
          int v15 = a1[3];
          goto LABEL_9;
        }
        int v11 = -1;
      }
      else
      {
        int v12 = -1;
      }
    }
  }
  else
  {
    int v11 = *(_DWORD *)(a2 + 12);
    int v12 = *(_DWORD *)(a2 + 20);
  }
  int v13 = v12;
  int v12 = *(_DWORD *)(a2 + 16);
  int v14 = v13;
  int v15 = *(_DWORD *)(a2 + 24);
  int v16 = v12;
LABEL_9:
  int v17 = a1[4];
  int v18 = 8 * v17;
  int v19 = a1[8];
  int v20 = 8 * v19;
  int v21 = v11 / (8 * v17);
  int v22 = v16 / (8 * v19);
  int v23 = (v14 + v11 - 1) / (8 * v17) - v21 + 1;
  int v24 = (v15 + v16 - 1) / (8 * v19) - v22 + 1;
  if (v7 != 8 && *a1 != 1)
  {
    int v17 = 2;
    int v19 = 2;
  }
  unint64_t v25 = v23 * v18 / v7;
  unint64_t v26 = v24 * v20 / v7;
  *(void *)a3 = v25;
  *(void *)(a3 + 8) = v26;
  if (a4)
  {
    unint64_t v25 = (v25 + 8 * v17 - 1) & (-8 * v17);
    unint64_t v26 = (v26 + 8 * v19 - 1) & (-8 * v19);
    *(void *)a3 = v25;
    *(void *)(a3 + 8) = v26;
  }
  unint64_t v27 = v25 / v17;
  unint64_t v28 = v26 / v19;
  *(void *)(a3 + 32) = v27;
  *(void *)(a3 + 40) = v28;
  if (v10 != -1)
  {
    int v29 = *(_DWORD *)(a2 + 12);
LABEL_16:
    int v30 = (v29 - v21 * v18) / v7;
    int v31 = (v12 - v22 * v20) / v7;
    *(_DWORD *)(a3 + 16) = v30;
    *(_DWORD *)(a3 + 20) = v31;
    *(_DWORD *)(a3 + 48) = v30 / v17;
    *(_DWORD *)(a3 + 52) = v31 / v19;
    int v32 = v13 / v7;
    *(_DWORD *)(a3 + 56) = v13 / v7 / v17;
    int v33 = v10 / v7;
    *(_DWORD *)(a3 + 24) = v32;
    *(_DWORD *)(a3 + 28) = v33;
    int v34 = v33 / v19;
    goto LABEL_17;
  }
  int v29 = *(_DWORD *)(a2 + 12);
  if (v13 != -1 || v29 != -1) {
    goto LABEL_16;
  }
  if (v12 != -1)
  {
    int v29 = -1;
    goto LABEL_16;
  }
  *(void *)(a3 + 16) = 0;
  int v44 = v9 / v7;
  int v34 = v8 / v7;
  *(_DWORD *)(a3 + 24) = v44;
  *(_DWORD *)(a3 + 28) = v34;
  *(void *)(a3 + 48) = 0;
  if (v17 == 2)
  {
    if (v44 >= -1) {
      int v45 = v44 + 1;
    }
    else {
      int v45 = v44 + 2;
    }
    int v44 = v45 >> 1;
  }
  *(_DWORD *)(a3 + 56) = v44;
  if (v19 == 2)
  {
    if (v34 >= -1) {
      int v46 = v34 + 1;
    }
    else {
      int v46 = v34 + 2;
    }
    int v34 = v46 >> 1;
  }
LABEL_17:
  *(_DWORD *)(a3 + 60) = v34;
  unint64_t v35 = *(void *)(a2 + 40);
  if (v35)
  {
    BOOL v36 = v35 >= v25;
    unint64_t v25 = *(void *)(a2 + 40);
    if (!v36) {
      return 5;
    }
  }
  unint64_t v37 = *(void *)(a2 + 48);
  unint64_t v38 = v27;
  if (v37)
  {
    unint64_t v38 = *(void *)(a2 + 48);
    if (v37 < v27) {
      return 5;
    }
  }
  unint64_t v39 = *(void *)(a2 + 56);
  if (v39)
  {
    BOOL v36 = v39 >= v27;
    unint64_t v27 = *(void *)(a2 + 56);
    if (!v36) {
      return 5;
    }
  }
  unint64_t v41 = v25 * v26;
  unint64_t v42 = v38 * v28;
  unint64_t v43 = v27 * v28;
  if (a6)
  {
    *(void *)a6 = v41;
    *(void *)(a6 + 8) = v42;
    *(void *)(a6 + 16) = v43;
    *(_DWORD *)(a6 + 32) = 3;
  }
  if (a5) {
    *a5 = v42 + v41 + v43;
  }
  uint64_t result = 0;
  if (a7) {
    *a7 = 8 * (v38 + v25 * v19 + v27);
  }
  return result;
}

uint64_t aj_init_bitmapinfo(uint64_t a1, _DWORD *a2, uint64_t a3, int a4)
{
  uint64_t v14 = 0;
  uint64_t result = aj_calculate_dimensions((_DWORD *)a3, (uint64_t)a2, (int *)&v14 + 1, (int *)&v14, 0, 0, 0, 0, 0);
  if (result) {
    goto LABEL_2;
  }
  int v9 = *(_DWORD *)(a3 + 80);
  if (v9 == 270 || v9 == 90)
  {
    int v10 = HIDWORD(v14);
    *(_DWORD *)a1 = v14;
    *(_DWORD *)(a1 + 4) = v10;
    int v11 = *(_DWORD *)(a3 + 8);
    int v12 = v11 - 8;
    if (v11 - 8) < 6 && ((0x33u >> v12))
    {
      *(_DWORD *)(a1 + 8) = dword_21040FB60[v12];
      goto LABEL_13;
    }
    *(_DWORD *)(a1 + 8) = v11;
  }
  else
  {
    int v11 = *(_DWORD *)(a3 + 8);
    int v13 = v14;
    *(_DWORD *)a1 = HIDWORD(v14);
    *(_DWORD *)(a1 + 4) = v13;
    *(_DWORD *)(a1 + 8) = v11;
  }
  if (v11 == 14)
  {
    uint64_t result = aj_get_texture_size(a2, a3, a1 + 16, a4, 0, 0, 0);
    if (result)
    {
LABEL_2:
      *(_OWORD *)(a1 + 80) = 0u;
      *(_OWORD *)(a1 + 96) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
      *(_OWORD *)(a1 + 64) = 0u;
      *(_OWORD *)(a1 + 16) = 0u;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)a1 = 0u;
      return result;
    }
  }
LABEL_13:
  *(void *)(a1 + 80) = *(void *)(a3 + 40);
  *(void *)(a1 + 88) = *(void *)(a3 + 48);
  *(void *)(a1 + 96) = *(void *)(a3 + 56);
  return result;
}

unsigned int **aj_reset_texture_buffer_ptrs(unsigned int **result, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v3 = *result;
  int v4 = *((_DWORD *)result + 43);
  v15[0] = v4;
  if (*((_DWORD *)result + 1721)) {
    int v5 = 8 / *((_DWORD *)result + 42);
  }
  else {
    int v5 = v4 / 2;
  }
  v15[1] = v5;
  v15[2] = v5;
  uint64_t v6 = *v3;
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    int v8 = (void *)(a2 + 8);
    do
    {
      uint64_t v9 = *(void *)(a3 + 8 * v7);
      *(void *)(a2 + (v7 << 7)) = v9;
      uint64_t v10 = v15[v7];
      if ((int)v10 >= 2)
      {
        int v11 = result[v7 + 12];
        uint64_t v12 = (uint64_t)v11 + v9;
        uint64_t v13 = v10 - 1;
        uint64_t v14 = v8;
        do
        {
          *v14++ = v12;
          v12 += (uint64_t)v11;
          --v13;
        }
        while (v13);
      }
      ++v7;
      v8 += 16;
    }
    while (v7 != v6);
  }
  return result;
}

uint64_t aj_get_rowptrs(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = *(_DWORD *)(a1 + 6464);
  if (v4 < 1)
  {
LABEL_9:
    uint64_t result = 0;
    *(unsigned char *)(a2 + 560) = 1;
  }
  else
  {
    uint64_t v7 = 0;
    while (1)
    {
      uint64_t v8 = *(int *)(a1 + 4 * v7 + 6684);
      if (v8) {
        break;
      }
LABEL_8:
      ++v7;
      a3 += 16;
      if (v7 >= v4) {
        goto LABEL_9;
      }
    }
    uint64_t v9 = *(void *)(a1 + 16 * v7 + 6712);
    uint64_t v10 = a3;
    while (1)
    {
      buffer = aj_rowbuffer_get_buffer((unsigned int *)(a2 + 152), v9);
      *uint64_t v10 = buffer;
      if (!buffer) {
        return 1;
      }
      ++v10;
      if (!--v8)
      {
        int v4 = *(_DWORD *)(a1 + 6464);
        goto LABEL_8;
      }
    }
  }
  return result;
}

void aj_return_rowptrs(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  int v4 = *(_DWORD *)(a1 + 6464);
  if (v4 >= 1)
  {
    for (uint64_t i = 0; i < v4; ++i)
    {
      uint64_t v8 = *(int *)(a1 + 4 * i + 6684);
      uint64_t v9 = a3;
      if (v8)
      {
        do
        {
          unint64_t v10 = *v9++;
          aj_rowbuffer_return_buffer((unsigned int *)(a2 + 152), v10);
          --v8;
        }
        while (v8);
        int v4 = *(_DWORD *)(a1 + 6464);
      }
      a3 += 16;
    }
  }
  *(unsigned char *)(a2 + 560) = 0;
}

uint64_t aj_get_jpeg_format_from_subsampling(uint64_t a1, int a2)
{
  if (a2 == 1) {
    return 4;
  }
  switch(a1)
  {
    case 0x100000001:
      return 0;
    case 0x100000002:
      return 1;
    case 0x200000001:
      return 2;
  }
  if (HIDWORD(a1) == 2 && a1 == 2) {
    return 3;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t aj_get_subsampling_from_jpeg_format(signed int a1)
{
  if (a1 > 4) {
    return 0;
  }
  else {
    return qword_21040FBA0[a1] | qword_21040FB78[a1];
  }
}

uint64_t aj_get_format_description(int a1, uint64_t a2)
{
  *(void *)(a2 + 8) = 0;
  *(void *)a2 = 0x100000003;
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)(a2 + 24) = xmmword_21040FB30;
  switch(a1)
  {
    case 0:
    case 6:
      uint64_t result = 0;
      int v5 = 3;
      goto LABEL_25;
    case 1:
    case 2:
      goto LABEL_22;
    case 3:
    case 4:
    case 15:
      uint64_t result = 0;
      int v4 = 4;
      goto LABEL_11;
    case 5:
      uint64_t result = 0;
      int v4 = 1;
LABEL_11:
      *(_DWORD *)a2 = v4;
      goto LABEL_13;
    case 7:
      uint64_t result = 0;
      int v4 = 2;
      *(_DWORD *)(a2 + 24) = 2;
      goto LABEL_13;
    case 8:
      goto LABEL_15;
    case 9:
      *(void *)(a2 + 32) = 0x100000002;
LABEL_15:
      uint64_t result = 0;
      *(void *)(a2 + 24) = 0x100000002;
      goto LABEL_27;
    case 10:
      goto LABEL_17;
    case 11:
      *(void *)(a2 + 32) = 0x100000002;
LABEL_17:
      uint64_t result = 0;
      uint64_t v7 = 0x200000002;
      goto LABEL_20;
    case 12:
      goto LABEL_19;
    case 13:
      *(void *)(a2 + 32) = 0x100000002;
LABEL_19:
      uint64_t result = 0;
      uint64_t v7 = 0x200000001;
LABEL_20:
      *(void *)(a2 + 24) = v7;
      goto LABEL_27;
    case 14:
    case 25:
      uint64_t result = 0;
      long long v6 = xmmword_21040FB40;
      goto LABEL_30;
    case 16:
    case 17:
    case 21:
      uint64_t result = 0;
      *(_DWORD *)a2 = 4;
      int v4 = 8;
      goto LABEL_13;
    case 18:
      *(_DWORD *)a2 = 1;
LABEL_22:
      uint64_t result = 0;
      int v5 = 2;
      goto LABEL_25;
    case 19:
      uint64_t result = 0;
      *(void *)(a2 + 24) = 0x200000002;
      *(void *)(a2 + 4) = 0x200000002;
      int v8 = 4;
      goto LABEL_28;
    case 20:
      uint64_t result = 0;
      int v5 = 6;
LABEL_25:
      *(_DWORD *)(a2 + 8) = v5;
      break;
    case 22:
    case 23:
      uint64_t result = 0;
      *(_DWORD *)a2 = 2;
      if (a1 == 22) {
        int v4 = 2;
      }
      else {
        int v4 = 4;
      }
LABEL_13:
      *(_DWORD *)(a2 + 8) = v4;
      break;
    case 24:
      uint64_t result = 0;
      *(_DWORD *)(a2 + 28) = 1;
LABEL_27:
      *(void *)(a2 + 4) = 0x100000002;
      int v8 = 2;
LABEL_28:
      *(_DWORD *)(a2 + 12) = v8;
      break;
    case 26:
      uint64_t result = 0;
      long long v6 = xmmword_21040FB50;
LABEL_30:
      *(_OWORD *)(a2 + 4) = v6;
      break;
    default:
      uint64_t result = 1;
      break;
  }
  return result;
}

uint64_t aj_transforms_from_orientation(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  int v4 = a1 - 1;
  uint64_t result = 0;
  switch(v4)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = 0;
      goto LABEL_7;
    case 2:
      uint64_t result = 0;
      goto LABEL_12;
    case 3:
      uint64_t result = 0;
      goto LABEL_13;
    case 4:
      uint64_t result = 0;
      *a2 = 90;
LABEL_7:
      *a3 = 1;
      return result;
    case 5:
      uint64_t result = 0;
      *a2 = 90;
      return result;
    case 6:
      uint64_t result = 0;
      *a2 = 90;
      goto LABEL_13;
    case 7:
      uint64_t result = 0;
      *a2 = 90;
LABEL_12:
      *a3 = 1;
LABEL_13:
      *a4 = 1;
      break;
    default:
      aj_log_error((uint64_t)"Utils", "Illegal display orientation option: %d", 0);
      uint64_t result = 5;
      break;
  }
  return result;
}

uint64_t aj_huffman_decode_val(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  unsigned int v4 = *(_DWORD *)a2;
  int v5 = *(_DWORD *)(a2 + 24);
  if (*(_DWORD *)(a2 + 28)) {
    goto LABEL_32;
  }
  int v6 = *(_DWORD *)(a1 + 4 * ((*(_DWORD *)a2 >> 23) + 100));
  if ((v6 & 0x30000) == 0)
  {
    int v7 = v6 >> 18;
    int v8 = a3 + v6;
    if ((_BYTE)v6) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = v7 == 0;
    }
    if (v9) {
      int v8 = 63;
    }
    unsigned int v10 = v4 << SBYTE1(v6);
    int v11 = v5 - BYTE1(v6);
    if (v11 >= 0) {
      goto LABEL_9;
    }
    goto LABEL_11;
  }
  if ((v6 & 0x10000) != 0)
  {
LABEL_32:
    *(_DWORD *)(a2 + 24) = v5;
    return aj_huffman_decode_val_slow(a1, (unsigned int *)a2, a3, 0, a4);
  }
  int v25 = BYTE1(v6);
  unsigned int v26 = v6 >> 18;
  int v11 = v5 - v25;
  unsigned int v10 = v4 << v25;
  int v8 = a3 + (v26 >> 4);
  int v27 = v26 & 0xF;
  if (v27)
  {
    if (v11 + 9 < v27)
    {
      *(_DWORD *)(a2 + 24) = v11;
      *(_DWORD *)a2 = v10;
      int v34 = (unsigned int *)a2;
      int v31 = v8;
      int v32 = a4;
      int v30 = v27;
      uint64_t result = aj_istream_fill_buf(a2, v27 - 9);
      int v27 = v30;
      if (result) {
        return result;
      }
      int v8 = v31;
      a4 = v32;
      a2 = (uint64_t)v34;
      int v11 = v34[6];
      unsigned int v10 = *v34;
    }
    v11 -= v27;
    int v28 = v10 >> (32 - v27);
    v10 <<= v27;
    int v29 = 1 << (v27 - 1);
    if (v28 < v29) {
      int v7 = v28 + 1 - 2 * v29;
    }
    else {
      int v7 = v28;
    }
  }
  else
  {
    int v7 = 0;
  }
  if (v11 >= 0)
  {
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
  if (*(_DWORD *)(a2 + 28))
  {
LABEL_9:
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
LABEL_11:
  int v13 = *(_DWORD *)(a2 + 32);
  uint64_t v14 = *(unsigned __int8 **)(a2 + 8);
  if (v13 < 8) {
    goto LABEL_33;
  }
  int v15 = *v14;
  int v16 = v14[1];
  BOOL v9 = v15 == 255;
  int v17 = v16 + (v15 << 8);
  BOOL v18 = v9 || v16 == 255;
  int v19 = v14[2];
  int v20 = v14 + 3;
  int v21 = v13 - 3;
  int v22 = v19 + (v17 << 8);
  if (v18 || v19 == 255)
  {
LABEL_33:
    *(_DWORD *)a2 = v10;
    *(_DWORD *)(a2 + 24) = v11;
    int v33 = a4;
    int v35 = v8 + (v7 << 16);
    uint64_t result = aj_istream_fill_buf(a2, -9);
    if (!result)
    {
      uint64_t result = 0;
      *int v33 = v35;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 32) = v21;
    int v24 = -v11 - 1;
    *(void *)(a2 + 8) = v20;
    *(_DWORD *)a2 = v10 | (v22 << v24);
    *(_DWORD *)(a2 + 24) = 23 - v24;
    *a4 = v8 + (v7 << 16);
    return 0;
  }
  return result;
}

long long *aj_internal_upsample_422(unint64_t *a1, char *a2, int a3, double a4, double a5, double a6, double a7, int64x2_t a8, int64x2_t a9)
{
  unsigned int v11 = a3 - 1;
  unsigned int v12 = v11 >> 4;
  a8.i64[0] = *a1;
  uint64_t result = (long long *)(a1 + 1);
  for (int8x8_t i = (int8x8_t)vshlq_n_s64(a8, 0x38uLL).u64[0]; v12; a2 += 32)
  {
    long long v15 = *result++;
    a9.i64[0] = *((void *)&v15 + 1);
    int16x8_t v16 = (int16x8_t)vmull_u8(*(uint8x8_t *)a8.i8, (uint8x8_t)0x303030303030303);
    int16x8_t v17 = (int16x8_t)vmull_u8(*(uint8x8_t *)&v15, (uint8x8_t)0x303030303030303);
    *(uint8x8_t *)v27.val[0].i8 = vqrshrn_n_u16(vaddw_u8((uint16x8_t)v16, (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL)), 2uLL);
    *(uint8x8_t *)v27.val[1].i8 = vqshrn_n_u16((uint16x8_t)vaddq_s16(v16, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)&v15, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    --v12;
    v27.val[0].u64[1] = (unint64_t)vqrshrn_n_u16(vaddw_u8((uint16x8_t)v17, (uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)&v15, 7uLL)), 2uLL);
    v27.val[1].u64[1] = (unint64_t)vqshrn_n_u16((uint16x8_t)vaddq_s16(v17, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)&v15, *(int8x8_t *)((char *)&v15 + 8), 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    int8x8_t i = (int8x8_t)v15;
    a8 = a9;
    vst2q_s8(a2, v27);
  }
  if ((v11 & 8) != 0)
  {
    uint8x8_t v18 = (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL);
    int8x8_t i = *(int8x8_t *)a8.i8;
    int8x8_t v19 = *(int8x8_t *)result;
    uint64_t result = (long long *)((char *)result + 8);
    *(int8x8_t *)a8.i8 = v19;
    int16x8_t v20 = (int16x8_t)vmull_u8((uint8x8_t)i, (uint8x8_t)0x303030303030303);
    v26.val[0] = (int8x8_t)vqrshrn_n_u16(vaddw_u8((uint16x8_t)v20, v18), 2uLL);
    v26.val[1] = (int8x8_t)vqshrn_n_u16((uint16x8_t)vaddq_s16(v20, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(i, v19, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
    vst2_s8(a2, v26);
    a2 += 16;
  }
  int v21 = v11 - 8 * (v11 >> 3);
  uint8x8_t v22 = (uint8x8_t)vext_s8(i, *(int8x8_t *)a8.i8, 7uLL);
  uint64x2_t v23 = (uint64x2_t)a8;
  int16x8_t v24 = (int16x8_t)vmull_u8(*(uint8x8_t *)a8.i8, (uint8x8_t)0x303030303030303);
  *(uint8x8_t *)v9.i8 = vqrshrn_n_u16(vaddw_u8((uint16x8_t)v24, v22), 2uLL);
  *(uint8x8_t *)v10.i8 = vqshrn_n_u16((uint16x8_t)vaddq_s16(v24, (int16x8_t)vaddl_u8((uint8x8_t)vext_s8(*(int8x8_t *)a8.i8, *(int8x8_t *)a8.i8, 1uLL), (uint8x8_t)0x101010101010101)), 2uLL);
  if (v11 != 8 * (v11 >> 3))
  {
    do
    {
      *a2 = v9.i8[0];
      a2[1] = v10.i8[0];
      a2 += 2;
      uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
      uint64x2_t v10 = vshrq_n_u64(v10, 8uLL);
      uint64x2_t v23 = vshrq_n_u64(v23, 8uLL);
      BOOL v25 = __OFSUB__(v21--, 1);
    }
    while (!((v21 < 0) ^ v25 | (v21 == 0)));
  }
  *a2 = v9.i8[0];
  a2[1] = v23.i8[0];
  return result;
}

uint8x16_t **aj_icol_row_420_to_rgba(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint8x8_t v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  unint64_t v12 = vdupq_n_s8(0xFFu).u64[0];
  if (a6 >= 1)
  {
    int v13 = *result;
    uint64_t v14 = *a2;
    long long v15 = *a3;
    if (a6 == 1)
    {
      for (unsigned int i = a7 >> 4; i; --i)
      {
        uint8x16_t v58 = *v13++;
        uint8x8_t v59 = *v14++;
        uint8x8_t v60 = *v15++;
        int16x8_t v61 = (int16x8_t)vsubl_u8(v59, v11);
        int16x8_t v62 = (int16x8_t)vsubl_u8(v60, v11);
        int16x8_t v63 = vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v64 = vmulq_n_s16(v62, 179);
        int16x8_t v65 = vqaddq_s16(vmulq_lane_s16(v61, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v66 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v58.i8, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v63, v63)), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v66, vzip1q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v66, vzip1q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v86);
        size_t v67 = a4 + 32;
        int16x8_t v68 = (int16x8_t)vshll_high_n_u8(v58, 7uLL);
        v86.val[2] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v63, v63)), 7uLL);
        v86.val[0] = vqrshrun_n_s16(vqaddq_s16(v68, vzip2q_s16(v64, v64)), 7uLL);
        v86.val[1] = vqrshrun_n_s16(vqsubq_s16(v68, vzip2q_s16(v65, v65)), 7uLL);
        v86.val[3] = (int8x8_t)v12;
        vst4_s8(v67, v86);
        a4 = v67 + 32;
      }
      unsigned int v69 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v70 = *(uint64x2_t *)v13;
        int16x8_t v71 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v72 = (int16x8_t)vsubl_u8(*v15, v11);
        int16x8_t v73 = vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v74 = vmulq_n_s16(v72, 179);
        int16x8_t v75 = vqaddq_s16(vmulq_lane_s16(v71, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v72, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v76 = vzip2q_s16(v73, v73);
        int16x8_t v77 = vzip2q_s16(v74, v74);
        int16x8_t v78 = vzip2q_s16(v75, v75);
        int16x8_t v79 = vzip1q_s16(v73, v73);
        int16x8_t v80 = vzip1q_s16(v74, v74);
        int16x8_t v81 = vzip1q_s16(v75, v75);
        if (!(v69 >> 3)) {
          goto LABEL_16;
        }
        int16x8_t v82 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
        v87.val[2] = vqrshrun_n_s16(vqaddq_s16(v82, v79), 7uLL);
        v87.val[0] = vqrshrun_n_s16(vqaddq_s16(v82, v80), 7uLL);
        v87.val[1] = vqrshrun_n_s16(vqsubq_s16(v82, v81), 7uLL);
        v87.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v87);
        a4 += 32;
        int16x8_t v79 = v76;
        int16x8_t v80 = v77;
        int16x8_t v81 = v78;
        v70.i64[0] = v70.i64[1];
        v69 -= 8;
        if (v69)
        {
LABEL_16:
          int16x8_t v83 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v70.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v79), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v83, v80), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v83, v81), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            --v69;
          }
          while (v69);
        }
      }
    }
    else
    {
      unsigned int v16 = a7 >> 4;
      for (uint64_t j = result[1]; v16; --v16)
      {
        uint8x16_t v18 = *v13++;
        uint8x16_t v19 = *j++;
        uint8x8_t v20 = *v14++;
        uint8x8_t v21 = *v15++;
        int16x8_t v22 = (int16x8_t)vsubl_u8(v20, v11);
        int16x8_t v23 = (int16x8_t)vsubl_u8(v21, v11);
        int16x8_t v24 = vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v25 = vmulq_n_s16(v23, 179);
        int16x8_t v26 = vqaddq_s16(vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v23, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v27 = vzip2q_s16(v24, v24);
        int16x8_t v28 = vzip2q_s16(v25, v25);
        int16x8_t v29 = vzip2q_s16(v26, v26);
        int16x8_t v30 = vzip1q_s16(v24, v24);
        int16x8_t v31 = vzip1q_s16(v25, v25);
        int16x8_t v32 = vzip1q_s16(v26, v26);
        int16x8_t v33 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v18.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v33, v30), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v33, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v33, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v84);
        int v34 = a4 + 32;
        int16x8_t v35 = (int16x8_t)vshll_high_n_u8(v18, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v35, v27), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v35, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v35, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v34, v84);
        a4 = v34 + 32;
        int16x8_t v36 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v19.i8, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v36, v30), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v36, v31), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v36, v32), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v84);
        unint64_t v37 = a5 + 32;
        int16x8_t v38 = (int16x8_t)vshll_high_n_u8(v19, 7uLL);
        v84.val[2] = vqrshrun_n_s16(vqaddq_s16(v38, v27), 7uLL);
        v84.val[0] = vqrshrun_n_s16(vqaddq_s16(v38, v28), 7uLL);
        v84.val[1] = vqrshrun_n_s16(vqsubq_s16(v38, v29), 7uLL);
        v84.val[3] = (int8x8_t)v12;
        vst4_s8(v37, v84);
        a5 = v37 + 32;
      }
      unsigned int v39 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v40 = *(uint64x2_t *)v13;
        uint64x2_t v41 = *(uint64x2_t *)j;
        int16x8_t v42 = (int16x8_t)vsubl_u8(*v14, v11);
        int16x8_t v43 = (int16x8_t)vsubl_u8(*v15, v11);
        int16x8_t v44 = vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v45 = vmulq_n_s16(v43, 179);
        int16x8_t v46 = vqaddq_s16(vmulq_lane_s16(v42, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v43, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v47 = vzip2q_s16(v44, v44);
        int16x8_t v48 = vzip2q_s16(v45, v45);
        int16x8_t v49 = vzip2q_s16(v46, v46);
        int16x8_t v50 = vzip1q_s16(v44, v44);
        int16x8_t v51 = vzip1q_s16(v45, v45);
        int16x8_t v52 = vzip1q_s16(v46, v46);
        if (!(v39 >> 3)) {
          goto LABEL_8;
        }
        int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v53, v50), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v53, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v53, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a4, v85);
        a4 += 32;
        int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
        v85.val[2] = vqrshrun_n_s16(vqaddq_s16(v54, v50), 7uLL);
        v85.val[0] = vqrshrun_n_s16(vqaddq_s16(v54, v51), 7uLL);
        v85.val[1] = vqrshrun_n_s16(vqsubq_s16(v54, v52), 7uLL);
        v85.val[3] = (int8x8_t)v12;
        vst4_s8(a5, v85);
        a5 += 32;
        int16x8_t v50 = v47;
        int16x8_t v51 = v48;
        int16x8_t v52 = v49;
        v40.i64[0] = v40.i64[1];
        v41.i64[0] = v41.i64[1];
        v39 -= 8;
        if (v39)
        {
LABEL_8:
          int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v40.i8, 7uLL);
          *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v50), 7uLL);
          *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vqaddq_s16(v55, v51), 7uLL);
          *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vqsubq_s16(v55, v52), 7uLL);
          int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v41.i8, 7uLL);
          *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v50), 7uLL);
          *(int8x8_t *)v40.i8 = vqrshrun_n_s16(vqaddq_s16(v56, v51), 7uLL);
          *(int8x8_t *)v41.i8 = vqrshrun_n_s16(vqsubq_s16(v56, v52), 7uLL);
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4[2] = v9.i8[0];
            a4[3] = v12;
            a4 += 4;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            uint64x2_t v9 = vshrq_n_u64(v9, 8uLL);
            *a5 = v40.i8[0];
            a5[1] = v41.i8[0];
            a5[2] = v10.i8[0];
            a5[3] = v12;
            a5 += 4;
            uint64x2_t v40 = vshrq_n_u64(v40, 8uLL);
            uint64x2_t v41 = vshrq_n_u64(v41, 8uLL);
            uint64x2_t v10 = vshrq_n_u64(v10, 8uLL);
            --v39;
          }
          while (v39);
        }
      }
    }
  }
  return result;
}

uint64_t aj_huffman_encode_val_lkup(uint64_t a1, int a2, int a3, int32x2_t *a4)
{
  if (a3)
  {
    if (a3 >= 0) {
      unsigned int v4 = a3;
    }
    else {
      unsigned int v4 = -a3;
    }
    unsigned int v5 = HIWORD(v4);
    if (!HIWORD(v4)) {
      unsigned int v5 = v4;
    }
    if (v5 <= 0xFF) {
      int v6 = 16 * (HIWORD(v4) != 0);
    }
    else {
      int v6 = (16 * (HIWORD(v4) != 0)) | 8;
    }
    if (v5 > 0xFF) {
      v5 >>= 8;
    }
    if (v5 > 0xF)
    {
      v6 |= 4u;
      v5 >>= 4;
    }
    if (v5 > 3)
    {
      v6 |= 2u;
      v5 >>= 2;
    }
    int v7 = v6 | (v5 > 1);
    int v8 = v7 + 1;
    int v9 = (-2 << v7) | v4;
    if (a3 < 0) {
      unsigned int v4 = ~v9;
    }
  }
  else
  {
    unsigned int v4 = 0;
    int v8 = 0;
  }
  int v10 = v8 + HIWORD(*(_DWORD *)(a1 + 4 * (v8 + 16 * a2)));
  unsigned int v11 = ((unsigned __int16)*(_DWORD *)(a1 + 4 * (v8 + 16 * a2)) << v8) + v4;
  if (a4[2].i32[1] >= 9 && (int v12 = a4->i32[1] + v10, v12 < 33))
  {
    unsigned int v14 = a4->i32[0] | (v11 << -(char)v12);
    a4->i32[0] = v14;
    a4->i32[1] = v12;
    if (v12 >= 8)
    {
      do
      {
        unsigned int v15 = HIBYTE(v14);
        unsigned int v16 = (unsigned char *)a4[1];
        a4[1] = (int32x2_t)(v16 + 1);
        unsigned char *v16 = v15;
        a4[2] = vadd_s32(a4[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v15 == 255)
        {
          int16x8_t v17 = (unsigned char *)a4[1];
          a4[1] = (int32x2_t)(v17 + 1);
          unsigned char *v17 = 0;
          a4[2] = vadd_s32(a4[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        int v18 = a4->i32[1];
        unsigned int v14 = a4->i32[0] << 8;
        a4->i32[0] = v14;
        a4->i32[1] = v18 - 8;
      }
      while (v18 > 15);
    }
  }
  else
  {
    uint64_t result = aj_ostream_write((unsigned int *)a4, v11, v10);
    if (result) {
      return result;
    }
  }
  return 0;
}

uint64_t aj_huffman_encode_sym_lkup(uint64_t a1, int a2, int32x2_t *a3)
{
  int v3 = HIWORD(*(_DWORD *)(a1 + 4 * a2));
  unsigned int v4 = (unsigned __int16)*(_DWORD *)(a1 + 4 * a2);
  if (a3[2].i32[1] >= 9 && (int v5 = a3->i32[1] + v3, v5 < 33))
  {
    unsigned int v7 = a3->i32[0] | (v4 << -(char)v5);
    a3->i32[0] = v7;
    a3->i32[1] = v5;
    if (v5 >= 8)
    {
      do
      {
        unsigned int v8 = HIBYTE(v7);
        int v9 = (unsigned char *)a3[1];
        a3[1] = (int32x2_t)(v9 + 1);
        *int v9 = v8;
        a3[2] = vadd_s32(a3[2], (int32x2_t)0xFFFFFFFF00000001);
        if (v8 == 255)
        {
          int v10 = (unsigned char *)a3[1];
          a3[1] = (int32x2_t)(v10 + 1);
          *int v10 = 0;
          a3[2] = vadd_s32(a3[2], (int32x2_t)0xFFFFFFFF00000001);
        }
        int v11 = a3->i32[1];
        unsigned int v7 = a3->i32[0] << 8;
        a3->i32[0] = v7;
        a3->i32[1] = v11 - 8;
      }
      while (v11 > 15);
    }
  }
  else
  {
    uint64_t result = aj_ostream_write((unsigned int *)a3, v4, v3);
    if (result) {
      return result;
    }
  }
  return 0;
}

void aj_huffman_encode_init_lookups(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x400uLL);
  int v8 = 0;
  for (uint64_t i = 1; i != 17; ++i)
  {
    unsigned int v10 = *(unsigned __int8 *)(i + a1 - 1);
    if (*(unsigned char *)(i + a1 - 1) && v8 <= 255)
    {
      uint64_t v11 = v8;
      do
      {
        int v8 = v11 + 1;
        v34[v11] = i;
        if (v10 < 2) {
          break;
        }
        --v10;
      }
      while (v11++ < 255);
    }
  }
  int v13 = 0;
  LODWORD(v14) = 0;
  int v15 = v34[0];
  while (v34[(int)v14])
  {
    uint64_t v14 = (int)v14;
    int v16 = 2 * v13;
    while (v34[v14] == v15)
    {
      v33[v14] = v13++;
      v16 += 2;
      if (++v14 == 256) {
        goto LABEL_17;
      }
    }
    ++v15;
    int v13 = v16;
    if ((int)v14 >= 256) {
      goto LABEL_17;
    }
  }
  if ((int)v14 < 1) {
    goto LABEL_19;
  }
LABEL_17:
  uint64_t v14 = v14;
  int16x8_t v17 = v33;
  int v18 = v34;
  do
  {
    int v20 = *v18++;
    int v19 = v20;
    int v21 = *v17++;
    int v22 = v21 | (v19 << 16);
    unsigned int v23 = *a2++;
    *(_DWORD *)(a3 + 4 * v23) = v22;
    --v14;
  }
  while (v14);
LABEL_19:
  if (a4)
  {
    for (uint64_t j = 0; j != 8; ++j)
    {
      for (uint64_t k = 0; k != 32; ++k)
      {
        uint64_t v26 = k - 16;
        if (k == 16)
        {
          unsigned int v27 = 0;
        }
        else
        {
          unsigned int v28 = 16 - k;
          if ((int)k - 16 >= 0) {
            unsigned int v28 = k - 16;
          }
          unsigned int v29 = HIWORD(v28);
          if (!HIWORD(v28)) {
            unsigned int v29 = v28;
          }
          if (v29 <= 0xFF) {
            int v30 = 16 * (HIWORD(v28) != 0);
          }
          else {
            int v30 = (16 * (HIWORD(v28) != 0)) | 8;
          }
          if (v29 > 0xFF) {
            v29 >>= 8;
          }
          if (v29 > 0xF)
          {
            v30 |= 4u;
            v29 >>= 4;
          }
          if (v29 > 3)
          {
            v30 |= 2u;
            v29 >>= 2;
          }
          int v31 = v30 | (v29 > 1);
          unsigned int v27 = v31 + 1;
          int v32 = (-2 << v31) | v28;
          if (v26 < 0) {
            LODWORD(v26) = ~v32;
          }
          else {
            LODWORD(v26) = v28;
          }
        }
        *(_DWORD *)(a4 + 4 * k) = (((unsigned __int16)*(_DWORD *)(a3 + 4 * (16 * j + v27)) << v27) + v26) | ((v27 + HIWORD(*(_DWORD *)(a3 + 4 * (16 * j + v27)))) << 24);
      }
      a4 += 128;
    }
  }
}

uint64_t aj_lossless_decode_all(int **a1, uint64_t a2)
{
  uint64_t v116 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a2 + 112);
  uint64_t v5 = (uint64_t)*a1;
  int64_t v6 = **a1;
  unsigned int v7 = *((_DWORD *)a1 + 1645);
  int v8 = 0;
  int v9 = 0;
  int v10 = 0;
  unsigned int v11 = 4;
  int v12 = 1;
  switch(v7)
  {
    case 0u:
    case 0x14u:
    case 0x19u:
    case 0x1Au:
      int v8 = 0;
      int v9 = 0;
      int v10 = 0;
      unsigned int v11 = 3;
      break;
    case 3u:
    case 4u:
    case 0x10u:
    case 0x11u:
    case 0x15u:
      break;
    case 5u:
    case 0x12u:
      int v8 = 0;
      int v10 = 0;
      int v9 = 1;
      unsigned int v11 = 1;
      break;
    case 0x16u:
    case 0x17u:
      int v8 = 0;
      int v9 = 0;
      unsigned int v11 = 2;
      int v10 = 1;
      break;
    default:
      int v9 = 0;
      int v10 = 0;
      int v12 = 0;
      unsigned int v11 = 0;
      int v8 = 1;
      break;
  }
  if (v7 > 0x1A) {
    goto LABEL_12;
  }
  int v13 = 1;
  if (((1 << v7) & 0x4B70000) == 0)
  {
    if (((1 << v7) & 0x2400039) != 0)
    {
      int v14 = 0;
      if (!v8) {
        goto LABEL_13;
      }
    }
LABEL_12:
    aj_log_error(0, "Unsupported output format for lossless JPEG");
    return 5;
  }
  int v13 = 2;
  int v14 = 1;
  if (v8) {
    goto LABEL_12;
  }
LABEL_13:
  if ((int)v6 > 1) {
    int v15 = v9;
  }
  else {
    int v15 = 0;
  }
  if (v15 == 1)
  {
    aj_log_error(0, "Decoding lossless RGB JPEG to grayscale not supported");
    return 5;
  }
  if (v6 == 2) {
    int v16 = 0;
  }
  else {
    int v16 = v10;
  }
  if (v16 == 1)
  {
    aj_log_error(0, "Only two-component JPEGs can be decoded to two-component format");
    return 5;
  }
  if (a1[1][23] >= 7)
  {
    aj_log_error(0, "Max 6 blocks per MCU supported");
    return 3;
  }
  if (*(int *)(v5 + 32) >= 3)
  {
    aj_log_error(0, "Vertical subsampling > 2 not yet supported");
    return 3;
  }
  if (*(int *)(v5 + 16) >= 3)
  {
    aj_log_error(0, "Horizontal subsampling > 2 not yet supported");
    return 3;
  }
  if (v6 == 3)
  {
    uint64_t v18 = 0;
    while (*(_DWORD *)(v5 + v18 + 36) == 1 && *(_DWORD *)(v5 + v18 + 20) == 1)
    {
      v18 += 4;
      if (v18 == 8) {
        goto LABEL_36;
      }
    }
    aj_log_error(0, "Subsampling not yet supported");
    return 3;
  }
LABEL_36:
  uint64_t result = aj_istream_move_to_position(v4, *(unsigned int *)(v5 + 3420));
  if (!result)
  {
    int v19 = *((_DWORD *)a1 + 1645);
    memset(&v115[1], 0, 32);
    BOOL v21 = v19 == 17 || v19 == 4;
    long long v114 = 0uLL;
    v115[0] = 0uLL;
    if (v14) {
      __int16 v22 = -1;
    }
    else {
      __int16 v22 = 255;
    }
    memset(v113, 0, sizeof(v113));
    long long v111 = 0uLL;
    memset(v112, 0, sizeof(v112));
    memset(v110, 0, sizeof(v110));
    if ((v19 - 25) >= 2)
    {
      uint64_t v105 = v11;
      unsigned int v23 = *a1;
      if (v12)
      {
        unint64_t v50 = 0;
        int16x8_t v51 = a1[12];
        int16x8_t v52 = a1[8];
        if (v11 <= 1) {
          uint64_t v53 = 1;
        }
        else {
          uint64_t v53 = v11;
        }
        int16x8_t v54 = (char *)&v111 + 4;
        int v55 = 2;
        do
        {
          if (v21 && v50 < 3) {
            int v56 = v55;
          }
          else {
            int v56 = v50;
          }
          *((_DWORD *)v54 - 1) = v13 * v11;
          *(_DWORD *)int16x8_t v54 = v11;
          *((_DWORD *)v54 + 1) = v56 * v13;
          *((_DWORD *)v54 + 2) = v51;
          *((void *)v54 + 2) = 0x100000000;
          *((_DWORD *)v54 + 6) = 2;
          *((_DWORD *)v54 + 7) = v23[847];
          if ((uint64_t)v50 >= v6) {
            v54[32] = 1;
          }
          else {
            *(void *)(v54 - 12) = *(void *)&a1[1][4 * v23[v50 + 839] + 2];
          }
          *((void *)v115 + v50) = v52;
          v113[v50++] = v51;
          --v55;
          v54 += 72;
        }
        while (v53 != v50);
      }
    }
    else
    {
      unsigned int v23 = *a1;
      int16x8_t v24 = a1[1];
      int v25 = v24[23];
      uint64_t v105 = v25;
      int v26 = (*a1)[8];
      if (v26 >= 1)
      {
        int v27 = 0;
        uint64_t v28 = 0;
        int v29 = v23[4];
        while (1)
        {
          if (v29 < 1) {
            goto LABEL_66;
          }
          int v30 = 0;
          uint64_t v31 = 0;
          int v32 = a1[12];
          int v33 = *((unsigned __int8 *)a1 + 6904);
          int v34 = (char *)a1[8] + (void)v32 * v28;
          do
          {
            int v35 = v27 * v29;
            uint64_t v36 = v31 + (int)v28 * v29;
            unint64_t v37 = (char *)v110 + 72 * v36;
            *((_DWORD *)v37 + 10) = v30;
            int v38 = v23[4] * v13;
            *((_DWORD *)v37 + 11) = v32;
            unsigned int v39 = v37 + 44;
            *(v39 - 3) = v38;
            *(v39 - 2) = 1;
            if (v35 == v31 && v33 != 0) {
              *unsigned int v39 = v23[8] * v32;
            }
            *((void *)v115 + v36) = v34;
            v113[v36] = (void)v32 * (int)v23[8];
            uint64x2_t v41 = (char *)v110 + 72 * v36;
            *(void *)(v41 + 52) = 0x100000000;
            int16x8_t v42 = v41 + 52;
            int16x8_t v43 = v42 + 1;
            v42[2] = 2;
            v42[3] = v23[847];
            if (v28 && v31)
            {
              *int16x8_t v42 = v23[847];
              _DWORD *v43 = v23[847];
LABEL_59:
              v42[2] = v23[847];
              goto LABEL_62;
            }
            if (v28)
            {
              *int16x8_t v42 = 2;
              _DWORD *v43 = v23[847];
            }
            else if (v31)
            {
              *int16x8_t v42 = 1;
              goto LABEL_59;
            }
LABEL_62:
            *((void *)&v110[1] + 9 * v36 + 1) = *(void *)&v24[4 * v23[839] + 2];
            int v29 = v23[4];
            ++v31;
            v30 += v13;
          }
          while ((int)v31 < v29);
          int v26 = v23[8];
LABEL_66:
          ++v28;
          --v27;
          if (v28 >= v26)
          {
            int v25 = v24[23];
            break;
          }
        }
      }
      uint64_t v44 = v24[22];
      if ((int)v44 < v25)
      {
        int v45 = v44 + 1;
        int16x8_t v46 = (char *)&v110[2] + 72 * (int)v44;
        do
        {
          int v47 = v45 - v24[22];
          int16x8_t v48 = &a1[v47];
          int16x8_t v49 = v48[12];
          *((void *)v115 + v44) = v48[8];
          v113[v44] = v49;
          *((_DWORD *)v46 + 3) = v49;
          *(_DWORD *)int16x8_t v46 = v13;
          *(void *)(v46 + 4) = 1;
          *(void *)(v46 + 20) = 0x100000000;
          *((_DWORD *)v46 + 7) = 2;
          *((_DWORD *)v46 + 8) = v23[847];
          *((void *)v46 - 1) = *(void *)&v24[4 * v23[v47 + 839] + 2];
          ++v45;
          v46 += 72;
          ++v44;
        }
        while (v44 < v24[23]);
      }
    }
    int v57 = a1[1];
    uint64_t v100 = v57[21];
    uint64_t v58 = v105;
    if ((int)v100 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v59 = 0;
      int v60 = 0;
      int v106 = 0;
      int v107 = v23[851];
      uint64_t v61 = v57[20];
      LOBYTE(v104) = 7;
      __int16 v108 = v22;
      unsigned int v101 = v57[20];
      while (1)
      {
        if (v58)
        {
          uint64_t v62 = *((int *)a1 + 1650);
          int16x8_t v63 = v110;
          int16x8_t v64 = v115;
          int16x8_t v65 = v113;
          uint64_t v66 = v58;
          do
          {
            uint64_t v67 = *v65++;
            uint64_t v68 = *v64 + v67 * v59 + v62 + *((int *)v63 + 10);
            uint64_t v69 = v68 - *((int *)v63 + 11);
            *(void *)int16x8_t v63 = v68;
            *((void *)v63 + 1) = v69;
            *((void *)v63 + 2) = v68;
            if (!*((unsigned char *)v63 + 68)) {
              *((_DWORD *)v63 + 12) = *(_DWORD *)((char *)v63 + ((8 * (v106 != 0)) | 0x34));
            }
            int16x8_t v63 = (_OWORD *)((char *)v63 + 72);
            ++v64;
            --v66;
          }
          while (v66);
        }
        if ((int)v61 >= 1) {
          break;
        }
LABEL_148:
        ++*(_DWORD *)(a2 + 36);
        ++v59;
        ++v106;
        if (v59 == v100) {
          return 0;
        }
      }
      int v70 = 0;
      int v71 = 0;
      while (1)
      {
        if (!*(void *)(v4 + 16) && *(int *)(v4 + 24) <= 6)
        {
          uint64_t v105 = v58;
          int v72 = v70;
          int v73 = v60;
          uint64_t result = aj_istream_fill_buf(v4, -9);
          uint64_t v61 = v101;
          int v60 = v73;
          int v70 = v72;
          if (result) {
            return result;
          }
        }
        if (v107 < 1 || v60 != v107) {
          goto LABEL_109;
        }
        int16x8_t v74 = *(unsigned __int8 **)(v4 + 16);
        if (!v74) {
          break;
        }
        int v104 = ((_BYTE)v104 + 1) & 7;
        int v75 = *v74;
        if ((v104 | 0xD0) != v75)
        {
          aj_log_error(0, "Bitstream corrupt: Wrong marker (%02X) found.", v75);
          return 7;
        }
        uint64_t v76 = v61;
        *(_DWORD *)uint64_t v4 = 0;
        *(_DWORD *)(v4 + 24) = -9;
        *(void *)(v4 + 16) = 0;
        uint64_t result = aj_istream_fill_buf(v4, -9);
        if (result) {
          return result;
        }
        if (v58)
        {
          uint64_t v77 = v58;
          int16x8_t v78 = v112;
          uint64_t v61 = v76;
          do
          {
            if (!*((unsigned char *)v78 + 20)) {
              *(_DWORD *)int16x8_t v78 = *((_DWORD *)v78 + 1);
            }
            int16x8_t v78 = (_OWORD *)((char *)v78 + 72);
            --v77;
          }
          while (v77);
          int v60 = 0;
          int v106 = 0;
          int v71 = 0;
LABEL_109:
          if (!v58) {
            goto LABEL_147;
          }
          int v102 = v70;
          int v103 = v60;
          uint64_t v79 = 12;
          if (!v106) {
            uint64_t v79 = 4;
          }
          uint64_t v80 = v79 + 52;
          int16x8_t v81 = v110;
          while (2)
          {
            __int16 v82 = v22;
            if (*((unsigned char *)v81 + 68))
            {
              if (v14) {
                goto LABEL_115;
              }
LABEL_141:
              **((unsigned char **)v81 + 2) = v82;
              int16x8_t v83 = (__int16 *)*((void *)v81 + 2);
            }
            else
            {
              uint64_t v84 = -(uint64_t)*((int *)v81 + 9);
              int8x8x4_t v85 = (_WORD *)*((void *)v81 + 1);
              uint64_t v86 = *((void *)v81 + 2);
              int v87 = *((_DWORD *)v81 + 12);
              if (v14)
              {
                switch(v87)
                {
                  case 0:
                    goto LABEL_120;
                  case 1:
                    LOWORD(v88) = *(_WORD *)(v86 - 2 * *((int *)v81 + 9));
                    break;
                  case 2:
                    LOWORD(v88) = *v85;
                    break;
                  case 3:
                    LOWORD(v88) = v85[(int)v84];
                    break;
                  case 4:
                    __int16 v89 = *v85 + *(_WORD *)(v86 + 2 * (int)v84);
                    __int16 v90 = v85[(int)v84];
                    goto LABEL_132;
                  case 5:
                    int v91 = *(unsigned __int16 *)(v86 + 2 * (int)v84);
                    int v92 = (unsigned __int16)*v85;
                    int v93 = (unsigned __int16)v85[(int)v84];
                    goto LABEL_134;
                  case 6:
                    int v94 = (unsigned __int16)*v85;
                    int v95 = *(unsigned __int16 *)(v86 + 2 * (int)v84);
                    int v96 = (unsigned __int16)v85[(int)v84];
                    goto LABEL_136;
                  case 7:
                    int v97 = *(unsigned __int16 *)(v86 + 2 * (int)v84);
                    int v98 = (unsigned __int16)*v85;
                    goto LABEL_138;
                  default:
                    goto LABEL_121;
                }
              }
              else
              {
                switch(v87)
                {
                  case 0:
LABEL_120:
                    unsigned int v88 = 1 << (*((unsigned char *)*a1 + 4) - 1);
                    break;
                  case 1:
                    LOWORD(v88) = *(unsigned __int8 *)(v86 - *((int *)v81 + 9));
                    break;
                  case 2:
                    LOWORD(v88) = *(unsigned __int8 *)v85;
                    break;
                  case 3:
                    LOWORD(v88) = *((unsigned __int8 *)v85 - *((int *)v81 + 9));
                    break;
                  case 4:
                    __int16 v89 = *(unsigned __int8 *)v85 + *(unsigned __int8 *)(v86 - *((int *)v81 + 9));
                    __int16 v90 = *((unsigned __int8 *)v85 - *((int *)v81 + 9));
LABEL_132:
                    LOWORD(v88) = v89 - v90;
                    break;
                  case 5:
                    int v91 = *(unsigned __int8 *)(v86 - *((int *)v81 + 9));
                    int v92 = *(unsigned __int8 *)v85;
                    int v93 = *((unsigned __int8 *)v85 - *((int *)v81 + 9));
LABEL_134:
                    unsigned int v88 = v91 + ((v92 - v93) >> 1);
                    break;
                  case 6:
                    int v94 = *(unsigned __int8 *)v85;
                    int v95 = *(unsigned __int8 *)(v86 - *((int *)v81 + 9));
                    int v96 = *((unsigned __int8 *)v85 - *((int *)v81 + 9));
LABEL_136:
                    unsigned int v88 = v94 + ((v95 - v96) >> 1);
                    break;
                  case 7:
                    int v97 = *(unsigned __int8 *)(v86 - *((int *)v81 + 9));
                    int v98 = *(unsigned __int8 *)v85;
LABEL_138:
                    unsigned int v88 = (v98 + v97) >> 1;
                    break;
                  default:
LABEL_121:
                    LOWORD(v88) = 0;
                    break;
                }
              }
              int v109 = 0;
              uint64_t result = aj_huffman_decode_val(*((void *)v81 + 3), v4, 1, &v109);
              if (result) {
                return result;
              }
              __int16 v82 = HIWORD(v109) + v88;
              __int16 v22 = v108;
              if (!v14) {
                goto LABEL_141;
              }
LABEL_115:
              int16x8_t v83 = (__int16 *)*((void *)v81 + 2);
              *int16x8_t v83 = v82;
            }
            uint64_t v99 = *((int *)v81 + 8);
            *((void *)v81 + 1) += v99;
            *((void *)v81 + 2) = (char *)v83 + v99;
            if (!v71) {
              *((_DWORD *)v81 + 12) = *(_DWORD *)((char *)v81 + v80);
            }
            int16x8_t v81 = (_OWORD *)((char *)v81 + 72);
            if (!--v58)
            {
              uint64_t v58 = v105;
              uint64_t v61 = v101;
              int v70 = v102;
              int v60 = v103;
              goto LABEL_147;
            }
            continue;
          }
        }
        int v71 = 0;
        int v106 = 0;
        int v60 = 0;
        uint64_t v61 = v76;
LABEL_147:
        ++v70;
        ++v60;
        ++v71;
        if (v70 == v61) {
          goto LABEL_148;
        }
      }
      if (*(int *)(v4 + 32) > 1) {
        return 7;
      }
      uint64_t result = 7;
      if (*(unsigned char *)(v4 + 112))
      {
        if (*(_DWORD *)(v4 + 56) == 1) {
          return 4294967294;
        }
        else {
          return 7;
        }
      }
    }
  }
  return result;
}

uint64_t aj_dct_prescale_qtable(uint64_t result, uint64_t a2)
{
  for (uint64_t i = 0; i != 64; ++i)
    *(_WORD *)(a2 + 2 * i) = dword_21040FBD0[8 * (i >> 3) + (i & 7)] / *(_DWORD *)(result + 4 * i);
  return result;
}

uint64_t aj_get_qtable_for_quality(uint64_t result, int a2, int a3, int a4)
{
  uint64_t v4 = 0;
  uint64_t v5 = &base_qtable_luma;
  if (!a3) {
    uint64_t v5 = &base_qtable_chroma;
  }
  int v6 = 5000 / a2;
  if (a2 >= 51) {
    int v6 = 200 - 2 * a2;
  }
  if (a2 > 99) {
    int v6 = 0;
  }
  do
  {
    if (a4) {
      int v7 = aj_glob_zigzag[v4];
    }
    else {
      int v7 = v4;
    }
    uint64_t v8 = 1374389535 * (v5[v7] * v6 + 50);
    int v9 = (v8 >> 37) + ((unint64_t)v8 >> 63);
    if (v9 <= 1) {
      int v9 = 1;
    }
    if (v9 >= 0xFF) {
      int v9 = 255;
    }
    *(_DWORD *)(result + 4 * v4++) = v9;
  }
  while (v4 != 64);
  return result;
}

uint8x8_t **aj_icol_row_444_to_rgb(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64x2_t a9, uint64_t a10, uint64_t a11, unsigned int a12)
{
  uint8x8_t v12 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  int v13 = *result;
  int v14 = *a2;
  int v15 = *a3;
  for (unsigned int i = a12 >> 3; i; --i)
  {
    uint8x8_t v17 = *v13++;
    uint8x8_t v18 = *v14++;
    uint8x8_t v19 = *v15++;
    int16x8_t v20 = (int16x8_t)vshll_n_u8(v17, 7uLL);
    int16x8_t v21 = (int16x8_t)vsubl_u8(v18, v12);
    int16x8_t v22 = (int16x8_t)vsubl_u8(v19, v12);
    v27.val[2] = vqrshrun_n_s16(vqaddq_s16(v20, vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    v27.val[0] = vqrshrun_n_s16(vqaddq_s16(v20, vmulq_n_s16(v22, 179)), 7uLL);
    v27.val[1] = vqrshrun_n_s16(vqsubq_s16(v20, vqaddq_s16(vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v22, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    vst3_s8(a4, v27);
    a4 += 24;
  }
  if ((a12 & 7) != 0)
  {
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*v13, 7uLL);
    int16x8_t v24 = (int16x8_t)vsubl_u8(*v14, v12);
    int16x8_t v25 = (int16x8_t)vsubl_u8(*v15, v12);
    *(int8x8_t *)a9.i8 = vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL);
    *(int8x8_t *)a7.i8 = vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL);
    *(int8x8_t *)a8.i8 = vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL);
    int v26 = a12 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4[2] = a9.i8[0];
      a4 += 3;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      a9 = vshrq_n_u64(a9, 8uLL);
      --v26;
    }
    while (v26);
  }
  return result;
}

uint64_t aj_idct_s1_8x16_nearest(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  int16x8_t v63 = a2 + 2;
  uint64_t v66 = *v63;
  uint64_t v67 = v63[1];
  v63 += 2;
  uint64_t v68 = *v63;
  uint64_t v69 = v63[1];
  v63 += 2;
  int16x8_t v70 = vaddq_s16(v60, v59);
  int16x8_t v71 = vaddq_s16(v55, v56);
  int16x8_t v72 = vsubq_s16(v55, v56);
  int16x8_t v73 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v74 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v75 = vaddq_s16(v61, v58);
  int16x8_t v76 = vsubq_s16(v58, v61);
  int16x8_t v77 = vaddq_s16(v57, v74);
  int16x8_t v78 = vsubq_s16(v57, v74);
  int16x8_t v79 = vaddq_s16(v77, v75);
  int16x8_t v80 = vaddq_s16(v70, v73);
  int16x8_t v81 = vaddq_s16(v71, v80);
  int16x8_t v82 = vsubq_s16(v71, v80);
  int16x8_t v83 = vqrdmulhq_lane_s16(vaddq_s16(v76, v78), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v84 = vqrdmulhq_lane_s16(vsubq_s16(v77, v75), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v85 = vsubq_s16(v72, v73);
  int16x8_t v86 = vaddq_s16(v72, v73);
  int16x8_t v87 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 2), v78), v83);
  int16x8_t v88 = vaddq_s16(vqrdmulhq_lane_s16(v76, (int16x4_t)0x30FC273D5A824546, 0), v83);
  int16x8_t v89 = vaddq_s16(v79, v87);
  int16x8_t v90 = vaddq_s16(v87, v84);
  int16x8_t v91 = vaddq_s16(v88, v84);
  int16x8_t v92 = vaddq_s16(v86, v90);
  int16x8_t v93 = vaddq_s16(v85, v91);
  int16x8_t v94 = vaddq_s16(v82, v88);
  int16x8_t v95 = vsubq_s16(v82, v88);
  int16x8_t v96 = vsubq_s16(v85, v91);
  int16x8_t v97 = vsubq_s16(v86, v90);
  int16x8_t v98 = vsubq_s16(v81, v89);
  *(int8x8_t *)v89.i8 = vqrshrn_n_s16(vaddq_s16(v81, v89), 5uLL);
  *(int8x8_t *)v91.i8 = vqrshrn_n_s16(v92, 5uLL);
  *(int8x8_t *)v86.i8 = vqrshrn_n_s16(v93, 5uLL);
  *(int8x8_t *)v77.i8 = vqrshrn_n_s16(v94, 5uLL);
  *(int8x8_t *)v76.i8 = vqrshrn_n_s16(v95, 5uLL);
  *(int8x8_t *)v81.i8 = vqrshrn_n_s16(v96, 5uLL);
  *(int8x8_t *)v85.i8 = vqrshrn_n_s16(v97, 5uLL);
  *(int8x8_t *)v46.i8 = vqrshrn_n_s16(v98, 5uLL);
  _X3 = (char *)(v64 + a3);
  _X4 = (char *)(v65 + a3);
  _X5 = (char *)(v66 + a3);
  _X6 = (char *)(v67 + a3);
  _X7 = (char *)(v68 + a3);
  _X9 = (char *)(v69 + a3);
  _X10 = (char *)(*v63 + a3);
  _X11 = (char *)(v63[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  *(int8x8_t *)v55.i8 = vadd_s8(*(int8x8_t *)v89.i8, (int8x8_t)0x8080808080808080);
  v92.i64[0] = v55.i64[0];
  *(int8x8_t *)v93.i8 = vadd_s8(*(int8x8_t *)v91.i8, (int8x8_t)0x8080808080808080);
  v94.i64[0] = v93.i64[0];
  *(int8x8_t *)v95.i8 = vadd_s8(*(int8x8_t *)v86.i8, (int8x8_t)0x8080808080808080);
  v96.i64[0] = v95.i64[0];
  *(int8x8_t *)v97.i8 = vadd_s8(*(int8x8_t *)v77.i8, (int8x8_t)0x8080808080808080);
  v98.i64[0] = v97.i64[0];
  *(int8x8_t *)v89.i8 = vadd_s8(*(int8x8_t *)v76.i8, (int8x8_t)0x8080808080808080);
  v91.i64[0] = v89.i64[0];
  *(int8x8_t *)v86.i8 = vadd_s8(*(int8x8_t *)v81.i8, (int8x8_t)0x8080808080808080);
  v77.i64[0] = v86.i64[0];
  *(int8x8_t *)v76.i8 = vadd_s8(*(int8x8_t *)v85.i8, (int8x8_t)0x8080808080808080);
  v81.i64[0] = v76.i64[0];
  *(int8x8_t *)v85.i8 = vadd_s8(*(int8x8_t *)v46.i8, (int8x8_t)0x8080808080808080);
  v46.i64[0] = v85.i64[0];
  vst2_s8(_X3, (int8x8x2_t)v55);
  vst2_s8(_X4, (int8x8x2_t)v93);
  vst2_s8(_X5, (int8x8x2_t)v95);
  vst2_s8(_X6, (int8x8x2_t)v97);
  vst2_s8(_X7, (int8x8x2_t)v89);
  vst2_s8(_X9, *(int8x8x2_t *)((char *)&v77 - 8));
  vst2_s8(_X10, (int8x8x2_t)v76);
  vst2_s8(_X11, *(int8x8x2_t *)((char *)&v46 - 8));
  return 16;
}

uint64_t aj_bufferproc_resize_get_blendrows(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v5 + 1106))
  {
    *a4 = 0;
    *a5 = 0;
  }
  return get_startposition_for_thread(v5, 0, *(_DWORD *)(v5 + 4) + *(_DWORD *)(v5 + 1108), a4, a5);
}

uint64_t get_startposition_for_thread(uint64_t a1, unsigned int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  if (!a3) {
    return 0;
  }
  if (a5) {
    *a5 = 0;
  }
  unint64_t v7 = *(void *)(a1 + 8 * a2 + 168);
  uint64_t v8 = (a3 - 1);
  unint64_t v9 = (v8 << 32) - 0x110000001;
  if ((unint64_t)(v8 << 32) < 0x110000001) {
    unint64_t v9 = 0;
  }
  int v10 = v9 / v7 + 1;
  uint64_t v11 = v7 * v10;
  unint64_t v12 = (unint64_t)(v11 + 0x10000000) >> 32;
  if (a3 + 2 > (int)v12)
  {
    uint64_t v13 = v7 * v10;
    do
    {
      if (a5) {
        ++*a5;
      }
      v13 += v7;
      ++v10;
      if ((int)v8 > (int)v12) {
        uint64_t v11 = v13;
      }
      unint64_t v12 = (unint64_t)(v13 + 0x10000000) >> 32;
    }
    while (a3 + 2 > (int)v12);
    if (a2) {
      goto LABEL_23;
    }
    goto LABEL_17;
  }
  uint64_t v13 = v7 * v10;
  if (!a2)
  {
LABEL_17:
    int v14 = *(_DWORD *)(a1 + 68);
    if (v14)
    {
      unint64_t v15 = *(void *)(a1 + 176);
      if (v15)
      {
        unsigned int v16 = (get_startposition_for_thread() / v15) << v14;
        BOOL v17 = __OFSUB__(v16, v10);
        int v18 = v16 - v10;
        if (!((v18 < 0) ^ v17 | (v18 == 0)))
        {
          do
          {
            if (a5) {
              ++*a5;
            }
            v13 += v7;
            --v18;
          }
          while (v18);
        }
      }
    }
  }
LABEL_23:
  if (a4) {
    *a4 = ((unint64_t)(v13 - v11) >> 32) + 3;
  }
  return v13;
}

void aj_bufferproc_resize(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a3 + 1082)) {
    *(unsigned char *)(v5 + 264) = 0;
  }
  BOOL v79 = a5 + a4 >= *(_DWORD *)(v5 + 4) && *(unsigned char *)(v5 + 1106) != 0;
  v84[0] = 0;
  v84[1] = 0;
  v83[0] = 0;
  v83[1] = 0;
  uint64_t v6 = *(unsigned int *)(a2 + 6464);
  if ((int)v6 >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      int v8 = a4;
      if (v7) {
        int v8 = (*(_DWORD *)(v5 + 68) + a4) >> *(_DWORD *)(v5 + 68);
      }
      *(_DWORD *)((char *)v83 + v7) = v8;
      v7 += 4;
    }
    while (4 * v6 != v7);
    int16x8_t v74 = (unsigned char *)(a2 + 6577);
    uint64_t v73 = a3 + 568;
    while (1)
    {
      uint64_t v6 = v6;
      if (!LODWORD(v83[0]))
      {
        uint64_t v9 = 1;
        do
        {
          unint64_t v10 = v9;
          if (v6 == v9) {
            break;
          }
        }
        while (!*((_DWORD *)v83 + v9++));
        if (v10 >= v6) {
          return;
        }
      }
      v82[0] = 0;
      v82[1] = 0;
      int32x4_t v81 = 0uLL;
      int32x4_t v81 = vsubq_s32(*(int32x4_t *)(v5 + 976), *(int32x4_t *)(v5 + 960));
      unint64_t v12 = (__int32 *)v82;
      uint64_t v13 = &v81;
      int v14 = (__int32 *)v83;
      do
      {
        __int32 v16 = *v14++;
        __int32 v15 = v16;
        __int32 v18 = v13->i32[0];
        uint64_t v13 = (int32x4_t *)((char *)v13 + 4);
        __int32 v17 = v18;
        if (v15 >= v18) {
          __int32 v15 = v17;
        }
        *v12++ = v15;
        --v6;
      }
      while (v6);
      if (*v74)
      {
        uint64_t v19 = 0;
        *(_OWORD *)&src.data = xmmword_21040FED8;
        *(_OWORD *)&dest.data = xmmword_21040FED8;
        uint64_t v20 = v73;
        do
        {
          int16x8_t v21 = (int *)(v5 + 8 * v19);
          src.width = *v21;
          src.rowBytes = src.width;
          dest.width = v21[8];
          dest.rowBytes = dest.width;
          uint64_t v22 = *((unsigned int *)v82 + v19);
          if ((int)v22 >= 1)
          {
            uint64_t v23 = 0;
            int16x8_t v24 = (_DWORD *)(v5 + 4 * v19);
            int16x8_t v25 = v24 + 240;
            int16x8_t v26 = v24 + 248;
            int16x8_t v27 = v24 + 244;
            uint64_t v28 = v20 + 8 * *((int *)v84 + v19);
            do
            {
              src.data = *(void **)(v28 + 8 * v23);
              dest.data = *(void **)(v5 + 168 * v19 + 8 * (((int)v23 + *v25 + *v26) % *v27) + 272);
              vImage_Error v29 = vImageHorizontalShear_Planar8(&src, &dest, 0, 0, 0.0, 0.0, *(ResamplingFilter *)(v5 + 1112), 0, 8u);
              if (v29) {
                aj_log_error(0, "vImage returned error: %ld\n", v29);
              }
              ++v23;
            }
            while (v22 != v23);
          }
          *(_DWORD *)(v5 + 4 * v19++ + 960) += v22;
          uint64_t v30 = a2;
          uint64_t v6 = *(int *)(a2 + 6464);
          v20 += 128;
        }
        while (v19 < v6);
      }
      else
      {
        uint64_t v31 = 0;
        uint64_t v77 = v73;
        do
        {
          uint64_t v32 = *((unsigned int *)v82 + v31);
          if ((int)v32 >= 1)
          {
            uint64_t v33 = 0;
            int16x8_t v34 = (_DWORD *)(v5 + 4 * v31);
            int16x8_t v35 = v34 + 240;
            int16x8_t v36 = v34 + 248;
            int16x8_t v37 = v34 + 244;
            uint64_t v38 = v77 + 8 * *((int *)v84 + v31);
            do
            {
              memcpy(*(void **)(v5 + 168 * v31 + 8 * (((int)v33 + *v35 + *v36) % *v37) + 272), *(const void **)(v38 + 8 * v33), *(int *)(v5 + 8 * v31));
              ++v33;
            }
            while (v32 != v33);
          }
          *(_DWORD *)(v5 + 4 * v31++ + 960) += v32;
          uint64_t v30 = a2;
          uint64_t v6 = *(int *)(a2 + 6464);
          v77 += 128;
        }
        while (v31 < v6);
      }
      uint64_t v39 = *(void *)(a1 + 32);
      uint64_t v86 = 0;
      memset(&src, 0, sizeof(src));
      if (!*(unsigned char *)(v39 + 264)) {
        break;
      }
LABEL_36:
      if (v79)
      {
        if ((int)v6 <= 0) {
          return;
        }
        if (*(_DWORD *)(v39 + 1072))
        {
LABEL_39:
          if (!*(unsigned char *)(v39 + 264))
          {
            outbuffer_drain(a1, v30, a3);
            LODWORD(v6) = *(_DWORD *)(v30 + 6464);
          }
        }
        else
        {
          unint64_t v69 = 0;
          while (v6 - 1 != v69)
          {
            if (*(_DWORD *)(v39 + 1076 + 4 * v69++))
            {
              if (v69 < v6) {
                goto LABEL_39;
              }
              break;
            }
          }
        }
      }
      if ((int)v6 < 1) {
        return;
      }
      uint64_t v71 = 0;
      do
      {
        int v72 = *(_DWORD *)((char *)v82 + v71);
        *(_DWORD *)((char *)v84 + v71) += v72;
        *(_DWORD *)((char *)v83 + v71) -= v72;
        v71 += 4;
      }
      while (4 * v6 != v71);
    }
    while (1)
    {
      LODWORD(v6) = *(_DWORD *)(v30 + 6464);
      if ((int)v6 < 1) {
        goto LABEL_36;
      }
      uint64_t v40 = 0;
      int v41 = 0;
      do
      {
        int32x4_t v42 = (int *)(v39 + 4 * v40);
        uint64_t v43 = v42[268];
        if ((int)v43 < v42[272])
        {
          uint64_t v44 = v39 + 8 * v40;
          uint64_t v46 = *(void *)(v44 + 200);
          int32x4_t v45 = (uint64_t *)(v44 + 200);
          unsigned int v47 = v46 + 0x10000000;
          unint64_t v48 = (unint64_t)(v46 + 0x10000000) >> 32;
          int64x2_t v49 = v42 + 236;
          int v50 = v42[236];
          int64x2_t v51 = v42 + 240;
          int v52 = v42[240];
          int v53 = v48 + 2;
          if (v79) {
            int v53 = v48;
          }
          if (v52 + v50 > v53)
          {
            uint64_t v54 = 0;
            int16x8_t v55 = v42 + 268;
            uint64_t v56 = v39 + 4 * v40;
            int16x8_t v57 = (int *)(v56 + 992);
            int16x8_t v58 = (_DWORD *)(v56 + 976);
            int v59 = v48 - v50 - 2;
            do
            {
              if (v59 + v54 < 0)
              {
                int v62 = *v57 % *v58;
              }
              else
              {
                int v60 = *v57;
                if (v59 + (int)v54 >= v52) {
                  int v61 = v52 - 1 + v60;
                }
                else {
                  int v61 = v59 + v54 + v60;
                }
                int v62 = v61 % *v58;
              }
              *((void *)&src.data + v54++) = *(void *)(v39 + 168 * v40 + 8 * v62 + 272);
            }
            while (v54 != 5);
            uint64_t v63 = v39 + 8 * v40;
            (*(void (**)(vImage_Buffer *, uint64_t, void, void))(v39 + 80))(&src, v39 + 10 * (v47 >> 29) + 88, *(unsigned int *)(v63 + 32), *(void *)(v39 + 16 * v40 + 8 * v43 + 1008));
            ++*v55;
            uint64_t v64 = *v45;
            if (*(int *)(v63 + 4) > 1)
            {
              v64 += *(void *)(v63 + 168);
              *int32x4_t v45 = v64;
            }
            unint64_t v48 = (unint64_t)(v64 + 0x10000000) >> 32;
            int v50 = *v49;
            int v52 = *v51;
            int v41 = 1;
            uint64_t v30 = a2;
          }
          int v65 = v48 - v50 - 2;
          if (v65 >= v52) {
            int v65 = v52;
          }
          if (v65 >= 1)
          {
            *(_DWORD *)(v39 + 4 * v40 + 992) = (*(_DWORD *)(v39 + 4 * v40 + 992) + v65)
                                             % *(_DWORD *)(v39 + 4 * v40 + 976);
            *int64x2_t v51 = v52 - v65;
            *int64x2_t v49 = v65 + v50;
          }
        }
        ++v40;
        uint64_t v6 = *(int *)(v30 + 6464);
      }
      while (v40 < v6);
      if (!v41) {
        goto LABEL_36;
      }
      if ((int)v6 < 1) {
        goto LABEL_70;
      }
      if (*(_DWORD *)(v39 + 1072) >= *(_DWORD *)(v39 + 1088)) {
        break;
      }
LABEL_71:
      if (*(unsigned char *)(v39 + 264))
      {
        LODWORD(v6) = *(_DWORD *)(v30 + 6464);
        goto LABEL_36;
      }
    }
    unint64_t v66 = 0;
    unint64_t v67 = *(unsigned int *)(v30 + 6464);
    while (v67 - 1 != v66)
    {
      uint64_t v68 = v39 + 4 * v66++;
      if (*(_DWORD *)(v68 + 1076) < *(_DWORD *)(v68 + 1092))
      {
        if (v66 < v67) {
          goto LABEL_71;
        }
        break;
      }
    }
LABEL_70:
    outbuffer_drain(a1, v30, a3);
    goto LABEL_71;
  }
}

uint64_t aj_bufferproc_resize_maxout(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4 = ((unint64_t)(a4 + 3) << 32) / *(void *)(*(void *)(a1 + 32) + 168)
     + *(_DWORD *)(a1 + 44);
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v5 + 8))(v5, a2, a3, (v4 + 1));
  }
  else {
    return (v4 + 1);
  }
}

uint64_t aj_bufferproc_resize_init(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  v88[40] = *MEMORY[0x263EF8340];
  uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, void))a4)(1120, *(void *)(a4 + 16));
  if (!v9) {
    return 6;
  }
  uint64_t v10 = (uint64_t)v9;
  bzero(v9, 0x460uLL);
  unsigned int v11 = *(_DWORD *)(a1 + 40);
  *(void *)(a1 + 32) = v10;
  *(_DWORD *)(v10 + 64) = aj_highest_set_bit(v11) - 1;
  int32x4_t v81 = (long long *)(a1 + 40);
  *(_DWORD *)(v10 + 68) = aj_highest_set_bit(*(_DWORD *)(a1 + 44)) - 1;
  *(_DWORD *)(v10 + 72) = 0;
  BOOL v12 = a3[7] == *(_DWORD *)(a2 + 6840);
  int v14 = a3[6] - *(_DWORD *)(a2 + 6836);
  BOOL v13 = a3[6] == *(_DWORD *)(a2 + 6836);
  *(unsigned char *)(v10 + 1105) = v13;
  *(unsigned char *)(v10 + 1106) = v12;
  int v15 = *(_DWORD *)(a2 + 172) * v14;
  *(_DWORD *)(v10 + 1108) = v15;
  if (!v13) {
    *(_DWORD *)(v10 + 1108) = v15 - *(_DWORD *)(a2 + 6856);
  }
  uint64_t v84 = a1;
  double v16 = (double)*(int *)(a2 + 6504) / (double)*(int *)(a2 + 6620);
  double v17 = 0.5;
  if (v16 >= 0.5)
  {
    double v17 = (double)*(int *)(a2 + 6504) / (double)*(int *)(a2 + 6620);
    if (v16 > 1.0) {
      double v17 = 1.0;
    }
  }
  uint64_t v82 = a5;
  uint64_t v18 = 0;
  uint64_t v19 = v88;
  double v20 = 0.125;
  do
  {
    uint64_t v21 = 0;
    double v22 = 0.0;
    do
    {
      double v23 = v17 * ((double)((int)v21 - 2) + -(double)(int)v18 * v20);
      BOOL v24 = v23 > -2.0 && v23 < 2.0;
      double v25 = 0.0;
      if (v24)
      {
        double v25 = 1.0;
        if (v23 != 0.0)
        {
          double v26 = v23 * 3.14159265;
          long double v27 = sin(v23 * 3.14159265);
          long double v28 = v23 * 0.5 * 3.14159265;
          long double v29 = v27 / v26;
          long double v30 = sin(v28);
          double v20 = 0.125;
          double v25 = v29 * (v30 / v28);
        }
      }
      *(double *)&v19[v21] = v25;
      double v22 = v22 + v25;
      ++v21;
    }
    while (v21 != 5);
    v87[v18++] = v22;
    v19 += 5;
  }
  while (v18 != 8);
  uint64_t v31 = 0;
  for (uint64_t i = 0; i != 8; ++i)
  {
    __int16 v33 = 0;
    double v34 = v87[i];
    uint64_t v35 = v31;
    uint64_t v36 = 5;
    do
    {
      double v37 = *(double *)&v88[v35] / v34;
      *(double *)&v88[v35] = v37;
      __int16 v38 = llround(v37 * 16384.0);
      *(_WORD *)(v10 + 2 * v35 + 88) = v38;
      v33 += v38;
      ++v35;
      --v36;
    }
    while (v36);
    *(_WORD *)(v10 + 10 * i + 92) = *(_WORD *)(v10 + 10 * i + 92) - v33 + 0x4000;
    v31 += 5;
  }
  uint64_t v39 = aj_resize_vertically;
  if (!*(unsigned char *)(a2 + 6576)) {
    uint64_t v39 = aj_memcpy_wrapper;
  }
  *(void *)(v10 + 80) = v39;
  uint64_t v40 = *(unsigned int *)(a2 + 6464);
  if ((int)v40 < 1)
  {
LABEL_63:
    uint64_t v73 = 1;
    *(unsigned char *)(v10 + 1104) = 1;
    ResamplingFilter v74 = vImageNewResamplingFilter((float)*(int *)(a2 + 6500) / (float)*(int *)(a2 + 6616), 0);
    *(void *)(v10 + 1112) = v74;
    if (v74)
    {
      long long v75 = *v81;
      long long v76 = v81[1];
      *(void *)(v82 + 32) = *((void *)v81 + 4);
      *(_OWORD *)uint64_t v82 = v75;
      *(_OWORD *)(v82 + 16) = v76;
      if (*(int *)(a2 + 6464) >= 1)
      {
        uint64_t v77 = 0;
        int16x8_t v78 = (_DWORD *)(v10 + 36);
        do
        {
          uint64_t v79 = v82 + 4 * v77;
          *(_DWORD *)(v79 + 24) = *v78;
          *(_DWORD *)(v79 + 8) = *(v78 - 1);
          ++v77;
          v78 += 2;
        }
        while (v77 < *(int *)(a2 + 6464));
      }
      return 0;
    }
  }
  else
  {
    int v41 = a3 + 38;
    unsigned int v86 = v40 - 1;
    while (1)
    {
      uint64_t v83 = v40--;
      if (v40)
      {
        int v43 = *(_DWORD *)(v10 + 64);
        int v42 = *(_DWORD *)(v10 + 68);
      }
      else
      {
        int v43 = 0;
        int v42 = 0;
      }
      int v44 = (*(_DWORD *)(a2 + 6620) + v42) >> v42;
      int v45 = (*(_DWORD *)(a2 + 6504) + v42) >> v42;
      if (v44 <= 2) {
        int v44 = 2;
      }
      unint64_t v46 = (unint64_t)(v44 - 1) << 32;
      if (v45 <= 2) {
        int v47 = 2;
      }
      else {
        int v47 = (*(_DWORD *)(a2 + 6504) + v42) >> v42;
      }
      unint64_t v48 = v46 / (v47 - 1);
      uint64_t v49 = v10 + 8 * v40;
      if (v45 == 1) {
        ++v48;
      }
      *(void *)(v49 + 168) = v48;
      int v50 = (void *)(v49 + 168);
      uint64_t v51 = ((*(_DWORD *)(v10 + 1108) + v42) >> v42);
      if (v40 || (int v64 = *(_DWORD *)(v10 + 68)) == 0 || *(int *)(a2 + 6464) < 2)
      {
        uint64_t startposition_for_thread = get_startposition_for_thread(v10, v40, v51, 0, 0);
        *(void *)(v10 + 8 * v40 + 232) = startposition_for_thread;
      }
      else
      {
        *(void *)(v10 + 232) = *(void *)(v10 + 168)
                               * (int)((*(void *)(v10 + 240) / *(void *)(v10 + 176)) << v64);
        uint64_t startposition_for_thread = *(void *)(v10 + 232 + 8 * v40);
      }
      uint64_t v53 = v84 + 4 * v40;
      uint64_t v54 = v10 + 8 * v40;
      *(_DWORD *)uint64_t v54 = *(_DWORD *)(v53 + 48);
      int v55 = *(_DWORD *)(v53 + 64);
      *(_DWORD *)(v54 + 32) = (*(_DWORD *)(a2 + 6500) + v43) >> v43;
      uint64_t v56 = (int *)(v54 + 32);
      uint64_t v57 = startposition_for_thread - (v51 << 32);
      *(void *)(v54 + 200) = v57;
      *(_DWORD *)(v54 + 4) = v55;
      uint64_t v58 = (v55 - 1);
      if (v58)
      {
        unint64_t v59 = v58 << 32;
        unint64_t v60 = v59 - 0x110000001;
        if (v59 < 0x110000001) {
          unint64_t v60 = 0;
        }
        if (!*(unsigned char *)(v10 + 1106)) {
          unint64_t v59 = v60;
        }
        int v45 = (v59 - v57) / *v50 + 1;
      }
      *(_DWORD *)(v54 + 36) = v45;
      int v61 = ((*(_DWORD *)(a2 + 172) + v42) >> v42) + 5;
      uint64_t v62 = v10 + 4 * v40;
      *(_DWORD *)(v62 + 976) = v61;
      int v63 = v40 ? 1 : *(_DWORD *)(v84 + 44);
      *(_DWORD *)(v62 + 1088) = v63;
      BOOL v65 = *(_DWORD *)(a2 + 24) == 2 && *(_DWORD *)(a2 + 48) > 1;
      uint64_t v66 = aj_rowbuffer_add_block(v41, (uint64_t (**)(size_t, void))a4, *v56, v63 + v61 + v65, 0x10uLL);
      if (v66) {
        return v66;
      }
      if (*(int *)(v62 + 976) >= 1)
      {
        uint64_t v67 = 0;
        do
        {
          buffer = aj_rowbuffer_get_buffer(v41, *v56);
          *(void *)(v10 + 272 + 168 * v86 + 8 * v67) = buffer;
          if (!buffer) {
            return 1;
          }
        }
        while (++v67 < *(int *)(v62 + 976));
      }
      unint64_t v69 = (int *)(v62 + 1088);
      if (*v69 >= 1)
      {
        uint64_t v70 = 0;
        do
        {
          uint64_t v71 = aj_rowbuffer_get_buffer(v41, *v56);
          *(void *)(v10 + 1008 + 16 * v86 + 8 * v70) = v71;
          if (!v71) {
            return 1;
          }
        }
        while (++v70 < *v69);
      }
      int v72 = (_DWORD *)(v10 + 4 * v40);
      v72[236] = 0;
      v72[240] = 0;
      v72[248] = 0;
      --v86;
      if (v83 <= 1) {
        goto LABEL_63;
      }
    }
  }
  return v73;
}

uint64_t aj_bufferproc_resize_terminate(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 32);
  if (v4)
  {
    int v8 = *(void **)(v4 + 1112);
    if (v8) {
      vImageDestroyResamplingFilter(v8);
    }
    if (*(unsigned char *)(v4 + 1104))
    {
      if (*(int *)(a2 + 6464) >= 1)
      {
        uint64_t v9 = 0;
        uint64_t v10 = (unsigned int *)(a3 + 152);
        uint64_t v11 = v4 + 272;
        uint64_t v12 = v4 + 1008;
        do
        {
          uint64_t v13 = v4 + 4 * v9;
          if (*(int *)(v13 + 976) >= 1)
          {
            uint64_t v14 = 0;
            do
            {
              aj_rowbuffer_return_buffer(v10, *(void *)(v11 + 8 * v14));
              *(void *)(v11 + 8 * v14++) = 0;
            }
            while (v14 < *(int *)(v13 + 976));
          }
          if (*(int *)(v13 + 1088) >= 1)
          {
            uint64_t v15 = 0;
            double v16 = (int *)(v13 + 1088);
            do
            {
              aj_rowbuffer_return_buffer(v10, *(void *)(v12 + 8 * v15));
              *(void *)(v12 + 8 * v15++) = 0;
            }
            while (v15 < *v16);
          }
          ++v9;
          v11 += 168;
          v12 += 16;
        }
        while (v9 < *(int *)(a2 + 6464));
      }
      *(unsigned char *)(v4 + 1104) = 0;
    }
    uint64_t v18 = *(uint64_t (**)(uint64_t, uint64_t))(a4 + 8);
    uint64_t v17 = *(void *)(a4 + 16);
    return v18(v4, v17);
  }
  return result;
}

unsigned char *outbuffer_drain(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(uint64_t (***)(void, uint64_t, uint64_t, void, void))(a1 + 80);
  uint64_t v7 = *(unsigned int *)(a2 + 6464);
  if ((int)v7 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = (void *)(a3 + 568);
    uint64_t v10 = (uint64_t *)(v5 + 1008);
    uint64_t v11 = v26;
    do
    {
      uint64_t v12 = *(unsigned int *)(v5 + 4 * v8 + 1072);
      uint64_t v13 = v10;
      uint64_t v14 = v11;
      uint64_t v15 = v9;
      if ((int)v12 >= 1)
      {
        do
        {
          *v14++ = *v15;
          uint64_t v16 = *v13++;
          *v15++ = v16;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v9 += 16;
      v11 += 16;
      v10 += 2;
    }
    while (v8 != v7);
  }
  uint64_t result = (unsigned char *)(*v6)(v6, a2, a3, *(unsigned int *)(v5 + 1072), *(unsigned int *)(v5 + 72));
  int v18 = *(_DWORD *)(v5 + 72) + *(_DWORD *)(v5 + 1072);
  *(_DWORD *)(v5 + 72) = v18;
  if (v18 >= *(_DWORD *)(v5 + 36) && !*(unsigned char *)(a3 + 1082)) {
    *(unsigned char *)(v5 + 264) = 1;
  }
  if (*(int *)(a2 + 6464) >= 1)
  {
    uint64_t v19 = 0;
    double v20 = (unsigned int *)(a3 + 152);
    uint64_t v21 = a3 + 568;
    uint64_t v22 = v5 + 1008;
    double v23 = v26;
    do
    {
      BOOL v24 = (int *)(v5 + 4 * v19 + 1072);
      if (*v24 >= 1)
      {
        uint64_t v25 = 0;
        do
        {
          aj_rowbuffer_return_buffer(v20, *(void *)(v21 + 8 * v25));
          *(void *)(v21 + 8 * v25) = *(void *)&v23[8 * v25];
          uint64_t result = aj_rowbuffer_get_buffer(v20, *(int *)(v5 + 8 * v19 + 32));
          *(void *)(v22 + 8 * v25++) = result;
        }
        while (v25 < *v24);
      }
      int *v24 = 0;
      ++v19;
      v21 += 128;
      v23 += 16;
      v22 += 16;
    }
    while (v19 < *(int *)(a2 + 6464));
  }
  return result;
}

void *aj_memcpy_wrapper(uint64_t a1, int a2, int a3, void *__dst)
{
  return memcpy(__dst, *(const void **)(a1 + 16), a3);
}

uint64_t aj_reduce_init_unpack(uint64_t a1, int *a2, uint64_t a3, int **a4, void *a5, unsigned int *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  *a4 = (int *)a6;
  uint64_t result = aj_imageinfo_init(a6, (uint64_t)a4, a8);
  if (!result)
  {
    aj_reset_mcustate(a5, a7);
    uint64_t result = aj_init_huffman(a6, (uint64_t)a4, a8);
    if (!result)
    {
      uint64_t result = init_reduce(a2, a4, a3, a1, a8, a9);
      if (!result)
      {
        uint64_t v18 = 0;
        char v19 = 1;
        do
        {
          char v20 = v19;
          uint64_t v21 = &a4[2 * v18];
          uint64_t v22 = (uint64_t)v21[1];
          if (v22) {
            aj_huffman_encode_init_lookups(v22, (unsigned __int8 *)(v22 + 16), (uint64_t)&a2[512 * v18 + 33898], 0);
          }
          uint64_t v23 = (uint64_t)v21[2];
          if (v23) {
            aj_huffman_encode_init_lookups(v23, (unsigned __int8 *)(v23 + 16), (uint64_t)&a2[512 * v18 + 34154], (uint64_t)&a2[256 * v18 + 34922]);
          }
          char v19 = 0;
          uint64_t v18 = 1;
        }
        while ((v20 & 1) != 0);
        return 0;
      }
    }
  }
  return result;
}

uint64_t init_reduce(int *a1, int **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = (uint64_t *)(a1 + 33636);
  int v13 = *((_DWORD *)a2 + 20) * *((_DWORD *)a2 + 23);
  *((void *)a1 + 17718) = a2;
  uint64_t v14 = *(void *)a1;
  if (v14) {
    (*(void (**)(uint64_t, void))(a5 + 8))(v14, *(void *)(a5 + 16));
  }
  uint64_t v15 = (void *)(*(uint64_t (**)(uint64_t, void))a5)(132 * v13, *(void *)(a5 + 16));
  *(void *)(a4 + 16) = v15;
  *(void *)a1 = v15;
  if (!v15 || (bzero(v15, 132 * v13), (uint64_t v16 = *(void *)a1) == 0))
  {
    aj_log_error(0, "Could not allocate memory for block buffers.");
    return 6;
  }
  unint64_t v69 = a1 + 22401;
  uint64_t v17 = a1 + 11169;
  uint64_t v18 = *((int *)a2 + 20);
  int v19 = v18 * *((_DWORD *)a2 + 22);
  uint64_t v20 = v16 + 66 * v19;
  v18 *= 33;
  *((void *)a1 + 1) = v20;
  *((void *)a1 + 2) = v20 + 2 * v18;
  uint64_t v21 = v16 + 66 * v13;
  uint64_t v22 = v21 + 66 * v19;
  *((void *)a1 + 3) = v21;
  *((void *)a1 + 4) = v22;
  *((void *)a1 + 5) = v22 + 2 * v18;
  *((int8x16_t *)v12 + 19) = vextq_s8(*(int8x16_t *)(v12 + 41), *(int8x16_t *)(v12 + 41), 8uLL);
  determine_max_bits(&(*a2)[64 * (uint64_t)(*a2)[12] + 22], a1 + 11172);
  uint64_t v23 = *a2;
  BOOL v24 = a2;
  if (**a2 >= 2)
  {
    uint64_t v25 = v23[13];
    if (v25 == v23[14])
    {
      determine_max_bits(&v23[64 * v25 + 22], a1 + 22404);
      *((_OWORD *)a1 + 8421) = *((_OWORD *)a1 + 5613);
      *((_OWORD *)a1 + 8422) = *((_OWORD *)a1 + 5614);
      *((_OWORD *)a1 + 8423) = *((_OWORD *)a1 + 5615);
      *((_OWORD *)a1 + 8424) = *((_OWORD *)a1 + 5616);
      *((_OWORD *)a1 + 8417) = *((_OWORD *)a1 + 5609);
      *((_OWORD *)a1 + 8418) = *((_OWORD *)a1 + 5610);
      *((_OWORD *)a1 + 8419) = *((_OWORD *)a1 + 5611);
      *((_OWORD *)a1 + 8420) = *((_OWORD *)a1 + 5612);
      *((_OWORD *)a1 + 8413) = *((_OWORD *)a1 + 5605);
      *((_OWORD *)a1 + 8414) = *((_OWORD *)a1 + 5606);
      *((_OWORD *)a1 + 8415) = *((_OWORD *)a1 + 5607);
      *((_OWORD *)a1 + 8416) = *((_OWORD *)a1 + 5608);
      *((_OWORD *)a1 + 8409) = *((_OWORD *)a1 + 5601);
      *((_OWORD *)a1 + 8410) = *((_OWORD *)a1 + 5602);
      *((_OWORD *)a1 + 8411) = *((_OWORD *)a1 + 5603);
      *((_OWORD *)a1 + 8412) = *((_OWORD *)a1 + 5604);
    }
    else
    {
      a1[22404] = 11;
      *(_DWORD *)uint64_t v12 = 11;
      memset_pattern16(a1 + 22405, &unk_21040FF00, 0xFCuLL);
      memset_pattern16(a1 + 33637, &unk_21040FF00, 0xFCuLL);
    }
    BOOL v24 = a2;
  }
  uint64_t v71 = a1;
  int v26 = 12 * (*(uint64_t (**)(uint64_t))a6)(38);
  int v27 = v26 + 16 * (*(uint64_t (**)(uint64_t))a6)(9);
  int v28 = v27 + 5544 * (*(uint64_t (**)(uint64_t))a6)(15);
  uint64_t v68 = v24;
  if (**v24 >= 2)
  {
    int v29 = v28 + 12 * (*(uint64_t (**)(uint64_t))a6)(23);
    int v30 = v29 + 16 * (*(uint64_t (**)(uint64_t))a6)(9);
    int v28 = v30 + 5544 * (*(uint64_t (**)(uint64_t))a6)(15);
  }
  uint64_t v31 = (char *)(*(uint64_t (**)(void, void))a5)(v28, *(void *)(a5 + 16));
  *(void *)(a4 + 24) = v31;
  if (!v31)
  {
    aj_log_error(0, "Could not allocate memory for contexts.");
    return 6;
  }
  uint64_t v32 = v31;
  bzero(v31, v28);
  uint64_t v33 = **v24;
  if ((int)v33 >= 1)
  {
    uint64_t v34 = 0;
    uint64_t v35 = v17 + 1;
    do
    {
      if (v34) {
        int v36 = 4;
      }
      else {
        int v36 = 5;
      }
      *((_DWORD *)v35 - 2) = 1 << v36;
      *((_DWORD *)v35 - 1) = v36;
      *uint64_t v35 = 0x300000008;
      ++v34;
      v35 += 5616;
    }
    while (v33 != v34);
  }
  uint64_t v37 = 0;
  __int16 v38 = v71 + 33708;
  do
  {
    uint64_t v39 = (v17[3] - *v17 + (1 << *v17));
    *(void *)&v71[v37 + 24] = v32;
    (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v39, 1);
    v32 += (*(int (**)(uint64_t))a6)(v39);
    v37 += 2;
  }
  while (v37 != 24);
  uint64_t v67 = a3;
  uint64_t v40 = 0;
  int v41 = v71;
  do
  {
    *(void *)&v71[v40 + 48] = v32;
    (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, 9, 1);
    v32 += (*(int (**)(uint64_t))a6)(9);
    v40 += 2;
  }
  while (v40 != 32);
  uint64_t v42 = 0;
  do
  {
    ++v42;
    for (uint64_t i = 80; i != 256; i += 2)
    {
      uint64_t v44 = (v71[v42 + 11172] - v17[2] + (1 << v17[2]));
      *(void *)&v41[i] = v32;
      (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v44, 1);
      v32 += (*(int (**)(uint64_t))a6)(v44);
    }
    v41 += 176;
  }
  while (v42 != 63);
  int v45 = v68;
  unint64_t v46 = *v68;
  int v47 = **v68;
  if (v47 <= 1)
  {
    uint64_t v57 = v67;
  }
  else
  {
    for (uint64_t j = 0; j != 24; j += 2)
    {
      uint64_t v49 = (v69[3] - *v69 + (1 << *v69));
      *(void *)&v71[j + 11256] = v32;
      *(void *)&v71[j + 22488] = v32;
      (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v49, 1);
      v32 += (*(int (**)(uint64_t))a6)(v49);
    }
    for (uint64_t k = 0; k != 32; k += 2)
    {
      *(void *)&v71[k + 11280] = v32;
      *(void *)&v71[k + 22512] = v32;
      (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, 9, 1);
      v32 += (*(int (**)(uint64_t))a6)(9);
    }
    uint64_t v51 = 0;
    int v52 = v71 + 11312;
    uint64_t v53 = v71 + 22544;
    do
    {
      uint64_t v54 = 0;
      uint64_t v70 = v51 + 1;
      int v55 = &v71[v51 + 22405];
      do
      {
        uint64_t v56 = (*v55 - v69[2] + (1 << v69[2]));
        v52[v54] = v32;
        v53[v54] = v32;
        (*(void (**)(void *, char *, uint64_t, uint64_t))(a6 + 24))(v38, v32, v56, 1);
        v32 += (*(int (**)(uint64_t))a6)(v56);
        ++v54;
      }
      while (v54 != 88);
      v52 += 88;
      v53 += 88;
      uint64_t v51 = v70;
    }
    while (v70 != 63);
    uint64_t v57 = v67;
    int v45 = v68;
    unint64_t v46 = *v68;
    int v47 = **v68;
  }
  if (v47 >= 1)
  {
    uint64_t v59 = 0;
    uint64_t v60 = 1568 * v47;
    int v61 = v46 + 843;
    uint64_t v62 = v71 + 33898;
    int v63 = v71;
    do
    {
      uint64_t v64 = *(v61 - 4);
      uint64_t v65 = *v61;
      uint64_t v66 = (void *)(v57 + v59);
      *((void *)v63 + 5621) = v57 + v59;
      v66[4] = v45[2 * v64 + 1];
      v66[5] = v45[2 * v65 + 2];
      v66[84] = &v62[256 * v64];
      v66[85] = &v62[256 * v65 + 128];
      v66[86] = &v71[256 * v65 + 34922];
      *((void *)v63 + 10) = v38;
      *((void *)v63 + 11) = a6;
      *((void *)v63 + 5618) = v71 + 33722;
      *((void *)v63 + 5619) = v71 + 33738;
      *((void *)v63 + 5620) = v71 + 33866;
      v59 += 1568;
      ++v61;
      v63 += 11232;
    }
    while (v60 != v59);
  }
  return 0;
}

__n128 aj_reduce_init_pack(uint64_t a1, int *a2, uint64_t a3, unsigned int **a4, uint64_t a5, unsigned int *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  *(void *)a3 = a6;
  *a4 = a6;
  aj_reset_mcustate((void *)(a5 + 112), a7);
  uint64_t v17 = *(void *)a3;
  *(_DWORD *)a5 = 0;
  if (!*(unsigned char *)(v17 + 84))
  {
    *(void *)(a3 + 6892) = 0x100000001;
    *(void *)(a3 + 6804) = 0;
    *(_DWORD *)(a3 + 168) = 1;
    *(_DWORD *)(a3 + 6612) = 0;
    int v18 = *(_DWORD *)(v17 + 8);
    *(_DWORD *)(a3 + 6484) = v18;
    int v19 = *(_DWORD *)(v17 + 12);
    *(_DWORD *)(a3 + 6488) = v19;
    *(_DWORD *)(a3 + 6580) = 0;
    *(_DWORD *)(a3 + 6824) = 0;
    *(void *)(a3 + 6816) = 0;
    *(_DWORD *)(a3 + 6828) = v18;
    *(_DWORD *)(a3 + 6832) = v19;
    *(_DWORD *)(a3 + 6884) = 1;
    if (!aj_compute_helpers(a3))
    {
      uint64_t v20 = a3 + 192;
      if (!init_reduce(a2, *(int ***)(a3 + 8), a3 + 192, a1, a8, a9)
        && !aj_init_huffman(a6, (uint64_t)a4, a8))
      {
        if ((int)*a6 >= 1)
        {
          uint64_t v21 = 0;
          do
          {
            aj_init_component(a3, v20, v21++, 1, 0);
            v20 += 1568;
          }
          while (v21 < (int)*a6);
        }
        *(_DWORD *)(a3 + 6948) = 1;
        if (!aj_init_decode_jobs(a3, (_DWORD *)a5, 0, 0, a8, 1))
        {
          uint64_t v22 = 0;
          uint64_t v23 = 88;
          do
          {
            uint64_t v24 = 0;
            uint64_t v25 = *(void *)a3;
            uint64_t v26 = *(void *)a3 + v23;
            do
            {
              *((_DWORD *)v36 + aj_glob_zigzag[v24]) = *(_DWORD *)(v26 + v24 * 4);
              ++v24;
            }
            while (v24 != 64);
            long long v27 = v36[9];
            uint64_t v28 = v25 + (v22 << 8);
            *(_OWORD *)(v28 + 216) = v36[8];
            *(_OWORD *)(v28 + 232) = v27;
            long long v29 = v36[11];
            *(_OWORD *)(v28 + 248) = v36[10];
            long long v30 = v36[5];
            *(_OWORD *)(v28 + 152) = v36[4];
            *(_OWORD *)(v28 + 168) = v30;
            long long v31 = v36[7];
            *(_OWORD *)(v28 + 184) = v36[6];
            *(_OWORD *)(v28 + 200) = v31;
            long long v32 = v36[1];
            *(_OWORD *)(v28 + 88) = v36[0];
            *(_OWORD *)(v28 + 104) = v32;
            long long v33 = v36[3];
            *(_OWORD *)(v28 + 120) = v36[2];
            *(_OWORD *)(v28 + 136) = v33;
            v28 += 88;
            __n128 result = (__n128)v36[12];
            long long v34 = v36[14];
            long long v35 = v36[15];
            *(_OWORD *)(v28 + 208) = v36[13];
            *(_OWORD *)(v28 + 224) = v34;
            *(_OWORD *)(v28 + 240) = v35;
            ++v22;
            v23 += 256;
            *(_OWORD *)(v28 + 176) = v29;
            *(__n128 *)(v28 + 192) = result;
          }
          while (v22 != 4);
        }
      }
    }
  }
  return result;
}

int *determine_max_bits(int *result, int *a2)
{
  if (*result >= 2)
  {
    unsigned int v3 = 0;
    do
    {
      unsigned int v4 = v3 + 1;
      if (v3 > 0x1F) {
        break;
      }
      int v5 = 1 << v3++;
    }
    while (v5 <= *result);
    int v2 = 13 - v4;
  }
  else
  {
    int v2 = 11;
  }
  *a2 = v2;
  for (uint64_t i = 1; i != 64; ++i)
  {
    int v7 = result[i];
    if (v7 >= 2)
    {
      int v8 = -2;
      do
      {
        unsigned int v9 = v8 + 2;
        ++v8;
      }
      while (v9 <= 0x1F && 1 << v9 <= v7);
    }
    else
    {
      int v8 = 0;
    }
    a2[i] = 10 - v8;
  }
  return result;
}

uint64_t *applejpeg_recode_open_file(void *a1, unint64_t a2, int *a3)
{
  return recode_open(a1, 0, a2, a3);
}

uint64_t *recode_open(void *a1, uint64_t *a2, unint64_t a3, int *a4)
{
  if (!a4)
  {
    aj_log_error((uint64_t)"Recode", "Error pointer cannot be NULL");
    return 0;
  }
  if (!a1 || !*a1 || !a1[1])
  {
    aj_log_error((uint64_t)"Recode", "Memory manager cannot be NULL");
    goto LABEL_9;
  }
  if (!a2 || !a3)
  {
    if (!((unint64_t)a2 | a3))
    {
      aj_log_error((uint64_t)"Recode", "Input cannot be NULL");
      goto LABEL_9;
    }
    if (a3)
    {
      if (!*(void *)a3 || !*(void *)(a3 + 16))
      {
        aj_log_error((uint64_t)"Recode", "Read/Skip callback is missing");
        goto LABEL_9;
      }
      unint64_t v11 = *(void *)(a3 + 40);
      if (v11)
      {
        if (v11 <= 0x3FF)
        {
          aj_log_error((uint64_t)"Recode", "Read buff must be at least %d bytes");
          goto LABEL_9;
        }
        if (v11 >> 31)
        {
          aj_log_error((uint64_t)"Recode", "Read buff can't be larger than %d");
          goto LABEL_9;
        }
      }
      if (*(void *)(a3 + 48) >> 31)
      {
        aj_log_error((uint64_t)"Recode", "The file size can't be larger than %d");
        goto LABEL_9;
      }
    }
    else
    {
      if (!*a2 || (unint64_t v12 = a2[1]) == 0)
      {
        aj_log_error((uint64_t)"Recode", "NULL fields in the memory input struct not allowed");
        goto LABEL_9;
      }
      if (v12 >> 31)
      {
        aj_log_error((uint64_t)"Recode", "Memory input buffer size may not be larger than %d");
        goto LABEL_9;
      }
    }
    int v13 = (uint64_t *)((uint64_t (*)(uint64_t, void))*a1)(1488, a1[2]);
    if (!v13)
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for session object");
      int v8 = 6;
      goto LABEL_10;
    }
    unsigned int v9 = v13;
    bzero(v13, 0x5D0uLL);
    bzero(v9, 0x5D0uLL);
    applejpeg_recode_clear_options((uint64_t)v9);
    long long v14 = *(_OWORD *)a1;
    void v9[2] = a1[2];
    *(_OWORD *)unsigned int v9 = v14;
    v9[142] = (uint64_t)v9;
    uint64_t v15 = applejpeg_decode_create(a1);
    v9[3] = (uint64_t)v15;
    if (v15)
    {
      if (a3) {
        int v16 = applejpeg_decode_open_file((uint64_t)v15, a3, 0);
      }
      else {
        int v16 = applejpeg_decode_open_mem((uint64_t)v15, a2);
      }
      int v8 = v16;
      *a4 = v16;
      uint64_t v17 = v9[3];
      if (v17)
      {
        if (!v8)
        {
          int image_info = applejpeg_decode_get_image_info(v17, (uint64_t)(v9 + 5));
          if (image_info)
          {
            int v8 = image_info;
            aj_log_error((uint64_t)"Recode", "Could not extract image information");
          }
          else
          {
            if (*((_DWORD *)v9 + 14) == 2)
            {
              aj_log_error((uint64_t)"Recode", "Recode does not support lossless jpegs");
            }
            else
            {
              if (applejpeg_decode_get_precision(v9[3]) == 8)
              {
                *a4 = 0;
                return v9;
              }
              aj_log_error((uint64_t)"Recode", "Recode only supports 8-bit jpegs");
            }
            int v8 = 3;
          }
        }
        goto LABEL_44;
      }
    }
    else
    {
      int v8 = *a4;
    }
    if (!v8)
    {
      int v8 = 6;
      *a4 = 6;
    }
LABEL_44:
    applejpeg_decode_destroy((void *)v9[3]);
    v9[3] = 0;
    int v19 = v9 + 144;
    do
    {
      if (*v19)
      {
        ((void (*)(uint64_t, void))a1[1])(*v19, a1[2]);
        uint64_t *v19 = 0;
      }
      ++v19;
    }
    while (v19 < v9 + 153);
    ((void (*)(uint64_t *, void))a1[1])(v9, a1[2]);
    goto LABEL_10;
  }
  aj_log_error((uint64_t)"Recode", "Cannot have both file input AND memory input");
LABEL_9:
  int v8 = 8;
LABEL_10:
  unsigned int v9 = 0;
  *a4 = v8;
  return v9;
}

uint64_t *applejpeg_recode_open_mem(void *a1, uint64_t *a2, int *a3)
{
  return recode_open(a1, a2, 0, a3);
}

uint64_t applejpeg_recode_set_option_outsize(uint64_t a1, int a2, int a3, int a4)
{
  if (!a1) {
    return 5;
  }
  if (a4 | a3 | a2)
  {
    if (a2 && a4 | a3)
    {
      aj_log_error((uint64_t)"Recode", "Can not set both output scale and width/height");
    }
    else
    {
      if ((a3 != 0) == (a4 != 0))
      {
        uint64_t v4 = 0;
        *(_DWORD *)(a1 + 228) = a2;
        *(_DWORD *)(a1 + 216) = a3;
        *(_DWORD *)(a1 + 220) = a4;
        *(unsigned char *)(a1 + 1128) = 0;
        return v4;
      }
      aj_log_error((uint64_t)"Recode", "Can not set only one output dimension");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Must set either output scale or width/height");
  }
  return 5;
}

uint64_t applejpeg_recode_set_option_aspect(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 5;
  }
  if (a2 >= 4)
  {
    aj_log_error((uint64_t)"Recode", "Unknown aspect option: %d", a2);
    return 5;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 224) = a2;
    *(_DWORD *)(a1 + 232) = a3;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_orientation(uint64_t a1, int a2)
{
  if (!a1) {
    return 5;
  }
  if ((a2 - 9) > 0xFFFFFFF7)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 408) = a2;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Orientation out of bounds: %u", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_crop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 5;
  }
  if ((a2 & 0x8000000080000000) != 0 || (int)a3 < 1 || a3 <= 0)
  {
    aj_log_error((uint64_t)"Recode", "Invalid cropregion: (%d,%d) %dx%d", a2, HIDWORD(a2), a3, HIDWORD(a3));
    return 5;
  }
  else
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 236) = a2;
    *(void *)(a1 + 244) = a3;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  return v3;
}

uint64_t applejpeg_recode_set_option_skip_app0(uint64_t a1, int a2)
{
  if (!a1) {
    return 5;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 336) = a2;
  *(unsigned char *)(a1 + 1128) = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_jpeg_quality(uint64_t a1, int a2)
{
  if (!a1) {
    return 5;
  }
  if ((a2 - 101) > 0xFFFFFF9B)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 272) = a2;
    *(unsigned char *)(a1 + 252) = 1;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Quality out of bounds: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_quantization_tables(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 5;
  }
  for (uint64_t i = 0; i != 32; i += 8)
    *(void *)(a1 + 280 + i) = *(void *)(a2 + i);
  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(unsigned char *)(a1 + 252) = 1;
  *(unsigned char *)(a1 + 1128) = 0;
  return v3;
}

uint64_t applejpeg_recode_set_option_jpeg_format(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 5;
  }
  if (a2 >= 5)
  {
    aj_log_error((uint64_t)"Recode", "Unknown JPEG format: %d", a2);
    return 5;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 312) = a2;
    *(unsigned char *)(a1 + 253) = 1;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_jpeg_type(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 5;
  }
  if (a2 < 2)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 316) = a2;
    *(unsigned char *)(a1 + 1128) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Unknown JPEG type: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_recode_set_option_accelerated_resize(unsigned char *a1, char a2)
{
  if (!a1) {
    return 5;
  }
  uint64_t result = 0;
  a1[412] = a2;
  a1[413] = a2;
  a1[1128] = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_hw_accelerated_resize(unsigned char *a1, int a2, int a3)
{
  if (!a1) {
    return 5;
  }
  uint64_t result = 0;
  a1[412] = a2;
  if (a2) {
    BOOL v5 = a3 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  char v6 = !v5;
  a1[413] = v6;
  a1[1128] = 0;
  return result;
}

uint64_t applejpeg_recode_set_option_converter(uint64_t a1, long long *a2)
{
  uint64_t result = 5;
  if (a1 && a2)
  {
    if (*(_DWORD *)a2 == 1)
    {
      uint64_t result = 0;
      *(unsigned char *)(a1 + 414) = 1;
      long long v4 = *a2;
      *(void *)(a1 + 432) = *((void *)a2 + 2);
      *(_OWORD *)(a1 + 416) = v4;
      *(unsigned char *)(a1 + 1128) = 0;
    }
    else
    {
      aj_log_error((uint64_t)"Recode", "Unknown converter version: %d", *(_DWORD *)a2);
      return 5;
    }
  }
  return result;
}

void applejpeg_recode_clear_options(uint64_t a1)
{
  if (a1)
  {
    *(_OWORD *)(a1 + 216) = xmmword_21040FF10;
    uint64_t v1 = a1 + 216;
    *(void *)(a1 + 236) = -1;
    *(void *)(a1 + 244) = -1;
    *(_DWORD *)(a1 + 232) = 0;
    *(unsigned char *)(a1 + 368) = 0;
    *(_OWORD *)(a1 + 376) = 0u;
    *(_OWORD *)(a1 + 392) = 0u;
    applejpeg_encode_options_init(a1 + 256);
    *(_DWORD *)(v1 + 192) = 1;
    *(_WORD *)(v1 + 196) = 0;
    *(unsigned char *)(v1 + 198) = 0;
    *(unsigned char *)(v1 + 912) = 0;
    *(_WORD *)(v1 + 36) = 0;
  }
}

uint64_t applejpeg_recode_get_image_info(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    return applejpeg_decode_get_image_info(v2, a2);
  }
  else
  {
    aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_resize_plugin_set_preferred_format(uint64_t result, unsigned int a2)
{
  if (a2 <= 0xA && ((1 << a2) & 0x518) != 0)
  {
    *(_DWORD *)(result + 928) = a2;
    *(_DWORD *)(result + 932) = 1;
  }
  return result;
}

uint64_t applejpeg_recode_all_file(unint64_t a1, uint64_t a2, void *a3)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(void *)(a2 + 40))
  {
    aj_log_error((uint64_t)"Recode", "File write buffer size may not be larger than %d", a2, a3);
    return 8;
  }
  return recode_all(a1, 0, (long long *)a2, a3);
}

uint64_t recode_all(unint64_t a1, uint64_t a2, long long *a3, void *a4)
{
  uint64_t v94 = *MEMORY[0x263EF8340];
  kdebug_trace();
  *(_DWORD *)(*(void *)(a1 + 24) + 4100) = 1;
  if (!*(unsigned char *)(a1 + 1128))
  {
    if ((*(_DWORD *)(a1 + 408) - 9) <= 0xFFFFFFF7)
    {
      aj_log_error((uint64_t)"Recode", "Orientation must be [1..8]. Got %d");
      return 5;
    }
    int v13 = (int *)(a1 + 216);
    int v14 = *(_DWORD *)(a1 + 228);
    int v15 = *(_DWORD *)(a1 + 220);
    if (v14)
    {
      if (v15 || *v13)
      {
        aj_log_error((uint64_t)"Recode", "Set scale OR width and height");
        return 5;
      }
      if ((v14 - 65) > 0xFFFFFFBF) {
        goto LABEL_127;
      }
    }
    else
    {
      int v63 = *v13;
      if (v15 | *v13)
      {
        if (v63 < 1 || (v15 - 0x10000) < 0xFFFF0001 || v63 >= 0x10000)
        {
          aj_log_error((uint64_t)"Recode", "Illegal dimensions (%dx%d). Dimensions must be 0 < x <= 65535.");
          return 5;
        }
LABEL_127:
        if (*(_DWORD *)(a1 + 224) >= 4u)
        {
          aj_log_error((uint64_t)"Recode", "Illegal preserve aspect ratio option");
          return 5;
        }
        if (*(unsigned char *)(a1 + 368) && (!*(void *)(a1 + 384) || !*(void *)(a1 + 392)))
        {
          aj_log_error((uint64_t)"Recode", "A resize plugin must implement create and resize");
          return 5;
        }
        if (*(unsigned char *)(a1 + 414))
        {
          if ((*(_DWORD *)(a1 + 60) - 3) <= 2)
          {
            aj_log_error((uint64_t)"Recode", "Converter requires BGRA data, but the JPEG is CMYK or YCCK. Unable to convert");
            return 3;
          }
          if (*(_DWORD *)(a1 + 416) == 1 && !*(void *)(a1 + 432))
          {
            aj_log_error((uint64_t)"Recode", "The converter callback is NULL");
            return 5;
          }
        }
        init_decopt(a1, a1 + 216, a1 + 80);
        if (!*(unsigned char *)(a1 + 252))
        {
          int64x2_t v75 = vdupq_n_s64(a1);
          v90[0] = 0;
          v90[1] = 0;
          v88[0] = 0;
          int64x2_t v91 = vaddq_s64(v75, (int64x2_t)xmmword_21040FF20);
          int64x2_t v92 = vaddq_s64(v75, (int64x2_t)xmmword_21040FF30);
          uint64_t qtables = applejpeg_decode_get_qtables(*(void *)(a1 + 24), (uint64_t)&v91, v88, (uint64_t)v90);
          if (qtables) {
            return qtables;
          }
          for (uint64_t i = 0; i != 4; ++i)
            *(void *)(a1 + 280 + 8 * i) = v91.i64[*((int *)v90 + i)];
          *(_DWORD *)(a1 + 272) = 0;
        }
        if (!*(unsigned char *)(a1 + 253)) {
          *(_DWORD *)(a1 + 312) = applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24));
        }
        *(unsigned char *)(a1 + 1128) = 1;
        if (*(_DWORD *)(a1 + 220)) {
          goto LABEL_155;
        }
        int v74 = *v13;
        if (*v13) {
          goto LABEL_155;
        }
        unsigned int v78 = *(_DWORD *)(a1 + 228);
        if (v78 > 8 || ((1 << v78) & 0x116) == 0) {
          goto LABEL_156;
        }
        if (*(unsigned char *)(a1 + 253))
        {
          if (v78 != 8) {
            goto LABEL_172;
          }
          int v79 = *(_DWORD *)(a1 + 312);
          if (v79 != applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24))) {
            goto LABEL_155;
          }
          if (*(_DWORD *)(a1 + 228) != 8)
          {
LABEL_172:
            if (*(_DWORD *)(a1 + 312) != 3) {
              goto LABEL_155;
            }
          }
        }
        LOBYTE(v74) = 0;
        int v80 = *(_DWORD *)(a1 + 44);
        if (v80 == 1 || v80 > 3) {
          goto LABEL_156;
        }
        if (*(_DWORD *)(a1 + 248) == -1)
        {
          LOBYTE(v74) = *(_DWORD *)(a1 + 244) == -1
                     && *(_DWORD *)(a1 + 236) == -1
                     && *(_DWORD *)(a1 + 240) == -1
                     && *(_DWORD *)(a1 + 408) == 1
                     && *(unsigned char *)(a1 + 414) == 0;
          goto LABEL_156;
        }
LABEL_155:
        LOBYTE(v74) = 0;
LABEL_156:
        *(unsigned char *)(a1 + 1129) = v74;
        goto LABEL_2;
      }
    }
    aj_log_error((uint64_t)"Recode", "Unsupported scale. Scale: %d.");
    return 5;
  }
LABEL_2:
  BOOL v8 = *(unsigned char *)(a1 + 368) == 0;
  if (*(unsigned char *)(a1 + 412))
  {
    if (*(unsigned char *)(a1 + 368) && *(void *)(a1 + 384) && *(void *)(a1 + 392))
    {
      BOOL v8 = 0;
    }
    else
    {
      unsigned int v9 = plugin_vimage_destroy;
      uint64_t v10 = plugin_vimage_resize;
      unint64_t v11 = plugin_vimage_create;
      if (*(unsigned char *)(a1 + 413))
      {
        int v12 = 4;
        unsigned int v9 = plugin_iosaccelerator_destroy;
        uint64_t v10 = plugin_iosaccelerator_resize;
        unint64_t v11 = plugin_iosaccelerator_create;
        if (*(_DWORD *)(a1 + 408) <= 1u)
        {
          if (*(_DWORD *)(a1 + 160)) {
            int v12 = 4;
          }
          else {
            int v12 = 8;
          }
          unsigned int v9 = plugin_iosaccelerator_destroy;
          uint64_t v10 = plugin_iosaccelerator_resize;
          unint64_t v11 = plugin_iosaccelerator_create;
        }
      }
      else
      {
        int v12 = 4;
      }
      BOOL v8 = 0;
      *(unsigned char *)(a1 + 368) = 1;
      *(void *)(a1 + 376) = 0;
      *(void *)(a1 + 384) = v11;
      *(void *)(a1 + 392) = v10;
      *(void *)(a1 + 400) = v9;
      *(_DWORD *)(a1 + 928) = v12;
      *(_DWORD *)(a1 + 932) = 1;
    }
  }
  int v89 = 0;
  LODWORD(v90[0]) = 0;
  int v87 = 0;
  v88[0] = 0;
  int v85 = 0;
  int64x2_t v91 = 0uLL;
  if (v8) {
    goto LABEL_38;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 156);
  unsigned int v86 = v16;
  if ((!*(_DWORD *)(a1 + 108) || !*(_DWORD *)(a1 + 112)) && v16 <= 8 && ((1 << v16) & 0x116) != 0) {
    goto LABEL_38;
  }
  if (aj_calculate_dimensions((_DWORD *)(a1 + 80), *(void *)(a1 + 24) + 144, (int *)v90, v88, &v89, &v87, &v91, (int *)&v86, &v85))goto LABEL_38; {
  signed int v17 = v86;
  }
  if ((int)v86 >= 2) {
    signed int v17 = v86 >> (*(_DWORD *)(*(void *)(a1 + 24) + 156) / (int)v86 < *(_DWORD *)(a1 + 112));
  }
  int v18 = v91.i32[2] / v17;
  if (v91.i32[2] / v17 == v89 && v91.i32[3] / v17 == v87) {
    goto LABEL_38;
  }
  if (*(_DWORD *)(a1 + 108) && *(_DWORD *)(a1 + 112) && *(_DWORD *)(a1 + 116) == 1)
  {
    if (v89 != LODWORD(v90[0])) {
      goto LABEL_38;
    }
    int v19 = v87;
    if (v87 != v88[0] || v18 > 4 * v89) {
      goto LABEL_38;
    }
  }
  else
  {
    if (v18 > 4 * v89) {
      goto LABEL_38;
    }
    int v19 = v87;
  }
  int v64 = v91.i32[3] / v17;
  if (v64 > 4 * v19 || v18 < 16 || v89 < 16 || v19 < 16 || v64 <= 15 || *(void *)(a1 + 264)) {
    goto LABEL_38;
  }
  int v65 = do_recode_plugin(a1, a2, a3, a4);
  if (v65 != 3)
  {
LABEL_184:
    init_decopt(a1, a1 + 216, a1 + 80);
    if (!v65)
    {
      uint64_t v20 = 0;
      goto LABEL_105;
    }
    goto LABEL_38;
  }
  if (*(int *(**)(uint64_t, int *, uint64_t, int *))(a1 + 384) == plugin_iosaccelerator_create
    && *(uint64_t (**)(uint64_t, int *, _DWORD *, int))(a1 + 392) == plugin_iosaccelerator_resize
    && *(void (**)(void *))(a1 + 400) == plugin_iosaccelerator_destroy)
  {
    init_decopt(a1, a1 + 216, a1 + 80);
    *(unsigned char *)(a1 + 368) = 1;
    *(void *)(a1 + 376) = 0;
    *(void *)(a1 + 384) = plugin_vimage_create;
    *(void *)(a1 + 392) = plugin_vimage_resize;
    *(void *)(a1 + 400) = plugin_vimage_destroy;
    *(void *)(a1 + 928) = 0x100000004;
    int v65 = do_recode_plugin(a1, a2, a3, a4);
    goto LABEL_184;
  }
  init_decopt(a1, a1 + 216, a1 + 80);
LABEL_38:
  if (!*(void *)(a1 + 264) && *(_DWORD *)(a1 + 408) == 1)
  {
    memset(v93, 0, sizeof(v93));
    int64x2_t v91 = 0u;
    int64x2_t v92 = 0u;
    if (*(unsigned char *)(a1 + 1129)) {
      *(_DWORD *)(a1 + 88) = 14;
    }
    v90[0] = 0;
    *(void *)int16x8_t v88 = 0;
    uint64_t v20 = applejpeg_decode_set_options(*(void *)(a1 + 24), a1 + 80, v88, 0, v90, &v93[8], &v93[12]);
    if (v20) {
      goto LABEL_105;
    }
    int v83 = *(_DWORD *)&v93[12];
    *(void *)(a1 + 448) = v90[0];
    if (*(void *)(a1 + 1160)) {
      (*(void (**)(void, void))(a1 + 8))(*(void *)(a1 + 1160), *(void *)(a1 + 16));
    }
    uint64_t v21 = (void *)(*(uint64_t (**)(void))a1)();
    *(void *)(a1 + 440) = v21;
    *(void *)(a1 + 1160) = v21;
    if (v21 && (bzero(v21, *(void *)(a1 + 448)), *(void *)(a1 + 1160)))
    {
      if (!*(unsigned char *)(a1 + 414)) {
        goto LABEL_52;
      }
      uint64_t v22 = *(void *)(a1 + 976);
      if (v22) {
        (*(void (**)(uint64_t, void))(a1 + 8))(v22, *(void *)(a1 + 16));
      }
      uint64_t v23 = (void *)(*(uint64_t (**)(void, void))a1)(*(void *)(a1 + 448), *(void *)(a1 + 16));
      *(void *)(a1 + 1216) = v23;
      *(void *)(a1 + 976) = v23;
      if (v23)
      {
        bzero(v23, *(void *)(a1 + 448));
        if (*(void *)(a1 + 976))
        {
LABEL_52:
          int32x4_t v81 = a3;
          char v24 = 0;
          int v25 = 0;
          uint64_t v26 = 0;
          uint64_t v84 = (uint64_t *)(a1 + 440);
          *(_DWORD *)&v93[16] = *(_DWORD *)(a1 + 88);
          int v89 = 1;
          uint64_t v82 = (_OWORD *)(a1 + 256);
          while (1)
          {
            uint64_t v27 = *(void *)(a1 + 24);
            if (*(unsigned char *)(a1 + 1129)) {
              uint64_t v28 = applejpeg_decode_image_row_texture(v27, v84, (uint64_t)&v93[8], &v89);
            }
            else {
              uint64_t v28 = applejpeg_decode_image_row(v27, (uint64_t)v84, (uint64_t)&v93[8], &v89);
            }
            uint64_t v20 = v28;
            if (v28)
            {
LABEL_159:
              uint64_t v72 = *(void *)(a1 + 32);
              if (v72)
              {
LABEL_160:
                applejpeg_encode_destroy(v72);
                *(void *)(a1 + 32) = 0;
              }
              goto LABEL_105;
            }
            if (v24)
            {
              if (*(unsigned char *)(a1 + 1129)) {
                goto LABEL_76;
              }
              int v29 = *(unsigned __int8 *)(a1 + 414);
            }
            else
            {
              long long v30 = applejpeg_encode_create((long long *)a1);
              *(void *)(a1 + 32) = v30;
              if (!v30)
              {
                uint64_t v20 = 6;
                goto LABEL_105;
              }
              *((_DWORD *)v30 + 3328) = 1;
              if (a2)
              {
                uint64_t v31 = applejpeg_encode_set_options_mem((uint64_t)v30, v82, (uint64_t)&v93[8], a2);
                if (v31) {
                  goto LABEL_158;
                }
              }
              else
              {
                uint64_t v31 = applejpeg_encode_set_options_file((uint64_t)v30, v82, (uint64_t)&v93[8], v81);
                if (v31)
                {
LABEL_158:
                  uint64_t v20 = v31;
                  goto LABEL_159;
                }
              }
              *(_DWORD *)(*(void *)(a1 + 32) + 3464) = *(_DWORD *)(*(void *)(a1 + 24) + 3560);
              long long v32 = *(_OWORD *)&v93[88];
              *(_OWORD *)(a1 + 1080) = *(_OWORD *)&v93[72];
              *(_OWORD *)(a1 + 1096) = v32;
              *(_OWORD *)(a1 + 1112) = *(_OWORD *)&v93[104];
              long long v33 = *(_OWORD *)&v93[24];
              *(_OWORD *)(a1 + 1016) = *(_OWORD *)&v93[8];
              *(_OWORD *)(a1 + 1032) = v33;
              long long v34 = *(_OWORD *)&v93[56];
              *(_OWORD *)(a1 + 1048) = *(_OWORD *)&v93[40];
              *(_OWORD *)(a1 + 1064) = v34;
              int v29 = *(unsigned __int8 *)(a1 + 414);
              if (*(unsigned char *)(a1 + 414)) {
                uint64_t v26 = (int64x2_t *)(a1 + 976);
              }
              else {
                uint64_t v26 = &v91;
              }
              long long v35 = v93;
              if (*(unsigned char *)(a1 + 414)) {
                long long v35 = (_DWORD *)(a1 + 1008);
              }
              if (*(unsigned char *)(a1 + 1129))
              {
                *long long v35 = 3;
                uint64_t v36 = *v84;
                v26->i64[0] = *v84;
                uint64_t v37 = v36 + *(void *)&v93[32] * *(void *)&v93[24];
                BOOL v38 = v29 == 0;
                uint64_t v39 = &v91.i64[1];
                if (!v38) {
                  uint64_t v39 = (uint64_t *)(a1 + 984);
                }
                *uint64_t v39 = v37;
                uint64_t v40 = &v92;
                if (!v38) {
                  uint64_t v40 = (int64x2_t *)(a1 + 992);
                }
                v40->i64[0] = v91.i64[1] + *(void *)&v93[64] * *(void *)&v93[56];
LABEL_76:
                __int32 v41 = *(_DWORD *)&v93[52];
                if (*(int *)&v93[52] >= v83 - v25) {
                  __int32 v41 = v83 - v25;
                }
                v26[2].i32[3] = v41;
                goto LABEL_82;
              }
              *long long v35 = 1;
              v91.i64[0] = *v84;
            }
            v26[2].i32[3] = 1;
            *(_DWORD *)&v93[12] = 1;
            if (v29) {
              (*(void (**)(void, int64x2_t *, int64x2_t *))(a1 + 432))(*(void *)(a1 + 424), &v91, v26);
            }
LABEL_82:
            __int32 v42 = v26[2].i32[3];
            uint64_t v20 = applejpeg_encode_image_row(*(void *)(a1 + 32), (unsigned int *)v26, a4);
            if (!v20)
            {
              v25 += v42;
              char v24 = 1;
              if (v89) {
                continue;
              }
            }
            goto LABEL_159;
          }
        }
      }
      aj_log_error((uint64_t)"Recode", "Could not allocate the convert buffer");
    }
    else
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for row buffer");
    }
LABEL_104:
    uint64_t v20 = 6;
    goto LABEL_105;
  }
  uint64_t v43 = *(void *)(a1 + 24);
  *(_DWORD *)(v43 + 4100) = 1;
  if (*(unsigned char *)(a1 + 1129)) {
    *(_DWORD *)(a1 + 88) = 14;
  }
  v90[0] = 0;
  int64x2_t v91 = 0u;
  int64x2_t v92 = 0u;
  memset(v93, 0, sizeof(v93));
  uint64_t v20 = applejpeg_decode_set_options(v43, a1 + 80, (void *)(a1 + 448), 0, v90, &v93[8], &v93[12]);
  if (v20) {
    goto LABEL_105;
  }
  uint64_t v44 = *(void *)(a1 + 1160);
  if (v44) {
    (*(void (**)(uint64_t, void))(a1 + 8))(v44, *(void *)(a1 + 16));
  }
  int v45 = (void *)(*(uint64_t (**)(void, void))a1)(*(void *)(a1 + 448), *(void *)(a1 + 16));
  *(void *)(a1 + 440) = v45;
  *(void *)(a1 + 1160) = v45;
  if (!v45 || (bzero(v45, *(void *)(a1 + 448)), !*(void *)(a1 + 1160)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for image buffer");
    goto LABEL_104;
  }
  uint64_t v20 = applejpeg_decode_image_all(*(void *)(a1 + 24), (uint64_t *)(a1 + 440), 1u, (uint64_t)&v91);
  if (v20) {
    goto LABEL_105;
  }
  if (*(unsigned char *)(a1 + 1129))
  {
    uint64_t v46 = v91.i64[0];
    if (v91.i64[0])
    {
      if (*(_DWORD *)&v93[16] == 14)
      {
        int v47 = *(_DWORD *)&v93[24];
        int v48 = *(_DWORD *)&v93[32];
        int v49 = *(_DWORD *)&v93[56];
        int v50 = a3;
        int v51 = *(_DWORD *)&v93[64];
        pad_region((char *)v91.i64[0], *(int *)&v93[24], *(int *)&v93[32], *(int *)&v93[40], *(int *)&v93[44], *(int *)&v93[48], *(int *)&v93[52]);
        int v52 = (char *)(v46 + v47 * v48);
        pad_region(v52, v49, v51, *(int *)&v93[72], *(int *)&v93[76], *(int *)&v93[80], *(int *)&v93[84]);
        uint64_t v53 = &v52[v49 * v51];
        int v54 = v51;
        a3 = v50;
        pad_region(v53, v49, v54, *(int *)&v93[72], *(int *)&v93[76], *(int *)&v93[80], *(int *)&v93[84]);
      }
    }
  }
  if (*(unsigned char *)(a1 + 414))
  {
    uint64_t v55 = *(void *)(a1 + 1216);
    if (v55) {
      (*(void (**)(uint64_t, void))(a1 + 8))(v55, *(void *)(a1 + 16));
    }
    uint64_t v56 = (void *)(*(uint64_t (**)(void, void))a1)(*(void *)(a1 + 448), *(void *)(a1 + 16));
    *(void *)(a1 + 1216) = v56;
    if (!v56 || (uint64_t v57 = v56, bzero(v56, *(void *)(a1 + 448)), !*(void *)(a1 + 1216)))
    {
      aj_log_error((uint64_t)"Recode", "Could not allocate memory for color conversion buffer");
      goto LABEL_104;
    }
    uint64_t v58 = (int64x2_t *)(a1 + 976);
    long long v59 = *(_OWORD *)&v93[80];
    *(_OWORD *)(a1 + 1072) = *(_OWORD *)&v93[64];
    *(_OWORD *)(a1 + 1088) = v59;
    *(_OWORD *)(a1 + 1104) = *(_OWORD *)&v93[96];
    *(void *)(a1 + 1120) = *(void *)&v93[112];
    long long v60 = *(_OWORD *)&v93[16];
    *(_OWORD *)(a1 + 1008) = *(_OWORD *)v93;
    *(_OWORD *)(a1 + 1024) = v60;
    long long v61 = *(_OWORD *)&v93[48];
    *(_OWORD *)(a1 + 1040) = *(_OWORD *)&v93[32];
    *(_OWORD *)(a1 + 1056) = v61;
    int64x2_t v62 = v92;
    *(int64x2_t *)(a1 + 976) = v91;
    *(int64x2_t *)(a1 + 992) = v62;
    *(void *)(a1 + 976) = v57;
    (*(void (**)(void, int64x2_t *, unint64_t))(a1 + 432))(*(void *)(a1 + 424), &v91, a1 + 976);
  }
  else
  {
    uint64_t v58 = &v91;
  }
  int v66 = *(_DWORD *)(*(void *)(a1 + 24) + 3560);
  uint64_t v67 = applejpeg_encode_create((long long *)a1);
  *(void *)(a1 + 32) = v67;
  if (!v67) {
    goto LABEL_104;
  }
  *((_DWORD *)v67 + 3328) = 1;
  uint64_t v68 = (_OWORD *)(a1 + 256);
  uint64_t v69 = (uint64_t)&v58[2].i64[1];
  if (a2) {
    uint64_t v70 = applejpeg_encode_set_options_mem((uint64_t)v67, v68, v69, a2);
  }
  else {
    uint64_t v70 = applejpeg_encode_set_options_file((uint64_t)v67, v68, v69, a3);
  }
  uint64_t v20 = v70;
  if (!v70)
  {
    uint64_t v71 = *(void *)(a1 + 32);
    *(_DWORD *)(v71 + 3464) = v66;
    uint64_t v20 = applejpeg_encode_image_all(v71, (unsigned int *)v58, a4);
    if (!v20)
    {
      uint64_t v72 = *(void *)(a1 + 32);
      goto LABEL_160;
    }
  }
LABEL_105:
  kdebug_trace();
  return v20;
}

uint64_t applejpeg_recode_all_mem(unint64_t a1, uint64_t a2, void *a3)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Recode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(void *)(a2 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Recode", "Memory buffer size may not be larger than %d");
    return 8;
  }
  return recode_all(a1, a2, 0, a3);
}

void *applejpeg_recode_close(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    char v6 = (uint64_t (*)(void *, uint64_t))result[1];
    uint64_t v3 = result[2];
    uint64_t v2 = (void *)result[3];
    if (v2)
    {
      applejpeg_decode_destroy(v2);
      v1[3] = 0;
    }
    uint64_t v4 = v1[4];
    if (v4)
    {
      applejpeg_encode_destroy(v4);
      v1[4] = 0;
    }
    BOOL v5 = v1 + 144;
    do
    {
      if (*v5)
      {
        v6((void *)*v5, v3);
        *BOOL v5 = 0;
      }
      ++v5;
    }
    while (v5 < v1 + 153);
    return (void *)v6(v1, v3);
  }
  return result;
}

uint64_t init_decopt(uint64_t a1, uint64_t a2, uint64_t a3)
{
  applejpeg_decode_options_init(a3);
  *(_OWORD *)(a3 + 12) = *(_OWORD *)(a2 + 20);
  int v6 = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a3 + 76) = *(_DWORD *)(a2 + 12);
  *(void *)(a3 + 28) = *(void *)a2;
  *(_DWORD *)(a3 + 36) = v6;
  *(_DWORD *)(a3 + 72) = *(_DWORD *)(a2 + 16);
  if ((*(_DWORD *)(a1 + 60) - 3) > 2)
  {
    if (*(unsigned char *)(a2 + 198)) {
      int v7 = 4;
    }
    else {
      int v7 = 6;
    }
  }
  else
  {
    int v7 = 15;
  }
  *(_DWORD *)(a3 + 8) = v7;
  *(void *)(a3 + 92) = 0x400000000;
  *(_DWORD *)(a3 + 112) = 0;
  *(void *)(a3 + 120) = 0;
  uint64_t result = *(unsigned int *)(a2 + 192);
  if (result >= 2)
  {
    return aj_transforms_from_orientation(result, (_DWORD *)(a3 + 80), (_DWORD *)(a3 + 84), (_DWORD *)(a3 + 88));
  }
  return result;
}

uint64_t do_recode_plugin(uint64_t a1, uint64_t a2, long long *a3, void *a4)
{
  v160[7] = *MEMORY[0x263EF8340];
  if (a4) {
    *a4 = 0;
  }
  if (*(_DWORD *)(a1 + 88) == 15)
  {
    int v8 = 15;
  }
  else if (*(unsigned char *)(a1 + 414))
  {
    int v8 = 4;
  }
  else
  {
    if (*(_DWORD *)(a1 + 932))
    {
      int v8 = *(_DWORD *)(a1 + 928);
      goto LABEL_8;
    }
    int v8 = 10;
  }
  *(_DWORD *)(a1 + 928) = v8;
LABEL_8:
  BOOL v9 = 1;
  if ((v8 - 10) >= 4) {
    int v10 = 1;
  }
  else {
    int v10 = 2;
  }
  *(_DWORD *)(a1 + 936) = v10;
  LODWORD(v144[0]) = 0;
  LODWORD(v158) = 0;
  LODWORD(v157) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 408);
  if (v11 < 2 || v11 > 8)
  {
    int v13 = 0;
  }
  else if (((1 << v11) & 0x18) != 0)
  {
    int v13 = 1;
  }
  else
  {
    int v12 = 1 << v11;
    if ((v12 & 0x60) != 0)
    {
      BOOL v9 = 0;
      int v13 = 2;
    }
    else
    {
      BOOL v9 = (v12 & 0x180) == 0;
      if ((v12 & 0x180) != 0) {
        int v13 = 3;
      }
      else {
        int v13 = 0;
      }
    }
  }
  int32x2_t v142 = 0;
  uint64_t v143 = 0;
  long long v141 = 0uLL;
  *(void *)&long long v146 = 0;
  uint64_t v159 = 0;
  HIDWORD(v156) = 0;
  *(_DWORD *)(a1 + 940) = v13;
  uint64_t v14 = aj_calculate_dimensions((_DWORD *)(a1 + 80), *(void *)(a1 + 24) + 144, (int *)&v142, (int *)&v142 + 1, (int *)v144, (int *)&v158, &v141, (int *)&v156 + 1, (int *)&v157);
  if (v14) {
    goto LABEL_53;
  }
  if (!v9)
  {
    int32x2_t v142 = vrev64_s32(v142);
    int v15 = v158;
    LODWORD(v158) = v144[0];
    LODWORD(v144[0]) = v15;
  }
  int v16 = HIDWORD(v156);
  uint64_t v17 = *(void *)(a1 + 24);
  if (SHIDWORD(v156) >= 2 && *(_DWORD *)(v17 + 156) / SHIDWORD(v156) < *(_DWORD *)(a1 + 112))
  {
    int v16 = HIDWORD(v156) >> 1;
    HIDWORD(v156) >>= 1;
  }
  uint64_t v18 = 160;
  if (v9) {
    uint64_t v18 = 176;
  }
  int v19 = 8 * *(_DWORD *)(v17 + v18);
  int v20 = v16 << 6;
  *(_DWORD *)(a1 + 960) = v16 << 6;
  switch(*(_DWORD *)(a1 + 940))
  {
    case 0:
      int v21 = DWORD1(v141);
      goto LABEL_36;
    case 1:
      int v22 = DWORD1(v141);
      int v23 = HIDWORD(v141);
      goto LABEL_38;
    case 2:
      int v21 = v141;
LABEL_36:
      v20 += v21 / v19 * v19 - v21;
      goto LABEL_40;
    case 3:
      int v22 = v141;
      int v23 = DWORD2(v141);
LABEL_38:
      int v24 = (v23 + v22) % v19;
      if (v24) {
        int v20 = v20 - v19 + v24;
      }
LABEL_40:
      *(_DWORD *)(a1 + 964) = v20;
      break;
    default:
      int v20 = *(_DWORD *)(a1 + 964);
      break;
  }
  uint64_t v25 = 8;
  if (v9) {
    uint64_t v25 = 12;
  }
  int v26 = *(_DWORD *)((char *)&v141 + v25);
  if (v20 > v26)
  {
    *(_DWORD *)(a1 + 964) = v26;
    int v20 = v26;
  }
  if (*(_DWORD *)(a1 + 936) == 2 && ((v20 / v16) & 1) != 0)
  {
    if ((v19 / v16))
    {
      int v27 = v20 + v19;
    }
    else
    {
      int v27 = (v20 + v16) & -v16;
      DWORD1(v141) += v20 - v27;
    }
    *(_DWORD *)(a1 + 964) = v27;
  }
  *(_DWORD *)(a1 + 156) = v16;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 108) = 0;
  *(_OWORD *)(a1 + 92) = v141;
  *(_DWORD *)(a1 + 88) = v8;
  uint64_t v14 = applejpeg_decode_set_options(v17, a1 + 80, &v146, 0, &v159, &v143, (_DWORD *)&v143 + 1);
  if (v14) {
    goto LABEL_53;
  }
  int v31 = *(_DWORD *)(a1 + 964);
  int v32 = *(_DWORD *)(a1 + 960);
  int v33 = (v26 - v31) % v32;
  int v34 = v31 / SHIDWORD(v156) + v33 / SHIDWORD(v156);
  int v35 = v33 + v31;
  int v36 = HIDWORD(v143);
  if (v34 != v35 / SHIDWORD(v156)) {
    int v36 = --HIDWORD(v143);
  }
  if (v32 > v31) {
    int v31 = v32;
  }
  int v37 = v31 / SHIDWORD(v156);
  if (v37 >= v36) {
    int v37 = v36;
  }
  *(_DWORD *)(a1 + 968) = v37;
  unsigned int v38 = *(_DWORD *)(a1 + 928);
  LODWORD(v159) = 0;
  *(void *)&long long v146 = v143;
  *((int32x2_t *)&v146 + 1) = v142;
  *(void *)&long long v147 = __PAIR64__(v37, v38);
  *(void *)(a1 + 472) = (*(uint64_t (**)(void, long long *, uint64_t, uint64_t *))(a1 + 384))(*(void *)(a1 + 376), &v146, a1 + 480, &v159);
  int v39 = v159;
  *(_DWORD *)(a1 + 972) = v159 == 0;
  if (v39)
  {
    aj_log_error((uint64_t)"Recode", "Resize plugin returned error code %d on init", v39);
    uint64_t v14 = v159;
    if (v159) {
      goto LABEL_53;
    }
  }
  int v40 = *(_DWORD *)(a1 + 928);
  if (v40 <= 9)
  {
    if ((v40 - 3) >= 2)
    {
      if (v40 == 8)
      {
        int v41 = 0;
        int v42 = 0;
        unsigned int v43 = 0;
        int v44 = 1;
        int v45 = 2;
LABEL_74:
        int v46 = 1;
        goto LABEL_76;
      }
LABEL_113:
      aj_log_error((uint64_t)"Recode", "Unsupported format");
      uint64_t v14 = 3;
      goto LABEL_53;
    }
LABEL_73:
    int v44 = 0;
    int v42 = 0;
    unsigned int v43 = 4;
    int v41 = 1;
    int v45 = 1;
    goto LABEL_74;
  }
  if (v40 != 10)
  {
    if (v40 != 15) {
      goto LABEL_113;
    }
    goto LABEL_73;
  }
  int v41 = 0;
  unsigned int v43 = 0;
  int v45 = 2;
  int v44 = 1;
  int v42 = 1;
  int v46 = 2;
LABEL_76:
  int v47 = *(_DWORD *)(a1 + 560);
  *(_DWORD *)(a1 + 956) = v47;
  if (v47)
  {
    *(_DWORD *)(a1 + 808) = v45;
    *(_DWORD *)(a1 + 824) = v40;
    *(_DWORD *)(a1 + 816) = v142.i32[0];
    uint64_t v48 = v45;
    int v49 = (uint64_t *)(a1 + 568);
    do
    {
      uint64_t v50 = *v49;
      v49[26] = *v49;
      v49[41] = v49[4];
      v49[22] = v50;
      ++v49;
      --v48;
    }
    while (v48);
    goto LABEL_79;
  }
  int v70 = *(_DWORD *)(a1 + 480) & 1;
  if (!v42) {
    int v70 = 0;
  }
  unsigned int v71 = v70 + *(_DWORD *)(a1 + 480);
  __int32 v72 = v142.i32[0];
  __int32 v73 = (v142.i8[0] & 1) + v142.i32[0];
  if (v44)
  {
    unint64_t v74 = v71 * (unint64_t)v73;
    BOOL v75 = (v74 & 0xFFFFFFFF00000000) != 0;
    unint64_t v76 = (2 * ((int)v71 / v46)) * (unint64_t)(v73 / v45);
    uint64_t v77 = (v74 + v76);
    BOOL v78 = __CFADD__(v74, v76);
    *(void *)(a1 + 448) = v77;
    if (v75 || (v76 & 0xFFFFFFFF00000000) != 0 || v78) {
      goto LABEL_122;
    }
  }
  else
  {
    unint64_t v84 = v71 * (unint64_t)v142.u32[0];
    uint64_t v77 = v84 * v43;
    *(void *)(a1 + 448) = v77;
    if ((v84 & 0xFFFFFFFF00000000) != 0 || ((v84 * (unint64_t)v43) & 0xFFFFFFFF00000000) != 0)
    {
LABEL_122:
      aj_log_error((uint64_t)"Recode", "Warning: Output buffer sizes larger than UINT32_MAX not supported.");
      goto LABEL_133;
    }
  }
  __int32 v133 = v73;
  int v134 = v46;
  int v137 = v42;
  int v135 = v41;
  unsigned int v139 = v43;
  if (*(void *)(a1 + 1160))
  {
    (*(void (**)(void, void))(a1 + 8))(*(void *)(a1 + 1160), *(void *)(a1 + 16));
    uint64_t v77 = *(void *)(a1 + 448);
  }
  int v85 = (void *)(*(uint64_t (**)(uint64_t, void))a1)(v77, *(void *)(a1 + 16));
  *(void *)(a1 + 440) = v85;
  *(void *)(a1 + 1160) = v85;
  if (!v85 || (bzero(v85, *(void *)(a1 + 448)), !*(void *)(a1 + 1160)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for the plugin out buffer");
    goto LABEL_133;
  }
  *(_DWORD *)(a1 + 808) = v45;
  uint64_t v86 = *(void *)(a1 + 440);
  *(void *)(a1 + 776) = v86;
  *(_DWORD *)(a1 + 824) = v40;
  *(_DWORD *)(a1 + 816) = v142.i32[0];
  *(void *)(a1 + 744) = v86;
  int v42 = v137;
  if (v44)
  {
    uint64_t v87 = v86 + (int)(v71 * v133);
    *(void *)(a1 + 784) = v87;
    *(void *)(a1 + 752) = v87;
    *(void *)(a1 + 712) = v133;
    *(void *)(a1 + 720) = 2 * (v133 / v45);
    unsigned int v43 = v139;
  }
  else
  {
    unsigned int v43 = v139;
    *(void *)(a1 + 712) = (int)(v72 * v139);
  }
  int v41 = v135;
  int v46 = v134;
LABEL_79:
  int v51 = *(_DWORD *)(a1 + 488);
  *(_DWORD *)(a1 + 952) = v51;
  if (v51)
  {
    unint64_t v52 = (v143 & 1) + (int)v143;
    uint64_t v53 = v45;
    int v54 = (void *)a1;
    while (1)
    {
      unint64_t v55 = v54[66];
      if (v55 < v52) {
        break;
      }
      v54[85] = v54[62];
      v54[81] = v55;
      v54[15] = v55;
      ++v54;
      if (!--v53) {
        goto LABEL_83;
      }
    }
    aj_log_error((uint64_t)"Recode", "The plugin supplied row buffers are too small");
    uint64_t v14 = 8;
    goto LABEL_53;
  }
  int v79 = *(_DWORD *)(a1 + 484) + *(_DWORD *)(a1 + 968);
  int v80 = v79 & 1;
  if (!v42) {
    int v80 = 0;
  }
  int v81 = v80 + v79;
  if (v44) {
    int v82 = (v143 & 1) + v143;
  }
  else {
    int v82 = v143;
  }
  unsigned int v138 = v43;
  int v136 = v82;
  if (v44) {
    int v83 = v81 * ((v143 & 1) + v143) + 2 * v81 / v46 * ((int)((v143 & 1) + v143) / v45);
  }
  else {
    int v83 = v143 * v43 * v81;
  }
  int v88 = v41;
  uint64_t v89 = *(void *)(a1 + 1208);
  if (v89) {
    (*(void (**)(uint64_t, void))(a1 + 8))(v89, *(void *)(a1 + 16));
  }
  int16x8_t v90 = (void *)(*(uint64_t (**)(void, void))a1)(v83, *(void *)(a1 + 16));
  *(void *)(a1 + 944) = v90;
  *(void *)(a1 + 1208) = v90;
  if (!v90 || (bzero(v90, v83), !*(void *)(a1 + 1208)))
  {
    aj_log_error((uint64_t)"Recode", "Could not allocate memory for the plugin input buffer");
    goto LABEL_133;
  }
  uint64_t v91 = *(void *)(a1 + 944);
  *(void *)(a1 + 680) = v91;
  if (v88)
  {
    unsigned int v43 = v138;
    *(void *)(a1 + 648) = (int)(v136 * v138);
  }
  else
  {
    *(void *)(a1 + 648) = v136;
    *(void *)(a1 + 688) = v91 + v81 * v136;
    *(void *)(a1 + 656) = 2 * (v136 / v45);
    unsigned int v43 = v138;
  }
LABEL_83:
  if (*(unsigned char *)(a1 + 414))
  {
    unsigned int v56 = v43;
    size_t v57 = (int)(*(_DWORD *)(a1 + 480) * v43 * v142.i32[0]);
    uint64_t v58 = *(void *)(a1 + 976);
    if (v58) {
      (*(void (**)(uint64_t, void))(a1 + 8))(v58, *(void *)(a1 + 16));
    }
    long long v59 = (void *)(*(uint64_t (**)(size_t, void))a1)(v57, *(void *)(a1 + 16));
    *(void *)(a1 + 1216) = v59;
    *(void *)(a1 + 976) = v59;
    if (!v59 || (bzero(v59, v57), !*(void *)(a1 + 976)))
    {
      aj_log_error((uint64_t)"Recode", "Unable to allocate the convert buffer");
      goto LABEL_133;
    }
    *(_DWORD *)(a1 + 1008) = v45;
    *(_DWORD *)(a1 + 1024) = v40;
    *(_DWORD *)(a1 + 1020) = *(_DWORD *)(a1 + 480);
    __int32 v60 = v142.i32[0];
    *(_DWORD *)(a1 + 1016) = v142.i32[0];
    *(void *)(a1 + 1096) = (int)(v60 * v56);
  }
  int v61 = *(_DWORD *)(a1 + 928);
  int64x2_t v62 = applejpeg_encode_create((long long *)a1);
  *(void *)(a1 + 32) = v62;
  if (!v62)
  {
LABEL_133:
    uint64_t v14 = 6;
    goto LABEL_53;
  }
  *((_DWORD *)v62 + 3328) = 1;
  *(_DWORD *)(a1 + 824) = v61;
  *(int32x2_t *)(a1 + 816) = v142;
  if (!*(unsigned char *)(a1 + 253))
  {
    *(void *)&long long v148 = 0;
    long long v146 = 0u;
    long long v147 = 0u;
    uint64_t format_description = aj_get_format_description(v61, (uint64_t)&v146);
    if (format_description)
    {
LABEL_136:
      uint64_t v14 = format_description;
      goto LABEL_53;
    }
    int v97 = DWORD2(v147);
    int v98 = HIDWORD(v147);
    signed int chroma_subsampling = applejpeg_decode_get_chroma_subsampling(*(_DWORD **)(a1 + 24));
    uint64_t subsampling_from_jpeg_format = aj_get_subsampling_from_jpeg_format(chroma_subsampling);
    if (v97 <= (int)subsampling_from_jpeg_format) {
      uint64_t v101 = subsampling_from_jpeg_format;
    }
    else {
      uint64_t v101 = v97;
    }
    if (v98 <= SHIDWORD(subsampling_from_jpeg_format)) {
      uint64_t v102 = HIDWORD(subsampling_from_jpeg_format);
    }
    else {
      uint64_t v102 = v98;
    }
    *(_DWORD *)(a1 + 312) = aj_get_jpeg_format_from_subsampling(v101 | (v102 << 32), *(_DWORD *)(*(void *)(a1 + 24) + 144));
  }
  int v63 = (_OWORD *)(a1 + 256);
  long long v64 = *(_OWORD *)(a1 + 896);
  long long v150 = *(_OWORD *)(a1 + 880);
  long long v151 = v64;
  long long v152 = *(_OWORD *)(a1 + 912);
  long long v65 = *(_OWORD *)(a1 + 832);
  long long v146 = *(_OWORD *)(a1 + 816);
  long long v147 = v65;
  long long v66 = *(_OWORD *)(a1 + 864);
  long long v148 = *(_OWORD *)(a1 + 848);
  long long v149 = v66;
  if (*(unsigned char *)(a1 + 414))
  {
    long long v67 = *(_OWORD *)(a1 + 1112);
    long long v151 = *(_OWORD *)(a1 + 1096);
    long long v152 = v67;
  }
  uint64_t v68 = *(void *)(a1 + 32);
  if (a2) {
    uint64_t v69 = applejpeg_encode_set_options_mem(v68, v63, (uint64_t)&v146, a2);
  }
  else {
    uint64_t v69 = applejpeg_encode_set_options_file(v68, v63, (uint64_t)&v146, a3);
  }
  uint64_t v14 = v69;
  *(_DWORD *)(*(void *)(a1 + 32) + 3464) = *(_DWORD *)(*(void *)(a1 + 24) + 3560);
  if (!v69)
  {
    unint64_t v93 = DWORD1(v141);
    int v94 = *(_DWORD *)(a1 + 940);
    switch(v94)
    {
      case 0:
        unsigned int v95 = *(_DWORD *)(a1 + 964);
        unint64_t v96 = DWORD2(v141) | ((unint64_t)v95 << 32);
        goto LABEL_152;
      case 1:
        unsigned int v95 = *(_DWORD *)(a1 + 964);
        unint64_t v96 = DWORD2(v141) | ((unint64_t)v95 << 32);
        LODWORD(v93) = HIDWORD(v141) + DWORD1(v141) - v95;
LABEL_152:
        BOOL v105 = (int)v95 < SHIDWORD(v141);
        goto LABEL_154;
      case 2:
        uint64_t v106 = *(unsigned int *)(a1 + 964);
        unint64_t v96 = *((void *)&v141 + 1) & 0xFFFFFFFF00000000 | v106;
        BOOL v105 = (int)v106 < SDWORD2(v141);
LABEL_154:
        BOOL v103 = !v105;
        unsigned int v104 = v141;
        break;
      case 3:
        uint64_t v107 = *(unsigned int *)(a1 + 964);
        unint64_t v96 = *((void *)&v141 + 1) & 0xFFFFFFFF00000000 | v107;
        unsigned int v104 = DWORD2(v141) + v141 - v107;
        BOOL v103 = (int)v107 >= SDWORD2(v141);
        break;
      default:
        BOOL v103 = 0;
        unint64_t v96 = *((void *)&v141 + 1);
        unsigned int v104 = v141;
        break;
    }
    unint64_t v108 = aj_limit_region(v104 | ((unint64_t)v93 << 32), v96, v141);
    unint64_t v110 = v109;
    char v111 = 0;
    int v140 = (int *)(a1 + 632);
    while (1)
    {
      uint64_t v155 = 0;
      long long v153 = 0u;
      long long v154 = 0u;
      long long v151 = 0u;
      long long v152 = 0u;
      long long v149 = 0u;
      long long v150 = 0u;
      long long v147 = 0u;
      long long v148 = 0u;
      long long v146 = 0u;
      *(void *)(a1 + 92) = v108;
      unint64_t v112 = HIDWORD(v110);
      *(void *)(a1 + 100) = v110;
      if (!v103 || (int v113 = *(_DWORD *)(a1 + 156), (int)v110 / v113) && SHIDWORD(v110) / v113)
      {
        if (v111 & 1 | (v94 == 0))
        {
          *(void *)(a1 + 184) = 0;
          *(_DWORD *)(a1 + 180) = 0;
        }
        else
        {
          *(_DWORD *)(a1 + 180) = 1;
          if ((v94 - 1) > 2)
          {
            int v116 = 0;
            int v115 = 0;
          }
          else
          {
            int v115 = dword_21040FF50[v94 - 1];
            int v116 = 1;
          }
          *(_DWORD *)(a1 + 184) = v116;
          *(_DWORD *)(a1 + 188) = v115;
        }
        uint64_t v157 = 0;
        uint64_t v158 = 0;
        uint64_t v156 = 0;
        memset(v144, 0, sizeof(v144));
        uint64_t v145 = 0;
        uint64_t format_description = applejpeg_decode_set_options(*(void *)(a1 + 24), a1 + 80, &v158, (uint64_t)v144, &v157, (_DWORD *)&v156 + 1, &v156);
        if (format_description) {
          goto LABEL_136;
        }
        unsigned int v117 = v145;
        if ((int)v145 >= 1)
        {
          uint64_t v118 = 0;
          uint64_t v119 = 8 * v145;
          uint16x8_t v120 = v160;
          do
          {
            if (v118)
            {
              int v121 = (void *)(a1 + v118 + 648);
              int v122 = *(_DWORD *)(a1 + 636) / *(_DWORD *)(a1 + 936);
            }
            else
            {
              int v122 = *(_DWORD *)(a1 + 636);
              int v121 = (void *)(a1 + 648);
            }
            *(v120 - 1) = *(void *)(a1 + v118 + 680) + *v121 * v122;
            *uint16x8_t v120 = *(void *)((char *)v144 + v118);
            v120 += 2;
            v118 += 8;
          }
          while (v119 != v118);
        }
        uint64_t v123 = applejpeg_decode_image_all(*(void *)(a1 + 24), &v159, v117, (uint64_t)&v146);
        if (v123)
        {
          uint64_t v14 = v123;
          aj_log_error((uint64_t)"Recode", "Decoder returned error code %d", v123);
          *(_DWORD *)(a1 + 644) = *(_DWORD *)(a1 + 636);
          *(_DWORD *)(a1 + 640) = HIDWORD(v148);
          break;
        }
        int v114 = HIDWORD(v148);
      }
      else
      {
        int v114 = 0;
      }
      *(_DWORD *)(a1 + 644) = *(_DWORD *)(a1 + 636);
      *(_DWORD *)(a1 + 640) = v114;
      uint64_t v124 = (*(uint64_t (**)(void, uint64_t, int *, BOOL))(a1 + 392))(*(void *)(a1 + 472), a1 + 640, v140, v103);
      if (v124)
      {
        uint64_t v14 = v124;
        aj_log_error((uint64_t)"Recode", "Resize plugin returned error code %d on resize()", v124);
        break;
      }
      int v125 = *(_DWORD *)(a1 + 636);
      if (*(int *)(a1 + 936) >= 2)
      {
        if (!v103 && (v125 & 1) != 0)
        {
          aj_log_error((uint64_t)"Recode", "Resize-plugin can't save an odd number of rows when the data fromat is 420f");
          goto LABEL_214;
        }
        if (!v103 && (*v140 & 1) != 0)
        {
          aj_log_error((uint64_t)"Recode", "Plugin wrote an uneven nbrof rows");
          goto LABEL_214;
        }
      }
      if (v125 > *(_DWORD *)(a1 + 484))
      {
        aj_log_error((uint64_t)"Recode", "Resize-plugin saved more more rows than allowed");
LABEL_214:
        uint64_t v14 = 1;
        break;
      }
      if (v103 && v125)
      {
        aj_log_error((uint64_t)"Recode", "Resize-plugin saved rows on the last call");
        goto LABEL_214;
      }
      int v126 = *v140;
      if (*v140)
      {
        *(_DWORD *)(a1 + 820) = v126;
        unint64_t v127 = (unsigned int *)(a1 + 776);
        if (*(unsigned char *)(a1 + 414))
        {
          *(_DWORD *)(a1 + 1020) = v126;
          (*(void (**)(void, uint64_t, uint64_t))(a1 + 432))(*(void *)(a1 + 424), a1 + 776, a1 + 976);
          unint64_t v127 = (unsigned int *)(a1 + 976);
        }
        uint64_t v128 = applejpeg_encode_image_row(*(void *)(a1 + 32), v127, a4);
        uint64_t v14 = v128;
        if (v103 || v128) {
          break;
        }
      }
      else if (v103)
      {
        uint64_t v14 = 0;
        break;
      }
      unint64_t v129 = HIDWORD(v108);
      int v94 = *(_DWORD *)(a1 + 940);
      switch(v94)
      {
        case 0:
          unint64_t v129 = (HIDWORD(v108) + HIDWORD(v110));
          unint64_t v112 = *(unsigned int *)(a1 + 960);
          BOOL v130 = (int)v112 + (int)v129 < HIDWORD(v141) + DWORD1(v141);
          goto LABEL_200;
        case 1:
          unint64_t v112 = *(unsigned int *)(a1 + 960);
          unint64_t v129 = (HIDWORD(v108) - v112);
          BOOL v131 = (int)v129 <= SDWORD1(v141);
          goto LABEL_204;
        case 2:
          LODWORD(v108) = v108 + v110;
          LODWORD(v110) = *(_DWORD *)(a1 + 960);
          BOOL v130 = (int)v110 + (int)v108 < DWORD2(v141) + (int)v141;
LABEL_200:
          BOOL v103 = !v130;
          break;
        case 3:
          LODWORD(v110) = *(_DWORD *)(a1 + 960);
          LODWORD(v108) = v108 - v110;
          BOOL v131 = (int)v108 <= (int)v141;
LABEL_204:
          BOOL v103 = v131;
          break;
        default:
          BOOL v103 = 0;
          break;
      }
      unint64_t v108 = aj_limit_region(v108 | (v129 << 32), v110 | (v112 << 32), v141);
      unint64_t v110 = v132;
      char v111 = 1;
    }
  }
LABEL_53:
  uint64_t v28 = *(void (**)(void))(a1 + 400);
  if (v28 && *(_DWORD *)(a1 + 972))
  {
    v28(*(void *)(a1 + 472));
    *(void *)(a1 + 472) = 0;
  }
  *(_DWORD *)(a1 + 972) = 0;
  uint64_t v29 = *(void *)(a1 + 32);
  if (v29)
  {
    applejpeg_encode_destroy(v29);
    *(void *)(a1 + 32) = 0;
  }
  return v14;
}

uint64_t aj_limit_region(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((int)a1 < (int)a3) {
    uint64_t v3 = a3;
  }
  else {
    uint64_t v3 = a1;
  }
  if (SHIDWORD(a1) <= SHIDWORD(a3)) {
    uint64_t v4 = HIDWORD(a3);
  }
  else {
    uint64_t v4 = HIDWORD(a1);
  }
  return v3 | (v4 << 32);
}

char *pad_region(char *result, int a2, int a3, int a4, int a5, int a6, int a7)
{
  if (result)
  {
    unsigned int v11 = result;
    if (a2 > a6 + a4 && a7 >= 1)
    {
      int v12 = &result[a5 * (uint64_t)a2 + a6 + a4];
      size_t v13 = a2 - (a6 + a4);
      int v14 = a7;
      do
      {
        uint64_t result = (char *)memset(v12, *(v12 - 1), v13);
        v12 += a2;
        --v14;
      }
      while (v14);
    }
    int v15 = a7 + a5;
    int v16 = a3 - (a7 + a5);
    if (a3 > v15 && v16 >= 1)
    {
      size_t v17 = a2;
      uint64_t v18 = &v11[v15 * (uint64_t)a2];
      int v19 = &v18[-a2];
      do
      {
        uint64_t result = (char *)memcpy(v18, v19, v17);
        v18 += v17;
        --v16;
      }
      while (v16);
    }
  }
  return result;
}

uint64_t aj_encode_release_scan_buffers(uint64_t result, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)(result + 19808);
  if (*(int *)(result + 19808) >= 1)
  {
    int v4 = 0;
    BOOL v5 = (void *)(*(void *)(result + 19816) + 184);
    do
    {
      if (*v5)
      {
        (*(void (**)(void, void))(a2 + 8))(*v5, *(void *)(a2 + 16));
        *BOOL v5 = 0;
      }
      uint64_t v6 = *(v5 - 2);
      if (v6)
      {
        (*(void (**)(uint64_t, void))(a2 + 8))(v6, *(void *)(a2 + 16));
        *(v5 - 2) = 0;
      }
      uint64_t result = *(v5 - 9);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void))(a2 + 8))(result, *(void *)(a2 + 16));
        *(v5 - 9) = 0;
      }
      ++v4;
      v5 += 38;
    }
    while (v4 < *v2);
  }
  return result;
}

unsigned int *aj_reset_row_ptrs(unsigned int *result, void *a2, uint64_t a3)
{
  v14[4] = *MEMORY[0x263EF8340];
  if (result[3340] == 14)
  {
    uint64_t v3 = *((void *)result + 2471);
    uint64_t v4 = *((void *)result + 2472);
    uint64_t v5 = *((void *)result + 2473);
  }
  else
  {
    uint64_t v3 = (int)result[3354];
    signed int v6 = result[4];
    uint64_t v4 = (int)(result[5] * v3) / v6;
    uint64_t v5 = (int)(result[6] * v3) / v6;
    void v14[3] = (int)(result[7] * v3) / v6;
  }
  v14[0] = v3;
  v14[1] = v4;
  v14[2] = v5;
  uint64_t v7 = *result;
  if ((int)v7 >= 1)
  {
    for (uint64_t i = 0; i != v7; ++i)
    {
      int v9 = result[i + 8];
      if (v9 >= 1)
      {
        uint64_t v10 = 0;
        LODWORD(v11) = 8 * v9;
        uint64_t v12 = v14[i];
        if ((int)v11 <= 1) {
          uint64_t v11 = 1;
        }
        else {
          uint64_t v11 = v11;
        }
        size_t v13 = a2;
        do
        {
          *v13++ = *(void *)(a3 + 8 * i) + v10;
          v10 += v12;
          --v11;
        }
        while (v11);
      }
      a2 += 16;
    }
  }
  return result;
}

uint64_t aj_allocate_enc_buffers(unsigned int *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = *a1;
  if ((int)v6 < 1)
  {
    int v9 = 0;
  }
  else
  {
    int v7 = 0;
    int v8 = a1 + 3370;
    do
    {
      v7 += *v8;
      v8 += 392;
      --v6;
    }
    while (v6);
    int v9 = v7 << 6;
  }
  uint64_t v10 = (int)(v9 * a1[3358]);
  *((void *)a1 + 1681) = v10;
  uint64_t v11 = a2 + 224;
  if (a2[224])
  {
    (*(void (**)(void, void))(a3 + 8))(a2[224], *(void *)(a3 + 16));
    uint64_t v10 = *((void *)a1 + 1681);
  }
  uint64_t v12 = (void *)(*(uint64_t (**)(uint64_t, void))a3)(v10, *(void *)(a3 + 16));
  *uint64_t v11 = (uint64_t)v12;
  if (v12 && (bzero(v12, *((void *)a1 + 1681)), (uint64_t v13 = *v11) != 0))
  {
    uint64_t v14 = *a1;
    if ((int)v14 >= 1)
    {
      unsigned int v15 = a1[3358];
      int v16 = a2 + 224;
      size_t v17 = a1 + 3370;
      do
      {
        *v16++ = v13;
        v13 += (int)((*v17 * v15) << 6);
        v17 += 392;
        --v14;
      }
      while (v14);
    }
    aj_reset_row_ptrs(a1, a2, (uint64_t)(a2 + 224));
    return 0;
  }
  else
  {
    aj_log_error((uint64_t)"EncodeInit", "Could not allocate memory for mcu buffer");
    return 6;
  }
}

uint64_t aj_init_out_stream(uint64_t result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  int v4 = *((_DWORD *)a3 + 2);
  *(_DWORD *)(result + 64) = v4;
  *(void *)(result + 40) = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(result + 24) = v3;
  *(void *)(result + 32) = v5;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = v3;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 20) = v4;
  return result;
}

uint64_t aj_encode_init(uint64_t *a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14 = (_DWORD *)(a2 + 13440);
  *(void *)(a2 + 13284) = 0;
  *(_OWORD *)(a2 + 13268) = xmmword_21040FF60;
  int v15 = a4[2];
  *(_DWORD *)(a2 + 13360) = v15;
  int v16 = *(_DWORD *)(a5 + 60);
  *(_DWORD *)(a2 + 19800) = v16 == 1;
  *(_DWORD *)(a2 + 19804) = v16 == 2;
  size_t v17 = aj_encode_buffers_baseline;
  if (v16 == 1) {
    size_t v17 = aj_encode_buffers_progressive;
  }
  *(void *)(a2 + 19752) = v17;
  int v160 = (_DWORD *)(a2 + 13440);
  if (v15 != 14)
  {
    int v27 = (_DWORD *)(a2 + 19832);
    *(_DWORD *)(a2 + 19848) = 1;
    *(_OWORD *)(a2 + 19832) = xmmword_21040FF70;
    uint64_t v28 = (void *)(a2 + 19844);
    uint64_t v29 = (void *)(a2 + 19836);
    switch(v15)
    {
      case 0:
        *(_DWORD *)(a2 + 13444) = 3;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283300;
        goto LABEL_54;
      case 1:
        *(_DWORD *)(a2 + 13444) = 2;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283378;
        goto LABEL_54;
      case 2:
        *(_DWORD *)(a2 + 13444) = 2;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C2833A0;
        goto LABEL_54;
      case 3:
        *(_DWORD *)(a2 + 13444) = 4;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283328;
        goto LABEL_54;
      case 4:
        *(_DWORD *)(a2 + 13444) = 4;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283350;
        goto LABEL_54;
      case 5:
        int v36 = 1;
        goto LABEL_52;
      case 6:
        *(_DWORD *)(a2 + 13444) = 3;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C2833F0;
        goto LABEL_54;
      case 8:
      case 9:
        *int v27 = 1;
        if (v15 == 9) {
          *uint64_t v29 = 0x100000002;
        }
        *(_DWORD *)(a2 + 19848) = 2;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283418;
        goto LABEL_54;
      case 10:
      case 11:
        *int v27 = 1;
        if (v15 == 11) {
          *uint64_t v29 = 0x100000002;
        }
        *uint64_t v28 = 0x200000002;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283440;
        goto LABEL_54;
      case 12:
      case 13:
        *int v27 = 1;
        if (v15 == 13) {
          *uint64_t v29 = 0x100000002;
        }
        *(_DWORD *)uint64_t v28 = 2;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5) {
          goto LABEL_55;
        }
        int v35 = &off_26C283468;
        goto LABEL_54;
      case 15:
        *(_DWORD *)(a2 + 13444) = 4;
        int v31 = (uint64_t (*)())aj_deinterleave_8888;
        goto LABEL_56;
      case 16:
      case 17:
      case 20:
        if (v15 == 20) {
          int v30 = 6;
        }
        else {
          int v30 = 8;
        }
        *(_DWORD *)(a2 + 13444) = v30;
        *(void *)(a2 + 19744) = 0;
        if (v16 != 2)
        {
          aj_log_error((uint64_t)"EncodeInit", "16-bit RGB only supported for lossless encoding");
          return 3;
        }
        int v31 = 0;
LABEL_60:
        if (*v27)
        {
          int v38 = v14[1602];
          int v39 = *a4 & 1;
          if (v38 != 2) {
            int v39 = 0;
          }
          int v40 = v39 + *a4;
          unint64_t v41 = *((void *)a4 + 10);
          uint64_t v42 = v40;
          if (v41)
          {
            uint64_t v42 = *((void *)a4 + 10);
            if (v41 < v40) {
              goto LABEL_78;
            }
          }
          *(void *)(a2 + 19768) = v42;
          unint64_t v43 = *((void *)a4 + 11);
          unint64_t v44 = 2 * (v40 / v38);
          if (v43)
          {
            if (v43 < v44) {
              goto LABEL_78;
            }
          }
          else
          {
            unint64_t v43 = v44;
          }
          *(void *)(a2 + 19776) = v43;
          if (v31) {
            goto LABEL_87;
          }
        }
        else
        {
          unint64_t v47 = *((void *)a4 + 10);
          int v48 = *(_DWORD *)(a2 + 13444);
          if (v47)
          {
            if (v47 < v48 * (uint64_t)*a4) {
              goto LABEL_78;
            }
          }
          else
          {
            unint64_t v47 = v48 * (uint64_t)*a4;
          }
          *(void *)(a2 + 19768) = v47;
          if (v31) {
            goto LABEL_87;
          }
        }
        if (v14[1591]) {
          goto LABEL_87;
        }
        aj_log_error((uint64_t)"EncodeInit", "Colortransform function pointer is NULL.");
        return 5;
      case 18:
        int v36 = 2;
LABEL_52:
        *(_DWORD *)(a2 + 13444) = v36;
        uint64_t v34 = *(int *)(a5 + 56);
        if (v34 >= 5)
        {
LABEL_55:
          aj_log_error((uint64_t)"EncodeInit", "Unsupported output format.");
          uint64_t v14 = v160;
          int v31 = 0;
        }
        else
        {
          int v35 = &off_26C2833C8;
LABEL_54:
          int v31 = v35[v34];
        }
LABEL_56:
        *(void *)(a2 + 19744) = v31;
        int v15 = *(_DWORD *)(a2 + 13360);
        if (v15 == 14) {
          goto LABEL_57;
        }
        goto LABEL_60;
      default:
        aj_log_error((uint64_t)"EncodeInit", "Unsupported input format");
        return 3;
    }
  }
  long long v19 = *((_OWORD *)a4 + 3);
  long long v18 = *((_OWORD *)a4 + 4);
  long long v20 = *((_OWORD *)a4 + 2);
  *(_OWORD *)(a2 + 13296) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a2 + 13328) = v19;
  *(_OWORD *)(a2 + 13344) = v18;
  *(_OWORD *)(a2 + 13312) = v20;
  uint64_t v21 = *(void *)(a2 + 13304);
  unint64_t v22 = (unint64_t)(v21 + 1) >> 1;
  uint64_t v23 = *(void *)(a2 + 13296);
  uint64_t v24 = *(void *)(a2 + 13328);
  if (v23 == v24)
  {
    uint64_t v25 = *(void *)(a2 + 13336);
    if (v21 == v25)
    {
      int v26 = 0;
      goto LABEL_20;
    }
    if (v22 == v25)
    {
      int v26 = 2;
      goto LABEL_20;
    }
LABEL_21:
    aj_log_error((uint64_t)"EncodeInit", "Unknown input decimation");
    return 3;
  }
  if (v24 != (unint64_t)(v23 + 1) >> 1) {
    goto LABEL_21;
  }
  uint64_t v32 = *(void *)(a2 + 13336);
  if (v21 == v32)
  {
    int v26 = 1;
    goto LABEL_20;
  }
  if (v22 != v32) {
    goto LABEL_21;
  }
  int v26 = 3;
LABEL_20:
  *(_DWORD *)(a5 + 56) = v26;
  int v27 = (_DWORD *)(a2 + 19832);
  uint64_t v28 = (void *)(a2 + 19844);
  *(_DWORD *)(a2 + 19848) = 1;
  *(_OWORD *)(a2 + 19832) = xmmword_21040FF70;
LABEL_57:
  unint64_t v37 = *((void *)a4 + 10);
  if (v37)
  {
    if (v37 < *((void *)a4 + 2)) {
      goto LABEL_78;
    }
  }
  else
  {
    unint64_t v37 = *((void *)a4 + 2);
  }
  *(void *)(a2 + 19768) = v37;
  unint64_t v45 = *((void *)a4 + 11);
  if (v45)
  {
    if (v45 < *((void *)a4 + 6)) {
      goto LABEL_78;
    }
  }
  else
  {
    unint64_t v45 = *((void *)a4 + 6);
  }
  *(void *)(a2 + 19776) = v45;
  unint64_t v46 = *((void *)a4 + 12);
  if (v46)
  {
    if (v46 < *((void *)a4 + 6))
    {
LABEL_78:
      aj_log_error((uint64_t)"EncodeInit", "Set stride is smaller than the image data");
      return 8;
    }
  }
  else
  {
    unint64_t v46 = *((void *)a4 + 6);
  }
  *(void *)(a2 + 19784) = v46;
  int v15 = 14;
LABEL_87:
  if (v14[1590])
  {
    if (*(void *)(a5 + 72))
    {
      int v49 = *(_DWORD *)(a5 + 64);
      if (v49 < 1) {
        return 1;
      }
      uint64_t v159 = *(char **)(a5 + 72);
    }
    else
    {
      int v49 = 10;
      if (v15 == 15)
      {
        uint64_t v159 = (char *)&prog_scan_cmyk;
      }
      else
      {
        int v51 = *(_DWORD *)(a5 + 56);
        BOOL v52 = v51 == 4;
        if (v51 == 4) {
          uint64_t v53 = (char *)&prog_scan_gray;
        }
        else {
          uint64_t v53 = (char *)&prog_scan_yuv;
        }
        uint64_t v159 = v53;
        if (v52) {
          int v49 = 6;
        }
        else {
          int v49 = 10;
        }
      }
    }
  }
  else
  {
    if (v15 == 15)
    {
      uint64_t v50 = (char *)&base_scan_cmyk;
    }
    else
    {
      uint64_t v50 = (char *)&base_scan_yuv;
      if (*(_DWORD *)(a5 + 56) == 4) {
        uint64_t v50 = (char *)&base_scan_gray;
      }
    }
    uint64_t v159 = v50;
    int v49 = 1;
  }
  if (*(void *)(a2 + 19816)) {
    aj_encode_release_scan_buffers(a2, *a1);
  }
  uint64_t v156 = v28;
  uint64_t v54 = a1[5];
  if (v54) {
    (*(void (**)(uint64_t, void))(*a1 + 8))(v54, *(void *)(*a1 + 16));
  }
  unint64_t v55 = (void *)(*(uint64_t (**)(uint64_t, void))*a1)(304 * v49, *(void *)(*a1 + 16));
  *(void *)(a2 + 19816) = v55;
  a1[5] = (uint64_t)v55;
  if (!v55 || (bzero(v55, 304 * v49), (uint64_t v56 = *(void *)(a2 + 19816)) == 0))
  {
    aj_log_error((uint64_t)"EncodeInit", "Unable to allocate scan info");
    return 6;
  }
  uint64_t v155 = v27;
  long long v152 = a7;
  uint64_t v153 = a6;
  v161 = a1;
  uint64_t v57 = 0;
  uint64_t v154 = a3;
  uint64_t v58 = v160;
  v160[1592] = v49;
  int v59 = *(_DWORD *)(a2 + 12) * *(_DWORD *)(a2 + 8) / (2 * v49);
  if (v59 <= 0x1000) {
    int v59 = 4096;
  }
  int v157 = v59;
  size_t v158 = v59;
  __int32 v60 = v159;
  int v61 = v159 + 4;
  int64x2_t v62 = (uint64_t *)(v56 + 272);
  do
  {
    int v63 = &v60[36 * v57];
    long long v64 = (int *)(v63 + 20);
    int v65 = *((_DWORD *)v63 + 5);
    int v68 = *((_DWORD *)v63 + 7);
    long long v66 = (int *)(v63 + 28);
    int v67 = v68;
    uint64_t v69 = *(unsigned int *)&v60[36 * v57];
    *(_DWORD *)uint64_t v56 = v69;
    if ((int)v69 < 1)
    {
      int v82 = v67;
      int v81 = v65;
    }
    else
    {
      uint64_t v70 = 0;
      if (v67) {
        BOOL v71 = v65 != 0;
      }
      else {
        BOOL v71 = 1;
      }
      uint64_t v72 = 4 * v69;
      __int32 v73 = v62;
      do
      {
        int v74 = *(_DWORD *)&v61[v70];
        uint64_t v75 = v56 + v70;
        *(_DWORD *)(v56 + v70 + 4) = v74;
        *(v73 - 9) = a2 + 1568 * *(int *)&v61[v70] + 13472;
        if (v71)
        {
          uint64_t v76 = v74 != 0;
          uint64_t v77 = a2 + 548 * v76 + 274 * (v65 != 0) + 3424;
          if (v67) {
            uint64_t v77 = a2 + 274 * v76 + 10664;
          }
          *(v73 - 4) = v77;
          unint64_t v78 = a2 + (v76 << 11) + ((unint64_t)(v65 != 0) << 10) + 4520;
          uint64_t v79 = a2 + (v76 << 10) + 11212;
          if (!v67) {
            uint64_t v79 = v78;
          }
          *__int32 v73 = v79;
        }
        v70 += 4;
        BOOL v80 = v74 != 0;
        *(_DWORD *)(v75 + 20) = v80;
        *(_DWORD *)(v75 + 36) = v80;
        ++v73;
      }
      while (v72 != v70);
      int v81 = *v64;
      int v82 = *v66;
    }
    int v83 = &v60[36 * v57];
    int v84 = *((_DWORD *)v83 + 6);
    *(_DWORD *)(v56 + 52) = v81;
    *(_DWORD *)(v56 + 56) = v84;
    *(_DWORD *)(v56 + 60) = *((_DWORD *)v83 + 8);
    *(_DWORD *)(v56 + 64) = v82;
    *(_OWORD *)(v56 + 68) = xmmword_21040FF80;
    uint64_t v85 = *v161;
    *(void *)(v56 + 160) = *v161;
    if (v58[1590])
    {
      if (v65) {
        BOOL v86 = v67 == 0;
      }
      else {
        BOOL v86 = 1;
      }
      if (v86)
      {
        size_t v87 = v158;
      }
      else
      {
        uint64_t v88 = *(void *)(v56 + 184);
        if (v88)
        {
          (*(void (**)(uint64_t, void))(v85 + 8))(v88, *(void *)(v85 + 16));
          uint64_t v85 = *v161;
        }
        uint64_t v89 = (void *)(*(uint64_t (**)(uint64_t, void))v85)(1024, *(void *)(v85 + 16));
        *(void *)(v56 + 184) = v89;
        if (!v89 || (bzero(v89, 0x400uLL), !*(void *)(v56 + 184)))
        {
          aj_log_error((uint64_t)"EncodeInit", "Unable to allocate the correction-bit buffer");
          return 6;
        }
        *(void *)(v56 + 192) = 1024;
        uint64_t v85 = *v161;
        size_t v87 = v158;
      }
      *(void *)(v56 + 232) = *(&off_26C2832E0 + 2 * (v65 != 0) + (v67 != 0));
      *(void *)(v56 + 168) = 0;
      *(void *)(v56 + 176) = 0;
      size_t v90 = v87;
      uint64_t v91 = (void *)(*(uint64_t (**)(void))v85)();
      if (!v91)
      {
        aj_log_error((uint64_t)"EncodeInit", "Unable to allocate %zd bytes for scan #%d out-stream");
        return 6;
      }
      int64x2_t v92 = v91;
      bzero(v91, v90);
      *(void *)(v56 + 112) = v92;
      *(void *)(v56 + 120) = v56;
      *(_DWORD *)(v56 + 152) = v157;
      *(void *)(v56 + 128) = progscan_write_callback;
      *(void *)(v56 + 88) = 0;
      *(void *)(v56 + 96) = v92;
      *(_DWORD *)(v56 + 104) = 0;
      *(_DWORD *)(v56 + 108) = v157;
      uint64_t v58 = v160;
      __int32 v60 = v159;
    }
    ++v57;
    v56 += 304;
    v61 += 36;
    v62 += 38;
  }
  while (v57 != v49);
  *(void *)(a2 + 8) = *(void *)a4;
  int v93 = *(_DWORD *)(a5 + 60);
  if (v93 == 2)
  {
    LOBYTE(v93) = 0;
    int v96 = 195;
    int v94 = v161;
    unsigned int v95 = v155;
  }
  else
  {
    int v94 = v161;
    unsigned int v95 = v155;
    if (v93 == 1)
    {
      int v96 = 194;
    }
    else
    {
      LOBYTE(v93) = 0;
      int v96 = 192;
    }
  }
  *(_DWORD *)(a2 + 80) = v96;
  *(unsigned char *)(a2 + 84) = v93;
  if (*(_DWORD *)(a2 + 13360) == 15)
  {
    int v97 = 4;
    *(_DWORD *)a2 = 4;
    *(void *)&long long v98 = 0x100000001;
    *((void *)&v98 + 1) = 0x100000001;
    *(_OWORD *)(a2 + 16) = v98;
    *(_OWORD *)(a2 + 32) = v98;
  }
  else
  {
    uint64_t v99 = *(unsigned int *)(a5 + 56);
    if (v99 == 4) {
      int v97 = 1;
    }
    else {
      int v97 = 3;
    }
    *(_DWORD *)a2 = v97;
    switch((int)v99)
    {
      case 0:
        *(_DWORD *)(a2 + 24) = 1;
        uint64_t v100 = 0x100000001;
        goto LABEL_165;
      case 1:
        *(_DWORD *)(a2 + 24) = 1;
        *(void *)(a2 + 16) = 0x100000002;
        *(_DWORD *)(a2 + 40) = 1;
        uint64_t v100 = 0x100000001;
        goto LABEL_166;
      case 2:
        *(_DWORD *)(a2 + 13272) = 1;
        *(_DWORD *)(a2 + 24) = 1;
        *(_DWORD *)(a2 + 40) = 1;
        *(void *)(a2 + 32) = 0x100000002;
        *(void *)(a2 + 16) = 0x100000001;
        break;
      case 3:
        *(_DWORD *)(a2 + 13272) = 1;
        *(_DWORD *)(a2 + 24) = 1;
        uint64_t v100 = 0x100000002;
LABEL_165:
        *(void *)(a2 + 16) = v100;
        *(_DWORD *)(a2 + 40) = 1;
        goto LABEL_166;
      default:
        *(_DWORD *)(a2 + 24) = 0;
        uint64_t v100 = 1;
        *(void *)(a2 + 16) = 1;
        *(_DWORD *)(a2 + 40) = 0;
LABEL_166:
        *(void *)(a2 + 32) = v100;
        break;
    }
  }
  *(_DWORD *)(a2 + 4) = 8;
  if (*(_DWORD *)(a5 + 16))
  {
    *(_OWORD *)(a2 + 48) = xmmword_21040FF90;
    aj_get_qtable_for_quality(a2 + 88, *(_DWORD *)(a5 + 16), 1, 0);
    aj_get_qtable_for_quality(a2 + 344, *(_DWORD *)(a5 + 16), 0, 0);
    uint64_t v58 = v160;
  }
  else
  {
    uint64_t v101 = 0;
    uint64_t v102 = a2 + 88;
    do
    {
      if (v101)
      {
        uint64_t v103 = 0;
        uint64_t v104 = *(void *)(a5 + 8 * v101 + 24);
        while (v104 != *(void *)(a5 + 24 + 8 * v103))
        {
          if (v101 == ++v103) {
            goto LABEL_176;
          }
        }
        *(_DWORD *)(a2 + 4 * v101 + 48) = v103;
      }
      else
      {
        uint64_t v104 = *(void *)(a5 + 24);
LABEL_176:
        uint64_t v105 = 0;
        *(_DWORD *)(a2 + 4 * v101 + 48) = v101;
        do
        {
          *(_DWORD *)(v102 + 4 * v105) = *(unsigned __int8 *)(v104 + v105);
          ++v105;
        }
        while (v105 != 64);
      }
      ++v101;
      v102 += 256;
    }
    while (v101 != v97);
  }
  *(_OWORD *)(a2 + 64) = xmmword_21040FFB0;
  *(_OWORD *)(a2 + 3340) = xmmword_21040FFA0;
  *(_OWORD *)(a2 + 3356) = xmmword_21040FF90;
  *(_OWORD *)(a2 + 3372) = xmmword_21040FF90;
  uint64_t v106 = *(void *)(a2 + 19816);
  *(_DWORD *)(a2 + 3336) = *(_DWORD *)v106;
  *(_OWORD *)(a2 + 3388) = *(_OWORD *)(v106 + 52);
  int v107 = *(_DWORD *)(a2 + 13360);
  if ((*(_DWORD *)(a5 + 56) & 0xFFFFFFFE) != 2)
  {
    unint64_t v108 = 0;
    goto LABEL_185;
  }
  if (v107 == 14)
  {
    unint64_t v108 = 0;
    int v109 = *(_DWORD *)(a2 + 32);
    int v110 = 8 * v109;
LABEL_186:
    int v111 = v110;
    goto LABEL_187;
  }
  if (!*v95 || *v156 == 1)
  {
    size_t v134 = vaddvq_s64(vaddq_s64(*(int64x2_t *)(v58 + 1586), *(int64x2_t *)(v58 + 1582)));
    uint64_t v135 = v94[2];
    uint64_t v136 = *v94;
    if (v135)
    {
      (*(void (**)(uint64_t, void))(v136 + 8))(v135, *(void *)(v136 + 16));
      uint64_t v136 = *v94;
    }
    int v137 = (void *)(*(uint64_t (**)(size_t, void))v136)(v134, *(void *)(v136 + 16));
    v94[2] = (uint64_t)v137;
    if (!v137)
    {
      aj_log_error((uint64_t)"EncodeInit", "Could not allocate input buffer memory");
      return 6;
    }
    unint64_t v108 = v137;
    bzero(v137, v134);
    int v107 = *(_DWORD *)(a2 + 13360);
    uint64_t v58 = v160;
LABEL_185:
    int v109 = *(_DWORD *)(a2 + 32);
    int v110 = 8 * v109;
    int v111 = v109;
    if (v107 != 14) {
      goto LABEL_187;
    }
    goto LABEL_186;
  }
  unint64_t v108 = 0;
  int v109 = *(_DWORD *)(a2 + 32);
  int v110 = 8 * v109;
  int v111 = v109;
LABEL_187:
  *(_DWORD *)(a2 + 13292) = v111;
  int v112 = *(_DWORD *)(a2 + 8);
  int v113 = *(_DWORD *)(a2 + 12);
  int v114 = v113 / 8;
  if ((v113 & 7) != 0) {
    ++v114;
  }
  int v115 = v114 / v109;
  if (v114 % v109) {
    ++v115;
  }
  *(_DWORD *)(a2 + 13436) = v115;
  int v116 = v112 / 8;
  if ((v112 & 7) != 0) {
    ++v116;
  }
  int v117 = *(_DWORD *)(a2 + 16);
  if (v116 % v117) {
    int v118 = v116 / v117 + 1;
  }
  else {
    int v118 = v116 / v117;
  }
  *(_DWORD *)(a2 + 13432) = v118;
  *(_DWORD *)(a2 + 13428) = v110;
  *(_DWORD *)(a2 + 13424) = 8 * v117;
  int v119 = v115 * v110;
  *(_DWORD *)(a2 + 13420) = v119;
  *(_DWORD *)(a2 + 13416) = v118 * 8 * v117;
  if (v113 <= v119 - 8) {
    *(unsigned char *)uint64_t v58 = 1;
  }
  if (v109 != 2 || !v58[1590]) {
    goto LABEL_205;
  }
  uint64_t v120 = v94[6];
  uint64_t v121 = *v94;
  if (v120)
  {
    (*(void (**)(uint64_t, void))(v121 + 8))(v120, *(void *)(v121 + 16));
    uint64_t v121 = *v94;
    int v118 = *(_DWORD *)(a2 + 13432);
    int v117 = *(_DWORD *)(a2 + 16);
  }
  int v122 = (void *)(*(uint64_t (**)(uint64_t, void))v121)((uint64_t)(v117 * v118) << 7, *(void *)(v121 + 16));
  *(void *)(a2 + 19824) = v122;
  v94[6] = (uint64_t)v122;
  if (!v122 || (bzero(v122, (uint64_t)(*(_DWORD *)(a2 + 16) * *(_DWORD *)(a2 + 13432)) << 7), !*(void *)(a2 + 19824)))
  {
    aj_log_error((uint64_t)"EncodeInit", "Unable to allocate progressive coeff buffer");
    return 6;
  }
  int v107 = *(_DWORD *)(a2 + 13360);
  uint64_t v58 = v160;
LABEL_205:
  if (v107 == 14)
  {
    uint64_t v123 = *(void *)(a2 + 19768);
    *(void *)(a2 + 13368) = *(void *)(a2 + 13304) * v123;
    uint64_t v124 = *(void *)(a2 + 19776);
    uint64_t v125 = *(void *)(a2 + 13336);
    *(void *)(a2 + 13376) = v125 * v124;
    uint64_t v126 = *(void *)(a2 + 19784);
    *(void *)(a2 + 13384) = v126 * v125;
    *(void *)(a2 + 13392) = *(int *)(a2 + 13312) + v123 * *(int *)(a2 + 13316);
    uint64_t v127 = *(int *)(a2 + 13348);
    uint64_t v128 = *(int *)(a2 + 13344);
    *(void *)(a2 + 13400) = v128 + v124 * v127;
    *(void *)(a2 + 13408) = v128 + v126 * v127;
  }
  uint64_t v129 = a2 + 3424;
  if (v58[1590])
  {
    aj_huffman_encode_init_progressive(v129, 1, 1, 1);
    aj_huffman_encode_init_progressive(a2 + 3698, 1, 0, 1);
    aj_huffman_encode_init_progressive(a2 + 3972, 0, 1, 1);
    aj_huffman_encode_init_progressive(a2 + 4246, 0, 0, 1);
    aj_huffman_encode_init_progressive(a2 + 10664, 1, 0, 0);
    aj_huffman_encode_init_progressive(a2 + 10938, 0, 0, 0);
    aj_huffman_encode_init_lookups(a2 + 3424, (unsigned __int8 *)(a2 + 3440), a2 + 4520, 0);
    aj_huffman_encode_init_lookups(a2 + 3698, (unsigned __int8 *)(a2 + 3714), a2 + 5544, 0);
    aj_huffman_encode_init_lookups(a2 + 3972, (unsigned __int8 *)(a2 + 3988), a2 + 6568, 0);
    aj_huffman_encode_init_lookups(a2 + 4246, (unsigned __int8 *)(a2 + 4262), a2 + 7592, 0);
    aj_huffman_encode_init_lookups(a2 + 10664, (unsigned __int8 *)(a2 + 10680), a2 + 11212, 0);
    BOOL v130 = (unsigned __int8 *)(a2 + 10954);
    uint64_t v131 = a2 + 12236;
    uint64_t v132 = a2 + 10938;
    uint64_t v133 = 0;
  }
  else
  {
    aj_huffman_encode_init_baseline(v129, 1, 1);
    aj_huffman_encode_init_baseline(a2 + 3698, 1, 0);
    aj_huffman_encode_init_baseline(a2 + 3972, 0, 1);
    aj_huffman_encode_init_baseline(a2 + 4246, 0, 0);
    aj_huffman_encode_init_lookups(a2 + 3424, (unsigned __int8 *)(a2 + 3440), a2 + 4520, 0);
    aj_huffman_encode_init_lookups(a2 + 3698, (unsigned __int8 *)(a2 + 3714), a2 + 5544, a2 + 8616);
    aj_huffman_encode_init_lookups(a2 + 3972, (unsigned __int8 *)(a2 + 3988), a2 + 6568, 0);
    BOOL v130 = (unsigned __int8 *)(a2 + 4262);
    uint64_t v131 = a2 + 7592;
    uint64_t v133 = a2 + 9640;
    uint64_t v132 = a2 + 4246;
  }
  aj_huffman_encode_init_lookups(v132, v130, v131, v133);
  uint64_t v138 = 0;
  *(void *)(v154 + 1896) = v108;
  uint64_t v139 = 1832;
  do
  {
    int v140 = (void *)(v154 + v139);
    *int v140 = 0;
    v140[1] = 0;
    if (v108 && v138) {
      *(void *)(v154 + 8 * v138 + 1896) = *(void *)(v154 + 8 * (v138 - 1) + 1896)
    }
                                          + *(void *)(a2 + 8 * (v138 - 1) + 19768);
    *(_DWORD *)(v154 + 4 * v138++ + 2000) = 0;
    v139 += 16;
  }
  while (v138 != 4);
  int v141 = *(_DWORD *)(a5 + 96);
  *(_DWORD *)(v154 + 2024) = v141;
  *(void *)(v154 + 2032) = *(void *)(a5 + 88);
  *(void *)(v154 + 2040) = *(void *)(a5 + 104);
  *(_DWORD *)(v154 + 2048) = v141;
  *(_DWORD *)(v154 + 1824) = 0;
  int v142 = *(_DWORD *)(a2 + 13436);
  *(_DWORD *)(v154 + 1828) = v142;
  *(void *)(v154 + 2016) = 0;
  *(void *)(v154 + 2056) = 0;
  int v143 = *(unsigned __int8 *)(a5 + 122);
  *(_DWORD *)(v154 + 2068) = v143;
  *(_DWORD *)(v154 + 2064) = v143 + 7;
  *(void *)(v154 + 2072) = *(void *)(a5 + 152);
  *(_DWORD *)(v154 + 2080) = *(_DWORD *)(a5 + 160);
  *(void *)(v154 + 2084) = 0;
  *(unsigned char *)(v154 + 2096) = *(unsigned char *)(a5 + 121);
  int v144 = *(_DWORD *)(a5 + 4);
  if (v144)
  {
    uint64_t v145 = v153;
    if ((*(_DWORD *)(a5 + 60) - 1) >= 2)
    {
      if (v144 == 2)
      {
        int v144 = *(_DWORD *)(a2 + 13432);
        if (v144 >= 16)
        {
          int v146 = v144 - 1;
          if (v144 >= 0x40) {
            int v146 = 64;
          }
          if (v146 >= 0x10)
          {
            while (v144 % v146)
            {
              if (v146-- <= 16) {
                goto LABEL_241;
              }
            }
            int v144 = v146;
          }
        }
      }
      else
      {
        if (v144 != 1)
        {
          aj_log_error((uint64_t)"EncodeInit", "Invalid interval units.");
          return 5;
        }
        int v144 = *(_DWORD *)(a2 + 13432);
      }
LABEL_241:
      *(_DWORD *)(v154 + 2056) = v144;
    }
    else
    {
      int v144 = 0;
    }
  }
  else
  {
    uint64_t v145 = v153;
  }
  uint64_t v148 = *v152;
  *(void *)(v154 + 1952) = *v152;
  int v149 = *((_DWORD *)v152 + 2);
  *(_DWORD *)(v154 + 1992) = v149;
  uint64_t v150 = *(void *)(v145 + 8);
  *(void *)(v154 + 1968) = v150;
  *(void *)(v154 + 1960) = *(void *)(v145 + 32);
  *(void *)(v154 + 1928) = 0;
  *(_DWORD *)(v154 + 1948) = v149;
  *(void *)(v154 + 1936) = v148;
  *(_DWORD *)(v154 + 1944) = 0;
  if (!v150)
  {
    aj_log_error((uint64_t)"EncodeInit", "Invalid output callback function.");
    return 5;
  }
  unint64_t v151 = *(unsigned int *)(a5 + 144);
  if (v151 && v144 >= 1 && v151 < v142 * *(_DWORD *)(a2 + 13432) / v144 - 1)
  {
    aj_log_error((uint64_t)"EncodeInit", "Restart marker offset table size does not match number of restart markers");
    return 5;
  }
  init_component((int *)a2);
  if (*(_DWORD *)(a2 + 13360) == 14) {
    return 0;
  }
  uint64_t result = aj_allocate_enc_buffers((unsigned int *)a2, (void *)v154, *v94);
  if (!result) {
    v94[3] = *(void *)(v154 + 1792);
  }
  return result;
}

int *init_component(int *result)
{
  if (*result >= 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v4 = 3503;
    uint64_t v5 = 843;
    uint64_t v6 = result + 1130;
    do
    {
      int v7 = &v1[v3];
      int v8 = v7[4];
      int v9 = &v1[v2];
      v9[3368] = v8;
      int v10 = v7[8];
      v9[3369] = v10;
      v9[3370] = v10 * v8;
      uint64_t v11 = v1[v5 - 4];
      *((void *)v9 + 1686) = &v1[137 * (int)v11 + 856];
      uint64_t v12 = v1[v5];
      *((void *)v9 + 1687) = (char *)&v1[137 * (int)v12 + 924] + 2;
      *((void *)v9 + 1768) = &v6[512 * v11];
      *((void *)v9 + 1769) = &v6[512 * v12 + 256];
      *((void *)v9 + 1770) = &v1[256 * v12 + 2154];
      v9[3371] = 0;
      *(_OWORD *)(v9 + 3494) = 0u;
      uint64_t result = (int *)aj_dct_prescale_qtable((uint64_t)&v1[64 * (uint64_t)v7[12] + 22], (uint64_t)&v1[v4]);
      ++v3;
      v2 += 392;
      v4 += 392;
      ++v5;
    }
    while (v3 < *v1);
  }
  return result;
}

uint64_t aj_encode_reset_session(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1 + 3317;
  int v7 = (char *)a1 + 4245;
  *(_OWORD *)(a2 + 1864) = 0u;
  *(_OWORD *)(a2 + 1880) = 0u;
  *(_OWORD *)(a2 + 1832) = 0u;
  *(_OWORD *)(a2 + 1848) = 0u;
  *(void *)(a1 + 3321) = 0;
  *(_OWORD *)(a1 + 3317) = xmmword_21040FF60;
  *(void *)(a2 + 1928) = 0;
  *(_DWORD *)(a2 + 1944) = 0;
  *(_DWORD *)(a2 + 1948) = *(_DWORD *)(a2 + 1992);
  *(_DWORD *)(a2 + 2048) = *(_DWORD *)(a3 + 96);
  *(void *)(a2 + 2060) = 0x700000000;
  aj_get_qtable_for_quality((uint64_t)(a1 + 22), *(_DWORD *)(a3 + 16), 1, 0);
  aj_get_qtable_for_quality((uint64_t)(a1 + 86), *(_DWORD *)(a3 + 16), 0, 0);
  *((unsigned char *)a1 + 3697) = 0;
  *((unsigned char *)a1 + 3971) = 0;
  *int v7 = 0;
  v7[274] = 0;
  uint64_t v8 = *(void *)(a2 + 1792);
  int v9 = v6[1635];
  if (v9 >= 1)
  {
    int v10 = 0;
    uint64_t v11 = (unsigned int *)*((void *)a1 + 2477);
    do
    {
      *(_OWORD *)(v11 + 17) = xmmword_21040FF80;
      v11[45] = 0;
      v11[49] = 0;
      uint64_t v12 = *((void *)v11 + 14);
      unsigned int v13 = v11[38];
      *((void *)v11 + 11) = 0;
      *((void *)v11 + 12) = v12;
      v11[26] = 0;
      v11[27] = v13;
      uint64_t v14 = *v11;
      if ((int)v14 >= 1)
      {
        unint64_t v15 = 0;
        uint64_t v16 = 8 * v14;
        do
        {
          uint64_t v17 = *(void *)&v11[v15 / 4 + 60];
          if (v17) {
            *(unsigned char *)(v17 + 273) = 0;
          }
          v15 += 8;
        }
        while (v16 != v15);
      }
      ++v10;
      v11 += 76;
    }
    while (v10 != v9);
  }
  init_component(a1);
  *(_DWORD *)(a2 + 1824) = 0;
  *(_DWORD *)(a2 + 1828) = a1[3359];
  if (*a1 >= 1)
  {
    uint64_t v18 = 0;
    int v19 = a1[3340];
    uint64_t v20 = a2 + 1792;
    uint64_t v21 = a1 + 3370;
    do
    {
      *(_DWORD *)(v20 + 4 * v18 + 208) = 0;
      if (v19 != 14)
      {
        *((void *)v21 + 45) = v8;
        *(void *)(v20 + 8 * v18) = v8;
        v8 += (*v21 * a1[3358]) << 6;
      }
      ++v18;
      v21 += 392;
    }
    while (v18 < *a1);
  }
  aj_reset_row_ptrs((unsigned int *)a1, (void *)a2, a2 + 1792);
  return 0;
}

uint64_t progscan_write_callback(const void *a1, int a2, uint64_t a3)
{
  int v7 = *(_DWORD *)(a3 + 176);
  int v6 = *(_DWORD *)(a3 + 180);
  if (v7 - v6 >= a2)
  {
    uint64_t v11 = *(char **)(a3 + 168);
LABEL_13:
    memcpy(&v11[v6], a1, a2);
    uint64_t result = 0;
    *(_DWORD *)(a3 + 180) += a2;
    return result;
  }
  int v8 = 2 * v7;
  if (!v7) {
    int v8 = 0x2000;
  }
  if (v8 <= a2) {
    int v9 = a2;
  }
  else {
    int v9 = v8;
  }
  int v10 = (char *)(**(uint64_t (***)(void, void))(a3 + 160))(v9, *(void *)(*(void *)(a3 + 160) + 16));
  if (v10)
  {
    uint64_t v11 = v10;
    bzero(v10, v9);
    uint64_t v12 = *(const void **)(a3 + 168);
    if (v12)
    {
      memcpy(v11, v12, *(int *)(a3 + 180));
      uint64_t v13 = *(void *)(a3 + 168);
      if (v13) {
        (*(void (**)(uint64_t, void))(*(void *)(a3 + 160) + 8))(v13, *(void *)(*(void *)(a3 + 160) + 16));
      }
    }
    *(void *)(a3 + 168) = v11;
    *(_DWORD *)(a3 + 176) = v9;
    int v6 = *(_DWORD *)(a3 + 180);
    goto LABEL_13;
  }
  return 6;
}

uint64_t aj_istream_get_error_code_eod(uint64_t a1)
{
  if (*(void *)(a1 + 16) && *(int *)(a1 + 32) >= 1)
  {
    aj_log_error((uint64_t)"Istream", "Corrupt marker in bitstream, cannot read more data.");
    return 7;
  }
  else
  {
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

double aj_istream_init_mem(uint64_t a1, uint64_t *a2, char a3, int a4)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(void *)(a1 + 112) = 0;
  int v5 = *((_DWORD *)a2 + 2);
  uint64_t v6 = *a2;
  *(void *)(a1 + 40) = *a2;
  *(void *)(a1 + 8) = v6;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 24) = -9;
  *(_DWORD *)(a1 + 32) = v5;
  *(_DWORD *)(a1 + 36) = v5;
  *(_DWORD *)(a1 + 48) = v5;
  *(_DWORD *)(a1 + 52) = v5;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_DWORD *)(a1 + 56) = a4;
  *(_DWORD *)(a1 + 96) = 0;
  *(unsigned char *)(a1 + 112) = a3;
  return result;
}

uint64_t read_bytes_with_callback(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  if (*(_DWORD *)(a1 + 56) == 2)
  {
    int v5 = 0;
LABEL_11:
    uint64_t result = 0;
    goto LABEL_21;
  }
  int v5 = 0;
  while (1)
  {
    int v9 = *(_DWORD *)(a1 + 52);
    if (v9)
    {
      int v10 = *(_DWORD *)(a1 + 48);
      if (v10 >= v9)
      {
        *(_DWORD *)(a1 + 56) = 2;
        if ((v10 & 0x80000000) == 0) {
          goto LABEL_11;
        }
        goto LABEL_16;
      }
    }
    if (*(_DWORD *)(a1 + 56) == 1) {
      *(_DWORD *)(a1 + 56) = 0;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(a1 + 80))(a2 + v5, (a3 - v5), *(void *)(a1 + 64));
    if ((int)result <= 0) {
      break;
    }
    int v12 = *(_DWORD *)(a1 + 48) + result;
    *(_DWORD *)(a1 + 48) = v12;
    v5 += result;
    if (v5 >= 8)
    {
      if ((v12 & 0x80000000) == 0) {
        goto LABEL_11;
      }
LABEL_16:
      aj_log_error((uint64_t)"Istream", "File is larger than %d bytes, aborting");
      goto LABEL_20;
    }
  }
  if (result == -1)
  {
    uint64_t result = 0;
    int v13 = 2;
    goto LABEL_18;
  }
  if (!result)
  {
    int v13 = 1;
LABEL_18:
    *(_DWORD *)(a1 + 56) = v13;
    goto LABEL_21;
  }
  aj_log_error((uint64_t)"Istream", "File read error");
LABEL_20:
  uint64_t result = 9;
LABEL_21:
  *a4 = v5;
  return result;
}

uint64_t aj_istream_find_next_val(uint64_t a1, int __c)
{
  if (*(void *)(a1 + 104) || *(void *)(a1 + 16)) {
    return 7;
  }
  *(_DWORD *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -9;
  if (*(int *)(a1 + 32) > 1) {
    goto LABEL_10;
  }
  uint64_t v2 = aj_istream_move_forward(a1);
  if (v2) {
    return v2;
  }
  if (*(int *)(a1 + 32) > 1)
  {
LABEL_10:
    uint64_t v6 = (int *)(a1 + 56);
    while (1)
    {
      uint64_t v7 = *(unsigned int *)(a1 + 32);
      if ((int)v7 < 1) {
        break;
      }
      int v8 = *(unsigned __int8 **)(a1 + 8);
      if (*v8 == __c) {
        goto LABEL_28;
      }
      int v9 = memchr(*(void **)(a1 + 8), __c, *(unsigned int *)(a1 + 32));
      uint64_t v10 = (uint64_t)&v8[v7 - 1];
      if (v9) {
        uint64_t v10 = (uint64_t)v9;
      }
      *(void *)(a1 + 8) = v10;
      int v11 = v7 + v8 - v10;
      *(_DWORD *)(a1 + 32) = v11;
      if (v11 <= 7)
      {
        uint64_t v12 = aj_istream_move_forward(a1);
        if (v12)
        {
          int v13 = 1;
          uint64_t v2 = v12;
LABEL_25:
          if (v13 == 1) {
            return v2;
          }
          LODWORD(v7) = *(_DWORD *)(a1 + 32);
          break;
        }
        if (*(int *)(a1 + 32) <= 1)
        {
          if (!*(void *)(a1 + 80) || (int v13 = *v6) != 0) {
            int v13 = 3;
          }
          if (v13) {
            goto LABEL_25;
          }
        }
      }
    }
    if (!v7) {
      goto LABEL_30;
    }
LABEL_28:
    if (**(unsigned __int8 **)(a1 + 8) == __c) {
      return 0;
    }
LABEL_30:
    if (!*(unsigned char *)(a1 + 112)) {
      return 7;
    }
  }
  else
  {
    if (!*(unsigned char *)(a1 + 112)) {
      return 7;
    }
    uint64_t v6 = (int *)(a1 + 56);
  }
  if (*v6 == 1) {
    return 4294967294;
  }
  else {
    return 7;
  }
}

uint64_t aj_istream_read_bytes_le(uint64_t a1, unsigned int *a2, int a3)
{
  int v3 = a3;
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    uint64_t result = aj_istream_move_forward(a1);
    if (result) {
      return result;
    }
    int v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= v3)
  {
    char v8 = 32 - 8 * v3;
    unsigned int v9 = 0;
    if (v3)
    {
      uint64_t v10 = *(void *)(a1 + 8) + 1;
      int v11 = v6 - 1;
      do
      {
        *(_DWORD *)(a1 + 32) = v11;
        *(void *)(a1 + 8) = v10;
        HIDWORD(v12) = *(unsigned __int8 *)(v10 - 1);
        LODWORD(v12) = v9;
        unsigned int v9 = v12 >> 8;
        ++v10;
        --v11;
        --v3;
      }
      while (v3);
    }
    uint64_t result = 0;
    *a2 = v9 >> v8;
  }
  else
  {
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t aj_istream_peek_byte(uint64_t a1, unsigned char *a2)
{
  if (*(int *)(a1 + 32) > 0) {
    goto LABEL_2;
  }
  uint64_t result = aj_istream_move_forward(a1);
  if (!result)
  {
    if (*(int *)(a1 + 32) > 0)
    {
LABEL_2:
      uint64_t result = 0;
      *a2 = **(unsigned char **)(a1 + 8);
      return result;
    }
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t aj_istream_peek_bytes(uint64_t a1, void *__dst, int a3)
{
  int v6 = *(_DWORD *)(a1 + 32);
  if (v6 < a3)
  {
    uint64_t result = aj_istream_move_forward(a1);
    if (result) {
      return result;
    }
    int v6 = *(_DWORD *)(a1 + 32);
  }
  if (v6 >= a3)
  {
    memcpy(__dst, *(const void **)(a1 + 8), a3);
    return 0;
  }
  else
  {
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t aj_istream_fill_buf(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4 <= 7)
  {
    uint64_t result = aj_istream_move_forward(a1);
    if (result) {
      return result;
    }
    int v4 = *(_DWORD *)(a1 + 32);
    if (v4 <= 7) {
      goto LABEL_24;
    }
  }
  int v5 = 0;
  int v6 = 0;
  uint64_t v7 = *(unsigned __int8 **)(a1 + 16);
  while (1)
  {
    if (v7)
    {
      int v13 = *(_DWORD *)(a1 + 24);
      if (v13 < 0) {
        goto LABEL_15;
      }
      goto LABEL_13;
    }
    int v8 = v4 - 1;
    *(_DWORD *)(a1 + 32) = v4 - 1;
    unsigned int v9 = *(unsigned __int8 **)(a1 + 8);
    uint64_t v10 = v9 + 1;
    *(void *)(a1 + 8) = v9 + 1;
    int v11 = *v9;
    if (v11 == 255) {
      break;
    }
LABEL_7:
    int v5 = v11 | (v5 << 8);
    v6 += 8;
    int v13 = *(_DWORD *)(a1 + 24) + v6;
    int v4 = v8;
    if (v13 >= 16)
    {
      uint64_t v10 = 0;
      goto LABEL_9;
    }
  }
  int v12 = v4 - 2;
  *(_DWORD *)(a1 + 32) = v12;
  *(void *)(a1 + 8) = v9 + 2;
  if (!v9[1])
  {
    int v11 = 255;
    int v8 = v12;
    goto LABEL_7;
  }
  if (v9[1] != 255)
  {
    *(void *)(a1 + 16) = v10;
    *(_DWORD *)(a1 + 28) = 1;
    int v13 = *(_DWORD *)(a1 + 24);
    if (v6)
    {
      v13 += v6;
LABEL_9:
      *(_DWORD *)a1 |= v5 << (23 - v13);
      *(_DWORD *)(a1 + 24) = v13;
    }
    uint64_t v7 = v10;
    if (v13 < 0)
    {
LABEL_15:
      if (v13 >= a2) {
        return 0;
      }
      return aj_istream_get_error_code_eod(a1);
    }
LABEL_13:
    if (!v7) {
      *(_DWORD *)(a1 + 28) = 0;
    }
    goto LABEL_15;
  }
  *(void *)(a1 + 8) = v10;
  *(_DWORD *)(a1 + 32) = v8;
  if (v6)
  {
    int v15 = *(_DWORD *)(a1 + 24) + v6;
    *(_DWORD *)a1 |= v5 << (23 - v15);
    *(_DWORD *)(a1 + 24) = v15;
  }
LABEL_24:
  return secure_fill_buf(a1, a2);
}

uint64_t secure_fill_buf(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 32) <= 7)
  {
    uint64_t result = aj_istream_move_forward(a1);
    if (result) {
      return result;
    }
  }
  int v5 = *(_DWORD *)(a1 + 24);
  if (v5 > 15) {
    goto LABEL_23;
  }
  int v6 = 0;
  int v7 = 0;
  do
  {
    int v8 = *(_DWORD *)(a1 + 32);
    if (v8 < 1 || *(void *)(a1 + 16)) {
      break;
    }
    unsigned int v9 = *(unsigned __int8 **)(a1 + 8);
    *(_DWORD *)(a1 + 32) = v8 - 1;
    uint64_t v10 = v9 + 1;
    *(void *)(a1 + 8) = v9 + 1;
    int v11 = *v9;
    if (v11 == 255)
    {
      if (v8 == 1)
      {
        *(void *)(a1 + 8) = v9;
        *(_DWORD *)(a1 + 32) = 1;
        break;
      }
      int v12 = *v10;
      if (v12 == 255)
      {
        if (v8 <= 8)
        {
          uint64_t result = aj_istream_move_forward(a1);
          if (result) {
            return result;
          }
          int v5 = *(_DWORD *)(a1 + 24);
        }
        continue;
      }
      *(_DWORD *)(a1 + 32) = v8 - 2;
      *(void *)(a1 + 8) = v9 + 2;
      if (v12)
      {
        *(void *)(a1 + 16) = v10;
        break;
      }
      int v11 = 255;
    }
    int v7 = v11 | (v7 << 8);
    v6 += 8;
  }
  while (v5 + v6 < 16);
  if (v6 >= 1)
  {
    v5 += v6;
    *(_DWORD *)a1 |= v7 << (23 - v5);
    *(_DWORD *)(a1 + 24) = v5;
  }
  if (v5 < 0)
  {
LABEL_24:
    LODWORD(v13) = 1;
  }
  else
  {
LABEL_23:
    uint64_t v13 = *(void *)(a1 + 16);
    if (v13) {
      goto LABEL_24;
    }
  }
  *(_DWORD *)(a1 + 28) = v13;
  if (v5 >= a2) {
    return 0;
  }
  return aj_istream_get_error_code_eod(a1);
}

uint64_t aj_istream_memcpy(uint64_t a1, char *__dst, int a3, _DWORD *a4)
{
  if (*(int *)(a1 + 32) > 0 || (uint64_t result = aj_istream_move_forward(a1), !result))
  {
    int v8 = a3;
    while (v8 >= 1)
    {
      int v9 = *(_DWORD *)(a1 + 32);
      if (v9 <= 0)
      {
        *a4 = a3 - v8;
        goto LABEL_15;
      }
      if (v9 >= v8) {
        size_t v10 = v8;
      }
      else {
        size_t v10 = v9;
      }
      memcpy(__dst, *(const void **)(a1 + 8), v10);
      __dst += v10;
      v8 -= v10;
      uint64_t result = aj_istream_move_to_position(a1, (*(_DWORD *)(a1 + 48) + v10 - *(_DWORD *)(a1 + 32)));
      if (result) {
        return result;
      }
    }
    *a4 = a3 - v8;
    if (!v8) {
      return 0;
    }
LABEL_15:
    uint64_t result = 7;
    if (*(unsigned char *)(a1 + 112))
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        return 4294967294;
      }
      else {
        return 7;
      }
    }
  }
  return result;
}

uint64_t aj_istream_state_save(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  int v3 = *(_DWORD *)(a1 + 24);
  if (v2) {
    BOOL v4 = v3 == -9;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    return 1;
  }
  if (v3 <= 15)
  {
    uint64_t result = secure_fill_buf(a1, -8);
    if (result) {
      return result;
    }
    uint64_t v2 = *(void *)(a1 + 16);
    int v3 = *(_DWORD *)(a1 + 24);
  }
  uint64_t result = 0;
  BOOL v4 = v2 == 0;
  int v8 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 96) - 2;
  if (v4) {
    int v8 = *(_DWORD *)(a1 + 48) - *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 96);
  }
  *(unsigned char *)(a2 + 16) = v3 + 9;
  int v9 = *(_DWORD *)a1;
  *(_DWORD *)a2 = v8;
  *(_DWORD *)(a2 + 4) = v9;
  *(unsigned char *)(a2 + 17) = 1;
  return result;
}

uint64_t aj_istream_state_restore(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = 0;
  }
  int v4 = *(unsigned __int8 *)(a2 + 16);
  uint64_t result = aj_istream_move_to_position(a1, (*(_DWORD *)a2 - *(_DWORD *)(a1 + 96)));
  if (!result)
  {
    *(_DWORD *)(a1 + 24) = v4 - 9;
    *(_DWORD *)a1 = *(_DWORD *)(a2 + 4);
    return secure_fill_buf(a1, -9);
  }
  return result;
}

uint64_t aj_istream_state_serialized_size()
{
  return 17;
}

uint64_t aj_istream_state_serialize(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  *(_DWORD *)uint64_t result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  do
  {
    *(_WORD *)(result + 8 + v2) = *(_WORD *)(a2 + 8 + v2);
    v2 += 2;
  }
  while (v2 != 8);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 16);
  return result;
}

uint64_t aj_istream_state_deserialize(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  *(_DWORD *)uint64_t result = *(_DWORD *)a2;
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 4);
  do
  {
    *(_WORD *)(result + 8 + v2) = *(_WORD *)(a2 + 8 + v2);
    v2 += 2;
  }
  while (v2 != 8);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 16);
  *(unsigned char *)(result + 17) = 1;
  return result;
}

void *aj_icol_row_420_to_bgra_12bit(void *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 1, 1);
}

void *aj_icol_row_420_rgb_12bit_generic(void *result, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, char a9)
{
  v41[2] = *MEMORY[0x263EF8340];
  v41[0] = a4;
  v41[1] = a5;
  v40[0] = *result;
  if (a6 == 1) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = result[1];
  }
  v40[1] = v9;
  if (a7 >= 1)
  {
    int v10 = 0;
    int v11 = *a3;
    int v12 = *a2;
    uint64_t result = v41;
    int v13 = a7;
    do
    {
      if (v13 <= 1) {
        int v14 = 1;
      }
      else {
        int v14 = 2;
      }
      int v16 = *v12++;
      int v15 = v16;
      int v18 = *v11++;
      int v17 = v18;
      if (a6 >= 1)
      {
        uint64_t v19 = 0;
        int v20 = v15 - 2048;
        int v21 = v17 - 2048;
        int v22 = 227 * (v15 - 2048);
        int v23 = -44 * v20 - 91 * (v17 - 2048);
        int v24 = 179 * v21;
        do
        {
          if (v10 < a7)
          {
            uint64_t v25 = (unsigned __int16 *)v40[v19];
            int v26 = (_WORD *)v41[v19];
            int v27 = v14;
            do
            {
              int v28 = *v25++;
              int v29 = v22 + (v28 << 7);
              int v30 = v23 + (v28 << 7);
              int v31 = v24 + (v28 << 7);
              unsigned int v32 = (v29 + 64) >> 7;
              unsigned int v33 = v31 + 64;
              unsigned int v34 = (v31 + 64) >> 7;
              if (v31 <= -65) {
                __int16 v35 = 0;
              }
              else {
                __int16 v35 = 4095;
              }
              if (v33 >= 0x80000) {
                LOWORD(v34) = v35;
              }
              if (v30 <= -65) {
                __int16 v36 = 0;
              }
              else {
                __int16 v36 = 4095;
              }
              if ((v30 + 64) >= 0x80000) {
                __int16 v37 = v36;
              }
              else {
                __int16 v37 = (v30 + 64) >> 7;
              }
              if (v29 <= -65) {
                __int16 v38 = 0;
              }
              else {
                __int16 v38 = 4095;
              }
              if ((v29 + 64) >= 0x80000) {
                LOWORD(v32) = v38;
              }
              if (a8) {
                __int16 v39 = v32;
              }
              else {
                __int16 v39 = v34;
              }
              _WORD *v26 = v39;
              if (!a8) {
                LOWORD(v34) = v32;
              }
              v26[1] = v37;
              v26[2] = v34;
              if (a9)
              {
                v26[3] = 4095;
                v26 += 4;
              }
              else
              {
                v26 += 3;
              }
              --v27;
            }
            while (v27);
            v40[v19] = v25;
            v41[v19] = v26;
          }
          ++v19;
        }
        while (v19 != a6);
      }
      v10 += 2;
      v13 -= 2;
    }
    while (v10 < a7);
  }
  return result;
}

void *aj_icol_row_420_to_rgba_12bit(void *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 0, 1);
}

unsigned __int16 **aj_icol_row_444_to_bgra_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 1, 1);
}

unsigned __int16 **aj_icol_row_444_rgb_12bit_generic(unsigned __int16 **result, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, int a5, int a6, int a7)
{
  if (a5 >= 1)
  {
    int v7 = *a3;
    int v8 = *a2;
    uint64_t v9 = *result;
    do
    {
      int v11 = *v9++;
      int v10 = v11;
      int v12 = *v8++;
      int v13 = v12 - 2048;
      int v14 = *v7++;
      int v15 = 227 * v13 + (v10 << 7);
      int v16 = -44 * v13 + (v10 << 7) - 91 * (v14 - 2048);
      int v17 = 179 * (v14 - 2048) + (v10 << 7);
      unsigned int v18 = v15 + 64;
      unsigned int v19 = (v15 + 64) >> 7;
      unsigned int v20 = v16 + 64;
      unsigned int v21 = (v16 + 64) >> 7;
      unsigned int v22 = v17 + 64;
      unsigned int v23 = (v17 + 64) >> 7;
      if (v17 <= -65) {
        __int16 v24 = 0;
      }
      else {
        __int16 v24 = 4095;
      }
      if (v22 < 0x80000) {
        __int16 v24 = v23;
      }
      if (v16 <= -65) {
        __int16 v25 = 0;
      }
      else {
        __int16 v25 = 4095;
      }
      if (v20 < 0x80000) {
        __int16 v25 = v21;
      }
      if (v15 <= -65) {
        unsigned int v26 = 0;
      }
      else {
        unsigned int v26 = 4095;
      }
      if (v18 >= 0x80000) {
        uint64_t result = (unsigned __int16 **)v26;
      }
      else {
        uint64_t result = (unsigned __int16 **)v19;
      }
      if (a6) {
        __int16 v27 = (__int16)result;
      }
      else {
        __int16 v27 = v24;
      }
      *a4 = v27;
      if (!a6) {
        __int16 v24 = (__int16)result;
      }
      a4[1] = v25;
      a4[2] = v24;
      if (a7)
      {
        a4[3] = 4095;
        a4 += 4;
      }
      else
      {
        a4 += 3;
      }
      --a5;
    }
    while (a5);
  }
  return result;
}

unsigned __int16 **aj_icol_row_444_to_rgba_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 0, 1);
}

void *aj_icol_row_420_to_bgr_12bit(void *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 1, 0);
}

void *aj_icol_row_420_to_rgb_12bit(void *a1, unsigned __int16 **a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_420_rgb_12bit_generic(a1, a2, a3, a4, a5, a6, a7, 0, 0);
}

unsigned __int16 **aj_icol_row_444_to_bgr_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 1, 0);
}

unsigned __int16 **aj_icol_row_444_to_rgb_12bit(unsigned __int16 **a1, unsigned __int16 **a2, unsigned __int16 **a3, __int16 *a4, uint64_t a5, uint64_t a6, int a7)
{
  return aj_icol_row_444_rgb_12bit_generic(a1, a2, a3, a4, a7, 0, 0);
}

unint64_t aj_icol_row_444_to_yuyv(unint64_t result, char **a2, char **a3, unsigned char *a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7 = *(char **)result;
  int v8 = *a2;
  uint64_t v9 = *a3;
  if (a7 < 2)
  {
    if ((a7 & 1) == 0) {
      return result;
    }
LABEL_7:
    char v17 = *v7;
    char v18 = *v8;
    char v19 = *v9;
    *a4 = v17;
    a4[1] = v18;
    a4[2] = v17;
    a4[3] = v19;
    return result;
  }
  uint64_t v10 = 0;
  do
  {
    char v11 = v7[v10 + 1];
    int v12 = v8[v10];
    int v13 = v8[v10 + 1];
    uint64_t result = v9[v10];
    int v14 = v9[v10 + 1];
    *a4 = v7[v10];
    a4[1] = (v13 + v12) >> 1;
    a4[2] = v11;
    unsigned int v15 = (v14 + result) >> 1;
    int v16 = a4 + 4;
    a4[3] = v15;
    v10 += 2;
    a4 += 4;
  }
  while ((int)v10 < a7 - 1);
  v9 += v10;
  v8 += v10;
  v7 += v10;
  a4 = v16;
  if (a7) {
    goto LABEL_7;
  }
  return result;
}

char **aj_icol_row_420_to_yuyv(char **result, char **a2, char **a3, unsigned char *a4, unsigned char *a5, int a6, int a7)
{
  int v7 = *result;
  int v8 = *a2;
  uint64_t v9 = *a3;
  if (a6 == 1)
  {
    if (a7 >= 2)
    {
      uint64_t v10 = 0;
      do
      {
        char v11 = v7[v10 + 1];
        char v13 = *v8++;
        char v12 = v13;
        char v14 = *v9++;
        *a4 = v7[v10];
        a4[1] = v12;
        a4[2] = v11;
        unsigned int v15 = a4 + 4;
        a4[3] = v14;
        v10 += 2;
        a4 += 4;
      }
      while ((int)v10 < a7 - 1);
      v7 += v10;
      a4 = v15;
    }
    if (a7)
    {
      char v16 = *v7;
      char v17 = *v8;
      char v18 = *v9;
      *a4 = v16;
      a4[1] = v17;
      a4[2] = v16;
      a4[3] = v18;
    }
  }
  else
  {
    char v19 = result[1];
    if (a7 >= 2)
    {
      uint64_t v20 = 0;
      do
      {
        char v21 = v7[v20 + 1];
        char v22 = v19[v20];
        char v23 = v19[v20 + 1];
        unsigned int v24 = *v8++;
        uint64_t result = (char **)v24;
        LOBYTE(v24) = *v9++;
        *a4 = v7[v20];
        a4[1] = (_BYTE)result;
        a4[2] = v21;
        __int16 v25 = a4 + 4;
        a4[3] = v24;
        *a5 = v22;
        a5[1] = (_BYTE)result;
        unsigned int v26 = a5 + 4;
        v20 += 2;
        a5[2] = v23;
        a5[3] = v24;
        a5 += 4;
        a4 += 4;
      }
      while ((int)v20 < a7 - 1);
      v19 += v20;
      v7 += v20;
      a4 = v25;
      a5 = v26;
    }
    if (a7)
    {
      char v27 = *v7;
      char v28 = *v19;
      char v29 = *v8;
      char v30 = *v9;
      *a4 = v27;
      a4[1] = v29;
      a4[2] = v27;
      a4[3] = v30;
      *a5 = v28;
      a5[1] = v29;
      a5[2] = v28;
      a5[3] = v30;
    }
  }
  return result;
}

char **aj_icol_row_444_to_yuv(char **result, char **a2, char **a3, unsigned char *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a7)
  {
    int v7 = *a3;
    int v8 = *a2;
    uint64_t v9 = *result;
    do
    {
      char v10 = *v9++;
      *a4 = v10;
      char v11 = *v8++;
      a4[1] = v11;
      char v12 = *v7++;
      a4[2] = v12;
      a4 += 3;
      --a7;
    }
    while (a7);
  }
  return result;
}

uint64_t aj_icol_row_420_to_yuv(uint64_t result, char **a2, char **a3, unsigned char *a4, unsigned char *a5, int a6, int a7)
{
  int v7 = *(unsigned char **)result;
  int v8 = *a2;
  uint64_t v9 = *a3;
  if (a6 == 1)
  {
    if (a7 >= 2)
    {
      uint64_t v10 = 0;
      do
      {
        char v12 = *v8++;
        char v11 = v12;
        char v13 = *v9++;
        *a4 = v7[v10];
        a4[1] = v11;
        a4[2] = v13;
        a4[3] = v7[v10 + 1];
        a4[4] = v11;
        char v14 = a4 + 6;
        a4[5] = v13;
        v10 += 2;
        a4 += 6;
      }
      while ((int)v10 < a7 - 1);
      v7 += v10;
      a4 = v14;
    }
    if (a7)
    {
      *a4 = *v7;
      a4[1] = *v8;
      a4[2] = *v9;
    }
  }
  else
  {
    unsigned int v15 = *(unsigned char **)(result + 8);
    if (a7 >= 2)
    {
      uint64_t v16 = 0;
      do
      {
        char v18 = *v8++;
        char v17 = v18;
        char v19 = *v9++;
        *a4 = v7[v16];
        a4[1] = v17;
        a4[2] = v19;
        a4[3] = v7[v16 + 1];
        a4[4] = v17;
        uint64_t v20 = a4 + 6;
        a4[5] = v19;
        uint64_t result = v15[v16];
        *a5 = result;
        a5[1] = v17;
        a5[2] = v19;
        a5[3] = v15[v16 + 1];
        a5[4] = v17;
        char v21 = a5 + 6;
        a5[5] = v19;
        v16 += 2;
        a4 += 6;
        a5 += 6;
      }
      while ((int)v16 < a7 - 1);
      v7 += v16;
      v15 += v16;
      a5 = v21;
      a4 = v20;
    }
    if (a7)
    {
      char v22 = *v8;
      char v23 = *v9;
      *a4 = *v7;
      a4[1] = v22;
      a4[2] = v23;
      *a5 = *v15;
      a5[1] = v22;
      a5[2] = v23;
    }
  }
  return result;
}

void *aj_icol_row_444_to_biplanar(void *__src, int a2, char *a3, int a4, char *a5, int a6, void *__dst, int a8, unsigned char *a9, int a10)
{
  int v12 = a10;
  uint64_t result = memcpy(__dst, __src, a10);
  if (a10 >= 1)
  {
    do
    {
      char v15 = *a3++;
      *a9 = v15;
      char v16 = *a5++;
      a9[1] = v16;
      a9 += 2;
      --v12;
    }
    while (v12);
  }
  return result;
}

void *aj_icol_row_422_to_biplanar(void *__src, int a2, char *a3, int a4, char *a5, int a6, char *__dst, int a8, unsigned char *a9, int a10, int a11, unsigned __int8 a12)
{
  int v15 = a12;
  char v16 = a9;
  uint64_t result = memcpy(__dst, __src, a10);
  if (a10) {
    __dst[a10] = __dst[a10 - 1];
  }
  if (a11 != 1 || a12 != 0)
  {
    int v19 = a10 - 1 + a12;
    if (v19 <= a12)
    {
      char v23 = a9;
      if ((a10 & 1) == 0) {
        return result;
      }
    }
    else
    {
      do
      {
        unint64_t v20 = (unint64_t)v15 >> a11;
        unint64_t v21 = (unint64_t)(v15 + 1) >> a11;
        unsigned char *v16 = (a3[v21] + a3[v20]) >> 1;
        unsigned int v22 = (a5[v21] + a5[v20]) >> 1;
        char v23 = v16 + 2;
        v16[1] = v22;
        v15 += 2;
        v16 += 2;
      }
      while (v15 < v19);
      if ((a10 & 1) == 0) {
        return result;
      }
    }
    int v27 = (a10 - 1) >> a11;
    unsigned char *v23 = a3[v27];
    v23[1] = a5[v27];
    return result;
  }
  if (a10 >= 1)
  {
    unsigned int v24 = (a10 + 1) >> 1;
    do
    {
      char v25 = *a3++;
      unsigned char *v16 = v25;
      char v26 = *a5++;
      v16[1] = v26;
      v16 += 2;
      --v24;
    }
    while (v24);
  }
  return result;
}

void *aj_icol_row_420_to_biplanar(void *__src, const void *a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned __int8 *a6, void *__dst, void *a8, unsigned char *a9, int a10, int a11, unsigned __int8 a12)
{
  int v17 = a12;
  char v18 = a9;
  memcpy(__dst, __src, a10);
  uint64_t result = memcpy(a8, a2, a10);
  if (a10)
  {
    *((unsigned char *)__dst + a10) = *((unsigned char *)__dst + a10 - 1);
    *((unsigned char *)a8 + a10) = *((unsigned char *)a8 + a10 - 1);
  }
  BOOL v21 = a11 != 1 || a12 != 0;
  if (a3 == a4 && a5 == a6)
  {
    if (v21)
    {
      int v22 = a10 - 1 + a12;
      if (v22 <= a12)
      {
        char v26 = a9;
        if ((a10 & 1) == 0) {
          return result;
        }
      }
      else
      {
        do
        {
          unint64_t v23 = (unint64_t)v17 >> a11;
          unint64_t v24 = (unint64_t)(v17 + 1) >> a11;
          unsigned char *v18 = (a3[v23] + a3[v24] + 1) >> 1;
          unsigned int v25 = (a5[v23] + a5[v24] + 1) >> 1;
          char v26 = v18 + 2;
          v18[1] = v25;
          v17 += 2;
          v18 += 2;
        }
        while (v17 < v22);
        if ((a10 & 1) == 0) {
          return result;
        }
      }
      signed int v42 = (a10 - 1) >> a11;
      unsigned char *v26 = a3[v42];
      LOBYTE(v42) = a5[v42];
LABEL_33:
      v26[1] = v42;
      return result;
    }
    if (a10 >= 1)
    {
      unsigned int v38 = (a10 + 1) >> 1;
      do
      {
        char v39 = *a3++;
        unsigned char *v18 = v39;
        char v40 = *a5++;
        v18[1] = v40;
        v18 += 2;
        --v38;
      }
      while (v38);
    }
  }
  else
  {
    if (v21)
    {
      int v27 = a10 - 1 + a12;
      if (v27 <= a12)
      {
        char v26 = a9;
        if ((a10 & 1) == 0) {
          return result;
        }
      }
      else
      {
        do
        {
          unint64_t v28 = (unint64_t)v17 >> a11;
          unint64_t v29 = (unint64_t)(v17 + 1) >> a11;
          unsigned char *v18 = (a3[v28] + a4[v28] + a3[v29] + a4[v29] + 2) >> 2;
          unsigned int v30 = (a5[v28] + a6[v28] + a5[v29] + a6[v29] + 2) >> 2;
          char v26 = v18 + 2;
          v18[1] = v30;
          v17 += 2;
          v18 += 2;
        }
        while (v17 < v27);
        if ((a10 & 1) == 0) {
          return result;
        }
      }
      int v41 = (a10 - 1) >> a11;
      unsigned char *v26 = (a4[v41] + a3[v41]) >> 1;
      signed int v42 = (a6[v41] + a5[v41]) >> 1;
      goto LABEL_33;
    }
    if (a10 >= 1)
    {
      unsigned int v31 = (a10 + 1) >> 1;
      do
      {
        int v33 = *a3++;
        int v32 = v33;
        int v34 = *a4++;
        unsigned char *v18 = (v34 + v32) >> 1;
        int v36 = *a5++;
        int v35 = v36;
        int v37 = *a6++;
        v18[1] = (v37 + v35) >> 1;
        v18 += 2;
        --v31;
      }
      while (v31);
    }
  }
  return result;
}

void *aj_icol_row_420_to_biplanar_12bit(void *__src, const void *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, char *__dst, char *a8, _WORD *a9, int a10, int a11, unsigned __int8 a12)
{
  unsigned int v17 = a12;
  memcpy(__dst, __src, 2 * a10);
  uint64_t result = memcpy(a8, a2, 2 * a10);
  if (a10)
  {
    uint64_t v20 = 2 * a10 - 2;
    *(_WORD *)&__dst[2 * a10] = *(_WORD *)&__dst[v20];
    *(_WORD *)&a8[2 * a10] = *(_WORD *)&a8[v20];
  }
  BOOL v22 = a11 != 1 || a12 != 0;
  if (a3 == a4 && a5 == a6)
  {
    if (v22)
    {
      int v23 = a10 - 1 + a12;
      if (v23 > a12)
      {
        do
        {
          unsigned int v24 = (v17 + 1) >> a11;
          *a9 = (a3[v17 >> a11] + a3[v24] + 1) >> 1;
          unsigned int v25 = a9 + 2;
          a9[1] = (a5[v17 >> a11] + a5[v24] + 1) >> 1;
          v17 += 2;
          a9 += 2;
        }
        while ((int)v17 < v23);
        a9 = v25;
      }
      if (a10)
      {
        signed int v26 = (a10 - 1) >> a11;
        *a9 = a3[v26];
        LOWORD(v26) = a5[v26];
LABEL_23:
        a9[1] = v26;
      }
    }
    else if (a10 >= 1)
    {
      unsigned int v38 = (a10 + 1) >> 1;
      do
      {
        __int16 v39 = *a3++;
        *a9 = v39;
        __int16 v40 = *a5++;
        a9[1] = v40;
        a9 += 2;
        --v38;
      }
      while (v38);
    }
  }
  else if (v22)
  {
    int v27 = a10 - 1 + a12;
    if (v27 > a12)
    {
      do
      {
        unsigned int v28 = (v17 + 1) >> a11;
        *a9 = (a3[v17 >> a11] + a4[v17 >> a11] + a3[v28] + a4[v28] + 2) >> 2;
        unint64_t v29 = a9 + 2;
        a9[1] = (a5[v17 >> a11] + a6[v17 >> a11] + a5[v28] + a6[v28] + 2) >> 2;
        v17 += 2;
        a9 += 2;
      }
      while ((int)v17 < v27);
      a9 = v29;
    }
    if (a10)
    {
      int v30 = (a10 - 1) >> a11;
      *a9 = (a4[v30] + a3[v30]) >> 1;
      signed int v26 = (a6[v30] + a5[v30]) >> 1;
      goto LABEL_23;
    }
  }
  else if (a10 >= 1)
  {
    unsigned int v31 = (a10 + 1) >> 1;
    do
    {
      int v33 = *a3++;
      int v32 = v33;
      int v34 = *a4++;
      *a9 = (v34 + v32) >> 1;
      int v36 = *a5++;
      int v35 = v36;
      int v37 = *a6++;
      a9[1] = (v37 + v35) >> 1;
      a9 += 2;
      --v31;
    }
    while (v31);
  }
  return result;
}

void *aj_icol_row_440_to_biplanar(void *__src, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *__dst, void *a8, unsigned char *a9, int a10, char a11)
{
  memcpy(__dst, __src, a10);
  uint64_t result = memcpy(a8, a2, a10);
  if (a10 >= 1)
  {
    for (unsigned int i = 0; i != a10; ++i)
    {
      unint64_t v20 = (unint64_t)i >> a11;
      *a9 = (*(unsigned __int8 *)(a4 + v20) + *(unsigned __int8 *)(a3 + v20)) >> 1;
      a9[1] = (*(unsigned __int8 *)(a6 + v20) + *(unsigned __int8 *)(a5 + v20)) >> 1;
      a9 += 2;
    }
  }
  return result;
}

const void **aj_icol_row_all_to_gray(const void **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a6 >= 1)
  {
    int v7 = result;
    size_t v8 = a7;
    uint64_t v9 = (void **)v14;
    uint64_t v10 = a6;
    do
    {
      int v12 = *v9++;
      char v11 = v12;
      char v13 = *v7++;
      uint64_t result = (const void **)memcpy(v11, v13, v8);
      --v10;
    }
    while (v10);
  }
  return result;
}

const void **aj_icol_row_all_to_gray_12bit(const void **result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a6 >= 1)
  {
    int v7 = result;
    size_t v8 = 2 * a7;
    uint64_t v9 = (void **)v14;
    uint64_t v10 = a6;
    do
    {
      int v12 = *v9++;
      char v11 = v12;
      char v13 = *v7++;
      uint64_t result = (const void **)memcpy(v11, v13, v8);
      --v10;
    }
    while (v10);
  }
  return result;
}

void *aj_icol_row_gray_to_444biplanar(void *__src, int a2, int a3, int a4, int a5, int a6, void *__dst, int a8, void *a9, size_t __n)
{
  memcpy(__dst, __src, (int)__n);
  return memset(a9, 128, 2 * (int)__n);
}

void *aj_icol_row_gray_to_422biplanar(void *__src, int a2, int a3, int a4, int a5, int a6, char *__dst, int a8, void *a9, int a10)
{
  memcpy(__dst, __src, a10);
  if (a10) {
    __dst[a10] = __dst[a10 - 1];
  }
  return memset(a9, 128, (a10 & 1) + a10);
}

void *aj_icol_row_gray_to_420biplanar(void *__src, const void *a2, int a3, int a4, int a5, int a6, char *__dst, char *a8, void *a9, int a10)
{
  memcpy(__dst, __src, a10);
  memcpy(a8, a2, a10);
  if (a10)
  {
    __dst[a10] = __dst[a10 - 1];
    a8[a10] = a8[a10 - 1];
  }
  return memset(a9, 128, (a10 & 1) + a10);
}

void aj_icol_row_gray_to_420biplanar_12bit(void *__src, const void *a2, int a3, int a4, int a5, int a6, void *__dst, void *a8, void *a9, int a10)
{
  memcpy(__dst, __src, 2 * a10);
  memcpy(a8, a2, 2 * a10);
  if (a10)
  {
    *((_WORD *)__dst + a10) = *((_WORD *)__dst + a10 - 1);
    *((_WORD *)a8 + a10) = *((_WORD *)a8 + a10 - 1);
  }
  int v13 = (a10 & 1) + a10;
  BOOL v14 = __OFSUB__(v13, 1);
  int v15 = v13 - 1;
  if (v15 < 0 == v14)
  {
    memset_pattern16(a9, &unk_210410410, 2 * v15 + 2);
  }
}

void *aj_icol_row_gray_to_440biplanar(void *__src, const void *a2, int a3, int a4, int a5, int a6, void *__dst, void *a8, void *a9, size_t __n)
{
  memcpy(__dst, __src, (int)__n);
  memcpy(a8, a2, (int)__n);
  return memset(a9, 128, 2 * (int)__n);
}

uint64_t aj_icol_row_gray_to_yuyv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v12[2] = *MEMORY[0x263EF8340];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      size_t v8 = *(unsigned char **)(result + 8 * i);
      uint64_t v9 = (unsigned char *)v12[i];
      if (a7 >= 2)
      {
        uint64_t v10 = 0;
        do
        {
          *uint64_t v9 = v8[v10];
          v9[1] = 0x80;
          void v9[2] = v8[v10 + 1];
          char v11 = v9 + 4;
          v9[3] = 0x80;
          v10 += 2;
          v9 += 4;
        }
        while ((int)v10 < a7 - 1);
        v8 += v10;
        uint64_t v9 = v11;
      }
      if (a7)
      {
        *uint64_t v9 = *v8;
        v9[1] = 0x80;
        void v9[2] = *v8;
        v9[3] = 0x80;
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_yuv(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v12[2] = *MEMORY[0x263EF8340];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        uint64_t v8 = v12[i];
        uint64_t v9 = *(char **)(result + 8 * i);
        int v10 = a7;
        do
        {
          char v11 = *v9++;
          *(unsigned char *)uint64_t v8 = v11;
          *(_WORD *)(v8 + 1) = -32640;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb565(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  return aj_icol_row_gray_to_color_generic(a1, a4, a5, a6, a7, 2, 1);
}

uint64_t aj_icol_row_gray_to_color_generic(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7)
{
  v19[2] = *MEMORY[0x263EF8340];
  v19[0] = a2;
  v19[1] = a3;
  if (a4 >= 1)
  {
    for (uint64_t i = 0; i != a4; ++i)
    {
      uint64_t v8 = *(__int16 **)(result + 8 * i);
      uint64_t v9 = (int16x4_t *)v19[i];
      switch(a6)
      {
        case 2:
          if (a5 >= 1)
          {
            int v15 = a5;
            do
            {
              unsigned int v16 = *(unsigned __int8 *)v8;
              uint64_t v8 = (__int16 *)((char *)v8 + 1);
              v9->i8[0] = (v16 >> 3) & 0x1F | (32 * ((v16 >> 2) & 7));
              v9->i8[1] = (unsigned __int16)((8 * v16) | ((unsigned __int16)(v16 >> 3) << 11)) >> 8;
              uint64_t v9 = (int16x4_t *)((char *)v9 + 2);
              --v15;
            }
            while (v15);
          }
          break;
        case 4:
          if (a7 == 2)
          {
            if (a5 >= 1)
            {
              int v12 = a5;
              do
              {
                v13.i16[1] = -4096;
                v13.i32[1] = -268374016;
                v13.i16[0] = *v8++;
                int16x4_t v14 = vzip1_s16(v13, v13);
                v14.i16[2] = v13.i16[0];
                *v9++ = v14;
                --v12;
              }
              while (v12);
            }
          }
          else
          {
            int v17 = a5;
            if (a5 >= 1)
            {
              do
              {
                __int8 v18 = *(unsigned char *)v8;
                uint64_t v8 = (__int16 *)((char *)v8 + 1);
                v9->i8[0] = v18;
                v9->i8[1] = v18;
                v9->i8[2] = v18;
                v9->i8[3] = -1;
                uint64_t v9 = (int16x4_t *)((char *)v9 + 4);
                --v17;
              }
              while (v17);
            }
          }
          break;
        case 3:
          int v10 = a5;
          if (a5 >= 1)
          {
            do
            {
              __int8 v11 = *(unsigned char *)v8;
              uint64_t v8 = (__int16 *)((char *)v8 + 1);
              v9->i8[0] = v11;
              v9->i8[1] = v11;
              v9->i8[2] = v11;
              uint64_t v9 = (int16x4_t *)((char *)v9 + 3);
              --v10;
            }
            while (v10);
          }
          break;
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v12[2] = *MEMORY[0x263EF8340];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        uint64_t v8 = (unsigned char *)v12[i];
        uint64_t v9 = *(char **)(result + 8 * i);
        int v10 = a7;
        do
        {
          char v11 = *v9++;
          *uint64_t v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgb_12bit(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v12[2] = *MEMORY[0x263EF8340];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        uint64_t v8 = (unsigned char *)v12[i];
        uint64_t v9 = *(char **)(result + 8 * i);
        int v10 = a7;
        do
        {
          char v11 = *v9++;
          *uint64_t v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8 += 3;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgba(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v12[2] = *MEMORY[0x263EF8340];
  v12[0] = a4;
  v12[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        uint64_t v8 = (unsigned char *)v12[i];
        uint64_t v9 = *(char **)(result + 8 * i);
        int v10 = a7;
        do
        {
          char v11 = *v9++;
          *uint64_t v8 = v11;
          v8[1] = v11;
          v8[2] = v11;
          v8[3] = -1;
          v8 += 4;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

uint64_t aj_icol_row_gray_to_rgba_12bit(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  v13[2] = *MEMORY[0x263EF8340];
  v13[0] = a4;
  v13[1] = a5;
  if (a6 >= 1)
  {
    for (uint64_t i = 0; i != a6; ++i)
    {
      if (a7 >= 1)
      {
        uint64_t v8 = (int16x4_t *)v13[i];
        uint64_t v9 = *(__int16 **)(result + 8 * i);
        int v10 = a7;
        do
        {
          v11.i16[1] = -4096;
          v11.i32[1] = -268374016;
          v11.i16[0] = *v9++;
          int16x4_t v12 = vzip1_s16(v11, v11);
          v12.i16[2] = v11.i16[0];
          *v8++ = v12;
          --v10;
        }
        while (v10);
      }
    }
  }
  return result;
}

void aj_icol_mcurow_default(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4)
  {
    uint64_t v8 = (void *)(a3 + 568);
    int v9 = **(_DWORD **)a2;
    BOOL v10 = v9 == 3;
    if (v9 == 3) {
      int16x4_t v11 = (unsigned char **)(a3 + 696);
    }
    else {
      int16x4_t v11 = 0;
    }
    unsigned int v31 = v11;
    if (v10) {
      int16x4_t v12 = (char **)(a3 + 824);
    }
    else {
      int16x4_t v12 = 0;
    }
    int v32 = v12;
    if (*(_DWORD *)(a2 + 6464) == 3 && !*(_DWORD *)(a2 + 6884))
    {
      if (*(unsigned char *)(a3 + 1080))
      {
        if (*(_DWORD *)(a2 + 6804)) {
          buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6776));
        }
        else {
          buffer = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        }
        invcol_wrapper(a2, v8, v31++, v32++, (uint64_t)buffer, 0, 1, *(unsigned int *)(a1 + 48), *(unsigned char *)(a3 + 1081));
        unsigned int v20 = *(_DWORD *)(a2 + 6804);
        if (v20)
        {
          aj_row_translate(v20, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(void *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)buffer);
        }
        ++*(_DWORD *)(a3 + 36);
        int v19 = *(unsigned __int8 *)(a3 + 1080);
      }
      else
      {
        int v19 = 0;
      }
      unsigned int v29 = a4 - 1;
      if (a4 - 1 > v19)
      {
        int v30 = (unsigned int *)(a3 + 152);
        unint64_t v21 = (unint64_t)v19 >> 1;
        BOOL v22 = (void *)(a3 + 8 * v19 + 568);
        do
        {
          if (*(_DWORD *)(a2 + 6804))
          {
            int v23 = aj_rowbuffer_get_buffer(v30, *(void *)(a2 + 6776));
            unsigned int v24 = aj_rowbuffer_get_buffer(v30, *(void *)(a2 + 6776));
          }
          else
          {
            uint64_t v25 = *(void *)(a2 + 96);
            int v23 = (char *)(*(void *)(a2 + 64) + v25 * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
            unsigned int v24 = &v23[v25];
          }
          invcol_wrapper(a2, v22, &v31[v21 & 0x7FFFFFFF], &v32[v21 & 0x7FFFFFFF], (uint64_t)v23, (uint64_t)v24, 2, *(unsigned int *)(a1 + 48), *(unsigned char *)(a3 + 1081));
          unsigned int v26 = *(_DWORD *)(a2 + 6804);
          if (v26)
          {
            aj_row_translate(v26, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v23, *(void *)(a2 + 64));
            aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v23);
            aj_row_translate(*(_DWORD *)(a2 + 6804), *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v24, *(void *)(a2 + 64));
            aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v24);
          }
          *(_DWORD *)(a3 + 36) += 2;
          LODWORD(v21) = v21 + 1;
          v22 += 2;
          v19 += 2;
        }
        while ((int)v29 > v19);
      }
      if (v19 == v29)
      {
        if (*(_DWORD *)(a2 + 6804)) {
          int v27 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6776));
        }
        else {
          int v27 = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        }
        invcol_wrapper(a2, &v8[v29], &v31[v29 >> 1], &v32[v29 >> 1], (uint64_t)v27, 0, 1, *(unsigned int *)(a1 + 48), *(unsigned char *)(a3 + 1081));
        unsigned int v28 = *(_DWORD *)(a2 + 6804);
        if (v28)
        {
          aj_row_translate(v28, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v27, *(void *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v27);
        }
        ++*(_DWORD *)(a3 + 36);
      }
    }
    else if (a4 >= 1)
    {
      uint64_t v13 = 0;
      int v14 = *(int *)(a1 + 44) >> 1;
      do
      {
        if (*(_DWORD *)(a2 + 6804)) {
          unsigned int v16 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6776));
        }
        else {
          unsigned int v16 = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
        }
        (*(void (**)(void *, unsigned char **, char **, char *, void, uint64_t, void))(a2 + 6912))(v8, &v31[v13 >> v14], &v32[v13 >> v14], v16, 0, 1, *(unsigned int *)(a1 + 48));
        unsigned int v17 = *(_DWORD *)(a2 + 6804);
        if (v17)
        {
          aj_row_translate(v17, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v16, *(void *)(a2 + 64));
          aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v16);
        }
        ++*(_DWORD *)(a3 + 36);
        ++v13;
        ++v8;
      }
      while (a4 != v13);
    }
  }
}

uint64_t invcol_wrapper(uint64_t a1, void *a2, unsigned char **a3, char **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int16x4_t v12 = a2;
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (a9)
  {
    uint64_t v56 = a5;
    uint64_t v57 = a6;
    int v13 = *(_DWORD *)(a1 + 6580);
    if (v13 == 2)
    {
      BOOL v21 = 0;
    }
    else
    {
      if (v13 == 6)
      {
        if ((int)a7 >= 1)
        {
          uint64_t v14 = a7;
          int v15 = &v56;
          unsigned int v16 = (unsigned char **)a2;
          do
          {
            unsigned int v17 = (unsigned char *)*v15;
            unsigned char *v17 = **v16;
            v17[1] = **a3;
            char v18 = **a4;
            *v15++ = (uint64_t)(v17 + 3);
            v17[2] = v18;
            ++*v16++;
            --v14;
          }
          while (v14);
        }
        ++*a3;
        ++*a4;
LABEL_54:
        uint64_t result = (*(uint64_t (**)(void *, unsigned char **, char **, uint64_t, uint64_t, uint64_t, void))(a1 + 6912))(v12, a3, a4, v56, v57, a7, (a8 - 1));
        --*a3;
        --*a4;
        if ((int)a7 >= 1)
        {
          uint64_t v55 = a7;
          do
          {
            --*v12++;
            --v55;
          }
          while (v55);
        }
        return result;
      }
      BOOL v21 = v13 != 4;
    }
    int v22 = **a3;
    int v23 = **a4;
    ++*a3;
    ++*a4;
    if ((int)a7 >= 1)
    {
      int v24 = v23 - 128;
      int v25 = v22 - 128;
      int v26 = 227 * (v22 - 128);
      int v27 = -44 * v25 - 91 * v24;
      int v28 = 179 * v24;
      uint64_t v29 = a7;
      int v30 = &v56;
      unsigned int v31 = a2;
      do
      {
        int v32 = *(unsigned __int8 *)*v31;
        int v33 = v26 + (v32 << 7);
        int v34 = v27 + (v32 << 7);
        int v35 = v28 + (v32 << 7);
        int v36 = *(_DWORD *)(a1 + 28);
        int v37 = (unsigned char *)*v30;
        unsigned int v38 = v33 + 64;
        unsigned int v39 = (v33 + 64) >> 7;
        unsigned int v40 = v34 + 64;
        unsigned int v41 = (v34 + 64) >> 7;
        unsigned int v42 = v35 + 64;
        unsigned int v43 = (v35 + 64) >> 7;
        if (v35 <= -65) {
          unsigned int v44 = 0;
        }
        else {
          unsigned int v44 = 255;
        }
        if (v42 < 0x8000) {
          unsigned int v44 = v43;
        }
        if (v34 <= -65) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = 255;
        }
        if (v40 < 0x8000) {
          unsigned int v45 = v41;
        }
        if (v33 <= -65) {
          unsigned int v46 = 0;
        }
        else {
          unsigned int v46 = 255;
        }
        if (v38 < 0x8000) {
          unsigned int v46 = v39;
        }
        switch(v36)
        {
          case 4:
            if (v21) {
              char v54 = v46;
            }
            else {
              char v54 = v44;
            }
            if (v21) {
              LOBYTE(v46) = v44;
            }
            *int v37 = v46;
            v37[1] = v45;
            v37[2] = v54;
            v37[3] = -1;
            v37 += 4;
            break;
          case 3:
            *int v37 = v44;
            v37[1] = v45;
            v37[2] = v46;
            v37 += 3;
            break;
          case 2:
            if (v44 >= 0xFC) {
              unsigned int v47 = 255;
            }
            else {
              unsigned int v47 = v44 + 4;
            }
            unsigned int v48 = v45 + 2;
            if (v45 >= 0xFE) {
              unsigned int v48 = 255;
            }
            unsigned int v49 = v47 >> 3;
            if (v46 >= 0xFC) {
              unsigned int v50 = 255;
            }
            else {
              unsigned int v50 = v46 + 4;
            }
            unsigned int v51 = v50 >> 3;
            int v52 = 32 * (v48 >> 2);
            if (v21) {
              __int16 v53 = v52 | ((_WORD)v51 << 11) | v49;
            }
            else {
              __int16 v53 = v52 | ((_WORD)v49 << 11) | v51;
            }
            *(_WORD *)int v37 = v53;
            v37 += 2;
            break;
        }
        *v30++ = (uint64_t)v37;
        ++*v31++;
        --v29;
      }
      while (v29);
    }
    goto LABEL_54;
  }
  int v19 = *(uint64_t (**)(void *, unsigned char **, char **, uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 6912);
  return v19(a2, a3, a4, a5, a6, a7, a8);
}

void aj_icol_mcurow_cmyk(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  if (a4 > 0)
  {
    uint64_t v6 = 0;
    int64x2_t v7 = vdupq_n_s64(a3);
    unsigned int v50 = (unsigned char *)(a2 + 6936);
    unsigned int v51 = (unsigned int *)(a3 + 152);
    int64x2_t v48 = vaddq_s64(v7, (int64x2_t)xmmword_2104103F0);
    int64x2_t v47 = vaddq_s64(v7, (int64x2_t)xmmword_210410400);
    uint64_t v49 = a4;
    int v8 = *(_DWORD *)(a1 + 48);
    do
    {
      if (*(_DWORD *)(a2 + 6804)) {
        buffer = aj_rowbuffer_get_buffer(v51, *(void *)(a2 + 6776));
      }
      else {
        buffer = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * *(int *)(a3 + 36) + *(int *)(a2 + 6600));
      }
      if (*v50)
      {
        if (v8)
        {
          BOOL v10 = *(char **)(v48.i64[1] + 8 * v6);
          int16x4_t v11 = *(unsigned __int8 **)(v48.i64[0] + 8 * v6);
          int16x4_t v12 = *(unsigned __int8 **)(v47.i64[1] + 8 * v6);
          int v13 = v8;
          uint64_t v14 = buffer;
          int v15 = *(unsigned __int8 **)(v47.i64[0] + 8 * v6);
          do
          {
            int v17 = *v15++;
            int v16 = v17;
            int v18 = *v12++;
            int v19 = v18 - 128;
            int v20 = *v11++;
            int v21 = 179 * (v20 - 128) + (v16 << 7);
            int v22 = -44 * v19 + (v16 << 7) - 91 * (v20 - 128);
            int v23 = 227 * v19 + (v16 << 7);
            unsigned int v24 = v21 + 64;
            unsigned int v25 = (v21 + 64) >> 7;
            unsigned int v26 = v22 + 64;
            unsigned int v27 = (v22 + 64) >> 7;
            unsigned int v28 = v23 + 64;
            unsigned int v29 = (v23 + 64) >> 7;
            if (v21 <= -65) {
              char v30 = 0;
            }
            else {
              char v30 = -1;
            }
            if (v24 >= 0x8000) {
              char v31 = v30;
            }
            else {
              char v31 = v25;
            }
            if (v22 <= -65) {
              char v32 = 0;
            }
            else {
              char v32 = -1;
            }
            if (v26 < 0x8000) {
              char v32 = v27;
            }
            if (v23 <= -65) {
              char v33 = 0;
            }
            else {
              char v33 = -1;
            }
            if (v28 < 0x8000) {
              char v33 = v29;
            }
            *uint64_t v14 = ~v31;
            v14[1] = ~v32;
            v14[2] = ~v33;
            char v34 = *v10++;
            void v14[3] = v34;
            v14 += 4;
            --v13;
          }
          while (v13);
        }
      }
      else if (v8)
      {
        int v35 = *(char **)(v48.i64[1] + 8 * v6);
        int v36 = *(char **)(v48.i64[0] + 8 * v6);
        int v37 = *(char **)(v47.i64[1] + 8 * v6);
        unsigned int v38 = buffer;
        int v39 = v8;
        unsigned int v40 = *(char **)(v47.i64[0] + 8 * v6);
        do
        {
          char v41 = *v40++;
          *unsigned int v38 = v41;
          char v42 = *v37++;
          v38[1] = v42;
          char v43 = *v36++;
          v38[2] = v43;
          char v44 = *v35++;
          v38[3] = v44;
          v38 += 4;
          --v39;
        }
        while (v39);
      }
      unsigned int v45 = *(_DWORD *)(a2 + 6804);
      int v46 = *(_DWORD *)(a3 + 36);
      if (v45)
      {
        aj_row_translate(v45, *(_DWORD *)(a2 + 28), *(_DWORD *)(a2 + 6492), *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), *(_DWORD *)(a2 + 6492) - *(_DWORD *)(a2 + 6596), *(_DWORD *)(a2 + 6496), v46, buffer, *(void *)(a2 + 64));
        aj_rowbuffer_return_buffer(v51, (unint64_t)buffer);
        int v46 = *(_DWORD *)(a3 + 36);
      }
      *(_DWORD *)(a3 + 36) = v46 + 1;
      ++v6;
    }
    while (v6 != v49);
  }
}

void aj_icol_mcurow_semiplanar444(_DWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v8 = a1[10];
  int v7 = a1[11];
  unsigned int v29 = a1[12];
  unsigned int v9 = *(unsigned __int8 *)(a3 + 1080);
  if (*(_DWORD *)(a2 + 6804))
  {
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6776));
    int16x4_t v11 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6792));
  }
  else
  {
    buffer = 0;
    int16x4_t v11 = 0;
  }
  if (a4 >= 1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v27 = v7 >> 1;
    int v28 = v8 >> 1;
    uint64_t v14 = (void *)(a3 + 568);
    uint64_t v15 = a4;
    do
    {
      if (**(_DWORD **)a2 == 3)
      {
        uint64_t v13 = *(void *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 52) << 7) + 8 * (v9 >> v27));
        uint64_t v12 = *(void *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 56) << 7) + 8 * (v9 >> v27));
      }
      if (!*(_DWORD *)(a2 + 6804))
      {
        uint64_t v16 = *(int *)(a3 + 36);
        uint64_t v17 = *(int *)(a2 + 6592);
        buffer = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * v16 + v17);
        int16x4_t v11 = (char *)(*(void *)(a2 + 72) + *(void *)(a2 + 104) * v16 + v17);
      }
      LOBYTE(v26) = *(unsigned char *)(a3 + 1081);
      (*(void (**)(void, void, uint64_t, void, uint64_t, void, char *, void, char *, unint64_t, int))(a2 + 6920))(*v14, 0, v13, 0, v12, 0, buffer, 0, v11, __PAIR64__(v28, v29), v26);
      unsigned int v18 = *(_DWORD *)(a2 + 6804);
      if (v18)
      {
        uint64_t v30 = v12;
        uint64_t v19 = v13;
        unint64_t v20 = *(void *)(a2 + 72);
        int v21 = *(_DWORD *)(a2 + 6492);
        int v22 = *(_DWORD *)(a2 + 6596);
        int v23 = v21 - v22;
        aj_row_translate(v18, 1, v21, *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), v21 - v22, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(void *)(a2 + 64));
        unint64_t v25 = v20;
        uint64_t v13 = v19;
        uint64_t v12 = v30;
        aj_row_translate(*(_DWORD *)(a2 + 6804), 2, *(_DWORD *)(a2 + 6492), *(void *)(a2 + 136), *(_DWORD *)(a2 + 6592), v23, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v11, v25);
      }
      ++*(_DWORD *)(a3 + 36);
      ++v9;
      ++v14;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)(a2 + 6804))
  {
    unsigned int v24 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v24, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v24, (unint64_t)v11);
  }
}

void aj_icol_mcurow_semiplanar422(_DWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  int v8 = a1[10];
  int v7 = a1[11];
  unsigned int v29 = a1[12];
  unsigned int v9 = *(unsigned __int8 *)(a3 + 1080);
  if (*(_DWORD *)(a2 + 6804))
  {
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6776));
    int16x4_t v11 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), *(void *)(a2 + 6792));
  }
  else
  {
    buffer = 0;
    int16x4_t v11 = 0;
  }
  if (a4 >= 1)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v27 = v7 >> 1;
    int v28 = v8 >> 1;
    uint64_t v14 = (void *)(a3 + 568);
    uint64_t v15 = a4;
    do
    {
      if (**(_DWORD **)a2 == 3)
      {
        uint64_t v13 = *(void *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 52) << 7) + 8 * (v9 >> v27));
        uint64_t v12 = *(void *)(a3 + 568 + ((uint64_t)*(int *)(a2 + 56) << 7) + 8 * (v9 >> v27));
      }
      if (!*(_DWORD *)(a2 + 6804))
      {
        uint64_t v16 = *(int *)(a3 + 36);
        uint64_t v17 = *(int *)(a2 + 6592);
        buffer = (char *)(*(void *)(a2 + 64) + *(void *)(a2 + 96) * v16 + v17);
        int16x4_t v11 = (char *)(*(void *)(a2 + 72) + *(void *)(a2 + 104) * v16 + v17);
      }
      LOBYTE(v26) = *(unsigned char *)(a3 + 1081);
      (*(void (**)(void, void, uint64_t, void, uint64_t, void, char *, void, char *, unint64_t, int))(a2 + 6920))(*v14, 0, v13, 0, v12, 0, buffer, 0, v11, __PAIR64__(v28, v29), v26);
      unsigned int v18 = *(_DWORD *)(a2 + 6804);
      if (v18)
      {
        uint64_t v30 = v12;
        uint64_t v19 = v13;
        unint64_t v20 = *(void *)(a2 + 72);
        int v21 = *(_DWORD *)(a2 + 6492);
        int v22 = ((v21 - *(_DWORD *)(a2 + 6596)) & 1) + v21 - *(_DWORD *)(a2 + 6596);
        aj_row_translate(v18, 1, v21, *(void *)(a2 + 128), *(_DWORD *)(a2 + 6592), v22, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), buffer, *(void *)(a2 + 64));
        if (v22 >= 0) {
          int v23 = v22;
        }
        else {
          int v23 = v22 + 1;
        }
        unint64_t v25 = v20;
        uint64_t v13 = v19;
        uint64_t v12 = v30;
        aj_row_translate(*(_DWORD *)(a2 + 6804), 2, *(_DWORD *)(a2 + 6492) / 2, *(void *)(a2 + 136), *(_DWORD *)(a2 + 6592) / 2, v23 >> 1, *(_DWORD *)(a2 + 6496), *(_DWORD *)(a3 + 36), v11, v25);
      }
      ++*(_DWORD *)(a3 + 36);
      ++v9;
      ++v14;
      --v15;
    }
    while (v15);
  }
  if (*(_DWORD *)(a2 + 6804))
  {
    unsigned int v24 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v24, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v24, (unint64_t)v11);
  }
}

void aj_icol_mcurow_semiplanar4X0(_DWORD *a1, int **a2, uint64_t a3, signed int a4, int a5)
{
  int v44 = *((_DWORD *)a2 + 11);
  char v52 = v44 == 2;
  if (*(unsigned char *)(a3 + 1083)) {
    int v7 = a5 + a4 >= a1[16];
  }
  else {
    int v7 = 0;
  }
  int v8 = a1[10];
  int v9 = a1[11];
  unint64_t v48 = (unint64_t)a2[8];
  unint64_t v49 = (unint64_t)a2[9];
  unsigned int v51 = a1[12];
  uint64_t v46 = *((int *)a2 + 14);
  uint64_t v47 = *((int *)a2 + 13);
  int v10 = *(_DWORD *)(a3 + 32);
  if ((v10 & 1) != 0 && *(_DWORD *)(a3 + 36) == v10)
  {
    *(_DWORD *)(a3 + 36) = v10 + 1;
    unsigned int v11 = 1;
  }
  else
  {
    unsigned int v11 = 0;
  }
  int v12 = *(unsigned __int8 *)(a3 + 1080);
  if (*((_DWORD *)a2 + 1701))
  {
    signed int v13 = a4;
    buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[847]);
    uint64_t v14 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[847]);
    uint64_t v15 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), (uint64_t)a2[849]);
    a4 = v13;
    uint64_t v16 = v15;
  }
  else
  {
    buffer = 0;
    uint64_t v14 = 0;
    uint64_t v16 = 0;
  }
  int v50 = v8 >> 1;
  if ((int)v11 < a4)
  {
    HIDWORD(v43) = v7;
    uint64_t v54 = 0;
    unint64_t v17 = 0;
    int v45 = v9 >> 1;
    unsigned int v18 = (unsigned int *)(a3 + 152);
    unsigned int v19 = v11 + v12;
    unint64_t v20 = (unint64_t *)(a3 + 8 * v11 + 568);
    unint64_t v21 = a4 - (unint64_t)v11;
    int v22 = 1;
    do
    {
      int v23 = **a2;
      if (v23 == 3)
      {
        unint64_t v17 = *(void *)(a3 + 568 + (v47 << 7) + 8 * (v19 >> v45));
        uint64_t v54 = *(void *)(a3 + 568 + (v46 << 7) + 8 * (v19 >> v45));
      }
      unint64_t v24 = *v20;
      if (*(_DWORD *)(a3 + 1480))
      {
        if (!*((_DWORD *)a2 + 1701))
        {
          uint64_t v25 = *(int *)(a3 + 36);
          int v26 = a2[12];
          uint64_t v27 = *((int *)a2 + 1648);
          buffer = (char *)(v48 + (void)v26 * v25 + v27);
          uint64_t v14 = (char *)v26 + (void)buffer;
          uint64_t v16 = (char *)(v49 + (void)a2[13] * ((uint64_t)(int)(v25 + ((int)v25 < 0)) >> 1) + ((2 * (int)v27) >> v52));
        }
        LOBYTE(v43) = *(unsigned char *)(a3 + 1081);
        ((void (*)(void, unint64_t, void, unint64_t, void, uint64_t, char *, char *, char *, unint64_t, uint64_t))a2[865])(*(void *)(a3 + 1456), v24, *(void *)(a3 + 1464), v17, *(void *)(a3 + 1472), v54, buffer, v14, v16, __PAIR64__(v50, v51), v43);
        if (v22)
        {
          aj_rowbuffer_return_buffer(v18, *(void *)(a3 + 1456));
          if (**a2 == 3)
          {
            aj_rowbuffer_return_buffer(v18, *(void *)(a3 + 1464));
            aj_rowbuffer_return_buffer(v18, *(void *)(a3 + 1472));
          }
        }
        *(_DWORD *)(a3 + 1480) = 0;
        unsigned int v28 = *((_DWORD *)a2 + 1701);
        if (v28)
        {
          int v29 = *((_DWORD *)a2 + 1623);
          int v30 = v29 - *((_DWORD *)a2 + 1649);
          int v31 = v30 & 1;
          if (v44 != 2) {
            int v31 = 0;
          }
          int v53 = v22;
          int v32 = v31 + v30;
          aj_row_translate(v28, 1, v29, (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v31 + v30, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36), buffer, v48);
          aj_row_translate(*((_DWORD *)a2 + 1701), 1, *((_DWORD *)a2 + 1623), (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v32, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36) + 1, v14, v48);
          int v33 = v32 >> v52;
          int v22 = v53;
          aj_row_translate(*((_DWORD *)a2 + 1701), 2, *((int *)a2 + 1623) >> v52, (uint64_t)a2[17], *((int *)a2 + 1648) >> v52, v33, *((_DWORD *)a2 + 1624) / 2, *(_DWORD *)(a3 + 36) / 2, v16, v49);
        }
        *(_DWORD *)(a3 + 36) += 2;
      }
      else
      {
        *(_DWORD *)(a3 + 1480) = 1;
        *(void *)(a3 + 1456) = v24;
        if (!*(unsigned char *)(a3 + 1082) || *((unsigned char *)a2 + 6577) || *((unsigned char *)a2 + 6576))
        {
          aj_rowbuffer_lock_buffer(v18, v24);
          if (**a2 == 3)
          {
            *(void *)(a3 + 1464) = v17;
            *(void *)(a3 + 1472) = v54;
            aj_rowbuffer_lock_buffer(v18, v17);
            aj_rowbuffer_lock_buffer(v18, *(void *)(a3 + 1472));
          }
          int v22 = 1;
        }
        else
        {
          int v22 = 0;
          if (v23 == 3)
          {
            *(void *)(a3 + 1464) = v17;
            *(void *)(a3 + 1472) = v54;
          }
        }
      }
      ++v19;
      ++v20;
      --v21;
    }
    while (v21);
    int v7 = HIDWORD(v43);
    if (!v22 && *(_DWORD *)(a3 + 1480)) {
      *(_DWORD *)(a3 + 1480) = 0;
    }
  }
  if (v7 && *(_DWORD *)(a3 + 1480))
  {
    if (!*((_DWORD *)a2 + 1701))
    {
      uint64_t v34 = *(int *)(a3 + 36);
      int v35 = a2[12];
      uint64_t v36 = *((int *)a2 + 1648);
      buffer = (char *)a2[8] + (void)v35 * v34 + v36;
      uint64_t v14 = (char *)v35 + (void)buffer;
      uint64_t v16 = (char *)a2[9] + (void)a2[13] * ((uint64_t)(int)(v34 + ((int)v34 < 0)) >> 1) + ((2 * (int)v36) >> v52);
    }
    LOBYTE(v43) = *(unsigned char *)(a3 + 1081);
    ((void (*)(void, void, void, void, void, void, char *, char *, char *, unint64_t, uint64_t))a2[865])(*(void *)(a3 + 1456), *(void *)(a3 + 1456), *(void *)(a3 + 1464), *(void *)(a3 + 1464), *(void *)(a3 + 1472), *(void *)(a3 + 1472), buffer, v14, v16, __PAIR64__(v50, v51), v43);
    aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(void *)(a3 + 1456));
    if (**a2 == 3)
    {
      aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(void *)(a3 + 1464));
      aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), *(void *)(a3 + 1472));
    }
    unsigned int v37 = *((_DWORD *)a2 + 1701);
    if (v37)
    {
      int v38 = *((_DWORD *)a2 + 1623);
      int v39 = v38 - *((_DWORD *)a2 + 1649);
      int v40 = v39 & 1;
      if (v44 != 2) {
        int v40 = 0;
      }
      int v41 = v40 + v39;
      aj_row_translate(v37, 1, v38, (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v40 + v39, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36), buffer, v48);
      aj_row_translate(*((_DWORD *)a2 + 1701), 1, *((_DWORD *)a2 + 1623), (uint64_t)a2[16], *((_DWORD *)a2 + 1648), v41, *((_DWORD *)a2 + 1624), *(_DWORD *)(a3 + 36) + 1, v14, v48);
      aj_row_translate(*((_DWORD *)a2 + 1701), 2, *((int *)a2 + 1623) >> v52, (uint64_t)a2[17], *((int *)a2 + 1648) >> v52, v41 >> v52, *((_DWORD *)a2 + 1624) / 2, *(_DWORD *)(a3 + 36) / 2, v16, v49);
    }
    *(_DWORD *)(a3 + 36) += 2;
    *(_DWORD *)(a3 + 1480) = 0;
  }
  if (*((_DWORD *)a2 + 1701))
  {
    char v42 = (unsigned int *)(a3 + 152);
    aj_rowbuffer_return_buffer(v42, (unint64_t)buffer);
    aj_rowbuffer_return_buffer(v42, (unint64_t)v14);
    aj_rowbuffer_return_buffer(v42, (unint64_t)v16);
  }
}

uint64_t aj_icol_max_rows_out(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    return (*(uint64_t (**)(void))(v4 + 8))();
  }
  else {
    return (a4 + *(_DWORD *)(a2 + 48) - 1);
  }
}

uint64_t (**aj_select_adaptive_coder(uint64_t (**result)(int a1)))(int a1)
{
  result[3] = (uint64_t (*)(int))arithmetic_context_init_0;
  result[4] = (uint64_t (*)(int))arithmetic_context_init_prob_0;
  result[10] = (uint64_t (*)(int))arithmetic_decode_close_0;
  result[8] = (uint64_t (*)(int))arithmetic_decode_static_data_0;
  result[2] = (uint64_t (*)(int))arithmetic_decode_init_0;
  result[6] = (uint64_t (*)(int))arithmetic_decode_symbols_0;
  result[9] = (uint64_t (*)(int))arithmetic_encode_close_0;
  result[7] = (uint64_t (*)(int))arithmetic_encode_static_data_0;
  result[1] = (uint64_t (*)(int))arithmetic_encode_init_0;
  result[5] = (uint64_t (*)(int))arithmetic_encode_symbols_0;
  *uint64_t result = arithmetic_prob_table_size_0;
  return result;
}

int *arithmetic_context_init_0(uint64_t a1, int *a2, int a3, int a4)
{
  return init_cum_prob_0(a2, a3, 0, a4);
}

int *arithmetic_context_init_prob_0(uint64_t a1, int *a2, int a3, int a4, unsigned __int8 *a5)
{
  return init_cum_prob_0(a2, a3, a5, a4);
}

uint64_t arithmetic_decode_close_0()
{
  return 0;
}

uint64_t arithmetic_decode_static_data_0(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  char v3 = a3;
  if (a3 - 33 <= 0xFFFFFFDF)
  {
    aj_log_error(0, "Illegal number of data bits: %d", a3);
    return 7;
  }
  *a2 = 0;
  if (a3 < 0x11) {
    goto LABEL_9;
  }
  unsigned int v7 = HIWORD(*(_DWORD *)a1);
  if (*(_DWORD *)(a1 + 8) / v7 >= 0xFFFF) {
    int v8 = 0xFFFF;
  }
  else {
    int v8 = *(_DWORD *)(a1 + 8) / v7;
  }
  uint64_t result = arithmetic_decode_0((int *)a1, *(void *)(a1 + 24), v8, v8 + 1, v7);
  if (!result)
  {
    v3 -= 16;
    *a2 = v8 << v3;
LABEL_9:
    unsigned int v9 = *(_DWORD *)a1 >> v3;
    if (*(_DWORD *)(a1 + 8) / v9 >= ~(-1 << v3)) {
      int v10 = ~(-1 << v3);
    }
    else {
      int v10 = *(_DWORD *)(a1 + 8) / v9;
    }
    uint64_t result = arithmetic_decode_0((int *)a1, *(void *)(a1 + 24), v10, v10 + 1, v9);
    if (!result) {
      *a2 |= v10;
    }
  }
  return result;
}

uint64_t arithmetic_decode_init_0(uint64_t a1)
{
  unsigned int v2 = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  unsigned int v6 = 0;
  *(void *)a1 = 0xFFFFFFFFLL;
  int v4 = 4;
  do
  {
    *(_DWORD *)(a1 + 8) = v2 << 8;
    uint64_t result = aj_istream_read_bytes_le(v3, &v6, 1);
    if (result) {
      break;
    }
    unsigned int v2 = *(_DWORD *)(a1 + 8) | v6;
    *(_DWORD *)(a1 + 8) = v2;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t arithmetic_decode_symbols_0(uint64_t a1, int **a2, unsigned char *a3, int a4)
{
  if (a4)
  {
    for (int i = a4; i; --i)
    {
      uint64_t v7 = 0;
      int v8 = *a2;
      int v10 = *a2 + 1;
      int v9 = **a2;
      uint64_t v11 = v10[v9 + 2];
      uint64_t v12 = v9 + 1;
      unsigned int v13 = v10[v12];
      unsigned int v14 = v13 - 1;
      unsigned int v15 = *(_DWORD *)a1 / v13;
      if (v13 - 1 >= *(_DWORD *)(a1 + 8) / v15) {
        unsigned int v14 = *(_DWORD *)(a1 + 8) / v15;
      }
      do
        unsigned int v16 = v8[v9 + v7--];
      while (v16 > v14);
      char v17 = ~(_BYTE)v7;
      if (~v7 >= (int)v11)
      {
        int v25 = v10[v9 + (v7 | 0xFFFFFF00)];
        uint64_t result = arithmetic_decode_0((int *)a1, *(void *)(a1 + 24), v25, v25 + 1, v15);
        if (result) {
          return result;
        }
        unsigned int v26 = -1;
        do
          ++v26;
        while (v26 <= 0x1F && 1 << v26 < v9);
        unsigned int v27 = *(_DWORD *)a1 >> v26;
        int v28 = *(_DWORD *)(a1 + 8) / v27 >= ~(-1 << v26) ? ~(-1 << v26) : *(_DWORD *)(a1 + 8) / v27;
        uint64_t result = arithmetic_decode_0((int *)a1, *(void *)(a1 + 24), v28, v28 + 1, v27);
        if (result) {
          return result;
        }
        int v35 = i;
        *a3 = v28;
        int v29 = v28;
        if (v28 >= v9)
        {
          aj_log_error(0, "Symbol is too large. %d > %d", v28, v9);
          return 7;
        }
        cum_to_probs((uint64_t)v10, v9);
        int v30 = v28 + 1;
        if ((int)v11 < v29)
        {
          int v31 = v11 + 1;
          int v32 = &v8[v11 + 3];
          do
          {
            ++*v32++;
            ++v10[v12];
            ++v31;
          }
          while (v30 != v31);
        }
        int v33 = v29 + 2;
        if (v30 < v9)
        {
          ++v10[v33];
          ++v10[v12];
        }
        ++v10[v30];
        ++v10[v12];
        probs_to_cum(v10, v9);
        if (v9 == v33) {
          int v34 = v9;
        }
        else {
          int v34 = v29 + 1;
        }
        v10[v9 + 2] = v34;
        int i = v35;
      }
      else
      {
        int v18 = v9 + v7;
        int v19 = v8[v9 + 2 + (int)v7];
        int v20 = v9 + v7 + 1;
        int v21 = v8[v9 + 1 + (int)v7];
        if (v20 <= v9)
        {
          uint64_t v22 = v18;
          do
            ++v8[v22++ + 2];
          while (v9 != v22);
          unsigned int v13 = v10[v12];
        }
        uint64_t v23 = *(void *)(a1 + 24);
        v10[v12] = v13 + 1;
        uint64_t result = arithmetic_decode_0((int *)a1, v23, v16, v19 + v16 - v21, v15);
        if (result) {
          return result;
        }
        *a3 = v17;
        if (v10[v12] >= 0x800) {
          scale_cumprob(v10, v9);
        }
      }
      ++a2;
      ++a3;
    }
  }
  return 0;
}

uint64_t arithmetic_encode_close_0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 4);
  int v4 = 4;
  while (1)
  {
    uint64_t result = byte_plus_prev(a1, v2, HIBYTE(v3));
    if (result) {
      return result;
    }
    unsigned int v3 = *(_DWORD *)(a1 + 4) << 8;
    *(_DWORD *)(a1 + 4) = v3;
    if (!--v4)
    {
      uint64_t result = aj_ostream_write_bytes(v2, *(unsigned __int8 *)(a1 + 33), 1);
      if (!result)
      {
        if (*(_DWORD *)(a1 + 12))
        {
          while (1)
          {
            uint64_t result = aj_ostream_write_bytes(v2, 255, 1);
            if (result) {
              break;
            }
            int v6 = *(_DWORD *)(a1 + 12) - 1;
            *(_DWORD *)(a1 + 12) = v6;
            if (!v6) {
              goto LABEL_8;
            }
          }
        }
        else
        {
LABEL_8:
          uint64_t result = 0;
          *(unsigned char *)(a1 + 33) = 0;
        }
      }
      return result;
    }
  }
}

uint64_t arithmetic_encode_static_data_0(uint64_t a1, unsigned int a2, int a3)
{
  char v3 = a3;
  int v4 = a2;
  if (a3 >= 17)
  {
    char v3 = a3 - 16;
    uint64_t result = arithmetic_encode_static((int *)a1, *(void *)(a1 + 16), a2 >> (a3 - 16), (a2 >> (a3 - 16)) + 1, 16);
    if (result) {
      return result;
    }
    v4 &= ~(-1 << v3);
  }
  uint64_t v7 = *(void *)(a1 + 16);
  return arithmetic_encode_static((int *)a1, v7, v4, v4 + 1, v3);
}

uint64_t arithmetic_encode_init_0(uint64_t a1)
{
  *(void *)a1 = 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = 0;
  return 0;
}

uint64_t arithmetic_encode_symbols_0(uint64_t a1, int **a2, unsigned __int8 *a3, int a4)
{
  if (!a4) {
    return 0;
  }
  int v4 = a4;
  while (1)
  {
    int v8 = *a2++;
    uint64_t v7 = v8;
    int v10 = v8 + 1;
    uint64_t v9 = *v8;
    LODWORD(v8) = *a3++;
    uint64_t v11 = v8;
    if ((int)v9 <= (int)v8) {
      break;
    }
    uint64_t v12 = v10[v9 + 2];
    if ((int)v11 >= (int)v12)
    {
      int v21 = v10[(int)v9 + ~v12];
      uint64_t v22 = v9 + 1;
      uint64_t result = arithmetic_encode_0((int *)a1, *(void *)(a1 + 16), v21, v21 + 1, v10[v9 + 1]);
      if (result) {
        return result;
      }
      int v29 = v4;
      unsigned int v23 = -1;
      do
        ++v23;
      while (v23 <= 0x1F && 1 << v23 < (int)v9);
      uint64_t v24 = v11 + 1;
      uint64_t result = arithmetic_encode_static((int *)a1, *(void *)(a1 + 16), v11, (int)v11 + 1, v23);
      if (result) {
        return result;
      }
      cum_to_probs((uint64_t)v10, v9);
      if ((int)v11 > (int)v12)
      {
        int v25 = v11 - v12;
        unsigned int v26 = &v7[v12 + 3];
        do
        {
          ++*v26++;
          ++v10[v22];
          --v25;
        }
        while (v25);
      }
      uint64_t v27 = v11 + 2;
      if ((int)v24 < (int)v9)
      {
        ++v10[v27];
        ++v10[v22];
      }
      ++v10[v24];
      ++v10[v22];
      probs_to_cum(v10, v9);
      if (v9 == v27) {
        int v28 = v9;
      }
      else {
        int v28 = v11 + 1;
      }
      v10[v9 + 2] = v28;
      int v4 = v29;
    }
    else
    {
      int v13 = v9 + ~v11;
      int v14 = v10[v13];
      int v15 = v7[v13 + 2];
      if (v13 < (int)v9)
      {
        unsigned int v16 = &v7[v13 + 2];
        int v17 = v11 + 1;
        do
        {
          ++*v16++;
          --v17;
        }
        while (v17);
      }
      uint64_t v18 = *(void *)(a1 + 16);
      unsigned int v19 = v10[(int)v9 + 1];
      v10[(int)v9 + 1] = v19 + 1;
      uint64_t result = arithmetic_encode_0((int *)a1, v18, v14, v15, v19);
      if (result) {
        return result;
      }
      if (v10[(int)v9 + 1] >= 0x800) {
        scale_cumprob(v10, v9);
      }
    }
    if (!--v4) {
      return 0;
    }
  }
  aj_log_error(0, "Illegal symbol to be encoded (%d). Num syms in this context is %d.", v11, v9);
  return 7;
}

uint64_t arithmetic_prob_table_size_0(int a1)
{
  return (4 * a1 + 16);
}

int *init_cum_prob_0(int *a1, int a2, unsigned __int8 *a3, int a4)
{
  bzero(a1, 4 * a2 + 16);
  *a1 = a2;
  int v8 = a1 + 1;
  if (a2 - 1 <= a4) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = a4;
  }
  v8[a2 + 2] = v9;
  if (a3)
  {
    int v10 = 0;
    if ((int)v9 >= 1)
    {
      uint64_t v11 = a1 + 2;
      uint64_t v12 = v9;
      do
      {
        *v11++ = *a3;
        int v13 = *a3++;
        v10 += v13;
        --v12;
      }
      while (v12);
    }
    if ((int)v9 < a2)
    {
      v8[(int)v9 + 1] = 1;
      ++v10;
    }
  }
  else
  {
    if ((int)v9 >= 1) {
      memset_pattern16(a1 + 2, &unk_210410420, 4 * v9);
    }
    int v10 = v9;
    if ((int)v9 < a2)
    {
      bzero(&a1[(int)v9 + 2], 4 * (a2 - 1 - v9) + 4);
      int v10 = v9 + 1;
      v8[(int)v9 + 1] = 1;
    }
  }
  v8[a2 + 1] = v10;
  return probs_to_cum(a1 + 1, a2);
}

int *probs_to_cum(int *result, int a2)
{
  uint64_t v2 = result + 1;
  int v3 = a2 - 1;
  if (a2 > 1)
  {
    uint64_t v4 = a2 >> 1;
    int v5 = result + 1;
    do
    {
      int v6 = *v5;
      *v5++ = v2[v3];
      v2[v3--] = v6;
      --v4;
    }
    while (v4);
  }
  if (a2 >= 1)
  {
    uint64_t v7 = a2;
    int v8 = *result;
    do
    {
      v8 += *v2;
      *v2++ = v8;
      --v7;
    }
    while (v7);
  }
  return result;
}

uint64_t arithmetic_decode_0(int *a1, uint64_t a2, int a3, int a4, int a5)
{
  int v6 = (a4 - a3) * a5;
  *a1 = v6;
  unsigned int v7 = a1[2] - a5 * a3;
  a1[2] = v7;
  if ((v6 - 16777217) >> 24 == 255)
  {
    unsigned int v11 = 0;
    while (1)
    {
      a1[2] = v7 << 8;
      uint64_t result = aj_istream_read_bytes_le(a2, &v11, 1);
      if (result) {
        break;
      }
      unsigned int v7 = a1[2] | v11;
      a1[2] = v7;
      int v10 = *a1;
      int v6 = *a1 << 8;
      *a1 = v6;
      if (((v10 << 8) - 16777217) >> 24 != 255) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    uint64_t result = 0;
    if (!v6) {
      *a1 = -1;
    }
  }
  return result;
}

int *scale_cumprob(int *a1, int a2)
{
  cum_to_probs((uint64_t)a1, a2);
  if (a2 < 1)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    int v5 = (unsigned int *)(a1 + 1);
    uint64_t v6 = a2;
    do
    {
      unsigned int v7 = *v5 + 1;
      *v5++ = v7 >> 1;
      v4 += v7 >> 1;
      --v6;
    }
    while (v6);
  }
  a1[a2 + 1] = v4;
  return probs_to_cum(a1, a2);
}

uint64_t cum_to_probs(uint64_t result, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = (int *)(result + 4);
    int v3 = *(_DWORD *)(result + 4 * a2);
    unint64_t v4 = a2;
    do
    {
      int v5 = (_DWORD *)(result + 4 * v4);
      int v6 = *(v5 - 1);
      *int v5 = v3 - v6;
      int v3 = v6;
    }
    while (v4-- > 1);
    if (a2 >= 2)
    {
      uint64_t v8 = a2 >> 1;
      uint64_t v9 = (int *)(result + 4 * (a2 - 1) + 4);
      do
      {
        int v10 = *v2;
        *v2++ = *v9;
        *v9-- = v10;
        --v8;
      }
      while (v8);
    }
  }
  return result;
}

uint64_t arithmetic_encode_static(int *a1, uint64_t a2, int a3, int a4, char a5)
{
  int v7 = a1[1];
  unsigned int v8 = *a1 >> a5;
  int v9 = v8 * (a4 - a3);
  *a1 = v9;
  int v10 = v8 * a3;
  unsigned int v11 = v10 + v7;
  if (__CFADD__(v10, v7))
  {
    uint64_t result = byte_carry((uint64_t)a1, a2);
    if (result) {
      return result;
    }
    int v9 = *a1;
  }
  a1[1] = v11;
  if ((v9 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      uint64_t result = byte_plus_prev((uint64_t)a1, a2, HIBYTE(v11));
      if (result) {
        break;
      }
      int v13 = *a1;
      unsigned int v11 = a1[1] << 8;
      int v9 = *a1 << 8;
      *a1 = v9;
      a1[1] = v11;
      if (((v13 << 8) - 16777217) >> 24 != 255) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t result = 0;
    if (!v9) {
      *a1 = -1;
    }
  }
  return result;
}

uint64_t byte_carry(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(a1 + 33) + 1;
  *(unsigned char *)(a1 + 33) = v2;
  if (!*(_DWORD *)(a1 + 12)) {
    return 0;
  }
  int v5 = v2;
  do
  {
    uint64_t result = aj_ostream_write_bytes(a2, v5, 1);
    if (result) {
      break;
    }
    int v5 = 0;
    *(unsigned char *)(a1 + 33) = 0;
    int v7 = *(_DWORD *)(a1 + 12) - 1;
    *(_DWORD *)(a1 + 12) = v7;
  }
  while (v7);
  return result;
}

uint64_t arithmetic_encode_0(int *a1, uint64_t a2, int a3, int a4, unsigned int a5)
{
  int v7 = a1[1];
  int v8 = *a1 / a5;
  int v9 = v8 * (a4 - a3);
  *a1 = v9;
  int v10 = v8 * a3;
  unsigned int v11 = v7 + v10;
  if (__CFADD__(v7, v10))
  {
    uint64_t result = byte_carry((uint64_t)a1, a2);
    if (result) {
      return result;
    }
    int v9 = *a1;
  }
  a1[1] = v11;
  if ((v9 - 16777217) >> 24 == 255)
  {
    while (1)
    {
      uint64_t result = byte_plus_prev((uint64_t)a1, a2, HIBYTE(v11));
      if (result) {
        break;
      }
      int v13 = *a1;
      unsigned int v11 = a1[1] << 8;
      int v9 = *a1 << 8;
      *a1 = v9;
      a1[1] = v11;
      if (((v13 << 8) - 16777217) >> 24 != 255) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t result = 0;
    if (!v9) {
      *a1 = -1;
    }
  }
  return result;
}

uint64_t aj_init_QT_as_no_op(uint64_t result, int a2)
{
  uint64_t v2 = 0;
  if (a2 == 1) {
    unsigned int v3 = 4096;
  }
  else {
    unsigned int v3 = 1;
  }
  int32x4_t v4 = vdupq_n_s32(v3);
  do
  {
    *(int32x4_t *)(result + v2) = v4;
    v2 += 16;
  }
  while (v2 != 256);
  return result;
}

_DWORD *aj_init_QT_aanIDCT(_DWORD *result, _DWORD *a2, int a3, int *a4)
{
  switch(a3)
  {
    case 1:
      for (uint64_t i = 0; i != 64; ++i)
        a2[a4[i]] = dword_210410430[aj_glob_zigzag[i]] * result[i];
      break;
    case 2:
      for (uint64_t j = 0; j != 25; ++j)
        a2[a4[j]] = result[j];
      break;
    case 4:
      a2[*a4] = *result;
      a2[a4[1]] = result[1];
      a2[a4[2]] = result[2];
      a2[a4[4]] = result[4];
      break;
    case 8:
      *a2 = *result;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t aj_idct_s8(__int16 *a1, void *a2, int a3)
{
  int v3 = *a1;
  unsigned int v4 = v3 + 1028;
  unsigned int v5 = (v3 + 1028) >> 3;
  if (v3 <= -1029) {
    char v6 = 0;
  }
  else {
    char v6 = -1;
  }
  if (v4 < 0x800) {
    char v6 = v5;
  }
  *(unsigned char *)(*a2 + a3) = v6;
  return 1;
}

uint64_t aj_idct_s8_1x2_nearest(__int16 *a1, void *a2, int a3)
{
  int v3 = *a1;
  unsigned int v4 = v3 + 1028;
  unsigned int v5 = (v3 + 1028) >> 3;
  if (v3 <= -1029) {
    char v6 = 0;
  }
  else {
    char v6 = -1;
  }
  if (v4 < 0x800) {
    char v6 = v5;
  }
  int v7 = (char *)(*a2 + a3);
  *int v7 = v6;
  v7[1] = v6;
  return 2;
}

uint64_t aj_idct_s4_1x2(__int16 *a1, void *a2, int a3)
{
  int v3 = (unsigned char *)(*a2 + a3);
  int v4 = *a1;
  int v5 = a1[1];
  int v6 = v4 - v5;
  int v7 = a1[8];
  int v8 = a1[9];
  int v9 = v7 - v8;
  int v10 = v5 + v4 + v7 + v8;
  if (v10 <= -1029) {
    char v11 = 0;
  }
  else {
    char v11 = -1;
  }
  if ((v10 + 1028) >= 0x800) {
    char v12 = v11;
  }
  else {
    char v12 = (v10 + 1028) >> 3;
  }
  unsigned char *v3 = v12;
  int v13 = v9 + v6;
  unsigned int v14 = v9 + v6 + 1028;
  if (v13 <= -1029) {
    char v15 = 0;
  }
  else {
    char v15 = -1;
  }
  if (v14 < 0x800) {
    char v15 = v14 >> 3;
  }
  v3[1] = v15;
  return 2;
}

uint64_t aj_idct_s4_2x1(__int16 *a1, void *a2, int a3)
{
  uint64_t v3 = a2[1];
  int v4 = *a1;
  int v5 = a1[8];
  int v6 = a1[9];
  int v7 = v6 + v5;
  int v8 = v5 - v6;
  int v9 = v7 + 2 * v4 + v8;
  int v10 = v9 + 2;
  if (v9 >= -1) {
    int v10 = v9 + 1;
  }
  unsigned int v11 = (v10 >> 1) + 1028;
  if (v9 <= -2059) {
    char v12 = 0;
  }
  else {
    char v12 = -1;
  }
  if (v11 >= 0x800) {
    char v13 = v12;
  }
  else {
    char v13 = v11 >> 3;
  }
  *(unsigned char *)(*a2 + a3) = v13;
  int v14 = v4 - v7 + v4 - v8;
  int v15 = v14 + 2;
  if (v14 >= -1) {
    int v15 = v14 + 1;
  }
  unsigned int v16 = (v15 >> 1) + 1028;
  if (v14 <= -2059) {
    char v17 = 0;
  }
  else {
    char v17 = -1;
  }
  if (v16 < 0x800) {
    char v17 = v16 >> 3;
  }
  *(unsigned char *)(v3 + a3) = v17;
  return 1;
}

uint64_t aj_idct_s2_2x4(int16x4_t *a1, void *a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1] + a3;
  v30[0] = *a2 + a3;
  v30[1] = v4;
  int16x4_t v5 = a1[2];
  int32x4_t v6 = vsubl_s16(*a1, v5);
  char v7 = 1;
  v31[0] = vaddl_s16(v5, *a1);
  v31[1] = v6;
  do
  {
    char v8 = v7;
    int v9 = (int *)&v31[v3];
    int v10 = *v9;
    int v11 = v9[1];
    int v12 = v9[2];
    LODWORD(v9) = v9[3];
    int v13 = v12 + v10;
    int v14 = v10 - v12;
    int v15 = (17734 * ((int)v9 + v11) + 0x4000) >> 15;
    int v16 = v15 + ((25080 * v11 + 0x4000) >> 15);
    int v17 = v15 - (v9 + ((27779 * (int)v9 + 0x4000) >> 15));
    unsigned int v18 = v16 + v13 + 1028;
    if (v16 + v13 <= -1029) {
      char v19 = 0;
    }
    else {
      char v19 = -1;
    }
    if (v18 < 0x800) {
      char v19 = v18 >> 3;
    }
    int v20 = (char *)v30[v3];
    char *v20 = v19;
    unsigned int v21 = v17 + v14 + 1028;
    if (v17 + v14 <= -1029) {
      char v22 = 0;
    }
    else {
      char v22 = -1;
    }
    if (v21 < 0x800) {
      char v22 = v21 >> 3;
    }
    v20[1] = v22;
    int v23 = v14 - v17;
    unsigned int v24 = v23 + 1028;
    unsigned int v25 = (v23 + 1028) >> 3;
    if (v23 <= -1029) {
      char v26 = 0;
    }
    else {
      char v26 = -1;
    }
    if (v24 < 0x800) {
      char v26 = v25;
    }
    v20[2] = v26;
    unsigned int v27 = v13 - v16 + 1028;
    if (v13 - v16 <= -1029) {
      char v28 = 0;
    }
    else {
      char v28 = -1;
    }
    if (v27 < 0x800) {
      char v28 = v27 >> 3;
    }
    v20[3] = v28;
    v30[v3] = v20 + 4;
    uint64_t v3 = 1;
    char v7 = 0;
  }
  while ((v8 & 1) != 0);
  return 4;
}

uint64_t aj_idct_s2_4x2(int16x4_t *a1, void *a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1] + a3;
  v34[0] = *a2 + a3;
  v34[1] = v4;
  uint64_t v5 = a2[3] + a3;
  v34[2] = a2[2] + a3;
  v34[3] = v5;
  int16x4_t v6 = a1[4];
  int32x4_t v7 = vaddl_s16(v6, *a1);
  int32x4_t v8 = vsubl_s16(*a1, v6);
  int16x4_t v9 = a1[2];
  int16x4_t v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v13 = vshrq_n_s32(vmlaq_s32(v12, vaddl_s16(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v14 = vmlal_s16(v12, v9, vdup_n_s16(0x61F8u));
  int32x4_t v15 = vsubq_s32(v13, vsraq_n_s32(vmovl_s16(v10), vmlal_s16(v11, v10, vdup_n_s16(0x6C83u)), 0xFuLL));
  int32x4_t v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v35[0] = vaddq_s32(v16, v7);
  v35[1] = vaddq_s32(v15, v8);
  v35[2] = vsubq_s32(v8, v15);
  v35[3] = vsubq_s32(v7, v16);
  int v17 = (char *)v35 + 8;
  do
  {
    int v18 = *((_DWORD *)v17 - 2);
    int v19 = *((_DWORD *)v17 - 1);
    int v20 = *((_DWORD *)v17 + 1);
    v17 += 16;
    int v21 = (17734 * (v20 + v19) + 0x4000) >> 15;
    int v22 = v21 + ((25080 * v19 + 0x4000) >> 15);
    int v23 = v21 - (v20 + ((27779 * v20 + 0x4000) >> 15));
    int v24 = v22 + 2 * v18 + v23;
    int v25 = v24 + 2;
    if (v24 >= -1) {
      int v25 = v24 + 1;
    }
    unsigned int v26 = (v25 >> 1) + 1028;
    if (v24 <= -2059) {
      char v27 = 0;
    }
    else {
      char v27 = -1;
    }
    if (v26 < 0x800) {
      char v27 = v26 >> 3;
    }
    char v28 = (char *)v34[v3];
    *char v28 = v27;
    int v29 = v18 - v23 + v18 - v22;
    int v30 = v29 + 2;
    if (v29 >= -1) {
      int v30 = v29 + 1;
    }
    unsigned int v31 = (v30 >> 1) + 1028;
    if (v29 <= -2059) {
      char v32 = 0;
    }
    else {
      char v32 = -1;
    }
    if (v31 < 0x800) {
      char v32 = v31 >> 3;
    }
    v28[1] = v32;
    v34[v3++] = v28 + 2;
  }
  while (v3 != 4);
  return 2;
}

uint64_t aj_idct_s1_12bit(int *a1, uint64_t *a2, int a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (uint64_t i = 0; i != 128; i += 16)
  {
    uint64_t v6 = *a2++;
    *(_OWORD *)(v6 + a3) = *(_OWORD *)&v8[i];
  }
  return 16;
}

uint64_t basic_idct_s1_12bit(int *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v5 = v45;
  uint64_t v6 = a1;
  do
  {
    int32x4_t v7 = &a1[v4];
    if (v7[8] || v7[24] | v7[16] || (int32x4_t v8 = &a1[v4], v8[40] | v8[32]) || v8[56] | v8[48])
    {
      uint64_t v9 = 0;
      int16x4_t v10 = v6;
      do
      {
        int v11 = *v10;
        v10 += 8;
        v46[v9++] = v11;
      }
      while (v9 != 8);
      int32x4_t v12 = &v45[4 * v4];
      idct_aan(v46, v12, v12 + 8, v12 + 16, v12 + 24, v12 + 32, v12 + 40, v12 + 48, v12 + 56);
    }
    else
    {
      uint64_t v13 = 0;
      int v14 = a1[v4];
      do
      {
        *(_DWORD *)&v5[v13] = v14;
        v13 += 32;
      }
      while (v13 != 256);
    }
    ++v4;
    ++v6;
    v5 += 4;
  }
  while (v4 != 8);
  uint64_t v15 = 0;
  int32x4_t v16 = (__int16 *)(a2 + 8);
  do
  {
    uint64_t v43 = (int *)&v45[v15 + 24];
    int v44 = (int *)&v45[v15 + 28];
    uint64_t result = idct_aan(&v45[v15], &v45[v15], &v45[v15 + 4], &v45[v15 + 8], &v45[v15 + 12], &v45[v15 + 16], &v45[v15 + 20], v43, v44);
    int v18 = *(_DWORD *)&v45[v15];
    if ((v18 + 65552) >= 0x20000)
    {
      if (v18 <= -65553) {
        LOWORD(v19) = 0;
      }
      else {
        LOWORD(v19) = 4095;
      }
    }
    else
    {
      unsigned int v19 = (v18 + 65552) >> 5;
    }
    *(v16 - 4) = v19;
    int v20 = *(_DWORD *)&v45[v15 + 4];
    if ((v20 + 65552) >= 0x20000)
    {
      if (v20 <= -65553) {
        LOWORD(v21) = 0;
      }
      else {
        LOWORD(v21) = 4095;
      }
    }
    else
    {
      unsigned int v21 = (v20 + 65552) >> 5;
    }
    *(v16 - 3) = v21;
    int v22 = *(_DWORD *)&v45[v15 + 8];
    if ((v22 + 65552) >= 0x20000)
    {
      if (v22 <= -65553) {
        LOWORD(v23) = 0;
      }
      else {
        LOWORD(v23) = 4095;
      }
    }
    else
    {
      unsigned int v23 = (v22 + 65552) >> 5;
    }
    *(v16 - 2) = v23;
    int v24 = *(_DWORD *)&v45[v15 + 12];
    if ((v24 + 65552) >= 0x20000)
    {
      if (v24 <= -65553) {
        LOWORD(v25) = 0;
      }
      else {
        LOWORD(v25) = 4095;
      }
    }
    else
    {
      unsigned int v25 = (v24 + 65552) >> 5;
    }
    *(v16 - 1) = v25;
    int v26 = *(_DWORD *)&v45[v15 + 16];
    unsigned int v27 = v26 + 65552;
    unsigned int v28 = (v26 + 65552) >> 5;
    if (v26 <= -65553) {
      __int16 v29 = 0;
    }
    else {
      __int16 v29 = 4095;
    }
    if (v27 < 0x20000) {
      __int16 v29 = v28;
    }
    __int16 *v16 = v29;
    int v30 = *(_DWORD *)&v45[v15 + 20];
    unsigned int v31 = v30 + 65552;
    unsigned int v32 = (v30 + 65552) >> 5;
    if (v30 <= -65553) {
      __int16 v33 = 0;
    }
    else {
      __int16 v33 = 4095;
    }
    if (v31 < 0x20000) {
      __int16 v33 = v32;
    }
    v16[1] = v33;
    unsigned int v34 = *v43 + 65552;
    if (*v43 <= -65553) {
      __int16 v35 = 0;
    }
    else {
      __int16 v35 = 4095;
    }
    if (v34 < 0x20000) {
      __int16 v35 = v34 >> 5;
    }
    v16[2] = v35;
    unsigned int v36 = *v44 + 65552;
    if (*v44 <= -65553) {
      __int16 v37 = 0;
    }
    else {
      __int16 v37 = 4095;
    }
    if (v36 < 0x20000) {
      __int16 v37 = v36 >> 5;
    }
    v16[3] = v37;
    v15 += 32;
    v16 += 8;
  }
  while (v15 != 256);
  for (unint64_t i = 0; i != 8; ++i)
  {
    if (i <= 6)
    {
      uint64_t v39 = 1;
      uint64_t v40 = 16;
      do
      {
        __int16 v41 = *(_WORD *)(a2 + 2 * v39) ^ *(_WORD *)(a2 + v40);
        *(_WORD *)(a2 + 2 * v39) = v41;
        __int16 v42 = *(_WORD *)(a2 + v40) ^ v41;
        *(_WORD *)(a2 + v40) = v42;
        *(_WORD *)(a2 + 2 * v39) ^= v42;
        v40 += 16;
        ++v39;
      }
      while (i + v39 != 8);
    }
    a2 += 18;
  }
  return result;
}

uint64_t aj_idct_s1_16x16_bilinear_12bit(int *a1, void *a2, int a3)
{
  v37[14] = *MEMORY[0x263EF8340];
  basic_idct_s1_12bit(a1, (uint64_t)v36);
  uint64_t v5 = 0;
  uint64_t v6 = (_WORD *)(*a2 + a3);
  int v7 = v36[0];
  *uint64_t v6 = v36[0];
  int32x4_t v8 = v6 + 1;
  int v9 = v7;
  do
  {
    int16x4_t v10 = &v8[v5 * 2];
    int v11 = (unsigned __int16)v36[v5 + 1];
    *int16x4_t v10 = (3 * v9 + v11 + 2) >> 2;
    v10[1] = (v9 + 3 * v11 + 1) >> 2;
    ++v5;
    int v9 = v11;
  }
  while (v5 != 7);
  int32x4_t v12 = (unsigned __int16 *)v37;
  v8[14] = v11;
  uint64_t v13 = 1;
  int v14 = v36;
  do
  {
    uint64_t v15 = 0;
    int v16 = v7;
    int v17 = &a2[2 * v13];
    int v18 = (_WORD *)(*(v17 - 1) + a3);
    unsigned int v19 = (_WORD *)(*v17 + a3);
    int v7 = *v12;
    int v20 = 3 * v16 + v7;
    int v21 = 3 * v7 + v16;
    _WORD *v18 = (v20 + 1) >> 2;
    int v22 = v18 + 1;
    _WORD *v19 = (v21 + 1) >> 2;
    unsigned int v23 = v19 + 1;
    do
    {
      int v24 = &v23[v15 * 2];
      unsigned int v25 = &v22[v15 * 2];
      int v26 = (unsigned __int16)v14[v15 + 1];
      int v27 = (unsigned __int16)v14[v15 + 9];
      int v28 = 3 * v26 + v27;
      int v29 = 3 * v27 + v26;
      *unsigned int v25 = (3 * v20 + v28 + 8) >> 4;
      v25[1] = (v20 + 3 * v28 + 7) >> 4;
      _WORD *v24 = (3 * v21 + v29 + 8) >> 4;
      v24[1] = (v21 + 3 * v29 + 7) >> 4;
      ++v15;
      int v21 = v29;
      int v20 = v28;
    }
    while (v15 != 7);
    v22[14] = (v28 + 2) >> 2;
    v23[14] = (v29 + 2) >> 2;
    ++v13;
    int32x4_t v12 = &v36[8 * v13];
    v14 += 8;
  }
  while (v13 != 8);
  unint64_t v30 = 0;
  unsigned int v31 = (_WORD *)(a2[15] + a3);
  *unsigned int v31 = v7;
  unsigned int v32 = v31 + 1;
  do
  {
    __int16 v33 = &v32[v30];
    int v34 = (unsigned __int16)v14[v30 / 2 + 1];
    *__int16 v33 = (3 * v7 + v34 + 2) >> 2;
    v33[1] = (v7 + 3 * v34 + 1) >> 2;
    v30 += 2;
    int v7 = v34;
  }
  while (v30 != 14);
  v32[v30] = v34;
  return 32;
}

uint64_t aj_idct_s1_16x8_bilinear_12bit(int *a1, void *a2, int a3)
{
  v17[14] = *MEMORY[0x263EF8340];
  uint64_t v5 = v17;
  basic_idct_s1_12bit(a1, (uint64_t)&v16);
  *(_OWORD *)(*a2 + a3) = v16;
  uint64_t v6 = 1;
  int v7 = &v16;
  do
  {
    uint64_t v8 = 0;
    int v9 = v5;
    int16x4_t v10 = &a2[2 * v6];
    uint64_t v11 = *(v10 - 1) + a3;
    uint64_t v12 = *v10 + a3;
    do
    {
      int v13 = *(unsigned __int16 *)((char *)v7 + v8);
      int v14 = *(unsigned __int16 *)((char *)v7 + v8 + 16);
      *(_WORD *)(v11 + v8) = (v14 + 3 * v13 + 1) >> 2;
      *(_WORD *)(v12 + v8) = (v13 + 3 * v14 + 2) >> 2;
      v8 += 2;
    }
    while (v8 != 16);
    ++v6;
    uint64_t v5 = &v17[2 * v6 - 2];
    ++v7;
  }
  while (v6 != 8);
  *(_OWORD *)(a2[15] + a3) = *v9;
  return 16;
}

uint64_t aj_idct_s1_8x4_12bit(int *a1, uint64_t a2, int a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (uint64_t i = 0; i != 8; ++i)
  {
    uint64_t v6 = (const __int16 *)&v8[i];
    int16x4x2_t v10 = vld2_s16(v6);
    *(uint16x4_t *)(*(void *)(a2 + 8 * i) + a3) = vrhadd_u16((uint16x4_t)v10.val[0], (uint16x4_t)v10.val[1]);
  }
  return 8;
}

uint64_t aj_idct_s1_4x8_12bit(int *a1, uint64_t *a2, int a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  basic_idct_s1_12bit(a1, (uint64_t)v8);
  for (uint64_t i = 0; i != 128; i += 32)
  {
    uint64_t v6 = *a2++;
    *(_OWORD *)(v6 + a3) = *(_OWORD *)&v8[i];
  }
  return 16;
}

uint64_t aj_idct_s2_12bit(int32x4_t *a1, void *a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1] + a3;
  v40[0] = *a2 + a3;
  v40[1] = v4;
  uint64_t v5 = a2[3] + a3;
  void v40[2] = a2[2] + a3;
  v40[3] = v5;
  int32x4_t v6 = a1[4];
  int32x4_t v7 = vaddq_s32(v6, *a1);
  int32x4_t v8 = vsubq_s32(*a1, v6);
  int32x4_t v9 = a1[2];
  int32x4_t v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v13 = vshrq_n_s32(vmlaq_s32(v12, vaddq_s32(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v14 = vmlaq_s32(v12, v9, vdupq_n_s32(0x61F8u));
  int32x4_t v15 = vsubq_s32(v13, vsraq_n_s32(v10, vmlaq_s32(v11, v10, vdupq_n_s32(0x6C83u)), 0xFuLL));
  int32x4_t v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v41[0] = vaddq_s32(v16, v7);
  v41[1] = vaddq_s32(v15, v8);
  int v17 = (int *)v41 + 2;
  v41[2] = vsubq_s32(v8, v15);
  void v41[3] = vsubq_s32(v7, v16);
  do
  {
    int v18 = *(v17 - 2);
    int v19 = *(v17 - 1);
    int v20 = *v17;
    int v21 = v17[1];
    v17 += 4;
    int v22 = v20 + v18;
    int v23 = v18 - v20;
    int v24 = (17734 * (v21 + v19) + 0x4000) >> 15;
    int v25 = v24 + ((25080 * v19 + 0x4000) >> 15);
    int v26 = v24 - (v21 + ((27779 * v21 + 0x4000) >> 15));
    unsigned int v27 = v25 + v22 + 16388;
    if (v25 + v22 <= -16389) {
      __int16 v28 = 0;
    }
    else {
      __int16 v28 = 4095;
    }
    if (v27 < 0x8000) {
      __int16 v28 = v27 >> 3;
    }
    int v29 = (__int16 *)v40[v3];
    *int v29 = v28;
    unsigned int v30 = v26 + v23 + 16388;
    if (v26 + v23 <= -16389) {
      __int16 v31 = 0;
    }
    else {
      __int16 v31 = 4095;
    }
    if (v30 < 0x8000) {
      __int16 v31 = v30 >> 3;
    }
    v29[1] = v31;
    int v32 = v23 - v26;
    unsigned int v33 = v32 + 16388;
    unsigned int v34 = (v32 + 16388) >> 3;
    if (v32 <= -16389) {
      __int16 v35 = 0;
    }
    else {
      __int16 v35 = 4095;
    }
    if (v33 < 0x8000) {
      __int16 v35 = v34;
    }
    v29[2] = v35;
    int v36 = v22 - v25;
    unsigned int v37 = v22 - v25 + 16388;
    if (v36 <= -16389) {
      __int16 v38 = 0;
    }
    else {
      __int16 v38 = 4095;
    }
    if (v37 < 0x8000) {
      __int16 v38 = v37 >> 3;
    }
    v29[3] = v38;
    v40[v3++] = v29 + 4;
  }
  while (v3 != 4);
  return 8;
}

uint64_t aj_idct_s2_2x4_12bit(int32x4_t *a1, void *a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1] + a3;
  v31[0] = *a2 + a3;
  v31[1] = v4;
  int32x4_t v5 = *a1;
  int32x4_t v6 = a1[2];
  int32x4_t v7 = vaddq_s32(v6, *a1);
  char v8 = 1;
  v32[0] = v7;
  v32[1] = vsubq_s32(v5, v6);
  do
  {
    char v9 = v8;
    int32x4_t v10 = (int *)&v32[v3];
    int v11 = *v10;
    int v12 = v10[1];
    int v13 = v10[2];
    LODWORD(v10) = v10[3];
    int v14 = v13 + v11;
    int v15 = v11 - v13;
    int v16 = (17734 * ((int)v10 + v12) + 0x4000) >> 15;
    int v17 = v16 + ((25080 * v12 + 0x4000) >> 15);
    int v18 = v16 - (v10 + ((27779 * (int)v10 + 0x4000) >> 15));
    unsigned int v19 = v17 + v14 + 16388;
    if (v17 + v14 <= -16389) {
      __int16 v20 = 0;
    }
    else {
      __int16 v20 = 4095;
    }
    if (v19 < 0x8000) {
      __int16 v20 = v19 >> 3;
    }
    int v21 = (__int16 *)v31[v3];
    __int16 *v21 = v20;
    unsigned int v22 = v18 + v15 + 16388;
    if (v18 + v15 <= -16389) {
      __int16 v23 = 0;
    }
    else {
      __int16 v23 = 4095;
    }
    if (v22 < 0x8000) {
      __int16 v23 = v22 >> 3;
    }
    v21[1] = v23;
    int v24 = v15 - v18;
    unsigned int v25 = v24 + 16388;
    unsigned int v26 = (v24 + 16388) >> 3;
    if (v24 <= -16389) {
      __int16 v27 = 0;
    }
    else {
      __int16 v27 = 4095;
    }
    if (v25 < 0x8000) {
      __int16 v27 = v26;
    }
    _OWORD v21[2] = v27;
    unsigned int v28 = v14 - v17 + 16388;
    if (v14 - v17 <= -16389) {
      __int16 v29 = 0;
    }
    else {
      __int16 v29 = 4095;
    }
    if (v28 < 0x8000) {
      __int16 v29 = v28 >> 3;
    }
    v21[3] = v29;
    v31[v3] = v21 + 4;
    uint64_t v3 = 1;
    char v8 = 0;
  }
  while ((v9 & 1) != 0);
  return 8;
}

uint64_t aj_idct_s2_4x2_12bit(int32x4_t *a1, void *a2, int a3)
{
  uint64_t v3 = 0;
  uint64_t v36 = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[1] + a3;
  v34[0] = *a2 + a3;
  v34[1] = v4;
  uint64_t v5 = a2[3] + a3;
  v34[2] = a2[2] + a3;
  v34[3] = v5;
  int32x4_t v6 = a1[4];
  int32x4_t v7 = vaddq_s32(v6, *a1);
  int32x4_t v8 = vsubq_s32(*a1, v6);
  int32x4_t v9 = a1[2];
  int32x4_t v10 = a1[6];
  v11.i64[0] = 0x400000004000;
  v11.i64[1] = 0x400000004000;
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v13 = vshrq_n_s32(vmlaq_s32(v12, vaddq_s32(v10, v9), vdupq_n_s32(0x4546u)), 0xFuLL);
  v12.i64[0] = 0x400000004000;
  v12.i64[1] = 0x400000004000;
  int32x4_t v14 = vmlaq_s32(v12, v9, vdupq_n_s32(0x61F8u));
  int32x4_t v15 = vsubq_s32(v13, vsraq_n_s32(v10, vmlaq_s32(v11, v10, vdupq_n_s32(0x6C83u)), 0xFuLL));
  int32x4_t v16 = vsraq_n_s32(v13, v14, 0xFuLL);
  v35[0] = vaddq_s32(v16, v7);
  v35[1] = vaddq_s32(v15, v8);
  int v17 = (char *)v35 + 8;
  v35[2] = vsubq_s32(v8, v15);
  v35[3] = vsubq_s32(v7, v16);
  do
  {
    int v18 = *((_DWORD *)v17 - 2);
    int v19 = *((_DWORD *)v17 - 1);
    int v20 = *((_DWORD *)v17 + 1);
    v17 += 16;
    int v21 = (17734 * (v20 + v19) + 0x4000) >> 15;
    int v22 = v21 + ((25080 * v19 + 0x4000) >> 15);
    int v23 = v21 - (v20 + ((27779 * v20 + 0x4000) >> 15));
    int v24 = v22 + 2 * v18 + v23;
    int v25 = v24 + 2;
    if (v24 >= -1) {
      int v25 = v24 + 1;
    }
    unsigned int v26 = (v25 >> 1) + 16388;
    if (v24 <= -32779) {
      __int16 v27 = 0;
    }
    else {
      __int16 v27 = 4095;
    }
    if (v26 < 0x8000) {
      __int16 v27 = v26 >> 3;
    }
    unsigned int v28 = (__int16 *)v34[v3];
    *unsigned int v28 = v27;
    int v29 = v18 - v23 + v18 - v22;
    int v30 = v29 + 2;
    if (v29 >= -1) {
      int v30 = v29 + 1;
    }
    unsigned int v31 = (v30 >> 1) + 16388;
    if (v29 <= -32779) {
      __int16 v32 = 0;
    }
    else {
      __int16 v32 = 4095;
    }
    if (v31 < 0x8000) {
      __int16 v32 = v31 >> 3;
    }
    v28[1] = v32;
    v34[v3++] = v28 + 2;
  }
  while (v3 != 4);
  return 4;
}

uint64_t aj_idct_s4_12bit(_DWORD *a1, void *a2, int a3)
{
  uint64_t v3 = (_WORD *)(*a2 + a3);
  uint64_t v4 = (__int16 *)(a2[1] + a3);
  int v5 = a1[1];
  int v6 = v5 + *a1;
  int v7 = *a1 - v5;
  int v8 = a1[8];
  int v9 = a1[9];
  int v10 = v9 + v8;
  int v11 = v8 - v9;
  unsigned int v12 = v10 + v6 + 16388;
  if (v10 + v6 <= -16389) {
    __int16 v13 = 0;
  }
  else {
    __int16 v13 = 4095;
  }
  if (v12 >= 0x8000) {
    __int16 v14 = v13;
  }
  else {
    __int16 v14 = v12 >> 3;
  }
  _WORD *v3 = v14;
  unsigned int v15 = v11 + v7 + 16388;
  if (v11 + v7 <= -16389) {
    __int16 v16 = 0;
  }
  else {
    __int16 v16 = 4095;
  }
  if (v15 < 0x8000) {
    __int16 v16 = v15 >> 3;
  }
  v3[1] = v16;
  int v17 = v6 - v10;
  unsigned int v18 = v6 - v10 + 16388;
  if (v17 <= -16389) {
    __int16 v19 = 0;
  }
  else {
    __int16 v19 = 4095;
  }
  if (v18 < 0x8000) {
    __int16 v19 = v18 >> 3;
  }
  *uint64_t v4 = v19;
  int v20 = v7 - v11;
  unsigned int v21 = v7 - v11 + 16388;
  if (v20 <= -16389) {
    __int16 v22 = 0;
  }
  else {
    __int16 v22 = 4095;
  }
  if (v21 < 0x8000) {
    __int16 v22 = v21 >> 3;
  }
  v4[1] = v22;
  return 4;
}

uint64_t aj_idct_s4_1x2_12bit(int32x2_t *a1, void *a2, int a3)
{
  *(int32x2_t *)v3.i8 = *a1;
  uint64_t v4 = (_WORD *)(*a2 + a3);
  int32x2_t v5 = vsub_s32(*a1, vdup_lane_s32(*a1, 1));
  int32x2_t v6 = vsub_s32(a1[4], vdup_lane_s32(a1[4], 1));
  v3.u64[1] = (unint64_t)a1[4];
  int v7 = vaddvq_s32(v3);
  if (v7 <= -16389) {
    __int16 v8 = 0;
  }
  else {
    __int16 v8 = 4095;
  }
  if ((v7 + 16388) >= 0x8000) {
    __int16 v9 = v8;
  }
  else {
    __int16 v9 = (v7 + 16388) >> 3;
  }
  *uint64_t v4 = v9;
  int v10 = vadd_s32(v6, v5).u32[0];
  if (v10 <= -16389) {
    __int16 v11 = 0;
  }
  else {
    __int16 v11 = 4095;
  }
  if ((v10 + 16388) < 0x8000) {
    __int16 v11 = (v10 + 16388) >> 3;
  }
  v4[1] = v11;
  return 4;
}

uint64_t aj_idct_s4_2x1_12bit(int *a1, void *a2, int a3)
{
  uint64_t v3 = a2[1];
  int v4 = *a1;
  int v5 = a1[1];
  int v6 = v5 + *a1;
  int v7 = a1[8];
  int v8 = a1[9];
  int v9 = v8 + v7;
  int v10 = v7 - v8;
  int v11 = v9 + 2 * *a1 + v10;
  int v12 = v11 + 2;
  if (v11 >= -1) {
    int v12 = v11 + 1;
  }
  unsigned int v13 = (v12 >> 1) + 16388;
  if (v11 <= -32779) {
    __int16 v14 = 0;
  }
  else {
    __int16 v14 = 4095;
  }
  if (v13 >= 0x8000) {
    __int16 v15 = v14;
  }
  else {
    __int16 v15 = v13 >> 3;
  }
  *(_WORD *)(*a2 + a3) = v15;
  int v16 = v6 - v9 + v4 - v5 - v10;
  int v17 = v16 + 2;
  if (v16 >= -1) {
    int v17 = v16 + 1;
  }
  unsigned int v18 = (v17 >> 1) + 16388;
  if (v16 <= -32779) {
    __int16 v19 = 0;
  }
  else {
    __int16 v19 = 4095;
  }
  if (v18 < 0x8000) {
    __int16 v19 = v18 >> 3;
  }
  *(_WORD *)(v3 + a3) = v19;
  return 2;
}

uint64_t aj_idct_s8_12bit(int *a1, void *a2, int a3)
{
  unsigned int v3 = *a1 + 16388;
  if (*a1 <= -16389) {
    __int16 v4 = 0;
  }
  else {
    __int16 v4 = 4095;
  }
  if (v3 < 0x8000) {
    __int16 v4 = v3 >> 3;
  }
  *(_WORD *)(*a2 + a3) = v4;
  return 2;
}

uint64_t idct_aan(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8, _DWORD *a9)
{
  int v9 = a1[2];
  int v10 = a1[3];
  int v11 = a1[6];
  int v12 = a1[7];
  int v13 = v9 + v11;
  int v14 = v9 - v11;
  int v15 = a1[4];
  int v16 = a1[5];
  int v17 = a1[1];
  int v18 = v15 + *a1;
  int v19 = *a1 - v15;
  int v20 = 23170 * v14 + 0x4000;
  int v21 = v16 + v10;
  int v22 = v16 - v10;
  int v23 = v17 + 2 * v12;
  int v24 = 17734 * v22 + 0x4000;
  int v25 = v17 - 2 * v12;
  int v26 = v23 + v21;
  int v27 = v13 + (v20 >> 15);
  int v28 = v27 + v18;
  int v29 = 23170 * (v23 - v21) + 0x4000;
  int v30 = (12540 * (v25 + v22) + 0x4000) >> 15;
  uint64_t result = (v19 - (v20 >> 15));
  int v32 = v19 + (v20 >> 15);
  int v33 = v25 + ((10045 * v25 + 0x4000) >> 15) - v30;
  int v34 = v30 + (v24 >> 15);
  int v35 = v26 + v33;
  int v36 = v33 + (v29 >> 15);
  *a2 = v35 + v27 + v18;
  *a3 = v36 + v32;
  int v37 = v34 + (v29 >> 15);
  *a4 = v37 + result;
  int v38 = v18 - v27;
  *a5 = v34 + v38;
  *a6 = v38 - v34;
  *a7 = result - v37;
  *a8 = v32 - v36;
  *a9 = v28 - v35;
  return result;
}

uint64_t aj_RGB888_YUV444(double a1, int64x2_t a2, int64x2_t a3, int64x2_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, unsigned int a8, int a9)
{
  uint64_t v9 = *a6;
  int v10 = *(unsigned char **)a7;
  int v11 = *(unsigned char **)(a7 + 16);
  int v12 = *(unsigned char **)(a7 + 32);
  v13.i64[0] = 0x80008000800080;
  v13.i64[1] = 0x80008000800080;
  int16x8_t v14 = vshlq_n_s16(v13, 7uLL);
  v15.i64[0] = 0x15980E984B232646;
  v15.i64[1] = 0xA6835982A68;
  for (unsigned int i = a8 >> 3; i; --i)
  {
    int8x8x3_t v30 = vld3_s8((const char *)v9);
    v9 += 24;
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[0], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[1], 7uLL);
    int16x8_t v19 = (int16x8_t)vshll_n_u8((uint8x8_t)v30.val[2], 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v19, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v17, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v18, v15, 4)), vrshrq_n_s16(v19, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v17, 1uLL), vqrdmulhq_laneq_s16(v18, v15, 5)), vqrdmulhq_laneq_s16(v19, v15, 6)), v14), 7uLL);
    *(void *)int v10 = a2.i64[0];
    v10 += 8;
    *(void *)int v11 = a3.i64[0];
    v11 += 8;
    *(void *)int v12 = a4.i64[0];
    v12 += 8;
  }
  int v20 = a8 & 7;
  if ((a8 & 7) != 0)
  {
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      a2.i8[0] = *(unsigned char *)v9;
      a3.i8[0] = *(unsigned char *)(v9 + 1);
      a4.i8[0] = *(unsigned char *)(v9 + 2);
      v9 += 3;
      --v20;
    }
    while (v20);
    int v21 = a8 & 7;
    int v22 = 8 - v21;
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a2.i8, 7uLL);
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a3.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)a4.i8, 7uLL);
    *(int8x8_t *)a2.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v15.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v15.i8, 2)), 7uLL);
    *(int8x8_t *)a3.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v14, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v15.i8, 3)), vqrdmulhq_laneq_s16(v24, v15, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
    *(int8x8_t *)a4.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v15, 5)), vqrdmulhq_laneq_s16(v25, v15, 6)), v14), 7uLL);
    do
    {
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v22;
    }
    while (v22);
    do
    {
      *v10++ = a2.i8[7];
      *v11++ = a3.i8[7];
      *v12++ = a4.i8[7];
      a2 = vshlq_n_s64(a2, 8uLL);
      a3 = vshlq_n_s64(a3, 8uLL);
      a4 = vshlq_n_s64(a4, 8uLL);
      --v21;
    }
    while (v21);
  }
  uint64_t result = a9 - a8;
  if (a9 != a8)
  {
    char v27 = *(v10 - 1);
    char v28 = *(v11 - 1);
    char v29 = *(v12 - 1);
    do
    {
      *v10++ = v27;
      *v11++ = v28;
      *v12++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
  }
  return result;
}

unint64_t aj_RGB888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  if (a1 == 1)
  {
    aj_RGB888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    int v12 = a2[1];
    int16x8_t v13 = *a2;
    int16x8_t v14 = *(int8x8_t **)a3;
    int16x8_t v15 = *(unsigned char **)(a3 + 8);
    int v16 = *(unsigned char **)(a3 + 16);
    int16x8_t v17 = *(unsigned char **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    int16x8_t v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (unsigned int i = a4 >> 4; i; --i)
    {
      int8x8x3_t v66 = vld3_s8(v13);
      int v22 = v13 + 24;
      int8x8x3_t v68 = vld3_s8(v22);
      int16x8_t v13 = v22 + 24;
      int16x8_t v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      int16x8_t v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      int16x8_t v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      int16x8_t v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      int16x8_t v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      int16x8_t v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[2];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *int16x8_t v14 = v66.val[0];
      unsigned int v31 = v14 + 1;
      *unsigned int v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      int16x8_t v14 = v31 + 1;
      int8x8x3_t v67 = vld3_s8(v12);
      int v32 = v12 + 24;
      int8x8x3_t v69 = vld3_s8(v32);
      int v12 = v32 + 24;
      int16x8_t v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      int16x8_t v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      int16x8_t v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      int16x8_t v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      int16x8_t v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      int16x8_t v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(void *)int16x8_t v15 = v5.i64[0];
      uint64_t v39 = v15 + 8;
      *uint64_t v39 = v8.i64[0];
      int16x8_t v15 = v39 + 1;
      uint64_t v40 = v9.i64[0];
      uint64_t v41 = v10.i64[0];
      int64x2_t v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      int64x2_t v7 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[2].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(void *)int v16 = v6.i64[0];
      v16 += 8;
      *(void *)int16x8_t v17 = v7.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x3_t *)((char *)&v6 - 8) = vld3_s8(v13);
      v13 += 24;
      int8x8x3_t v70 = vld3_s8(v12);
      v12 += 24;
      int16x8_t v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      int16x8_t v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      int16x8_t v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      int16x8_t v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      int16x8_t v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v5.i8;
      *(void *)int16x8_t v15 = v8.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v10.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), *(int16x4_t *)v10.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      *(_DWORD *)int v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)int16x8_t v17 = v7.i32[0];
      v17 += 4;
    }
    int v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        int64x2_t v8 = vshlq_n_s64(v8, 8uLL);
        int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
        int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 3;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 3;
        --v49;
      }
      while (v49);
      int v50 = a4 & 7;
      int v51 = 8 - v50;
      unsigned int v52 = (v50 + 1) >> 1;
      int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      int16x8_t v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      int16x8_t v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        int64x2_t v5 = vsliq_n_s64(v5, v5, 8uLL);
        int64x2_t v6 = vsliq_n_s64(v6, v6, 8uLL);
        int64x2_t v7 = vsliq_n_s64(v7, v7, 8uLL);
        int64x2_t v8 = vsliq_n_s64(v8, v8, 8uLL);
        int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
        int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v7.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v7.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v10.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v7.i8 = vqrshrn_n_u16((uint16x8_t)v7, 2uLL);
      do
      {
        v14->i8[0] = v5.i8[7];
        int16x8_t v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v8.i8[7];
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        int64x2_t v8 = vshlq_n_s64(v8, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v7.i8[3];
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        --v52;
      }
      while (v52);
    }
    unint64_t result = a5 - a4;
    if (a5 != a4)
    {
      unsigned int v59 = result >> 1;
      __int8 v60 = v14[-1].i8[7];
      char v61 = *(v15 - 1);
      char v62 = *(v16 - 1);
      char v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        int16x8_t v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        unint64_t result = (result - 1);
      }
      while (result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t aj_check_options(uint64_t a1, int *a2, int a3)
{
  int v3 = *(_DWORD *)(a1 + 24);
  BOOL v4 = *(void *)(a1 + 20) != -1 || *(_DWORD *)(a1 + 12) != -1 || *(_DWORD *)(a1 + 16) != -1;
  int v5 = *(_DWORD *)(a1 + 80);
  if (v5 > 179)
  {
    if (v5 != 180 && v5 != 270) {
      goto LABEL_21;
    }
  }
  else if (v5 && v5 != 90)
  {
LABEL_21:
    aj_log_error((uint64_t)"Parse", "Unsupported rotation. Rotation: %d.");
    return 5;
  }
  int v6 = *(_DWORD *)(a1 + 28);
  if (v6 && (int v7 = *(_DWORD *)(a1 + 32)) != 0)
  {
    if (v6 >= 0x10000 || v7 >= 0x10000)
    {
      aj_log_error((uint64_t)"Parse", "Output width/height cannot exceed 65535.");
      return 5;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 8);
    if (v8 == 14)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is only allowed with fixed scales");
      return 5;
    }
    if (v6 < 1 || v7 <= 0)
    {
      aj_log_error((uint64_t)"Parse", "Output size is not set properly.");
      return 5;
    }
    if (!a3 && (v7 > a2[3] << 9 || v6 > a2[2] << 9))
    {
      aj_log_error((uint64_t)"Parse", "Selected output width or height is too large.");
      return 5;
    }
  }
  else
  {
    if ((*(_DWORD *)(a1 + 76) - 65) < 0xFFFFFFC0)
    {
      aj_log_error((uint64_t)"Parse", "Unsupported scale. Scale: %d.");
      return 5;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 8);
  }
  if (v8 >= 0x1B)
  {
    aj_log_error((uint64_t)"Parse", "Unsupported output format");
    return 5;
  }
  int v11 = *a2;
  if (*a2 != 4)
  {
    if (((1 << v8) & 0x4BF0000) != 0) {
      goto LABEL_47;
    }
    if (v8 == 15)
    {
      aj_log_error((uint64_t)"Parse", "Can only decode to CMYK if image has 4 components");
      return 3;
    }
LABEL_56:
    int v14 = a2[1];
    if (v14 >= 9)
    {
      aj_log_error((uint64_t)"Parse", ">8 bit JPEGs require 16-bit output formats");
      return 3;
    }
    int v17 = 0;
    BOOL v15 = 1;
    if (*((unsigned char *)a2 + 86)) {
      goto LABEL_60;
    }
LABEL_68:
    if (v8 - 25 <= 1)
    {
      aj_log_error((uint64_t)"Parse", "Tri-planar formats only supported for lossless JPEG");
      return 3;
    }
    goto LABEL_90;
  }
  BOOL v13 = v8 == 21 && *((unsigned char *)a2 + 86) != 0;
  if (v8 != 15 && !v13)
  {
    aj_log_error((uint64_t)"Parse", "Image with 4 components can only be decoded CMYK or lossless RGGB");
    return 3;
  }
  if (v8 - 16 >= 6) {
    goto LABEL_56;
  }
LABEL_47:
  int v14 = a2[1];
  BOOL v15 = v14 < 9;
  if (v14 == 8)
  {
    aj_log_error((uint64_t)"Parse", "16-bit output is only supported for >8 bit JPEGs");
    return 3;
  }
  if (v14 < 9)
  {
    int v17 = 0;
    if (*((unsigned char *)a2 + 86)) {
      goto LABEL_60;
    }
    goto LABEL_68;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 76);
  if (v16 > 8 || ((1 << v16) & 0x117) == 0)
  {
    aj_log_error((uint64_t)"Parse", "Rescaling beyond DCT scales is not supported for 12-bit JPEGs");
    return 3;
  }
  if (v5 || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
  {
    aj_log_error((uint64_t)"Parse", "Output transforms are not supported for 12-bit JPEGs");
    return 3;
  }
  int v17 = 1;
  if (!*((unsigned char *)a2 + 86)) {
    goto LABEL_68;
  }
LABEL_60:
  if (v3 != -1
    || *(_DWORD *)(a1 + 20) != -1
    || *(_DWORD *)(a1 + 12) != -1
    || *(_DWORD *)(a1 + 16) != -1
    || v5
    || *(_DWORD *)(a1 + 76) != 1
    || *(_DWORD *)(a1 + 88)
    || *(_DWORD *)(a1 + 84))
  {
    aj_log_error((uint64_t)"Parse", "Cropping, scaling or rotating not supported for lossless JPEG");
    return 3;
  }
  if (v11 == 2) {
    goto LABEL_90;
  }
  if (v11 == 1)
  {
    if (v17)
    {
      if (v8 != 18)
      {
        aj_log_error((uint64_t)"Parse", ">8 bit grayscale lossless JPEG can only be decode to 16-bit grayscale");
        return 3;
      }
      if (!v15) {
        goto LABEL_103;
      }
LABEL_85:
      aj_log_error((uint64_t)"Parse", "8-bit grayscale lossless JPEG can only be decode to 8-bit grayscale");
      return 3;
    }
    if (v15)
    {
      if (v8 == 5) {
        goto LABEL_103;
      }
      goto LABEL_85;
    }
  }
  else
  {
    if (v8 >= 0x19 && v11 != 3)
    {
      aj_log_error((uint64_t)"Parse", "Only three-component JPEGs can be decoded to tri-planar formats");
      return 3;
    }
    if (!(v15 | (v8 < 0x1B) & (0x4330000u >> v8)))
    {
      aj_log_error((uint64_t)"Parse", ">8 bit RGB lossless JPEG can only be decode to 16-bit RGB format");
      return 3;
    }
    if (v14 == 8 && ((v8 < 0x1A) & (0x2000019u >> v8)) == 0)
    {
      aj_log_error((uint64_t)"Parse", "8-bit RGB lossless JPEG can only be decode to 8-bit RGB format");
      return 3;
    }
  }
LABEL_90:
  if (v8 == 14)
  {
    unsigned int v18 = *(_DWORD *)(a1 + 76);
    if (v18 > 8 || ((1 << v18) & 0x116) == 0)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is only allowed with fixed scales");
      return 3;
    }
    if (v5)
    {
      aj_log_error((uint64_t)"Parse", "The texture format is not compatible with rotation");
      return 3;
    }
    if (*(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88))
    {
      aj_log_error((uint64_t)"Parse", "The texture format is not compatible with flipping");
      return 3;
    }
  }
  else if (v8 == 7 && (v5 || *(_DWORD *)(a1 + 84) || *(_DWORD *)(a1 + 88)))
  {
    aj_log_error((uint64_t)"Parse", "Rotation/Flipping and YUV422_YUYV is not yet supported");
    return 3;
  }
LABEL_103:
  if (v4)
  {
    signed int v19 = *(_DWORD *)(a1 + 12);
    if (v19 < 0 || (signed int v20 = a2[2], v19 >= v20))
    {
      aj_log_error((uint64_t)"Parse", "Cropping-regions x-position is invalid");
      return 5;
    }
    signed int v21 = *(_DWORD *)(a1 + 16);
    if (v21 < 0 || (signed int v22 = a2[3], v21 >= v22))
    {
      aj_log_error((uint64_t)"Parse", "Cropping-regions y-position is invalid");
      return 5;
    }
    int v23 = *(_DWORD *)(a1 + 20);
    if (v23 + v19 > v20 || v21 + v3 > v22)
    {
      aj_log_error((uint64_t)"Parse", "Cropping-region exceeds image dimensions [%d,%d+%d,%d] > [%d,%d]");
      return 5;
    }
    if (v3 < 1 || v23 <= 0)
    {
      aj_log_error((uint64_t)"Parse", "Cropping-region is empty");
      return 5;
    }
  }
  if ((*(_DWORD *)a1 & 0x80000000) != 0)
  {
    aj_log_error((uint64_t)"Parse", "Number of threads can't be negative");
    return 5;
  }
  uint64_t v9 = *(unsigned __int8 *)(a1 + 136);
  if (*(unsigned char *)(a1 + 136))
  {
    uint64_t v9 = 0;
    if (!*(_DWORD *)(a1 + 140) && v11 >= 1)
    {
      int v24 = 0;
      int16x8_t v25 = (unsigned int *)(a2 + 8);
      uint64_t v9 = *a2;
      int16x8_t v26 = a2 + 8;
      do
      {
        int v27 = *v26++;
        BOOL v28 = v27 > 1 || (int)*(v25 - 4) > 1;
        v24 |= v28;
        int16x8_t v25 = (unsigned int *)v26;
        --v9;
      }
      while (v9);
      if (v11 != 1 && v24)
      {
        aj_log_error((uint64_t)"Parse", "Unsupported decimation with APP14 transform");
        return 3;
      }
    }
  }
  return v9;
}

uint64_t handle_suspension(void *a1, int a2, uint64_t a3, uint64_t a4, int *a5, int a6, int a7, int a8, unsigned int a9)
{
  if (!a2) {
    return 7;
  }
  uint64_t v9 = *(void *)(a3 + 104);
  uint64_t v10 = v9 - *(void *)(a4 + 104);
  int v11 = *(_DWORD *)(a4 + 48);
  int v12 = *(_DWORD *)(a3 + 48);
  if (v9 != *(_DWORD *)(a4 + 104) || v11 != v12)
  {
    int v14 = v11 - v12;
    *(void *)(a3 + 104) = v9 - (int)v10;
    uint64_t v15 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) -= (int)v10;
    if (v15) {
      *(void *)(a3 + 16) = v15 - (int)v10;
    }
    *(_DWORD *)(a3 + 48) = v11;
    *(_DWORD *)(a3 + 32) += v14;
    return 4294967294;
  }
  if (*(_DWORD *)(a3 + 32) + *(_DWORD *)(a3 + 8) - *(_DWORD *)(a3 + 40) != *(_DWORD *)(a3 + 36)) {
    return 4294967294;
  }
  *(void *)(a3 + 104) = 0;
  uint64_t result = aj_istream_move_to_position(a3, a9);
  if (!result)
  {
    uint64_t result = add_segment_info(a1, a5, a6, a7, a8);
    if (!result) {
      return 4294967294;
    }
  }
  return result;
}

uint64_t aj_rowbuffer_add_block(_DWORD *a1, uint64_t (**a2)(size_t, void), uint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a1 && a2 && a3 && a4)
  {
    int v9 = *a1;
    if ((int)*a1 < 10)
    {
      int v11 = (uint64_t *)&a1[10 * v9 + 2];
      unint64_t v12 = (8 * a4 + 15) & 0xFFFFFFFFFFFFFFF0;
      unint64_t v13 = (a3 + 15) & 0xFFFFFFFFFFFFFFF0;
      unint64_t v14 = v13 + 16;
      BOOL v15 = a5 >= v13 - a3;
      uint64_t v16 = a5 - (v13 - a3);
      if (!v15) {
        uint64_t v16 = 0;
      }
      size_t v17 = v12 + v14 * a4 + v16;
      v11[4] = v17;
      unsigned int v18 = (size_t *)(v11 + 4);
      signed int v20 = v11 + 3;
      size_t v19 = v11[3];
      if (v19)
      {
        a2[1](v19, a2[2]);
        size_t v17 = *v18;
      }
      signed int v21 = (void *)(*a2)(v17, a2[2]);
      uint64_t *v20 = (uint64_t)v21;
      if (v21 && (bzero(v21, *v18), (uint64_t v22 = *v20) != 0))
      {
        uint64_t v23 = 0;
        uint64_t v24 = (uint64_t)&a1[10 * v9 + 2];
        *(void *)(v24 + 16) = v22;
        int16x8_t v25 = (void *)(v24 + 16);
        uint64_t v26 = v22 + v12;
        do
        {
          *(void *)(*v25 + 8 * v23++) = v26;
          v26 += v14;
        }
        while (a4 != v23);
        uint64_t result = 0;
        *int v11 = a4;
        *(void *)&a1[10 * v9 + 4] = a3;
        ++*a1;
      }
      else
      {
        return 6;
      }
    }
    else
    {
      aj_log_error(0, "Rowbuffermanager is full (%d blocks)", *a1);
      return 1;
    }
  }
  else
  {
    aj_log_error(0, "Illegal input to add_block: mgr=%p, mem=%p, len=%zu, rows=%zu\n", a1, a2, a3, a4);
    return 8;
  }
  return result;
}

uint64_t aj_rowbuffer_destroy(int *a1, uint64_t a2)
{
  uint64_t result = 8;
  if (a1 && a2)
  {
    int v5 = *a1;
    if (*a1 >= 1)
    {
      do
      {
        int v6 = v5 - 1;
        uint64_t v7 = *(void *)&a1[10 * (v5 - 1) + 8];
        if (v7)
        {
          (*(void (**)(uint64_t, void))(a2 + 8))(v7, *(void *)(a2 + 16));
          int v5 = *a1;
          int v6 = *a1 - 1;
          *(void *)&a1[10 * v6 + 8] = 0;
        }
        *a1 = v6;
        BOOL v8 = v5 <= 1;
        int v5 = v6;
      }
      while (!v8);
    }
    return 0;
  }
  return result;
}

unsigned char *aj_rowbuffer_get_buffer(unsigned int *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  if ((int)v2 < 1)
  {
LABEL_9:
    aj_log_error(0, "No buffers available of length: %d", a2);
    return 0;
  }
  else
  {
    uint64_t v3 = 0;
    BOOL v4 = a1 + 2;
    while (1)
    {
      if (*(void *)&a1[10 * v3 + 4] == a2)
      {
        uint64_t v5 = *(void *)&v4[10 * v3];
        if (v5) {
          break;
        }
      }
LABEL_8:
      if (++v3 == v2) {
        goto LABEL_9;
      }
    }
    int v6 = *(unsigned char ***)&v4[10 * v3 + 4];
    while (1)
    {
      uint64_t v7 = *v6;
      if (!**v6) {
        break;
      }
      ++v6;
      if (!--v5) {
        goto LABEL_8;
      }
    }
    *uint64_t v7 = 1;
    return v7 + 16;
  }
}

uint64_t aj_rowbuffer_retain_count(unsigned int *a1, unint64_t a2)
{
  rowbuffer_for_pointer = (unsigned __int8 *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer) {
    return *rowbuffer_for_pointer;
  }
  aj_log_error(0, "Requesting retain count for a pointer that is not in the list\n");
  return 0xFFFFFFFFLL;
}

uint64_t find_rowbuffer_for_pointer(unsigned int *a1, unint64_t a2)
{
  unint64_t v2 = *a1;
  if ((int)v2 < 1) {
    return 0;
  }
  unint64_t v3 = 0;
  BOOL v4 = a1 + 2;
  do
  {
    uint64_t v5 = (unint64_t *)&v4[10 * v3];
    unint64_t v6 = v5[3];
    if (v6 > a2 || v6 + *(void *)&v4[10 * v3 + 8] <= a2)
    {
      uint64_t result = 0;
    }
    else
    {
      unint64_t v7 = *v5;
      uint64_t v8 = *(void *)&v4[10 * v3 + 4];
      uint64_t v9 = 1;
      if (v7 >= 2)
      {
        while (*(void *)(v8 + 8 * v9) <= a2)
        {
          if (v7 == ++v9)
          {
            uint64_t v9 = v7;
            break;
          }
        }
      }
      uint64_t result = *(void *)(v8 + (((v9 << 32) - 0x100000000) >> 29));
    }
    ++v3;
  }
  while (v3 < v2 && !result);
  return result;
}

unint64_t aj_rowbuffer_lock_buffer(unsigned int *a1, unint64_t a2)
{
  rowbuffer_for_pointer = (unsigned char *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer) {
    ++*rowbuffer_for_pointer;
  }
  return a2;
}

void aj_rowbuffer_return_buffer(unsigned int *a1, unint64_t a2)
{
  rowbuffer_for_pointer = (unsigned char *)find_rowbuffer_for_pointer(a1, a2);
  if (rowbuffer_for_pointer)
  {
    if (*rowbuffer_for_pointer)
    {
      --*rowbuffer_for_pointer;
      return;
    }
    unint64_t v3 = "Releasing a rowbuffer without lock";
  }
  else
  {
    unint64_t v3 = "Releasing a rowbuffer that is not in the list";
  }
  aj_log_error(0, v3);
}

BOOL applejpeg_reduce_is_reduced_jpeg(_DWORD *a1, unint64_t a2)
{
  return a2 >= 4 && *a1 == 1196444242;
}

BOOL *applejpeg_reduce_open_file(void *a1, unint64_t a2, uint64_t a3, int *a4)
{
  return reduce_open(a1, a2, 0, a3, a4);
}

BOOL *reduce_open(void *a1, unint64_t a2, uint64_t *a3, uint64_t a4, int *a5)
{
  int __dst = 0;
  if (a2 && a3)
  {
    aj_log_error((uint64_t)"Reduce", "Cannot have both file input AND memory input");
LABEL_36:
    unint64_t v14 = 0;
    goto LABEL_37;
  }
  if (!(a2 | (unint64_t)a3))
  {
    aj_log_error((uint64_t)"Reduce", "Input cannot be NULL");
    goto LABEL_36;
  }
  if (a2)
  {
    if (!*(void *)a2 || !*(void *)(a2 + 16))
    {
      aj_log_error((uint64_t)"Reduce", "Read/Skip callback is missing");
      goto LABEL_36;
    }
    unint64_t v10 = *(void *)(a2 + 40);
    if (v10)
    {
      if (v10 <= 0xFFF)
      {
        aj_log_error((uint64_t)"Reduce", "The read buffer size must be larger than %d");
        goto LABEL_36;
      }
      if (v10 >> 31)
      {
        aj_log_error((uint64_t)"Reduce", "The read buffer size can't be larger than %d");
        goto LABEL_36;
      }
    }
    unint64_t v12 = *(void *)(a2 + 48);
    if (v12 >> 31)
    {
      aj_log_error((uint64_t)"Reduce", "The file size can't be larger than %d");
      goto LABEL_36;
    }
    if (!v12)
    {
      aj_log_error((uint64_t)"Reduce", "The file size may not be zero");
      goto LABEL_36;
    }
  }
  else
  {
    if (!*a3 || (unint64_t v11 = a3[1]) == 0)
    {
      aj_log_error((uint64_t)"Reduce", "NULL fields in the memory input struct not allowed");
      goto LABEL_36;
    }
    if (v11 >> 31)
    {
      aj_log_error((uint64_t)"Reduce", "The input buffer size can't be larger than %d");
      goto LABEL_36;
    }
  }
  unint64_t v13 = (BOOL *)((uint64_t (*)(uint64_t, void))*a1)(160576, a1[2]);
  unint64_t v14 = v13;
  if (!v13)
  {
    aj_log_error((uint64_t)"Reduce", "Unable to allocate memory");
    uint64_t v18 = 0;
    goto LABEL_28;
  }
  bzero(v13, 0x27340uLL);
  long long v15 = *(_OWORD *)a1;
  *((void *)v14 + 20063) = a1[2];
  *(_OWORD *)(v14 + 160488) = v15;
  *((void *)v14 + 20064) = v14 + 160488;
  if (a2)
  {
    if (!*(void *)(a2 + 24))
    {
      aj_log_error((uint64_t)"Reduce", "No rewind callback specified", *(double *)&v15);
      goto LABEL_37;
    }
    unint64_t v16 = *(void *)(a2 + 48);
    double inited = aj_istream_init_file((uint64_t)(v14 + 152136), (void *)a2, (uint64_t)(v14 + 156352), 4096, 0, 0);
  }
  else
  {
    unint64_t v16 = a3[1];
    double inited = aj_istream_init_mem((uint64_t)(v14 + 152136), a3, 0, 0);
  }
  if (v16 <= 0x2E)
  {
    aj_log_error((uint64_t)"Reduce", "File/buffer size is too small to fit image", inited);
LABEL_37:
    uint64_t v18 = 0;
    int v19 = 8;
    goto LABEL_38;
  }
  int v20 = aj_istream_peek_bytes((uint64_t)(v14 + 152136), &__dst, 4);
  if (v20) {
    goto LABEL_33;
  }
  BOOL v22 = __dst == 1196444242;
  if (__dst == 1196444242)
  {
    int v20 = aj_istream_move_to_position((uint64_t)(v14 + 152136), 4);
    if (v20)
    {
LABEL_33:
      int v19 = v20;
LABEL_34:
      uint64_t v18 = 0;
      goto LABEL_38;
    }
    int v23 = parse_reduced_file((uint64_t)(v14 + 152136), (char *)v14);
    if (v23)
    {
      int v19 = v23;
      aj_log_error((uint64_t)"Reduce", "Error %d while parsing RJPEG headers", v23);
      goto LABEL_34;
    }
    *unint64_t v14 = v22;
    if (a4)
    {
      *(unsigned char *)a4 = v22;
      BOOL v27 = v14[10];
      uint64_t v28 = *((unsigned int *)v14 + 11);
      int v29 = *((unsigned __int16 *)v14 + 7);
      int v30 = *((unsigned __int16 *)v14 + 6);
      goto LABEL_59;
    }
    goto LABEL_60;
  }
  if (a2)
  {
    (*((void (**)(void))v14 + 19028))(*((void *)v14 + 19025));
    uint64_t v24 = applejpeg_decode_create(a1);
    uint64_t v18 = (uint64_t)v24;
    if (v24)
    {
      int v25 = applejpeg_decode_open_file((uint64_t)v24, a2, 0);
      goto LABEL_52;
    }
LABEL_28:
    int v19 = 6;
LABEL_38:
    if (a5) {
      *a5 = v19;
    }
    applejpeg_decode_destroy((void *)v18);
    applejpeg_reduce_close(v14);
    return 0;
  }
  uint64_t v26 = applejpeg_decode_create(a1);
  uint64_t v18 = (uint64_t)v26;
  if (!v26) {
    goto LABEL_28;
  }
  int v25 = applejpeg_decode_open_mem((uint64_t)v26, a3);
LABEL_52:
  int v19 = v25;
  if (v25)
  {
    aj_log_error((uint64_t)"Reduce", "Decode open failed");
    goto LABEL_38;
  }
  if (!can_jpeg_be_reduced(v18))
  {
    int v19 = 3;
    goto LABEL_38;
  }
  *((void *)v14 + 17732) = v18;
  *unint64_t v14 = v22;
  if (a4)
  {
    BOOL v27 = 0;
    uint64_t v28 = 0;
    *(unsigned char *)a4 = v22;
    int v29 = *(_DWORD *)(v18 + 152);
    int v30 = *(_DWORD *)(v18 + 156);
LABEL_59:
    *(_DWORD *)(a4 + 4) = v27;
    *(void *)(a4 + 8) = v28;
    *(_DWORD *)(a4 + 16) = v29;
    *(_DWORD *)(a4 + 20) = v30;
    *(_DWORD *)(a4 + 24) = 0;
  }
LABEL_60:
  if (a5) {
    *a5 = 0;
  }
  return v14;
}

BOOL *applejpeg_reduce_open_mem(void *a1, uint64_t *a2, uint64_t a3, int *a4)
{
  return reduce_open(a1, 0, a2, a3, a4);
}

uint64_t applejpeg_reduce_options_init(uint64_t result)
{
  *(_DWORD *)uint64_t result = 0;
  *(unsigned char *)(result + 4) = 0;
  return result;
}

uint64_t applejpeg_reduce_set_options(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a1) {
    return 0;
  }
  if (*(_DWORD *)a2)
  {
    if (*(_DWORD *)a2 != 1)
    {
      aj_log_error((uint64_t)"Reduce", "Unsupported compression option");
      return 3;
    }
    int v3 = 3;
  }
  else
  {
    int v3 = 2;
  }
  *(_DWORD *)(a1 + 4) = v3;
  if (!*(unsigned char *)(a2 + 4)) {
    return 0;
  }
  return 3;
}

uint64_t applejpeg_reduce_pack_file(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (a2 && *(void *)(a2 + 40) >> 31)
  {
    aj_log_error((uint64_t)"Reduce", "File write buffer size may not be larger than %d", 0x7FFFFFFF);
    return 8;
  }
  else
  {
    return reduce_pack(a1, a2, 0, a3);
  }
}

uint64_t reduce_pack(uint64_t a1, unint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v42 = 0;
  if (!a1 || !(a2 | a3) || !a4)
  {
    aj_log_error((uint64_t)"Reduce", "Input arguments may not be null");
    return 8;
  }
  if (*(unsigned char *)a1)
  {
    aj_log_error((uint64_t)"Reduce", "Input is already packed");
    return 8;
  }
  unint64_t v10 = (void *)(a1 + 134984);
  uint64_t v11 = *(void *)(a1 + 141856);
  if (!v11)
  {
    aj_log_error((uint64_t)"Reduce", "Reducer session object is corrupt");
    return 8;
  }
  unint64_t v12 = (_DWORD *)(a1 + 160472);
  if (a2 && (uint64_t v13 = *(void *)(a2 + 40)) != 0)
  {
    if (*(void *)(a1 + 160552))
    {
      (*(void (**)(void, void))(a1 + 160496))(*(void *)(a1 + 160552), *(void *)(a1 + 160504));
      uint64_t v13 = *(void *)(a2 + 40);
    }
    unint64_t v14 = (void *)(*(uint64_t (**)(uint64_t, void))(a1 + 160488))(v13, *(void *)(a1 + 160504));
    *(void *)(a1 + 160552) = v14;
    if (!v14 || (bzero(v14, *(void *)(a2 + 40)), (uint64_t v15 = *(void *)(a1 + 160552)) == 0))
    {
      aj_log_error((uint64_t)"Reduce", "Could not allocate memory for write buffer");
      return 6;
    }
    int v16 = *(_DWORD *)(a2 + 40);
  }
  else
  {
    uint64_t v15 = a1 + 152256;
    int v16 = 4096;
  }
  if (a3)
  {
    uint64_t v17 = a1 + 160448;
    *(_OWORD *)(a1 + 160448) = *(_OWORD *)a3;
    *unint64_t v12 = *(void *)(a3 + 8);
    *(void *)(a1 + 160464) = *(void *)a3;
    uint64_t v18 = red_mem_skip_callback;
    int v19 = red_mem_rewind_callback;
    int v20 = red_mem_write_callback;
  }
  else
  {
    int v20 = *(uint64_t (**)(void *, int, uint64_t))(a2 + 8);
    uint64_t v18 = *(uint64_t (**)(int, void *))(a2 + 16);
    int v19 = *(uint64_t (**)(uint64_t))(a2 + 24);
    uint64_t v17 = *(void *)(a2 + 32);
  }
  uint64_t v39 = v20;
  uint64_t v40 = v19;
  uint64_t v41 = v18;
  LODWORD(v42) = v16;
  uint64_t v37 = v15;
  uint64_t v38 = v17;
  v34[0] = 0;
  v34[1] = v15;
  int v35 = 0;
  int v36 = v16;
  if (!v19 || !v18)
  {
    aj_log_error((uint64_t)"Reduce", "Cannot use pack without rewind and skip callbacks");
    return 8;
  }
  *unint64_t v10 = v34;
  int v21 = *(_DWORD *)(v11 + 76);
  *(_WORD *)(a1 + 8) = 47;
  *(unsigned char *)(a1 + 10) = 1;
  *(_WORD *)(a1 + 12) = *(_DWORD *)(v11 + 156);
  *(_WORD *)(a1 + 14) = *(_DWORD *)(v11 + 152);
  *(_WORD *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 44) = v21;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  int v22 = *(unsigned __int8 *)(a1 + 4);
  *(_WORD *)(a1 + 64) = 9;
  *(_DWORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 72) = 1;
  *(unsigned char *)(a1 + 74) = v22;
  if (v22 == 3)
  {
    aj_select_semistatic_coder((uint64_t (**)(int))(a1 + 141864));
  }
  else
  {
    if (v22 != 2) {
      return 5;
    }
    aj_select_adaptive_coder((uint64_t (**)(int))(a1 + 141864));
  }
  *(void *)(v11 + 4200) = v11 + 3744;
  *(void *)&double v24 = aj_reduce_init_pack(a1 + 160512, (int *)(a1 + 104), v11 + 4192, (unsigned int **)(v11 + 3744), v11 + 11168, (unsigned int *)(v11 + 144), v11 + 24, v11, a1 + 141864).n128_u64[0];
  if (v23)
  {
    uint64_t v8 = v23;
    aj_log_error((uint64_t)"Reduce", "Failed to initialize reducer for packing", v24);
    return v8;
  }
  uint64_t v25 = write_pre_rimg_headers(a1, v11 + 24, (uint64_t)v34);
  if (v25)
  {
    uint64_t v8 = v25;
    aj_log_error((uint64_t)"Reduce", "Failed to write pre RIMG headers", v26);
    return v8;
  }
  *(void *)(a1 + 88) = v35;
  uint64_t v27 = write_rimg_segment_and_data(a1, v11, v11 + 4192, (uint64_t)v34);
  if (v27)
  {
    uint64_t v8 = v27;
    aj_log_error((uint64_t)"Reduce", "Failed to write RIMG segment and data", v28);
    return v8;
  }
  int v29 = *(unsigned __int8 **)(v11 + 40);
  if (!v29 || *v29 != 217)
  {
    aj_log_error((uint64_t)"Reduce", "No EOI marker in image");
    return 7;
  }
  int v30 = *(_DWORD *)(v11 + 48);
  if (v30 != -9 && *(_DWORD *)(v11 + 24) != ~(-1 << (v30 + 9)) << (23 - v30))
  {
    aj_log_error((uint64_t)"Reduce", "Padding before EOI not all ones, dbits is 0x%08X, expected 0x%08X");
    return 7;
  }
  uint64_t v8 = aj_ostream_write_bytes((uint64_t)v34, 65497, 2);
  if (!v8)
  {
    *(void *)(v11 + 40) = 0;
    int v31 = applejpeg_decode_get_bytes_read(v11);
    int v32 = *(_DWORD *)(v11 + 76);
    if (v31 == v32
      || (int v33 = applejpeg_decode_get_bytes_read(v11),
          *(void *)(a1 + 96) = v35,
          uint64_t v8 = write_rblob_segment_and_data((unsigned __int16 *)(a1 + 76), v11 + 24, (uint64_t)v34, v32 - v33),
          !v8))
    {
      uint64_t v8 = aj_ostream_write_bytes((uint64_t)v34, 65455, 2);
      if (!v8)
      {
        uint64_t v8 = aj_ostream_flush_buffer((uint64_t)v34);
        if (!v8)
        {
          *a4 = v35;
          return finalize_rjpeg_header((unsigned int *)a1, (uint64_t)v34);
        }
      }
    }
  }
  return v8;
}

uint64_t applejpeg_reduce_pack_mem(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a2 && *(void *)(a2 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Reduce", "Destination buffer size may not be larger than %d", 0x7FFFFFFF);
    return 8;
  }
  else
  {
    return reduce_pack(a1, 0, a2, a3);
  }
}

uint64_t applejpeg_reduce_unpack_file(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (a2 && *(void *)(a2 + 40) >> 31)
  {
    aj_log_error((uint64_t)"Reduce", "File write buffer size may not be larger than %d", 0x7FFFFFFF);
    return 8;
  }
  else
  {
    return reduce_unpack(a1, a2, 0, a3);
  }
}

uint64_t reduce_unpack(uint64_t a1, unint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v59 = 0;
  if (!a1 || !(a2 | a3) || !a4)
  {
    aj_log_error((uint64_t)"Reduce", "Input arguments may not be null");
    return 8;
  }
  if (!*(unsigned char *)a1)
  {
    aj_log_error((uint64_t)"Reduce", "Input is not packed");
    return 8;
  }
  uint64_t v8 = (void *)(a1 + 160464);
  if (a2)
  {
    uint64_t v9 = *(void *)(a2 + 40);
    if (v9)
    {
      if (*(void *)(a1 + 160552))
      {
        (*(void (**)(void, void))(a1 + 160496))(*(void *)(a1 + 160552), *(void *)(a1 + 160504));
        uint64_t v9 = *(void *)(a2 + 40);
      }
      unint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, void))(a1 + 160488))(v9, *(void *)(a1 + 160504));
      *(void *)(a1 + 160552) = v10;
      if (!v10 || (bzero(v10, *(void *)(a2 + 40)), int32x2_t v11 = *(int32x2_t *)(a1 + 160552), !*(void *)&v11))
      {
        aj_log_error((uint64_t)"Reduce", "Could not allocate memory for write buffer");
        return 6;
      }
      int v12 = *(_DWORD *)(a2 + 40);
      if (!a3) {
        goto LABEL_12;
      }
LABEL_17:
      uint64_t v16 = a1 + 160448;
      *(_OWORD *)(a1 + 160448) = *(_OWORD *)a3;
      *(_DWORD *)(a1 + 160472) = *(void *)(a3 + 8);
      *uint64_t v8 = *(void *)a3;
      uint64_t v13 = red_mem_skip_callback;
      uint64_t v15 = red_mem_rewind_callback;
      unint64_t v14 = red_mem_write_callback;
      goto LABEL_18;
    }
  }
  int32x2_t v11 = (int32x2_t)(a1 + 152256);
  int v12 = 4096;
  if (a3) {
    goto LABEL_17;
  }
LABEL_12:
  unint64_t v14 = *(uint64_t (**)(void *, int, uint64_t))(a2 + 8);
  uint64_t v13 = *(uint64_t (**)(int, void *))(a2 + 16);
  uint64_t v15 = *(uint64_t (**)(uint64_t))(a2 + 24);
  uint64_t v16 = *(void *)(a2 + 32);
LABEL_18:
  int16x8_t v56 = v14;
  int16x8_t v57 = v15;
  int16x8_t v58 = v13;
  LODWORD(v59) = v12;
  int32x2_t v54 = v11;
  uint64_t v55 = v16;
  v51[0] = 0;
  v51[1] = v11;
  int v52 = 0;
  int v53 = v12;
  int8x8x3_t v68 = 0;
  uint64_t v69 = 0;
  int v67 = 0;
  uint64_t __dst = 0;
  unsigned __int16 v63 = -40;
  uint64_t v17 = aj_ostream_write_bytes((uint64_t)v51, 65496, 2);
  if (v17) {
    goto LABEL_19;
  }
  int v19 = (char *)(*(uint64_t (**)(uint64_t, void))(a1 + 160488))(65537, *(void *)(a1 + 160504));
  *(void *)(a1 + 160544) = v19;
  if (!v19)
  {
    uint64_t v17 = 6;
    goto LABEL_19;
  }
  int v20 = v19;
  uint64_t v65 = 0;
  memset(v64, 0, sizeof(v64));
  bzero(v19, 0x10001uLL);
  unsigned int v62 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v17 = aj_istream_peek_short(a1 + 152136, &v63);
  if (v17) {
    goto LABEL_19;
  }
  int v47 = 0;
  int v21 = 0;
  int v50 = v20 + 2;
  uint64_t v48 = 0;
  int v49 = (int *)(a1 + 148264);
  int v22 = (_DWORD *)(a1 + 68);
  int16x8_t v46 = (char *)(a1 + 64);
  int16x8_t v45 = (char *)(a1 + 72);
  uint64_t v23 = (char *)(a1 + 73);
  int16x8_t v44 = (char *)(a1 + 74);
  while (1)
  {
    if (v63 != 255)
    {
      aj_log_error((uint64_t)"Reduce", "Expected 0xFF while parsing, got 0x%02X");
LABEL_106:
      uint64_t v17 = 7;
      goto LABEL_19;
    }
    LODWORD(v61) = HIBYTE(v63);
    if (v61 == 217 || HIBYTE(v63) == 175)
    {
      unsigned int v62 = 0;
      HIDWORD(v60) = aj_istream_get_pos(a1 + 152136) + 2;
      uint64_t v24 = aj_istream_move_to_position(a1 + 152136, HIDWORD(v60));
      if (v24) {
        goto LABEL_104;
      }
    }
    else if (aj_get_segment_id_and_length(a1 + 152136, &v62, (_DWORD *)&v61 + 1, &v61, (_DWORD *)&v60 + 1, 1))
    {
      goto LABEL_109;
    }
    if ((int)v61 > 193)
    {
      switch((int)v61)
      {
        case 217:
          uint64_t v24 = aj_ostream_write_bytes((uint64_t)v51, 65497, 2);
          if (v24) {
            goto LABEL_104;
          }
          uint64_t v24 = aj_ostream_flush_buffer((uint64_t)v51);
          if (v24) {
            goto LABEL_104;
          }
          goto LABEL_94;
        case 218:
          aj_log_error((uint64_t)"Reduce", "Unexpected marker in reduced file");
          goto LABEL_106;
        case 219:
          int v21 = 1;
          goto LABEL_55;
        case 220:
          break;
        case 221:
          goto LABEL_55;
        default:
          if (v61 == 196)
          {
            int v47 = 1;
            goto LABEL_55;
          }
          if (v61 == 194)
          {
            aj_log_error((uint64_t)"Reduce", "Unreduce of progressive images not supported");
            goto LABEL_120;
          }
          break;
      }
LABEL_99:
      char *v20 = -1;
      v20[1] = v61;
      uint64_t v30 = aj_istream_memcpy(a1 + 152136, v50, v62, &v60);
      if (!v30)
      {
        int v42 = v62;
        if (v62 != v60) {
          goto LABEL_101;
        }
LABEL_93:
        uint64_t v24 = aj_ostream_write_buf((uint64_t)v51, v20, (v42 + 2));
        if (v24) {
          goto LABEL_104;
        }
        goto LABEL_94;
      }
LABEL_107:
      uint64_t v17 = v30;
LABEL_108:
      aj_log_error((uint64_t)"Reduce", "Error %d while copying headers to memory", v30);
      goto LABEL_19;
    }
    if ((int)v61 > 162)
    {
      switch(v61)
      {
        case 0xA3:
          LODWORD(v61) = 218;
          HIDWORD(v48) = 1;
          goto LABEL_55;
        case 0xC0:
          LODWORD(v48) = 1;
LABEL_55:
          char *v20 = -1;
          v20[1] = v61;
          uint64_t v30 = aj_istream_memcpy(a1 + 152136, v50, v62, &v60);
          if (v30) {
            goto LABEL_107;
          }
          if (v62 == v60)
          {
            int8x8x3_t v68 = v20 + 2;
            uint64_t v69 = 0xFFFFLL;
            double inited = aj_istream_init_mem((uint64_t)v64, (uint64_t *)&v68, 0, 0);
            if ((int)v61 > 217)
            {
              switch(v61)
              {
                case 0xDA:
                  uint64_t sos = aj_read_sos((uint64_t)v64, v49);
                  break;
                case 0xDB:
                  uint64_t sos = aj_read_dqt((uint64_t)v64, (uint64_t)v49);
                  break;
                case 0xDD:
                  uint64_t sos = aj_read_dri((uint64_t)v64, (uint64_t)v49);
                  break;
                default:
LABEL_117:
                  aj_log_error((uint64_t)"Reduce", "Asked to parse unknown marker", inited);
                  uint64_t v17 = 4;
                  goto LABEL_19;
              }
            }
            else if (v61 == 192 || v61 == 194)
            {
              uint64_t sos = aj_read_sof((uint64_t)v64, (unsigned int *)v49, v61);
            }
            else
            {
              if (v61 != 196) {
                goto LABEL_117;
              }
              uint64_t sos = aj_read_dht((uint64_t)v64, (uint64_t)v49);
            }
            uint64_t v17 = sos;
            if (sos) {
              goto LABEL_19;
            }
            uint64_t v24 = aj_check_huffman_tables((uint64_t)v49);
            if (v24)
            {
LABEL_104:
              uint64_t v17 = v24;
              goto LABEL_19;
            }
            int v42 = v62;
            goto LABEL_93;
          }
LABEL_101:
          uint64_t v17 = 9;
          goto LABEL_108;
        case 0xAF:
LABEL_109:
          uint64_t v17 = 0;
          *a4 = v52;
          return v17;
      }
      goto LABEL_99;
    }
    if (v61 == 161) {
      break;
    }
    if (v61 != 162) {
      goto LABEL_99;
    }
    v70[0] = 0;
    uint64_t v24 = aj_istream_memcpy(a1 + 152136, (char *)&__dst, 2, v70);
    if (v24) {
      goto LABEL_104;
    }
    char v25 = BYTE1(__dst);
    BYTE1(__dst) = __dst;
    LOBYTE(__dst) = v25;
    if ((unsigned __int16)__dst != 7)
    {
      aj_log_error((uint64_t)"Reduce", "Bad RBLOB segment length: %u");
      goto LABEL_122;
    }
    v70[0] = 0;
    uint64_t v24 = aj_istream_memcpy(a1 + 152136, (char *)&__dst + 4, 4, v70);
    if (v24) {
      goto LABEL_104;
    }
    uint64_t v26 = 0;
    unint64_t v27 = 0x300000000;
    do
    {
      char v28 = *((unsigned char *)&__dst + v26 + 4) ^ *((unsigned char *)&__dst + HIDWORD(v27) + 4);
      *((unsigned char *)&__dst + v26 + 4) = v28;
      char v29 = *((unsigned char *)&__dst + HIDWORD(v27) + 4) ^ v28;
      *((unsigned char *)&__dst + HIDWORD(v27) + 4) = v29;
      *((unsigned char *)&__dst + v26++ + 4) ^= v29;
      v27 -= 0x100000000;
    }
    while (v26 != 2);
    if (!HIDWORD(__dst))
    {
      aj_log_error((uint64_t)"Reduce", "Bad RBLOB data size: %u");
      goto LABEL_122;
    }
    v70[0] = 0;
    uint64_t v24 = aj_istream_memcpy(a1 + 152136, (char *)&v67, 1, v70);
    if (v24) {
      goto LABEL_104;
    }
    if ((_BYTE)v67)
    {
      aj_log_error((uint64_t)"Reduce", "RBLOB compression method unsupported: %u");
      goto LABEL_120;
    }
    uint64_t v24 = copy_input_to_output(a1 + 152136, (uint64_t)v51, SHIDWORD(__dst));
    if (v24) {
      goto LABEL_104;
    }
LABEL_94:
    unsigned int v62 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    uint64_t v24 = aj_istream_peek_short(a1 + 152136, &v63);
    if (v24) {
      goto LABEL_104;
    }
  }
  if (!v47 || !v21 || !HIDWORD(v48) || !v48)
  {
    aj_log_error((uint64_t)"Reduce", "File is missing SOF, DQT, DHT or RSOS. Cannot unpack.");
    goto LABEL_106;
  }
  uint64_t v24 = aj_check_components_and_decimation(v49);
  if (v24) {
    goto LABEL_104;
  }
  *(void *)(a1 + 88) = (int)(aj_istream_get_pos(a1 + 152136) - 2);
  int pos = aj_istream_get_pos(a1 + 152136);
  v70[0] = 0;
  uint64_t v24 = aj_istream_memcpy(a1 + 152136, v46, 2, v70);
  if (v24) {
    goto LABEL_104;
  }
  char v34 = *(unsigned char *)(a1 + 65);
  *(unsigned char *)(a1 + 65) = *(unsigned char *)(a1 + 64);
  *(unsigned char *)(a1 + 64) = v34;
  if (*(_WORD *)(a1 + 64) != 9)
  {
    aj_log_error((uint64_t)"Reduce", "Bad/unsupported RIMG segment length: %u");
    goto LABEL_120;
  }
  v70[0] = 0;
  uint64_t v24 = aj_istream_memcpy(a1 + 152136, (char *)(a1 + 68), 4, v70);
  if (v24) {
    goto LABEL_104;
  }
  unint64_t v35 = 0x300000000;
  for (uint64_t i = 68; i != 70; ++i)
  {
    char v37 = *(unsigned char *)(a1 + i) ^ *((unsigned char *)v22 + HIDWORD(v35));
    *(unsigned char *)(a1 + i) = v37;
    char v38 = *((unsigned char *)v22 + HIDWORD(v35)) ^ v37;
    *((unsigned char *)v22 + HIDWORD(v35)) = v38;
    *(unsigned char *)(a1 + i) ^= v38;
    v35 -= 0x100000000;
  }
  if (!*v22)
  {
    aj_log_error((uint64_t)"Reduce", "Bad RIMG data size: %u");
    goto LABEL_122;
  }
  int16x8_t v43 = v23;
  v70[0] = 0;
  uint64_t v24 = aj_istream_memcpy(a1 + 152136, v45, 1, v70);
  if (v24) {
    goto LABEL_104;
  }
  if (*v45 != 1)
  {
    aj_log_error((uint64_t)"Reduce", "Unsupported number of scans: %d");
    goto LABEL_120;
  }
  v70[0] = 0;
  uint64_t v24 = aj_istream_memcpy(a1 + 152136, v23, 1, v70);
  if (v24) {
    goto LABEL_104;
  }
  v70[0] = 0;
  uint64_t v24 = aj_istream_memcpy(a1 + 152136, v44, 1, v70);
  if (v24) {
    goto LABEL_104;
  }
  if ((*v44 & 0xFE) == 2)
  {
    int v39 = pos + *(unsigned __int16 *)v46;
    if (v39 != aj_istream_get_pos(a1 + 152136))
    {
      aj_log_error((uint64_t)"Reduce", "Segment length did not match number of bytes read");
LABEL_122:
      uint64_t v17 = 11;
      goto LABEL_19;
    }
    uint64_t v24 = initialize_unreduce(a1, a1 + 152136);
    if (v24) {
      goto LABEL_104;
    }
    int v40 = aj_istream_get_pos(a1 + 152136);
    int v41 = *(_DWORD *)(a1 + 68);
    uint64_t v24 = unpack_rimg_data(a1, a1 + 148224, a1 + 152136, v51);
    if (v24) {
      goto LABEL_104;
    }
    if (v41 + v40 != aj_istream_get_pos(a1 + 152136))
    {
      aj_istream_get_pos(a1 + 152136);
      aj_log_error((uint64_t)"Reduce", "RIMG size does not match amount of data read. Image is corrupt. (%d != %d)");
      goto LABEL_106;
    }
    int v47 = 1;
    uint64_t v48 = 0x100000001;
    int v21 = 1;
    uint64_t v23 = v43;
    goto LABEL_94;
  }
  aj_log_error((uint64_t)"Reduce", "RIMG compression scheme not supported: %u");
LABEL_120:
  uint64_t v17 = 3;
LABEL_19:
  aj_log_error((uint64_t)"Reduce", "Unpacking of headers failed.");
  return v17;
}

uint64_t applejpeg_reduce_unpack_mem(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a2 && *(void *)(a2 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Reduce", "Destination buffer size may not be larger than %d", 0x7FFFFFFF);
    return 8;
  }
  else
  {
    return reduce_unpack(a1, 0, a2, a3);
  }
}

void *applejpeg_reduce_close(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    unint64_t v2 = result + 17732;
    int v12 = (uint64_t (*)(void *, uint64_t))result[20062];
    uint64_t v3 = result[20063];
    BOOL v4 = (void *)result[17732];
    if (v4)
    {
      applejpeg_decode_destroy(v4);
      void *v2 = 0;
    }
    else
    {
      uint64_t v5 = 0;
      char v6 = 1;
      do
      {
        uint64_t v7 = 0;
        char v8 = v6;
        uint64_t v9 = (uint64_t)&v1[v5 + 18962];
        do
        {
          if (!aj_huffman_decode_is_static_table(*(char **)(v9 + v7)))
          {
            unint64_t v10 = *(void **)(v9 + v7);
            if (v10)
            {
              v12(v10, v3);
              *(void *)(v9 + v7) = 0;
            }
          }
          v7 += 16;
        }
        while (v7 != 64);
        char v6 = 0;
        uint64_t v5 = 1;
      }
      while ((v8 & 1) != 0);
    }
    int32x2_t v11 = v2 + 2334;
    do
    {
      if (*v11)
      {
        v12((void *)*v11, v3);
        *int32x2_t v11 = 0;
      }
      ++v11;
    }
    while (v11 < v1 + 20070);
    return (void *)v12(v1, v3);
  }
  return result;
}

uint64_t applejpeg_reduce_dump_contexts()
{
  return 3;
}

uint64_t parse_reduced_file(uint64_t a1, char *a2)
{
  __int16 __dst = 0;
  int v33 = 0;
  uint64_t result = aj_istream_memcpy(a1, (char *)&__dst, 2, &v33);
  if (result) {
    return result;
  }
  char v5 = HIBYTE(__dst);
  HIBYTE(__dst) = __dst;
  LOBYTE(__dst) = v5;
  if (__dst != -96) {
    return 4;
  }
  char v6 = (unsigned __int16 *)(a2 + 8);
  int pos = aj_istream_get_pos(a1);
  int v33 = 0;
  uint64_t result = aj_istream_memcpy(a1, a2 + 8, 2, &v33);
  if (result) {
    return result;
  }
  char v8 = a2[9];
  a2[9] = a2[8];
  a2[8] = v8;
  if (*((_WORD *)a2 + 4) != 47) {
    return 11;
  }
  int v33 = 0;
  uint64_t result = aj_istream_memcpy(a1, a2 + 10, 1, &v33);
  if (!result)
  {
    if (a2[10] > 1u) {
      return 3;
    }
    int v33 = 0;
    uint64_t result = aj_istream_memcpy(a1, a2 + 12, 2, &v33);
    if (!result)
    {
      char v9 = a2[13];
      a2[13] = a2[12];
      a2[12] = v9;
      int v33 = 0;
      uint64_t result = aj_istream_memcpy(a1, a2 + 14, 2, &v33);
      if (!result)
      {
        char v10 = a2[15];
        a2[15] = a2[14];
        a2[14] = v10;
        if (*((_WORD *)a2 + 7) && *((_WORD *)a2 + 6))
        {
          int v33 = 0;
          uint64_t result = aj_istream_memcpy(a1, a2 + 16, 2, &v33);
          if (result) {
            return result;
          }
          char v11 = a2[17];
          a2[17] = a2[16];
          a2[16] = v11;
          int v33 = 0;
          uint64_t result = aj_istream_memcpy(a1, a2 + 24, 8, &v33);
          if (result) {
            return result;
          }
          uint64_t v13 = 0;
          unint64_t v14 = 0x700000000;
          int v12 = a2 + 24;
          do
          {
            char v15 = v12[v13] ^ v12[HIDWORD(v14)];
            v12[v13] = v15;
            char v16 = v12[HIDWORD(v14)] ^ v15;
            v12[HIDWORD(v14)] = v16;
            v12[v13++] ^= v16;
            v14 -= 0x100000000;
          }
          while (v13 != 4);
          int v33 = 0;
          uint64_t result = aj_istream_memcpy(a1, a2 + 32, 8, &v33);
          if (result) {
            return result;
          }
          uint64_t v18 = 0;
          unint64_t v19 = 0x700000000;
          uint64_t v17 = a2 + 32;
          do
          {
            char v20 = v17[v18] ^ v17[HIDWORD(v19)];
            v17[v18] = v20;
            char v21 = v17[HIDWORD(v19)] ^ v20;
            v17[HIDWORD(v19)] = v21;
            v17[v18++] ^= v21;
            v19 -= 0x100000000;
          }
          while (v18 != 4);
          int v33 = 0;
          uint64_t result = aj_istream_memcpy(a1, a2 + 40, 2, &v33);
          if (result) {
            return result;
          }
          char v22 = a2[41];
          a2[41] = a2[40];
          a2[40] = v22;
          int v33 = 0;
          uint64_t result = aj_istream_memcpy(a1, a2 + 44, 4, &v33);
          if (result) {
            return result;
          }
          uint64_t v24 = 0;
          unint64_t v25 = 0x300000000;
          uint64_t v23 = a2 + 44;
          do
          {
            char v26 = *((unsigned char *)v23 + v24) ^ *((unsigned char *)v23 + HIDWORD(v25));
            *((unsigned char *)v23 + v24) = v26;
            char v27 = *((unsigned char *)v23 + HIDWORD(v25)) ^ v26;
            *((unsigned char *)v23 + HIDWORD(v25)) = v27;
            *((unsigned char *)v23 + v24++) ^= v27;
            v25 -= 0x100000000;
          }
          while (v24 != 2);
          if (*v23)
          {
            uint64_t v28 = 0;
            char v29 = a2 + 48;
            while (1)
            {
              uint64_t v30 = (unsigned __int8 *)&v29[v28];
              int v33 = 0;
              uint64_t result = aj_istream_memcpy(a1, &v29[v28], 1, &v33);
              if (result) {
                break;
              }
              if (*v30)
              {
                aj_log_error((uint64_t)"Reduce", "Unsupported capability flag: capability[%i] = 0x%02X", v28, *v30);
                return 3;
              }
              if (++v28 == 16)
              {
                int v31 = pos + *v6;
                if (v31 == aj_istream_get_pos(a1)) {
                  return 0;
                }
                aj_log_error((uint64_t)"Reduce", "Segment length did not match number of bytes read");
                return 11;
              }
            }
            return result;
          }
          aj_log_error((uint64_t)"Reduce", "Illegal original size: %u");
        }
        else
        {
          aj_log_error((uint64_t)"Reduce", "Illegal image dimensions: %dx%d");
        }
        return 11;
      }
    }
  }
  return result;
}

uint64_t can_jpeg_be_reduced(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 144) | 2) != 3) {
    goto LABEL_8;
  }
  int v1 = *(_DWORD *)(a1 + 160);
  if (*(int *)(a1 + 176) > 2 || v1 >= 3)
  {
    aj_log_error((uint64_t)"Reduce", "Unsupported decimation (VF|HF): %d|%d", *(_DWORD *)(a1 + 176), v1);
    return 3;
  }
  if (!*(unsigned char *)(a1 + 228))
  {
    if (!*(unsigned char *)(a1 + 230)) {
      return 1;
    }
    aj_log_error((uint64_t)"Reduce", "Lossless not yet supported.");
  }
  else
  {
LABEL_8:
    aj_log_error((uint64_t)"Reduce", "Image not yet supported.");
  }
  return 0;
}

uint64_t write_pre_rimg_headers(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = aj_ostream_write_bytes(a3, 1380601927, 4);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a3, 65440, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 8), 2);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int8 *)(a1 + 10), 1);
        if (!result)
        {
          uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 12), 2);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 14), 2);
            if (!result)
            {
              uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 16), 2);
              if (!result)
              {
                uint64_t result = write_variable_size_data(a3, *(void *)(a1 + 24), 8);
                if (!result)
                {
                  uint64_t result = write_variable_size_data(a3, *(void *)(a1 + 32), 8);
                  if (!result)
                  {
                    uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int16 *)(a1 + 40), 2);
                    if (!result)
                    {
                      uint64_t result = aj_ostream_write_bytes(a3, *(_DWORD *)(a1 + 44), 4);
                      if (!result)
                      {
                        uint64_t v7 = 0;
                        uint64_t v8 = a1 + 160488;
                        uint64_t v9 = a1 + 48;
                        do
                        {
                          uint64_t result = aj_ostream_write_bytes(a3, *(unsigned __int8 *)(v9 + v7), 1);
                          if (result) {
                            return result;
                          }
                          ++v7;
                        }
                        while (v7 != 16);
                        uint64_t result = aj_istream_move_to_position(a2, 2);
                        if (!result)
                        {
                          char v10 = (char *)(*(uint64_t (**)(uint64_t, void))v8)(65537, *(void *)(v8 + 16));
                          *(void *)(v8 + 56) = v10;
                          if (!v10) {
                            return 6;
                          }
                          char v11 = v10;
                          bzero(v10, 0x10001uLL);
                          while (1)
                          {
                            unsigned __int16 v25 = 0;
                            uint64_t v12 = aj_istream_peek_short(a2, &v25);
                            if (v12) {
                              return v12;
                            }
                            if (v25 != 255)
                            {
                              aj_log_error((uint64_t)"Reduce", "Expected 0xFF while parsing, got 0x%02X", v25);
                              return 11;
                            }
                            unsigned int v24 = 0;
                            uint64_t v23 = 0;
                            int v13 = HIBYTE(v25);
                            int v21 = v13;
                            int v22 = 0;
                            switch(v13)
                            {
                              case 208:
                              case 209:
                              case 210:
                              case 211:
                              case 212:
                              case 213:
                              case 214:
                              case 215:
                              case 217:
                                aj_log_error((uint64_t)"Reduce", "EOI or RST marker encountered while parsing headers (marker = 0x%02X", v13);
                                return 11;
                              case 216:
                                int pos = aj_istream_get_pos(a2);
                                uint64_t v15 = aj_istream_move_to_position(a2, (pos + 2));
                                if (v15) {
                                  return v15;
                                }
                                int v16 = 0;
                                goto LABEL_32;
                              case 218:
                                int v16 = 1;
                                goto LABEL_26;
                              default:
                                int v16 = 0;
LABEL_26:
                                if (aj_get_segment_id_and_length(a2, &v24, (_DWORD *)&v23 + 1, &v21, &v23, 1))goto LABEL_32; {
                                char v17 = v21;
                                }
                                if (v21 == 218)
                                {
                                  char v17 = -93;
                                  int v21 = 163;
                                }
                                *char v11 = -1;
                                v11[1] = v17;
                                uint64_t v18 = aj_istream_memcpy(a2, v11 + 2, v24, &v22);
                                if (v18)
                                {
                                  uint64_t v19 = v18;
                                  goto LABEL_43;
                                }
                                if (v24 != v22)
                                {
                                  uint64_t v19 = 9;
LABEL_43:
                                  aj_log_error((uint64_t)"Reduce", "Error %d while copying headers to memory", v18);
                                  return v19;
                                }
                                uint64_t v15 = aj_ostream_write_buf(a3, v11, v24 + 2);
                                if (v15) {
                                  return v15;
                                }
LABEL_32:
                                uint64_t result = 0;
                                if (v16) {
                                  return result;
                                }
                                break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_rimg_segment_and_data(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = aj_ostream_write_bytes(a4, 65441, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a4, *(unsigned __int16 *)(a1 + 64), 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a4, *(_DWORD *)(a1 + 68), 4);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 72), 1);
        if (!result)
        {
          uint64_t result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 73), 1);
          if (!result)
          {
            uint64_t result = aj_ostream_write_bytes(a4, *(unsigned __int8 *)(a1 + 74), 1);
            if (!result)
            {
              int v9 = *(_DWORD *)(a4 + 16);
              uint64_t result = aj_istream_move_to_position(*(void *)(a2 + 11280), *(unsigned int *)(*(void *)a3 + 3420));
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 141872))(a1 + 134936);
                if (!result)
                {
                  uint64_t result = aj_pack_all(a3, (uint64_t *)(a1 + 104), a2 + 11280);
                  if (!result)
                  {
                    uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 141936))(a1 + 134936);
                    if (!result) {
                      *(_DWORD *)(a1 + 68) = *(_DWORD *)(a4 + 16) - v9;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t write_variable_size_data(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = a3;
  int v4 = a2;
  if (a3 >= 5)
  {
    uint64_t result = aj_ostream_write_bytes(a1, SHIDWORD(a2), 4);
    if (result) {
      return result;
    }
    v3 -= 4;
  }
  return aj_ostream_write_bytes(a1, v4, v3);
}

uint64_t write_rblob_segment_and_data(unsigned __int16 *a1, uint64_t a2, uint64_t a3, int a4)
{
  *a1 = 7;
  *((_DWORD *)a1 + 1) = 0;
  *((unsigned char *)a1 + 8) = 0;
  uint64_t result = aj_ostream_write_bytes(a3, 65442, 2);
  if (!result)
  {
    uint64_t result = aj_ostream_write_bytes(a3, *a1, 2);
    if (!result)
    {
      uint64_t result = aj_ostream_write_bytes(a3, *((_DWORD *)a1 + 1), 4);
      if (!result)
      {
        uint64_t result = aj_ostream_write_bytes(a3, *((unsigned __int8 *)a1 + 8), 1);
        if (!result)
        {
          int v9 = *(_DWORD *)(a3 + 16);
          uint64_t result = copy_input_to_output(a2, a3, a4);
          if (!result) {
            *((_DWORD *)a1 + 1) = *(_DWORD *)(a3 + 16) - v9;
          }
        }
      }
    }
  }
  return result;
}

uint64_t finalize_rjpeg_header(unsigned int *a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 16);
  unsigned int v7 = v4;
  uint64_t result = overwrite_uint32(a2, &v7, 0x21u, a1[11]);
  if (!result)
  {
    uint64_t result = overwrite_uint32(a2, &v7, a1[22] + 4, a1[17]);
    if (!result)
    {
      unsigned int v6 = a1[20];
      if (!v6 || (uint64_t result = overwrite_uint32(a2, &v7, a1[24] + 4, v6), !result))
      {
        (*(void (**)(void, void))(a2 + 56))(v4 - v7, *(void *)(a2 + 32));
        return 0;
      }
    }
  }
  return result;
}

uint64_t red_mem_write_callback(void *__src, int a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) < (unint64_t)a2) {
    return 1;
  }
  uint64_t v5 = a2;
  memcpy(*(void **)a3, __src, a2);
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a3 + 8) - v5;
  *(void *)a3 += v5;
  *(void *)(a3 + 8) = v6;
  return result;
}

uint64_t red_mem_rewind_callback(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 24);
  *(void *)a1 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = v1;
  return 0;
}

uint64_t red_mem_skip_callback(int a1, void *a2)
{
  uint64_t v2 = a2[1] - a1;
  *a2 += a1;
  a2[1] = v2;
  return 0;
}

uint64_t copy_input_to_output(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (!a3) {
    return 0;
  }
  int v3 = a3;
  while (1)
  {
    unsigned int v8 = 0;
    int v6 = v3 >= 1024 ? 1024 : v3;
    uint64_t result = aj_istream_memcpy(a1, __src, v6, &v8);
    if (result) {
      break;
    }
    uint64_t result = aj_ostream_write_buf(a2, __src, v8);
    if (result) {
      break;
    }
    v3 -= v8;
    if (!v3) {
      return 0;
    }
  }
  return result;
}

uint64_t overwrite_uint32(uint64_t a1, unsigned int *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v10 = bswap32(a4);
  unsigned int v7 = *a2;
  if (*a2 > a3)
  {
    (*(void (**)(void))(a1 + 48))(*(void *)(a1 + 32));
    unsigned int v7 = 0;
    *a2 = 0;
  }
  uint64_t v8 = a3 - v7;
  (*(void (**)(uint64_t, void))(a1 + 56))(v8, *(void *)(a1 + 32));
  *a2 += v8;
  uint64_t result = (*(uint64_t (**)(unsigned int *, uint64_t, void))(a1 + 40))(&v10, 4, *(void *)(a1 + 32));
  if (!result) {
    *a2 += 4;
  }
  return result;
}

uint64_t initialize_unreduce(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 134976) = a1 + 152136;
  int v4 = *(unsigned __int8 *)(a1 + 74);
  if (v4 == 3)
  {
    aj_select_semistatic_coder((uint64_t (**)(int))(a1 + 141864));
    return aj_reduce_init_unpack(a1 + 160512, (int *)(a1 + 104), a1 + 141952, (int **)(a1 + 151688), (void *)(a1 + 148224), (unsigned int *)(a1 + 148264), a2, a1 + 160488, a1 + 141864);
  }
  if (v4 == 2)
  {
    aj_select_adaptive_coder((uint64_t (**)(int))(a1 + 141864));
    return aj_reduce_init_unpack(a1 + 160512, (int *)(a1 + 104), a1 + 141952, (int **)(a1 + 151688), (void *)(a1 + 148224), (unsigned int *)(a1 + 148264), a2, a1 + 160488, a1 + 141864);
  }
  return 5;
}

uint64_t unpack_rimg_data(uint64_t a1, uint64_t a2, uint64_t a3, int32x2_t *a4)
{
  uint64_t result = aj_istream_move_to_position(a3, (*(_DWORD *)(a1 + 88) + 11));
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 141880))(a1 + 134936);
    if (!result)
    {
      uint64_t result = aj_unpack_all((uint64_t *)(a1 + 104), a2, a4);
      if (!result)
      {
        uint64_t v8 = *(uint64_t (**)(uint64_t))(a1 + 141944);
        return v8(a1 + 134936);
      }
    }
  }
  return result;
}

uint64_t aj_idct_s1_16x16_bilinear(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = a1[4];
  int16x8_t v7 = a1[5];
  int16x8_t v8 = a1[6];
  int16x8_t v9 = vaddq_s16(v8, v4);
  int16x8_t v10 = vaddq_s16(*a1, v6);
  int16x8_t v11 = vsubq_s16(*a1, v6);
  int16x8_t v12 = vqrdmulhq_lane_s16(vsubq_s16(v4, v8), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v13 = vqshlq_n_s16(a1[7], 1uLL);
  int16x8_t v14 = vaddq_s16(v5, v7);
  int16x8_t v15 = vsubq_s16(v7, v5);
  int16x8_t v16 = vaddq_s16(v3, v13);
  int16x8_t v17 = vsubq_s16(v3, v13);
  int16x8_t v18 = vaddq_s16(v16, v14);
  int16x8_t v19 = vaddq_s16(v9, v12);
  int16x8_t v20 = vaddq_s16(v10, v19);
  int16x8_t v21 = vsubq_s16(v10, v19);
  int16x8_t v22 = vqrdmulhq_lane_s16(vaddq_s16(v15, v17), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v23 = vqrdmulhq_lane_s16(vsubq_s16(v16, v14), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v24 = vsubq_s16(v11, v12);
  int16x8_t v25 = vaddq_s16(v11, v12);
  int16x8_t v26 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v17, (int16x4_t)0x30FC273D5A824546, 2), v17), v22);
  int16x8_t v27 = vaddq_s16(vqrdmulhq_lane_s16(v15, (int16x4_t)0x30FC273D5A824546, 0), v22);
  int16x8_t v28 = vaddq_s16(v18, v26);
  int16x8_t v29 = vaddq_s16(v26, v23);
  int16x8_t v30 = vaddq_s16(v27, v23);
  int16x8_t v31 = vaddq_s16(v20, v28);
  int16x8_t v32 = vaddq_s16(v25, v29);
  int16x8_t v33 = vaddq_s16(v24, v30);
  int16x8_t v34 = vaddq_s16(v21, v27);
  int16x8_t v35 = vsubq_s16(v21, v27);
  int16x8_t v36 = vsubq_s16(v24, v30);
  int16x8_t v37 = vsubq_s16(v25, v29);
  int16x8_t v38 = vsubq_s16(v20, v28);
  int32x4_t v39 = (int32x4_t)vtrn1q_s16(v31, v32);
  int32x4_t v40 = (int32x4_t)vtrn2q_s16(v31, v32);
  int32x4_t v41 = (int32x4_t)vtrn1q_s16(v33, v34);
  int32x4_t v42 = (int32x4_t)vtrn2q_s16(v33, v34);
  int32x4_t v43 = (int32x4_t)vtrn1q_s16(v35, v36);
  int32x4_t v44 = (int32x4_t)vtrn2q_s16(v35, v36);
  int32x4_t v45 = (int32x4_t)vtrn1q_s16(v37, v38);
  int32x4_t v46 = (int32x4_t)vtrn2q_s16(v37, v38);
  int64x2_t v47 = (int64x2_t)vtrn1q_s32(v39, v41);
  int64x2_t v48 = (int64x2_t)vtrn2q_s32(v39, v41);
  int64x2_t v49 = (int64x2_t)vtrn1q_s32(v40, v42);
  int64x2_t v50 = (int64x2_t)vtrn2q_s32(v40, v42);
  int64x2_t v51 = (int64x2_t)vtrn1q_s32(v43, v45);
  int64x2_t v52 = (int64x2_t)vtrn2q_s32(v43, v45);
  int64x2_t v53 = (int64x2_t)vtrn1q_s32(v44, v46);
  int64x2_t v54 = (int64x2_t)vtrn2q_s32(v44, v46);
  int16x8_t v55 = (int16x8_t)vtrn1q_s64(v47, v51);
  int16x8_t v56 = (int16x8_t)vtrn2q_s64(v47, v51);
  int16x8_t v57 = (int16x8_t)vtrn1q_s64(v49, v53);
  int16x8_t v58 = (int16x8_t)vtrn2q_s64(v49, v53);
  int16x8_t v59 = (int16x8_t)vtrn1q_s64(v48, v52);
  int16x8_t v60 = (int16x8_t)vtrn2q_s64(v48, v52);
  int16x8_t v61 = (int16x8_t)vtrn1q_s64(v50, v54);
  int16x8_t v62 = (int16x8_t)vtrn2q_s64(v50, v54);
  uint64_t v64 = *a2;
  uint64_t v65 = a2[1];
  unsigned __int16 v63 = a2 + 2;
  uint64_t v66 = *v63;
  uint64_t v67 = v63[1];
  v63 += 2;
  uint64_t v68 = *v63;
  uint64_t v69 = v63[1];
  v63 += 2;
  uint64_t v70 = *v63;
  uint64_t v71 = v63[1];
  v63 += 2;
  int16x8_t v72 = vaddq_s16(v60, v59);
  int16x8_t v73 = vaddq_s16(v55, v56);
  int16x8_t v74 = vsubq_s16(v55, v56);
  int16x8_t v75 = vqrdmulhq_lane_s16(vsubq_s16(v59, v60), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v76 = vqshlq_n_s16(v62, 1uLL);
  int16x8_t v77 = vaddq_s16(v61, v58);
  int16x8_t v78 = vsubq_s16(v58, v61);
  int16x8_t v79 = vaddq_s16(v57, v76);
  int16x8_t v80 = vsubq_s16(v57, v76);
  int16x8_t v81 = vaddq_s16(v79, v77);
  int16x8_t v82 = vaddq_s16(v72, v75);
  int16x8_t v83 = vaddq_s16(v73, v82);
  int16x8_t v84 = vsubq_s16(v73, v82);
  int16x8_t v85 = vqrdmulhq_lane_s16(vaddq_s16(v78, v80), (int16x4_t)0x30FC273D5A824546, 3);
  int16x8_t v86 = vqrdmulhq_lane_s16(vsubq_s16(v79, v77), (int16x4_t)0x30FC273D5A824546, 1);
  int16x8_t v87 = vsubq_s16(v74, v75);
  int16x8_t v88 = vaddq_s16(v74, v75);
  int16x8_t v89 = vsubq_s16(vaddq_s16(vqrdmulhq_lane_s16(v80, (int16x4_t)0x30FC273D5A824546, 2), v80), v85);
  int16x8_t v90 = vaddq_s16(vqrdmulhq_lane_s16(v78, (int16x4_t)0x30FC273D5A824546, 0), v85);
  int16x8_t v91 = vaddq_s16(v81, v89);
  int16x8_t v92 = vaddq_s16(v89, v86);
  int16x8_t v93 = vaddq_s16(v90, v86);
  int16x8_t v94 = vaddq_s16(v83, v91);
  int16x8_t v95 = vaddq_s16(v88, v92);
  int16x8_t v96 = vaddq_s16(v87, v93);
  int16x8_t v97 = vaddq_s16(v84, v90);
  int16x8_t v98 = vsubq_s16(v84, v90);
  int16x8_t v99 = vsubq_s16(v87, v93);
  int16x8_t v100 = vsubq_s16(v88, v92);
  int16x8_t v101 = vsubq_s16(v83, v91);
  _X3 = (char *)(v64 + a3);
  _X4 = (char *)(v65 + a3);
  _X5 = (char *)(v66 + a3);
  _X6 = (char *)(v67 + a3);
  _X7 = (char *)(v68 + a3);
  _X9 = (char *)(v69 + a3);
  _X10 = (char *)(v70 + a3);
  _X11 = (char *)(v71 + a3);
  *(int8x8_t *)v94.i8 = vadd_s8(vqrshrn_n_s16(v94, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v95.i8 = vadd_s8(vqrshrn_n_s16(v95, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v96.i8 = vadd_s8(vqrshrn_n_s16(v96, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v97.i8 = vadd_s8(vqrshrn_n_s16(v97, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v98.i8 = vadd_s8(vqrshrn_n_s16(v98, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v99.i8 = vadd_s8(vqrshrn_n_s16(v99, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v100.i8 = vadd_s8(vqrshrn_n_s16(v100, 5uLL), (int8x8_t)0x8080808080808080);
  *(int8x8_t *)v101.i8 = vadd_s8(vqrshrn_n_s16(v101, 5uLL), (int8x8_t)0x8080808080808080);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  v122.i64[0] = 0x3000300030003;
  v122.i64[1] = 0x3000300030003;
  uint16x8_t v123 = vmull_u8(*(uint8x8_t *)v94.i8, (uint8x8_t)0x303030303030303);
  uint16x8_t v124 = vmull_u8(*(uint8x8_t *)v95.i8, (uint8x8_t)0x303030303030303);
  v78.i64[0] = v94.i64[0];
  v83.i64[0] = v94.i64[0];
  v87.i64[0] = v95.i64[0];
  v46.i64[0] = v95.i64[0];
  int16x8_t v125 = (int16x8_t)vaddw_u8(v123, (uint8x8_t)*(_OWORD *)&vsliq_n_s64((int64x2_t)v78, (int64x2_t)v94, 8uLL));
  int16x8_t v126 = (int16x8_t)vaddw_u8(v123, (uint8x8_t)*(_OWORD *)&vsriq_n_s64((int64x2_t)v83, (int64x2_t)v94, 8uLL));
  *(uint8x8_t *)v48.i8 = vqshrn_n_u16(vaddw_u8((uint16x8_t)v125, (uint8x8_t)0x101010101010101), 2uLL);
  uint8x8_t v127 = vqrshrn_n_u16((uint16x8_t)v126, 2uLL);
  int16x8_t v128 = (int16x8_t)vaddw_u8(v124, (uint8x8_t)*(_OWORD *)&vsliq_n_s64((int64x2_t)v87, (int64x2_t)v95, 8uLL));
  int16x8_t v129 = (int16x8_t)vaddw_u8(v124, (uint8x8_t)*(_OWORD *)&vsriq_n_s64((int64x2_t)v46, (int64x2_t)v95, 8uLL));
  vst2_s8(_X3, (int8x8x2_t)v48);
  int64x2_t v130 = (int64x2_t)vaddq_s16(v128, vmulq_s16(v125, v122));
  int64x2_t v131 = (int64x2_t)vaddq_s16(v125, vmulq_s16(v128, v122));
  uint16x8_t v132 = (uint16x8_t)vaddq_s16(v129, vmulq_s16(v126, v122));
  uint16x8_t v133 = (uint16x8_t)vaddq_s16(v126, vmulq_s16(v129, v122));
  int8x8x2_t v134 = (int8x8x2_t)vaddw_u8((uint16x8_t)v130, (uint8x8_t)0x707070707070707);
  int8x8x2_t v135 = (int8x8x2_t)vaddw_u8((uint16x8_t)v131, (uint8x8_t)0x707070707070707);
  uint16x8_t v136 = vmull_u8(*(uint8x8_t *)v96.i8, (uint8x8_t)0x303030303030303);
  v130.i64[0] = v96.i64[0];
  v131.i64[0] = v96.i64[0];
  uint8x8_t v137 = vqrshrn_n_u16(v132, 4uLL);
  v134.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v134, 4uLL);
  v135.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v135, 4uLL);
  uint8x8_t v138 = vqrshrn_n_u16(v133, 4uLL);
  vst2_s8(_X4, v134);
  vst2_s8(_X5, v135);
  int16x8_t v139 = (int16x8_t)vaddw_u8(v136, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v130, (int64x2_t)v96, 8uLL));
  int16x8_t v140 = (int16x8_t)vaddw_u8(v136, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v131, (int64x2_t)v96, 8uLL));
  int64x2_t v141 = (int64x2_t)vaddq_s16(v139, vmulq_s16(v128, v122));
  int64x2_t v142 = (int64x2_t)vaddq_s16(v128, vmulq_s16(v139, v122));
  uint16x8_t v143 = (uint16x8_t)vaddq_s16(v140, vmulq_s16(v129, v122));
  uint16x8_t v144 = (uint16x8_t)vaddq_s16(v129, vmulq_s16(v140, v122));
  int8x8x2_t v145 = (int8x8x2_t)vaddw_u8((uint16x8_t)v141, (uint8x8_t)0x707070707070707);
  int8x8x2_t v146 = (int8x8x2_t)vaddw_u8((uint16x8_t)v142, (uint8x8_t)0x707070707070707);
  uint16x8_t v147 = vmull_u8(*(uint8x8_t *)v97.i8, (uint8x8_t)0x303030303030303);
  v141.i64[0] = v97.i64[0];
  v142.i64[0] = v97.i64[0];
  uint8x8_t v148 = vqrshrn_n_u16(v143, 4uLL);
  v145.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v145, 4uLL);
  v146.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v146, 4uLL);
  uint8x8_t v149 = vqrshrn_n_u16(v144, 4uLL);
  vst2_s8(_X6, v145);
  vst2_s8(_X7, v146);
  int16x8_t v150 = (int16x8_t)vaddw_u8(v147, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v141, (int64x2_t)v97, 8uLL));
  int16x8_t v151 = (int16x8_t)vaddw_u8(v147, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v142, (int64x2_t)v97, 8uLL));
  uint64_t v152 = *v63;
  uint64_t v153 = v63[1];
  v63 += 2;
  uint64_t v154 = *v63;
  uint64_t v155 = v63[1];
  v63 += 2;
  int64x2_t v156 = (int64x2_t)vaddq_s16(v150, vmulq_s16(v139, v122));
  int64x2_t v157 = (int64x2_t)vaddq_s16(v139, vmulq_s16(v150, v122));
  uint16x8_t v158 = (uint16x8_t)vaddq_s16(v151, vmulq_s16(v140, v122));
  uint16x8_t v159 = (uint16x8_t)vaddq_s16(v140, vmulq_s16(v151, v122));
  int8x8x2_t v160 = (int8x8x2_t)vaddw_u8((uint16x8_t)v156, (uint8x8_t)0x707070707070707);
  int8x8x2_t v161 = (int8x8x2_t)vaddw_u8((uint16x8_t)v157, (uint8x8_t)0x707070707070707);
  uint16x8_t v162 = vmull_u8(*(uint8x8_t *)v98.i8, (uint8x8_t)0x303030303030303);
  v156.i64[0] = v98.i64[0];
  v157.i64[0] = v98.i64[0];
  uint8x8_t v163 = vqrshrn_n_u16(v158, 4uLL);
  v160.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v160, 4uLL);
  v161.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v161, 4uLL);
  uint8x8_t v164 = vqrshrn_n_u16(v159, 4uLL);
  vst2_s8(_X9, v160);
  vst2_s8(_X10, v161);
  int16x8_t v165 = (int16x8_t)vaddw_u8(v162, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v156, (int64x2_t)v98, 8uLL));
  int16x8_t v166 = (int16x8_t)vaddw_u8(v162, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v157, (int64x2_t)v98, 8uLL));
  _X3 = (char *)(v152 + a3);
  _X4 = (char *)(v153 + a3);
  _X5 = (char *)(v154 + a3);
  _X6 = (char *)(v155 + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  int64x2_t v175 = (int64x2_t)vaddq_s16(v165, vmulq_s16(v150, v122));
  int64x2_t v176 = (int64x2_t)vaddq_s16(v150, vmulq_s16(v165, v122));
  uint16x8_t v177 = (uint16x8_t)vaddq_s16(v166, vmulq_s16(v151, v122));
  uint16x8_t v178 = (uint16x8_t)vaddq_s16(v151, vmulq_s16(v166, v122));
  int8x8x2_t v179 = (int8x8x2_t)vaddw_u8((uint16x8_t)v175, (uint8x8_t)0x707070707070707);
  int8x8x2_t v180 = (int8x8x2_t)vaddw_u8((uint16x8_t)v176, (uint8x8_t)0x707070707070707);
  uint16x8_t v181 = vmull_u8(*(uint8x8_t *)v99.i8, (uint8x8_t)0x303030303030303);
  v175.i64[0] = v99.i64[0];
  v176.i64[0] = v99.i64[0];
  uint8x8_t v182 = vqrshrn_n_u16(v177, 4uLL);
  v179.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v179, 4uLL);
  v180.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v180, 4uLL);
  uint8x8_t v183 = vqrshrn_n_u16(v178, 4uLL);
  vst2_s8(_X11, v179);
  vst2_s8(_X3, v180);
  int16x8_t v184 = (int16x8_t)vaddw_u8(v181, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v175, (int64x2_t)v99, 8uLL));
  int16x8_t v185 = (int16x8_t)vaddw_u8(v181, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v176, (int64x2_t)v99, 8uLL));
  uint64_t v186 = *v63;
  uint64_t v187 = v63[1];
  v63 += 2;
  uint64_t v188 = *v63;
  uint64_t v189 = v63[1];
  int64x2_t v190 = (int64x2_t)vaddq_s16(v184, vmulq_s16(v165, v122));
  int64x2_t v191 = (int64x2_t)vaddq_s16(v165, vmulq_s16(v184, v122));
  uint16x8_t v192 = (uint16x8_t)vaddq_s16(v185, vmulq_s16(v166, v122));
  uint16x8_t v193 = (uint16x8_t)vaddq_s16(v166, vmulq_s16(v185, v122));
  int8x8x2_t v194 = (int8x8x2_t)vaddw_u8((uint16x8_t)v190, (uint8x8_t)0x707070707070707);
  int8x8x2_t v195 = (int8x8x2_t)vaddw_u8((uint16x8_t)v191, (uint8x8_t)0x707070707070707);
  uint16x8_t v196 = vmull_u8(*(uint8x8_t *)v100.i8, (uint8x8_t)0x303030303030303);
  v190.i64[0] = v100.i64[0];
  v191.i64[0] = v100.i64[0];
  uint8x8_t v197 = vqrshrn_n_u16(v192, 4uLL);
  v194.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v194, 4uLL);
  v195.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v195, 4uLL);
  uint8x8_t v198 = vqrshrn_n_u16(v193, 4uLL);
  vst2_s8(_X4, v194);
  vst2_s8(_X5, v195);
  int16x8_t v199 = (int16x8_t)vaddw_u8(v196, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v190, (int64x2_t)v100, 8uLL));
  int16x8_t v200 = (int16x8_t)vaddw_u8(v196, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v191, (int64x2_t)v100, 8uLL));
  _X7 = (char *)(v186 + a3);
  _X9 = (char *)(v187 + a3);
  _X10 = (char *)(v188 + a3);
  _X11 = (char *)(v189 + a3);
  __asm
  {
    PRFM            #0x11, [X7]
    PRFM            #0x11, [X9]
    PRFM            #0x11, [X10]
    PRFM            #0x11, [X11]
  }
  int64x2_t v209 = (int64x2_t)vaddq_s16(v199, vmulq_s16(v184, v122));
  int64x2_t v210 = (int64x2_t)vaddq_s16(v184, vmulq_s16(v199, v122));
  uint16x8_t v211 = (uint16x8_t)vaddq_s16(v200, vmulq_s16(v185, v122));
  uint16x8_t v212 = (uint16x8_t)vaddq_s16(v185, vmulq_s16(v200, v122));
  int8x8x2_t v213 = (int8x8x2_t)vaddw_u8((uint16x8_t)v209, (uint8x8_t)0x707070707070707);
  int8x8x2_t v214 = (int8x8x2_t)vaddw_u8((uint16x8_t)v210, (uint8x8_t)0x707070707070707);
  uint16x8_t v215 = vmull_u8(*(uint8x8_t *)v101.i8, (uint8x8_t)0x303030303030303);
  v209.i64[0] = v101.i64[0];
  v210.i64[0] = v101.i64[0];
  uint8x8_t v216 = vqrshrn_n_u16(v211, 4uLL);
  v213.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v213, 4uLL);
  v214.val[0] = (int8x8_t)vqshrn_n_u16((uint16x8_t)v214, 4uLL);
  uint8x8_t v217 = vqrshrn_n_u16(v212, 4uLL);
  vst2_s8(_X6, v213);
  vst2_s8(_X7, v214);
  int16x8_t v218 = (int16x8_t)vaddw_u8(v215, (uint8x8_t)*(_OWORD *)&vsliq_n_s64(v209, (int64x2_t)v101, 8uLL));
  int16x8_t v219 = (int16x8_t)vaddw_u8(v215, (uint8x8_t)*(_OWORD *)&vsriq_n_s64(v210, (int64x2_t)v101, 8uLL));
  v213.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)v218, (uint8x8_t)0x101010101010101), 2uLL);
  uint8x8_t v220 = vqrshrn_n_u16((uint16x8_t)v219, 2uLL);
  vst2_s8(_X11, v213);
  v213.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)vaddq_s16(v218, vmulq_s16(v199, v122)), (uint8x8_t)0x707070707070707), 4uLL);
  uint8x8_t v221 = vqrshrn_n_u16((uint16x8_t)vaddq_s16(v219, vmulq_s16(v200, v122)), 4uLL);
  v214.val[0] = (int8x8_t)vqshrn_n_u16(vaddw_u8((uint16x8_t)vaddq_s16(v199, vmulq_s16(v218, v122)), (uint8x8_t)0x707070707070707), 4uLL);
  uint8x8_t v222 = vqrshrn_n_u16((uint16x8_t)vaddq_s16(v200, vmulq_s16(v219, v122)), 4uLL);
  vst2_s8(_X9, v213);
  vst2_s8(_X10, v214);
  return 16;
}

uint64_t aj_RGB888_YUV440(uint64_t result, uint64_t *a2, void *a3, signed int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  int16x8_t v11 = (unsigned char *)*a3;
  int16x8_t v10 = (unsigned char *)a3[1];
  if (result == 1)
  {
    aj_RGB888_YUV444(a6, a7, a8, a9, result, a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v10, v11, a5);
  }
  else
  {
    int16x8_t v12 = (unsigned char *)a3[4];
    int16x8_t v13 = (unsigned char *)a3[2];
    if (a4 >= 1)
    {
      int16x8_t v14 = (unsigned __int8 *)*a2;
      int16x8_t v15 = (unsigned __int8 *)a2[1];
      LODWORD(result) = a4;
      do
      {
        int v16 = *v14;
        int v17 = v14[1];
        int v18 = v14[2];
        *v11++ = (((1254144 * v16 + 0x4000) >> 15)
                + ((2462080 * v17 + 0x4000) >> 15)
                + ((478208 * v18 + 0x4000) >> 15)
                + 64) >> 7;
        int v19 = *v15;
        int v20 = v15[1];
        int v21 = v15[2];
        unsigned int v22 = (((v21 << 6)
              - (((707584 * v19 + 0x4000) >> 15)
               + ((1389568 * v20 + 0x4000) >> 15))
              + 16448) >> 7)
            + (((v18 << 6)
              - (((707584 * v16 + 0x4000) >> 15)
               + ((1389568 * v17 + 0x4000) >> 15))
              + 16448) >> 7);
        *v10++ = (((1254144 * v19 + 0x4000) >> 15)
                + ((2462080 * v20 + 0x4000) >> 15)
                + ((478208 * v21 + 0x4000) >> 15)
                + 64) >> 7;
        if (v22 >= 0x1FF) {
          LOBYTE(v23) = -1;
        }
        else {
          unsigned int v23 = (v22 + 1) >> 1;
        }
        unsigned int v24 = (((v19 << 6)
              - (((1756160 * v20 + 0x4000) >> 15)
               + ((340992 * v21 + 0x4000) >> 15))
              + 16448) >> 7)
            + (((v16 << 6)
              - (((1756160 * v17 + 0x4000) >> 15)
               + ((340992 * v18 + 0x4000) >> 15))
              + 16448) >> 7);
        if (v24 >= 0x1FF) {
          LOBYTE(v25) = -1;
        }
        else {
          unsigned int v25 = (v24 + 1) >> 1;
        }
        *v13++ = v23;
        *v12++ = v25;
        v14 += 3;
        v15 += 3;
        uint64_t result = (result - 1);
      }
      while (result);
    }
    size_t v26 = (a5 - a4);
    if ((int)v26 >= 1)
    {
      memset(v11, *(v11 - 1), v26);
      memset(v10, *(v10 - 1), v26);
      memset(v13, *(v13 - 1), v26);
      int v27 = *(v12 - 1);
      return (uint64_t)memset(v12, v27, v26);
    }
  }
  return result;
}

unsigned char *aj_RGB888_to_gray(uint64_t a1, unsigned __int8 **a2, unsigned char **a3, int a4, int a5)
{
  uint64_t result = *a3;
  if (a4 >= 1)
  {
    int16x8_t v6 = *a2;
    int v7 = a4;
    do
    {
      *result++ = (((1254144 * *v6 + 0x4000) >> 15)
                 + ((2462080 * v6[1] + 0x4000) >> 15)
                 + ((478208 * v6[2] + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 3;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4) {
    return memset(result, *(result - 1), a5 - a4);
  }
  return result;
}

unsigned char *aj_RGBA8888_YUV440(uint64_t a1, uint64_t *a2, const void **a3, unsigned int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  if (a1 == 1)
  {
    aj_RGBA8888_YUV444(a6, a7, a8, a9, a1, a2, (uint64_t)a3, a4, a5);
    int16x8_t v12 = *a3;
    int16x8_t v11 = (void *)a3[1];
    return memcpy(v11, v12, a5);
  }
  else
  {
    return XXXA8888_YUV440(a2, (uint64_t)a3, a4, a5, 0);
  }
}

unsigned char *XXXA8888_YUV440(void *a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t result = *(unsigned char **)a2;
  int v7 = *(unsigned char **)(a2 + 8);
  int16x8_t v8 = *(unsigned char **)(a2 + 16);
  int16x8_t v9 = *(unsigned char **)(a2 + 32);
  if (a3 >= 1)
  {
    int16x8_t v12 = a1;
    int16x8_t v10 = (unsigned __int8 *)*a1;
    int16x8_t v11 = (unsigned __int8 *)v12[1];
    int v13 = a3;
    do
    {
      int16x8_t v14 = v10 + 2;
      if (a5) {
        int16x8_t v15 = v10 + 2;
      }
      else {
        int16x8_t v15 = v10;
      }
      if (a5) {
        int16x8_t v14 = v10;
      }
      int v16 = *v14;
      int v17 = v10[1];
      int v18 = *v15;
      if (a5) {
        int v19 = v11 + 2;
      }
      else {
        int v19 = v11;
      }
      if (a5) {
        int v20 = v11;
      }
      else {
        int v20 = v11 + 2;
      }
      *result++ = (((478208 * v16 + 0x4000) >> 15)
                 + ((2462080 * v17 + 0x4000) >> 15)
                 + ((1254144 * v18 + 0x4000) >> 15)
                 + 64) >> 7;
      int v21 = *v19;
      int v22 = v11[1];
      int v23 = *v20;
      unsigned int v24 = (((v23 << 6)
            - (((707584 * v21 + 0x4000) >> 15)
             + ((1389568 * v22 + 0x4000) >> 15))
            + 16448) >> 7)
          + (((v16 << 6)
            - (((1389568 * v17 + 0x4000) >> 15)
             + ((707584 * v18 + 0x4000) >> 15))
            + 16448) >> 7);
      *v7++ = (((1254144 * v21 + 0x4000) >> 15)
             + ((2462080 * v22 + 0x4000) >> 15)
             + ((478208 * v23 + 0x4000) >> 15)
             + 64) >> 7;
      if (v24 >= 0x1FF) {
        LOBYTE(v25) = -1;
      }
      else {
        unsigned int v25 = (v24 + 1) >> 1;
      }
      unsigned int v26 = (((v21 << 6)
            - (((1756160 * v22 + 0x4000) >> 15)
             + ((340992 * v23 + 0x4000) >> 15))
            + 16448) >> 7)
          + (((v18 << 6)
            - (((340992 * v16 + 0x4000) >> 15)
             + ((1756160 * v17 + 0x4000) >> 15))
            + 16448) >> 7);
      if (v26 >= 0x1FF) {
        LOBYTE(v27) = -1;
      }
      else {
        unsigned int v27 = (v26 + 1) >> 1;
      }
      *v8++ = v25;
      *v9++ = v27;
      v10 += 4;
      v11 += 4;
      --v13;
    }
    while (v13);
  }
  size_t v28 = (a4 - a3);
  if ((int)v28 >= 1)
  {
    memset(result, *(result - 1), (a4 - a3));
    memset(v7, *(v7 - 1), v28);
    memset(v8, *(v8 - 1), v28);
    int v29 = *(v9 - 1);
    return memset(v9, v29, v28);
  }
  return result;
}

unsigned char *aj_RGBA8888_to_gray(uint64_t a1, unsigned __int8 **a2, unsigned char **a3, int a4, int a5)
{
  return XXXA8888_to_gray(a2, a3, a4, a5, 0);
}

unsigned char *XXXA8888_to_gray(unsigned __int8 **a1, unsigned char **a2, int a3, int a4, int a5)
{
  uint64_t result = *a2;
  if (a3 >= 1)
  {
    int v7 = *a1;
    int v8 = a3;
    do
    {
      int16x8_t v9 = v7 + 2;
      if (a5) {
        int16x8_t v10 = v7 + 2;
      }
      else {
        int16x8_t v10 = v7;
      }
      if (a5) {
        int16x8_t v9 = v7;
      }
      *result++ = (((1254144 * *v10 + 0x4000) >> 15)
                 + ((2462080 * v7[1] + 0x4000) >> 15)
                 + ((478208 * *v9 + 0x4000) >> 15)
                 + 64) >> 7;
      v7 += 4;
      --v8;
    }
    while (v8);
  }
  if (a4 > a3) {
    return memset(result, *(result - 1), a4 - a3);
  }
  return result;
}

unsigned char *aj_BGRA8888_YUV440(uint64_t a1, uint64_t *a2, const void **a3, unsigned int a4, int a5, double a6, int64x2_t a7, int64x2_t a8, int64x2_t a9)
{
  if (a1 == 1)
  {
    aj_BGRA8888_YUV444(a6, a7, a8, a9, a1, a2, (uint64_t)a3, a4, a5);
    int16x8_t v12 = *a3;
    int16x8_t v11 = (void *)a3[1];
    return memcpy(v11, v12, a5);
  }
  else
  {
    return XXXA8888_YUV440(a2, (uint64_t)a3, a4, a5, 1);
  }
}

unsigned char *aj_BGRA8888_to_gray(uint64_t a1, unsigned __int8 **a2, unsigned char **a3, int a4, int a5)
{
  return XXXA8888_to_gray(a2, a3, a4, a5, 1);
}

unsigned char *aj_RGB565_YUV444(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned char **)a3;
  int16x8_t v6 = *(unsigned char **)(a3 + 16);
  int v7 = *(unsigned char **)(a3 + 32);
  if (a4 >= 1)
  {
    int v8 = *a2;
    int v9 = a4;
    do
    {
      unsigned int v10 = *v8;
      int v11 = v8[1];
      unsigned int v12 = (v10 >> 5) & 0xFFFFFFC7 | (8 * (v11 & 7));
      unsigned int v13 = (v11 << 7) & 0x7C00;
      *result++ = (((10033152 * (v10 & 0x1F) + 0x4000) >> 15)
                 + ((3736 * v13 + 0x4000) >> 15)
                 + ((9848320 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
      *v6++ = (((v13 >> 1) | 0x40404040) - (((5660672 * (v10 & 0x1F) + 0x4000) >> 15) + ((5558272 * v12 + 0x4000) >> 15))) >> 7;
      *v7++ = (((v10 << 9) | 0x40404040) - (((2664 * v13 + 0x4000) >> 15) + ((7024640 * v12 + 0x4000) >> 15))) >> 7;
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  int v14 = a5 - a4;
  if (a5 > a4)
  {
    size_t v15 = v14;
    memset(result, *(result - 1), v14);
    memset(v6, *(v6 - 1), v15);
    int v16 = *(v7 - 1);
    return memset(v7, v16, v15);
  }
  return result;
}

unsigned char *aj_RGB565_YUV422(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  int16x8_t v5 = *a2;
  uint64_t result = *(unsigned char **)a3;
  int v7 = *(unsigned char **)(a3 + 16);
  int v8 = *(unsigned char **)(a3 + 32);
  int v9 = a4 - 1;
  if (a4 < 2)
  {
    signed int v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    signed int v11 = a4 & 0xFFFFFFFE;
    do
    {
      unsigned int v12 = &result[v10];
      unsigned int v13 = *v5;
      unsigned int v14 = (v13 & 0x1F) << 10;
      int v15 = v5[1];
      unsigned int v16 = (v13 >> 5) & 0xFFFFFFC7 | (8 * (v15 & 7));
      unsigned int v17 = (v15 << 7) & 0x7C00;
      unsigned int v18 = (((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7;
      unsigned int v19 = (((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7;
      *unsigned int v12 = (((9798 * v14 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + 64) >> 7;
      unsigned int v20 = v5[2];
      unsigned int v21 = (v20 & 0x1F) << 10;
      int v22 = v5[3];
      unsigned int v23 = (v20 >> 5) & 0xFFFFFFC7 | (8 * (v22 & 7));
      v5 += 4;
      unsigned int v24 = (v22 << 7) & 0x7C00;
      v12[1] = (((9798 * v21 + 0x4000) >> 15) + ((3736 * v24 + 0x4000) >> 15) + ((9848320 * v23 + 0x4000) >> 15) + 64) >> 7;
      *v7++ = (v19
             + ((((v24 >> 1) | 0x40404040) - (((5528 * v21 + 0x4000) >> 15) + ((5558272 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (v18
             + ((((v21 >> 1) | 0x40404040) - (((2664 * v24 + 0x4000) >> 15) + ((7024640 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      v10 += 2;
    }
    while ((int)v10 < v9);
    result += v10;
  }
  if (v11 == v9)
  {
    unsigned int v25 = *v5;
    int v26 = v5[1];
    unsigned int v27 = (v25 >> 5) & 0xFFFFFFC7 | (8 * (v26 & 7));
    unsigned int v28 = (v26 << 7) & 0x7C00;
    unsigned int v29 = (((10033152 * (v25 & 0x1F) + 0x4000) >> 15)
         + ((3736 * v28 + 0x4000) >> 15)
         + ((9848320 * v27 + 0x4000) >> 15)
         + 64) >> 7;
    *uint64_t result = v29;
    result[1] = v29;
    result += 2;
    *v7++ = (((v28 >> 1) | 0x40404040) - (((5660672 * (v25 & 0x1F) + 0x4000) >> 15) + ((5558272 * v27 + 0x4000) >> 15))) >> 7;
    *v8++ = (((v25 << 9) | 0x40404040) - (((2664 * v28 + 0x4000) >> 15) + ((7024640 * v27 + 0x4000) >> 15))) >> 7;
    signed int v11 = a4 + 1;
  }
  int v30 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v30);
    size_t v31 = (uint64_t)v30 >> 1;
    memset(v7, *(v7 - 1), v31);
    int v32 = *(v8 - 1);
    return memset(v8, v32, v31);
  }
  return result;
}

uint64_t aj_RGB565_YUV440(uint64_t result, uint64_t a2, void *a3, int a4, int a5)
{
  int v7 = (unsigned char *)*a3;
  int16x8_t v6 = (unsigned char *)a3[1];
  if (result == 1)
  {
    aj_RGB565_YUV444(result, (unsigned __int8 **)a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    int v8 = (unsigned char *)a3[4];
    int v9 = (unsigned char *)a3[2];
    if (a4 >= 1)
    {
      uint64_t v10 = *(unsigned __int8 **)a2;
      signed int v11 = *(unsigned __int8 **)(a2 + 8);
      int v12 = a4;
      do
      {
        unsigned int v13 = *v10;
        unsigned int v14 = (v13 & 0x1F) << 10;
        int v15 = v10[1];
        unsigned int v16 = (v13 >> 5) & 0xFFFFFFC7 | (8 * (v15 & 7));
        unsigned int v17 = (v15 << 7) & 0x7C00;
        *v7++ = (((9798 * v14 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + 64) >> 7;
        unsigned int v18 = *v11;
        unsigned int v19 = (v18 & 0x1F) << 10;
        int v20 = v11[1];
        unsigned int v21 = (v18 >> 5) & 0xFFFFFFC7 | (8 * (v20 & 7));
        unsigned int v22 = (v20 << 7) & 0x7C00;
        *v6++ = (((9798 * v19 + 0x4000) >> 15) + ((3736 * v22 + 0x4000) >> 15) + ((9848320 * v21 + 0x4000) >> 15) + 64) >> 7;
        *v9++ = (((((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7)
               + ((((v22 >> 1) | 0x40404040) - (((5528 * v19 + 0x4000) >> 15) + ((5558272 * v21 + 0x4000) >> 15))) >> 7)
               + 1) >> 1;
        uint64_t result = (((((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7)
                + ((((v19 >> 1) | 0x40404040) - (((2664 * v22 + 0x4000) >> 15) + ((7024640 * v21 + 0x4000) >> 15))) >> 7)
                + 1) >> 1;
        *v8++ = result;
        v10 += 2;
        v11 += 2;
        --v12;
      }
      while (v12);
    }
    size_t v23 = (a5 - a4);
    if ((int)v23 >= 1)
    {
      memset(v7, *(v7 - 1), v23);
      memset(v6, *(v6 - 1), v23);
      memset(v9, *(v9 - 1), v23);
      int v24 = *(v8 - 1);
      return (uint64_t)memset(v8, v24, v23);
    }
  }
  return result;
}

uint64_t aj_RGB565_YUV420(uint64_t result, unsigned __int8 **a2, void *a3, int a4, int a5)
{
  int v7 = (unsigned char *)*a3;
  int16x8_t v6 = (unsigned char *)a3[1];
  if (result == 1)
  {
    aj_RGB565_YUV422(result, a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    int v8 = (unsigned char *)a3[4];
    int v9 = (unsigned char *)a3[2];
    int v10 = a4 - 1;
    signed int v11 = *a2;
    int v12 = a2[1];
    if (a4 < 2)
    {
      signed int v15 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      signed int v15 = a4 & 0xFFFFFFFE;
      int32x4_t v16 = vdupq_n_s32(0x6B3000u);
      uint16x4_t v17 = (uint16x4_t)vdup_n_s16(0xA68u);
      uint32x4_t v18 = (uint32x4_t)vdupq_n_s32(0x4040u);
      uint16x4_t v19 = (uint16x4_t)vdup_n_s16(0x1598u);
      int32x4_t v20 = vdupq_n_s32(0x54D000u);
      do
      {
        unsigned int v21 = &v7[v14];
        unsigned int v22 = *v11;
        int v23 = v11[1];
        int v24 = (v22 & 0x1F) << 10;
        unsigned int v25 = (v22 >> 5) & 0xFFFFFFC7 | (8 * (v23 & 7));
        int v26 = (v23 << 7) & 0x7C00;
        unsigned int v27 = &v6[v14];
        unsigned char *v21 = (((10033152 * (v22 & 0x1F) + 0x4000) >> 15)
              + ((3736 * v26 + 0x4000) >> 15)
              + ((9848320 * v25 + 0x4000) >> 15)
              + 64) >> 7;
        unsigned int v28 = v11 + 4;
        unsigned int v29 = v11[2];
        int v30 = (v29 & 0x1F) << 10;
        unsigned int v31 = v29 >> 5;
        int v32 = v11[3];
        unsigned int v33 = v31 & 0xFFFFFFC7 | (8 * (v32 & 7));
        int v34 = (v32 << 7) & 0x7C00;
        int16x8_t v35 = v12 + 4;
        v21[1] = (((9798 * v30 + 0x4000) >> 15)
                + ((3736 * v34 + 0x4000) >> 15)
                + ((9848320 * v33 + 0x4000) >> 15)
                + 64) >> 7;
        LODWORD(v21) = *v12;
        __int32 v36 = (v21 & 0x1F) << 10;
        int v37 = v12[1];
        LODWORD(v21) = (v21 >> 5) & 0xFFFFFFC7 | (8 * (v37 & 7));
        int v38 = (v37 << 7) & 0x7C00;
        *unsigned int v27 = (((9798 * v36 + 0x4000) >> 15)
              + ((3736 * v38 + 0x4000) >> 15)
              + ((9848320 * v21 + 0x4000) >> 15)
              + 64) >> 7;
        unsigned int v39 = v12[2];
        v40.i64[0] = __PAIR64__(v30, v24);
        v40.i32[2] = v36;
        v40.i32[3] = (v39 & 0x1F) << 10;
        int v41 = v12[3];
        v42.i64[0] = __PAIR64__(v33, v25);
        unsigned int v43 = (v39 >> 5) & 0xFFFFFFC7 | (8 * (v41 & 7));
        v42.i64[1] = __PAIR64__(v43, v21);
        v44.i64[0] = 0x400000004000;
        v44.i64[1] = 0x400000004000;
        v45.i64[0] = __PAIR64__(v34, v26);
        v45.i32[2] = v38;
        v45.i32[3] = (v41 << 7) & 0x7C00;
        v46.i64[0] = 0x400000004000;
        v46.i64[1] = 0x400000004000;
        v47.i64[0] = 0x400000004000;
        v47.i64[1] = 0x400000004000;
        int32x4_t v48 = (int32x4_t)vsraq_n_u32(vshrq_n_u32(vmlal_u16(v46, (uint16x4_t)vmovn_s32(v45), v17), 0xFuLL), (uint32x4_t)vmlaq_s32(v44, v42, v16), 0xFuLL);
        v44.i64[0] = 0x400000004000;
        v44.i64[1] = 0x400000004000;
        v27[1] = (((10033152 * (v39 & 0x1F) + 0x4000) >> 15)
                + ((3736 * v45.i32[3] + 0x4000) >> 15)
                + ((9848320 * v43 + 0x4000) >> 15)
                + 64) >> 7;
        uint64_t result = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v18, v40, 1uLL), v48), 7uLL))+ 2) >> 2;
        *v9++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v18, (uint32x4_t)v45, 1uLL), (int32x4_t)vsraq_n_u32(vshrq_n_u32(vmlal_u16(v47, (uint16x4_t)vmovn_s32((int32x4_t)v40), v19), 0xFuLL), (uint32x4_t)vmlaq_s32(v44, v42, v20), 0xFuLL)), 7uLL))+ 2) >> 2;
        *v8++ = result;
        v14 += 2;
        signed int v11 = v28;
        int v12 = v35;
      }
      while ((int)v14 < v10);
      v7 += v14;
      v6 += v14;
      int v12 = v35;
      signed int v11 = v28;
    }
    if (v15 == v10)
    {
      unsigned int v49 = *v11;
      unsigned int v50 = (v49 & 0x1F) << 10;
      int v51 = v11[1];
      unsigned int v52 = (v49 >> 5) & 0xFFFFFFC7 | (8 * (v51 & 7));
      unsigned int v53 = (v51 << 7) & 0x7C00;
      unsigned int v54 = (((9798 * v50 + 0x4000) >> 15) + ((3736 * v53 + 0x4000) >> 15) + ((9848320 * v52 + 0x4000) >> 15) + 64) >> 7;
      *int v7 = v54;
      v7[1] = v54;
      v7 += 2;
      unsigned int v55 = *v12;
      unsigned int v56 = (v55 & 0x1F) << 10;
      int v57 = v12[1];
      unsigned int v58 = (v55 >> 5) & 0xFFFFFFC7 | (8 * (v57 & 7));
      unsigned int v59 = (v57 << 7) & 0x7C00;
      uint64_t result = ((v56 >> 1) | 0x40404040) - (((2664 * v59 + 0x4000) >> 15) + ((7024640 * v58 + 0x4000) >> 15));
      unsigned int v60 = (((9798 * v56 + 0x4000) >> 15) + ((3736 * v59 + 0x4000) >> 15) + ((9848320 * v58 + 0x4000) >> 15) + 64) >> 7;
      *int16x8_t v6 = v60;
      v6[1] = v60;
      v6 += 2;
      *v9++ = (((((v53 >> 1) | 0x40404040) - (((5528 * v50 + 0x4000) >> 15) + ((5558272 * v52 + 0x4000) >> 15))) >> 7)
             + ((((v59 >> 1) | 0x40404040) - (((5528 * v56 + 0x4000) >> 15) + ((5558272 * v58 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (((((v50 >> 1) | 0x40404040) - (((2664 * v53 + 0x4000) >> 15) + ((7024640 * v52 + 0x4000) >> 15))) >> 7)
             + (result >> 7)
             + 1) >> 1;
      signed int v15 = a4 + 1;
    }
    int v61 = a5 - v15;
    if (a5 > v15)
    {
      memset(v7, *(v7 - 1), v61);
      memset(v6, *(v6 - 1), v61);
      memset(v9, *(v9 - 1), (uint64_t)v61 >> 1);
      int v62 = *(v8 - 1);
      return (uint64_t)memset(v8, v62, (uint64_t)v61 >> 1);
    }
  }
  return result;
}

unsigned char *aj_RGB565_to_gray(uint64_t a1, unsigned __int8 **a2, unsigned char **a3, int a4, int a5)
{
  uint64_t result = *a3;
  if (a4 >= 1)
  {
    int16x8_t v6 = *a2;
    int v7 = a4;
    do
    {
      *result++ = (((10033152 * (*v6 & 0x1Fu) + 0x4000) >> 15)
                 + ((3736 * ((v6[1] << 7) & 0x7C00u) + 0x4000) >> 15)
                 + ((9848320 * ((*v6 >> 5) & 0xFFFFFFC7 | (8 * (v6[1] & 7))) + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 2;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4) {
    return memset(result, *(result - 1), a5 - a4);
  }
  return result;
}

unsigned char *aj_BGR565_YUV444(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned char **)a3;
  int16x8_t v6 = *(unsigned char **)(a3 + 16);
  int v7 = *(unsigned char **)(a3 + 32);
  if (a4 >= 1)
  {
    int v8 = *a2;
    int v9 = a4;
    do
    {
      unsigned int v10 = *v8;
      int v11 = v8[1];
      unsigned int v12 = (v10 >> 5) & 0xFFFFFFC7 | (8 * (v11 & 7));
      unsigned int v13 = (v11 << 7) & 0x7C00;
      *result++ = (((3825664 * (v10 & 0x1F) + 0x4000) >> 15)
                 + ((9798 * v13 + 0x4000) >> 15)
                 + ((9848320 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
      *v6++ = (((v10 << 9) | 0x40404040) - (((5528 * v13 + 0x4000) >> 15) + ((5558272 * v12 + 0x4000) >> 15))) >> 7;
      *v7++ = (((v13 >> 1) | 0x40404040) - (((2727936 * (v10 & 0x1F) + 0x4000) >> 15) + ((7024640 * v12 + 0x4000) >> 15))) >> 7;
      v8 += 2;
      --v9;
    }
    while (v9);
  }
  int v14 = a5 - a4;
  if (a5 > a4)
  {
    size_t v15 = v14;
    memset(result, *(result - 1), v14);
    memset(v6, *(v6 - 1), v15);
    int v16 = *(v7 - 1);
    return memset(v7, v16, v15);
  }
  return result;
}

unsigned char *aj_BGR565_YUV422(uint64_t a1, unsigned __int8 **a2, uint64_t a3, int a4, int a5)
{
  int16x8_t v5 = *a2;
  uint64_t result = *(unsigned char **)a3;
  int v7 = *(unsigned char **)(a3 + 16);
  int v8 = *(unsigned char **)(a3 + 32);
  int v9 = a4 - 1;
  if (a4 < 2)
  {
    signed int v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    signed int v11 = a4 & 0xFFFFFFFE;
    do
    {
      unsigned int v12 = &result[v10];
      int v13 = v5[1];
      unsigned int v14 = (v13 << 7) & 0x7C00;
      unsigned int v15 = *v5;
      unsigned int v16 = (v15 >> 5) & 0xFFFFFFC7 | (8 * (v13 & 7));
      unsigned int v17 = (v15 & 0x1F) << 10;
      unsigned int v18 = (((v14 >> 1) | 0x40404040) - (((2664 * v17 + 0x4000) >> 15) + ((7024640 * v16 + 0x4000) >> 15))) >> 7;
      unsigned int v19 = (((v17 >> 1) | 0x40404040) - (((5528 * v14 + 0x4000) >> 15) + ((5558272 * v16 + 0x4000) >> 15))) >> 7;
      *unsigned int v12 = (((9798 * v14 + 0x4000) >> 15) + ((9848320 * v16 + 0x4000) >> 15) + ((3736 * v17 + 0x4000) >> 15) + 64) >> 7;
      unsigned int v20 = v5[2];
      unsigned int v21 = (v20 & 0x1F) << 10;
      int v22 = v5[3];
      unsigned int v23 = (v20 >> 5) & 0xFFFFFFC7 | (8 * (v22 & 7));
      v5 += 4;
      unsigned int v24 = (v22 << 7) & 0x7C00;
      v12[1] = (((3736 * v21 + 0x4000) >> 15) + ((9798 * v24 + 0x4000) >> 15) + ((9848320 * v23 + 0x4000) >> 15) + 64) >> 7;
      *v7++ = (v19
             + ((((v21 >> 1) | 0x40404040) - (((5528 * v24 + 0x4000) >> 15) + ((5558272 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      *v8++ = (v18
             + ((((v24 >> 1) | 0x40404040) - (((2664 * v21 + 0x4000) >> 15) + ((7024640 * v23 + 0x4000) >> 15))) >> 7)
             + 1) >> 1;
      v10 += 2;
    }
    while ((int)v10 < v9);
    result += v10;
  }
  if (v11 == v9)
  {
    unsigned int v25 = *v5;
    int v26 = v5[1];
    unsigned int v27 = (v25 >> 5) & 0xFFFFFFC7 | (8 * (v26 & 7));
    unsigned int v28 = (v26 << 7) & 0x7C00;
    unsigned int v29 = (((3825664 * (v25 & 0x1F) + 0x4000) >> 15)
         + ((9798 * v28 + 0x4000) >> 15)
         + ((9848320 * v27 + 0x4000) >> 15)
         + 64) >> 7;
    *uint64_t result = v29;
    result[1] = v29;
    result += 2;
    *v7++ = (((v25 << 9) | 0x40404040) - (((5528 * v28 + 0x4000) >> 15) + ((5558272 * v27 + 0x4000) >> 15))) >> 7;
    *v8++ = (((v28 >> 1) | 0x40404040) - (((2727936 * (v25 & 0x1F) + 0x4000) >> 15) + ((7024640 * v27 + 0x4000) >> 15))) >> 7;
    signed int v11 = a4 + 1;
  }
  int v30 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v30);
    size_t v31 = (uint64_t)v30 >> 1;
    memset(v7, *(v7 - 1), v31);
    int v32 = *(v8 - 1);
    return memset(v8, v32, v31);
  }
  return result;
}

uint64_t aj_BGR565_YUV440(uint64_t result, uint64_t a2, void *a3, int a4, int a5)
{
  int v7 = (unsigned char *)*a3;
  int16x8_t v6 = (unsigned char *)a3[1];
  if (result == 1)
  {
    aj_BGR565_YUV444(result, (unsigned __int8 **)a2, (uint64_t)a3, a4, a5);
    return (uint64_t)memcpy(v6, v7, a5);
  }
  else
  {
    int v8 = (unsigned char *)a3[4];
    int v9 = (unsigned char *)a3[2];
    if (a4 >= 1)
    {
      uint64_t v10 = (unsigned __int8 *)(*(void *)a2 + 1);
      signed int v11 = (unsigned __int8 *)(*(void *)(a2 + 8) + 1);
      int v12 = a4;
      do
      {
        int v13 = *v10;
        unsigned int v14 = (v13 << 7) & 0x7C00;
        unsigned int v15 = *(v10 - 1);
        unsigned int v16 = (v15 >> 5) & 0xFFFFFFC7 | (8 * (v13 & 7));
        *v7++ = (((9798 * v14 + 0x4000) >> 15)
               + ((9848320 * v16 + 0x4000) >> 15)
               + ((3825664 * (v15 & 0x1F) + 0x4000) >> 15)
               + 64) >> 7;
        int v17 = *v11;
        unsigned int v18 = (v17 << 7) & 0x7C00;
        unsigned int v19 = *(v11 - 1);
        unsigned int v20 = (v19 >> 5) & 0xFFFFFFC7 | (8 * (v17 & 7));
        *v6++ = (((9798 * v18 + 0x4000) >> 15)
               + ((9848320 * v20 + 0x4000) >> 15)
               + ((3825664 * (v19 & 0x1F) + 0x4000) >> 15)
               + 64) >> 7;
        *v9++ = ((((((v15 & 0x1F) << 10 >> 1) | 0x40404040)
                 - (((5528 * v14 + 0x4000) >> 15)
                  + ((5558272 * v16 + 0x4000) >> 15))) >> 7)
               + (((((v19 & 0x1F) << 10 >> 1) | 0x40404040)
                 - (((5528 * v18 + 0x4000) >> 15)
                  + ((5558272 * v20 + 0x4000) >> 15))) >> 7)
               + 1) >> 1;
        uint64_t result = (((((v14 >> 1) | 0x40404040)
                  - (((2727936 * (v15 & 0x1F) + 0x4000) >> 15)
                   + ((7024640 * v16 + 0x4000) >> 15))) >> 7)
                + ((((v18 >> 1) | 0x40404040)
                  - (((2727936 * (v19 & 0x1F) + 0x4000) >> 15)
                   + ((7024640 * v20 + 0x4000) >> 15))) >> 7)
                + 1) >> 1;
        *v8++ = result;
        v10 += 2;
        v11 += 2;
        --v12;
      }
      while (v12);
    }
    size_t v21 = (a5 - a4);
    if ((int)v21 >= 1)
    {
      memset(v7, *(v7 - 1), v21);
      memset(v6, *(v6 - 1), v21);
      memset(v9, *(v9 - 1), v21);
      int v22 = *(v8 - 1);
      return (uint64_t)memset(v8, v22, v21);
    }
  }
  return result;
}

unsigned char *aj_BGR565_YUV420(uint64_t a1, unsigned __int8 **a2, void *a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_BGR565_YUV422(a1, a2, (uint64_t)a3, a4, a5);
    int v8 = (unsigned char *)*a3;
    int v7 = (void *)a3[1];
    return memcpy(v7, v8, a5);
  }
  else
  {
    uint64_t v10 = (unsigned char *)a3[4];
    int v12 = (unsigned char *)a3[1];
    signed int v11 = (unsigned char *)a3[2];
    uint64_t result = (unsigned char *)*a3;
    int v13 = a4 - 1;
    unsigned int v15 = *a2;
    unsigned int v14 = a2[1];
    if (a4 < 2)
    {
      signed int v17 = 0;
    }
    else
    {
      uint64_t v16 = 0;
      signed int v17 = a4 & 0xFFFFFFFE;
      int32x4_t v18 = vdupq_n_s32(0x6B3000u);
      uint16x4_t v19 = (uint16x4_t)vdup_n_s16(0xA68u);
      uint32x4_t v20 = (uint32x4_t)vdupq_n_s32(0x4040u);
      uint16x4_t v21 = (uint16x4_t)vdup_n_s16(0x1598u);
      int32x4_t v22 = vdupq_n_s32(0x54D000u);
      do
      {
        int v23 = v15[1];
        unsigned int v24 = *v15;
        int v25 = (v23 << 7) & 0x7C00;
        unsigned int v26 = (v24 >> 5) & 0xFFFFFFC7 | (8 * (v23 & 7));
        int v27 = (v24 & 0x1F) << 10;
        unsigned int v28 = &result[v16];
        *unsigned int v28 = (((9798 * v25 + 0x4000) >> 15)
              + ((9848320 * v26 + 0x4000) >> 15)
              + ((3825664 * (v24 & 0x1F) + 0x4000) >> 15)
              + 64) >> 7;
        int v29 = v15[3];
        int v30 = (v29 << 7) & 0x7C00;
        unsigned int v31 = v15[2];
        unsigned int v32 = (v31 >> 5) & 0xFFFFFFC7 | (8 * (v29 & 7));
        int v33 = (v31 & 0x1F) << 10;
        int v34 = &v12[v16];
        v28[1] = (((9798 * v30 + 0x4000) >> 15)
                + ((9848320 * v32 + 0x4000) >> 15)
                + ((3736 * v33 + 0x4000) >> 15)
                + 64) >> 7;
        v15 += 4;
        LODWORD(v28) = v14[1];
        int v35 = (v28 << 7) & 0x7C00;
        unsigned int v36 = *v14;
        unsigned int v37 = (v36 >> 5) & 0xFFFFFFC7 | (8 * (v28 & 7));
        LODWORD(v28) = (v36 & 0x1F) << 10;
        *int v34 = (((9798 * v35 + 0x4000) >> 15)
              + ((9848320 * v37 + 0x4000) >> 15)
              + ((3825664 * (v36 & 0x1F) + 0x4000) >> 15)
              + 64) >> 7;
        v38.i64[0] = __PAIR64__(v30, v25);
        LOWORD(v25) = v14[3];
        v38.i32[2] = v35;
        unsigned int v39 = v14[2];
        v14 += 4;
        v40.i64[0] = __PAIR64__(v32, v26);
        unsigned int v41 = (v39 >> 5) & 0xFFFFFFC7 | (8 * (v25 & 7));
        v40.i64[1] = __PAIR64__(v41, v37);
        v42.i64[0] = 0x400000004000;
        v42.i64[1] = 0x400000004000;
        v38.i32[3] = ((_WORD)v25 << 7) & 0x7C00;
        v43.i64[0] = __PAIR64__(v33, v27);
        v43.i32[2] = (int)v28;
        v43.i32[3] = (v39 & 0x1F) << 10;
        v44.i64[0] = 0x400000004000;
        v44.i64[1] = 0x400000004000;
        uint32x4_t v45 = vshrq_n_u32(vmlal_u16(v44, (uint16x4_t)vmovn_s32(v43), v19), 0xFuLL);
        int32x4_t v46 = (int32x4_t)vsraq_n_u32(v20, v38, 1uLL);
        int32x4_t v47 = (int32x4_t)vsraq_n_u32(v45, (uint32x4_t)vmlaq_s32(v42, v40, v18), 0xFuLL);
        v42.i64[0] = 0x400000004000;
        v42.i64[1] = 0x400000004000;
        uint32x4_t v48 = vshrq_n_u32(vmlal_u16((uint32x4_t)v42, (uint16x4_t)vmovn_s32((int32x4_t)v38), v21), 0xFuLL);
        v42.i64[0] = 0x400000004000;
        v42.i64[1] = 0x400000004000;
        v34[1] = (((9798 * (((_WORD)v25 << 7) & 0x7C00u) + 0x4000) >> 15)
                + ((9848320 * v41 + 0x4000) >> 15)
                + ((3825664 * (v39 & 0x1F) + 0x4000) >> 15)
                + 64) >> 7;
        *v11++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32((int32x4_t)vsraq_n_u32(v20, (uint32x4_t)v43, 1uLL), (int32x4_t)vsraq_n_u32(v48, (uint32x4_t)vmlaq_s32(v42, v40, v22), 0xFuLL)), 7uLL))+ 2) >> 2;
        *v10++ = (vaddvq_s32((int32x4_t)vshrq_n_u32((uint32x4_t)vsubq_s32(v46, v47), 7uLL)) + 2) >> 2;
        v16 += 2;
      }
      while ((int)v16 < v13);
      v12 += v16;
      result += v16;
    }
    if (v17 == v13)
    {
      int v49 = v15[1];
      unsigned int v50 = (v49 << 7) & 0x7C00;
      unsigned int v51 = *v15;
      unsigned int v52 = (v51 >> 5) & 0xFFFFFFC7 | (8 * (v49 & 7));
      unsigned int v53 = (((9798 * v50 + 0x4000) >> 15)
           + ((9848320 * v52 + 0x4000) >> 15)
           + ((3825664 * (v51 & 0x1F) + 0x4000) >> 15)
           + 64) >> 7;
      *uint64_t result = v53;
      result[1] = v53;
      result += 2;
      int v54 = v14[1];
      unsigned int v55 = (v54 << 7) & 0x7C00;
      unsigned int v56 = *v14;
      unsigned int v57 = (v56 >> 5) & 0xFFFFFFC7 | (8 * (v54 & 7));
      unsigned int v58 = (v56 & 0x1F) << 10;
      unsigned int v59 = (((9798 * v55 + 0x4000) >> 15) + ((9848320 * v57 + 0x4000) >> 15) + ((3736 * v58 + 0x4000) >> 15) + 64) >> 7;
      *int v12 = v59;
      v12[1] = v59;
      v12 += 2;
      *v11++ = ((((((v51 & 0x1F) << 10 >> 1) | 0x40404040)
                - (((5528 * v50 + 0x4000) >> 15)
                 + ((5558272 * v52 + 0x4000) >> 15))) >> 7)
              + ((((v58 >> 1) | 0x40404040) - (((5528 * v55 + 0x4000) >> 15) + ((5558272 * v57 + 0x4000) >> 15))) >> 7)
              + 1) >> 1;
      *v10++ = (((((v50 >> 1) | 0x40404040)
                - (((2727936 * (v51 & 0x1F) + 0x4000) >> 15)
                 + ((7024640 * v52 + 0x4000) >> 15))) >> 7)
              + ((((v55 >> 1) | 0x40404040) - (((2664 * v58 + 0x4000) >> 15) + ((7024640 * v57 + 0x4000) >> 15))) >> 7)
              + 1) >> 1;
      signed int v17 = a4 + 1;
    }
    int v60 = a5 - v17;
    if (a5 > v17)
    {
      memset(result, *(result - 1), v60);
      memset(v12, *(v12 - 1), v60);
      memset(v11, *(v11 - 1), (uint64_t)v60 >> 1);
      int v61 = *(v10 - 1);
      return memset(v10, v61, (uint64_t)v60 >> 1);
    }
  }
  return result;
}

unsigned char *aj_BGR565_to_gray(uint64_t a1, void *a2, unsigned char **a3, int a4, int a5)
{
  uint64_t result = *a3;
  if (a4 >= 1)
  {
    int16x8_t v6 = (unsigned char *)(*a2 + 1);
    int v7 = a4;
    do
    {
      *result++ = (((9798 * ((*v6 << 7) & 0x7C00u) + 0x4000) >> 15)
                 + ((9848320 * ((*(v6 - 1) >> 5) & 0xFFFFFFC7 | (8 * (*v6 & 7))) + 0x4000) >> 15)
                 + ((3825664 * (*(v6 - 1) & 0x1Fu) + 0x4000) >> 15)
                 + 64) >> 7;
      v6 += 2;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4) {
    return memset(result, *(result - 1), a5 - a4);
  }
  return result;
}

void *aj_gray_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v8 = (char *)*a2;
  int v9 = (char *)*a3;
  uint64_t v10 = a4;
  memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    memset(&v9[v10], v8[v10 - 1], a5 - a4);
  }
  memset(a3[2], 128, a5);
  signed int v11 = (char *)a3[4];
  return memset(v11, 128, a5);
}

void *aj_gray_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v8 = (char *)*a2;
  int v9 = (char *)*a3;
  uint64_t v10 = a4;
  memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    memset(&v9[v10], v8[v10 - 1], a5 - a4);
  }
  if (a5 >= 0) {
    int v11 = a5;
  }
  else {
    int v11 = a5 + 1;
  }
  size_t v12 = ((v11 >> 1) & 1) + (v11 >> 1);
  memset(a3[2], 128, v12);
  int v13 = (char *)a3[4];
  return memset(v13, 128, v12);
}

void *aj_gray_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_gray_YUV444(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    size_t v12 = (unsigned __int8 *)*a2;
    int v13 = (char *)*a3;
    size_t v14 = a4;
    memcpy(*a3, *a2, a4);
    int v15 = a5 - a4;
    if (a5 <= a4)
    {
      memcpy(a3[1], a2[1], a4);
    }
    else
    {
      uint64_t v16 = &v13[a4];
      size_t v17 = v15;
      memset(v16, v12[v14 - 1], v15);
      int32x4_t v18 = (unsigned __int8 *)a2[1];
      uint16x4_t v19 = (char *)a3[1];
      memcpy(v19, v18, v14);
      memset(&v19[v14], v18[v14 - 1], v17);
    }
    memset(a3[2], 128, a5);
    uint32x4_t v20 = (char *)a3[4];
    return memset(v20, 128, a5);
  }
}

void *aj_gray_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_gray_YUV422(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    size_t v12 = (unsigned __int8 *)*a2;
    int v13 = (char *)*a3;
    size_t v14 = a4;
    memcpy(*a3, *a2, a4);
    int v15 = a5 - a4;
    if (a5 <= a4)
    {
      memcpy(a3[1], a2[1], a4);
    }
    else
    {
      uint64_t v16 = &v13[a4];
      size_t v17 = v15;
      memset(v16, v12[v14 - 1], v15);
      int32x4_t v18 = (unsigned __int8 *)a2[1];
      uint16x4_t v19 = (char *)a3[1];
      memcpy(v19, v18, v14);
      memset(&v19[v14], v18[v14 - 1], v17);
    }
    if (a5 >= 0) {
      int v20 = a5;
    }
    else {
      int v20 = a5 + 1;
    }
    size_t v21 = ((v20 >> 1) & 1) + (v20 >> 1);
    memset(a3[2], 128, v21);
    int32x4_t v22 = (char *)a3[4];
    return memset(v22, 128, v21);
  }
}

void *aj_gray_to_gray(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)*a2;
  int v8 = (char *)*a3;
  uint64_t v9 = a4;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
  {
    int v11 = v7[v9 - 1];
    return memset(&v8[v9], v11, a5 - a4);
  }
  return result;
}

unsigned char *aj_YUV_YUV444(uint64_t a1, unsigned char **a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned char **)a3;
  int16x8_t v6 = *(unsigned char **)(a3 + 16);
  int v7 = *(unsigned char **)(a3 + 32);
  if (a4 >= 1)
  {
    int v8 = *a2;
    int v9 = a4;
    do
    {
      *result++ = *v8;
      *v6++ = v8[1];
      *v7++ = v8[2];
      v8 += 3;
      --v9;
    }
    while (v9);
  }
  int v10 = a5 - a4;
  if (a5 > a4)
  {
    size_t v11 = v10;
    memset(result, *(result - 1), v10);
    memset(v6, *(v6 - 1), v11);
    int v12 = *(v7 - 1);
    return memset(v7, v12, v11);
  }
  return result;
}

unsigned char *aj_YUV_YUV422(uint64_t a1, unsigned char **a2, uint64_t a3, int a4, int a5)
{
  int16x8_t v5 = *a2;
  uint64_t result = *(unsigned char **)a3;
  int v7 = *(unsigned char **)(a3 + 16);
  int v8 = *(unsigned char **)(a3 + 32);
  int v9 = a4 - 1;
  if (a4 < 2)
  {
    signed int v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    signed int v11 = a4 & 0xFFFFFFFE;
    do
    {
      int v12 = &result[v10];
      *int v12 = *v5;
      int v13 = v5[1];
      int v14 = v5[2];
      v12[1] = v5[3];
      *v7++ = (v5[4] + v13) >> 1;
      int v15 = v5 + 6;
      *v8++ = (v5[5] + v14) >> 1;
      v10 += 2;
      v5 += 6;
    }
    while ((int)v10 < v9);
    result += v10;
    int16x8_t v5 = v15;
  }
  if (v11 == v9)
  {
    *uint64_t result = *v5;
    char v16 = v5[1];
    char v17 = v5[2];
    result[1] = *v5;
    result += 2;
    *v7++ = v16;
    *v8++ = v17;
    signed int v11 = a4 + 1;
  }
  int v18 = a5 - v11;
  if (a5 > v11)
  {
    memset(result, *(result - 1), v18);
    size_t v19 = (uint64_t)v18 >> 1;
    memset(v7, *(v7 - 1), v19);
    int v20 = *(v8 - 1);
    return memset(v8, v20, v19);
  }
  return result;
}

unsigned char *aj_YUV_YUV440(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV_YUV444(a1, (unsigned char **)a2, (uint64_t)a3, a4, a5);
    int v8 = (unsigned char *)*a3;
    int v7 = (void *)a3[1];
    return memcpy(v7, v8, a5);
  }
  else
  {
    uint64_t v10 = (unsigned char *)a3[4];
    int v12 = (unsigned char *)a3[1];
    signed int v11 = (unsigned char *)a3[2];
    uint64_t result = (unsigned char *)*a3;
    if (a4 >= 1)
    {
      int v13 = *(unsigned char **)a2;
      int v14 = *(unsigned char **)(a2 + 8);
      int v15 = a4;
      do
      {
        *result++ = *v13;
        *v12++ = *v14;
        *v11++ = (v14[1] + v13[1]) >> 1;
        *v10++ = (v14[2] + v13[2]) >> 1;
        v13 += 3;
        v14 += 3;
        --v15;
      }
      while (v15);
    }
    size_t v16 = (a5 - a4);
    if ((int)v16 >= 1)
    {
      memset(result, *(result - 1), v16);
      memset(v12, *(v12 - 1), v16);
      memset(v11, *(v11 - 1), v16);
      int v17 = *(v10 - 1);
      return memset(v10, v17, v16);
    }
  }
  return result;
}

unsigned char *aj_YUV_YUV420(uint64_t a1, uint64_t a2, void *a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV_YUV422(a1, (unsigned char **)a2, (uint64_t)a3, a4, a5);
    int v8 = (unsigned char *)*a3;
    int v7 = (void *)a3[1];
    return memcpy(v7, v8, a5);
  }
  else
  {
    uint64_t v10 = (unsigned char *)a3[4];
    int v12 = (unsigned char *)a3[1];
    signed int v11 = (unsigned char *)a3[2];
    uint64_t result = (unsigned char *)*a3;
    int v13 = a4 - 1;
    int v15 = *(unsigned char **)a2;
    int v14 = *(unsigned char **)(a2 + 8);
    if (a4 < 2)
    {
      signed int v17 = 0;
    }
    else
    {
      uint64_t v16 = 0;
      signed int v17 = a4 & 0xFFFFFFFE;
      do
      {
        int v18 = &v12[v16];
        size_t v19 = &result[v16];
        unsigned char *v19 = *v15;
        unsigned char *v18 = *v14;
        int v20 = v15[1];
        int v21 = v14[1];
        int v22 = v15[2];
        int v23 = v14[2];
        v19[1] = v15[3];
        v18[1] = v14[3];
        LODWORD(v19) = v15[4];
        unsigned int v24 = v15 + 6;
        int v25 = v15[5];
        int v26 = v14[5];
        *v11++ = (v20 + v21 + v19 + v14[4] + 2) >> 2;
        int v27 = v14 + 6;
        *v10++ = (v22 + v23 + v25 + v26 + 2) >> 2;
        v16 += 2;
        v14 += 6;
        int v15 = v24;
      }
      while ((int)v16 < v13);
      v12 += v16;
      result += v16;
      int v15 = v24;
      int v14 = v27;
    }
    if (v17 == v13)
    {
      *uint64_t result = *v15;
      *int v12 = *v14;
      unsigned int v28 = v14[1] + v15[1];
      unsigned int v29 = v14[2] + v15[2];
      result[1] = *result;
      result += 2;
      v12[1] = *v12;
      v12 += 2;
      *v11++ = v28 >> 1;
      *v10++ = v29 >> 1;
      signed int v17 = a4 + 1;
    }
    int v30 = a5 - v17;
    if (a5 > v17)
    {
      memset(result, *(result - 1), v30);
      memset(v12, *(v12 - 1), v30);
      memset(v11, *(v11 - 1), (uint64_t)v30 >> 1);
      int v31 = *(v10 - 1);
      return memset(v10, v31, (uint64_t)v30 >> 1);
    }
  }
  return result;
}

unsigned char *aj_YUV_to_gray(uint64_t a1, char **a2, unsigned char **a3, int a4, int a5)
{
  uint64_t result = *a3;
  if (a4 >= 1)
  {
    int16x8_t v6 = *a2;
    int v7 = a4;
    do
    {
      char v8 = *v6;
      v6 += 3;
      *result++ = v8;
      --v7;
    }
    while (v7);
  }
  if (a5 > a4) {
    return memset(result, *(result - 1), a5 - a4);
  }
  return result;
}

void *aj_YUV422SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  if (a4 >= 1)
  {
    unsigned int v14 = (a4 + 1) >> 1;
    do
    {
      *char v8 = *v7;
      int v15 = v8 + 2;
      v8[1] = *v7;
      *int v9 = v7[1];
      uint64_t v16 = v7 + 2;
      signed int v17 = v9 + 2;
      v9[1] = v7[1];
      v9 += 2;
      v8 += 2;
      v7 += 2;
      --v14;
    }
    while (v14);
    int v7 = v16;
    char v8 = v15;
    int v9 = v17;
  }
  if (a5 > a4)
  {
    size_t v18 = a5 - a4 - (a4 & 1);
    memset(v8, *(v7 - 2), v18);
    int v19 = *(v7 - 1);
    return memset(v9, v19, v18);
  }
  return result;
}

void *aj_YUV422SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  int v14 = a4 + 2;
  if (a4 >= -1) {
    int v14 = a4 + 1;
  }
  int v15 = v14 >> 1;
  if (a4 >= 1)
  {
    if (v15 <= 1) {
      int v16 = 1;
    }
    else {
      int v16 = v15;
    }
    do
    {
      *v8++ = *v7;
      signed int v17 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v16;
    }
    while (v16);
    int v7 = v17;
  }
  if (a5 > a4)
  {
    int v18 = a5 + 2;
    if (a5 >= -1) {
      int v18 = a5 + 1;
    }
    size_t v19 = (v18 >> 1) - v15;
    memset(v8, *(v7 - 2), v19);
    int v20 = *(v7 - 1);
    return memset(v9, v20, v19);
  }
  return result;
}

void *aj_YUV422SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV422SEMIP_YUV422(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (unsigned __int8 *)a2[2];
    int v15 = (unsigned __int8 *)a2[3];
    int v16 = (char *)*a3;
    unsigned int v29 = (unsigned __int8 *)*a2;
    memcpy(*a3, *a2, a4);
    int v30 = a5;
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      size_t v18 = v17;
      memset(&v16[a4], v29[a4 - 1], v17);
      size_t v19 = (unsigned __int8 *)a2[1];
      int v20 = (char *)a3[1];
      memcpy(v20, v19, a4);
      uint64_t result = memset(&v20[a4], v19[a4 - 1], v18);
    }
    int v21 = a4 + 2;
    if (a4 >= -1) {
      int v21 = a4 + 1;
    }
    int v22 = v21 >> 1;
    if (a4 >= 1)
    {
      if (v22 <= 1) {
        int v23 = 1;
      }
      else {
        int v23 = v22;
      }
      do
      {
        *v13++ = (*v15 + *v14) >> 1;
        unsigned int v24 = v14 + 2;
        int v25 = v15 + 2;
        *v12++ = (v15[1] + v14[1]) >> 1;
        v15 += 2;
        v14 += 2;
        --v23;
      }
      while (v23);
      int v14 = v24;
      int v15 = v25;
    }
    if (v30 > a4)
    {
      int v26 = v30 + 2;
      if (v30 >= -1) {
        int v26 = v30 + 1;
      }
      size_t v27 = (v26 >> 1) - v22;
      memset(v13, (*(v15 - 2) + *(v14 - 2)) >> 1, v27);
      unsigned int v28 = (*(v15 - 1) + *(v14 - 1)) >> 1;
      return memset(v12, v28, v27);
    }
  }
  return result;
}

void *aj_YUV422SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV422SEMIP_YUV444(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (unsigned __int8 *)a2[2];
    int v15 = (unsigned __int8 *)a2[3];
    int v16 = (char *)*a3;
    unsigned int v29 = (unsigned __int8 *)*a2;
    memcpy(*a3, *a2, a4);
    int v30 = a5;
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      size_t v18 = v17;
      memset(&v16[a4], v29[a4 - 1], v17);
      size_t v19 = (unsigned __int8 *)a2[1];
      int v20 = (char *)a3[1];
      memcpy(v20, v19, a4);
      uint64_t result = memset(&v20[a4], v19[a4 - 1], v18);
    }
    if (a4 >= 1)
    {
      unsigned int v21 = (a4 + 1) >> 1;
      do
      {
        unsigned int v22 = (*v15 + *v14) >> 1;
        *int v13 = v22;
        int v23 = v13 + 2;
        v13[1] = v22;
        unsigned int v24 = v14 + 2;
        int v25 = v15 + 2;
        unsigned int v26 = (v15[1] + v14[1]) >> 1;
        *int v12 = v26;
        size_t v27 = v12 + 2;
        v12[1] = v26;
        v12 += 2;
        v13 += 2;
        v15 += 2;
        v14 += 2;
        --v21;
      }
      while (v21);
      int v14 = v24;
      int v15 = v25;
      int v13 = v23;
      int v12 = v27;
    }
    if (v30 > a4)
    {
      memset(v13, (*(v15 - 2) + *(v14 - 2)) >> 1, v30 - a4 - (a4 & 1));
      unsigned int v28 = (*(v15 - 1) + *(v14 - 1)) >> 1;
      return memset(v12, v28, v30 - a4 - (a4 & 1));
    }
  }
  return result;
}

void *aj_YUV420SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  if (a4 >= 1)
  {
    unsigned int v14 = (a4 + 1) >> 1;
    do
    {
      *char v8 = *v7;
      int v15 = v8 + 2;
      v8[1] = *v7;
      *int v9 = v7[1];
      int v16 = v7 + 2;
      int v17 = v9 + 2;
      v9[1] = v7[1];
      v9 += 2;
      v8 += 2;
      v7 += 2;
      --v14;
    }
    while (v14);
    int v7 = v16;
    char v8 = v15;
    int v9 = v17;
  }
  if (a5 > a4)
  {
    size_t v18 = a5 - a4 - (a4 & 1);
    memset(v8, *(v7 - 2), v18);
    int v19 = *(v7 - 1);
    return memset(v9, v19, v18);
  }
  return result;
}

void *aj_YUV420SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  int v14 = a4 + 2;
  if (a4 >= -1) {
    int v14 = a4 + 1;
  }
  int v15 = v14 >> 1;
  if (a4 >= 1)
  {
    if (v15 <= 1) {
      int v16 = 1;
    }
    else {
      int v16 = v15;
    }
    do
    {
      *v8++ = *v7;
      int v17 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v16;
    }
    while (v16);
    int v7 = v17;
  }
  if (a5 > a4)
  {
    int v18 = a5 + 2;
    if (a5 >= -1) {
      int v18 = a5 + 1;
    }
    size_t v19 = (v18 >> 1) - v15;
    memset(v8, *(v7 - 2), v19);
    int v20 = *(v7 - 1);
    return memset(v9, v20, v19);
  }
  return result;
}

void *aj_YUV420SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV420SEMIP_YUV422(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (unsigned __int8 *)a2[2];
    int v15 = (unsigned __int8 *)*a2;
    int v16 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      int v18 = v15[a4 - 1];
      size_t v19 = v17;
      memset(&v16[a4], v18, v17);
      int v20 = (unsigned __int8 *)a2[1];
      unsigned int v21 = (char *)a3[1];
      memcpy(v21, v20, a4);
      uint64_t result = memset(&v21[a4], v20[a4 - 1], v19);
    }
    int v22 = a4 + 2;
    if (a4 >= -1) {
      int v22 = a4 + 1;
    }
    int v23 = v22 >> 1;
    if (a4 >= 1)
    {
      if (v23 <= 1) {
        int v24 = 1;
      }
      else {
        int v24 = v23;
      }
      do
      {
        *v13++ = *v14;
        int v25 = v14 + 2;
        *v12++ = v14[1];
        v14 += 2;
        --v24;
      }
      while (v24);
      int v14 = v25;
    }
    if (a5 > a4)
    {
      int v26 = a5 + 2;
      if (a5 >= -1) {
        int v26 = a5 + 1;
      }
      size_t v27 = (v26 >> 1) - v23;
      memset(v13, *(v14 - 2), v27);
      int v28 = *(v14 - 1);
      return memset(v12, v28, v27);
    }
  }
  return result;
}

void *aj_YUV420SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV420SEMIP_YUV444(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (unsigned __int8 *)a2[2];
    int v15 = (unsigned __int8 *)*a2;
    int v16 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      int v18 = v15[a4 - 1];
      size_t v19 = v17;
      memset(&v16[a4], v18, v17);
      int v20 = (unsigned __int8 *)a2[1];
      unsigned int v21 = (char *)a3[1];
      memcpy(v21, v20, a4);
      uint64_t result = memset(&v21[a4], v20[a4 - 1], v19);
    }
    if (a4 >= 1)
    {
      unsigned int v22 = (a4 + 1) >> 1;
      do
      {
        unsigned __int8 v23 = *v14;
        *int v13 = *v14;
        int v24 = v13 + 2;
        v13[1] = v23;
        int v25 = v14 + 2;
        char v26 = v14[1];
        size_t v27 = v12 + 2;
        *int v12 = v26;
        v12[1] = v26;
        v12 += 2;
        v13 += 2;
        v14 += 2;
        --v22;
      }
      while (v22);
      int v14 = v25;
      int v13 = v24;
      int v12 = v27;
    }
    if (a5 > a4)
    {
      size_t v28 = a5 - a4 - (a4 & 1);
      memset(v13, *(v14 - 2), v28);
      int v29 = *(v14 - 1);
      return memset(v12, v29, v28);
    }
  }
  return result;
}

void *aj_YUV440SEMIP_YUV444(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  if (a4 >= 1)
  {
    int v14 = a4;
    do
    {
      *v8++ = *v7;
      int v15 = v7 + 2;
      *v9++ = v7[1];
      v7 += 2;
      --v14;
    }
    while (v14);
    int v7 = v15;
  }
  int v16 = a5 - a4;
  if (a5 > a4)
  {
    size_t v17 = v16;
    memset(v8, *(v7 - 2), v16);
    int v18 = *(v7 - 1);
    return memset(v9, v18, v17);
  }
  return result;
}

void *aj_YUV440SEMIP_YUV422(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)a2[2];
  char v8 = (char *)a3[2];
  int v9 = (char *)a3[4];
  uint64_t v10 = (char *)*a2;
  uint64_t v11 = a4;
  int v12 = (char *)*a3;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4) {
    uint64_t result = memset(&v12[v11], v10[v11 - 1], a5 - a4);
  }
  if (a4 >= 0) {
    int v14 = a4;
  }
  else {
    int v14 = a4 + 1;
  }
  if (a4 >= 2)
  {
    int v15 = v14 >> 1;
    do
    {
      *v8++ = (v7[2] + *v7) >> 1;
      *v9++ = (v7[3] + v7[1]) >> 1;
      v7 += 4;
      --v15;
    }
    while (v15);
  }
  if (a4)
  {
    *v8++ = *v7;
    *v9++ = v7[1];
    v7 += 2;
  }
  if (a5 > a4)
  {
    size_t v16 = (uint64_t)(a5 - a4 + (a5 - a4 < 0)) >> 1;
    memset(v8, *(v7 - 2), v16);
    int v17 = *(v7 - 1);
    return memset(v9, v17, v16);
  }
  return result;
}

void *aj_YUV440SEMIP_YUV420(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV440SEMIP_YUV422(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (char *)a2[2];
    int v15 = (unsigned __int8 *)*a2;
    size_t v16 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      int v18 = v15[a4 - 1];
      size_t v19 = v17;
      memset(&v16[a4], v18, v17);
      int v20 = (unsigned __int8 *)a2[1];
      unsigned int v21 = (char *)a3[1];
      memcpy(v21, v20, a4);
      uint64_t result = memset(&v21[a4], v20[a4 - 1], v19);
    }
    if (a4 >= 0) {
      int v22 = a4;
    }
    else {
      int v22 = a4 + 1;
    }
    if (a4 >= 2)
    {
      int v23 = v22 >> 1;
      do
      {
        *v13++ = (v14[2] + *v14) >> 1;
        *v12++ = (v14[3] + v14[1]) >> 1;
        v14 += 4;
        --v23;
      }
      while (v23);
    }
    if (a4)
    {
      *v13++ = *v14;
      *v12++ = v14[1];
      v14 += 2;
    }
    if (a5 > a4)
    {
      size_t v24 = (uint64_t)(a5 - a4 + (a5 - a4 < 0)) >> 1;
      memset(v13, *(v14 - 2), v24);
      int v25 = *(v14 - 1);
      return memset(v12, v25, v24);
    }
  }
  return result;
}

void *aj_YUV440SEMIP_YUV440(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  if (a1 == 1)
  {
    aj_YUV440SEMIP_YUV444(a1, a2, a3, a4, a5);
    uint64_t v10 = *a3;
    int v9 = (char *)a3[1];
    return memcpy(v9, v10, a5);
  }
  else
  {
    int v12 = (char *)a3[4];
    int v13 = (char *)a3[2];
    int v14 = (unsigned __int8 *)a2[2];
    int v15 = (unsigned __int8 *)*a2;
    size_t v16 = (char *)*a3;
    memcpy(*a3, *a2, a4);
    int v17 = a5 - a4;
    if (a5 <= a4)
    {
      uint64_t result = memcpy(a3[1], a2[1], a4);
    }
    else
    {
      int v18 = v15[a4 - 1];
      size_t v19 = v17;
      memset(&v16[a4], v18, v17);
      int v20 = (unsigned __int8 *)a2[1];
      unsigned int v21 = (char *)a3[1];
      memcpy(v21, v20, a4);
      uint64_t result = memset(&v21[a4], v20[a4 - 1], v19);
    }
    if (a4 >= 1)
    {
      int v22 = a4;
      do
      {
        *v13++ = *v14;
        int v23 = v14 + 2;
        *v12++ = v14[1];
        v14 += 2;
        --v22;
      }
      while (v22);
      int v14 = v23;
    }
    int v24 = a5 - a4;
    if (a5 > a4)
    {
      size_t v25 = v24;
      memset(v13, *(v14 - 2), v24);
      int v26 = *(v14 - 1);
      return memset(v12, v26, v25);
    }
  }
  return result;
}

void *aj_SEMIP_to_gray(uint64_t a1, const void **a2, void **a3, int a4, int a5)
{
  int v7 = (char *)*a2;
  char v8 = (char *)*a3;
  uint64_t v9 = a4;
  uint64_t result = memcpy(*a3, *a2, a4);
  if (a5 > a4)
  {
    int v11 = v7[v9 - 1];
    return memset(&v8[v9], v11, a5 - a4);
  }
  return result;
}

unsigned char *aj_deinterleave_8888(uint64_t a1, unsigned char **a2, uint64_t a3, int a4, int a5)
{
  uint64_t result = *(unsigned char **)a3;
  int16x8_t v6 = *(unsigned char **)(a3 + 16);
  int v7 = *(unsigned char **)(a3 + 32);
  char v8 = *(unsigned char **)(a3 + 48);
  if (a4 >= 1)
  {
    uint64_t v9 = *a2;
    int v10 = a4;
    do
    {
      *result++ = *v9;
      *v6++ = v9[1];
      *v7++ = v9[2];
      *v8++ = v9[3];
      v9 += 4;
      --v10;
    }
    while (v10);
  }
  int v11 = a5 - a4;
  if (a5 > a4)
  {
    size_t v12 = v11;
    memset(result, *(result - 1), v11);
    memset(v6, *(v6 - 1), v12);
    memset(v7, *(v7 - 1), v12);
    int v13 = *(v8 - 1);
    return memset(v8, v13, v12);
  }
  return result;
}

int *aj_col_trans_row(int *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int16x8_t v5 = result;
  v22[7] = *MEMORY[0x263EF8340];
  int v6 = result[8];
  uint64_t v7 = result[4960];
  uint64_t v8 = a3 + 8 * a5;
  uint64_t v9 = *(void *)(v8 + ((uint64_t)result[4959] << 7));
  long long v21 = *(_OWORD *)(a3 + 8 * v6 * a5);
  v22[0] = v9;
  v22[1] = 0;
  void v22[2] = *(void *)(v8 + (v7 << 7));
  v22[3] = 0;
  v22[4] = *(void *)(v8 + 384);
  v22[5] = 0;
  if ((int)a4 > 0) {
    return (int *)(*((uint64_t (**)(uint64_t, uint64_t, long long *, void, void))result + 2468))(a4, a2 + 1832, &v21, result[2], result[3354]);
  }
  if (v6 >= 1)
  {
    uint64_t v12 = 0;
    int v13 = v6 * a5 - 1;
    do
    {
      uint64_t result = (int *)memcpy((void *)v22[v12 - 2], *(const void **)(a3 + 8 * (v13 + (int)v12)), v5[3354]);
      ++v12;
    }
    while (v12 < v5[8]);
  }
  if (*v5 > 1)
  {
    int v14 = a5 - 1;
    int v15 = (void **)v22;
    size_t v16 = (const void **)(a3 + 8 * v14 + 128);
    uint64_t v17 = 1;
    do
    {
      size_t v19 = *v15;
      v15 += 2;
      int v18 = v19;
      int v20 = *v16;
      v16 += 16;
      uint64_t result = (int *)memcpy(v18, v20, v5[3354] / v5[4]);
      ++v17;
    }
    while (v17 < *v5);
  }
  return result;
}

uint8x8_t **aj_resize_vertically(uint8x8_t **result, const __int16 *a2, unint64_t a3, int8x8_t *a4)
{
  if (a3)
  {
    int16x8_t v4 = *result;
    int16x8_t v5 = result[1];
    int v6 = result[2];
    uint64_t v7 = result[3];
    uint64_t v8 = result[4];
    int16x8_t v10 = vld1q_dup_s16(a2);
    uint64_t v9 = a2 + 1;
    int16x8_t v11 = vld1q_dup_s16(v9++);
    int16x8_t v12 = vld1q_dup_s16(v9++);
    int16x8_t v13 = vld1q_dup_s16(v9++);
    int16x8_t v14 = vld1q_dup_s16(v9++);
    int v15 = (__int16 *)(v9 - 5);
    uint64_t v16 = a3 >> 3;
    if (a3 >> 3)
    {
      do
      {
        uint8x8_t v17 = *v4++;
        uint8x8_t v18 = *v5++;
        uint8x8_t v19 = *v6++;
        uint8x8_t v20 = *v7++;
        uint8x8_t v21 = *v8++;
        int16x8_t v22 = (int16x8_t)vmovl_u8(v17);
        int16x8_t v23 = (int16x8_t)vmovl_u8(v18);
        int16x8_t v24 = (int16x8_t)vmovl_u8(v19);
        int16x8_t v25 = (int16x8_t)vmovl_u8(v20);
        int16x8_t v26 = (int16x8_t)vmovl_u8(v21);
        *a4++ = vqmovun_s16(vqrshrn_high_n_s32(vqrshrn_n_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vmull_s16(*(int16x4_t *)v22.i8, *(int16x4_t *)v10.i8), vmull_s16(*(int16x4_t *)v23.i8, *(int16x4_t *)v11.i8)), vmull_s16(*(int16x4_t *)v24.i8, *(int16x4_t *)v12.i8)), vmull_s16(*(int16x4_t *)v25.i8, *(int16x4_t *)v13.i8)), vmull_s16(*(int16x4_t *)v26.i8, *(int16x4_t *)v14.i8)), 0xEuLL), vqaddq_s32(vqaddq_s32(vqaddq_s32(vqaddq_s32(vmull_high_s16(v22, v10), vmull_high_s16(v23, v11)), vmull_high_s16(v24, v12)), vmull_high_s16(v25, v13)), vmull_high_s16(v26, v14)),
                    0xEuLL));
        BOOL v27 = v16-- <= 1;
      }
      while (!v27);
    }
    uint64_t v28 = a3 & 7;
    if ((a3 & 7) != 0)
    {
      do
      {
        int v29 = v4->u8[0];
        int16x8_t v4 = (uint8x8_t *)((char *)v4 + 1);
        int v30 = v29 * *v15;
        int v31 = v5->u8[0];
        int16x8_t v5 = (uint8x8_t *)((char *)v5 + 1);
        int v32 = v30 + v31 * v15[1];
        int v33 = v6->u8[0];
        int v6 = (uint8x8_t *)((char *)v6 + 1);
        int v34 = v32 + v33 * v15[2];
        int v35 = v7->u8[0];
        uint64_t v7 = (uint8x8_t *)((char *)v7 + 1);
        int v36 = v34 + v35 * v15[3];
        int v37 = v8->u8[0];
        uint64_t v8 = (uint8x8_t *)((char *)v8 + 1);
        int v38 = (v36 + v37 * v15[4] + 0x2000) >> 14;
        if (v38 <= 0) {
          int v38 = 0;
        }
        if (v38 >= 255) {
          LOBYTE(v38) = -1;
        }
        a4->i8[0] = v38;
        a4 = (int8x8_t *)((char *)a4 + 1);
        BOOL v27 = v28-- <= 1;
      }
      while (!v27);
    }
  }
  return result;
}

uint64_t aj_init_lookup(uint64_t a1)
{
  unsigned int v1 = 0;
  LODWORD(v2) = 0;
  uint64_t v3 = 1;
  while (!*(unsigned char *)(a1 + v3 - 1))
  {
LABEL_10:
    v1 *= 2;
    if (++v3 == 9)
    {
      uint64_t v11 = 0;
      *(_DWORD *)(a1 + 784) = v1;
      *(_DWORD *)(a1 + 788) = v2;
      return v11;
    }
  }
  int v4 = 0;
  unsigned int v5 = ~(-1 << v3);
  uint64_t v2 = (int)v2;
  unsigned int v6 = v5 - v1;
  if (v5 < v1) {
    unsigned int v6 = 0;
  }
  char v7 = 8 - v3;
  while (v4 != v6)
  {
    __int16 v8 = ((_WORD)v3 << 8) | *(unsigned __int8 *)(a1 + v2 + 16);
    unsigned int v9 = 1;
    do
      *(_WORD *)(a1 + 2 * ((v9 - 1) | (v1 << v7)) + 272) = v8;
    while (!(v9++ >> v7));
    ++v1;
    ++v2;
    if (++v4 >= *(unsigned __int8 *)(a1 + v3 - 1)) {
      goto LABEL_10;
    }
  }
  aj_log_error((uint64_t)"Read", "Code larger than bitlength: %d >= %d", v1, ~(-1 << v3));
  return 7;
}

uint64_t aj_read_dht_prog(unsigned __int8 **a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  char v7 = *a1 + 2;
  signed int v8 = __rev16(*(unsigned __int16 *)*a1) - 2;
  while (1)
  {
    if (v8 < 1)
    {
      uint64_t result = 0;
      *a1 = v7;
      *a2 = v6;
      return result;
    }
    if (v8 <= 0x10)
    {
      aj_log_error((uint64_t)"Read", "Not enough bytes in header for Huffman table. %d bytes remaining, requires >= 17.");
      return 4;
    }
    unint64_t v9 = *v7;
    unint64_t v10 = v9 >> 4;
    if (v9 >= 0x20)
    {
      aj_log_error((uint64_t)"Read", "Huffman table class is %d, only values 0 and 1 are allowed.");
      return 4;
    }
    uint64_t v11 = v9 & 0xF;
    if (v11 >= 4)
    {
      aj_log_error((uint64_t)"Read", "Huffman table index is %d, only values 0 to 3 are allowed.", v11);
      return 3;
    }
    uint64_t v12 = 0;
    LODWORD(v13) = 0;
    *(void *)(a3 + 16 * v11 + 8 * v10) = v6;
    int16x8_t v14 = v7 + 1;
    do
    {
      int v15 = v14[v12];
      *(unsigned char *)(v6 + v12) = v15;
      size_t v13 = (v13 + v15);
      ++v12;
    }
    while (v12 != 16);
    int v16 = v8 - 17;
    signed int v8 = v8 - 17 - v13;
    if (v16 < (int)v13)
    {
      aj_log_error((uint64_t)"Read", "Too few bytes in Huffman header. %d bytes left, requires %d bytes.");
      return 4;
    }
    if (v13 >= 0x101) {
      break;
    }
    memcpy((void *)(v6 + 16), v7 + 17, v13);
    bzero((void *)(v6 + 16 + v13), (256 - v13));
    char v7 = &v14[v13 + 16];
    uint64_t result = aj_init_lookup(v6);
    v6 += 792;
    if (result) {
      return result;
    }
  }
  aj_log_error((uint64_t)"Read", "Too many codes in Huffman table: %d codes.");
  return 4;
}

uint64_t aj_read_sos_prog(unsigned __int16 **a1, unsigned int *a2, int *a3)
{
  uint64_t v3 = (uint64_t)*a1;
  unsigned int v4 = __rev16(**a1);
  if (v4 <= 7)
  {
    aj_log_error((uint64_t)"Read", "Illegal length of SOS segment: %d");
    return 4;
  }
  unint64_t v8 = *(unsigned __int8 *)(v3 + 2);
  *a2 = v8;
  int v9 = *a3;
  if (v8) {
    BOOL v10 = v9 < (int)v8;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    aj_log_error((uint64_t)"Read", "Component count is %d, only values between 1 and %d supported.", v8, v9);
    return 3;
  }
  else
  {
    if (v4 != 2 * v8 + 6)
    {
      aj_log_error((uint64_t)"Read", "Illegal length of SOS segment.");
      return 4;
    }
    unint64_t v12 = 0;
    uint64_t v13 = v3 + 3;
    BOOL v14 = 1;
    int v15 = (unsigned __int8 *)(v3 + 3);
    while (1)
    {
      int v17 = *v15++;
      int v16 = v17;
      uint64_t v18 = *a3;
      if ((int)v18 < 1)
      {
LABEL_24:
        aj_log_error((uint64_t)"Read", "Component ID not found among declared components");
        goto LABEL_25;
      }
      uint64_t v19 = 0;
      while (a3[v19 + 16] != v16)
      {
        if (v18 == ++v19) {
          goto LABEL_24;
        }
      }
      a2[v12 + 1] = v19;
      int v15 = (unsigned __int8 *)(v13 + 2);
      unsigned int v20 = *(unsigned __int8 *)(v13 + 1);
      uint8x8_t v21 = &a2[v19];
      v21[5] = v20 >> 4;
      v21[9] = v20 & 0xF;
      if (v20 > 0x3F || (v20 & 0xF) >= 4) {
        break;
      }
      ++v12;
      v13 += 2;
      BOOL v14 = v12 < v8;
      if (v12 == v8) {
        goto LABEL_26;
      }
    }
    aj_log_error((uint64_t)"Read", "Corrupt scan, invalid huffman table indices. DC: %d, AC: %d");
LABEL_25:
    if (v14) {
      return 4;
    }
LABEL_26:
    unint64_t v23 = *a2;
    if ((int)v23 >= 2)
    {
      uint64_t v24 = 0;
      while (1)
      {
        uint64_t v25 = v24 + 1;
        if (v24 + 1 < v23) {
          break;
        }
LABEL_32:
        ++v24;
        if (v25 == v23 - 1) {
          goto LABEL_33;
        }
      }
      uint64_t v26 = v24;
      while (a2[v24 + 1] != a2[v26 + 2])
      {
        if (v23 - 1 == ++v26) {
          goto LABEL_32;
        }
      }
      aj_log_error((uint64_t)"Read", "SOS components IDs are not unique. id[%d] == id[%d] == %d");
      return 4;
    }
LABEL_33:
    unsigned int v27 = *v15;
    a2[13] = v27;
    unsigned int v28 = v15[1];
    a2[14] = v28;
    unsigned int v29 = v15[2];
    unsigned int v30 = v29 >> 4;
    unsigned int v31 = v29 & 0xF;
    a2[15] = v31;
    a2[16] = v29 >> 4;
    if (a3[20] == 194)
    {
      if (v27 > v28 || v28 >= 0x40)
      {
        aj_log_error((uint64_t)"Read", "Bad spectral selection. Ss = %d, Se = %d.");
        return 4;
      }
      if (v31 > 0xD || v29 >= 0x10 && v30 != v31 + 1)
      {
        aj_log_error((uint64_t)"Read", "Bad successive approximation. Ah = %d, Al = %d.");
        return 4;
      }
    }
    else
    {
      if (v27 || v28 != 63)
      {
        aj_log_error((uint64_t)"Read", "Bad spectral selection for baseline multiscan image. Ss = %d, Se = %d. Assuming Ss = 0, Se = 63.", v27, v28);
        *(void *)(a2 + 13) = 0x3F00000000;
        unsigned int v31 = a2[15];
        unsigned int v30 = a2[16];
      }
      if (v31 | v30) {
        aj_log_error((uint64_t)"Read", "Bad successive approximation for baseline multiscan image. Al = %d, Ah = %d. Assuming Al = 0, Ah = 0.", v31, v30);
      }
    }
    uint64_t result = 0;
    *a1 = (unsigned __int16 *)(v15 + 3);
  }
  return result;
}

uint64_t aj_read_com(uint64_t a1)
{
  int v4 = 0;
  uint64_t result = aj_istream_read_bytes_be(a1, &v4, 2);
  if (!result)
  {
    if (v4 < 3)
    {
      return 0;
    }
    else
    {
      int v3 = v4 - 2;
      while (1)
      {
        uint64_t result = aj_istream_read_bytes_be(a1, &v4, 1);
        if (result) {
          break;
        }
        if (!--v3) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t getw_little(uint64_t a1, _DWORD *a2)
{
  unsigned int v4 = 0;
  uint64_t result = aj_istream_read_bytes_le(a1, &v4, 4);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t geth_little(uint64_t a1, _WORD *a2)
{
  unsigned int v4 = 0;
  uint64_t result = aj_istream_read_bytes_le(a1, &v4, 2);
  if (!result) {
    *a2 = v4;
  }
  return result;
}

uint64_t aj_idct_s2(int16x8_t *a1, uint64_t *a2, uint64_t a3)
{
  int16x8_t v3 = a1[1];
  int16x8_t v4 = a1[2];
  int16x8_t v5 = a1[3];
  int16x8_t v6 = vqrdmulhq_lane_s16(vaddq_s16(v3, v5), (int16x4_t)0x6C8361F84546, 0);
  int16x8_t v7 = vaddq_s16(*a1, v4);
  int16x8_t v8 = vsubq_s16(*a1, v4);
  int16x8_t v9 = vaddq_s16(vqrdmulhq_lane_s16(v3, (int16x4_t)0x6C8361F84546, 1), v6);
  int16x8_t v10 = vsubq_s16(vsubq_s16(v6, vqrdmulhq_lane_s16(v5, (int16x4_t)0x6C8361F84546, 2)), v5);
  int16x8_t v11 = vaddq_s16(v7, v9);
  int16x8_t v12 = vaddq_s16(v8, v10);
  int16x8_t v13 = vsubq_s16(v8, v10);
  int16x8_t v14 = vsubq_s16(v7, v9);
  int32x4_t v15 = (int32x4_t)vtrn1q_s16(v11, v12);
  int32x4_t v16 = (int32x4_t)vtrn2q_s16(v11, v12);
  int32x4_t v17 = (int32x4_t)vtrn1q_s16(v13, v14);
  int32x4_t v18 = (int32x4_t)vtrn2q_s16(v13, v14);
  int16x8_t v19 = (int16x8_t)vtrn1q_s32(v15, v17);
  int16x8_t v20 = (int16x8_t)vtrn2q_s32(v15, v17);
  int16x8_t v21 = (int16x8_t)vtrn1q_s32(v16, v18);
  int16x8_t v22 = (int16x8_t)vtrn2q_s32(v16, v18);
  int16x8_t v23 = vqrdmulhq_lane_s16(vaddq_s16(v21, v22), (int16x4_t)0x6C8361F84546, 0);
  int16x8_t v24 = vaddq_s16(v19, v20);
  int16x8_t v25 = vsubq_s16(v19, v20);
  int16x8_t v26 = vaddq_s16(vqrdmulhq_lane_s16(v21, (int16x4_t)0x6C8361F84546, 1), v23);
  int16x8_t v27 = vsubq_s16(vsubq_s16(v23, vqrdmulhq_lane_s16(v22, (int16x4_t)0x6C8361F84546, 2)), v22);
  int16x8_t v28 = vaddq_s16(v24, v26);
  int16x8_t v29 = vaddq_s16(v25, v27);
  int16x8_t v30 = vsubq_s16(v25, v27);
  int16x8_t v31 = vsubq_s16(v24, v26);
  int32x4_t v32 = (int32x4_t)vtrn1q_s16(v28, v29);
  int32x4_t v33 = (int32x4_t)vtrn2q_s16(v28, v29);
  int32x4_t v34 = (int32x4_t)vtrn1q_s16(v30, v31);
  int32x4_t v35 = (int32x4_t)vtrn2q_s16(v30, v31);
  uint64_t v37 = *a2;
  uint64_t v38 = a2[1];
  int v36 = a2 + 2;
  _X3 = (_DWORD *)(v37 + a3);
  _X4 = (_DWORD *)(v38 + a3);
  _X5 = (_DWORD *)(*v36 + a3);
  _X6 = (_DWORD *)(v36[1] + a3);
  __asm
  {
    PRFM            #0x11, [X3]
    PRFM            #0x11, [X4]
    PRFM            #0x11, [X5]
    PRFM            #0x11, [X6]
  }
  *_X3 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X4 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn1q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X5 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v32, v34), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  *_X6 = vadd_s8(vqrshrn_n_s16((int16x8_t)vtrn2q_s32(v33, v35), 3uLL), (int8x8_t)0x8080808080808080).u32[0];
  return 4;
}

uint64_t applejpeg_get_api_number()
{
  return 31;
}

const char *applejpeg_get_git_hash()
{
  return "<APPLEJPEG_GIT_HASH>";
}

const char *applejpeg_get_framework_version()
{
  return "EmbeddedAppleJPEG-220.7";
}

const char *applejpeg_get_build_timestamp()
{
  return "Wed Dec 31 16:00:00 1969";
}

uint64_t aj_extract_info_struct(uint64_t a1)
{
  return a1 + 144;
}

uint64_t aj_extract_istream_struct(uint64_t a1)
{
  return a1 + 24;
}

uint64_t applejpeg_decode_get_headersize(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 3564);
  }
  return result;
}

double applejpeg_decode_clear_options(uint64_t a1)
{
  if (a1)
  {
    *(void *)(a1 + 3584) = 0x100000001;
    *(_DWORD *)(a1 + 3592) = 0;
    *(void *)(a1 + 3596) = -1;
    *(void *)(a1 + 3604) = -1;
    *(_DWORD *)(a1 + 3612) = 0;
    *(void *)(a1 + 3616) = 0;
    *(void *)(a1 + 3672) = 0;
    *(void *)(a1 + 3664) = 0;
    *(void *)(a1 + 3656) = 0x1FF000000;
    *(_OWORD *)(a1 + 3680) = xmmword_210410570;
    double result = 0.0;
    *(_OWORD *)(a1 + 3624) = 0u;
    *(_OWORD *)(a1 + 3640) = 0u;
    *(_DWORD *)(a1 + 3696) = 0;
    *(_DWORD *)(a1 + 3724) = 0;
    *(void *)(a1 + 3712) = 0;
    *(void *)(a1 + 3704) = 0;
    *(unsigned char *)(a1 + 3720) = 0;
    *(unsigned char *)(a1 + 3728) = 1;
    *(unsigned char *)(a1 + 12697) = 0;
  }
  return result;
}

uint64_t applejpeg_decode_set_parse_option_use_first_sof(uint64_t a1, char a2)
{
  if (!a1) {
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928))
  {
    aj_log_error((uint64_t)"Decode", "applejpeg_decode_set_parse_option_use_first_sof must be called before any file is opened");
    return 5;
  }
  else
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 12696) = a2;
  }
  return result;
}

uint64_t applejpeg_decode_open_jpeg_dib(uint64_t a1, uint64_t *a2)
{
  return decode_open(a1, 0, a2, 0, 1);
}

uint64_t applejpeg_decode_open_mem(uint64_t a1, uint64_t *a2)
{
  return decode_open(a1, 0, a2, 0, 0);
}

_OWORD *applejpeg_decode_clone_session(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12928) == 2 && !*(_DWORD *)(a1 + 12992) && !*(void *)(a1 + 13064) && !*(void *)(a1 + 104))
  {
    int16x8_t v4 = applejpeg_decode_create((void *)a1);
    uint64_t v2 = v4;
    if (!v4) {
      return v2;
    }
    long long v5 = *(_OWORD *)(a1 + 24);
    long long v6 = *(_OWORD *)(a1 + 40);
    long long v7 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)((char *)v4 + 72) = *(_OWORD *)(a1 + 72);
    *(_OWORD *)((char *)v4 + 56) = v7;
    *(_OWORD *)((char *)v4 + 40) = v6;
    *(_OWORD *)((char *)v4 + 24) = v5;
    long long v8 = *(_OWORD *)(a1 + 88);
    long long v9 = *(_OWORD *)(a1 + 104);
    long long v10 = *(_OWORD *)(a1 + 120);
    *((void *)v4 + 17) = *(void *)(a1 + 136);
    *(_OWORD *)((char *)v4 + 120) = v10;
    *(_OWORD *)((char *)v4 + 104) = v9;
    *(_OWORD *)((char *)v4 + 88) = v8;
    memcpy(v4 + 9, (const void *)(a1 + 144), 0xD60uLL);
    if (!copy_imagesession((uint64_t)(v2 + 234), (const void **)(a1 + 3744), (void *)v2 + 1631))
    {
      *((_DWORD *)v2 + 3232) = *(_DWORD *)(a1 + 12928);
      return v2;
    }
    applejpeg_decode_destroy(v2);
  }
  return 0;
}

uint64_t copy_imagesession(uint64_t a1, const void **a2, void *a3)
{
  memcpy((void *)a1, a2, 0x1B8uLL);
  if (a2[12])
  {
    *(void *)(a1 + 96) = 0;
    int v6 = *(_DWORD *)(a1 + 128);
    int v7 = 20 * *(_DWORD *)(a1 + 132);
    long long v8 = (void *)(*(uint64_t (**)(void, void))*a3)((v7 + 8) * v6, *(void *)(*a3 + 16));
    a3[4] = v8;
    *(void *)(a1 + 96) = v8;
    if (!v8) {
      return 6;
    }
    int v9 = 8 * v6;
    bzero(v8, v9 + *(_DWORD *)(a1 + 128) * v7);
    long long v10 = *(void **)(a1 + 96);
    if (!v10) {
      return 6;
    }
    memcpy(v10, a2[12], v9 + *(_DWORD *)(a1 + 128) * v7);
    uint64_t v11 = *(void *)(a1 + 96);
    *(void *)(a1 + 104) = v11;
    uint64_t v12 = *(unsigned int *)(a1 + 128);
    if ((int)v12 >= 1)
    {
      uint64_t v13 = 0;
      uint64_t v14 = v11 + v9;
      uint64_t v15 = 8 * v12;
      uint64_t v16 = 20 * *(int *)(a1 + 132);
      do
      {
        *(void *)(*(void *)(a1 + 104) + v13) = v14;
        v13 += 8;
        v14 += v16;
      }
      while (v15 != v13);
    }
  }
  uint64_t v17 = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  int32x4_t v18 = (_OWORD *)(a1 + 8);
  v18[2] = 0u;
  v18[3] = 0u;
  v18[1] = 0u;
  int16x8_t v19 = a2 + 1;
  char v20 = 1;
  while (2)
  {
    uint64_t v21 = 0;
    char v22 = v20;
    int16x8_t v23 = &v19[v17];
    int16x8_t v24 = (char *)v18 + 8 * v17;
    do
    {
      int16x8_t v25 = (char *)v23[v21];
      if (v25)
      {
        if (aj_huffman_decode_is_static_table(v25))
        {
          *(void *)&v24[v21 * 8] = v23[v21];
        }
        else
        {
          uint64_t v26 = *(void *)&v24[v21 * 8];
          if (v26) {
            (*(void (**)(uint64_t, void))(*a3 + 8))(v26, *(void *)(*a3 + 16));
          }
          int16x8_t v27 = (void *)(*(uint64_t (**)(uint64_t, void))*a3)(4500, *(void *)(*a3 + 16));
          *(void *)&v24[v21 * 8] = v27;
          if (!v27 || (bzero(v27, 0x1194uLL), (int16x8_t v28 = *(void **)&v24[v21 * 8]) == 0))
          {
            aj_log_error((uint64_t)"Decode", "Could not allocate memory for huffman table");
            return 6;
          }
          memcpy(v28, v23[v21], 0x1194uLL);
        }
      }
      v21 += 2;
    }
    while (v21 != 8);
    char v20 = 0;
    uint64_t v17 = 1;
    if (v22) {
      continue;
    }
    break;
  }
  return 0;
}

uint64_t applejpeg_decode_build_index(uint64_t a1)
{
  if (!a1)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(unsigned char *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    return 3;
  }
  if ((*(_DWORD *)(a1 + 3688) - 0x10000) < 0xFFFF0001
    || (*(_DWORD *)(a1 + 3692) - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"Decode", "Unsupported sampling interval");
    return 8;
  }
  if (*(unsigned char *)(a1 + 228)) {
    return 0;
  }
  if (*(void *)(a1 + 104) && (!*(void *)(a1 + 112) || !*(void *)(a1 + 96)))
  {
    aj_log_error((uint64_t)"Decode", "rewind or skip callback not provided");
    return 8;
  }
  log_basic_decode_info(OS_LOG_TYPE_DEBUG, a1, 0, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
  *(_DWORD *)(a1 + 4108) = 0;
  uint64_t inited = aj_decode_init_index(a1 + 13000, a1 + 13048, (void *)(a1 + 4192), a1 + 3744, a1 + 11168, (int *)(a1 + 144), a1 + 24, a1 + 3584, a1, *(_DWORD *)(a1 + 3564));
  if (inited) {
    goto LABEL_18;
  }
  if (!*(_DWORD *)(a1 + 11168))
  {
    dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
    return 0;
  }
  uint64_t inited = aj_create_ra_table_mt(a1 + 4192, (_DWORD *)(a1 + 11168));
  os_log_object = aj_get_os_log_object();
  if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_DEBUG))
  {
    applejpeg_decode_build_index_cold_1();
    if (!inited)
    {
LABEL_28:
      uint64_t inited = aj_istream_move_to_position(a1 + 24, *(unsigned int *)(a1 + 3564));
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      if (!inited) {
        return inited;
      }
      goto LABEL_19;
    }
  }
  else if (!inited)
  {
    goto LABEL_28;
  }
LABEL_18:
  dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
LABEL_19:
  if (*(void *)(a1 + 3840) && *(void *)(a1 + 13080))
  {
    (*(void (**)(void))(a1 + 8))();
    *(void *)(a1 + 3840) = 0;
    *(void *)(a1 + 13080) = 0;
  }
  *(_DWORD *)(a1 + 3880) = 0;
  if (inited == -2)
  {
    aj_log_error((uint64_t)"Decode", "IO suspension is not supported for building an index table separately");
    return 9;
  }
  return inited;
}

void log_basic_decode_info(os_log_type_t a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  int v11 = *(_DWORD *)(a5 + 28) | (16 * *(_DWORD *)(a5 + 44)) | (*(_DWORD *)(a5 + 24) << 8) | (*(_DWORD *)(a5 + 40) << 12) | (*(_DWORD *)(a5 + 20) << 16) | (*(_DWORD *)(a5 + 36) << 20) | (*(_DWORD *)(a5 + 16) << 24) | (*(_DWORD *)(a5 + 32) << 28);
  int v12 = (a4[32] << 14) | (a4[34] << 28) | a4[33];
  int v13 = *(_DWORD *)(a5 + 3328);
  if (v13 <= 3) {
    int v14 = 32 * v13;
  }
  else {
    int v14 = 0;
  }
  int v15 = *(_DWORD *)(a5 + 3332);
  if (v15 <= 3) {
    int v16 = 4 * v15;
  }
  else {
    int v16 = 0;
  }
  int v17 = (*(_DWORD *)a5 << 12) | (*(_DWORD *)(a5 + 3404) << 16) | (*(unsigned __int8 *)(a5 + 84) << 11) | (*(_DWORD *)(a5 + 3408) << 10) | (*(_DWORD *)(a5 + 3412) << 8) | v14 | v16 | (2 * (*(void *)(a2 + 104) != 0));
  os_log_object = aj_get_os_log_object();
  BOOL v19 = os_log_type_enabled(os_log_object, a1);
  if (a3)
  {
    if (!v19) {
      goto LABEL_13;
    }
    int v20 = *(_DWORD *)(a5 + 80);
    int v21 = *(_DWORD *)(a5 + 12) | (*(_DWORD *)(a5 + 8) << 16);
    int v22 = *(_DWORD *)(a2 + 76);
    *(_DWORD *)buf = 134219520;
    uint64_t v50 = a2;
    __int16 v51 = 1024;
    int v52 = v20;
    __int16 v53 = 1024;
    int v54 = v21;
    __int16 v55 = 1024;
    int v56 = v17;
    __int16 v57 = 1024;
    int v58 = v11;
    __int16 v59 = 1024;
    int v60 = v12;
    __int16 v61 = 1024;
    int v62 = v22;
    int16x8_t v23 = "[%p] Decoding: %2X 0x%08X 0x%08X 0x%08X 0x%08X %d";
    int16x8_t v24 = os_log_object;
    os_log_type_t v25 = a1;
    uint32_t v26 = 48;
  }
  else
  {
    if (!v19) {
      goto LABEL_13;
    }
    int v27 = *(_DWORD *)(a5 + 80);
    int v28 = *(_DWORD *)(a5 + 12) | (*(_DWORD *)(a5 + 8) << 16);
    *(_DWORD *)buf = 134219264;
    uint64_t v50 = a2;
    __int16 v51 = 1024;
    int v52 = v27;
    __int16 v53 = 1024;
    int v54 = v28;
    __int16 v55 = 1024;
    int v56 = v17;
    __int16 v57 = 1024;
    int v58 = v11;
    __int16 v59 = 1024;
    int v60 = v12;
    int16x8_t v23 = "[%p] Building: %2X 0x%08X 0x%08X 0x%08X 0x%08X";
    int16x8_t v24 = os_log_object;
    os_log_type_t v25 = a1;
    uint32_t v26 = 42;
  }
  _os_log_impl(&dword_2103CE000, v24, v25, v23, buf, v26);
LABEL_13:
  int v30 = *(_DWORD *)(a6 + 28);
  int v29 = *(_DWORD *)(a6 + 32);
  uint64_t v48 = a2;
  if (v30)
  {
LABEL_14:
    int v47 = v29;
    goto LABEL_17;
  }
  if (!v29)
  {
    int v30 = *(_DWORD *)(a6 + 76);
    int v29 = -1;
    goto LABEL_14;
  }
  int v47 = *(_DWORD *)(a6 + 32);
  int v30 = 0;
LABEL_17:
  int v32 = *(_DWORD *)a6;
  int v31 = *(_DWORD *)(a6 + 4);
  int v33 = *(_DWORD *)(a6 + 80);
  int v34 = *(_DWORD *)(a6 + 104);
  int v35 = *(_DWORD *)(a6 + 108);
  int v36 = *(_DWORD *)(a6 + 8);
  int v45 = *(unsigned __int16 *)(a6 + 16);
  int v46 = *(_DWORD *)(a6 + 12);
  int v43 = *(_DWORD *)(a6 + 100);
  int v44 = *(_DWORD *)(a6 + 20);
  int v37 = *(unsigned __int16 *)(a6 + 24);
  uint64_t v38 = aj_get_os_log_object();
  if (os_log_type_enabled(v38, a1))
  {
    if (v35 <= 63) {
      int v39 = v35;
    }
    else {
      int v39 = 0;
    }
    int v40 = (v32 << 19) - 0x80000;
    if (v32 >= 8) {
      int v40 = 3670016;
    }
    *(_DWORD *)buf = 134219264;
    uint64_t v50 = v48;
    int v41 = v40 | (v36 << 15) | ((v31 != 0) << 14) | ((v33 != 0) << 13) | ((v43 != 0) << 12);
    int v42 = v34 << 6;
    __int16 v51 = 1024;
    int v52 = v30;
    __int16 v53 = 1024;
    int v54 = v47;
    if (v34 > 63) {
      int v42 = 0;
    }
    __int16 v55 = 1024;
    int v56 = v45 | (v46 << 16);
    __int16 v57 = 1024;
    int v58 = v37 | (v44 << 16);
    __int16 v59 = 1024;
    int v60 = v41 | v42 | v39;
    _os_log_impl(&dword_2103CE000, v38, a1, "[%p] Options: %dx%d [%08X,%08X] %08X", buf, 0x2Au);
  }
}

__n128 applejpeg_decode_build_index_table(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    if (*(unsigned char *)(a1 + 230))
    {
      aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    }
    else
    {
      long long v16 = *(_OWORD *)(a1 + 3680);
      long long v17 = *(_OWORD *)(a1 + 3696);
      uint64_t v18 = *(void *)(a1 + 3712);
      __n128 v12 = *(__n128 *)(a1 + 3616);
      long long v13 = *(_OWORD *)(a1 + 3632);
      long long v14 = *(_OWORD *)(a1 + 3648);
      long long v15 = *(_OWORD *)(a1 + 3664);
      long long v10 = *(_OWORD *)(a1 + 3584);
      long long v11 = *(_OWORD *)(a1 + 3600);
      *(_OWORD *)(a1 + 3584) = *(_OWORD *)a2;
      long long v4 = *(_OWORD *)(a2 + 16);
      long long v5 = *(_OWORD *)(a2 + 32);
      long long v6 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 3648) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3632) = v6;
      *(_OWORD *)(a1 + 3616) = v5;
      *(_OWORD *)(a1 + 3600) = v4;
      long long v7 = *(_OWORD *)(a2 + 80);
      long long v8 = *(_OWORD *)(a2 + 96);
      long long v9 = *(_OWORD *)(a2 + 112);
      *(void *)(a1 + 3712) = *(void *)(a2 + 128);
      *(_OWORD *)(a1 + 3696) = v9;
      *(_OWORD *)(a1 + 3680) = v8;
      *(_OWORD *)(a1 + 3664) = v7;
      applejpeg_decode_build_index(a1);
      *(_OWORD *)(a1 + 3664) = v15;
      *(_OWORD *)(a1 + 3680) = v16;
      *(_OWORD *)(a1 + 3696) = v17;
      *(_OWORD *)(a1 + 3600) = v11;
      __n128 result = v12;
      *(__n128 *)(a1 + 3616) = v12;
      *(_OWORD *)(a1 + 3632) = v13;
      *(_OWORD *)(a1 + 3648) = v14;
      *(void *)(a1 + 3712) = v18;
      *(_OWORD *)(a1 + 3584) = v10;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
  }
  return result;
}

uint64_t applejpeg_decode_set_ra_table(uint64_t a1, uint64_t a2, unint64_t a3)
{
  long long v51 = 0u;
  memset(v50, 0, sizeof(v50));
  if (!a1) {
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(unsigned char *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Random access table is not supported for lossless JPEGs");
    return 3;
  }
  if (!a2 || !a3)
  {
    aj_log_error((uint64_t)"Decode", "Table or table size may not be NULL");
    return 8;
  }
  if (a3 >= 0x2800001)
  {
    aj_log_error((uint64_t)"Decode", "Table size may not be larger than %d");
    return 8;
  }
  if ((int)(2 * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Illegal or corrupt RA-table: Table too small to be a RA-table");
    return 8;
  }
  int v7 = *(_DWORD *)(a1 + 76);
  if (!v7)
  {
    aj_log_error((uint64_t)"Decode", "File size must be known in order to set a RA-table");
    return 8;
  }
  if (*(void *)a2 != 0x47504A454C505041 || *(void *)(a2 + 8) != 0x454843414355434DLL)
  {
    aj_log_error((uint64_t)"Decode", "Illegal or corrupt RA-table: Wrong magic string");
    return 12;
  }
  if (*(_DWORD *)(a2 + 16) != 4)
  {
    aj_log_error((uint64_t)"Decode", "Cache file version is not supported");
    return 12;
  }
  if (*(int *)(a2 + 20) + 24 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Size is smaller than indicated in table header.");
    return 12;
  }
  if (*(_DWORD *)(a2 + 24))
  {
    aj_log_error((uint64_t)"Decode", "Table checksums do not match.");
    return 12;
  }
  if (*(_DWORD *)(a1 + 120) + v7 != *(_DWORD *)(a2 + 28))
  {
    aj_log_error((uint64_t)"Decode", "RA-table image size does not match image");
    return 12;
  }
  unsigned int v9 = *(_DWORD *)(a2 + 32);
  LODWORD(v50[0]) = v9;
  if (v9 >= 0xA)
  {
    aj_log_error((uint64_t)"Decode", "Illegal number of check states: %u");
    return 12;
  }
  int v10 = aj_istream_state_serialized_size();
  if ((unint64_t)(v10 + v10 * v9) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Table size too small to contain expected data");
    return 12;
  }
  v52[0] = 0;
  v52[1] = 0;
  int v53 = 0;
  long long v11 = *(unsigned __int8 **)(a1 + 40);
  if (v11 && *v11 == 217 && *(_DWORD *)(a1 + 48) == -9)
  {
    char v12 = 1;
  }
  else
  {
    uint64_t v13 = aj_istream_state_save(a1 + 24, (uint64_t)v52);
    if (v13)
    {
      uint64_t v14 = v13;
      long long v15 = "Could not save state when setting RA-table";
LABEL_40:
      aj_log_error((uint64_t)"Decode", v15);
      return v14;
    }
    char v12 = 0;
  }
  long long v16 = (int *)(a2 + 36);
  int v17 = aj_istream_state_serialized_size();
  if (v9)
  {
    unint64_t v18 = 0;
    LODWORD(v19) = 0;
    uint64_t v20 = v17;
    int v21 = (char *)v50 + 4;
    do
    {
      aj_istream_state_deserialize((uint64_t)v21, (uint64_t)v16);
      long long v16 = (int *)((char *)v16 + v20);
      if (check_mcu_table((uint64_t)v21, a1 + 24)) {
        uint64_t v19 = 12;
      }
      else {
        uint64_t v19 = v19;
      }
      ++v18;
      v21 += 20;
    }
    while (v18 < v9);
  }
  else
  {
    uint64_t v19 = 0;
  }
  if (v12)
  {
    aj_reset_mcustate((void *)(a1 + 11280), a1 + 24);
    uint64_t v22 = *(unsigned int *)(a1 + 3564);
    if (*(unsigned char *)(a1 + 228))
    {
      if (*(void *)(a1 + 104)) {
        uint64_t v22 = 0;
      }
      else {
        uint64_t v22 = v22;
      }
    }
    uint64_t v23 = aj_istream_move_to_position(a1 + 24, v22);
  }
  else
  {
    uint64_t v23 = aj_istream_state_restore(a1 + 24, (uint64_t)v52);
  }
  uint64_t v14 = v23;
  if (v23) {
    return v14;
  }
  uint64_t v14 = v19;
  if (v19) {
    return v14;
  }
  int v24 = *v16;
  int v25 = v16[1];
  int v46 = *v16;
  int v47 = v25;
  int v26 = v16[2];
  int v27 = v16[3];
  int v48 = v26;
  int v49 = v27;
  uint64_t v14 = 12;
  long long v15 = "Table data is corrupt";
  if ((*v16 - 0x10000) < 0xFFFF0001
    || (v25 - 0x10000) < 0xFFFF0001
    || (v26 - 0x10000) < 0xFFFF0001
    || v27 < 1
    || v27 >= 0x10000
    || v24 != (v26 + *(_DWORD *)(a1 + 3824) - 1) / v26
    || v25 != (v27 + *(_DWORD *)(a1 + 3828) - 1) / v27)
  {
    goto LABEL_40;
  }
  if ((unint64_t)((v9 + v25 * v24) * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Table size too small to contain expected data");
    return v14;
  }
  *((void *)&v51 + 1) = v16 + 4;
  int v28 = aj_istream_state_serialized_size();
  *(void *)(a1 + 3864) = 0;
  *(_DWORD *)(a1 + 3860) = v48;
  *(_DWORD *)(a1 + 3856) = v49;
  int v29 = v47;
  *(_DWORD *)(a1 + 3876) = v46;
  *(_DWORD *)(a1 + 3872) = v47;
  int v30 = 8 * v47;
  int v31 = 20 * v46;
  uint64_t v32 = *(void *)(a1 + 3840);
  if (v32)
  {
    (*(void (**)(uint64_t, void))(*(void *)(a1 + 13048) + 8))(v32, *(void *)(*(void *)(a1 + 13048) + 16));
    int v29 = *(_DWORD *)(a1 + 3872);
  }
  int v33 = (void *)(**(uint64_t (***)(void, void))(a1 + 13048))(v30 + v29 * v31, *(void *)(*(void *)(a1 + 13048) + 16));
  *(void *)(a1 + 13080) = v33;
  *(void *)(a1 + 3840) = v33;
  if (v33 && (bzero(v33, v30 + *(_DWORD *)(a1 + 3872) * v31), (uint64_t v34 = *(void *)(a1 + 3840)) != 0))
  {
    *(void *)(a1 + 3848) = v34;
    uint64_t v35 = *(unsigned int *)(a1 + 3872);
    if ((int)v35 >= 1)
    {
      uint64_t v36 = 0;
      uint64_t v37 = v34 + v30;
      uint64_t v38 = *(int *)(a1 + 3876);
      do
      {
        *(void *)(*(void *)(a1 + 3848) + v36) = v37;
        v36 += 8;
        v37 += 20 * v38;
      }
      while (8 * v35 != v36);
      uint64_t v39 = 0;
      uint64_t v40 = *((void *)&v51 + 1);
      do
      {
        if ((int)v38 >= 1)
        {
          uint64_t v41 = 0;
          for (uint64_t i = 0; i < v38; ++i)
          {
            aj_istream_state_deserialize(*(void *)(*(void *)(a1 + 3848) + 8 * v39) + v41, v40);
            v40 += v28;
            uint64_t v38 = *(int *)(a1 + 3876);
            v41 += 20;
          }
          LODWORD(v35) = *(_DWORD *)(a1 + 3872);
        }
        ++v39;
      }
      while (v39 < (int)v35);
    }
    uint64_t v43 = LODWORD(v50[0]);
    if (LODWORD(v50[0]))
    {
      uint64_t v44 = a1 + 3888;
      int v45 = (char *)v50 + 4;
      do
      {
        *(_OWORD *)uint64_t v44 = *(_OWORD *)v45;
        *(_DWORD *)(v44 + 16) = *((_DWORD *)v45 + 4);
        v44 += 24;
        v45 += 20;
        --v43;
      }
      while (v43);
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 3880) = 3;
    *(_DWORD *)(a1 + 11168) = 0;
    *(void *)(a1 + 11184) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Could not allocate memory for RA-table");
    return 6;
  }
  return result;
}

uint64_t applejpeg_decode_dump_ra_table(uint64_t a1, uint64_t a2, unint64_t a3, int a4, int a5)
{
  if (!a2 || !a3)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take null input");
    return 8;
  }
  if (a3 >> 31)
  {
    aj_log_error((uint64_t)"Decode", "Table size may not be larger than %d");
    return 5;
  }
  if ((a4 - 0x10000) < 0xFFFF0001 || (a5 - 0x10000) <= 0xFFFF0000)
  {
    aj_log_error((uint64_t)"Decode", "Unsupported sampling interval");
    return 8;
  }
  int v8 = *(_DWORD *)(a1 + 3856);
  if (v8 > a4 || (int v9 = *(_DWORD *)(a1 + 3860), v9 > a5))
  {
    aj_log_error((uint64_t)"Decode", "Illegal sampling interval. Use recommended intervals.");
    return 5;
  }
  if ((*(_DWORD *)(a1 + 3880) & 0xFFFFFFFE) != 2 || !*(void *)(a1 + 3840) || !*(void *)(a1 + 3848))
  {
    aj_log_error((uint64_t)"Decode", "RA-table not created, cannot dump it");
    return 5;
  }
  int v12 = *(_DWORD *)(a1 + 3824);
  uint64_t v13 = ((a5 + v12 - 1) / a5);
  int v14 = *(_DWORD *)(a1 + 3828);
  if (v12 < 4 || v14 < 4) {
    uint64_t v16 = 1;
  }
  else {
    uint64_t v16 = 9;
  }
  uint64_t v27 = ((a4 + v14 - 1) / a4);
  int v26 = v16 + v27 * v13;
  if ((int)(v26 * aj_istream_state_serialized_size()) + 52 > a3)
  {
    aj_log_error((uint64_t)"Decode", "Supplied table is not large enough");
    return 8;
  }
  int v17 = a5 / v9;
  *(_OWORD *)a2 = *(_OWORD *)"APPLEJPGMCUCACHE";
  *(_DWORD *)(a2 + 16) = 4;
  int v25 = a4 / v8;
  *(_DWORD *)(a2 + 20) = aj_istream_state_serialized_size() * v26 + 26;
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 120) + *(_DWORD *)(a1 + 76);
  *(_DWORD *)(a2 + 32) = v16;
  unint64_t v18 = (_DWORD *)(a2 + 36);
  uint64_t v19 = (int)aj_istream_state_serialized_size();
  uint64_t v20 = a1 + 3888;
  do
  {
    aj_istream_state_serialize((uint64_t)v18, v20);
    unint64_t v18 = (_DWORD *)((char *)v18 + v19);
    v20 += 24;
    --v16;
  }
  while (v16);
  _DWORD *v18 = v13;
  v18[1] = v27;
  v18[2] = a5;
  v18[3] = a4;
  if ((int)v27 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = (uint64_t)(v18 + 4);
    uint64_t v23 = v13;
    do
    {
      if ((int)v13 >= 1)
      {
        uint64_t v24 = 0;
        do
        {
          aj_istream_state_serialize(v22, *(void *)(*(void *)(a1 + 3848) + 8 * v21 * v25) + v24);
          v22 += v19;
          v24 += 20 * v17;
          --v13;
        }
        while (v13);
      }
      ++v21;
      uint64_t v13 = v23;
    }
    while (v21 != v27);
  }
  uint64_t result = 0;
  *(_DWORD *)(a2 + 24) = 0;
  return result;
}

uint64_t applejpeg_decode_get_bytes_read(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 11280);
  if (result) {
    return aj_istream_get_pos(result);
  }
  return result;
}

uint64_t applejpeg_decode_get_qtables(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  return _get_qtables_helper(a1, a2, 0, a3, a4);
}

uint64_t _get_qtables_helper(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  v16[2] = *MEMORY[0x263EF8340];
  v16[0] = 0;
  v16[1] = 0;
  v15[0] = 0;
  v15[1] = 0;
  if (!a1 || !a4 || !a5)
  {
    aj_log_error((uint64_t)"Decode", "Function cannot take NULL arguments");
    return 8;
  }
  if (!(a2 | a3))
  {
    aj_log_error((uint64_t)"Decode", "qtable argument may not be NULL");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  if (*(unsigned char *)(a1 + 230))
  {
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  if (*(int *)(a1 + 144) < 1)
  {
    int v8 = 0;
LABEL_34:
    uint64_t result = 0;
    *a4 = v8;
    return result;
  }
  unint64_t v6 = 0;
  int v7 = 0;
  int v8 = 0;
  while (1)
  {
    uint64_t v9 = *(unsigned int *)(a1 + 4 * v6 + 192);
    if (v9 > 3 || !*(_DWORD *)(a1 + 4 * v9 + 1256))
    {
      aj_log_error((uint64_t)"Decode", "The file is referencing an undefined Q table");
      return 4;
    }
    if (!*((_DWORD *)v16 + v9)) {
      break;
    }
    *(_DWORD *)(a5 + 4 * v6) = *((_DWORD *)v15 + v9);
LABEL_29:
    if (v6 <= 2 && (uint64_t)++v6 < *(int *)(a1 + 144)) {
      continue;
    }
    goto LABEL_34;
  }
  if (a2)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(void *)(a2 + 8 * v7);
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v10 = *(void *)(a3 + 8 * v7);
  }
  if (v11 | v10)
  {
    for (uint64_t i = 0; i != 64; ++i)
    {
      int v13 = *(_DWORD *)(a1 + (v9 << 8) + 232 + i * 4);
      uint64_t v14 = aj_glob_zigzag[i];
      if (a2) {
        *(unsigned char *)(v11 + v14) = v13;
      }
      else {
        *(_WORD *)(v10 + 2 * v14) = v13;
      }
    }
    *(_DWORD *)(a5 + 4 * v6) = v7;
    *((_DWORD *)v15 + v9) = v7++;
    ++v8;
    *((_DWORD *)v16 + v9) = 1;
    goto LABEL_29;
  }
  aj_log_error((uint64_t)"Decode", "Null pointer passed as quantization table");
  return 8;
}

uint64_t applejpeg_decode_get_qtables16(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  return _get_qtables_helper(a1, 0, a2, a3, a4);
}

uint64_t applejpeg_decode_get_segment_info(uint64_t a1, unsigned int a2, _OWORD *a3)
{
  if (a1 && a3)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      if ((a2 & 0x80000000) != 0 || *(_DWORD *)(a1 + 3572) <= (signed int)a2)
      {
        aj_log_error((uint64_t)"Decode", "Index out of bounds");
        return 5;
      }
      else
      {
        uint64_t result = 0;
        *a3 = *(_OWORD *)(*(void *)(a1 + 3576) + 16 * a2);
      }
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_set_option_outsize(uint64_t a1, int a2, int a3, int a4)
{
  if (!a1) {
    return 8;
  }
  if (a4 | a3 | a2)
  {
    if (a2 && a4 | a3)
    {
      aj_log_error((uint64_t)"Decode", "Can not set both output scale and width/height");
    }
    else
    {
      if ((a3 != 0) == (a4 != 0))
      {
        uint64_t v4 = 0;
        *(_DWORD *)(a1 + 3660) = a2;
        *(_DWORD *)(a1 + 3612) = a3;
        *(_DWORD *)(a1 + 3616) = a4;
        *(unsigned char *)(a1 + 12697) = 0;
        return v4;
      }
      aj_log_error((uint64_t)"Decode", "Can not set only one output dimension");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Must set either output scale or width/height");
  }
  return 5;
}

uint64_t applejpeg_decode_set_option_aspect(uint64_t a1, unsigned int a2, int a3)
{
  if (!a1) {
    return 8;
  }
  if (a2 >= 4)
  {
    aj_log_error((uint64_t)"Decode", "Unknown aspect ratio option: %d", a2);
    return 5;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 3620) = a2;
    *(_DWORD *)(a1 + 3656) = a3;
    *(unsigned char *)(a1 + 12697) = 0;
  }
  return result;
}

uint64_t applejpeg_decode_set_option_outformat(uint64_t a1, int a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 3592) = a2;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_orientation(uint64_t a1, int a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = aj_transforms_from_orientation(a2, (_DWORD *)(a1 + 3664), (_DWORD *)(a1 + 3668), (_DWORD *)(a1 + 3672));
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_multithread(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 3584) = a2;
  *(_DWORD *)(a1 + 3588) = a3;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_crop(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a1) {
    return 8;
  }
  if ((a2 & 0x8000000080000000) != 0 || (int)a3 < 1 || a3 <= 0)
  {
    aj_log_error((uint64_t)"Decode", "Invalid cropregion: (%d,%d) %dx%d", a2, HIDWORD(a2), a3, HIDWORD(a3));
    return 5;
  }
  else
  {
    uint64_t v3 = 0;
    *(void *)(a1 + 3596) = a2;
    *(void *)(a1 + 3604) = a3;
    *(unsigned char *)(a1 + 12697) = 0;
  }
  return v3;
}

uint64_t applejpeg_decode_set_option_upsampling(uint64_t a1, int a2)
{
  if (!a1) {
    return 8;
  }
  if (*(int *)(a1 + 148) > 8) {
    return 0;
  }
  if (a2)
  {
    if (a2 != 1)
    {
      aj_log_error((uint64_t)"Decode", "Unknown upsampling method: %d", a2);
      return 5;
    }
    int v3 = 4;
  }
  else
  {
    int v3 = 3;
  }
  uint64_t v2 = 0;
  *(_DWORD *)(a1 + 3680) = v3;
  *(unsigned char *)(a1 + 12697) = 0;
  return v2;
}

uint64_t applejpeg_decode_set_option_stride(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 8;
  }
  for (uint64_t i = 0; i != 32; i += 8)
    *(void *)(a1 + 3624 + i) = *(void *)(a2 + i);
  uint64_t v3 = 0;
  *(unsigned char *)(a1 + 12697) = 0;
  return v3;
}

uint64_t applejpeg_decode_set_option_buildindex(uint64_t a1, int a2, int a3, int a4)
{
  if (!a1) {
    return 8;
  }
  *(_DWORD *)(a1 + 3684) = a2;
  if (a4 >= 1) {
    *(_DWORD *)(a1 + 3692) = a4;
  }
  if (a3 >= 1) {
    *(_DWORD *)(a1 + 3688) = a3;
  }
  uint64_t v4 = 0;
  *(unsigned char *)(a1 + 12697) = 0;
  return v4;
}

uint64_t applejpeg_decode_set_option_callback(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(void *)(a1 + 3704) = a3;
  *(void *)(a1 + 3712) = a4;
  *(_DWORD *)(a1 + 3696) = a2;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_force_app14(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return 8;
  }
  if (a2 < 3)
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 3720) = 1;
    *(_DWORD *)(a1 + 3724) = a2;
    *(unsigned char *)(a1 + 12697) = 0;
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Unknown App14 transform: %d", a2);
    return 5;
  }
  return result;
}

uint64_t applejpeg_decode_set_option_error_fill(uint64_t a1, char a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 3728) = a2;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_mosquito_spray(uint64_t a1, int a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 3732) = a2;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

uint64_t applejpeg_decode_set_option_alternate_420_prediction(uint64_t a1, char a2)
{
  if (!a1) {
    return 8;
  }
  uint64_t result = 0;
  *(unsigned char *)(a1 + 3736) = a2;
  *(unsigned char *)(a1 + 12697) = 0;
  return result;
}

double applejpeg_decode_options_init(uint64_t a1)
{
  *(void *)a1 = 0x100000001;
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)(a1 + 12) = -1;
  *(void *)(a1 + 20) = -1;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0x1FF000000;
  *(_OWORD *)(a1 + 96) = xmmword_210410570;
  double result = 0.0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  return result;
}

uint64_t applejpeg_decode_get_output_dimensions(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  if (a1 && a1[3232] == 2)
  {
    uint64_t result = commit_decode_options_if_needed((uint64_t)a1);
    if (!result)
    {
      if (a2) {
        *a2 = a1[3176];
      }
      uint64_t result = 0;
      if (a3) {
        *a3 = a1[3177];
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  return result;
}

uint64_t commit_decode_options_if_needed(uint64_t a1)
{
  v57[5] = *MEMORY[0x263EF8340];
  unsigned int v1 = (unsigned char *)(a1 + 12697);
  if (*(unsigned char *)(a1 + 12697)) {
    return 0;
  }
  uint64_t v4 = (_DWORD *)(a1 + 144);
  int v5 = *(_DWORD *)(a1 + 4100);
  unint64_t v6 = (_DWORD *)(a1 + 3584);
  memset(v53, 0, sizeof(v53));
  uint64_t v52 = 0;
  long long v50 = 0u;
  long long v51 = 0u;
  uint64_t result = aj_check_options(a1 + 3584, (int *)(a1 + 144), 0);
  if (!result)
  {
    aj_init_bitmapinfo(a1 + 12704, v4, (uint64_t)v6, v5);
    unint64_t v49 = 0;
    uint64_t result = aj_calculate_dimensions(v6, (uint64_t)v4, (int *)&v49 + 1, (int *)&v49, 0, 0, 0, 0, 0);
    if (!result)
    {
      uint64_t result = aj_get_format_description(*(_DWORD *)(a1 + 3592), (uint64_t)&v50);
      if (!result)
      {
        int v8 = *(_DWORD *)(a1 + 3664);
        if (v8 == 270 || v8 == 90)
        {
          unint64_t v49 = __PAIR64__(v49, HIDWORD(v49));
          *((int32x2_t *)&v51 + 1) = vrev64_s32(*(int32x2_t *)((char *)&v51 + 8));
        }
        int v9 = *(_DWORD *)(a1 + 3592);
        if (v9 == 14)
        {
          uint64_t result = aj_get_texture_size(v4, (uint64_t)v6, (uint64_t)v53, v5, (void *)(a1 + 12816), a1 + 12832, (void *)(a1 + 12824));
          goto LABEL_61;
        }
        memset(v57, 0, 32);
        memset(v56, 0, sizeof(v56));
        if ((v9 - 25) < 2)
        {
          uint64_t v10 = 0;
          unint64_t v11 = 0;
          char v12 = v9 != 25;
          int v13 = *(_DWORD *)(a1 + 3824);
          int v14 = *(_DWORD *)(a1 + 3816);
          int v15 = *(_DWORD *)(a1 + 3828);
          int v16 = *(_DWORD *)(a1 + 3820);
          do
          {
            if (v10 * 8) {
              int v17 = 1;
            }
            else {
              int v17 = v14;
            }
            unint64_t v18 = (v13 * (uint64_t)v17) << v12;
            if (v10 * 8) {
              int v19 = 1;
            }
            else {
              int v19 = v16;
            }
            unint64_t v20 = *(void *)(a1 + 3624 + v10 * 8);
            if (v20)
            {
              BOOL v21 = v20 >= v18;
              unint64_t v7 = v20 - v18;
              if (!v21) {
                goto LABEL_48;
              }
              v56[v10] = v7;
            }
            uint64_t v22 = v18 * v15 * (uint64_t)v19;
            v57[v10] = v22;
            v11 += v22;
            ++v10;
          }
          while (v10 != 3);
LABEL_24:
          unint64_t v23 = 0;
          goto LABEL_57;
        }
        if (v9 == 7)
        {
          unint64_t v24 = 2 * ((BYTE4(v49) & 1) + HIDWORD(v49));
          unint64_t v25 = *(void *)(a1 + 3624);
          if (v25)
          {
            if ((v25 & 3) != 0 || (BOOL v21 = v25 >= v24, v26 = v25 - v24, !v21))
            {
              aj_log_error((uint64_t)"Decode", "The set stride is smaller than the output size or unaligned", v7);
              goto LABEL_53;
            }
            v56[0] = v26;
            unint64_t v24 = v25;
          }
          unint64_t v23 = 0;
          unint64_t v11 = v24 * (int)v49;
        }
        else
        {
          if (DWORD1(v50) == 2)
          {
            uint64_t v27 = 0;
            unint64_t v11 = 0;
            int v28 = v49;
            int v29 = v49 & 1;
            if (HIDWORD(v51) != 2) {
              int v29 = 0;
            }
            uint64_t v30 = v29 + (int)v49;
            if (HIDWORD(v51) == 2) {
              int v28 = ((int)v49 + 1) >> 1;
            }
            v55[0] = v30;
            v55[1] = v28;
            int v31 = HIDWORD(v49);
            int v32 = BYTE4(v49) & 1;
            if (DWORD2(v51) != 2) {
              int v32 = 0;
            }
            uint64_t v33 = v32 + HIDWORD(v49);
            if (DWORD2(v51) == 2) {
              int v31 = (HIDWORD(v49) + 1) >> 1;
            }
            v54[0] = v33;
            v54[1] = v31;
            char v34 = 1;
            while (1)
            {
              char v35 = v34;
              unint64_t v36 = v54[v27] * *((int *)&v50 + v27 + 2);
              unint64_t v37 = *(void *)(a1 + 8 * v27 + 3624);
              if (v37)
              {
                BOOL v21 = v37 >= v36;
                unint64_t v38 = v37 - v36;
                if (!v21)
                {
LABEL_48:
                  aj_log_error((uint64_t)"Decode", "Set stride is smaller than required row size", v7);
                  goto LABEL_53;
                }
                v56[v27] = v38;
                unint64_t v36 = v37;
              }
              char v34 = 0;
              uint64_t v39 = v55[v27] * v36;
              v57[v27] = v39;
              v11 += v39;
              uint64_t v27 = 1;
              if ((v35 & 1) == 0) {
                goto LABEL_24;
              }
            }
          }
          unint64_t v40 = *(void *)(a1 + 3624);
          unint64_t v23 = SDWORD2(v50) * (uint64_t)SHIDWORD(v49);
          if (v40)
          {
            BOOL v21 = v40 >= v23;
            unint64_t v41 = v40 - v23;
            if (!v21)
            {
              aj_log_error((uint64_t)"Decode", "Set stride is smaller than output size", v7);
LABEL_53:
              uint64_t result = 5;
LABEL_61:
              if (!result)
              {
                v1[207] = 0;
                *unsigned int v1 = 1;
              }
              return result;
            }
            v56[0] = v41;
            unint64_t v23 = v40;
          }
          unint64_t v11 = v23 * (int)v49;
        }
        v57[0] = v11;
LABEL_57:
        int v42 = DWORD1(v50);
        if (SDWORD1(v50) >= 1)
        {
          uint64_t v43 = (void *)(a1 + 12872);
          uint64_t v44 = v56;
          int v45 = v57;
          uint64_t v46 = DWORD1(v50);
          do
          {
            uint64_t v47 = *v45++;
            *(v43 - 5) = v47;
            uint64_t v48 = *v44++;
            *v43++ = v48;
            --v46;
          }
          while (v46);
        }
        uint64_t result = 0;
        *(_DWORD *)(a1 + 12864) = v42;
        *(void *)(a1 + 12816) = v11;
        *(void *)(a1 + 12824) = v23;
        goto LABEL_61;
      }
    }
  }
  return result;
}

uint64_t applejpeg_decode_get_output_buffer_size(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  if (a1 && *(_DWORD *)(a1 + 12928) == 2)
  {
    uint64_t result = commit_decode_options_if_needed(a1);
    if (!result)
    {
      if (a2) {
        *a2 = *(void *)(a1 + 12816);
      }
      if (a4)
      {
        long long v9 = *(_OWORD *)(a1 + 12832);
        long long v10 = *(_OWORD *)(a1 + 12848);
        *(void *)(a4 + 32) = *(void *)(a1 + 12864);
        *(_OWORD *)a4 = v9;
        *(_OWORD *)(a4 + 16) = v10;
      }
      uint64_t result = 0;
      if (a3) {
        *a3 = *(void *)(a1 + 12824);
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_get_planar_output_buffer_size(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  if (!a1 || *(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 8;
  }
  uint64_t result = commit_decode_options_if_needed(a1);
  if (result) {
    return result;
  }
  if ((*(_DWORD *)(a1 + 10772) - 25) >= 2)
  {
    aj_log_error((uint64_t)"Decode", "Function can only be called for tri-planar output");
    return 8;
  }
  if (a2) {
    *a2 = *(void *)(a1 + 12816);
  }
  if (a3) {
    *a3 = *(int *)(a1 + 4220);
  }
  if (a4)
  {
    long long v13 = *(_OWORD *)(a1 + 12832);
    long long v14 = *(_OWORD *)(a1 + 12848);
    *(void *)(a4 + 32) = *(void *)(a1 + 12864);
    *(_OWORD *)a4 = v13;
    *(_OWORD *)(a4 + 16) = v14;
  }
  if (a5)
  {
    uint64_t v15 = *(int *)(a1 + 3824);
    *a5 = *(int *)(a1 + 3816) * (uint64_t)(int)v15;
    a5[1] = v15;
    a5[2] = v15;
    a5[3] = 0;
  }
  uint64_t result = 0;
  if (a6)
  {
    uint64_t v16 = *(int *)(a1 + 3828);
    *a6 = *(int *)(a1 + 3820) * (uint64_t)(int)v16;
    a6[1] = v16;
    a6[2] = v16;
    a6[3] = 0;
  }
  return result;
}

uint64_t applejpeg_decode_set_options(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  if (a1 && a2 && a3)
  {
    if (*(_DWORD *)(a1 + 12928) == 2)
    {
      *(_OWORD *)(a1 + 3584) = *(_OWORD *)a2;
      long long v11 = *(_OWORD *)(a2 + 16);
      long long v12 = *(_OWORD *)(a2 + 32);
      long long v13 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(a1 + 3648) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 3632) = v13;
      *(_OWORD *)(a1 + 3616) = v12;
      *(_OWORD *)(a1 + 3600) = v11;
      long long v14 = *(_OWORD *)(a2 + 80);
      long long v15 = *(_OWORD *)(a2 + 96);
      long long v16 = *(_OWORD *)(a2 + 112);
      *(void *)(a1 + 3712) = *(void *)(a2 + 128);
      *(_OWORD *)(a1 + 3696) = v16;
      *(_OWORD *)(a1 + 3680) = v15;
      *(_OWORD *)(a1 + 3664) = v14;
      *(unsigned char *)(a1 + 3720) = 0;
      *(_DWORD *)(a1 + 3724) = 0;
      *(unsigned char *)(a1 + 3728) = 1;
      *(_DWORD *)(a1 + 3732) = 2;
      *(unsigned char *)(a1 + 3736) = 0;
      if (*(int *)(a1 + 148) >= 9) {
        *(_DWORD *)(a1 + 3680) = 4;
      }
      *(unsigned char *)(a1 + 12697) = 0;
      if (a4)
      {
        *(void *)(a4 + 32) = 0;
        *(_OWORD *)a4 = 0u;
        *(_OWORD *)(a4 + 16) = 0u;
      }
      if (a6) {
        *a6 = 0;
      }
      if (a7) {
        *a7 = 0;
      }
      uint64_t result = applejpeg_decode_get_output_dimensions((_DWORD *)a1, a6, a7);
      if (!result)
      {
        return applejpeg_decode_get_output_buffer_size(a1, a3, a5, a4);
      }
    }
    else
    {
      aj_log_error((uint64_t)"Decode", "Image session not opened");
      return 1;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_decode_image_all(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4)
{
  if (!a1 || !a2 || !a4)
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (a3 - 5 <= 0xFFFFFFFB)
  {
    aj_log_error((uint64_t)"Decode", "nplanes clearly incorrect: %d");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  kdebug_trace();
  uint64_t v7 = commit_decode_options_if_needed(a1);
  if (!v7)
  {
    int v10 = *(_DWORD *)(a1 + 12864);
    if (a3 != 1 && v10 != a3)
    {
      aj_log_error((uint64_t)"Decode", "The number of allocated planes needs to match the output format or be one: %d");
      return 8;
    }
    uint64_t v11 = 0;
    long long v12 = (uint64_t *)(a1 + 12832);
    long long v13 = a2 + 1;
    do
    {
      if (!*(v13 - 1) || !*v13)
      {
        aj_log_error((uint64_t)"Decode", "Destination pointer or size is NULL/zero for plane ind: %d");
        return 8;
      }
      ++v11;
      v13 += 2;
    }
    while (a3 != v11);
    if (v10 <= (int)a3)
    {
      uint64_t v17 = 0;
      unint64_t v18 = (unint64_t *)(a2 + 1);
      while (1)
      {
        unint64_t v19 = *v18;
        v18 += 2;
        if (v19 < *v12 - v12[5]) {
          break;
        }
        ++v12;
        if (-(uint64_t)a3 == --v17) {
          goto LABEL_33;
        }
      }
      aj_log_error((uint64_t)"Decode", "Destination plane %d is too small for decoded data: %zu vs %zu");
      return 8;
    }
    if (v10 < 1)
    {
      uint64_t v14 = 0;
    }
    else
    {
      uint64_t v14 = 0;
      uint64_t v15 = *(unsigned int *)(a1 + 12864);
      do
      {
        uint64_t v16 = *v12++;
        v14 += v16;
        --v15;
      }
      while (v15);
    }
    if (a2[1] < (unint64_t)(v14 - *(void *)(a1 + 8 * v10 + 12864)))
    {
      aj_log_error((uint64_t)"Decode", "Destination buffer is too small for decoded data: %zu vs %zu");
      return 8;
    }
LABEL_33:
    int v20 = *(_DWORD *)(a1 + 4100);
    *(_DWORD *)(a4 + 32) = a3;
    BOOL v21 = a2;
    uint64_t v22 = (uint64_t *)a4;
    uint64_t v23 = a3;
    do
    {
      uint64_t v24 = *v21;
      v21 += 2;
      *v22++ = v24;
      --v23;
    }
    while (v23);
    aj_init_bitmapinfo(a4 + 40, (_DWORD *)(a1 + 144), a1 + 3584, v20);
    int v25 = *(_DWORD *)(a1 + 12996);
    if (!v25)
    {
      log_basic_decode_info(OS_LOG_TYPE_DEBUG, a1, 1, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
      int v25 = *(_DWORD *)(a1 + 12996);
    }
    *(_DWORD *)(a1 + 4108) = v25;
    uint64_t v26 = perform_decode((uint64_t *)(a1 + 13000), (void *)(a1 + 13048), a1 + 4192, a1 + 3744, (_DWORD *)(a1 + 11168), a2, a3, a1 + 144, a1 + 3584, a1 + 24);
    uint64_t v7 = v26;
    if (v26 != -2)
    {
      if (v26)
      {
        if (v26 == -1)
        {
          os_log_object = aj_get_os_log_object();
          if (os_log_type_enabled(os_log_object, OS_LOG_TYPE_ERROR)) {
            applejpeg_decode_image_all_cold_3(a1, os_log_object);
          }
        }
        else
        {
          char v35 = aj_get_os_log_object();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
            applejpeg_decode_image_all_cold_1();
          }
        }
        log_basic_decode_info(OS_LOG_TYPE_ERROR, a1, 1, (_DWORD *)(a1 + 3744), a1 + 144, a1 + 3584);
      }
      else
      {
        int v28 = aj_get_os_log_object();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
          applejpeg_decode_image_all_cold_2(a1, v28, v29, v30, v31, v32, v33, v34);
        }
      }
    }
    kdebug_trace();
  }
  return v7;
}

uint64_t perform_decode(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t *a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  if ((*(_DWORD *)(a4 + 360) | 2) == 2)
  {
    unint64_t v18 = (_OWORD *)a10;
    LODWORD(v19) = *(_DWORD *)(a8 + 3420);
    if (*(unsigned char *)(a8 + 84) && *(void *)(a10 + 80))
    {
      *(_DWORD *)(a4 + 360) = 0;
      uint64_t v20 = mmap_multiscan(a2, a4 + 368, (uint64_t)v31, a10, a8);
      uint64_t v19 = v20;
      if (v20)
      {
        if (v20 != -2)
        {
LABEL_26:
          dec_free_allocations(a3, *a1, (uint64_t)a1, (uint64_t)a5);
          return v19;
        }
        LODWORD(v19) = 0;
        *(_DWORD *)(a4 + 360) = 2;
      }
      unint64_t v18 = v31;
    }
    uint64_t v21 = aj_decode_init((uint64_t)a1, (uint64_t)a2, a3, a4, (uint64_t)a5, (int *)a8, (uint64_t)v18, a9, *a1, a6, a7, 0, v19);
    if (v21)
    {
LABEL_24:
      uint64_t v19 = v21;
      goto LABEL_25;
    }
  }
  uint64_t v22 = aj_decode_all_mt(a3, (uint64_t)a5);
  uint64_t v19 = v22;
  if (*(_DWORD *)(a4 + 360) == 2)
  {
    uint64_t v23 = *(void *)(a4 + 408);
    uint64_t v24 = *(int *)(a4 + 404) - 1;
    int v25 = *(unsigned __int8 **)(v23 + 288 * v24 + 112);
    if (!v25 || *v25 != 217)
    {
      uint64_t v26 = *(unsigned int *)(v23 + 288 * v24 + 128);
      if ((int)v26 < 2) {
        goto LABEL_22;
      }
      uint64_t v27 = (unsigned __int8 *)(*(void *)(v23 + 288 * v24 + 104) + 1);
      uint64_t v28 = v26 - 1;
      while (1)
      {
        if (*(v27 - 1) == 255)
        {
          int v29 = *v27;
          if (v29 != 255) {
            break;
          }
        }
        ++v27;
        if (!--v28) {
          goto LABEL_22;
        }
      }
      if (v29 != 217)
      {
LABEL_22:
        *(unsigned char *)(a4 + 401) = 0;
        uint64_t v19 = 4294967294;
        handle_error_from_decode(0xFFFFFFFE, (uint64_t)a2, a4, *a1, a5);
        goto LABEL_26;
      }
    }
  }
  if (!v22)
  {
LABEL_25:
    *(_DWORD *)(a4 + 360) = 0;
    goto LABEL_26;
  }
  if (v22 != -2)
  {
    uint64_t v21 = handle_error_from_decode(v22, (uint64_t)a2, a4, *a1, a5);
    goto LABEL_24;
  }
  *(_DWORD *)(a4 + 360) = 1;
  return v19;
}

uint64_t applejpeg_decode_get_rows_written(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 11208);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t applejpeg_decode_image_row_texture(uint64_t a1, uint64_t *a2, uint64_t a3, int *a4)
{
  v52[4] = *MEMORY[0x263EF8340];
  if (a1 && a2 && *a2 && a4 && a3 && a2[1])
  {
    if (!*(_DWORD *)(a1 + 4100))
    {
      aj_log_error((uint64_t)"Decode", "decode_row_texture is only allowed when recoding.");
      return 3;
    }
    if (*(int *)(a1 + 148) >= 9)
    {
      aj_log_error((uint64_t)"Decode", "Row decoding does not support 12-bit jpeg");
      return 3;
    }
    if (*(unsigned char *)(a1 + 230))
    {
      aj_log_error((uint64_t)"Decode", "Row-wise decompression for LOSSLESS is not implemented.");
      return 3;
    }
    uint64_t result = commit_decode_options_if_needed(a1);
    if (!result)
    {
      if (check_decode_row_options(a1 + 3584))
      {
        aj_log_error((uint64_t)"Decode", "Illegal options for row decoding.");
        return 5;
      }
      else if (*(unsigned char *)(a1 + 12904) || (LODWORD(result) = aj_decode_row_init(a1, a3, a2), !result))
      {
        LODWORD(v9) = 0;
        int v10 = 0;
        uint64_t v46 = (unsigned int **)(a1 + 4192);
        uint64_t v45 = a1 + 11168;
        unint64_t v11 = *(int *)(a1 + 10760) + (uint64_t)*(int *)(a1 + 10752);
        uint64_t v12 = *a2;
        uint64_t v44 = v12;
        unint64_t v13 = v11 - 1;
        int v14 = *(_DWORD *)(a1 + 4240);
        int v15 = *(_DWORD *)(a1 + 12924);
        LODWORD(v16) = *(_DWORD *)(a1 + 4364);
        uint64_t v50 = *(int *)(a1 + 10728) + (uint64_t)*(int *)(a1 + 10720) - 1;
        unint64_t v51 = *(int *)(a1 + 10728) + (uint64_t)*(int *)(a1 + 10720);
        while (1)
        {
          size_t v17 = *(void *)(a1 + 10704);
          size_t v18 = v17 * v10;
          uint64_t v19 = *(void *)(a1 + 10736);
          int v49 = v9;
          size_t v20 = v12 + 8 * v17 * v14 + v19 * (int)v9;
          size_t v21 = v20 + 8 * v19;
          int v22 = *(_DWORD *)(a1 + 10680);
          int v23 = v16 * v15;
          if (v15 >= *(_DWORD *)(a1 + 11032) - *(_DWORD *)(a1 + 11028) || v23 >= v22) {
            break;
          }
          size_t v25 = v12 + v18;
          v52[0] = v12 + v18;
          v52[1] = v20;
          size_t v48 = v21;
          void v52[2] = v21;
          v52[3] = 0;
          if (*(_DWORD *)(a1 + 10772) == 14) {
            aj_reset_texture_buffer_ptrs(v46, a1 + 11736, (uint64_t)v52);
          }
          LODWORD(result) = aj_decode_row((uint64_t)v46, v45);
          if (result) {
            goto LABEL_50;
          }
          LODWORD(v16) = *(_DWORD *)(a1 + 4364);
          unint64_t v26 = v51;
          int v47 = v10;
          if (*(void *)(a1 + 10704) > v51)
          {
            uint64_t v27 = v50;
            if ((int)v16 >= 1)
            {
              uint64_t v28 = 0;
              do
              {
                memset((void *)(v25 + v51 + *(void *)(a1 + 10704) * v28), *(unsigned __int8 *)(v25 + v27 + *(void *)(a1 + 10704) * v28), *(void *)(a1 + 10704) - v26);
                uint64_t v27 = v50;
                unint64_t v26 = v51;
                ++v28;
                uint64_t v16 = *(int *)(a1 + 4364);
              }
              while (v28 < v16);
              int v10 = v47;
              uint64_t v12 = v44;
            }
          }
          int v14 = *(_DWORD *)(a1 + 4240);
          int v29 = (int)v16 / v14;
          if (*(void *)(a1 + 10736) > v11 && v29 >= 1)
          {
            uint64_t v30 = 0;
            do
            {
              memset((void *)(v20 + v11 + *(void *)(a1 + 10736) * v30), *(unsigned __int8 *)(v20 + v13 + *(void *)(a1 + 10736) * v30), *(void *)(a1 + 10736) - v11);
              memset((void *)(v48 + v11 + *(void *)(a1 + 10736) * v30), *(unsigned __int8 *)(v48 + v13 + *(void *)(a1 + 10736) * v30), *(void *)(a1 + 10736) - v11);
              ++v30;
              LODWORD(v16) = *(_DWORD *)(a1 + 4364);
              int v14 = *(_DWORD *)(a1 + 4240);
              int v29 = (int)v16 / v14;
            }
            while (v30 < (int)v16 / v14);
            int v10 = v47;
            uint64_t v12 = v44;
          }
          v10 += v16;
          uint64_t v9 = (v29 + v49);
          int v15 = *(_DWORD *)(a1 + 12924) + 1;
          *(_DWORD *)(a1 + 12924) = v15;
          if ((int)v9 >= 8)
          {
            int v23 = v15 * v16;
            int v22 = *(_DWORD *)(a1 + 10680);
            if (v23 < v22) {
              goto LABEL_55;
            }
            size_t v17 = *(void *)(a1 + 10704);
            size_t v18 = v17 * v10;
            uint64_t v19 = *(void *)(a1 + 10736);
            int v49 = v9;
            size_t v20 = v12 + 8 * v14 * v17 + v19 * v9;
            size_t v21 = v20 + 8 * v19;
            break;
          }
        }
        size_t v31 = v21;
        int v32 = v23 - v22;
        int v33 = v10 - v32;
        int v34 = v32 / v14;
        int v35 = v49 - v32 / v14;
        int v36 = v33;
        if (v33 < 8 * v14)
        {
          unint64_t v37 = (char *)(v12 + v18 - v17 * v32);
          do
          {
            memcpy(v37, &v37[-v17], v17);
            ++v36;
            size_t v17 = *(void *)(a1 + 10704);
            v37 += v17;
          }
          while (v36 < 8 * *(_DWORD *)(a1 + 4240));
        }
        if (v35 > 7)
        {
          LODWORD(v9) = v35;
        }
        else
        {
          uint64_t v38 = v19 * v34;
          uint64_t v39 = (char *)(v20 - v38);
          unint64_t v40 = (char *)(v31 - v38);
          size_t v41 = *(void *)(a1 + 10736);
          int v42 = v34 - v49 + 8;
          do
          {
            memcpy(v39, &v39[-v41], v41);
            memcpy(v40, &v40[-*(void *)(a1 + 10736)], *(void *)(a1 + 10736));
            size_t v41 = *(void *)(a1 + 10736);
            v39 += v41;
            v40 += v41;
            --v42;
          }
          while (v42);
          LODWORD(v9) = 8;
        }
        int v10 = v36;
LABEL_55:
        uint64_t result = 0;
        *(_DWORD *)(a3 + 44) = v10;
        *(void *)(a3 + 24) = v10;
        *(_DWORD *)(a3 + 76) = v9;
        *(void *)(a3 + 56) = v9;
        int v43 = *(_DWORD *)(a1 + 11032) - (*(_DWORD *)(a1 + 11028) + *(_DWORD *)(a1 + 12924));
        *a4 = v43;
        if (*(_DWORD *)(a1 + 4364) * *(_DWORD *)(a1 + 12924) >= *(_DWORD *)(a1 + 10680)) {
          int v43 = 0;
        }
        *a4 = v43;
        if (!v43)
        {
          dec_free_allocations((uint64_t)v46, a1, a1 + 13000, v45);
          uint64_t result = 0;
          *(unsigned char *)(a1 + 12904) = 0;
        }
      }
      else
      {
LABEL_50:
        if (result == -2) {
          return 9;
        }
        else {
          return result;
        }
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  return result;
}

uint64_t check_decode_row_options(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 80) && !*(_DWORD *)(a1 + 88) && !*(void *)(a1 + 120))
  {
    unsigned int v2 = *(_DWORD *)(a1 + 8);
    if (v2 < 7 || v2 - 14 <= 1)
    {
      unint64_t v3 = 0;
      while (!*(void *)(a1 + 40 + 8 * v3))
      {
        if (v2 == 14 && v3++ <= 1) {
          continue;
        }
        if (*(_DWORD *)(a1 + 100)) {
          return 5;
        }
        else {
          return 0;
        }
      }
    }
  }
  return 5;
}

uint64_t aj_decode_row_init(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v6 = (int *)(a1 + 144);
  uint64_t v7 = a1 + 24;
  *(_DWORD *)(a1 + 4108) = *(_DWORD *)(a1 + 12996);
  *(void *)(a1 + 12904) = 0;
  *(void *)(a1 + 12920) = 0;
  *(void *)(a1 + 12912) = 0;
  unsigned int v8 = *(_DWORD *)(a1 + 3564);
  if (*(unsigned char *)(a1 + 228) && *(void *)(a1 + 104))
  {
    uint64_t v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v24 = 0u;
    uint64_t v9 = mmap_multiscan((void *)(a1 + 13048), a1 + 4112, (uint64_t)&v24, v7, (uint64_t)v6);
    if (v9) {
      return v9;
    }
    unsigned int v8 = 0;
    *(void *)(v7 + 112) = v31;
    long long v11 = v29;
    *(_OWORD *)(v7 + 64) = v28;
    *(_OWORD *)(v7 + 80) = v11;
    *(_OWORD *)(v7 + 96) = v30;
    long long v12 = v25;
    *(_OWORD *)uint64_t v7 = v24;
    *(_OWORD *)(v7 + 16) = v12;
    long long v13 = v27;
    *(_OWORD *)(v7 + 32) = v26;
    *(_OWORD *)(v7 + 48) = v13;
  }
  uint64_t v14 = aj_decode_init(a1 + 13000, a1 + 13048, a1 + 4192, a1 + 3744, a1 + 11168, v6, v7, a1 + 3584, a1, a3, 1, 1, v8);
  if (v14)
  {
    uint64_t v10 = v14;
    dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
  }
  else
  {
    if (*(_DWORD *)(a1 + 10772) == 14)
    {
      long long v15 = *(_OWORD *)(a1 + 10704);
      long long v16 = *(_OWORD *)(a1 + 10720);
      long long v17 = *(_OWORD *)(a1 + 10752);
      *(_OWORD *)(a2 + 48) = *(_OWORD *)(a1 + 10736);
      *(_OWORD *)(a2 + 64) = v17;
      *(_OWORD *)(a2 + 16) = v15;
      *(_OWORD *)(a2 + 32) = v16;
      uint64_t v18 = *(int *)(a1 + 4364);
      *(void *)(a2 + 24) = v18;
      int v19 = (int)v18 / *(_DWORD *)(a1 + 4240);
      *(void *)(a2 + 56) = v19;
      *(_DWORD *)(a2 + 44) = v18;
      *(_DWORD *)(a2 + 76) = v19;
    }
    else
    {
      int v20 = (*(uint64_t (**)(void))(*(void *)(a1 + 12656) + 8))();
      *(_DWORD *)(a1 + 12920) = v20;
      if (*(void *)(a1 + 13016))
      {
        (*(void (**)(void, void))(a1 + 8))(*(void *)(a1 + 13016), *(void *)(a1 + 16));
        int v20 = *(_DWORD *)(a1 + 12920);
      }
      size_t v21 = (void *)(*(uint64_t (**)(void, void))a1)(*(void *)(a1 + 12824) * v20, *(void *)(a1 + 16));
      *(void *)(a1 + 13016) = v21;
      if (!v21 || (bzero(v21, *(void *)(a1 + 12824) * *(int *)(a1 + 12920)), (uint64_t v22 = *(void *)(a1 + 13016)) == 0))
      {
        aj_log_error((uint64_t)"Decode", "Could not allocate memory for row buffer");
        return 6;
      }
      *(void *)(a1 + 4256) = v22;
      paint_row_buffer((void *)a1, a1 + 4192, *(_DWORD *)(a1 + 12920));
    }
    uint64_t v10 = 0;
    *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 3592);
    *(void *)a2 = *(void *)(a1 + 10676);
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(unsigned char *)(a1 + 12904) = 1;
  }
  return v10;
}

uint64_t applejpeg_decode_image_row(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!a1 || !a2 || !*(void *)a2 || !a4 || !a3 || !*(void *)(a2 + 8))
  {
    aj_log_error((uint64_t)"Decode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 12928) != 2)
  {
    aj_log_error((uint64_t)"Decode", "Image session not opened");
    return 1;
  }
  uint64_t result = commit_decode_options_if_needed(a1);
  if (result) {
    return result;
  }
  if (*(void *)(a2 + 8) < *(void *)(a1 + 12824))
  {
    aj_log_error((uint64_t)"Decode", "Destination buffer size too small (or destination buffer NULL)");
    return 8;
  }
  if (*(_DWORD *)(a1 + 3592) == 14 && !*(_DWORD *)(a1 + 4100))
  {
    aj_log_error((uint64_t)"Decode", "Illegal options for texture format");
    return 3;
  }
  if (*(unsigned char *)(a1 + 230))
  {
    aj_log_error((uint64_t)"Decode", "Row-wise decompression for LOSSLESS is not implemented.");
    return 3;
  }
  if (*(int *)(a1 + 148) >= 9)
  {
    aj_log_error((uint64_t)"Decode", "Row decoding does not support 12-bit jpeg");
    return 3;
  }
  if (check_decode_row_options(a1 + 3584))
  {
    aj_log_error((uint64_t)"Decode", "Illegal options for row decoding.");
    return 5;
  }
  if (*(unsigned char *)(a1 + 12904) || (LODWORD(result) = aj_decode_row_init(a1, a3, (uint64_t *)a2), !result))
  {
    int v9 = *(_DWORD *)(a1 + 12908);
    if (v9 < *(_DWORD *)(a1 + 10680))
    {
      int v10 = *(_DWORD *)(a1 + 10776);
      int v11 = *(_DWORD *)(a1 + 10696) + v10;
      if (v9 < v10 || v9 >= v11)
      {
        if (!v9 || v9 == v11) {
          paint_row_buffer((void *)a1, a1 + 4192, 1);
        }
        uint64_t v12 = 0;
        *(void *)(a1 + 12912) = 1;
      }
      else
      {
        if (!*(_DWORD *)(a1 + 12912))
        {
          *(_DWORD *)(a1 + 11204) = 0;
          while (1)
          {
            unsigned int v16 = aj_decode_row(a1 + 4192, a1 + 11168);
            if (v16) {
              break;
            }
            int v17 = *(_DWORD *)(a1 + 11204);
            if (v17)
            {
              uint64_t v12 = 0;
              *(_DWORD *)(a1 + 12912) = v17;
              *(_DWORD *)(a1 + 12916) = 0;
              goto LABEL_41;
            }
          }
          unsigned int v13 = v16;
          goto LABEL_42;
        }
        uint64_t v12 = *(int *)(a1 + 12916);
      }
LABEL_41:
      memcpy(*(void **)a2, (const void *)(*(void *)(a1 + 13016) + *(void *)(a1 + 12824) * v12), *(void *)(a1 + 12824));
      unsigned int v13 = 0;
      uint64_t result = 0;
      int32x2_t v14 = vadd_s32(*(int32x2_t *)(a1 + 12908), (int32x2_t)0xFFFFFFFF00000001);
      *(int32x2_t *)(a1 + 12908) = v14;
      ++*(_DWORD *)(a1 + 12916);
      if (v14.i32[0] < *(_DWORD *)(a1 + 10680))
      {
LABEL_50:
        *a4 = *(_DWORD *)(a1 + 10680) - *(_DWORD *)(a1 + 12908);
        return result;
      }
LABEL_42:
      if (*(unsigned char *)(a1 + 4144)) {
        unsigned int v13 = aj_handle_partial_progressive_decode(a1 + 4192);
      }
      dec_free_allocations(a1 + 4192, a1, a1 + 13000, a1 + 11168);
      *(unsigned char *)(a1 + 12904) = 0;
      if (v13 == -2) {
        unsigned int v15 = 9;
      }
      else {
        unsigned int v15 = v13;
      }
      if (v13) {
        uint64_t result = v15;
      }
      else {
        uint64_t result = 0;
      }
      goto LABEL_50;
    }
    aj_log_error((uint64_t)"Decode", "No more rows to write");
    return 1;
  }
  if (result == -2) {
    return 9;
  }
  else {
    return result;
  }
}

void *paint_row_buffer(void *result, uint64_t a2, int a3)
{
  int v19 = 0;
  int v5 = (void *)*((void *)result + 1627);
  int v6 = *(_DWORD *)(a2 + 6580);
  if (v6 == 15)
  {
    int v7 = *((_DWORD *)result + 1025);
    uint64_t result = (void *)aj_get_internal_format(*((_DWORD *)result + 36), *(unsigned __int8 *)(a2 + 6937), *(_DWORD *)(a2 + 6940));
    if (result == 5 && v7 == 0) {
      int v9 = 4;
    }
    else {
      int v9 = (int)result;
    }
    if (v9 == 5)
    {
      int v19 = 8421631;
    }
    else if (v9 == 3)
    {
      int v19 = -1;
    }
  }
  else if (v6 == 6)
  {
    *(_WORD *)((char *)&v19 + 1) = -32640;
  }
  int v10 = *(_DWORD *)(a2 + 28);
  int v11 = *(_DWORD *)(a2 + 6492);
  uint64_t v12 = v11 * v10;
  int v13 = *(_DWORD *)(a2 + 6592);
  int v14 = *(_DWORD *)(a2 + 6596);
  if (*(void *)(a2 + 6592))
  {
    uint64_t v16 = 0;
    int v17 = v13;
    int v18 = a3;
    v15[0] = v11 - v14;
    v15[1] = 0;
    void v15[2] = v14;
    _DWORD v15[3] = a3;
    aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, v11, v11 * v10, a3, (int *)&v16);
    uint64_t result = aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, *(_DWORD *)(a2 + 6492), v12, a3, v15);
  }
  if (*(_DWORD *)(a2 + 6584) || *(_DWORD *)(a2 + 6588))
  {
    uint64_t v16 = 0;
    int v17 = *(_DWORD *)(a2 + 6492);
    int v18 = a3;
    return aj_paint_region(v5, *(_DWORD *)(a2 + 6808), (char *)&v19, v10, v17, v12, a3, (int *)&v16);
  }
  return result;
}

uint64_t check_mcu_table(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 12) >= 5u)
  {
    aj_log_error((uint64_t)"Decode", "Too many check state stream bytes (%d > %d)");
    return 12;
  }
  uint64_t result = aj_istream_state_restore(a2, a1);
  if (!result)
  {
    if (*(unsigned char *)(a1 + 12))
    {
      uint64_t v5 = 0;
      while (*(unsigned __int8 *)(a1 + 8 + v5) == *(unsigned __int8 *)(*(void *)(a2 + 8) + v5))
      {
        if (*(unsigned __int8 *)(a1 + 12) == ++v5) {
          return 0;
        }
      }
      aj_log_error((uint64_t)"Decode", "Image data does not match data in supplied RA-table: Stream byte %d differs, 0x%X != 0x%X");
      return 12;
    }
    return 0;
  }
  return result;
}

uint64_t mmap_multiscan(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10 = (uint64_t *)(a2 + 16);
  uint64_t v9 = *(void *)(a2 + 16);
  if (v9)
  {
    int v11 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    int v28 = *(_DWORD *)(a4 + 32);
    int v29 = *(_DWORD *)(a4 + 52);
    int v30 = *(_DWORD *)(a4 + 48) - v28;
    *(_DWORD *)a2 = v30;
    if (v29)
    {
      int v31 = v29 - v30;
    }
    else
    {
      int v32 = estimate_jpeg_size(*(_DWORD *)(a5 + 8), *(_DWORD *)(a5 + 12));
      if (v32 >= 5242880) {
        int v31 = 5242880;
      }
      else {
        int v31 = v32;
      }
      int v28 = *(_DWORD *)(a4 + 32);
    }
    if (v31 <= v28) {
      int v33 = v28;
    }
    else {
      int v33 = v31;
    }
    uint64_t v34 = a1[3];
    if (v34) {
      (*(void (**)(uint64_t, void))(*a1 + 8))(v34, *(void *)(*a1 + 16));
    }
    int v35 = (void *)(*(uint64_t (**)(void, void))*a1)(v33, *(void *)(*a1 + 16));
    *int v10 = (uint64_t)v35;
    a1[3] = v35;
    if (!v35 || (bzero(v35, v33), (int v36 = (void *)a1[3]) == 0))
    {
      aj_log_error((uint64_t)"Decode", "Could not allocate memory for input mapping");
      return 6;
    }
    *(_DWORD *)(a2 + 8) = v33;
    memcpy(v36, *(const void **)(a4 + 8), *(int *)(a4 + 32));
    int v11 = *(_DWORD *)(a4 + 32);
    *(_DWORD *)(a2 + 4) = v11;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  int v12 = *(_DWORD *)(a2 + 8);
  int v13 = *(_DWORD *)(a4 + 36);
  uint64_t v14 = *(void *)(a4 + 40);
  *(void *)(a4 + 40) = v9;
  *(void *)(a4 + 8) = v9 + v11;
  *(_DWORD *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 36) = v12;
  *(void *)(a4 + 104) = v9;
  if (*(_DWORD *)(a4 + 56) != 2)
  {
    int v38 = v13;
    int v17 = 0;
    int v18 = v12 - v11;
    while (1)
    {
      if (!v18)
      {
        unint64_t v19 = 3 * *(int *)(a2 + 8);
        if (HIDWORD(v19)) {
          return 1;
        }
        int v20 = *(const void **)(a2 + 16);
        size_t v21 = v19 >> 1;
        uint64_t v22 = (char *)(*(uint64_t (**)(unint64_t, void))*a1)(v19 >> 1, *(void *)(*a1 + 16));
        if (!v22) {
          return 6;
        }
        int v23 = v22;
        bzero(v22, v21);
        memcpy(v23, v20, *(int *)(a2 + 4));
        a1[3] = v23;
        *(void *)(a2 + 16) = v23;
        *(_DWORD *)(a2 + 8) = v21;
        if (v20)
        {
          (*(void (**)(const void *, void))(*a1 + 8))(v20, *(void *)(*a1 + 16));
          LODWORD(v21) = *(_DWORD *)(a2 + 8);
          int v23 = *(char **)(a2 + 16);
        }
        int v17 = 0;
        uint64_t v24 = *(int *)(a2 + 4);
        int v18 = v21 - v24;
        *(void *)(a4 + 40) = v23;
        *(void *)(a4 + 8) = &v23[v24];
        *(_DWORD *)(a4 + 32) = 0;
        *(_DWORD *)(a4 + 36) = v21;
        *(void *)(a4 + 104) = v23;
      }
      uint64_t v25 = aj_istream_move_forward(a4);
      if (v25)
      {
        uint64_t v15 = v25;
        aj_log_error((uint64_t)"Decode", "Could not read file into memory");
        int v11 = *(_DWORD *)(a2 + 4);
        int v16 = *(_DWORD *)(a4 + 56);
        goto LABEL_37;
      }
      int v26 = *(_DWORD *)(a4 + 32);
      int v11 = *(_DWORD *)(a2 + 4) + v26 - v17;
      *(_DWORD *)(a2 + 4) = v11;
      int v27 = *(_DWORD *)(a4 + 52);
      if (v27 && v27 == *(_DWORD *)a2 + v11)
      {
        uint64_t v15 = 0;
        int v16 = 2;
        *(_DWORD *)(a4 + 56) = 2;
        goto LABEL_37;
      }
      int v16 = *(_DWORD *)(a4 + 56);
      if (v16 == 1)
      {
        uint64_t v15 = 4294967294;
        goto LABEL_37;
      }
      v18 -= v26 - v17;
      int v17 = v26;
      if (v16 == 2)
      {
        uint64_t v15 = 0;
LABEL_37:
        int v13 = v38;
        goto LABEL_38;
      }
    }
  }
  uint64_t v15 = 0;
  int v16 = 2;
LABEL_38:
  *(void *)(a4 + 40) = v14;
  *(void *)(a4 + 8) = v14;
  *(_DWORD *)(a4 + 32) = 0;
  *(_DWORD *)(a4 + 36) = v13;
  *(void *)(a4 + 104) = 0;
  *(void *)(a2 + 24) = v11;
  aj_istream_init_mem(a3, v10, *(unsigned char *)(a4 + 112), v16);
  *(_DWORD *)(a3 + 96) = *(_DWORD *)a2;
  return v15;
}

uint64_t handle_error_from_decode(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (*a5)
  {
    *a5 = 0;
    if (*(void *)(a3 + 96) && *(void *)(a2 + 32))
    {
      (*(void (**)(void))(a4 + 8))();
      *(void *)(a3 + 96) = 0;
      *(void *)(a2 + 32) = 0;
    }
    *(_DWORD *)(a3 + 136) = 0;
  }
  if ((int)a5[9] >= 1) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a1;
  }
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

uint8x16_t **aj_icol_row_420_to_bgr565(uint8x16_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, char *a5, int a6, unsigned int a7)
{
  uint8x8_t v9 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  if (a6 >= 1)
  {
    int v10 = *result;
    int v11 = *a2;
    int v12 = *a3;
    if (a6 == 1)
    {
      for (unsigned int i = a7 >> 4; i; --i)
      {
        uint8x16_t v59 = *v10++;
        uint8x8_t v60 = *v11++;
        uint8x8_t v61 = *v12++;
        int16x8_t v62 = (int16x8_t)vsubl_u8(v60, v9);
        int16x8_t v63 = (int16x8_t)vsubl_u8(v61, v9);
        int16x8_t v64 = vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v65 = vmulq_n_s16(v63, 179);
        int16x8_t v66 = vqaddq_s16(vmulq_lane_s16(v62, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v63, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v67 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v59.i8, 7uLL);
        int8x8_t v68 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v67, vzip1q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v68, 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v68, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v67, vzip1q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v90);
        uint64_t v69 = a4 + 16;
        int16x8_t v70 = (int16x8_t)vshll_high_n_u8(v59, 7uLL);
        v90.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v70, vzip2q_s16(v66, v66)), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v90.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v64, v64)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v90.val[1], 5uLL));
        v90.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v90.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v70, vzip2q_s16(v65, v65)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v69, v90);
        a4 = v69 + 16;
      }
      unsigned int v71 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v72 = *(uint64x2_t *)v10;
        int16x8_t v73 = (int16x8_t)vsubl_u8(*v11, v9);
        int16x8_t v74 = (int16x8_t)vsubl_u8(*v12, v9);
        int16x8_t v75 = vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v76 = vmulq_n_s16(v74, 179);
        int16x8_t v77 = vqaddq_s16(vmulq_lane_s16(v73, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v74, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v78 = vzip2q_s16(v75, v75);
        int16x8_t v79 = vzip2q_s16(v76, v76);
        int16x8_t v80 = vzip2q_s16(v77, v77);
        int16x8_t v81 = vzip1q_s16(v75, v75);
        int16x8_t v82 = vzip1q_s16(v76, v76);
        int16x8_t v83 = vzip1q_s16(v77, v77);
        if (!(v71 >> 3)) {
          goto LABEL_16;
        }
        int16x8_t v84 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
        int8x8_t v85 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v84, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v91.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v85, 5uLL));
        v91.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v85, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v84, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v91);
        a4 += 16;
        int16x8_t v81 = v78;
        int16x8_t v82 = v79;
        int16x8_t v83 = v80;
        v72.i64[0] = v72.i64[1];
        v71 -= 8;
        if (v71)
        {
LABEL_16:
          int16x8_t v86 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v72.i8, 7uLL);
          int8x8_t v87 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v86, v83), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v81), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v87, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v87, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v86, v82), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            --v71;
          }
          while (v71);
        }
      }
    }
    else
    {
      unsigned int v13 = a7 >> 4;
      for (uint64_t j = result[1]; v13; --v13)
      {
        uint8x16_t v15 = *v10++;
        uint8x16_t v16 = *j++;
        uint8x8_t v17 = *v11++;
        uint8x8_t v18 = *v12++;
        int16x8_t v19 = (int16x8_t)vsubl_u8(v17, v9);
        int16x8_t v20 = (int16x8_t)vsubl_u8(v18, v9);
        int16x8_t v21 = vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v22 = vmulq_n_s16(v20, 179);
        int16x8_t v23 = vqaddq_s16(vmulq_lane_s16(v19, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v24 = vzip2q_s16(v21, v21);
        int16x8_t v25 = vzip2q_s16(v22, v22);
        int16x8_t v26 = vzip2q_s16(v23, v23);
        int16x8_t v27 = vzip1q_s16(v21, v21);
        int16x8_t v28 = vzip1q_s16(v22, v22);
        int16x8_t v29 = vzip1q_s16(v23, v23);
        int16x8_t v30 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v15.i8, 7uLL);
        int8x8_t v31 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v30, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v31, 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v31, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v30, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v88);
        int v32 = a4 + 16;
        int16x8_t v33 = (int16x8_t)vshll_high_n_u8(v15, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v33, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v33, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v32, v88);
        a4 = v32 + 16;
        int16x8_t v34 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v16.i8, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v34, v29), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v27), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v34, v28), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v88);
        int v35 = a5 + 16;
        int16x8_t v36 = (int16x8_t)vshll_high_n_u8(v16, 7uLL);
        v88.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v36, v26), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v88.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v24), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v88.val[1], 5uLL));
        v88.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v88.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v36, v25), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(v35, v88);
        a5 = v35 + 16;
      }
      unsigned int v37 = a7 & 0xF;
      if ((a7 & 0xF) != 0)
      {
        uint64x2_t v38 = *(uint64x2_t *)v10;
        uint64x2_t v39 = *(uint64x2_t *)j;
        int16x8_t v40 = (int16x8_t)vsubl_u8(*v11, v9);
        int16x8_t v41 = (int16x8_t)vsubl_u8(*v12, v9);
        int16x8_t v42 = vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 3);
        int16x8_t v43 = vmulq_n_s16(v41, 179);
        int16x8_t v44 = vqaddq_s16(vmulq_lane_s16(v40, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v41, (int16x4_t)0xE3005B002C00B3, 2));
        int16x8_t v45 = vzip2q_s16(v42, v42);
        int16x8_t v46 = vzip2q_s16(v43, v43);
        int16x8_t v47 = vzip2q_s16(v44, v44);
        int16x8_t v48 = vzip1q_s16(v42, v42);
        int16x8_t v49 = vzip1q_s16(v43, v43);
        int16x8_t v50 = vzip1q_s16(v44, v44);
        if (!(v37 >> 3)) {
          goto LABEL_8;
        }
        int16x8_t v51 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
        int8x8_t v52 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v51, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v52, 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v52, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v51, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a4, v89);
        a4 += 16;
        int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
        v89.val[1] = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v53, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
        v89.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v89.val[1], 5uLL));
        v89.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v89.val[1], 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v53, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
        vst2_s8(a5, v89);
        a5 += 16;
        int16x8_t v48 = v45;
        int16x8_t v49 = v46;
        int16x8_t v50 = v47;
        v38.i64[0] = v38.i64[1];
        v39.i64[0] = v39.i64[1];
        v37 -= 8;
        if (v37)
        {
LABEL_8:
          int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v38.i8, 7uLL);
          int8x8_t v55 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v54, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v55, 5uLL));
          *(int8x8_t *)v8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v55, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v54, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v39.i8, 7uLL);
          int8x8_t v57 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v56, v50), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
          *(int8x8_t *)v38.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v48), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v57, 5uLL));
          *(int8x8_t *)v39.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v57, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v56, v49), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
          do
          {
            *a4 = v7.i8[0];
            a4[1] = v8.i8[0];
            a4 += 2;
            uint64x2_t v7 = vshrq_n_u64(v7, 8uLL);
            uint64x2_t v8 = vshrq_n_u64(v8, 8uLL);
            *a5 = v38.i8[0];
            a5[1] = v39.i8[0];
            a5 += 2;
            uint64x2_t v38 = vshrq_n_u64(v38, 8uLL);
            uint64x2_t v39 = vshrq_n_u64(v39, 8uLL);
            --v37;
          }
          while (v37);
        }
      }
    }
  }
  return result;
}

uint64_t aj_BGRA8888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(int8x8_t **)a3;
  int v6 = *(uint8x8_t **)(a3 + 16);
  uint64x2_t v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  int16x8_t v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (unsigned int i = a4 >> 4; i; --i)
  {
    int8x8x4_t v21 = vld4_s8(v4);
    int v12 = v4 + 32;
    int8x8x4_t v22 = vld4_s8(v12);
    uint64_t v4 = v12 + 32;
    int16x8_t v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *uint64_t v5 = v21.val[2];
    int16x8_t v19 = v5 + 1;
    int8x8_t *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    uint64_t v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[0], v22.val[0]), (uint8x8_t)vuzp2_s8(v21.val[0], v22.val[0]));
  }
  if ((a4 & 8) == 0) {
    JUMPOUT(0x210405F88);
  }
  return sub_210405F04();
}

uint64_t sub_210405F04(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, void *a9)
{
  int8x8x4_t v32 = vld4_s8(a3);
  int16x8_t v13 = (__int8 *)(a3 + 32);
  int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v9.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[0], v32.val[0]), (uint8x8_t)vuzp2_s8(v32.val[0], v32.val[0]));
  *a9 = v11.i64[0];
  int16x8_t v17 = a9 + 1;
  *a7 = v10.i32[0];
  int16x8_t v18 = a7 + 1;
  *a8 = v9.i32[0];
  int16x8_t v19 = a8 + 1;
  int v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 4;
      --v20;
    }
    while (v20);
    int v21 = a5 & 7;
    int v22 = 8 - v21;
    unsigned int v23 = (v21 + 1) >> 1;
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    int16x8_t v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      int64x2_t v11 = vsliq_n_s64(v11, v11, 8uLL);
      int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
      int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v9.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v9.i8, *(int8x8_t *)v9.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v9.i8, *(int8x8_t *)v9.i8));
    do
    {
      *v17++ = v11.i8[7];
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v9.i8[3];
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      --v23;
    }
    while (v23);
  }
  uint64_t result = (a6 - a5);
  if (a6 != a5)
  {
    unsigned int v28 = result >> 1;
    char v29 = *(v17 - 1);
    char v30 = *(v18 - 1);
    char v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_mcu_dct(int *a1, _DWORD *a2)
{
  unsigned int v2 = a2;
  int v4 = a2[514];
  if (v4 && v4 == a2[515])
  {
    int v5 = (a2[516] + 1) & 7;
    a2[516] = v5;
    uint64_t result = aj_ostream_write_bytes((uint64_t)(a2 + 482), v5 | 0xFFD0u, 2);
    if (result) {
      return result;
    }
    uint64_t v7 = *((void *)v2 + 259);
    if (v7)
    {
      int v8 = v2[520] + v2[486] - v2[505] - 2;
      uint64_t v9 = (int)v2[522];
      v2[522] = v9 + 1;
      *(_DWORD *)(v7 + 4 * v9) = v8;
    }
    v2[515] = 0;
    *((_OWORD *)v2 + 125) = 0u;
  }
  int v10 = *a1;
  if (*a1 < 1)
  {
LABEL_19:
    uint64_t result = 0;
    ++v2[515];
  }
  else
  {
    uint64_t v11 = 0;
    int16x8_t v12 = a1 + 3368;
    int16x8_t v13 = (int8x16_t *)(v2 + 128);
    int16x8_t v14 = (int32x2_t *)(v2 + 482);
    int16x8_t v27 = a1;
    unsigned int v28 = v2;
    int16x8_t v26 = a1 + 3368;
    while (1)
    {
      int16x8_t v15 = &a1[v11];
      int v16 = v15[8];
      char v30 = v15 + 8;
      if (v16 >= 1) {
        break;
      }
LABEL_18:
      if (++v11 >= v10) {
        goto LABEL_19;
      }
    }
    uint64_t v17 = 0;
    int v20 = v15[4];
    int16x8_t v19 = v15 + 4;
    int v18 = v20;
    int v21 = &v2[32 * v11];
    uint64_t v22 = (uint64_t)&v12[392 * v11];
    unsigned int v23 = &v2[v11 + 500];
    char v29 = v21;
    while (v18 < 1)
    {
LABEL_16:
      if (++v17 >= v16)
      {
        a1 = v27;
        unsigned int v2 = v28;
        int v10 = *v27;
        int16x8_t v12 = v26;
        goto LABEL_18;
      }
    }
    int v24 = 0;
    int16x8_t v25 = (uint8x8_t **)&v21[2 * (8 * v17)];
    while (1)
    {
      aj_block_dct(v25, v13, (int16x8_t *)(v22 + 540));
      uint64_t result = aj_block_encode(v22, v13->i16, v14, v23);
      if (result) {
        break;
      }
      v13 += 8;
      ++v24;
      int v18 = *v19;
      if (v24 >= *v19)
      {
        int v21 = v29;
        int v16 = *v30;
        goto LABEL_16;
      }
    }
  }
  return result;
}

uint64_t (*aj_fill_prog_coeff_buf(uint64_t (*result)(), uint8x8_t **a2))()
{
  if (*((_DWORD *)result + 4) * *((_DWORD *)result + 3358) >= 1)
  {
    unint64_t v3 = result;
    int v4 = 0;
    int v5 = (int8x16_t *)*((void *)result + 2478);
    int v6 = (int16x8_t *)((char *)result + 14012);
    do
    {
      uint64_t result = aj_block_dct(a2, v5, v6);
      ++v4;
      v5 += 8;
    }
    while (v4 < *((_DWORD *)v3 + 4) * *((_DWORD *)v3 + 3358));
  }
  return result;
}

uint64_t aj_bufferproc_savefirst(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int a4)
{
  int v5 = a3;
  if (a3[279] < a3[275] || a3[280] < a3[276])
  {
    int v7 = aj_highest_set_bit(*(_DWORD *)(a1 + 44));
    if (*(int *)(a2 + 6464) >= 1)
    {
      uint64_t v8 = 0;
      unsigned int v9 = (int)(v7 - 1 + a4) >> (v7 - 1);
      int v10 = v5 + 38;
      uint64_t v11 = v5 + 284;
      int16x8_t v12 = v5 + 142;
      unsigned int v28 = a4;
      uint64_t v26 = a2;
      int16x8_t v27 = v5;
      unsigned int v25 = v9;
      do
      {
        if (v8) {
          unint64_t v13 = v9;
        }
        else {
          unint64_t v13 = a4;
        }
        int16x8_t v14 = &v5[v8];
        int v15 = v14[279];
        if (v15 < v14[275] && (int)v13 >= 1)
        {
          unint64_t v17 = 0;
          int v29 = v14[279];
          int v18 = &v11[2 * v15];
          uint64_t v19 = v15 + 1;
          do
          {
            unint64_t v20 = v17;
            *(void *)&v18[2 * v17] = aj_rowbuffer_lock_buffer(v10, *(void *)&v12[2 * v17]);
            unint64_t v17 = v20 + 1;
          }
          while ((uint64_t)(v19 + v20) < (int)v14[275] && v17 < v13);
          int v15 = v29 + v17;
          a4 = v28;
          a2 = v26;
          int v5 = v27;
          unsigned int v9 = v25;
        }
        v14[279] = v15;
        ++v8;
        v11 += 20;
        v12 += 32;
      }
      while (v8 < *(int *)(a2 + 6464));
    }
  }
  uint64_t v22 = **(uint64_t (***)(void))(a1 + 80);
  return v22();
}

uint64_t aj_bufferproc_rgb2yuv(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(unsigned char *)(a3 + 1082)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = a4 < 1;
  }
  if (!v4)
  {
    uint64_t v5 = 0;
    do
    {
      int v6 = *(_DWORD *)(a1 + 48);
      if (v6 >= 1)
      {
        int v7 = *(unsigned __int8 **)(a3 + 824 + 8 * v5);
        uint64_t v8 = *(unsigned __int8 **)(a3 + 696 + 8 * v5);
        unsigned int v9 = *(unsigned __int8 **)(a3 + 568 + 8 * v5);
        do
        {
          int v10 = *v9;
          int v11 = *v8;
          int v12 = *v7;
          unsigned int v13 = (v12 << 6)
              - (((707584 * v10 + 0x4000) >> 15)
               + ((1389568 * v11 + 0x4000) >> 15))
              + 16448;
          if (v13 >= 0x8000) {
            LOBYTE(v14) = -1;
          }
          else {
            unsigned int v14 = v13 >> 7;
          }
          unsigned int v15 = (v10 << 6)
              - (((1756160 * v11 + 0x4000) >> 15)
               + ((340992 * v12 + 0x4000) >> 15))
              + 16448;
          if (v15 >= 0x8000) {
            LOBYTE(v16) = -1;
          }
          else {
            unsigned int v16 = v15 >> 7;
          }
          *v9++ = (((1254144 * v10 + 0x4000) >> 15)
                 + ((2462080 * v11 + 0x4000) >> 15)
                 + ((478208 * v12 + 0x4000) >> 15)
                 + 64) >> 7;
          *v8++ = v14;
          *v7++ = v16;
          --v6;
        }
        while (v6);
      }
      ++v5;
    }
    while (v5 != a4);
  }
  unint64_t v17 = **(uint64_t (***)(void))(a1 + 80);
  return v17();
}

void aj_bufferproc_upsample_422(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int a5)
{
  uint64_t v6 = a1;
  int v7 = *(void (***)(void))(a1 + 80);
  if (*(_DWORD *)(*a2 + 4) == 12) {
    uint64_t v8 = aj_internal_upsample_422_12bit;
  }
  else {
    uint64_t v8 = aj_internal_upsample_422;
  }
  if (a4)
  {
    int v21 = (void (**)(void, void, void, void, void))v7;
    if (a4 >= 1)
    {
      uint64_t v10 = 0;
      uint64_t v19 = a4;
      uint64_t v20 = v6;
      do
      {
        buffer = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), a2[839]);
        int v12 = aj_rowbuffer_get_buffer((unsigned int *)(a3 + 152), a2[839]);
        unsigned int v13 = (void *)(a3 + 8 * v10);
        ((void (*)(void, unsigned char *, void))v8)(v13[87], buffer, *(unsigned int *)(v6 + 52));
        ((void (*)(void, unsigned char *, void))v8)(v13[103], v12, *(unsigned int *)(v6 + 56));
        uint64_t v14 = *(void *)(a3 + 568);
        *(void *)(a3 + 568) = v13[71];
        uint64_t v15 = *(void *)(a3 + 696);
        *(void *)(a3 + 696) = buffer;
        uint64_t v16 = *(void *)(a3 + 824);
        *(void *)(a3 + 824) = v12;
        (*v21)(v21, a2, a3, 1, (a5 + v10));
        *(void *)(a3 + 568) = v14;
        uint64_t v6 = v20;
        *(void *)(a3 + 696) = v15;
        *(void *)(a3 + 824) = v16;
        aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)buffer);
        aj_rowbuffer_return_buffer((unsigned int *)(a3 + 152), (unint64_t)v12);
        ++v10;
      }
      while (v19 != v10);
    }
  }
  else
  {
    unint64_t v17 = *v7;
    v17();
  }
}

uint64_t aj_bufferproc_upsample422_init(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a1 + 40) == 2 && *(_DWORD *)(a1 + 44) == 1)
  {
    uint64_t v5 = 0;
    long long v7 = *(_OWORD *)(a1 + 40);
    long long v6 = *(_OWORD *)(a1 + 56);
    *(void *)(a5 + 32) = *(void *)(a1 + 72);
    *(_OWORD *)a5 = v7;
    *(_OWORD *)(a5 + 16) = v6;
    *(_DWORD *)a5 = 1;
    int v8 = *(_DWORD *)(a5 + 8);
    do
    {
      *(_DWORD *)(a5 + 12 + v5) = v8;
      v5 += 4;
    }
    while (v5 != 12);
    return 0;
  }
  else
  {
    aj_log_error(0, "Input format to upsample422, is not 4:2:2");
    return 1;
  }
}

unsigned __int16 *aj_internal_upsample_422_12bit(unsigned __int16 *result, _WORD *a2, int a3)
{
  int v3 = *result;
  *a2 = v3;
  BOOL v4 = a2 + 1;
  int v5 = a3 - 1;
  if (a3 != 1)
  {
    long long v6 = result + 1;
    do
    {
      int v8 = *v6++;
      __int16 v7 = v8;
      *BOOL v4 = (3 * v3 + v8 + 1) >> 2;
      unsigned int v9 = v4 + 2;
      v4[1] = (v3 + 3 * v8 + 2) >> 2;
      v4 += 2;
      int v3 = v8;
      --v5;
    }
    while (v5);
    LOWORD(v3) = v7;
    BOOL v4 = v9;
  }
  *BOOL v4 = v3;
  return result;
}

uint64_t aj_block_encode_ac(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = 62;
  uint64_t v4 = *(void *)(a1 + 680);
  uint64_t v5 = *(void *)(a1 + 688);
  long long v6 = (__int16 *)(a2 + 2);
  int v9 = *v6;
  int v8 = (unsigned int *)(v6 + 1);
  int v7 = v9;
  int v10 = v9 == 0;
  if (v9)
  {
    unsigned int v11 = v7 + 16;
    if (v11 >= 0x20)
    {
      if ((int)(v11 - 16) >= 0) {
        unsigned int v43 = v11 - 16;
      }
      else {
        unsigned int v43 = 16 - v11;
      }
      unsigned int v44 = 32 - __clz(v43);
      if ((int)(v11 - 16) < 0) {
        unsigned int v43 = ~v43;
      }
      unsigned int v45 = v44 + 16 * v10;
      unsigned int v15 = (v43 << (32 - v44) >> (32 - v44)) + ((unsigned __int16)*(_DWORD *)(v4 + 4 * v45) << v44);
      int v14 = v44 + HIWORD(*(_DWORD *)(v4 + 4 * v45));
      if (v14 > 24) {
        goto LABEL_76;
      }
      int v46 = *(_DWORD *)(a3 + 20);
      if (v46 <= 8) {
        goto LABEL_76;
      }
      int v47 = v14 + *(_DWORD *)(a3 + 4);
      unsigned int v48 = *(_DWORD *)a3 | (v15 << (32 - v47));
      int16x8_t v49 = *(unsigned char **)(a3 + 8);
      for (int i = *(_DWORD *)(a3 + 16); v47 >= 8; v48 <<= 8)
      {
        *v49++ = HIBYTE(v48);
        --v46;
        ++i;
        if (HIBYTE(v48) == 255)
        {
          *v49++ = 0;
          --v46;
          ++i;
        }
        v47 -= 8;
      }
      *(_DWORD *)a3 = v48;
      *(_DWORD *)(a3 + 4) = v47;
      *(void *)(a3 + 8) = v49;
      *(_DWORD *)(a3 + 16) = i;
      *(_DWORD *)(a3 + 20) = v46;
    }
    else
    {
      int v12 = *(_DWORD *)(a3 + 20);
      unsigned int v13 = *(_DWORD *)(v5 + 4 * v11);
      int v14 = HIBYTE(v13);
      unsigned int v15 = v13 & 0xFFFFFF;
      if (v12 <= 8) {
        goto LABEL_76;
      }
      int v16 = v14 + *(_DWORD *)(a3 + 4);
      unsigned int v17 = *(_DWORD *)a3 | (v15 << (32 - v16));
      int v18 = *(unsigned char **)(a3 + 8);
      for (int j = *(_DWORD *)(a3 + 16); v16 >= 8; v17 <<= 8)
      {
        *v18++ = HIBYTE(v17);
        --v12;
        ++j;
        if (HIBYTE(v17) == 255)
        {
          *v18++ = 0;
          --v12;
          ++j;
        }
        v16 -= 8;
      }
      *(_DWORD *)a3 = v17;
      *(_DWORD *)(a3 + 4) = v16;
      *(void *)(a3 + 8) = v18;
      *(_DWORD *)(a3 + 16) = j;
      *(_DWORD *)(a3 + 20) = v12;
    }
  }
LABEL_12:
  unsigned int v21 = *v8++;
  uint64_t result = v21;
  if (!v21)
  {
    v10 += 2;
LABEL_10:
    --v3;
    goto LABEL_11;
  }
  if (result << 16) {
    int v22 = result << 16;
  }
  else {
    int v22 = result;
  }
  --v3;
  int v23 = v22 >> 16;
  if (result << 16) {
    ++v3;
  }
  else {
    ++v10;
  }
  if (v10 >> 4)
  {
LABEL_54:
    while (1)
    {
      v10 -= 16;
      unsigned int v51 = (unsigned __int16)*(_DWORD *)(v4 + 960);
      int v52 = HIWORD(*(_DWORD *)(v4 + 960));
      int v53 = *(_DWORD *)(a3 + 20);
      if (v53 <= 8) {
        goto LABEL_83;
      }
      int v54 = v52 + *(_DWORD *)(a3 + 4);
      unsigned int v55 = *(_DWORD *)a3 | (v51 << (32 - v54));
      int16x8_t v56 = *(unsigned char **)(a3 + 8);
      for (int k = *(_DWORD *)(a3 + 16); v54 >= 8; v55 <<= 8)
      {
        *v56++ = HIBYTE(v55);
        --v53;
        ++k;
        if (HIBYTE(v55) == 255)
        {
          *v56++ = 0;
          --v53;
          ++k;
        }
        v54 -= 8;
      }
      *(_DWORD *)a3 = v55;
      *(_DWORD *)(a3 + 4) = v54;
      *(void *)(a3 + 8) = v56;
      *(_DWORD *)(a3 + 16) = k;
      *(_DWORD *)(a3 + 20) = v53;
      if (!(v10 >> 4))
      {
        int v23 = (__int16)result;
        if (v3) {
          int v23 = (int)result >> 16;
        }
        goto LABEL_20;
      }
    }
  }
  do
  {
LABEL_20:
    while (1)
    {
      unsigned int v24 = v23 + 16;
      if (v24 < 0x20 && v10 < 8) {
        break;
      }
      if ((int)(v24 - 16) >= 0) {
        unsigned int v58 = v24 - 16;
      }
      else {
        unsigned int v58 = 16 - v24;
      }
      unsigned int v59 = 32 - __clz(v58);
      if ((int)(v24 - 16) < 0) {
        unsigned int v58 = ~v58;
      }
      unsigned int v60 = v59 + 16 * v10;
      int v10 = 0;
      int v61 = (v58 << (32 - v59) >> (32 - v59)) + ((unsigned __int16)*(_DWORD *)(v4 + 4 * v60) << v59);
      int v62 = v59 + HIWORD(*(_DWORD *)(v4 + 4 * v60));
      int v29 = v62;
      unsigned int v30 = v61;
      if (v62 > 24 || (int v63 = *(_DWORD *)(a3 + 20), v63 <= 8))
      {
LABEL_78:
        int16x8_t v80 = v8;
        uint64_t v83 = a3;
        int v77 = v3;
        uint64_t v69 = v5;
        uint64_t v72 = result;
        uint64_t v66 = v4;
        BOOL v34 = aj_ostream_write((unsigned int *)a3, v30, v29) == 0;
        uint64_t v4 = v66;
        uint64_t v5 = v69;
        uint64_t result = v72;
        int v10 = 0;
        int v3 = v77;
        int v8 = v80;
        a3 = v83;
        if (!v34) {
          return result;
        }
        if (v77)
        {
LABEL_11:
          if (!--v3) {
            goto LABEL_29;
          }
          goto LABEL_12;
        }
        int v23 = (int)v72 >> 16;
        int v10 = (int)v72 >> 16 == 0;
        if (!((int)v72 >> 16)) {
          goto LABEL_10;
        }
        int v3 = v77 - 1;
        if (v77 == 1)
        {
LABEL_83:
          int16x8_t v81 = v8;
          uint64_t v84 = a3;
          unsigned int v75 = v10;
          int v78 = v3;
          uint64_t v70 = v5;
          uint64_t v73 = result;
          uint64_t v67 = v4;
          BOOL v34 = aj_ostream_write((unsigned int *)a3, v51, v52) == 0;
          uint64_t v4 = v67;
          uint64_t v5 = v70;
          uint64_t result = v73;
          int v10 = v75;
          int v3 = v78;
          int v8 = v81;
          a3 = v84;
          if (!v34) {
            return result;
          }
          if (v75 >> 4) {
            goto LABEL_54;
          }
          int v23 = (__int16)v73;
          if (v78) {
            int v23 = (int)v73 >> 16;
          }
        }
      }
      else
      {
        int v14 = v62 + *(_DWORD *)(a3 + 4);
        unsigned int v15 = *(_DWORD *)a3 | (v61 << (32 - v14));
        int16x8_t v64 = *(unsigned char **)(a3 + 8);
        for (int m = *(_DWORD *)(a3 + 16); v14 >= 8; v15 <<= 8)
        {
          *v64++ = HIBYTE(v15);
          --v63;
          ++m;
          if (HIBYTE(v15) == 255)
          {
            *v64++ = 0;
            --v63;
            ++m;
          }
          v14 -= 8;
        }
        *(_DWORD *)a3 = v15;
        *(_DWORD *)(a3 + 4) = v14;
        *(void *)(a3 + 8) = v64;
        *(_DWORD *)(a3 + 16) = m;
        *(_DWORD *)(a3 + 20) = v63;
        if (v3) {
          goto LABEL_11;
        }
        int v23 = (int)result >> 16;
        int v10 = (int)result >> 16 == 0;
        if (!((int)result >> 16)) {
          goto LABEL_10;
        }
        if (!--v3)
        {
LABEL_76:
          int16x8_t v79 = v8;
          uint64_t v82 = a3;
          int v74 = v10;
          int v76 = v3;
          uint64_t v68 = v5;
          uint64_t v71 = v4;
          uint64_t result = aj_ostream_write((unsigned int *)a3, v15, v14);
          uint64_t v5 = v68;
          uint64_t v4 = v71;
          int v10 = v74;
          int v3 = v76;
          int v8 = v79;
          a3 = v82;
          if (result) {
            return result;
          }
          goto LABEL_12;
        }
      }
    }
    unsigned int v25 = *(_DWORD *)(v5 + 4 * (v24 + 32 * v10));
    uint64_t v26 = *(unsigned char **)(a3 + 8);
    int v27 = *(_DWORD *)(a3 + 16);
    int v28 = *(_DWORD *)(a3 + 20);
    int v10 = 0;
    int v29 = HIBYTE(v25);
    unsigned int v30 = v25 & 0xFFFFFF;
    if (v28 <= 8) {
      goto LABEL_78;
    }
    int v31 = *(_DWORD *)(a3 + 4) + v29;
    unsigned int v32 = *(_DWORD *)a3 | (v30 << (32 - v31));
    while (v31 >= 8)
    {
      while (1)
      {
        unsigned int v33 = HIBYTE(v32);
        ++v27;
        --v28;
        *v26++ = HIBYTE(v32);
        BOOL v34 = HIBYTE(v32) == 255;
        v31 -= 8;
        v32 <<= 8;
        if (v33 == 255) {
          break;
        }
        if (v31 < 8) {
          goto LABEL_26;
        }
      }
      if (v34)
      {
        *v26++ = 0;
        --v28;
        ++v27;
      }
    }
LABEL_26:
    *(_DWORD *)a3 = v32;
    *(_DWORD *)(a3 + 4) = v31;
    *(void *)(a3 + 8) = v26;
    *(_DWORD *)(a3 + 16) = v27;
    *(_DWORD *)(a3 + 20) = v28;
    if (v3) {
      goto LABEL_11;
    }
    int v23 = (int)result >> 16;
    int v10 = (int)result >> 16 == 0;
    if (!((int)result >> 16)) {
      goto LABEL_10;
    }
    --v3;
  }
  while (v3);
LABEL_29:
  if (!v10) {
    return 0;
  }
  int v35 = *(_DWORD *)(a3 + 20);
  unsigned int v36 = *(_DWORD *)(v5 + 64);
  int v37 = HIBYTE(v36);
  unsigned int v38 = v36 & 0xFFFFFF;
  if (v35 <= 8)
  {
    uint64_t result = aj_ostream_write((unsigned int *)a3, v38, v37);
    if (!result) {
      return 0;
    }
  }
  else
  {
    int v39 = v37 + *(_DWORD *)(a3 + 4);
    unsigned int v40 = *(_DWORD *)a3 | (v38 << (32 - v39));
    int16x8_t v41 = *(unsigned char **)(a3 + 8);
    for (int n = *(_DWORD *)(a3 + 16); v39 >= 8; v40 <<= 8)
    {
      *v41++ = HIBYTE(v40);
      --v35;
      ++n;
      if (HIBYTE(v40) == 255)
      {
        *v41++ = 0;
        --v35;
        ++n;
      }
      v39 -= 8;
    }
    *(_DWORD *)a3 = v40;
    *(_DWORD *)(a3 + 4) = v39;
    *(void *)(a3 + 8) = v41;
    *(_DWORD *)(a3 + 16) = n;
    *(_DWORD *)(a3 + 20) = v35;
    return 0;
  }
  return result;
}

unint64_t aj_BGRA8888_YUV420(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4, size_t a5)
{
  if (a1 == 1)
  {
    aj_BGRA8888_YUV422(a1, a2, a3, a4);
    return (unint64_t)memcpy(*(void **)(a3 + 8), *(const void **)a3, a5);
  }
  else
  {
    int v12 = a2[1];
    unsigned int v13 = *a2;
    int v14 = *(int8x8_t **)a3;
    unsigned int v15 = *(unsigned char **)(a3 + 8);
    int v16 = *(unsigned char **)(a3 + 16);
    unsigned int v17 = *(unsigned char **)(a3 + 32);
    v18.i64[0] = 0x80008000800080;
    v18.i64[1] = 0x80008000800080;
    int16x8_t v19 = vshlq_n_s16(v18, 7uLL);
    v20.i64[0] = 0x15980E984B232646;
    v20.i64[1] = 0xA6835982A68;
    for (unsigned int i = a4 >> 4; i; --i)
    {
      int8x8x4_t v66 = vld4_s8(v13);
      int v22 = v13 + 32;
      int8x8x4_t v68 = vld4_s8(v22);
      unsigned int v13 = v22 + 32;
      int16x8_t v23 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[2], 7uLL);
      int16x8_t v24 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[1], 7uLL);
      int16x8_t v25 = (int16x8_t)vshll_n_u8((uint8x8_t)v66.val[0], 7uLL);
      v66.val[2] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v24, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v25, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v66.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v23, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v24, v20, 4)), vrshrq_n_s16(v25, 1uLL)), 7uLL);
      v66.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v23, 1uLL), vqrdmulhq_laneq_s16(v24, v20, 5)), vqrdmulhq_laneq_s16(v25, v20, 6)), v19), 7uLL);
      int16x8_t v26 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[2], 7uLL);
      int16x8_t v27 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[1], 7uLL);
      int16x8_t v28 = (int16x8_t)vshll_n_u8((uint8x8_t)v68.val[0], 7uLL);
      v29.i64[0] = (uint64_t)v66.val[1];
      v29.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v27, v20, 4)), vrshrq_n_s16(v28, 1uLL)), 7uLL);
      v30.i64[0] = (uint64_t)v66.val[0];
      v30.u64[1] = (unint64_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v26, 1uLL), vqrdmulhq_laneq_s16(v27, v20, 5)), vqrdmulhq_laneq_s16(v28, v20, 6)), v19), 7uLL);
      *int v14 = v66.val[2];
      int v31 = v14 + 1;
      *int v31 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v26, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v27, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v28, *(int16x4_t *)v20.i8, 2)), 7uLL);
      int v14 = v31 + 1;
      int8x8x4_t v67 = vld4_s8(v12);
      unsigned int v32 = v12 + 32;
      int8x8x4_t v69 = vld4_s8(v32);
      int v12 = v32 + 32;
      int16x8_t v33 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[2], 7uLL);
      int16x8_t v34 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[1], 7uLL);
      int16x8_t v35 = (int16x8_t)vshll_n_u8((uint8x8_t)v67.val[0], 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v34, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v35, *(int16x4_t *)v20.i8, 2)), 7uLL);
      v67.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v33, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v34, v20, 4)), vrshrq_n_s16(v35, 1uLL)), 7uLL);
      v67.val[0] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v33, 1uLL), vqrdmulhq_laneq_s16(v34, v20, 5)), vqrdmulhq_laneq_s16(v35, v20, 6)), v19), 7uLL);
      int16x8_t v36 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[2], 7uLL);
      int16x8_t v37 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[1], 7uLL);
      int16x8_t v38 = (int16x8_t)vshll_n_u8((uint8x8_t)v69.val[0], 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v37, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v38, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v36, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v37, v20, 4)), vrshrq_n_s16(v38, 1uLL)), 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v36, 1uLL), vqrdmulhq_laneq_s16(v37, v20, 5)), vqrdmulhq_laneq_s16(v38, v20, 6)), v19), 7uLL);
      *(void *)unsigned int v15 = v7.i64[0];
      int v39 = v15 + 8;
      *int v39 = v10.i64[0];
      unsigned int v15 = v39 + 1;
      uint64_t v40 = v9.i64[0];
      uint64_t v41 = v8.i64[0];
      int64x2_t v6 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[1].i8), (int16x8_t)vpaddlq_u8(v29));
      int64x2_t v5 = (int64x2_t)vaddq_s16((int16x8_t)vpaddlq_u8(*(uint8x16_t *)v67.val[0].i8), (int16x8_t)vpaddlq_u8(v30));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      *(void *)int v16 = v6.i64[0];
      v16 += 8;
      *(void *)unsigned int v17 = v5.i64[0];
      v17 += 8;
    }
    if ((a4 & 8) != 0)
    {
      *(int8x8x4_t *)v5.i8 = vld4_s8(v13);
      v13 += 32;
      int8x8x4_t v70 = vld4_s8(v12);
      v12 += 32;
      int16x8_t v43 = (int16x8_t)vshll_n_u8(v42, 7uLL);
      int16x8_t v44 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v45 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v44, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v45, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v43, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v44, v20, 4)), vrshrq_n_s16(v45, 1uLL)), 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v43, 1uLL), vqrdmulhq_laneq_s16(v44, v20, 5)), vqrdmulhq_laneq_s16(v45, v20, 6)), v19), 7uLL);
      int16x8_t v46 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[2], 7uLL);
      int16x8_t v47 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[1], 7uLL);
      int16x8_t v48 = (int16x8_t)vshll_n_u8((uint8x8_t)v70.val[0], 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v47, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v48, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *v14++ = *(int8x8_t *)v7.i8;
      *(void *)unsigned int v15 = v10.i64[0];
      v15 += 8;
      *(uint16x4_t *)v9.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v46, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v47, v20, 4)), vrshrq_n_s16(v48, 1uLL)), 7uLL));
      *(uint16x4_t *)v8.i8 = vpaddl_u8((uint8x8_t)vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v46, 1uLL), vqrdmulhq_laneq_s16(v47, v20, 5)), vqrdmulhq_laneq_s16(v48, v20, 6)), v19), 7uLL));
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), *(int16x4_t *)v9.i8);
      *(int16x4_t *)v5.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v5.i8), *(int16x4_t *)v8.i8);
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      *(_DWORD *)int v16 = v6.i32[0];
      v16 += 4;
      *(_DWORD *)unsigned int v17 = v5.i32[0];
      v17 += 4;
    }
    int v49 = a4 & 7;
    if ((a4 & 7) != 0)
    {
      do
      {
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
        int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
        int64x2_t v8 = vshlq_n_s64(v8, 8uLL);
        v5.i8[0] = *v13;
        v6.i8[0] = v13[1];
        v7.i8[0] = v13[2];
        v13 += 4;
        v8.i8[0] = *v12;
        v9.i8[0] = v12[1];
        v10.i8[0] = v12[2];
        v12 += 4;
        --v49;
      }
      while (v49);
      int v50 = a4 & 7;
      int v51 = 8 - v50;
      unsigned int v52 = (v50 + 1) >> 1;
      int16x8_t v53 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v7.i8, 7uLL);
      int16x8_t v54 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v6.i8, 7uLL);
      int16x8_t v55 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v5.i8, 7uLL);
      *(int8x8_t *)v7.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v54, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v55, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v6.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v53, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v54, v20, 4)), vrshrq_n_s16(v55, 1uLL)), 7uLL);
      *(int8x8_t *)v5.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v53, 1uLL), vqrdmulhq_laneq_s16(v54, v20, 5)), vqrdmulhq_laneq_s16(v55, v20, 6)), v19), 7uLL);
      int16x8_t v56 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
      int16x8_t v57 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
      int16x8_t v58 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v8.i8, 7uLL);
      *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 0), vqrdmulhq_lane_s16(v57, *(int16x4_t *)v20.i8, 1)), vqrdmulhq_lane_s16(v58, *(int16x4_t *)v20.i8, 2)), 7uLL);
      *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v19, vqrdmulhq_lane_s16(v56, *(int16x4_t *)v20.i8, 3)), vqrdmulhq_laneq_s16(v57, v20, 4)), vrshrq_n_s16(v58, 1uLL)), 7uLL);
      *(int8x8_t *)v8.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v56, 1uLL), vqrdmulhq_laneq_s16(v57, v20, 5)), vqrdmulhq_laneq_s16(v58, v20, 6)), v19), 7uLL);
      do
      {
        int64x2_t v7 = vsliq_n_s64(v7, v7, 8uLL);
        int64x2_t v6 = vsliq_n_s64(v6, v6, 8uLL);
        int64x2_t v5 = vsliq_n_s64(v5, v5, 8uLL);
        int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
        int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
        int64x2_t v8 = vsliq_n_s64(v8, v8, 8uLL);
        --v51;
      }
      while (v51);
      *(int16x4_t *)v6.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v6.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v9.i8));
      *(int16x4_t *)v5.i8 = vadd_s16((int16x4_t)vpaddl_u8(*(uint8x8_t *)v5.i8), (int16x4_t)vpaddl_u8(*(uint8x8_t *)v8.i8));
      *(uint8x8_t *)v6.i8 = vqrshrn_n_u16((uint16x8_t)v6, 2uLL);
      *(uint8x8_t *)v5.i8 = vqrshrn_n_u16((uint16x8_t)v5, 2uLL);
      do
      {
        v14->i8[0] = v7.i8[7];
        int v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v10.i8[7];
        int64x2_t v7 = vshlq_n_s64(v7, 8uLL);
        int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
        --v50;
      }
      while (v50);
      do
      {
        *v16++ = v6.i8[3];
        *v17++ = v5.i8[3];
        int64x2_t v6 = vshlq_n_s64(v6, 8uLL);
        int64x2_t v5 = vshlq_n_s64(v5, 8uLL);
        --v52;
      }
      while (v52);
    }
    unint64_t result = a5 - a4;
    if (a5 != a4)
    {
      unsigned int v59 = result >> 1;
      __int8 v60 = v14[-1].i8[7];
      char v61 = *(v15 - 1);
      char v62 = *(v16 - 1);
      char v63 = *(v17 - 1);
      do
      {
        v14->i8[0] = v60;
        int v14 = (int8x8_t *)((char *)v14 + 1);
        *v15++ = v61;
        unint64_t result = (result - 1);
      }
      while (result);
      for (; v59; --v59)
      {
        *v16++ = v62;
        *v17++ = v63;
      }
    }
  }
  return result;
}

uint64_t aj_RGB888_YUV422(uint64_t a1, const char **a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4 = *a2;
  int64x2_t v5 = *(int8x8_t **)a3;
  int64x2_t v6 = *(uint8x8_t **)(a3 + 16);
  int64x2_t v7 = *(uint8x8_t **)(a3 + 32);
  v8.i64[0] = 0x80008000800080;
  v8.i64[1] = 0x80008000800080;
  int16x8_t v9 = vshlq_n_s16(v8, 7uLL);
  v10.i64[0] = 0x15980E984B232646;
  v10.i64[1] = 0xA6835982A68;
  for (unsigned int i = a4 >> 4; i; --i)
  {
    int8x8x3_t v21 = vld3_s8(v4);
    int v12 = v4 + 24;
    int8x8x3_t v22 = vld3_s8(v12);
    uint64_t v4 = v12 + 24;
    int16x8_t v13 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[0], 7uLL);
    int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[1], 7uLL);
    int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v21.val[2], 7uLL);
    v21.val[0] = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v14, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v15, *(int16x4_t *)v10.i8, 2)), 7uLL);
    v21.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v13, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v14, v10, 4)), vrshrq_n_s16(v15, 1uLL)), 7uLL);
    v21.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v13, 1uLL), vqrdmulhq_laneq_s16(v14, v10, 5)), vqrdmulhq_laneq_s16(v15, v10, 6)), v9), 7uLL);
    int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[0], 7uLL);
    int16x8_t v17 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[1], 7uLL);
    int16x8_t v18 = (int16x8_t)vshll_n_u8((uint8x8_t)v22.val[2], 7uLL);
    v22.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v9, vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 3)), vqrdmulhq_laneq_s16(v17, v10, 4)), vrshrq_n_s16(v18, 1uLL)), 7uLL);
    v22.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v16, 1uLL), vqrdmulhq_laneq_s16(v17, v10, 5)), vqrdmulhq_laneq_s16(v18, v10, 6)), v9), 7uLL);
    *int64x2_t v5 = v21.val[0];
    int16x8_t v19 = v5 + 1;
    int8x8_t *v19 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v16, *(int16x4_t *)v10.i8, 0), vqrdmulhq_lane_s16(v17, *(int16x4_t *)v10.i8, 1)), vqrdmulhq_lane_s16(v18, *(int16x4_t *)v10.i8, 2)), 7uLL);
    int64x2_t v5 = v19 + 1;
    *v6++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[1], v22.val[1]), (uint8x8_t)vuzp2_s8(v21.val[1], v22.val[1]));
    *v7++ = vrhadd_u8((uint8x8_t)vuzp1_s8(v21.val[2], v22.val[2]), (uint8x8_t)vuzp2_s8(v21.val[2], v22.val[2]));
  }
  if ((a4 & 8) == 0) {
    JUMPOUT(0x210407524);
  }
  return sub_2104074A0();
}

uint64_t sub_2104074A0(int16x8_t a1, uint64_t a2, const char *a3, uint64_t a4, int a5, int a6, _DWORD *a7, _DWORD *a8, void *a9)
{
  int8x8x3_t v32 = vld3_s8(a3);
  int16x8_t v13 = (__int8 *)(a3 + 24);
  int16x8_t v14 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[0], 7uLL);
  int16x8_t v15 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[1], 7uLL);
  int16x8_t v16 = (int16x8_t)vshll_n_u8((uint8x8_t)v32.val[2], 7uLL);
  *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v15, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v16, *(int16x4_t *)a1.i8, 2)), 7uLL);
  v32.val[1] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v14, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v15, a1, 4)), vrshrq_n_s16(v16, 1uLL)), 7uLL);
  v32.val[2] = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v14, 1uLL), vqrdmulhq_laneq_s16(v15, a1, 5)), vqrdmulhq_laneq_s16(v16, a1, 6)), v12), 7uLL);
  *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[1], v32.val[1]), (uint8x8_t)vuzp2_s8(v32.val[1], v32.val[1]));
  *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(v32.val[2], v32.val[2]), (uint8x8_t)vuzp2_s8(v32.val[2], v32.val[2]));
  *a9 = v9.i64[0];
  int16x8_t v17 = a9 + 1;
  *a7 = v10.i32[0];
  int16x8_t v18 = a7 + 1;
  *a8 = v11.i32[0];
  int16x8_t v19 = a8 + 1;
  int v20 = a5 & 7;
  if ((a5 & 7) != 0)
  {
    do
    {
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      v9.i8[0] = *v13;
      v10.i8[0] = v13[1];
      v11.i8[0] = v13[2];
      v13 += 3;
      --v20;
    }
    while (v20);
    int v21 = a5 & 7;
    int v22 = 8 - v21;
    unsigned int v23 = (v21 + 1) >> 1;
    int16x8_t v24 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v9.i8, 7uLL);
    int16x8_t v25 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v10.i8, 7uLL);
    int16x8_t v26 = (int16x8_t)vshll_n_u8(*(uint8x8_t *)v11.i8, 7uLL);
    *(int8x8_t *)v9.i8 = vqrshrun_n_s16(vaddq_s16(vaddq_s16(vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 0), vqrdmulhq_lane_s16(v25, *(int16x4_t *)a1.i8, 1)), vqrdmulhq_lane_s16(v26, *(int16x4_t *)a1.i8, 2)), 7uLL);
    *(int8x8_t *)v10.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(v12, vqrdmulhq_lane_s16(v24, *(int16x4_t *)a1.i8, 3)), vqrdmulhq_laneq_s16(v25, a1, 4)), vrshrq_n_s16(v26, 1uLL)), 7uLL);
    *(int8x8_t *)v11.i8 = vqrshrun_n_s16(vaddq_s16(vsubq_s16(vsubq_s16(vrshrq_n_s16(v24, 1uLL), vqrdmulhq_laneq_s16(v25, a1, 5)), vqrdmulhq_laneq_s16(v26, a1, 6)), v12), 7uLL);
    do
    {
      int64x2_t v9 = vsliq_n_s64(v9, v9, 8uLL);
      int64x2_t v10 = vsliq_n_s64(v10, v10, 8uLL);
      int64x2_t v11 = vsliq_n_s64(v11, v11, 8uLL);
      --v22;
    }
    while (v22);
    *(uint8x8_t *)v10.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v10.i8, *(int8x8_t *)v10.i8));
    *(uint8x8_t *)v11.i8 = vrhadd_u8((uint8x8_t)vuzp1_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8), (uint8x8_t)vuzp2_s8(*(int8x8_t *)v11.i8, *(int8x8_t *)v11.i8));
    do
    {
      *v17++ = v9.i8[7];
      int64x2_t v9 = vshlq_n_s64(v9, 8uLL);
      --v21;
    }
    while (v21);
    do
    {
      *v18++ = v10.i8[3];
      *v19++ = v11.i8[3];
      int64x2_t v10 = vshlq_n_s64(v10, 8uLL);
      int64x2_t v11 = vshlq_n_s64(v11, 8uLL);
      --v23;
    }
    while (v23);
  }
  uint64_t result = (a6 - a5);
  if (a6 != a5)
  {
    unsigned int v28 = result >> 1;
    char v29 = *(v17 - 1);
    char v30 = *(v18 - 1);
    char v31 = *(v19 - 1);
    do
    {
      *v17++ = v29;
      uint64_t result = (result - 1);
    }
    while (result);
    for (; v28; --v28)
    {
      *v18++ = v30;
      *v19++ = v31;
    }
  }
  return result;
}

uint64_t aj_mcu_pack(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)a3;
  uint64_t result = aj_find_and_handle_markers((int **)a2, (uint64_t *)a3, 0);
  if (!result)
  {
    uint64_t result = process_blocks(a1, (int *)a3, *(_DWORD *)(*(void *)(a2 + 8) + 88), **(_DWORD **)a2, *(_DWORD *)(a2 + 196), *(_DWORD *)(a2 + 192), v6, 0);
    if (!result)
    {
      int32x2_t v8 = vadd_s32(*(int32x2_t *)(a3 + 28), (int32x2_t)0x100000001);
      *(int32x2_t *)(a3 + 28) = v8;
      uint64_t result = 0;
      if (v8.i32[0] >= *(_DWORD *)(*(void *)(a2 + 8) + 80)) {
        *(void *)(a3 + 24) = (*(_DWORD *)(a3 + 24) + 1);
      }
    }
  }
  return result;
}

uint64_t process_blocks(uint64_t *a1, int *a2, int a3, int a4, int a5, int a6, uint64_t a7, int32x2_t *a8)
{
  int v13 = a2[6];
  uint64_t v14 = a2[7];
  int v15 = (a5 - 1) * a6;
  uint64_t v16 = *a1 + 66 * (int)v14 * a3 + 66 * v15;
  a1[8] = v16;
  int16x8_t v17 = a1 + 8;
  int16x8_t v18 = a1 + 11238;
  int16x8_t v19 = a1 + 5622;
  uint64_t v20 = a1[4];
  uint64_t v21 = a1[3] + 66 * (int)v14 * a3;
  a1[6] = v21;
  int v22 = a1 + 6;
  uint64_t v23 = v20 + 66 * v14;
  uint64_t v24 = a1[5];
  uint64_t v26 = a1[1];
  uint64_t v25 = a1[2];
  uint64_t v27 = v26 + 66 * v14;
  v19[2] = v27;
  uint64_t v28 = v25 + 66 * v14;
  *(v17 - 1) = v21 + 66 * ~v15;
  v18[2] = v28;
  uint64_t v29 = v24 + 66 * v14;
  uint64_t *v19 = v23;
  v19[1] = v23 - 66;
  uint64_t *v18 = v29;
  v18[1] = v29 - 66;
  v17[1] = v16 + 66 * ~v15;
  void v19[3] = v27 - 66;
  v18[3] = v28 - 66;
  if (!v14)
  {
    a1[7] = 0;
    v19[1] = 0;
    v18[1] = 0;
    a1[9] = 0;
    void v19[3] = 0;
    v18[3] = 0;
  }
  uint64_t v40 = v18;
  uint64_t v41 = v19;
  if (!v13)
  {
    uint64_t *v17 = 0;
    v17[1] = 0;
    v19[2] = 0;
    void v19[3] = 0;
    v18[2] = 0;
    v18[3] = 0;
  }
  if (a5 >= 1)
  {
    int v30 = 0;
    int v46 = v14 * a3;
    int v44 = v14;
    int v45 = ~v15;
    char v31 = a2 + 2;
    do
    {
      if (a6 >= 1)
      {
        int v32 = a6;
        do
        {
          if (a7)
          {
            aj_block_pack(v22, a7, v31);
          }
          else
          {
            uint64_t result = aj_block_unpack(v22, a8, v31);
            if (result) {
              return result;
            }
          }
          if (a6 <= 1)
          {
            uint64_t v35 = *v22;
          }
          else
          {
            uint64_t v34 = *v17;
            if (*v17)
            {
              a1[8] = v34 + 66;
              a1[9] = v34;
            }
            uint64_t v35 = a1[6];
            a1[7] = v35;
          }
          uint64_t v21 = v35 + 66;
          uint64_t *v22 = v21;
          --v32;
        }
        while (v32);
        LODWORD(v14) = v44;
      }
      uint64_t v36 = v21 - 66 * a6;
      uint64_t *v17 = v36;
      if ((int)v14 < 1)
      {
        uint64_t v37 = 0;
        uint64_t v38 = 0;
      }
      else
      {
        uint64_t v37 = a1[3] + 66 * v46 - 66;
        uint64_t v38 = v36 + 66 * v45;
      }
      a1[7] = v37;
      a1[9] = v38;
      ++v30;
    }
    while (v30 != a5);
  }
  if (a4 != 3) {
    return 0;
  }
  int v39 = a2 + 3;
  if (a7)
  {
    aj_block_pack(v41, a7, v39);
    aj_block_pack(v40, a7, a2 + 4);
    return 0;
  }
  uint64_t result = aj_block_unpack(v41, a8, v39);
  if (!result)
  {
    uint64_t result = aj_block_unpack(v40, a8, a2 + 4);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t aj_mcu_unpack(uint64_t *a1, uint64_t a2, int32x2_t *a3)
{
  uint64_t v6 = (int ***)(a1 + 17718);
  int64x2_t v7 = (_DWORD *)a1[17718];
  int32x2_t v8 = *(int **)v7;
  int v9 = *(_DWORD *)(*(void *)v7 + 32);
  int v10 = *(_DWORD *)(*(void *)v7 + 16);
  int v11 = v7[22];
  int v12 = *(_DWORD *)(*(void *)v7 + 3404);
  if (v12 && *(_DWORD *)(a2 + 32) == v12)
  {
    int v13 = (*(_DWORD *)(a2 + 36) + 1) & 7;
    *(_DWORD *)(a2 + 36) = v13;
    uint64_t result = aj_ostream_write_bytes((uint64_t)a3, v13 | 0xFFD0u, 2);
    if (result) {
      return result;
    }
    *(_DWORD *)(a2 + 32) = 0;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    int32x2_t v8 = **v6;
  }
  uint64_t result = process_blocks(a1, (int *)a2, v11, *v8, v9, v10, 0, a3);
  if (!result)
  {
    int32x2_t v15 = vadd_s32(*(int32x2_t *)(a2 + 28), (int32x2_t)0x100000001);
    *(int32x2_t *)(a2 + 28) = v15;
    uint64_t result = 0;
    if (v15.i32[0] >= *((_DWORD *)*v6 + 20)) {
      *(void *)(a2 + 24) = (*(_DWORD *)(a2 + 24) + 1);
    }
  }
  return result;
}

uint8x8_t **aj_icol_row_444_to_rgb565(uint8x8_t **result, uint8x8_t **a2, uint8x8_t **a3, char *a4, double a5, double a6, uint64x2_t a7, uint64x2_t a8, uint64_t a9, uint64_t a10, unsigned int a11)
{
  uint8x8_t v11 = (uint8x8_t)vdupq_n_s8(0x80u).u64[0];
  int v12 = *result;
  int v13 = *a2;
  uint64_t v14 = *a3;
  for (unsigned int i = a11 >> 3; i; --i)
  {
    uint8x8_t v16 = *v12++;
    uint8x8_t v17 = *v13++;
    uint8x8_t v18 = *v14++;
    int16x8_t v19 = (int16x8_t)vshll_n_u8(v16, 7uLL);
    int16x8_t v20 = (int16x8_t)vsubl_u8(v17, v11);
    int16x8_t v21 = (int16x8_t)vsubl_u8(v18, v11);
    int8x8_t v22 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v19, vqaddq_s16(vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v21, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    v28.val[0] = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_n_s16(v21, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v22, 5uLL));
    v28.val[1] = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v22, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v19, vmulq_lane_s16(v20, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    vst2_s8(a4, v28);
    a4 += 16;
  }
  if ((a11 & 7) != 0)
  {
    int16x8_t v23 = (int16x8_t)vshll_n_u8(*v12, 7uLL);
    int16x8_t v24 = (int16x8_t)vsubl_u8(*v13, v11);
    int16x8_t v25 = (int16x8_t)vsubl_u8(*v14, v11);
    int8x8_t v26 = (int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqsubq_s16(v23, vqaddq_s16(vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 1), vmulq_lane_s16(v25, (int16x4_t)0xE3005B002C00B3, 2))), 7uLL), (uint8x8_t)0x202020202020202), 2uLL);
    *(int8x8_t *)a7.i8 = vorr_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_n_s16(v25, 179)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), vshl_n_s8(v26, 5uLL));
    *(int8x8_t *)a8.i8 = vorr_s8((int8x8_t)vshr_n_u8((uint8x8_t)v26, 3uLL), vshl_n_s8((int8x8_t)vshr_n_u8(vqadd_u8((uint8x8_t)vqrshrun_n_s16(vqaddq_s16(v23, vmulq_lane_s16(v24, (int16x4_t)0xE3005B002C00B3, 3)), 7uLL), (uint8x8_t)0x404040404040404), 3uLL), 3uLL));
    int v27 = a11 & 7;
    do
    {
      *a4 = a7.i8[0];
      a4[1] = a8.i8[0];
      a4 += 2;
      a7 = vshrq_n_u64(a7, 8uLL);
      a8 = vshrq_n_u64(a8, 8uLL);
      --v27;
    }
    while (v27);
  }
  return result;
}

_OWORD *applejpeg_encode_create(long long *a1)
{
  if (a1 && *(void *)a1 && *((void *)a1 + 1))
  {
    unsigned int v2 = (char *)(*(uint64_t (**)(uint64_t, void))a1)(26736, *((void *)a1 + 2));
    int v3 = v2;
    if (v2)
    {
      uint64_t v4 = v2 + 19920;
      bzero(v2, 0x6870uLL);
      bzero(v3, 0x6870uLL);
      long long v5 = *a1;
      *((void *)v3 + 2) = *((void *)a1 + 2);
      _OWORD *v3 = v5;
      *((void *)v3 + 3333) = v3;
      *((void *)v3 + 2488) = 0x100000001;
      *((void *)v3 + 2489) = 0;
      *uint64_t v4 = 95;
      *(_OWORD *)((char *)v3 + 19928) = 0u;
      *(_OWORD *)((char *)v3 + 19944) = 0u;
      *((void *)v3 + 2495) = 3;
      *((_DWORD *)v3 + 4992) = 0;
      *((void *)v3 + 2497) = 0;
      *((_DWORD *)v3 + 4996) = 0;
      *((void *)v3 + 2499) = 0;
      *((_DWORD *)v3 + 5000) = 0;
      *((_DWORD *)v3 + 5007) = 0;
      *((_DWORD *)v3 + 5008) = 0;
      *((void *)v3 + 2505) = 0;
      *((_DWORD *)v3 + 5012) = 0;
      *((void *)v3 + 2507) = 0;
      *((_DWORD *)v3 + 5016) = 0;
      *((void *)v3 + 2502) = 0;
      *((void *)v3 + 2501) = 0;
      *(_DWORD *)((char *)v3 + 20023) = 0;
    }
    else
    {
      aj_log_error((uint64_t)"Encode", "Could not allocate memory for session");
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Memory manager cannot be NULL");
    return 0;
  }
  return v3;
}

double applejpeg_encode_options_init(uint64_t a1)
{
  *(void *)a1 = 0x100000001;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = 95;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)&double result = 3;
  *(void *)(a1 + 56) = 3;
  *(_DWORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  return result;
}

uint64_t applejpeg_encode_set_options_mem(uint64_t a1, _OWORD *a2, uint64_t a3, uint64_t a4)
{
  if (!a1 || !a2 || !a3 || !a4)
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(void *)(a4 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Encode", "Memory output buffer may not be larger than %d");
    return 8;
  }
  memset(&v8[7], 0, 56);
  long long v5 = a2[5];
  v8[4] = a2[4];
  v8[5] = v5;
  v8[6] = a2[6];
  long long v6 = a2[1];
  v8[0] = *a2;
  v8[1] = v6;
  long long v7 = a2[3];
  v8[2] = a2[2];
  v8[3] = v7;
  return encode_set_options(a1, (uint64_t)v8, a3, (_OWORD *)a4, 0);
}

uint64_t encode_set_options(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4, long long *a5)
{
  uint64_t v10 = a1 + 20072;
  *(_DWORD *)(a1 + 26656) = 0;
  uint64_t v11 = encode_check_options(a2, a3);
  if (!v11)
  {
    if (a3)
    {
      if (*(int *)a3 < 1 || (int v12 = *(_DWORD *)(a3 + 4), v12 < 1))
      {
        uint64_t v11 = 8;
        aj_log_error((uint64_t)"Encode", "Width and height must be > 0");
      }
      else if ((v12 | *(_DWORD *)a3) >> 16)
      {
        uint64_t v11 = 8;
        aj_log_error((uint64_t)"Encode", "Width and height must be <= 0xFFFF");
      }
      else
      {
        unsigned int v13 = *(_DWORD *)(a3 + 8);
        if (v13 < 0x13 || v13 == 20)
        {
          *(void *)(a1 + 20408) = a1 + 22544;
          *(void *)(a1 + 20416) = 4096;
          if (a4)
          {
            *(_OWORD *)(a1 + 24) = *a4;
            *(void *)(a1 + 20384) = a1 + 24;
            *(void *)(a1 + 20360) = enc_mem_callback;
          }
          else
          {
            long long v15 = *a5;
            long long v16 = a5[1];
            long long v17 = a5[2];
            *(void *)(a1 + 20400) = *((void *)a5 + 6);
            *(_OWORD *)(a1 + 20384) = v17;
            *(_OWORD *)(a1 + 20368) = v16;
            *(_OWORD *)(a1 + 20352) = v15;
          }
          long long v18 = *(_OWORD *)a2;
          long long v19 = *(_OWORD *)(a2 + 32);
          *(_OWORD *)(v10 + 16) = *(_OWORD *)(a2 + 16);
          *(_OWORD *)(v10 + 32) = v19;
          *(_OWORD *)uint64_t v10 = v18;
          long long v20 = *(_OWORD *)(a2 + 48);
          long long v21 = *(_OWORD *)(a2 + 64);
          long long v22 = *(_OWORD *)(a2 + 96);
          *(_OWORD *)(v10 + 80) = *(_OWORD *)(a2 + 80);
          *(_OWORD *)(v10 + 96) = v22;
          *(_OWORD *)(v10 + 48) = v20;
          *(_OWORD *)(v10 + 64) = v21;
          long long v23 = *(_OWORD *)(a2 + 112);
          long long v24 = *(_OWORD *)(a2 + 128);
          long long v25 = *(_OWORD *)(a2 + 144);
          *(void *)(v10 + 160) = *(void *)(a2 + 160);
          *(_OWORD *)(v10 + 128) = v24;
          *(_OWORD *)(v10 + 144) = v25;
          *(_OWORD *)(v10 + 112) = v23;
          long long v26 = *(_OWORD *)a3;
          long long v27 = *(_OWORD *)(a3 + 16);
          *(_OWORD *)(a1 + 20272) = *(_OWORD *)(a3 + 32);
          *(_OWORD *)(a1 + 20256) = v27;
          *(_OWORD *)(a1 + 20240) = v26;
          long long v28 = *(_OWORD *)(a3 + 48);
          long long v29 = *(_OWORD *)(a3 + 64);
          long long v30 = *(_OWORD *)(a3 + 80);
          *(_OWORD *)(a1 + 20336) = *(_OWORD *)(a3 + 96);
          *(_OWORD *)(a1 + 20320) = v30;
          *(_OWORD *)(a1 + 20304) = v29;
          *(_OWORD *)(a1 + 20288) = v28;
          if (*(int *)v10 >= 17) {
            *(_DWORD *)uint64_t v10 = 16;
          }
          uint64_t v11 = aj_encode_init((uint64_t *)(a1 + 26664), a1 + 48, a1 + 20432, (int *)(a1 + 20240), v10, a1 + 20352, (uint64_t *)(a1 + 20408));
          if (!v11) {
            *(_DWORD *)(v10 + 6584) = 1;
          }
        }
        else
        {
          uint64_t v11 = 3;
          aj_log_error((uint64_t)"Encode", "Unsupported format");
        }
      }
    }
    else
    {
      uint64_t v11 = 8;
      aj_log_error((uint64_t)"Encode", "Bitmap info struct cannot be NULL");
    }
  }
  return v11;
}

uint64_t applejpeg_encode_set_options_file(uint64_t a1, _OWORD *a2, uint64_t a3, long long *a4)
{
  if (a1 && a2 && a3 && a4)
  {
    memset(&v8[7], 0, 56);
    long long v4 = a2[5];
    v8[4] = a2[4];
    v8[5] = v4;
    v8[6] = a2[6];
    long long v5 = a2[1];
    v8[0] = *a2;
    v8[1] = v5;
    long long v6 = a2[3];
    v8[2] = a2[2];
    v8[3] = v6;
    return encode_set_options(a1, (uint64_t)v8, a3, 0, a4);
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_num_threads(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19904);
    if (v3[1688])
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      _DWORD *v3 = a3;
      return encode_check_options((uint64_t)v3, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t encode_check_options(uint64_t a1, uint64_t a2)
{
  if (!a1)
  {
    aj_log_error((uint64_t)"Encode", "Option pointer is NULL");
    return 8;
  }
  if (*(int *)a1 <= 0)
  {
    aj_log_error((uint64_t)"Encode", "Number of threads cannot be zero or smaller.");
  }
  else if (*(void *)(a1 + 8) >> 31)
  {
    aj_log_error((uint64_t)"Encode", "max_filesize must be less than %d");
  }
  else
  {
    unsigned int v4 = *(_DWORD *)(a1 + 16);
    if (v4 < 0x65)
    {
      if (*(unsigned __int8 *)(a1 + 122) < 8u)
      {
        int v5 = *(_DWORD *)(a1 + 124);
        if (v5 && v5 < *(_DWORD *)(a2 + 4))
        {
          aj_log_error((uint64_t)"Encode", "Strip encoding height override must be 0 or larger/equal to input height");
        }
        else
        {
          int v6 = *(_DWORD *)(a1 + 128);
          if (*(unsigned char *)(a1 + 120))
          {
            if (v6)
            {
              aj_log_error((uint64_t)"Encode", "Can't both skip all headers and insert custom header segment");
              return 5;
            }
          }
          else if (v6)
          {
            if (!*(void *)(a1 + 136))
            {
              aj_log_error((uint64_t)"Encode", "Can't have NULL for inserted segment data");
              return 5;
            }
            if (*(_DWORD *)(a1 + 80))
            {
              aj_log_error((uint64_t)"Encode", "Can't skip App0 segment if inserting custom segment");
              return 5;
            }
          }
          unsigned int v7 = *(_DWORD *)(a1 + 144);
          if (!v7) {
            goto LABEL_29;
          }
          if (!*(void *)(a1 + 152))
          {
            aj_log_error((uint64_t)"Encode", "Can't have NULL for RST offset table");
            return 5;
          }
          if (*(_DWORD *)(a1 + 4) != 1)
          {
            aj_log_error((uint64_t)"Encode", "Can't have marker offset table unless restart marker interval is set to sparse");
            return 5;
          }
          int v8 = (*(_DWORD *)(a1 + 56) & 0xFFFFFFFE) == 2 ? 16 : 8;
          if (v7 < (*(_DWORD *)(a2 + 4) + v8 - 1) / v8 - 1)
          {
            aj_log_error((uint64_t)"Encode", "Restart marker offset table size does not match number of restart markers");
          }
          else
          {
LABEL_29:
            unsigned int v9 = *(_DWORD *)(a2 + 8);
            if (v9 == 15)
            {
              int v10 = 4;
            }
            else
            {
              unsigned int v11 = *(_DWORD *)(a1 + 56);
              if (v11 >= 5)
              {
                aj_log_error((uint64_t)"Encode", "Unsupported subsampling");
                return 5;
              }
              if (v11 == 4) {
                int v10 = 1;
              }
              else {
                int v10 = 3;
              }
            }
            if (!v4)
            {
              uint64_t v16 = 0;
              while (2)
              {
                uint64_t v17 = *(void *)(a1 + 8 * v16 + 24);
                if (!v17)
                {
                  aj_log_error((uint64_t)"Encode", "Component %d is missing custom quantization table");
                  return 5;
                }
                for (uint64_t i = 0; i != 64; ++i)
                {
                  if (!*(unsigned char *)(v17 + i))
                  {
                    aj_log_error((uint64_t)"Encode", "Quantization value %d in table %d is 0 which is not allowed");
                    return 5;
                  }
                }
                if (++v16 != v10) {
                  continue;
                }
                break;
              }
            }
            int v12 = *(_DWORD *)(a1 + 96);
            if (v12 < 0)
            {
              aj_log_error((uint64_t)"Encode", "Negative callback interval");
            }
            else if (v12 && !*(void *)(a1 + 88))
            {
              aj_log_error((uint64_t)"Encode", "Callback interval specified, but no callback function");
            }
            else
            {
              if (*(_DWORD *)(a1 + 4) < 3u)
              {
                int v13 = *(_DWORD *)(a1 + 60);
                if (v13 == 2)
                {
                  int v19 = *(_DWORD *)(a1 + 56);
                  if (v19)
                  {
                    if (v19 != 4)
                    {
                      aj_log_error((uint64_t)"Encode", "Unsupported: LLJPEG can only take GRAY or RGB");
                      return 5;
                    }
                    if (v9 != 5 && v9 != 18)
                    {
                      aj_log_error((uint64_t)"Encode", "Unsupported LLJPEG: GRAY to GRAY please");
                      return 5;
                    }
                  }
                  else if (v9 > 0x14 || ((1 << v9) & 0x130019) == 0)
                  {
                    aj_log_error((uint64_t)"Encode", "Unsupported LLJPEG: RGB to RGB please");
                    return 5;
                  }
                  int v20 = *(_DWORD *)(a1 + 112);
                  if (v20)
                  {
                    if (v20 <= 7)
                    {
                      aj_log_error((uint64_t)"Encode", "Bitdepth must be >= 8");
                      return 5;
                    }
                    if (((1 << v9) & 0x170000) != 0)
                    {
                      int v21 = *(_DWORD *)(a1 + 116);
                      if (v21 < 0)
                      {
                        aj_log_error((uint64_t)"Encode", "Downshift can't be <0 if input is 16 bit");
                        return 5;
                      }
                      if ((v21 + v20) >= 0x11)
                      {
                        aj_log_error((uint64_t)"Encode", "Bitdepth plus Downshift can't be >16 if input is 16 bit");
                        return 5;
                      }
                    }
                    else
                    {
                      if (*(_DWORD *)(a1 + 116))
                      {
                        aj_log_error((uint64_t)"Encode", "Downshift must be 0 if input is 8 bit");
                        return 5;
                      }
                      if (v20 >= 9)
                      {
                        aj_log_error((uint64_t)"Encode", "Bitdepth can't be >8 if input is 8 bit");
                        return 5;
                      }
                    }
                  }
                }
                else if (v13 == 1)
                {
                  uint64_t v14 = *(unsigned int **)(a1 + 72);
                  if (v14)
                  {
                    int v15 = *(_DWORD *)(a1 + 64);
                    if (v15 <= v10 || v15 > 896 * v10)
                    {
                      aj_log_error((uint64_t)"Encode", "Illegal number of progressive scans for a %d component JPEG: %d");
                      return 5;
                    }
                    uint64_t result = verify_pscan_setup(v14, v15, v10);
                    if (result) {
                      return result;
                    }
                    unsigned int v9 = *(_DWORD *)(a2 + 8);
                  }
                }
                if (v9 != 18 || *(_DWORD *)(a1 + 60) == 2) {
                  return 0;
                }
                aj_log_error((uint64_t)"Encode", "Unsupported: 16 bit gray is only for lossless jpeg");
                return 5;
              }
              aj_log_error((uint64_t)"Encode", "Illegal restart marker setting");
            }
          }
        }
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "restart_marker_offset must be >=0 and <8");
      }
    }
    else
    {
      aj_log_error((uint64_t)"Encode", "Unsupported quality setting");
    }
  }
  return 5;
}

uint64_t applejpeg_encode_set_option_restart_markers(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19908);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v5 = a1 + 19904;
      _DWORD *v3 = a3;
      return encode_check_options(v5, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_max_filesize(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(void *)(a1 + 19912) = a3;
      uint64_t v4 = a1 + 19904;
      return encode_check_options(v4, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_quality(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19920);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v5 = a1 + 19904;
      _DWORD *v3 = a3;
      return encode_check_options(v5, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_q_tables(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
  if (*(_DWORD *)(a1 + 26656))
  {
    aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
    return 5;
  }
  if (!a3 || a3 >= 5)
  {
    aj_log_error((uint64_t)"Encode", "Invalid num_tables");
    return 8;
  }
  *(_DWORD *)(a1 + 19920) = 0;
  if (a3 >= 1)
  {
    uint64_t v7 = a3;
    int v8 = (void *)(a1 + 19928);
    do
    {
      if (!*a4)
      {
        aj_log_error((uint64_t)"Encode", "Table may not be NULL");
        return 8;
      }
      *v8++ = *a4++;
      --v7;
    }
    while (v7);
    if (a3 > 3) {
      goto LABEL_15;
    }
  }
  bzero((void *)(a1 + 8 * a3 + 19928), 8 * (3 - a3) + 8);
LABEL_15:
  return encode_check_options(a1 + 19904, a2);
}

uint64_t applejpeg_encode_set_option_format(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19960);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v5 = a1 + 19904;
      _DWORD *v3 = a3;
      return encode_check_options(v5, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_baseline(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19960);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v5 = a1 + 19904;
      _DWORD *v3 = a3;
      v3[1] = 0;
      return encode_check_options(v5, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_progressive(uint64_t a1, uint64_t a2, int a3, int a4, const void *a5)
{
  if (a1 && a2 && a4 && a5)
  {
    unsigned int v9 = (_DWORD *)(a1 + 19960);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v12 = *(void *)(a1 + 26648);
      if (v12)
      {
        (*(void (**)(uint64_t, void))(a1 + 8))(v12, *(void *)(a1 + 16));
        *(void *)(a1 + 26648) = 0;
        v9[1670] = 0;
      }
      int v13 = (void *)(*(uint64_t (**)(uint64_t, void))a1)(36 * a4, *(void *)(a1 + 16));
      *(void *)(a1 + 26720) = v13;
      *(void *)(a1 + 26648) = v13;
      if (v13 && (bzero(v13, 36 * a4), (uint64_t v14 = *(void **)(a1 + 26648)) != 0))
      {
        memcpy(v14, a5, 36 * a4);
        *unsigned int v9 = a3;
        v9[1] = 1;
        void v9[2] = a4;
        *(void *)(a1 + 19976) = *(void *)(a1 + 26648);
        return encode_check_options(a1 + 19904, a2);
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "Could not allocate scans");
        return 6;
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_type_lossless(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  if (a1 && a2)
  {
    uint64_t v5 = (_DWORD *)(a1 + 19960);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v7 = a1 + 19904;
      *uint64_t v5 = a3;
      v5[1] = 2;
      v5[14] = a4;
      v5[15] = a5;
      return encode_check_options(v7, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_skip_app0_header(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    int v3 = (_DWORD *)(a1 + 19984);
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      uint64_t v5 = a1 + 19904;
      _DWORD *v3 = a3;
      return encode_check_options(v5, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (a1 && a2 && a3 && a4)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(void *)(a1 + 19992) = a3;
      *(_DWORD *)(a1 + 20000) = a4;
      *(void *)(a1 + 20008) = a5;
      uint64_t v6 = a1 + 19904;
      return encode_check_options(v6, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_strip_encode(uint64_t a1, uint64_t a2, char a3, char a4, char a5, int a6)
{
  if (a1 && a2)
  {
    uint64_t v6 = a1 + 20024;
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(unsigned char *)uint64_t v6 = a3;
      uint64_t v8 = a1 + 19904;
      *(unsigned char *)(v6 + 1) = a4;
      *(unsigned char *)(v6 + 2) = a5;
      *(_DWORD *)(v6 + 4) = a6;
      return encode_check_options(v8, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_insert_segment(uint64_t a1, uint64_t a2, int a3, uint64_t a4, void *a5)
{
  if (a1 && a2 && a5)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 20032) = a3;
      *(void *)(a1 + 20040) = a4;
      *a5 = 20;
      uint64_t v6 = a1 + 19904;
      return encode_check_options(v6, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

uint64_t applejpeg_encode_set_option_record_rst_offsets(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  if (a1 && a2)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
      return 5;
    }
    else
    {
      *(_DWORD *)(a1 + 20048) = a3;
      *(void *)(a1 + 20056) = a4;
      *(_DWORD *)(a1 + 20064) = a5;
      uint64_t v6 = a1 + 19904;
      return encode_check_options(v6, a2);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
    return 8;
  }
}

double applejpeg_encode_reset_options(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Cannot modify options after committing them");
    }
    else
    {
      *(void *)(a1 + 20072) = 0x100000001;
      *(_DWORD *)(a1 + 20088) = 95;
      *(_OWORD *)(a1 + 20096) = 0u;
      *(_OWORD *)(a1 + 20112) = 0u;
      *(void *)&double result = 3;
      *(void *)(a1 + 20080) = 0;
      *(void *)(a1 + 20128) = 3;
      *(_DWORD *)(a1 + 20136) = 0;
      *(void *)(a1 + 20144) = 0;
      *(_DWORD *)(a1 + 20152) = 0;
      *(void *)(a1 + 20160) = 0;
      *(_DWORD *)(a1 + 20168) = 0;
      *(_DWORD *)(a1 + 20196) = 0;
      *(_DWORD *)(a1 + 20200) = 0;
      *(void *)(a1 + 20208) = 0;
      *(_DWORD *)(a1 + 20216) = 0;
      *(void *)(a1 + 20224) = 0;
      *(_DWORD *)(a1 + 20232) = 0;
      *(void *)(a1 + 20184) = 0;
      *(void *)(a1 + 20176) = 0;
      *(_DWORD *)(a1 + 20191) = 0;
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot take NULL arguments");
  }
  return result;
}

uint64_t applejpeg_encode_commit_options_for_mem(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  return encode_set_options(a1, a1 + 19904, a2, a3, 0);
}

uint64_t applejpeg_encode_commit_options_for_file(uint64_t a1, uint64_t a2, long long *a3)
{
  return encode_set_options(a1, a1 + 19904, a2, 0, a3);
}

uint64_t applejpeg_encode_image_row(uint64_t a1, unsigned int *a2, void *a3)
{
  BOOL v19 = 0;
  if (a1 && a2)
  {
    uint64_t v6 = check_input((_DWORD *)a1, a2, 0, &v19);
    if (!v6)
    {
      if (*(_DWORD *)(a1 + 26656))
      {
        uint64_t v8 = a2 + 11;
        int v7 = a2[11];
        if (v7 >= 16) {
          kdebug_trace();
        }
        if (*(_DWORD *)(a1 + 13408) == 14 && !*(_DWORD *)(a1 + 13312))
        {
          aj_log_error((uint64_t)"Encode", "Illegal settings for texture format.");
          return 3;
        }
        if (*(_DWORD *)(a1 + 20132) == 2)
        {
          aj_log_error((uint64_t)"Encode", "Row-wise compression for LOSSLESS is not implemented.");
          return 3;
        }
        if (*v8 + *(_DWORD *)(a1 + 13336) > *(_DWORD *)(a1 + 60))
        {
          aj_log_error((uint64_t)"Encode", "Image height is %d but %d rows have been passed in.");
          return 1;
        }
        if (*(void *)(a1 + 20080))
        {
          aj_log_error((uint64_t)"Encode", "Max filesize not supported for row-by-row encoding");
          return 1;
        }
        uint64_t v10 = a1 + 48;
        if (!*(_DWORD *)(a1 + 13316))
        {
          uint64_t v17 = aj_write_jpeg_headers((int *)(a1 + 48), a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), *(_DWORD *)(a1 + 22488), *(unsigned __int8 *)(a1 + 20152), *(unsigned int *)(a1 + 20200), *(char **)(a1 + 20208), 0);
          if (v17)
          {
            uint64_t v6 = v17;
            aj_log_error((uint64_t)"Encode", "Failed to write JPEG headers");
            return v6;
          }
          *(_DWORD *)(a1 + 13316) = 1;
        }
        BOOL v11 = v19;
        if (v19 && *(_DWORD *)(a1 + 13408) == 14) {
          uint64_t v8 = (_DWORD *)(a1 + 13476);
        }
        int v12 = *(_DWORD *)(a1 + 13324) + *v8;
        if (v12 >= *(_DWORD *)(a1 + 13340))
        {
          uint64_t v18 = a1 + 48;
          int v13 = 0;
          while (1)
          {
            setup_input((void *)(a1 + 20432), v18, (uint64_t)a2, v13);
            uint64_t v14 = aj_encode_row(v18, (void *)(a1 + 20432), *(_DWORD *)(a1 + 13336) >= (*(_DWORD *)(a1 + 13484) - 1) * *(_DWORD *)(a1 + 13476));
            if (v14) {
              break;
            }
            int v15 = *(_DWORD *)(a1 + 13340);
            if (*(_DWORD *)(a1 + 13324)) {
              int v16 = 1;
            }
            else {
              int v16 = *(_DWORD *)(a1 + 13340);
            }
            v13 += v16;
            *(_DWORD *)(a1 + 13336) += v15;
            *(_DWORD *)(a1 + 13324) = 0;
            v12 -= v15;
            if (v12 < v15)
            {
              BOOL v11 = v19;
              uint64_t v10 = a1 + 48;
              goto LABEL_34;
            }
          }
          uint64_t v6 = v14;
          aj_log_error((uint64_t)"Encode", "Failed to encode row");
        }
        else
        {
          int v13 = 0;
LABEL_34:
          if (v11)
          {
            if (v12 && *(_DWORD *)(a1 + 13408) != 14)
            {
              setup_input((void *)(a1 + 20432), v10, (uint64_t)a2, v13);
              *(_DWORD *)(a1 + 13324) = 1;
            }
            uint64_t v6 = aj_encode_row_close(v10, a1 + 20432);
            *(_DWORD *)(a1 + 13324) = 0;
            *(_DWORD *)(a1 + 26656) = 0;
          }
          else
          {
            if (v12)
            {
              setup_input((void *)(a1 + 20432), v10, (uint64_t)a2, v13);
              buffer_input_row(v10, a1 + 20432);
            }
            uint64_t v6 = 0;
          }
          if (v7 >= 16) {
            kdebug_trace();
          }
          *a3 = *(int *)(a1 + 22448);
        }
      }
      else
      {
        aj_log_error((uint64_t)"Encode", "Options not set");
        return 5;
      }
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  return v6;
}

uint64_t check_input(_DWORD *a1, unsigned int *a2, int a3, BOOL *a4)
{
  uint64_t v4 = a2[8];
  if ((v4 - 5) < 0xFFFFFFFC)
  {
    aj_log_error((uint64_t)"Encode", "Invalid number of planes: %d");
    return 8;
  }
  uint64_t v6 = 0;
  do
  {
    if (!*(void *)&a2[2 * v6])
    {
      aj_log_error((uint64_t)"Encode", "Plane pointer #%d is NULL");
      return 8;
    }
    ++v6;
  }
  while (v4 != v6);
  int v7 = a1[5062];
  if (v7 != a2[12])
  {
    aj_log_error((uint64_t)"Encode", "Format differs from what previously set");
    return 8;
  }
  if (a2[10] != a1[5060]) {
    goto LABEL_15;
  }
  int v8 = a2[11];
  if (a3)
  {
    int v9 = a2[11];
    if (v8 == a1[5061]) {
      goto LABEL_18;
    }
LABEL_15:
    aj_log_error((uint64_t)"Encode", "Invalid data dimensions");
    return 8;
  }
  if (v8 < 1) {
    goto LABEL_15;
  }
  int v9 = a1[5061];
  if (v8 > v9) {
    goto LABEL_15;
  }
LABEL_18:
  int v11 = a1[3334] + v8 + a1[3331];
  BOOL v12 = v11 >= v9;
  if ((v7 - 10) >= 4)
  {
    if (v7 == 14 && memcmp(a1 + 5064, a2 + 14, 0x40uLL))
    {
      aj_log_error((uint64_t)"Encode", "Texture info structs differ");
      return 8;
    }
  }
  else if ((v8 & 1) != 0 && v11 < v9)
  {
    aj_log_error((uint64_t)"Encode", "An even number of rows is required for vertically decimated input");
    return 8;
  }
  uint64_t result = 0;
  if (a4) {
    *a4 = v12;
  }
  return result;
}

void *setup_input(void *result, uint64_t a2, uint64_t a3, int a4)
{
  if (*(_DWORD *)(a3 + 48) == 14)
  {
    result[230] = *(void *)a3 + *(void *)(a2 + 19768) * a4 + *(void *)(a2 + 13392);
    if (*(_DWORD *)(a3 + 32) == 3)
    {
      result[232] = *(void *)(a3 + 8) + *(void *)(a2 + 19776) * a4 + *(void *)(a2 + 13400);
      uint64_t v4 = *(void *)(a3 + 16);
    }
    else
    {
      uint64_t v9 = *(void *)a3 + *(void *)(a2 + 13368);
      result[232] = v9 + *(void *)(a2 + 19776) * a4 + *(void *)(a2 + 13400);
      uint64_t v4 = v9 + *(void *)(a2 + 13376);
    }
    result[234] = v4 + *(void *)(a2 + 19784) * a4 + *(void *)(a2 + 13408);
    uint64_t v10 = 3;
  }
  else if (*(_DWORD *)(a2 + 19832))
  {
    int v5 = *(_DWORD *)(a3 + 44);
    int v6 = *(_DWORD *)(a2 + 19844);
    uint64_t v7 = *(void *)(a2 + 19768);
    result[230] = *(void *)a3 + v7 * a4;
    if (*(_DWORD *)(a3 + 32) == 2)
    {
      uint64_t v8 = *(void *)(a3 + 8);
    }
    else
    {
      int v11 = v5 & 1;
      if (v6 != 2) {
        int v11 = 0;
      }
      uint64_t v8 = *(void *)a3 + v7 * (v11 + v5);
    }
    result[232] = v8;
    result[232] = v8 + *(void *)(a2 + 19776) * (a4 >> (v6 - 1));
    uint64_t v10 = 2;
  }
  else
  {
    result[230] = *(void *)a3 + *(void *)(a2 + 19768) * a4;
    uint64_t v10 = 1;
  }
  if (*(_DWORD *)(a2 + 13276))
  {
    BOOL v12 = result + 237;
    int v13 = result + 229;
    do
    {
      uint64_t v14 = *v12++;
      *int v13 = v14;
      v13 += 2;
      --v10;
    }
    while (v10);
  }
  else
  {
    int v15 = result + 230;
    int v16 = (uint64_t *)(a2 + 19768);
    do
    {
      uint64_t v17 = *v15;
      *(v15 - 1) = *v15;
      uint64_t v18 = *v16++;
      *int v15 = v17 + v18;
      v15 += 2;
      --v10;
    }
    while (v10);
  }
  return result;
}

void *buffer_input_row(uint64_t a1, uint64_t a2)
{
  uint64_t result = memcpy(*(void **)(a2 + 1896), *(const void **)(a2 + 1832), *(void *)(a1 + 19768));
  if (*(_DWORD *)(a1 + 19832)) {
    uint64_t result = memcpy(*(void **)(a2 + 1904), *(const void **)(a2 + 1848), *(void *)(a1 + 19776));
  }
  *(_DWORD *)(a1 + 13276) = 1;
  return result;
}

uint64_t applejpeg_encode_image_all(uint64_t a1, unsigned int *a2, void *a3)
{
  if (!a1 || !a2)
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  uint64_t v6 = check_input((_DWORD *)a1, a2, 1, 0);
  if (!v6)
  {
    if (!*(_DWORD *)(a1 + 26656))
    {
      aj_log_error((uint64_t)"Encode", "Options not set");
      return 5;
    }
    kdebug_trace();
    if (*(_DWORD *)(a1 + 19852))
    {
      setup_input((void *)(a1 + 20432), a1 + 48, (uint64_t)a2, 0);
      uint64_t v7 = do_encode_lossless(a1);
LABEL_7:
      uint64_t v6 = v7;
LABEL_8:
      *a3 = *(int *)(a1 + 22448);
      *(_DWORD *)(a1 + 26656) = 0;
      kdebug_trace();
      return v6;
    }
    uint64_t v9 = *(void *)(a1 + 20080);
    if (!v9)
    {
      uint64_t v7 = do_encode(a1, (uint64_t)a2);
      goto LABEL_7;
    }
    uint64_t v29 = *(void *)(a1 + 22424);
    long long v27 = *(_OWORD *)(a1 + 22392);
    long long v28 = *(_OWORD *)(a1 + 22408);
    long long v25 = *(_OWORD *)(a1 + 22360);
    long long v26 = *(_OWORD *)(a1 + 22376);
    *(void *)(a1 + 22400) = dummy_callback2;
    *(void *)(a1 + 20080) = 0;
    uint64_t v24 = a1 + 20072;
    aj_encode_reset_session((int *)(a1 + 48), a1 + 20432, a1 + 20072);
    uint64_t v6 = do_encode(a1, (uint64_t)a2);
    if (v6) {
      return v6;
    }
    uint64_t v10 = a1 + 20072;
    int v11 = *(_DWORD *)(a1 + 22448);
    int v23 = v9;
    if (v11 < (int)v9)
    {
      uint64_t v13 = a1 + 22360;
      uint64_t v12 = a1 + 20432;
LABEL_17:
      if (v11 < v23)
      {
        aj_encode_reset_session((int *)(a1 + 48), v12, v10);
        *(_OWORD *)(v13 + 32) = v27;
        *(_OWORD *)(v13 + 48) = v28;
        *(void *)(v13 + 64) = v29;
        *(_OWORD *)uint64_t v13 = v25;
        *(_OWORD *)(v13 + 16) = v26;
        uint64_t v6 = do_encode(a1, (uint64_t)a2);
        if (v6) {
          return v6;
        }
        goto LABEL_8;
      }
      aj_log_error((uint64_t)"Encode", "Unable to produce smaller image", a1 + 22360);
      return 5;
    }
    int v14 = *(_DWORD *)(a1 + 20088);
    if (v14 >= 0) {
      int v15 = *(_DWORD *)(a1 + 20088);
    }
    else {
      int v15 = v14 + 1;
    }
    uint64_t v12 = a1 + 20432;
    if (v14 < 2)
    {
      int v16 = v15 >> 1;
LABEL_36:
      if (v11 < v23)
      {
        uint64_t v10 = a1 + 20072;
        uint64_t v13 = a1 + 22360;
      }
      else
      {
        uint64_t v10 = a1 + 20072;
        uint64_t v13 = a1 + 22360;
        if (v16 >= 2)
        {
          *(_DWORD *)(a1 + 20088) = v16 - 1;
          uint64_t v22 = v12;
          aj_encode_reset_session((int *)(a1 + 48), v12, v24);
          uint64_t v6 = do_encode(a1, (uint64_t)a2);
          if (v6) {
            return v6;
          }
          int v11 = *(_DWORD *)(a1 + 22448);
          uint64_t v12 = v22;
          uint64_t v10 = a1 + 20072;
          uint64_t v13 = a1 + 22360;
        }
      }
      goto LABEL_17;
    }
    int v17 = v14 - 1;
    int v18 = (int)v9 / 20;
    int v19 = 1;
    while (1)
    {
      int v20 = v19 + v17;
      if (v19 + v17 < 0 != __OFADD__(v19, v17)) {
        ++v20;
      }
      int v16 = v20 >> 1;
      *(_DWORD *)(a1 + 20088) = v20 >> 1;
      aj_encode_reset_session((int *)(a1 + 48), v12, v24);
      uint64_t v21 = do_encode(a1, (uint64_t)a2);
      if (v21) {
        return v21;
      }
      int v11 = *(_DWORD *)(a1 + 22448);
      if (v23 <= v11)
      {
        int v17 = v16 - 1;
        uint64_t v12 = a1 + 20432;
      }
      else
      {
        uint64_t v12 = a1 + 20432;
        if (v23 - v11 < v18) {
          goto LABEL_36;
        }
        int v19 = v16 + 1;
      }
      if (v19 > v17) {
        goto LABEL_36;
      }
    }
  }
  return v6;
}

uint64_t do_encode(uint64_t a1, uint64_t a2)
{
  int v3 = (int *)(a1 + 22488);
  uint64_t v4 = a1 + 20072;
  int v5 = (int *)(a1 + 48);
  uint64_t v6 = a1 + 20432;
  setup_input((void *)(a1 + 20432), a1 + 48, a2, 0);
  if (aj_allow_multithread_encode(v5, v6, *(_DWORD *)v4))
  {
    signed int v7 = *(_DWORD *)v4;
    int v8 = *(_DWORD *)(a1 + 13480);
    int v9 = *(_DWORD *)(a1 + 13484);
    signed int v10 = *(_DWORD *)v4;
    do
    {
      int v11 = v9 / v10;
      if (v9 % v10) {
        ++v11;
      }
      v10 *= 2;
    }
    while (v11 > 0xFFFF / v8);
    *(_DWORD *)(a1 + 19808) = v11;
    int v12 = *v3;
    if (*v3)
    {
      if (v12 == v8 * v11 || !(v8 % v12)) {
        goto LABEL_14;
      }
    }
    else
    {
      v8 *= v11;
    }
    int *v3 = v8;
    int v12 = v8;
LABEL_14:
    if (!*(unsigned char *)(v4 + 120))
    {
      uint64_t result = aj_write_jpeg_headers(v5, a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), v12, *(unsigned __int8 *)(v4 + 80), *(unsigned int *)(v4 + 128), *(char **)(a1 + 20208), *(_DWORD *)(v4 + 124));
      if (result) {
        return result;
      }
      *(_DWORD *)(v4 + 2380) = *(_DWORD *)(v4 + 2304);
      signed int v7 = *(_DWORD *)v4;
    }
    uint64_t result = aj_encode_all_mt((uint64_t)v5, v6, v7, a1);
    goto LABEL_16;
  }
  if (!*(unsigned char *)(v4 + 120))
  {
    uint64_t result = aj_write_jpeg_headers(v5, a1 + 22360, a1 + 3472, *(int **)(a1 + 19864), *v3, *(unsigned __int8 *)(v4 + 80), *(unsigned int *)(v4 + 128), *(char **)(a1 + 20208), *(_DWORD *)(v4 + 124));
    if (result) {
      return result;
    }
    *(_DWORD *)(v4 + 2380) = *(_DWORD *)(v4 + 2304);
  }
  uint64_t result = aj_encode_all((uint64_t)v5, v6, 217);
LABEL_16:
  if (result == 9)
  {
    if (*(uint64_t (**)(void *, int, uint64_t))(a1 + 22400) == enc_mem_callback) {
      aj_log_error((uint64_t)"Encode", "Output buffer too small");
    }
    uint64_t result = 9;
  }
  else if (!result)
  {
    uint64_t result = aj_ostream_flush_buffer(a1 + 22360);
  }
  *(_DWORD *)(v4 + 2376) = *(_DWORD *)(v4 + 2304);
  return result;
}

uint64_t dummy_callback2()
{
  return 0;
}

uint64_t applejpeg_encode_image_all_with_bitstream_offset(uint64_t a1, unsigned int *a2, void *a3, void *a4)
{
  if (a4)
  {
    uint64_t result = applejpeg_encode_image_all(a1, a2, a3);
    if (!result) {
      *a4 = *(int *)(a1 + 22452);
    }
  }
  else
  {
    aj_log_error((uint64_t)"Encode", "Cannot accept NULL arguments");
    return 8;
  }
  return result;
}

uint64_t applejpeg_encode_destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    long long v3 = *(_OWORD *)result;
    uint64_t v4 = *(void *)(result + 16);
    aj_encode_release_scan_buffers(result + 48, (uint64_t)&v3);
    unsigned int v2 = (void *)(v1 + 26680);
    do
    {
      if (*v2)
      {
        (*((void (**)(void, uint64_t))&v3 + 1))(*v2, v4);
        void *v2 = 0;
      }
      ++v2;
    }
    while ((unint64_t)v2 < v1 + 26728);
    return (*((uint64_t (**)(uint64_t, uint64_t))&v3 + 1))(v1, v4);
  }
  return result;
}

uint64_t enc_mem_callback(void *__src, int a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) < (unint64_t)a2) {
    return 1;
  }
  uint64_t v5 = a2;
  memcpy(*(void **)a3, __src, a2);
  uint64_t result = 0;
  uint64_t v6 = *(void *)(a3 + 8) - v5;
  *(void *)a3 += v5;
  *(void *)(a3 + 8) = v6;
  return result;
}

uint64_t verify_pscan_setup(unsigned int *a1, int a2, int a3)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    while (!aj_fill_coeffblock_from_scan_properties(a1, (uint64_t)&v10, a3))
    {
      a1 += 9;
      if (!--v5) {
        goto LABEL_5;
      }
    }
    goto LABEL_12;
  }
LABEL_5:
  if (a3 >= 1)
  {
    uint64_t v6 = 0;
    signed int v7 = &v10;
LABEL_7:
    uint64_t v8 = 0;
    while (*(__int16 *)((char *)v7 + v8) == -1)
    {
      v8 += 2;
      if (v8 == 128)
      {
        uint64_t result = 0;
        ++v6;
        v7 += 8;
        if (v6 != a3) {
          goto LABEL_7;
        }
        return result;
      }
    }
LABEL_12:
    aj_log_error((uint64_t)"Encode", "The progressive scan set-up is illegal or contains errors", v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      (void)v40);
    return 5;
  }
  return 0;
}

uint64_t aj_huffman_decode_ac_s1(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  a3[6] = 0;
  a3[7] = 0;
  a3[8] = 0;
  a3[9] = 0;
  a3[10] = 0;
  a3[11] = 0;
  a3[12] = 0;
  a3[13] = 0;
  a3[14] = 0;
  a3[15] = 0;
  LODWORD(v6) = 1;
  uint64_t v7 = a1 + 48;
  uint64_t v8 = *(void *)(a1 + 696);
  unsigned int v9 = *(_DWORD *)a2;
  unsigned int v10 = *(_DWORD *)(a2 + 28);
  uint64_t v11 = *(void *)(a1 + 40) + 400;
  int v12 = *(_DWORD *)(a2 + 24);
  uint64_t v13 = *(_DWORD *)a2 >> 23;
  uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
  do
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (v10)
          {
LABEL_42:
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            uint64_t v41 = v11;
            uint64_t v42 = (unsigned int *)a2;
            long long v39 = a3;
            long long v40 = a4;
            uint64_t v37 = a6;
            uint64_t v38 = v7;
            uint64_t v35 = v13;
            uint64_t v36 = v8;
            uint64_t result = aj_huffman_decode_val_slow(v11 - 400, (unsigned int *)a2, v6, 0, (int *)&v33);
            if (result) {
              return result;
            }
            LODWORD(v6) = v33;
            int v32 = (int)v33 >> 16;
            uint64_t v13 = v35;
            uint64_t v8 = v36;
            uint64_t v7 = v38;
            a3 = v39;
            a4 = v40;
            uint64_t v11 = v41;
            a2 = (uint64_t)v42;
            unsigned int v10 = v42[7];
            int v12 = v42[6];
            unsigned int v9 = *v42;
            goto LABEL_34;
          }
          int v15 = (int)v14 >> 18;
          unsigned int v16 = v6 + v14;
          if ((v14 & 0x20000) != 0) {
            break;
          }
          if (v15)
          {
            int v17 = *(_DWORD *)(v7 + 4 * v16) * v15 + 2048;
            a6 = *(unsigned int *)(v8 + 4 * v16);
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            uint64_t v13 = v9 >> 23;
            uint64_t v6 = v16 + 1;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            *(_WORD *)((char *)a3 + a6) = v17 >> 12;
            if (v12 < 0) {
              goto LABEL_17;
            }
LABEL_6:
            if ((int)v6 >= 64)
            {
              if ((int)v6 <= 64)
              {
                *(_DWORD *)a2 = v9;
                *(_DWORD *)(a2 + 24) = v12;
                *a4 = v6;
                return 0;
              }
              goto LABEL_48;
            }
          }
          else
          {
            if ((_BYTE)v14) {
              uint64_t v6 = v16 + 1;
            }
            else {
              uint64_t v6 = 64;
            }
            a6 = v14 >> 8;
            v12 -= BYTE1(v14);
            v9 <<= SBYTE1(v14);
            if (v12 < 0) {
              goto LABEL_17;
            }
            uint64_t v13 = v9 >> 23;
            uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
            if ((int)v6 >= 64)
            {
              if ((int)v6 <= 64)
              {
                *(_DWORD *)a2 = v9;
                *(_DWORD *)(a2 + 24) = v12;
                *a4 = v6;
                return 0;
              }
              goto LABEL_48;
            }
          }
        }
        LODWORD(v6) = v16 - v14;
        a6 = v14 & 0x10000;
        if ((v14 & 0x10000) != 0) {
          goto LABEL_42;
        }
        int v28 = BYTE1(v14);
        unsigned int v29 = v14 >> 18;
        v12 -= v28;
        v9 <<= v28;
        uint64_t v6 = v6 + (v29 >> 4);
        uint64_t v14 = v29 & 0xF;
        if (!v14) {
          goto LABEL_35;
        }
        if (v12 + 9 < (int)v14)
        {
          *(_DWORD *)(a2 + 24) = v12;
          *(_DWORD *)a2 = v9;
          uint64_t v41 = v11;
          uint64_t v42 = (unsigned int *)a2;
          long long v39 = a3;
          long long v40 = a4;
          uint64_t v37 = (v12 + 9);
          uint64_t v38 = v7;
          uint64_t v35 = v6;
          uint64_t v36 = v13;
          uint64_t v33 = v8;
          uint64_t v34 = v14;
          uint64_t result = aj_istream_fill_buf(a2, (int)v14 - 9);
          if (result) {
            return result;
          }
          uint64_t v8 = v33;
          LODWORD(v14) = v34;
          LODWORD(v6) = v35;
          uint64_t v13 = v36;
          uint64_t v7 = v38;
          a3 = v39;
          a4 = v40;
          uint64_t v11 = v41;
          a2 = (uint64_t)v42;
          unsigned int v10 = v42[7];
          int v12 = v42[6];
          unsigned int v9 = *v42;
        }
        v12 -= v14;
        signed int v30 = v9 >> (32 - v14);
        v9 <<= v14;
        int v31 = 1 << (v14 - 1);
        int v32 = v30 < v31 ? v30 + 1 - 2 * v31 : v30;
LABEL_34:
        uint64_t v14 = *(unsigned int *)(v7 + 4 * v6);
        a6 = *(unsigned int *)(v8 + 4 * v6);
        uint64_t v6 = (v6 + 1);
        *(_WORD *)((char *)a3 + a6) = ((int)v14 * v32 + 2048) >> 12;
LABEL_35:
        if (v12 < 0) {
          break;
        }
        uint64_t v13 = v9 >> 23;
        uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
        if ((int)v6 >= 64)
        {
          if ((int)v6 <= 64)
          {
            *(_DWORD *)a2 = v9;
            *(_DWORD *)(a2 + 24) = v12;
            *a4 = v6;
            return 0;
          }
          goto LABEL_48;
        }
      }
      if (v10) {
        goto LABEL_6;
      }
LABEL_17:
      a6 = *(unsigned int *)(a2 + 32);
      long long v19 = *(unsigned __int8 **)(a2 + 8);
      if ((int)a6 < 8) {
        break;
      }
      int v20 = *v19;
      int v21 = v19[1];
      BOOL v23 = v20 == 255;
      int v22 = v21 + (v20 << 8);
      BOOL v23 = v23 || v21 == 255;
      int v24 = v19[2];
      long long v25 = v19 + 3;
      a6 = (a6 - 3);
      uint64_t v14 = (v24 + (v22 << 8));
      if (v23 || v24 == 255) {
        break;
      }
      int v27 = ~v12;
      *(_DWORD *)(a2 + 32) = a6;
      *(void *)(a2 + 8) = v25;
      v9 |= v14 << v27;
      int v12 = 23 - v27;
      uint64_t v13 = v9 >> 23;
      uint64_t v14 = *(unsigned int *)(v11 + 4 * v13);
      if ((int)v6 >= 64)
      {
        if ((int)v6 <= 64)
        {
          *(_DWORD *)a2 = v9;
          *(_DWORD *)(a2 + 24) = v12;
          *a4 = v6;
          return 0;
        }
        goto LABEL_48;
      }
    }
    *(_DWORD *)a2 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    uint64_t v41 = v11;
    uint64_t v42 = (unsigned int *)a2;
    long long v39 = a3;
    long long v40 = a4;
    uint64_t v37 = a6;
    uint64_t v38 = v7;
    uint64_t v35 = v6;
    uint64_t v36 = v13;
    uint64_t v33 = v8;
    uint64_t v34 = v14;
    uint64_t result = aj_istream_fill_buf(a2, -9);
    if (result) {
      return result;
    }
    uint64_t v8 = v33;
    LODWORD(v6) = v35;
    a6 = v37;
    uint64_t v7 = v38;
    a3 = v39;
    a4 = v40;
    uint64_t v11 = v41;
    a2 = (uint64_t)v42;
    unsigned int v10 = v42[7];
    int v12 = v42[6];
    unsigned int v9 = *v42;
    uint64_t v13 = *v42 >> 23;
    uint64_t v14 = *(unsigned int *)(v41 + 4 * v13);
  }
  while ((int)v35 < 64);
  if ((int)v35 <= 64)
  {
    *uint64_t v42 = v9;
    *(_DWORD *)(a2 + 24) = v12;
    *a4 = v6;
    return 0;
  }
LABEL_48:
  *(_DWORD *)a2 = v9;
  *(_DWORD *)(a2 + 24) = v12;
  *a4 = v6;
  return 7;
}

void applejpeg_decode_create_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void applejpeg_decode_destroy_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void applejpeg_decode_build_index_cold_1()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_0();
  _os_log_debug_impl(&dword_2103CE000, v0, OS_LOG_TYPE_DEBUG, "[%p] Index-table finished with code %d", v1, 0x12u);
}

void applejpeg_decode_image_all_cold_1()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_2103CE000, v0, OS_LOG_TYPE_ERROR, "[%p] Decoding failed with error code %d", v1, 0x12u);
}

void applejpeg_decode_image_all_cold_2(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void applejpeg_decode_image_all_cold_3(uint64_t a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 134218240;
  uint64_t v3 = a1;
  __int16 v4 = 1024;
  int v5 = -1;
  _os_log_error_impl(&dword_2103CE000, a2, OS_LOG_TYPE_ERROR, "Warning! [%p] Decoding incomplete with error code %d. This is expected if the image has not been fully downloaded.", (uint8_t *)&v2, 0x12u);
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4300](allocator, capacity, callBacks);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x270EE47E0](allocator, capacity);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

void CFDataReplaceBytes(CFMutableDataRef theData, CFRange range, const UInt8 *newBytes, CFIndex newLength)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x270EE4CA0](key, applicationID);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x270EE51C8](str);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x270EE5430](url, resolveAgainstBase, buffer, maxBufLen);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x270EF4820](*(void *)&object);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF4A50](*(void *)&entry, plane, key, allocator, *(void *)&options);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x270EF4AB0](*(void *)&mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD0](name);
}

uint64_t IOSurfaceAcceleratorCreate()
{
  return MEMORY[0x270F3D448]();
}

uint64_t IOSurfaceAcceleratorTransformSurface()
{
  return MEMORY[0x270F3D468]();
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x270EF4C28](properties);
}

void *__cdecl IOSurfaceGetBaseAddressOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return (void *)MEMORY[0x270EF4C80](buffer, planeIndex);
}

size_t IOSurfaceGetBytesPerRowOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4CC0](buffer, planeIndex);
}

size_t IOSurfaceGetPlaneCount(IOSurfaceRef buffer)
{
  return MEMORY[0x270EF4D88](buffer);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E18](buffer, *(void *)&options, seed);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E88](buffer, *(void *)&options, seed);
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x270ED7E38]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

int access(const char *a1, int a2)
{
  return MEMORY[0x270ED8480](a1, *(void *)&a2);
}

void bzero(void *a1, size_t a2)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

int feof(FILE *a1)
{
  return MEMORY[0x270ED9910](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x270ED9918](a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9A28](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x270ED9AC0](a1, a2, *(void *)&a3);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x270ED9B18](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x270EDAEA0](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x270EDAF10](a1, a2);
}

long double sin(long double __x)
{
  MEMORY[0x270EDB4E8](__x);
  return result;
}

void vImageDestroyResamplingFilter(ResamplingFilter filter)
{
}

vImage_Error vImageHorizontalShear_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, float xTranslate, float shearSlope, ResamplingFilter filter, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF230](src, dest, srcOffsetToROI_X, srcOffsetToROI_Y, filter, backColor, *(void *)&flags, xTranslate, shearSlope);
}

ResamplingFilter vImageNewResamplingFilter(float scale, vImage_Flags flags)
{
  return (ResamplingFilter)MEMORY[0x270EDF248](*(void *)&flags, scale);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF328](src, dest, tempBuffer, *(void *)&flags);
}