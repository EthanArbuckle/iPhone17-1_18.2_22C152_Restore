long long *HyperParams.keyHeartRatePeriod10PctModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for keyHeartRatePeriod10PctModelName != -1) {
    swift_once();
  }
  return &static HyperParams.keyHeartRatePeriod10PctModelName;
}

uint64_t one-time initialization function for keyWTmpFwEndLstmModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("WTmpFwEndLstmModelName", 0x16uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyWTmpFwEndLstmModelName = (__int128)v1;
  return result;
}

long long *HyperParams.keyWTmpFwEndLstmModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for keyWTmpFwEndLstmModelName != -1) {
    swift_once();
  }
  return &static HyperParams.keyWTmpFwEndLstmModelName;
}

uint64_t one-time initialization function for keyWTmpFwEndRFModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("WTmpFwEndRFModelName", 0x14uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyWTmpFwEndRFModelName = (__int128)v1;
  return result;
}

long long *HyperParams.keyWTmpFwEndRFModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for keyWTmpFwEndRFModelName != -1) {
    swift_once();
  }
  return &static HyperParams.keyWTmpFwEndRFModelName;
}

uint64_t one-time initialization function for keyWTmpPeriodLstmModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("WTmpPeriodLstmModelName", 0x17uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyWTmpPeriodLstmModelName = (__int128)v1;
  return result;
}

long long *HyperParams.keyWTmpPeriodLstmModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for keyWTmpPeriodLstmModelName != -1) {
    swift_once();
  }
  return &static HyperParams.keyWTmpPeriodLstmModelName;
}

uint64_t one-time initialization function for keyHeartRatePeriodTFModelNames()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("HeartRatePeriodTFModelNames", 0x1BuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyHeartRatePeriodTFModelNames = (__int128)v1;
  return result;
}

long long *HyperParams.keyHeartRatePeriodTFModelNames.unsafeMutableAddressor()
{
  if (one-time initialization token for keyHeartRatePeriodTFModelNames != -1) {
    swift_once();
  }
  return &static HyperParams.keyHeartRatePeriodTFModelNames;
}

uint64_t one-time initialization function for keyHeartRatePeriodEnsembleModelNames()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("HeartRatePeriodEnsembleModelNames", 0x21uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyHeartRatePeriodEnsembleModelNames = (__int128)v1;
  return result;
}

long long *HyperParams.keyHeartRatePeriodEnsembleModelNames.unsafeMutableAddressor()
{
  if (one-time initialization token for keyHeartRatePeriodEnsembleModelNames != -1) {
    swift_once();
  }
  return &static HyperParams.keyHeartRatePeriodEnsembleModelNames;
}

uint64_t one-time initialization function for keyRecipeId()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("RecipeId", 8uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyRecipeId = (__int128)v1;
  return result;
}

long long *HyperParams.keyRecipeId.unsafeMutableAddressor()
{
  if (one-time initialization token for keyRecipeId != -1) {
    swift_once();
  }
  return &static HyperParams.keyRecipeId;
}

uint64_t one-time initialization function for keyUseCachedDayStreamProcessorConfig()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UseCachedDayStreamProcessorConfig", 0x21uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyUseCachedDayStreamProcessorConfig = (__int128)v1;
  return result;
}

long long *HyperParams.keyUseCachedDayStreamProcessorConfig.unsafeMutableAddressor()
{
  if (one-time initialization token for keyUseCachedDayStreamProcessorConfig != -1) {
    swift_once();
  }
  return &static HyperParams.keyUseCachedDayStreamProcessorConfig;
}

uint64_t one-time initialization function for keySensorTimeout()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("SensorTimeout", 0xDuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keySensorTimeout = (__int128)v1;
  return result;
}

long long *HyperParams.keySensorTimeout.unsafeMutableAddressor()
{
  if (one-time initialization token for keySensorTimeout != -1) {
    swift_once();
  }
  return &static HyperParams.keySensorTimeout;
}

uint64_t one-time initialization function for keyPregnancySourceList()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("PregnancySourceList", 0x13uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyPregnancySourceList = (__int128)v1;
  return result;
}

long long *HyperParams.keyPregnancySourceList.unsafeMutableAddressor()
{
  if (one-time initialization token for keyPregnancySourceList != -1) {
    swift_once();
  }
  return &static HyperParams.keyPregnancySourceList;
}

uint64_t one-time initialization function for keyHKPregnancyStartSourceIncludeList()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("HKPregnancyStartSourceIncludeList", 0x21uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyHKPregnancyStartSourceIncludeList = (__int128)v1;
  return result;
}

long long *HyperParams.keyHKPregnancyStartSourceIncludeList.unsafeMutableAddressor()
{
  if (one-time initialization token for keyHKPregnancyStartSourceIncludeList != -1) {
    swift_once();
  }
  return &static HyperParams.keyHKPregnancyStartSourceIncludeList;
}

uint64_t one-time initialization function for keyLMPMaxRange()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("LMPMaxRange", 0xBuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyLMPMaxRange = (__int128)v1;
  return result;
}

long long *HyperParams.keyLMPMaxRange.unsafeMutableAddressor()
{
  if (one-time initialization token for keyLMPMaxRange != -1) {
    swift_once();
  }
  return &static HyperParams.keyLMPMaxRange;
}

uint64_t one-time initialization function for keyNightingaleDInputFeatureList()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NightingaleDInputFeatureList", 0x1CuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyNightingaleDInputFeatureList = (__int128)v1;
  return result;
}

long long *HyperParams.keyNightingaleDInputFeatureList.unsafeMutableAddressor()
{
  if (one-time initialization token for keyNightingaleDInputFeatureList != -1) {
    swift_once();
  }
  return &static HyperParams.keyNightingaleDInputFeatureList;
}

uint64_t one-time initialization function for keyNightingaleDInputFeatureStatsOption()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("NightingaleDInputFeatureStatsOption", 0x23uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyNightingaleDInputFeatureStatsOption = (__int128)v1;
  return result;
}

long long *HyperParams.keyNightingaleDInputFeatureStatsOption.unsafeMutableAddressor()
{
  if (one-time initialization token for keyNightingaleDInputFeatureStatsOption != -1) {
    swift_once();
  }
  return &static HyperParams.keyNightingaleDInputFeatureStatsOption;
}

uint64_t one-time initialization function for keyMinPregnancyDuration()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinPregnancyDuration", 0x14uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinPregnancyDuration = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinPregnancyDuration.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinPregnancyDuration != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinPregnancyDuration;
}

uint64_t one-time initialization function for keyMaxPregnancyDuration()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxPregnancyDuration", 0x14uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxPregnancyDuration = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxPregnancyDuration.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxPregnancyDuration != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxPregnancyDuration;
}

uint64_t one-time initialization function for keyOverlapPregnanciesStrategy()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("OverlapPregnanciesStrategy", 0x1AuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyOverlapPregnanciesStrategy = (__int128)v1;
  return result;
}

long long *HyperParams.keyOverlapPregnanciesStrategy.unsafeMutableAddressor()
{
  if (one-time initialization token for keyOverlapPregnanciesStrategy != -1) {
    swift_once();
  }
  return &static HyperParams.keyOverlapPregnanciesStrategy;
}

uint64_t one-time initialization function for keyExcludeContraceptionSlices()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ExcludeContraceptionSlices", 0x1AuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyExcludeContraceptionSlices = (__int128)v1;
  return result;
}

long long *HyperParams.keyExcludeContraceptionSlices.unsafeMutableAddressor()
{
  if (one-time initialization token for keyExcludeContraceptionSlices != -1) {
    swift_once();
  }
  return &static HyperParams.keyExcludeContraceptionSlices;
}

uint64_t one-time initialization function for keyExcludeOtherPregnancySlices()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ExcludeOtherPregnancySlices", 0x1BuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyExcludeOtherPregnancySlices = (__int128)v1;
  return result;
}

long long *HyperParams.keyExcludeOtherPregnancySlices.unsafeMutableAddressor()
{
  if (one-time initialization token for keyExcludeOtherPregnancySlices != -1) {
    swift_once();
  }
  return &static HyperParams.keyExcludeOtherPregnancySlices;
}

uint64_t one-time initialization function for keyExcludeLactationSlices()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ExcludeLactationSlices", 0x16uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyExcludeLactationSlices = (__int128)v1;
  return result;
}

long long *HyperParams.keyExcludeLactationSlices.unsafeMutableAddressor()
{
  if (one-time initialization token for keyExcludeLactationSlices != -1) {
    swift_once();
  }
  return &static HyperParams.keyExcludeLactationSlices;
}

uint64_t one-time initialization function for keyMinLMPFactorDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinLMPFactorDelta", 0x11uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinLMPFactorDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinLMPFactorDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinLMPFactorDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinLMPFactorDelta;
}

uint64_t one-time initialization function for keyMaxLMPFactorDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxLMPFactorDelta", 0x11uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxLMPFactorDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxLMPFactorDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxLMPFactorDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxLMPFactorDelta;
}

uint64_t one-time initialization function for keyMinLMPTestDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinLMPTestDelta", 0xFuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinLMPTestDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinLMPTestDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinLMPTestDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinLMPTestDelta;
}

uint64_t one-time initialization function for keyMaxLMPTestDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxLMPTestDelta", 0xFuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxLMPTestDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxLMPTestDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxLMPTestDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxLMPTestDelta;
}

uint64_t one-time initialization function for keyUseSeahorseInferredStartdate()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UseSeahorseInferredStartdate", 0x1CuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyUseSeahorseInferredStartdate = (__int128)v1;
  return result;
}

long long *HyperParams.keyUseSeahorseInferredStartdate.unsafeMutableAddressor()
{
  if (one-time initialization token for keyUseSeahorseInferredStartdate != -1) {
    swift_once();
  }
  return &static HyperParams.keyUseSeahorseInferredStartdate;
}

uint64_t one-time initialization function for keyExcludePregnanciesContainingFlow()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ExcludePregnanciesContainingFlow", 0x20uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyExcludePregnanciesContainingFlow = (__int128)v1;
  return result;
}

long long *HyperParams.keyExcludePregnanciesContainingFlow.unsafeMutableAddressor()
{
  if (one-time initialization token for keyExcludePregnanciesContainingFlow != -1) {
    swift_once();
  }
  return &static HyperParams.keyExcludePregnanciesContainingFlow;
}

uint64_t one-time initialization function for keyMaxLMPTolerableFlowDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxLMPTolerableFlowDelta", 0x18uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxLMPTolerableFlowDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxLMPTolerableFlowDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxLMPTolerableFlowDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxLMPTolerableFlowDelta;
}

uint64_t one-time initialization function for keySliceDeltaAnchor()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("SliceDeltaAnchor", 0x10uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keySliceDeltaAnchor = (__int128)v1;
  return result;
}

long long *HyperParams.keySliceDeltaAnchor.unsafeMutableAddressor()
{
  if (one-time initialization token for keySliceDeltaAnchor != -1) {
    swift_once();
  }
  return &static HyperParams.keySliceDeltaAnchor;
}

uint64_t one-time initialization function for keyMinSliceAnchorDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinSliceAnchorDelta", 0x13uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinSliceAnchorDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinSliceAnchorDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinSliceAnchorDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinSliceAnchorDelta;
}

uint64_t one-time initialization function for keyMaxSliceAnchorDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxSliceAnchorDelta", 0x13uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxSliceAnchorDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxSliceAnchorDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxSliceAnchorDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxSliceAnchorDelta;
}

uint64_t one-time initialization function for keyPregLabelStartAnchorDelta()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("PregLabelStartAnchorDelta", 0x19uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyPregLabelStartAnchorDelta = (__int128)v1;
  return result;
}

long long *HyperParams.keyPregLabelStartAnchorDelta.unsafeMutableAddressor()
{
  if (one-time initialization token for keyPregLabelStartAnchorDelta != -1) {
    swift_once();
  }
  return &static HyperParams.keyPregLabelStartAnchorDelta;
}

uint64_t one-time initialization function for keyMinDaySHRAvailability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinDaySHRAvailability", 0x15uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinDaySHRAvailability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinDaySHRAvailability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinDaySHRAvailability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinDaySHRAvailability;
}

uint64_t one-time initialization function for keyMinNightSHRAvailability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinNightSHRAvailability", 0x17uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinNightSHRAvailability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinNightSHRAvailability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinNightSHRAvailability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinNightSHRAvailability;
}

uint64_t one-time initialization function for keyMinWristTempAvailability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinWristTempAvailability", 0x18uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinWristTempAvailability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinWristTempAvailability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinWristTempAvailability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinWristTempAvailability;
}

uint64_t one-time initialization function for keyMinHRVAvailability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinHRVAvailability", 0x12uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinHRVAvailability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinHRVAvailability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinHRVAvailability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinHRVAvailability;
}

uint64_t one-time initialization function for keyMinRespiratoryRateAvailability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinRespiratoryRateAvailability", 0x1EuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinRespiratoryRateAvailability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinRespiratoryRateAvailability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinRespiratoryRateAvailability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinRespiratoryRateAvailability;
}

uint64_t one-time initialization function for keyMinSpO2Availability()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MinSpO2Availability", 0x13uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMinSpO2Availability = (__int128)v1;
  return result;
}

long long *HyperParams.keyMinSpO2Availability.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMinSpO2Availability != -1) {
    swift_once();
  }
  return &static HyperParams.keyMinSpO2Availability;
}

uint64_t one-time initialization function for keyMetricsProcessEngine()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MetricsProcessEngine", 0x14uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMetricsProcessEngine = (__int128)v1;
  return result;
}

long long *HyperParams.keyMetricsProcessEngine.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMetricsProcessEngine != -1) {
    swift_once();
  }
  return &static HyperParams.keyMetricsProcessEngine;
}

uint64_t one-time initialization function for keyMaxFPR()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("MaxFPR", 6uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyMaxFPR = (__int128)v1;
  return result;
}

long long *HyperParams.keyMaxFPR.unsafeMutableAddressor()
{
  if (one-time initialization token for keyMaxFPR != -1) {
    swift_once();
  }
  return &static HyperParams.keyMaxFPR;
}

uint64_t one-time initialization function for keyOutputPostProcThreshold()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("OutputPostProcThreshold", 0x17uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyOutputPostProcThreshold = (__int128)v1;
  return result;
}

long long *HyperParams.keyOutputPostProcThreshold.unsafeMutableAddressor()
{
  if (one-time initialization token for keyOutputPostProcThreshold != -1) {
    swift_once();
  }
  return &static HyperParams.keyOutputPostProcThreshold;
}

uint64_t one-time initialization function for keyConfusionMatrixNumThresholds()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ConfusionMatrixNumThresholds", 0x1CuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyConfusionMatrixNumThresholds = (__int128)v1;
  return result;
}

long long *HyperParams.keyConfusionMatrixNumThresholds.unsafeMutableAddressor()
{
  if (one-time initialization token for keyConfusionMatrixNumThresholds != -1) {
    swift_once();
  }
  return &static HyperParams.keyConfusionMatrixNumThresholds;
}

uint64_t one-time initialization function for keyLatencyBuckets()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("LatencyBuckets", 0xEuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyLatencyBuckets = (__int128)v1;
  return result;
}

long long *HyperParams.keyLatencyBuckets.unsafeMutableAddressor()
{
  if (one-time initialization token for keyLatencyBuckets != -1) {
    swift_once();
  }
  return &static HyperParams.keyLatencyBuckets;
}

uint64_t one-time initialization function for keyUseFactorStartDateAsLMP()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UseFactorStartDateAsLMP", 0x17uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyUseFactorStartDateAsLMP = (__int128)v1;
  return result;
}

long long *HyperParams.keyUseFactorStartDateAsLMP.unsafeMutableAddressor()
{
  if (one-time initialization token for keyUseFactorStartDateAsLMP != -1) {
    swift_once();
  }
  return &static HyperParams.keyUseFactorStartDateAsLMP;
}

uint64_t one-time initialization function for keyDropNegativeSlicesForInferredFactorLMP()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("DropNegativeSlicesForInferredFactorLMP", 0x26uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyDropNegativeSlicesForInferredFactorLMP = (__int128)v1;
  return result;
}

long long *HyperParams.keyDropNegativeSlicesForInferredFactorLMP.unsafeMutableAddressor()
{
  if (one-time initialization token for keyDropNegativeSlicesForInferredFactorLMP != -1) {
    swift_once();
  }
  return &static HyperParams.keyDropNegativeSlicesForInferredFactorLMP;
}

uint64_t one-time initialization function for keyUseTestDateAsLMP()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("UseTestDateAsLMP", 0x10uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyUseTestDateAsLMP = (__int128)v1;
  return result;
}

long long *HyperParams.keyUseTestDateAsLMP.unsafeMutableAddressor()
{
  if (one-time initialization token for keyUseTestDateAsLMP != -1) {
    swift_once();
  }
  return &static HyperParams.keyUseTestDateAsLMP;
}

uint64_t one-time initialization function for keyDropNegativeSlicesForInferredTestLMP()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("DropNegativeSlicesForInferredTestLMP", 0x24uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.keyDropNegativeSlicesForInferredTestLMP = (__int128)v1;
  return result;
}

long long *HyperParams.keyDropNegativeSlicesForInferredTestLMP.unsafeMutableAddressor()
{
  if (one-time initialization token for keyDropNegativeSlicesForInferredTestLMP != -1) {
    swift_once();
  }
  return &static HyperParams.keyDropNegativeSlicesForInferredTestLMP;
}

void *HyperParams.defaultSHRQueryBatchSize.unsafeMutableAddressor()
{
  return &static HyperParams.defaultSHRQueryBatchSize;
}

void *HyperParams.defaultMaximumDays.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaximumDays;
}

void *HyperParams.defaultSliceSize.unsafeMutableAddressor()
{
  return &static HyperParams.defaultSliceSize;
}

void *HyperParams.defaultRawSampleTimeoutS.unsafeMutableAddressor()
{
  return &static HyperParams.defaultRawSampleTimeoutS;
}

void *HyperParams.defaultSHRTimeoutS.unsafeMutableAddressor()
{
  return &static HyperParams.defaultSHRTimeoutS;
}

void *HyperParams.defaultBMITimeoutS.unsafeMutableAddressor()
{
  return &static HyperParams.defaultBMITimeoutS;
}

void *HyperParams.defaultLabelSize.unsafeMutableAddressor()
{
  return &static HyperParams.defaultLabelSize;
}

void *HyperParams.defaultMaxNumDaysToNextPeriod.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxNumDaysToNextPeriod;
}

uint64_t one-time initialization function for modelRepresentationEIR()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Espresso", 8uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.modelRepresentationEIR = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for modelRepresentationMIL()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Mil", 3uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.modelRepresentationMIL = (__int128)v1;
  return result;
}

long long *HyperParams.modelRepresentationMIL.unsafeMutableAddressor()
{
  if (one-time initialization token for modelRepresentationMIL != -1) {
    swift_once();
  }
  return &static HyperParams.modelRepresentationMIL;
}

void *one-time initialization function for defaultModelRepresentation()
{
  v0 = HyperParams.modelRepresentationMIL.unsafeMutableAddressor();
  return outlined init with copy of String(v0, static HyperParams.defaultModelRepresentation);
}

void *HyperParams.defaultModelRepresentation.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultModelRepresentation != -1) {
    swift_once();
  }
  return static HyperParams.defaultModelRepresentation;
}

void *HyperParams.defaultBatchSize.unsafeMutableAddressor()
{
  return &static HyperParams.defaultBatchSize;
}

uint64_t one-time initialization function for defaultModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model.espresso.net", 0x12uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultModelName;
}

void *HyperParams.defaultLearningRate.unsafeMutableAddressor()
{
  return &static HyperParams.defaultLearningRate;
}

void *HyperParams.defaultMinNumSlice.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNumSlice;
}

void *HyperParams.defaultMaxNumSlice.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxNumSlice;
}

uint64_t one-time initialization function for labelEncodingTypeOnehot()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Onehot", 6uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.labelEncodingTypeOnehot = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for labelEncodingTypeRegression()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Regression", 0xAuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.labelEncodingTypeRegression = (__int128)v1;
  return result;
}

void *one-time initialization function for defaultLabelEncodingType()
{
  v0 = HyperParams.labelEncodingTypeOnehot.unsafeMutableAddressor();
  return outlined init with copy of String(v0, static HyperParams.defaultLabelEncodingType);
}

void *HyperParams.defaultLabelEncodingType.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultLabelEncodingType != -1) {
    swift_once();
  }
  return static HyperParams.defaultLabelEncodingType;
}

void *HyperParams.defaultReportLastReachLocation.unsafeMutableAddressor()
{
  return &static HyperParams.defaultReportLastReachLocation;
}

void *HyperParams.defaultPFLTaskType.unsafeMutableAddressor()
{
  return &static HyperParams.defaultPFLTaskType;
}

void *HyperParams.defaultBMI.unsafeMutableAddressor()
{
  return &static HyperParams.defaultBMI;
}

void *HyperParams.defaultAge.unsafeMutableAddressor()
{
  return &static HyperParams.defaultAge;
}

void *HyperParams.defaultMinNumOfDaySHRPerSlice.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNumOfDaySHRPerSlice;
}

void *HyperParams.defaultEpochs.unsafeMutableAddressor()
{
  return &static HyperParams.defaultEpochs;
}

void *HyperParams.defaultBirthDateRequired.unsafeMutableAddressor()
{
  return &static HyperParams.defaultBirthDateRequired;
}

void *HyperParams.defaultFullBatchTraining.unsafeMutableAddressor()
{
  return &static HyperParams.defaultFullBatchTraining;
}

void *HyperParams.defaultEvalBeforeTrain.unsafeMutableAddressor()
{
  return &static HyperParams.defaultEvalBeforeTrain;
}

uint64_t one-time initialization function for defaultInputShuffleMethod()
{
  uint64_t v2 = type metadata accessor for ShuffleMethod();
  __swift_allocate_value_buffer(v2, static HyperParams.defaultInputShuffleMethod);
  uint64_t v0 = __swift_project_value_buffer(v2, (uint64_t)static HyperParams.defaultInputShuffleMethod);
  return (*(uint64_t (**)(uint64_t, void))(*(void *)(v2 - 8) + 104))(v0, *MEMORY[0x263F61100]);
}

uint64_t HyperParams.defaultInputShuffleMethod.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultInputShuffleMethod != -1) {
    swift_once();
  }
  uint64_t v0 = type metadata accessor for ShuffleMethod();
  return __swift_project_value_buffer(v0, (uint64_t)static HyperParams.defaultInputShuffleMethod);
}

void *HyperParams.defaultCollectL2Norm.unsafeMutableAddressor()
{
  return &static HyperParams.defaultCollectL2Norm;
}

void *HyperParams.defaultModelMaxNumDaysToNextPeriod.unsafeMutableAddressor()
{
  return &static HyperParams.defaultModelMaxNumDaysToNextPeriod;
}

void *HyperParams.defaultMinCycleLenStd.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinCycleLenStd;
}

uint64_t one-time initialization function for defaultMaxCycleLenStd()
{
  uint64_t result = static Float.greatestFiniteMagnitude.getter();
  static HyperParams.defaultMaxCycleLenStd = v1;
  return result;
}

int *HyperParams.defaultMaxCycleLenStd.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultMaxCycleLenStd != -1) {
    swift_once();
  }
  return &static HyperParams.defaultMaxCycleLenStd;
}

uint64_t one-time initialization function for defaultEvalModels()
{
  uint64_t result = specialized Array.init()();
  static HyperParams.defaultEvalModels = result;
  return result;
}

uint64_t *HyperParams.defaultEvalModels.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultEvalModels != -1) {
    swift_once();
  }
  return &static HyperParams.defaultEvalModels;
}

void *HyperParams.defaultMinNumDaysToNextPeriod.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNumDaysToNextPeriod;
}

uint64_t one-time initialization function for defaultModelPath()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("dummy.mlmodelc", 0xEuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultModelPath = (__int128)v1;
  return result;
}

long long *HyperParams.defaultModelPath.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultModelPath != -1) {
    swift_once();
  }
  return &static HyperParams.defaultModelPath;
}

void *HyperParams.defaultIntervalCorrectionFactor.unsafeMutableAddressor()
{
  return &static HyperParams.defaultIntervalCorrectionFactor;
}

void *HyperParams.defaultUseCachedDayStreamProcessorConfig.unsafeMutableAddressor()
{
  return &static HyperParams.defaultUseCachedDayStreamProcessorConfig;
}

uint64_t one-time initialization function for nightingaleDInputDaySHR10()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("day_shr_10", 0xAuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputDaySHR10 = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputNightSHR10()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("night_shr_10", 0xCuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputNightSHR10 = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputPeriodStartMean()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("period_start_mean", 0x11uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputPeriodStartMean = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputPeriodStartStd()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("period_start_std", 0x10uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputPeriodStartStd = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputAppleSleepingWristTemperature()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("apple_sleeping_wrist_temp", 0x19uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputAppleSleepingWristTemperature = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputDaysSinceLMS()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("days_since_lms", 0xEuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputDaysSinceLMS = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputHRV()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("hrv", 3uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputHRV = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputRespiratoryRate()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("respiratory_rate", 0x10uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputRespiratoryRate = (__int128)v1;
  return result;
}

uint64_t one-time initialization function for nightingaleDInputSpO2()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("spo2", 4uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.nightingaleDInputSpO2 = (__int128)v1;
  return result;
}

void *HyperParams.defaultSensorTimeout.unsafeMutableAddressor()
{
  return &static HyperParams.defaultSensorTimeout;
}

uint64_t one-time initialization function for defaultPregnancySourceList()
{
  uint64_t result = _allocateUninitializedArray<A>(_:)();
  *Swift::String v1 = 0;
  v1[1] = 1;
  v1[2] = 2;
  _finalizeUninitializedArray<A>(_:)();
  static HyperParams.defaultPregnancySourceList = result;
  return result;
}

uint64_t *HyperParams.defaultPregnancySourceList.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultPregnancySourceList != -1) {
    swift_once();
  }
  return &static HyperParams.defaultPregnancySourceList;
}

uint64_t one-time initialization function for defaultHKPregnancyStartSourceIncludeList()
{
  type metadata accessor for _HKPrivatePregnancyStartDateSource();
  uint64_t result = _allocateUninitializedArray<A>(_:)();
  *Swift::String v1 = 0;
  v1[1] = 1;
  v1[2] = 2;
  v1[3] = 3;
  v1[4] = 4;
  _finalizeUninitializedArray<A>(_:)();
  static HyperParams.defaultHKPregnancyStartSourceIncludeList = result;
  return result;
}

uint64_t *HyperParams.defaultHKPregnancyStartSourceIncludeList.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultHKPregnancyStartSourceIncludeList != -1) {
    swift_once();
  }
  return &static HyperParams.defaultHKPregnancyStartSourceIncludeList;
}

void *HyperParams.defaultLMPMaxRange.unsafeMutableAddressor()
{
  return &static HyperParams.defaultLMPMaxRange;
}

uint64_t one-time initialization function for defaultNightingaleDInputFeatureList()
{
  uint64_t v12 = _allocateUninitializedArray<A>(_:)();
  v11 = v0;
  Swift::String v1 = HyperParams.nightingaleDInputDaySHR10.unsafeMutableAddressor();
  outlined init with copy of String(v1, v11);
  uint64_t v2 = HyperParams.nightingaleDInputNightSHR10.unsafeMutableAddressor();
  outlined init with copy of String(v2, v11 + 2);
  started = HyperParams.nightingaleDInputPeriodStartMean.unsafeMutableAddressor();
  outlined init with copy of String(started, v11 + 4);
  v4 = HyperParams.nightingaleDInputPeriodStartStd.unsafeMutableAddressor();
  outlined init with copy of String(v4, v11 + 6);
  v5 = HyperParams.nightingaleDInputDaysSinceLMS.unsafeMutableAddressor();
  outlined init with copy of String(v5, v11 + 8);
  v6 = HyperParams.nightingaleDInputAppleSleepingWristTemperature.unsafeMutableAddressor();
  outlined init with copy of String(v6, v11 + 10);
  v7 = HyperParams.nightingaleDInputHRV.unsafeMutableAddressor();
  outlined init with copy of String(v7, v11 + 12);
  v8 = HyperParams.nightingaleDInputRespiratoryRate.unsafeMutableAddressor();
  outlined init with copy of String(v8, v11 + 14);
  v9 = HyperParams.nightingaleDInputSpO2.unsafeMutableAddressor();
  outlined init with copy of String(v9, v11 + 16);
  uint64_t result = v12;
  _finalizeUninitializedArray<A>(_:)();
  static HyperParams.defaultNightingaleDInputFeatureList = v12;
  return result;
}

uint64_t *HyperParams.defaultNightingaleDInputFeatureList.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultNightingaleDInputFeatureList != -1) {
    swift_once();
  }
  return &static HyperParams.defaultNightingaleDInputFeatureList;
}

uint64_t one-time initialization function for defaultNightingaleDInputFeatureStatsOption()
{
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (String, FeatureStatsOption));
  _allocateUninitializedArray<A>(_:)();
  uint64_t v11 = v0;
  Swift::String v1 = HyperParams.nightingaleDInputDaySHR10.unsafeMutableAddressor();
  outlined init with copy of String(v1, (void *)v11);
  *(unsigned char *)(v11 + 16) = 2;
  uint64_t v2 = HyperParams.nightingaleDInputNightSHR10.unsafeMutableAddressor();
  outlined init with copy of String(v2, (void *)(v11 + 24));
  *(unsigned char *)(v11 + 40) = 2;
  started = HyperParams.nightingaleDInputPeriodStartMean.unsafeMutableAddressor();
  outlined init with copy of String(started, (void *)(v11 + 48));
  *(unsigned char *)(v11 + 64) = 2;
  v4 = HyperParams.nightingaleDInputPeriodStartStd.unsafeMutableAddressor();
  outlined init with copy of String(v4, (void *)(v11 + 72));
  *(unsigned char *)(v11 + 88) = 2;
  v5 = HyperParams.nightingaleDInputDaysSinceLMS.unsafeMutableAddressor();
  outlined init with copy of String(v5, (void *)(v11 + 96));
  *(unsigned char *)(v11 + 112) = 2;
  v6 = HyperParams.nightingaleDInputAppleSleepingWristTemperature.unsafeMutableAddressor();
  outlined init with copy of String(v6, (void *)(v11 + 120));
  *(unsigned char *)(v11 + 136) = 2;
  v7 = HyperParams.nightingaleDInputHRV.unsafeMutableAddressor();
  outlined init with copy of String(v7, (void *)(v11 + 144));
  *(unsigned char *)(v11 + 160) = 2;
  v8 = HyperParams.nightingaleDInputRespiratoryRate.unsafeMutableAddressor();
  outlined init with copy of String(v8, (void *)(v11 + 168));
  *(unsigned char *)(v11 + 184) = 2;
  v9 = HyperParams.nightingaleDInputSpO2.unsafeMutableAddressor();
  outlined init with copy of String(v9, (void *)(v11 + 192));
  *(unsigned char *)(v11 + 208) = 2;
  _finalizeUninitializedArray<A>(_:)();
  uint64_t result = Dictionary.init(dictionaryLiteral:)();
  static HyperParams.defaultNightingaleDInputFeatureStatsOption = result;
  return result;
}

uint64_t *HyperParams.defaultNightingaleDInputFeatureStatsOption.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultNightingaleDInputFeatureStatsOption != -1) {
    swift_once();
  }
  return &static HyperParams.defaultNightingaleDInputFeatureStatsOption;
}

void *HyperParams.defaultMinPregnancyDuration.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinPregnancyDuration;
}

void *HyperParams.defaultMaxPregnancyDuration.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxPregnancyDuration;
}

void *HyperParams.defaultOverlapPregnanciesStrategy.unsafeMutableAddressor()
{
  return &static HyperParams.defaultOverlapPregnanciesStrategy;
}

void *HyperParams.defaultExcludeContraceptionSlices.unsafeMutableAddressor()
{
  return &static HyperParams.defaultExcludeContraceptionSlices;
}

void *HyperParams.defaultExcludeOtherPregnancySlices.unsafeMutableAddressor()
{
  return &static HyperParams.defaultExcludeOtherPregnancySlices;
}

void *HyperParams.defaultExcludeLactationSlices.unsafeMutableAddressor()
{
  return &static HyperParams.defaultExcludeLactationSlices;
}

void *HyperParams.defaultMinLMPFactorDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinLMPFactorDelta;
}

void *HyperParams.defaultMaxLMPFactorDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxLMPFactorDelta;
}

void *HyperParams.defaultMinLMPTestDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinLMPTestDelta;
}

void *HyperParams.defaultMaxLMPTestDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxLMPTestDelta;
}

void *HyperParams.defaultUseSeahorseInferredStartdate.unsafeMutableAddressor()
{
  return &static HyperParams.defaultUseSeahorseInferredStartdate;
}

void *HyperParams.defaultExcludePregnanciesContainingFlow.unsafeMutableAddressor()
{
  return &static HyperParams.defaultExcludePregnanciesContainingFlow;
}

void *HyperParams.defaultMaxLMPTolerableFlowDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxLMPTolerableFlowDelta;
}

void *HyperParams.defaultSliceDeltaAnchor.unsafeMutableAddressor()
{
  return &static HyperParams.defaultSliceDeltaAnchor;
}

void *HyperParams.defaultMinSliceAnchorDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinSliceAnchorDelta;
}

void *HyperParams.defaultMaxSliceAnchorDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxSliceAnchorDelta;
}

void *HyperParams.defaultPregLabelStartAnchorDelta.unsafeMutableAddressor()
{
  return &static HyperParams.defaultPregLabelStartAnchorDelta;
}

void *HyperParams.defaultMinDaySHRAvailability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinDaySHRAvailability;
}

void *HyperParams.defaultMinNightSHRAvailability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNightSHRAvailability;
}

void *HyperParams.defaultMinWristTempAvailability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinWristTempAvailability;
}

void *HyperParams.defaultMinHRVAvailability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinHRVAvailability;
}

void *HyperParams.defaultMinRespiratoryRateAvailability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinRespiratoryRateAvailability;
}

void *HyperParams.defaultMinSpO2Availability.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinSpO2Availability;
}

void *HyperParams.defaultMetricsProcessEngine.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMetricsProcessEngine;
}

void *HyperParams.defaultMaxFPR.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxFPR;
}

void *HyperParams.defaultOutputPostProcThreshold.unsafeMutableAddressor()
{
  return &static HyperParams.defaultOutputPostProcThreshold;
}

void *HyperParams.defaultConfusionMatrixNumThresholds.unsafeMutableAddressor()
{
  return &static HyperParams.defaultConfusionMatrixNumThresholds;
}

uint64_t one-time initialization function for defaultLatencyBuckets()
{
  uint64_t result = _allocateUninitializedArray<A>(_:)();
  *(_DWORD *)uint64_t v1 = -1027080192;
  *(float *)(v1 + 4) = -14.0;
  *(float *)(v1 + 8) = -10.0;
  *(float *)(v1 + 12) = -7.0;
  *(float *)(v1 + 16) = -3.0;
  *(_DWORD *)(v1 + 20) = 0;
  *(float *)(v1 + 24) = 3.0;
  *(float *)(v1 + 28) = 7.0;
  *(float *)(v1 + 32) = 10.0;
  *(float *)(v1 + 36) = 14.0;
  *(float *)(v1 + 40) = 18.0;
  *(float *)(v1 + 44) = 21.0;
  *(float *)(v1 + 48) = 24.0;
  *(float *)(v1 + 52) = 28.0;
  _finalizeUninitializedArray<A>(_:)();
  static HyperParams.defaultLatencyBuckets = result;
  return result;
}

uint64_t *HyperParams.defaultLatencyBuckets.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultLatencyBuckets != -1) {
    swift_once();
  }
  return &static HyperParams.defaultLatencyBuckets;
}

void *HyperParams.defaultUseFactorStartDateAsLMP.unsafeMutableAddressor()
{
  return &static HyperParams.defaultUseFactorStartDateAsLMP;
}

void *HyperParams.defaultUseTestDateAsLMP.unsafeMutableAddressor()
{
  return &static HyperParams.defaultUseTestDateAsLMP;
}

void *HyperParams.defaultDropNegativeSlicesForInferredFactorLMP.unsafeMutableAddressor()
{
  return &static HyperParams.defaultDropNegativeSlicesForInferredFactorLMP;
}

void *HyperParams.defaultDropNegativeSlicesForInferredTestLMP.unsafeMutableAddressor()
{
  return &static HyperParams.defaultDropNegativeSlicesForInferredTestLMP;
}

void *HyperParams.defaultMinDaysAgo.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinDaysAgo;
}

void *HyperParams.defaultMinNEligibleCyclesHistory.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNEligibleCyclesHistory;
}

void *HyperParams.defaultMaxNEligibleCyclesHistory.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMaxNEligibleCyclesHistory;
}

void *HyperParams.defaultMinDaySHRCountThreshold.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinDaySHRCountThreshold;
}

void *HyperParams.defaultMinNightSHRCountThreshold.unsafeMutableAddressor()
{
  return &static HyperParams.defaultMinNightSHRCountThreshold;
}

uint64_t one-time initialization function for defaultHeartRateFwEnd10PctModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model_fwEnd_10pct.mlmodelc/model.espresso.net", 0x2DuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultHeartRateFwEnd10PctModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultHeartRateFwEnd10PctModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultHeartRateFwEnd10PctModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultHeartRateFwEnd10PctModelName;
}

uint64_t one-time initialization function for defaultHeartRatePeriod10PctModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model_period_10pct.mlmodelc/model.espresso.net", 0x2EuLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultHeartRatePeriod10PctModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultHeartRatePeriod10PctModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultHeartRatePeriod10PctModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultHeartRatePeriod10PctModelName;
}

uint64_t one-time initialization function for defaultWTmpFwEndLstmModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("fwEnddet_lstm.mlmodelc/model.espresso.net", 0x29uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultWTmpFwEndLstmModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultWTmpFwEndLstmModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultWTmpFwEndLstmModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultWTmpFwEndLstmModelName;
}

uint64_t one-time initialization function for defaultWTmpFwEndRFModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("fwEnddet_rf.mlmodelc/coremldata.bin", 0x23uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultWTmpFwEndRFModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultWTmpFwEndRFModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultWTmpFwEndRFModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultWTmpFwEndRFModelName;
}

uint64_t one-time initialization function for defaultWTmpPeriodLstmModelName()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("period_lstm.mlmodelc/model.espresso.net", 0x27uLL, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultWTmpPeriodLstmModelName = (__int128)v1;
  return result;
}

long long *HyperParams.defaultWTmpPeriodLstmModelName.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultWTmpPeriodLstmModelName != -1) {
    swift_once();
  }
  return &static HyperParams.defaultWTmpPeriodLstmModelName;
}

uint64_t one-time initialization function for defaultHeartRatePeriodTFModelNames()
{
  uint64_t result = _allocateUninitializedArray<A>(_:)();
  static HyperParams.defaultHeartRatePeriodTFModelNames = result;
  return result;
}

uint64_t *HyperParams.defaultHeartRatePeriodTFModelNames.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultHeartRatePeriodTFModelNames != -1) {
    swift_once();
  }
  return &static HyperParams.defaultHeartRatePeriodTFModelNames;
}

uint64_t one-time initialization function for defaultHeartRatePeriodEnsembleModelNames()
{
  uint64_t result = _allocateUninitializedArray<A>(_:)();
  static HyperParams.defaultHeartRatePeriodEnsembleModelNames = result;
  return result;
}

uint64_t *HyperParams.defaultHeartRatePeriodEnsembleModelNames.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultHeartRatePeriodEnsembleModelNames != -1) {
    swift_once();
  }
  return &static HyperParams.defaultHeartRatePeriodEnsembleModelNames;
}

uint64_t one-time initialization function for defaultRecipeId()
{
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("", 0, 1);
  uint64_t result = v1._countAndFlagsBits;
  static HyperParams.defaultRecipeId = (__int128)v1;
  return result;
}

long long *HyperParams.defaultRecipeId.unsafeMutableAddressor()
{
  if (one-time initialization token for defaultRecipeId != -1) {
    swift_once();
  }
  return &static HyperParams.defaultRecipeId;
}

uint64_t HyperParams.recipe.getter()
{
  swift_beginAccess();
  uint64_t v2 = *(void *)(v0 + 16);
  swift_bridgeObjectRetain();
  swift_endAccess();
  return v2;
}

uint64_t HyperParams.recipe.setter(uint64_t a1)
{
  swift_bridgeObjectRetain();
  swift_beginAccess();
  *(void *)(v1 + 16) = a1;
  swift_bridgeObjectRelease();
  swift_endAccess();
  return swift_bridgeObjectRelease();
}

uint64_t HyperParams.init(recipe:)(uint64_t a1)
{
  uint64_t v26 = a1;
  uint64_t v25 = v1;
  swift_bridgeObjectRetain();
  *(void *)(v1 + 16) = a1;
  uint64_t v2 = HyperParams.keyNightingaleDInputFeatureList.unsafeMutableAddressor();
  outlined init with copy of String(v2, &v22);
  _convertToAnyHashable<A>(_:)();
  MEMORY[0x25A2C04B0](v23, v21, a1, MEMORY[0x263F8DB68], MEMORY[0x263F8EE58] + 8, MEMORY[0x263F8DB70]);
  if (v23[3])
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
    if (swift_dynamicCast()) {
      uint64_t v10 = v14;
    }
    else {
      uint64_t v10 = 0;
    }
    outlined destroy of AnyHashable((uint64_t)v21);
    outlined destroy of DefaultStringInterpolation();
    uint64_t v11 = v10;
  }
  else
  {
    outlined destroy of AnyHashable((uint64_t)v21);
    outlined destroy of DefaultStringInterpolation();
    outlined destroy of Pregnancy?((uint64_t)v23);
    uint64_t v11 = 0;
  }
  uint64_t v20 = v11;
  if (v11)
  {
    uint64_t v24 = v20;
  }
  else
  {
    v3 = HyperParams.defaultNightingaleDInputFeatureList.unsafeMutableAddressor();
    outlined init with copy of [Float](v3, &v24);
    outlined destroy of [A]();
  }
  *(void *)(v12 + 24) = v24;
  v4 = HyperParams.keyNightingaleDInputFeatureStatsOption.unsafeMutableAddressor();
  outlined init with copy of String(v4, &v17);
  _convertToAnyHashable<A>(_:)();
  MEMORY[0x25A2C04B0](v18, v16, a1, MEMORY[0x263F8DB68], MEMORY[0x263F8EE58] + 8, MEMORY[0x263F8DB70]);
  if (v18[3])
  {
    __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : String]);
    if (swift_dynamicCast()) {
      uint64_t v8 = v15;
    }
    else {
      uint64_t v8 = 0;
    }
    outlined destroy of AnyHashable((uint64_t)v16);
    outlined destroy of DefaultStringInterpolation();
    uint64_t v9 = v8;
  }
  else
  {
    outlined destroy of AnyHashable((uint64_t)v16);
    outlined destroy of DefaultStringInterpolation();
    outlined destroy of Pregnancy?((uint64_t)v18);
    uint64_t v9 = 0;
  }
  if (v9)
  {
    uint64_t v19 = v9;
  }
  else
  {
    HyperParams.defaultNightingaleDInputFeatureStatsOption.unsafeMutableAddressor();
    swift_bridgeObjectRetain();
    uint64_t v7 = Dictionary.mapValues<A>(_:)();
    swift_bridgeObjectRelease();
    uint64_t v19 = v7;
    outlined destroy of [A]();
  }
  uint64_t v6 = Dictionary.mapValues<A>(_:)();
  swift_bridgeObjectRelease();
  *(void *)(v12 + 32) = v6;
  swift_bridgeObjectRelease();
  return v12;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> outlined destroy of AnyHashable(uint64_t a1)
{
}

uint64_t closure #1 in implicit closure #2 in HyperParams.init(recipe:)@<X0>(char *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = FeatureStatsOption.rawValue.getter(*a1);
  *a2 = result;
  a2[1] = v3;
  return result;
}

NightingaleTraining::FeatureStatsOption_optional closure #2 in HyperParams.init(recipe:)@<W0>(Swift::String *a1@<X0>, NightingaleTraining::FeatureStatsOption *a2@<X8>)
{
  Swift::String rawValue = *a1;
  swift_bridgeObjectRetain();
  result.value = FeatureStatsOption.init(rawValue:)(rawValue).value;
  if (result.value == NightingaleTraining_FeatureStatsOption_unknownDefault) {
    *a2 = NightingaleTraining_FeatureStatsOption_none;
  }
  else {
    *(NightingaleTraining::FeatureStatsOption_optional *)a2 = result;
  }
  return result;
}

void *HyperParams.parameter<A>(for:default:)@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X8>)
{
  v13 = a5;
  uint64_t v21 = a1;
  uint64_t v22 = a2;
  uint64_t v18 = a3;
  uint64_t v27 = a4;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v34 = 0;
  uint64_t v33 = 0;
  uint64_t v37 = a4;
  uint64_t v14 = *(void *)(a4 - 8);
  uint64_t v15 = a4 - 8;
  unint64_t v16 = (*(void *)(v14 + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x270FA5388](a1);
  uint64_t v17 = (char *)&v10 - v16;
  uint64_t v19 = type metadata accessor for Optional();
  unint64_t v20 = (*(void *)(*(void *)(v19 - 8) + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v6 = MEMORY[0x270FA5388](v22);
  uint64_t v28 = (uint64_t)&v10 - v20;
  uint64_t v35 = v7;
  uint64_t v36 = v6;
  uint64_t v34 = v8;
  uint64_t v33 = v5;
  swift_bridgeObjectRetain();
  v32[0] = v21;
  v32[1] = v22;
  uint64_t v24 = v31;
  _convertToAnyHashable<A>(_:)();
  v23 = &v30;
  swift_beginAccess();
  uint64_t v25 = *(void *)(v5 + 16);
  swift_bridgeObjectRetain();
  swift_endAccess();
  uint64_t v26 = &v29;
  MEMORY[0x25A2C04B0](v24, v25, MEMORY[0x263F8DB68], MEMORY[0x263F8EE58] + 8, MEMORY[0x263F8DB70]);
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for Any?);
  if (swift_dynamicCast()) {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v14 + 56))(v28, 0, 1, v27);
  }
  else {
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 56))(v28, 1, 1, v27);
  }
  uint64_t v11 = *(void (**)(char *, uint64_t, uint64_t))(v14 + 16);
  uint64_t v12 = v14 + 16;
  v11(v17, v18, v27);
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v14 + 48))(v28, 1, v27) == 1)
  {
    v11(v13, (uint64_t)v17, v27);
    outlined destroy of B?(v28, v27);
  }
  else
  {
    (*(void (**)(char *, uint64_t, uint64_t))(v14 + 32))(v13, v28, v27);
  }
  (*(void (**)(char *, uint64_t))(v14 + 8))(v17, v27);
  swift_bridgeObjectRelease();
  outlined destroy of AnyHashable((uint64_t)v31);
  NightingaleTraining::FeatureStatsOption_optional result = v32;
  outlined destroy of DefaultStringInterpolation();
  return result;
}

uint64_t HyperParams.maximumDays.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaximumDays.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(550).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

NSNumber __swiftcall NSNumber.__allocating_init(value:)(Swift::Int value)
{
  id v1 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  return (NSNumber)@nonobjc NSNumber.init(value:)(value);
}

uint64_t HyperParams.minimumDaysAgo.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinDaysAgo.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.minDaySHRCountThreshold.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinDaySHRCountThreshold.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(24).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.minNightSHRCountThreshold.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinNightSHRCountThreshold.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(24).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.minimumNEligibleCyclesHistory.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinNEligibleCyclesHistory.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(1).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.maximumNEligibleCyclesHistory.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaxNEligibleCyclesHistory.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(100).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.sHRQueryBatchSize.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keySHRQueryBatchSize.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(10).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.sliceSize.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keySliceSize.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(45).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.rawSampleTimeout.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyRawSampleTimeout.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 30;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.shrTimeout.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keySHRTimeout.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 30;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.bmiTimeout.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyBMITimeout.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 30;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.labelSize.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyLabelSize.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(32).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.maxNumDaysToNextPeriod.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaxNumDaysToNextPeriod.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(32).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.modelRepresentation.getter()
{
  uint64_t v10 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelRepresentation.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = HyperParams.defaultModelRepresentation.unsafeMutableAddressor();
  uint64_t v5 = *v2;
  uint64_t v6 = v2[1];
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.batchSize.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyBatchSize.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = -1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

float HyperParams.learningRate.getter()
{
  v9[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyLearningRate.unsafeMutableAddressor();
  uint64_t v4 = *v0;
  uint64_t v5 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v3 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0.1).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&isa, v3, (char *)v9);

  swift_bridgeObjectRelease();
  id v6 = v9[0];
  objc_msgSend(v9[0], sel_floatValue);
  float v7 = v1;

  return v7;
}

NSNumber __swiftcall NSNumber.__allocating_init(value:)(Swift::Double value)
{
  id v1 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  return (NSNumber)@nonobjc NSNumber.init(value:)();
}

uint64_t HyperParams.maxNumSlice.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyMaxNumSlice.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = -1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.minNumSlice.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyMinNumSlice.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.inputName.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelInputName.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  Swift::String v5 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("", 0, 1);
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D310], (char *)&v6);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.outputName.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelOutputName.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  Swift::String v5 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("", 0, 1);
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D310], (char *)&v6);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.lossName.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelLossName.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  Swift::String v5 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("", 0, 1);
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D310], (char *)&v6);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.labelName.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelLabelName.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  Swift::String v5 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("", 0, 1);
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D310], (char *)&v6);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.weightNames.getter()
{
  uint64_t v8 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelOrderedWeightNames.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v5 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v6 = _allocateUninitializedArray<A>(_:)();
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&v6, v2, (char *)&v7);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  return v7;
}

uint64_t HyperParams.labelEncodingType.getter()
{
  uint64_t v10 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelLabelEncodingType.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultLabelEncodingType.unsafeMutableAddressor();
  uint64_t v5 = *v2;
  uint64_t v6 = v2[1];
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.pflTaskType.getter()
{
  uint64_t v9 = v0;
  id v1 = (uint64_t *)HyperParams.keyPFLTaskType.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v7 = NightingalePFLTaskType.rawValue.getter(0);
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v7, MEMORY[0x263F8D6C8], (char *)&v8);
  swift_bridgeObjectRelease();
  v5.value = NightingalePFLTaskType.init(rawValue:)(v8).value;
  if (v5.value == NightingaleTraining_NightingalePFLTaskType_unknownDefault) {
    return 0;
  }
  else {
    return v5.value;
  }
}

uint64_t HyperParams.minNumOfDaySHRPerSlice.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyMinNumOfDaySHRPerSlice.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.defaultBMI.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyDefaultBMI.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = -1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.epochs.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyNumLocalIterations.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.birthDateRequired.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyBirthDateRequired.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.defaultAge.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyDefaultAge.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = -1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.fullBatchTraining.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyFullBatchTraining.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.evalBeforeTrain.getter()
{
  uint64_t v7 = v0;
  id v1 = (uint64_t *)HyperParams.keyEvalBeforeTrain.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.inputShuffleMethod.getter@<X0>(char *a1@<X8>)
{
  Swift::Int v8 = a1;
  uint64_t v24 = 0;
  uint64_t v21 = 0;
  uint64_t v1 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for ShuffleMethod?);
  unint64_t v9 = (*(void *)(*(void *)(v1 - 8) + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x270FA5388](v1);
  uint64_t v19 = (uint64_t)&v8 - v9;
  uint64_t v20 = type metadata accessor for ShuffleMethod();
  uint64_t v17 = *(void *)(v20 - 8);
  uint64_t v18 = v20 - 8;
  unint64_t v10 = (*(void *)(v17 + 64) + 15) & 0xFFFFFFFFFFFFFFF0;
  MEMORY[0x270FA5388](v20);
  uint64_t v2 = (char *)&v8 - v10;
  v13 = (char *)&v8 - v10;
  uint64_t v24 = v3;
  uint64_t v4 = (uint64_t *)HyperParams.keyInputShuffleMethod.unsafeMutableAddressor();
  uint64_t v15 = *v4;
  uint64_t v16 = v4[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = HyperParams.defaultInputShuffleMethod.unsafeMutableAddressor();
  uint64_t v11 = *(void (**)(char *, uint64_t, uint64_t))(v17 + 16);
  uint64_t v12 = v17 + 16;
  v11(v2, v5, v20);
  uint64_t v14 = ShuffleMethod.rawValue.getter();
  (*(void (**)(char *, uint64_t))(v17 + 8))(v13, v20);
  uint64_t v22 = v14;
  HyperParams.parameter<A>(for:default:)(v15, v16, (uint64_t)&v22, MEMORY[0x263F8D6C8], (char *)&v23);
  swift_bridgeObjectRelease();
  uint64_t v21 = v23;
  ShuffleMethod.init(rawValue:)();
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(v17 + 48))(v19, 1, v20) != 1) {
    return (*(uint64_t (**)(char *, uint64_t, uint64_t))(v17 + 32))(v8, v19, v20);
  }
  uint64_t v7 = HyperParams.defaultInputShuffleMethod.unsafeMutableAddressor();
  v11(v8, v7, v20);
  return outlined destroy of ShuffleMethod?(v19);
}

uint64_t outlined destroy of ShuffleMethod?(uint64_t a1)
{
  uint64_t v3 = type metadata accessor for ShuffleMethod();
  uint64_t v4 = *(void *)(v3 - 8);
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(v4 + 48))(a1, 1)) {
    (*(void (**)(uint64_t, uint64_t))(v4 + 8))(a1, v3);
  }
  return a1;
}

uint64_t HyperParams.collectL2Norm.getter()
{
  uint64_t v7 = v0;
  uint64_t v1 = (uint64_t *)HyperParams.keyCollectL2Norm.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.modelMaxNumDaysToNextPeriod.getter()
{
  uint64_t v7 = v0;
  uint64_t v1 = (uint64_t *)HyperParams.keyModelMaxNumDaysToNextPeriod.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 32;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

float HyperParams.minCycleLenStd.getter()
{
  v9[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinCycleLenStd.unsafeMutableAddressor();
  uint64_t v4 = *v0;
  uint64_t v5 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v3 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0.0).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&isa, v3, (char *)v9);

  swift_bridgeObjectRelease();
  id v6 = v9[0];
  objc_msgSend(v9[0], sel_floatValue);
  float v7 = v1;

  return v7;
}

NSNumber __swiftcall NSNumber.__allocating_init(value:)(Swift::Float value)
{
  id v1 = objc_allocWithZone((Class)swift_getObjCClassFromMetadata());
  return (NSNumber)@nonobjc NSNumber.init(value:)();
}

float HyperParams.maxCycleLenStd.getter()
{
  v10[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaxCycleLenStd.unsafeMutableAddressor();
  uint64_t v5 = *v0;
  uint64_t v6 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v4 = type metadata accessor for NSNumber();
  id v1 = HyperParams.defaultMaxCycleLenStd.unsafeMutableAddressor();
  Class isa = NSNumber.__allocating_init(value:)(*(Swift::Float *)v1).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v5, v6, (uint64_t)&isa, v4, (char *)v10);

  swift_bridgeObjectRelease();
  id v7 = v10[0];
  objc_msgSend(v10[0], sel_floatValue);
  float v8 = v2;

  return v8;
}

uint64_t HyperParams.evalModels.getter()
{
  uint64_t v9 = v0;
  id v1 = (uint64_t *)HyperParams.keyEvalModels.unsafeMutableAddressor();
  uint64_t v5 = *v1;
  uint64_t v6 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v4 = *HyperParams.defaultEvalModels.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  uint64_t v7 = v4;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v5, v6, (uint64_t)&v7, v2, (char *)&v8);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  return v8;
}

uint64_t HyperParams.minNumDaysToNextPeriod.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMinNumDaysToNextPeriod.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(1).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.reportLastReachLocation.getter()
{
  uint64_t v7 = v0;
  Reach = (uint64_t *)HyperParams.keyReportLastReachLocation.unsafeMutableAddressor();
  uint64_t v3 = *Reach;
  uint64_t v4 = Reach[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.modelPath.getter()
{
  uint64_t v10 = v0;
  id v1 = (uint64_t *)HyperParams.keyModelPath.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = HyperParams.defaultModelPath.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.recipeForModel(model:)(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a1;
  uint64_t v11 = a2;
  uint64_t v9 = v2;
  uint64_t v7 = Dictionary.init()();
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String : Any]);
  HyperParams.parameter<A>(for:default:)(a1, a2, (uint64_t)&v7, v3, (char *)&v8);
  outlined destroy of [A]();
  return v8;
}

float HyperParams.intervalCorrectionFactor.getter()
{
  v9[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyIntervalCorrectionFactor.unsafeMutableAddressor();
  uint64_t v4 = *v0;
  uint64_t v5 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v3 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0.85).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&isa, v3, (char *)v9);

  swift_bridgeObjectRelease();
  id v6 = v9[0];
  objc_msgSend(v9[0], sel_floatValue);
  float v7 = v1;

  return v7;
}

uint64_t HyperParams.modelName.getter()
{
  uint64_t v10 = v0;
  float v1 = (uint64_t *)HyperParams.keyModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.useCachedDayStreamProcessorConfig.getter()
{
  uint64_t v7 = v0;
  float v1 = (uint64_t *)HyperParams.keyUseCachedDayStreamProcessorConfig.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.sensorTimeout.getter()
{
  uint64_t v7 = v0;
  float v1 = (uint64_t *)HyperParams.keySensorTimeout.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 30;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.pregnancySourceList.getter()
{
  v14[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyPregnancySourceList.unsafeMutableAddressor();
  uint64_t v7 = *v0;
  uint64_t v8 = v0[1];
  swift_bridgeObjectRetain();
  uint64_t v9 = *HyperParams.defaultPregnancySourceList.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  v13[1] = v9;
  uint64_t v10 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [PregnancySource]);
  unint64_t v1 = lazy protocol witness table accessor for type [PregnancySource] and conformance [A]();
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))closure #1 in HyperParams.pregnancySourceList.getter, 0, v10, MEMORY[0x263F8D310], MEMORY[0x263F8E628], v1, MEMORY[0x263F8E658], v11);
  outlined destroy of [A]();
  v13[0] = v12;
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v7, v8, (uint64_t)v13, v5, (char *)v14);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  uint64_t v6 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for PregnancySource?);
  unint64_t v2 = lazy protocol witness table accessor for type [String] and conformance [A]();
  _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))closure #2 in HyperParams.pregnancySourceList.getter, 0, v5, v6, MEMORY[0x263F8E628], v2, MEMORY[0x263F8E658], v11);
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [PregnancySource?]);
  lazy protocol witness table accessor for type [PregnancySource?] and conformance [A]();
  uint64_t v4 = Sequence.compactMap<A>(_:)();
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  return v4;
}

uint64_t closure #1 in HyperParams.pregnancySourceList.getter@<X0>(char *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = PregnancySource.rawValue.getter(*a1);
  *a2 = result;
  a2[1] = v3;
  return result;
}

NightingaleTraining::PregnancySource_optional closure #2 in HyperParams.pregnancySourceList.getter@<W0>(Swift::String *a1@<X0>, NightingaleTraining::PregnancySource_optional *a2@<X8>)
{
  Swift::String rawValue = *a1;
  swift_bridgeObjectRetain();
  result.value = PregnancySource.init(rawValue:)(rawValue).value;
  a2->value = result.value;
  return result;
}

unsigned char *closure #3 in HyperParams.pregnancySourceList.getter@<X0>(unsigned char *result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = *result;
  return result;
}

unint64_t lazy protocol witness table accessor for type [PregnancySource?] and conformance [A]()
{
  uint64_t v2 = lazy protocol witness table cache variable for type [PregnancySource?] and conformance [A];
  if (!lazy protocol witness table cache variable for type [PregnancySource?] and conformance [A])
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for [PregnancySource?]);
    unint64_t WitnessTable = swift_getWitnessTable();
    atomic_store(WitnessTable, (unint64_t *)&lazy protocol witness table cache variable for type [PregnancySource?] and conformance [A]);
    return WitnessTable;
  }
  return v2;
}

uint64_t HyperParams.hkPregnancyStartSourceIncludeList.getter()
{
  v15[1] = 0;
  started = (uint64_t *)HyperParams.keyHKPregnancyStartSourceIncludeList.unsafeMutableAddressor();
  uint64_t v7 = *started;
  uint64_t v8 = started[1];
  swift_bridgeObjectRetain();
  uint64_t v9 = *HyperParams.defaultHKPregnancyStartSourceIncludeList.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  v14[1] = v9;
  swift_retain();
  uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [_HKPrivatePregnancyStartDateSource]);
  unint64_t v1 = lazy protocol witness table accessor for type [_HKPrivatePregnancyStartDateSource] and conformance [A]();
  uint64_t v13 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))partial apply for closure #1 in HyperParams.hkPregnancyStartSourceIncludeList.getter, v10, v11, MEMORY[0x263F8D310], MEMORY[0x263F8E628], v1, MEMORY[0x263F8E658], v12);
  swift_release();
  outlined destroy of [A]();
  v14[0] = v13;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v7, v8, (uint64_t)v14, v4, (char *)v15);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  swift_retain();
  uint64_t v5 = type metadata accessor for _HKPrivatePregnancyStartDateSource();
  unint64_t v2 = lazy protocol witness table accessor for type [String] and conformance [A]();
  uint64_t v6 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))partial apply for closure #2 in HyperParams.hkPregnancyStartSourceIncludeList.getter, v10, v4, v5, MEMORY[0x263F8E628], v2, MEMORY[0x263F8E658], v12);
  swift_release();
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t closure #1 in HyperParams.hkPregnancyStartSourceIncludeList.getter@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t result = HyperParams.pregnancyStartSourceToString(_:)(*a1);
  *a2 = result;
  a2[1] = v3;
  return result;
}

uint64_t partial apply for closure #1 in HyperParams.hkPregnancyStartSourceIncludeList.getter@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  return closure #1 in HyperParams.hkPregnancyStartSourceIncludeList.getter(a1, a2);
}

uint64_t closure #2 in HyperParams.hkPregnancyStartSourceIncludeList.getter@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = HyperParams.stringToTregnancyStartSource(_:)();
  *a1 = result;
  return result;
}

uint64_t partial apply for closure #2 in HyperParams.hkPregnancyStartSourceIncludeList.getter@<X0>(uint64_t *a1@<X8>)
{
  return closure #2 in HyperParams.hkPregnancyStartSourceIncludeList.getter(a1);
}

uint64_t HyperParams.lmpMaxRange.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyLMPMaxRange.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 70;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.minPregnancyDuration.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinPregnancyDuration.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 42;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.maxPregnancyDuration.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMaxPregnancyDuration.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 322;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.overlapPregnanciesStrategy.getter()
{
  uint64_t v11 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyOverlapPregnanciesStrategy.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v5 = v1[1];
  swift_bridgeObjectRetain();
  v9[0] = OverlapPregnanciesStrategy.rawValue.getter(1);
  v9[1] = v2;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)v9, MEMORY[0x263F8D310], (char *)&v10);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  Swift::String rawValue = v10;
  swift_bridgeObjectRetain();
  v7.value = OverlapPregnanciesStrategy.init(rawValue:)(rawValue).value;
  if (v7.value == NightingaleTraining_OverlapPregnanciesStrategy_unknownDefault) {
    char v8 = 1;
  }
  else {
    char v8 = v7.value & 1;
  }
  swift_bridgeObjectRelease();
  return v8 & 1;
}

uint64_t HyperParams.excludeContraceptionSlices.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyExcludeContraceptionSlices.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.excludeOtherPregnancySlices.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyExcludeOtherPregnancySlices.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.excludeLactationSlices.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyExcludeLactationSlices.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.minLMPFactorDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinLMPFactorDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.maxLMPFactorDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMaxLMPFactorDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 21;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.minLMPTestDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinLMPTestDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.maxLMPTestDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMaxLMPTestDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 21;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.useSeahorseInferredStartdate.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyUseSeahorseInferredStartdate.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.excludePregnanciesContainingFlow.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyExcludePregnanciesContainingFlow.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 1;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.maxLMPTolerableFlowDelta.getter()
{
  v8[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaxLMPTolerableFlowDelta.unsafeMutableAddressor();
  uint64_t v3 = *v0;
  uint64_t v4 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v2 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(10).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&isa, v2, (char *)v8);

  swift_bridgeObjectRelease();
  id v5 = v8[0];
  unsigned int v6 = objc_msgSend(v8[0], sel_unsignedIntValue);

  return v6;
}

uint64_t HyperParams.sliceDeltaAnchor.getter()
{
  uint64_t v11 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keySliceDeltaAnchor.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v5 = v1[1];
  swift_bridgeObjectRetain();
  v9[0] = SliceDeltaAnchor.rawValue.getter(1);
  v9[1] = v2;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)v9, MEMORY[0x263F8D310], (char *)&v10);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  Swift::String rawValue = v10;
  swift_bridgeObjectRetain();
  v7.value = SliceDeltaAnchor.init(rawValue:)(rawValue).value;
  if (v7.value == NightingaleTraining_SliceDeltaAnchor_unknownDefault) {
    char v8 = 1;
  }
  else {
    char v8 = v7.value & 1;
  }
  swift_bridgeObjectRelease();
  return v8 & 1;
}

uint64_t HyperParams.minSliceAnchorDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinSliceAnchorDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = -60;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.maxSliceAnchorDelta.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMaxSliceAnchorDelta.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 42;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.pregLabelStartAnchorDelta.getter()
{
  uint64_t v7 = v0;
  started = (uint64_t *)HyperParams.keyPregLabelStartAnchorDelta.unsafeMutableAddressor();
  uint64_t v3 = *started;
  uint64_t v4 = started[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 13;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minDaySHRAvailability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinDaySHRAvailability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minNightSHRAvailability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinNightSHRAvailability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minWristTempAvailability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinWristTempAvailability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minHRVAvailability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinHRVAvailability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minRespiratoryRateAvailability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinRespiratoryRateAvailability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

double HyperParams.minSpO2Availability.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyMinSpO2Availability.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0x3FECCCCCCCCCCCCDLL;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D538], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

Swift::Bool __swiftcall HyperParams.isHRVRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputHRV.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isSpO2Required()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputSpO2.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isRespiratoryRateRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputRespiratoryRate.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isSWTRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputAppleSleepingWristTemperature.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isDaySHRRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputDaySHR10.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isNightSHRRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputNightSHR10.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isSHRRequired()()
{
  Swift::Bool v2 = HyperParams.isDaySHRRequired()();
  swift_retain();
  BOOL v1 = v2 || HyperParams.isNightSHRRequired()();
  swift_release();
  return v1;
}

Swift::Bool __swiftcall HyperParams.isPSMRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputPeriodStartMean.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isPSSRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputPeriodStartStd.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isDaysSinceLastPeriodStartRequired()()
{
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  HyperParams.nightingaleDInputDaysSinceLMS.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  lazy protocol witness table accessor for type [String] and conformance [A]();
  char v1 = Sequence<>.contains(_:)();
  outlined destroy of DefaultStringInterpolation();
  outlined destroy of [A]();
  return v1 & 1;
}

Swift::Bool __swiftcall HyperParams.isCalendarPeriodPredictionRequired()()
{
  Swift::Bool v2 = HyperParams.isPSMRequired()();
  swift_retain();
  BOOL v1 = v2 || HyperParams.isPSSRequired()();
  swift_release();
  return v1;
}

Swift::Bool __swiftcall HyperParams.isCalendarAlgorithmRequired()()
{
  Swift::Bool v2 = HyperParams.isCalendarPeriodPredictionRequired()();
  swift_retain();
  BOOL v1 = v2 || HyperParams.isDaysSinceLastPeriodStartRequired()();
  swift_release();
  return v1;
}

uint64_t HyperParams.hrvStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputHRV.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.spO2StatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputSpO2.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.respiratoryRateStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputRespiratoryRate.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.sWTStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputAppleSleepingWristTemperature.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.daySHRStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputDaySHR10.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.nightSHRStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputNightSHR10.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.pSMStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputPeriodStartMean.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.pSSStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputPeriodStartStd.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.daysSinceLastPeriodStartStatsOption.getter()
{
  uint64_t v4 = v0;
  HyperParams.nightingaleDInputDaysSinceLMS.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  swift_beginAccess();
  swift_bridgeObjectRetain();
  swift_endAccess();
  MEMORY[0x25A2C04B0](&v2);
  outlined destroy of DefaultStringInterpolation();
  if (v2 == 3) {
    unsigned __int8 v3 = 0;
  }
  else {
    unsigned __int8 v3 = v2;
  }
  swift_bridgeObjectRelease();
  return v3;
}

uint64_t HyperParams.metricsProcessEngine.getter()
{
  uint64_t v11 = v0;
  BOOL v1 = (uint64_t *)HyperParams.keyMetricsProcessEngine.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v5 = v1[1];
  swift_bridgeObjectRetain();
  v9[0] = NightingaleDMetricsProcessEngine.rawValue.getter(0);
  v9[1] = v2;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)v9, MEMORY[0x263F8D310], (char *)&v10);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  Swift::String rawValue = v10;
  swift_bridgeObjectRetain();
  v7.value = NightingaleDMetricsProcessEngine.init(rawValue:)(rawValue).value;
  if (v7.value == NightingaleTraining_NightingaleDMetricsProcessEngine_unknownDefault) {
    char v8 = 0;
  }
  else {
    char v8 = v7.value & 1;
  }
  swift_bridgeObjectRelease();
  return v8 & 1;
}

float HyperParams.maxFPR.getter()
{
  v9[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyMaxFPR.unsafeMutableAddressor();
  uint64_t v4 = *v0;
  uint64_t v5 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v3 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0.1).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&isa, v3, (char *)v9);

  swift_bridgeObjectRelease();
  id v6 = v9[0];
  objc_msgSend(v9[0], sel_floatValue);
  float v7 = v1;

  return v7;
}

float HyperParams.outputPostProcThreshold.getter()
{
  v9[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyOutputPostProcThreshold.unsafeMutableAddressor();
  uint64_t v4 = *v0;
  uint64_t v5 = v0[1];
  swift_bridgeObjectRetain();
  unint64_t v3 = type metadata accessor for NSNumber();
  Class isa = NSNumber.__allocating_init(value:)(0.5).super.super.isa;
  HyperParams.parameter<A>(for:default:)(v4, v5, (uint64_t)&isa, v3, (char *)v9);

  swift_bridgeObjectRelease();
  id v6 = v9[0];
  objc_msgSend(v9[0], sel_floatValue);
  float v7 = v1;

  return v7;
}

uint64_t HyperParams.confusionMatrixNumThresholds.getter()
{
  uint64_t v7 = v0;
  float v1 = (uint64_t *)HyperParams.keyConfusionMatrixNumThresholds.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 10;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.latencyBuckets.getter()
{
  v14[1] = 0;
  uint64_t v0 = (uint64_t *)HyperParams.keyLatencyBuckets.unsafeMutableAddressor();
  uint64_t v6 = *v0;
  uint64_t v7 = v0[1];
  swift_bridgeObjectRetain();
  uint64_t v8 = *HyperParams.defaultLatencyBuckets.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  v13[1] = v8;
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [Float]);
  unint64_t v10 = type metadata accessor for NSNumber();
  unint64_t v1 = lazy protocol witness table accessor for type [Float] and conformance [A]();
  uint64_t v12 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))closure #1 in HyperParams.latencyBuckets.getter, 0, v9, v10, MEMORY[0x263F8E628], v1, MEMORY[0x263F8E658], v11);
  outlined destroy of [A]();
  v13[0] = v12;
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [NSNumber]);
  HyperParams.parameter<A>(for:default:)(v6, v7, (uint64_t)v13, v4, (char *)v14);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  unint64_t v2 = lazy protocol witness table accessor for type [NSNumber] and conformance [A]();
  uint64_t v5 = _sSlsE3mapySayqd__Gqd__7ElementQzqd_0_YKXEqd_0_YKs5ErrorRd_0_r0_lF((void (*)(char *, char *))closure #2 in HyperParams.latencyBuckets.getter, 0, v4, MEMORY[0x263F8D5C8], MEMORY[0x263F8E628], v2, MEMORY[0x263F8E658], v11);
  swift_bridgeObjectRelease();
  return v5;
}

NSNumber closure #1 in HyperParams.latencyBuckets.getter@<X0>(float *a1@<X0>, NSNumber *a2@<X8>)
{
  Swift::Float value = *a1;
  type metadata accessor for NSNumber();
  result.super.super.Class isa = NSNumber.__allocating_init(value:)(value).super.super.isa;
  a2->super.super.Class isa = result.super.super.isa;
  return result;
}

id closure #2 in HyperParams.latencyBuckets.getter@<X0>(id *a1@<X0>, _DWORD *a2@<X8>)
{
  id result = objc_msgSend(*a1, sel_floatValue);
  *a2 = v3;
  return result;
}

unint64_t lazy protocol witness table accessor for type [NSNumber] and conformance [A]()
{
  uint64_t v2 = lazy protocol witness table cache variable for type [NSNumber] and conformance [A];
  if (!lazy protocol witness table cache variable for type [NSNumber] and conformance [A])
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract(&demangling cache variable for type metadata for [NSNumber]);
    unint64_t WitnessTable = swift_getWitnessTable();
    atomic_store(WitnessTable, (unint64_t *)&lazy protocol witness table cache variable for type [NSNumber] and conformance [A]);
    return WitnessTable;
  }
  return v2;
}

uint64_t HyperParams.heartRateFwEnd10PctModelName.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyHeartRateFwEnd10PctModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultHeartRateFwEnd10PctModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.heartRatePeriod10PctModelName.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyHeartRatePeriod10PctModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultHeartRatePeriod10PctModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.wTmpFwEndLstmModelName.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyWTmpFwEndLstmModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultWTmpFwEndLstmModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.wTmpFwEndRFModelName.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyWTmpFwEndRFModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultWTmpFwEndRFModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.wTmpPeriodLstmModelName.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyWTmpPeriodLstmModelName.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultWTmpPeriodLstmModelName.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.heartRatePeriodTFModelNames.getter()
{
  uint64_t v9 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyHeartRatePeriodTFModelNames.unsafeMutableAddressor();
  uint64_t v5 = *v1;
  uint64_t v6 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v4 = *HyperParams.defaultHeartRatePeriodTFModelNames.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  uint64_t v7 = v4;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v5, v6, (uint64_t)&v7, v2, (char *)&v8);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  return v8;
}

uint64_t HyperParams.heartRatePeriodEnsembleModelNames.getter()
{
  uint64_t v9 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyHeartRatePeriodEnsembleModelNames.unsafeMutableAddressor();
  uint64_t v5 = *v1;
  uint64_t v6 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v4 = *HyperParams.defaultHeartRatePeriodEnsembleModelNames.unsafeMutableAddressor();
  swift_bridgeObjectRetain();
  uint64_t v7 = v4;
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for [String]);
  HyperParams.parameter<A>(for:default:)(v5, v6, (uint64_t)&v7, v2, (char *)&v8);
  outlined destroy of [A]();
  swift_bridgeObjectRelease();
  return v8;
}

uint64_t HyperParams.recipeId.getter()
{
  uint64_t v10 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyRecipeId.unsafeMutableAddressor();
  uint64_t v4 = *v1;
  uint64_t v7 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v2 = HyperParams.defaultRecipeId.unsafeMutableAddressor();
  uint64_t v5 = *(void *)v2;
  uint64_t v6 = *((void *)v2 + 1);
  swift_bridgeObjectRetain();
  v8[0] = v5;
  v8[1] = v6;
  HyperParams.parameter<A>(for:default:)(v4, v7, (uint64_t)v8, MEMORY[0x263F8D310], (char *)&v9);
  outlined destroy of DefaultStringInterpolation();
  swift_bridgeObjectRelease();
  return v9;
}

uint64_t HyperParams.useFactorStartDateAsLMP.getter()
{
  uint64_t v7 = v0;
  started = (uint64_t *)HyperParams.keyUseFactorStartDateAsLMP.unsafeMutableAddressor();
  uint64_t v3 = *started;
  uint64_t v4 = started[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.useTestDateAsLMP.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyUseTestDateAsLMP.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  char v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D4F8], &v6);
  swift_bridgeObjectRelease();
  return v6 & 1;
}

uint64_t HyperParams.dropNegativeSlicesForInferredFactorLMP.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyDropNegativeSlicesForInferredFactorLMP.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.dropNegativeSlicesForInferredTestLMP.getter()
{
  uint64_t v7 = v0;
  unint64_t v1 = (uint64_t *)HyperParams.keyDropNegativeSlicesForInferredTestLMP.unsafeMutableAddressor();
  uint64_t v3 = *v1;
  uint64_t v4 = v1[1];
  swift_bridgeObjectRetain();
  uint64_t v5 = 0;
  HyperParams.parameter<A>(for:default:)(v3, v4, (uint64_t)&v5, MEMORY[0x263F8D6C8], (char *)&v6);
  swift_bridgeObjectRelease();
  return v6;
}

uint64_t HyperParams.stringToTregnancyStartSource(_:)()
{
  swift_bridgeObjectRetain();
  String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("FirstDayOfLastMenstrualPeriod", 0x1DuLL, 1);
  swift_bridgeObjectRetain();
  char v5 = static String.== infix(_:_:)();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  if (v5)
  {
    swift_bridgeObjectRelease();
    return 0;
  }
  else
  {
    swift_bridgeObjectRelease();
    swift_bridgeObjectRetain();
    String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EstimatedDueDate", 0x10uLL, 1);
    swift_bridgeObjectRetain();
    char v3 = static String.== infix(_:_:)();
    swift_bridgeObjectRelease();
    swift_bridgeObjectRelease();
    if (v3)
    {
      swift_bridgeObjectRelease();
      return 1;
    }
    else
    {
      swift_bridgeObjectRelease();
      swift_bridgeObjectRetain();
      String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EstimatedGestationalAge", 0x17uLL, 1);
      swift_bridgeObjectRetain();
      char v2 = static String.== infix(_:_:)();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (v2)
      {
        swift_bridgeObjectRelease();
        return 2;
      }
      else
      {
        swift_bridgeObjectRelease();
        swift_bridgeObjectRetain();
        String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EmbryoTransfer", 0xEuLL, 1);
        swift_bridgeObjectRetain();
        char v1 = static String.== infix(_:_:)();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        swift_bridgeObjectRelease();
        if (v1) {
          return 3;
        }
        else {
          return 4;
        }
      }
    }
  }
}

uint64_t HyperParams.pregnancyStartSourceToString(_:)(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("FirstDayOfLastMenstrualPeriod", 0x1DuLL, 1)._countAndFlagsBits;
      case 1:
        return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EstimatedDueDate", 0x10uLL, 1)._countAndFlagsBits;
      case 2:
        return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EstimatedGestationalAge", 0x17uLL, 1)._countAndFlagsBits;
      case 3:
        return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("EmbryoTransfer", 0xEuLL, 1)._countAndFlagsBits;
      case 4:
        return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Unspecified", 0xBuLL, 1)._countAndFlagsBits;
      default:
        JUMPOUT(0);
    }
  }
  return String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("Unspecified", 0xBuLL, 1)._countAndFlagsBits;
}

uint64_t HyperParams.deinit()
{
  outlined destroy of [A]();
  outlined destroy of [A]();
  outlined destroy of [A]();
  return v1;
}

uint64_t HyperParams.__deallocating_deinit()
{
  return swift_deallocClassInstance();
}

uint64_t type metadata accessor for HyperParams()
{
  return self;
}

id @nonobjc NSNumber.init(value:)(uint64_t a1)
{
  return objc_msgSend(v1, sel_initWithInteger_, a1);
}

id @nonobjc NSNumber.init(value:)()
{
  return objc_msgSend(v0, sel_initWithDouble_);
}

{
  void *v0;

  return objc_msgSend(v0, sel_initWithFloat_);
}

uint64_t static NightingaleTelemetry.sendNightingaleReachTelemetryLazy(taskId:location:useCase:errorCode:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6)
{
  char v13 = *a5;
  uint64_t v8 = NightingaleTelemetry.logger.unsafeMutableAddressor();
  swift_beginAccess();
  uint64_t v15 = *v8;
  swift_retain();
  swift_endAccess();
  Swift::String v6 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("com.apple.priml.NightingaleTraining.PluginReach", 0x2FuLL, 1);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  uint64_t v16 = swift_allocObject();
  *(void *)(v16 + 16) = a1;
  *(void *)(v16 + 24) = a2;
  *(void *)(v16 + 32) = a3;
  *(void *)(v16 + 40) = a4;
  *(unsigned char *)(v16 + 48) = v13;
  *(void *)(v16 + 56) = a6;
  ((void (*)(uint64_t, void *, uint64_t (*)()))v15)(v6._countAndFlagsBits, v6._object, partial apply for closure #1 in static NightingaleTelemetry.sendNightingaleReachTelemetryLazy(taskId:location:useCase:errorCode:));
  swift_release();
  swift_bridgeObjectRelease();
  return swift_release();
}

uint64_t static NightingaleTelemetry.sendNightingaleShadowEvaluationTelemetryLazy(flycatcherResults:)(void *__src)
{
  memcpy(__dst, __src, sizeof(__dst));
  char v3 = NightingaleTelemetry.logger.unsafeMutableAddressor();
  swift_beginAccess();
  uint64_t v4 = *v3;
  swift_retain();
  swift_endAccess();
  Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("com.apple.hid.cycle_tracking.pfl_shadow_evaluation", 0x32uLL, 1);
  outlined retain of FlycatcherTelemetrics?();
  uint64_t v5 = swift_allocObject();
  memcpy((void *)(v5 + 16), __dst, 0x118uLL);
  ((void (*)(uint64_t, void *, uint64_t (*)(), uint64_t))v4)(v1._countAndFlagsBits, v1._object, partial apply for closure #1 in static NightingaleTelemetry.sendNightingaleShadowEvaluationTelemetryLazy(flycatcherResults:), v5);
  swift_release();
  swift_bridgeObjectRelease();
  return swift_release();
}

NightingaleTraining::HIDPFLUseCase_optional __swiftcall HIDPFLUseCase.init(rawValue:)(Swift::Int rawValue)
{
  switch(rawValue)
  {
    case 0:
      char v3 = 0;
LABEL_32:
      *Swift::String v1 = v3;
      return (NightingaleTraining::HIDPFLUseCase_optional)rawValue;
    case 1:
      char v3 = 1;
      goto LABEL_32;
    case 2:
      char v3 = 2;
      goto LABEL_32;
    case 3:
      char v3 = 3;
      goto LABEL_32;
    case 4:
      char v3 = 4;
      goto LABEL_32;
    case 5:
      char v3 = 5;
      goto LABEL_32;
    case 6:
      char v3 = 6;
      goto LABEL_32;
    case 7:
      char v3 = 7;
      goto LABEL_32;
    case 8:
      char v3 = 8;
      goto LABEL_32;
    case 9:
      char v3 = 9;
      goto LABEL_32;
    case 10:
      char v3 = 10;
      goto LABEL_32;
    case 11:
      char v3 = 11;
      goto LABEL_32;
    case 12:
      char v3 = 12;
      goto LABEL_32;
    case 13:
      char v3 = 13;
      goto LABEL_32;
    case 14:
      char v3 = 14;
      goto LABEL_32;
  }
  *Swift::String v1 = 15;
  return (NightingaleTraining::HIDPFLUseCase_optional)rawValue;
}

uint64_t HIDPFLUseCase.rawValue.getter()
{
  switch(*v0)
  {
    case 1:
      uint64_t v2 = 1;
      break;
    case 2:
      uint64_t v2 = 2;
      break;
    case 3:
      uint64_t v2 = 3;
      break;
    case 4:
      uint64_t v2 = 4;
      break;
    case 5:
      uint64_t v2 = 5;
      break;
    case 6:
      uint64_t v2 = 6;
      break;
    case 7:
      uint64_t v2 = 7;
      break;
    case 8:
      uint64_t v2 = 8;
      break;
    case 9:
      uint64_t v2 = 9;
      break;
    case 0xA:
      uint64_t v2 = 10;
      break;
    case 0xB:
      uint64_t v2 = 11;
      break;
    case 0xC:
      uint64_t v2 = 12;
      break;
    case 0xD:
      uint64_t v2 = 13;
      break;
    case 0xE:
      uint64_t v2 = 14;
      break;
    default:
      uint64_t v2 = 0;
      break;
  }
  return v2;
}

uint64_t protocol witness for static Equatable.== infix(_:_:) in conformance HIDPFLUseCase()
{
  return == infix<A>(_:_:)() & 1;
}

uint64_t protocol witness for Hashable.hashValue.getter in conformance HIDPFLUseCase()
{
  return RawRepresentable<>.hashValue.getter();
}

uint64_t protocol witness for Hashable.hash(into:) in conformance HIDPFLUseCase()
{
  return RawRepresentable<>.hash(into:)();
}

uint64_t protocol witness for Hashable._rawHashValue(seed:) in conformance HIDPFLUseCase()
{
  return RawRepresentable<>._rawHashValue(seed:)();
}

NightingaleTraining::HIDPFLUseCase_optional protocol witness for RawRepresentable.init(rawValue:) in conformance HIDPFLUseCase(Swift::Int *a1)
{
  return HIDPFLUseCase.init(rawValue:)(*a1);
}

uint64_t protocol witness for RawRepresentable.rawValue.getter in conformance HIDPFLUseCase@<X0>(uint64_t *a1@<X8>)
{
  uint64_t result = HIDPFLUseCase.rawValue.getter();
  *a1 = result;
  return result;
}

uint64_t @nonobjc AnalyticsSendEventLazy(_:_:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  swift_bridgeObjectRetain();
  id v9 = (id)MEMORY[0x25A2C0590](a1, a2);
  swift_retain();
  uint64_t v17 = a3;
  uint64_t v18 = a4;
  uint64_t aBlock = MEMORY[0x263EF8330];
  int v13 = 1107296256;
  int v14 = 0;
  uint64_t v15 = thunk for @escaping @callee_guaranteed () -> (@owned [String : NSObject]?);
  uint64_t v16 = &block_descriptor_1;
  uint64_t v8 = _Block_copy(&aBlock);
  char v11 = AnalyticsSendEventLazy();
  _Block_release(v8);
  swift_release();

  swift_bridgeObjectRelease();
  return v11 & 1;
}

uint64_t (**NightingaleTelemetry.logger.unsafeMutableAddressor())()
{
  return &static NightingaleTelemetry.logger;
}

uint64_t closure #1 in static NightingaleTelemetry.sendNightingaleReachTelemetryLazy(taskId:location:useCase:errorCode:)(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (String, NSObject));
  _allocateUninitializedArray<A>(_:)();
  uint64_t v8 = v4;
  Swift::String *v4 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("taskId", 6uLL, 1);
  swift_bridgeObjectRetain();
  v8[1]._countAndFlagsBits = MEMORY[0x25A2C0590](a1, a2);
  *(Swift::String *)((char *)v8 + 24) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("location", 8uLL, 1);
  swift_bridgeObjectRetain();
  v8[2]._object = (void *)MEMORY[0x25A2C0590](a3, a4);
  v8[3] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("useCase", 7uLL, 1);
  HIDPFLUseCase.rawValue.getter();
  v8[4]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v8 + 72) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("errorCode", 9uLL, 1);
  v8[5]._object = Int._bridgeToObjectiveC()().super.super.isa;
  _finalizeUninitializedArray<A>(_:)();
  swift_bridgeObjectRelease();
  swift_bridgeObjectRelease();
  type metadata accessor for NSObject();
  return Dictionary.init(dictionaryLiteral:)();
}

uint64_t sub_257D13774()
{
  return swift_deallocObject();
}

uint64_t partial apply for closure #1 in static NightingaleTelemetry.sendNightingaleReachTelemetryLazy(taskId:location:useCase:errorCode:)()
{
  return closure #1 in static NightingaleTelemetry.sendNightingaleReachTelemetryLazy(taskId:location:useCase:errorCode:)(v0[2], v0[3], v0[4], v0[5]);
}

uint64_t closure #1 in static NightingaleTelemetry.sendNightingaleShadowEvaluationTelemetryLazy(flycatcherResults:)(uint64_t *a1)
{
  __swift_instantiateConcreteTypeFromMangledName(&demangling cache variable for type metadata for (String, NSObject));
  _allocateUninitializedArray<A>(_:)();
  uint64_t v5 = v1;
  *Swift::String v1 = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("recipeId", 8uLL, 1);
  uint64_t v3 = *a1;
  uint64_t v6 = a1[1];
  swift_bridgeObjectRetain();
  v5[1]._countAndFlagsBits = MEMORY[0x25A2C0590](v3, v6);
  *(Swift::String *)((char *)v5 + 24) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("cycleIdx", 8uLL, 1);
  v5[2]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[3] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("ensembleLogicId", 0xFuLL, 1);
  v5[4]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 72) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("selectedModelId", 0xFuLL, 1);
  v5[5]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[6] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("abserr", 6uLL, 1);
  v5[7]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 120) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("widthOneSide", 0xCuLL, 1);
  v5[8]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[9] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("widthTwoSide", 0xCuLL, 1);
  v5[10]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 168) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("coverage", 8uLL, 1);
  v5[11]._object = Bool._bridgeToObjectiveC()().super.super.isa;
  v5[12] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("baselineMean", 0xCuLL, 1);
  v5[13]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 216) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("baselineStd", 0xBuLL, 1);
  v5[14]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[15] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("numHistCycles", 0xDuLL, 1);
  v5[16]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 264) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("cycleLen", 8uLL, 1);
  v5[17]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[18] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysToModel0DRS", 0xFuLL, 1);
  v5[19]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 312) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysToModel1DRS", 0xFuLL, 1);
  v5[20]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[21] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysToModel2DRS", 0xFuLL, 1);
  v5[22]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 360) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model0Width", 0xBuLL, 1);
  v5[23]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[24] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model1Width", 0xBuLL, 1);
  v5[25]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 408) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("model2Width", 0xBuLL, 1);
  v5[26]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[27] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysSinceLastPeriod", 0x13uLL, 1);
  v5[28]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 456) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysSinceLastContraceptionEnd", 0x1DuLL, 1);
  v5[29]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[30] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysSinceLastPregnancyEnd", 0x19uLL, 1);
  v5[31]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 504) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("daysSinceLastLactationEnd", 0x19uLL, 1);
  v5[32]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[33] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceDayHRCount", 0xFuLL, 1);
  v5[34]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 552) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceDayHRMean", 0xEuLL, 1);
  v5[35]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[36] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceDayHRStd", 0xDuLL, 1);
  v5[37]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 600) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceNightHRCount", 0x11uLL, 1);
  v5[38]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[39] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceNightHRMean", 0x10uLL, 1);
  v5[40]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 648) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("sliceNightHRStd", 0xFuLL, 1);
  v5[41]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[42] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("numOutliers", 0xBuLL, 1);
  v5[43]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 696) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("numCycles", 9uLL, 1);
  v5[44]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[45] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("fullCycleLengthMean", 0x13uLL, 1);
  v5[46]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 744) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("fullCycleLengthStd", 0x12uLL, 1);
  v5[47]._object = Int._bridgeToObjectiveC()().super.super.isa;
  v5[48] = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("bmi", 3uLL, 1);
  v5[49]._countAndFlagsBits = (uint64_t)Int._bridgeToObjectiveC()().super.super.isa;
  *(Swift::String *)((char *)v5 + 792) = String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)("age", 3uLL, 1);
  v5[50]._object = Int._bridgeToObjectiveC()().super.super.isa;
  _finalizeUninitializedArray<A>(_:)();
  swift_bridgeObjectRelease();
  type metadata accessor for NSObject();
  return Dictionary.init(dictionaryLiteral:)();
}

uint64_t sub_257D140E0()
{
  return swift_deallocObject();
}

uint64_t partial apply for closure #1 in static NightingaleTelemetry.sendNightingaleShadowEvaluationTelemetryLazy(flycatcherResults:)()
{
  return closure #1 in static NightingaleTelemetry.sendNightingaleShadowEvaluationTelemetryLazy(flycatcherResults:)((uint64_t *)(v0 + 16));
}

unint64_t lazy protocol witness table accessor for type HIDPFLUseCase and conformance HIDPFLUseCase()
{
  uint64_t v2 = lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase;
  if (!lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase)
  {
    unint64_t WitnessTable = swift_getWitnessTable();
    atomic_store(WitnessTable, (unint64_t *)&lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase);
    return WitnessTable;
  }
  return v2;
}

{
  unint64_t WitnessTable;
  uint64_t v2;

  uint64_t v2 = lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase;
  if (!lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase)
  {
    unint64_t WitnessTable = swift_getWitnessTable();
    atomic_store(WitnessTable, (unint64_t *)&lazy protocol witness table cache variable for type HIDPFLUseCase and conformance HIDPFLUseCase);
    return WitnessTable;
  }
  return v2;
}

unint64_t base witness table accessor for Equatable in HIDPFLUseCase()
{
  return lazy protocol witness table accessor for type HIDPFLUseCase and conformance HIDPFLUseCase();
}

uint64_t getEnumTagSinglePayload for HIDPFLUseCase(unsigned __int8 *a1, unsigned int a2)
{
  if (a2)
  {
    if (a2 <= 0xF1) {
      goto LABEL_15;
    }
    unsigned int v7 = ((a2 + 14) >> 8) + 1;
    int v8 = 1;
    if (v7 >= 0x100)
    {
      if (v7 >= 0x10000) {
        int v2 = 4;
      }
      else {
        int v2 = 2;
      }
      int v8 = v2;
    }
    if (v8 == 1) {
      int v6 = a1[1];
    }
    else {
      int v6 = v8 == 2 ? *(unsigned __int16 *)(a1 + 1) : *(_DWORD *)(a1 + 1);
    }
    if (v6)
    {
      int v5 = (*a1 | ((v6 - 1) << 8)) + 241;
    }
    else
    {
LABEL_15:
      int v3 = *a1 - 15;
      if (v3 < 0) {
        int v3 = -1;
      }
      int v5 = v3;
    }
  }
  else
  {
    int v5 = -1;
  }
  return (v5 + 1);
}

unsigned char *storeEnumTagSinglePayload for HIDPFLUseCase(unsigned char *result, unsigned int a2, unsigned int a3)
{
  int v7 = 0;
  if (a3 > 0xF1)
  {
    unsigned int v5 = ((a3 + 14) >> 8) + 1;
    int v6 = 1;
    if (v5 >= 0x100)
    {
      if (v5 >= 0x10000) {
        int v3 = 4;
      }
      else {
        int v3 = 2;
      }
      int v6 = v3;
    }
    int v7 = v6;
  }
  if (a2 > 0xF1)
  {
    unsigned int v4 = ((a2 - 242) >> 8) + 1;
    *uint64_t result = a2 + 14;
    if (v7)
    {
      if (v7 == 1)
      {
        result[1] = v4;
      }
      else if (v7 == 2)
      {
        *(_WORD *)(result + 1) = v4;
      }
      else
      {
        *(_DWORD *)(result + 1) = v4;
      }
    }
  }
  else
  {
    if (v7)
    {
      if (v7 == 1)
      {
        result[1] = 0;
      }
      else if (v7 == 2)
      {
        *(_WORD *)(result + 1) = 0;
      }
      else
      {
        *(_DWORD *)(result + 1) = 0;
      }
    }
    if (a2) {
      *uint64_t result = a2 + 14;
    }
  }
  return result;
}

ValueMetadata *type metadata accessor for HIDPFLUseCase()
{
  return &type metadata for HIDPFLUseCase;
}

ValueMetadata *type metadata accessor for NightingaleTelemetry()
{
  return &type metadata for NightingaleTelemetry;
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void *)(a2 + 40);
  swift_retain();
  uint64_t result = a1;
  *(void *)(a1 + 32) = v4;
  *(void *)(a1 + 40) = v5;
  return result;
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

id ha_get_log()
{
  if (ha_get_log_onceToken != -1) {
    dispatch_once(&ha_get_log_onceToken, &__block_literal_global);
  }
  uint64_t v0 = (void *)ha_get_log_log;
  return v0;
}

uint64_t __ha_get_log_block_invoke()
{
  ha_get_log_log = (uint64_t)os_log_create("com.apple.NightingaleAlgs", "framework");
  return MEMORY[0x270F9A758]();
}

void Nightingale::preprocess_temperature_inputs_for_hist_cycle(void *a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = (Nightingale::lunaExtractedData *)(a2 - 43);
  Nightingale::extract_and_validate_temperature_data(a1, a3, (uint64_t)__p);
  Nightingale::truncate_temperature_data((Nightingale *)__p, v5, (uint64_t)v6);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)__p = *(_OWORD *)v6;
  uint64_t v11 = v7;
  v6[1] = 0;
  uint64_t v7 = 0;
  v6[0] = 0;
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__move_assign((uint64_t)v12, v8);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__move_assign((uint64_t)v13, v9);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v9);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v8);
  if (v6[0])
  {
    v6[1] = v6[0];
    operator delete(v6[0]);
  }
  Nightingale::preprocess_all_temperature_data((Nightingale *)__p, a4);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v13);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v12);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_257D14854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  Nightingale::lunaExtractedData::~lunaExtractedData((Nightingale::lunaExtractedData *)va);
  _Unwind_Resume(a1);
}

void Nightingale::extract_and_validate_temperature_data(void *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 48) = 0;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_DWORD *)(a3 + 56) = 1065353216;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_DWORD *)(a3 + 96) = 1065353216;
  v139 = 0;
  v140 = 0;
  v141 = 0;
  __p = 0;
  v137 = 0;
  v138 = 0;
  v133 = 0;
  uint64_t v134 = 0;
  v135 = 0;
  long long v130 = 0u;
  long long v131 = 0u;
  int v132 = 1065353216;
  int v126 = a2;
  if ((int)(-286331153 * ((uint64_t)(a1[1] - *a1) >> 2)) < 1)
  {
    v39 = 0;
    v40 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = -286331153 * ((uint64_t)(a1[1] - *a1) >> 2);
    do
    {
      uint64_t v6 = *a1 + 60 * (v5 - 1);
      if (*(unsigned char *)(v6 + 56))
      {
        char v142 = 0;
        if (!*(unsigned char *)(v6 + 56)) {
          goto LABEL_193;
        }
        char v142 = *(unsigned char *)(v6 + 48);
        uint64_t v7 = v140;
        if (v140 >= v141)
        {
          id v9 = v139;
          uint64_t v10 = (v140 - v139) >> 2;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v12 = v141 - v139;
          if ((v141 - v139) >> 1 > v11) {
            unint64_t v11 = v12 >> 1;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v11;
          }
          if (v13)
          {
            int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v141, v13);
            id v9 = v139;
            uint64_t v7 = v140;
          }
          else
          {
            int v14 = 0;
          }
          uint64_t v15 = &v14[4 * v10];
          *(_DWORD *)uint64_t v15 = *(_DWORD *)v6;
          int v8 = v15 + 4;
          while (v7 != v9)
          {
            int v16 = *((_DWORD *)v7 - 1);
            v7 -= 4;
            *((_DWORD *)v15 - 1) = v16;
            v15 -= 4;
          }
          v139 = v15;
          v140 = v8;
          v141 = &v14[4 * v13];
          if (v9) {
            operator delete(v9);
          }
        }
        else
        {
          *(_DWORD *)v140 = *(_DWORD *)v6;
          int v8 = v7 + 4;
        }
        v140 = v8;
        if (!*(unsigned char *)(v6 + 56)) {
LABEL_193:
        }
          std::__throw_bad_optional_access[abi:ne180100]();
        uint64_t v17 = v137;
        if (v137 >= v138)
        {
          uint64_t v19 = (char *)__p;
          uint64_t v20 = (v137 - (unsigned char *)__p) >> 2;
          unint64_t v21 = v20 + 1;
          if ((unint64_t)(v20 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v22 = v138 - (unsigned char *)__p;
          if ((v138 - (unsigned char *)__p) >> 1 > v21) {
            unint64_t v21 = v22 >> 1;
          }
          if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23)
          {
            uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v138, v23);
            uint64_t v19 = (char *)__p;
            uint64_t v17 = v137;
          }
          else
          {
            uint64_t v24 = 0;
          }
          uint64_t v25 = &v24[4 * v20];
          *(_DWORD *)uint64_t v25 = *(_DWORD *)(v6 + 52);
          uint64_t v18 = v25 + 4;
          while (v17 != v19)
          {
            int v26 = *((_DWORD *)v17 - 1);
            v17 -= 4;
            *((_DWORD *)v25 - 1) = v26;
            v25 -= 4;
          }
          __p = v25;
          v137 = v18;
          v138 = &v24[4 * v23];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          *(_DWORD *)v137 = *(_DWORD *)(v6 + 52);
          uint64_t v18 = v17 + 4;
        }
        v137 = v18;
        if (v4 >= v135)
        {
          unint64_t v28 = (unint64_t)v133;
          uint64_t v29 = v4 - (unsigned char *)v133;
          uint64_t v30 = v4 - (unsigned char *)v133 + 1;
          if (v30 < 0) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v31 = v135 - (unsigned char *)v133;
          if (2 * (v135 - (unsigned char *)v133) > (unint64_t)v30) {
            uint64_t v30 = 2 * v31;
          }
          if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v32 = v30;
          }
          if (v32) {
            uint64_t v33 = (char *)operator new(v32);
          }
          else {
            uint64_t v33 = 0;
          }
          uint64_t v34 = &v33[v29];
          v33[v29] = v142;
          uint64_t v27 = (uint64_t)&v33[v29 + 1];
          if (v4 != (char *)v28)
          {
            uint64_t v35 = &v4[~v28];
            do
            {
              char v36 = *--v4;
              (v35--)[(void)v33] = v36;
            }
            while (v4 != (char *)v28);
            uint64_t v4 = (char *)v133;
            uint64_t v34 = v33;
          }
          v133 = v34;
          uint64_t v134 = (uint64_t)&v33[v29 + 1];
          v135 = &v33[v32];
          if (v4) {
            operator delete(v4);
          }
        }
        else
        {
          char *v4 = v142;
          uint64_t v27 = (uint64_t)(v4 + 1);
        }
        uint64_t v134 = v27;
        if (!std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::find<unsigned char>(&v130, (unsigned __int8 *)&v142))
        {
          __src = &v142;
          uint64_t v37 = (char *)std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, (unsigned __int8 *)&v142, (uint64_t)&std::piecewise_construct, (unsigned char **)&__src);
          std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v37 + 24, 0, 0, 0);
        }
        uint64_t v4 = (char *)v27;
      }
    }
    while (v5-- > 1);
    v39 = (int *)v139;
    v40 = v140;
    a2 = v126;
  }
  uint64_t v41 = (v40 - (char *)v39) >> 2;
  __src = 0;
  v128 = 0;
  unint64_t v129 = 0;
  if (v41)
  {
    int v42 = v39[v41 - 1];
    int v43 = a2 - v42;
    if (a2 >= v42)
    {
      int v44 = -1;
      do
      {
        int v45 = *v39++;
        ++v44;
      }
      while (v45 > a2);
    }
    else
    {
      int v44 = 0;
    }
    int v123 = a2 - v42;
    if ((v43 & 0x80000000) == 0)
    {
      int v46 = 0;
      int v124 = v43 + 1;
      int v125 = v41;
      while (1)
      {
        int v47 = a2 - v46;
        if (v44 >= (int)v41) {
          break;
        }
        v49 = v128;
        unint64_t v48 = v129;
        if (v47 != *(_DWORD *)&v139[4 * v44]) {
          goto LABEL_74;
        }
        if ((unint64_t)v128 >= v129)
        {
          v75 = __src;
          uint64_t v76 = ((char *)v128 - (unsigned char *)__src) >> 2;
          unint64_t v77 = v76 + 1;
          if ((unint64_t)(v76 + 1) >> 62) {
LABEL_199:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          uint64_t v78 = v129 - (void)__src;
          if ((uint64_t)(v129 - (void)__src) >> 1 > v77) {
            unint64_t v77 = v78 >> 1;
          }
          if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v79 = v77;
          }
          if (v79)
          {
            v80 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v129, v79);
            v75 = __src;
            v49 = v128;
          }
          else
          {
            v80 = 0;
          }
          v81 = &v80[4 * v76];
          *(_DWORD *)v81 = v47;
          v50 = v81 + 4;
          while (v49 != v75)
          {
            int v82 = *--v49;
            *((_DWORD *)v81 - 1) = v82;
            v81 -= 4;
          }
          __src = v81;
          v128 = v50;
          unint64_t v129 = (unint64_t)&v80[4 * v79];
          if (v75) {
            operator delete(v75);
          }
        }
        else
        {
          _DWORD *v128 = v47;
          v50 = v49 + 1;
        }
        v128 = v50;
        v83 = (uint64_t *)v131;
        if ((void)v131)
        {
          int v84 = *((unsigned __int8 *)v133 + v44);
          if (*((float *)__p + v44) <= 0.0) {
            float v85 = NAN;
          }
          else {
            float v85 = *((float *)__p + v44);
          }
          do
          {
            v86 = (unsigned __int8 *)(v83 + 2);
            if (*((unsigned __int8 *)v83 + 16) == v84)
            {
              v143[0] = v83 + 2;
              v87 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, v86, (uint64_t)&std::piecewise_construct, v143);
              v88 = v87;
              v89 = (float *)v87[4];
              uint64_t v90 = (uint64_t)(v87 + 5);
              unint64_t v91 = v87[5];
              if ((unint64_t)v89 >= v91)
              {
                v98 = (float *)v87[3];
                uint64_t v99 = v89 - v98;
                if ((unint64_t)(v99 + 1) >> 62) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v100 = v91 - (void)v98;
                unint64_t v101 = (uint64_t)(v91 - (void)v98) >> 1;
                if (v101 <= v99 + 1) {
                  unint64_t v101 = v99 + 1;
                }
                if (v100 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v102 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v102 = v101;
                }
                if (v102)
                {
                  v103 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v90, v102);
                  v98 = (float *)v88[3];
                  v89 = (float *)v88[4];
                }
                else
                {
                  v103 = 0;
                }
                v107 = (float *)&v103[4 * v99];
                float *v107 = v85;
                v97 = v107 + 1;
                while (v89 != v98)
                {
                  int v108 = *((_DWORD *)v89-- - 1);
                  *((_DWORD *)v107-- - 1) = v108;
                }
LABEL_157:
                v88[3] = v107;
                v88[4] = v97;
                v88[5] = &v103[4 * v102];
                if (v98) {
                  operator delete(v98);
                }
                goto LABEL_159;
              }
              float *v89 = v85;
              v92 = v89 + 1;
            }
            else
            {
              v143[0] = v83 + 2;
              v93 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, v86, (uint64_t)&std::piecewise_construct, v143);
              v88 = v93;
              v94 = (char *)v93[4];
              uint64_t v95 = (uint64_t)(v93 + 5);
              unint64_t v96 = v93[5];
              if ((unint64_t)v94 >= v96)
              {
                v98 = (float *)v93[3];
                uint64_t v104 = (v94 - (char *)v98) >> 2;
                if ((unint64_t)(v104 + 1) >> 62) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v105 = v96 - (void)v98;
                unint64_t v106 = (uint64_t)(v96 - (void)v98) >> 1;
                if (v106 <= v104 + 1) {
                  unint64_t v106 = v104 + 1;
                }
                if (v105 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v102 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v102 = v106;
                }
                if (v102)
                {
                  v103 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v95, v102);
                  v98 = (float *)v88[3];
                  v94 = (char *)v88[4];
                }
                else
                {
                  v103 = 0;
                }
                v107 = (float *)&v103[4 * v104];
                float *v107 = NAN;
                v97 = v107 + 1;
                while (v94 != (char *)v98)
                {
                  int v109 = *((_DWORD *)v94 - 1);
                  v94 -= 4;
                  *((_DWORD *)v107-- - 1) = v109;
                }
                goto LABEL_157;
              }
              *(_DWORD *)v94 = 2143289344;
              v92 = (float *)(v94 + 4);
            }
            v97 = v92;
LABEL_159:
            v88[4] = v97;
            v83 = (uint64_t *)*v83;
          }
          while (v83);
        }
        ++v44;
LABEL_161:
        ++v46;
        a2 = v126;
        LODWORD(v41) = v125;
        if (v46 == v124) {
          goto LABEL_162;
        }
      }
      v49 = v128;
      unint64_t v48 = v129;
LABEL_74:
      if ((unint64_t)v49 >= v48)
      {
        v52 = __src;
        uint64_t v53 = ((char *)v49 - (unsigned char *)__src) >> 2;
        unint64_t v54 = v53 + 1;
        if ((unint64_t)(v53 + 1) >> 62) {
          goto LABEL_199;
        }
        uint64_t v55 = v48 - (void)__src;
        if (v55 >> 1 > v54) {
          unint64_t v54 = v55 >> 1;
        }
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v56 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v56 = v54;
        }
        if (v56)
        {
          v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v129, v56);
          v52 = __src;
          v49 = v128;
        }
        else
        {
          v57 = 0;
        }
        v58 = &v57[4 * v53];
        *(_DWORD *)v58 = v47;
        v51 = v58 + 4;
        while (v49 != v52)
        {
          int v59 = *--v49;
          *((_DWORD *)v58 - 1) = v59;
          v58 -= 4;
        }
        __src = v58;
        v128 = v51;
        unint64_t v129 = (unint64_t)&v57[4 * v56];
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        _DWORD *v49 = v47;
        v51 = v49 + 1;
      }
      v128 = v51;
      for (i = (unsigned __int8 *)v131; i; i = *(unsigned __int8 **)i)
      {
        v143[0] = i + 16;
        v61 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, i + 16, (uint64_t)&std::piecewise_construct, v143);
        v62 = v61;
        v63 = (char *)v61[4];
        uint64_t v64 = (uint64_t)(v61 + 5);
        unint64_t v65 = v61[5];
        if ((unint64_t)v63 >= v65)
        {
          v67 = (char *)v61[3];
          uint64_t v68 = (v63 - v67) >> 2;
          if ((unint64_t)(v68 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v69 = v65 - (void)v67;
          unint64_t v70 = (uint64_t)(v65 - (void)v67) >> 1;
          if (v70 <= v68 + 1) {
            unint64_t v70 = v68 + 1;
          }
          if (v69 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v71 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v71 = v70;
          }
          if (v71)
          {
            v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v64, v71);
            v67 = (char *)v62[3];
            v63 = (char *)v62[4];
          }
          else
          {
            v72 = 0;
          }
          v73 = &v72[4 * v68];
          *(_DWORD *)v73 = 2143289344;
          v66 = v73 + 4;
          while (v63 != v67)
          {
            int v74 = *((_DWORD *)v63 - 1);
            v63 -= 4;
            *((_DWORD *)v73 - 1) = v74;
            v73 -= 4;
          }
          v62[3] = v73;
          v62[4] = v66;
          v62[5] = &v72[4 * v71];
          if (v67) {
            operator delete(v67);
          }
        }
        else
        {
          *(_DWORD *)v63 = 2143289344;
          v66 = v63 + 4;
        }
        v62[4] = v66;
      }
      goto LABEL_161;
    }
LABEL_162:
    v110 = (unsigned __int8 *)v131;
    if ((void)v131)
    {
      int v111 = v123 + 1;
      do
      {
        v143[0] = v110 + 16;
        v112 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, v110 + 16, (uint64_t)&std::piecewise_construct, v143);
        uint64_t v113 = v112[3];
        unint64_t v114 = v112[4] - v113;
        unint64_t v115 = v114 >> 2;
        if ((int)(v114 >> 2) < 1)
        {
          int v116 = 0;
        }
        else
        {
          int v116 = 0;
          unsigned int v117 = (v114 >> 2) - 1;
          while ((*(_DWORD *)(v113 + 4 * v117) & 0x7FFFFFFFu) >= 0x7F800000)
          {
            ++v116;
            --v117;
            if (v115 == v116)
            {
              int v116 = v115;
              break;
            }
          }
        }
        if (v116 < v111) {
          int v111 = v116;
        }
        v110 = *(unsigned __int8 **)v110;
      }
      while (v110);
      if (v111 >= 1 && v111 <= v123)
      {
        for (int j = 0; j != v111; ++j)
        {
          --v128;
          for (k = (unsigned __int8 *)v131; k; k = *(unsigned __int8 **)k)
          {
            v143[0] = k + 16;
            v120 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)&v130, k + 16, (uint64_t)&std::piecewise_construct, v143);
            v120[4] -= 4;
          }
        }
      }
    }
    if ((long long *)(a3 + 24) != &v130)
    {
      *(_DWORD *)(a3 + 56) = v132;
      std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *> *>>((void *)(a3 + 24), (void *)v131, 0);
    }
    v121 = __src;
    if (&__src != (void **)a3)
    {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a3, (char *)__src, (uint64_t)v128, ((char *)v128 - (unsigned char *)__src) >> 2);
      v121 = __src;
    }
    if (v121)
    {
      v128 = v121;
      operator delete(v121);
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&v130);
  if (v133) {
    operator delete(v133);
  }
  if (__p)
  {
    v137 = (char *)__p;
    operator delete(__p);
  }
  if (v139)
  {
    v140 = v139;
    operator delete(v139);
  }
}

void sub_257D15254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29)
{
  if (__p) {
    operator delete(__p);
  }
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&a19);
  if (a25)
  {
    a26 = (uint64_t)a25;
    operator delete(a25);
  }
  if (a28)
  {
    a29 = (uint64_t)a28;
    operator delete(a28);
  }
  size_t v32 = *(void **)(v30 - 144);
  if (v32)
  {
    *(void *)(v30 - 136) = v32;
    operator delete(v32);
  }
  Nightingale::lunaExtractedData::~lunaExtractedData(v29);
  _Unwind_Resume(a1);
}

void Nightingale::truncate_temperature_data(Nightingale *this@<X0>, Nightingale::lunaExtractedData *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = (int)a2;
  uint64_t v6 = *(const void **)this;
  uint64_t v7 = (const void *)*((void *)this + 1);
  uint64_t v8 = (uint64_t)v7 - *(void *)this;
  unint64_t v9 = v8 >> 2;
  if (v7 == *(const void **)this)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a3, v7, (uint64_t)v7, v9);
    std::unordered_map<unsigned char,std::vector<float>>::unordered_map(a3 + 24, (uint64_t)this + 24);
    std::unordered_map<unsigned char,std::vector<int>>::unordered_map(a3 + 64, (uint64_t)this + 64);
  }
  else if (*((_DWORD *)v6 + v9 - 1) >= v3)
  {
LABEL_8:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a3, v6, (uint64_t)v7, v9);
    std::unordered_map<unsigned char,std::vector<float>>::unordered_map(a3 + 24, (uint64_t)this + 24);
    std::unordered_map<unsigned char,std::vector<int>>::unordered_map(a3 + 64, (uint64_t)this + 64);
  }
  else
  {
    uint64_t v10 = 0;
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v8 >> 2;
    }
    while (*((_DWORD *)v6 + v10) != v3)
    {
      if (v11 == ++v10) {
        goto LABEL_8;
      }
    }
    unint64_t v12 = (unint64_t)v8 >> 2;
    *(void *)(a3 + 48) = 0;
    if ((int)v10 + 1 < (int)v12) {
      int v13 = v10 + 1;
    }
    else {
      int v13 = v12;
    }
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_DWORD *)(a3 + 56) = 1065353216;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_DWORD *)(a3 + 96) = 1065353216;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v23 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(__p, v6, (uint64_t)v6 + 4 * v13 + 4, (4 * v13 + 4) >> 2);
    int v14 = *(void **)a3;
    if (*(void *)a3)
    {
      *(void *)(a3 + 8) = v14;
      operator delete(v14);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v23;
    uint64_t v15 = (unsigned __int8 *)*((void *)this + 5);
    if (v15)
    {
      int v16 = (char *)this + 24;
      do
      {
        *(void *)&long long v20 = v15 + 16;
        uint64_t v17 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v16, v15 + 16, (uint64_t)&std::piecewise_construct, (unsigned char **)&v20);
        __p[1] = 0;
        uint64_t v23 = 0;
        __p[0] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(__p, (const void *)v17[3], v17[4], (uint64_t)(v17[4] - v17[3]) >> 2);
        uint64_t v21 = 0;
        long long v20 = 0uLL;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v20, __p[0], (uint64_t)__p[0] + 4 * v13 + 4, (4 * v13 + 4) >> 2);
        uint64_t v24 = v15 + 16;
        uint64_t v18 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(a3 + 24, v15 + 16, (uint64_t)&std::piecewise_construct, &v24);
        uint64_t v19 = (void *)v18[3];
        if (v19)
        {
          void v18[4] = v19;
          operator delete(v19);
          v18[3] = 0;
          void v18[4] = 0;
          v18[5] = 0;
        }
        *(_OWORD *)(v18 + 3) = v20;
        v18[5] = v21;
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        uint64_t v15 = *(unsigned __int8 **)v15;
      }
      while (v15);
    }
  }
}

void sub_257D15574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table(v15);
  uint64_t v17 = *(void **)v14;
  if (*(void *)v14)
  {
    *(void *)(v14 + 8) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(a1);
}

void Nightingale::lunaExtractedData::~lunaExtractedData(Nightingale::lunaExtractedData *this)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)this + 64);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)this + 24);
  int v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

void Nightingale::preprocess_all_temperature_data(Nightingale *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 48) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_DWORD *)(a2 + 56) = 1065353216;
  *(_OWORD *)(a2 + 64) = 0u;
  uint64_t v3 = a2 + 64;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_DWORD *)(a2 + 96) = 1065353216;
  for (i = (uint64_t *)*((void *)this + 5); i; i = (uint64_t *)*i)
  {
    unsigned __int8 v22 = *((unsigned char *)i + 16);
    uint64_t v19 = 0;
    long long v20 = 0;
    uint64_t v21 = 0;
    int v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v16, (const void *)i[3], i[4], (i[4] - i[3]) >> 2);
    uint64_t v5 = (float *)v16;
    uint64_t v6 = v17;
    while (v5 != v6)
    {
      float v7 = *v5;
      if (*v5 > 38.5) {
        float v7 = NAN;
      }
      *v5++ = v7;
    }
    Nightingale::remove_outlier_via_sliding_window_r((uint64_t *)&v16, 7, (char **)&__p, 1.0);
    unint64_t v9 = __p;
    uint64_t v8 = v15;
    uint64_t v24 = &v19;
    while (v9 != v8)
    {
      BOOL v23 = (*v9 & 0x7FFFFFFFu) < 0x7F800000;
      std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100]((uint64_t *)&v24, &v23);
      ++v9;
    }
    uint64_t v24 = (void **)&v22;
    uint64_t v10 = (char *)(std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(a2 + 24, &v22, (uint64_t)&std::piecewise_construct, (unsigned char **)&v24)+ 3);
    if (v10 != (char *)&__p) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v10, (char *)__p, (uint64_t)v15, ((char *)v15 - (unsigned char *)__p) >> 2);
    }
    uint64_t v24 = (void **)&v22;
    uint64_t v11 = (char *)(std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v3, &v22, (uint64_t)&std::piecewise_construct, (unsigned char **)&v24)+ 3);
    if (v11 != (char *)&v19) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v11, (char *)v19, (uint64_t)v20, (v20 - (unsigned char *)v19) >> 2);
    }
    if (__p)
    {
      uint64_t v15 = __p;
      operator delete(__p);
    }
    if (v16)
    {
      uint64_t v17 = (float *)v16;
      operator delete(v16);
    }
    if (v19)
    {
      long long v20 = v19;
      operator delete(v19);
    }
  }
  if ((Nightingale *)a2 != this) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a2, *(char **)this, *((void *)this + 1), (uint64_t)(*((void *)this + 1) - *(void *)this) >> 2);
  }
}

void sub_257D15844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  Nightingale::lunaExtractedData::~lunaExtractedData(v19);
  _Unwind_Resume(a1);
}

void Nightingale::prepare_temperature_input_slice_for_kdays(void *a1@<X0>, int a2@<W1>, void *a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  __p = 0;
  v75 = 0;
  uint64_t v76 = 0;
  if (a2 >= 1)
  {
    float v7 = 0;
    for (int i = 0; i != a2; ++i)
    {
      if (v7 >= v76)
      {
        uint64_t v10 = (char *)__p;
        uint64_t v11 = (v7 - (unsigned char *)__p) >> 2;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v13 = v76 - (unsigned char *)__p;
        if ((v76 - (unsigned char *)__p) >> 1 > v12) {
          unint64_t v12 = v13 >> 1;
        }
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14)
        {
          uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v76, v14);
          uint64_t v10 = (char *)__p;
          float v7 = v75;
        }
        else
        {
          uint64_t v15 = 0;
        }
        int v16 = &v15[4 * v11];
        *(_DWORD *)int v16 = 2143289344;
        unint64_t v9 = v16 + 4;
        while (v7 != v10)
        {
          int v17 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *((_DWORD *)v16 - 1) = v17;
          v16 -= 4;
        }
        __p = v16;
        v75 = v9;
        uint64_t v76 = &v15[4 * v14];
        if (v10) {
          operator delete(v10);
        }
      }
      else
      {
        *(_DWORD *)float v7 = 2143289344;
        unint64_t v9 = v7 + 4;
      }
      v75 = v9;
      float v7 = v9;
    }
  }
  if (a1[1] == *a1)
  {
    LODWORD(v31) = 0;
  }
  else
  {
    unint64_t v18 = 0;
    uint64_t v19 = (void **)(a4 + 24);
    do
    {
      __src = 0;
      long long v73 = 0uLL;
      std::vector<std::vector<float>>::push_back[abi:ne180100]((uint64_t *)a4, (uint64_t)&__src);
      if (__src)
      {
        *(void *)&long long v73 = __src;
        operator delete(__src);
      }
      uint64_t v21 = *(char **)(a4 + 32);
      unint64_t v20 = *(void *)(a4 + 40);
      if ((unint64_t)v21 >= v20)
      {
        BOOL v23 = (char *)*v19;
        uint64_t v24 = (v21 - (unsigned char *)*v19) >> 2;
        unint64_t v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v26 = v20 - (void)v23;
        if (v26 >> 1 > v25) {
          unint64_t v25 = v26 >> 1;
        }
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v27 = v25;
        }
        if (v27)
        {
          unint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a4 + 40, v27);
          BOOL v23 = *(char **)(a4 + 24);
          uint64_t v21 = *(char **)(a4 + 32);
        }
        else
        {
          unint64_t v28 = 0;
        }
        uint64_t v29 = &v28[4 * v24];
        *(_DWORD *)uint64_t v29 = 2143289344;
        unsigned __int8 v22 = v29 + 4;
        while (v21 != v23)
        {
          int v30 = *((_DWORD *)v21 - 1);
          v21 -= 4;
          *((_DWORD *)v29 - 1) = v30;
          v29 -= 4;
        }
        *(void *)(a4 + 24) = v29;
        *(void *)(a4 + 32) = v22;
        *(void *)(a4 + 40) = &v28[4 * v27];
        if (v23) {
          operator delete(v23);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v21 = 2143289344;
        unsigned __int8 v22 = v21 + 4;
      }
      *(void *)(a4 + 32) = v22;
      ++v18;
      unint64_t v31 = (uint64_t)(a1[1] - *a1) >> 2;
    }
    while (v31 > v18);
  }
  size_t v32 = a3;
  if ((int)v31 >= 1)
  {
    int v33 = 0;
    uint64_t v34 = v31;
    do
    {
      unint64_t v35 = (v34 - 1);
      if (v35 >= (uint64_t)(a1[1] - *a1) >> 2) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      int v36 = *(_DWORD *)(*a1 + 4 * v35);
      unint64_t v37 = (uint64_t)(v32[1] - *v32) >> 2;
      unint64_t v38 = v33;
      if (v37 > v33)
      {
        do
        {
          if (v36 >= *(_DWORD *)(*v32 + 4 * v38)) {
            break;
          }
          ++v38;
        }
        while (v37 > v38);
        int v33 = v38;
      }
      __src = 0;
      long long v73 = 0uLL;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__src, __p, (uint64_t)v75, (v75 - (unsigned char *)__p) >> 2);
      float v39 = 1.0;
      if (v38 >= (uint64_t)(v32[1] - *v32) >> 2 || v36 != *(_DWORD *)(*v32 + 4 * v38)) {
        goto LABEL_99;
      }
      __int16 v71 = 0;
      v40 = (uint64_t **)v32[10];
      if (v40)
      {
        int v41 = v33 + a2;
        do
        {
          int v42 = v40[3];
          unint64_t v43 = (unint64_t)((char *)v40[4] - (char *)v42) >> 2;
          if (v41 < (int)v43) {
            LODWORD(v43) = v33 + a2;
          }
          unint64_t v69 = 0;
          long long v70 = 0uLL;
          std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>((char *)&v69, (int *)v42 + v38, (int *)v42 + (int)v43, (int)v43 - v38);
          double v44 = 0.0;
          if (v69 != (float *)v70)
          {
            int v45 = v69;
            do
            {
              float v46 = *v45++;
              double v44 = v44 + v46;
            }
            while (v45 != (float *)v70);
          }
          float v47 = 1.0 - v44 / (float)a2;
          if (v39 > v47)
          {
            __int16 v71 = *((unsigned __int8 *)v40 + 16) | 0x100;
            float v39 = v47;
          }
          if (v69)
          {
            *(void *)&long long v70 = v69;
            operator delete(v69);
          }
          v40 = (uint64_t **)*v40;
        }
        while (v40);
        if (HIBYTE(v71))
        {
          unint64_t v69 = (float *)&v71;
          unint64_t v48 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)(a3 + 3), (unsigned __int8 *)&v71, (uint64_t)&std::piecewise_construct, (unsigned char **)&v69);
          uint64_t v49 = v48[3];
          unint64_t v50 = (unint64_t)(v48[4] - v49) >> 2;
          if (v41 < (int)v50) {
            LODWORD(v50) = v33 + a2;
          }
          unint64_t v69 = 0;
          long long v70 = 0uLL;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v69, (const void *)(v49 + 4 * v38), v49 + 4 * (int)v50, (int)v50 - v38);
          size_t v32 = a3;
          if (__src)
          {
            *(void *)&long long v73 = __src;
            operator delete(__src);
          }
          v51 = (char *)v69;
          __src = v69;
          long long v73 = v70;
          v52 = (char *)v70;
          goto LABEL_72;
        }
        size_t v32 = a3;
      }
      v51 = (char *)__src;
      v52 = (char *)v73;
LABEL_72:
      unint64_t v53 = (v52 - v51) >> 2;
      if (v53 >= a2)
      {
        unint64_t v54 = v52;
      }
      else
      {
        do
        {
          if ((unint64_t)v52 >= *((void *)&v73 + 1))
          {
            unint64_t v55 = v53 + 1;
            if ((v53 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v56 = *((void *)&v73 + 1) - (void)v51;
            if ((uint64_t)(*((void *)&v73 + 1) - (void)v51) >> 1 > v55) {
              unint64_t v55 = v56 >> 1;
            }
            if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v57 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v57 = v55;
            }
            if (v57)
            {
              v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v73 + 8, v57);
              v51 = (char *)__src;
              v52 = (char *)v73;
            }
            else
            {
              v58 = 0;
            }
            int v59 = &v58[4 * v53];
            *(_DWORD *)int v59 = 2143289344;
            unint64_t v54 = v59 + 4;
            while (v52 != v51)
            {
              int v60 = *((_DWORD *)v52 - 1);
              v52 -= 4;
              *((_DWORD *)v59 - 1) = v60;
              v59 -= 4;
            }
            __src = v59;
            *(void *)&long long v73 = v54;
            *((void *)&v73 + 1) = &v58[4 * v57];
            if (v51)
            {
              operator delete(v51);
              v51 = (char *)__src;
            }
            else
            {
              v51 = v59;
            }
          }
          else
          {
            *(_DWORD *)v52 = 2143289344;
            unint64_t v54 = v52 + 4;
          }
          *(void *)&long long v73 = v54;
          unint64_t v53 = (v54 - v51) >> 2;
          v52 = v54;
        }
        while (v53 < a2);
      }
      if (v51 != v54)
      {
        v61 = v54 - 4;
        if (v54 - 4 > v51)
        {
          v62 = v51 + 4;
          do
          {
            int v63 = *((_DWORD *)v62 - 1);
            *((_DWORD *)v62 - 1) = *(_DWORD *)v61;
            *(_DWORD *)v61 = v63;
            v61 -= 4;
            BOOL v64 = v62 >= v61;
            v62 += 4;
          }
          while (!v64);
        }
      }
      ++v33;
LABEL_99:
      unint64_t v65 = (char *)(*(void *)a4 + 24 * v35);
      v66 = __src;
      if (v65 != (char *)&__src)
      {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v65, (char *)__src, v73, (uint64_t)(v73 - (void)__src) >> 2);
        v66 = __src;
      }
      *(float *)(*(void *)(a4 + 24) + 4 * v35) = v39;
      if (v66)
      {
        *(void *)&long long v73 = v66;
        operator delete(v66);
      }
    }
    while (v34-- > 1);
  }
  if (__p)
  {
    v75 = (char *)__p;
    operator delete(__p);
  }
}

void sub_257D15EAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  Nightingale::lunaInputSlice::~lunaInputSlice(v21);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  float v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v12);
    unint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)unint64_t v14 = 0;
    *(_OWORD *)unint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)float v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_257D16040(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void Nightingale::lunaInputSlice::~lunaInputSlice(Nightingale::lunaInputSlice *this)
{
  int v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)this;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void Nightingale::remove_outlier_via_sliding_window_r(uint64_t *a1@<X0>, int a2@<W1>, char **a3@<X8>, float a4@<S0>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  unint64_t v8 = (unint64_t)(a1[1] - *a1) >> 2;
  unint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = (v8 - 1);
  if ((int)v8 < 1)
  {
LABEL_22:
    uint64_t v13 = v9;
    if ((v11 & 0x80000000) != 0) {
      goto LABEL_84;
    }
    int v22 = v10 + a2;
    uint64_t v11 = v11;
    while (1)
    {
      uint64_t v23 = *a1;
      if (v11 >= (int)(((unint64_t)(a1[1] - *a1) >> 2) - v22))
      {
        int v33 = a3[1];
        unint64_t v32 = (unint64_t)a3[2];
        if ((unint64_t)v33 >= v32)
        {
          unint64_t v35 = *a3;
          uint64_t v36 = (v33 - *a3) >> 2;
          unint64_t v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v38 = v32 - (void)v35;
          if (v38 >> 1 > v37) {
            unint64_t v37 = v38 >> 1;
          }
          if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v39 = v37;
          }
          if (v39)
          {
            v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v39);
            unint64_t v35 = *a3;
            int v33 = a3[1];
          }
          else
          {
            v40 = 0;
          }
          unint64_t v53 = &v40[4 * v36];
          *(_DWORD *)unint64_t v53 = *(_DWORD *)(v23 + 4 * v11);
          uint64_t v34 = v53 + 4;
          while (v33 != v35)
          {
            int v54 = *((_DWORD *)v33 - 1);
            v33 -= 4;
            *((_DWORD *)v53 - 1) = v54;
            v53 -= 4;
          }
          *a3 = v53;
          a3[1] = v34;
          a3[2] = &v40[4 * v39];
          if (v35) {
            operator delete(v35);
          }
        }
        else
        {
          *(_DWORD *)int v33 = *(_DWORD *)(v23 + 4 * v11);
          uint64_t v34 = v33 + 4;
        }
        a3[1] = v34;
        goto LABEL_81;
      }
      uint64_t v24 = (uint64_t)a3[1];
      unint64_t v25 = (unint64_t)(v24 - (void)*a3) >> 2;
      if ((int)v25 >= a2) {
        LODWORD(v25) = a2;
      }
      v67 = 0;
      uint64_t v68 = 0;
      uint64_t v69 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v67, (const void *)(v24 - 4 * (int)v25), v24, (int)v25);
      uint64_t v26 = *a1;
      unint64_t v65 = 0;
      uint64_t v66 = 0;
      __p = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, (const void *)(v26 + 4 * v11), v26 + 4 * v11 + 4, 1uLL);
      Nightingale::get_sw_difference((char **)&v67, (int **)&__p);
      if (v27 >= a4 || v27 <= (float)-a4)
      {
        int v42 = a3[1];
        unint64_t v41 = (unint64_t)a3[2];
        if ((unint64_t)v42 >= v41)
        {
          double v44 = *a3;
          uint64_t v45 = (v42 - *a3) >> 2;
          unint64_t v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v47 = v41 - (void)v44;
          if (v47 >> 1 > v46) {
            unint64_t v46 = v47 >> 1;
          }
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v46;
          }
          if (v48)
          {
            uint64_t v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v48);
            double v44 = *a3;
            int v42 = a3[1];
          }
          else
          {
            uint64_t v49 = 0;
          }
          unint64_t v55 = &v49[4 * v45];
          *(_DWORD *)unint64_t v55 = 2143289344;
          unint64_t v43 = v55 + 4;
          while (v42 != v44)
          {
            int v56 = *((_DWORD *)v42 - 1);
            v42 -= 4;
            *((_DWORD *)v55 - 1) = v56;
            v55 -= 4;
          }
          goto LABEL_75;
        }
        *(_DWORD *)int v42 = 2143289344;
        unint64_t v31 = v42 + 4;
      }
      else
      {
        uint64_t v28 = *a1;
        int v30 = a3[1];
        unint64_t v29 = (unint64_t)a3[2];
        if ((unint64_t)v30 >= v29)
        {
          double v44 = *a3;
          uint64_t v50 = (v30 - *a3) >> 2;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v52 = v29 - (void)v44;
          if (v52 >> 1 > v51) {
            unint64_t v51 = v52 >> 1;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v51;
          }
          if (v48)
          {
            uint64_t v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v48);
            double v44 = *a3;
            int v30 = a3[1];
          }
          else
          {
            uint64_t v49 = 0;
          }
          unint64_t v55 = &v49[4 * v50];
          *(_DWORD *)unint64_t v55 = *(_DWORD *)(v28 + 4 * v11);
          unint64_t v43 = v55 + 4;
          while (v30 != v44)
          {
            int v57 = *((_DWORD *)v30 - 1);
            v30 -= 4;
            *((_DWORD *)v55 - 1) = v57;
            v55 -= 4;
          }
LABEL_75:
          *a3 = v55;
          a3[1] = v43;
          a3[2] = &v49[4 * v48];
          if (v44) {
            operator delete(v44);
          }
          goto LABEL_77;
        }
        *(_DWORD *)int v30 = *(_DWORD *)(v28 + 4 * v11);
        unint64_t v31 = v30 + 4;
      }
      unint64_t v43 = v31;
LABEL_77:
      a3[1] = v43;
      if (__p)
      {
        unint64_t v65 = __p;
        operator delete(__p);
      }
      if (v67)
      {
        uint64_t v68 = v67;
        operator delete(v67);
      }
LABEL_81:
      BOOL v60 = v11-- <= 0;
      if (v60)
      {
        uint64_t v13 = a3[1];
        goto LABEL_84;
      }
    }
  }
  unint64_t v12 = a3 + 2;
  do
  {
    if ((*(_DWORD *)(*a1 + 4 * v11) & 0x7FFFFFFFu) < 0x7F800000) {
      goto LABEL_22;
    }
    if ((unint64_t)v9 >= *v12)
    {
      unint64_t v14 = *a3;
      uint64_t v15 = (v9 - *a3) >> 2;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v17 = *v12 - (void)v14;
      if (v17 >> 1 > v16) {
        unint64_t v16 = v17 >> 1;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v18);
        unint64_t v14 = *a3;
        unint64_t v9 = a3[1];
      }
      else
      {
        uint64_t v19 = 0;
      }
      unint64_t v20 = &v19[4 * v15];
      *(_DWORD *)unint64_t v20 = 2143289344;
      uint64_t v13 = v20 + 4;
      while (v9 != v14)
      {
        int v21 = *((_DWORD *)v9 - 1);
        v9 -= 4;
        *((_DWORD *)v20 - 1) = v21;
        v20 -= 4;
      }
      *a3 = v20;
      a3[1] = v13;
      a3[2] = &v19[4 * v18];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v9 = 2143289344;
      uint64_t v13 = v9 + 4;
    }
    a3[1] = v13;
    ++v10;
    --v11;
    unint64_t v9 = v13;
  }
  while (v10 != v8);
LABEL_84:
  v58 = *a3;
  int v59 = v13 - 4;
  BOOL v60 = *a3 != v13 && v59 > v58;
  if (v60)
  {
    unint64_t v61 = (unint64_t)(v58 + 4);
    do
    {
      int v62 = *(_DWORD *)(v61 - 4);
      *(_DWORD *)(v61 - 4) = *(_DWORD *)v59;
      *(_DWORD *)int v59 = v62;
      v59 -= 4;
      BOOL v63 = v61 >= (unint64_t)v59;
      v61 += 4;
    }
    while (!v63);
  }
}

void sub_257D1650C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  uint64_t v15 = *(void **)v13;
  if (*(void *)v13)
  {
    *(void *)(v13 + 8) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(exception_object);
}

int *Nightingale::get_sw_difference(char **a1, int **a2)
{
  uint64_t v3 = *a1;
  int v2 = a1[1];
  uint64_t result = *a2;
  unint64_t v5 = a2[1];
  unint64_t v6 = (unint64_t)((char *)v5 - (char *)*a2) >> 2;
  for (unint64_t i = (unint64_t)(v2 - v3) >> 2; v3 != v2; LODWORD(i) = i - ((v8 & 0x7FFFFFFFu) > 0x7F7FFFFF))
  {
    int v8 = *(_DWORD *)v3;
    v3 += 4;
  }
  int v9 = v6;
  if (result != v5)
  {
    int v9 = v6;
    int v10 = result;
    do
    {
      int v11 = *v10++;
      v9 -= (v11 & 0x7FFFFFFFu) > 0x7F7FFFFF;
    }
    while (v10 != v5);
  }
  if (i)
  {
    if (v9) {
      Nightingale::vMean<float>();
    }
  }
  return result;
}

char *Nightingale::calculate_snr_noise_power(char **a1, int **a2)
{
  uint64_t result = *a1;
  uint64_t v3 = a1[1];
  unint64_t v6 = *a2;
  unint64_t v5 = a2[1];
  unint64_t v7 = (unint64_t)((char *)v5 - (char *)*a2) >> 2;
  unint64_t v8 = (unint64_t)(v3 - result) >> 2;
  if (v3 != result)
  {
    unint64_t v8 = (unint64_t)(v3 - result) >> 2;
    int v9 = result;
    do
    {
      int v10 = *(_DWORD *)v9;
      v9 += 4;
      LODWORD(v8) = v8 - ((v10 & 0x7FFFFFFFu) > 0x7F7FFFFF);
    }
    while (v9 != v3);
  }
  for (; v6 != v5; LODWORD(v7) = v7 - ((v11 & 0x7FFFFFFFu) > 0x7F7FFFFF))
    int v11 = *v6++;
  if (v8 && v7 && (int)v7 + (int)v8 >= 3) {
    Nightingale::vVar<float>();
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::clear(a1);
  uint64_t v4 = *a2;
  *a2 = 0;
  unint64_t v5 = *(void **)a1;
  *(void *)a1 = v4;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v8 = a2[2];
  unint64_t v7 = a2 + 2;
  uint64_t v6 = v8;
  uint64_t v9 = *(v7 - 1);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 8) = v9;
  *(v7 - 1) = 0;
  uint64_t v10 = v7[1];
  *(void *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v7 + 4);
  if (v10)
  {
    unint64_t v11 = *(void *)(v6 + 8);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        v11 %= v12;
      }
    }
    else
    {
      v11 &= v12 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v11) = a1 + 16;
    void *v7 = 0;
    v7[1] = 0;
  }
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void __clang_call_terminate(void *a1)
{
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::vector<float>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_26542F270, MEMORY[0x263F8C060]);
}

void sub_257D16954(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C388] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  Swift::String v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x263F8C208], MEMORY[0x263F8C090]);
}

uint64_t std::vector<std::vector<float>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<float>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<float>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<int>::__throw_out_of_range[abi:ne180100]()
{
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_26542F278, MEMORY[0x263F8C068]);
}

void sub_257D16CE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C390] + 16);
  return result;
}

void *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D16D88(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

char *std::vector<float>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(char *result, int *a2, int *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (float *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v8 = *a2++;
      *v7++ = (float)v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_257D16E44(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x263F8C3B0] + 16;
  __cxa_throw(exception, MEMORY[0x263F8C200], MEMORY[0x263F8C088]);
}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    long long v13 = (char *)v7[1];
    char v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  char v12 = (void **)(result + 8);
  long long v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *char v12 = &v9[v17];
  return result;
}

void std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::unordered_map<unsigned char,std::vector<float>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(unsigned __int8 **)(a2 + 16); i; uint64_t i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::pair<unsigned char const,std::vector<float>> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_257D170C4(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            void *v7 = *v11;
            void *v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            unint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::pair<unsigned char const,std::vector<float>> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v5 = *a2;
  unint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 <= v5) {
        unint64_t v3 = v5 % v6;
      }
    }
    else
    {
      unint64_t v3 = (v6 - 1) & v5;
    }
    unint64_t v8 = *(uint64_t ****)(*(void *)a1 + 8 * v3);
    if (v8)
    {
      for (uint64_t result = *v8; result; uint64_t result = (uint64_t **)*result)
      {
        unint64_t v10 = (unint64_t)result[1];
        if (v10 == v5)
        {
          if (*((unsigned __int8 *)result + 16) == v5) {
            return result;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v10 >= v6) {
              v10 %= v6;
            }
          }
          else
          {
            v10 &= v6 - 1;
          }
          if (v10 != v3) {
            break;
          }
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__construct_node_hash<std::pair<unsigned char const,std::vector<float>> const&>(a1, *a2, a3, (uint64_t)v19);
  float v11 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v12 = *(float *)(a1 + 32);
  if (!v6 || (float)(v12 * (float)v6) < v11)
  {
    BOOL v13 = 1;
    if (v6 >= 3) {
      BOOL v13 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v14 = v13 | (2 * v6);
    unint64_t v15 = vcvtps_u32_f32(v11 / v12);
    if (v14 <= v15) {
      size_t v16 = v15;
    }
    else {
      size_t v16 = v14;
    }
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<true>(a1, v16);
    unint64_t v6 = *(void *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5) {
        unint64_t v3 = v5 % v6;
      }
      else {
        unint64_t v3 = v5;
      }
    }
    else
    {
      unint64_t v3 = (v6 - 1) & v5;
    }
  }
  size_t v17 = *(void **)(*(void *)a1 + 8 * v3);
  if (v17)
  {
    *(void *)v19[0] = *v17;
    *size_t v17 = v19[0];
  }
  else
  {
    *(void *)v19[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v19[0];
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*(void *)v19[0])
    {
      unint64_t v18 = *(void *)(*(void *)v19[0] + 8);
      if ((v6 & (v6 - 1)) != 0)
      {
        if (v18 >= v6) {
          v18 %= v6;
        }
      }
      else
      {
        v18 &= v6 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v18) = v19[0];
    }
  }
  uint64_t result = (uint64_t **)v19[0];
  ++*(void *)(a1 + 24);
  return result;
}

void sub_257D17540(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__construct_node_hash<std::pair<unsigned char const,std::vector<float>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  unint64_t v8 = operator new(0x30uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  void *v8 = 0;
  v8[1] = a2;
  *((unsigned char *)v8 + 16) = *(unsigned char *)a3;
  v8[4] = 0;
  uint64_t v8[5] = 0;
  v8[3] = 0;
  uint64_t result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v8 + 3, *(const void **)(a3 + 8), *(void *)(a3 + 16), (uint64_t)(*(void *)(a3 + 16) - *(void *)(a3 + 8)) >> 2);
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_257D175E8(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::unordered_map<unsigned char,std::vector<int>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(unsigned __int8 **)(a2 + 16); i; uint64_t i = *(unsigned __int8 **)i)
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::pair<unsigned char const,std::vector<float>> const&>(a1, i + 16, (uint64_t)(i + 16));
  return a1;
}

void sub_257D176C4(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::back_insert_iterator<std::vector<int>>::operator=[abi:ne180100](uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = *(_DWORD **)(*a1 + 8);
  unint64_t v6 = (void *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    unint64_t v8 = *(_DWORD **)v4;
    uint64_t v9 = ((uint64_t)v5 - *(void *)v4) >> 2;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = *v6 - (void)v8;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      BOOL v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v6, v12);
      unint64_t v8 = *(_DWORD **)v4;
      unint64_t v5 = *(_DWORD **)(v4 + 8);
    }
    else
    {
      BOOL v13 = 0;
    }
    unint64_t v14 = &v13[4 * v9];
    unint64_t v15 = &v13[4 * v12];
    *(_DWORD *)unint64_t v14 = *a2;
    uint64_t v7 = v14 + 4;
    while (v5 != v8)
    {
      int v16 = *--v5;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(void *)uint64_t v4 = v14;
    *(void *)(v4 + 8) = v7;
    *(void *)(v4 + 16) = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    _DWORD *v5 = *a2;
    uint64_t v7 = v5 + 1;
  }
  *(void *)(v4 + 8) = v7;
  return a1;
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned char **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    unint64_t v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (*((unsigned __int8 *)v11 + 16) == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  BOOL v13 = (void *)(a1 + 16);
  uint64_t v11 = operator new(0x30uLL);
  void *v11 = 0;
  v11[1] = v7;
  *((unsigned char *)v11 + 16) = **a4;
  v11[4] = 0;
  v11[5] = 0;
  void v11[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v8 || (float)(v15 * (float)v8) < v14)
  {
    BOOL v16 = 1;
    if (v8 >= 3) {
      BOOL v16 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v8);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<true>(a1, v19);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v20 = *(void *)a1;
  int v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    void *v11 = *v21;
LABEL_38:
    *int v21 = v11;
    goto LABEL_39;
  }
  void *v11 = *v13;
  void *v13 = v11;
  *(void *)(v20 + 8 * v4) = v13;
  if (*v11)
  {
    unint64_t v22 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v22 >= v8) {
        v22 %= v8;
      }
    }
    else
    {
      v22 &= v8 - 1;
    }
    int v21 = (void *)(*(void *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_257D17A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::find<unsigned char>(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  unint64_t v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
      if (*((unsigned __int8 *)result + 16) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *> *>>(void *a1, void *a2, void *a3)
{
  uint8x8_t v4 = a2;
  uint64_t v6 = a1[1];
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
      *(void *)(*a1 + 8 * i) = 0;
    unint64_t v8 = (void *)a1[2];
    a1[2] = 0;
    a1[3] = 0;
    if (v8) {
      BOOL v9 = a2 == a3;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      unint64_t v10 = v8;
    }
    else
    {
      do
      {
        v13[0] = v8 + 2;
        v13[1] = v8 + 3;
        std::pair<unsigned char &,std::vector<float> &>::operator=[abi:ne180100]<unsigned char const,std::vector<float>,(void *)0>(v13, (uint64_t)(v4 + 2));
        unint64_t v10 = (void *)*v8;
        unint64_t v11 = *((unsigned __int8 *)v8 + 16);
        v8[1] = v11;
        inserted = (void *)std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_prepare((uint64_t)a1, v11, (unsigned __int8 *)v8 + 16);
        std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_perform(a1, v8, inserted);
        uint8x8_t v4 = (void *)*v4;
        if (!v10) {
          break;
        }
        unint64_t v8 = v10;
      }
      while (v4 != a3);
    }
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__deallocate_node((int)a1, v10);
  }
  while (v4 != a3)
  {
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_multi<std::pair<unsigned char const,std::vector<float>> const&>(a1, (uint64_t)(v4 + 2));
    uint8x8_t v4 = (void *)*v4;
  }
}

void sub_257D17BD0(void *a1)
{
  __cxa_begin_catch(a1);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__deallocate_node(v1, v2);
  __cxa_rethrow();
}

void sub_257D17BEC(_Unwind_Exception *a1)
{
}

unsigned char **std::pair<unsigned char &,std::vector<float> &>::operator=[abi:ne180100]<unsigned char const,std::vector<float>,(void *)0>(unsigned char **a1, uint64_t a2)
{
  **a1 = *(unsigned char *)a2;
  unint64_t v3 = a1[1];
  if (v3 != (char *)(a2 + 8)) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v3, *(char **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 2);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, unsigned __int8 *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    uint64_t v9 = 2 * v6;
    BOOL v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    size_t v11 = v10 | v9;
    unint64_t v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<false>(a1, v13);
    unint64_t v6 = *(void *)(a1 + 8);
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = a2;
    if (v6 <= a2) {
      unint64_t v15 = a2 % v6;
    }
  }
  else
  {
    unint64_t v15 = (v6 - 1) & a2;
  }
  uint64_t v16 = *(void *)(*(void *)a1 + 8 * v15);
  if (!v16) {
    return 0;
  }
  int v17 = 0;
  do
  {
    uint64_t result = v16;
    uint64_t v16 = *(void *)v16;
    if (!v16) {
      break;
    }
    unint64_t v19 = *(void *)(v16 + 8);
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v20 = *(void *)(v16 + 8);
      if (v19 >= v6) {
        unint64_t v20 = v19 % v6;
      }
    }
    else
    {
      unint64_t v20 = v19 & (v6 - 1);
    }
    if (v20 != v15) {
      break;
    }
    BOOL v21 = v19 == a2 && *(unsigned __int8 *)(v16 + 16) == *a3;
    int v22 = v17 & !v21;
    v17 |= v21;
  }
  while (v22 != 1);
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_perform(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_18:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_18;
    }
  }
LABEL_19:
  ++result[3];
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__do_rehash<false>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(uint64_t ***)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = (unint64_t)v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      for (uint64_t i = *v7; *v7; uint64_t i = *v7)
      {
        unint64_t v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2) {
            v12 %= a2;
          }
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          uint64_t v7 = (uint64_t **)i;
        }
        else
        {
          size_t v13 = i;
          if (*(void *)(*(void *)a1 + 8 * v12))
          {
            do
            {
              uint8x8_t v14 = v13;
              size_t v13 = (uint64_t *)*v13;
            }
            while (v13 && *((unsigned __int8 *)i + 16) == *((unsigned __int8 *)v13 + 16));
            _DWORD *v7 = v13;
            *uint8x8_t v14 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v12) = v7;
            uint64_t v7 = (uint64_t **)i;
            unint64_t v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    BOOL v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_multi<std::pair<unsigned char const,std::vector<float>> const&>(void *a1, uint64_t a2)
{
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__construct_node<std::pair<unsigned char const,std::vector<float>> const&>((uint64_t)a1, a2, (uint64_t)v8);
  int8x8_t v3 = (void *)v8[0];
  unint64_t v5 = (unsigned __int8 *)(v8[0] + 16);
  unint64_t v4 = *(unsigned __int8 *)(v8[0] + 16);
  *(void *)(v8[0] + 8) = v4;
  inserted = (void *)std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_prepare((uint64_t)a1, v4, v5);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__node_insert_multi_perform(a1, v3, inserted);
  return v3;
}

void sub_257D18154(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100]((uint64_t)&a11, __p);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__construct_node<std::pair<unsigned char const,std::vector<float>> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 16;
  uint64_t v6 = operator new(0x30uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  void *v6 = 0;
  v6[1] = 0;
  *((unsigned char *)v6 + 16) = *(unsigned char *)a2;
  v6[4] = 0;
  v6[5] = 0;
  v6[3] = 0;
  uint64_t result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v6 + 3, *(const void **)(a2 + 8), *(void *)(a2 + 16), (uint64_t)(*(void *)(a2 + 16) - *(void *)(a2 + 8)) >> 2);
  *(unsigned char *)(a3 + 16) = 1;
  v6[1] = *((unsigned __int8 *)v6 + 16);
  return result;
}

void sub_257D18200(_Unwind_Exception *a1)
{
  *int v1 = 0;
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<float>>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

Nightingale::periodEstimatorLuna *Nightingale::periodEstimatorLuna::periodEstimatorLuna(Nightingale::periodEstimatorLuna *this, const Nightingale::ngt_Config *a2)
{
  uint64_t v4 = Nightingale::periodEstimatorBase::periodEstimatorBase(this, a2);
  Nightingale::ngt_luna_period_dl_tmp_process::ngt_luna_period_dl_tmp_process((Nightingale::ngt_luna_period_dl_tmp_process *)(v4 + 8), a2);
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + 20) = 0;
  if (*((unsigned char *)a2 + 52))
  {
    *((_DWORD *)this + 4) = (int)*((float *)a2 + 12);
    *((unsigned char *)this + 20) = 1;
  }
  return this;
}

void sub_257D18278(_Unwind_Exception *a1)
{
  Nightingale::periodEstimatorBase::~periodEstimatorBase(v1);
  _Unwind_Resume(a1);
}

void Nightingale::periodEstimatorLuna::~periodEstimatorLuna(id **this)
{
  Nightingale::ngt_luna_period_dl_tmp_process::~ngt_luna_period_dl_tmp_process(this + 1);
  Nightingale::periodEstimatorBase::~periodEstimatorBase((Nightingale::periodEstimatorBase *)this);
}

{
  uint64_t vars8;

  Nightingale::ngt_luna_period_dl_tmp_process::~ngt_luna_period_dl_tmp_process(this + 1);
  Nightingale::periodEstimatorBase::~periodEstimatorBase((Nightingale::periodEstimatorBase *)this);
}

void Nightingale::periodEstimatorLuna::estimatePeriodLuna(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, const Nightingale::ngt_Config *a4@<X3>, int a5@<W4>, uint64_t a6@<X5>, uint64_t a7@<X8>)
{
  Nightingale::CGradient::CGradient(a7);
  *(unsigned char *)(a7 + 56) = 0;
  *(unsigned char *)(a7 + 60) = 0;
  *(unsigned char *)(a7 + 64) = 0;
  *(unsigned char *)(a7 + 68) = 0;
  *(unsigned char *)(a7 + 72) = 0;
  *(_DWORD *)(a7 + 76) = 5;
  *(unsigned char *)(a7 + 80) = 0;
  uint64_t v14 = a3[1];
  v39[0] = *(_OWORD *)(v14 - 96);
  long long v15 = *(_OWORD *)(v14 - 80);
  long long v16 = *(_OWORD *)(v14 - 64);
  long long v17 = *(_OWORD *)(v14 - 48);
  *(void *)&v41[13] = *(void *)(v14 - 35);
  long long v40 = v16;
  *(_OWORD *)unint64_t v41 = v17;
  v39[1] = v15;
  unint64_t v43 = 0;
  uint64_t v44 = 0;
  int v42 = 0;
  unint64_t v18 = std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v42, *(const void **)(v14 - 24), *(void *)(v14 - 16), *(void *)(v14 - 16) - *(void *)(v14 - 24));
  if (*a3 == a3[1]
    || !BYTE4(v40)
    || !BYTE12(v40)
    || !*((unsigned char *)a4 + 36)
    || !*(unsigned char *)(a6 + 16)
    || *(_DWORD *)(a6 + 8) < *(_DWORD *)(a6 + 4))
  {
    goto LABEL_48;
  }
  int AlgsUsedToRunLunaPeriod = Nightingale::periodEstimatorLuna::getAlgsUsedToRunLunaPeriod((uint64_t)v18, *(_DWORD *)a6, a3, (uint64_t)a4, a5, *(void *)(a6 + 4));
  Nightingale::periodEstimatorCalendar::periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)v38, a4);
  if (AlgsUsedToRunLunaPeriod == 1)
  {
    Nightingale::lstmLunaPeriod::lstmLunaPeriod(&v35, a2, a3, a4, *(void *)(a6 + 4));
    Nightingale::lstmLunaPeriod::estimatePeriodStartLuna((Nightingale::lstmLunaPeriod *)&v35, (uint64_t)&__p);
    if (v32)
    {
      if (Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)&__p))
      {
        unsigned __int8 v21 = 0;
        unsigned int v22 = 0;
        int v23 = 0;
        int AlgsUsedToRunLunaPeriod = 5;
      }
      else
      {
        if (&__p != (void **)a7) {
          std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a7, (char *)__p, (uint64_t)v26, (v26 - (unsigned char *)__p) >> 2);
        }
        *(_OWORD *)(a7 + 24) = v27[0];
        *(_OWORD *)(a7 + 33) = *(_OWORD *)((char *)v27 + 9);
        if (*(unsigned __int8 *)(a7 + 60) == v29)
        {
          if (*(unsigned char *)(a7 + 60)) {
            *(_DWORD *)(a7 + 56) = (int)v28;
          }
        }
        else if (*(unsigned char *)(a7 + 60))
        {
          *(unsigned char *)(a7 + 60) = 0;
        }
        else
        {
          *(_DWORD *)(a7 + 56) = (int)v28;
          *(unsigned char *)(a7 + 60) = 1;
        }
        if (*(unsigned __int8 *)(a7 + 68) == v31)
        {
          if (*(unsigned char *)(a7 + 68)) {
            *(_DWORD *)(a7 + 64) = (int)v30;
          }
        }
        else if (*(unsigned char *)(a7 + 68))
        {
          *(unsigned char *)(a7 + 68) = 0;
        }
        else
        {
          *(_DWORD *)(a7 + 64) = (int)v30;
          *(unsigned char *)(a7 + 68) = 1;
        }
        unsigned __int8 v21 = v33;
        unsigned int v22 = v33 & 0xFFFFFF00;
        int v23 = v34;
        int AlgsUsedToRunLunaPeriod = 1;
      }
      *(unsigned char *)(a7 + 72) = 1;
    }
    else if (*(_DWORD *)a6 == 1)
    {
      unsigned __int8 v21 = v33;
      unsigned int v22 = v33 & 0xFFFFFF00;
      int v23 = v34;
      int AlgsUsedToRunLunaPeriod = 2;
    }
    else
    {
      unsigned __int8 v21 = 0;
      unsigned int v22 = 0;
      int v23 = 0;
      int AlgsUsedToRunLunaPeriod = 1;
    }
    if (__p)
    {
      uint64_t v26 = __p;
      operator delete(__p);
    }
    Nightingale::lstmLunaPeriod::~lstmLunaPeriod((Nightingale::lstmLunaPeriod *)&v35);
    if (v23 && Nightingale::periodEstimatorBase::checkDayToRunPeriodDLLessThanOPK(a1, a3[13], v22 & 0xFFFFFF00 | v21))
    {
      *(unsigned char *)(a7 + 80) = 1;
      *(void *)(a7 + 8) = *(void *)a7;
      if (*(unsigned char *)(a7 + 60)) {
        *(unsigned char *)(a7 + 60) = 0;
      }
      if (*(unsigned char *)(a7 + 68)) {
        *(unsigned char *)(a7 + 68) = 0;
      }
      *(unsigned char *)(a7 + 72) = 0;
      int AlgsUsedToRunLunaPeriod = 5;
      goto LABEL_47;
    }
    goto LABEL_43;
  }
  if (AlgsUsedToRunLunaPeriod)
  {
LABEL_43:
    if (AlgsUsedToRunLunaPeriod == 2)
    {
      Nightingale::periodEstimatorLuna::getPeriodRegularLuna(a1, *(void *)(a6 + 12), a3[12], (uint64_t)v39, (Nightingale::periodEstimatorCalendar *)v38, (uint64_t)&v35);
      uint64_t v24 = *(void **)a7;
      if (*(void *)a7)
      {
        *(void *)(a7 + 8) = v24;
        operator delete(v24);
        *(void *)a7 = 0;
        *(void *)(a7 + 8) = 0;
        *(void *)(a7 + 16) = 0;
      }
      *(_OWORD *)a7 = v35;
      *(void *)(a7 + 16) = v36;
      *(_OWORD *)(a7 + 24) = v37[0];
      *(_OWORD *)(a7 + 33) = *(_OWORD *)((char *)v37 + 9);
      int AlgsUsedToRunLunaPeriod = 2;
    }
    goto LABEL_47;
  }
  Nightingale::periodEstimatorLuna::getPeriodRegularLuna(a1, 0, a3[12], (uint64_t)v39, (Nightingale::periodEstimatorCalendar *)v38, (uint64_t)&v35);
  unint64_t v20 = *(void **)a7;
  if (*(void *)a7)
  {
    *(void *)(a7 + 8) = v20;
    operator delete(v20);
    *(void *)a7 = 0;
    *(void *)(a7 + 8) = 0;
    *(void *)(a7 + 16) = 0;
  }
  int AlgsUsedToRunLunaPeriod = 0;
  *(_OWORD *)a7 = v35;
  *(void *)(a7 + 16) = v36;
  *(_OWORD *)(a7 + 24) = v37[0];
  *(_OWORD *)(a7 + 33) = *(_OWORD *)((char *)v37 + 9);
LABEL_47:
  *(_DWORD *)(a7 + 76) = AlgsUsedToRunLunaPeriod;
  Nightingale::periodEstimatorCalendar::~periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)v38);
LABEL_48:
  if (v42)
  {
    unint64_t v43 = v42;
    operator delete(v42);
  }
}

void sub_257D186D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  Nightingale::periodEstimatorCalendar::~periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)(v22 - 208));
  uint64_t v24 = *(void **)(v22 - 104);
  if (v24)
  {
    *(void *)(v22 - 96) = v24;
    operator delete(v24);
  }
  unint64_t v25 = *(void **)v21;
  if (*(void *)v21)
  {
    *(void *)(v21 + 8) = v25;
    operator delete(v25);
  }
  _Unwind_Resume(a1);
}

uint64_t Nightingale::periodEstimatorLuna::getAlgsUsedToRunLunaPeriod(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, int a5, unint64_t a6)
{
  if (a2 == 7) {
    return 5;
  }
  uint64_t v7 = a3[1];
  if (*(unsigned char *)(v7 - 52)) {
    BOOL v8 = *(float *)(v7 - 56) < 2.25;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8) {
    return 0;
  }
  unint64_t v9 = HIDWORD(a6);
  if ((int)a6 <= SHIDWORD(a6))
  {
    BOOL v11 = 0;
    BOOL v12 = *(unsigned char *)(a4 + 4) != 0;
    if (*(unsigned char *)(a4 + 4)) {
      uint64_t v13 = a3[1];
    }
    else {
      uint64_t v13 = *a3;
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v7 - v13) >> 5);
    if (v7 == *a3) {
      BOOL v12 = 0;
    }
    if (v14 > 1) {
      BOOL v12 = 1;
    }
    while (1)
    {
      unsigned int v10 = (int)a6 - 45 >= a5 && v12;
      if (v10 == 1 && (!*((unsigned char *)a3 + 36) || *((_DWORD *)a3 + 8) <= (int)a6 - 44)) {
        break;
      }
      BOOL v11 = (int)a6 >= (int)v9;
      LODWORD(a6) = a6 + 1;
      if (v9 + 1 == a6)
      {
        unsigned int v10 = 5;
        break;
      }
    }
  }
  else
  {
    unsigned int v10 = 5;
    BOOL v11 = 1;
  }
  if (a2 == 1 && v11) {
    return 2;
  }
  else {
    return v10;
  }
}

double Nightingale::periodEstimatorLuna::getPeriodRegularLuna@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, Nightingale::periodEstimatorCalendar *a5@<X5>, uint64_t a6@<X8>)
{
  Nightingale::CGradient::CGradient(a6);
  if (*(unsigned char *)(a4 + 36) && *(unsigned char *)(a4 + 44))
  {
    uint64_t NullPoint = Nightingale::periodEstimatorBase::getNullPoint(a1, a2, a3, *(_DWORD *)a4);
    if (!*(unsigned char *)(a4 + 36) || !*(unsigned char *)(a4 + 44)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::periodEstimatorCalendar::getCalBasedPeriodStartGradient(a5, NullPoint, (uint64_t)&v15, *(float *)(a4 + 32), *(float *)(a4 + 40));
    unint64_t v14 = *(void **)a6;
    if (*(void *)a6)
    {
      *(void *)(a6 + 8) = v14;
      operator delete(v14);
      *(void *)a6 = 0;
      *(void *)(a6 + 8) = 0;
      *(void *)(a6 + 16) = 0;
    }
    *(_OWORD *)a6 = v15;
    *(void *)(a6 + 16) = v16;
    *(_OWORD *)(a6 + 24) = v17[0];
    double result = *(double *)((char *)v17 + 9);
    *(_OWORD *)(a6 + 33) = *(_OWORD *)((char *)v17 + 9);
  }
  return result;
}

void sub_257D18914(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::periodEstimatorLuna::enoughDataToRunlunaDL(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, int a5)
{
  if (a2 - 45 < a5) {
    return 0;
  }
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (!*(unsigned char *)(a4 + 4))
  {
LABEL_5:
    if (0xAAAAAAAAAAAAAAABLL * ((v5 - v6) >> 5) >= 2) {
      goto LABEL_6;
    }
    return 0;
  }
  if (v5 == v6)
  {
    uint64_t v6 = a3[1];
    goto LABEL_5;
  }
LABEL_6:
  int v7 = a2 - 44;
  int v8 = *((_DWORD *)a3 + 8);
  if (*((unsigned char *)a3 + 36))
  {
    BOOL v11 = __OFSUB__(v8, v7);
    BOOL v9 = v8 == v7;
    BOOL v10 = v8 - v7 < 0;
  }
  else
  {
    BOOL v11 = 0;
    BOOL v9 = 1;
    BOOL v10 = 0;
  }
  return (v10 ^ v11 | v9) != 0;
}

void *std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    uint64_t v6 = result;
    double result = std::vector<Nightingale::Phase>::__vallocate[abi:ne180100](result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D189F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Nightingale::Phase>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

void *Nightingale::fwEstimatorBase::fwEstimatorBase(void *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

void Nightingale::fwEstimatorBase::~fwEstimatorBase(Nightingale::fwEstimatorBase *this)
{
  int8x8_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  int8x8_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

void Nightingale::fwEstimatorBase::suppressHistFWOverCycleBoundary(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (!*(unsigned char *)(a4 + 4)) {
    goto LABEL_7;
  }
  if (*(_DWORD *)a4 < a2) {
    goto LABEL_6;
  }
  if ((a3 & 0xFF00000000) != 0)
  {
    if (!*(unsigned char *)(a4 + 12)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if (*(_DWORD *)(a4 + 8) > (int)a3)
    {
LABEL_6:
      *(unsigned char *)(a4 + 4) = 0;
LABEL_7:
      if (*(unsigned char *)(a4 + 12)) {
        *(unsigned char *)(a4 + 12) = 0;
      }
    }
  }
}

unsigned char *Nightingale::heartRateInputAcquisition::heartRateInputAcquisition(Nightingale::heartRateInputAcquisition *this)
{
  double result = (unsigned char *)Nightingale::sensorInputProcessBase::sensorInputProcessBase(this);
  *double result = 0;
  result[4] = 0;
  result[8] = 0;
  result[12] = 0;
  return result;
}

{
  unsigned char *result;

  double result = (unsigned char *)Nightingale::sensorInputProcessBase::sensorInputProcessBase(this);
  *double result = 0;
  result[4] = 0;
  result[8] = 0;
  result[12] = 0;
  return result;
}

void Nightingale::heartRateInputAcquisition::acquireSlicesFwDayStream(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t DailyJDayIdx1stHr = Nightingale::heartRateInputAcquisition::getDailyJDayIdx1stHr(a1, (uint64_t)a2);
  *(_DWORD *)a1 = DailyJDayIdx1stHr;
  *(unsigned char *)(a1 + 4) = BYTE4(DailyJDayIdx1stHr);
  *(_DWORD *)(a1 + 8) = v11;
  *(unsigned char *)(a1 + 12) = BYTE4(v11);
  if ((DailyJDayIdx1stHr & 0xFF00000000) != 0 && (v11 & 0xFF00000000) != 0)
  {
    uint64_t JDayHrSlicesStartEnd = Nightingale::heartRateInputAcquisition::getJDayHrSlicesStartEnd(a1, a3, a4);
    if ((JDayHrSlicesStartEnd & 0xFF00000000) != 0 && (v13 & 0xFF00000000) != 0)
    {
      Nightingale::heartRateInputAcquisition::acquireSlicesJDayRange(a1, a2, JDayHrSlicesStartEnd, v13, a5);
    }
  }
}

uint64_t Nightingale::heartRateInputAcquisition::getDailyJDayIdx1stHr(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(unsigned char **)a2;
  uint64_t v3 = *(unsigned char **)(a2 + 8);
  if (*(unsigned char **)a2 == v3)
  {
LABEL_8:
    uint64_t v5 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    int v4 = 0;
    while ((!v2[20] || !v2[36]) && (!v2[28] || !v2[44]))
    {
      ++v4;
      v2 += 60;
      if (v2 == v3) {
        goto LABEL_8;
      }
    }
    uint64_t v6 = *(unsigned int *)v2;
    uint64_t v5 = 0x100000000;
  }
  return v6 | v5;
}

uint64_t Nightingale::heartRateInputAcquisition::getJDayHrSlicesStartEnd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a3 & 0xFF00000000) != 0 && *(unsigned char *)(a1 + 4) && *(unsigned char *)(a1 + 12))
  {
    if ((int)a3 <= 39) {
      int v3 = 39;
    }
    else {
      int v3 = a3;
    }
    int v4 = v3 - 39;
    if (v4 <= *(_DWORD *)a1) {
      int v4 = *(_DWORD *)a1;
    }
    uint64_t v5 = v4 & 0x7FFFFF00;
    uint64_t v6 = v4;
    uint64_t v7 = 0x100000000;
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  return v6 | v5 | v7;
}

void Nightingale::heartRateInputAcquisition::acquireSlicesJDayRange(uint64_t a1, uint64_t *a2, int a3, int a4, uint64_t a5)
{
  uint64_t IdxOfDailyInGreaterThanJayDay = Nightingale::getIdxOfDailyInGreaterThanJayDay((uint64_t)a2, a3);
  uint64_t IdxOfDailyInFromJDay = Nightingale::getIdxOfDailyInFromJDay((uint64_t)a2, a4);
  if ((IdxOfDailyInGreaterThanJayDay & 0xFF00000000) != 0 && *(unsigned char *)(a1 + 12))
  {
    if ((IdxOfDailyInFromJDay & 0xFF00000000) == 0) {
      LODWORD(IdxOfDailyInFromJDay) = -286331153 * ((unint64_t)(a2[1] - *a2) >> 2) - 1;
    }
    int v12 = *(_DWORD *)(a1 + 8);
    if (v12 <= (int)IdxOfDailyInGreaterThanJayDay) {
      int v12 = IdxOfDailyInGreaterThanJayDay;
    }
    if (v12 <= (int)IdxOfDailyInFromJDay)
    {
      uint64_t v13 = *a2;
      if (0xEEEEEEEEEEEEEEEFLL * ((a2[1] - *a2) >> 2) <= (int)IdxOfDailyInFromJDay) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      unint64_t v14 = (int *)(v13 + 60 * (int)IdxOfDailyInFromJDay);
      int v17 = *v14;
      uint64_t v15 = (uint64_t)(v14 + 15);
      int v16 = v17;
      if (v17 <= a4) {
        int v18 = a4;
      }
      else {
        int v18 = v16;
      }
      __p = 0;
      char v142 = 0;
      uint64_t v143 = 0;
      std::vector<Nightingale::ngt_DayInput>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_DayInput const*>,std::__wrap_iter<Nightingale::ngt_DayInput const*>>(&__p, (const void *)(v13 + 60 * v12), v15, 0xEEEEEEEEEEEEEEEFLL * ((v15 - (v13 + 60 * v12)) >> 2));
      __int16 v19 = v18 - a3;
      unint64_t v20 = __p;
      if (v18 - a3 >= 44 && __p != v142)
      {
        if (v18 >= a3)
        {
          int v21 = 0;
          uint64_t v136 = a5 + 64;
          uint64_t v137 = a5 + 16;
          v139 = (void *)(a5 + 24);
          v140 = (void *)(a5 + 48);
          uint64_t v22 = (void *)(a5 + 72);
          uint64_t v134 = a5 + 88;
          uint64_t v135 = a5 + 40;
          int v23 = a3;
          do
          {
            if (0xEEEEEEEEEEEEEEEFLL * ((v142 - (unsigned char *)__p) >> 2) > v21 && *((_DWORD *)__p + 15 * v21) == v23)
            {
              uint64_t v24 = v22;
              unint64_t v25 = (char *)__p + 60 * v21;
              uint64_t v27 = v25[2];
              uint64_t v26 = v25[3];
              uint64_t v28 = v25[4];
              uint64_t v138 = v25[5];
              float v30 = *(void **)(a5 + 8);
              unint64_t v29 = *(void *)(a5 + 16);
              if ((unint64_t)v30 >= v29)
              {
                uint64_t v84 = ((uint64_t)v30 - *(void *)a5) >> 3;
                if ((unint64_t)(v84 + 1) >> 61) {
                  goto LABEL_158;
                }
                uint64_t v85 = v29 - *(void *)a5;
                uint64_t v86 = v85 >> 2;
                if (v85 >> 2 <= (unint64_t)(v84 + 1)) {
                  uint64_t v86 = v84 + 1;
                }
                if ((unint64_t)v85 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v87 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v87 = v86;
                }
                if (v87) {
                  v88 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v137, v87);
                }
                else {
                  v88 = 0;
                }
                v89 = &v88[8 * v84];
                *(void *)v89 = v27;
                unsigned __int8 v31 = v89 + 8;
                unint64_t v91 = *(unsigned char **)a5;
                uint64_t v90 = *(unsigned char **)(a5 + 8);
                if (v90 != *(unsigned char **)a5)
                {
                  do
                  {
                    int v92 = *((_DWORD *)v90 - 2);
                    v90 -= 8;
                    char v93 = v90[4];
                    *((_DWORD *)v89 - 2) = v92;
                    v89 -= 8;
                    v89[4] = v93;
                  }
                  while (v90 != v91);
                  uint64_t v90 = *(unsigned char **)a5;
                }
                *(void *)a5 = v89;
                *(void *)(a5 + 8) = v31;
                *(void *)(a5 + 16) = &v88[8 * v87];
                if (v90) {
                  operator delete(v90);
                }
              }
              else
              {
                *float v30 = v27;
                unsigned __int8 v31 = v30 + 1;
              }
              *(void *)(a5 + 8) = v31;
              uint64_t v95 = *(void **)(a5 + 56);
              unint64_t v94 = *(void *)(a5 + 64);
              if ((unint64_t)v95 >= v94)
              {
                uint64_t v97 = ((uint64_t)v95 - *v140) >> 3;
                if ((unint64_t)(v97 + 1) >> 61) {
                  goto LABEL_159;
                }
                uint64_t v98 = v94 - *v140;
                uint64_t v99 = v98 >> 2;
                if (v98 >> 2 <= (unint64_t)(v97 + 1)) {
                  uint64_t v99 = v97 + 1;
                }
                if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v100 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v100 = v99;
                }
                if (v100) {
                  unint64_t v101 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v136, v100);
                }
                else {
                  unint64_t v101 = 0;
                }
                unint64_t v102 = &v101[8 * v97];
                *(void *)unint64_t v102 = v28;
                unint64_t v96 = v102 + 8;
                uint64_t v104 = *(unsigned char **)(a5 + 48);
                v103 = *(unsigned char **)(a5 + 56);
                if (v103 != v104)
                {
                  do
                  {
                    int v105 = *((_DWORD *)v103 - 2);
                    v103 -= 8;
                    char v106 = v103[4];
                    *((_DWORD *)v102 - 2) = v105;
                    v102 -= 8;
                    v102[4] = v106;
                  }
                  while (v103 != v104);
                  v103 = (unsigned char *)*v140;
                }
                *(void *)(a5 + 48) = v102;
                *(void *)(a5 + 56) = v96;
                *(void *)(a5 + 64) = &v101[8 * v100];
                if (v103) {
                  operator delete(v103);
                }
              }
              else
              {
                *uint64_t v95 = v28;
                unint64_t v96 = v95 + 1;
              }
              *(void *)(a5 + 56) = v96;
              int v108 = *(void **)(a5 + 32);
              unint64_t v107 = *(void *)(a5 + 40);
              if ((unint64_t)v108 >= v107)
              {
                uint64_t v110 = ((uint64_t)v108 - *v139) >> 3;
                if ((unint64_t)(v110 + 1) >> 61) {
LABEL_158:
                }
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                uint64_t v111 = v107 - *v139;
                uint64_t v112 = v111 >> 2;
                if (v111 >> 2 <= (unint64_t)(v110 + 1)) {
                  uint64_t v112 = v110 + 1;
                }
                if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v113 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v113 = v112;
                }
                if (v113) {
                  unint64_t v114 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v135, v113);
                }
                else {
                  unint64_t v114 = 0;
                }
                unint64_t v115 = &v114[8 * v110];
                *(void *)unint64_t v115 = v26;
                int v109 = v115 + 8;
                unsigned int v117 = *(unsigned char **)(a5 + 24);
                int v116 = *(unsigned char **)(a5 + 32);
                if (v116 != v117)
                {
                  do
                  {
                    int v118 = *((_DWORD *)v116 - 2);
                    v116 -= 8;
                    char v119 = v116[4];
                    *((_DWORD *)v115 - 2) = v118;
                    v115 -= 8;
                    v115[4] = v119;
                  }
                  while (v116 != v117);
                  int v116 = (unsigned char *)*v139;
                }
                *(void *)(a5 + 24) = v115;
                *(void *)(a5 + 32) = v109;
                *(void *)(a5 + 40) = &v114[8 * v113];
                if (v116) {
                  operator delete(v116);
                }
              }
              else
              {
                *int v108 = v26;
                int v109 = v108 + 1;
              }
              *(void *)(a5 + 32) = v109;
              v121 = *(void **)(a5 + 80);
              unint64_t v120 = *(void *)(a5 + 88);
              if ((unint64_t)v121 >= v120)
              {
                uint64_t v123 = ((uint64_t)v121 - *v24) >> 3;
                if ((unint64_t)(v123 + 1) >> 61) {
LABEL_159:
                }
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                uint64_t v124 = v120 - *v24;
                uint64_t v125 = v124 >> 2;
                if (v124 >> 2 <= (unint64_t)(v123 + 1)) {
                  uint64_t v125 = v123 + 1;
                }
                if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v126 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v126 = v125;
                }
                if (v126) {
                  v127 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v134, v126);
                }
                else {
                  v127 = 0;
                }
                v128 = &v127[8 * v123];
                *(void *)v128 = v138;
                v122 = v128 + 8;
                long long v130 = *(unsigned char **)(a5 + 72);
                unint64_t v129 = *(unsigned char **)(a5 + 80);
                uint64_t v22 = v24;
                if (v129 != v130)
                {
                  do
                  {
                    int v131 = *((_DWORD *)v129 - 2);
                    v129 -= 8;
                    char v132 = v129[4];
                    *((_DWORD *)v128 - 2) = v131;
                    v128 -= 8;
                    v128[4] = v132;
                  }
                  while (v129 != v130);
                  unint64_t v129 = (unsigned char *)*v24;
                }
                *(void *)(a5 + 72) = v128;
                *(void *)(a5 + 80) = v122;
                *(void *)(a5 + 88) = &v127[8 * v126];
                if (v129) {
                  operator delete(v129);
                }
              }
              else
              {
                void *v121 = v138;
                v122 = v121 + 1;
                uint64_t v22 = v24;
              }
              *(void *)(a5 + 80) = v122;
              ++v21;
            }
            else
            {
              int v33 = *(void **)(a5 + 8);
              unint64_t v32 = *(void *)(a5 + 16);
              if ((unint64_t)v33 >= v32)
              {
                uint64_t v35 = ((uint64_t)v33 - *(void *)a5) >> 3;
                if ((unint64_t)(v35 + 1) >> 61) {
                  goto LABEL_155;
                }
                uint64_t v36 = v32 - *(void *)a5;
                uint64_t v37 = v36 >> 2;
                if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
                  uint64_t v37 = v35 + 1;
                }
                if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v38 = v37;
                }
                if (v38) {
                  unint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v137, v38);
                }
                else {
                  unint64_t v39 = 0;
                }
                long long v40 = &v39[8 * v35];
                *(void *)long long v40 = 0;
                unsigned __int8 v34 = v40 + 8;
                int v42 = *(unsigned char **)a5;
                unint64_t v41 = *(unsigned char **)(a5 + 8);
                if (v41 != *(unsigned char **)a5)
                {
                  do
                  {
                    int v43 = *((_DWORD *)v41 - 2);
                    v41 -= 8;
                    char v44 = v41[4];
                    *((_DWORD *)v40 - 2) = v43;
                    v40 -= 8;
                    v40[4] = v44;
                  }
                  while (v41 != v42);
                  unint64_t v41 = *(unsigned char **)a5;
                }
                *(void *)a5 = v40;
                *(void *)(a5 + 8) = v34;
                *(void *)(a5 + 16) = &v39[8 * v38];
                if (v41) {
                  operator delete(v41);
                }
              }
              else
              {
                *int v33 = 0;
                unsigned __int8 v34 = v33 + 1;
              }
              *(void *)(a5 + 8) = v34;
              unint64_t v46 = *(void **)(a5 + 56);
              unint64_t v45 = *(void *)(a5 + 64);
              if ((unint64_t)v46 >= v45)
              {
                uint64_t v48 = ((uint64_t)v46 - *v140) >> 3;
                if ((unint64_t)(v48 + 1) >> 61) {
                  goto LABEL_156;
                }
                uint64_t v49 = v45 - *v140;
                uint64_t v50 = v49 >> 2;
                if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
                  uint64_t v50 = v48 + 1;
                }
                if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v51 = v50;
                }
                if (v51) {
                  uint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v136, v51);
                }
                else {
                  uint64_t v52 = 0;
                }
                unint64_t v53 = &v52[8 * v48];
                *(void *)unint64_t v53 = 0;
                uint64_t v47 = v53 + 8;
                unint64_t v55 = *(unsigned char **)(a5 + 48);
                int v54 = *(unsigned char **)(a5 + 56);
                if (v54 != v55)
                {
                  do
                  {
                    int v56 = *((_DWORD *)v54 - 2);
                    v54 -= 8;
                    char v57 = v54[4];
                    *((_DWORD *)v53 - 2) = v56;
                    v53 -= 8;
                    v53[4] = v57;
                  }
                  while (v54 != v55);
                  int v54 = (unsigned char *)*v140;
                }
                *(void *)(a5 + 48) = v53;
                *(void *)(a5 + 56) = v47;
                *(void *)(a5 + 64) = &v52[8 * v51];
                if (v54) {
                  operator delete(v54);
                }
              }
              else
              {
                *unint64_t v46 = 0;
                uint64_t v47 = v46 + 1;
              }
              *(void *)(a5 + 56) = v47;
              int v59 = *(void **)(a5 + 32);
              unint64_t v58 = *(void *)(a5 + 40);
              if ((unint64_t)v59 >= v58)
              {
                uint64_t v61 = ((uint64_t)v59 - *v139) >> 3;
                if ((unint64_t)(v61 + 1) >> 61) {
LABEL_155:
                }
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                uint64_t v62 = v58 - *v139;
                uint64_t v63 = v62 >> 2;
                if (v62 >> 2 <= (unint64_t)(v61 + 1)) {
                  uint64_t v63 = v61 + 1;
                }
                if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v64 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v64 = v63;
                }
                if (v64) {
                  unint64_t v65 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v135, v64);
                }
                else {
                  unint64_t v65 = 0;
                }
                uint64_t v66 = &v65[8 * v61];
                *(void *)uint64_t v66 = 0;
                BOOL v60 = v66 + 8;
                uint64_t v68 = *(unsigned char **)(a5 + 24);
                v67 = *(unsigned char **)(a5 + 32);
                if (v67 != v68)
                {
                  do
                  {
                    int v69 = *((_DWORD *)v67 - 2);
                    v67 -= 8;
                    char v70 = v67[4];
                    *((_DWORD *)v66 - 2) = v69;
                    v66 -= 8;
                    v66[4] = v70;
                  }
                  while (v67 != v68);
                  v67 = (unsigned char *)*v139;
                }
                *(void *)(a5 + 24) = v66;
                *(void *)(a5 + 32) = v60;
                *(void *)(a5 + 40) = &v65[8 * v64];
                if (v67) {
                  operator delete(v67);
                }
              }
              else
              {
                *int v59 = 0;
                BOOL v60 = v59 + 1;
              }
              *(void *)(a5 + 32) = v60;
              v72 = *(void **)(a5 + 80);
              unint64_t v71 = *(void *)(a5 + 88);
              if ((unint64_t)v72 >= v71)
              {
                uint64_t v74 = ((uint64_t)v72 - *v22) >> 3;
                if ((unint64_t)(v74 + 1) >> 61) {
LABEL_156:
                }
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                uint64_t v75 = v71 - *v22;
                uint64_t v76 = v75 >> 2;
                if (v75 >> 2 <= (unint64_t)(v74 + 1)) {
                  uint64_t v76 = v74 + 1;
                }
                if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v77 = v76;
                }
                if (v77) {
                  uint64_t v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v134, v77);
                }
                else {
                  uint64_t v78 = 0;
                }
                unint64_t v79 = &v78[8 * v74];
                *(void *)unint64_t v79 = 0;
                long long v73 = v79 + 8;
                v81 = *(unsigned char **)(a5 + 72);
                v80 = *(unsigned char **)(a5 + 80);
                if (v80 != v81)
                {
                  do
                  {
                    int v82 = *((_DWORD *)v80 - 2);
                    v80 -= 8;
                    char v83 = v80[4];
                    *((_DWORD *)v79 - 2) = v82;
                    v79 -= 8;
                    v79[4] = v83;
                  }
                  while (v80 != v81);
                  v80 = (unsigned char *)*v22;
                }
                *(void *)(a5 + 72) = v79;
                *(void *)(a5 + 80) = v73;
                *(void *)(a5 + 88) = &v78[8 * v77];
                if (v80) {
                  operator delete(v80);
                }
              }
              else
              {
                void *v72 = 0;
                long long v73 = v72 + 1;
              }
              *(void *)(a5 + 80) = v73;
            }
          }
          while (v23++ != v18);
          unint64_t v20 = __p;
          __int16 v19 = v18 - a3;
        }
        *(_DWORD *)(a5 + 96) = a3;
        *(unsigned char *)(a5 + 100) = 1;
        *(_DWORD *)(a5 + 104) = v18;
        *(unsigned char *)(a5 + 108) = 1;
        *(_WORD *)(a5 + 112) = v19 - 43;
      }
      if (v20)
      {
        char v142 = v20;
        operator delete(v20);
      }
    }
  }
}

void sub_257D19544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::heartRateInputAcquisition::get1stJDayDailyIdx(Nightingale::heartRateInputAcquisition *this)
{
  return *(void *)this;
}

void Nightingale::heartRateInputAcquisition::acquireSlicesPeriodDayStream(uint64_t a1, uint64_t *a2, int a3, uint64_t a4)
{
  uint64_t DailyJDayIdx1stHr = Nightingale::heartRateInputAcquisition::getDailyJDayIdx1stHr(a1, (uint64_t)a2);
  *(_DWORD *)a1 = DailyJDayIdx1stHr;
  *(unsigned char *)(a1 + 4) = BYTE4(DailyJDayIdx1stHr);
  *(_DWORD *)(a1 + 8) = v9;
  *(unsigned char *)(a1 + 12) = BYTE4(v9);
  if ((DailyJDayIdx1stHr & 0xFF00000000) != 0 && (v9 & 0xFF00000000) != 0)
  {
    Nightingale::heartRateInputAcquisition::acquireSlicesJDayRange(a1, a2, a3 - 44, a3, a4);
  }
}

Nightingale::heartRateInputValidation *Nightingale::heartRateInputValidation::heartRateInputValidation(Nightingale::heartRateInputValidation *this, const Nightingale::ngt_Config *a2)
{
  int v4 = (Nightingale::ngt_Config *)Nightingale::sensorInputProcessBase::sensorInputProcessBase(this);
  Nightingale::ngt_Config::ngt_Config(v4, a2);
  *((_WORD *)this + 156) = 0;
  return this;
}

void sub_257D19644(_Unwind_Exception *a1)
{
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase(v1);
  _Unwind_Resume(a1);
}

void Nightingale::heartRateInputValidation::~heartRateInputValidation(void **this)
{
  Nightingale::ngt_Config::~ngt_Config(this);
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase(v1);
}

{
  Nightingale::sensorInputProcessBase *v1;
  uint64_t vars8;

  Nightingale::ngt_Config::~ngt_Config(this);
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase(v1);
}

void Nightingale::heartRateInputValidation::process(uint64_t a1, void *a2, uint64_t *a3, int a4)
{
  if (Nightingale::heartRateInputValidation::validateSizeOfSlices(a1, (uint64_t)a2))
  {
    uint64_t v8 = Nightingale::heartRateInputValidation::validateHrSamples(a1, a2);
    if (a4)
    {
      Nightingale::heartRateInputValidation::validateHrSlices(v8, (uint64_t)a2, a3);
    }
  }
}

BOOL Nightingale::heartRateInputValidation::validateSizeOfSlices(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  uint64_t v3 = *(void *)(a2 + 56);
  if (v2 == v3) {
    return 0;
  }
  BOOL v4 = !*(_WORD *)(a2 + 112) || *(unsigned char *)(a2 + 100) == 0;
  if (v4 || *(unsigned char *)(a2 + 108) == 0) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  uint64_t v7 = *(void *)(a2 + 32);
  if (v6 == v7) {
    return 0;
  }
  uint64_t v8 = *(void *)(a2 + 72);
  uint64_t v9 = *(void *)(a2 + 80);
  if (v8 == v9) {
    return 0;
  }
  uint64_t v10 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3;
  return v10 == (v7 - v6) >> 3 && v10 == (v3 - v2) >> 3 && v10 == (v9 - v8) >> 3;
}

uint64_t Nightingale::heartRateInputValidation::validateHrSamples(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  uint64_t v3 = a2[7];
  if (v2 != v3)
  {
    int v4 = *(_DWORD *)(result + 132);
    uint64_t v5 = (unsigned char *)(*a2 + 4);
    do
    {
      if (!*(unsigned char *)(v2 + 4) || *(_DWORD *)v2 < v4)
      {
        if (*v5) {
          unsigned char *v5 = 0;
        }
        if (*(unsigned char *)(v2 + 4)) {
          *(unsigned char *)(v2 + 4) = 0;
        }
      }
      v2 += 8;
      v5 += 8;
    }
    while (v2 != v3);
  }
  uint64_t v6 = a2[9];
  uint64_t v7 = a2[10];
  if (v6 != v7)
  {
    int v8 = *(_DWORD *)(result + 136);
    uint64_t v9 = (unsigned char *)(a2[3] + 4);
    do
    {
      if (!*(unsigned char *)(v6 + 4) || *(_DWORD *)v6 < v8)
      {
        if (*v9) {
          unsigned char *v9 = 0;
        }
        if (*(unsigned char *)(v6 + 4)) {
          *(unsigned char *)(v6 + 4) = 0;
        }
      }
      v6 += 8;
      v9 += 8;
    }
    while (v6 != v7);
  }
  return result;
}

void Nightingale::heartRateInputValidation::validateHrSlices(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (*(_WORD *)(a2 + 112))
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = 0;
      memset(__p, 0, sizeof(__p));
      for (uint64_t i = 4; i != 364; i += 8)
      {
        if (!*(unsigned char *)(*(void *)(a2 + 48) + v5 + i)) {
          ++v7;
        }
      }
      BOOL v15 = (float)((float)v7 / 45.0) < 0.7;
      std::vector<BOOL>::push_back((uint64_t)__p, &v15);
      uint64_t v9 = 0;
      for (uint64_t j = 4; j != 364; j += 8)
      {
        if (!*(unsigned char *)(*(void *)(a2 + 72) + v5 + j)) {
          ++v9;
        }
      }
      BOOL v15 = (float)((float)v9 / 45.0) < 1.0;
      std::vector<BOOL>::push_back((uint64_t)__p, &v15);
      uint64_t v11 = 0;
      for (uint64_t k = 4; k != 364; k += 8)
      {
        if (!*(unsigned char *)(*(void *)(a2 + 48) + v5 + k)) {
          ++v11;
        }
      }
      BOOL v15 = (float)((float)v11 / 45.0) < 0.5;
      std::vector<BOOL>::push_back((uint64_t)__p, &v15);
      unint64_t v13 = a3[1];
      if (v13 >= a3[2])
      {
        uint64_t v14 = std::vector<std::vector<BOOL>>::__push_back_slow_path<std::vector<BOOL> const&>(a3, (uint64_t)__p);
      }
      else
      {
        std::vector<BOOL>::vector((void *)a3[1], (uint64_t)__p);
        uint64_t v14 = v13 + 24;
        a3[1] = v13 + 24;
      }
      a3[1] = v14;
      if (__p[0]) {
        operator delete(__p[0]);
      }
      ++v6;
      v5 += 8;
    }
    while (v6 < *(unsigned __int16 *)(a2 + 112));
  }
}

void sub_257D199F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<BOOL>::push_back(uint64_t a1, unsigned char *a2)
{
  unint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  if (v4 == v5 << 6)
  {
    if ((uint64_t)(v4 + 1) < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v6 = v5 << 7;
    if (v6 <= (v4 & 0xFFFFFFFFFFFFFFC0) + 64) {
      unint64_t v6 = (v4 & 0xFFFFFFFFFFFFFFC0) + 64;
    }
    if (v4 <= 0x3FFFFFFFFFFFFFFELL) {
      unint64_t v7 = v6;
    }
    else {
      unint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
    }
    std::vector<BOOL>::reserve((char **)a1, v7);
    unint64_t v4 = *(void *)(a1 + 8);
  }
  *(void *)(a1 + 8) = v4 + 1;
  int v8 = *(char **)a1;
  unint64_t v9 = v4 >> 6;
  uint64_t v10 = 1 << v4;
  if (*a2) {
    uint64_t v11 = *(void *)&v8[8 * v9] | v10;
  }
  else {
    uint64_t v11 = *(void *)&v8[8 * v9] & ~v10;
  }
  *(void *)&v8[8 * v9] = v11;
}

BOOL Nightingale::heartRateInputValidation::validateASlice(float a1, uint64_t a2, void *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5 = 0;
  for (uint64_t i = 4; i != 364; i += 8)
  {
    if (!*(unsigned char *)(*a3 + 8 * a4 + i)) {
      ++v5;
    }
  }
  return (float)((float)v5 / (float)a5) < a1;
}

Nightingale::sensorInputProcessBase *Nightingale::heartRateInputPreCondition::heartRateInputPreCondition(Nightingale::sensorInputProcessBase *a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4)
{
  int v8 = (void *)Nightingale::sensorInputProcessBase::sensorInputProcessBase(a1);
  v8[1] = a2;
  void v8[2] = a3;
  Nightingale::ngt_Config::ngt_Config((Nightingale::ngt_Config *)(v8 + 3), a4);
  return a1;
}

void sub_257D19B5C(_Unwind_Exception *a1)
{
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase(v1);
  _Unwind_Resume(a1);
}

void Nightingale::heartRateInputPreCondition::~heartRateInputPreCondition(void **this)
{
  Nightingale::ngt_Config::~ngt_Config(this + 3);
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase((Nightingale::sensorInputProcessBase *)this);
}

{
  uint64_t vars8;

  Nightingale::ngt_Config::~ngt_Config(this + 3);
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase((Nightingale::sensorInputProcessBase *)this);
}

BOOL Nightingale::heartRateInputPreCondition::preConditionHr(unsigned int ***this)
{
  unint64_t v2 = Nightingale::heartRateInputPreCondition::find1stHrSampleDayStreamLstmHr((Nightingale::heartRateInputPreCondition *)this);
  BOOL v4 = (v3 & 0xFF00000000) != 0 && (v2 & 0xFF00000000) != 0;
  if (v4)
  {
    unint64_t v5 = v2;
    unint64_t v6 = v3;
    unint64_t v7 = this[2];
    int v8 = *v7;
    unint64_t v9 = ((char *)v7[1] - (char *)*v7) >> 3;
    if ((int)v9 >= 1)
    {
      unint64_t v10 = 0;
      do
      {
        if (v9 <= v10) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v11 = &v8[2 * v10];
        if (*((unsigned char *)v11 + 4)) {
          int v12 = *v11;
        }
        else {
          int v12 = 2143289344;
        }
        unint64_t v13 = (unint64_t)v7[17];
        uint64_t v14 = (int *)v7[16];
        if ((unint64_t)v14 >= v13)
        {
          int v16 = (int *)v7[15];
          uint64_t v17 = v14 - v16;
          if ((unint64_t)(v17 + 1) >> 62) {
LABEL_82:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          unint64_t v18 = v13 - (void)v16;
          unint64_t v19 = (uint64_t)(v13 - (void)v16) >> 1;
          if (v19 <= v17 + 1) {
            unint64_t v19 = v17 + 1;
          }
          if (v18 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v19;
          }
          if (v20)
          {
            int v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v7 + 17), v20);
            int v16 = (int *)v7[15];
            uint64_t v14 = (int *)v7[16];
          }
          else
          {
            int v21 = 0;
          }
          uint64_t v22 = (int *)&v21[4 * v17];
          *uint64_t v22 = v12;
          BOOL v15 = (unsigned int *)(v22 + 1);
          while (v14 != v16)
          {
            int v23 = *--v14;
            *--uint64_t v22 = v23;
          }
          v7[15] = (unsigned int *)v22;
          v7[16] = v15;
          v7[17] = (unsigned int *)&v21[4 * v20];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          *uint64_t v14 = v12;
          BOOL v15 = (unsigned int *)(v14 + 1);
        }
        v7[16] = v15;
        ++v10;
        unint64_t v7 = this[2];
        int v8 = *v7;
        unint64_t v9 = ((char *)v7[1] - (char *)*v7) >> 3;
        if ((int)v9 >= 45) {
          int v24 = 45;
        }
        else {
          int v24 = ((char *)v7[1] - (char *)*v7) >> 3;
        }
      }
      while ((uint64_t)v10 < v24);
    }
    unint64_t v25 = v7[3];
    unint64_t v26 = ((char *)v7[4] - (char *)v25) >> 3;
    if ((int)v26 >= 1)
    {
      unint64_t v27 = 0;
      do
      {
        if (v26 <= v27) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v28 = &v25[2 * v27];
        if (*((unsigned char *)v28 + 4)) {
          int v29 = *v28;
        }
        else {
          int v29 = 2143289344;
        }
        unint64_t v30 = (unint64_t)v7[20];
        unsigned __int8 v31 = (int *)v7[19];
        if ((unint64_t)v31 >= v30)
        {
          int v33 = (int *)v7[18];
          uint64_t v34 = v31 - v33;
          if ((unint64_t)(v34 + 1) >> 62) {
            goto LABEL_82;
          }
          unint64_t v35 = v30 - (void)v33;
          unint64_t v36 = (uint64_t)(v30 - (void)v33) >> 1;
          if (v36 <= v34 + 1) {
            unint64_t v36 = v34 + 1;
          }
          if (v35 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          if (v37)
          {
            unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v7 + 20), v37);
            int v33 = (int *)v7[18];
            unsigned __int8 v31 = (int *)v7[19];
          }
          else
          {
            unint64_t v38 = 0;
          }
          unint64_t v39 = (int *)&v38[4 * v34];
          int *v39 = v29;
          unint64_t v32 = (unsigned int *)(v39 + 1);
          while (v31 != v33)
          {
            int v40 = *--v31;
            *--unint64_t v39 = v40;
          }
          v7[18] = (unsigned int *)v39;
          v7[19] = v32;
          v7[20] = (unsigned int *)&v38[4 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *unsigned __int8 v31 = v29;
          unint64_t v32 = (unsigned int *)(v31 + 1);
        }
        v7[19] = v32;
        ++v27;
        unint64_t v7 = this[2];
        unint64_t v25 = v7[3];
        unint64_t v26 = ((char *)v7[4] - (char *)v25) >> 3;
        if ((int)v26 >= 45) {
          int v41 = 45;
        }
        else {
          int v41 = ((char *)v7[4] - (char *)v25) >> 3;
        }
      }
      while ((uint64_t)v27 < v41);
      int v8 = *v7;
    }
    int v42 = v7[1];
    if (v8 != v42)
    {
      do
      {
        if (*((unsigned char *)v8 + 4))
        {
          unint64_t v5 = *v8 | ((unint64_t)*((unsigned __int8 *)v8 + 4) << 32);
        }
        else
        {
          unsigned int *v8 = v5;
          *((unsigned char *)v8 + 4) = BYTE4(v5);
        }
        v8 += 2;
      }
      while (v8 != v42);
      unint64_t v7 = this[2];
    }
    int v43 = v7[3];
    char v44 = v7[4];
    if (v43 != v44)
    {
      do
      {
        if (*((unsigned char *)v43 + 4))
        {
          unint64_t v6 = *v43 | ((unint64_t)*((unsigned __int8 *)v43 + 4) << 32);
        }
        else
        {
          *int v43 = v6;
          *((unsigned char *)v43 + 4) = BYTE4(v6);
        }
        v43 += 2;
      }
      while (v43 != v44);
      unint64_t v7 = this[2];
    }
    unint64_t v45 = *v7;
    unint64_t v46 = v7[1];
    if (*v7 != v46)
    {
      do
      {
        if (*((unsigned char *)v45 + 4))
        {
          *(float *)unint64_t v45 = (float)(*(float *)v45 + -68.352) / 9.696;
          *((unsigned char *)v45 + 4) = 1;
        }
        v45 += 2;
      }
      while (v45 != v46);
      unint64_t v7 = this[2];
    }
    uint64_t v47 = v7[3];
    for (uint64_t i = v7[4]; v47 != i; v47 += 2)
    {
      if (*((unsigned char *)v47 + 4))
      {
        *(float *)uint64_t v47 = (float)(*(float *)v47 + -64.88) / 9.6825;
        *((unsigned char *)v47 + 4) = 1;
      }
    }
  }
  return v4;
}

unint64_t Nightingale::heartRateInputPreCondition::find1stHrSampleDayStreamLstmHr(Nightingale::heartRateInputPreCondition *this)
{
  uint64_t v1 = *((void *)this + 2);
  if (*(unsigned char *)(v1 + 100) && *(unsigned char *)(v1 + 108))
  {
    unint64_t v2 = (uint64_t *)*((void *)this + 1);
    BOOL v4 = (unsigned char *)*v2;
    unint64_t v3 = (unsigned char *)v2[1];
    if ((unsigned char *)*v2 == v3)
    {
      unsigned __int8 v5 = 0;
      int v7 = 0;
    }
    else
    {
      unsigned __int8 v5 = 0;
      unint64_t v6 = v4 + 36;
      int v7 = 0;
      do
      {
        int v8 = v6 - 36;
        if (*((_DWORD *)v6 - 9) <= *(_DWORD *)(v1 + 96)
          && *(v6 - 16)
          && *v6
          && *((_DWORD *)v6 - 1) >= *((_DWORD *)this + 39))
        {
          unsigned __int8 v5 = 1;
          int v7 = *((_DWORD *)v6 - 5);
        }
        v6 += 60;
      }
      while (v8 + 60 != v3);
    }
    unint64_t v10 = (unint64_t)v5 << 32;
    uint64_t v11 = v7 & 0xFFFFFF00;
    uint64_t v9 = v7;
  }
  else
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    uint64_t v11 = 0;
  }
  return v10 | v9 | v11;
}

void Nightingale::heartRateInputPreCondition::forwardFill(uint64_t a1, unsigned int **a2, unint64_t a3)
{
  unint64_t v3 = *a2;
  BOOL v4 = a2[1];
  while (v3 != v4)
  {
    if (*((unsigned char *)v3 + 4))
    {
      a3 = *v3 | ((unint64_t)*((unsigned __int8 *)v3 + 4) << 32);
    }
    else
    {
      unsigned int *v3 = a3;
      *((unsigned char *)v3 + 4) = BYTE4(a3);
    }
    v3 += 2;
  }
}

void Nightingale::heartRateInputPreCondition::standardizeVec(float a1, float a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  uint64_t v5 = a4[1];
  if (*a4 != v5)
  {
    do
    {
      if (*(unsigned char *)(v4 + 4))
      {
        *(float *)uint64_t v4 = (float)(*(float *)v4 - a1) / a2;
        *(unsigned char *)(v4 + 4) = 1;
      }
      v4 += 8;
    }
    while (v4 != v5);
  }
}

void *std::vector<Nightingale::ngt_DayInput>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_DayInput const*>,std::__wrap_iter<Nightingale::ngt_DayInput const*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    double result = std::vector<Nightingale::ngt_DayInput>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      double result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D1A1A0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Nightingale::ngt_DayInput>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x444444444444445) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_DayInput>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[60 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_DayInput>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x444444444444445) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(60 * a2);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(8 * a2);
}

Nightingale::ngt_Config *Nightingale::ngt_Config::ngt_Config(Nightingale::ngt_Config *this, const Nightingale::ngt_Config *a2)
{
  *(_OWORD *)this = *(_OWORD *)a2;
  long long v4 = *((_OWORD *)a2 + 1);
  long long v5 = *((_OWORD *)a2 + 2);
  long long v6 = *((_OWORD *)a2 + 4);
  *((_OWORD *)this + 3) = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 4) = v6;
  *((_OWORD *)this + 1) = v4;
  *((_OWORD *)this + 2) = v5;
  long long v7 = *((_OWORD *)a2 + 5);
  long long v8 = *((_OWORD *)a2 + 6);
  long long v9 = *((_OWORD *)a2 + 7);
  *(_OWORD *)((char *)this + 124) = *(_OWORD *)((char *)a2 + 124);
  *((_OWORD *)this + 6) = v8;
  *((_OWORD *)this + 7) = v9;
  *((_OWORD *)this + 5) = v7;
  if (*((char *)a2 + 167) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)this + 6, *((const std::string::value_type **)a2 + 18), *((void *)a2 + 19));
  }
  else
  {
    long long v10 = *((_OWORD *)a2 + 9);
    *((void *)this + 20) = *((void *)a2 + 20);
    *((_OWORD *)this + 9) = v10;
  }
  if (*((char *)a2 + 191) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)this + 7, *((const std::string::value_type **)a2 + 21), *((void *)a2 + 22));
  }
  else
  {
    long long v11 = *(_OWORD *)((char *)a2 + 168);
    *((void *)this + 23) = *((void *)a2 + 23);
    *(_OWORD *)((char *)this + 168) = v11;
  }
  if (*((char *)a2 + 215) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)this + 8, *((const std::string::value_type **)a2 + 24), *((void *)a2 + 25));
  }
  else
  {
    long long v12 = *((_OWORD *)a2 + 12);
    *((void *)this + 26) = *((void *)a2 + 26);
    *((_OWORD *)this + 12) = v12;
  }
  if (*((char *)a2 + 239) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)this + 9, *((const std::string::value_type **)a2 + 27), *((void *)a2 + 28));
  }
  else
  {
    long long v13 = *(_OWORD *)((char *)a2 + 216);
    *((void *)this + 29) = *((void *)a2 + 29);
    *(_OWORD *)((char *)this + 216) = v13;
  }
  if (*((char *)a2 + 263) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)this + 10, *((const std::string::value_type **)a2 + 30), *((void *)a2 + 31));
  }
  else
  {
    long long v14 = *((_OWORD *)a2 + 15);
    *((void *)this + 32) = *((void *)a2 + 32);
    *((_OWORD *)this + 15) = v14;
  }
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>((std::string *)this + 11, *((long long **)a2 + 33), *((long long **)a2 + 34), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 34) - *((void *)a2 + 33)) >> 3));
  BOOL v15 = (std::string *)((char *)this + 288);
  if (*((char *)a2 + 311) < 0)
  {
    std::string::__init_copy_ctor_external(v15, *((const std::string::value_type **)a2 + 36), *((void *)a2 + 37));
  }
  else
  {
    long long v16 = *((_OWORD *)a2 + 18);
    *((void *)this + 38) = *((void *)a2 + 38);
    *(_OWORD *)&v15->__r_.__value_.__l.__data_ = v16;
  }
  return this;
}

void sub_257D1A450(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  if (v2[263] < 0) {
    operator delete(*v7);
  }
  if (v2[239] < 0) {
    operator delete(*v6);
  }
  if (v2[215] < 0) {
    operator delete(*v5);
  }
  if (v2[191] < 0) {
    operator delete(*v4);
  }
  if (v2[167] < 0) {
    operator delete(*v3);
  }
  _Unwind_Resume(a1);
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  long long v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    long long v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    long long v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

std::string *std::vector<std::string>::__init_with_size[abi:ne180100]<std::string*,std::string*>(std::string *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    std::string::size_type v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    double result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>((uint64_t)&v6->__r_.__value_.__r.__words[2], a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

void sub_257D1A600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::string>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(uint64_t a1, long long *a2, long long *a3, std::string *this)
{
  uint64_t v4 = this;
  long long v11 = this;
  long long v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  id v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    std::string::size_type v6 = a2;
    do
    {
      if (*((char *)v6 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v4, *(const std::string::value_type **)v6, *((void *)v6 + 1));
        uint64_t v4 = v12;
      }
      else
      {
        long long v7 = *v6;
        v4->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
        *(_OWORD *)&v4->__r_.__value_.__l.__data_ = v7;
      }
      std::string::size_type v6 = (long long *)((char *)v6 + 24);
      long long v12 = ++v4;
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_257D1A720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::string*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 - 1) < 0) {
      operator delete(*(void **)(v1 - 24));
    }
    v1 -= 24;
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:ne180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void Nightingale::ngt_Config::~ngt_Config(void **this)
{
  if (*((char *)this + 311) < 0) {
    operator delete(this[36]);
  }
  uint64_t v2 = this + 33;
  std::vector<std::string>::__destroy_vector::operator()[abi:ne180100](&v2);
  if (*((char *)this + 263) < 0) {
    operator delete(this[30]);
  }
  if (*((char *)this + 239) < 0) {
    operator delete(this[27]);
  }
  if (*((char *)this + 215) < 0) {
    operator delete(this[24]);
  }
  if (*((char *)this + 191) < 0) {
    operator delete(this[21]);
  }
  if (*((char *)this + 167) < 0) {
    operator delete(this[18]);
  }
}

void std::vector<BOOL>::reserve(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    char v10 = 0;
    long long v11 = 0uLL;
    std::vector<BOOL>::__vallocate[abi:ne180100](&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    long long v8 = *a1;
    int v9 = 0;
    std::string::size_type v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    uint64_t v4 = *a1;
    *a1 = v10;
    char v10 = v4;
    long long v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    long long v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_257D1A99C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  double result = std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*a1 + 8 * v6) = 0;
  }
  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(&v16, &v14, &v12, (uint64_t)&v11);
}

void std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,0>(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    uint64_t *v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

uint64_t std::vector<std::vector<BOOL>>::__push_back_slow_path<std::vector<BOOL> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  int v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  int v13 = v10;
  uint64_t v14 = &v10[24 * v4];
  uint64_t v16 = &v10[24 * v9];
  std::vector<BOOL>::vector(v14, a2);
  int v15 = v14 + 24;
  std::vector<std::vector<BOOL>>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<std::vector<BOOL>>::~__split_buffer(&v13);
  return v11;
}

void sub_257D1ACF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<BOOL>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void *std::vector<BOOL>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    std::vector<BOOL>::__vallocate[abi:ne180100](a1, v4);
    std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(a1, *(void **)a2, 0, (void *)(*(void *)a2 + 8 * (*(void *)(a2 + 8) >> 6)), *(void *)(a2 + 8) & 0x3F, *(void *)(a2 + 8));
  }
  return a1;
}

void std::vector<BOOL>::__construct_at_end<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>>(void *a1, void *a2, unint64_t a3, void *a4, int a5, uint64_t a6)
{
  unint64_t v6 = a1[1];
  unint64_t v7 = v6 + a6;
  a1[1] = v6 + a6;
  if (!v6 || ((v7 - 1) ^ (v6 - 1)) >= 0x40)
  {
    if (v7 >= 0x41) {
      unint64_t v8 = (v7 - 1) >> 6;
    }
    else {
      unint64_t v8 = 0;
    }
    *(void *)(*a1 + 8 * v8) = 0;
  }
  uint64_t v9 = *a1 + 8 * (v6 >> 6);
  int v10 = v6 & 0x3F;
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(a2, a3, a4, a5, (uint64_t)&v9, (uint64_t)v11);
}

void std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,true,0ul>,std::__bit_iterator<std::vector<BOOL>,false,0ul>>(void *a1@<X1>, unint64_t a2@<X2>, void *a3@<X3>, int a4@<W4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  LODWORD(v6) = a2;
  unint64_t v7 = *(uint64_t **)a5;
  int v8 = *(_DWORD *)(a5 + 8);
  if (a1 != a3 || a2 != a4)
  {
    do
    {
      uint64_t v9 = 1 << v8;
      if ((*a1 >> a2)) {
        uint64_t v10 = *v7 | v9;
      }
      else {
        uint64_t v10 = *v7 & ~v9;
      }
      uint64_t *v7 = v10;
      BOOL v11 = v6 == 63;
      BOOL v12 = v6 == 63;
      uint64_t v6 = (a2 + 1);
      if (v11) {
        uint64_t v6 = 0;
      }
      if (v8 == 63)
      {
        int v8 = 0;
        *(void *)a5 = ++v7;
      }
      else
      {
        ++v8;
      }
      a1 += v12;
      a2 = v6 | a2 & 0xFFFFFFFF00000000;
      *(_DWORD *)(a5 + 8) = v8;
    }
    while (a1 != a3 || v6 != a4);
    a1 = a3;
  }
  *(void *)a6 = a1;
  *(void *)(a6 + 8) = a2;
  *(void *)(a6 + 16) = v7;
  *(_DWORD *)(a6 + 24) = v8;
}

uint64_t std::vector<std::vector<BOOL>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>,std::reverse_iterator<std::vector<BOOL>*>,std::reverse_iterator<std::vector<BOOL>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>,std::reverse_iterator<std::vector<BOOL>*>,std::reverse_iterator<std::vector<BOOL>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      uint64_t v8 = *(a3 - 3);
      a3 -= 3;
      *(void *)(v7 - 24) = v8;
      *(void *)(v7 - 16) = a3[1];
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<BOOL>>,std::reverse_iterator<std::vector<BOOL>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*v1) {
      operator delete(*v1);
    }
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<BOOL>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::vector<BOOL>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    uint64_t v5 = *(void **)(v1 - 24);
    v1 -= 24;
    uint64_t v4 = v5;
    *(void *)(a1 + 16) = v1;
    if (v5)
    {
      operator delete(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
  }
}

void *Nightingale::fwEstimatorLuna::fwEstimatorLuna(void *a1)
{
  uint64_t v2 = Nightingale::fwEstimatorBase::fwEstimatorBase(a1);
  v2[3] = 0;
  v2[4] = 0;
  v2[5] = 0;
  uint64_t v3 = operator new(0x14uLL);
  a1[4] = v3 + 5;
  a1[5] = v3 + 5;
  v3[4] = 5;
  *(_OWORD *)uint64_t v3 = xmmword_257D5F640;
  a1[3] = v3;
  return a1;
}

void sub_257D1B0FC(_Unwind_Exception *a1)
{
  Nightingale::fwEstimatorBase::~fwEstimatorBase(v1);
  _Unwind_Resume(a1);
}

void Nightingale::fwEstimatorLuna::~fwEstimatorLuna(Nightingale::fwEstimatorLuna *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  Nightingale::fwEstimatorBase::~fwEstimatorBase(this);
}

void Nightingale::fwEstimatorLuna::getHistFwKali(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t *a6@<X5>, uint64_t a7@<X6>, uint64_t *a8@<X7>, uint64_t a9@<X8>, unsigned __int8 a10)
{
  *(unsigned char *)a9 = 0;
  *(unsigned char *)(a9 + 4) = 0;
  *(unsigned char *)(a9 + 8) = 0;
  unint64_t v32 = (unsigned int *)(a9 + 8);
  *(unsigned char *)(a9 + 12) = 0;
  *(_DWORD *)(a9 + 16) = 3;
  *(void *)(a9 + 20) = 0;
  int v15 = (_DWORD *)(a9 + 20);
  *(unsigned char *)(a9 + 32) = 0;
  *(_WORD *)(a9 + 28) = 0;
  *(int32x4_t *)(a9 + 36) = vdupq_n_s32(0x7FC00000u);
  *(unsigned char *)(a9 + 52) = 0;
  *(unsigned char *)(a9 + 56) = 0;
  *(unsigned char *)(a9 + 60) = 0;
  *(unsigned char *)(a9 + 64) = 0;
  *(unsigned char *)(a9 + 72) = 0;
  *(unsigned char *)(a9 + 96) = 0;
  *(unsigned char *)(a9 + 104) = 0;
  *(unsigned char *)(a9 + 128) = 0;
  *(unsigned char *)(a9 + 136) = 0;
  *(unsigned char *)(a9 + 140) = 0;
  *(void *)(a9 + 144) = 0x17FC00000;
  *(_DWORD *)(a9 + 152) = 0;
  *(_WORD *)(a9 + 156) = 0;
  if ((_BYTE)a5)
  {
    if (!*(unsigned char *)(a2 + 24)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(a8, *(_DWORD *)(a2 + 20) - *(_DWORD *)a2 + 1, *(_DWORD *)(a2 + 20), a3, a4, (uint64_t)&v41);
    memset(v51, 0, 24);
    std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(v51, v41, v42, 0xAAAAAAAAAAAAAAABLL * ((v42 - v41) >> 3));
    v51[3] = v43;
    uint64_t v52 = 0;
    unint64_t v53 = 0;
    uint64_t v54 = 0;
    std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v52, v44, *(uint64_t *)v45, *(void *)v45 - (void)v44);
    unint64_t v55 = 0;
    int v56 = 0;
    uint64_t v57 = 0;
    uint64_t v16 = std::vector<std::optional<float>>::__init_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(&v55, __p, (uint64_t)v47, (v47 - (unsigned char *)__p) >> 3);
    unint64_t EligibleWTmpCnts = Nightingale::fwEstimatorLuna::getEligibleWTmpCnts((uint64_t)v16, a2, v17, v18, v51);
    int v20 = EligibleWTmpCnts;
    unint64_t v21 = HIDWORD(EligibleWTmpCnts);
    if (v55)
    {
      int v56 = v55;
      operator delete(v55);
    }
    if (v52)
    {
      unint64_t v53 = v52;
      operator delete(v52);
    }
    v48[0] = (void **)v51;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v48);
    *(_DWORD *)(a9 + 24) = v20;
    *(unsigned char *)(a9 + 32) = v20 > 0;
    if ((int)v21 >= 1) {
      *(float *)(a9 + 152) = (float)v20 / (float)(int)v21;
    }
    if (__p)
    {
      uint64_t v47 = __p;
      operator delete(__p);
    }
    if (v44)
    {
      *(void *)unint64_t v45 = v44;
      operator delete(v44);
    }
    uint64_t v22 = (void **)a4;
    v48[0] = (void **)&v41;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v48);
  }
  else
  {
    uint64_t v22 = (void **)a4;
    int v20 = 0;
  }
  if (!*(unsigned char *)(a2 + 24)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  int v23 = a3;
  int v24 = *(_DWORD *)(a2 + 20);
  int v25 = *(_DWORD *)a2;
  if (Nightingale::phaseFactorProcessor::vPhasesContainsAPhase(a1, (unsigned __int8 **)(a2 + 72), 0))
  {
    if (!(v20 | BYTE4(a7))) {
      goto LABEL_28;
    }
    if (!BYTE4(a7))
    {
      *(_DWORD *)(a9 + 20) = 4;
      int v26 = 7;
      goto LABEL_30;
    }
  }
  if (v24 - v25 <= 17)
  {
    *(_DWORD *)(a9 + 20) = 4;
    int v26 = 6;
LABEL_30:
    *(_DWORD *)(a9 + 148) = v26;
    return;
  }
  if (!v20)
  {
LABEL_28:
    int v26 = 1;
    *(_DWORD *)(a9 + 20) = 1;
    goto LABEL_30;
  }
  if (!BYTE4(a7)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  uint64_t v27 = *(unsigned __int8 *)(a2 + 36);
  uint64_t v28 = (int)*(float *)(a2 + 32);
  if (!*(unsigned char *)(a2 + 36)) {
    uint64_t v28 = 0;
  }
  LODWORD(v48[0]) = *(_DWORD *)a2;
  HIDWORD(v48[0]) = a7;
  v48[1] = (void **)(v28 | (v27 << 32));
  v48[2] = v22;
  int v49 = a5;
  int v50 = 0;
  Nightingale::slidingWindowHistLuna::slidingWindowHistLuna((uint64_t)&v41, (uint64_t)v48);
  Nightingale::slidingWindowBaseLuna::process(&v41, v23, a10, (uint64_t)&v36);
  if (!v37)
  {
    int v30 = 0;
LABEL_33:
    __int16 v31 = 0;
    LODWORD(v29) = v36;
    goto LABEL_34;
  }
  uint64_t v29 = Nightingale::run_m_over_n_moving_target(v23, (int)a7 + 1, *(_DWORD *)a2);
  if ((v29 & 0xFF00000000) == 0)
  {
    int v30 = v37;
    goto LABEL_33;
  }
  int v36 = v29;
  int v37 = v30;
  int v40 = 9;
  __int16 v31 = 1;
LABEL_34:
  *int v15 = v30;
  if ((int)v29 >= 1)
  {
    *(_DWORD *)(a9 + 16) = 1;
    *(_DWORD *)(a9 + 8) = v29;
    *(unsigned char *)(a9 + 12) = 1;
    *(_DWORD *)a9 = v29 - 5;
    *(unsigned char *)(a9 + 4) = 1;
    if (Nightingale::phaseFactorProcessor::suppressFWStEnd(a1, (unsigned int *)a9, v32, a6))
    {
      int v40 = 7;
      *(_DWORD *)(a9 + 20) = 0;
      *(unsigned char *)(a9 + 29) = 1;
    }
    Nightingale::fwEstimatorBase::suppressHistFWOverCycleBoundary(a1, *(_DWORD *)a2, a7, a9);
  }
  if (a10)
  {
    *(void *)(a9 + 36) = v38;
    *(_DWORD *)(a9 + 48) = v39;
    *(_DWORD *)(a9 + 148) = v40;
    *(_WORD *)(a9 + 156) = v31 | 0x100;
  }
  Nightingale::slidingWindowHistLuna::~slidingWindowHistLuna((Nightingale::slidingWindowHistLuna *)&v41);
}

void sub_257D1B538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  Nightingale::slidingWindowHistLuna::~slidingWindowHistLuna((Nightingale::slidingWindowHistLuna *)va);
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle(v10);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorLuna::getEligibleWTmpCnts(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (!*(unsigned char *)(a2 + 24)
    || (v5 = *a5, uint64_t v6 = a5[1], *a5 == v6)
    || (uint64_t v7 = *(void *)(v5 + 8), *(void *)v5 == v7)
    || *(void *)(v6 - 24) == *(void *)(v6 - 16))
  {
    unsigned int v28 = 0;
    uint64_t v29 = 0;
    return v29 | v28;
  }
  LODWORD(v8) = 0;
  unint64_t v9 = (unint64_t)(v7 - *(void *)v5) >> 2;
  __p = 0;
  unint64_t v32 = 0;
  int v33 = 0;
  do
  {
    int MissingCnt = Nightingale::getMissingCnt((float **)v5);
    int v11 = MissingCnt;
    char v12 = v32;
    if (v32 >= v33)
    {
      long long v14 = __p;
      uint64_t v15 = (v32 - __p) >> 2;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v17 = v33 - __p;
      if ((v33 - __p) >> 1 > v16) {
        unint64_t v16 = v17 >> 1;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v33, v18);
        long long v14 = __p;
        char v12 = v32;
      }
      else
      {
        int v19 = 0;
      }
      int v20 = &v19[4 * v15];
      *(_DWORD *)int v20 = v11;
      long long v13 = v20 + 4;
      while (v12 != v14)
      {
        int v21 = *((_DWORD *)v12 - 1);
        v12 -= 4;
        *((_DWORD *)v20 - 1) = v21;
        v20 -= 4;
      }
      __p = v20;
      int v33 = &v19[4 * v18];
      if (v14) {
        operator delete(v14);
      }
    }
    else
    {
      *(_DWORD *)unint64_t v32 = MissingCnt;
      long long v13 = v32 + 4;
    }
    unint64_t v32 = v13;
    uint64_t v8 = (v8 + v9 - v11);
    v5 += 24;
  }
  while (v5 != v6);
  if (__p == v13)
  {
    unsigned int v28 = 0;
    if (!__p) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v22 = (int *)(__p + 4);
    int v23 = __p;
    if (__p + 4 != v13)
    {
      int v24 = *(_DWORD *)__p;
      int v23 = __p;
      int v25 = (int *)(__p + 4);
      do
      {
        int v27 = *v25++;
        int v26 = v27;
        if (v27 < v24)
        {
          int v24 = v26;
          int v23 = (char *)v22;
        }
        uint64_t v22 = v25;
      }
      while (v25 != (int *)v13);
    }
    unsigned int v28 = v9 - *(_DWORD *)v23;
    if (!__p) {
      goto LABEL_31;
    }
  }
  operator delete(__p);
LABEL_31:
  uint64_t v29 = v8 << 32;
  return v29 | v28;
}

void sub_257D1B7A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn(Nightingale::extractKaliInputsRtn *this)
{
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 4);
  if (v3)
  {
    *((void *)this + 5) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void **)this;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle(Nightingale::fwEstimatorHistOutACycle *this)
{
  if (*((unsigned char *)this + 128))
  {
    uint64_t v2 = (void *)*((void *)this + 13);
    if (v2)
    {
      *((void *)this + 14) = v2;
      operator delete(v2);
    }
  }
  if (*((unsigned char *)this + 96))
  {
    uint64_t v3 = (void *)*((void *)this + 9);
    if (v3)
    {
      *((void *)this + 10) = v3;
      operator delete(v3);
    }
  }
}

unint64_t Nightingale::fwEstimatorLuna::getJDayCycleEnd(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 68))
  {
    float v2 = roundf(*(float *)(a2 + 64));
    if (v2 <= 0.0)
    {
      LOBYTE(v3) = 0;
      unint64_t v5 = 0;
      unsigned int v4 = 0;
    }
    else
    {
      int v3 = (int)(float)((float)(v2 + (float)*(int *)a2) + -1.0);
      unsigned int v4 = v3 & 0xFFFFFF00;
      unint64_t v5 = 0x100000000;
    }
  }
  else
  {
    int v3 = *(_DWORD *)(a2 + 20);
    unsigned int v4 = v3 & 0xFFFFFF00;
    unint64_t v5 = (unint64_t)*(unsigned __int8 *)(a2 + 24) << 32;
  }
  return v5 | v4 | v3;
}

void Nightingale::fwEstimatorLuna::getFwEndLuna(uint64_t a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, unint64_t a5@<X4>, int a6@<W5>, int *a7@<X8>)
{
  *((unsigned char *)a7 + 4) = 0;
  *((unsigned char *)a7 + 8) = 0;
  *((unsigned char *)a7 + 12) = 0;
  *((unsigned char *)a7 + 16) = 0;
  *((unsigned char *)a7 + 20) = 0;
  *((unsigned char *)a7 + 24) = 0;
  a7[8] = 8;
  uint64_t v8 = a7 + 8;
  *((_WORD *)a7 + 18) = 0;
  *((unsigned char *)a7 + 38) = 0;
  *((void *)a7 + 5) = -1;
  *((unsigned char *)a7 + 52) = 0;
  *((void *)a7 + 8) = 0;
  *((unsigned char *)a7 + 56) = 0;
  *((void *)a7 + 9) = 0;
  *((void *)a7 + 10) = 0;
  a7[22] = -1;
  *((unsigned char *)a7 + 92) = 0;
  *((unsigned char *)a7 + 96) = 0;
  *a7 = 7;
  uint64_t v9 = a2[1];
  if (*a2 == v9 || !*(unsigned char *)(v9 - 60) || !*(unsigned char *)(a4 + 36)) {
    return;
  }
  int v15 = *(_DWORD *)(v9 - 96);
  int v52 = (int)(float)((float)(roundf(*(float *)(v9 - 64)) + (float)v15) + -13.0);
  int v53 = v15 + 10;
  uint64_t v16 = a3[1];
  int v51 = v15;
  if (*a3 == v16)
  {
    int v19 = -1;
  }
  else
  {
    int v17 = *(_DWORD *)(a4 + 32);
    int v18 = v15 + 66;
    if (*(_DWORD *)(v16 - 60) != v17 || !*(unsigned char *)(v16 - 4)) {
      --v17;
    }
    if (v18 >= v17) {
      int v19 = v17;
    }
    else {
      int v19 = v18;
    }
  }
  int v20 = v52 - 3;
  if (v53 > v52 - 3) {
    int v20 = v53;
  }
  int v56 = v20;
  memset(v77, 0, sizeof(v77));
  int v21 = v52 + 10;
  if (v52 + 10 >= v19) {
    int v21 = v19;
  }
  int v54 = v21;
  memset(v76, 0, sizeof(v76));
  memset(v75, 0, sizeof(v75));
  v71[0] = 8;
  std::vector<Nightingale::fwEndConfirmationFailureReason_t>::vector(&v73, 3uLL, v71);
  __int16 v72 = 0;
  Nightingale::lstmLunaFw::lstmLunaFw((uint64_t)v71, (uint64_t)a3, (uint64_t)a2, (const Nightingale::ngt_Config *)a4);
  int v49 = v8;
  uint64_t v50 = a1;
  unint64_t v55 = a3;
  uint64_t v48 = a4;
  Nightingale::rfLuna::rfLuna(v70, a3, a2, a4);
  float v22 = -1.0;
  if (v53 > v19)
  {
LABEL_51:
    if (!a6) {
      goto LABEL_62;
    }
    goto LABEL_52;
  }
  uint64_t v23 = 0;
  if (v53 <= v52 + 3) {
    int v24 = v52 + 3;
  }
  else {
    int v24 = v53;
  }
  int v25 = v51 + 9;
  while (1)
  {
    if (((int v26 = v25 + 1,
           Nightingale::lstmLunaFw::getOngoingFwLstmLunaAvailibilityFail((Nightingale::lstmLunaFw *)v71, (v25 + 1), 0.1))|| Nightingale::rfLuna::getRfAvailabilityFail((Nightingale::rfLuna *)v70, v25 + 1, 0.1, 1))&& v26 >= v24&& v52 + 8 >= v26)
    {
      uint64_t v27 = a2[1];
      LOBYTE(v28) = *(unsigned char *)(v27 - 60);
      if ((_BYTE)v28)
      {
        unsigned int v28 = (int)*(float *)(v27 - 64);
        uint64_t v29 = v28 >> 8;
        uint64_t v30 = 0x100000000;
      }
      else
      {
        uint64_t v30 = 0;
        uint64_t v29 = v23;
      }
      uint64_t v23 = v29;
      v65[0] = *(_DWORD *)(v27 - 96);
      v65[1] = 0;
      uint64_t v66 = v30 | v28 | (v29 << 8);
      unint64_t v67 = a5;
      int v68 = 1;
      int v69 = v25 + 1;
      Nightingale::slidingWindowDayStreamLuna::slidingWindowDayStreamLuna(v64, v65);
      Nightingale::slidingWindowBaseLuna::process(v64, v55, a6, (uint64_t)v61);
      if (a6)
      {
        if (v74 == (unsigned char *)v73) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        _DWORD *v73 = v63;
        float v22 = *(float *)&v61[3];
        v78[0] = v62;
        std::vector<BOOL>::push_back((uint64_t)v77, v78);
      }
      int v31 = v61[0];
      if (v61[0] > 0)
      {
        *((unsigned char *)a7 + 8) = 1;
        *a7 = 1;
        a7[1] = v31;
        a7[3] = v25 + 1;
        *((unsigned char *)a7 + 16) = 1;
        a7[5] = v19;
        *((unsigned char *)a7 + 24) = 1;
        Nightingale::slidingWindowDayStreamLuna::~slidingWindowDayStreamLuna((Nightingale::slidingWindowDayStreamLuna *)v64);
        goto LABEL_51;
      }
      Nightingale::slidingWindowDayStreamLuna::~slidingWindowDayStreamLuna((Nightingale::slidingWindowDayStreamLuna *)v64);
    }
    else
    {
      if (v74 == (unsigned char *)v73) {
        goto LABEL_75;
      }
      _DWORD *v73 = 8;
    }
    if (Nightingale::rfLuna::getOngoingFwRfLuna((Nightingale::rfLuna *)v70, v25 + 1)) {
      break;
    }
    if (a6)
    {
      int FailureReasonOngoingFwRF = Nightingale::rfLuna::getFailureReasonOngoingFwRF((Nightingale::rfLuna *)v70);
      int v39 = v73;
      unint64_t v40 = v74 - (unsigned char *)v73;
      if ((unint64_t)(v74 - (unsigned char *)v73) < 5 || (v73[1] = FailureReasonOngoingFwRF, v40 < 9)) {
LABEL_75:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      _OWORD v39[2] = 8;
LABEL_44:
      HIBYTE(v72) = !Nightingale::rfLuna::getRfAvailabilityFail((Nightingale::rfLuna *)v70, v25 + 1, 0.3, 1);
      LOBYTE(v72) = !Nightingale::lstmLunaFw::getOngoingFwLstmLunaAvailibilityFail((Nightingale::lstmLunaFw *)v71, (v25 + 1), 0.3);
      if (v56 <= v26 && v26 <= v54)
      {
        std::vector<BOOL>::push_back((uint64_t)v76, (unsigned char *)&v72 + 1);
        std::vector<BOOL>::push_back((uint64_t)v75, &v72);
      }
    }
LABEL_48:
    Nightingale::lstmLuna::reset((uint64_t)v71);
    Nightingale::rfLuna::reset((Nightingale::rfLuna *)v70);
    if (v19 == ++v25) {
      goto LABEL_51;
    }
  }
  uint64_t OngoingFwLstmLuna = Nightingale::lstmLunaFw::getOngoingFwLstmLuna((Nightingale::lstmLunaFw *)v71, (v25 + 1));
  uint64_t v34 = OngoingFwLstmLuna;
  uint64_t v35 = v33;
  if (a6)
  {
    int FwConfirmationFailureReason = Nightingale::lstmLunaFw::getFwConfirmationFailureReason((Nightingale::lstmLunaFw *)v71);
    int v37 = v73;
    if ((unint64_t)(v74 - (unsigned char *)v73) <= 8) {
      goto LABEL_72;
    }
    v73[1] = 9;
    v37[2] = FwConfirmationFailureReason;
    if ((v34 & 0xFF00000000) != 0)
    {
      *((unsigned char *)a7 + 8) = BYTE4(v34);
      a7[3] = v35;
      *((unsigned char *)a7 + 16) = BYTE4(v35);
      a7[5] = v19;
      *((unsigned char *)a7 + 24) = 1;
      *a7 = 2;
      a7[1] = v34;
      goto LABEL_73;
    }
    goto LABEL_44;
  }
  if ((OngoingFwLstmLuna & 0xFF00000000) == 0) {
    goto LABEL_48;
  }
  *((unsigned char *)a7 + 8) = BYTE4(OngoingFwLstmLuna);
  int v37 = v73;
  unint64_t v47 = v74 - (unsigned char *)v73;
  a7[3] = v33;
  *((unsigned char *)a7 + 16) = BYTE4(v33);
  a7[5] = v19;
  *((unsigned char *)a7 + 24) = 1;
  *a7 = 2;
  a7[1] = OngoingFwLstmLuna;
  if (v47 < 9) {
LABEL_72:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
LABEL_73:
  v37[2] = 9;
  if (a6)
  {
LABEL_52:
    std::vector<BOOL>::vector(v60, (uint64_t)v77);
    std::vector<BOOL>::vector(v59, (uint64_t)v76);
    uint64_t v41 = std::vector<BOOL>::vector(__p, (uint64_t)v75);
    Nightingale::fwEstimatorLuna::updateAvailabilityKaliCA((uint64_t)v41, (uint64_t *)v60, (uint64_t *)v59, (uint64_t *)__p, v49);
    if (__p[0]) {
      operator delete(__p[0]);
    }
    if (v59[0]) {
      operator delete(v59[0]);
    }
    if (v60[0]) {
      operator delete(v60[0]);
    }
    updated = (Nightingale *)Nightingale::fwEstimatorLuna::updateFailureReasonsCA(v50, (uint64_t)&v73, v72, v53, v19, v49);
    BOOL v43 = Nightingale::fwEstimatorLuna::updateSignalAtFwEndCA(updated, (Nightingale::lstmLunaFw *)v71, a7, (uint64_t)v49, v22);
    uint64_t KaliDay2DayNoiseAnchoredByToday = Nightingale::fwEstimatorLuna::getKaliDay2DayNoiseAnchoredByToday(v43, v55, v48, a5, v51);
    int v45 = *a7;
    a7[11] = KaliDay2DayNoiseAnchoredByToday;
    a7[12] = v45;
    if (*((unsigned char *)a7 + 16) && *((unsigned char *)a7 + 8))
    {
      a7[13] = a7[3] - a7[1];
      *((unsigned char *)a7 + 56) = 1;
    }
    int JDayLastDayToRunLuna = Nightingale::fwEstimatorLuna::getJDayLastDayToRunLuna(KaliDay2DayNoiseAnchoredByToday, (int *)(v55[1] - 60), v48, v51);
    Nightingale::fwEstimatorLuna::getDaysWristTempInPassNDaysAndDaysPassedEPAvailability(v50, v55, a5, v52, JDayLastDayToRunLuna, v51, (uint64_t)v49);
    a7[23] = JDayLastDayToRunLuna;
    *((unsigned char *)a7 + 96) = 1;
  }
LABEL_62:
  Nightingale::rfLuna::~rfLuna((Nightingale::rfLuna *)v70);
  Nightingale::lstmLunaFw::~lstmLunaFw((Nightingale::lstmLunaFw *)v71);
  if (v73)
  {
    uint64_t v74 = v73;
    operator delete(v73);
  }
  if (v75[0]) {
    operator delete(v75[0]);
  }
  if (v76[0]) {
    operator delete(v76[0]);
  }
  if (v77[0]) {
    operator delete(v77[0]);
  }
}

void sub_257D1BF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24)
{
  if (__p) {
    operator delete(__p);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  Nightingale::rfLuna::~rfLuna((Nightingale::rfLuna *)&STACK[0x200]);
  Nightingale::lstmLunaFw::~lstmLunaFw((Nightingale::lstmLunaFw *)&STACK[0x340]);
  uint64_t v27 = *(void **)(v25 - 224);
  if (v27)
  {
    *(void *)(v25 - 216) = v27;
    operator delete(v27);
  }
  unsigned int v28 = *(void **)(v25 - 200);
  if (v28) {
    operator delete(v28);
  }
  uint64_t v29 = *(void **)(v25 - 176);
  if (v29) {
    operator delete(v29);
  }
  uint64_t v30 = *(void **)(v25 - 152);
  if (v30) {
    operator delete(v30);
  }
  int v31 = *a9;
  if (*a9)
  {
    *(void *)(v24 + 72) = v31;
    operator delete(v31);
  }
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorLuna::getJDayKEd(uint64_t a1, unsigned int a2, void *a3, int a4)
{
  uint64_t v4 = a3[1];
  if (*a3 == v4) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = a4 + 66;
  if (*(_DWORD *)(v4 - 60) == a2 && *(unsigned char *)(v4 - 4))
  {
    if ((int)v5 >= (int)a2) {
      return a2;
    }
    else {
      return v5;
    }
  }
  else if ((int)v5 >= (int)(a2 - 1))
  {
    return a2 - 1;
  }
  else
  {
    return v5;
  }
}

BOOL Nightingale::fwEstimatorLuna::jDayWithinEpSearchRange(Nightingale::fwEstimatorLuna *this, int a2, int a3, int a4)
{
  return a4 + 10 <= a2 && a3 + 3 <= a2 && a3 + 8 >= a2;
}

void Nightingale::fwEstimatorLuna::updateAvailabilityKaliCA(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, unsigned char *a5)
{
  unint64_t v8 = a2[1];
  if (v8)
  {
    uint64_t v9 = *a2;
    char v14 = 1;
    uint64_t v17 = v9;
    int v18 = 0;
    uint64_t v15 = v9 + 8 * (v8 >> 6);
    int v16 = v8 & 0x3F;
    LOBYTE(v8) = a2[1] <= (unint64_t)(2
                                           * std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<BOOL>,false,BOOL,std::__identity,0>(&v17, (uint64_t)&v15, &v14));
  }
  a5[4] = v8;
  unint64_t v10 = a3[1];
  if (v10)
  {
    uint64_t v11 = *a3;
    char v14 = 1;
    uint64_t v17 = v11;
    int v18 = 0;
    uint64_t v15 = v11 + 8 * (v10 >> 6);
    int v16 = v10 & 0x3F;
    LOBYTE(v10) = a3[1] <= (unint64_t)(2
                                            * std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<BOOL>,false,BOOL,std::__identity,0>(&v17, (uint64_t)&v15, &v14));
  }
  a5[5] = v10;
  unint64_t v12 = a4[1];
  if (v12)
  {
    uint64_t v13 = *a4;
    char v14 = 1;
    uint64_t v17 = v13;
    int v18 = 0;
    uint64_t v15 = v13 + 8 * (v12 >> 6);
    int v16 = v12 & 0x3F;
    LOBYTE(v12) = a4[1] <= (unint64_t)(2
                                            * std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<BOOL>,false,BOOL,std::__identity,0>(&v17, (uint64_t)&v15, &v14));
  }
  a5[6] = v12;
}

uint64_t Nightingale::fwEstimatorLuna::updateFailureReasonsCA(uint64_t a1, uint64_t a2, char a3, int a4, int a5, _DWORD *a6)
{
  uint64_t v6 = *(int **)a2;
  if (*(void *)(a2 + 8) - *(void *)a2 <= 8uLL) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  if (v6[2] == 9 || *v6 == 9)
  {
    uint64_t result = 9;
  }
  else
  {
    if (a5 >= a4 && (a3 & 1) == 0) {
      v6[2] = 1;
    }
    uint64_t result = Nightingale::fwEstimatorLuna::combineEpRfLstmFailureReasons(a1, (int **)a2);
  }
  *a6 = result;
  return result;
}

BOOL Nightingale::fwEstimatorLuna::updateSignalAtFwEndCA(Nightingale *a1, Nightingale::lstmLunaFw *this, _DWORD *a3, uint64_t a4, float SignalShift)
{
  if (*a3 != 1)
  {
    if (*a3 != 2)
    {
      BOOL result = Nightingale::check2Real_t_equal(a1, -1.0, -1.0);
      int v8 = (int)(result << 31) >> 31;
      goto LABEL_12;
    }
    SignalShift = Nightingale::lstmLunaFw::getSignalShift(this);
  }
  BOOL result = Nightingale::check2Real_t_equal(a1, SignalShift, -1.0);
  if (result)
  {
    int v8 = -1;
  }
  else if (SignalShift >= 0.1)
  {
    if (SignalShift >= 0.8) {
      int v8 = 15;
    }
    else {
      int v8 = (int)(float)((float)((float)(SignalShift + -0.1) / 0.05) + 1.0);
    }
  }
  else
  {
    int v8 = 0;
  }
LABEL_12:
  *(_DWORD *)(a4 + 8) = v8;
  return result;
}

uint64_t Nightingale::fwEstimatorLuna::getKaliDay2DayNoiseAnchoredByToday(uint64_t a1, void *a2, uint64_t a3, unint64_t a4, int a5)
{
  if (!*(unsigned char *)(a3 + 36)) {
    return 0xFFFFFFFFLL;
  }
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v36);
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v35);
  Nightingale::wristTemperatureInputValidation::wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)&v34);
  if (!*(unsigned char *)(a3 + 36)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  int v9 = *(_DWORD *)(a3 + 32);
  uint64_t v10 = a2[1];
  if (v10 != *a2) {
    int v9 = *(char *)(v10 - 4) + v9 - 1;
  }
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(v35, 20, v9, a5 - 43, a2, a4, (uint64_t)&v28);
  if (v28 == v29) {
    goto LABEL_33;
  }
  uint64_t v11 = *v28;
  unint64_t v12 = v28[1];
  if (*v28 == v12)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    char v14 = *v28;
    do
    {
      float v15 = *v14++;
      if (v15 == -1.0) {
        ++v13;
      }
    }
    while (v14 != v12);
  }
  unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * (v29 - v28);
  if (v17 < 2)
  {
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    for (uint64_t i = 1; i != v17; ++i)
    {
      int v20 = &v28[3 * i];
      int v21 = *v20;
      float v22 = v20[1];
      if (v21 == v22)
      {
        uint64_t v23 = 0;
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          float v24 = *v21++;
          if (v24 == -1.0) {
            ++v23;
          }
        }
        while (v21 != v22);
      }
      if (v13 > v23) {
        uint64_t v18 = i;
      }
      if (v13 >= v23) {
        uint64_t v13 = v23;
      }
    }
    uint64_t v25 = &v28[3 * v18];
    uint64_t v11 = *v25;
    unint64_t v12 = v25[1];
  }
  if (v12 == v11)
  {
LABEL_33:
    uint64_t v16 = 0xFFFFFFFFLL;
  }
  else
  {
    float v26 = sqrtf(COERCE_FLOAT(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::computeDay2DayNoise((uint64_t **)&v28[3 * v18])));
    if (v26 >= 0.35) {
      uint64_t v16 = 7;
    }
    else {
      uint64_t v16 = (int)(float)(v26 / 0.05);
    }
  }
  if (__p)
  {
    uint64_t v33 = __p;
    operator delete(__p);
  }
  if (v30)
  {
    int v31 = v30;
    operator delete(v30);
  }
  int v37 = &v28;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v37);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)&v34);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v35);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v36);
  return v16;
}

void sub_257D1C534(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23)
{
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn((Nightingale::extractKaliInputsRtn *)&a9);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)&a22);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)&a23);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(v23 - 41));
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorLuna::getJDayLastDayToRunLuna(uint64_t a1, int *a2, uint64_t a3, signed int a4)
{
  if (*(unsigned char *)(a3 + 36)) {
    int v4 = *(_DWORD *)(a3 + 32);
  }
  else {
    int v4 = *a2;
  }
  if (*((unsigned char *)a2 + 56)) {
    signed int v5 = v4;
  }
  else {
    signed int v5 = v4 - 1;
  }
  if (*a2 == v4) {
    signed int v6 = v5;
  }
  else {
    signed int v6 = v4 - 1;
  }
  if (v6 < a4 && *(unsigned char *)(a3 + 36) == 0) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  if (v6 < a4) {
    return *(unsigned int *)(a3 + 32);
  }
  else {
    return v6;
  }
}

void Nightingale::fwEstimatorLuna::getDaysWristTempInPassNDaysAndDaysPassedEPAvailability(uint64_t a1, void *a2, unint64_t a3, int a4, int a5, int a6, uint64_t a7)
{
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v36);
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(v36, 45, a5, a6 - 43, a2, a3, (uint64_t)v31);
  int v30 = a4;
  NumWristTempAvailRegardlessOf1stTemp = (char *)operator new(0xCuLL);
  char v14 = NumWristTempAvailRegardlessOf1stTemp;
  uint64_t v15 = 0;
  *(void *)NumWristTempAvailRegardlessOf1stTemp = 0x130000000CLL;
  *((_DWORD *)NumWristTempAvailRegardlessOf1stTemp + 2) = 45;
  uint64_t v16 = (void **)(a7 + 32);
  do
  {
    NumWristTempAvailRegardlessOf1stTemp = (char *)Nightingale::fwEstimatorLuna::getNumWristTempAvailRegardlessOf1stTemp((uint64_t)NumWristTempAvailRegardlessOf1stTemp, v31, *(_DWORD *)&v14[4 * v15], *(_DWORD *)&v14[4 * v15]);
    int v17 = (int)NumWristTempAvailRegardlessOf1stTemp;
    int v19 = *(char **)(a7 + 40);
    unint64_t v18 = *(void *)(a7 + 48);
    if ((unint64_t)v19 >= v18)
    {
      NumWristTempAvailRegardlessOf1stTemp = (char *)*v16;
      uint64_t v21 = (v19 - (unsigned char *)*v16) >> 2;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v23 = v18 - (void)NumWristTempAvailRegardlessOf1stTemp;
      if (v23 >> 1 > v22) {
        unint64_t v22 = v23 >> 1;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24)
      {
        uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a7 + 48, v24);
        NumWristTempAvailRegardlessOf1stTemp = *(char **)(a7 + 32);
        int v19 = *(char **)(a7 + 40);
      }
      else
      {
        uint64_t v25 = 0;
      }
      float v26 = &v25[4 * v21];
      *(_DWORD *)float v26 = v17;
      int v20 = v26 + 4;
      while (v19 != NumWristTempAvailRegardlessOf1stTemp)
      {
        int v27 = *((_DWORD *)v19 - 1);
        v19 -= 4;
        *((_DWORD *)v26 - 1) = v27;
        v26 -= 4;
      }
      *(void *)(a7 + 32) = v26;
      *(void *)(a7 + 40) = v20;
      *(void *)(a7 + 48) = &v25[4 * v24];
      if (NumWristTempAvailRegardlessOf1stTemp) {
        operator delete(NumWristTempAvailRegardlessOf1stTemp);
      }
    }
    else
    {
      *(_DWORD *)int v19 = NumWristTempAvailRegardlessOf1stTemp;
      int v20 = v19 + 4;
    }
    *(void *)(a7 + 40) = v20;
    ++v15;
  }
  while (v15 != 3);
  if (a5 - v30 == 8)
  {
    int v28 = 0;
    for (int i = 12; i != 18; ++i)
    {
      NumWristTempAvailRegardlessOf1stTemp = (char *)Nightingale::fwEstimatorLuna::getNumWristTempAvailRegardlessOf1stTemp((uint64_t)NumWristTempAvailRegardlessOf1stTemp, v31, i, 12);
      if ((int)NumWristTempAvailRegardlessOf1stTemp > 8) {
        ++v28;
      }
    }
    *(_DWORD *)(a7 + 56) = v28;
  }
  operator delete(v14);
  if (__p)
  {
    uint64_t v35 = __p;
    operator delete(__p);
  }
  if (v32)
  {
    uint64_t v33 = v32;
    operator delete(v32);
  }
  int v37 = (void **)v31;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v37);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v36);
}

void sub_257D1C7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn((Nightingale::extractKaliInputsRtn *)va);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)va1);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorLuna::combineEpRfLstmFailureReasons(uint64_t a1, int **a2)
{
  float v2 = *(unsigned int **)(a1 + 24);
  uint64_t v3 = *(unsigned int **)(a1 + 32);
  if (v2 == v3) {
    return 8;
  }
  int v4 = a2[1];
  while (1)
  {
    if (*a2 != v4)
    {
      uint64_t v5 = 0;
      uint64_t result = *v2;
      uint64_t v7 = *a2;
      do
      {
        int v8 = *v7++;
        if (v8 == result) {
          ++v5;
        }
      }
      while (v7 != v4);
      if (v5) {
        break;
      }
    }
    if (++v2 == v3) {
      return 8;
    }
  }
  return result;
}

uint64_t Nightingale::fwEstimatorLuna::getCASignalAtFwEndEstimate(Nightingale::fwEstimatorLuna *this, float a2)
{
  if (Nightingale::check2Real_t_equal(this, a2, -1.0)) {
    return 0xFFFFFFFFLL;
  }
  if (a2 < 0.1) {
    return 0;
  }
  if (a2 >= 0.8) {
    return 15;
  }
  return (int)(float)((float)((float)(a2 + -0.1) / 0.05) + 1.0);
}

uint64_t Nightingale::fwEstimatorLuna::getCABoundedDay2DayNoise(Nightingale::fwEstimatorLuna *this, float a2)
{
  if (a2 < 0.0) {
    return 0xFFFFFFFFLL;
  }
  if (a2 >= 0.35) {
    return 7;
  }
  return (int)(float)(a2 / 0.05);
}

void Nightingale::fwEstimatorLuna::updateAFwCycleFactorCAItems(float *a1, uint64_t a2, unsigned int *a3, uint64_t *a4, int a5, void *a6)
{
  if (a5)
  {
    if (!*((unsigned char *)a3 + 24)
      || (*(float *)(a2 + 52) = Nightingale::phaseFactorProcessor::getjDayStartOfAPhasetojDayRangeStart((uint64_t)a1, *a3 | ((unint64_t)a3[5] << 32), a4, 0), *(unsigned char *)(a2 + 56) = 1, !*((unsigned char *)a3 + 24)))
    {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    *(float *)(a2 + 60) = Nightingale::phaseFactorProcessor::getjDayEndOfAPhasetojDayRangeEnd((uint64_t)a1, *a3 | ((unint64_t)(a3[5] + 1) << 32), a4, 0);
    *(unsigned char *)(a2 + 64) = 1;
    uint64_t v11 = operator new(6uLL);
    uint64_t v42 = v11 + 3;
    BOOL v43 = (char *)(v11 + 3);
    *(_DWORD *)uint64_t v11 = 34014725;
    v11[2] = 1027;
    uint64_t v41 = v11;
    if (!*((unsigned char *)a3 + 24)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::phaseFactorProcessor::getjDayStartOfVPhasestojDayRangeStart(a1, *a3 | ((unint64_t)(a3[5] + 1) << 32), a4, (uint64_t *)&v41, (float **)&__p);
    std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>(a2 + 72, &__p);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    if (!*((unsigned char *)a3 + 24)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::phaseFactorProcessor::getjDayEndOfVPhasestojDayRangeEnd(a1, *a3 | ((unint64_t)(a3[5] + 1) << 32), a4, (uint64_t *)&v41, (float **)&__p);
    std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>(a2 + 104, &__p);
    if (__p.n128_u64[0])
    {
      __p.n128_u64[1] = __p.n128_u64[0];
      operator delete((void *)__p.n128_u64[0]);
    }
    if (*(unsigned char *)(a2 + 12) && *(_DWORD *)(a2 + 16) <= 1u)
    {
      BOOL v12 = Nightingale::phaseFactorProcessor::vPhasesContainsAPhase((uint64_t)a1, (unsigned __int8 **)a3 + 9, 0);
      int v13 = *((unsigned __int8 *)a3 + 24);
      if (!v12)
      {
        if (!*((unsigned char *)a3 + 24) || !*(unsigned char *)(a2 + 12)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        *(float *)(a2 + 144) = (float)(int)(a3[5] - *(_DWORD *)(a2 + 8) + 1);
      }
      if (v13 && !*(_DWORD *)(a2 + 16))
      {
        if (!*(unsigned char *)(a2 + 12)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        int v14 = *(_DWORD *)(a2 + 8);
        int v15 = *a3;
        int v16 = a3[5] + 1;
        int v17 = v14 - *a3;
        if (v16 - v14 >= 5) {
          int v18 = 5;
        }
        else {
          int v18 = v16 - v14;
        }
        if (v17 >= 6) {
          int v19 = 6;
        }
        else {
          int v19 = v17;
        }
        if ((v18 & 0x80000000) == 0 && v19 >= -1)
        {
          Nightingale::preprocess_temperature_inputs_for_hist_cycle(a6, v15, v16, (uint64_t)&__p);
          int v20 = operator new(4uLL);
          int v27 = v20;
          *int v20 = v18 + v14;
          int v28 = v20 + 1;
          uint64_t v29 = v20 + 1;
          Nightingale::prepare_temperature_input_slice_for_kdays(&v27, v18 + v19 + 1, &__p, (uint64_t)&v30);
          if (v31 == v30) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v35 = 0;
          char v36 = 0;
          uint64_t v37 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v35, *(const void **)v30, *((void *)v30 + 1), (uint64_t)(*((void *)v30 + 1) - *(void *)v30) >> 2);
          if (v33)
          {
            char v34 = v33;
            operator delete(v33);
          }
          unint64_t v24 = &v30;
          std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v24);
          if (v27)
          {
            int v28 = v27;
            operator delete(v27);
          }
          unint64_t v21 = (unint64_t)(v36 - (unsigned char *)v35) >> 2;
          if (v19 + 1 < (int)v21) {
            LODWORD(v21) = v19 + 1;
          }
          uint64_t v22 = (int)v21;
          int v30 = 0;
          int v31 = 0;
          uint64_t v32 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v30, v35, (uint64_t)v35 + 4 * (int)v21, (int)v21);
          uint64_t v25 = 0;
          uint64_t v26 = 0;
          unint64_t v24 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v24, (char *)v35 + 4 * v22, (uint64_t)v36, (v36 - ((unsigned char *)v35 + 4 * v22)) >> 2);
          Nightingale::get_sw_difference((char **)&v30, (int **)&v24);
          *(_DWORD *)(a2 + 44) = v23;
          if (v24)
          {
            uint64_t v25 = v24;
            operator delete(v24);
          }
          if (v30)
          {
            int v31 = v30;
            operator delete(v30);
          }
          if (v35)
          {
            char v36 = v35;
            operator delete(v35);
          }
          std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&v40);
          std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&v39);
          if (__p.n128_u64[0])
          {
            __p.n128_u64[1] = __p.n128_u64[0];
            operator delete((void *)__p.n128_u64[0]);
          }
        }
      }
    }
    if (v41)
    {
      uint64_t v42 = v41;
      operator delete(v41);
    }
  }
}

void sub_257D1CCC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a22) {
    operator delete(a22);
  }
  Nightingale::lunaExtractedData::~lunaExtractedData((Nightingale::lunaExtractedData *)&a25);
  int v28 = *(void **)(v26 - 88);
  if (v28)
  {
    *(void *)(v26 - 80) = v28;
    operator delete(v28);
  }
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::vector<float>>::operator=[abi:ne180100]<std::vector<float>,void>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned char *)(a1 + 24))
  {
    std::vector<float>::__move_assign(a1, a2);
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return a1;
}

uint64_t Nightingale::fwEstimatorLuna::getNumWristTempAvailRegardlessOf1stTemp(uint64_t a1, uint64_t *a2, int a3, int a4)
{
  __n128 __p = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 == v5) {
    return 0;
  }
  int v7 = a3 - a4;
  uint64_t v8 = 4 * a4 - 4 * a3;
  do
  {
    char v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v34, *(const void **)v4, *(void *)(v4 + 8), (uint64_t)(*(void *)(v4 + 8) - *(void *)v4) >> 2);
    uint64_t v9 = v34;
    unint64_t v10 = (unint64_t)(v35 - (unsigned char *)v34) >> 2;
    if ((int)v10 >= a3) {
      LODWORD(v10) = a3;
    }
    if (v7 <= (int)v10)
    {
      int v11 = 0;
      if (v7 != v10)
      {
        BOOL v12 = (float *)&v35[-4 * (int)v10];
        uint64_t v13 = v8 + 4 * (int)v10;
        do
        {
          float v14 = *v12++;
          if (v14 > 0.0) {
            ++v11;
          }
          v13 -= 4;
        }
        while (v13);
      }
      int v15 = v38;
      if (v38 >= v39)
      {
        int v17 = (char *)__p;
        uint64_t v18 = (v38 - (unsigned char *)__p) >> 2;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v20 = v39 - (unsigned char *)__p;
        if ((v39 - (unsigned char *)__p) >> 1 > v19) {
          unint64_t v19 = v20 >> 1;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v21 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          uint64_t v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v39, v21);
          int v17 = (char *)__p;
          int v15 = v38;
        }
        else
        {
          uint64_t v22 = 0;
        }
        int v23 = &v22[4 * v18];
        *(_DWORD *)int v23 = v11;
        int v16 = v23 + 4;
        while (v15 != v17)
        {
          int v24 = *((_DWORD *)v15 - 1);
          v15 -= 4;
          *((_DWORD *)v23 - 1) = v24;
          v23 -= 4;
        }
        __n128 __p = v23;
        uint64_t v38 = v16;
        uint64_t v39 = &v22[4 * v21];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v38 = v11;
        int v16 = v15 + 4;
      }
      uint64_t v38 = v16;
      uint64_t v9 = v34;
    }
    if (v9)
    {
      uint64_t v35 = v9;
      operator delete(v9);
    }
    v4 += 24;
  }
  while (v4 != v5);
  if (__p == v38)
  {
    uint64_t v32 = 0;
    if (!__p) {
      return v32;
    }
LABEL_43:
    uint64_t v38 = (char *)__p;
    operator delete(__p);
    return v32;
  }
  uint64_t v25 = (char *)__p + 4;
  uint64_t v26 = (unsigned int *)__p;
  if ((char *)__p + 4 != v38)
  {
    int v27 = *(_DWORD *)__p;
    uint64_t v26 = (unsigned int *)__p;
    int v28 = (char *)__p + 4;
    do
    {
      int v30 = *(_DWORD *)v28;
      v28 += 4;
      int v29 = v30;
      BOOL v31 = v27 < v30;
      if (v27 <= v30) {
        int v27 = v29;
      }
      if (v31) {
        uint64_t v26 = (unsigned int *)v25;
      }
      uint64_t v25 = v28;
    }
    while (v28 != v38);
  }
  uint64_t v32 = *v26;
  if (__p) {
    goto LABEL_43;
  }
  return v32;
}

void sub_257D1CFE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::fwEstimatorLuna::getDaysPassedEPAvailability(Nightingale::fwEstimatorLuna *this, const Nightingale::extractKaliInputsRtn *a2, int a3)
{
  if (a3 < 1) {
    return 0;
  }
  int v5 = 0;
  int v6 = 0;
  LODWORD(v7) = 0;
  do
  {
    this = (Nightingale::fwEstimatorLuna *)Nightingale::fwEstimatorLuna::getNumWristTempAvailRegardlessOf1stTemp((uint64_t)this, (uint64_t *)a2, v5 + 12, 12);
    if ((int)this <= 8) {
      uint64_t v7 = v7;
    }
    else {
      uint64_t v7 = (v7 + 1);
    }
    int v5 = (char)++v6;
  }
  while ((char)v6 < a3);
  return v7;
}

void *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    int v6 = result;
    std::vector<std::string>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (void *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_257D1D0FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  int v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  void v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_257D1D1BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      int v5 = *(void **)(v3 - 24);
      v3 -= 24;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 16) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

void *std::vector<std::optional<float>>::__init_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    uint64_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8 - 3);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D1D2B8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::optional<float>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::vector<Nightingale::fwEndConfirmationFailureReason_t>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_257D1D380(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<BOOL>,false,BOOL,std::__identity,0>(uint64_t *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *a1;
  if (*a3)
  {
    uint64_t v6 = *a1;
    return std::__count_BOOL[abi:ne180100]<true,std::vector<BOOL>,false>((uint64_t)&v6, *(unsigned int *)(a2 + 8) - (unint64_t)*((unsigned int *)a1 + 2) + 8 * (*(void *)a2 - v3));
  }
  else
  {
    uint64_t v5 = *a1;
    return std::__count_BOOL[abi:ne180100]<false,std::vector<BOOL>,false>((uint64_t)&v5, *(unsigned int *)(a2 + 8) - (unint64_t)*((unsigned int *)a1 + 2) + 8 * (*(void *)a2 - v3));
  }
}

uint64_t std::__count_BOOL[abi:ne180100]<true,std::vector<BOOL>,false>(uint64_t a1, unint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    if ((64 - v2) >= a2) {
      unint64_t v3 = a2;
    }
    else {
      unint64_t v3 = (64 - v2);
    }
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - v2 - v3)) & (-1 << v2) & **(void **)a1));
    v4.i16[0] = vaddlv_u8(v4);
    uint64_t v5 = v4.u32[0];
    a2 -= v3;
    *(void *)a1 += 8;
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (a2 >= 0x40)
  {
    uint64_t v6 = *(int8x8_t **)a1;
    do
    {
      int8x8_t v7 = *v6++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
      v8.i16[0] = vaddlv_u8(v8);
      v5 += v8.u32[0];
      a2 -= 64;
    }
    while (a2 > 0x3F);
    *(void *)a1 = v6;
  }
  if (a2)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)(**(void **)a1 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a2)));
    v9.i16[0] = vaddlv_u8(v9);
    v5 += v9.u32[0];
  }
  return v5;
}

uint64_t std::__count_BOOL[abi:ne180100]<false,std::vector<BOOL>,false>(uint64_t a1, unint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    if ((64 - v2) >= a2) {
      unint64_t v3 = a2;
    }
    else {
      unint64_t v3 = (64 - v2);
    }
    uint8x8_t v4 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - v2 - v3)) & (-1 << v2) & ~**(void **)a1));
    v4.i16[0] = vaddlv_u8(v4);
    uint64_t v5 = v4.u32[0];
    a2 -= v3;
    *(void *)a1 += 8;
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (a2 >= 0x40)
  {
    uint64_t v6 = *(uint64_t **)a1;
    do
    {
      uint64_t v7 = *v6++;
      uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)~v7);
      v8.i16[0] = vaddlv_u8(v8);
      v5 += v8.u32[0];
      a2 -= 64;
    }
    while (a2 > 0x3F);
    *(void *)a1 = v6;
  }
  if (a2)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> -(char)a2) & ~**(void **)a1));
    v9.i16[0] = vaddlv_u8(v9);
    v5 += v9.u32[0];
  }
  return v5;
}

__n128 std::vector<float>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint8x8_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t Nightingale::rfLuna::rfLuna(uint64_t a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  *(unsigned char *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = -1;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 216) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_DWORD *)(a1 + 224) = 9;
  *(_OWORD *)(a1 + 177) = 0u;
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(a1 + 232));
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(a1 + 304));
  Nightingale::wristTemperatureInputValidation::wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)(a1 + 305));
  Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fw_dl_tmp_process((Nightingale::ngt_luna_fw_dl_tmp_process *)(a1 + 312), a4);
  return a1;
}

void sub_257D1D6C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation(v14);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess(v13);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition(v12);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a10);
  Nightingale::pickSlicesStruct::~pickSlicesStruct((Nightingale::pickSlicesStruct *)(v11 + 120));
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn(v10);
  _Unwind_Resume(a1);
}

void Nightingale::pickSlicesStruct::~pickSlicesStruct(Nightingale::pickSlicesStruct *this)
{
  int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 3);
  if (v3)
  {
    *((void *)this + 4) = v3;
    operator delete(v3);
  }
  uint8x8_t v4 = (void **)this;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void Nightingale::rfLuna::~rfLuna(id **this)
{
  Nightingale::ngt_luna_fw_dl_tmp_process::~ngt_luna_fw_dl_tmp_process(this + 39);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)((char *)this + 305));
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(this + 38));
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(this + 29));
  uint64_t v6 = (void **)(this + 25);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  int v2 = this[21];
  if (v2)
  {
    this[22] = v2;
    operator delete(v2);
  }
  unint64_t v3 = this[18];
  if (v3)
  {
    this[19] = v3;
    operator delete(v3);
  }
  uint64_t v6 = (void **)(this + 15);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  uint8x8_t v4 = this[12];
  if (v4)
  {
    this[13] = v4;
    operator delete(v4);
  }
  uint64_t v5 = this[9];
  if (v5)
  {
    this[10] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void **)(this + 5);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
}

uint64_t Nightingale::rfLuna::getOngoingFwRfLuna(Nightingale::rfLuna *this, int a2)
{
  *((_DWORD *)this + 56) = 8;
  if (Nightingale::rfLuna::acquireWTmp(this, a2 - 17, a2, 2) && Nightingale::rfLuna::validateWTmp(this, 0.3))
  {
    Nightingale::rfLuna::preCondition(this);
    if (Nightingale::rfLuna::applyAlgs(this, a2, 0.3)) {
      return 1;
    }
    int v5 = 8;
  }
  else
  {
    int v5 = 1;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 56) = v5;
  return result;
}

BOOL Nightingale::rfLuna::acquireWTmp(Nightingale::rfLuna *this, int a2, int a3, int a4)
{
  uint8x8_t v8 = (uint64_t *)((char *)this + 232);
  unint64_t JDayIdx1stTmp = Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp((uint64_t)this + 232, *(unsigned int ***)this);
  if (*((unsigned __int8 *)this + 32) == v10)
  {
    if (!*((unsigned char *)this + 32)) {
      return 0;
    }
    *((void *)this + 3) = JDayIdx1stTmp;
  }
  else
  {
    if (*((unsigned char *)this + 32))
    {
      BOOL v11 = 0;
      *((unsigned char *)this + 32) = 0;
      return v11;
    }
    *((void *)this + 3) = JDayIdx1stTmp;
    *((unsigned char *)this + 32) = 1;
  }
  memset(v23, 0, sizeof(v23));
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(v8, a3 - a2 + 1, a3, *(_DWORD *)(*(void *)(*((void *)this + 1) + 8) - 96) - 43, *(void **)this, JDayIdx1stTmp, (uint64_t)&v19);
  std::vector<std::vector<float>>::__vdeallocate((uint64_t *)this + 5);
  *(_OWORD *)((char *)this + 40) = v19;
  BOOL v12 = (void *)*((void *)this + 9);
  uint64_t v13 = v20;
  uint64_t v14 = *(void *)__p;
  uint64_t v20 = 0;
  long long v19 = 0uLL;
  *((void *)this + 7) = v13;
  *((void *)this + 8) = v14;
  if (v12)
  {
    *((void *)this + 10) = v12;
    operator delete(v12);
    *((void *)this + 9) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
  }
  int v15 = (void *)*((void *)this + 12);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)&__p[8];
  *((void *)this + 11) = *(void *)&__p[24];
  memset(&__p[8], 0, 24);
  if (v15)
  {
    *((void *)this + 13) = v15;
    operator delete(v15);
    *((void *)this + 12) = 0;
    *((void *)this + 13) = 0;
    *((void *)this + 14) = 0;
    int v15 = *(void **)&__p[8];
  }
  *((_OWORD *)this + 6) = *(_OWORD *)&__p[32];
  *((void *)this + 14) = v22;
  *(void *)&__p[40] = 0;
  uint64_t v22 = 0;
  *(void *)&__p[32] = 0;
  if (v15)
  {
    *(void *)&__p[16] = v15;
    operator delete(v15);
  }
  int v24 = (void **)&v19;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v24);
  if (*((void *)this + 5) == *((void *)this + 6))
  {
    BOOL v11 = 0;
  }
  else
  {
    Nightingale::wristTemperatureInputProcess::constructVectorOfSlicesFromMultipleWatches((Nightingale::rfLuna *)((char *)this + 40), 17, a4, a2, (uint64_t)&v19);
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)this + 15);
    *(_OWORD *)((char *)this + 120) = v19;
    int v16 = (void *)*((void *)this + 18);
    *((void *)this + 17) = v20;
    uint64_t v20 = 0;
    long long v19 = 0uLL;
    if (v16)
    {
      *((void *)this + 19) = v16;
      operator delete(v16);
      *((void *)this + 18) = 0;
      *((void *)this + 19) = 0;
      *((void *)this + 20) = 0;
    }
    int v17 = (void *)*((void *)this + 21);
    *((_OWORD *)this + 9) = *(_OWORD *)__p;
    *((void *)this + 20) = *(void *)&__p[16];
    memset(__p, 0, 24);
    if (v17)
    {
      *((void *)this + 22) = v17;
      operator delete(v17);
      *((void *)this + 21) = 0;
      *((void *)this + 22) = 0;
      *((void *)this + 23) = 0;
      int v17 = *(void **)__p;
    }
    *(_OWORD *)((char *)this + 168) = *(_OWORD *)&__p[24];
    *((void *)this + 23) = *(void *)&__p[40];
    memset(&__p[24], 0, 24);
    if (v17)
    {
      *(void *)&__p[8] = v17;
      operator delete(v17);
    }
    int v24 = (void **)&v19;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v24);
    BOOL v11 = *((void *)this + 15) != *((void *)this + 16);
  }
  *(void *)&long long v19 = v23;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v19);
  return v11;
}

void sub_257D1DB68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  a9 = (void **)&a19;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

BOOL Nightingale::rfLuna::validateWTmp(Nightingale::rfLuna *this, float a2)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  memset(v21, 0, sizeof(v21));
  uint64_t v22 = &unk_2706971D0;
  int v23 = Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpMissingCntHigh;
  int v24 = 0;
  uint64_t v25 = &v22;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v21, (uint64_t)&v22);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&v22);
  uint8x8_t v4 = (uint64_t *)*((void *)this + 15);
  uint64_t v6 = *v4;
  uint64_t v5 = v4[1];
  uint64_t v7 = operator new(4uLL);
  uint64_t v22 = v7;
  _DWORD *v7 = (unint64_t)(v5 - v6) >> 2;
  int v23 = v7 + 1;
  int v24 = v7 + 1;
  uint8x8_t v8 = (float *)operator new(4uLL);
  float *v8 = a2;
  long long v19 = v8 + 1;
  uint64_t v20 = v8 + 1;
  uint64_t v18 = v8;
  uint8x8_t v9 = (uint64_t *)*((void *)this + 16);
  if (v4 == v9)
  {
    *((_DWORD *)this + 49) = 1;
    int v14 = **(unsigned __int8 **)(*((void *)this + 26) - 24);
LABEL_18:
    long long v19 = v8;
    operator delete(v8);
    goto LABEL_19;
  }
  do
  {
    uint64_t v10 = *((void *)this + 21);
    if (*((void *)this + 22) == v10) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    if (*(unsigned char *)(v10 + 4)) {
      goto LABEL_8;
    }
    BOOL v11 = (float **)*((void *)this + 15);
    if (*((float ***)this + 16) == v11) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    if (**v11 >= 0.0)
    {
LABEL_8:
      Nightingale::wristTemperatureInputValidation::checkListOfConditions((uint64_t)this + 305, v21, (uint64_t)v4, &v22, &v18, 1, __p);
      std::vector<std::vector<std::pair<BOOL,float>>>::push_back[abi:ne180100]((uint64_t *)this + 25, (uint64_t)__p);
    }
    else
    {
      LOBYTE(v16) = 1;
      HIDWORD(v16) = 1065353216;
      std::vector<std::pair<BOOL,float>>::vector(__p, 1uLL, &v16);
      unint64_t v12 = *((void *)this + 26);
      if (v12 >= *((void *)this + 27))
      {
        uint64_t v13 = std::vector<std::vector<std::pair<BOOL,float>>>::__push_back_slow_path<std::vector<std::pair<BOOL,float>> const&>((uint64_t *)this + 25, (uint64_t **)__p);
      }
      else
      {
        std::vector<std::vector<std::pair<BOOL,float>>>::__construct_one_at_end[abi:ne180100]<std::vector<std::pair<BOOL,float>> const&>((uint64_t)this + 200, (uint64_t **)__p);
        uint64_t v13 = v12 + 24;
      }
      *((void *)this + 26) = v13;
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    v4 += 3;
  }
  while (v4 != v9);
  uint8x8_t v8 = v18;
  *((_DWORD *)this + 49) = 1;
  int v14 = **(unsigned __int8 **)(*((void *)this + 26) - 24);
  if (v8) {
    goto LABEL_18;
  }
LABEL_19:
  if (v22)
  {
    int v23 = v22;
    operator delete(v22);
  }
  uint64_t v22 = v21;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v22);
  return v14 == 0;
}

void sub_257D1DE00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, char *__p,char *a21)
{
  if (__p)
  {
    a21 = __p;
    operator delete(__p);
  }
  __n128 __p = &a17;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void Nightingale::rfLuna::preCondition(Nightingale::rfLuna *this)
{
  uint64_t v1 = (float **)*((void *)this + 15);
  int v2 = (float **)*((void *)this + 16);
  if (v1 != v2)
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *((void *)this + 21);
      if (v4 >= (*((void *)this + 22) - v5) >> 3) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v6 = *v1;
      uint64_t v7 = v1[1];
      if (*v1 != v7)
      {
        uint64_t v8 = v5 + 8 * v4;
        float v9 = *(float *)v8;
        if (!*(unsigned char *)(v8 + 4)) {
          float v9 = -1.0;
        }
        unint64_t v10 = v7 - v6;
        if (v10 <= 1) {
          unint64_t v10 = 1;
        }
        BOOL v11 = *v1;
        unint64_t v12 = v10;
        do
        {
          float v13 = *v11;
          if (fabsf(*v11 + 1.0) < 1.0e-12)
          {
            float *v11 = v9;
            float v13 = v9;
          }
          ++v11;
          float v9 = v13;
          --v12;
        }
        while (v12);
        do
        {
          float *v6 = (float)(*v6 + -36.033) / 0.41302;
          ++v6;
          --v10;
        }
        while (v10);
      }
      ++v4;
      Nightingale::vDemean<float>((uint64_t)v1);
      v1 += 3;
    }
    while (v1 != v2);
  }
}

BOOL Nightingale::rfLuna::applyAlgs(Nightingale::rfLuna *this, int a2, float a3)
{
  unint64_t v3 = (float **)*((void *)this + 15);
  unint64_t v4 = (float **)*((void *)this + 16);
  if (v3 == v4 || **(unsigned char **)(*((void *)this + 26) - 24)) {
    return 0;
  }
  __n128 __p = 0;
  char v34 = 0;
  uint64_t v35 = 0;
  do
  {
    if (!Nightingale::rfLuna::getRfAvailabilityFail(this, a2, a3, 2))
    {
      int v30 = 0;
      BOOL v31 = 0;
      uint64_t v32 = 0;
      std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v30, 0, *v3, v3[1], v3[1] - *v3);
      int v27 = 0;
      int v28 = 0;
      uint64_t v29 = 0;
      Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fwEndDetRF((void **)this + 39, (uint64_t *)&v30, (uint64_t)&v27);
      unint64_t v10 = v27;
      BOOL v11 = v34;
      if (v34 >= v35)
      {
        float v13 = (char *)__p;
        uint64_t v14 = (v34 - (unsigned char *)__p) >> 2;
        unint64_t v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v16 = v35 - (unsigned char *)__p;
        if ((v35 - (unsigned char *)__p) >> 1 > v15) {
          unint64_t v15 = v16 >> 1;
        }
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v15;
        }
        if (v17)
        {
          uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v35, v17);
          float v13 = (char *)__p;
          BOOL v11 = v34;
        }
        else
        {
          uint64_t v18 = 0;
        }
        long long v19 = &v18[4 * v14];
        *(_DWORD *)long long v19 = v10[1];
        unint64_t v12 = v19 + 4;
        while (v11 != v13)
        {
          int v20 = *((_DWORD *)v11 - 1);
          v11 -= 4;
          *((_DWORD *)v19 - 1) = v20;
          v19 -= 4;
        }
        __n128 __p = v19;
        char v34 = v12;
        uint64_t v35 = &v18[4 * v17];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *(_DWORD *)char v34 = *((_DWORD *)v27 + 1);
        unint64_t v12 = v11 + 4;
      }
      char v34 = v12;
      if (v27)
      {
        int v28 = v27;
        operator delete(v27);
      }
      if (v30)
      {
        BOOL v31 = v30;
        operator delete(v30);
      }
    }
    v3 += 3;
  }
  while (v3 != v4);
  unint64_t v21 = (char *)__p;
  if (__p == v34)
  {
    BOOL v6 = 0;
    unint64_t v21 = v34;
    if (!v34) {
      return v6;
    }
LABEL_36:
    char v34 = v21;
    operator delete(v21);
    return v6;
  }
  double v22 = 0.0;
  int v23 = (float *)__p;
  do
  {
    float v24 = *v23++;
    double v22 = v22 + v24;
  }
  while (v23 != (float *)v34);
  uint64_t v25 = (v34 - (unsigned char *)__p) >> 2;
  if (v34 != (char *)__p + 4)
  {
    memmove(__p, (char *)__p + 4, v34 - ((unsigned char *)__p + 4));
    unint64_t v21 = (char *)__p;
  }
  float v26 = v22 / (double)(unint64_t)v25;
  BOOL v6 = v26 >= 0.67;
  if (v21) {
    goto LABEL_36;
  }
  return v6;
}

void sub_257D1E1F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::rfLuna::reset(Nightingale::rfLuna *this)
{
  *((_DWORD *)this + 56) = 9;
}

uint64_t Nightingale::rfLuna::getFailureReasonOngoingFwRF(Nightingale::rfLuna *this)
{
  return *((unsigned int *)this + 56);
}

BOOL Nightingale::rfLuna::getRfAvailabilityFail(Nightingale::rfLuna *this, int a2, float a3, int a4)
{
  uint64_t v5 = (uint64_t *)((char *)this + 200);
  if (*((void *)this + 25) != *((void *)this + 26)) {
    return *((_DWORD *)this + 56) == 1;
  }
  BOOL result = Nightingale::rfLuna::acquireWTmp(this, a2 - a4 - 15, a2, a4);
  if (result)
  {
    if (Nightingale::rfLuna::validateWTmp(this, a3))
    {
      return 0;
    }
    else
    {
      std::vector<std::vector<float>>::__clear[abi:ne180100](v5);
      *((_DWORD *)this + 56) = 9;
      return 1;
    }
  }
  return result;
}

uint64_t std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>>(v4, v13);
    }
    else {
      uint64_t v14 = 0;
    }
    unint64_t v15 = v14;
    uint64_t v16 = &v14[32 * v10];
    uint64_t v18 = &v14[32 * v13];
    std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::__value_func[abi:ne180100]((uint64_t)v16, a2);
    unint64_t v17 = v16 + 32;
    std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::__value_func[abi:ne180100](*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_257D1E3FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<std::pair<BOOL,float>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)uint64_t v14 = 0;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<std::pair<BOOL,float>>>::__swap_out_circular_buffer(a1, v16);
    uint64_t v8 = (void *)a1[1];
    uint64_t result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)unint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_257D1E53C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void Nightingale::vDemean<float>(uint64_t a1)
{
  uint64_t v1 = *(float **)a1;
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(void *)a1 != v2)
  {
    __n128 __p = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v1, v2, (v2 - (uint64_t)v1) >> 2);
    float Mean = Nightingale::getMeanWin<float>((float **)&__p, -1);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
    unint64_t v5 = *(float **)a1;
    unint64_t v6 = *(float **)(a1 + 8);
    while (v5 != v6)
    {
      float *v5 = *v5 - Mean;
      ++v5;
    }
  }
}

void sub_257D1E5E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::vector<float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    unint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

uint64_t std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 32;
    uint64_t result = std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::__value_func[abi:ne180100](result - 32, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(32 * a2);
}

uint64_t std::__split_buffer<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100]((void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<std::pair<BOOL,float>>::vector(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::optional<float>>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_257D1E830(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::vector<std::pair<BOOL,float>>>::__construct_one_at_end[abi:ne180100]<std::vector<std::pair<BOOL,float>> const&>(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(void *)(v3 + 16) = 0;
  uint64_t result = std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>((char *)v3, *a2, a2[1], a2[1] - *a2);
  *(void *)(a1 + 8) = v3 + 24;
  return result;
}

void sub_257D1E898(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<std::pair<BOOL,float>>>::__push_back_slow_path<std::vector<std::pair<BOOL,float>> const&>(uint64_t *a1, uint64_t **a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  uint64_t v16 = &v10[24 * v9];
  *(void *)unint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>(v11, *a2, a2[1], a2[1] - *a2);
  v15 += 24;
  std::vector<std::vector<std::pair<BOOL,float>>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_257D1E9A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (void *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      uint64_t v8 = *a2++;
      *v7++ = v8;
    }
    *((void *)v6 + 1) = v7;
  }
  return result;
}

void sub_257D1EA10(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<std::pair<BOOL,float>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::pair<BOOL,float>>>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::pair<BOOL,float>>>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::pair<BOOL,float>>>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::pair<BOOL,float>>>,std::reverse_iterator<std::vector<std::pair<BOOL,float>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    unint64_t v4 = v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        unint64_t v4 = std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](v4 - 4);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

char *std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(uint64_t a1, char *__src, float *a3, float *a4, uint64_t a5)
{
  uint64_t v5 = __src;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = a3;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    long long v13 = *(unsigned char **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__src - v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v40 = v9;
    if (v17) {
      uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v9, v17);
    }
    else {
      uint64_t v18 = 0;
    }
    BOOL v31 = (double *)&v18[8 * v15];
    __n128 __p = v18;
    uint64_t v37 = v31;
    uint64_t v39 = &v18[8 * v17];
    uint64_t v32 = 8 * a5;
    uint64_t v33 = &v31[a5];
    do
    {
      float v34 = *v7++;
      *v31++ = v34;
      v32 -= 8;
    }
    while (v32);
    uint64_t v38 = v33;
    uint64_t v5 = std::vector<double>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v38 != v37) {
      uint64_t v38 = (double *)((char *)v38 + (((char *)v37 - (char *)v38 + 7) & 0xFFFFFFFFFFFFFFF8));
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = (uint64_t)(v12 - (void)__src) >> 3;
  if (v19 >= a5)
  {
    int v20 = &a3[a5];
    unint64_t v21 = *(char **)(v9 - 8);
LABEL_18:
    uint64_t v25 = &__src[8 * a5];
    float v26 = &v21[-8 * a5];
    int v27 = v21;
    if ((unint64_t)v26 < v12)
    {
      int v27 = v21;
      do
      {
        uint64_t v28 = *(void *)v26;
        v26 += 8;
        *(void *)int v27 = v28;
        v27 += 8;
      }
      while ((unint64_t)v26 < v12);
    }
    *(void *)(a1 + 8) = v27;
    if (v21 != v25) {
      memmove(&v21[-8 * ((v21 - v25) >> 3)], __src, v21 - v25);
    }
    if (v20 != v7)
    {
      uint64_t v29 = (double *)v5;
      do
      {
        float v30 = *v7++;
        *v29++ = v30;
      }
      while (v7 != v20);
    }
    return v5;
  }
  int v20 = &a3[v19];
  unint64_t v21 = *(char **)(v9 - 8);
  if (v20 != a4)
  {
    double v22 = v20;
    int v23 = *(double **)(v9 - 8);
    do
    {
      float v24 = *v22++;
      *v23++ = v24;
      v21 += 8;
    }
    while (v22 != a4);
  }
  *(void *)(a1 + 8) = v21;
  if ((uint64_t)(v12 - (void)__src) >= 1) {
    goto LABEL_18;
  }
  return v5;
}

void sub_257D1EDF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<double>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    long long v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  long long v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::~__func()
{
}

__n128 std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_2706971D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_2706971D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, float *a5)
{
  uint64_t v5 = *(uint64_t (**)(void *, uint64_t, void, float))(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = (void *)(a2 + (v6 >> 1));
  if (v6) {
    uint64_t v5 = *(uint64_t (**)(void *, uint64_t, void, float))(*v7 + v5);
  }
  return v5(v7, a3, *a4, *a5);
}

uint64_t std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::target(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void *std::__function::__func<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),std::allocator<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float)>,std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems&,std::vector<float> const&,int,float)>::target_type()
{
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

float Nightingale::getMeanWin<float>(float **a1, int a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  float result = (float)a2;
  if (*a1 != v3)
  {
    int v5 = 0;
    uint64_t v6 = *a1;
    do
    {
      float v7 = *v6++;
      if (v7 == result) {
        ++v5;
      }
    }
    while (v6 != v3);
    uint64_t v8 = v3 - v2;
    if (v8 != v5)
    {
      uint64_t v9 = *a1;
      do
      {
        if (*v9 == result) {
          float *v9 = 0.0;
        }
        ++v9;
      }
      while (v9 != v3);
      double v10 = 0.0;
      do
      {
        float v11 = *v2++;
        double v10 = v10 + v11;
      }
      while (v2 != v3);
      return v10 / (double)(unint64_t)(v8 - v5);
    }
  }
  return result;
}

uint64_t Nightingale::run_m_over_n_moving_target(void *a1, int a2, int a3)
{
  if ((a3 | a2) < 0)
  {
    uint64_t v31 = 0;
    unsigned __int8 v32 = 0;
    int v33 = 0;
  }
  else
  {
    Nightingale::prepare_input_slices_for_mt(a1, a3, a2, &v48);
    Nightingale::day2day_noise_check_per_slice(&v48, (uint64_t)v47, 0.16);
    Nightingale::signal2noise_check_per_slice(&v48, (uint64_t)v46, 0.3025);
    Nightingale::missing_spec_check_for_each_window(&v48, v43, 8.0, 8.0);
    __n128 __p = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    uint64_t v4 = v48;
    uint64_t v3 = v49;
    int v5 = v47[1];
    uint64_t v6 = v46[1];
    float v7 = v43[1];
    uint64_t v8 = v45;
    uint64_t v9 = operator new(0x28uLL);
    double v10 = v9;
    uint64_t v11 = 0;
    unint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * ((v3 - v4) >> 3);
    void *v9 = v12;
    v9[1] = v5;
    id v9[2] = v6;
    void v9[3] = v7;
    v9[4] = v8;
    LOBYTE(v13) = 1;
    do
      int v13 = (v9[v11++] == v12) & v13;
    while (v11 != 5);
    if (v13)
    {
      if (v3 == v4)
      {
        unint64_t v14 = 0;
        float v30 = 0;
      }
      else
      {
        unint64_t v14 = 0;
        unint64_t v15 = 0;
        do
        {
          uint64_t v16 = (v15 >> 3) & 0x1FFFFFFFFFFFFFF8;
          BOOL v17 = (*(void *)((unsigned char *)v47[0] + v16) & (1 << v15)) != 0;
          BOOL v18 = (*(void *)((unsigned char *)v46[0] + v16) & (1 << v15)) != 0;
          BOOL v19 = (*(void *)((unsigned char *)v43[0] + v16) & (1 << v15)) != 0;
          BOOL v20 = (*(void *)((unsigned char *)v44 + v16) & (1 << v15)) != 0;
          if (v14 >= v42)
          {
            unint64_t v21 = (char *)__p;
            unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * (v14 - (unsigned char *)__p);
            unint64_t v23 = v22 + 1;
            if (v22 + 1 >= 0x3333333333333334) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            if (0x999999999999999ALL * (v42 - (unsigned char *)__p) > v23) {
              unint64_t v23 = 0x999999999999999ALL * (v42 - (unsigned char *)__p);
            }
            if (0xCCCCCCCCCCCCCCCDLL * (v42 - (unsigned char *)__p) >= 0x1999999999999999) {
              unint64_t v24 = 0x3333333333333333;
            }
            else {
              unint64_t v24 = v23;
            }
            if (v24)
            {
              uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::lunaMTSpecs>>((uint64_t)&v42, v24);
              unint64_t v21 = (char *)__p;
              unint64_t v14 = v41;
            }
            else
            {
              uint64_t v25 = 0;
            }
            float v26 = &v25[5 * v22];
            *float v26 = 1;
            v26[1] = v17;
            v26[2] = v18;
            v26[3] = v19;
            v26[4] = v20;
            int v27 = v26;
            if (v14 != v21)
            {
              do
              {
                int v28 = *(_DWORD *)(v14 - 5);
                v14 -= 5;
                char v29 = v14[4];
                *(_DWORD *)(v27 - 5) = v28;
                v27 -= 5;
                v27[4] = v29;
              }
              while (v14 != v21);
              unint64_t v21 = (char *)__p;
            }
            unint64_t v14 = v26 + 5;
            __n128 __p = v27;
            uint64_t v41 = v26 + 5;
            uint64_t v42 = &v25[5 * v24];
            if (v21) {
              operator delete(v21);
            }
          }
          else
          {
            *unint64_t v14 = 1;
            v14[1] = v17;
            void v14[2] = v18;
            v14[3] = v19;
            v14[4] = v20;
            v14 += 5;
          }
          uint64_t v41 = v14;
          ++v15;
        }
        while (0xEEEEEEEEEEEEEEEFLL * ((v49 - v48) >> 3) > v15);
        float v30 = __p;
      }
      uint64_t v37 = 0;
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      std::vector<Nightingale::lunaMTSpecs>::__init_with_size[abi:ne180100]<Nightingale::lunaMTSpecs*,Nightingale::lunaMTSpecs*>(&v37, v30, (uint64_t)v14, 0xCCCCCCCCCCCCCCCDLL * (v14 - (unsigned char *)v30));
      uint64_t v34 = Nightingale::predict_on_day_range_historical((float *)&v48, (uint64_t *)&v37);
      if (v37)
      {
        uint64_t v38 = v37;
        operator delete(v37);
      }
      if ((v34 & 0xFF00000000) != 0)
      {
        int v33 = v34 & 0xFFFFFF00;
        char v35 = v34;
        uint64_t v31 = 0x100000000;
      }
      else
      {
        uint64_t v31 = 0;
        char v35 = 0;
        int v33 = 0;
      }
      unsigned __int8 v32 = v33 | v35;
    }
    else
    {
      uint64_t v31 = 0;
      unsigned __int8 v32 = 0;
      int v33 = 0;
    }
    operator delete(v10);
    if (__p)
    {
      uint64_t v41 = (char *)__p;
      operator delete(__p);
    }
    if (v44) {
      operator delete(v44);
    }
    if (v43[0]) {
      operator delete(v43[0]);
    }
    if (v46[0]) {
      operator delete(v46[0]);
    }
    if (v47[0]) {
      operator delete(v47[0]);
    }
    v43[0] = &v48;
    std::vector<Nightingale::lunaMTPreparedData>::__destroy_vector::operator()[abi:ne180100]((void ***)v43);
  }
  return v31 & 0x100000000 | v33 & 0xFFFFFF00 | v32;
}

void sub_257D1F578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,void *a26)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v26);
  if (a14) {
    operator delete(a14);
  }
  std::pair<std::vector<BOOL>,std::vector<BOOL>>::~pair((uint64_t)&a17);
  if (a23) {
    operator delete(a23);
  }
  if (a26) {
    operator delete(a26);
  }
  a17 = v27 - 112;
  std::vector<Nightingale::lunaMTPreparedData>::__destroy_vector::operator()[abi:ne180100]((void ***)&a17);
  _Unwind_Resume(a1);
}

void Nightingale::prepare_input_slices_for_mt(void *a1@<X0>, int a2@<W1>, int a3@<W2>, uint64_t *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  Nightingale::preprocess_temperature_inputs_for_hist_cycle(a1, a2, a3, (uint64_t)v64);
  Nightingale::extract_temperature_data_for_given_range((Nightingale *)(a2 + 2), a3 - 2, (uint64_t *)v64, (char **)&v59);
  if (v61[3] && v60 != v59)
  {
    float v7 = v63;
    unsigned __int8 v58 = *(unsigned char *)(v61[2] + 16);
    if (v63)
    {
      float v8 = 1.0;
      do
      {
        double v10 = (int *)v7[3];
        uint64_t v9 = (int *)v7[4];
        float v11 = 1.0;
        if (v9 != v10)
        {
          uint64_t v12 = v9 - v10;
          double v13 = 0.0;
          do
          {
            int v14 = *v10++;
            double v13 = v13 + (double)v14;
          }
          while (v10 != v9);
          float v11 = 1.0 - v13 / (float)(unint64_t)v12;
        }
        if (v11 < v8)
        {
          unsigned __int8 v58 = *((unsigned char *)v7 + 16);
          float v8 = v11;
        }
        float v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    uint64_t v15 = 0;
    unint64_t v57 = 0xFFFFFFFDFFFFFFFELL;
    long long v56 = xmmword_257D5F6AC;
    do
    {
      *(_DWORD *)((char *)&v56 + v15) += a3 - 13;
      v15 += 4;
    }
    while (v15 != 24);
    BOOL v43 = &v58;
    uint64_t v16 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v61, &v58, (uint64_t)&std::piecewise_construct, (unsigned char **)&v43);
    BOOL v43 = &v58;
    BOOL v17 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)v62, &v58, (uint64_t)&std::piecewise_construct, (unsigned char **)&v43);
    for (uint64_t i = 0; i != 6; ++i)
    {
      uint64_t v19 = v60 - (unsigned char *)v59;
      if (v60 != v59)
      {
        uint64_t v20 = 0;
        uint64_t v21 = v19 >> 2;
        if ((unint64_t)(v19 >> 2) <= 1) {
          uint64_t v21 = 1;
        }
        while (*((_DWORD *)&v56 + i) != *((_DWORD *)v59 + v20))
        {
          if (v21 == ++v20) {
            goto LABEL_63;
          }
        }
        if ((int)(((unint64_t)v19 >> 2) - 1) > (int)v20)
        {
          int v46 = *((_DWORD *)v59 + v20);
          unint64_t v22 = (const void *)v16[3];
          char v44 = 0;
          uint64_t v45 = 0;
          BOOL v43 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v43, v22, (uint64_t)v22 + 4 * v20 + 4, (4 * v20 + 4) >> 2);
          uint64_t v20 = v20;
          uint64_t v23 = v16[4];
          unint64_t v24 = (const void *)(v16[3] + 4 * v20 + 4);
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          uint64_t v40 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v40, v24, v23, (v23 - (uint64_t)v24) >> 2);
          std::pair<std::vector<float>,std::vector<float>>::pair[abi:ne180100]<true,0>(v47, (uint64_t)&v43, (uint64_t)&v40);
          uint64_t v25 = (_DWORD *)v17[3];
          memset(v39, 0, sizeof(v39));
          std::vector<BOOL>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(v39, v25, &v25[v20 + 1], (4 * v20 + 4) >> 2);
          float v26 = (_DWORD *)v17[4];
          uint64_t v27 = (_DWORD *)(v17[3] + 4 * v20 + 4);
          memset(__p, 0, sizeof(__p));
          std::vector<BOOL>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(__p, v27, v26, v26 - v27);
          std::pair<std::vector<BOOL>,std::vector<BOOL>>::pair[abi:ne180100]<std::vector<BOOL>&,std::vector<BOOL>&,0>(&v50, (uint64_t)v39, (uint64_t)__p);
          uint64_t v54 = 0;
          uint64_t v55 = 0;
          if (__p[0]) {
            operator delete(__p[0]);
          }
          if (v39[0]) {
            operator delete(v39[0]);
          }
          if (v40)
          {
            uint64_t v41 = v40;
            operator delete(v40);
          }
          if (v43)
          {
            char v44 = v43;
            operator delete(v43);
          }
          int v28 = v50;
          if (v51 > 0x3F || (double v29 = 0.0, (v51 & 0x3F) != 0))
          {
            int v30 = 0;
            double v29 = 0.0;
            do
            {
              if ((*v28 >> v30)) {
                double v31 = 1.0;
              }
              else {
                double v31 = 0.0;
              }
              double v29 = v29 + v31;
              v28 += v30 == 63;
              if (v30 == 63) {
                int v30 = 0;
              }
              else {
                ++v30;
              }
            }
            while (v30 != (v51 & 0x3F) || v28 != (void *)((char *)v50 + 8 * (v51 >> 6)));
          }
          unsigned __int8 v32 = v52;
          if (v53 > 0x3F || (double v33 = 0.0, (v53 & 0x3F) != 0))
          {
            int v34 = 0;
            double v33 = 0.0;
            do
            {
              if ((*v32 >> v34)) {
                double v35 = 1.0;
              }
              else {
                double v35 = 0.0;
              }
              double v33 = v33 + v35;
              v32 += v34 == 63;
              if (v34 == 63) {
                int v34 = 0;
              }
              else {
                ++v34;
              }
            }
            while (v34 != (v53 & 0x3F) || v32 != (void *)((char *)v52 + 8 * (v53 >> 6)));
          }
          LODWORD(v55) = (int)v29;
          HIDWORD(v55) = (int)v33;
          *(float *)&uint64_t v54 = 1.0 - (float)((float)(int)v29 / (float)v51);
          *((float *)&v54 + 1) = 1.0 - (float)((float)(int)v33 / (float)v53);
          unint64_t v36 = a4[1];
          if (v36 >= a4[2])
          {
            uint64_t v37 = std::vector<Nightingale::lunaMTPreparedData>::__push_back_slow_path<Nightingale::lunaMTPreparedData const&>(a4, (uint64_t)&v46);
          }
          else
          {
            std::construct_at[abi:ne180100]<Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData const&,Nightingale::lunaMTPreparedData*>(a4[1], (uint64_t)&v46);
            uint64_t v37 = v36 + 120;
            a4[1] = v36 + 120;
          }
          a4[1] = v37;
          if (v52) {
            operator delete(v52);
          }
          if (v50) {
            operator delete(v50);
          }
          if (v48)
          {
            uint64_t v49 = v48;
            operator delete(v48);
          }
          if (v47[0])
          {
            v47[1] = v47[0];
            operator delete(v47[0]);
          }
        }
      }
LABEL_63:
      ;
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v62);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)v61);
  if (v59)
  {
    BOOL v60 = v59;
    operator delete(v59);
  }
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&v66);
  std::__hash_table<std::__hash_value_type<unsigned char,std::vector<int>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<int>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<int>>>>::~__hash_table((uint64_t)&v65);
  if (v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }
}

void sub_257D1FAC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  Nightingale::lunaExtractedData::~lunaExtractedData((Nightingale::lunaExtractedData *)&a42);
  Nightingale::lunaExtractedData::~lunaExtractedData((Nightingale::lunaExtractedData *)(v42 - 224));
  std::vector<Nightingale::lunaMTPreparedData>::__destroy_vector::operator()[abi:ne180100]((void ***)&a22);
  _Unwind_Resume(a1);
}

void Nightingale::day2day_noise_check_per_slice(uint64_t *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  std::vector<BOOL>::reserve((char **)a2, 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3));
  uint64_t v7 = *a1;
  for (uint64_t i = a1[1]; v7 != i; v7 += 120)
  {
    __n128 __p = 0;
    __dst = 0;
    uint64_t v14 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)(v7 + 8), *(void *)(v7 + 16), (uint64_t)(*(void *)(v7 + 16) - *(void *)(v7 + 8)) >> 2);
    std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&__p, (uint64_t)__dst, *(char **)(v7 + 32), *(char **)(v7 + 40), (uint64_t)(*(void *)(v7 + 40) - *(void *)(v7 + 32)) >> 2);
    float v8 = Nightingale::day2day_noise((uint64_t)&__p);
    BOOL v10 = v8 <= a3 && (LODWORD(v8) & 0x7FFFFFFFu) < 0x7F800000;
    BOOL v11 = v10;
    std::vector<BOOL>::push_back(a2, &v11);
    if (__p)
    {
      __dst = __p;
      operator delete(__p);
    }
  }
}

void sub_257D1FC80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (*v11) {
    operator delete(*v11);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::signal2noise_check_per_slice(uint64_t *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  std::vector<BOOL>::reserve((char **)a2, 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3));
  uint64_t v6 = *a1;
  uint64_t v7 = a1[1];
  if (*a1 != v7)
  {
    do
    {
      Nightingale::calculate_snr_noise_power((char **)(v6 + 8), (int **)(v6 + 32));
      float v9 = v8;
      Nightingale::get_sw_difference((char **)(v6 + 8), (int **)(v6 + 32));
      if ((LODWORD(v9) & 0x7FFFFFFFu) > 0x7F7FFFFF)
      {
        float v11 = NAN;
      }
      else
      {
        float v11 = NAN;
        if ((LODWORD(v10) & 0x7FFFFFFFu) <= 0x7F7FFFFF && v9 != 0.0) {
          float v11 = (float)(v10 * v10) / v9;
        }
      }
      BOOL v13 = v11 >= a3 && (LODWORD(v11) & 0x7FFFFFFFu) < 0x7F800000;
      BOOL v14 = v13;
      std::vector<BOOL>::push_back(a2, &v14);
      v6 += 120;
    }
    while (v6 != v7);
  }
}

void sub_257D1FDDC(_Unwind_Exception *exception_object)
{
  if (*v1) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::missing_spec_check_for_each_window(void *a1@<X0>, void *a2@<X8>, float a3@<S0>, float a4@<S1>)
{
  memset(v30, 0, sizeof(v30));
  memset(__p, 0, sizeof(__p));
  std::vector<BOOL>::reserve((char **)v30, 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a1[1] - *a1) >> 3));
  std::vector<BOOL>::reserve((char **)__p, 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a1[1] - *a1) >> 3));
  float v9 = (void *)*a1;
  for (uint64_t i = (void *)a1[1]; v9 != i; v9 += 15)
  {
    unint64_t v10 = v9[8];
    int v11 = v10 & 0x3F;
    BOOL v12 = v10 <= 0x3F && v11 == 0;
    double v13 = 0.0;
    if (!v12)
    {
      int v14 = 0;
      uint64_t v15 = (void *)v9[7];
      uint64_t v16 = &v15[v10 >> 6];
      do
      {
        if ((*v15 >> v14)) {
          double v17 = 1.0;
        }
        else {
          double v17 = 0.0;
        }
        double v13 = v13 + v17;
        v15 += v14 == 63;
        if (v14 == 63) {
          int v14 = 0;
        }
        else {
          ++v14;
        }
      }
      while (v14 != v11 || v15 != v16);
    }
    unint64_t v18 = v9[11];
    int v19 = v18 & 0x3F;
    double v20 = 0.0;
    if (v18 > 0x3F || v19 != 0)
    {
      int v22 = 0;
      uint64_t v23 = (void *)v9[10];
      unint64_t v24 = &v23[v18 >> 6];
      do
      {
        if ((*v23 >> v22)) {
          double v25 = 1.0;
        }
        else {
          double v25 = 0.0;
        }
        double v20 = v20 + v25;
        v23 += v22 == 63;
        if (v22 == 63) {
          int v22 = 0;
        }
        else {
          ++v22;
        }
      }
      while (v22 != v19 || v23 != v24);
    }
    float v26 = v13;
    BOOL v28 = v26 >= a3;
    std::vector<BOOL>::push_back((uint64_t)v30, &v28);
    float v27 = v20;
    BOOL v28 = v27 >= a4;
    std::vector<BOOL>::push_back((uint64_t)__p, &v28);
  }
  std::pair<std::vector<BOOL>,std::vector<BOOL>>::pair[abi:ne180100]<std::vector<BOOL>&,std::vector<BOOL>&,0>(a2, (uint64_t)v30, (uint64_t)__p);
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (v30[0]) {
    operator delete(v30[0]);
  }
}

void sub_257D1FFD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::predict_on_day_range_historical(float *a1, uint64_t *a2)
{
  uint64_t v3 = *(int **)a1;
  uint64_t v2 = (int *)*((void *)a1 + 1);
  if (v2 != *(int **)a1)
  {
    int v5 = a1;
    int v6 = *v3;
    int v7 = *v3;
    float v8 = *(int **)a1;
    do
    {
      int v10 = *v8;
      v8 += 30;
      int v9 = v10;
      if (v10 < v7)
      {
        int v6 = v9;
        int v7 = v9;
      }
    }
    while (v8 != v2);
    unint64_t v11 = 0;
    int v12 = 0;
    uint64_t v41 = 0;
    __n128 __p = 0;
    int v39 = 0;
    *(void *)uint64_t v40 = 0;
    BOOL v43 = 0;
    char v44 = 0;
    do
    {
      uint64_t v13 = *a2;
      uint64_t v15 = __p;
      int v14 = v43;
      int64_t v16 = (char *)v43 - (char *)__p;
      if ((int)((unint64_t)((char *)v43 - (char *)__p) >> 2) >= 1)
      {
        if (v16 != 4) {
          a1 = (float *)memmove(__p, __p + 1, v16 - 4);
        }
        int v14 = --v43;
      }
      if (*(unsigned char *)(v13 + 5 * v11))
      {
        if (((v11 != 0) & ~v12) != 0) {
          break;
        }
        sw_difference = Nightingale::get_sw_difference((char **)&v3[30 * v11 + 2], (int **)&v3[30 * v11 + 8]);
        float Sigmoid = Nightingale::getSigmoid((Nightingale *)sw_difference, v18);
        float v20 = Sigmoid;
        uint64_t v21 = v43;
        if (v43 >= v44)
        {
          a1 = __p;
          uint64_t v23 = v43 - __p;
          unint64_t v24 = v23 + 1;
          if ((unint64_t)(v23 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v25 = (char *)v44 - (char *)__p;
          if (((char *)v44 - (char *)__p) >> 1 > v24) {
            unint64_t v24 = v25 >> 1;
          }
          if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v26 = v24;
          }
          if (v26)
          {
            float v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v44, v26);
            a1 = __p;
            uint64_t v21 = v43;
          }
          else
          {
            float v27 = 0;
          }
          unsigned __int8 v32 = (float *)&v27[4 * v23];
          *unsigned __int8 v32 = v20;
          int v22 = v32 + 1;
          while (v21 != a1)
          {
            int v33 = *((_DWORD *)v21-- - 1);
            *((_DWORD *)v32-- - 1) = v33;
          }
          __n128 __p = v32;
          char v44 = (float *)&v27[4 * v26];
          if (a1) {
            operator delete(a1);
          }
        }
        else
        {
          *BOOL v43 = Sigmoid;
          int v22 = v43 + 1;
        }
        BOOL v43 = v22;
        int v12 = 1;
      }
      else
      {
        if (v14 >= v44)
        {
          uint64_t v28 = v14 - __p;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v30 = (char *)v44 - (char *)__p;
          if (((char *)v44 - (char *)__p) >> 1 > v29) {
            unint64_t v29 = v30 >> 1;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            a1 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v44, v31);
            uint64_t v15 = __p;
            int v14 = v43;
          }
          else
          {
            a1 = 0;
          }
          int v34 = &a1[v28];
          *int v34 = NAN;
          int v22 = v34 + 1;
          while (v14 != v15)
          {
            int v35 = *((_DWORD *)v14-- - 1);
            *((_DWORD *)v34-- - 1) = v35;
          }
          __n128 __p = v34;
          char v44 = &a1[v31];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          *int v14 = NAN;
          int v22 = v14 + 1;
        }
        BOOL v43 = v22;
        ++HIDWORD(v41);
      }
      if (v3[30 * v11] >= v6)
      {
        uint64_t v36 = v13 + 5 * v11;
        if (*(unsigned char *)(v36 + 4))
        {
          if (*(unsigned char *)(v36 + 3))
          {
            uint64_t v37 = v13 + 5 * v11;
            if (*(unsigned char *)(v37 + 1))
            {
              if (*(unsigned char *)(v37 + 2))
              {
                a1 = __p;
                if (v22 != __p) {
                  Nightingale::vMean<float>();
                }
              }
              else
              {
                ++v39;
              }
            }
            else
            {
              ++v40[0];
            }
          }
          else
          {
            ++v40[1];
          }
        }
        else
        {
          LODWORD(v41) = v41 + 1;
        }
      }
      ++v11;
      uint64_t v3 = *(int **)v5;
    }
    while (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)v5 + 1) - *(void *)v5) >> 3) > v11);
    Nightingale::get_failure_reasons_for_historical((Nightingale *)a1, SHIDWORD(v41), v40[0], v39, 0, v41, v40[1]);
    if (__p) {
      operator delete(__p);
    }
  }
  return 0;
}

void sub_257D203D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<std::vector<BOOL>,std::vector<BOOL>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2) {
    operator delete(v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t Nightingale::get_failure_reasons_for_historical(Nightingale *this, int a2, int a3, int a4, int a5, int a6, int a7)
{
  uint64_t v13 = (int *)operator new(0x18uLL);
  int *v13 = a2;
  v13[1] = a3;
  void v13[2] = a4;
  v13[3] = a5;
  uint64_t v14 = 1;
  int v15 = a2;
  int64_t v16 = v13;
  v13[4] = a6;
  v13[5] = a7;
  do
  {
    int v17 = v13[v14];
    BOOL v18 = v15 < v17;
    if (v15 <= v17) {
      int v15 = v13[v14];
    }
    if (v18) {
      int64_t v16 = &v13[v14];
    }
    ++v14;
  }
  while (v14 != 6);
  int v19 = *v16;
  if (*v16 == a2)
  {
    uint64_t v20 = 1;
  }
  else if (v19 == a5)
  {
    uint64_t v20 = 2;
  }
  else if (v19 == a3)
  {
    uint64_t v20 = 3;
  }
  else if (v19 == a4)
  {
    uint64_t v20 = 4;
  }
  else if (v19 == a6)
  {
    uint64_t v20 = 5;
  }
  else if (v19 == a7)
  {
    uint64_t v20 = 6;
  }
  else
  {
    uint64_t v20 = 9;
  }
  operator delete(v13);
  return v20;
}

float Nightingale::day2day_noise(uint64_t a1)
{
  uint64_t v1 = *(float **)a1;
  uint64_t v2 = (*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if ((int)v2 < 3) {
    return NAN;
  }
  float v4 = *v1;
  float v5 = v1[1];
  uint64_t v3 = v1 + 2;
  uint64_t v6 = (v2 - 1) - 1;
  float v7 = 0.0;
  float v8 = 0.0;
  do
  {
    double v9 = v5 + v4 * -0.5;
    float v4 = v5;
    float v10 = *v3++;
    float v5 = v10;
    float v11 = (v9 + v10 * -0.5) * (v9 + v10 * -0.5);
    BOOL v12 = (LODWORD(v11) & 0x7FFFFFFF) == 0;
    if ((LODWORD(v11) - 1) < 0x7FFFFF) {
      BOOL v12 = 1;
    }
    int v14 = ((LODWORD(v11) & 0x7FFFFFFFu) - 0x800000) >> 24 < 0x7F && v11 >= 0.0 || v12;
    if (!v14) {
      float v11 = -0.0;
    }
    float v8 = v8 + v11;
    if (v14) {
      float v7 = v7 + 1.0;
    }
    --v6;
  }
  while (v6);
  if (v7 == 0.0) {
    return NAN;
  }
  else {
    return (float)(v8 / v7) / 1.5;
  }
}

void Nightingale::extract_temperature_data_for_given_range(Nightingale *this@<X0>, int a2@<W1>, uint64_t *a3@<X2>, char **a4@<X8>)
{
  int v116 = (int)this;
  a4[6] = 0;
  *((_OWORD *)a4 + 1) = 0u;
  *((_OWORD *)a4 + 2) = 0u;
  *(_OWORD *)a4 = 0u;
  *((_OWORD *)a4 + 4) = 0u;
  uint64_t v5 = (uint64_t)(a4 + 8);
  *((_DWORD *)a4 + 14) = 1065353216;
  *((_OWORD *)a4 + 5) = 0u;
  *((_DWORD *)a4 + 24) = 1065353216;
  uint64_t v7 = *a3;
  uint64_t v6 = a3[1];
  if (v6 != *a3)
  {
    unint64_t v8 = 0;
    uint64_t v115 = (uint64_t)(a4 + 2);
    do
    {
      int v9 = *(_DWORD *)(v7 + 4 * v8);
      if (v9 <= a2)
      {
        if (v9 < v116) {
          break;
        }
        float v11 = a4[1];
        unint64_t v10 = (unint64_t)a4[2];
        if ((unint64_t)v11 >= v10)
        {
          uint64_t v13 = *a4;
          uint64_t v14 = (v11 - *a4) >> 2;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v16 = v10 - (void)v13;
          if (v16 >> 1 > v15) {
            unint64_t v15 = v16 >> 1;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17)
          {
            BOOL v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v115, v17);
            uint64_t v13 = *a4;
            float v11 = a4[1];
          }
          else
          {
            BOOL v18 = 0;
          }
          int v19 = &v18[4 * v14];
          *(_DWORD *)int v19 = v9;
          BOOL v12 = v19 + 4;
          while (v11 != v13)
          {
            int v20 = *((_DWORD *)v11 - 1);
            v11 -= 4;
            *((_DWORD *)v19 - 1) = v20;
            v19 -= 4;
          }
          *a4 = v19;
          a4[1] = v12;
          a4[2] = &v18[4 * v17];
          if (v13) {
            operator delete(v13);
          }
        }
        else
        {
          *(_DWORD *)float v11 = v9;
          BOOL v12 = v11 + 4;
        }
        a4[1] = v12;
        for (uint64_t i = (unsigned __int8 *)a3[5]; i; uint64_t i = *(unsigned __int8 **)i)
        {
          unint64_t v120 = i + 16;
          int v22 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)(a4 + 3), i + 16, (uint64_t)&std::piecewise_construct, &v120);
          uint64_t v23 = v22;
          uint64_t v24 = *((void *)i + 3);
          uint64_t v25 = (char *)v22[4];
          uint64_t v26 = (uint64_t)(v22 + 5);
          unint64_t v27 = v22[5];
          if ((unint64_t)v25 >= v27)
          {
            unint64_t v29 = (char *)v22[3];
            uint64_t v30 = (v25 - v29) >> 2;
            if ((unint64_t)(v30 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v31 = v27 - (void)v29;
            unint64_t v32 = (uint64_t)(v27 - (void)v29) >> 1;
            if (v32 <= v30 + 1) {
              unint64_t v32 = v30 + 1;
            }
            if (v31 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v32;
            }
            if (v33)
            {
              int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v26, v33);
              unint64_t v29 = (char *)v23[3];
              uint64_t v25 = (char *)v23[4];
            }
            else
            {
              int v34 = 0;
            }
            int v35 = &v34[4 * v30];
            *(_DWORD *)int v35 = *(_DWORD *)(v24 + 4 * v8);
            uint64_t v28 = v35 + 4;
            while (v25 != v29)
            {
              int v36 = *((_DWORD *)v25 - 1);
              v25 -= 4;
              *((_DWORD *)v35 - 1) = v36;
              v35 -= 4;
            }
            void v23[3] = v35;
            void v23[4] = v28;
            v23[5] = &v34[4 * v33];
            if (v29) {
              operator delete(v29);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v25 = *(_DWORD *)(v24 + 4 * v8);
            uint64_t v28 = v25 + 4;
          }
          void v23[4] = v28;
        }
        for (uint64_t j = (unsigned __int8 *)a3[10]; j; uint64_t j = *(unsigned __int8 **)j)
        {
          unint64_t v120 = j + 16;
          uint64_t v38 = std::__hash_table<std::__hash_value_type<unsigned char,std::vector<float>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<float>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<float>>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>(v5, j + 16, (uint64_t)&std::piecewise_construct, &v120);
          int v39 = v38;
          uint64_t v40 = *((void *)j + 3);
          uint64_t v41 = (char *)v38[4];
          uint64_t v42 = (uint64_t)(v38 + 5);
          unint64_t v43 = v38[5];
          if ((unint64_t)v41 >= v43)
          {
            uint64_t v45 = (char *)v38[3];
            uint64_t v46 = (v41 - v45) >> 2;
            if ((unint64_t)(v46 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v47 = v43 - (void)v45;
            unint64_t v48 = (uint64_t)(v43 - (void)v45) >> 1;
            if (v48 <= v46 + 1) {
              unint64_t v48 = v46 + 1;
            }
            if (v47 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v48;
            }
            if (v49)
            {
              uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v42, v49);
              uint64_t v45 = (char *)v39[3];
              uint64_t v41 = (char *)v39[4];
            }
            else
            {
              uint64_t v50 = 0;
            }
            unint64_t v51 = &v50[4 * v46];
            *(_DWORD *)unint64_t v51 = *(_DWORD *)(v40 + 4 * v8);
            char v44 = v51 + 4;
            while (v41 != v45)
            {
              int v52 = *((_DWORD *)v41 - 1);
              v41 -= 4;
              *((_DWORD *)v51 - 1) = v52;
              v51 -= 4;
            }
            v39[3] = v51;
            v39[4] = v44;
            v39[5] = &v50[4 * v49];
            if (v45) {
              operator delete(v45);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v41 = *(_DWORD *)(v40 + 4 * v8);
            char v44 = v41 + 4;
          }
          v39[4] = v44;
        }
      }
      ++v8;
      uint64_t v7 = *a3;
      uint64_t v6 = a3[1];
    }
    while (v8 < (v6 - *a3) >> 2);
    if (v6 != v7)
    {
      int v53 = *(_DWORD *)(v6 - 4);
      int v54 = v53 - v116;
      BOOL v55 = v53 > v116 && v53 < a2;
      if (v55 && v54 >= 1)
      {
        for (int k = 0; k != v54; ++k)
        {
          unsigned __int8 v58 = *a4;
          unint64_t v57 = a4[1];
          uint64_t v59 = v57 - *a4;
          uint64_t v60 = ((v59 << 30) - 0x100000000) >> 32;
          unint64_t v61 = (unint64_t)a4[2];
          if ((unint64_t)v57 >= v61)
          {
            uint64_t v63 = v59 >> 2;
            unint64_t v64 = (v59 >> 2) + 1;
            if (v64 >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v65 = v61 - (void)v58;
            if (v65 >> 1 > v64) {
              unint64_t v64 = v65 >> 1;
            }
            if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v66 = v64;
            }
            if (v66)
            {
              unint64_t v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v115, v66);
              int v68 = *a4;
              unint64_t v57 = a4[1];
            }
            else
            {
              unint64_t v67 = 0;
              int v68 = *a4;
            }
            int v69 = &v67[4 * v63];
            *(_DWORD *)int v69 = *(_DWORD *)&v58[4 * v60];
            char v62 = v69 + 4;
            while (v57 != v68)
            {
              int v70 = *((_DWORD *)v57 - 1);
              v57 -= 4;
              *((_DWORD *)v69 - 1) = v70;
              v69 -= 4;
            }
            *a4 = v69;
            a4[1] = v62;
            a4[2] = &v67[4 * v66];
            if (v68) {
              operator delete(v68);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v57 = *(_DWORD *)&v58[4 * v60];
            char v62 = v57 + 4;
          }
          a4[1] = v62;
          for (m = a4[5]; m; m = *(char **)m)
          {
            unint64_t v72 = *((void *)m + 5);
            long long v73 = (char *)*((void *)m + 4);
            if ((unint64_t)v73 >= v72)
            {
              uint64_t v75 = (char *)*((void *)m + 3);
              uint64_t v76 = (v73 - v75) >> 2;
              if ((unint64_t)(v76 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v77 = v72 - (void)v75;
              unint64_t v78 = (uint64_t)(v72 - (void)v75) >> 1;
              if (v78 <= v76 + 1) {
                unint64_t v78 = v76 + 1;
              }
              if (v77 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v79 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v79 = v78;
              }
              if (v79)
              {
                v80 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(m + 40), v79);
                uint64_t v75 = (char *)*((void *)m + 3);
                long long v73 = (char *)*((void *)m + 4);
              }
              else
              {
                v80 = 0;
              }
              v81 = &v80[4 * v76];
              *(_DWORD *)v81 = 2143289344;
              uint64_t v74 = v81 + 4;
              while (v73 != v75)
              {
                int v82 = *((_DWORD *)v73 - 1);
                v73 -= 4;
                *((_DWORD *)v81 - 1) = v82;
                v81 -= 4;
              }
              *((void *)m + 3) = v81;
              *((void *)m + 4) = v74;
              *((void *)m + 5) = &v80[4 * v79];
              if (v75) {
                operator delete(v75);
              }
            }
            else
            {
              *(_DWORD *)long long v73 = 2143289344;
              uint64_t v74 = v73 + 4;
            }
            *((void *)m + 4) = v74;
          }
          for (n = a4[10]; n; n = *(char **)n)
          {
            unint64_t v84 = *((void *)n + 5);
            uint64_t v85 = (char *)*((void *)n + 4);
            if ((unint64_t)v85 >= v84)
            {
              unint64_t v87 = (char *)*((void *)n + 3);
              uint64_t v88 = (v85 - v87) >> 2;
              if ((unint64_t)(v88 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v89 = v84 - (void)v87;
              unint64_t v90 = (uint64_t)(v84 - (void)v87) >> 1;
              if (v90 <= v88 + 1) {
                unint64_t v90 = v88 + 1;
              }
              if (v89 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v91 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v91 = v90;
              }
              if (v91)
              {
                int v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(n + 40), v91);
                unint64_t v87 = (char *)*((void *)n + 3);
                uint64_t v85 = (char *)*((void *)n + 4);
              }
              else
              {
                int v92 = 0;
              }
              char v93 = &v92[4 * v88];
              *(_DWORD *)char v93 = 0;
              uint64_t v86 = v93 + 4;
              while (v85 != v87)
              {
                int v94 = *((_DWORD *)v85 - 1);
                v85 -= 4;
                *((_DWORD *)v93 - 1) = v94;
                v93 -= 4;
              }
              *((void *)n + 3) = v93;
              *((void *)n + 4) = v86;
              *((void *)n + 5) = &v92[4 * v91];
              if (v87) {
                operator delete(v87);
              }
            }
            else
            {
              *(_DWORD *)uint64_t v85 = 0;
              uint64_t v86 = v85 + 4;
            }
            *((void *)n + 4) = v86;
          }
        }
      }
    }
  }
  unint64_t v96 = (unint64_t)*a4;
  uint64_t v95 = a4[1];
  if (*a4 != v95)
  {
    uint64_t v97 = v95 - 4;
    if ((unint64_t)v97 > v96)
    {
      unint64_t v98 = v96 + 4;
      do
      {
        int v99 = *(_DWORD *)(v98 - 4);
        *(_DWORD *)(v98 - 4) = *(_DWORD *)v97;
        *(_DWORD *)uint64_t v97 = v99;
        v97 -= 4;
        BOOL v100 = v98 >= (unint64_t)v97;
        v98 += 4;
      }
      while (!v100);
    }
  }
  for (iuint64_t i = a4[5]; ii; iuint64_t i = *(char **)ii)
  {
    unint64_t v102 = *((void *)ii + 3);
    uint64_t v103 = *((void *)ii + 4);
    uint64_t v104 = (_DWORD *)(v103 - 4);
    if (v102 != v103 && (unint64_t)v104 > v102)
    {
      unint64_t v106 = v102 + 4;
      do
      {
        int v107 = *(_DWORD *)(v106 - 4);
        *(_DWORD *)(v106 - 4) = *v104;
        *v104-- = v107;
        BOOL v100 = v106 >= (unint64_t)v104;
        v106 += 4;
      }
      while (!v100);
    }
  }
  for (juint64_t j = a4[10]; jj; juint64_t j = *(char **)jj)
  {
    unint64_t v109 = *((void *)jj + 3);
    uint64_t v110 = *((void *)jj + 4);
    uint64_t v111 = (_DWORD *)(v110 - 4);
    if (v109 != v110 && (unint64_t)v111 > v109)
    {
      unint64_t v113 = v109 + 4;
      do
      {
        int v114 = *(_DWORD *)(v113 - 4);
        *(_DWORD *)(v113 - 4) = *v111;
        *v111-- = v114;
        BOOL v100 = v113 >= (unint64_t)v111;
        v113 += 4;
      }
      while (!v100);
    }
  }
}

void sub_257D20CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, Nightingale::lunaExtractedData *a12)
{
}

uint64_t std::pair<std::vector<float>,std::vector<float>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

void Nightingale::lunaMTPreparedData::~lunaMTPreparedData(Nightingale::lunaMTPreparedData *this)
{
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 7);
  if (v3) {
    operator delete(v3);
  }
  float v4 = (void *)*((void *)this + 4);
  if (v4)
  {
    *((void *)this + 5) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::lunaMTSpecs>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x3333333333333334) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(5 * a2);
}

void *std::vector<Nightingale::lunaMTSpecs>::__init_with_size[abi:ne180100]<Nightingale::lunaMTSpecs*,Nightingale::lunaMTSpecs*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    float result = std::vector<Nightingale::lunaMTSpecs>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      float result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D20E60(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Nightingale::lunaMTSpecs>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x3333333333333334) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::lunaMTSpecs>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[5 * v4];
  return result;
}

void std::vector<Nightingale::lunaMTPreparedData>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 15;
        std::__destroy_at[abi:ne180100]<Nightingale::lunaMTPreparedData,0>(v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:ne180100]<Nightingale::lunaMTPreparedData,0>(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[7];
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[4];
  if (v4)
  {
    a1[5] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[1];
  if (v5)
  {
    a1[2] = v5;
    operator delete(v5);
  }
}

char *std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    uint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 2);
    if (v14 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 2;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 1 > v14) {
      unint64_t v14 = v16 >> 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      BOOL v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v17);
    }
    else {
      BOOL v18 = 0;
    }
    uint64_t v28 = &v18[4 * v15];
    __n128 __p = v18;
    int v34 = v28;
    int v36 = &v18[4 * v17];
    uint64_t v29 = 4 * a5;
    uint64_t v30 = &v28[4 * a5];
    do
    {
      int v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)uint64_t v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    int v35 = v30;
    uint64_t v5 = std::vector<float>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    uint64_t v21 = &__src[4 * a5];
    uint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    uint64_t v24 = &v5[4 * a5];
    uint64_t v25 = &v23[-4 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        int v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)uint64_t v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  uint64_t v21 = &__src[4 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_257D21198(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<float>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(char **)(a2 + 8);
  uint64_t v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    size_t v8 = __src;
    uint64_t v7 = *(char **)(a2 + 8);
    do
    {
      int v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint64_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  uint64_t v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *std::pair<std::vector<BOOL>,std::vector<BOOL>>::pair[abi:ne180100]<std::vector<BOOL>&,std::vector<BOOL>&,0>(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = std::vector<BOOL>::vector(a1, a2);
  std::vector<BOOL>::vector(v5 + 3, a3);
  return a1;
}

void sub_257D212D0(_Unwind_Exception *exception_object)
{
  if (*v1) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::pair<std::vector<float>,std::vector<float>>::pair[abi:ne180100]<true,0>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 3, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  return a1;
}

void sub_257D21348(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<BOOL>::__init_with_size[abi:ne180100]<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(void *result, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v7 = result;
    std::vector<BOOL>::__vallocate[abi:ne180100](result, a4);
    return std::vector<BOOL>::__construct_at_end<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(v7, a2, a3, a4);
  }
  return result;
}

void sub_257D213B8(_Unwind_Exception *exception_object)
{
  if (*v1) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<BOOL>::__construct_at_end<std::__wrap_iter<int const*>,std::__wrap_iter<int const*>>(void *result, _DWORD *a2, _DWORD *a3, uint64_t a4)
{
  unint64_t v4 = result[1];
  unint64_t v5 = v4 + a4;
  result[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*result + 8 * v6) = 0;
  }
  if (a2 != a3)
  {
    int v7 = v4 & 0x3F;
    size_t v8 = (uint64_t *)(*result + 8 * (v4 >> 6));
    do
    {
      uint64_t v9 = 1 << v7;
      if (*a2) {
        uint64_t v10 = *v8 | v9;
      }
      else {
        uint64_t v10 = *v8 & ~v9;
      }
      uint64_t *v8 = v10;
      ++a2;
      v8 += v7 == 63;
      if (v7 == 63) {
        int v7 = 0;
      }
      else {
        ++v7;
      }
    }
    while (a2 != a3);
  }
  return result;
}

uint64_t std::vector<Nightingale::lunaMTPreparedData>::__push_back_slow_path<Nightingale::lunaMTPreparedData const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x222222222222222) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x111111111111111) {
    unint64_t v9 = 0x222222222222222;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::lunaMTPreparedData>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  unint64_t v14 = &v10[120 * v4];
  uint64_t v16 = &v10[120 * v9];
  std::construct_at[abi:ne180100]<Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData const&,Nightingale::lunaMTPreparedData*>((uint64_t)v14, a2);
  uint64_t v15 = v14 + 120;
  std::vector<Nightingale::lunaMTPreparedData>::__swap_out_circular_buffer(a1, &v13);
  uint64_t v11 = a1[1];
  std::__split_buffer<Nightingale::lunaMTPreparedData>::~__split_buffer((uint64_t)&v13);
  return v11;
}

void sub_257D21560(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Nightingale::lunaMTPreparedData>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::construct_at[abi:ne180100]<Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData const&,Nightingale::lunaMTPreparedData*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2 + 56;
  *(_DWORD *)a1 = *(_DWORD *)a2;
  unint64_t v5 = (void *)(a1 + 56);
  std::pair<std::vector<float>,std::vector<float>>::pair[abi:ne180100]((void *)(a1 + 8), a2 + 8);
  std::pair<std::vector<BOOL>,std::vector<BOOL>>::pair[abi:ne180100](v5, v4);
  *(_OWORD *)(a1 + 104) = *(_OWORD *)(a2 + 104);
  return a1;
}

void sub_257D215E0(_Unwind_Exception *exception_object)
{
  uint64_t v4 = (void *)v1[4];
  if (v4)
  {
    v1[5] = v4;
    operator delete(v4);
  }
  unint64_t v5 = *v2;
  if (*v2)
  {
    v1[2] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void *std::pair<std::vector<float>,std::vector<float>>::pair[abi:ne180100](void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1 + 3, *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 2);
  return a1;
}

void sub_257D2166C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::pair<std::vector<BOOL>,std::vector<BOOL>>::pair[abi:ne180100](void *a1, uint64_t a2)
{
  uint64_t v4 = std::vector<BOOL>::vector(a1, a2);
  std::vector<BOOL>::vector(v4 + 3, a2 + 24);
  return a1;
}

void sub_257D216C0(_Unwind_Exception *exception_object)
{
  if (*v1) {
    operator delete(*v1);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<Nightingale::lunaMTPreparedData>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 120;
    v4 -= 120;
    std::construct_at[abi:ne180100]<Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::lunaMTPreparedData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(120 * a2);
}

__n128 std::construct_at[abi:ne180100]<Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData,Nightingale::lunaMTPreparedData*>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = 0;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)(a2 + 8);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 32) = 0;
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a1 + 64) = v2;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 56) = 0;
  uint64_t v3 = *(void *)(a2 + 88);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a1 + 88) = v3;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  __n128 result = *(__n128 *)(a2 + 104);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

uint64_t std::__split_buffer<Nightingale::lunaMTPreparedData>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 120;
    std::__destroy_at[abi:ne180100]<Nightingale::lunaMTPreparedData,0>((void *)(i - 120));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL Nightingale::periodEstimatorBase::checkDayToRunPeriodDLLessThanOPK(uint64_t a1, uint64_t a2, int a3)
{
  return (a2 & 0xFF00000000) != 0 && (int)a2 + 1 >= a3;
}

uint64_t Nightingale::periodEstimatorBase::getNullPoint(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = a3 & 0xFF00000000;
  if ((a2 & 0xFF00000000) != 0)
  {
    int v5 = a2 + 8;
    if ((int)a2 + 8 <= (int)a3) {
      int v5 = a3;
    }
    int v6 = v5 - a4;
    BOOL v9 = v4 == 0;
    uint64_t v7 = 0x100000000;
    if (v9)
    {
      LOBYTE(v6) = a2 + 8 - a4;
      unsigned int v8 = (a2 + 8 - a4) & 0xFFFFFF00;
    }
    else
    {
      unsigned int v8 = v6 & 0xFFFFFF00;
    }
  }
  else
  {
    LOBYTE(v6) = a3 - a4;
    unsigned int v8 = (a3 - a4) & 0xFFFFFF00;
    BOOL v9 = v4 == 0;
    if (v4) {
      uint64_t v7 = 0x100000000;
    }
    else {
      uint64_t v7 = 0;
    }
    if (v9)
    {
      LOBYTE(v6) = 0;
      unsigned int v8 = 0;
    }
  }
  return v7 | v8 | v6;
}

uint64_t Nightingale::periodEstimatorBase::constructPeriodGradFromDLOut@<X0>(void *a1@<X1>, int a2@<W2>, int a3@<W3>, int a4@<W4>, Nightingale::CGradient *a5@<X8>)
{
  uint64_t result = Nightingale::CGradient::CGradient((uint64_t)a5);
  if (a1[1] - *a1 == 128)
  {
    if (a4 >= -31)
    {
      uint64_t v11 = 0;
      uint64_t v12 = (a4 + 32);
      uint64_t v13 = -(uint64_t)a4;
      uint64_t v14 = -4 * a4;
      do
      {
        double v15 = 0.0;
        if (v11 >= a2 && v11 <= a3)
        {
          if (v13 + v11 >= (unint64_t)((uint64_t)(a1[1] - *a1) >> 2)) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v15 = *(float *)(*a1 + v14 + 4 * v11);
        }
        Nightingale::CGradient::push_back(a5, v15);
        ++v11;
      }
      while (v12 != v11);
    }
    return Nightingale::CGradient::normalize((uint64_t)a5);
  }
  return result;
}

void sub_257D219F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::fwEstimatorOPK::getHistFwOpk(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X8>)
{
  *(unsigned char *)a5 = 0;
  *(unsigned char *)(a5 + 4) = 0;
  *(unsigned char *)(a5 + 8) = 0;
  int v6 = (unsigned int *)(a5 + 8);
  *(unsigned char *)(a5 + 12) = 0;
  *(_DWORD *)(a5 + 16) = 3;
  *(unsigned char *)(a5 + 32) = 0;
  *(void *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 28) = 0;
  *(int32x4_t *)(a5 + 36) = vdupq_n_s32(0x7FC00000u);
  *(unsigned char *)(a5 + 52) = 0;
  *(unsigned char *)(a5 + 56) = 0;
  *(unsigned char *)(a5 + 60) = 0;
  *(unsigned char *)(a5 + 64) = 0;
  *(unsigned char *)(a5 + 72) = 0;
  *(unsigned char *)(a5 + 96) = 0;
  *(unsigned char *)(a5 + 104) = 0;
  *(unsigned char *)(a5 + 128) = 0;
  *(unsigned char *)(a5 + 136) = 0;
  *(unsigned char *)(a5 + 140) = 0;
  *(void *)(a5 + 144) = 0x17FC00000;
  *(_DWORD *)(a5 + 152) = 0;
  *(_WORD *)(a5 + 156) = 0;
  if (*(unsigned char *)(a2 + 24) && *(unsigned char *)(a2 + 16) && (a4 & 0xFF00000000) != 0)
  {
    int v8 = *(_DWORD *)(a2 + 12);
    if (v8 <= (int)a4)
    {
      *(_DWORD *)a5 = v8 - 4;
      *(unsigned char *)(a5 + 4) = 1;
      *(_DWORD *)(a5 + 8) = v8 + 1;
      *(unsigned char *)(a5 + 12) = 1;
      *(_DWORD *)(a5 + 16) = 0;
      *(unsigned char *)(a5 + 29) = Nightingale::phaseFactorProcessor::suppressFWStEnd(a1, (unsigned int *)a5, v6, a3);
      Nightingale::fwEstimatorBase::suppressHistFWOverCycleBoundary(a1, *(_DWORD *)a2, *(void *)(a2 + 20), a5);
    }
    else
    {
      *(unsigned char *)(a5 + 28) = 1;
    }
  }
}

void sub_257D21B3C(_Unwind_Exception *a1)
{
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle(v1);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorOPK::getOnGoingjDayFwEndOpk(uint64_t a1, int a2, uint64_t a3)
{
  if ((int)a3 - 4 < a2 || (a3 & 0xFF00000000) == 0) {
    return 0;
  }
  else {
    return (a3 + 1) | 0x100000000;
  }
}

uint64_t **Nightingale::PhaseCondenser::begin_phase(uint64_t **a1, unsigned int a2, int a3)
{
  int v5 = a3;
  int v6 = &v5;
  uint64_t result = std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a1, &v5, (uint64_t)&std::piecewise_construct, &v6);
  if (a2 >= 9) {
    std::__throw_out_of_range[abi:ne180100]("array::at");
  }
  ++*((_WORD *)result + a2 + 16);
  return result;
}

uint64_t **Nightingale::PhaseCondenser::end_phase(uint64_t **a1, unsigned int a2, int a3)
{
  int v5 = a3 + 1;
  int v6 = &v5;
  uint64_t result = std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a1, &v5, (uint64_t)&std::piecewise_construct, &v6);
  if (a2 >= 9) {
    std::__throw_out_of_range[abi:ne180100]("array::at");
  }
  --*((_WORD *)result + a2 + 16);
  return result;
}

void Nightingale::PhaseCondenser::phase_updates(Nightingale::PhaseCondenser *this@<X0>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  std::vector<Nightingale::PhaseUpdate>::reserve((char **)a2, *((void *)this + 2));
  long long v35 = 0uLL;
  __int16 v36 = 0;
  int v6 = *(char **)this;
  uint64_t v4 = (char *)this + 8;
  int v5 = v6;
  if (v6 != v4)
  {
    do
    {
      uint64_t v7 = *(void *)(a2 + 8);
      if (*(void *)a2 == v7) {
        uint64_t v8 = 0;
      }
      else {
        uint64_t v8 = *(void *)(v7 - 16);
      }
      uint64_t v9 = 0;
      uint64_t v34 = v8;
      long long v32 = *((_OWORD *)v5 + 2);
      __int16 v33 = *((_WORD *)v5 + 24);
      do
      {
        *(_WORD *)((char *)&v35 + v9) += *(_WORD *)((char *)&v32 + v9);
        v9 += 2;
      }
      while (v9 != 18);
      long long v29 = v35;
      __int16 v30 = v36;
      uint64_t v31 = Nightingale::PhaseCondenser::flatten_counted_phase_set((uint64_t)&v29);
      if ((std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,9ul>,true,true>(&v34, 0, (uint64_t)&v34, 9u, &v31) & 1) == 0)
      {
        int v10 = *((_DWORD *)v5 + 7);
        uint64_t v11 = v31;
        unint64_t v13 = *(void *)(a2 + 8);
        unint64_t v12 = *(void *)(a2 + 16);
        if (v13 >= v12)
        {
          uint64_t v15 = (uint64_t)(v13 - *(void *)a2) >> 4;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 60) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v17 = v12 - *(void *)a2;
          if (v17 >> 3 > v16) {
            unint64_t v16 = v17 >> 3;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v16;
          }
          if (v18) {
            uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::PhaseUpdate>>(a2 + 16, v18);
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v20 = &v19[16 * v15];
          *(void *)uint64_t v20 = v11;
          *((_DWORD *)v20 + 2) = v10;
          int64_t v22 = *(char **)a2;
          uint64_t v21 = *(char **)(a2 + 8);
          uint64_t v23 = v20;
          if (v21 != *(char **)a2)
          {
            do
            {
              uint64_t v24 = *((void *)v21 - 2);
              v21 -= 16;
              int v25 = *((_DWORD *)v21 + 2);
              *((void *)v23 - 2) = v24;
              v23 -= 16;
              *((_DWORD *)v23 + 2) = v25;
            }
            while (v21 != v22);
            uint64_t v21 = *(char **)a2;
          }
          uint64_t v14 = v20 + 16;
          *(void *)a2 = v23;
          *(void *)(a2 + 8) = v20 + 16;
          *(void *)(a2 + 16) = &v19[16 * v18];
          if (v21) {
            operator delete(v21);
          }
        }
        else
        {
          *(void *)unint64_t v13 = v31;
          *(_DWORD *)(v13 + 8) = v10;
          uint64_t v14 = (char *)(v13 + 16);
        }
        *(void *)(a2 + 8) = v14;
      }
      uint64_t v26 = (char *)*((void *)v5 + 1);
      if (v26)
      {
        do
        {
          int v27 = v26;
          uint64_t v26 = *(char **)v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          int v27 = (char *)*((void *)v5 + 2);
          BOOL v28 = *(void *)v27 == (void)v5;
          int v5 = v27;
        }
        while (!v28);
      }
      int v5 = v27;
    }
    while (v27 != v4);
  }
}

void sub_257D21E68(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<Nightingale::PhaseUpdate>::reserve(char **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 4)
  {
    if (a2 >> 60) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = a1[1] - *a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::PhaseUpdate>>(v3, a2);
    uint64_t v7 = &v6[v5];
    uint64_t v9 = &v6[16 * v8];
    uint64_t v11 = *a1;
    int v10 = a1[1];
    unint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 2);
        v10 -= 16;
        int v14 = *((_DWORD *)v10 + 2);
        *((void *)v12 - 2) = v13;
        v12 -= 16;
        *((_DWORD *)v12 + 2) = v14;
      }
      while (v10 != v11);
      int v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t Nightingale::PhaseCondenser::flatten_counted_phase_set(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v4 = 0;
  do
  {
    if (*(__int16 *)(a1 + 2 * v2) >= 1) {
      Nightingale::PhaseSet::add(&v4, v2);
    }
    ++v2;
  }
  while (v2 != 9);
  return v4;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::PhaseUpdate>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t std::__equal_aligned[abi:ne180100]<std::__bitset<1ul,9ul>,true,true>(void *a1, unsigned int a2, uint64_t a3, unsigned int a4, void *a5)
{
  int64_t v5 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
  if (v5 >= 1)
  {
    if (a2)
    {
      if (v5 >= (unint64_t)(64 - a2)) {
        unint64_t v6 = 64 - a2;
      }
      else {
        unint64_t v6 = a4 - (unint64_t)a2 + 8 * (a3 - (void)a1);
      }
      if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v6)) & (-1 << a2) & (*a1 ^ *a5)) != 0) {
        return 0;
      }
      v5 -= v6;
      ++a5;
      ++a1;
    }
    if (v5 >= 64)
    {
      while (*a5 == *a1)
      {
        uint64_t v7 = v5 - 64;
        ++a1;
        ++a5;
        BOOL v8 = v5 <= 127;
        v5 -= 64;
        if (v8) {
          goto LABEL_14;
        }
      }
      return 0;
    }
    uint64_t v7 = v5;
LABEL_14:
    if (v7 >= 1 && (*a1 ^ *a5) << -(char)v7) {
      return 0;
    }
  }
  return 1;
}

uint64_t **std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x38uLL);
    v11[7] = **a4;
    *((_WORD *)v11 + 24) = 0;
    *((void *)v11 + 4) = 0;
    *((void *)v11 + 5) = 0;
    std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  int64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            int v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              id v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            id v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            char *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void Nightingale::ngt_deviationAnalyzer::deviation_process(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X4>, int a6@<W6>, uint64_t a7@<X8>)
{
  *(unsigned char *)a7 = 0;
  *(void *)(a7 + 4) = -1;
  *(unsigned char *)(a7 + 12) = 0;
  uint64_t v7 = a7 + 12;
  *(void *)(a7 + 16) = -1;
  *(unsigned char *)(a7 + 24) = 0;
  uint64_t v8 = a7 + 24;
  *(unsigned char *)(a7 + 36) = 0;
  uint64_t v9 = a7 + 36;
  *(void *)(a7 + 28) = -1;
  *(void *)(a7 + 40) = -1;
  *(_DWORD *)(a7 + 48) = 0;
  *(_WORD *)(a7 + 52) = 0;
  *(void *)(a7 + 56) = -1;
  *(void *)(a7 + 64) = -1;
  *(void *)(a7 + 72) = 0xFFFFFFFFLL;
  *(_WORD *)(a7 + 80) = 0;
  *(void *)(a7 + 84) = -1;
  *(void *)(a7 + 92) = 0xFFFFFFFFLL;
  *(_WORD *)(a7 + 100) = 0;
  *(void *)(a7 + 104) = -1;
  *(_DWORD *)(a7 + 112) = -1;
  *(_DWORD *)(a7 + 116) = 0;
  uint64_t v10 = a7 + 116;
  *(_WORD *)(a7 + 120) = 0;
  *(void *)(a7 + 124) = -1;
  *(_DWORD *)(a7 + 132) = -1;
  if (*(unsigned char *)(a2 + 36) && *(unsigned char *)(a2 + 128))
  {
    uint64_t v22 = *(void *)(a2 + 72);
    uint64_t v18 = *(void *)(a2 + 88);
    uint64_t v16 = *(void *)(a2 + 104);
    uint64_t v19 = *(void *)(a2 + 112);
    uint64_t v20 = *(void *)(a2 + 80);
    uint64_t v17 = *(void *)(a2 + 120);
    Nightingale::ngt_deviationAnalyzer::detectIrreg(a1, *(void *)(a2 + 64), *(void *)(a2 + 96), a4, a5, *(_DWORD *)(a2 + 32), a6, a7, a7 + 48);
    if (!*(unsigned char *)(a2 + 36)
      || (Nightingale::ngt_deviationAnalyzer::detectInfreq(a1, v22, v16, a4, a5, *(_DWORD *)(a2 + 32), a6, v7, v10 - 40),
          !*(unsigned char *)(a2 + 36)))
    {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::ngt_deviationAnalyzer::detectProlonged(a1, v20, v19, a4, a5, *(_DWORD *)(a2 + 32), a6, v8, v10 - 20);
    __n128 __p = 0;
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    std::vector<Nightingale::ngt_DayInput>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_DayInput const*>,std::__wrap_iter<Nightingale::ngt_DayInput const*>>(&__p, *(const void **)a3, *(void *)(a3 + 8), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2));
    if (!*(unsigned char *)(a2 + 36)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::ngt_deviationAnalyzer::detectSpotting(a1, v18, v17, (uint64_t)&__p, a4, a5, *(_DWORD *)(a2 + 32), a6, v9, v10);
    if (__p)
    {
      uint64_t v24 = __p;
      operator delete(__p);
    }
  }
}

void sub_257D22550(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngt_deviationAnalyzer::detectIrreg(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  if (!*(unsigned char *)(a4 + 84)) {
    return;
  }
  if (*(void *)a4 == *(void *)(a4 + 8)) {
    return;
  }
  int v12 = *(_DWORD *)(a4 + 80);
  int v13 = v12 - 179;
  *(_DWORD *)(a8 + 4) = v12 - 179;
  *(_DWORD *)(a8 + 8) = v12;
  char v14 = Nightingale::ngt_deviationAnalyzer::ruleChecker(a1, a2, a3, v12 - 179, v12, a4, a5, a6, a7, a9);
  char v15 = v14;
  if ((v14 & 1) == 0 && !a7) {
    return;
  }
  __n128 __p = 0;
  unint64_t v64 = 0;
  uint64_t v65 = 0;
  uint64_t v60 = 0;
  unint64_t v61 = 0;
  char v62 = 0;
  uint64_t v16 = *(void *)a4;
  uint64_t v17 = *(void *)(a4 + 8);
  if (*(void *)a4 == v17)
  {
    uint64_t v46 = 0;
  }
  else
  {
    char v59 = v14;
    do
    {
      int v18 = *(_DWORD *)v16;
      if (*(unsigned char *)(v16 + 24)) {
        BOOL v19 = v18 < v13;
      }
      else {
        BOOL v19 = 1;
      }
      if (!v19)
      {
        int v20 = *(_DWORD *)(v16 + 20);
        int v21 = v20 + 1;
        if (v20 < v12 && v21 >= v12 - 89)
        {
          int v23 = v20 - v18 + 1;
          uint64_t v24 = v64;
          if (v64 >= v65)
          {
            uint64_t v26 = (char *)__p;
            uint64_t v27 = (v64 - (unsigned char *)__p) >> 2;
            unint64_t v28 = v27 + 1;
            if ((unint64_t)(v27 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v29 = v65 - (unsigned char *)__p;
            if ((v65 - (unsigned char *)__p) >> 1 > v28) {
              unint64_t v28 = v29 >> 1;
            }
            if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v30 = v28;
            }
            if (v30)
            {
              uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v65, v30);
              uint64_t v26 = (char *)__p;
              uint64_t v24 = v64;
            }
            else
            {
              uint64_t v31 = 0;
            }
            long long v32 = (int *)&v31[4 * v27];
            *long long v32 = v23;
            uint64_t v25 = (char *)(v32 + 1);
            while (v24 != v26)
            {
              int v33 = *((_DWORD *)v24 - 1);
              v24 -= 4;
              *--long long v32 = v33;
            }
            __n128 __p = v32;
            unint64_t v64 = v25;
            uint64_t v65 = &v31[4 * v30];
            if (v26) {
              operator delete(v26);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v64 = v23;
            uint64_t v25 = v24 + 4;
          }
          unint64_t v64 = v25;
          int v20 = *(_DWORD *)(v16 + 20);
          int v21 = v20 + 1;
        }
        if (v20 < v12 - 90 && v21 >= v13)
        {
          int v35 = v20 - *(_DWORD *)v16 + 1;
          __int16 v36 = v61;
          if (v61 >= v62)
          {
            uint64_t v38 = v60;
            uint64_t v39 = v61 - v60;
            unint64_t v40 = v39 + 1;
            if ((unint64_t)(v39 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v41 = (char *)v62 - (char *)v60;
            if (((char *)v62 - (char *)v60) >> 1 > v40) {
              unint64_t v40 = v41 >> 1;
            }
            if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v42 = v40;
            }
            if (v42)
            {
              unint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v62, v42);
              uint64_t v38 = v60;
              __int16 v36 = v61;
            }
            else
            {
              unint64_t v43 = 0;
            }
            char v44 = (int *)&v43[4 * v39];
            *char v44 = v35;
            uint64_t v37 = v44 + 1;
            while (v36 != v38)
            {
              int v45 = *--v36;
              *--char v44 = v45;
            }
            uint64_t v60 = v44;
            char v62 = (int *)&v43[4 * v42];
            if (v38) {
              operator delete(v38);
            }
          }
          else
          {
            int *v61 = v35;
            uint64_t v37 = v61 + 1;
          }
          unint64_t v61 = v37;
        }
      }
      v16 += 96;
    }
    while (v16 != v17);
    uint64_t v46 = (char *)__p;
    char v15 = v59;
  }
  unint64_t v47 = v64;
  if (*(unsigned char *)(a9 + 3))
  {
    *(_DWORD *)(a9 + 20) = (unint64_t)(v64 - v46) >> 2;
    *(_DWORD *)(a9 + 24) = (unint64_t)((char *)v61 - (char *)v60) >> 2;
  }
  if (v46 == v47) {
    goto LABEL_71;
  }
  unint64_t v48 = v60;
  if (v60 != v61)
  {
    char v66 = 0;
    unint64_t v49 = std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<int *>,std::__wrap_iter<int *>,std::__identity,std::__less<void,void>>(v46, v47);
    int v51 = *v50;
    int v52 = *v49;
    char v66 = 0;
    int v53 = std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<int *>,std::__wrap_iter<int *>,std::__identity,std::__less<void,void>>(v60, v61);
    int v55 = *v54 - *v53;
    BOOL v56 = v51 - v52 <= 16 || v55 <= 16;
    char v57 = !v56;
    *(unsigned char *)a9 = v57;
    if (v56) {
      char v58 = 0;
    }
    else {
      char v58 = v15;
    }
    *(unsigned char *)a8 = v58;
    if (*(unsigned char *)(a9 + 3))
    {
      *(_DWORD *)(a9 + 12) = v51 - v52;
      *(_DWORD *)(a9 + 16) = v55;
    }
LABEL_71:
    unint64_t v48 = v60;
  }
  if (v48) {
    operator delete(v48);
  }
  if (__p)
  {
    unint64_t v64 = (char *)__p;
    operator delete(__p);
  }
}

void sub_257D228D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngt_deviationAnalyzer::detectInfreq(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  if (*(unsigned char *)(a4 + 60))
  {
    if (*(void *)a4 != *(void *)(a4 + 8))
    {
      int v12 = *(_DWORD *)(a4 + 56);
      *(_DWORD *)(a8 + 4) = v12 - 179;
      *(_DWORD *)(a8 + 8) = v12;
      uint64_t result = Nightingale::ngt_deviationAnalyzer::ruleChecker(result, a2, a3, v12 - 179, v12, a4, a5, a6, a7, a9);
      if ((result & 1) != 0 || a7)
      {
        int v13 = *(int **)a4;
        char v14 = *(int **)(a4 + 8);
        if (*(int **)a4 == v14)
        {
          unsigned int v16 = 0;
          unsigned int v15 = 0;
        }
        else
        {
          unsigned int v15 = 0;
          unsigned int v16 = 0;
          do
          {
            int v18 = *v13;
            v13 += 24;
            int v17 = v18;
            if (v18 <= v12 && v17 >= v12 - 89) {
              ++v16;
            }
            if (v17 <= v12 - 90 && v17 >= v12 - 179) {
              ++v15;
            }
          }
          while (v13 != v14);
        }
        if (*(unsigned char *)(a9 + 3))
        {
          *(_DWORD *)(a9 + 12) = v16;
          *(_DWORD *)(a9 + 16) = v15;
        }
        BOOL v21 = v16 >= 2 || v15 >= 2;
        char v22 = !v21;
        *(unsigned char *)a9 = v22;
        if (v21) {
          char v23 = 0;
        }
        else {
          char v23 = result;
        }
        *(unsigned char *)a8 = v23;
      }
    }
  }
  return result;
}

uint64_t Nightingale::ngt_deviationAnalyzer::detectProlonged(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9 = *(void *)(a4 + 8);
  if (*(void *)a4 != v9)
  {
    if (*(unsigned char *)(a4 + 68))
    {
      if (*(unsigned char *)(v9 - 88))
      {
        int v14 = *(_DWORD *)(a4 + 64);
        int v15 = v14 - 179;
        *(_DWORD *)(a8 + 4) = v14 - 179;
        *(_DWORD *)(a8 + 8) = v14;
        uint64_t result = Nightingale::ngt_deviationAnalyzer::ruleChecker(result, a2, a3, v14 - 179, v14, a4, a5, a6, a7, a9);
        if ((result & 1) != 0 || a7)
        {
          uint64_t v16 = *(void *)a4;
          uint64_t v17 = *(void *)(a4 + 8);
          if (*(void *)a4 == v17)
          {
            int v19 = 0;
            int v18 = 0;
          }
          else
          {
            int v18 = 0;
            int v19 = 0;
            do
            {
              if (*(_DWORD *)v16 >= v15)
              {
                ++v19;
                if (*(unsigned char *)(v16 + 8))
                {
                  if (*(_DWORD *)(v16 + 4) - *(_DWORD *)v16 > 8) {
                    ++v18;
                  }
                }
              }
              v16 += 96;
            }
            while (v16 != v17);
          }
          *(unsigned char *)a9 = v18 > 1;
          if (*(unsigned char *)(a9 + 3))
          {
            *(_DWORD *)(a9 + 12) = v19;
            *(_DWORD *)(a9 + 16) = v18;
          }
          if (v18 > 1) {
            char v20 = result;
          }
          else {
            char v20 = 0;
          }
          *(unsigned char *)a8 = v20;
        }
      }
    }
  }
  return result;
}

void Nightingale::ngt_deviationAnalyzer::detectSpotting(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (*(void *)a5 != *(void *)(a5 + 8) && *(unsigned char *)(a5 + 84) != 0)
  {
    int v14 = *(_DWORD *)(a5 + 80);
    *(_DWORD *)(a9 + 4) = v14 - 179;
    *(_DWORD *)(a9 + 8) = v14;
    char v15 = Nightingale::ngt_deviationAnalyzer::ruleChecker(a1, a2, a3, v14 - 179, v14, a5, a6, a7, a8, a10);
    if ((v15 & 1) != 0 || a8)
    {
      unint64_t v28 = 0;
      uint64_t v29 = 0;
      __n128 __p = 0;
      std::vector<Nightingale::ngt_DayInput>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_DayInput const*>,std::__wrap_iter<Nightingale::ngt_DayInput const*>>(&__p, *(const void **)a4, *(void *)(a4 + 8), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 2));
      Nightingale::ngt_deviationAnalyzer::extendPeriodWFlowSpotting(v14 - 179, v14, (int **)&__p, (void *)a5, v30);
      uint64_t NonAdjacentSpottingInACycle = (uint64_t)__p;
      if (__p)
      {
        unint64_t v28 = __p;
        operator delete(__p);
      }
      LODWORD(v31) = 0;
      uint64_t v17 = *(int **)a4;
      int v18 = *(int **)(a4 + 8);
      if (*(int **)a4 == v18)
      {
        int v20 = 0;
        int v19 = 0;
      }
      else
      {
        int v19 = 0;
        int v20 = 0;
        do
        {
          if (*((unsigned char *)v17 + 8))
          {
            int v21 = *v17;
            if (*v17 >= v14 - 89 && v21 <= v14)
            {
              uint64_t NonAdjacentSpottingInACycle = Nightingale::ngt_deviationAnalyzer::findNonAdjacentSpottingInACycle(NonAdjacentSpottingInACycle, (uint64_t)v30, v21, (int *)&v31);
              v20 += NonAdjacentSpottingInACycle;
            }
            else if (v21 >= v14 - 179 && v21 <= v14 - 90)
            {
              uint64_t NonAdjacentSpottingInACycle = Nightingale::ngt_deviationAnalyzer::findNonAdjacentSpottingInACycle(NonAdjacentSpottingInACycle, (uint64_t)v30, v21, (int *)&v31);
              v19 += NonAdjacentSpottingInACycle;
            }
          }
          v17 += 15;
        }
        while (v17 != v18);
      }
      BOOL v24 = v20 <= 0 || v19 <= 0;
      char v25 = !v24;
      *(unsigned char *)a10 = v25;
      char v26 = v15;
      if (v24) {
        char v26 = 0;
      }
      *(unsigned char *)a9 = v26;
      if (*(unsigned char *)(a10 + 3))
      {
        *(_DWORD *)(a10 + 12) = v20;
        *(_DWORD *)(a10 + 16) = v19;
      }
      uint64_t v31 = (void **)v30;
      std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100](&v31);
    }
  }
}

void sub_257D22CC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngt_deviationAnalyzer::ruleChecker(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4, int a5, uint64_t a6, uint64_t *a7, int a8, char a9, uint64_t a10)
{
  BOOL v14 = (a2 & 0xFF00000000) == 0 || (int)a2 <= a4;
  *(unsigned char *)(a10 + 1) = v14;
  BOOL v16 = (a3 & 0xFF00000000) == 0 || (int)a3 <= a5;
  *(unsigned char *)(a10 + 2) = v16;
  if (*(unsigned char *)(a6 + 36)) {
    *(unsigned char *)(a10 + 3) = *(_DWORD *)(a6 + 32) <= a4;
  }
  *(_DWORD *)(a10 + 8) = a8 - a5;
  if (v14 && v16)
  {
    BOOL v17 = *(unsigned char *)(a10 + 3) != 0;
    if (*(unsigned char *)(a10 + 3)) {
      goto LABEL_21;
    }
  }
  else
  {
    BOOL v17 = 0;
  }
  if (!a9) {
    return 0;
  }
LABEL_21:
  uint64_t CycleFactorsEndBfrWinEnd = Nightingale::ngt_deviationAnalyzer::findCycleFactorsEndBfrWinEnd(a1, a5, (uint64_t)a7);
  BOOL v20 = (int)CycleFactorsEndBfrWinEnd < 1 || (int)CycleFactorsEndBfrWinEnd + 84 < a4;
  char v21 = v20;
  *(unsigned char *)(a10 + 4) = v21;
  if (!v20) {
    BOOL v17 = 0;
  }
  BOOL v22 = Nightingale::ngt_deviationAnalyzer::checkCycleFactorInWin(CycleFactorsEndBfrWinEnd, a4, (a5 - 1), a7);
  *(unsigned char *)(a10 + 5) = v22;
  return v22 & v17;
}

uint64_t Nightingale::ngt_deviationAnalyzer::findNonAdjacentSpottingInACycle(uint64_t a1, uint64_t a2, int a3, int *a4)
{
  int64_t v5 = *(_DWORD **)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t result = *(void *)a2 != v4 && a3 + 2 <= *v5;
  int v7 = *a4;
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v4 - (uint64_t)v5) >> 5);
  if (*a4 < (int)v8)
  {
    unint64_t v9 = v8 - v7;
    if (v8 < v7) {
      unint64_t v9 = 0;
    }
    for (uint64_t i = &v5[24 * v7 + 6]; ; i += 96)
    {
      if (!v9) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (*(i - 16))
      {
        if (*i)
        {
          if (*((_DWORD *)i - 6) <= a3)
          {
            int v11 = *((_DWORD *)i - 1);
            if (v11 >= a3 && *((_DWORD *)i - 5) + 2 < a3 && v11 - 1 > a3) {
              break;
            }
          }
        }
      }
      ++v7;
      --v9;
      if (v8 == v7) {
        return result;
      }
    }
    uint64_t result = (result + 1);
    *a4 = v7;
  }
  return result;
}

void Nightingale::ngt_deviationAnalyzer::extendPeriodWFlowSpotting(int a1@<W1>, int a2@<W2>, int **a3@<X3>, void *a4@<X4>, uint64_t *a5@<X8>)
{
  int v7 = a1;
  uint64_t v10 = (char *)*a4;
  unint64_t v9 = (char *)a4[1];
  int v11 = (int *)&Nightingale::INVALID_JDAY;
  if ((char *)*a4 == v9)
  {
    int v12 = 0;
  }
  else
  {
    int v12 = 0;
    int v13 = (char *)*a4;
    do
    {
      if (*(_DWORD *)v13 >= a1) {
        break;
      }
      int v14 = v13[8];
      char v15 = v13 + 4;
      BOOL v16 = v14 ? (int *)v15 : (int *)&Nightingale::INVALID_JDAY;
      if (*v16 >= a1) {
        break;
      }
      ++v12;
      int v13 = v15 + 92;
    }
    while (v13 != v9);
  }
  BOOL v17 = v12 != 0;
  unsigned int v18 = v12 - 1;
  if (v17) {
    unint64_t v19 = v18;
  }
  else {
    unint64_t v19 = 0;
  }
  unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v10) >> 5);
  if (v20 <= v19) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  char v21 = &v10[96 * v19];
  if (v21[8]) {
    int v11 = (int *)(v21 + 4);
  }
  int v22 = *v11;
  if (v22 >= a1) {
    int v22 = a1;
  }
  char v23 = *a3;
  BOOL v24 = a3[1];
  if (*a3 == v24)
  {
    int v25 = 0;
  }
  else
  {
    int v25 = 0;
    do
    {
      if (*v23 >= v22) {
        break;
      }
      ++v25;
      v23 += 15;
    }
    while (v23 != v24);
  }
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  BYTE4(v88) = 0;
  BYTE8(v88) = 0;
  BYTE12(v88) = 0;
  LOBYTE(v89) = 0;
  BYTE4(v89) = 0;
  BYTE8(v89) = 0;
  LOBYTE(v90) = 0;
  BYTE4(v90) = 0;
  BYTE8(v90) = 0;
  BYTE12(v90) = 0;
  v91[0] = 0;
  v91[4] = 0;
  v91[8] = 0;
  v91[12] = 0;
  v91[16] = 0;
  v91[20] = 0;
  char v93 = 0;
  uint64_t v94 = 0;
  int v92 = 0;
  if (v20 - 1 > v19)
  {
    uint64_t v26 = (int)v19;
    unint64_t v27 = v19;
    int v79 = v19;
    while (1)
    {
      if (v20 <= v27) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      unint64_t v28 = &v10[96 * v27];
      long long v81 = *(_OWORD *)v28;
      long long v29 = *((_OWORD *)v28 + 1);
      long long v30 = *((_OWORD *)v28 + 2);
      long long v31 = *((_OWORD *)v28 + 3);
      *(void *)&v84[13] = *(void *)(v28 + 61);
      long long v83 = v30;
      *(_OWORD *)unint64_t v84 = v31;
      long long v82 = v29;
      uint64_t v86 = 0;
      uint64_t v87 = 0;
      __n128 __p = 0;
      std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&__p, *((const void **)v28 + 9), *((void *)v28 + 10), *((void *)v28 + 10) - *((void *)v28 + 9));
      if (BYTE8(v81)) {
        BOOL v32 = BYTE8(v82) == 0;
      }
      else {
        BOOL v32 = 1;
      }
      char v33 = !v32;
      if (!v32)
      {
        int v34 = DWORD1(v81);
        if (SDWORD1(v81) >= v7) {
          int v35 = v7;
        }
        else {
          int v35 = DWORD1(v81);
        }
        if (v19 < v26)
        {
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 5) <= v26 - 1) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v36 = *a4 + 96 * (v26 - 1);
          if (*(unsigned char *)(v36 + 8)) {
            int v35 = *(_DWORD *)(v36 + 4) + 3;
          }
        }
        int v37 = DWORD1(v82) - 1;
        if (DWORD1(v82) - 1 >= a2) {
          int v37 = a2;
        }
        unint64_t v38 = 0xEEEEEEEEEEEEEEEFLL * (a3[1] - *a3);
        if (v38 > v25)
        {
          uint64_t v39 = 0;
          int v40 = 0;
          int v41 = v81;
          unint64_t v42 = &(*a3)[15 * v25 + 2];
          int v43 = -3;
          uint64_t v44 = 4294967293;
          do
          {
            uint64_t v45 = *(v42 - 2);
            if (((*(v42 - 1) - 5) > 0xFFFFFFFB || *(unsigned char *)v42 != 0)
              && (int)v45 >= v35
              && (int)v45 <= v37)
            {
              if ((int)v45 < v41)
              {
                int v49 = v45 - v44;
                BOOL v50 = v49 < 3;
                if (v49 >= 3) {
                  int v51 = -3;
                }
                else {
                  int v51 = v43;
                }
                if (v50 || v43 == -3) {
                  int v40 = *(v42 - 2);
                }
                if (v43 == -3) {
                  int v43 = *(v42 - 2);
                }
                else {
                  int v43 = v51;
                }
                if (v41 - v40 <= 2)
                {
                  LODWORD(v81) = v43;
                  int v41 = v43;
                }
                goto LABEL_57;
              }
              if ((int)v45 > v34)
              {
                if ((int)v45 - v34 > 2)
                {
                  v25 += v39;
                  break;
                }
                DWORD1(v81) = *(v42 - 2);
                BYTE8(v81) = 1;
                int v34 = v45;
              }
            }
            uint64_t v45 = v44;
LABEL_57:
            v42 += 15;
            ++v39;
            uint64_t v44 = v45;
          }
          while (v38 > v25 + v39);
        }
        unint64_t v53 = a5[1];
        if (v53 >= a5[2])
        {
          uint64_t v54 = std::vector<Nightingale::cycleInfo>::__push_back_slow_path<Nightingale::cycleInfo const&>(a5, (uint64_t)&v81);
        }
        else
        {
          std::vector<Nightingale::cycleInfo>::__construct_one_at_end[abi:ne180100]<Nightingale::cycleInfo const&>((uint64_t)a5, (uint64_t)&v81);
          uint64_t v54 = v53 + 96;
        }
        LODWORD(v19) = v79;
        a5[1] = v54;
      }
      if (__p)
      {
        uint64_t v86 = __p;
        operator delete(__p);
      }
      unint64_t v9 = (char *)a4[1];
      if (v33)
      {
        unint64_t v27 = ++v26;
        uint64_t v10 = (char *)*a4;
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-*a4] >> 5);
        if (v20 - 1 > v26) {
          continue;
        }
      }
      break;
    }
  }
  long long v88 = *((_OWORD *)v9 - 6);
  long long v55 = *((_OWORD *)v9 - 5);
  long long v56 = *((_OWORD *)v9 - 4);
  long long v57 = *((_OWORD *)v9 - 3);
  *(void *)&v91[13] = *(void *)(v9 - 35);
  long long v90 = v56;
  *(_OWORD *)unint64_t v91 = v57;
  long long v89 = v55;
  if (&v88 != (long long *)(v9 - 96))
  {
    std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v92, *((char **)v9 - 3), *((char **)v9 - 2), *((void *)v9 - 2) - *((void *)v9 - 3));
    unint64_t v9 = (char *)a4[1];
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v9[-*a4] >> 5) >= 2 && *(v9 - 184)) {
    int v7 = *((_DWORD *)v9 - 47) + 3;
  }
  unint64_t v58 = 0xEEEEEEEEEEEEEEEFLL * (a3[1] - *a3);
  if (v58 > v25)
  {
    int v59 = 0;
    unint64_t v60 = v25;
    int v61 = v88;
    char v62 = &(*a3)[15 * v25 + 2];
    int v63 = -3;
    uint64_t v64 = 4294967293;
    do
    {
      uint64_t v65 = *(v62 - 2);
      if ((*(v62 - 1) - 1) < 4 || (*(unsigned char *)v62)
        && ((int)v65 >= v7 ? (BOOL v66 = (int)v65 < v61) : (BOOL v66 = 0), v66))
      {
        int v67 = v65 - v64;
        BOOL v68 = v67 < 3;
        if (v67 >= 3) {
          int v69 = -3;
        }
        else {
          int v69 = v63;
        }
        if (v68 || v63 == -3) {
          int v59 = *(v62 - 2);
        }
        if (v63 == -3) {
          int v63 = *(v62 - 2);
        }
        else {
          int v63 = v69;
        }
        if (v61 - v59 <= 2)
        {
          LODWORD(v88) = v63;
          int v61 = v63;
        }
      }
      else
      {
        uint64_t v65 = v64;
      }
      ++v60;
      v62 += 15;
      uint64_t v64 = v65;
    }
    while (v58 > v60);
  }
  unint64_t v71 = a5[1];
  if (v71 >= a5[2])
  {
    uint64_t v72 = std::vector<Nightingale::cycleInfo>::__push_back_slow_path<Nightingale::cycleInfo const&>(a5, (uint64_t)&v88);
  }
  else
  {
    std::vector<Nightingale::cycleInfo>::__construct_one_at_end[abi:ne180100]<Nightingale::cycleInfo const&>((uint64_t)a5, (uint64_t)&v88);
    uint64_t v72 = v71 + 96;
  }
  a5[1] = v72;
  uint64_t v73 = *a5;
  uint64_t v74 = v72 - *a5;
  if (v74 != 96)
  {
    uint64_t v75 = 0;
    unint64_t v76 = 0;
    unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * (v74 >> 5);
    do
    {
      if (v77 <= ++v76) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v78 = v73 + v75;
      *(_DWORD *)(v78 + 20) = *(_DWORD *)(v78 + 96) - 1;
      *(unsigned char *)(v78 + 24) = 1;
      uint64_t v73 = *a5;
      unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * ((a5[1] - *a5) >> 5);
      v75 += 96;
    }
    while (v77 - 1 > v76);
  }
  if (v92)
  {
    char v93 = v92;
    operator delete(v92);
  }
}

void sub_257D234A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  if (__p)
  {
    a33 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a23);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::ngt_deviationAnalyzer::findCycleFactorsEndBfrWinEnd(uint64_t a1, int a2, uint64_t a3)
{
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  uint64_t v10 = 0;
  Nightingale::phaseFactorProcessor::getAllCycleVec(__p);
  uint64_t EndOfReproductiveBfrADate = Nightingale::phaseFactorProcessor::findEndOfReproductiveBfrADate((uint64_t)&v8, a3, (uint64_t *)__p, a2);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v8)
  {
    unint64_t v9 = v8;
    operator delete(v8);
  }
  return EndOfReproductiveBfrADate;
}

void sub_257D23570(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::ngt_deviationAnalyzer::checkCycleFactorInWin(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t *a4)
{
  int v14 = 0;
  char v15 = 0;
  uint64_t v16 = 0;
  Nightingale::phaseFactorProcessor::getAllCycleVec(&v12);
  __n128 __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&__p, v12, (uint64_t)v13, v13 - (unsigned char *)v12);
  char v7 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v14, a2 | (unint64_t)(a3 << 32), (uint64_t *)&__p, a4);
  if (__p)
  {
    uint64_t v10 = __p;
    operator delete(__p);
  }
  if (v12)
  {
    int v13 = v12;
    operator delete(v12);
  }
  if (v14)
  {
    char v15 = v14;
    operator delete(v14);
  }
  return v7 == 0;
}

void sub_257D2365C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13) {
    operator delete(a13);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *std::__minmax_element_impl[abi:ne180100]<std::__wrap_iter<int *>,std::__wrap_iter<int *>,std::__identity,std::__less<void,void>>(_DWORD *result, _DWORD *a2)
{
  uint64_t v2 = result;
  if (result != a2 && result + 1 != a2)
  {
    int v5 = *result;
    int v4 = result[1];
    if (v4 < *result) {
      ++result;
    }
    int v6 = v4 >= v5 ? v2 + 1 : v2;
    char v7 = v2 + 2;
    if (v7 != a2)
    {
      if (v4 <= v5) {
        int v8 = v5;
      }
      else {
        int v8 = v4;
      }
      if (v4 >= v5) {
        int v4 = v5;
      }
      while (v7 + 1 != a2)
      {
        int v10 = *v7;
        int v9 = v7[1];
        if (v9 >= *v7)
        {
          if (v10 < v4)
          {
            int v4 = *v7;
            uint64_t result = v7;
          }
          BOOL v11 = v9 < v8;
          if (v9 > v8) {
            int v8 = v7[1];
          }
          if (!v11) {
            int v6 = v7 + 1;
          }
        }
        else
        {
          int v4 = *result;
          if (v9 < *result)
          {
            int v4 = v7[1];
            uint64_t result = v7 + 1;
          }
          int v8 = *v6;
          if (v10 > *v6) {
            int v8 = *v7;
          }
          if (v10 >= *v6) {
            int v6 = v7;
          }
        }
        v7 += 2;
        if (v7 == a2) {
          return result;
        }
      }
      if (*v7 < *result) {
        return v7;
      }
    }
  }
  return result;
}

void *std::vector<Nightingale::cycleInfo>::__construct_one_at_end[abi:ne180100]<Nightingale::cycleInfo const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  long long v4 = *(_OWORD *)(a2 + 16);
  long long v5 = *(_OWORD *)(a2 + 32);
  long long v6 = *(_OWORD *)(a2 + 48);
  *(void *)(v3 + 61) = *(void *)(a2 + 61);
  *(_OWORD *)(v3 + 32) = v5;
  *(_OWORD *)(v3 + 48) = v6;
  *(_OWORD *)(v3 + 16) = v4;
  *(_OWORD *)uint64_t v3 = *(_OWORD *)a2;
  *(void *)(v3 + 80) = 0;
  *(void *)(v3 + 88) = 0;
  *(void *)(v3 + 72) = 0;
  uint64_t result = std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)(v3 + 72), *(const void **)(a2 + 72), *(void *)(a2 + 80), *(void *)(a2 + 80) - *(void *)(a2 + 72));
  *(void *)(a1 + 8) = v3 + 96;
  return result;
}

void sub_257D237EC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<Nightingale::cycleInfo>::__push_back_slow_path<Nightingale::cycleInfo const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x2AAAAAAAAAAAAAALL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x155555555555555) {
    unint64_t v9 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v20 = a1 + 2;
  if (v9) {
    int v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(v7, v9);
  }
  else {
    int v10 = 0;
  }
  BOOL v11 = &v10[96 * v4];
  v17[0] = v10;
  v17[1] = v11;
  unsigned int v18 = v11;
  unint64_t v19 = &v10[96 * v9];
  long long v12 = *(_OWORD *)(a2 + 16);
  long long v13 = *(_OWORD *)(a2 + 32);
  long long v14 = *(_OWORD *)(a2 + 48);
  *(void *)(v11 + 61) = *(void *)(a2 + 61);
  *((_OWORD *)v11 + 2) = v13;
  *((_OWORD *)v11 + 3) = v14;
  *((_OWORD *)v11 + 1) = v12;
  *(_OWORD *)BOOL v11 = *(_OWORD *)a2;
  *((void *)v11 + 10) = 0;
  *((void *)v11 + 11) = 0;
  *((void *)v11 + 9) = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)v11 + 9, *(const void **)(a2 + 72), *(void *)(a2 + 80), *(void *)(a2 + 80) - *(void *)(a2 + 72));
  v18 += 96;
  std::vector<Nightingale::cycleInfo>::__swap_out_circular_buffer(a1, v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer((uint64_t)v17);
  return v15;
}

void sub_257D23914(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Nightingale::cycleInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(96 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    do
    {
      *(_OWORD *)(v7 - 96) = *(_OWORD *)(a3 - 96);
      long long v8 = *(_OWORD *)(a3 - 80);
      long long v9 = *(_OWORD *)(a3 - 64);
      long long v10 = *(_OWORD *)(a3 - 48);
      *(void *)(v7 - 35) = *(void *)(a3 - 35);
      *(_OWORD *)(v7 - 64) = v9;
      *(_OWORD *)(v7 - 48) = v10;
      *(_OWORD *)(v7 - 80) = v8;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      *(void *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 - 24);
      *(void *)(v7 - 8) = *(void *)(a3 - 8);
      *(void *)(a3 - 24) = 0;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      uint64_t v7 = *((void *)&v16 + 1) - 96;
      *((void *)&v16 + 1) -= 96;
      a3 -= 96;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 + 72);
    if (v3)
    {
      *(void *)(v1 + 80) = v3;
      operator delete(v3);
    }
    v1 += 96;
  }
}

uint64_t std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<Nightingale::cycleInfo>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    *(void *)(a1 + 16) = v2 - 96;
    uint64_t v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 96;
    }
  }
}

void *std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(void *result, char *__src, char *a3, unint64_t a4)
{
  uint64_t v7 = result;
  unint64_t v8 = result[2];
  long long v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    uint64_t result = std::vector<Nightingale::Phase>::__vallocate[abi:ne180100](v7, v11);
    long long v9 = (char *)v7[1];
    goto LABEL_17;
  }
  long long v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      uint64_t result = memmove(v9, __src, v16);
    }
    long long v15 = &v9[v16];
    goto LABEL_20;
  }
  char v14 = &__src[v13];
  if (v12 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v13);
    long long v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    uint64_t result = memmove(v9, v14, a3 - v14);
  }
  long long v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<Nightingale::cycleInfo>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<Nightingale::cycleInfo>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 96)
  {
    unint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void Nightingale::fwEstimatorCalendar::getHistFwCal(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X3>, uint64_t *a4@<X4>, uint64_t a5@<X8>)
{
  *(unsigned char *)a5 = 0;
  *(unsigned char *)(a5 + 4) = 0;
  *(unsigned char *)(a5 + 8) = 0;
  *(unsigned char *)(a5 + 12) = 0;
  *(_DWORD *)(a5 + 16) = 3;
  *(unsigned char *)(a5 + 32) = 0;
  *(void *)(a5 + 20) = 0;
  *(_WORD *)(a5 + 28) = 0;
  *(int32x4_t *)(a5 + 36) = vdupq_n_s32(0x7FC00000u);
  *(unsigned char *)(a5 + 52) = 0;
  *(unsigned char *)(a5 + 56) = 0;
  *(unsigned char *)(a5 + 60) = 0;
  *(unsigned char *)(a5 + 64) = 0;
  *(unsigned char *)(a5 + 72) = 0;
  *(unsigned char *)(a5 + 96) = 0;
  *(unsigned char *)(a5 + 104) = 0;
  *(unsigned char *)(a5 + 128) = 0;
  *(unsigned char *)(a5 + 136) = 0;
  *(unsigned char *)(a5 + 140) = 0;
  *(void *)(a5 + 144) = 0x17FC00000;
  *(_DWORD *)(a5 + 152) = 0;
  *(_WORD *)(a5 + 156) = 0;
  if ((a3 & 0xFF00000000) != 0)
  {
    *(unsigned char *)(a5 + 4) = 1;
    *(_DWORD *)a5 = (int)(float)((float)((float)(int)a3 + -18.0) + 1.0);
    *(unsigned char *)(a5 + 12) = 1;
    *(_DWORD *)(a5 + 8) = (int)(float)((float)((float)(int)a3 + -13.0) + 1.0);
    *(_DWORD *)(a5 + 16) = 3;
    *(unsigned char *)(a5 + 29) = Nightingale::phaseFactorProcessor::suppressFWStEnd(a1, (unsigned int *)a5, (unsigned int *)(a5 + 8), a4);
    Nightingale::fwEstimatorBase::suppressHistFWOverCycleBoundary(a1, *a2, a3, a5);
  }
}

void sub_257D23E9C(_Unwind_Exception *a1)
{
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle(v1);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::fwEstimatorCalendar::getjDayFwCal(Nightingale::fwEstimatorCalendar *this, int a2, int a3)
{
  LODWORD(v3) = (int)(float)((float)a3 + -18.0);
  LODWORD(v4) = (int)(float)((float)a3 + -13.0);
  BOOL v5 = (int)v3 < a2;
  if ((int)v3 < a2) {
    uint64_t v3 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v3 = v3;
  }
  if (v5) {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v4 = v4;
  }
  return v3 | (v4 << 32);
}

uint64_t Nightingale::fwEstimatorCalendar::getjDayFwEndCal(Nightingale::fwEstimatorCalendar *this, int a2, int a3)
{
  int v3 = (int)(float)((float)a3 + -18.0);
  BOOL v4 = v3 < a2;
  uint64_t v5 = v3 >= a2;
  LODWORD(v6) = (int)(float)((float)a3 + -13.0);
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v6;
  }
  return v6 | (v5 << 32);
}

void sub_257D23FD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D2414C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D242C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D24404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D24528(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D245DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D2468C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D24740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D247F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D248A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D24954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D24A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t Nightingale::phaseFactorProcessor::detectPhaseJDayRange(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v3 = (char *)*a3;
  BOOL v4 = (char *)a3[1];
  if (v4 == (char *)*a3)
  {
    unsigned int v17 = -1;
  }
  else
  {
    unint64_t v5 = (uint64_t)&v4[-*a3] >> 2;
    unint64_t v6 = v5;
    uint64_t v7 = (char *)*a3;
    do
    {
      unint64_t v8 = v6 >> 1;
      long long v9 = (int *)&v7[4 * (v6 >> 1)];
      int v11 = *v9;
      uint64_t v10 = (char *)(v9 + 1);
      v6 += ~(v6 >> 1);
      if (v11 > (int)a2) {
        unint64_t v6 = v8;
      }
      else {
        uint64_t v7 = v10;
      }
    }
    while (v6);
    uint64_t v12 = ((unint64_t)(v7 - v3) >> 2) + 0xFFFFFFFF;
    BOOL v4 = (char *)*a3;
    do
    {
      unint64_t v13 = v5 >> 1;
      char v14 = (int *)&v4[4 * (v5 >> 1)];
      int v16 = *v14;
      long long v15 = (char *)(v14 + 1);
      v5 += ~(v5 >> 1);
      if (v16 > SHIDWORD(a2)) {
        unint64_t v5 = v13;
      }
      else {
        BOOL v4 = v15;
      }
    }
    while (v5);
    unsigned int v17 = v12;
  }
  return (v17 | ((unint64_t)((unint64_t)(v4 - v3) >> 2) << 32)) - 0x100000000;
}

uint64_t Nightingale::phaseFactorProcessor::detectPhases(uint64_t a1, unint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t v7 = HIDWORD(a2);
  unint64_t v8 = Nightingale::phaseFactorProcessor::detectPhaseJDayRange(a1, a2, a4);
  unint64_t v9 = HIDWORD(v8);
  if ((HIDWORD(v8) & v8) == 0xFFFFFFFF && v7 != -1) {
    return 0;
  }
  if (v8 == -1) {
    int v11 = 0;
  }
  else {
    int v11 = v8;
  }
  if (v7 == -1) {
    LODWORD(v9) = ((unint64_t)(a4[1] - *a4) >> 2) - 1;
  }
  if (v11 <= (int)v9)
  {
    int isEndOfAPhase = 0;
    BOOL isStartOfAPhase = 0;
    unsigned __int8 v12 = 0;
    unint64_t v16 = v11;
    uint64_t v17 = *a3;
    uint64_t v18 = a3[1];
    int v19 = v9 + 1;
    do
    {
      if (v18 == v17)
      {
        uint64_t v18 = v17;
      }
      else
      {
        unint64_t v20 = 0;
        do
        {
          uint64_t v21 = a4[3];
          if (v16 >= (a4[4] - v21) >> 3) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v23 = *(void *)(v21 + 8 * v16);
          uint64_t v22 = Nightingale::PhaseSet::contains(&v23, *(unsigned __int8 *)(v17 + v20));
          if (v22)
          {
            if (!isStartOfAPhase) {
              BOOL isStartOfAPhase = Nightingale::phaseFactorProcessor::isStartOfAPhase(v22, v16, a2, a4, 0);
            }
            unsigned __int8 v12 = 1;
          }
          else if (!(_BYTE)isEndOfAPhase)
          {
            int isEndOfAPhase = Nightingale::phaseFactorProcessor::isEndOfAPhase(v22, v16, a2, a4, 0);
          }
          ++v20;
          uint64_t v17 = *a3;
          uint64_t v18 = a3[1];
        }
        while (v18 - *a3 > v20);
      }
      ++v16;
    }
    while (v19 != v16);
  }
  else
  {
    unsigned __int8 v12 = 0;
    BOOL isStartOfAPhase = 0;
    int isEndOfAPhase = 0;
  }
  return v12 | (isStartOfAPhase << 8) | (isEndOfAPhase << 16);
}

BOOL Nightingale::phaseFactorProcessor::isStartOfAPhase(uint64_t a1, int a2, uint64_t a3, void *a4, unsigned int a5)
{
  if (a2 >= (unint64_t)((uint64_t)(a4[1] - *a4) >> 2)) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  int v5 = *(_DWORD *)(*a4 + 4 * a2);
  if (v5 < (int)a3 || v5 > SHIDWORD(a3)) {
    return 0;
  }
  if (!a2) {
    return 1;
  }
  uint64_t v7 = a4[3];
  unint64_t v8 = a2 - 1;
  if (v8 >= (a4[4] - v7) >> 3) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  return !Nightingale::PhaseSet::contains((void *)(v7 + 8 * v8), a5);
}

BOOL Nightingale::phaseFactorProcessor::isEndOfAPhase(uint64_t a1, int a2, uint64_t a3, void *a4, unsigned int a5)
{
  if (a2 >= (unint64_t)((uint64_t)(a4[1] - *a4) >> 2)) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  int v5 = *(_DWORD *)(*a4 + 4 * a2);
  BOOL v6 = v5 >= (int)a3 && v5 <= SHIDWORD(a3);
  if (!v6 || !a2) {
    return 0;
  }
  uint64_t v7 = a4[3];
  unint64_t v8 = a2 - 1;
  if (v8 >= (a4[4] - v7) >> 3) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  return (Nightingale::PhaseSet::contains((void *)(v7 + 8 * v8), a5) & 1) != 0;
}

uint64_t Nightingale::phaseFactorProcessor::jDayLastEndOfAPhaseSet(uint64_t a1, void *a2, uint64_t *a3)
{
  unint64_t v3 = a2[1] - *a2;
  if (!(v3 >> 2)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = a3[1];
  if (v6 != *a3)
  {
    unint64_t v7 = 0;
    unint64_t v8 = (uint64_t)((v3 << 30) - 0x100000000) >> 32;
    uint64_t v6 = *a3;
    while (1)
    {
      uint64_t v9 = a2[3];
      if (v8 >= (a2[4] - v9) >> 3) {
LABEL_40:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      if (Nightingale::PhaseSet::contains((void *)(v9 + 8 * v8), *(unsigned __int8 *)(v6 + v7))) {
        return 4294967294;
      }
      ++v7;
      uint64_t v6 = *a3;
      uint64_t v10 = a3[1];
      if (v10 - *a3 <= v7) {
        goto LABEL_9;
      }
    }
  }
  uint64_t v10 = a3[1];
LABEL_9:
  if ((int)(v3 >> 2) < 2) {
    goto LABEL_27;
  }
  uint64_t v11 = (uint64_t)((v3 << 30) - 0x200000000) >> 32;
  while (v10 == v6)
  {
    uint64_t v10 = v6;
LABEL_21:
    if (v11-- <= 0) {
      goto LABEL_27;
    }
  }
  unint64_t v12 = 0;
  unint64_t v13 = v11 + 1;
  while (1)
  {
    uint64_t v14 = a2[3];
    if (v11 >= (unint64_t)((a2[4] - v14) >> 3)) {
      goto LABEL_40;
    }
    if (Nightingale::PhaseSet::contains((void *)(v14 + 8 * v11), *(unsigned __int8 *)(v6 + v12)))
    {
      uint64_t v15 = a2[3];
      if (v13 >= (a2[4] - v15) >> 3) {
        goto LABEL_40;
      }
      if (a3[1] - *a3 <= v12) {
LABEL_42:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      if ((Nightingale::PhaseSet::contains((void *)(v15 + 8 * v13), *(unsigned __int8 *)(*a3 + v12)) & 1) == 0) {
        break;
      }
    }
    ++v12;
    uint64_t v6 = *a3;
    uint64_t v10 = a3[1];
    if (v10 - *a3 <= v12) {
      goto LABEL_21;
    }
  }
  if (v13 >= (uint64_t)(a2[1] - *a2) >> 2) {
LABEL_43:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  uint64_t v17 = *(unsigned int *)(*a2 + 4 * v13);
  if (v17 == -1)
  {
LABEL_27:
    uint64_t v18 = *a3;
    if (a3[1] != *a3)
    {
      unint64_t v19 = 0;
      uint64_t v17 = 0xFFFFFFFFLL;
      while (1)
      {
        unint64_t v20 = (void *)a2[3];
        if ((void *)a2[4] == v20) {
LABEL_41:
        }
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        if (Nightingale::PhaseSet::contains(v20, *(unsigned __int8 *)(v18 + v19)))
        {
          uint64_t v21 = a2[3];
          if ((unint64_t)(a2[4] - v21) <= 8) {
            goto LABEL_41;
          }
          if (a3[1] - *a3 <= v19) {
            goto LABEL_42;
          }
          if ((Nightingale::PhaseSet::contains((void *)(v21 + 8), *(unsigned __int8 *)(*a3 + v19)) & 1) == 0)
          {
            if (a2[1] - *a2 <= 4uLL) {
              goto LABEL_43;
            }
            uint64_t v17 = *(unsigned int *)(*a2 + 4);
          }
        }
        ++v19;
        uint64_t v18 = *a3;
        if (a3[1] - *a3 <= v19) {
          return v17;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v17;
}

float Nightingale::phaseFactorProcessor::getjDayStartOfAPhasetojDayRangeStart(uint64_t a1, unint64_t a2, uint64_t *a3, unsigned int a4)
{
  uint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  if (*a3 == v5) {
    return NAN;
  }
  uint64_t v7 = a3[3];
  uint64_t v8 = a3[4];
  if (v7 == v8) {
    return NAN;
  }
  unint64_t v9 = (v5 - v4) >> 2;
  if (v9 != (v8 - v7) >> 3 || (int)v9 < 1) {
    return NAN;
  }
  int v12 = a2;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  unint64_t v15 = HIDWORD(a2);
  while (1)
  {
    if (v9 <= v14) {
      goto LABEL_23;
    }
    int v16 = *(_DWORD *)(v4 + 4 * v14);
    if (v16 >= v12 && v16 < (int)v15)
    {
      uint64_t v18 = a3[3];
      if (v14 >= (a3[4] - v18) >> 3) {
        goto LABEL_24;
      }
      if (Nightingale::PhaseSet::contains((void *)(v18 + v13), a4))
      {
        if (!v14) {
          break;
        }
        uint64_t v19 = a3[3];
        if (v14 - 1 >= (a3[4] - v19) >> 3) {
LABEL_24:
        }
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        if ((Nightingale::PhaseSet::contains((void *)(v19 + v13 - 8), a4) & 1) == 0) {
          break;
        }
      }
    }
    ++v14;
    uint64_t v4 = *a3;
    uint64_t v20 = a3[1] - *a3;
    unint64_t v9 = v20 >> 2;
    v13 += 8;
    if ((uint64_t)v14 >= (int)((unint64_t)v20 >> 2)) {
      return NAN;
    }
  }
  if (v14 >= (a3[1] - *a3) >> 2) {
LABEL_23:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  return (float)(*(_DWORD *)(*a3 + 4 * v14) - v12);
}

float Nightingale::phaseFactorProcessor::getjDayEndOfAPhasetojDayRangeEnd(uint64_t a1, unint64_t a2, void *a3, unsigned int a4)
{
  uint64_t v4 = a3[1];
  if (*a3 == v4) {
    return NAN;
  }
  uint64_t v6 = a3[3];
  uint64_t v7 = a3[4];
  if (v6 == v7) {
    return NAN;
  }
  uint64_t v8 = v4 - *a3;
  if (v8 >> 2 != (v7 - v6) >> 3 || (int)(v8 >> 2) < 2) {
    return NAN;
  }
  int v11 = a2;
  unint64_t v12 = HIDWORD(a2);
  for (uint64_t i = ((unint64_t)v8 >> 2); ; --i)
  {
    uint64_t v14 = i - 1;
    unint64_t v15 = (i - 1);
    if (v15 >= (uint64_t)(a3[1] - *a3) >> 2) {
      goto LABEL_22;
    }
    int v16 = *(_DWORD *)(*a3 + 4 * v15);
    if (v16 >= v11 && v16 < (int)v12)
    {
      uint64_t v18 = a3[3];
      if (v15 >= (a3[4] - v18) >> 3) {
        goto LABEL_23;
      }
      if ((Nightingale::PhaseSet::contains((void *)(v18 + 8 * v15), a4) & 1) == 0)
      {
        unint64_t v19 = (i - 2);
        uint64_t v20 = a3[3];
        if (v19 >= (a3[4] - v20) >> 3) {
LABEL_23:
        }
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        if (Nightingale::PhaseSet::contains((void *)(v20 + 8 * v19), a4)) {
          break;
        }
      }
    }
    if ((unint64_t)(v14 + 1) <= 2) {
      return NAN;
    }
  }
  if (v15 >= (uint64_t)(a3[1] - *a3) >> 2) {
LABEL_22:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  return (float)((int)v12 - *(_DWORD *)(*a3 + 4 * v15));
}

void Nightingale::phaseFactorProcessor::getjDayStartOfVPhasestojDayRangeStart(float *a1@<X0>, unint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, float **a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  uint64_t v6 = *a4;
  if (a4[1] != *a4)
  {
    unint64_t v10 = 0;
    do
    {
      float v11 = Nightingale::phaseFactorProcessor::getjDayStartOfAPhasetojDayRangeStart((uint64_t)a1, a2, a3, *(unsigned __int8 *)(v6 + v10));
      float v12 = v11;
      uint64_t v14 = a5[1];
      unint64_t v13 = (unint64_t)a5[2];
      if ((unint64_t)v14 >= v13)
      {
        a1 = *a5;
        uint64_t v16 = v14 - *a5;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v13 - (void)a1;
        if (v18 >> 1 > v17) {
          unint64_t v17 = v18 >> 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          uint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a5 + 2), v19);
          a1 = *a5;
          uint64_t v14 = a5[1];
        }
        else
        {
          uint64_t v20 = 0;
        }
        uint64_t v21 = (float *)&v20[4 * v16];
        *uint64_t v21 = v12;
        unint64_t v15 = v21 + 1;
        while (v14 != a1)
        {
          int v22 = *((_DWORD *)v14-- - 1);
          *((_DWORD *)v21-- - 1) = v22;
        }
        *a5 = v21;
        a5[1] = v15;
        a5[2] = (float *)&v20[4 * v19];
        if (a1) {
          operator delete(a1);
        }
      }
      else
      {
        *uint64_t v14 = v11;
        unint64_t v15 = v14 + 1;
      }
      a5[1] = v15;
      ++v10;
      uint64_t v6 = *a4;
    }
    while (a4[1] - *a4 > v10);
  }
}

void sub_257D25350(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::phaseFactorProcessor::getjDayEndOfVPhasestojDayRangeEnd(float *a1@<X0>, unint64_t a2@<X1>, void *a3@<X2>, uint64_t *a4@<X3>, float **a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  uint64_t v6 = *a4;
  if (a4[1] != *a4)
  {
    unint64_t v10 = 0;
    do
    {
      float v11 = Nightingale::phaseFactorProcessor::getjDayEndOfAPhasetojDayRangeEnd((uint64_t)a1, a2, a3, *(unsigned __int8 *)(v6 + v10));
      float v12 = v11;
      uint64_t v14 = a5[1];
      unint64_t v13 = (unint64_t)a5[2];
      if ((unint64_t)v14 >= v13)
      {
        a1 = *a5;
        uint64_t v16 = v14 - *a5;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v13 - (void)a1;
        if (v18 >> 1 > v17) {
          unint64_t v17 = v18 >> 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          uint64_t v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a5 + 2), v19);
          a1 = *a5;
          uint64_t v14 = a5[1];
        }
        else
        {
          uint64_t v20 = 0;
        }
        uint64_t v21 = (float *)&v20[4 * v16];
        *uint64_t v21 = v12;
        unint64_t v15 = v21 + 1;
        while (v14 != a1)
        {
          int v22 = *((_DWORD *)v14-- - 1);
          *((_DWORD *)v21-- - 1) = v22;
        }
        *a5 = v21;
        a5[1] = v15;
        a5[2] = (float *)&v20[4 * v19];
        if (a1) {
          operator delete(a1);
        }
      }
      else
      {
        *uint64_t v14 = v11;
        unint64_t v15 = v14 + 1;
      }
      a5[1] = v15;
      ++v10;
      uint64_t v6 = *a4;
    }
    while (a4[1] - *a4 > v10);
  }
}

void sub_257D254C4(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::phaseFactorProcessor::findEndOfReproductiveBfrADate(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t v5 = *(_DWORD **)a2;
  uint64_t v6 = *(unsigned char **)(a2 + 8);
  if (v5 == (_DWORD *)v6 || *(void *)(a2 + 24) == *(void *)(a2 + 32)) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v8 = v6 - (unsigned char *)v5;
  uint64_t v9 = (v6 - (unsigned char *)v5) >> 2;
  if ((int)v9 < 1)
  {
    LODWORD(v10) = 0;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = (v8 >> 2);
    while (1)
    {
      if (v9 == v10) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (v5[v10] > a4) {
        break;
      }
      if (v11 == ++v10)
      {
        LODWORD(v10) = v9;
        break;
      }
    }
  }
  uint64_t v23 = 0;
  BOOL v24 = 0;
  uint64_t v25 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v23, v5, (uint64_t)&v5[v10], v10);
  unint64_t v13 = *(const void **)(a2 + 24);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  std::vector<Nightingale::PhaseSet>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::PhaseSet*>,std::__wrap_iter<Nightingale::PhaseSet*>>(&v20, v13, (uint64_t)v13 + 8 * v10, v10);
  uint64_t v14 = std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100]<std::vector<int>&,std::vector<Nightingale::PhaseSet>&,0>(v17, (uint64_t)&v23, (uint64_t)&v20);
  int EndOfAPhaseSet = Nightingale::phaseFactorProcessor::jDayLastEndOfAPhaseSet((uint64_t)v14, v17, a3);
  if (EndOfAPhaseSet < 0) {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v12 = EndOfAPhaseSet;
  }
  if (__p)
  {
    unint64_t v19 = __p;
    operator delete(__p);
  }
  if (v17[0])
  {
    v17[1] = v17[0];
    operator delete(v17[0]);
  }
  if (v20)
  {
    uint64_t v21 = v20;
    operator delete(v20);
  }
  if (v23)
  {
    BOOL v24 = v23;
    operator delete(v23);
  }
  return v12;
}

void sub_257D2562C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  std::pair<std::vector<float>,std::vector<float>>::~pair((uint64_t)&a9);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  uint64_t v18 = *(void **)(v16 - 56);
  if (v18)
  {
    *(void *)(v16 - 48) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(a1);
}

uint64_t Nightingale::phaseFactorProcessor::ccMenstCycleLen_handling(uint64_t *a1, void *a2, uint64_t *a3)
{
  int EndOfAPhaseSet = Nightingale::phaseFactorProcessor::jDayLastEndOfAPhaseSet((uint64_t)a1, a2, a3);
  uint64_t v6 = *a1;
  uint64_t v5 = a1[1];
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::phaseFactorProcessor::ccMenstCycleLen_handling(EndOfAPhaseSet, log);
  }
  uint64_t v9 = *a1;
  uint64_t v8 = a1[1];
  if (*a1 == v8) {
    return 0;
  }
  if (EndOfAPhaseSet == -2)
  {
    unint64_t v16 = (unint64_t)(v8 - v9) >> 3;
    if ((int)v16 >= 2) {
      return 2;
    }
    else {
      return v16;
    }
  }
  else
  {
    uint64_t result = (unint64_t)(v5 - v6) >> 3;
    if (EndOfAPhaseSet != -1)
    {
      unint64_t v11 = v8 - v9;
      uint64_t v12 = (v8 - v9) >> 3;
      if ((int)v12 >= 1)
      {
        uint64_t v13 = (result - v12);
        uint64_t v14 = (v11 >> 3);
        for (uint64_t i = (int *)(v9 + 4); ; i += 2)
        {
          if (!v12) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          if (*i >= EndOfAPhaseSet) {
            break;
          }
          uint64_t result = (result - 1);
          --v12;
          if (!--v14) {
            return v13;
          }
        }
      }
    }
  }
  return result;
}

void Nightingale::phaseFactorProcessor::tagPhaseJDayRange(uint64_t a1, unint64_t a2, uint64_t *a3, unint64_t *a4)
{
  unint64_t v5 = HIDWORD(a2);
  unint64_t v6 = Nightingale::phaseFactorProcessor::detectPhaseJDayRange(a1, a2, a3);
  unint64_t v7 = HIDWORD(v6);
  a4[1] = *a4;
  __n128 __p = 0;
  BOOL v50 = 0;
  uint64_t v51 = 0;
  if ((HIDWORD(v6) & v6) != 0xFFFFFFFF || v5 == -1)
  {
    if (v6 == -1) {
      int v9 = 0;
    }
    else {
      int v9 = v6;
    }
    if (v5 == -1) {
      LODWORD(v7) = ((unint64_t)(a3[1] - *a3) >> 2) - 1;
    }
    if (v9 <= (int)v7)
    {
      unint64_t v10 = v9;
      int v41 = v7 + 1;
      while (1)
      {
        uint64_t v11 = a3[3];
        if (v10 >= (a3[4] - v11) >> 3) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v12 = *(void *)(v11 + 8 * v10);
        uint64_t v47 = 0;
        uint64_t v48 = v12;
        uint64_t v45 = 0;
        uint64_t v46 = 0;
        Nightingale::PhaseSet::phasesOnInPhaseSet2Vec(&v48, (unint64_t *)&v45);
        unint64_t v43 = v10;
        uint64_t v13 = v45;
        uint64_t v14 = v46;
        if (v46 == v45)
        {
          uint64_t v13 = v46;
          if (!v46) {
            goto LABEL_50;
          }
        }
        else
        {
          unint64_t v15 = 0;
          do
          {
            unsigned __int8 v44 = 0;
            unsigned int v16 = v13[v15];
            unsigned __int8 v44 = v13[v15];
            unint64_t v17 = (char *)__p;
            uint64_t v18 = (unsigned __int8 *)__p;
            unint64_t v19 = v50 - (unsigned char *)__p;
            if (v50 != __p)
            {
              uint64_t v18 = (unsigned __int8 *)__p;
              unint64_t v20 = v50 - (unsigned char *)__p;
              do
              {
                uint64_t v21 = &v18[v20 >> 1];
                unsigned int v23 = *v21;
                uint64_t v22 = v21 + 1;
                unint64_t v24 = v20 >> 1;
                v20 += ~(v20 >> 1);
                if (v23 < v16) {
                  uint64_t v18 = v22;
                }
                else {
                  unint64_t v20 = v24;
                }
              }
              while (v20);
            }
            if (v18 == v50 || v16 < *v18)
            {
              uint64_t v26 = (unsigned char *)a4[1];
              unint64_t v25 = a4[2];
              if ((unint64_t)v26 >= v25)
              {
                unint64_t v28 = *a4;
                long long v29 = &v26[-*a4];
                unint64_t v30 = (unint64_t)(v29 + 1);
                if ((uint64_t)(v29 + 1) < 0) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v31 = v25 - v28;
                if (2 * v31 > v30) {
                  unint64_t v30 = 2 * v31;
                }
                if (v31 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v32 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v32 = v30;
                }
                if (v32) {
                  char v33 = (char *)operator new(v32);
                }
                else {
                  char v33 = 0;
                }
                int v34 = &v29[(void)v33];
                int v35 = &v29[(void)v33];
                *int v35 = v16;
                unint64_t v27 = v35 + 1;
                if (v26 != (unsigned char *)v28)
                {
                  uint64_t v36 = &v26[~v28];
                  do
                  {
                    char v37 = *--v26;
                    (v36--)[(void)v33] = v37;
                  }
                  while (v26 != (unsigned char *)v28);
                  int v34 = v33;
                }
                *a4 = (unint64_t)v34;
                a4[1] = (unint64_t)v27;
                a4[2] = (unint64_t)&v33[v32];
                if (v28)
                {
                  operator delete((void *)v28);
                  unint64_t v17 = (char *)__p;
                  unint64_t v19 = v50 - (unsigned char *)__p;
                }
              }
              else
              {
                *uint64_t v26 = v16;
                unint64_t v27 = v26 + 1;
              }
              a4[1] = (unint64_t)v27;
              while (v19)
              {
                unint64_t v38 = &v17[v19 >> 1];
                unsigned int v40 = *v38;
                uint64_t v39 = v38 + 1;
                if (v44 < v40)
                {
                  v19 >>= 1;
                }
                else
                {
                  unint64_t v17 = v39;
                  v19 += ~(v19 >> 1);
                }
              }
              std::vector<Nightingale::Phase>::insert((uint64_t)&__p, v17, (char *)&v44);
              uint64_t v13 = v45;
              uint64_t v14 = v46;
            }
            ++v15;
          }
          while (v14 - v13 > v15);
          if (!v13) {
            goto LABEL_50;
          }
        }
        uint64_t v46 = v13;
        operator delete(v13);
LABEL_50:
        unint64_t v10 = v43 + 1;
        if (v41 == v43 + 1)
        {
          if (__p)
          {
            BOOL v50 = (unsigned __int8 *)__p;
            operator delete(__p);
          }
          return;
        }
      }
    }
  }
}

void sub_257D25A18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Nightingale::Phase>::insert(uint64_t a1, char *__src, char *a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = __src;
  unint64_t v6 = *(char **)(a1 + 8);
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    unint64_t v10 = *(char **)a1;
    uint64_t v11 = (uint64_t)&v6[-*(void *)a1 + 1];
    if (v11 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = __src - v10;
    unint64_t v13 = v7 - (void)v10;
    if (2 * v13 > v11) {
      uint64_t v11 = 2 * v13;
    }
    if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v14 = v11;
    }
    if (v14) {
      unint64_t v15 = (char *)operator new(v14);
    }
    else {
      unint64_t v15 = 0;
    }
    unsigned int v16 = &v15[v12];
    unint64_t v17 = &v15[v14];
    if (v12 == v14)
    {
      if (v12 < 1)
      {
        if ((unint64_t)(2 * v12) <= 1) {
          size_t v19 = 1;
        }
        else {
          size_t v19 = 2 * v12;
        }
        unint64_t v20 = (char *)operator new(v19);
        unsigned int v16 = &v20[v19 >> 2];
        unint64_t v17 = &v20[v19];
        if (v15)
        {
          operator delete(v15);
          unint64_t v10 = *(char **)a1;
        }
      }
      else
      {
        if (v12 + 1 >= 0) {
          uint64_t v18 = v12 + 1;
        }
        else {
          uint64_t v18 = v12 + 2;
        }
        v16 -= v18 >> 1;
      }
    }
    *unsigned int v16 = *v3;
    uint64_t v21 = v16;
    if (v10 != v4)
    {
      uint64_t v22 = v4;
      uint64_t v21 = v16;
      do
      {
        char v23 = *--v22;
        *--uint64_t v21 = v23;
      }
      while (v22 != v10);
    }
    unint64_t v24 = *(unsigned char **)(a1 + 8);
    uint64_t v25 = v24 - v4;
    if (v24 != v4)
    {
      memmove(v16 + 1, v4, v24 - v4);
      unint64_t v10 = *(char **)a1;
    }
    *(void *)a1 = v21;
    *(void *)(a1 + 8) = &v16[v25 + 1];
    *(void *)(a1 + 16) = v17;
    if (v10) {
      operator delete(v10);
    }
    return v16;
  }
  else if (__src == v6)
  {
    void *__src = *a3;
    *(void *)(a1 + 8) = __src + 1;
  }
  else
  {
    uint64_t v8 = __src + 1;
    if (v6)
    {
      char *v6 = *(v6 - 1);
      int v9 = v6 + 1;
    }
    else
    {
      int v9 = 0;
    }
    *(void *)(a1 + 8) = v9;
    if (v6 != v8) {
      memmove(__src + 1, __src, v6 - v8);
    }
    if (v4 <= v3 && *(void *)(a1 + 8) > (unint64_t)v3) {
      ++v3;
    }
    char *v4 = *v3;
  }
  return v4;
}

void sub_257D25C48(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::phaseFactorProcessor::suppressFWStEnd(uint64_t a1, unsigned int *a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t v8 = operator new(6uLL);
  int v9 = v8;
  _DWORD *v8 = 84148994;
  *((_WORD *)v8 + 2) = 1798;
  if (!*((unsigned char *)a2 + 4) || !*((unsigned char *)a3 + 4)) {
    goto LABEL_11;
  }
  uint64_t v10 = *a2;
  uint64_t v11 = *a3;
  unsigned int v16 = 0;
  uint64_t v17 = 0;
  __n128 __p = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&__p, v8, (uint64_t)v8 + 6, 6uLL);
  char v12 = Nightingale::phaseFactorProcessor::detectPhases(a1, v10 | (v11 << 32), (uint64_t *)&__p, a4);
  if (__p)
  {
    unsigned int v16 = __p;
    operator delete(__p);
  }
  if (v12)
  {
    if (*((unsigned char *)a2 + 4)) {
      *((unsigned char *)a2 + 4) = 0;
    }
    if (*((unsigned char *)a3 + 4)) {
      *((unsigned char *)a3 + 4) = 0;
    }
    uint64_t v13 = 1;
  }
  else
  {
LABEL_11:
    uint64_t v13 = 0;
  }
  operator delete(v9);
  return v13;
}

void sub_257D25D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  operator delete(v11);
  _Unwind_Resume(a1);
}

char *Nightingale::phaseFactorProcessor::getCCVec@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t result = (char *)operator new(3uLL);
  a1[1] = result + 3;
  a1[2] = result + 3;
  *(_WORD *)uint64_t result = 1798;
  result[2] = 5;
  *a1 = result;
  return result;
}

void *Nightingale::phaseFactorProcessor::getAllCycleVec@<X0>(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  unint64_t v3 = operator new(8uLL);
  *a1 = v3;
  void *v3 = 0x706050403020100;
  uint64_t result = v3 + 1;
  a1[1] = result;
  a1[2] = result;
  return result;
}

uint64_t Nightingale::phaseFactorProcessor::aPhase_contains_phaseTobeDetected(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v7 = a2;
  uint64_t v3 = a3[1];
  if (*a3 == v3) {
    return 0;
  }
  uint64_t v4 = *a3 + 1;
  do
  {
    uint64_t result = Nightingale::PhaseSet::contains(&v7, *(unsigned __int8 *)(v4 - 1));
    if (result) {
      break;
    }
  }
  while (v4++ != v3);
  return result;
}

unint64_t Nightingale::phaseFactorProcessor::jDayFirstStartLastEndOfAPhaseSet(uint64_t a1, void *a2, unsigned __int8 **a3)
{
  unint64_t v3 = a2[1] - *a2;
  unint64_t v4 = v3 >> 2;
  if ((v3 >> 2))
  {
    int v7 = v4 - 1;
    if ((int)v4 >= 1)
    {
      unsigned int v8 = -1;
      unsigned int v9 = v4 - 1;
      while (1)
      {
        unint64_t v10 = v9;
        uint64_t v11 = a2[3];
        if (v10 >= (a2[4] - v11) >> 3) {
          break;
        }
        uint64_t v30 = *(void *)(v11 + 8 * v10);
        char v12 = *a3;
        uint64_t v13 = a3[1];
        while (1)
        {
          if (v12 == v13) {
            goto LABEL_14;
          }
          if (Nightingale::PhaseSet::contains(&v30, *v12)) {
            break;
          }
          ++v12;
        }
        if (v10 >= (uint64_t)(a2[1] - *a2) >> 2) {
          goto LABEL_54;
        }
        unsigned int v8 = *(_DWORD *)(*a2 + 4 * v10);
        unsigned int v9 = v10 - 1;
        if ((int)v10 <= 0) {
          goto LABEL_14;
        }
      }
LABEL_52:
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    unsigned int v8 = -1;
LABEL_14:
    unint64_t v15 = a3[1];
    if (v15 == *a3)
    {
      uint64_t v18 = a3[1];
LABEL_21:
      if ((int)v4 < 2) {
        goto LABEL_39;
      }
      uint64_t v19 = (uint64_t)((v3 << 30) - 0x200000000) >> 32;
      while (v18 == v15)
      {
        uint64_t v18 = v15;
LABEL_33:
        if (v19-- <= 0) {
          goto LABEL_39;
        }
      }
      unint64_t v20 = 0;
      unint64_t v21 = v19 + 1;
      while (1)
      {
        uint64_t v22 = a2[3];
        if (v19 >= (unint64_t)((a2[4] - v22) >> 3)) {
          goto LABEL_52;
        }
        if (Nightingale::PhaseSet::contains((void *)(v22 + 8 * v19), v15[v20]))
        {
          uint64_t v23 = a2[3];
          if (v21 >= (a2[4] - v23) >> 3) {
            goto LABEL_52;
          }
          if (a3[1] - *a3 <= v20) {
LABEL_53:
          }
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          if ((Nightingale::PhaseSet::contains((void *)(v23 + 8 * v21), (*a3)[v20]) & 1) == 0) {
            break;
          }
        }
        ++v20;
        unint64_t v15 = *a3;
        uint64_t v18 = a3[1];
        if (v18 - *a3 <= v20) {
          goto LABEL_33;
        }
      }
      if (v21 >= (uint64_t)(a2[1] - *a2) >> 2) {
LABEL_54:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      uint64_t v14 = *(unsigned int *)(*a2 + 4 * v21);
      if (v14 == -1)
      {
LABEL_39:
        uint64_t v25 = *a3;
        if (a3[1] != *a3)
        {
          unint64_t v26 = 0;
          uint64_t v14 = 0xFFFFFFFFLL;
          while (1)
          {
            unint64_t v27 = (void *)a2[3];
            if ((void *)a2[4] == v27) {
              goto LABEL_52;
            }
            if (Nightingale::PhaseSet::contains(v27, v25[v26]))
            {
              uint64_t v28 = a2[3];
              if ((unint64_t)(a2[4] - v28) <= 8) {
                goto LABEL_52;
              }
              if (a3[1] - *a3 <= v26) {
                goto LABEL_53;
              }
              if ((Nightingale::PhaseSet::contains((void *)(v28 + 8), (*a3)[v26]) & 1) == 0)
              {
                if (a2[1] - *a2 <= 4uLL) {
                  goto LABEL_54;
                }
                uint64_t v14 = *(unsigned int *)(*a2 + 4);
              }
            }
            ++v26;
            uint64_t v25 = *a3;
            if (a3[1] - *a3 <= v26) {
              return v8 | (unint64_t)(v14 << 32);
            }
          }
        }
        uint64_t v14 = 0xFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v16 = 0;
      unint64_t v15 = *a3;
      while (1)
      {
        uint64_t v17 = a2[3];
        if (v7 >= (unint64_t)((a2[4] - v17) >> 3)) {
          goto LABEL_52;
        }
        if (Nightingale::PhaseSet::contains((void *)(v17 + 8 * v7), v15[v16])) {
          break;
        }
        ++v16;
        unint64_t v15 = *a3;
        uint64_t v18 = a3[1];
        if (v18 - *a3 <= v16) {
          goto LABEL_21;
        }
      }
      uint64_t v14 = 4294967294;
    }
  }
  else
  {
    uint64_t v14 = 0xFFFFFFFFLL;
    unsigned int v8 = -1;
  }
  return v8 | (unint64_t)(v14 << 32);
}

BOOL Nightingale::phaseFactorProcessor::containContraceptiveCycleFactors(uint64_t a1, unsigned __int8 **a2)
{
  unint64_t v3 = operator new(6uLL);
  *(_DWORD *)unint64_t v3 = 84148994;
  v3[2] = 1798;
  unint64_t v4 = *a2;
  unint64_t v5 = a2[1];
  if (*a2 == v5)
  {
    BOOL v8 = 0;
  }
  else
  {
    for (uint64_t i = 0; i != 6; ++i)
    {
      int v7 = v4;
      while (*v7 != *((unsigned __int8 *)v3 + i))
      {
        if (++v7 == v5)
        {
          int v7 = v5;
          break;
        }
      }
      BOOL v8 = v7 != v5;
      if (v7 != v5) {
        break;
      }
    }
  }
  operator delete(v3);
  return v8;
}

BOOL Nightingale::phaseFactorProcessor::vPhasesContainsAPhase(uint64_t a1, unsigned __int8 **a2, int a3)
{
  unint64_t v4 = *a2;
  unint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    while (*v4 != a3)
    {
      if (++v4 == v3)
      {
        unint64_t v4 = a2[1];
        return v4 != v3;
      }
    }
  }
  return v4 != v3;
}

BOOL Nightingale::phaseFactorProcessor::vPhasesContainsVPhases(uint64_t a1, unsigned __int8 **a2, unsigned __int8 **a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  if (*a2 == v4) {
    return 0;
  }
  unint64_t v5 = a3[1];
  do
  {
    if (*a3 == v5)
    {
      unint64_t v6 = *a3;
    }
    else
    {
      unint64_t v6 = *a3;
      while (*v6 != *v3)
      {
        if (++v6 == v5)
        {
          unint64_t v6 = a3[1];
          break;
        }
      }
    }
    BOOL result = v6 != v5;
    if (v6 != v5) {
      break;
    }
    ++v3;
  }
  while (v3 != v4);
  return result;
}

void *std::vector<Nightingale::PhaseSet>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::PhaseSet*>,std::__wrap_iter<Nightingale::PhaseSet*>>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    BOOL result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      BOOL result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_257D262D0(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100]<std::vector<int>&,std::vector<Nightingale::PhaseSet>&,0>(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<Nightingale::PhaseSet>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::PhaseSet*>,std::__wrap_iter<Nightingale::PhaseSet*>>(a1 + 3, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
  return a1;
}

void sub_257D2634C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngtProjector::ngtProjector(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 92) = 0;
  *(void *)(a1 + 96) = a4;
  *(void *)(a1 + 104) = a5;
  *(void *)(a1 + 112) = a3;
  *(void *)(a1 + 120) = a2;
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 148) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  Nightingale::coreAnalyticsDayStream_t::coreAnalyticsDayStream_t((Nightingale::coreAnalyticsDayStream_t *)(a1 + 320));
  *(unsigned char *)(a1 + 560) = 0;
  *(unsigned char *)(a1 + 592) = 0;
  *(unsigned char *)(a1 + 600) = 0;
  *(unsigned char *)(a1 + 632) = 0;
  *(_OWORD *)(a1 + 640) = xmmword_257D5F6E0;
  *(unsigned char *)(a1 + 664) = 0;
  *(unsigned char *)(a1 + 696) = 0;
  *(unsigned char *)(a1 + 704) = 0;
  *(unsigned char *)(a1 + 736) = 0;
  *(_OWORD *)(a1 + 744) = xmmword_257D5F6E0;
  *(unsigned char *)(a1 + 760) = 0;
  *(unsigned char *)(a1 + 764) = 0;
  return a1;
}

void Nightingale::ngtProjector::~ngtProjector(Nightingale::ngtProjector *this)
{
}

{
  Nightingale::structDLIn_hr::~structDLIn_hr((Nightingale::ngtProjector *)((char *)this + 128));
}

void Nightingale::ngtProjector::projector(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t a4, int a5, uint64_t a6)
{
  Nightingale::periodEstimatorAggregation::periodEstimatorAggregation((Nightingale::periodEstimatorAggregation *)v98);
  Nightingale::periodEstimatorCalendarWithEnd::periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)v97, *(const Nightingale::ngt_Config **)(a1 + 112));
  uint64_t v11 = *(void *)(a1 + 96);
  uint64_t v12 = *(void *)(v11 + 8);
  int v15 = *(_DWORD *)(v12 - 96);
  uint64_t v13 = v12 - 96;
  int v14 = v15;
  if (*(unsigned char *)(v11 + 128))
  {
    Nightingale::ngtProjector::get1stPeriodProjInPeriodNow((Nightingale::periodEstimatorCalendar *)v97, v13, (uint64_t)v69);
    LOBYTE(v92) = 0;
    char v96 = 0;
    Nightingale::ngtProjector::periodEstimationOutStruct2NgtPrediction(a1, (uint64_t)v69, (uint64_t)__p, (uint64_t)&v92, v14, (uint64_t)v87);
    unint64_t v16 = a2[2];
    unint64_t v17 = a2[1];
    if (v17 >= v16)
    {
      uint64_t v19 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v17 - *a2) >> 3);
      unint64_t v20 = v19 + 1;
      if ((unint64_t)(v19 + 1) > 0x276276276276276) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v21 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v16 - *a2) >> 3);
      if (2 * v21 > v20) {
        unint64_t v20 = 2 * v21;
      }
      if (v21 >= 0x13B13B13B13B13BLL) {
        unint64_t v22 = 0x276276276276276;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22) {
        uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>((uint64_t)(a2 + 2), v22);
      }
      else {
        uint64_t v23 = 0;
      }
      unint64_t v24 = &v23[104 * v19];
      uint64_t v25 = &v23[104 * v22];
      *(_OWORD *)unint64_t v24 = v87[0];
      *((_OWORD *)v24 + 1) = v87[1];
      *((_OWORD *)v24 + 2) = v87[2];
      *((void *)v24 + 12) = v91;
      *((_OWORD *)v24 + 5) = v90;
      *((_OWORD *)v24 + 4) = v89;
      *((_OWORD *)v24 + 3) = v88;
      uint64_t v18 = (uint64_t)(v24 + 104);
      unint64_t v27 = (char *)*a2;
      unint64_t v26 = (char *)a2[1];
      if (v26 != (char *)*a2)
      {
        do
        {
          long long v28 = *(_OWORD *)(v26 - 104);
          long long v29 = *(_OWORD *)(v26 - 88);
          *(_OWORD *)(v24 - 72) = *(_OWORD *)(v26 - 72);
          *(_OWORD *)(v24 - 88) = v29;
          *(_OWORD *)(v24 - 104) = v28;
          long long v30 = *(_OWORD *)(v26 - 56);
          long long v31 = *(_OWORD *)(v26 - 40);
          long long v32 = *(_OWORD *)(v26 - 24);
          *((void *)v24 - 1) = *((void *)v26 - 1);
          *(_OWORD *)(v24 - 24) = v32;
          *(_OWORD *)(v24 - 40) = v31;
          *(_OWORD *)(v24 - 56) = v30;
          v24 -= 104;
          v26 -= 104;
        }
        while (v26 != v27);
        unint64_t v26 = (char *)*a2;
      }
      *a2 = (uint64_t)v24;
      a2[1] = v18;
      a2[2] = (uint64_t)v25;
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      *(_OWORD *)(v17 + 48) = v88;
      *(_OWORD *)(v17 + 64) = v89;
      *(_OWORD *)(v17 + 80) = v90;
      *(void *)(v17 + 96) = v91;
      *(_OWORD *)unint64_t v17 = v87[0];
      *(_OWORD *)(v17 + 16) = v87[1];
      *(_OWORD *)(v17 + 32) = v87[2];
      uint64_t v18 = v17 + 104;
    }
    a2[1] = v18;
    if (v96 && (void)v92)
    {
      *((void *)&v92 + 1) = v92;
      operator delete((void *)v92);
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v69[0])
    {
      v69[1] = v69[0];
      operator delete(v69[0]);
    }
  }
  Nightingale::ngtProjector::get1stFwCompletePeriodProj((Nightingale::ngtProjector *)a1, a5, (uint64_t)v69);
  long long v33 = v85;
  *(_OWORD *)(a1 + 32) = v84;
  *(_OWORD *)(a1 + 48) = v33;
  *(_OWORD *)(a1 + 64) = v86[0];
  long long v34 = v83;
  *(_OWORD *)a1 = v82;
  *(_OWORD *)(a1 + 16) = v34;
  *(_OWORD *)(a1 + 77) = *(_OWORD *)((char *)v86 + 13);
  uint64_t vGrad_empty = Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)v77);
  if (vGrad_empty)
  {
    a2[1] = *a2;
    if (v75)
    {
      unsigned int v36 = v76;
      if (v76 <= 1)
      {
        int v37 = v74 - v14;
        int v38 = v74 - v14 - 5;
        if (v74 - v14 >= 5)
        {
          int v39 = v14 - LODWORD(v69[0]);
          if (!BYTE4(v69[0])) {
            int v39 = 0;
          }
          double v40 = (double)v38;
          double v41 = (double)v37;
          if (BYTE4(v69[0])) {
            BOOL v42 = v76 == 0;
          }
          else {
            BOOL v42 = 1;
          }
          int v43 = v39 + v37;
          if (v42) {
            int v44 = 0;
          }
          else {
            int v44 = v43;
          }
          uint64_t vGrad_empty = (uint64_t)(a3 + 2);
          unint64_t v45 = a3[2];
          unint64_t v46 = a3[1];
          if (v46 >= v45)
          {
            uint64_t v49 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v46 - *a3) >> 3);
            unint64_t v50 = v49 + 1;
            if ((unint64_t)(v49 + 1) > 0x276276276276276) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v51 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v45 - *a3) >> 3);
            if (2 * v51 > v50) {
              unint64_t v50 = 2 * v51;
            }
            if (v51 >= 0x13B13B13B13B13BLL) {
              unint64_t v52 = 0x276276276276276;
            }
            else {
              unint64_t v52 = v50;
            }
            if (v52) {
              unint64_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(vGrad_empty, v52);
            }
            else {
              unint64_t v53 = 0;
            }
            uint64_t v54 = (double *)&v53[104 * v49];
            *(_DWORD *)uint64_t v54 = v14;
            v54[1] = v40;
            v54[2] = 0.0;
            long long v55 = &v53[104 * v52];
            v54[3] = v40;
            v54[4] = v40;
            *((unsigned char *)v54 + 40) = 1;
            v54[6] = v41;
            v54[7] = 0.0;
            v54[8] = v41;
            v54[9] = v41;
            *((unsigned char *)v54 + 80) = 1;
            *((_DWORD *)v54 + 22) = v38;
            *((_DWORD *)v54 + 23) = 6;
            *((_DWORD *)v54 + 24) = v44;
            *((_DWORD *)v54 + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v36;
            uint64_t v47 = (uint64_t)(v54 + 13);
            uint64_t v56 = *a3;
            uint64_t vGrad_empty = a3[1];
            if (vGrad_empty != *a3)
            {
              do
              {
                long long v57 = *(_OWORD *)(vGrad_empty - 104);
                long long v58 = *(_OWORD *)(vGrad_empty - 88);
                *(_OWORD *)(v54 - 9) = *(_OWORD *)(vGrad_empty - 72);
                *(_OWORD *)(v54 - 11) = v58;
                *(_OWORD *)(v54 - 13) = v57;
                long long v59 = *(_OWORD *)(vGrad_empty - 56);
                long long v60 = *(_OWORD *)(vGrad_empty - 40);
                long long v61 = *(_OWORD *)(vGrad_empty - 24);
                *(v54 - 1) = *(double *)(vGrad_empty - 8);
                *(_OWORD *)(v54 - 3) = v61;
                *(_OWORD *)(v54 - 5) = v60;
                *(_OWORD *)(v54 - 7) = v59;
                v54 -= 13;
                vGrad_empty -= 104;
              }
              while (vGrad_empty != v56);
              uint64_t vGrad_empty = *a3;
            }
            *a3 = (uint64_t)v54;
            a3[1] = v47;
            a3[2] = (uint64_t)v55;
            if (vGrad_empty) {
              operator delete((void *)vGrad_empty);
            }
          }
          else
          {
            *(_DWORD *)unint64_t v46 = v14;
            *(double *)(v46 + 8) = v40;
            *(void *)(v46 + 16) = 0;
            *(double *)(v46 + 24) = v40;
            *(double *)(v46 + 32) = v40;
            *(unsigned char *)(v46 + 40) = 1;
            *(double *)(v46 + 48) = v41;
            *(void *)(v46 + 56) = 0;
            *(double *)(v46 + 64) = v41;
            *(double *)(v46 + 72) = v41;
            *(unsigned char *)(v46 + 80) = 1;
            *(_DWORD *)(v46 + 88) = v38;
            *(_DWORD *)(v46 + 92) = 6;
            uint64_t v47 = v46 + 104;
            *(_DWORD *)(v46 + 96) = v44;
            *(_DWORD *)(v46 + 100) = v36;
          }
          a3[1] = v47;
        }
      }
    }
  }
  else
  {
    if (*(unsigned char *)(*(void *)(a1 + 96) + 128)) {
      int v48 = 4;
    }
    else {
      int v48 = 5;
    }
    memset(v87, 0, sizeof(v87));
    if (!Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)v77))
    {
      Nightingale::ngtProjector::getDerivedPeriodProjs((Nightingale::ngtProjector *)a1, (Nightingale::firstFwPeriodStartOutStruct *)v69, v48, (uint64_t)&v92);
      std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vdeallocate((void **)v87);
      v87[0] = v92;
      *(void *)&v87[1] = v93;
      uint64_t v93 = 0;
      long long v92 = 0uLL;
      std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vdeallocate((void **)&v87[1] + 1);
      *(_OWORD *)((char *)&v87[1] + 8) = v94;
      *((void *)&v87[2] + 1) = v95;
      uint64_t v95 = 0;
      long long v94 = 0uLL;
      v68[0] = &v94;
      std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)v68);
      v68[0] = &v92;
      std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)v68);
      Nightingale::ngtProjector::constructSurfacedPeriodProjs((Nightingale::ngtProjector *)a1, (Nightingale::firstFwPeriodStartOutStruct *)v69, (Nightingale::derivedPeriodProjsStruct *)v87, v14, (void **)&v92);
      std::vector<Nightingale::ngt_Prediction>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_Prediction*>,std::__wrap_iter<Nightingale::ngt_Prediction*>>((uint64_t)a2, a2[1], (char *)v92, *((char **)&v92 + 1), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)&v92 + 1) - v92) >> 3));
      if ((void)v92)
      {
        *((void *)&v92 + 1) = v92;
        operator delete((void *)v92);
      }
    }
    Nightingale::ngtProjector::getDerivedFwProjs((Nightingale::CGradient *)v77, (uint64_t *)&v87[1] + 1, (char **)&v92);
    Nightingale::ngtProjector::getDerivedFwProjs((Nightingale::CGradient *)v70, (uint64_t *)v87, (char **)v68);
    Nightingale::ngtProjector::constructSurfacedFwProjs((int *)v69, (uint64_t **)&v92, v68, v14, &v66);
    std::vector<Nightingale::ngt_Prediction>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_Prediction*>,std::__wrap_iter<Nightingale::ngt_Prediction*>>((uint64_t)a3, a3[1], (char *)v66, v67, 0x4EC4EC4EC4EC4EC5 * ((v67 - (unsigned char *)v66) >> 3));
    if (v66)
    {
      int v67 = (char *)v66;
      operator delete(v66);
    }
    if (v68[0])
    {
      v68[1] = v68[0];
      operator delete(v68[0]);
    }
    if ((void)v92)
    {
      *((void *)&v92 + 1) = v92;
      operator delete((void *)v92);
    }
    *(void *)&long long v92 = (char *)&v87[1] + 8;
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v92);
    *(void *)&long long v92 = v87;
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v92);
  }
  Nightingale::ngtProjector::shrinkLowRangeToRmOverlapFW(vGrad_empty, a2, a3, *(unsigned __int8 *)(*(void *)(a1 + 96) + 128));
  Nightingale::ngtProjector::reproductiveInfiniteHandlingPeriod(a1, a2, *(uint64_t **)(a1 + 104), (void **)v87);
  char v62 = (void *)*a2;
  if (*a2)
  {
    a2[1] = (uint64_t)v62;
    operator delete(v62);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  *(_OWORD *)a2 = v87[0];
  a2[2] = *(void *)&v87[1];
  Nightingale::ngtProjector::reproductiveInfiniteHandlingFw(a1, a3, *(uint64_t **)(a1 + 104), (uint64_t)v70, (void **)v87);
  uint64_t v65 = (void *)*a3;
  if (*a3)
  {
    a3[1] = (uint64_t)v65;
    operator delete(v65);
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  *(_OWORD *)a3 = v87[0];
  a3[2] = *(void *)&v87[1];
  if (a5)
  {
    Nightingale::ngtProjector::getCaContent(a1, (uint64_t)v69, v63, v64, a6);
    if (*a3 == a3[1]) {
      *(_DWORD *)(a6 + 224) = 4;
    }
    if (*a2 == a2[1]) {
      *(_DWORD *)(a6 + 124) = 5;
    }
  }
  if (v80)
  {
    long long v81 = v80;
    operator delete(v80);
  }
  if (v78)
  {
    int v79 = v78;
    operator delete(v78);
  }
  if (v77[0])
  {
    v77[1] = v77[0];
    operator delete(v77[0]);
  }
  if (v72)
  {
    uint64_t v73 = v72;
    operator delete(v72);
  }
  if (v70[0])
  {
    v70[1] = v70[0];
    operator delete(v70[0]);
  }
  Nightingale::periodEstimatorCalendarWithEnd::~periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)v97);
  Nightingale::periodEstimatorAggregation::~periodEstimatorAggregation((Nightingale::periodEstimatorAggregation *)v98);
}

void sub_257D26C2C(_Unwind_Exception *a1, void *__p, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  Nightingale::firstFwPeriodStartOutStruct::~firstFwPeriodStartOutStruct((Nightingale::firstFwPeriodStartOutStruct *)va);
  Nightingale::periodEstimatorCalendarWithEnd::~periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)(v7 - 152));
  Nightingale::periodEstimatorAggregation::~periodEstimatorAggregation((Nightingale::periodEstimatorAggregation *)(v7 - 113));
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::get1stPeriodProjInPeriodNow(Nightingale::periodEstimatorCalendar *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100]<true,0>((uint64_t)v21);
  if (*(unsigned char *)(a2 + 60)) {
    BOOL v6 = *(unsigned char *)(a2 + 52) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    *(_OWORD *)a3 = *(_OWORD *)v21;
    *(void *)(a3 + 16) = v22;
    v21[0] = 0;
    v21[1] = 0;
    *(_OWORD *)(a3 + 24) = v23[0];
    *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v23 + 9);
    *(_OWORD *)(a3 + 56) = *(_OWORD *)v24;
    *(void *)(a3 + 69) = *(void *)&v24[13];
    *(_OWORD *)(a3 + 80) = *(_OWORD *)v25;
    *(void *)(a3 + 96) = v26;
    v25[1] = 0;
    uint64_t v26 = 0;
    uint64_t v22 = 0;
    v25[0] = 0;
    long long v7 = v27[0];
    *(_OWORD *)(a3 + 113) = *(_OWORD *)((char *)v27 + 9);
    *(_OWORD *)(a3 + 104) = v7;
    long long v8 = *(_OWORD *)v28;
    *(void *)(a3 + 149) = *(void *)&v28[13];
    *(_OWORD *)(a3 + 136) = v8;
  }
  else
  {
    Nightingale::CGradient::CGradient((uint64_t)__p);
    char v15 = 0;
    char v16 = 0;
    char v17 = 0;
    char v18 = 0;
    char v19 = 0;
    char v20 = 0;
    Nightingale::periodEstimatorCalendar::getPeriodStartGradient(a1, 0.0, 0.0, (uint64_t)v9);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    *(_OWORD *)__n128 __p = *(_OWORD *)v9;
    uint64_t v13 = v10;
    v14[0] = v11[0];
    *(_OWORD *)((char *)v14 + 9) = *(_OWORD *)((char *)v11 + 9);
    Nightingale::periodEstimatorCalendarWithEnd::getPeriodEndProjection(a2, (Nightingale::CGradient *)__p, (uint64_t)v9);
    std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100]<Nightingale::periodEstimationOutStruct&,Nightingale::periodEstimationOutStruct&,0>(a3, (uint64_t)__p, (uint64_t)v9);
    if (v9[0])
    {
      v9[1] = v9[0];
      operator delete(v9[0]);
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v25[0])
    {
      v25[1] = v25[0];
      operator delete(v25[0]);
    }
  }
  if (v21[0])
  {
    v21[1] = v21[0];
    operator delete(v21[0]);
  }
}

void sub_257D26E8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (a19) {
    operator delete(a19);
  }
  std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::~pair((uint64_t)&a29);
  _Unwind_Resume(a1);
}

float Nightingale::ngtProjector::periodEstimationOutStruct2NgtPrediction@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, uint64_t a6@<X8>)
{
  *(unsigned char *)(a6 + 8) = 0;
  *(unsigned char *)(a6 + 40) = 0;
  *(unsigned char *)(a6 + 48) = 0;
  *(unsigned char *)(a6 + 80) = 0;
  *(_OWORD *)(a6 + 88) = xmmword_257D5F6E0;
  *(_DWORD *)a6 = a5;
  *(double *)(a6 + 8) = Nightingale::ngtProjector::getAMetricFromperiodEstimationOut(a1, (Nightingale::CGradient *)a2);
  *(void *)(a6 + 16) = v11;
  *(void *)(a6 + 24) = v12;
  *(void *)(a6 + 32) = v13;
  *(unsigned char *)(a6 + 40) = 1;
  double AMetricFromperiodEstimationOut = Nightingale::ngtProjector::getAMetricFromperiodEstimationOut(a1, (Nightingale::CGradient *)a3);
  *(double *)(a6 + 48) = AMetricFromperiodEstimationOut;
  *(void *)(a6 + 56) = v15;
  *(void *)(a6 + 64) = v16;
  *(void *)(a6 + 72) = v17;
  *(unsigned char *)(a6 + 80) = 1;
  if (*(unsigned char *)(a2 + 60))
  {
    LODWORD(AMetricFromperiodEstimationOut) = *(_DWORD *)(a2 + 56);
    int v18 = llroundf(*(float *)&AMetricFromperiodEstimationOut);
    *(_DWORD *)(a6 + 88) = v18;
    if (*(unsigned char *)(a3 + 68))
    {
      *(float *)&double AMetricFromperiodEstimationOut = (float)(*(float *)(a3 + 64) - *(float *)&AMetricFromperiodEstimationOut)
                                                + 1.0;
      *(_DWORD *)(a6 + 92) = llroundf(*(float *)&AMetricFromperiodEstimationOut);
    }
  }
  else
  {
    int v18 = 0;
  }
  if (*(unsigned char *)(a4 + 80))
  {
    Nightingale::ngtProjector::computeLowRangeMeanStd(a1, (Nightingale::CGradient *)a4);
    if (!*(unsigned char *)(a4 + 80)) {
      goto LABEL_12;
    }
    if (Nightingale::CGradient::get_isNull((Nightingale::CGradient *)a4)) {
      return *(float *)&AMetricFromperiodEstimationOut;
    }
    if (!*(unsigned char *)(a4 + 80)) {
LABEL_12:
    }
      std::__throw_bad_optional_access[abi:ne180100]();
    if (*(unsigned char *)(a4 + 60))
    {
      *(float *)&double AMetricFromperiodEstimationOut = (float)v18 - roundf(*(float *)(a4 + 56));
      *(_DWORD *)(a6 + 96) = (int)*(float *)&AMetricFromperiodEstimationOut;
    }
  }
  return *(float *)&AMetricFromperiodEstimationOut;
}

uint64_t std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 88) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
  return a1;
}

double Nightingale::ngtProjector::get1stFwCompletePeriodProj@<D0>(Nightingale::ngtProjector *this@<X0>, int a2@<W2>, uint64_t a3@<X8>)
{
  Nightingale::ngtProjector::compute1stFWPeriodStart(this, a2, a3);
  if (!Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)(a3 + 200)))
  {
    Nightingale::periodEstimatorCalendarWithEnd::getPeriodEndProjection(*(void *)(*((void *)this + 12) + 8) - 96, (Nightingale::CGradient *)(a3 + 200), (uint64_t)&v10);
    long long v8 = (void *)(a3 + 280);
    unsigned int v9 = *(void **)(a3 + 280);
    if (v9)
    {
      *(void *)(a3 + 288) = v9;
      operator delete(v9);
      void *v8 = 0;
      *(void *)(a3 + 288) = 0;
      *(void *)(a3 + 296) = 0;
    }
    *(_OWORD *)long long v8 = v10;
    *(void *)(a3 + 296) = v11;
    *(_OWORD *)(a3 + 304) = v12[0];
    *(_OWORD *)(a3 + 313) = *(_OWORD *)((char *)v12 + 9);
    double result = v13[0];
    *(_OWORD *)(a3 + 336) = *(_OWORD *)v13;
    *(double *)(a3 + 349) = *(double *)((char *)&v13[1] + 5);
  }
  return result;
}

void sub_257D270F0(_Unwind_Exception *a1)
{
  Nightingale::firstFwPeriodStartOutStruct::~firstFwPeriodStartOutStruct(v1);
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::getDerivedPeriodProjs(Nightingale::ngtProjector *this@<X0>, Nightingale::firstFwPeriodStartOutStruct *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  int v9 = *((_DWORD *)a2 + 90);
  if (v9 == 3) {
    int adjusted = Nightingale::CGradient::get_adjusted((Nightingale::firstFwPeriodStartOutStruct *)((char *)a2 + 200));
  }
  else {
    int adjusted = 0;
  }
  BOOL v11 = (v9 - 1) < 2;
  if ((v9 - 1) < 2) {
    int v12 = 1;
  }
  else {
    int v12 = adjusted;
  }
  Nightingale::periodEstimatorAggregation::deriveRestPeriodProjs(*((Nightingale::ngt_Config **)this + 14), (uint64_t)a2 + 200, *((void *)this + 12), a3, 2, v12, v11, &v18);
  if ((uint64_t *)(a4 + 24) != &v18) {
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__assign_with_size[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(a4 + 24, v18, v19, 0xCCCCCCCCCCCCCCCDLL * ((v19 - v18) >> 5));
  }
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  if (*((_DWORD *)a2 + 90) == 3)
  {
    if (&v18 != (uint64_t *)a4)
    {
      uint64_t v13 = &v18;
LABEL_13:
      std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__assign_with_size[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(a4, *v13, v13[1], 0xCCCCCCCCCCCCCCCDLL * ((v13[1] - *v13) >> 5));
    }
  }
  else
  {
    Nightingale::periodEstimatorAggregation::deriveRestPeriodProjs(*((Nightingale::ngt_Config **)this + 14), (uint64_t)a2 + 16, *((void *)this + 12), a3, 2, v12, 0, (uint64_t *)&v14);
    uint64_t v13 = (uint64_t *)&v16;
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vdeallocate((void **)&v16);
    long long v16 = v14;
    uint64_t v17 = v15;
    uint64_t v15 = 0;
    long long v14 = 0uLL;
    char v20 = (void **)&v14;
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100](&v20);
    if (&v16 != (long long *)a4) {
      goto LABEL_13;
    }
  }
  *(void *)&long long v14 = &v16;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v14);
  *(void *)&long long v16 = &v18;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v16);
}

void sub_257D272AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void ***a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  a9 = &a13;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  a13 = (void **)&a17;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100](&a13);
  Nightingale::derivedPeriodProjsStruct::~derivedPeriodProjsStruct(v17);
  _Unwind_Resume(a1);
}

void Nightingale::derivedPeriodProjsStruct::~derivedPeriodProjsStruct(void **this)
{
  uint64_t v2 = this + 3;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100](&v2);
  uint64_t v2 = this;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void Nightingale::ngtProjector::constructSurfacedPeriodProjs(Nightingale::ngtProjector *this@<X0>, Nightingale::firstFwPeriodStartOutStruct *a2@<X1>, Nightingale::derivedPeriodProjsStruct *a3@<X2>, int a4@<W3>, void **a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  LOBYTE(v84) = 0;
  long long v10 = (char *)a2 + 16;
  char v86 = 0;
  std::optional<Nightingale::periodEstimationOutStruct>::operator=[abi:ne180100]<Nightingale::periodEstimationOutStruct&,void>((uint64_t)&v84, (uint64_t)a2 + 16);
  uint64_t v11 = *((void *)this + 12);
  uint64_t v12 = *(void *)(v11 + 96);
  if ((v12 & 0xFF00000000) != 0)
  {
    *((_DWORD *)this + 190) = v12 - *(_DWORD *)(*(void *)(v11 + 8) - 96);
    *((unsigned char *)this + 764) = 1;
  }
  Nightingale::ngtProjector::periodEstimationOutStruct2NgtPrediction((uint64_t)this, (uint64_t)a2 + 200, (uint64_t)a2 + 280, (uint64_t)&v84, a4, (uint64_t)&v77);
  HIDWORD(v83) = *((_DWORD *)a2 + 90);
  uint64_t v13 = (char *)a5[2];
  uint64_t v69 = (uint64_t)(a5 + 2);
  long long v14 = (char *)a5[1];
  if (v14 >= v13)
  {
    uint64_t v19 = (char *)*a5;
    uint64_t v20 = 0x4EC4EC4EC4EC4EC5 * ((v14 - (unsigned char *)*a5) >> 3);
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) > 0x276276276276276) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v22 = 0x4EC4EC4EC4EC4EC5 * ((v13 - v19) >> 3);
    if (2 * v22 > v21) {
      unint64_t v21 = 2 * v22;
    }
    if (v22 >= 0x13B13B13B13B13BLL) {
      unint64_t v23 = 0x276276276276276;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      unint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(v69, v23);
      uint64_t v19 = (char *)*a5;
      long long v14 = (char *)a5[1];
    }
    else
    {
      unint64_t v24 = 0;
    }
    long long v25 = v82;
    uint64_t v26 = &v24[104 * v20];
    *((_OWORD *)v26 + 4) = v81;
    *((_OWORD *)v26 + 5) = v25;
    unint64_t v27 = &v24[104 * v23];
    *((void *)v26 + 12) = v83;
    long long v28 = v78;
    *(_OWORD *)uint64_t v26 = v77;
    *((_OWORD *)v26 + 1) = v28;
    long long v29 = v80;
    *((_OWORD *)v26 + 2) = v79;
    *((_OWORD *)v26 + 3) = v29;
    uint64_t v18 = v26 + 104;
    if (v14 == v19)
    {
      int v35 = v26;
    }
    else
    {
      do
      {
        long long v30 = *(_OWORD *)(v14 - 104);
        long long v31 = *(_OWORD *)(v14 - 88);
        *(_OWORD *)(v26 - 72) = *(_OWORD *)(v14 - 72);
        *(_OWORD *)(v26 - 88) = v31;
        *(_OWORD *)(v26 - 104) = v30;
        long long v32 = *(_OWORD *)(v14 - 56);
        long long v33 = *(_OWORD *)(v14 - 40);
        long long v34 = *(_OWORD *)(v14 - 24);
        int v35 = v26 - 104;
        *((void *)v26 - 1) = *((void *)v14 - 1);
        *(_OWORD *)(v26 - 24) = v34;
        *(_OWORD *)(v26 - 40) = v33;
        *(_OWORD *)(v26 - 56) = v32;
        v14 -= 104;
        v26 -= 104;
      }
      while (v14 != v19);
    }
    *a5 = v35;
    a5[1] = v18;
    a5[2] = v27;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    long long v15 = v82;
    *((_OWORD *)v14 + 4) = v81;
    *((_OWORD *)v14 + 5) = v15;
    *((void *)v14 + 12) = v83;
    long long v16 = v78;
    *(_OWORD *)long long v14 = v77;
    *((_OWORD *)v14 + 1) = v16;
    long long v17 = v80;
    uint64_t v18 = v14 + 104;
    *((_OWORD *)v14 + 2) = v79;
    *((_OWORD *)v14 + 3) = v17;
  }
  a5[1] = v18;
  *((void *)this + 81) = v83;
  long long v36 = v82;
  *(_OWORD *)((char *)this + 616) = v81;
  *(_OWORD *)((char *)this + 632) = v36;
  long long v37 = v78;
  *(_OWORD *)((char *)this + 552) = v77;
  *(_OWORD *)((char *)this + 568) = v37;
  long long v38 = v80;
  *(_OWORD *)((char *)this + 584) = v79;
  *(_OWORD *)((char *)this + 600) = v38;
  Nightingale::ngtProjector::periodEstimationOutStruct2NgtPrediction((uint64_t)this, (uint64_t)v10, (uint64_t)a2 + 96, (uint64_t)&v84, a4, (uint64_t)&v70);
  long long v39 = v75;
  *((_OWORD *)this + 45) = v74;
  *((_OWORD *)this + 46) = v39;
  *((void *)this + 94) = v76;
  long long v40 = v71;
  *((_OWORD *)this + 41) = v70;
  *((_OWORD *)this + 42) = v40;
  long long v41 = v73;
  *((_OWORD *)this + 43) = v72;
  *((_OWORD *)this + 44) = v41;
  if (*((unsigned char *)this + 764)) {
    *((unsigned char *)this + 764) = 0;
  }
  uint64_t v42 = *((void *)a3 + 3);
  uint64_t v43 = *((void *)a3 + 4);
  if (v42 != v43)
  {
    unsigned __int8 v44 = 0;
    do
    {
      unsigned __int8 v45 = v44;
      if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)a3 + 1) - *(void *)a3) >> 5) <= v44)
      {
        if (v86)
        {
          if (v84)
          {
            long long v85 = v84;
            operator delete(v84);
          }
          char v86 = 0;
        }
      }
      else
      {
        std::optional<Nightingale::periodEstimationOutStruct>::operator=[abi:ne180100]<Nightingale::periodEstimationOutStruct&,void>((uint64_t)&v84, *(void *)a3 + 160 * v44);
      }
      Nightingale::ngtProjector::periodEstimationOutStruct2NgtPrediction((uint64_t)this, v42, v42 + 80, (uint64_t)&v84, a4, (uint64_t)&v70);
      uint64_t v83 = v76;
      long long v81 = v74;
      long long v82 = v75;
      long long v77 = v70;
      long long v78 = v71;
      long long v79 = v72;
      long long v80 = v73;
      HIDWORD(v83) = *((_DWORD *)a2 + 90);
      uint64_t v47 = (char *)a5[1];
      unint64_t v46 = (char *)a5[2];
      if (v47 >= v46)
      {
        unint64_t v52 = (char *)*a5;
        uint64_t v53 = 0x4EC4EC4EC4EC4EC5 * ((v47 - (unsigned char *)*a5) >> 3);
        unint64_t v54 = v53 + 1;
        if ((unint64_t)(v53 + 1) > 0x276276276276276) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v55 = 0x4EC4EC4EC4EC4EC5 * ((v46 - v52) >> 3);
        if (2 * v55 > v54) {
          unint64_t v54 = 2 * v55;
        }
        if (v55 >= 0x13B13B13B13B13BLL) {
          unint64_t v56 = 0x276276276276276;
        }
        else {
          unint64_t v56 = v54;
        }
        if (v56)
        {
          long long v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(v69, v56);
          unint64_t v52 = (char *)*a5;
          uint64_t v47 = (char *)a5[1];
        }
        else
        {
          long long v57 = 0;
        }
        long long v58 = v82;
        long long v59 = &v57[104 * v53];
        *((_OWORD *)v59 + 4) = v81;
        *((_OWORD *)v59 + 5) = v58;
        *((void *)v59 + 12) = v83;
        long long v60 = v78;
        *(_OWORD *)long long v59 = v77;
        *((_OWORD *)v59 + 1) = v60;
        long long v61 = v80;
        *((_OWORD *)v59 + 2) = v79;
        *((_OWORD *)v59 + 3) = v61;
        if (v47 == v52)
        {
          BOOL v68 = &v57[104 * v53];
        }
        else
        {
          char v62 = &v57[104 * v53];
          do
          {
            long long v63 = *(_OWORD *)(v47 - 104);
            long long v64 = *(_OWORD *)(v47 - 88);
            *(_OWORD *)(v62 - 72) = *(_OWORD *)(v47 - 72);
            *(_OWORD *)(v62 - 88) = v64;
            *(_OWORD *)(v62 - 104) = v63;
            long long v65 = *(_OWORD *)(v47 - 56);
            long long v66 = *(_OWORD *)(v47 - 40);
            long long v67 = *(_OWORD *)(v47 - 24);
            BOOL v68 = v62 - 104;
            *((void *)v62 - 1) = *((void *)v47 - 1);
            *(_OWORD *)(v62 - 24) = v67;
            *(_OWORD *)(v62 - 40) = v66;
            *(_OWORD *)(v62 - 56) = v65;
            v47 -= 104;
            v62 -= 104;
          }
          while (v47 != v52);
        }
        unint64_t v51 = v59 + 104;
        *a5 = v68;
        a5[1] = v59 + 104;
        a5[2] = &v57[104 * v56];
        if (v52) {
          operator delete(v52);
        }
      }
      else
      {
        long long v48 = v82;
        *((_OWORD *)v47 + 4) = v81;
        *((_OWORD *)v47 + 5) = v48;
        *((void *)v47 + 12) = v83;
        long long v49 = v78;
        *(_OWORD *)uint64_t v47 = v77;
        *((_OWORD *)v47 + 1) = v49;
        long long v50 = v80;
        unint64_t v51 = v47 + 104;
        *((_OWORD *)v47 + 2) = v79;
        *((_OWORD *)v47 + 3) = v50;
      }
      a5[1] = v51;
      unsigned __int8 v44 = v45 + 1;
      v42 += 160;
    }
    while (v42 != v43);
  }
  if (v86)
  {
    if (v84)
    {
      long long v85 = v84;
      operator delete(v84);
    }
  }
}

void sub_257D27848(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v2 - 104))
  {
    unint64_t v4 = *(void **)(v2 - 184);
    if (v4)
    {
      *(void *)(v2 - 176) = v4;
      operator delete(v4);
    }
  }
  unint64_t v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngtProjector::getDerivedFwProjs(Nightingale::CGradient *this@<X2>, uint64_t *a2@<X1>, char **a3@<X8>)
{
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (*((unsigned char *)this + 76))
  {
    float v6 = *((float *)this + 18);
  }
  else
  {
    uint64_t v7 = *(void *)((char *)this + 36);
    if ((v7 & 0xFF00000000) != 0)
    {
      LODWORD(v6) = *(void *)((char *)this + 36);
      *((_DWORD *)this + 18) = v7;
      *((unsigned char *)this + 76) = 1;
    }
    else
    {
      double expectation = Nightingale::CGradient::get_expectation((float **)this);
      if (!*((unsigned char *)this + 76)) {
        *((unsigned char *)this + 76) = 1;
      }
      float v6 = expectation;
      *((float *)this + 18) = v6;
    }
  }
  uint64_t v9 = *a2;
  uint64_t v10 = a2[1];
  if (*a2 != v10)
  {
    uint64_t v11 = 0;
    float v12 = roundf(v6);
    do
    {
      if (Nightingale::CGradient::get_isNull((Nightingale::CGradient *)v9)) {
        goto LABEL_19;
      }
      if (*(unsigned char *)(v9 + 76))
      {
        float v13 = *(float *)(v9 + 72);
      }
      else
      {
        uint64_t v14 = *(void *)(v9 + 36);
        if ((v14 & 0xFF00000000) != 0)
        {
          LODWORD(v13) = *(void *)(v9 + 36);
          *(_DWORD *)(v9 + 72) = v14;
          *(unsigned char *)(v9 + 76) = 1;
        }
        else
        {
          double v15 = Nightingale::CGradient::get_expectation((float **)v9);
          if (!*(unsigned char *)(v9 + 76)) {
            *(unsigned char *)(v9 + 76) = 1;
          }
          float v13 = v15;
          *(float *)(v9 + 72) = v13;
        }
      }
      if ((int)llroundf(v13 + -18.0) < (int)v12)
      {
LABEL_19:
        uint64_t v16 = 0;
        uint64_t v17 = 0;
      }
      else
      {
        unsigned int v18 = llroundf(v13 + -13.0);
        uint64_t v16 = v18;
        uint64_t v11 = v18 >> 8;
        uint64_t v17 = 0x100000000;
      }
      uint64_t v20 = (uint64_t *)a3[1];
      unint64_t v19 = (unint64_t)a3[2];
      if ((unint64_t)v20 >= v19)
      {
        uint64_t v22 = ((char *)v20 - *a3) >> 3;
        if ((unint64_t)(v22 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v23 = v19 - (void)*a3;
        uint64_t v24 = v23 >> 2;
        if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
          uint64_t v24 = v22 + 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        if (v25) {
          uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)(a3 + 2), v25);
        }
        else {
          uint64_t v26 = 0;
        }
        unint64_t v27 = &v26[8 * v22];
        *(void *)unint64_t v27 = v16 | (v11 << 8) | v17;
        unint64_t v21 = v27 + 8;
        long long v29 = *a3;
        long long v28 = a3[1];
        if (v28 != *a3)
        {
          do
          {
            int v30 = *((_DWORD *)v28 - 2);
            v28 -= 8;
            char v31 = v28[4];
            *((_DWORD *)v27 - 2) = v30;
            v27 -= 8;
            v27[4] = v31;
          }
          while (v28 != v29);
          long long v28 = *a3;
        }
        *a3 = v27;
        a3[1] = v21;
        a3[2] = &v26[8 * v25];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *uint64_t v20 = v16 | (v11 << 8) | v17;
        unint64_t v21 = (char *)(v20 + 1);
      }
      a3[1] = v21;
      if (*(unsigned char *)(v9 + 76))
      {
        float v32 = *(float *)(v9 + 72);
      }
      else
      {
        uint64_t v33 = *(void *)(v9 + 36);
        if ((v33 & 0xFF00000000) != 0)
        {
          LODWORD(v32) = *(void *)(v9 + 36);
          *(_DWORD *)(v9 + 72) = v33;
          *(unsigned char *)(v9 + 76) = 1;
        }
        else
        {
          double v34 = Nightingale::CGradient::get_expectation((float **)v9);
          if (!*(unsigned char *)(v9 + 76)) {
            *(unsigned char *)(v9 + 76) = 1;
          }
          float v32 = v34;
          *(float *)(v9 + 72) = v32;
        }
      }
      float v12 = roundf(v32);
      v9 += 160;
    }
    while (v9 != v10);
  }
}

void sub_257D27B1C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngtProjector::constructSurfacedFwProjs(int *a1@<X1>, uint64_t **a2@<X2>, void *a3@<X3>, int a4@<W4>, void *a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  long long v60 = a1;
  if (*((unsigned char *)a1 + 188) && (v10 = a1[46] - a4, int v11 = v10 - 5, v10 >= 5))
  {
    int v13 = *a1;
    int v5 = *((unsigned __int8 *)a1 + 4);
    int v14 = a1[48];
    double v15 = (double *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>((uint64_t)(a5 + 2), 1uLL);
    int v17 = a4 - v13;
    if (!v5) {
      int v17 = 0;
    }
    double v18 = (double)v10;
    double v19 = (double)v11;
    *(_DWORD *)double v15 = a4;
    if (v14) {
      BOOL v20 = v5 == 0;
    }
    else {
      BOOL v20 = 1;
    }
    v15[1] = v19;
    int v21 = v17 + v10;
    if (v20) {
      int v21 = 0;
    }
    void v15[2] = 0.0;
    uint64_t v22 = &v15[13 * v16];
    v15[3] = v19;
    v15[4] = v19;
    *((unsigned char *)v15 + 40) = 1;
    v15[6] = v18;
    v15[7] = 0.0;
    v15[8] = v18;
    v15[9] = v18;
    *((unsigned char *)v15 + 80) = 1;
    *((_DWORD *)v15 + 22) = v11;
    *((_DWORD *)v15 + 23) = 6;
    *((_DWORD *)v15 + 24) = v21;
    *((_DWORD *)v15 + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v14;
    float v12 = (char *)(v15 + 13);
    uint64_t v24 = (char *)*a5;
    uint64_t v23 = (double *)a5[1];
    if (v23 == (double *)*a5)
    {
      a1 = v60;
    }
    else
    {
      a1 = v60;
      do
      {
        long long v25 = *(_OWORD *)(v23 - 13);
        long long v26 = *(_OWORD *)(v23 - 11);
        *(_OWORD *)(v15 - 9) = *(_OWORD *)(v23 - 9);
        *(_OWORD *)(v15 - 11) = v26;
        *(_OWORD *)(v15 - 13) = v25;
        long long v27 = *(_OWORD *)(v23 - 7);
        long long v28 = *(_OWORD *)(v23 - 5);
        long long v29 = *(_OWORD *)(v23 - 3);
        *(v15 - 1) = *(v23 - 1);
        *(_OWORD *)(v15 - 3) = v29;
        *(_OWORD *)(v15 - 5) = v28;
        *(_OWORD *)(v15 - 7) = v27;
        v15 -= 13;
        v23 -= 13;
      }
      while (v23 != (double *)v24);
      uint64_t v23 = (double *)v24;
    }
    *a5 = v15;
    a5[1] = v12;
    a5[2] = v22;
    if (v23)
    {
      operator delete(v23);
      a1 = v60;
    }
    a5[1] = v12;
  }
  else
  {
    float v12 = 0;
  }
  int v30 = *a2;
  char v31 = a2[1];
  if (*a2 != v31)
  {
    unsigned __int8 v32 = 0;
    uint64_t v33 = a5 + 2;
    do
    {
      unsigned __int8 v34 = v32;
      if (v32 >= (unint64_t)((uint64_t)(a3[1] - *a3) >> 3))
      {
        int v37 = 0;
        int v36 = 0;
      }
      else
      {
        int v35 = (unsigned __int8 *)(*a3 + 8 * v32);
        int v36 = *v35;
        int v5 = *(unsigned __int16 *)(v35 + 1) | (v35[3] << 16);
        int v37 = v35[4];
      }
      uint64_t v38 = *v30;
      if ((*v30 & 0xFF00000000) != 0 && (int)v38 >= 5)
      {
        int v40 = a1[90];
        int v41 = v38 - 5;
        double v42 = (double)((int)v38 - 5);
        double v43 = (double)(int)v38;
        int v44 = v38 - (v5 << 8) - v36;
        if (v40) {
          BOOL v45 = v37 == 0;
        }
        else {
          BOOL v45 = 1;
        }
        if (v45) {
          int v46 = 0;
        }
        else {
          int v46 = v44;
        }
        if ((unint64_t)v12 >= *v33)
        {
          uint64_t v47 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)&v12[-*a5] >> 3);
          unint64_t v48 = v47 + 1;
          if ((unint64_t)(v47 + 1) > 0x276276276276276) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          if (0x9D89D89D89D89D8ALL * ((uint64_t)(*v33 - *a5) >> 3) > v48) {
            unint64_t v48 = 0x9D89D89D89D89D8ALL * ((uint64_t)(*v33 - *a5) >> 3);
          }
          if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*v33 - *a5) >> 3)) >= 0x13B13B13B13B13BLL) {
            unint64_t v49 = 0x276276276276276;
          }
          else {
            unint64_t v49 = v48;
          }
          if (v49) {
            long long v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>((uint64_t)v33, v49);
          }
          else {
            long long v50 = 0;
          }
          unint64_t v51 = &v50[104 * v47];
          *(_DWORD *)unint64_t v51 = a4;
          *((double *)v51 + 1) = v42;
          *((void *)v51 + 2) = 0;
          *((double *)v51 + 3) = v42;
          *((double *)v51 + 4) = v42;
          v51[40] = 1;
          *(_DWORD *)(v51 + 41) = *(_DWORD *)v63;
          *((_DWORD *)v51 + 11) = *(_DWORD *)&v63[3];
          *((double *)v51 + 6) = v43;
          *((void *)v51 + 7) = 0;
          *((double *)v51 + 8) = v43;
          *((double *)v51 + 9) = v43;
          v51[80] = 1;
          *(_DWORD *)(v51 + 81) = *(_DWORD *)v62;
          *((_DWORD *)v51 + 21) = *(_DWORD *)&v62[3];
          *((_DWORD *)v51 + 22) = v41;
          *((_DWORD *)v51 + 23) = 6;
          *((_DWORD *)v51 + 24) = v46;
          *((_DWORD *)v51 + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v40;
          uint64_t v53 = (char *)*a5;
          unint64_t v52 = (char *)a5[1];
          unint64_t v54 = v51;
          if (v52 != (char *)*a5)
          {
            do
            {
              long long v55 = *(_OWORD *)(v52 - 104);
              long long v56 = *(_OWORD *)(v52 - 88);
              *(_OWORD *)(v54 - 72) = *(_OWORD *)(v52 - 72);
              *(_OWORD *)(v54 - 88) = v56;
              *(_OWORD *)(v54 - 104) = v55;
              long long v57 = *(_OWORD *)(v52 - 56);
              long long v58 = *(_OWORD *)(v52 - 40);
              long long v59 = *(_OWORD *)(v52 - 24);
              *((void *)v54 - 1) = *((void *)v52 - 1);
              *(_OWORD *)(v54 - 24) = v59;
              *(_OWORD *)(v54 - 40) = v58;
              *(_OWORD *)(v54 - 56) = v57;
              v54 -= 104;
              v52 -= 104;
            }
            while (v52 != v53);
            unint64_t v52 = v53;
          }
          float v12 = v51 + 104;
          *a5 = v54;
          a5[1] = v51 + 104;
          a5[2] = &v50[104 * v49];
          if (v52) {
            operator delete(v52);
          }
          uint64_t v33 = a5 + 2;
          a1 = v60;
        }
        else
        {
          *(_DWORD *)float v12 = a4;
          *((double *)v12 + 1) = v42;
          *((void *)v12 + 2) = 0;
          *((double *)v12 + 3) = v42;
          *((double *)v12 + 4) = v42;
          unsigned char v12[40] = 1;
          *(_DWORD *)(v12 + 41) = *(_DWORD *)v63;
          *((_DWORD *)v12 + 11) = *(_DWORD *)&v63[3];
          *((double *)v12 + 6) = v43;
          *((void *)v12 + 7) = 0;
          *((double *)v12 + 8) = v43;
          *((double *)v12 + 9) = v43;
          v12[80] = 1;
          *(_DWORD *)(v12 + 81) = *(_DWORD *)v62;
          *((_DWORD *)v12 + 21) = *(_DWORD *)&v62[3];
          *((_DWORD *)v12 + 22) = v41;
          *((_DWORD *)v12 + 23) = 6;
          *((_DWORD *)v12 + 24) = v46;
          *((_DWORD *)v12 + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v40;
          v12 += 104;
        }
        a5[1] = v12;
      }
      unsigned __int8 v32 = v34 + 1;
      ++v30;
    }
    while (v30 != v31);
  }
}

void sub_257D27F54(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngtProjector::shrinkLowRangeToRmOverlapFW(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    uint64_t v7 = *a3;
    uint64_t v6 = a3[1];
    if (*a3 != v6)
    {
      int v8 = 0;
      uint64_t v9 = (unsigned __int128)((v6 - v7) * (__int128)0x4EC4EC4EC4EC4EC5) >> 64;
      unint64_t v10 = (v9 >> 5) + ((unint64_t)v9 >> 63);
      if (v10 <= 1) {
        unint64_t v10 = 1;
      }
      int v11 = (_DWORD *)(v7 + 92);
      float v12 = 0.0;
      do
      {
        if (*(unsigned char *)(v4 + 40))
        {
          if (v8 < 1) {
            int v13 = 1;
          }
          else {
            int v13 = a4 ^ 1;
          }
          if (v13 != 1 || (a4 & 1) == 0)
          {
            float v14 = roundf(v12);
            unint64_t v15 = v10;
            uint64_t v16 = v11;
            while (1)
            {
              int v17 = *v16 + *(v16 - 1);
              if (v14 <= (float)(v17 - 1) && round(*(double *)(v4 + 8)) > (double)(v17 - 1)) {
                break;
              }
              v16 += 26;
              if (!--v15) {
                goto LABEL_23;
              }
            }
            int v18 = *(_DWORD *)(v4 + 88);
            if (v18 != -1 && v18 < v17)
            {
              int v20 = v18 - v17 + *(_DWORD *)(v4 + 92);
              *(_DWORD *)(v4 + 88) = v17;
              *(_DWORD *)(v4 + 92) = v20;
            }
          }
LABEL_23:
          float v12 = *(double *)(v4 + 8);
          ++v8;
        }
        v4 += 104;
      }
      while (v4 != v5);
    }
  }
}

void Nightingale::ngtProjector::reproductiveInfiniteHandlingPeriod(BOOL a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, void **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    uint64_t v9 = (uint64_t)(a4 + 2);
    do
    {
      if ((Nightingale::ngtProjector::nullifyAPeriodProj(a1, v4, a3) & 1) == 0)
      {
        int v11 = (char *)a4[1];
        unint64_t v10 = (char *)a4[2];
        if (v11 >= v10)
        {
          int v18 = (char *)*a4;
          uint64_t v19 = 0x4EC4EC4EC4EC4EC5 * ((v11 - (unsigned char *)*a4) >> 3);
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) > 0x276276276276276) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v21 = 0x4EC4EC4EC4EC4EC5 * ((v10 - v18) >> 3);
          if (2 * v21 > v20) {
            unint64_t v20 = 2 * v21;
          }
          if (v21 >= 0x13B13B13B13B13BLL) {
            unint64_t v22 = 0x276276276276276;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(v9, v22);
            int v18 = (char *)*a4;
            int v11 = (char *)a4[1];
          }
          else
          {
            uint64_t v23 = 0;
          }
          uint64_t v24 = &v23[104 * v19];
          long long v25 = *(_OWORD *)v4;
          long long v26 = *(_OWORD *)(v4 + 32);
          *((_OWORD *)v24 + 1) = *(_OWORD *)(v4 + 16);
          *((_OWORD *)v24 + 2) = v26;
          *(_OWORD *)uint64_t v24 = v25;
          long long v27 = *(_OWORD *)(v4 + 48);
          long long v28 = *(_OWORD *)(v4 + 64);
          long long v29 = *(_OWORD *)(v4 + 80);
          *((void *)v24 + 12) = *(void *)(v4 + 96);
          *((_OWORD *)v24 + 4) = v28;
          *((_OWORD *)v24 + 5) = v29;
          *((_OWORD *)v24 + 3) = v27;
          if (v11 == v18)
          {
            int v36 = &v23[104 * v19];
          }
          else
          {
            int v30 = &v23[104 * v19];
            do
            {
              long long v31 = *(_OWORD *)(v11 - 104);
              long long v32 = *(_OWORD *)(v11 - 88);
              *(_OWORD *)(v30 - 72) = *(_OWORD *)(v11 - 72);
              *(_OWORD *)(v30 - 88) = v32;
              *(_OWORD *)(v30 - 104) = v31;
              long long v33 = *(_OWORD *)(v11 - 56);
              long long v34 = *(_OWORD *)(v11 - 40);
              long long v35 = *(_OWORD *)(v11 - 24);
              int v36 = v30 - 104;
              *((void *)v30 - 1) = *((void *)v11 - 1);
              *(_OWORD *)(v30 - 24) = v35;
              *(_OWORD *)(v30 - 40) = v34;
              *(_OWORD *)(v30 - 56) = v33;
              v11 -= 104;
              v30 -= 104;
            }
            while (v11 != v18);
          }
          int v17 = v24 + 104;
          *a4 = v36;
          a4[1] = v24 + 104;
          a4[2] = &v23[104 * v22];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          long long v12 = *(_OWORD *)v4;
          long long v13 = *(_OWORD *)(v4 + 32);
          *((_OWORD *)v11 + 1) = *(_OWORD *)(v4 + 16);
          *((_OWORD *)v11 + 2) = v13;
          *(_OWORD *)int v11 = v12;
          long long v14 = *(_OWORD *)(v4 + 48);
          long long v15 = *(_OWORD *)(v4 + 64);
          long long v16 = *(_OWORD *)(v4 + 80);
          *((void *)v11 + 12) = *(void *)(v4 + 96);
          *((_OWORD *)v11 + 4) = v15;
          *((_OWORD *)v11 + 5) = v16;
          *((_OWORD *)v11 + 3) = v14;
          int v17 = v11 + 104;
        }
        a4[1] = v17;
      }
      v4 += 104;
    }
    while (v4 != v5);
  }
}

void sub_257D28268(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngtProjector::reproductiveInfiniteHandlingFw(BOOL a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, void **a5@<X8>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  if (*a2 != v6)
  {
    uint64_t v38 = (uint64_t)(a5 + 2);
    do
    {
      if ((Nightingale::ngtProjector::nullifyAFwProj(a1, v5, a3, a4) & 1) == 0)
      {
        long long v12 = (char *)a5[1];
        int v11 = (char *)a5[2];
        if (v12 >= v11)
        {
          uint64_t v19 = (char *)*a5;
          uint64_t v20 = 0x4EC4EC4EC4EC4EC5 * ((v12 - (unsigned char *)*a5) >> 3);
          unint64_t v21 = v20 + 1;
          if ((unint64_t)(v20 + 1) > 0x276276276276276) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v22 = 0x4EC4EC4EC4EC4EC5 * ((v11 - v19) >> 3);
          if (2 * v22 > v21) {
            unint64_t v21 = 2 * v22;
          }
          if (v22 >= 0x13B13B13B13B13BLL) {
            unint64_t v23 = 0x276276276276276;
          }
          else {
            unint64_t v23 = v21;
          }
          if (v23)
          {
            uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(v38, v23);
            uint64_t v19 = (char *)*a5;
            long long v12 = (char *)a5[1];
          }
          else
          {
            uint64_t v24 = 0;
          }
          long long v25 = &v24[104 * v20];
          long long v26 = *(_OWORD *)v5;
          long long v27 = *(_OWORD *)(v5 + 32);
          *((_OWORD *)v25 + 1) = *(_OWORD *)(v5 + 16);
          *((_OWORD *)v25 + 2) = v27;
          *(_OWORD *)long long v25 = v26;
          long long v28 = *(_OWORD *)(v5 + 48);
          long long v29 = *(_OWORD *)(v5 + 64);
          long long v30 = *(_OWORD *)(v5 + 80);
          *((void *)v25 + 12) = *(void *)(v5 + 96);
          *((_OWORD *)v25 + 4) = v29;
          *((_OWORD *)v25 + 5) = v30;
          *((_OWORD *)v25 + 3) = v28;
          if (v12 == v19)
          {
            int v37 = &v24[104 * v20];
          }
          else
          {
            long long v31 = &v24[104 * v20];
            do
            {
              long long v32 = *(_OWORD *)(v12 - 104);
              long long v33 = *(_OWORD *)(v12 - 88);
              *(_OWORD *)(v31 - 72) = *(_OWORD *)(v12 - 72);
              *(_OWORD *)(v31 - 88) = v33;
              *(_OWORD *)(v31 - 104) = v32;
              long long v34 = *(_OWORD *)(v12 - 56);
              long long v35 = *(_OWORD *)(v12 - 40);
              long long v36 = *(_OWORD *)(v12 - 24);
              int v37 = v31 - 104;
              *((void *)v31 - 1) = *((void *)v12 - 1);
              *(_OWORD *)(v31 - 24) = v36;
              *(_OWORD *)(v31 - 40) = v35;
              *(_OWORD *)(v31 - 56) = v34;
              v12 -= 104;
              v31 -= 104;
            }
            while (v12 != v19);
          }
          int v18 = v25 + 104;
          *a5 = v37;
          a5[1] = v25 + 104;
          a5[2] = &v24[104 * v23];
          if (v19) {
            operator delete(v19);
          }
        }
        else
        {
          long long v13 = *(_OWORD *)v5;
          long long v14 = *(_OWORD *)(v5 + 32);
          *((_OWORD *)v12 + 1) = *(_OWORD *)(v5 + 16);
          *((_OWORD *)v12 + 2) = v14;
          *(_OWORD *)long long v12 = v13;
          long long v15 = *(_OWORD *)(v5 + 48);
          long long v16 = *(_OWORD *)(v5 + 64);
          long long v17 = *(_OWORD *)(v5 + 80);
          *((void *)v12 + 12) = *(void *)(v5 + 96);
          *((_OWORD *)v12 + 4) = v16;
          *((_OWORD *)v12 + 5) = v17;
          *((_OWORD *)v12 + 3) = v15;
          int v18 = v12 + 104;
        }
        a5[1] = v18;
      }
      v5 += 104;
    }
    while (v5 != v6);
  }
}

void sub_257D2849C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngtProjector::getCaContent(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(result + 96);
  uint64_t v6 = *(void *)(v5 + 8);
  if (*(void *)v5 == v6) {
    return result;
  }
  uint64_t v7 = result;
  if (!*(unsigned char *)(*(void *)(result + 112) + 36)) {
    return result;
  }
  *(unsigned char *)a5 = *(unsigned char *)(v5 + 128);
  *(unsigned char *)(a5 + 120) = *(void *)(v6 - 24) != *(void *)(v6 - 16);
  Nightingale::ngtProjector::get1stProjMetricsCa(result, result + 656, a5 + 56);
  Nightingale::ngtProjector::get1stProjMetricsCa(v10, v7 + 552, a5 + 8);
  int v12 = *(unsigned __int8 *)(a2 + 504);
  int v13 = *(unsigned __int8 *)(a2 + 505);
  if (!(v12 | v13))
  {
    *(_DWORD *)(a5 + 160) = 0;
    int v13 = *(unsigned __int8 *)(a2 + 505);
  }
  if (v12 || !v13)
  {
    if (v12 && !v13)
    {
      *(_DWORD *)(a5 + 160) = 2;
      int v13 = *(unsigned __int8 *)(a2 + 505);
    }
    if (!v12 || !v13) {
      goto LABEL_15;
    }
    int v14 = 3;
  }
  else
  {
    int v14 = 1;
  }
  *(_DWORD *)(a5 + 160) = v14;
LABEL_15:
  int v15 = *(_DWORD *)(a2 + 496);
  *(unsigned char *)(a5 + 108) = *(unsigned char *)(a2 + 500);
  *(_DWORD *)(a5 + 104) = v15;
  int v16 = *(_DWORD *)(a2 + 488);
  *(unsigned char *)(a5 + 116) = *(unsigned char *)(a2 + 492);
  *(_DWORD *)(a5 + 112) = v16;
  long long v17 = *(_OWORD *)(a2 + 444);
  long long v18 = *(_OWORD *)(a2 + 460);
  *(_OWORD *)(a5 + 192) = *(_OWORD *)(a2 + 472);
  *(_OWORD *)(a5 + 180) = v18;
  *(_OWORD *)(a5 + 164) = v17;
  uint64_t v19 = (Nightingale::ngtProjector *)Nightingale::ngtProjector::runSensorBasedAlgDueToCycleFactors(v11, (unsigned __int8 **)(*(void *)(*(void *)(v7 + 96) + 8) - 24));
  if (v19)
  {
    uint64_t v20 = *(void *)(v7 + 112);
    if (*(unsigned char *)(v20 + 36))
    {
      int v21 = *(_DWORD *)(v20 + 32);
      Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v52);
      Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v51);
      uint64_t JDayIdx1stTmp = Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp(v22, *(unsigned int ***)(v7 + 120));
      if ((_BYTE)v24)
      {
        Nightingale::wristTemperatureInputAcquisition::extractKaliInputsJDayRange((unint64_t)v51, *(void **)(v7 + 120), v21 - 13, v21, JDayIdx1stTmp, v24, (uint64_t)&v45);
        if (v45 != v46) {
          *(unsigned char *)(a5 + 121) = 0xAAAAAAAAAAAAAAABLL * ((v46 - v45) >> 3) > 1;
        }
        if (__p)
        {
          long long v50 = __p;
          operator delete(__p);
        }
        if (v47)
        {
          unint64_t v48 = v47;
          operator delete(v47);
        }
        uint64_t v53 = (void **)&v45;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v53);
      }
      Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v51);
      Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v52);
    }
    if (*(_DWORD *)(a2 + 192))
    {
      int v25 = *(_DWORD *)(a2 + 384);
      if (v25 == 2) {
        int v26 = 2;
      }
      else {
        int v26 = 4;
      }
      if (v25 == 1) {
        int v27 = 1;
      }
      else {
        int v27 = v26;
      }
    }
    else
    {
      int v27 = 4 * (*(unsigned char *)(a2 + 188) == 0);
    }
    *(_DWORD *)(a5 + 224) = v27;
    *(_OWORD *)long long v39 = *(_OWORD *)(a2 + 368);
    *(_OWORD *)((char *)&v39[2] + 1) = *(_OWORD *)(a2 + 377);
    int v41 = 0;
    uint64_t v42 = 0;
    int v40 = 0;
    long long v28 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v40, *(const void **)(a2 + 400), *(void *)(a2 + 408), (uint64_t)(*(void *)(a2 + 408) - *(void *)(a2 + 400)) >> 2);
    uint64_t v43 = *(void *)(a2 + 424);
    char v44 = *(unsigned char *)(a2 + 432);
    Nightingale::ngtProjector::surfaceLunaCa((uint64_t)v28, v39, *(_DWORD *)(a2 + 192), *(void *)(a2 + 184), a5);
    uint64_t v19 = (Nightingale::ngtProjector *)v40;
    if (v40)
    {
      int v41 = v40;
      operator delete(v40);
    }
    if (*(unsigned char *)(a2 + 392) && *(_DWORD *)(a2 + 192))
    {
      int v29 = *(_DWORD *)(a2 + 388);
      if (v29 >= 10) {
        unsigned __int8 v30 = 10;
      }
      else {
        unsigned __int8 v30 = *(_DWORD *)(a2 + 388);
      }
      int v31 = v30 >> 1;
      if (v29 < 0) {
        int v32 = -1;
      }
      else {
        int v32 = v31;
      }
    }
    else
    {
      int v32 = -1;
      *(_DWORD *)(a5 + 212) = -1;
    }
    *(_DWORD *)(a5 + 220) = v32;
  }
  CAPeriodPredictionMethod = (Nightingale::ngtProjector *)Nightingale::ngtProjector::getCAPeriodPredictionMethod(v19, (const Nightingale::firstFwPeriodStartOutStruct *)a2);
  *(_DWORD *)(a5 + 124) = CAPeriodPredictionMethod;
  uint64_t v34 = *(void *)(*(void *)(v7 + 96) + 8);
  if (*(unsigned char *)(v34 - 60))
  {
    uint64_t v35 = *(void *)(v7 + 112);
    if (!*(unsigned char *)(v35 + 36)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    long long v36 = (_DWORD *)(v35 + 32);
    int v37 = (int)(float)((float)(roundf(*(float *)(v34 - 64)) + -13.0) + (float)*(int *)(v34 - 96));
    if (*(unsigned char *)(a5 + 156)) {
      long long v36 = (_DWORD *)(a5 + 152);
    }
    uint64_t CABoundedDaysBetweenTodayAndCalFwEnd = Nightingale::ngtProjector::getCABoundedDaysBetweenTodayAndCalFwEnd(CAPeriodPredictionMethod, *v36 - v37);
  }
  else
  {
    uint64_t CABoundedDaysBetweenTodayAndCalFwEnd = 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a5 + 128) = CABoundedDaysBetweenTodayAndCalFwEnd;
  double result = Nightingale::ngtProjector::getCACurrentCycleFactor(CABoundedDaysBetweenTodayAndCalFwEnd, (unsigned __int8 **)(v34 - 24));
  *(_DWORD *)(a5 + 132) = result;
  return result;
}

void sub_257D28804(_Unwind_Exception *a1)
{
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(v1 - 136));
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(v1 - 57));
  _Unwind_Resume(a1);
}

void Nightingale::firstFwPeriodStartOutStruct::~firstFwPeriodStartOutStruct(Nightingale::firstFwPeriodStartOutStruct *this)
{
  uint64_t v2 = (void *)*((void *)this + 50);
  if (v2)
  {
    *((void *)this + 51) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 35);
  if (v3)
  {
    *((void *)this + 36) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 25);
  if (v4)
  {
    *((void *)this + 26) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 12);
  if (v5)
  {
    *((void *)this + 13) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 2);
  if (v6)
  {
    *((void *)this + 3) = v6;
    operator delete(v6);
  }
}

void Nightingale::ngtProjector::compute1stFWPeriodStart(Nightingale::ngtProjector *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  Nightingale::firstFwPeriodStartOutStruct::firstFwPeriodStartOutStruct((Nightingale::firstFwPeriodStartOutStruct *)a3);
  if (!*(unsigned char *)(*((void *)this + 14) + 36)) {
    return;
  }
  uint64_t v6 = (void *)*((void *)this + 12);
  uint64_t v7 = v6[1];
  if (*v6 == v7) {
    return;
  }
  int v8 = *(_DWORD *)(v7 - 96);
  uint64_t v9 = v6[13];
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)v62);
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v61);
  Nightingale::ngtProjector::runLunaAlgorithm(this, a2, (uint64_t)&v47);
  LOBYTE(v40) = 0;
  BYTE4(v40) = 0;
  BYTE8(v40) = 0;
  HIDWORD(v40) = 7;
  Nightingale::CGradient::CGradient((uint64_t)__p);
  LOBYTE(v44) = 0;
  BYTE4(v44) = 0;
  BYTE8(v44) = 0;
  BYTE12(v44) = 0;
  v45[0] = 0;
  *(void *)&v45[4] = 0xBF80000000000005;
  *(void *)&v45[12] = -1;
  *(void *)&v45[20] = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)&v45[28] = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)&v45[44] = _Q0;
  v45[52] = 0;
  v46[0] = 0;
  v46[4] = 0;
  v46[96] = 0;
  if (v50 == 7 || v54 == 5)
  {
    Nightingale::ngtProjector::runHrAlgorithm(this, a2, (uint64_t)&v28);
    long long v40 = v28;
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    *(_OWORD *)__n128 __p = *(_OWORD *)v29;
    uint64_t v42 = v30;
    v29[1] = 0;
    uint64_t v30 = 0;
    v29[0] = 0;
    v43[0] = v31[0];
    *(_OWORD *)((char *)v43 + 9) = *(_OWORD *)((char *)v31 + 9);
    long long v44 = *(_OWORD *)v32;
    *(void *)uint64_t v45 = *(void *)&v32[16];
    *(_OWORD *)&v45[8] = *(_OWORD *)v33;
    *(_OWORD *)&v45[24] = v34[0];
    *(_OWORD *)&v46[16] = v34[3];
    *(_OWORD *)&v46[32] = v35;
    *(_OWORD *)&v45[40] = v34[1];
    *(_OWORD *)uint64_t v46 = v34[2];
    v46[96] = v39;
    *(_OWORD *)&v46[64] = v37;
    *(_OWORD *)&v46[80] = v38;
    *(_OWORD *)&v46[48] = v36;
  }
  Nightingale::fwEstimatorOPK::fwEstimatorOPK((Nightingale::fwEstimatorOPK *)v27);
  uint64_t v15 = Nightingale::fwEstimatorOPK::getOnGoingjDayFwEndOpk((uint64_t)v27, v8, v9);
  Nightingale::ngtProjector::runCalAlgs(this, (uint64_t)&v28);
  Nightingale::ngtProjector::determineFinalFwEnd((uint64_t)this, a3, &v47, (int *)&v40, v15, (uint64_t)&v28, v8);
  Nightingale::ngtProjector::determineFinalPeriod(v16, a3, (uint64_t)&v47, (uint64_t)&v40, (uint64_t)&v28, v8);
  if (a2)
  {
    uint64_t v17 = *((void *)this + 12);
    if (!*(unsigned char *)(v17 + 108))
    {
LABEL_18:
      long long v21 = *(_OWORD *)&v45[24];
      *(_OWORD *)(a3 + 444) = *(_OWORD *)&v45[8];
      *(_OWORD *)(a3 + 460) = v21;
      *(_OWORD *)(a3 + 472) = *(_OWORD *)&v45[36];
      *(_OWORD *)(a3 + 368) = v55[0];
      *(_OWORD *)(a3 + 377) = *(_OWORD *)((char *)v55 + 9);
      if ((_OWORD *)(a3 + 368) != v55) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 400), (char *)__src, (uint64_t)v57, (v57 - (unsigned char *)__src) >> 2);
      }
      *(void *)(a3 + 424) = v58;
      *(unsigned char *)(a3 + 432) = v59;
      *(_DWORD *)(a3 + 440) = v60;
      char v22 = v45[0];
      *(unsigned char *)(a3 + 504) = BYTE8(v40);
      *(unsigned char *)(a3 + 505) = v22;
      char v23 = v53;
      *(unsigned char *)(a3 + 506) = v49;
      *(unsigned char *)(a3 + 507) = v23;
      goto LABEL_21;
    }
    int v18 = *(_DWORD *)(v17 + 104);
    int v19 = v18 + 1;
    if (v48)
    {
      uint64_t v20 = &v47;
    }
    else
    {
      if (!BYTE4(v40))
      {
LABEL_15:
        if (BYTE4(v28) && v18 > *(_DWORD *)(*(void *)(v17 + 8) - 96))
        {
          *(_DWORD *)(a3 + 488) = v28 - v19;
          *(unsigned char *)(a3 + 492) = 1;
        }
        goto LABEL_18;
      }
      uint64_t v20 = (int *)&v40;
    }
    *(_DWORD *)(a3 + 496) = *v20 - v19;
    *(unsigned char *)(a3 + 500) = 1;
    goto LABEL_15;
  }
LABEL_21:
  long long v24 = *(_OWORD *)&v46[52];
  *(_OWORD *)(a3 + 544) = *(_OWORD *)&v46[36];
  *(_OWORD *)(a3 + 560) = v24;
  *(_OWORD *)(a3 + 576) = *(_OWORD *)&v46[68];
  *(_OWORD *)(a3 + 589) = *(_OWORD *)&v46[81];
  long long v25 = *(_OWORD *)&v46[20];
  *(_OWORD *)(a3 + 512) = *(_OWORD *)&v46[4];
  *(_OWORD *)(a3 + 528) = v25;
  *(_OWORD *)a3 = v28;
  if (&v28 != (long long *)a3)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 16), (char *)v29[0], (uint64_t)v29[1], ((char *)v29[1] - (char *)v29[0]) >> 2);
    *(_OWORD *)(a3 + 40) = v31[0];
    *(_OWORD *)(a3 + 49) = *(_OWORD *)((char *)v31 + 9);
    *(_OWORD *)(a3 + 72) = *(_OWORD *)v32;
    *(void *)(a3 + 85) = *(void *)&v32[13];
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 96), (char *)v33[0], (uint64_t)v33[1], ((char *)v33[1] - (char *)v33[0]) >> 2);
  }
  *(_OWORD *)(a3 + 120) = *(_OWORD *)((char *)v34 + 8);
  *(_OWORD *)(a3 + 129) = *(_OWORD *)((char *)&v34[1] + 1);
  *(_OWORD *)(a3 + 152) = *(_OWORD *)((char *)&v34[2] + 8);
  *(void *)(a3 + 165) = *(void *)((char *)&v34[3] + 5);
  int v26 = v33[0];
  *(void *)(a3 + 176) = v35;
  if (v26)
  {
    v33[1] = v26;
    operator delete(v26);
  }
  if (v29[0])
  {
    v29[1] = v29[0];
    operator delete(v29[0]);
  }
  Nightingale::fwEstimatorOPK::~fwEstimatorOPK((Nightingale::fwEstimatorOPK *)v27);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (__src)
  {
    long long v57 = __src;
    operator delete(__src);
  }
  if (v51)
  {
    char v52 = v51;
    operator delete(v51);
  }
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v61);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)v62);
}

void sub_257D28CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  Nightingale::lunaAlgOutStruct::~lunaAlgOutStruct((Nightingale::lunaAlgOutStruct *)&STACK[0x210]);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(v46 - 176));
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(v46 - 97));
  Nightingale::firstFwPeriodStartOutStruct::~firstFwPeriodStartOutStruct(v45);
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::runLunaAlgorithm(Nightingale::ngtProjector *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 7;
  uint64_t v6 = (void **)(a3 + 16);
  uint64_t v7 = Nightingale::CGradient::CGradient(a3 + 16);
  *(_DWORD *)(a3 + 152) = -1;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 84) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  *(void *)(a3 + 92) = 0x800000005;
  *(_WORD *)(a3 + 100) = 0;
  *(unsigned char *)(a3 + 102) = 0;
  *(void *)(a3 + 104) = -1;
  *(unsigned char *)(a3 + 116) = 0;
  *(unsigned char *)(a3 + 120) = 0;
  *(void *)(a3 + 128) = 0;
  *(void *)(a3 + 136) = 0;
  *(void *)(a3 + 144) = 0;
  *(unsigned char *)(a3 + 156) = 0;
  *(unsigned char *)(a3 + 160) = 0;
  *(_DWORD *)(a3 + 168) = 5;
  uint64_t v8 = *((void *)this + 12);
  if (*(unsigned char *)(v8 + 84)
    && Nightingale::ngtProjector::runSensorBasedAlgDueToCycleFactors(v7, (unsigned __int8 **)(*(void *)(v8 + 8) - 24)))
  {
    Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v45);
    uint64_t JDayIdx1stTmp = Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp(v9, *((unsigned int ***)this + 15));
    uint64_t v11 = (_OWORD *)(a3 + 96);
    if (v12)
    {
      unint64_t v13 = JDayIdx1stTmp;
      uint64_t v14 = Nightingale::fwEstimatorLuna::fwEstimatorLuna((Nightingale::fwEstimatorLuna *)v44, *((const Nightingale::ngt_Config **)this + 14));
      Nightingale::fwEstimatorLuna::getFwEndLuna(v14, *((void **)this + 12), *((void **)this + 15), *((void *)this + 14), v13, a2, &v32);
      _OWORD *v11 = v39[0];
      *(_OWORD *)(a3 + 105) = *(_OWORD *)((char *)v39 + 9);
      if (v11 != v39) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 128), (char *)v40, (uint64_t)v41, (v41 - (unsigned char *)v40) >> 2);
      }
      *(void *)(a3 + 152) = v42;
      *(unsigned char *)(a3 + 160) = v43;
      if (v34 && v38 && v36 && v32 != 7)
      {
        Nightingale::periodEstimatorLuna::periodEstimatorLuna((Nightingale::periodEstimatorLuna *)v31, *((const Nightingale::ngt_Config **)this + 14));
        int v27 = 6;
        char v30 = 0;
        unint64_t v28 = 0;
        LOBYTE(v29) = 0;
        if (!v34 || !v36 || !v38) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        unsigned int v15 = v35;
        unsigned int v16 = v37;
        if (v33 > v35) {
          unsigned int v15 = v33;
        }
        if (v33 + 20 < v37) {
          unsigned int v16 = v33 + 20;
        }
        int v29 = v33;
        char v30 = v34;
        int v27 = v32;
        unint64_t v28 = __PAIR64__(v16, v15);
        Nightingale::periodEstimatorLuna::estimatePeriodLuna((uint64_t)v31, *((void *)this + 15), *((uint64_t **)this + 12), *((const Nightingale::ngt_Config **)this + 14), v13, (uint64_t)&v27, (uint64_t)&__p);
        *(_DWORD *)a3 = v33;
        *(unsigned char *)(a3 + 4) = v34;
        *(_DWORD *)(a3 + 12) = v32;
        if (v26) {
          *(_DWORD *)(a3 + 104) = -1;
        }
        else {
          *(unsigned char *)(a3 + 8) = v34;
        }
        if (v6 != &__p) {
          std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 16), (char *)__p, (uint64_t)v18, (v18 - (unsigned char *)__p) >> 2);
        }
        *(_OWORD *)(a3 + 40) = v19[0];
        *(_OWORD *)(a3 + 49) = *(_OWORD *)((char *)v19 + 9);
        *(_DWORD *)(a3 + 92) = v25;
        *(unsigned char *)(a3 + 88) = v24;
        if ((Nightingale::CGradient::get_adjusted((Nightingale::CGradient *)&__p) & 1) == 0)
        {
          if (*(unsigned __int8 *)(a3 + 76) == v21)
          {
            if (*(unsigned char *)(a3 + 76)) {
              *(float *)(a3 + 72) = (float)v20;
            }
          }
          else if (*(unsigned char *)(a3 + 76))
          {
            *(unsigned char *)(a3 + 76) = 0;
          }
          else
          {
            *(float *)(a3 + 72) = (float)v20;
            *(unsigned char *)(a3 + 76) = 1;
          }
          if (*(unsigned __int8 *)(a3 + 84) == v23)
          {
            if (*(unsigned char *)(a3 + 84)) {
              *(float *)(a3 + 80) = (float)v22;
            }
          }
          else if (*(unsigned char *)(a3 + 84))
          {
            *(unsigned char *)(a3 + 84) = 0;
          }
          else
          {
            *(float *)(a3 + 80) = (float)v22;
            *(unsigned char *)(a3 + 84) = 1;
          }
        }
        if (a2) {
          *(_DWORD *)(a3 + 168) = v25;
        }
        if (__p)
        {
          int v18 = __p;
          operator delete(__p);
        }
        Nightingale::periodEstimatorLuna::~periodEstimatorLuna(v31);
      }
      if (v40)
      {
        int v41 = v40;
        operator delete(v40);
      }
      Nightingale::fwEstimatorLuna::~fwEstimatorLuna((Nightingale::fwEstimatorLuna *)v44);
    }
    else
    {
      *(_DWORD *)uint64_t v11 = 1;
    }
    Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v45);
  }
}

void sub_257D290F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36)
{
  Nightingale::periodEstimatorLuna::~periodEstimatorLuna(&a24);
  if (__p)
  {
    a36 = (uint64_t)__p;
    operator delete(__p);
  }
  Nightingale::fwEstimatorLuna::~fwEstimatorLuna((Nightingale::fwEstimatorLuna *)(v37 - 200));
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(v37 - 152));
  Nightingale::lunaAlgOutStruct::~lunaAlgOutStruct(v36);
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::runHrAlgorithm(Nightingale::ngtProjector *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 8) = 0;
  *(_DWORD *)(a3 + 12) = 7;
  uint64_t v6 = (void **)(a3 + 16);
  uint64_t v7 = Nightingale::CGradient::CGradient(a3 + 16);
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 84) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  *(void *)(a3 + 92) = 0xBF80000000000005;
  *(void *)(a3 + 100) = -1;
  *(void *)(a3 + 108) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)(a3 + 116) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a3 + 132) = _Q0;
  *(unsigned char *)(a3 + 140) = 0;
  *(unsigned char *)(a3 + 144) = 0;
  *(unsigned char *)(a3 + 148) = 0;
  *(unsigned char *)(a3 + 240) = 0;
  if (Nightingale::ngtProjector::runSensorBasedAlgDueToCycleFactors(v7, (unsigned __int8 **)(*(void *)(*((void *)this + 12) + 8) - 24)))
  {
    Nightingale::lstmHrFw::lstmHrFw(v37, *((void *)this + 15), *((void *)this + 12), *((void *)this + 14), *((void *)this + 13));
    __n128 FWEndHr = Nightingale::lstmHrFw::getFWEndHr((Nightingale::lstmHrFw *)v37, a2, (uint64_t)&v30);
    Nightingale::lstmHrPeriod::lstmHrPeriod(v29, *((void *)this + 15), *((void *)this + 12), *((void *)this + 14), *((void *)this + 13), v32, FWEndHr);
    Nightingale::lstmHrPeriod::estimatePeriodStartHr((Nightingale::lstmHrPeriod *)v29, (uint64_t)&__p);
    Nightingale::lstmHrPeriod::getEnsembleTelemetry((Nightingale::lstmHrPeriod *)v29, (uint64_t)v19);
    *(_DWORD *)a3 = v30;
    int v14 = v31;
    *(unsigned char *)(a3 + 4) = v31;
    *(unsigned char *)(a3 + 8) = v14;
    if (v14) {
      *(_DWORD *)(a3 + 12) = 4;
    }
    if (v6 != &__p) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a3 + 16), (char *)__p, (uint64_t)v22, (v22 - (unsigned char *)__p) >> 2);
    }
    *(_OWORD *)(a3 + 40) = v23[0];
    *(_OWORD *)(a3 + 49) = *(_OWORD *)((char *)v23 + 9);
    if ((Nightingale::CGradient::get_adjusted((Nightingale::CGradient *)&__p) & 1) == 0)
    {
      *(_DWORD *)(a3 + 72) = v24;
      *(unsigned char *)(a3 + 76) = v25;
      *(_DWORD *)(a3 + 80) = v26;
      *(unsigned char *)(a3 + 84) = v27;
    }
    int v15 = v28;
    *(unsigned char *)(a3 + 88) = v28;
    if (v15 && !Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)&__p)) {
      *(_DWORD *)(a3 + 92) = 3;
    }
    long long v16 = v19[3];
    *(_OWORD *)(a3 + 180) = v19[2];
    *(_OWORD *)(a3 + 196) = v16;
    *(_OWORD *)(a3 + 212) = v20[0];
    *(_OWORD *)(a3 + 2std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = *(_OWORD *)((char *)v20 + 13);
    long long v17 = v19[1];
    *(_OWORD *)(a3 + 148) = v19[0];
    *(_OWORD *)(a3 + 164) = v17;
    if (a2)
    {
      long long v18 = *(_OWORD *)v34;
      *(_OWORD *)(a3 + 96) = v33;
      *(_OWORD *)(a3 + 112) = v18;
      *(_OWORD *)(a3 + 124) = *(_OWORD *)&v34[12];
      *(_DWORD *)(a3 + 140) = v35;
      *(unsigned char *)(a3 + 144) = v36;
    }
    if (__p)
    {
      int v22 = __p;
      operator delete(__p);
    }
    Nightingale::lstmHrPeriod::~lstmHrPeriod((Nightingale::lstmHrPeriod *)v29);
    Nightingale::lstmHrFw::~lstmHrFw((Nightingale::lstmHrFw *)v37);
  }
}

void sub_257D293B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  Nightingale::lstmHrPeriod::~lstmHrPeriod((Nightingale::lstmHrPeriod *)&a32);
  Nightingale::lstmHrFw::~lstmHrFw((Nightingale::lstmHrFw *)&STACK[0x350]);
  int v35 = *v33;
  if (*v33)
  {
    *(void *)(v32 + 24) = v35;
    operator delete(v35);
  }
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::runCalAlgs(Nightingale::ngtProjector *this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  *(unsigned char *)(a2 + 4) = 0;
  *(void *)(a2 + 8) = 3;
  uint64_t v4 = (void **)(a2 + 16);
  Nightingale::CGradient::CGradient(a2 + 16);
  *(unsigned char *)(a2 + 72) = 0;
  *(unsigned char *)(a2 + 76) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  *(unsigned char *)(a2 + 84) = 0;
  *(unsigned char *)(a2 + 88) = 0;
  *(unsigned char *)(a2 + 92) = 0;
  Nightingale::CGradient::CGradient(a2 + 96);
  *(unsigned char *)(a2 + 152) = 0;
  *(unsigned char *)(a2 + 156) = 0;
  *(unsigned char *)(a2 + 160) = 0;
  *(unsigned char *)(a2 + 164) = 0;
  *(unsigned char *)(a2 + 168) = 0;
  *(unsigned char *)(a2 + 172) = 0;
  *(void *)(a2 + 176) = 3;
  uint64_t v5 = (uint64_t *)*((void *)this + 12);
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  if (v7 != v6 && *(unsigned char *)(v6 - 52) && *(unsigned char *)(v6 - 60))
  {
    Nightingale::periodEstimatorCalendar::periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)v18, *((const Nightingale::ngt_Config **)this + 14));
    Nightingale::fwEstimatorCalendar::fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v17);
    Nightingale::periodEstimatorCalendar::predict1stPeriodStartCal((Nightingale::periodEstimatorCalendar *)v18, *(void *)(*((void *)this + 12) + 8) - 96, *(void *)(*((void *)this + 12) + 104), *(void *)(*((void *)this + 12) + 96), *(unsigned int *)(*((void *)this + 12) + 124) | 0x100000000, (uint64_t)&v14);
    uint64_t v8 = *v4;
    if (*v4)
    {
      *(void *)(a2 + 24) = v8;
      operator delete(v8);
      void *v4 = 0;
      *(void *)(a2 + 24) = 0;
      *(void *)(a2 + 32) = 0;
    }
    *(_OWORD *)(a2 + 16) = v14;
    *(void *)(a2 + 32) = v15;
    *(_OWORD *)(a2 + 40) = v16[0];
    *(_OWORD *)(a2 + 49) = *(_OWORD *)((char *)v16 + 9);
    *(_DWORD *)(a2 + 176) = 3;
    if (!Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)(a2 + 16)))
    {
      int v9 = *(_DWORD *)(*(void *)(*((void *)this + 12) + 8) - 96);
      if (*(unsigned char *)(a2 + 92))
      {
        float v10 = *(float *)(a2 + 88);
      }
      else
      {
        uint64_t v11 = *(void *)(a2 + 52);
        if ((v11 & 0xFF00000000) != 0)
        {
          LODWORD(v10) = *(void *)(a2 + 52);
          *(_DWORD *)(a2 + 88) = v11;
          *(unsigned char *)(a2 + 92) = 1;
        }
        else
        {
          double expectation = Nightingale::CGradient::get_expectation((float **)(a2 + 16));
          if (!*(unsigned char *)(a2 + 92)) {
            *(unsigned char *)(a2 + 92) = 1;
          }
          float v10 = expectation;
          *(float *)(a2 + 88) = v10;
        }
      }
      *(float *)(a2 + 88) = v10;
      *(unsigned char *)(a2 + 92) = 1;
      uint64_t v13 = Nightingale::fwEstimatorCalendar::getjDayFwEndCal((Nightingale::fwEstimatorCalendar *)v17, v9, (int)(float)(roundf(v10) + (float)v9));
      *(_DWORD *)a2 = v13;
      *(unsigned char *)(a2 + 4) = BYTE4(v13);
      *(_DWORD *)(a2 + 8) = 3;
    }
    Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v17);
    Nightingale::periodEstimatorCalendar::~periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)v18);
  }
}

void sub_257D295F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)va);
  Nightingale::periodEstimatorCalendar::~periodEstimatorCalendar((Nightingale::periodEstimatorCalendar *)va1);
  Nightingale::fwPeriodEstimateStruct::~fwPeriodEstimateStruct(v8);
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::determineFinalFwEnd(uint64_t a1, uint64_t a2, int *a3, int *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (BYTE4(a5))
  {
    *(_DWORD *)(a2 + 184) = a5;
    *(unsigned char *)(a2 + 188) = BYTE4(a5);
LABEL_4:
    *(_DWORD *)(a2 + 192) = 0;
    return;
  }
  if (*(unsigned char *)(*(void *)(a1 + 96) + 108)) {
    goto LABEL_4;
  }
  if (*((unsigned char *)a3 + 4))
  {
    int v8 = *a3;
    *(unsigned char *)(a2 + 188) = *((unsigned char *)a3 + 4);
    *(_DWORD *)(a2 + 184) = v8;
    *(_DWORD *)(a2 + 192) = 1;
    *(_DWORD *)(a2 + 440) = a3[42];
  }
  else if (*((unsigned char *)a4 + 4))
  {
    int v10 = *a4;
    *(unsigned char *)(a2 + 188) = *((unsigned char *)a4 + 4);
    *(_DWORD *)(a2 + 184) = v10;
    *(_DWORD *)(a2 + 192) = 2;
  }
  else
  {
    if (*(unsigned char *)(a6 + 4))
    {
      *(_DWORD *)(a2 + 184) = *(_DWORD *)a6;
      *(unsigned char *)(a2 + 188) = 1;
      *(_DWORD *)(a2 + 192) = 3;
    }
    if (a4[23] == 3
      && ((Nightingale::CGradient::get_isNull((Nightingale::CGradient *)(a6 + 16)) & 1) != 0 || !*(unsigned char *)(a6 + 4)))
    {
      Nightingale::fwEstimatorCalendar::fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v15);
      double expectation = Nightingale::CGradient::get_expectation((float **)a4 + 2);
      uint64_t v14 = Nightingale::fwEstimatorCalendar::getjDayFwEndCal((Nightingale::fwEstimatorCalendar *)v15, a7, (int)(round(expectation) + (double)a7));
      *(_DWORD *)(a2 + 184) = v14;
      *(unsigned char *)(a2 + 188) = BYTE4(v14);
      *(_DWORD *)(a2 + 192) = 2;
      Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v15);
    }
  }
}

void sub_257D2978C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)va);
  _Unwind_Resume(a1);
}

void Nightingale::ngtProjector::determineFinalPeriod(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  Nightingale::periodEstimatorAggregation::periodEstimatorAggregation((Nightingale::periodEstimatorAggregation *)&v22);
  if (Nightingale::periodEstimatorAggregation::period1stProjFromluna((uint64_t)&v22, (_DWORD *)(a3 + 92)))
  {
    if (a2 + 184 != a3) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a2 + 200), *(char **)(a3 + 16), *(void *)(a3 + 24), (uint64_t)(*(void *)(a3 + 24) - *(void *)(a3 + 16)) >> 2);
    }
    long long v11 = *(_OWORD *)(a3 + 40);
    *(_OWORD *)(a2 + 233) = *(_OWORD *)(a3 + 49);
    *(_OWORD *)(a2 + 224) = v11;
    *(_DWORD *)(a2 + 360) = 1;
    int v12 = *(_DWORD *)(a3 + 72);
    *(unsigned char *)(a2 + 260) = *(unsigned char *)(a3 + 76);
    *(_DWORD *)(a2 + 256) = v12;
    int v13 = *(_DWORD *)(a3 + 80);
    *(unsigned char *)(a2 + 268) = *(unsigned char *)(a3 + 84);
    *(_DWORD *)(a2 + 264) = v13;
    double expectation = Nightingale::CGradient::get_expectation((float **)(a3 + 16));
LABEL_12:
    if (!*(unsigned char *)(a2 + 276)) {
      *(unsigned char *)(a2 + 276) = 1;
    }
    float v19 = expectation;
    *(float *)(a2 + 272) = v19;
    goto LABEL_15;
  }
  if (Nightingale::periodEstimatorAggregation::period1stProjFromHR((uint64_t)&v22, (_DWORD *)(a4 + 92)))
  {
    if (!*(unsigned char *)(a2 + 188)) {
      goto LABEL_9;
    }
    double v15 = Nightingale::CGradient::get_expectation((float **)(a4 + 16));
    if (!*(unsigned char *)(a2 + 188)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if (round(v15) + (double)a6 - (double)*(int *)(a2 + 184) >= 6.0)
    {
LABEL_9:
      if (a2 + 184 != a4) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a2 + 200), *(char **)(a4 + 16), *(void *)(a4 + 24), (uint64_t)(*(void *)(a4 + 24) - *(void *)(a4 + 16)) >> 2);
      }
      long long v16 = *(_OWORD *)(a4 + 40);
      *(_OWORD *)(a2 + 233) = *(_OWORD *)(a4 + 49);
      *(_OWORD *)(a2 + 224) = v16;
      *(_DWORD *)(a2 + 360) = 2;
      int v17 = *(_DWORD *)(a4 + 72);
      *(unsigned char *)(a2 + 260) = *(unsigned char *)(a4 + 76);
      *(_DWORD *)(a2 + 256) = v17;
      int v18 = *(_DWORD *)(a4 + 80);
      *(unsigned char *)(a2 + 268) = *(unsigned char *)(a4 + 84);
      *(_DWORD *)(a2 + 264) = v18;
      double expectation = Nightingale::CGradient::get_expectation((float **)(a4 + 16));
      goto LABEL_12;
    }
  }
  else if (!(*(unsigned __int8 *)(a3 + 88) | *(unsigned __int8 *)(a4 + 88)))
  {
    if (a2 + 184 != a5) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a2 + 200), *(char **)(a5 + 16), *(void *)(a5 + 24), (uint64_t)(*(void *)(a5 + 24) - *(void *)(a5 + 16)) >> 2);
    }
    long long v20 = *(_OWORD *)(a5 + 40);
    *(_OWORD *)(a2 + 233) = *(_OWORD *)(a5 + 49);
    *(_OWORD *)(a2 + 224) = v20;
    long long v21 = *(_OWORD *)(a5 + 72);
    *(void *)(a2 + 269) = *(void *)(a5 + 85);
    *(_OWORD *)(a2 + 256) = v21;
    *(_DWORD *)(a2 + 360) = *(_DWORD *)(a5 + 176);
  }
LABEL_15:
  Nightingale::periodEstimatorAggregation::~periodEstimatorAggregation((Nightingale::periodEstimatorAggregation *)&v22);
}

void sub_257D29998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

void Nightingale::fwPeriodEstimateStruct::~fwPeriodEstimateStruct(Nightingale::fwPeriodEstimateStruct *this)
{
  uint64_t v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

void Nightingale::lunaAlgOutStruct::~lunaAlgOutStruct(Nightingale::lunaAlgOutStruct *this)
{
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

BOOL Nightingale::ngtProjector::runSensorBasedAlgDueToCycleFactors(uint64_t a1, unsigned __int8 **a2)
{
  __n128 __p = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  BOOL v2 = Nightingale::phaseFactorProcessor::containContraceptiveCycleFactors((uint64_t)&__p, a2);
  if (__p)
  {
    uint64_t v5 = __p;
    operator delete(__p);
  }
  return !v2;
}

void sub_257D29A88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::optional<Nightingale::periodEstimationOutStruct>::operator=[abi:ne180100]<Nightingale::periodEstimationOutStruct&,void>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 80))
  {
    if (a1 != a2) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    }
    long long v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v4;
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 69) = *(void *)(a2 + 69);
    *(_OWORD *)(a1 + 56) = v5;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    long long v6 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v6;
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 69) = *(void *)(a2 + 69);
    *(_OWORD *)(a1 + 56) = v7;
    *(unsigned char *)(a1 + 80) = 1;
  }
  return a1;
}

void Nightingale::ngtProjector::offsetFwEnd2NgtPrediction(uint64_t a1@<X1>, uint64_t a2@<X2>, int a3@<W3>, int a4@<W4>, uint64_t a5@<X8>)
{
  *(unsigned char *)(a5 + 8) = 0;
  *(unsigned char *)(a5 + 40) = 0;
  *(unsigned char *)(a5 + 48) = 0;
  *(unsigned char *)(a5 + 80) = 0;
  *(_OWORD *)(a5 + 88) = xmmword_257D5F6E0;
  if ((a1 & 0xFF00000000) != 0)
  {
    int v5 = a1 - 5;
    if ((int)a1 >= 5)
    {
      *(_DWORD *)(a5 + 88) = v5;
      *(_DWORD *)(a5 + 92) = 6;
      *(_DWORD *)a5 = a4;
      *(_DWORD *)(a5 + 100) = a3;
      *(double *)(a5 + 8) = (double)v5;
      *(void *)(a5 + 16) = 0;
      *(double *)(a5 + 24) = (double)v5;
      *(double *)(a5 + 32) = (double)v5;
      *(unsigned char *)(a5 + 40) = 1;
      *(double *)(a5 + 48) = (double)(int)a1;
      *(void *)(a5 + 56) = 0;
      *(double *)(a5 + 64) = (double)(int)a1;
      *(double *)(a5 + 72) = (double)(int)a1;
      *(unsigned char *)(a5 + 80) = 1;
      if ((a2 & 0xFF00000000) != 0)
      {
        if (a3) {
          *(_DWORD *)(a5 + 96) = a1 - a2;
        }
      }
    }
  }
}

double Nightingale::ngtProjector::getAMetricFromperiodEstimationOut(uint64_t a1, Nightingale::CGradient *this)
{
  BOOL vGrad_empty = Nightingale::CGradient::get_vGrad_empty(this);
  double result = 0.0;
  if (!vGrad_empty)
  {
    Nightingale::ngtProjector::computeLowRangeMeanStd(a1, this);
    double result = *((float *)this + 18);
    if (!*((unsigned char *)this + 76)) {
      return 0.0;
    }
  }
  return result;
}

float Nightingale::ngtProjector::computeLowRangeMeanStd(uint64_t a1, Nightingale::CGradient *this)
{
  if (*((unsigned char *)this + 76))
  {
    float v4 = *((float *)this + 18);
  }
  else
  {
    uint64_t v5 = *(void *)((char *)this + 36);
    if ((v5 & 0xFF00000000) != 0)
    {
      LODWORD(v4) = *(void *)((char *)this + 36);
      *((_DWORD *)this + 18) = v5;
      *((unsigned char *)this + 76) = 1;
    }
    else
    {
      double expectation = Nightingale::CGradient::get_expectation((float **)this);
      if (!*((unsigned char *)this + 76)) {
        *((unsigned char *)this + 76) = 1;
      }
      float v4 = expectation;
      *((float *)this + 18) = v4;
    }
  }
  float std = Nightingale::CGradient::get_std((float **)this);
  if ((*(void *)((unsigned char *)this + 44) & 0xFF00000000) != 0) {
    LODWORD(v8) = *(void *)((char *)this + 44);
  }
  else {
    float v8 = std;
  }
  uint64_t v9 = *(void *)(a1 + 760);
  if (!*((unsigned char *)this + 60))
  {
    float v10 = v4 + (float)(v8 * -1.28);
    if (v10 < 0.0) {
      float v10 = 0.0;
    }
    *((float *)this + 14) = v10;
    *((unsigned char *)this + 60) = 1;
  }
  if ((v9 & 0xFF00000000) != 0)
  {
    float v11 = (float)(v9 + 1);
    if (*((float *)this + 14) >= v11) {
      float v11 = *((float *)this + 14);
    }
    *((float *)this + 14) = v11;
    *((unsigned char *)this + 60) = 1;
  }
  if (!*((unsigned char *)this + 68))
  {
    float v12 = v4 + (float)(v8 * 1.28);
    float vGrad_len = (float)(int)Nightingale::CGradient::get_vGrad_len(this);
    if (v12 <= vGrad_len) {
      float vGrad_len = v12;
    }
    *((float *)this + 16) = vGrad_len;
    *((unsigned char *)this + 68) = 1;
  }
  return v8;
}

uint64_t Nightingale::ngtProjector::nullifyAFwProj(BOOL a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  long long v20 = 0;
  long long v21 = 0;
  uint64_t v22 = 0;
  if (Nightingale::ngtProjector::isFinite_aProj(a1, a2))
  {
    if ((Nightingale::CGradient::get_isNull((Nightingale::CGradient *)a4) & 1) != 0
      || (Nightingale::CGradient::get_isNull((Nightingale::CGradient *)a4) & 1) == 0
      && *(unsigned char *)(a4 + 76)
      && *(float *)(a4 + 72) > (float)(*(_DWORD *)(a2 + 88) + *(_DWORD *)(a2 + 92) - 1))
    {
      long long v7 = *(_OWORD *)(a2 + 80);
      void v18[4] = *(_OWORD *)(a2 + 64);
      v18[5] = v7;
      uint64_t v19 = *(void *)(a2 + 96);
      long long v8 = *(_OWORD *)(a2 + 16);
      v18[0] = *(_OWORD *)a2;
      v18[1] = v8;
      long long v9 = *(_OWORD *)(a2 + 48);
      v18[2] = *(_OWORD *)(a2 + 32);
      v18[3] = v9;
      BOOL v10 = Nightingale::phaseFactorProjector::projected1stFWFailRepro((uint64_t)&v20, (uint64_t)v18, a3);
    }
    else
    {
      long long v12 = *(_OWORD *)(a2 + 80);
      v16[4] = *(_OWORD *)(a2 + 64);
      void v16[5] = v12;
      uint64_t v17 = *(void *)(a2 + 96);
      long long v13 = *(_OWORD *)(a2 + 16);
      v16[0] = *(_OWORD *)a2;
      v16[1] = v13;
      long long v14 = *(_OWORD *)(a2 + 48);
      _OWORD v16[2] = *(_OWORD *)(a2 + 32);
      v16[3] = v14;
      BOOL v10 = Nightingale::phaseFactorProjector::projectedFWFailRepro((uint64_t)&v20, (uint64_t)v16, a3);
    }
    uint64_t v11 = v10;
  }
  else
  {
    uint64_t v11 = 1;
  }
  if (v20)
  {
    long long v21 = v20;
    operator delete(v20);
  }
  return v11;
}

void sub_257D29E98(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 - 56);
  if (v3)
  {
    *(void *)(v1 - 48) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngtProjector::nullifyAPeriodProj(BOOL a1, uint64_t a2, uint64_t *a3)
{
  long long v12 = 0;
  long long v13 = 0;
  uint64_t v14 = 0;
  if (!Nightingale::ngtProjector::isFinite_aProj(a1, a2)) {
    return 1;
  }
  long long v5 = *(_OWORD *)(a2 + 80);
  v10[4] = *(_OWORD *)(a2 + 64);
  v10[5] = v5;
  uint64_t v11 = *(void *)(a2 + 96);
  long long v6 = *(_OWORD *)(a2 + 16);
  v10[0] = *(_OWORD *)a2;
  v10[1] = v6;
  long long v7 = *(_OWORD *)(a2 + 48);
  id v10[2] = *(_OWORD *)(a2 + 32);
  v10[3] = v7;
  BOOL v8 = Nightingale::phaseFactorProjector::projectedPeriodFailRepro((uint64_t)&v12, (uint64_t)v10, a3);
  if (v12)
  {
    long long v13 = v12;
    operator delete(v12);
  }
  return v8;
}

void sub_257D29F40(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 - 40);
  if (v3)
  {
    *(void *)(v1 - 32) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::ngtProjector::get1stProjMetricsCa(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a2 + 40) && *(unsigned char *)(a2 + 80))
  {
    *(_DWORD *)(a3 + 32) = *(_DWORD *)(a2 + 88);
    *(unsigned char *)(a3 + 36) = 1;
    *(_DWORD *)(a3 + 40) = *(_DWORD *)(a2 + 92);
    *(unsigned char *)(a3 + 44) = 1;
    if (*(unsigned char *)(a2 + 40))
    {
      double result = *(double *)(a2 + 8);
      *(double *)a3 = result;
      *(unsigned char *)(a3 + 8) = 1;
    }
    if (*(unsigned char *)(a2 + 80))
    {
      double result = *(double *)(a2 + 48);
      *(double *)(a3 + 16) = result;
      *(unsigned char *)(a3 + 24) = 1;
    }
  }
  return result;
}

uint64_t Nightingale::ngtProjector::getCaFwEndConfirmationMethodLuna(uint64_t a1, int a2, int a3, uint64_t a4)
{
  if (a2 == 2) {
    unsigned int v4 = 2;
  }
  else {
    unsigned int v4 = 4;
  }
  if (a2 == 1) {
    unsigned int v4 = 1;
  }
  if (a3) {
    return v4;
  }
  else {
    return 4 * ((a4 & 0xFF00000000) == 0);
  }
}

void Nightingale::ngtProjector::surfaceLunaCa(uint64_t a1, int *a2, int a3, uint64_t a4, uint64_t a5)
{
  *(unsigned char *)(a5 + 208) = *((unsigned char *)a2 + 4);
  *(_WORD *)(a5 + 209) = *(_WORD *)((char *)a2 + 5);
  *(void *)(a5 + 212) = *((void *)a2 + 1);
  long long v5 = (uint32x2_t *)*((void *)a2 + 4);
  if (*((void *)a2 + 5) - (void)v5 == 12)
  {
    int8x8_t v6 = (int8x8_t)vcgt_u32((uint32x2_t)0x2E0000002ELL, *v5);
    *(int8x8_t *)(a5 + 140) = vorn_s8(vand_s8((int8x8_t)*v5, v6), v6);
    unsigned int v7 = v5[1].u32[0];
    if (v7 >= 0x2E) {
      unsigned int v7 = -1;
    }
    *(_DWORD *)(a5 + 148) = v7;
  }
  if (*((unsigned char *)a2 + 24))
  {
    int v8 = a2[5];
    if (v8 >= 10) {
      unsigned __int8 v9 = 10;
    }
    else {
      unsigned __int8 v9 = a2[5];
    }
    int v10 = v9 >> 1;
    if (v8 < 0) {
      int v11 = -1;
    }
    else {
      int v11 = v10;
    }
  }
  else
  {
    int v11 = -1;
  }
  *(_DWORD *)(a5 + 220) = v11;
  unsigned int v12 = a2[14];
  if (v12 >= 0x2E) {
    unsigned int v12 = -1;
  }
  *(_DWORD *)(a5 + 136) = v12;
  int v13 = a2[15];
  *(unsigned char *)(a5 + 156) = *((unsigned char *)a2 + 64);
  *(_DWORD *)(a5 + 152) = v13;
  if (a3)
  {
    int v14 = a2[4];
    if (v14 == 2) {
      int v15 = 2;
    }
    else {
      int v15 = 4;
    }
    if (v14 == 1) {
      int v16 = 1;
    }
    else {
      int v16 = v15;
    }
    int v17 = *a2;
  }
  else
  {
    int v16 = 4 * ((a4 & 0xFF00000000) == 0);
    int v17 = *a2;
    if ((a4 & 0xFF00000000) != 0) {
      int v17 = 0;
    }
  }
  *(_DWORD *)(a5 + 224) = v16;
  *(_DWORD *)(a5 + 228) = v17;
}

uint64_t Nightingale::ngtProjector::getCAtBoundedDaysBetweenFwEndAndNotification(Nightingale::ngtProjector *this, int a2)
{
  if (a2 >= 10) {
    unsigned __int8 v2 = 10;
  }
  else {
    unsigned __int8 v2 = a2;
  }
  unsigned int v3 = v2 >> 1;
  if (a2 < 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v3;
  }
}

uint64_t Nightingale::ngtProjector::getCAPeriodPredictionMethod(Nightingale::ngtProjector *this, const Nightingale::firstFwPeriodStartOutStruct *a2)
{
  if (Nightingale::CGradient::get_vGrad_empty((const Nightingale::firstFwPeriodStartOutStruct *)((char *)a2 + 200))) {
    return 5;
  }
  int v4 = *((_DWORD *)a2 + 90);
  if (v4 == 1)
  {
    uint64_t v6 = *((int *)a2 + 110);
    if (v6 >= 3) {
      return 5;
    }
    return dword_257D5F730[v6];
  }
  else
  {
    if (v4 == 2) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = 5;
    }
    if (v4 == 3) {
      return 0;
    }
    else {
      return v5;
    }
  }
}

uint64_t Nightingale::ngtProjector::getCABoundedDaysBetweenTodayAndCalFwEnd(Nightingale::ngtProjector *this, int a2)
{
  if ((a2 - 3) >= 8) {
    int v2 = 11;
  }
  else {
    int v2 = a2;
  }
  if (a2 >= 3) {
    int v3 = v2;
  }
  else {
    int v3 = 2;
  }
  if (a2 >= -2) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 1;
  }
  if (a2 >= -10) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t Nightingale::ngtProjector::getCACurrentCycleFactor(uint64_t a1, unsigned __int8 **a2)
{
  int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v3 = (char *)operator new(3uLL);
  int v16 = v3 + 3;
  int v17 = v3 + 3;
  *(_WORD *)int v3 = 1541;
  v3[2] = 7;
  __n128 __p = v3;
  BOOL v4 = Nightingale::phaseFactorProcessor::vPhasesContainsVPhases((uint64_t)&v18, a2, (unsigned __int8 **)&__p);
  if (__p)
  {
    int v16 = __p;
    operator delete(__p);
  }
  if (v4)
  {
    uint64_t v5 = 3;
  }
  else
  {
    uint64_t v6 = (char *)operator new(3uLL);
    int v16 = v6 + 3;
    int v17 = v6 + 3;
    *(_WORD *)uint64_t v6 = 770;
    v6[2] = 4;
    __n128 __p = v6;
    BOOL v7 = Nightingale::phaseFactorProcessor::vPhasesContainsVPhases((uint64_t)&v18, a2, (unsigned __int8 **)&__p);
    if (__p)
    {
      int v16 = __p;
      operator delete(__p);
    }
    if (v7)
    {
      uint64_t v5 = 4;
    }
    else
    {
      int v8 = operator new(1uLL);
      __n128 __p = v8;
      unsigned char *v8 = 0;
      int v16 = v8 + 1;
      int v17 = v8 + 1;
      BOOL v9 = Nightingale::phaseFactorProcessor::vPhasesContainsVPhases((uint64_t)&v18, a2, (unsigned __int8 **)&__p);
      if (__p)
      {
        int v16 = __p;
        operator delete(__p);
      }
      if (v9)
      {
        uint64_t v5 = 1;
      }
      else
      {
        int v10 = operator new(1uLL);
        __n128 __p = v10;
        *int v10 = 1;
        int v16 = v10 + 1;
        int v17 = v10 + 1;
        BOOL v11 = Nightingale::phaseFactorProcessor::vPhasesContainsVPhases((uint64_t)&v18, a2, (unsigned __int8 **)&__p);
        if (__p)
        {
          int v16 = __p;
          operator delete(__p);
        }
        if (v11)
        {
          uint64_t v5 = 2;
        }
        else
        {
          unsigned int v12 = operator new(1uLL);
          __n128 __p = v12;
          *unsigned int v12 = 8;
          int v16 = v12 + 1;
          int v17 = v12 + 1;
          BOOL v13 = Nightingale::phaseFactorProcessor::vPhasesContainsVPhases((uint64_t)&v18, a2, (unsigned __int8 **)&__p);
          if (__p)
          {
            int v16 = __p;
            operator delete(__p);
          }
          if (v13) {
            uint64_t v5 = 5;
          }
          else {
            uint64_t v5 = 0;
          }
        }
      }
    }
  }
  if (v18)
  {
    uint64_t v19 = v18;
    operator delete(v18);
  }
  return v5;
}

void sub_257D2A348(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::ngtProjector::getCABoundedNumberOfDays(Nightingale::ngtProjector *this, unsigned int a2)
{
  if (a2 >= 0x2E) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a2;
  }
}

__n128 Nightingale::ngtProjector::getEnsembleTelemetry@<Q0>(Nightingale::ngtProjector *this@<X0>, _OWORD *a2@<X8>)
{
  long long v2 = *((_OWORD *)this + 3);
  a2[2] = *((_OWORD *)this + 2);
  a2[3] = v2;
  long long v3 = *((_OWORD *)this + 5);
  a2[4] = *((_OWORD *)this + 4);
  a2[5] = v3;
  __n128 result = *(__n128 *)this;
  long long v5 = *((_OWORD *)this + 1);
  *a2 = *(_OWORD *)this;
  a2[1] = v5;
  return result;
}

void *Nightingale::phaseFactorProjector::phaseFactorProjector(void *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

BOOL Nightingale::ngtProjector::isFinite_aProj(BOOL isFinite_aGrad, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 40))
  {
    isFinite_aGrad = Nightingale::ngtProjector::isFinite_aGrad(isFinite_aGrad, (void *)(a2 + 8));
    if (!isFinite_aGrad)
    {
      log = ha_get_log();
      BOOL result = os_log_type_enabled(log, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
      Nightingale::ngtProjector::isFinite_aProj(log);
      return 0;
    }
  }
  if (!*(unsigned char *)(a2 + 80) || Nightingale::ngtProjector::isFinite_aGrad(isFinite_aGrad, (void *)(a2 + 48))) {
    return 1;
  }
  long long v5 = ha_get_log();
  BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_FAULT);
  if (result)
  {
    Nightingale::ngtProjector::isFinite_aProj(v5);
    return 0;
  }
  return result;
}

BOOL Nightingale::phaseFactorProjector::projected1stFWFailRepro(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = operator new(6uLL);
  v14[1] = v6 + 3;
  _OWORD v14[2] = v6 + 3;
  *(_DWORD *)uint64_t v6 = 84148994;
  v6[2] = 1798;
  v14[0] = v6;
  long long v7 = *(_OWORD *)(a2 + 80);
  v12[4] = *(_OWORD *)(a2 + 64);
  v12[5] = v7;
  uint64_t v13 = *(void *)(a2 + 96);
  long long v8 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v8;
  long long v9 = *(_OWORD *)(a2 + 48);
  _OWORD v12[2] = *(_OWORD *)(a2 + 32);
  v12[3] = v9;
  BOOL v10 = Nightingale::phaseFactorProjector::failReproAProjection(a1, v12, (uint64_t)v14, a3);
  operator delete(v6);
  return v10;
}

void sub_257D2A50C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL Nightingale::phaseFactorProjector::projectedFWFailRepro(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = operator new(7uLL);
  v14[1] = (char *)v6 + 7;
  _OWORD v14[2] = (char *)v6 + 7;
  *(_DWORD *)uint64_t v6 = 67305984;
  v6[2] = 1541;
  *((unsigned char *)v6 + 6) = 7;
  v14[0] = v6;
  long long v7 = *(_OWORD *)(a2 + 80);
  v12[4] = *(_OWORD *)(a2 + 64);
  v12[5] = v7;
  uint64_t v13 = *(void *)(a2 + 96);
  long long v8 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v8;
  long long v9 = *(_OWORD *)(a2 + 48);
  _OWORD v12[2] = *(_OWORD *)(a2 + 32);
  v12[3] = v9;
  BOOL v10 = Nightingale::phaseFactorProjector::failReproAProjection(a1, v12, (uint64_t)v14, a3);
  operator delete(v6);
  return v10;
}

void sub_257D2A5D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void Nightingale::phaseFactorProjector::~phaseFactorProjector(Nightingale::phaseFactorProjector *this)
{
  long long v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  long long v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

BOOL Nightingale::phaseFactorProjector::projectedPeriodFailRepro(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  long long v5 = *(_OWORD *)(a2 + 80);
  v12[4] = *(_OWORD *)(a2 + 64);
  v12[5] = v5;
  uint64_t v13 = *(void *)(a2 + 96);
  long long v6 = *(_OWORD *)(a2 + 16);
  v12[0] = *(_OWORD *)a2;
  v12[1] = v6;
  long long v7 = *(_OWORD *)(a2 + 48);
  _OWORD v12[2] = *(_OWORD *)(a2 + 32);
  v12[3] = v7;
  long long v8 = operator new(1uLL);
  unsigned char *v8 = 0;
  v11[1] = v8 + 1;
  v11[2] = v8 + 1;
  v11[0] = v8;
  BOOL v9 = Nightingale::phaseFactorProjector::failReproAProjection(a1, v12, (uint64_t)v11, a3);
  operator delete(v8);
  return v9;
}

void sub_257D2A6B4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

BOOL Nightingale::ngtProjector::isFinite_aGrad(uint64_t a1, void *a2)
{
  if ((*a2 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    log = ha_get_log();
    BOOL result = os_log_type_enabled(log, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    Nightingale::ngtProjector::isFinite_aGrad();
    return 0;
  }
  if ((a2[1] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    BOOL v4 = ha_get_log();
    BOOL result = os_log_type_enabled(v4, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    Nightingale::ngtProjector::isFinite_aGrad();
    return 0;
  }
  if ((a2[2] & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
    long long v5 = ha_get_log();
    BOOL result = os_log_type_enabled(v5, OS_LOG_TYPE_FAULT);
    if (!result) {
      return result;
    }
    Nightingale::ngtProjector::isFinite_aGrad();
    return 0;
  }
  if ((a2[3] & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000) {
    return 1;
  }
  long long v6 = ha_get_log();
  BOOL result = os_log_type_enabled(v6, OS_LOG_TYPE_FAULT);
  if (result)
  {
    Nightingale::ngtProjector::isFinite_aGrad();
    return 0;
  }
  return result;
}

BOOL Nightingale::phaseFactorProjector::failReproAProjection(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t *a4)
{
  int v4 = a2[23];
  if (v4 < 1) {
    return 1;
  }
  uint64_t v7 = (a2[22] + *a2);
  unint64_t v8 = v7 | ((unint64_t)(v4 + v7 - 1) << 32);
  unsigned int v12 = 0;
  uint64_t v13 = 0;
  __n128 __p = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&__p, *(const void **)a3, *(void *)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  char v9 = Nightingale::phaseFactorProcessor::detectPhases(a1, v8, (uint64_t *)&__p, a4);
  if (__p)
  {
    unsigned int v12 = __p;
    operator delete(__p);
  }
  return v9 != 0;
}

void sub_257D2A8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::coreAnalyticsDayStream_t::coreAnalyticsDayStream_t(Nightingale::coreAnalyticsDayStream_t *this)
{
  *((unsigned char *)this + 8) = 0;
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + 24) = 0;
  *((unsigned char *)this + 32) = 0;
  *((unsigned char *)this + 40) = 0;
  *((unsigned char *)this + 44) = 0;
  *((unsigned char *)this + 48) = 0;
  *((unsigned char *)this + 52) = 0;
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 64) = 0;
  *((unsigned char *)this + 72) = 0;
  *((unsigned char *)this + 80) = 0;
  *((unsigned char *)this + 88) = 0;
  *((unsigned char *)this + 92) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 100) = 0;
  *((unsigned char *)this + 104) = 0;
  *((unsigned char *)this + 108) = 0;
  *((unsigned char *)this + 112) = 0;
  *((unsigned char *)this + 116) = 0;
  *((_WORD *)this + 60) = 0;
  *(void *)((char *)this + 124) = -4294967291;
  *((_DWORD *)this + 33) = 0;
  *((void *)this + 17) = -1;
  *((void *)this + 18) = -1;
  *((unsigned char *)this + 152) = 0;
  *((unsigned char *)this + 156) = 0;
  *((_DWORD *)this + 41) = -1082130432;
  *((void *)this + 21) = -1;
  *((void *)this + 22) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)((char *)this + 184) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = _Q0;
  *((_WORD *)this + 104) = 0;
  *((unsigned char *)this + 210) = 0;
  double result = NAN;
  *(_OWORD *)((char *)this + 212) = xmmword_257D5F6F0;
  *((_DWORD *)this + 57) = 9;
  return result;
}

void Nightingale::structDLIn_hr::~structDLIn_hr(Nightingale::structDLIn_hr *this)
{
  long long v2 = (void *)*((void *)this + 21);
  if (v2) {
    operator delete(v2);
  }
  long long v3 = (void *)*((void *)this + 18);
  if (v3)
  {
    *((void *)this + 19) = v3;
    operator delete(v3);
  }
  int v4 = (void *)*((void *)this + 15);
  if (v4) {
    operator delete(v4);
  }
  long long v5 = (void *)*((void *)this + 12);
  if (v5)
  {
    *((void *)this + 13) = v5;
    operator delete(v5);
  }
  long long v6 = (void *)*((void *)this + 9);
  if (v6)
  {
    *((void *)this + 10) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 6);
  if (v7)
  {
    *((void *)this + 7) = v7;
    operator delete(v7);
  }
  unint64_t v8 = (void *)*((void *)this + 3);
  if (v8)
  {
    *((void *)this + 4) = v8;
    operator delete(v8);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(104 * a2);
}

char *std::vector<Nightingale::ngt_Prediction>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::ngt_Prediction*>,std::__wrap_iter<Nightingale::ngt_Prediction*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  long long v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  uint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v11 - v12) >> 3) < a5)
  {
    uint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 > 0x276276276276276) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = 0x4EC4EC4EC4EC4EC5 * ((__dst - (uint64_t)v13) >> 3);
    unint64_t v16 = 0x4EC4EC4EC4EC4EC5 * ((v10 - (uint64_t)v13) >> 3);
    uint64_t v17 = 2 * v16;
    if (2 * v16 <= v14) {
      uint64_t v17 = v14;
    }
    if (v16 >= 0x13B13B13B13B13BLL) {
      unint64_t v18 = 0x276276276276276;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v45 = v9;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>(v9, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v32 = &v19[104 * v15];
    __n128 __p = v19;
    uint64_t v42 = v32;
    long long v44 = &v19[104 * v18];
    uint64_t v33 = 104 * a5;
    char v34 = &v32[104 * a5];
    do
    {
      long long v35 = *(_OWORD *)v7;
      long long v36 = *((_OWORD *)v7 + 2);
      *((_OWORD *)v32 + 1) = *((_OWORD *)v7 + 1);
      *((_OWORD *)v32 + 2) = v36;
      *(_OWORD *)uint64_t v32 = v35;
      long long v37 = *((_OWORD *)v7 + 3);
      long long v38 = *((_OWORD *)v7 + 4);
      long long v39 = *((_OWORD *)v7 + 5);
      *((void *)v32 + 12) = *((void *)v7 + 12);
      *((_OWORD *)v32 + 4) = v38;
      *((_OWORD *)v32 + 5) = v39;
      *((_OWORD *)v32 + 3) = v37;
      v32 += 104;
      v7 += 104;
      v33 -= 104;
    }
    while (v33);
    char v43 = v34;
    long long v5 = (char *)std::vector<Nightingale::ngt_Prediction>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v43 != v42) {
      char v43 = &v42[(v43 - v42 - 104) % 0x68uLL];
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v20 = v12 - __dst;
  if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v12 - __dst) >> 3) >= a5)
  {
    long long v21 = &__src[104 * a5];
    unsigned __int8 v23 = *(char **)(v9 - 8);
LABEL_17:
    int v24 = &v5[104 * a5];
    char v25 = &v23[-104 * a5];
    int v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      int v26 = v23;
      do
      {
        long long v27 = *(_OWORD *)v25;
        long long v28 = *((_OWORD *)v25 + 2);
        *((_OWORD *)v26 + 1) = *((_OWORD *)v25 + 1);
        *((_OWORD *)v26 + 2) = v28;
        *(_OWORD *)int v26 = v27;
        long long v29 = *((_OWORD *)v25 + 3);
        long long v30 = *((_OWORD *)v25 + 4);
        long long v31 = *((_OWORD *)v25 + 5);
        *((void *)v26 + 12) = *((void *)v25 + 12);
        *((_OWORD *)v26 + 4) = v30;
        *((_OWORD *)v26 + 5) = v31;
        *((_OWORD *)v26 + 3) = v29;
        v25 += 104;
        v26 += 104;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v5[104 * a5], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  long long v21 = &__src[8 * ((uint64_t)(v12 - __dst) >> 3)];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * ((uint64_t)(v12 - __dst) >> 3)], a4 - v21);
  }
  unsigned __int8 v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v20 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_257D2AD14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<Nightingale::ngt_Prediction>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  long long v5 = *(void **)(a2 + 8);
  long long v6 = (char *)*a1;
  uint64_t v7 = v5;
  if (*a1 != __src)
  {
    unint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      long long v10 = *(_OWORD *)(v8 - 104);
      long long v11 = *(_OWORD *)(v8 - 88);
      *(_OWORD *)(v9 - 72) = *(_OWORD *)(v8 - 72);
      *(_OWORD *)(v9 - 88) = v11;
      *(_OWORD *)(v9 - 104) = v10;
      long long v12 = *(_OWORD *)(v8 - 56);
      long long v13 = *(_OWORD *)(v8 - 40);
      long long v14 = *(_OWORD *)(v8 - 24);
      uint64_t v7 = (void *)(v9 - 104);
      *(void *)(v9 - 8) = *((void *)v8 - 1);
      *(_OWORD *)(v9 - 24) = v14;
      *(_OWORD *)(v9 - 40) = v13;
      *(_OWORD *)(v9 - 56) = v12;
      v8 -= 104;
      v9 -= 104;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v15 = a1[1];
  uint64_t v16 = *(void *)(a2 + 16);
  int64_t v17 = v15 - __src;
  if (v15 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v15 - __src);
    uint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v16 + v17;
  unint64_t v18 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v18;
  uint64_t v19 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v19;
  uint64_t v20 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v20;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

Nightingale::firstFwPeriodStartOutStruct *Nightingale::firstFwPeriodStartOutStruct::firstFwPeriodStartOutStruct(Nightingale::firstFwPeriodStartOutStruct *this)
{
  *(unsigned char *)this = 0;
  *((unsigned char *)this + 4) = 0;
  *((void *)this + 1) = 3;
  Nightingale::CGradient::CGradient((uint64_t)this + 16);
  *((unsigned char *)this + 72) = 0;
  *((unsigned char *)this + 76) = 0;
  *((unsigned char *)this + 80) = 0;
  *((unsigned char *)this + 84) = 0;
  *((unsigned char *)this + 88) = 0;
  *((unsigned char *)this + 92) = 0;
  Nightingale::CGradient::CGradient((uint64_t)this + 96);
  *((unsigned char *)this + 152) = 0;
  *((unsigned char *)this + 156) = 0;
  *((unsigned char *)this + 160) = 0;
  *((unsigned char *)this + 164) = 0;
  *((unsigned char *)this + 168) = 0;
  *((unsigned char *)this + 172) = 0;
  *((void *)this + 22) = 3;
  *((unsigned char *)this + 184) = 0;
  *((unsigned char *)this + 188) = 0;
  *((void *)this + 24) = 3;
  Nightingale::CGradient::CGradient((uint64_t)this + 200);
  *((unsigned char *)this + 256) = 0;
  *((unsigned char *)this + 260) = 0;
  *((unsigned char *)this + 264) = 0;
  *((unsigned char *)this + 268) = 0;
  *((unsigned char *)this + 272) = 0;
  *((unsigned char *)this + 276) = 0;
  Nightingale::CGradient::CGradient((uint64_t)this + 280);
  *((unsigned char *)this + 336) = 0;
  *((unsigned char *)this + 340) = 0;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 348) = 0;
  *((unsigned char *)this + 352) = 0;
  *((unsigned char *)this + 356) = 0;
  *((void *)this + 45) = 3;
  *((_DWORD *)this + 92) = 8;
  *((_WORD *)this + 186) = 0;
  *((unsigned char *)this + 374) = 0;
  *((void *)this + 47) = -1;
  *((unsigned char *)this + 388) = 0;
  *((unsigned char *)this + 392) = 0;
  *((void *)this + 51) = 0;
  *((void *)this + 52) = 0;
  *((void *)this + 50) = 0;
  *((_DWORD *)this + 106) = -1;
  *((unsigned char *)this + 428) = 0;
  *((unsigned char *)this + 432) = 0;
  *((_DWORD *)this + 111) = -1082130432;
  *((void *)this + 56) = -1;
  *((void *)this + 57) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *((_OWORD *)this + 29) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *((void *)this + 60) = _Q0;
  *((unsigned char *)this + 488) = 0;
  *((unsigned char *)this + 492) = 0;
  *((unsigned char *)this + 496) = 0;
  *((unsigned char *)this + 500) = 0;
  *((_DWORD *)this + 126) = 0;
  *((unsigned char *)this + 512) = 0;
  *((unsigned char *)this + 604) = 0;
  return this;
}

void sub_257D2AFC0(_Unwind_Exception *a1)
{
  long long v3 = v2;
  long long v5 = *v3;
  if (*v3)
  {
    *((void *)v1 + 26) = v5;
    operator delete(v5);
  }
  Nightingale::fwPeriodEstimateStruct::~fwPeriodEstimateStruct(v1);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__assign_with_size[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(void **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5) < a4)
  {
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vdeallocate((void **)a1);
    if (a4 > 0x199999999999999) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x999999999999999ALL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 5) >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v11 = 0x199999999999999;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(v8, a2, a3, *(void *)(a1 + 8));
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 5) < a4)
  {
    uint64_t v13 = a2 + 32 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 5);
    std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,0>(a2, v13, (uint64_t)v9);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(v8, v13, a3, *(void *)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,0>(a2, a3, (uint64_t)v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 160;
      std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(v16);
    }
    while (v16 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_257D2B16C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_257D2B174(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vdeallocate(void **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = (uint64_t)a1[1];
    int v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 160;
        std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(v3);
      }
      while ((void *)v3 != v1);
      int v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  double result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[160 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100](a4 + v7, a2 + v7);
      v7 += 160;
    }
    while (a2 + v7 != a3);
    a4 += v7;
  }
  return a4;
}

void sub_257D2B298(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 - 160;
    do
    {
      std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(v4 + v2);
      v2 -= 160;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  long long v4 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v4;
  long long v5 = *(_OWORD *)(a2 + 56);
  uint64_t v6 = *(void *)(a2 + 69);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 69) = v6;
  *(_OWORD *)(a1 + 56) = v5;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 80), *(const void **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  long long v7 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 113) = *(_OWORD *)(a2 + 113);
  *(_OWORD *)(a1 + 104) = v7;
  long long v8 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 149) = *(void *)(a2 + 149);
  *(_OWORD *)(a1 + 136) = v8;
  return a1;
}

void sub_257D2B35C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    *(void *)(a1 + 88) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v3;
    operator delete(v3);
  }
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct> *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 != a2)
  {
    do
    {
      std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::operator=[abi:ne180100](a3, v4);
      v4 += 160;
      a3 += 160;
    }
    while (v4 != a2);
    return a2;
  }
  return v4;
}

uint64_t std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::operator=[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a1 == a2)
  {
    long long v6 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v6;
    long long v7 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 69) = *(void *)(a2 + 69);
    *(_OWORD *)(a1 + 56) = v7;
  }
  else
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    long long v4 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
    *(_OWORD *)(a1 + 24) = v4;
    long long v5 = *(_OWORD *)(a2 + 56);
    *(void *)(a1 + 69) = *(void *)(a2 + 69);
    *(_OWORD *)(a1 + 56) = v5;
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)(a1 + 80), *(char **)(a2 + 80), *(void *)(a2 + 88), (uint64_t)(*(void *)(a2 + 88) - *(void *)(a2 + 80)) >> 2);
  }
  long long v8 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(a1 + 113) = *(_OWORD *)(a2 + 113);
  *(_OWORD *)(a1 + 104) = v8;
  long long v9 = *(_OWORD *)(a2 + 136);
  *(void *)(a1 + 149) = *(void *)(a2 + 149);
  *(_OWORD *)(a1 + 136) = v9;
  return a1;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x19999999999999ALL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(160 * a2);
}

void std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    long long v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 160;
        std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(v4);
      }
      while ((void *)v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100]<true,0>(uint64_t a1)
{
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v2 = (_OWORD *)Nightingale::CGradient::CGradient(a1);
  v2[5] = 0u;
  v2 += 5;
  *((unsigned char *)v2 - 24) = 0;
  *((unsigned char *)v2 - 20) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  *((unsigned char *)v2 - 12) = 0;
  *((unsigned char *)v2 - 8) = 0;
  *((unsigned char *)v2 - 4) = 0;
  v2[1] = 0u;
  v2[2] = 0u;
  v2[3] = 0u;
  v2[4] = 0u;
  Nightingale::CGradient::CGradient((uint64_t)v2);
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 148) = 0;
  *(unsigned char *)(a1 + 152) = 0;
  *(unsigned char *)(a1 + 156) = 0;
  return a1;
}

void sub_257D2B634(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100]<Nightingale::periodEstimationOutStruct&,Nightingale::periodEstimationOutStruct&,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  long long v6 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v6;
  long long v7 = *(_OWORD *)(a2 + 56);
  uint64_t v8 = *(void *)(a2 + 69);
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 69) = v8;
  *(_OWORD *)(a1 + 56) = v7;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 80), *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  long long v9 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(a1 + 113) = *(_OWORD *)(a3 + 33);
  *(_OWORD *)(a1 + 104) = v9;
  long long v10 = *(_OWORD *)(a3 + 56);
  *(void *)(a1 + 149) = *(void *)(a3 + 69);
  *(_OWORD *)(a1 + 136) = v10;
  return a1;
}

void sub_257D2B6FC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void OUTLINED_FUNCTION_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void OUTLINED_FUNCTION_1(uint64_t a1@<X8>)
{
  *(void *)(v1 - 8) = a1;
}

void Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fw_dl_tmp_process(Nightingale::ngt_luna_fw_dl_tmp_process *this, const Nightingale::ngt_Config *a2)
{
}

void sub_257D2B7A4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::FwPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::FwPredictorWrapper_t::init(Nightingale::FwPredictorWrapper_t *this, const Nightingale::ngt_Config *a2)
{
  if (*((char *)a2 + 191) >= 0) {
    uint64_t v4 = (char *)a2 + 168;
  }
  else {
    uint64_t v4 = (char *)*((void *)a2 + 21);
  }
  long long v5 = [NSString stringWithUTF8String:v4];
  uint64_t v8 = (char *)*((void *)a2 + 24);
  long long v7 = (char *)a2 + 192;
  long long v6 = v8;
  if (v7[23] >= 0) {
    uint64_t v9 = v7;
  }
  else {
    uint64_t v9 = v6;
  }
  long long v10 = [NSString stringWithUTF8String:v9];
  unint64_t v11 = [NSURL fileURLWithPath:v5];
  uint64_t v12 = [NSURL fileURLWithPath:v10];
  uint64_t v13 = objc_opt_new();
  uint64_t v14 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v13;

  if (!*((void *)this + 3)) {
    goto LABEL_16;
  }
  uint64_t v15 = objc_opt_new();
  uint64_t v16 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v15;

  if (!*((void *)this + 2)) {
    goto LABEL_16;
  }
  [*((id *)this + 3) setComputeUnits:0];
  id v41 = 0;
  uint64_t v17 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BC48 dataType:65600 error:&v41];
  id v18 = v41;
  uint64_t v19 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v17;

  if (!*((void *)this + 1)) {
    goto LABEL_18;
  }
  uint64_t v20 = [fwEnddet_lstm alloc];
  uint64_t v21 = *((void *)this + 3);
  id v40 = v18;
  uint64_t v22 = [(fwEnddet_lstm *)v20 initWithContentsOfURL:v11 configuration:v21 error:&v40];
  id v23 = v40;

  int v24 = (void *)*((void *)this + 7);
  *((void *)this + 7) = v22;

  if (!v23)
  {
    uint64_t v26 = objc_opt_new();
    long long v27 = (void *)*((void *)this + 3);
    *((void *)this + 3) = v26;

    if (*((void *)this + 3))
    {
      uint64_t v28 = objc_opt_new();
      long long v29 = (void *)*((void *)this + 2);
      *((void *)this + 2) = v28;

      if (*((void *)this + 2))
      {
        [*((id *)this + 3) setComputeUnits:0];
        id v39 = 0;
        uint64_t v30 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BC60 dataType:65600 error:&v39];
        id v18 = v39;
        long long v31 = *(void **)this;
        *(void *)this = v30;

        if (*(void *)this)
        {
          uint64_t v32 = [fwEnddet_rf alloc];
          uint64_t v33 = *((void *)this + 3);
          id v38 = v18;
          uint64_t v34 = [(fwEnddet_rf *)v32 initWithContentsOfURL:v12 configuration:v33 error:&v38];
          id v35 = v38;

          long long v36 = (void *)*((void *)this + 5);
          *((void *)this + 5) = v34;

          BOOL v25 = v35 == 0;
          id v18 = v35;
          goto LABEL_17;
        }
LABEL_18:
        BOOL v25 = 0;
        goto LABEL_17;
      }
    }
LABEL_16:
    BOOL v25 = 0;
    id v18 = 0;
    goto LABEL_17;
  }
  BOOL v25 = 0;
  id v18 = v23;
LABEL_17:

  return v25;
}

void sub_257D2BA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_luna_fw_dl_tmp_process::~ngt_luna_fw_dl_tmp_process(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::FwPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::FwPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fwEndDetRF(void **a1, uint64_t *a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::FwPredictorWrapper_t::predict_fwEndDetRF(void *a1, uint64_t *a2, uint64_t a3)
{
  std::vector<double>::vector(&__p, 0x11uLL);
  uint64_t v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = (char *)__p;
  do
  {
    *(void *)&v8[v6] = *(void *)(v7 + v6);
    v6 += 8;
  }
  while (v6 != 136);
  uint64_t v9 = v59;
  long long v10 = (void *)[(id)*a1 dataPointer];
  if (v9 != v8) {
    memmove(v10, v8, v9 - v8);
  }
  unint64_t v11 = [[fwEnddet_rfInput alloc] initWithInput:*a1];
  uint64_t v12 = (void *)a1[4];
  a1[4] = v11;

  uint64_t v13 = [(id)a1[5] model];
  uint64_t v14 = a1[4];
  uint64_t v15 = a1[2];
  id v57 = 0;
  uint64_t v16 = [v13 predictionFromFeatures:v14 options:v15 error:&v57];
  id v17 = v57;

  id v18 = [fwEnddet_rfOutput alloc];
  uint64_t v19 = [v16 featureValueForName:@"classLabel"];
  uint64_t v20 = [v19 int64Value];
  uint64_t v21 = [v16 featureValueForName:@"classProbability"];
  uint64_t v22 = [v21 dictionaryValue];
  id v23 = [(fwEnddet_rfOutput *)v18 initWithClassLabel:v20 classProbability:v22];

  int v24 = [(fwEnddet_rfOutput *)v23 classProbability];
  BOOL v25 = [v24 objectForKeyedSubscript:&unk_27069BE10];
  [v25 doubleValue];
  float v27 = v26;
  unint64_t v28 = *(void *)(a3 + 16);
  long long v29 = *(float **)(a3 + 8);
  if ((unint64_t)v29 >= v28)
  {
    long long v31 = *(float **)a3;
    uint64_t v32 = ((uint64_t)v29 - *(void *)a3) >> 2;
    unint64_t v33 = v32 + 1;
    if ((unint64_t)(v32 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v34 = v28 - (void)v31;
    if (v34 >> 1 > v33) {
      unint64_t v33 = v34 >> 1;
    }
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v35 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v33;
    }
    if (v35)
    {
      long long v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v35);
      long long v31 = *(float **)a3;
      long long v29 = *(float **)(a3 + 8);
    }
    else
    {
      long long v36 = 0;
    }
    long long v37 = (float *)&v36[4 * v32];
    id v38 = &v36[4 * v35];
    *long long v37 = v27;
    uint64_t v30 = v37 + 1;
    while (v29 != v31)
    {
      int v39 = *((_DWORD *)v29-- - 1);
      *((_DWORD *)v37-- - 1) = v39;
    }
    *(void *)a3 = v37;
    *(void *)(a3 + 8) = v30;
    *(void *)(a3 + 16) = v38;
    if (v31) {
      operator delete(v31);
    }
  }
  else
  {
    *long long v29 = v27;
    uint64_t v30 = v29 + 1;
  }
  *(void *)(a3 + 8) = v30;

  id v40 = [(fwEnddet_rfOutput *)v23 classProbability];
  id v41 = [v40 objectForKeyedSubscript:&unk_27069BDC8];
  [v41 doubleValue];
  float v43 = v42;
  uint64_t v45 = *(float **)(a3 + 8);
  unint64_t v44 = *(void *)(a3 + 16);
  if ((unint64_t)v45 >= v44)
  {
    int v47 = *(float **)a3;
    uint64_t v48 = ((uint64_t)v45 - *(void *)a3) >> 2;
    unint64_t v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v50 = v44 - (void)v47;
    if (v50 >> 1 > v49) {
      unint64_t v49 = v50 >> 1;
    }
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v51 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v49;
    }
    if (v51)
    {
      char v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v51);
      int v47 = *(float **)a3;
      uint64_t v45 = *(float **)(a3 + 8);
    }
    else
    {
      char v52 = 0;
    }
    char v53 = (float *)&v52[4 * v48];
    int v54 = &v52[4 * v51];
    *char v53 = v43;
    uint64_t v46 = v53 + 1;
    while (v45 != v47)
    {
      int v55 = *((_DWORD *)v45-- - 1);
      *((_DWORD *)v53-- - 1) = v55;
    }
    *(void *)a3 = v53;
    *(void *)(a3 + 8) = v46;
    *(void *)(a3 + 16) = v54;
    if (v47) {
      operator delete(v47);
    }
  }
  else
  {
    *uint64_t v45 = v43;
    uint64_t v46 = v45 + 1;
  }
  *(void *)(a3 + 8) = v46;

  if (__p)
  {
    char v59 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D2BEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fwEndFlagDLTmp(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::FwPredictorWrapper_t::predict_fwEndFlagDLTmp(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::vector<double>::vector(&__p, 0x2DuLL);
  uint64_t v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = (char *)__p;
  do
  {
    *(void *)&v8[v6] = *(void *)(v7 + v6);
    v6 += 8;
  }
  while (v6 != 360);
  uint64_t v9 = v45;
  long long v10 = (void *)[*(id *)(a1 + 8) dataPointer];
  if (v9 != v8) {
    memmove(v10, v8, v9 - v8);
  }
  unint64_t v11 = [[fwEnddet_lstmInput alloc] initWithIn:*(void *)(a1 + 8) lstm_1_h_in:0 lstm_1_c_in:0];
  uint64_t v12 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = v11;

  uint64_t v13 = [*(id *)(a1 + 56) model];
  uint64_t v14 = *(void *)(a1 + 48);
  uint64_t v15 = *(void *)(a1 + 16);
  id v43 = 0;
  uint64_t v16 = [v13 predictionFromFeatures:v14 options:v15 error:&v43];
  id v42 = v43;

  id v17 = [fwEnddet_lstmOutput alloc];
  id v18 = [v16 featureValueForName:@"out"];
  uint64_t v19 = [v18 multiArrayValue];
  uint64_t v20 = [v16 featureValueForName:@"lstm_1_h_out"];
  uint64_t v21 = [v20 multiArrayValue];
  uint64_t v22 = [v16 featureValueForName:@"lstm_1_c_out"];
  id v23 = [v22 multiArrayValue];
  int v24 = [(fwEnddet_lstmOutput *)v17 initWithOut:v19 lstm_1_h_out:v21 lstm_1_c_out:v23];

  for (uint64_t i = 0; i != 34; ++i)
  {
    double v26 = [(fwEnddet_lstmOutput *)v24 out];
    float v27 = [v26 objectAtIndexedSubscript:i];
    [v27 doubleValue];
    float v29 = v28;
    long long v31 = *(float **)(a3 + 8);
    unint64_t v30 = *(void *)(a3 + 16);
    if ((unint64_t)v31 >= v30)
    {
      unint64_t v33 = *(float **)a3;
      uint64_t v34 = ((uint64_t)v31 - *(void *)a3) >> 2;
      unint64_t v35 = v34 + 1;
      if ((unint64_t)(v34 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v36 = v30 - (void)v33;
      if (v36 >> 1 > v35) {
        unint64_t v35 = v36 >> 1;
      }
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v37 = v35;
      }
      if (v37)
      {
        id v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v37);
        unint64_t v33 = *(float **)a3;
        long long v31 = *(float **)(a3 + 8);
      }
      else
      {
        id v38 = 0;
      }
      int v39 = (float *)&v38[4 * v34];
      float *v39 = v29;
      uint64_t v32 = v39 + 1;
      while (v31 != v33)
      {
        int v40 = *((_DWORD *)v31-- - 1);
        *((_DWORD *)v39-- - 1) = v40;
      }
      *(void *)a3 = v39;
      *(void *)(a3 + 8) = v32;
      *(void *)(a3 + 16) = &v38[4 * v37];
      if (v33) {
        operator delete(v33);
      }
    }
    else
    {
      *long long v31 = v29;
      uint64_t v32 = v31 + 1;
    }
    *(void *)(a3 + 8) = v32;
  }
  if (__p)
  {
    uint64_t v45 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D2C248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void Nightingale::ngt_luna_period_dl_tmp_process::ngt_luna_period_dl_tmp_process(Nightingale::ngt_luna_period_dl_tmp_process *this, const Nightingale::ngt_Config *a2)
{
}

void sub_257D2C360(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::PeriodPredictorWrapper_t::init(Nightingale::PeriodPredictorWrapper_t *this, const Nightingale::ngt_Config *a2)
{
  long long v5 = (char *)*((void *)a2 + 18);
  uint64_t v3 = (char *)a2 + 144;
  uint64_t v4 = v5;
  if (v3[23] >= 0) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v4;
  }
  uint64_t v7 = [NSString stringWithUTF8String:v6];
  uint64_t v8 = [NSURL fileURLWithPath:v7];
  uint64_t v9 = objc_opt_new();
  long long v10 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v9;

  if (*((void *)this + 2)
    && (uint64_t v11 = objc_opt_new(),
        uint64_t v12 = (void *)*((void *)this + 1),
        *((void *)this + 1) = v11,
        v12,
        *((void *)this + 1)))
  {
    [*((id *)this + 2) setComputeUnits:0];
    id v24 = 0;
    uint64_t v13 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BC78 dataType:65600 error:&v24];
    id v14 = v24;
    uint64_t v15 = *(void **)this;
    *(void *)this = v13;

    if (*(void *)this)
    {
      uint64_t v16 = [period_lstm alloc];
      uint64_t v17 = *((void *)this + 2);
      id v23 = v14;
      uint64_t v18 = [(period_lstm *)v16 initWithContentsOfURL:v8 configuration:v17 error:&v23];
      id v19 = v23;

      uint64_t v20 = (void *)*((void *)this + 4);
      *((void *)this + 4) = v18;

      BOOL v21 = v19 == 0;
      id v14 = v19;
    }
    else
    {
      BOOL v21 = 0;
    }
  }
  else
  {
    BOOL v21 = 0;
    id v14 = 0;
  }

  return v21;
}

void sub_257D2C510(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_luna_period_dl_tmp_process::~ngt_luna_period_dl_tmp_process(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_luna_period_dl_tmp_process::ngt_luna_periodRegressorLSTM(void **a1, uint64_t **a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::PeriodPredictorWrapper_t::predict_periodRegressorLSTM(void *a1, uint64_t **a2, uint64_t a3)
{
  std::vector<double>::vector(&__p, 0xB4uLL);
  uint64_t v6 = 0;
  uint64_t v7 = a2[9];
  uint64_t v8 = (char *)__p;
  uint64_t v9 = *a2;
  long long v10 = a2[3];
  uint64_t v11 = a2[6];
  do
  {
    uint64_t v12 = *v7++;
    uint64_t v13 = &v8[v6];
    *(void *)uint64_t v13 = v12;
    uint64_t v14 = *v9++;
    *((void *)v13 + 1) = v14;
    uint64_t v15 = *v10++;
    *((void *)v13 + 2) = v15;
    uint64_t v16 = *v11++;
    *((void *)v13 + 3) = v16;
    v6 += 32;
  }
  while (v6 != 1440);
  uint64_t v17 = v53;
  uint64_t v18 = (void *)[(id)*a1 dataPointer];
  if (v17 != v8) {
    memmove(v18, v8, v17 - v8);
  }
  id v19 = [[period_lstmInput alloc] initWithIn:*a1 lstm_1_h_in:0 lstm_1_c_in:0];
  uint64_t v20 = (void *)a1[3];
  a1[3] = v19;

  BOOL v21 = [(id)a1[4] model];
  uint64_t v22 = a1[3];
  uint64_t v23 = a1[1];
  id v51 = 0;
  id v24 = [v21 predictionFromFeatures:v22 options:v23 error:&v51];
  id v50 = v51;

  BOOL v25 = [period_lstmOutput alloc];
  double v26 = [v24 featureValueForName:@"out"];
  float v27 = [v26 multiArrayValue];
  double v28 = [v24 featureValueForName:@"lstm_1_h_out"];
  float v29 = [v28 multiArrayValue];
  unint64_t v30 = [v24 featureValueForName:@"lstm_1_c_out"];
  long long v31 = [v30 multiArrayValue];
  uint64_t v32 = [(period_lstmOutput *)v25 initWithOut:v27 lstm_1_h_out:v29 lstm_1_c_out:v31];

  for (uint64_t i = 0; i != 32; ++i)
  {
    uint64_t v34 = [(period_lstmOutput *)v32 out];
    unint64_t v35 = [v34 objectAtIndexedSubscript:i];
    [v35 doubleValue];
    float v37 = v36;
    int v39 = *(float **)(a3 + 8);
    unint64_t v38 = *(void *)(a3 + 16);
    if ((unint64_t)v39 >= v38)
    {
      id v41 = *(float **)a3;
      uint64_t v42 = ((uint64_t)v39 - *(void *)a3) >> 2;
      unint64_t v43 = v42 + 1;
      if ((unint64_t)(v42 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v44 = v38 - (void)v41;
      if (v44 >> 1 > v43) {
        unint64_t v43 = v44 >> 1;
      }
      if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v45 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v45 = v43;
      }
      if (v45)
      {
        uint64_t v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v45);
        id v41 = *(float **)a3;
        int v39 = *(float **)(a3 + 8);
      }
      else
      {
        uint64_t v46 = 0;
      }
      int v47 = (float *)&v46[4 * v42];
      *int v47 = v37;
      int v40 = v47 + 1;
      while (v39 != v41)
      {
        int v48 = *((_DWORD *)v39-- - 1);
        *((_DWORD *)v47-- - 1) = v48;
      }
      *(void *)a3 = v47;
      *(void *)(a3 + 8) = v40;
      *(void *)(a3 + 16) = &v46[4 * v45];
      if (v41) {
        operator delete(v41);
      }
    }
    else
    {
      float *v39 = v37;
      int v40 = v39 + 1;
    }
    *(void *)(a3 + 8) = v40;
  }
  if (__p)
  {
    char v53 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D2C8B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double Nightingale::FwPredictorWrapper_t::FwPredictorWrapper_t(Nightingale::FwPredictorWrapper_t *this)
{
  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  double result = 0.0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

double Nightingale::PeriodPredictorWrapper_t::PeriodPredictorWrapper_t(Nightingale::PeriodPredictorWrapper_t *this)
{
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void *std::vector<double>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::optional<float>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_257D2CA10(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::default_delete<Nightingale::FwPredictorWrapper_t>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (a2)
  {

    JUMPOUT(0x25A2C1380);
  }
}

void std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100](uint64_t a1, id *a2)
{
  if (a2)
  {

    JUMPOUT(0x25A2C1380);
  }
}

uint64_t Nightingale::uiLogProcessor::uiLogProcessor(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = (char *)operator new(3uLL);
  *(void *)(a1 + 8) = v4 + 3;
  *(void *)(a1 + 16) = v4 + 3;
  *(_WORD *)uint64_t v4 = 1798;
  v4[2] = 5;
  *(void *)a1 = v4;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 32) = 0x3F80000040400000;
  if ((a2 & 0xFF00000000) != 0)
  {
    BOOL v5 = *(float *)&a2 > 17.0;
    BOOL v6 = *(float *)&a2 < 45.0;
    float v7 = 36.0;
    if (v5 && v6) {
      float v7 = 16.0;
    }
    float v8 = 9.0;
    if (v5 && v6) {
      float v8 = 4.0;
    }
  }
  else
  {
    float v8 = 4.0;
    float v7 = 16.0;
  }
  *(float *)(a1 + 24) = v7;
  *(float *)(a1 + 28) = v8;
  return a1;
}

{
  char *v4;
  BOOL v5;
  BOOL v6;
  float v7;
  float v8;

  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v4 = (char *)operator new(3uLL);
  *(void *)(a1 + 8) = v4 + 3;
  *(void *)(a1 + 16) = v4 + 3;
  *(_WORD *)uint64_t v4 = 1798;
  v4[2] = 5;
  *(void *)a1 = v4;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 32) = 0x3F80000040400000;
  if ((a2 & 0xFF00000000) != 0)
  {
    BOOL v5 = *(float *)&a2 > 17.0;
    BOOL v6 = *(float *)&a2 < 45.0;
    float v7 = 36.0;
    if (v5 && v6) {
      float v7 = 16.0;
    }
    float v8 = 9.0;
    if (v5 && v6) {
      float v8 = 4.0;
    }
  }
  else
  {
    float v8 = 4.0;
    float v7 = 16.0;
  }
  *(float *)(a1 + 24) = v7;
  *(float *)(a1 + 28) = v8;
  return a1;
}

Nightingale::uiLogProcessor *Nightingale::uiLogProcessor::uiLogProcessor(Nightingale::uiLogProcessor *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v2 = (char *)operator new(3uLL);
  *((void *)this + 1) = v2 + 3;
  *((void *)this + 2) = v2 + 3;
  *(_WORD *)uint64_t v2 = 1798;
  v2[2] = 5;
  *(void *)this = v2;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((void *)this + 23) = 0;
  *((void *)this + 4) = 0x3F80000040400000;
  return this;
}

{
  char *v2;

  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v2 = (char *)operator new(3uLL);
  *((void *)this + 1) = v2 + 3;
  *((void *)this + 2) = v2 + 3;
  *(_WORD *)uint64_t v2 = 1798;
  v2[2] = 5;
  *(void *)this = v2;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = 0;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *((void *)this + 23) = 0;
  *((void *)this + 4) = 0x3F80000040400000;
  return this;
}

void Nightingale::uiLogProcessor::~uiLogProcessor(Nightingale::uiLogProcessor *this)
{
  uint64_t v2 = (void *)*((void *)this + 21);
  if (v2)
  {
    *((void *)this + 22) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 18);
  if (v3)
  {
    *((void *)this + 19) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 15);
  if (v4)
  {
    *((void *)this + 16) = v4;
    operator delete(v4);
  }
  BOOL v5 = (void *)*((void *)this + 12);
  if (v5)
  {
    *((void *)this + 13) = v5;
    operator delete(v5);
  }
  BOOL v6 = (void *)*((void *)this + 9);
  if (v6)
  {
    *((void *)this + 10) = v6;
    operator delete(v6);
  }
  float v7 = (void *)*((void *)this + 5);
  if (v7)
  {
    *((void *)this + 6) = v7;
    operator delete(v7);
  }
  float v8 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v8;
    operator delete(v8);
  }
}

void Nightingale::uiLogProcessor::guardConfig(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(a2 + 4) || !*(unsigned char *)(a2 + 12)) {
    goto LABEL_11;
  }
  int v3 = *(_DWORD *)(a2 + 8);
  if (*(_DWORD *)a2 > v3)
  {
    if (v3) {
      goto LABEL_11;
    }
    uint64_t v4 = (unsigned char *)(a2 + 28);
    int v5 = *(unsigned __int8 *)(a2 + 28);
    *(unsigned char *)(a2 + 12) = 0;
    if (!v5) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  *(unsigned char *)(a2 + 4) = 0;
  *(unsigned char *)(a2 + 12) = 0;
  if (*(unsigned char *)(a2 + 28)) {
    *(unsigned char *)(a2 + 28) = 0;
  }
  uint64_t v4 = (unsigned char *)(a2 + 20);
  if (*(unsigned char *)(a2 + 20)) {
LABEL_10:
  }
    unsigned char *v4 = 0;
LABEL_11:
  BOOL v6 = (_DWORD *)(a2 + 40);
  if (!*(unsigned char *)(a2 + 44) || (*(unsigned char *)(a3 + 36) ? (BOOL v7 = *v6 < *(_DWORD *)(a3 + 32)) : (BOOL v7 = 0), v7))
  {
    int v8 = *(_DWORD *)(a3 + 32);
    *(unsigned char *)(a2 + 44) = *(unsigned char *)(a3 + 36);
    _DWORD *v6 = v8;
  }
  uint64_t v9 = (_DWORD *)(a2 + 32);
  if (!*(unsigned char *)(a2 + 36) || *(unsigned char *)(a3 + 20) && *v9 < *(_DWORD *)(a3 + 16))
  {
    int v10 = *(_DWORD *)(a3 + 16);
    *(unsigned char *)(a2 + 36) = *(unsigned char *)(a3 + 20);
    _DWORD *v9 = v10;
  }
  if (!*(unsigned char *)(a2 + 52))
  {
    *(unsigned char *)(a2 + 52) = 1;
    *(_DWORD *)(a2 + 48) = 1106247680;
  }
}

void Nightingale::uiLogProcessor::periodListToCycleInfo(uint64_t a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  LOBYTE(v14) = 0;
  char v15 = 0;
  char v16 = 0;
  char v17 = 0;
  char v18 = 0;
  char v19 = 0;
  char v21 = 0;
  char v22 = 0;
  char v23 = 0;
  char v24 = 0;
  char v25 = 0;
  char v26 = 0;
  char v27 = 0;
  char v28 = 0;
  char v29 = 0;
  char v30 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  __n128 __p = 0;
  uint64_t v4 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      int v10 = (int *)(v4 + v8);
      int v13 = *v10;
      int v14 = v10[1];
      char v15 = 1;
      if (a3[1] <= v9) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      char v20 = (*(void *)(*a3 + ((v9 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v9) & 1;
      unint64_t v11 = a4[1];
      if (v11 >= a4[2])
      {
        uint64_t v12 = std::vector<Nightingale::cycleInfo>::__push_back_slow_path<Nightingale::cycleInfo const&>(a4, (uint64_t)&v13);
      }
      else
      {
        std::vector<Nightingale::cycleInfo>::__construct_one_at_end[abi:ne180100]<Nightingale::cycleInfo const&>((uint64_t)a4, (uint64_t)&v13);
        uint64_t v12 = v11 + 96;
      }
      a4[1] = v12;
      ++v9;
      uint64_t v4 = *a2;
      v8 += 8;
    }
    while (v9 < (a2[1] - *a2) >> 3);
    if (__p)
    {
      uint64_t v32 = __p;
      operator delete(__p);
    }
  }
}

void sub_257D2D0D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::extractPeriods(uint64_t a1, uint64_t a2, int **a3, int a4, uint64_t *a5, uint64_t *a6)
{
  BOOL v7 = *(_DWORD **)a2;
  if (*(void *)(a2 + 8) != *(void *)a2)
  {
    unint64_t v101 = 0;
    unint64_t v102 = 0;
    uint64_t v103 = 0;
    unint64_t v98 = 0;
    int v99 = 0;
    unint64_t v100 = 0;
    uint64_t v95 = 0;
    uint64_t v96 = 0;
    uint64_t v97 = 0;
    long long v92 = 0;
    uint64_t v93 = 0;
    unint64_t v94 = 0;
    unint64_t v11 = *a3;
    LODWORD(v12) = *v7;
    BOOL v91 = *v7 - a4 >= 10;
    std::vector<BOOL>::push_back((uint64_t)&v95, &v91);
    long long v81 = a6;
    long long v82 = a5;
    int v80 = a4;
    int v13 = *(_DWORD **)(a2 + 8);
    if (v7 == v13)
    {
      uint64_t v16 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v14 = 0xFFFFFFFFLL;
      do
      {
        int v15 = *v11++;
        if ((v15 - 1) > 3)
        {
          uint64_t v16 = v14;
        }
        else
        {
          uint64_t v16 = *v7;
          if (v14 == -1) {
            uint64_t v17 = v16;
          }
          else {
            uint64_t v17 = v14;
          }
          if (v14 == -1) {
            uint64_t v12 = v16;
          }
          else {
            uint64_t v12 = v12;
          }
          if ((int)v16 - (int)v17 >= 3)
          {
            char v18 = v93;
            if ((unint64_t)v93 >= v94)
            {
              int64_t v20 = (v93 - (unsigned char *)v92) >> 3;
              if ((unint64_t)(v20 + 1) >> 61) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              unint64_t v21 = (uint64_t)(v94 - (void)v92) >> 2;
              if (v21 <= v20 + 1) {
                unint64_t v21 = v20 + 1;
              }
              if (v94 - (unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v22 = v21;
              }
              if (v22) {
                char v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)&v94, v22);
              }
              else {
                char v23 = 0;
              }
              char v24 = (uint64_t *)&v23[8 * v20];
              *char v24 = v12 | (v17 << 32);
              char v19 = v24 + 1;
              char v26 = (uint64_t *)v92;
              char v25 = (uint64_t *)v93;
              if (v93 != v92)
              {
                do
                {
                  uint64_t v27 = *--v25;
                  *--char v24 = v27;
                }
                while (v25 != v26);
                char v25 = (uint64_t *)v92;
              }
              long long v92 = v24;
              uint64_t v93 = (char *)v19;
              unint64_t v94 = (unint64_t)&v23[8 * v22];
              if (v25) {
                operator delete(v25);
              }
            }
            else
            {
              *(void *)uint64_t v93 = v12 | (v17 << 32);
              char v19 = (uint64_t *)(v18 + 8);
            }
            uint64_t v93 = (char *)v19;
            int v13 = *(_DWORD **)(a2 + 8);
            LODWORD(v12) = v16;
          }
        }
        ++v7;
        uint64_t v14 = v16;
      }
      while (v7 != v13);
    }
    char v28 = v93;
    if ((unint64_t)v93 >= v94)
    {
      int64_t v31 = (v93 - (unsigned char *)v92) >> 3;
      if ((unint64_t)(v31 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v32 = (uint64_t)(v94 - (void)v92) >> 2;
      if (v32 <= v31 + 1) {
        unint64_t v32 = v31 + 1;
      }
      if (v94 - (unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v33 = v32;
      }
      if (v33) {
        uint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)&v94, v33);
      }
      else {
        uint64_t v34 = 0;
      }
      unint64_t v35 = (uint64_t *)&v34[8 * v31];
      double v36 = &v34[8 * v33];
      *unint64_t v35 = v12 | (unint64_t)(v16 << 32);
      char v29 = v35 + 1;
      unint64_t v38 = (uint64_t *)v92;
      float v37 = (uint64_t *)v93;
      if (v93 == v92)
      {
        char v30 = v82;
      }
      else
      {
        char v30 = v82;
        do
        {
          uint64_t v39 = *--v37;
          *--unint64_t v35 = v39;
        }
        while (v37 != v38);
        float v37 = (uint64_t *)v92;
      }
      long long v92 = v35;
      uint64_t v93 = (char *)v29;
      unint64_t v94 = (unint64_t)v36;
      if (v37) {
        operator delete(v37);
      }
    }
    else
    {
      *(void *)uint64_t v93 = v12 | (unint64_t)(v16 << 32);
      char v29 = (uint64_t *)(v28 + 8);
      char v30 = v82;
    }
    uint64_t v93 = (char *)v29;
    Nightingale::uiCycleFactorProcess::suppressPeriodReproductive((uint64_t)&v101, (uint64_t **)&v92, v30);
    int v40 = v92;
    if (v93 == v92)
    {
      std::vector<Nightingale::cycleInfo>::__clear[abi:ne180100](v81);
    }
    else
    {
      id v41 = v99;
      if ((unint64_t)v99 >= v100)
      {
        int64_t v44 = (v99 - v98) >> 3;
        if ((unint64_t)(v44 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v45 = (uint64_t)(v100 - (void)v98) >> 2;
        if (v45 <= v44 + 1) {
          unint64_t v45 = v44 + 1;
        }
        if (v100 - (unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v46 = v45;
        }
        if (v46) {
          int v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)&v100, v46);
        }
        else {
          int v47 = 0;
        }
        int v48 = &v47[8 * v44];
        unint64_t v49 = &v47[8 * v46];
        *(void *)int v48 = *v40;
        uint64_t v42 = (uint64_t *)(v48 + 8);
        id v51 = v98;
        id v50 = (uint64_t *)v99;
        if (v99 == v98)
        {
          unint64_t v43 = v81;
        }
        else
        {
          unint64_t v43 = v81;
          do
          {
            uint64_t v52 = *--v50;
            *((void *)v48 - 1) = v52;
            v48 -= 8;
          }
          while (v50 != (uint64_t *)v51);
          id v50 = (uint64_t *)v98;
        }
        unint64_t v98 = v48;
        int v99 = (char *)v42;
        unint64_t v100 = (unint64_t)v49;
        if (v50) {
          operator delete(v50);
        }
      }
      else
      {
        *(void *)int v99 = *(void *)v92;
        uint64_t v42 = (uint64_t *)(v41 + 8);
        unint64_t v43 = v81;
      }
      int v99 = (char *)v42;
      if ((unint64_t)(v93 - (unsigned char *)v92) < 9)
      {
        std::vector<std::pair<int,int>>::__assign_with_size[abi:ne180100]<std::pair<int,int>*,std::pair<int,int>*>(&v98, (uint64_t *)v92, (uint64_t *)v93, (unint64_t)(v93 - (unsigned char *)v92) >> 3);
        long long v88 = 0;
        long long v89 = 0;
        uint64_t v90 = 0;
        std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>((char *)&v88, (uint64_t *)v98, (uint64_t *)v99, (v99 - v98) >> 3);
        long long v79 = std::vector<BOOL>::vector(v87, (uint64_t)&v95);
        Nightingale::uiLogProcessor::periodListToCycleInfo((uint64_t)v79, (uint64_t *)&v88, v87, v43);
        if (v87[0]) {
          operator delete(v87[0]);
        }
        long long v78 = v88;
        if (!v88) {
          goto LABEL_128;
        }
        long long v89 = v88;
      }
      else
      {
        char v53 = (uint64_t *)((char *)v92 + 8);
        if ((char *)v92 + 8 != v93)
        {
          int v54 = *(_DWORD *)v92;
          while (1)
          {
            int v55 = *(_DWORD *)v53;
            if (*(_DWORD *)v53 - v54 >= 10) {
              break;
            }
            if (((*(void *)((char *)v95 + (((unint64_t)(v96 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v96 - 1)) & 1) == 0)
            {
              uint64_t v58 = v99;
              if ((unint64_t)v99 >= v100)
              {
                int64_t v64 = (v99 - v98) >> 3;
                if ((unint64_t)(v64 + 1) >> 61) {
LABEL_138:
                }
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                unint64_t v65 = (uint64_t)(v100 - (void)v98) >> 2;
                if (v65 <= v64 + 1) {
                  unint64_t v65 = v64 + 1;
                }
                if (v100 - (unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v66 = v65;
                }
                if (v66) {
                  long long v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)&v100, v66);
                }
                else {
                  long long v67 = 0;
                }
                long long v72 = (uint64_t *)&v67[8 * v64];
                uint64_t *v72 = *v53;
                char v59 = v72 + 1;
                long long v74 = v98;
                long long v73 = (uint64_t *)v99;
                if (v99 != v98)
                {
                  do
                  {
                    uint64_t v75 = *--v73;
                    *--long long v72 = v75;
                  }
                  while (v73 != (uint64_t *)v74);
                  long long v73 = (uint64_t *)v98;
                }
                unint64_t v98 = (char *)v72;
                int v99 = (char *)v59;
                unint64_t v100 = (unint64_t)&v67[8 * v66];
                if (v73) {
                  operator delete(v73);
                }
              }
              else
              {
                *(void *)int v99 = *v53;
                char v59 = (uint64_t *)(v58 + 8);
              }
              int v99 = (char *)v59;
              BOOL v91 = 0;
              std::vector<BOOL>::push_back((uint64_t)&v95, &v91);
              goto LABEL_114;
            }
LABEL_115:
            if (++v53 == (uint64_t *)v93) {
              goto LABEL_116;
            }
          }
          long long v56 = v99;
          if ((unint64_t)v99 >= v100)
          {
            int64_t v60 = (v99 - v98) >> 3;
            if ((unint64_t)(v60 + 1) >> 61) {
              goto LABEL_138;
            }
            unint64_t v61 = (uint64_t)(v100 - (void)v98) >> 2;
            if (v61 <= v60 + 1) {
              unint64_t v61 = v60 + 1;
            }
            if (v100 - (unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v62 = v61;
            }
            if (v62) {
              long long v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)&v100, v62);
            }
            else {
              long long v63 = 0;
            }
            BOOL v68 = (uint64_t *)&v63[8 * v60];
            *BOOL v68 = *v53;
            id v57 = v68 + 1;
            long long v70 = v98;
            uint64_t v69 = (uint64_t *)v99;
            if (v99 != v98)
            {
              do
              {
                uint64_t v71 = *--v69;
                *--BOOL v68 = v71;
              }
              while (v69 != (uint64_t *)v70);
              uint64_t v69 = (uint64_t *)v98;
            }
            unint64_t v98 = (char *)v68;
            int v99 = (char *)v57;
            unint64_t v100 = (unint64_t)&v63[8 * v62];
            if (v69) {
              operator delete(v69);
            }
          }
          else
          {
            *(void *)int v99 = *v53;
            id v57 = (uint64_t *)(v56 + 8);
          }
          int v99 = (char *)v57;
          BOOL v91 = 1;
          std::vector<BOOL>::push_back((uint64_t)&v95, &v91);
LABEL_114:
          int v54 = v55;
          goto LABEL_115;
        }
LABEL_116:
        uint64_t v76 = (uint64_t *)v98;
        if ((*(void *)v95 & 1) == 0 && *(_DWORD *)v98 - v80 >= 10) {
          *(void *)v95 |= 1uLL;
        }
        long long v84 = 0;
        uint64_t v85 = 0;
        uint64_t v86 = 0;
        std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>((char *)&v84, v76, (uint64_t *)v99, (v99 - (char *)v76) >> 3);
        long long v77 = std::vector<BOOL>::vector(__p, (uint64_t)&v95);
        Nightingale::uiLogProcessor::periodListToCycleInfo((uint64_t)v77, (uint64_t *)&v84, __p, v43);
        if (__p[0]) {
          operator delete(__p[0]);
        }
        long long v78 = v84;
        if (!v84) {
          goto LABEL_128;
        }
        uint64_t v85 = (uint64_t)v84;
      }
      operator delete(v78);
    }
LABEL_128:
    if (v92)
    {
      uint64_t v93 = (char *)v92;
      operator delete(v92);
    }
    if (v95) {
      operator delete(v95);
    }
    if (v98)
    {
      int v99 = v98;
      operator delete(v98);
    }
    if (v101)
    {
      unint64_t v102 = v101;
      operator delete(v101);
    }
    return;
  }
  std::vector<Nightingale::cycleInfo>::__clear[abi:ne180100](a6);
}

void sub_257D2D7E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,uint64_t a28,void *a29)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  if (a26) {
    operator delete(a26);
  }
  if (a29) {
    operator delete(a29);
  }
  int64_t v31 = *(void **)(v29 - 136);
  if (v31)
  {
    *(void *)(v29 - 128) = v31;
    operator delete(v31);
  }
  unint64_t v32 = *(void **)(v29 - 112);
  if (v32)
  {
    *(void *)(v29 - 104) = v32;
    operator delete(v32);
  }
  _Unwind_Resume(exception_object);
}

void *Nightingale::uiCycleFactorProcess::uiCycleFactorProcess(void *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

uint64_t **Nightingale::uiCycleFactorProcess::suppressPeriodReproductive(uint64_t a1, uint64_t **a2, uint64_t *a3)
{
  unint64_t v21 = 0;
  unint64_t v22 = 0;
  uint64_t v23 = 0;
  std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>((char *)&v21, *a2, a2[1], a2[1] - *a2);
  BOOL v6 = v22;
  if (v22 != v21)
  {
    unint64_t v7 = 0;
    int v8 = 0;
    BOOL v6 = v21;
    do
    {
      unint64_t v9 = v6[v7];
      __n128 __p = 0;
      char v19 = 0;
      int64_t v20 = 0;
      int v10 = operator new(1uLL);
      __n128 __p = v10;
      *int v10 = 0;
      char v19 = v10 + 1;
      int64_t v20 = v10 + 1;
      int v11 = Nightingale::phaseFactorProcessor::detectPhases(a1, v9, (uint64_t *)&__p, a3);
      if (__p)
      {
        char v19 = __p;
        operator delete(__p);
      }
      BOOL v12 = (v11 & 0xFF00) != 0 || v11 == 0;
      if (v12 && (v11 & 0xFFFFFFu) < 0x10000)
      {
        ++v8;
      }
      else
      {
        int v13 = a2[1];
        uint64_t v14 = (uint64_t)&(*a2)[v8];
        int v15 = (uint64_t *)(v14 + 8);
        if ((uint64_t *)(v14 + 8) != v13)
        {
          uint64_t v14 = (uint64_t)&(*a2)[v8];
          do
          {
            int v16 = *((_DWORD *)v15 + 1);
            *((_DWORD *)v15 - 2) = *(_DWORD *)v15;
            *((_DWORD *)v15++ - 1) = v16;
            v14 += 8;
          }
          while (v15 != v13);
        }
        a2[1] = (uint64_t *)v14;
      }
      ++v7;
      BOOL v6 = v21;
    }
    while (v7 < v22 - v21);
  }
  if (v6)
  {
    unint64_t v22 = v6;
    operator delete(v6);
  }
  return a2;
}

void sub_257D2D9F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiCycleFactorProcess::~uiCycleFactorProcess(Nightingale::uiCycleFactorProcess *this)
{
  uint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  uint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

void Nightingale::uiLogProcessor::addCycleEnd(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1] - *a2;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (v3 >> 5);
  if (v4 >= 2 && v3 != 96)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      if (v4 <= ++v6) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v7 = v2 + v5;
      *(_DWORD *)(v7 + 20) = *(_DWORD *)(v7 + 96) - 1;
      *(unsigned char *)(v7 + 24) = 1;
      uint64_t v2 = *a2;
      unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5);
      v5 += 96;
    }
    while (v4 - 1 > v6);
  }
}

void Nightingale::uiLogProcessor::opk2Cycles(uint64_t a1, uint64_t *a2, void *a3)
{
  uint64_t v3 = a3[1];
  if (*a3 != v3)
  {
    uint64_t v5 = *a2;
    uint64_t v4 = a2[1];
    if (v4 != *a2)
    {
      unint64_t v6 = 0;
      int v7 = 0;
      while (1)
      {
        if (*(_DWORD *)(v5 + 60 * v6 + 12) == 2)
        {
          unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a3) >> 5);
          unint64_t v9 = v8 - 1;
          if (v8 - 1 > v7)
          {
            uint64_t v10 = 0;
            int v11 = *(_DWORD *)(v5 + 60 * v6);
            if (v8 <= v7) {
              unint64_t v8 = v7;
            }
            unint64_t v12 = v7 - v8;
            int v13 = (unsigned char *)(*a3 + 96 * v7 + 24);
            while (1)
            {
              if (!(v12 + v10)) {
                std::vector<int>::__throw_out_of_range[abi:ne180100]();
              }
              BOOL v14 = *v13 && v11 <= *((_DWORD *)v13 - 1);
              if (v14 && v11 >= *((_DWORD *)v13 - 6)) {
                break;
              }
              ++v10;
              v13 += 96;
              if (v9 <= v7 + v10) {
                goto LABEL_17;
              }
            }
            *((_DWORD *)v13 - 3) = v11;
            *(v13 - 8) = 1;
            v7 += v10 + 1;
            uint64_t v5 = *a2;
            uint64_t v4 = a2[1];
          }
LABEL_17:
          if (0xEEEEEEEEEEEEEEEFLL * ((v4 - v5) >> 2) <= v6) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          int v15 = *(_DWORD *)(v5 + 60 * v6);
          uint64_t v3 = a3[1];
          if (v15 >= *(_DWORD *)(v3 - 96)) {
            break;
          }
        }
        if (0xEEEEEEEEEEEEEEEFLL * ((v4 - v5) >> 2) <= ++v6) {
          return;
        }
      }
      *(_DWORD *)(v3 - 84) = v15;
      *(unsigned char *)(v3 - 80) = 1;
    }
  }
}

uint64_t Nightingale::uiLogProcessor::getJDayLastNoFlowAftLastPeriodStart(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a2[1] - *a2) >> 2);
  if ((int)v4 < 1)
  {
LABEL_7:
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v5 = -286331153 * ((a2[1] - *a2) >> 2) + 1;
    while (1)
    {
      unint64_t v6 = (v5 - 2);
      if (v4 <= v6) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (*(_DWORD *)(v3 + 60 * v6 + 4) == 5)
      {
        uint64_t v7 = *(unsigned int *)(v3 + 60 * v6);
        if ((int)v7 > *(_DWORD *)(*(void *)(a3 + 8) - 96)) {
          break;
        }
      }
      if ((unint64_t)--v5 <= 1) {
        goto LABEL_7;
      }
    }
    uint64_t v8 = 0x100000000;
  }
  return v7 | v8;
}

uint64_t Nightingale::uiLogProcessor::getJDay1stOPKAftLastPeriodStart(uint64_t a1, unsigned int **a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * (a2[1] - *a2);
  if ((int)v4 < 1)
  {
LABEL_7:
    uint64_t v7 = 0;
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v5 = -286331153 * (a2[1] - *a2);
    while (1)
    {
      if (!v4) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (v3[3] == 2)
      {
        uint64_t v6 = *v3;
        if ((int)v6 >= *(_DWORD *)(*(void *)(a3 + 8) - 96)) {
          break;
        }
      }
      --v4;
      v3 += 15;
      if (!--v5) {
        goto LABEL_7;
      }
    }
    uint64_t v7 = 0x100000000;
  }
  return v6 | v7;
}

uint64_t Nightingale::uiLogProcessor::get_jDayLastOPKPosBfr1stPeriodSt(uint64_t a1, int a2, void *a3)
{
  uint64_t v3 = (_DWORD *)*a3;
  unint64_t v4 = (_DWORD *)a3[1];
  if ((_DWORD *)*a3 != v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = (_DWORD *)*a3;
    while (*v6 != a2)
    {
      v6 += 15;
      ++v5;
      if (v6 == v4) {
        return 0xFFFFFFFFLL;
      }
    }
    if (v5)
    {
      unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (v4 - v3);
      while (v5-- >= 1)
      {
        if (v7 <= v5) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        if (v3[15 * v5 + 3] == 2) {
          return v3[15 * v5];
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void Nightingale::uiLogProcessor::getJDay1stFlow(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t v3 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a2[1] - *a2) >> 2);
  if ((int)v3 >= 1)
  {
    uint64_t v4 = -286331153 * ((uint64_t)(a2[1] - *a2) >> 2);
    for (uint64_t i = (_DWORD *)(*a2 + 4); ; i += 15)
    {
      if (!v3) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if ((*i - 1) <= 4) {
        break;
      }
      --v3;
      if (!--v4) {
        return;
      }
    }
    *(_DWORD *)(a3 + 8) = *(i - 1);
    *(unsigned char *)(a3 + 12) = 1;
  }
}

void Nightingale::uiLogProcessor::getJDayLastFlowNoFlow(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = (a2[1] - *a2) / 60;
  uint64_t v5 = v4;
  uint64_t v6 = *a2 + 60 * v4;
  uint64_t v7 = v4;
  while ((int)v7 >= 1)
  {
    if (v4 <= --v7) {
LABEL_17:
    }
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    uint64_t v8 = (_DWORD *)(v6 - 60);
    int v9 = *(_DWORD *)(v6 - 56);
    v6 -= 60;
    if (v9 == 5)
    {
      *(_DWORD *)(a3 + 24) = *v8;
      *(unsigned char *)(a3 + 28) = 1;
      uint64_t v3 = *a2;
      unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a2[1] - *a2) >> 2);
      uint64_t v5 = -286331153 * ((a2[1] - *a2) >> 2);
      break;
    }
  }
  uint64_t v10 = v3 + 60 * v5;
  uint64_t v11 = v5;
  while ((int)v11 >= 1)
  {
    if (v4 <= --v11) {
      goto LABEL_17;
    }
    unint64_t v12 = (_DWORD *)(v10 - 60);
    unsigned int v13 = *(_DWORD *)(v10 - 56) - 1;
    v10 -= 60;
    if (v13 <= 4)
    {
      *(_DWORD *)(a3 + 32) = *v12;
      *(unsigned char *)(a3 + 36) = 1;
      uint64_t v3 = *a2;
      unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a2[1] - *a2) >> 2);
      uint64_t v5 = -286331153 * ((a2[1] - *a2) >> 2);
      break;
    }
  }
  uint64_t v14 = v3 + 60 * v5;
  while ((int)v5 >= 1)
  {
    if (v4 <= --v5) {
      goto LABEL_17;
    }
    int v15 = (_DWORD *)(v14 - 60);
    unsigned int v16 = *(_DWORD *)(v14 - 56) - 1;
    v14 -= 60;
    if (v16 <= 3)
    {
      *(_DWORD *)(a3 + 40) = *v15;
      *(unsigned char *)(a3 + 44) = 1;
      return;
    }
  }
}

void Nightingale::uiLogProcessor::getJDayFirstOPK(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(_DWORD **)a2;
  uint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  if (v4)
  {
    unint64_t v5 = v4 / 60;
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    while (v3[3] != 2)
    {
      v3 += 15;
      if (!--v5) {
        return;
      }
    }
    *(_DWORD *)(a3 + 48) = *v3;
    *(unsigned char *)(a3 + 52) = 1;
  }
}

void Nightingale::uiLogProcessor::getJDayUILog(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v7 = std::vector<Nightingale::cycleInfo>::__init_with_size[abi:ne180100]<Nightingale::cycleInfo*,Nightingale::cycleInfo*>(&v23, *(void *)a4, *(void *)(a4 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 5));
  uint64_t v8 = v23;
  if (v24 != v23)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v24 - v23) >> 5);
    *(_DWORD *)(a4 + 80) = *(_DWORD *)(v24 - 96);
    *(unsigned char *)(a4 + 84) = 1;
    if (v9 >= 2)
    {
      *(_DWORD *)(a4 + 88) = *(_DWORD *)(v8 + 96 * v9 - 192);
      *(unsigned char *)(a4 + 92) = 1;
    }
  }
  uint64_t JDayLastNoFlowAftLastPeriodStart = Nightingale::uiLogProcessor::getJDayLastNoFlowAftLastPeriodStart((uint64_t)v7, a2, (uint64_t)&v23);
  uint64_t JDay1stOPKAftLastPeriodStart = Nightingale::uiLogProcessor::getJDay1stOPKAftLastPeriodStart(JDayLastNoFlowAftLastPeriodStart, (unsigned int **)a2, (uint64_t)&v23);
  Nightingale::uiLogProcessor::getJDay1stFlow(JDay1stOPKAftLastPeriodStart, a2, a4 + 24);
  unsigned int v13 = (_DWORD *)*a2;
  uint64_t v14 = a2[1] - *a2;
  if (v14)
  {
    unint64_t v15 = v14 / 60;
    if (v15 <= 1) {
      unint64_t v15 = 1;
    }
    while (v13[3] != 2)
    {
      v13 += 15;
      if (!--v15) {
        goto LABEL_11;
      }
    }
    *(_DWORD *)(a4 + 72) = *v13;
    *(unsigned char *)(a4 + 76) = 1;
  }
LABEL_11:
  Nightingale::uiLogProcessor::getJDayLastFlowNoFlow(v12, a2, a4 + 24);
  if (BYTE4(JDayLastNoFlowAftLastPeriodStart))
  {
    int v16 = JDay1stOPKAftLastPeriodStart + 9;
    if ((int)JDay1stOPKAftLastPeriodStart + 9 <= (int)JDayLastNoFlowAftLastPeriodStart) {
      int v16 = JDayLastNoFlowAftLastPeriodStart;
    }
    if (BYTE4(JDay1stOPKAftLastPeriodStart)) {
      int v17 = v16;
    }
    else {
      int v17 = JDayLastNoFlowAftLastPeriodStart;
    }
    if (BYTE4(JDay1stOPKAftLastPeriodStart)) {
      char v18 = 1;
    }
    else {
      char v18 = BYTE4(JDayLastNoFlowAftLastPeriodStart);
    }
  }
  else
  {
    if (!BYTE4(JDay1stOPKAftLastPeriodStart)) {
      goto LABEL_23;
    }
    int v17 = JDay1stOPKAftLastPeriodStart + 9;
    char v18 = 1;
  }
  *(_DWORD *)(a4 + 112) = v17;
  *(unsigned char *)(a4 + 116) = v18;
LABEL_23:
  *(_DWORD *)(a4 + 96) = JDayLastNoFlowAftLastPeriodStart;
  *(unsigned char *)(a4 + 100) = BYTE4(JDayLastNoFlowAftLastPeriodStart);
  *(_DWORD *)(a4 + 104) = JDay1stOPKAftLastPeriodStart;
  *(unsigned char *)(a4 + 108) = BYTE4(JDay1stOPKAftLastPeriodStart);
  int64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v22 = 0;
  Nightingale::phaseFactorProcessor::getCCVec(__p);
  *(void *)(a4 + 120) = Nightingale::phaseFactorProcessor::jDayFirstStartLastEndOfAPhaseSet((uint64_t)&v20, a3, (unsigned __int8 **)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v20)
  {
    unint64_t v21 = v20;
    operator delete(v20);
  }
  int64_t v20 = &v23;
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v20);
}

void sub_257D2E238(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char *a13, char *a14, uint64_t a15, char a16)
{
  if (__p) {
    operator delete(__p);
  }
  if (a13)
  {
    a14 = a13;
    operator delete(a13);
  }
  a13 = &a16;
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a13);
  _Unwind_Resume(a1);
}

void Nightingale::uiLogProcessor::getInPeriodNow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(*(void *)(a2 + 8) - 92);
  *(unsigned char *)(a2 + 128) = 0;
  if (*(unsigned char *)(a3 + 44)) {
    BOOL v4 = (v3 & 0xFF00000000) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v5 = *(_DWORD *)(a3 + 40);
    if (v5 == v3) {
      goto LABEL_11;
    }
    if (!*(unsigned char *)(a2 + 52))
    {
      if (v5 != v3 + 1) {
        return;
      }
      goto LABEL_11;
    }
    if (v5 == v3 + 1 && v5 != *(_DWORD *)(a2 + 48)) {
LABEL_11:
    }
      *(unsigned char *)(a2 + 128) = 1;
  }
}

uint64_t Nightingale::uiLogProcessor::getNumPeriodsToKeepUR(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v4 = *(_DWORD **)a3;
  uint64_t v3 = *(_DWORD **)(a3 + 8);
  uint64_t result = -1431655765 * (((unint64_t)v3 - *(void *)a3) >> 5);
  if (result && v4 != v3)
  {
    int v6 = *(_DWORD *)(a2 + 24);
    do
    {
      if (*(unsigned char *)(a2 + 28))
      {
        uint64_t result = result - (*v4 <= v6);
        if (*v4 > v6) {
          break;
        }
      }
      v4 += 24;
    }
    while (v4 != v3);
  }
  return result;
}

unint64_t Nightingale::uiLogProcessor::getWhatShouldBeInSlideCC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 5);
  if (!v5)
  {
LABEL_21:
    uint64_t v8 = 1;
    return v8 | (v5 << 32);
  }
  if (HIDWORD(a4) != -2)
  {
    if (HIDWORD(a4) != -1 && (int)v5 >= 1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = (unsigned char *)(v4 + 8);
      uint64_t v8 = 1;
      while (1)
      {
        if (!(v5 + v6)) {
          goto LABEL_23;
        }
        if (*v7 && *((_DWORD *)v7 - 1) >= SHIDWORD(a4)) {
          break;
        }
        --v6;
        v7 += 96;
        if (-(uint64_t)v5 == v6)
        {
          unint64_t v5 = 0;
          return v8 | (v5 << 32);
        }
      }
      unint64_t v5 = (v5 + v6);
    }
    goto LABEL_21;
  }
  if (v5 == 1) {
    goto LABEL_12;
  }
  if ((int)v5 < 2) {
    goto LABEL_16;
  }
  unint64_t v9 = (v5 - 2);
  if (v5 <= v9) {
LABEL_23:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  if (*(_DWORD *)(v4 + 96 * v9) < (int)a4)
  {
LABEL_12:
    uint64_t v8 = 2;
    unint64_t v5 = 2;
  }
  else
  {
LABEL_16:
    if ((int)v5 >= 2) {
      unint64_t v5 = 2;
    }
    else {
      unint64_t v5 = v5;
    }
    uint64_t v8 = 3;
  }
  return v8 | (v5 << 32);
}

void Nightingale::uiLogProcessor::removeOutlier(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v3 = *(void **)a1;
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v6 = (v4 - (uint64_t)v3) >> 2;
  if ((unint64_t)(v4 - (void)v3) > 0xB)
  {
    __n128 __p = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v3, v4, v6);
    Nightingale::get_mad((float **)&__p, 1);
    if (__p)
    {
      uint64_t v8 = __p;
      operator delete(__p);
    }
    Nightingale::vMedian<double>();
  }
  if (a2 != a1) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a2, (char *)v3, v4, v6);
  }
}

void sub_257D2E614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  unsigned int v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::genPeriodSlide(uint64_t *a1@<X1>, int a2@<W2>, uint64_t a3@<X3>, int a4@<W4>, float **a5@<X8>)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  int v6 = -1431655765 * ((unint64_t)(a1[1] - *a1) >> 5);
  if (v6)
  {
    uint64_t v7 = a3;
    int v8 = v6 - a2;
    int v9 = v6 - a4;
    if (v6 - a2 >= v6 - a4)
    {
      char v26 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      uint64_t v12 = a5 + 2;
      unint64_t v13 = v8;
      do
      {
        uint64_t v14 = *a1;
        if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5) <= v13) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v15 = v14 + 96 * v13;
        if (*(unsigned char *)(v15 + 8))
        {
          float v16 = (float)(*(_DWORD *)(v15 + 4) - *(_DWORD *)(v14 + 96 * v13) + 1);
          if ((unint64_t)v11 >= *v12)
          {
            char v18 = *a5;
            uint64_t v19 = v11 - *a5;
            unint64_t v20 = v19 + 1;
            if ((unint64_t)(v19 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v21 = *v12 - (void)v18;
            if (v21 >> 1 > v20) {
              unint64_t v20 = v21 >> 1;
            }
            if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v22 = v20;
            }
            if (v22)
            {
              uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a5 + 2), v22);
              char v18 = *a5;
              uint64_t v11 = a5[1];
            }
            else
            {
              uint64_t v23 = 0;
            }
            uint64_t v24 = (float *)&v23[4 * v19];
            *uint64_t v24 = v16;
            int v17 = v24 + 1;
            while (v11 != v18)
            {
              int v25 = *((_DWORD *)v11-- - 1);
              *((_DWORD *)v24-- - 1) = v25;
            }
            *a5 = v24;
            a5[1] = v17;
            a5[2] = (float *)&v23[4 * v22];
            if (v18) {
              operator delete(v18);
            }
          }
          else
          {
            float *v11 = v16;
            int v17 = v11 + 1;
          }
          a5[1] = v17;
          uint64_t v11 = v17;
        }
        ++v13;
      }
      while (v9 != v13);
      char v26 = *a5;
      uint64_t v7 = a3;
    }
    uint64_t v27 = a5 + 1;
    if ((unint64_t)((char *)v11 - (char *)v26) > 0x30 && ((char *)v11 - (char *)v26) << 30 != 0xC00000000)
    {
      char v28 = (float *)((char *)v26 + (((((char *)v11 - (char *)v26) << 30) - 0xC00000000) >> 30));
      int64_t v29 = (char *)v11 - (char *)v28;
      if (v11 != v28) {
        memmove(v26, v28, (char *)v11 - (char *)v28);
      }
      uint64_t v11 = (float *)((char *)v26 + v29);
      *uint64_t v27 = (float *)((char *)v26 + v29);
    }
    if (*(unsigned char *)(v7 + 12)) {
      float v30 = (float)*(int *)(v7 + 8);
    }
    else {
      float v30 = 5.0;
    }
    unint64_t v31 = (unint64_t)a5[2];
    if ((unint64_t)v11 >= v31)
    {
      unint64_t v33 = *a5;
      uint64_t v34 = v11 - *a5;
      unint64_t v35 = v34 + 1;
      if ((unint64_t)(v34 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v36 = v31 - (void)v33;
      if (v36 >> 1 > v35) {
        unint64_t v35 = v36 >> 1;
      }
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v37 = v35;
      }
      if (v37)
      {
        unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a5 + 2), v37);
        unint64_t v33 = *a5;
        uint64_t v11 = a5[1];
      }
      else
      {
        unint64_t v38 = 0;
      }
      uint64_t v39 = (float *)&v38[4 * v34];
      int v40 = (float *)&v38[4 * v37];
      float *v39 = v30;
      unint64_t v32 = v39 + 1;
      while (v11 != v33)
      {
        int v41 = *((_DWORD *)v11-- - 1);
        *((_DWORD *)v39-- - 1) = v41;
      }
      *a5 = v39;
      a5[1] = v32;
      a5[2] = v40;
      if (v33) {
        operator delete(v33);
      }
    }
    else
    {
      float *v11 = v30;
      unint64_t v32 = v11 + 1;
    }
    *uint64_t v27 = v32;
    log = ha_get_log();
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide();
    }
    if ((char *)a5[1] - (char *)*a5 != 4)
    {
      unint64_t v43 = 0;
      do
      {
        int64_t v44 = ha_get_log();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          if (v43 >= a5[1] - *a5) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v45 = (*a5)[v43];
          *(_DWORD *)buf = 134217984;
          *(double *)&buf[4] = v45;
          _os_log_debug_impl(&dword_257C1A000, v44, OS_LOG_TYPE_DEBUG, "%3.1f, ", buf, 0xCu);
        }
        ++v43;
      }
      while (v43 < a5[1] - *a5 - 1);
    }
    unint64_t v46 = ha_get_log();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide(a5 + 1);
    }
    Nightingale::uiLogProcessor::removeOutlier((uint64_t)a5, (uint64_t)buf);
    int v47 = *a5;
    if (*a5)
    {
      a5[1] = v47;
      operator delete(v47);
      *a5 = 0;
      a5[1] = 0;
      a5[2] = 0;
    }
    *(_OWORD *)a5 = *(_OWORD *)buf;
    a5[2] = v55;
    int v48 = ha_get_log();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide();
    }
    if ((char *)a5[1] - (char *)*a5 != 4)
    {
      unint64_t v49 = 0;
      do
      {
        id v50 = ha_get_log();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          if (v49 >= a5[1] - *a5) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v51 = (*a5)[v49];
          *(_DWORD *)buf = 134217984;
          *(double *)&buf[4] = v51;
          _os_log_debug_impl(&dword_257C1A000, v50, OS_LOG_TYPE_DEBUG, "%3.1f, ", buf, 0xCu);
        }
        ++v49;
      }
      while (v49 < a5[1] - *a5 - 1);
    }
    uint64_t v52 = ha_get_log();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide(a5 + 1);
    }
  }
}

void sub_257D2EB64(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::uiLogProcessor::vecPhaseContains(uint64_t a1, unsigned __int8 **a2, int a3)
{
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1] - *a2;
  if (!v4) {
    return 0;
  }
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = a2[1] - *a2;
  }
  if (*v3 == a3) {
    return 1;
  }
  uint64_t v7 = 1;
  do
  {
    unint64_t v8 = v7;
    if (v5 == v7) {
      break;
    }
    int v9 = v3[v7++];
  }
  while (v9 != a3);
  return v4 > v8;
}

void Nightingale::uiLogProcessor::genCycleSlide(uint64_t *a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, _DWORD *a4@<X4>, char a5@<W5>, uint64_t a6@<X8>)
{
  __p[3] = *(void **)MEMORY[0x263EF8340];
  *(void *)a6 = 0;
  *(void *)(a6 + 8) = 0;
  *(void *)(a6 + 16) = 0;
  int v7 = -1431655765 * ((unint64_t)(a1[1] - *a1) >> 5);
  if (!v7) {
    return;
  }
  char v8 = a5;
  int v9 = a4;
  int v11 = a2;
  if (a2 != 1 && a2 != 3)
  {
    if (a2 == 2)
    {
      unint64_t v13 = 0;
      unint64_t v14 = 0;
      uint64_t v15 = (float **)(a6 + 8);
      goto LABEL_55;
    }
    int v41 = 0;
    goto LABEL_66;
  }
  int v16 = v7 - 1;
  if (v7 - HIDWORD(a2) < v7 - 1)
  {
    for (unint64_t i = v7 - HIDWORD(a2); v16 != i; ++i)
    {
      uint64_t v18 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5) <= i) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      memset(__p, 0, 24);
      std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(__p, *(const void **)(v18 + 96 * i + 72), *(void *)(v18 + 96 * i + 80), *(void *)(v18 + 96 * i + 80) - *(void *)(v18 + 96 * i + 72));
      uint64_t v19 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5) <= i) {
LABEL_126:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      long long v92 = 0;
      uint64_t v93 = 0;
      uint64_t v94 = 0;
      std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v92, *(const void **)(v19 + 96 * i + 72), *(void *)(v19 + 96 * i + 80), *(void *)(v19 + 96 * i + 80) - *(void *)(v19 + 96 * i + 72));
      unint64_t v20 = v93 - v92;
      if (v93 == v92)
      {
        BOOL v25 = 0;
        if (!v92) {
          goto LABEL_24;
        }
      }
      else
      {
        if (v20 <= 1) {
          uint64_t v21 = 1;
        }
        else {
          uint64_t v21 = v93 - v92;
        }
        if (*v92)
        {
          unint64_t v22 = 0;
          uint64_t v23 = v21 - 1;
          while (v23 != v22)
          {
            if (!v92[++v22])
            {
              BOOL v25 = v20 > v22;
              goto LABEL_23;
            }
          }
          BOOL v25 = 0;
        }
        else
        {
          BOOL v25 = 1;
        }
      }
LABEL_23:
      uint64_t v93 = v92;
      operator delete(v92);
LABEL_24:
      uint64_t v26 = *a1;
      if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5) <= i) {
        goto LABEL_126;
      }
      uint64_t v27 = v26 + 96 * i;
      if (*(unsigned char *)(v27 + 24)) {
        char v28 = v25;
      }
      else {
        char v28 = 1;
      }
      if ((v28 & 1) == 0)
      {
        float v29 = (float)(*(_DWORD *)(v27 + 20) - *(_DWORD *)(v26 + 96 * i) + 1);
        unint64_t v31 = *(float **)(a6 + 8);
        unint64_t v30 = *(void *)(a6 + 16);
        if ((unint64_t)v31 >= v30)
        {
          unint64_t v33 = *(float **)a6;
          uint64_t v34 = ((uint64_t)v31 - *(void *)a6) >> 2;
          unint64_t v35 = v34 + 1;
          if ((unint64_t)(v34 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v36 = v30 - (void)v33;
          if (v36 >> 1 > v35) {
            unint64_t v35 = v36 >> 1;
          }
          if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v35;
          }
          if (v37)
          {
            unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a6 + 16, v37);
            unint64_t v33 = *(float **)a6;
            unint64_t v31 = *(float **)(a6 + 8);
          }
          else
          {
            unint64_t v38 = 0;
          }
          uint64_t v39 = (float *)&v38[4 * v34];
          float *v39 = v29;
          unint64_t v32 = v39 + 1;
          while (v31 != v33)
          {
            int v40 = *((_DWORD *)v31-- - 1);
            *((_DWORD *)v39-- - 1) = v40;
          }
          *(void *)a6 = v39;
          *(void *)(a6 + 8) = v32;
          *(void *)(a6 + 16) = &v38[4 * v37];
          if (v33) {
            operator delete(v33);
          }
        }
        else
        {
          *unint64_t v31 = v29;
          unint64_t v32 = v31 + 1;
        }
        *(void *)(a6 + 8) = v32;
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
  }
  if (v11 == 2)
  {
    unint64_t v13 = *(float **)a6;
    *(void *)(a6 + 8) = *(void *)a6;
    uint64_t v15 = (float **)(a6 + 8);
    unint64_t v14 = *(void *)(a6 + 16);
    if ((unint64_t)v13 < v14)
    {
      float *v13 = 28.0;
      int v41 = v13 + 1;
      char v8 = a5;
      int v9 = a4;
LABEL_65:
      *uint64_t v15 = v41;
      goto LABEL_66;
    }
    char v8 = a5;
    int v9 = a4;
LABEL_55:
    uint64_t v42 = v14 - (void)v13;
    uint64_t v43 = v42 >> 1;
    if ((unint64_t)(v42 >> 1) <= 1) {
      uint64_t v43 = 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v44 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v43;
    }
    double v45 = std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a6 + 16, v44);
    unint64_t v46 = *(float **)a6;
    int v47 = *(float **)(a6 + 8);
    unint64_t v49 = &v45[v48];
    *double v45 = 1105199104;
    int v41 = (float *)(v45 + 1);
    while (v47 != v46)
    {
      int v50 = *((_DWORD *)v47-- - 1);
      *--double v45 = v50;
    }
    *(void *)a6 = v45;
    *(void *)(a6 + 8) = v41;
    *(void *)(a6 + 16) = v49;
    if (v46) {
      operator delete(v46);
    }
    goto LABEL_65;
  }
  int v41 = *(float **)(a6 + 8);
  char v8 = a5;
  int v9 = a4;
LABEL_66:
  double v51 = (float **)(a6 + 8);
  uint64_t v52 = *(float **)a6;
  unint64_t v53 = (unint64_t)v41 - *(void *)a6;
  BOOL v54 = v53 >= 0x31;
  uint64_t v55 = (v53 << 30) - 0xC00000000;
  if (v54 && v55 != 0)
  {
    id v57 = (float *)((char *)v52 + (v55 >> 30));
    int64_t v58 = (char *)v41 - (char *)v57;
    if (v41 != v57) {
      memmove(*(void **)a6, v57, (char *)v41 - (char *)v57);
    }
    int v41 = (float *)((char *)v52 + v58);
    char *v51 = (float *)((char *)v52 + v58);
  }
  if (v11 == 1 && *(unsigned char *)(a3 + 4))
  {
    float v59 = (float)*(int *)a3;
    unint64_t v60 = *(void *)(a6 + 16);
    if ((unint64_t)v41 >= v60)
    {
      unint64_t v62 = *(float **)a6;
      uint64_t v63 = ((uint64_t)v41 - *(void *)a6) >> 2;
      unint64_t v64 = v63 + 1;
      if ((unint64_t)(v63 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v65 = v60 - (void)v62;
      if (v65 >> 1 > v64) {
        unint64_t v64 = v65 >> 1;
      }
      if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v66 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v66 = v64;
      }
      if (v66)
      {
        long long v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a6 + 16, v66);
        unint64_t v62 = *(float **)a6;
        int v41 = *(float **)(a6 + 8);
      }
      else
      {
        long long v67 = 0;
      }
      BOOL v68 = (float *)&v67[4 * v63];
      uint64_t v69 = &v67[4 * v66];
      *BOOL v68 = v59;
      unint64_t v61 = v68 + 1;
      while (v41 != v62)
      {
        int v70 = *((_DWORD *)v41-- - 1);
        *((_DWORD *)v68-- - 1) = v70;
      }
      *(void *)a6 = v68;
      *(void *)(a6 + 8) = v61;
      *(void *)(a6 + 16) = v69;
      if (v62) {
        operator delete(v62);
      }
    }
    else
    {
      *int v41 = v59;
      unint64_t v61 = v41 + 1;
    }
    char *v51 = v61;
  }
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::uiLogProcessor::genCycleSlide();
  }
  uint64_t v72 = *(void *)(a6 + 8);
  if (*(void *)a6 == v72)
  {
    long long v77 = ha_get_log();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genCycleSlide();
    }
  }
  else
  {
    if (v72 - *(void *)a6 != 4)
    {
      unint64_t v73 = 0;
      do
      {
        long long v74 = ha_get_log();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
        {
          if (v73 >= (uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 2) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v75 = *(float *)(*(void *)a6 + 4 * v73);
          LODWORD(__p[0]) = 134217984;
          *(void **)((char *)__p + 4) = *(void **)&v75;
          _os_log_debug_impl(&dword_257C1A000, v74, OS_LOG_TYPE_DEBUG, "%3.1f, ", (uint8_t *)__p, 0xCu);
        }
        ++v73;
      }
      while (v73 < ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 2) - 1);
    }
    uint64_t v76 = ha_get_log();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide((void *)(a6 + 8));
    }
  }
  long long v79 = *(float **)a6;
  uint64_t v78 = *(void *)(a6 + 8);
  Nightingale::uiLogProcessor::removeOutlier(a6, (uint64_t)__p);
  int v80 = *(float **)a6;
  if (*(void *)a6)
  {
    *(void *)(a6 + 8) = v80;
    operator delete(v80);
    *(void *)a6 = 0;
    *(void *)(a6 + 8) = 0;
    *(void *)(a6 + 16) = 0;
  }
  long long v81 = __p[0];
  *(void **)a6 = __p[0];
  long long v82 = __p[1];
  *(_OWORD *)(a6 + 8) = *(_OWORD *)&__p[1];
  if (v8 && v9) {
    _DWORD *v9 = ((unint64_t)(v78 - (void)v79) >> 2) - ((unint64_t)(v82 - v81) >> 2);
  }
  uint64_t v83 = ha_get_log();
  if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG)) {
    Nightingale::uiLogProcessor::genCycleSlide();
  }
  uint64_t v84 = *(void *)(a6 + 8);
  if (*(void *)a6 == v84)
  {
    long long v89 = ha_get_log();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genCycleSlide();
    }
  }
  else
  {
    if (v84 - *(void *)a6 != 4)
    {
      unint64_t v85 = 0;
      do
      {
        uint64_t v86 = ha_get_log();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEBUG))
        {
          if (v85 >= (uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 2) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v87 = *(float *)(*(void *)a6 + 4 * v85);
          LODWORD(__p[0]) = 134217984;
          *(void **)((char *)__p + 4) = *(void **)&v87;
          _os_log_debug_impl(&dword_257C1A000, v86, OS_LOG_TYPE_DEBUG, "%3.1f, ", (uint8_t *)__p, 0xCu);
        }
        ++v85;
      }
      while (v85 < ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 2) - 1);
    }
    long long v88 = ha_get_log();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::genPeriodSlide((void *)(a6 + 8));
    }
  }
}

void sub_257D2F35C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  unint64_t v20 = *(void **)v18;
  if (*(void *)v18)
  {
    *(void *)(v18 + 8) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::getCenter(uint64_t a1, uint64_t a2, int a3)
{
  if (a3) {
    Nightingale::vMedian<double>();
  }
  Nightingale::vMean<double>();
}

double Nightingale::uiLogProcessor::getVariance(double a1, double a2, uint64_t a3, void *a4)
{
  if (a4[1] - *a4 >= 8uLL) {
    Nightingale::vVar<double>();
  }
  return a2;
}

void Nightingale::uiLogProcessor::calSlideMeanStd(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v5 = *(const void **)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v8 = v6 - (void)v5;
  if ((const void *)v6 != v5)
  {
    memset(__p, 0, sizeof(__p));
    int v9 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(__p, v5, v6, v8 >> 2);
    Nightingale::uiLogProcessor::getCenter((uint64_t)v9, (uint64_t)__p, a2);
  }
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 8) = v8;
  *(void *)(a3 + 16) = 0;
  *(unsigned char *)(a3 + 24) = v8;
}

void sub_257D2F564(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float Nightingale::uiLogProcessor::getACyclePeriodSlideMeanStd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  __n128 __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  Nightingale::uiLogProcessor::calSlideMeanStd((uint64_t)&__p, 1, (uint64_t)&v21);
  if (__p)
  {
    uint64_t v19 = __p;
    operator delete(__p);
  }
  if (*(unsigned __int8 *)(a4 + 36) == v22)
  {
    if (*(unsigned char *)(a4 + 36))
    {
      float v6 = v21;
      *(float *)(a4 + 32) = v6;
    }
  }
  else if (*(unsigned char *)(a4 + 36))
  {
    *(unsigned char *)(a4 + 36) = 0;
  }
  else
  {
    float v7 = v21;
    *(float *)(a4 + 32) = v7;
    *(unsigned char *)(a4 + 36) = 1;
  }
  if (*(unsigned __int8 *)(a4 + 44) == v24)
  {
    if (*(unsigned char *)(a4 + 44))
    {
      float v8 = v23;
      *(float *)(a4 + 40) = v8;
    }
  }
  else if (*(unsigned char *)(a4 + 44))
  {
    *(unsigned char *)(a4 + 44) = 0;
  }
  else
  {
    float v9 = v23;
    *(float *)(a4 + 40) = v9;
    *(unsigned char *)(a4 + 44) = 1;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  int v11 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v11, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
  Nightingale::uiLogProcessor::calSlideMeanStd((uint64_t)&v11, 1, (uint64_t)&v14);
  if (v11)
  {
    uint64_t v12 = v11;
    operator delete(v11);
  }
  if (*(unsigned __int8 *)(a4 + 52) == v15)
  {
    if (*(unsigned char *)(a4 + 52))
    {
      float result = v14;
      *(float *)(a4 + 48) = result;
    }
  }
  else if (*(unsigned char *)(a4 + 52))
  {
    *(unsigned char *)(a4 + 52) = 0;
  }
  else
  {
    float result = v14;
    *(float *)(a4 + 48) = result;
    *(unsigned char *)(a4 + 52) = 1;
  }
  if (*(unsigned __int8 *)(a4 + 60) == v17)
  {
    if (*(unsigned char *)(a4 + 60))
    {
      float result = v16;
      *(float *)(a4 + 56) = result;
    }
  }
  else if (*(unsigned char *)(a4 + 60))
  {
    *(unsigned char *)(a4 + 60) = 0;
  }
  else
  {
    float result = v16;
    *(float *)(a4 + 56) = result;
    *(unsigned char *)(a4 + 60) = 1;
  }
  return result;
}

void sub_257D2F760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::getDLStartProcDate(uint64_t a1, uint64_t a2, uint64_t a3, int **a4, uint64_t a5)
{
  int v5 = *(unsigned __int8 *)(a3 + 60);
  int v6 = *(_DWORD *)(a3 + 56) - 39;
  if (!*(unsigned char *)(a3 + 60)) {
    int v6 = 0;
  }
  *(_DWORD *)a5 = v6;
  *(unsigned char *)(a5 + 4) = v5;
  float v7 = *a4;
  float v8 = a4[1];
  uint64_t v9 = (char *)v8 - (char *)*a4;
  if (v8 != *a4)
  {
    uint64_t v10 = 0;
    unint64_t v11 = v9 / 60;
    if (v11 <= 1) {
      unint64_t v11 = 1;
    }
    while (1)
    {
      int v13 = *v7;
      v7 += 15;
      int v12 = v13;
      if (v5)
      {
        if (v12 == v6) {
          break;
        }
      }
      if (v11 == ++v10) {
        return;
      }
    }
    *(_DWORD *)(a5 + 8) = v10;
    *(unsigned char *)(a5 + 12) = 1;
  }
}

void Nightingale::uiLogProcessor::getCyclePeriodMeanStdAllCycles(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (v7 != v8)
  {
    uint64_t v54 = 0;
    uint64_t v55 = 0;
    uint64_t v56 = 0;
    unint64_t v11 = std::vector<Nightingale::cycleInfo>::__init_with_size[abi:ne180100]<Nightingale::cycleInfo*,Nightingale::cycleInfo*>(&v54, v7, v8, 0xAAAAAAAAAAAAAAABLL * ((v8 - v7) >> 5));
    if ((int)(-1431655765 * ((a2[1] - *a2) >> 5)) >= 1)
    {
      unint64_t v12 = -1431655765 * ((a2[1] - *a2) >> 5);
      do
      {
        uint64_t NumPeriodsToKeepUR = Nightingale::uiLogProcessor::getNumPeriodsToKeepUR((uint64_t)v11, a3, (uint64_t)a2);
        int v14 = NumPeriodsToKeepUR;
        unint64_t ShouldBeInSlideCC = Nightingale::uiLogProcessor::getWhatShouldBeInSlideCC(NumPeriodsToKeepUR, v15, &v54, a5);
        Nightingale::uiLogProcessor::genCycleSlide(&v54, ShouldBeInSlideCC, a3, 0, 0, (uint64_t)&v52);
        memset(v49, 0, sizeof(v49));
        std::vector<Nightingale::cycleInfo>::__init_with_size[abi:ne180100]<Nightingale::cycleInfo*,Nightingale::cycleInfo*>(v49, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5));
        if (v14 >= SHIDWORD(ShouldBeInSlideCC)) {
          int v17 = HIDWORD(ShouldBeInSlideCC);
        }
        else {
          int v17 = v14;
        }
        Nightingale::uiLogProcessor::genPeriodSlide(v49, v17, a3, a4, (float **)&v50);
        *(void *)buf = v49;
        std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
        int v47 = 0;
        uint64_t v48 = 0;
        unint64_t v46 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v46, v52, (uint64_t)v53, (v53 - (unsigned char *)v52) >> 2);
        __n128 __p = 0;
        unint64_t v44 = 0;
        uint64_t v45 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v50, (uint64_t)v51, (v51 - (unsigned char *)v50) >> 2);
        Nightingale::uiLogProcessor::getACyclePeriodSlideMeanStd(a1, (uint64_t)&v46, (uint64_t)&__p, v55 - 96);
        if (__p)
        {
          unint64_t v44 = __p;
          operator delete(__p);
        }
        if (v46)
        {
          int v47 = v46;
          operator delete(v46);
        }
        unint64_t v18 = v12 - 1;
        if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= (v12 - 1)) {
          goto LABEL_40;
        }
        unint64_t v19 = (v12 - 1);
        uint64_t v20 = *a2 + 96 * v18;
        int v21 = *(_DWORD *)(v55 - 64);
        *(unsigned char *)(v20 + 36) = *(unsigned char *)(v55 - 60);
        *(_DWORD *)(v20 + 32) = v21;
        if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v19) {
          goto LABEL_40;
        }
        uint64_t v22 = *a2 + 96 * v18;
        int v23 = *(_DWORD *)(v55 - 56);
        *(unsigned char *)(v22 + 44) = *(unsigned char *)(v55 - 52);
        *(_DWORD *)(v22 + 40) = v23;
        if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v19
          || (uint64_t v24 = *a2 + 96 * v18,
              int v25 = *(_DWORD *)(v55 - 48),
              *(unsigned char *)(v24 + 52) = *(unsigned char *)(v55 - 44),
              *(_DWORD *)(v24 + 48) = v25,
              0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v19))
        {
LABEL_40:
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v26 = *a2 + 96 * v18;
        int v27 = *(_DWORD *)(v55 - 40);
        *(unsigned char *)(v26 + 60) = *(unsigned char *)(v55 - 36);
        *(_DWORD *)(v26 + 56) = v27;
        uint64_t v28 = v55;
        float v29 = *(void **)(v55 - 24);
        if (v29)
        {
          *(void *)(v55 - 16) = v29;
          operator delete(v29);
        }
        uint64_t v55 = v28 - 96;
        log = ha_get_log();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v31 = *a2;
          if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v19) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v32 = v31 + 96 * v18;
          float v33 = -1.0;
          float v34 = -1.0;
          if (*(unsigned char *)(v32 + 36)) {
            float v34 = *(float *)(v32 + 32);
          }
          uint64_t v35 = v31 + 96 * v18;
          if (*(unsigned char *)(v35 + 44)) {
            float v33 = *(float *)(v35 + 40);
          }
          *(_DWORD *)buf = 134218240;
          *(double *)&buf[4] = v34;
          __int16 v58 = 2048;
          double v59 = v33;
          _os_log_debug_impl(&dword_257C1A000, log, OS_LOG_TYPE_DEBUG, "\t \"cycleLenMean\": %6.4f, \"cycleLenVar\": %6.4f, ", buf, 0x16u);
        }
        if (v12 >= 2)
        {
          uint64_t v36 = ha_get_log();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v37 = *a2;
            if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v19) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v38 = v37 + 96 * v18;
            float v39 = -1.0;
            float v40 = -1.0;
            if (*(unsigned char *)(v38 + 52)) {
              float v40 = *(float *)(v38 + 48);
            }
            uint64_t v41 = v37 + 96 * v18;
            if (*(unsigned char *)(v41 + 60)) {
              float v39 = *(float *)(v41 + 56);
            }
            *(_DWORD *)buf = 134218240;
            *(double *)&buf[4] = v40;
            __int16 v58 = 2048;
            double v59 = v39;
            _os_log_debug_impl(&dword_257C1A000, v36, OS_LOG_TYPE_DEBUG, "\"periodLenMean\": %6.4f, \"periodLenVar\": %6.4f},", buf, 0x16u);
          }
        }
        if (v50)
        {
          double v51 = v50;
          operator delete(v50);
        }
        unint64_t v11 = v52;
        if (v52)
        {
          unint64_t v53 = v52;
          operator delete(v52);
        }
        --v12;
      }
      while (v18 + 1 > 1);
    }
    uint64_t v52 = &v54;
    std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
  }
}

void sub_257D2FC7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,char a28)
{
}

void Nightingale::uiLogProcessor::getAvgCycleLenForSomeCycleReproductive(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  __n128 __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  if (*a2 != v5)
  {
    int v6 = a4;
    int v8 = 0;
    int v9 = -a4;
    uint64_t v19 = a2[1];
    do
    {
      if (Nightingale::phaseFactorProcessor::vPhasesContainsAPhase((uint64_t)&__p, (unsigned __int8 **)(v4 + 72), 0))
      {
        int v10 = -1 - 1431655765 * ((unint64_t)(a2[1] - *a2) >> 5);
        if (v8 + v6 < v10) {
          int v10 = v8 + v6;
        }
        if (!*(unsigned char *)(v4 + 68)) {
          *(unsigned char *)(v4 + 68) = 1;
        }
        *(_DWORD *)(v4 + 64) = 0;
        if (((v8 - v6) & ~((v8 - v6) >> 31)) <= v10)
        {
          int v11 = 0;
          int v12 = 0;
          unint64_t v13 = v9 & ~(v9 >> 31);
          uint64_t v14 = 96 * v13;
          uint64_t v15 = v10;
          do
          {
            if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v13) {
LABEL_23:
            }
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            uint64_t v16 = *a2 + v14;
            if (*(unsigned char *)(v16 + 24)
              && !Nightingale::phaseFactorProcessor::vPhasesContainsAPhase((uint64_t)&__p, (unsigned __int8 **)(v16 + 72), 0))
            {
              uint64_t v17 = *a2;
              if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v13) {
                goto LABEL_23;
              }
              if (!*(unsigned char *)(v17 + v14 + 24)) {
                std::__throw_bad_optional_access[abi:ne180100]();
              }
              int v12 = v12 + *(_DWORD *)(v17 + v14 + 20) - *(_DWORD *)(v17 + v14) + 1;
              ++v11;
            }
            v14 += 96;
          }
          while ((uint64_t)v13++ < v15);
          int v6 = a4;
          uint64_t v5 = v19;
          if (v11 > 0)
          {
            *(float *)(v4 + 64) = (float)v12 / (float)v11;
            *(unsigned char *)(v4 + 68) = 1;
          }
        }
      }
      ++v8;
      v4 += 96;
      ++v9;
    }
    while (v4 != v5);
    if (__p)
    {
      uint64_t v22 = __p;
      operator delete(__p);
    }
  }
}

void sub_257D2FF14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::hist_process(uint64_t a1@<X1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  *(unsigned char *)(a3 + 28) = 0;
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 36) = 0;
  *(unsigned char *)(a3 + 40) = 0;
  *(unsigned char *)(a3 + 44) = 0;
  *(unsigned char *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 52) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 60) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 84) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  *(unsigned char *)(a3 + 92) = 0;
  *(unsigned char *)(a3 + 96) = 0;
  *(unsigned char *)(a3 + 100) = 0;
  *(unsigned char *)(a3 + 104) = 0;
  *(unsigned char *)(a3 + 108) = 0;
  *(unsigned char *)(a3 + 112) = 0;
  *(unsigned char *)(a3 + 116) = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  if (*(void *)a1 != *(void *)(a1 + 8))
  {
    Nightingale::uiLogProcessor::process((int **)a1, a2, (uint64_t)__p);
    std::vector<Nightingale::cycleInfo>::__vdeallocate((uint64_t *)a3);
    *(_OWORD *)a3 = *(_OWORD *)__p;
    *(void *)(a3 + 16) = v14;
    __p[1] = 0;
    uint64_t v14 = 0;
    __p[0] = 0;
    *(_OWORD *)(a3 + 72) = v18;
    *(_OWORD *)(a3 + 88) = v19;
    *(_OWORD *)(a3 + 104) = v20[0];
    *(_OWORD *)(a3 + 113) = *(_OWORD *)((char *)v20 + 9);
    *(_OWORD *)(a3 + 24) = v15;
    *(_OWORD *)(a3 + 40) = v16;
    *(_OWORD *)(a3 + 56) = v17;
    int v21 = __p;
    std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100](&v21);
    Nightingale::uiLogProcessor::addCycleEnd(v6, (uint64_t *)a3);
    Nightingale::uiLogProcessor::opk2Cycles(v7, (uint64_t *)a1, (void *)a3);
    int v8 = *(int **)a1;
    uint64_t v9 = *(void *)(a1 + 8) - *(void *)a1;
    if (v9)
    {
      unint64_t v10 = v9 / 60;
      if (v10 <= 1) {
        unint64_t v10 = 1;
      }
      while (v8[3] != 2)
      {
        v8 += 15;
        if (!--v10) {
          goto LABEL_9;
        }
      }
      *(_DWORD *)(a3 + 72) = *v8;
      *(unsigned char *)(a3 + 76) = 1;
    }
LABEL_9:
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v14 = 0;
    Nightingale::uiCycleFactorProcess::tagCycleInfoReproductive((uint64_t)__p, (uint64_t *)a3, a2);
    Nightingale::uiLogProcessor::getAvgCycleLenForSomeCycleReproductive(v11, (uint64_t *)a3, v12, 6);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
}

void sub_257D300F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
}

void Nightingale::uiLogProcessor::process(int **a1@<X1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a3 + 28) = 0;
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 36) = 0;
  *(unsigned char *)(a3 + 40) = 0;
  *(unsigned char *)(a3 + 44) = 0;
  *(unsigned char *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 52) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 60) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 84) = 0;
  *(unsigned char *)(a3 + 88) = 0;
  *(unsigned char *)(a3 + 92) = 0;
  *(unsigned char *)(a3 + 96) = 0;
  *(unsigned char *)(a3 + 100) = 0;
  *(unsigned char *)(a3 + 104) = 0;
  *(unsigned char *)(a3 + 108) = 0;
  *(unsigned char *)(a3 + 112) = 0;
  *(unsigned char *)(a3 + 116) = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  __n128 __p = 0;
  long long v81 = 0;
  unint64_t v82 = 0;
  long long v77 = 0;
  uint64_t v78 = 0;
  unint64_t v79 = 0;
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (*a1 != v4)
  {
    uint64_t v7 = *a1;
    while (v7[1] > 5)
    {
      v7 += 15;
      if (v7 == v4)
      {
        int v69 = *v5;
        goto LABEL_7;
      }
    }
    int v69 = *v7;
LABEL_7:
    if (v5 != v4)
    {
      int v8 = 0;
      unint64_t v9 = 0;
      do
      {
        unint64_t v10 = &v5[15 * v9];
        if ((v10[1] - 1) <= 3)
        {
          uint64_t v11 = v81;
          if ((unint64_t)v81 >= v82)
          {
            unint64_t v13 = __p;
            uint64_t v14 = ((char *)v81 - (unsigned char *)__p) >> 2;
            unint64_t v15 = v14 + 1;
            if ((unint64_t)(v14 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v16 = v82 - (void)__p;
            if ((uint64_t)(v82 - (void)__p) >> 1 > v15) {
              unint64_t v15 = v16 >> 1;
            }
            if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v17 = v15;
            }
            if (v17)
            {
              long long v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v82, v17);
              unint64_t v13 = __p;
              uint64_t v11 = v81;
            }
            else
            {
              long long v18 = 0;
            }
            long long v19 = (int *)&v18[4 * v14];
            *long long v19 = *v10;
            uint64_t v12 = v19 + 1;
            while (v11 != v13)
            {
              int v20 = *--v11;
              *--long long v19 = v20;
            }
            __n128 __p = v19;
            long long v81 = v12;
            unint64_t v82 = (unint64_t)&v18[4 * v17];
            if (v13) {
              operator delete(v13);
            }
          }
          else
          {
            _DWORD *v81 = *v10;
            uint64_t v12 = v11 + 1;
          }
          long long v81 = v12;
          if (0xEEEEEEEEEEEEEEEFLL * (a1[1] - *a1) <= v9) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          int v21 = &(*a1)[15 * v9 + 1];
          uint64_t v22 = v78;
          if ((unint64_t)v78 >= v79)
          {
            uint64_t v23 = (int *)v77;
            uint64_t v24 = ((char *)v78 - (unsigned char *)v77) >> 2;
            unint64_t v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v26 = v79 - (void)v77;
            if ((uint64_t)(v79 - (void)v77) >> 1 > v25) {
              unint64_t v25 = v26 >> 1;
            }
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v27 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v27 = v25;
            }
            if (v27)
            {
              uint64_t v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v79, v27);
              uint64_t v23 = (int *)v77;
              uint64_t v22 = v78;
            }
            else
            {
              uint64_t v28 = 0;
            }
            float v29 = &v28[4 * v24];
            *(_DWORD *)float v29 = *v21;
            int v8 = (int *)(v29 + 4);
            while (v22 != v23)
            {
              int v30 = *--v22;
              *((_DWORD *)v29 - 1) = v30;
              v29 -= 4;
            }
            long long v77 = v29;
            uint64_t v78 = v8;
            unint64_t v79 = (unint64_t)&v28[4 * v27];
            if (v23) {
              operator delete(v23);
            }
          }
          else
          {
            *uint64_t v78 = *v21;
            int v8 = v22 + 1;
          }
          uint64_t v78 = v8;
          uint64_t v5 = *a1;
          uint64_t v4 = a1[1];
        }
        ++v9;
      }
      while (0xEEEEEEEEEEEEEEEFLL * (v4 - v5) > v9);
      if (__p != v81)
      {
        if (v77 == v8) {
          goto LABEL_110;
        }
        log = ha_get_log();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::process();
        }
        if (__p == v81)
        {
          float v33 = ha_get_log();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::genCycleSlide();
          }
        }
        else
        {
          if ((char *)v81 - (unsigned char *)__p != 4)
          {
            unint64_t v63 = 0;
            do
            {
              unint64_t v64 = ha_get_log();
              if (os_log_type_enabled(v64, OS_LOG_TYPE_DEBUG))
              {
                int v65 = *((_DWORD *)__p + v63);
                *(_DWORD *)buf = 67109120;
                int v84 = v65;
                _os_log_debug_impl(&dword_257C1A000, v64, OS_LOG_TYPE_DEBUG, "%d, ", buf, 8u);
              }
              ++v63;
            }
            while (v63 < (((char *)v81 - (unsigned char *)__p) >> 2) - 1);
          }
          uint64_t v32 = ha_get_log();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
        float v34 = ha_get_log();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::process();
        }
        if (v77 == v78)
        {
          uint64_t v36 = ha_get_log();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::genCycleSlide();
          }
        }
        else
        {
          if ((char *)v78 - (unsigned char *)v77 != 4)
          {
            unint64_t v66 = 0;
            do
            {
              long long v67 = ha_get_log();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
              {
                int v68 = *((_DWORD *)v77 + v66);
                *(_DWORD *)buf = 67109120;
                int v84 = v68;
                _os_log_debug_impl(&dword_257C1A000, v67, OS_LOG_TYPE_DEBUG, "%d, ", buf, 8u);
              }
              ++v66;
            }
            while (v66 < (((char *)v78 - (unsigned char *)v77) >> 2) - 1);
          }
          uint64_t v35 = ha_get_log();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
        long long v74 = 0;
        double v75 = 0;
        uint64_t v76 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v74, __p, (uint64_t)v81, ((char *)v81 - (unsigned char *)__p) >> 2);
        uint64_t v71 = 0;
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        uint64_t v37 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v71, v77, (uint64_t)v78, ((char *)v78 - (unsigned char *)v77) >> 2);
        Nightingale::uiLogProcessor::extractPeriods((uint64_t)v37, (uint64_t)&v74, (int **)&v71, v69, a2, (uint64_t *)a3);
        if (v71)
        {
          uint64_t v72 = v71;
          operator delete(v71);
        }
        if (v74)
        {
          double v75 = v74;
          operator delete(v74);
        }
        uint64_t v38 = ha_get_log();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::process();
        }
        uint64_t v39 = *(void *)(a3 + 8);
        if (*(void *)a3 == v39)
        {
          uint64_t v45 = ha_get_log();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::genCycleSlide();
          }
        }
        else
        {
          if (v39 - *(void *)a3 != 96)
          {
            uint64_t v40 = 0;
            unint64_t v41 = 0;
            do
            {
              uint64_t v42 = ha_get_log();
              if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
              {
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5) <= v41) {
                  std::vector<int>::__throw_out_of_range[abi:ne180100]();
                }
                int v43 = *(_DWORD *)(*(void *)a3 + v40);
                *(_DWORD *)buf = 67109120;
                int v84 = v43;
                _os_log_debug_impl(&dword_257C1A000, v42, OS_LOG_TYPE_DEBUG, "%d, ", buf, 8u);
              }
              ++v41;
              v40 += 96;
            }
            while (v41 < -1 - 0x5555555555555555 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5));
          }
          unint64_t v44 = ha_get_log();
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
        unint64_t v46 = ha_get_log();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::process();
        }
        uint64_t v47 = *(void *)(a3 + 8);
        if (*(void *)a3 == v47)
        {
          uint64_t v54 = ha_get_log();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::genCycleSlide();
          }
        }
        else
        {
          if (v47 - *(void *)a3 != 96)
          {
            uint64_t v48 = 0;
            unint64_t v49 = 0;
            do
            {
              int v50 = ha_get_log();
              if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
              {
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5) <= v49) {
                  std::vector<int>::__throw_out_of_range[abi:ne180100]();
                }
                uint64_t v51 = *(void *)a3 + v48;
                if (*(unsigned char *)(v51 + 8)) {
                  int v52 = *(_DWORD *)(v51 + 4);
                }
                else {
                  int v52 = -1;
                }
                *(_DWORD *)buf = 67109120;
                int v84 = v52;
                _os_log_debug_impl(&dword_257C1A000, v50, OS_LOG_TYPE_DEBUG, "%d, ", buf, 8u);
              }
              ++v49;
              v48 += 96;
            }
            while (v49 < -1 - 0x5555555555555555 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5));
          }
          unint64_t v53 = ha_get_log();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
        uint64_t v55 = ha_get_log();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::process();
        }
        uint64_t v56 = *(void *)(a3 + 8);
        if (*(void *)a3 == v56)
        {
          unint64_t v62 = ha_get_log();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
        else
        {
          if (v56 - *(void *)a3 != 96)
          {
            unint64_t v57 = 0;
            uint64_t v58 = 28;
            do
            {
              double v59 = ha_get_log();
              if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
              {
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5) <= v57) {
                  std::vector<int>::__throw_out_of_range[abi:ne180100]();
                }
                int v60 = *(unsigned __int8 *)(*(void *)a3 + v58);
                *(_DWORD *)buf = 67109120;
                int v84 = v60;
                _os_log_debug_impl(&dword_257C1A000, v59, OS_LOG_TYPE_DEBUG, "%d, ", buf, 8u);
              }
              ++v57;
              v58 += 96;
            }
            while (v57 < -1 - 0x5555555555555555 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 5));
          }
          unint64_t v61 = ha_get_log();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::process();
          }
        }
      }
    }
  }
  int v8 = (int *)v77;
LABEL_110:
  if (v8)
  {
    uint64_t v78 = v8;
    operator delete(v8);
  }
  if (__p)
  {
    long long v81 = __p;
    operator delete(__p);
  }
}

void sub_257D30A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  _Unwind_Resume(a1);
}

void Nightingale::uiCycleFactorProcess::tagCycleInfoReproductive(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (*a3 != a3[1])
  {
    __n128 __p = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v4 = a2[1];
    unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a2) >> 5);
    if ((int)v5 >= 1)
    {
      if (v5 != 1)
      {
        uint64_t v8 = 0;
        unint64_t v9 = 0;
        uint64_t v10 = (v5 - 1);
        do
        {
          uint64_t v11 = *a2;
          if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v9) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          if (*(unsigned char *)(v11 + v8 + 24))
          {
            Nightingale::phaseFactorProcessor::tagPhaseJDayRange(a1, *(unsigned int *)(v11 + v8) | ((unint64_t)*(unsigned int *)(v11 + v8 + 20) << 32), a3, (unint64_t *)&__p);
            if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 5) <= v9) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v12 = (void **)(*a2 + v8 + 72);
            if (v12 != &__p) {
              std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v12, (char *)__p, v16, v16 - (unsigned char *)__p);
            }
          }
          ++v9;
          v8 += 96;
        }
        while (v10 != v9);
        uint64_t v4 = a2[1];
      }
      Nightingale::phaseFactorProcessor::tagPhaseJDayRange(a1, *(unsigned int *)(v4 - 96) | 0xFFFFFFFF00000000, a3, (unint64_t *)&__p);
      unint64_t v13 = (void **)(a2[1] - 24);
      uint64_t v14 = (char *)__p;
      if (v13 != &__p)
      {
        std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v13, (char *)__p, v16, v16 - (unsigned char *)__p);
        uint64_t v14 = (char *)__p;
      }
      if (v14)
      {
        uint64_t v16 = v14;
        operator delete(v14);
      }
    }
  }
}

void sub_257D30CF0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiLogProcessor::extractCycles(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  *(unsigned char *)(a5 + 28) = 0;
  *(unsigned char *)(a5 + 32) = 0;
  *(unsigned char *)(a5 + 36) = 0;
  *(unsigned char *)(a5 + 40) = 0;
  *(unsigned char *)(a5 + 44) = 0;
  *(unsigned char *)(a5 + 48) = 0;
  *(unsigned char *)(a5 + 52) = 0;
  *(unsigned char *)(a5 + 56) = 0;
  *(unsigned char *)(a5 + 60) = 0;
  *(unsigned char *)(a5 + 64) = 0;
  *(unsigned char *)(a5 + 68) = 0;
  *(unsigned char *)(a5 + 72) = 0;
  *(unsigned char *)(a5 + 76) = 0;
  *(unsigned char *)(a5 + 80) = 0;
  *(unsigned char *)(a5 + 84) = 0;
  *(unsigned char *)(a5 + 88) = 0;
  *(unsigned char *)(a5 + 92) = 0;
  *(unsigned char *)(a5 + 96) = 0;
  *(unsigned char *)(a5 + 100) = 0;
  *(unsigned char *)(a5 + 104) = 0;
  *(unsigned char *)(a5 + 108) = 0;
  *(unsigned char *)(a5 + 112) = 0;
  *(unsigned char *)(a5 + 116) = 0;
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(unsigned char *)(a5 + 24) = 0;
  *(void *)(a5 + 16) = 0;
  if (*(void *)a2 != *(void *)(a2 + 8))
  {
    Nightingale::uiLogProcessor::process((int **)a2, a3, (uint64_t)__p);
    std::vector<Nightingale::cycleInfo>::__vdeallocate((uint64_t *)a5);
    *(_OWORD *)a5 = *(_OWORD *)__p;
    *(void *)(a5 + 16) = v16;
    __p[1] = 0;
    uint64_t v16 = 0;
    __p[0] = 0;
    *(_OWORD *)(a5 + 72) = v20;
    *(_OWORD *)(a5 + 88) = v21;
    *(_OWORD *)(a5 + 104) = v22[0];
    *(_OWORD *)(a5 + 113) = *(_OWORD *)((char *)v22 + 9);
    *(_OWORD *)(a5 + 24) = v17;
    *(_OWORD *)(a5 + 40) = v18;
    *(_OWORD *)(a5 + 56) = v19;
    uint64_t v23 = __p;
    std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100](&v23);
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v16 = 0;
    if (*(void *)a5 != *(void *)(a5 + 8))
    {
      Nightingale::uiLogProcessor::addCycleEnd(v10, (uint64_t *)a5);
      Nightingale::uiCycleFactorProcess::tagCycleInfoReproductive((uint64_t)__p, (uint64_t *)a5, a3);
      Nightingale::uiLogProcessor::opk2Cycles(v11, (uint64_t *)a2, (void *)a5);
      Nightingale::uiLogProcessor::getJDayUILog(v12, (uint64_t *)a2, a3, a5);
      Nightingale::uiLogProcessor::guardConfig(v13, a4, a5 + 24);
      Nightingale::uiLogProcessor::getInPeriodNow(v14, a5, a4);
      Nightingale::uiLogProcessor::getCyclePeriodMeanStdAllCycles(a1, (uint64_t *)a5, a4, *(unsigned __int8 *)(a5 + 128), *(void *)(a5 + 120));
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
    }
  }
}

void sub_257D30ECC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
  {
    a10 = (uint64_t)__p;
    operator delete(__p);
  }
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void Nightingale::uiLogProcessor::getEnsembleInput(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  int32x4_t v5 = vdupq_n_s32(0x7FC00000u);
  *(int32x4_t *)a4 = v5;
  *(int32x4_t *)(a4 + 16) = v5;
  *(int32x4_t *)(a4 + 32) = v5;
  *(int32x4_t *)(a4 + 48) = v5;
  *(int32x4_t *)(a4 + 64) = v5;
  *(void *)(a4 + 80) = v5.i64[0];
  if (*a2 != a2[1])
  {
    unint64_t ShouldBeInSlideCC = Nightingale::uiLogProcessor::getWhatShouldBeInSlideCC(a1, (uint64_t)a2, a2, a2[15]);
    int v20 = 0;
    Nightingale::uiLogProcessor::genCycleSlide(a2, ShouldBeInSlideCC, a3, &v20, 1, (uint64_t)&v18);
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    __n128 __p = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v18, (uint64_t)v19, (v19 - (unsigned char *)v18) >> 2);
    Nightingale::uiLogProcessor::calSlideMeanStd((uint64_t)&__p, 1, (uint64_t)&v14);
    if (__p)
    {
      uint64_t v12 = __p;
      operator delete(__p);
    }
    float v9 = v16;
    if (!v17) {
      float v9 = NAN;
    }
    *(float *)a4 = (float)(int)(-1431655765 * ((unint64_t)(a2[1] - *a2) >> 5) - 1);
    *(float *)(a4 + 4) = sqrtf(v9);
    float v10 = v14;
    if (!v15) {
      float v10 = NAN;
    }
    *(float *)(a4 + 8) = v10;
    *(float *)(a4 + 84) = (float)v20;
    if (v18)
    {
      long long v19 = v18;
      operator delete(v18);
    }
  }
}

void sub_257D31048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  if (a17) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

__n128 Nightingale::getEnsembleInputArray@<Q0>(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<float>::resize((uint64_t)a2, 0x16uLL);
  uint64_t v4 = *a2;
  __n128 result = *(__n128 *)a1;
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a1 + 16);
  long long v7 = *(_OWORD *)(a1 + 48);
  long long v6 = *(_OWORD *)(a1 + 64);
  long long v8 = *(_OWORD *)(a1 + 32);
  *(void *)(v4 + 80) = *(void *)(a1 + 80);
  *(_OWORD *)(v4 + 48) = v7;
  *(_OWORD *)(v4 + 64) = v6;
  *(_OWORD *)(v4 + 32) = v8;
  *(__n128 *)uint64_t v4 = result;
  return result;
}

void sub_257D310DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void Nightingale::uiLogProcessor::print_anUILog(uint64_t a1, int **a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (*a2 != a2[1])
  {
    log = ha_get_log();
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v4 = *a2;
    int32x4_t v5 = a2[1];
    if (*a2 != v5)
    {
      unint64_t v6 = 0;
      do
      {
        long long v7 = ha_get_log();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          int v24 = *v4;
          int v25 = *((unsigned __int8 *)v4 + 28);
          *(_DWORD *)buf = 67109376;
          int v52 = v24;
          __int16 v53 = 1024;
          int v54 = v25;
          _os_log_debug_impl(&dword_257C1A000, v7, OS_LOG_TYPE_DEBUG, "\t{\"jDayPeriodStart\": %d, \"isDeterminant\": %d", buf, 0xEu);
        }
        long long v8 = ha_get_log();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        float v9 = ha_get_log();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        float v10 = ha_get_log();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        uint64_t v11 = ha_get_log();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        uint64_t v12 = ha_get_log();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        uint64_t v13 = ha_get_log();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        double v14 = ha_get_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog();
        }
        char v15 = ha_get_log();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog(&v49, v50);
        }
        uint64_t v17 = *((void *)v4 + 9);
        uint64_t v16 = *((void *)v4 + 10);
        if (v17 != v16)
        {
          unint64_t v18 = 0;
          do
          {
            long long v19 = ha_get_log();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
            {
              int v21 = *(unsigned __int8 *)(v17 + v18);
              *(_DWORD *)buf = 67109120;
              int v52 = v21;
              _os_log_debug_impl(&dword_257C1A000, v19, OS_LOG_TYPE_DEBUG, "%d ", buf, 8u);
            }
            if (~*((void *)v4 + 9) + *((void *)v4 + 10) > v18)
            {
              int v20 = ha_get_log();
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)) {
                Nightingale::uiLogProcessor::print_anUILog(&v47, v48);
              }
            }
            ++v18;
          }
          while (v17 + v18 != v16);
        }
        uint64_t v22 = ha_get_log();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
          Nightingale::uiLogProcessor::print_anUILog(&v45, v46);
        }
        if (-1 - 0x5555555555555555 * (((char *)a2[1] - (char *)*a2) >> 5) > v6)
        {
          uint64_t v23 = ha_get_log();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
            Nightingale::uiLogProcessor::print_anUILog(&v43, v44);
          }
        }
        ++v6;
        v4 += 24;
      }
      while (v4 != v5);
    }
    uint64_t v26 = ha_get_log();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    unint64_t v27 = ha_get_log();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v28 = ha_get_log();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    float v29 = ha_get_log();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    int v30 = ha_get_log();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v31 = ha_get_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v32 = ha_get_log();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    float v33 = ha_get_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    float v34 = ha_get_log();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v35 = ha_get_log();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v36 = ha_get_log();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v37 = ha_get_log();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v38 = ha_get_log();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v39 = ha_get_log();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v40 = ha_get_log();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    unint64_t v41 = ha_get_log();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
    uint64_t v42 = ha_get_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
      Nightingale::uiLogProcessor::print_anUILog();
    }
  }
}

void *Nightingale::PhaseSet::add(void *result, unsigned int a2)
{
  if (a2 >= 9) {
    std::__throw_out_of_range[abi:ne180100]("bitset set argument out of range");
  }
  *result |= 1 << a2;
  return result;
}

void *Nightingale::PhaseSet::remove(void *result, unsigned int a2)
{
  if (a2 >= 9) {
    std::__throw_out_of_range[abi:ne180100]("bitset reset argument out of range");
  }
  *result &= ~(1 << a2);
  return result;
}

uint64_t Nightingale::PhaseSet::contains(void *a1, unsigned int a2)
{
  if (a2 >= 9) {
    std::__throw_out_of_range[abi:ne180100]("bitset test argument out of range");
  }
  return (*a1 >> a2) & 1;
}

void Nightingale::PhaseSet::phasesOnInPhaseSet2Vec(void *a1, unint64_t *a2)
{
  uint64_t v4 = (unsigned __int8 *)operator new(9uLL);
  uint64_t v5 = 0;
  *(void *)uint64_t v4 = 0x706050403020100;
  v4[8] = 8;
  do
  {
    unint64_t v6 = v4[v5];
    if (v6 >= 9) {
      std::__throw_out_of_range[abi:ne180100]("bitset test argument out of range");
    }
    if ((*a1 >> v6))
    {
      long long v8 = (unsigned char *)a2[1];
      unint64_t v7 = a2[2];
      if ((unint64_t)v8 >= v7)
      {
        unint64_t v10 = *a2;
        uint64_t v11 = &v8[-*a2];
        unint64_t v12 = (unint64_t)(v11 + 1);
        if ((uint64_t)(v11 + 1) < 0) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v13 = v7 - v10;
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x3FFFFFFFFFFFFFFFLL) {
          size_t v14 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          size_t v14 = v12;
        }
        if (v14) {
          char v15 = (char *)operator new(v14);
        }
        else {
          char v15 = 0;
        }
        uint64_t v16 = &v11[(void)v15];
        uint64_t v17 = &v11[(void)v15];
        *uint64_t v17 = v6;
        float v9 = v17 + 1;
        if (v8 != (unsigned char *)v10)
        {
          unint64_t v18 = &v8[~v10];
          do
          {
            char v19 = *--v8;
            (v18--)[(void)v15] = v19;
          }
          while (v8 != (unsigned char *)v10);
          uint64_t v16 = v15;
        }
        *a2 = (unint64_t)v16;
        a2[1] = (unint64_t)v9;
        a2[2] = (unint64_t)&v15[v14];
        if (v10) {
          operator delete((void *)v10);
        }
      }
      else
      {
        unsigned char *v8 = v6;
        float v9 = v8 + 1;
      }
      a2[1] = (unint64_t)v9;
    }
    ++v5;
  }
  while (v5 != 9);
  operator delete(v4);
}

void sub_257D319C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

__n128 Nightingale::uiProcessForLstm::uiProcessForLstm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __n128 *a5)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  __n128 result = *a5;
  *(void *)(a1 + 40) = a5[1].n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  return result;
}

{
  __n128 result;

  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(void *)(a1 + 16) = a4;
  __n128 result = *a5;
  *(void *)(a1 + 40) = a5[1].n128_u64[0];
  *(__n128 *)(a1 + 24) = result;
  return result;
}

void Nightingale::uiProcessForLstm::prepareUiLogForDL(uint64_t a1, uint64_t a2, uint64_t a3, float **a4, float **a5)
{
  if (*(unsigned char *)(a2 + 4))
  {
    if (*(unsigned char *)(a2 + 12)) {
      BOOL v5 = *(unsigned char *)(a2 + 20) == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5)
    {
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)a2;
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 8);
      Nightingale::uiProcessForLstm::prepareDLSliceFlow((uint64_t **)a1, a2, a3);
      Nightingale::uiProcessForLstm::prepareDLSliceCycleMeanStd(a1, v9, a4, a5);
    }
  }
}

void Nightingale::uiProcessForLstm::prepareDLSliceFlow(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = a1[2];
  if (*((unsigned char *)v5 + 12)) {
    unint64_t v6 = (int *)(v5 + 1);
  }
  else {
    unint64_t v6 = (int *)&Nightingale::DEFAULT_PERIOD_LEN_EXTEND_1DAYPERIOD;
  }
  int v7 = *v6;
  uint64_t IdxOfDailyInGreaterThanJayDay = Nightingale::getIdxOfDailyInGreaterThanJayDay((uint64_t)*a1, *((_DWORD *)a1 + 12));
  if ((IdxOfDailyInGreaterThanJayDay & 0xFF00000000) != 0)
  {
    int v60 = IdxOfDailyInGreaterThanJayDay;
    __n128 __p = 0;
    unint64_t v62 = 0;
    unint64_t v63 = 0;
    uint64_t v9 = a1[1];
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    if (*v9 != v11)
    {
      unint64_t v12 = 0;
      do
      {
        if (*(unsigned char *)(v10 + 8)) {
          BOOL v13 = *(_DWORD *)v10 == *(_DWORD *)(v10 + 4);
        }
        else {
          BOOL v13 = 0;
        }
        BOOL v14 = !v13 || v7 < 2;
        if (!v14)
        {
          int v15 = 1;
          do
          {
            int v16 = *(_DWORD *)v10 + v15;
            if (v16 >= *((_DWORD *)a1 + 12) && v16 <= *((_DWORD *)a1 + 13))
            {
              if (v12 >= (int *)v63)
              {
                unint64_t v18 = __p;
                uint64_t v19 = v12 - __p;
                unint64_t v20 = v19 + 1;
                if ((unint64_t)(v19 + 1) >> 62) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v21 = v63 - (char *)__p;
                if ((v63 - (char *)__p) >> 1 > v20) {
                  unint64_t v20 = v21 >> 1;
                }
                if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
                  unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v22 = v20;
                }
                if (v22)
                {
                  uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v63, v22);
                  unint64_t v18 = __p;
                  unint64_t v12 = v62;
                }
                else
                {
                  uint64_t v23 = 0;
                }
                int v24 = (int *)&v23[4 * v19];
                *int v24 = v16;
                uint64_t v17 = v24 + 1;
                while (v12 != v18)
                {
                  int v25 = *--v12;
                  *--int v24 = v25;
                }
                __n128 __p = v24;
                unint64_t v63 = &v23[4 * v22];
                if (v18) {
                  operator delete(v18);
                }
              }
              else
              {
                *unint64_t v12 = v16;
                uint64_t v17 = v12 + 1;
              }
              unint64_t v62 = v17;
              unint64_t v12 = v17;
            }
            ++v15;
          }
          while (v15 != v7);
        }
        v10 += 96;
      }
      while (v10 != v11);
    }
    int v26 = *((_DWORD *)a1 + 12);
    if (v26 <= *((_DWORD *)a1 + 13))
    {
      int v27 = v60;
      do
      {
        uint64_t v28 = **a1;
        if (0xEEEEEEEEEEEEEEEFLL * (((*a1)[1] - v28) >> 2) > v27 && v26 == *(_DWORD *)(v28 + 60 * v27))
        {
          uint64_t v29 = *(int *)(v28 + 60 * v27 + 4);
          int v30 = 0;
          if (v29 <= 4) {
            int v30 = dword_257D5F764[v29];
          }
          uint64_t v32 = *(float **)(a3 + 8);
          unint64_t v31 = *(void *)(a3 + 16);
          if ((unint64_t)v32 >= v31)
          {
            unint64_t v44 = *(float **)a3;
            uint64_t v45 = ((uint64_t)v32 - *(void *)a3) >> 2;
            unint64_t v46 = v45 + 1;
            if ((unint64_t)(v45 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v47 = v31 - (void)v44;
            if (v47 >> 1 > v46) {
              unint64_t v46 = v47 >> 1;
            }
            if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v48 = v46;
            }
            if (v48)
            {
              char v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v48);
              unint64_t v44 = *(float **)a3;
              uint64_t v32 = *(float **)(a3 + 8);
            }
            else
            {
              char v49 = 0;
            }
            int v50 = &v49[4 * v45];
            *(_DWORD *)int v50 = v30;
            float v33 = v50 + 4;
            while (v32 != v44)
            {
              int v51 = *((_DWORD *)v32-- - 1);
              *((_DWORD *)v50 - 1) = v51;
              v50 -= 4;
            }
            *(void *)a3 = v50;
            *(void *)(a3 + 8) = v33;
            *(void *)(a3 + 16) = &v49[4 * v48];
            if (v44) {
              operator delete(v44);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v32 = v30;
            float v33 = v32 + 1;
          }
          *(void *)(a3 + 8) = v33;
          ++v27;
        }
        else
        {
          uint64_t v35 = *(float **)(a3 + 8);
          unint64_t v34 = *(void *)(a3 + 16);
          if ((unint64_t)v35 >= v34)
          {
            uint64_t v36 = *(float **)a3;
            uint64_t v37 = ((uint64_t)v35 - *(void *)a3) >> 2;
            unint64_t v38 = v37 + 1;
            if ((unint64_t)(v37 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v39 = v34 - (void)v36;
            if (v39 >> 1 > v38) {
              unint64_t v38 = v39 >> 1;
            }
            if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v40 = v38;
            }
            if (v40)
            {
              unint64_t v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v40);
              uint64_t v36 = *(float **)a3;
              uint64_t v35 = *(float **)(a3 + 8);
            }
            else
            {
              unint64_t v41 = 0;
            }
            uint64_t v42 = &v41[4 * v37];
            *(_DWORD *)uint64_t v42 = 0;
            float v33 = v42 + 4;
            while (v35 != v36)
            {
              int v43 = *((_DWORD *)v35-- - 1);
              *((_DWORD *)v42 - 1) = v43;
              v42 -= 4;
            }
            *(void *)a3 = v42;
            *(void *)(a3 + 8) = v33;
            *(void *)(a3 + 16) = &v41[4 * v40];
            if (v36) {
              operator delete(v36);
            }
          }
          else
          {
            *uint64_t v35 = 0.0;
            float v33 = v35 + 1;
          }
          *(void *)(a3 + 8) = v33;
        }
        if (__p != v62 && v26 == *__p && v27 >= 1)
        {
          unint64_t v53 = (v27 - 1);
          uint64_t v54 = **a1;
          if (0xEEEEEEEEEEEEEEEFLL * (((*a1)[1] - v54) >> 2) <= v53) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          if ((*(_DWORD *)(v54 + 60 * v53 + 4) - 5) <= 0xFFFFFFFB) {
            *(v33 - 1) = 0x40000000;
          }
          if (v62 != __p + 1) {
            memmove(__p, __p + 1, (char *)v62 - (char *)(__p + 1));
          }
          --v62;
        }
        BOOL v14 = v26++ < *((_DWORD *)a1 + 13);
      }
      while (v14);
    }
    uint64_t v55 = *(float **)a3;
    uint64_t v56 = *(void *)(a3 + 8);
    if (*(void *)a3 != v56)
    {
      float v57 = *((float *)a1 + 7);
      if (v57 != 0.0)
      {
        float v58 = *((float *)a1 + 6);
        unint64_t v59 = (v56 - (uint64_t)v55) >> 2;
        if (v59 <= 1) {
          unint64_t v59 = 1;
        }
        do
        {
          *uint64_t v55 = (float)(*v55 - v58) / v57;
          ++v55;
          --v59;
        }
        while (v59);
      }
    }
    if (__p) {
      operator delete(__p);
    }
  }
}

void sub_257D31F5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::uiProcessForLstm::prepareDLSliceCycleMeanStd(uint64_t a1, uint64_t a2, float **a3, float **a4)
{
  BOOL v5 = *(uint64_t **)(a1 + 8);
  uint64_t v6 = *v5;
  unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5[1] - *v5) >> 5);
  if ((int)v7 >= 2)
  {
    int v10 = v7 - 1;
    uint64_t v11 = -1431655765 * ((v5[1] - *v5) >> 5);
    for (uint64_t i = 96 * v7; ; i -= 96)
    {
      unint64_t v13 = (v11 - 1);
      if (v7 <= v13) {
        goto LABEL_36;
      }
      int v14 = *(_DWORD *)(v6 + 96 * v13);
      int v15 = *(_DWORD *)(a1 + 48);
      BOOL v16 = __OFSUB__(v15, v14);
      int v17 = v15 - v14;
      if (v17 < 0 == v16) {
        break;
      }
      if ((int)--v11 <= 0) {
        return;
      }
    }
    uint64_t v18 = v6 + 96 * v13;
    if (*(unsigned char *)(v18 + 36))
    {
      uint64_t v19 = v6 + 96 * v13;
      if (*(unsigned char *)(v19 + 44))
      {
        float v20 = roundf(*(float *)(v18 + 32)) - (float)v17;
        float v21 = sqrtf(*(float *)(v19 + 40));
        int v22 = *(_DWORD *)(a1 + 52);
        uint64_t v23 = v6 + 96 * v13;
        if (*(unsigned char *)(v23 + 24))
        {
          int v24 = *(_DWORD *)(v23 + 20);
          if (v22 >= v24) {
            int v22 = v24;
          }
        }
        Nightingale::uiProcessForLstm::fillUpMeanStdVec(v20, v21, (uint64_t)v5, v15, v22, (uint64_t)a3, (uint64_t)a4);
        if ((int)v11 < v10)
        {
          uint64_t v26 = 0;
          while (1)
          {
            int v25 = *(uint64_t **)(a1 + 8);
            uint64_t v27 = *v25;
            if (0xAAAAAAAAAAAAAAABLL * ((v25[1] - *v25) >> 5) <= v11 + v26) {
              break;
            }
            uint64_t v28 = v27 + i;
            if (*(unsigned char *)(v27 + i + 36))
            {
              if (*(unsigned char *)(v28 + 44))
              {
                uint64_t v29 = v27 + i;
                if (*(unsigned char *)(v29 + 24)) {
                  Nightingale::uiProcessForLstm::fillUpMeanStdVec(roundf(*(float *)(v28 + 32)), sqrtf(*(float *)(v28 + 40)), (uint64_t)v25, *(_DWORD *)v28, *(_DWORD *)(v29 + 20), (uint64_t)a3, (uint64_t)a4);
                }
              }
            }
            int v30 = v11 + v26++;
            i += 96;
            if (v10 <= v30 + 1) {
              goto LABEL_21;
            }
          }
LABEL_36:
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
LABEL_21:
        uint64_t v31 = *(void *)(*(void *)(a1 + 8) + 8);
        int v32 = *(_DWORD *)(v31 - 96);
        if (*(_DWORD *)(a1 + 48) < v32 && *(unsigned char *)(v31 - 60) && *(unsigned char *)(v31 - 52)) {
          Nightingale::uiProcessForLstm::fillUpMeanStdVec(roundf(*(float *)(v31 - 64)), sqrtf(*(float *)(v31 - 56)), (uint64_t)v25, v32, *(_DWORD *)(a1 + 52), (uint64_t)a3, (uint64_t)a4);
        }
        float v33 = *a3;
        unint64_t v34 = a3[1];
        if (*a3 != v34)
        {
          float v35 = *(float *)(a1 + 36);
          if (v35 != 0.0)
          {
            float v36 = *(float *)(a1 + 32);
            unint64_t v37 = v34 - v33;
            if (v37 <= 1) {
              unint64_t v37 = 1;
            }
            do
            {
              *float v33 = (float)(*v33 - v36) / v35;
              ++v33;
              --v37;
            }
            while (v37);
          }
        }
        unint64_t v38 = *a4;
        uint64_t v39 = a4[1];
        if (*a4 != v39)
        {
          float v40 = *(float *)(a1 + 44);
          if (v40 != 0.0)
          {
            float v41 = *(float *)(a1 + 40);
            unint64_t v42 = v39 - v38;
            if (v42 <= 1) {
              unint64_t v42 = 1;
            }
            do
            {
              *unint64_t v38 = (float)(*v38 - v41) / v40;
              ++v38;
              --v42;
            }
            while (v42);
          }
        }
      }
    }
  }
}

void Nightingale::uiProcessForLstm::fillUpMeanStdVec(float a1, float a2, uint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  if (a4 <= a5)
  {
    int v10 = a4;
    uint64_t v13 = a6 + 16;
    uint64_t v14 = a7 + 16;
    do
    {
      BOOL v16 = *(float **)(a6 + 8);
      unint64_t v15 = *(void *)(a6 + 16);
      if ((unint64_t)v16 >= v15)
      {
        uint64_t v18 = *(float **)a6;
        uint64_t v19 = ((uint64_t)v16 - *(void *)a6) >> 2;
        unint64_t v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v21 = v15 - (void)v18;
        if (v21 >> 1 > v20) {
          unint64_t v20 = v21 >> 1;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v20;
        }
        if (v22)
        {
          uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v13, v22);
          uint64_t v18 = *(float **)a6;
          BOOL v16 = *(float **)(a6 + 8);
        }
        else
        {
          uint64_t v23 = 0;
        }
        int v24 = (float *)&v23[4 * v19];
        *int v24 = a1;
        int v17 = v24 + 1;
        while (v16 != v18)
        {
          int v25 = *((_DWORD *)v16-- - 1);
          *((_DWORD *)v24-- - 1) = v25;
        }
        *(void *)a6 = v24;
        *(void *)(a6 + 8) = v17;
        *(void *)(a6 + 16) = &v23[4 * v22];
        if (v18) {
          operator delete(v18);
        }
      }
      else
      {
        *BOOL v16 = a1;
        int v17 = v16 + 1;
      }
      *(void *)(a6 + 8) = v17;
      uint64_t v27 = *(float **)(a7 + 8);
      unint64_t v26 = *(void *)(a7 + 16);
      if ((unint64_t)v27 >= v26)
      {
        uint64_t v29 = *(float **)a7;
        uint64_t v30 = ((uint64_t)v27 - *(void *)a7) >> 2;
        unint64_t v31 = v30 + 1;
        if ((unint64_t)(v30 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v32 = v26 - (void)v29;
        if (v32 >> 1 > v31) {
          unint64_t v31 = v32 >> 1;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v33 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v31;
        }
        if (v33)
        {
          unint64_t v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v14, v33);
          uint64_t v29 = *(float **)a7;
          uint64_t v27 = *(float **)(a7 + 8);
        }
        else
        {
          unint64_t v34 = 0;
        }
        float v35 = (float *)&v34[4 * v30];
        *float v35 = a2;
        uint64_t v28 = v35 + 1;
        while (v27 != v29)
        {
          int v36 = *((_DWORD *)v27-- - 1);
          *((_DWORD *)v35-- - 1) = v36;
        }
        *(void *)a7 = v35;
        *(void *)(a7 + 8) = v28;
        *(void *)(a7 + 16) = &v34[4 * v33];
        if (v29) {
          operator delete(v29);
        }
      }
      else
      {
        *uint64_t v27 = a2;
        uint64_t v28 = v27 + 1;
      }
      a1 = a1 + -1.0;
      *(void *)(a7 + 8) = v28;
    }
    while (v10++ != a5);
  }
}

char *std::vector<std::pair<int,int>>::__assign_with_size[abi:ne180100]<std::pair<int,int>*,std::pair<int,int>*>(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  __n128 result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 3)
  {
    uint64_t v18 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v18;
    unint64_t v19 = (v18 - result) >> 3;
    if (v19 >= a4)
    {
      unint64_t v26 = result;
      if (a2 != a3)
      {
        uint64_t v27 = result;
        do
        {
          uint64_t v28 = *v6++;
          *(void *)uint64_t v27 = v28;
          v27 += 8;
          v26 += 8;
        }
        while (v6 != a3);
      }
      int v17 = (char *)(v26 - result);
      unint64_t v12 = result;
    }
    else
    {
      unint64_t v20 = &a2[v19];
      if (v12 != result)
      {
        uint64_t v21 = 8 * v19;
        do
        {
          uint64_t v22 = *v6++;
          *(void *)__n128 result = v22;
          result += 8;
          v21 -= 8;
        }
        while (v21);
      }
      uint64_t v23 = v12;
      if (v20 != a3)
      {
        int v24 = v12;
        do
        {
          uint64_t v25 = *v20++;
          *(void *)int v24 = v25;
          v24 += 8;
          v23 += 8;
        }
        while (v20 != a3);
      }
      int v17 = (char *)(v23 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](a1, v11);
    uint64_t v14 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    unint64_t v12 = v14;
    unint64_t v15 = v14;
    if (v6 != a3)
    {
      unint64_t v15 = v12;
      do
      {
        uint64_t v16 = *v6++;
        *(void *)unint64_t v15 = v16;
        v15 += 8;
      }
      while (v6 != a3);
    }
    int v17 = (char *)(v15 - v12);
  }
  void *v13 = &v17[(void)v12];
  return result;
}

void *std::vector<Nightingale::cycleInfo>::__init_with_size[abi:ne180100]<Nightingale::cycleInfo*,Nightingale::cycleInfo*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<Nightingale::cycleInfo>::__vallocate[abi:ne180100](result, a4);
    __n128 result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*,Nightingale::cycleInfo*,Nightingale::cycleInfo*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_257D325A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<Nightingale::cycleInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x2AAAAAAAAAAAAABLL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[96 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*,Nightingale::cycleInfo*,Nightingale::cycleInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v13 = a4;
  uint64_t v14 = a4;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  char v12 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)v6;
      long long v7 = *(_OWORD *)(v6 + 16);
      long long v8 = *(_OWORD *)(v6 + 32);
      long long v9 = *(_OWORD *)(v6 + 48);
      *(void *)(v4 + 61) = *(void *)(v6 + 61);
      *(_OWORD *)(v4 + 32) = v8;
      *(_OWORD *)(v4 + 48) = v9;
      *(_OWORD *)(v4 + 16) = v7;
      *(void *)(v4 + 80) = 0;
      *(void *)(v4 + 88) = 0;
      *(void *)(v4 + 72) = 0;
      std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)(v4 + 72), *(const void **)(v6 + 72), *(void *)(v6 + 80), *(void *)(v6 + 80) - *(void *)(v6 + 72));
      uint64_t v4 = v14 + 96;
      v14 += 96;
      v6 += 96;
    }
    while (v6 != a3);
  }
  char v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v4;
}

void sub_257D326D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 - 24);
    if (v3)
    {
      *(void *)(v1 - 16) = v3;
      operator delete(v3);
    }
    v1 -= 96;
  }
}

void std::vector<Nightingale::cycleInfo>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<Nightingale::cycleInfo>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  BOOL v5 = v6;
  long long v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    long long v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      long long v8 = *a1;
      long long v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[4 * v11];
    uint64_t v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    int v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void OUTLINED_FUNCTION_0_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

void OUTLINED_FUNCTION_1_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

void OUTLINED_FUNCTION_2_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 2u);
}

double OUTLINED_FUNCTION_6@<D0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(v2 - 8) = a2;
  return *(float *)(*a1 - 4);
}

void OUTLINED_FUNCTION_7(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

unsigned char *OUTLINED_FUNCTION_9(unsigned char *result, unsigned char *a2)
{
  *__n128 result = 0;
  *a2 = 0;
  return result;
}

double OUTLINED_FUNCTION_10(float a1, float a2, uint64_t a3, uint64_t a4, double *a5, uint64_t a6, float *a7)
{
  double result = a1;
  *a7 = a2;
  *a5 = result;
  return result;
}

void OUTLINED_FUNCTION_11(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_debug_impl(a1, a4, OS_LOG_TYPE_DEBUG, a2, a3, 8u);
}

uint64_t Nightingale::slidingWindowBaseLuna::slidingWindowBaseLuna(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_270697298;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v5 = operator new(0x1CuLL);
  void *v4 = v5;
  _OWORD *v5 = xmmword_257D5F7A0;
  *(_OWORD *)((char *)v5 + 12) = *(long long *)((char *)&xmmword_257D5F7A0 + 12);
  *(void *)(a1 + 16) = (char *)v5 + 28;
  *(void *)(a1 + 24) = (char *)v5 + 28;
  *(void *)(a1 + 32) = a2;
  Nightingale::slidingWindowBaseLuna::slidingWinConfigStruct::slidingWinConfigStruct((Nightingale::slidingWindowBaseLuna::slidingWinConfigStruct *)(a1 + 40));
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 124) = 0;
  *(unsigned char *)(a1 + 128) = 0;
  *(unsigned char *)(a1 + 132) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(unsigned char *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 144) = 0;
  *(unsigned char *)(a1 + 148) = 0;
  Nightingale::wristTemperatureInputValidation::wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)(a1 + 152));
  *(unsigned char *)(a1 + 232) = 0;
  *(_OWORD *)(a1 + 156) = 0u;
  *(_OWORD *)(a1 + 172) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(void *)(a1 + 236) = 0xFFFFFFFFLL;
  *(int32x2_t *)(a1 + 244) = vdup_n_s32(0x7FC00000u);
  *(_DWORD *)(a1 + 252) = 2143289344;
  *(unsigned char *)(a1 + 256) = 0;
  *(void *)(a1 + 260) = 0x800000008;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 288) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 296) = 0;
  return a1;
}

void sub_257D32AB8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = (void *)v1[6];
  if (v4)
  {
    v1[7] = v4;
    operator delete(v4);
  }
  uint64_t v5 = *v2;
  if (*v2)
  {
    v1[2] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::slidingWindowBaseLuna::~slidingWindowBaseLuna(Nightingale::slidingWindowBaseLuna *this)
{
  *(void *)this = &unk_270697298;
  uint64_t v2 = (void *)*((void *)this + 34);
  if (v2) {
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 24);
  if (v3) {
    operator delete(v3);
  }
  uint64_t v6 = (void **)((char *)this + 160);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::slidingWindowBaseLuna *)((char *)this + 152));
  uint64_t v4 = (void *)*((void *)this + 6);
  if (v4)
  {
    *((void *)this + 7) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    *((void *)this + 2) = v5;
    operator delete(v5);
  }
}

void Nightingale::slidingWindowBaseLuna::process(unsigned char *a1@<X0>, void *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(void *)a4 = 0xFFFFFFFFLL;
  *(int32x2_t *)(a4 + 8) = vdup_n_s32(0x7FC00000u);
  *(_DWORD *)(a4 + 16) = 2143289344;
  *(unsigned char *)(a4 + 20) = 0;
  *(_DWORD *)(a4 + 24) = 8;
  if (Nightingale::slidingWindowBaseLuna::validateConfigurationPass((Nightingale::slidingWindowBaseLuna *)a1))
  {
    (*(void (**)(unsigned char *))(*(void *)a1 + 8))(a1);
    if (a1[124])
    {
      if (a1[132])
      {
        Nightingale::slidingWindowBaseLuna::acquireWTmp((uint64_t)a1, a2, *((_DWORD *)a1 + 30) + **((_DWORD **)a1 + 4) - *((_DWORD *)a1 + 10) + 1, *((_DWORD *)a1 + 32) + *((_DWORD *)a1 + 11) + **((_DWORD **)a1 + 4), v10);
        if (Nightingale::assertVectorOfVectors((uint64_t)v10))
        {
          Nightingale::slidingWindowBaseLuna::validateWTmp((uint64_t)a1, (uint64_t)v10, *((_DWORD *)a1 + 10), (void *)a1 + 6, (uint64_t *)&v8);
          std::vector<std::vector<float>>::__vdeallocate((uint64_t *)a1 + 20);
          *((_OWORD *)a1 + 10) = v8;
          *((void *)a1 + 22) = v9;
          uint64_t v9 = 0;
          long long v8 = 0uLL;
          uint64_t v11 = (void **)&v8;
          std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v11);
          (*(void (**)(unsigned char *, void *))(*(void *)a1 + 16))(a1, v10);
          if (a1[232] && a1[124]) {
            *((_DWORD *)a1 + 59) = *((_DWORD *)a1 + 30) + *((_DWORD *)a1 + 54) + **((_DWORD **)a1 + 4);
          }
          *((_DWORD *)a1 + 66) = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 40))(a1);
          (*(void (**)(unsigned char *))(*(void *)a1 + 48))(a1);
          if (a3) {
            (*(void (**)(unsigned char *))(*(void *)a1 + 32))(a1);
          }
          *(_OWORD *)a4 = *(_OWORD *)(a1 + 236);
          *(_OWORD *)(a4 + 12) = *(_OWORD *)(a1 + 248);
          Nightingale::slidingWindowBaseLuna::reset((Nightingale::slidingWindowBaseLuna *)a1);
        }
        else
        {
          *(void *)(a4 + 4) = 1;
          *(_DWORD *)(a4 + 24) = 1;
        }
        *(void *)&long long v8 = v10;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v8);
      }
    }
  }
}

void sub_257D32DC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  a9 = (void **)&a13;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

BOOL Nightingale::slidingWindowBaseLuna::validateConfigurationPass(Nightingale::slidingWindowBaseLuna *this)
{
  if ((*((_DWORD *)this + 10) & 0x80000000) != 0
    || (*((_DWORD *)this + 11) & 0x80000000) != 0
    || *((int *)this + 19) < 1)
  {
    return 0;
  }
  uint64_t v1 = *((void *)this + 4);
  int v2 = *(_DWORD *)(v1 + 4);
  if (v2)
  {
    if (v2 >= 1 && *(_DWORD *)v1 > v2) {
      return 0;
    }
  }
  else if (!*(unsigned char *)(v1 + 12))
  {
    return 0;
  }
  return *((void *)this + 6) != *((void *)this + 7);
}

void Nightingale::slidingWindowBaseLuna::acquireWTmp(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W2>, int a4@<W3>, void *a5@<X8>)
{
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v24);
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v23);
  memset(v22, 0, sizeof(v22));
  if (a4 - a3 >= 0 && *(unsigned char *)(a1 + 132) && *(unsigned char *)(a1 + 124))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (!*(unsigned char *)(v10 + 24)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(v24, a4 - a3 + 1, a4, a3 - 43, a2, *(void *)(v10 + 16), (uint64_t)v17);
    if (!*(unsigned char *)(a1 + 132) || !*(unsigned char *)(a1 + 124)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    Nightingale::wristTemperatureInputProcess::constructVectorOfSlicesFromMultipleWatches((Nightingale::extractKaliInputsRtn *)v17, *(_DWORD *)(a1 + 44) + *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 128) - *(_DWORD *)(a1 + 120) + 1, a3, (uint64_t)&v11);
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
    std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a5, (uint64_t)v11, v12, 0xAAAAAAAAAAAAAAABLL * ((v12 - (uint64_t)v11) >> 3));
    if (__p)
    {
      uint64_t v16 = __p;
      operator delete(__p);
    }
    if (v13)
    {
      uint64_t v14 = v13;
      operator delete(v13);
    }
    uint64_t v25 = (void ***)&v11;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v25);
    if (v20)
    {
      uint64_t v21 = v20;
      operator delete(v20);
    }
    if (v18)
    {
      unint64_t v19 = v18;
      operator delete(v18);
    }
    uint64_t v11 = v17;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v11);
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
    a5[2] = 0;
  }
  v17[0] = (void **)v22;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v17);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v23);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v24);
}

void sub_257D32FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void **a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  Nightingale::pickSlicesStruct::~pickSlicesStruct((Nightingale::pickSlicesStruct *)&a10);
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn((Nightingale::extractKaliInputsRtn *)&a19);
  a19 = (void **)&a29;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a19);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(v29 - 129));
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(v29 - 128));
  _Unwind_Resume(a1);
}

void Nightingale::slidingWindowBaseLuna::validateWTmp(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, void *a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  if (*a4 == a4[1] || (Nightingale::assertVectorOfVectors(a2) & 1) == 0) {
    return;
  }
  memset(v63, 0, sizeof(v63));
  __n128 __p = &unk_2706971D0;
  int v65 = (char *)Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpMissingCntHigh;
  unint64_t v66 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v63, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  __n128 __p = &unk_2706971D0;
  int v65 = (char *)Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpEarlyWinMissingCntHigh;
  unint64_t v66 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v63, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  __n128 __p = &unk_2706971D0;
  int v65 = (char *)Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpLaterWinMissingCntHigh;
  unint64_t v66 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v63, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  __n128 __p = &unk_2706971D0;
  int v65 = (char *)Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpDay2dayNoiseHigh;
  unint64_t v66 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v63, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  __n128 __p = &unk_2706971D0;
  int v65 = (char *)Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpSnrLow;
  unint64_t v66 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v63, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  int v65 = 0;
  unint64_t v66 = 0;
  __n128 __p = 0;
  uint64_t v11 = **(void **)a2;
  uint64_t v10 = *(void *)(*(void *)a2 + 8);
  unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v66, 1uLL);
  uint64_t v14 = (char *)__p;
  unint64_t v15 = v65;
  uint64_t v16 = &v13[4 * v12];
  *(_DWORD *)unint64_t v13 = (unint64_t)(v10 - v11) >> 2;
  int v17 = v13 + 4;
  int v18 = v13;
  while (v15 != v14)
  {
    int v19 = *((_DWORD *)v15 - 1);
    v15 -= 4;
    *((_DWORD *)v18 - 1) = v19;
    v18 -= 4;
  }
  __n128 __p = v18;
  int v65 = v13 + 4;
  unint64_t v66 = &v13[4 * v12];
  if (v14)
  {
    operator delete(v14);
    uint64_t v16 = v66;
  }
  int v65 = v13 + 4;
  if (v17 >= v16)
  {
    uint64_t v21 = (char *)__p;
    uint64_t v22 = (v17 - (unsigned char *)__p) >> 2;
    unint64_t v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 62) {
      goto LABEL_84;
    }
    uint64_t v24 = v16 - (unsigned char *)__p;
    if (v24 >> 1 > v23) {
      unint64_t v23 = v24 >> 1;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v23;
    }
    if (v25)
    {
      unint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v66, v25);
      uint64_t v21 = (char *)__p;
      int v17 = v65;
    }
    else
    {
      unint64_t v26 = 0;
    }
    uint64_t v27 = &v26[4 * v22];
    uint64_t v16 = &v26[4 * v25];
    *(_DWORD *)uint64_t v27 = a3;
    unint64_t v20 = v27 + 4;
    while (v17 != v21)
    {
      int v28 = *((_DWORD *)v17 - 1);
      v17 -= 4;
      *((_DWORD *)v27 - 1) = v28;
      v27 -= 4;
    }
    __n128 __p = v27;
    int v65 = v20;
    unint64_t v66 = v16;
    if (v21)
    {
      operator delete(v21);
      uint64_t v16 = v66;
    }
  }
  else
  {
    *((_DWORD *)v13 + 1) = a3;
    unint64_t v20 = v13 + 8;
  }
  int v65 = v20;
  if (v20 >= v16)
  {
    uint64_t v30 = (char *)__p;
    uint64_t v31 = (v20 - (unsigned char *)__p) >> 2;
    unint64_t v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 62) {
      goto LABEL_84;
    }
    uint64_t v33 = v16 - (unsigned char *)__p;
    if (v33 >> 1 > v32) {
      unint64_t v32 = v33 >> 1;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v34 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v34 = v32;
    }
    if (v34)
    {
      float v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v66, v34);
      uint64_t v30 = (char *)__p;
      unint64_t v20 = v65;
    }
    else
    {
      float v35 = 0;
    }
    int v36 = &v35[4 * v31];
    uint64_t v16 = &v35[4 * v34];
    *(_DWORD *)int v36 = a3;
    uint64_t v29 = v36 + 4;
    while (v20 != v30)
    {
      int v37 = *((_DWORD *)v20 - 1);
      v20 -= 4;
      *((_DWORD *)v36 - 1) = v37;
      v36 -= 4;
    }
    __n128 __p = v36;
    int v65 = v29;
    unint64_t v66 = v16;
    if (v30)
    {
      operator delete(v30);
      uint64_t v16 = v66;
    }
  }
  else
  {
    *(_DWORD *)unint64_t v20 = a3;
    uint64_t v29 = v20 + 4;
  }
  int v65 = v29;
  if (v29 >= v16)
  {
    uint64_t v39 = (char *)__p;
    uint64_t v40 = (v29 - (unsigned char *)__p) >> 2;
    unint64_t v41 = v40 + 1;
    if ((unint64_t)(v40 + 1) >> 62) {
      goto LABEL_84;
    }
    uint64_t v42 = v16 - (unsigned char *)__p;
    if (v42 >> 1 > v41) {
      unint64_t v41 = v42 >> 1;
    }
    if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v43 = v41;
    }
    if (v43)
    {
      unint64_t v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v66, v43);
      uint64_t v39 = (char *)__p;
      uint64_t v29 = v65;
    }
    else
    {
      unint64_t v44 = 0;
    }
    uint64_t v45 = &v44[4 * v40];
    uint64_t v16 = &v44[4 * v43];
    *(_DWORD *)uint64_t v45 = a3;
    unint64_t v38 = v45 + 4;
    while (v29 != v39)
    {
      int v46 = *((_DWORD *)v29 - 1);
      v29 -= 4;
      *((_DWORD *)v45 - 1) = v46;
      v45 -= 4;
    }
    __n128 __p = v45;
    int v65 = v38;
    unint64_t v66 = v16;
    if (v39)
    {
      operator delete(v39);
      uint64_t v16 = v66;
    }
  }
  else
  {
    *(_DWORD *)uint64_t v29 = a3;
    unint64_t v38 = v29 + 4;
  }
  int v65 = v38;
  if (v38 >= v16)
  {
    unint64_t v48 = (char *)__p;
    uint64_t v49 = (v38 - (unsigned char *)__p) >> 2;
    unint64_t v50 = v49 + 1;
    if (!((unint64_t)(v49 + 1) >> 62))
    {
      uint64_t v51 = v16 - (unsigned char *)__p;
      if (v51 >> 1 > v50) {
        unint64_t v50 = v51 >> 1;
      }
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v52 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v52 = v50;
      }
      if (v52)
      {
        unint64_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v66, v52);
        unint64_t v48 = (char *)__p;
        unint64_t v38 = v65;
      }
      else
      {
        unint64_t v53 = 0;
      }
      uint64_t v54 = &v53[4 * v49];
      uint64_t v55 = &v53[4 * v52];
      *(_DWORD *)uint64_t v54 = a3;
      uint64_t v47 = v54 + 4;
      while (v38 != v48)
      {
        int v56 = *((_DWORD *)v38 - 1);
        v38 -= 4;
        *((_DWORD *)v54 - 1) = v56;
        v54 -= 4;
      }
      __n128 __p = v54;
      int v65 = v47;
      unint64_t v66 = v55;
      if (v48) {
        operator delete(v48);
      }
      goto LABEL_72;
    }
LABEL_84:
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  *(_DWORD *)unint64_t v38 = a3;
  uint64_t v47 = v38 + 4;
LABEL_72:
  int v65 = v47;
  *(_DWORD *)(a1 + 156) = (unint64_t)(v47 - (unsigned char *)__p) >> 2;
  Nightingale::wristTemperatureInputValidation::wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)&v62);
  float v58 = *(uint64_t **)a2;
  float v57 = *(uint64_t **)(a2 + 8);
  while (v58 != v57)
  {
    Nightingale::wristTemperatureInputValidation::checkListOfConditions((uint64_t)&v62, v63, (uint64_t)v58, &__p, a4, *(unsigned char *)(a1 + 72), v61);
    unint64_t v59 = a5[1];
    if (v59 >= a5[2])
    {
      uint64_t v60 = std::vector<std::vector<std::pair<BOOL,float>>>::__push_back_slow_path<std::vector<std::pair<BOOL,float>> const&>(a5, (uint64_t **)v61);
    }
    else
    {
      std::vector<std::vector<std::pair<BOOL,float>>>::__construct_one_at_end[abi:ne180100]<std::vector<std::pair<BOOL,float>> const&>((uint64_t)a5, (uint64_t **)v61);
      uint64_t v60 = v59 + 24;
    }
    a5[1] = v60;
    if (v61[0])
    {
      v61[1] = v61[0];
      operator delete(v61[0]);
    }
    v58 += 3;
  }
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)&v62);
  if (__p)
  {
    int v65 = (char *)__p;
    operator delete(__p);
  }
  __n128 __p = v63;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_257D3361C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, uint64_t a18, char *__p, char *a20)
{
  if (__p)
  {
    a20 = __p;
    operator delete(__p);
  }
  __n128 __p = &a16;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

int32x2_t Nightingale::slidingWindowBaseLuna::reset(Nightingale::slidingWindowBaseLuna *this)
{
  std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 20);
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = 0;
  if (*((unsigned char *)this + 232)) {
    *((unsigned char *)this + 232) = 0;
  }
  *(void *)((char *)this + 236) = 0xFFFFFFFFLL;
  int v2 = (char *)this + 236;
  *(v2 - 116) = 0;
  *(v2 - 112) = 0;
  *(v2 - 108) = 0;
  *(v2 - 104) = 0;
  *(v2 - 100) = 0;
  *(v2 - 96) = 0;
  *(v2 - 92) = 0;
  *(v2 - 88) = 0;
  int32x2_t result = vdup_n_s32(0x7FC00000u);
  *((int32x2_t *)v2 + 1) = result;
  *((_DWORD *)v2 + 4) = 2143289344;
  v2[20] = 0;
  *((void *)v2 + 3) = 0x800000008;
  *(void *)(v2 + 44) = 0;
  *((_DWORD *)v2 + 15) = 0;
  return result;
}

float Nightingale::slidingWindowBaseLuna::getRollingScoreASlice(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(const void **)a2;
  unint64_t v5 = *(int *)(a1 + 40);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unint64_t v13 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v13, v4, (uint64_t)v4 + 4 * v5, v5);
  uint64_t v6 = *(void *)(a2 + 8);
  long long v7 = (const void *)(*(void *)a2 + 4 * *(int *)(a1 + 40));
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  __n128 __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v7, v6, (v6 - (uint64_t)v7) >> 2);
  float SlidingWinScore = Nightingale::getSlidingWinScore((uint64_t)&v13, (float **)&__p, -1.0);
  if (__p)
  {
    uint64_t v11 = __p;
    operator delete(__p);
  }
  if (v13)
  {
    uint64_t v14 = v13;
    operator delete(v13);
  }
  return SlidingWinScore;
}

void sub_257D337E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::slidingWindowBaseLuna::updateRollingBufferWithAVal(float a1, uint64_t a2, float **a3, int a4)
{
  long long v7 = *a3;
  uint64_t v6 = a3[1];
  if (*a3 == v6)
  {
    uint64_t v6 = *a3;
  }
  else if (a4 <= (unint64_t)(v6 - v7))
  {
    long long v8 = (char *)((char *)v6 - (char *)(v7 + 1));
    if (v6 != v7 + 1) {
      memmove(v7, v7 + 1, (char *)v6 - (char *)(v7 + 1));
    }
    uint64_t v6 = (float *)&v8[(void)v7];
    a3[1] = (float *)&v8[(void)v7];
  }
  unint64_t v9 = (unint64_t)a3[2];
  if ((unint64_t)v6 >= v9)
  {
    uint64_t v11 = *a3;
    uint64_t v12 = v6 - *a3;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v9 - (void)v11;
    if (v14 >> 1 > v13) {
      unint64_t v13 = v14 >> 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v15);
      uint64_t v11 = *a3;
      uint64_t v6 = a3[1];
    }
    else
    {
      uint64_t v16 = 0;
    }
    int v17 = (float *)&v16[4 * v12];
    int v18 = (float *)&v16[4 * v15];
    *int v17 = a1;
    uint64_t v10 = v17 + 1;
    while (v6 != v11)
    {
      int v19 = *((_DWORD *)v6-- - 1);
      *((_DWORD *)v17-- - 1) = v19;
    }
    *a3 = v17;
    a3[1] = v10;
    a3[2] = v18;
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    float *v6 = a1;
    uint64_t v10 = v6 + 1;
  }
  a3[1] = v10;
}

uint64_t Nightingale::slidingWindowBaseLuna::applyAlgorithm(uint64_t a1, uint64_t *a2)
{
  int v3 = ~(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 96)) - 1431655765 * ((unint64_t)(a2[1] - *a2) >> 3);
  int v4 = v3 & ~(v3 >> 31);
  *(_DWORD *)(a1 + 184) = v4;
  Nightingale::slidingWindowBaseLuna::findRollingOfRolling(a1, a2, *(unsigned __int8 *)(a1 + 88), v4, 1, 0, (uint64_t)&v6);
  *(_OWORD *)(a1 + 216) = v6;
  *(unsigned char *)(a1 + 232) = v7;
  return Nightingale::slidingWindowBaseLuna::updateSearchRsltWeakSignal(a1);
}

void Nightingale::slidingWindowBaseLuna::findRollingOfRolling(uint64_t a1@<X0>, uint64_t *a2@<X1>, int a3@<W2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, uint64_t a7@<X8>)
{
  *(unsigned char *)a7 = 0;
  *(unsigned char *)(a7 + 16) = 0;
  if (!Nightingale::assertVectorOfVectors((uint64_t)a2)) {
    return;
  }
  uint64_t OverallWTmpValidationRsltASlice = Nightingale::slidingWindowBaseLuna::checkNumContinuousSlicesFailAvailabilityOverThreshold((Nightingale::slidingWindowBaseLuna *)a1);
  if (OverallWTmpValidationRsltASlice) {
    return;
  }
  float v35 = 0;
  int v36 = 0;
  uint64_t v37 = 0;
  unint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v16 = *a2;
  uint64_t v15 = a2[1];
  int v27 = 1;
  if (*a2 == v15)
  {
    LODWORD(v18) = 0;
    float v21 = -1.0;
    float Mean = 0.0;
    float RollingScoreASlice = -1.0;
    if (!a6) {
      goto LABEL_32;
    }
  }
  else
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    float Mean = 0.0;
    float RollingScoreASlice = -1.0;
    float v21 = -1.0;
    do
    {
      uint64_t v22 = *(void *)(a1 + 160);
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 168) - v22) >> 3);
      if (v23 <= v18) {
        goto LABEL_40;
      }
      if (**(unsigned char **)(v22 + v17))
      {
        if (a5)
        {
          float v21 = -1.0;
          float RollingScoreASlice = -1.0;
        }
      }
      else
      {
        float RollingScoreASlice = Nightingale::slidingWindowBaseLuna::getRollingScoreASlice(a1, v16 + v17);
        float v21 = v24;
        uint64_t v22 = *(void *)(a1 + 160);
        unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 168) - v22) >> 3);
      }
      if (v23 <= v18) {
LABEL_40:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      if (**(unsigned char **)(v22 + v17)) {
        BOOL v25 = a5 == 0;
      }
      else {
        BOOL v25 = 0;
      }
      if (!v25)
      {
        Nightingale::slidingWindowBaseLuna::updateRollingBufferWithAVal(RollingScoreASlice, OverallWTmpValidationRsltASlice, (float **)&v35, *(_DWORD *)(a1 + 76));
        Nightingale::slidingWindowBaseLuna::updateRollingBufferWithAVal(v21, v26, (float **)&v32, *(_DWORD *)(a1 + 76));
      }
      if ((uint64_t)v18 >= a4)
      {
        uint64_t OverallWTmpValidationRsltASlice = Nightingale::slidingWindowBaseLuna::getOverallWTmpValidationRsltASlice((Nightingale::slidingWindowBaseLuna *)a1, v18);
        if ((OverallWTmpValidationRsltASlice & 1) == 0)
        {
          __n128 __p = 0;
          uint64_t v30 = 0;
          uint64_t v31 = 0;
          std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v35, (uint64_t)v36, (v36 - (unsigned char *)v35) >> 2);
          float Mean = Nightingale::getMeanWin<float>((float **)&__p, -1);
          if (__p)
          {
            uint64_t v30 = __p;
            operator delete(__p);
          }
          if (Mean <= *(float *)(a1 + 80) || Mean >= *(float *)(a1 + 84))
          {
            BOOL v28 = 1;
            std::vector<BOOL>::push_back(a1 + 272, &v28);
          }
          else
          {
            BOOL v28 = 0;
            std::vector<BOOL>::push_back(a1 + 272, &v28);
            if (a3)
            {
              int v27 = 0;
              *(void *)a7 = v18 | ((unint64_t)LODWORD(RollingScoreASlice) << 32);
              *(void *)(a7 + 8) = LODWORD(v21) | ((unint64_t)LODWORD(Mean) << 32);
              *(unsigned char *)(a7 + 16) = 1;
              goto LABEL_28;
            }
          }
        }
      }
      ++v18;
      v17 += 24;
    }
    while (v16 + v17 != v15);
    int v27 = 1;
LABEL_28:
    if (!a6) {
      goto LABEL_32;
    }
  }
  *(void *)(a1 + 280) = 0;
  BOOL v28 = Mean <= *(float *)(a1 + 80);
  std::vector<BOOL>::push_back(a1 + 272, &v28);
LABEL_32:
  if ((a3 & 1) == 0)
  {
    *(void *)a7 = v18 | ((unint64_t)LODWORD(RollingScoreASlice) << 32);
    *(void *)(a7 + 8) = LODWORD(v21) | ((unint64_t)LODWORD(Mean) << 32);
    if (v27) {
      *(unsigned char *)(a7 + 16) = 1;
    }
  }
  if (v32)
  {
    uint64_t v33 = v32;
    operator delete(v32);
  }
  if (v35)
  {
    int v36 = v35;
    operator delete(v35);
  }
}

void sub_257D33CCC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::slidingWindowBaseLuna::updateSearchRsltWeakSignal(uint64_t this)
{
  if (*(unsigned char *)(this + 140)
    && *(unsigned char *)(this + 124)
    && *(unsigned char *)(this + 232)
    && *(float *)(this + 220) < *(float *)(this + 108))
  {
    uint64_t v1 = *(void *)(this + 160);
    unint64_t v2 = *(int *)(this + 136) - (uint64_t)*(int *)(this + 120);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(this + 168) - v1) >> 3) <= v2) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    if (!**(unsigned char **)(v1 + 24 * v2)) {
      *(_DWORD *)(this + 216) = v2;
    }
  }
  return this;
}

uint64_t Nightingale::slidingWindowBaseLuna::checkNumContinuousSlicesFailAvailabilityOverThreshold(Nightingale::slidingWindowBaseLuna *this)
{
  if (!*((unsigned char *)this + 148)) {
    return 0;
  }
  uint64_t v1 = (unsigned char **)*((void *)this + 20);
  unint64_t v2 = (unsigned char **)*((void *)this + 21);
  if (v1 == v2) {
    return 0;
  }
  int v3 = 0;
  while (1)
  {
    if (!**v1)
    {
      LODWORD(v2) = 0;
      int v4 = 1;
      return v4 & v2;
    }
    if (++v3 >= *((_DWORD *)this + 36)) {
      break;
    }
    v1 += 3;
    if (v1 == v2)
    {
      int v4 = 0;
      return v4 & v2;
    }
  }
  int v4 = 1;
  LODWORD(v2) = 1;
  return v4 & v2;
}

BOOL Nightingale::slidingWindowBaseLuna::getOverallWTmpValidationRsltASlice(Nightingale::slidingWindowBaseLuna *this, int a2)
{
  uint64_t v2 = *((void *)this + 20);
  uint64_t v3 = *((void *)this + 21);
  if (v2 == v3 || 0xAAAAAAAAAAAAAAABLL * ((v3 - v2) >> 3) <= a2) {
    return 1;
  }
  int v4 = (uint64_t *)(v2 + 24 * a2);
  uint64_t v6 = *v4;
  uint64_t v5 = v4[1];
  if (v6 == v5) {
    return 0;
  }
  uint64_t v7 = v6 + 8;
  do
  {
    BOOL result = *(unsigned char *)(v7 - 8) != 0;
    if (*(unsigned char *)(v7 - 8)) {
      BOOL v9 = 1;
    }
    else {
      BOOL v9 = v7 == v5;
    }
    v7 += 8;
  }
  while (!v9);
  return result;
}

uint64_t Nightingale::slidingWindowBaseLuna::getSliceCenterOffsetRange(uint64_t this)
{
  int v1 = *(_DWORD *)(*(void *)(this + 32) + 4) - **(_DWORD **)(this + 32);
  int v2 = (int)(float)((float)(v1 + 1) + -13.0);
  int v3 = (v2 - *(_DWORD *)(this + 76) - 8) & ~((v2 - *(_DWORD *)(this + 76) - 8) >> 31);
  int v4 = v3 + 6;
  if (v1 >= v2 + 10) {
    int v1 = v2 + 10;
  }
  int v5 = v1 - 5;
  if (v1 - 5 >= v4)
  {
    *(_DWORD *)(this + 120) = v4;
    *(unsigned char *)(this + 124) = 1;
    *(_DWORD *)(this + 128) = v5;
    *(unsigned char *)(this + 132) = 1;
    if (v5 >= v2 && v4 <= v2)
    {
      *(_DWORD *)(this + 136) = v2;
      *(unsigned char *)(this + 140) = 1;
      *(_DWORD *)(this + 144) = v2 - v3 + *(_DWORD *)(this + 116) - 6;
      *(unsigned char *)(this + 148) = 1;
    }
  }
  return this;
}

uint64_t Nightingale::slidingWindowBaseLuna::validateResults()
{
  return 1;
}

unint64_t Nightingale::slidingWindowBaseLuna::accumulateFailureReasonOverSlices(Nightingale::slidingWindowBaseLuna *this, char a2)
{
  std::vector<int>::size_type v4 = *((int *)this + 39);
  LODWORD(v38.__begin_) = 0;
  std::vector<int>::vector(&v40, v4, (const std::vector<int>::value_type *)&v38);
  uint64_t v5 = *((void *)this + 20);
  uint64_t v6 = *((void *)this + 21);
  if (v5 != v6)
  {
    int v7 = 0;
    do
    {
      if (v7 >= *((_DWORD *)this + 46))
      {
        long long v8 = *(unsigned char **)v5;
        BOOL v9 = *(unsigned char **)(v5 + 8);
        if (*(unsigned char **)v5 != v9)
        {
          unint64_t v10 = 0;
          std::vector<int>::pointer begin = v40.__begin_;
          unint64_t v12 = v40.__end_ - v40.__begin_;
          while (1)
          {
            if (*v8)
            {
              if (v12 <= v10) {
                std::vector<int>::__throw_out_of_range[abi:ne180100]();
              }
              ++begin[v10];
              if (a2) {
                break;
              }
            }
            v8 += 8;
            if (v8 == v9) {
              break;
            }
            ++v10;
          }
        }
      }
      ++v7;
      v5 += 24;
    }
    while (v5 != v6);
  }
  unint64_t v13 = (int *)*((void *)this + 34);
  unint64_t v14 = *((void *)this + 35);
  char v39 = 1;
  v38.__begin_ = v13;
  LODWORD(v38.__end_) = 0;
  unint64_t v41 = &v13[2 * (v14 >> 6)];
  int v42 = v14 & 0x3F;
  int v15 = std::__count[abi:ne180100]<std::_ClassicAlgPolicy,std::vector<BOOL>,false,BOOL,std::__identity,0>((uint64_t *)&v38, (uint64_t)&v41, &v39);
  int v16 = v15;
  std::vector<int>::pointer end = v40.__end_;
  if (v40.__end_ >= v40.__end_cap_.__value_)
  {
    std::vector<int>::pointer v19 = v40.__begin_;
    int64_t v20 = v40.__end_ - v40.__begin_;
    unint64_t v21 = v20 + 1;
    if ((unint64_t)(v20 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int64_t v22 = (char *)v40.__end_cap_.__value_ - (char *)v40.__begin_;
    if (((char *)v40.__end_cap_.__value_ - (char *)v40.__begin_) >> 1 > v21) {
      unint64_t v21 = v22 >> 1;
    }
    if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v23 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      float v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v40.__end_cap_, v23);
      std::vector<int>::pointer v19 = v40.__begin_;
      std::vector<int>::pointer end = v40.__end_;
    }
    else
    {
      float v24 = 0;
    }
    BOOL v25 = (int *)&v24[4 * v20];
    uint64_t v26 = (int *)&v24[4 * v23];
    *BOOL v25 = v16;
    unint64_t v18 = v25 + 1;
    while (end != v19)
    {
      int v27 = *--end;
      *--BOOL v25 = v27;
    }
    v40.__begin_ = v25;
    v40.__end_ = v18;
    v40.__end_cap_.__value_ = v26;
    if (v19) {
      operator delete(v19);
    }
  }
  else
  {
    *v40.__end_ = v15;
    unint64_t v18 = end + 1;
  }
  v40.__end_ = v18;
  Nightingale::mapToOrderOffwEndConfirmationFailureReasonACycle_t((uint64_t *)&v40, &v38);
  std::vector<int>::pointer v28 = v38.__begin_;
  uint64_t v29 = v38.__begin_ + 1;
  BOOL v30 = v38.__begin_ == v38.__end_ || v29 == v38.__end_;
  std::vector<int>::pointer v31 = v38.__begin_;
  if (!v30)
  {
    int v32 = *v38.__begin_;
    std::vector<int>::pointer v31 = v38.__begin_;
    std::vector<int>::pointer v33 = v38.__begin_ + 1;
    do
    {
      int v35 = *v33++;
      int v34 = v35;
      BOOL v36 = v32 < v35;
      if (v32 <= v35) {
        int v32 = v34;
      }
      if (v36) {
        std::vector<int>::pointer v31 = v29;
      }
      uint64_t v29 = v33;
    }
    while (v33 != v38.__end_);
  }
  if (v38.__begin_)
  {
    v38.__end_ = v38.__begin_;
    operator delete(v38.__begin_);
  }
  if (v40.__begin_)
  {
    v40.__end_ = v40.__begin_;
    operator delete(v40.__begin_);
  }
  return (unint64_t)((char *)v31 - (char *)v28) >> 2;
}

void sub_257D34158(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::mapToOrderOffwEndConfirmationFailureReasonACycle_t(uint64_t *a1@<X0>, std::vector<int> *a2@<X8>)
{
  __x[0] = 0;
  std::vector<int>::vector(a2, 0xAuLL, __x);
  std::vector<int>::size_type v4 = operator new(0x18uLL);
  unint64_t v12 = (char *)(v4 + 3);
  unint64_t v13 = (char *)(v4 + 3);
  v4[2] = 0x200000004;
  *(_OWORD *)std::vector<int>::size_type v4 = xmmword_257D5F860;
  *(void *)__x = v4;
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (*a1 != v6)
  {
    uint64_t v7 = 0;
    std::vector<int>::pointer begin = a2->__begin_;
    unint64_t v9 = a2->__end_ - a2->__begin_;
    do
    {
      if (v7 == 24 || (unint64_t v10 = *(int *)((char *)v4 + v7), v9 <= v10)) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      begin[v10] = *(_DWORD *)(v5 + v7);
      v7 += 4;
    }
    while (v5 + v7 != v6);
  }
  operator delete(v4);
}

void sub_257D34250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  unint64_t v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::slidingWindowBaseLuna::getSlidingWindowCAOut(Nightingale::slidingWindowBaseLuna *this)
{
  *((_DWORD *)this + 65) = *((_DWORD *)this + 66);
  __n128 __p = 0;
  std::vector<int>::pointer v19 = 0;
  int64_t v20 = 0;
  int v2 = (unsigned __int8 **)*((void *)this + 20);
  int v3 = (unsigned __int8 **)*((void *)this + 21);
  if (v2 == v3)
  {
    int v5 = 0;
  }
  else
  {
    std::vector<int>::size_type v4 = 0;
    int v5 = 0;
    do
    {
      uint64_t v7 = *v2;
      uint64_t v6 = v2[1];
      if ((unint64_t)(v6 - *v2) >= 0x19)
      {
        if (v4 >= v20)
        {
          unint64_t v9 = (char *)__p;
          uint64_t v10 = (v4 - (unsigned char *)__p) >> 2;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v12 = v20 - (unsigned char *)__p;
          if ((v20 - (unsigned char *)__p) >> 1 > v11) {
            unint64_t v11 = v12 >> 1;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v11;
          }
          if (v13)
          {
            unint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v20, v13);
            unint64_t v9 = (char *)__p;
            std::vector<int>::size_type v4 = v19;
          }
          else
          {
            unint64_t v14 = 0;
          }
          int v15 = &v14[4 * v10];
          *(_DWORD *)int v15 = *((_DWORD *)v7 + 7);
          long long v8 = v15 + 4;
          while (v4 != v9)
          {
            int v16 = *((_DWORD *)v4 - 1);
            v4 -= 4;
            *((_DWORD *)v15 - 1) = v16;
            v15 -= 4;
          }
          __n128 __p = v15;
          std::vector<int>::pointer v19 = v8;
          int64_t v20 = &v14[4 * v13];
          if (v9) {
            operator delete(v9);
          }
        }
        else
        {
          *(_DWORD *)std::vector<int>::size_type v4 = *((_DWORD *)v7 + 7);
          long long v8 = v4 + 4;
        }
        std::vector<int>::pointer v19 = v8;
        uint64_t v7 = *v2;
        uint64_t v6 = v2[1];
        std::vector<int>::size_type v4 = v8;
      }
      if (v6 != v7) {
        v5 += *v7;
      }
      v2 += 3;
    }
    while (v2 != v3);
    if (__p != v4)
    {
      Nightingale::removeNANFromVector((uint64_t *)&__p);
      if (__p != v19)
      {
        std::__sort<std::__less<float,float> &,float *>();
        *((float *)this + 63) = Nightingale::getPercentile((uint64_t *)&__p, 0, 0.5);
      }
    }
  }
  float v17 = 0.0;
  if ((float)((float)v5 + (float)v5) <= (float)(int)(-1431655765
                                                    * ((*((void *)this + 21) - *((void *)this + 20)) >> 3)))
    float v17 = 1.0;
  *((float *)this + 61) = v17;
  if (*((unsigned char *)this + 232)) {
    *((_DWORD *)this + 62) = *((_DWORD *)this + 56);
  }
  if (__p)
  {
    std::vector<int>::pointer v19 = (char *)__p;
    operator delete(__p);
  }
}

void sub_257D34480(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Nightingale::slidingWindowHistLuna::slidingWindowHistLuna(uint64_t a1, uint64_t a2)
{
  BOOL result = (void *)Nightingale::slidingWindowBaseLuna::slidingWindowBaseLuna(a1, a2);
  *BOOL result = &unk_2706972E0;
  return result;
}

{
  void *result;

  BOOL result = (void *)Nightingale::slidingWindowBaseLuna::slidingWindowBaseLuna(a1, a2);
  *BOOL result = &unk_2706972E0;
  return result;
}

uint64_t Nightingale::slidingWindowDayStreamLuna::slidingWindowDayStreamLuna(uint64_t a1, uint64_t a2)
{
  int v3 = (Nightingale::slidingWindowDayStreamLuna *)Nightingale::slidingWindowBaseLuna::slidingWindowBaseLuna(a1, a2);
  *(void *)int v3 = &unk_270697328;
  Nightingale::slidingWindowDayStreamLuna::setSlidingWinConfig(v3);
  return a1;
}

void sub_257D3455C(_Unwind_Exception *a1)
{
  Nightingale::slidingWindowBaseLuna::~slidingWindowBaseLuna(v1);
  _Unwind_Resume(a1);
}

double Nightingale::slidingWindowDayStreamLuna::setSlidingWinConfig(Nightingale::slidingWindowDayStreamLuna *this)
{
  *(void *)&v5[4] = *MEMORY[0x263EF8340];
  *((void *)this + 5) = 0x500000007;
  long long v3 = xmmword_257D5F7BC;
  int v4 = 1050337608;
  std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)this + 48, (char *)&v3, (uint64_t)v5, 5uLL);
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 19) = 3;
  *((void *)this + 10) = 0x3F3AE1483F09E83ELL;
  *((_WORD *)this + 44) = 257;
  *((_DWORD *)this + 23) = 1058139013;
  *((void *)this + 12) = 0x300000002;
  *((_DWORD *)this + 27) = 1058139013;
  *(void *)&double result = 0x100000001;
  *((void *)this + 14) = 0x100000001;
  return result;
}

uint64_t Nightingale::slidingWindowDayStreamLuna::getSliceCenterOffsetRange(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 32);
  int v2 = *(_DWORD *)(v1 + 28) - (*(_DWORD *)(this + 44) + *(_DWORD *)v1);
  *(_DWORD *)(this + 128) = v2;
  *(unsigned char *)(this + 132) = 1;
  int v3 = *(_DWORD *)(this + 76);
  *(_DWORD *)(this + 120) = v2 - v3 + 1;
  *(unsigned char *)(this + 124) = 1;
  if (*(unsigned char *)(v1 + 12))
  {
    float v4 = (float)*(int *)(v1 + 8) + -13.0;
    if (!*(unsigned char *)(this + 140)) {
      *(unsigned char *)(this + 140) = 1;
    }
    *(_DWORD *)(this + 136) = (int)v4;
  }
  *(_DWORD *)(this + 144) = v3;
  *(unsigned char *)(this + 148) = 1;
  return this;
}

double Nightingale::slidingWindowDayStreamLuna::applyAlgorithm(uint64_t a1, uint64_t *a2)
{
  Nightingale::slidingWindowBaseLuna::findRollingOfRolling(a1, a2, *(unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 76) - 1, 0, 1, (uint64_t)&v4);
  double result = *(double *)&v4;
  *(_OWORD *)(a1 + 216) = v4;
  *(unsigned char *)(a1 + 232) = v5;
  return result;
}

BOOL Nightingale::slidingWindowDayStreamLuna::validateResults(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 16)) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 124) || (uint64_t v3 = *(void *)(a1 + 32), !*(unsigned char *)(v3 + 12))) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  BOOL v5 = Nightingale::passLutealPhaseCheck((Nightingale *)(*(_DWORD *)(a1 + 120) + *(_DWORD *)a2), (float)*(int *)(v3 + 8), (float)*(int *)(a1 + 112));
  std::vector<BOOL>::push_back(a1 + 192, &v5);
  return v5;
}

uint64_t Nightingale::slidingWindowDayStreamLuna::getSlidingWindowCAOut(Nightingale::slidingWindowDayStreamLuna *this)
{
  *((_DWORD *)this + 65) = *((_DWORD *)this + 66);
  if (*((unsigned char *)this + 232)) {
    *((float *)this + 62) = Nightingale::getLogit(this, *((float *)this + 57));
  }
  uint64_t result = Nightingale::slidingWindowBaseLuna::checkNumContinuousSlicesFailAvailabilityOverThreshold(this);
  *((unsigned char *)this + 256) = result ^ 1;
  return result;
}

uint64_t Nightingale::slidingWindowBaseLuna::computeFwEndConfirmationFailureReason(Nightingale::slidingWindowBaseLuna *this)
{
  if (*((unsigned char *)this + 232)) {
    return 9;
  }
  unint64_t v3 = Nightingale::slidingWindowBaseLuna::accumulateFailureReasonOverSlices(this, *((unsigned char *)this + 89));
  uint64_t v4 = *((void *)this + 1);
  if (v3 >= (*((void *)this + 2) - v4) >> 2) {
    return 8;
  }
  else {
    return *(unsigned int *)(v4 + 4 * v3);
  }
}

uint64_t Nightingale::slidingWindowBaseLuna::computeFailureCode(uint64_t this)
{
  int v1 = *(unsigned __int8 *)(this + 264);
  if (v1 == 2) {
    int v2 = 2;
  }
  else {
    int v2 = 4;
  }
  if (v1 == 9) {
    int v2 = 0;
  }
  if (v1 == 1) {
    int v3 = 1;
  }
  else {
    int v3 = v2;
  }
  *(_DWORD *)(this + 240) = v3;
  return this;
}

uint64_t Nightingale::slidingWindowDayStreamLuna::computeFwEndConfirmationFailureReason(Nightingale::slidingWindowDayStreamLuna *this)
{
  if (*((unsigned char *)this + 232)) {
    return 9;
  }
  uint64_t v4 = *((void *)this + 21);
  if (*((void *)this + 20) == v4) {
    return 8;
  }
  __n128 __p = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  std::vector<std::pair<BOOL,float>>::__init_with_size[abi:ne180100]<std::pair<BOOL,float>*,std::pair<BOOL,float>*>((char *)&__p, *(uint64_t **)(v4 - 24), *(uint64_t **)(v4 - 16), (uint64_t)(*(void *)(v4 - 16) - *(void *)(v4 - 24)) >> 3);
  if (Nightingale::slidingWindowBaseLuna::checkNumContinuousSlicesFailAvailabilityOverThreshold(this))
  {
    uint64_t v1 = 1;
    goto LABEL_20;
  }
  uint64_t v5 = *((void *)this + 35);
  if (v5
    && ((*(void *)(*((void *)this + 34) + (((unint64_t)(v5 - 1) >> 3) & 0x1FFFFFFFFFFFFFF8)) >> (v5 - 1)) & 1) != 0)
  {
    uint64_t v1 = 3;
    goto LABEL_20;
  }
  if ((unint64_t)(v7 - (unsigned char *)__p) < 0x19) {
    goto LABEL_22;
  }
  if (*((unsigned char *)__p + 24))
  {
    uint64_t v1 = 2;
    goto LABEL_20;
  }
  if ((unint64_t)(v7 - (unsigned char *)__p) <= 0x20) {
LABEL_22:
  }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  if (*((unsigned char *)__p + 32))
  {
    uint64_t v1 = 4;
  }
  else if (*((unsigned char *)__p + 16))
  {
    uint64_t v1 = 5;
  }
  else
  {
    uint64_t v1 = 8;
  }
LABEL_20:
  if (__p)
  {
    uint64_t v7 = __p;
    operator delete(__p);
  }
  return v1;
}

void sub_257D3498C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

Nightingale::slidingWindowBaseLuna::slidingWinConfigStruct *Nightingale::slidingWindowBaseLuna::slidingWinConfigStruct::slidingWinConfigStruct(Nightingale::slidingWindowBaseLuna::slidingWinConfigStruct *this)
{
  *(void *)this = 0x500000007;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  int v2 = operator new(0x14uLL);
  *((void *)this + 2) = v2 + 5;
  *((void *)this + 3) = v2 + 5;
  v2[4] = 1050337608;
  *(_OWORD *)int v2 = xmmword_257D5F84C;
  *((void *)this + 1) = v2;
  *((unsigned char *)this + 32) = 0;
  *((_DWORD *)this + 9) = 5;
  *((void *)this + 5) = 0x3F3AE1483F0A3D71;
  *((_WORD *)this + 24) = 257;
  *((_DWORD *)this + 13) = 1058139013;
  *((void *)this + 7) = 0x500000003;
  *((_DWORD *)this + 17) = 1058139013;
  *((void *)this + 9) = 0x100000001;
  return this;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    std::vector<int>::pointer end = this->__end_;
    uint64_t v7 = &end[__n];
    std::vector<int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_257D34ABC(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void __65__period_lstm_loadContentsOfURL_configuration_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    int v3 = [[period_lstm alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void __56__period_lstm_predictionFromFeatures_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    uint64_t v6 = [period_lstmOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    std::vector<int>::size_type v8 = [v7 multiArrayValue];
    unint64_t v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    unint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    uint64_t v12 = [v11 multiArrayValue];
    unint64_t v13 = [(period_lstmOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = *(void (**)(uint64_t, void, period_lstmOutput *))(v14 + 16);
    unint64_t v13 = a3;
    v15(v14, 0, v13);
  }
}

void __64__period_lstm_predictionFromFeatures_options_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    uint64_t v6 = [period_lstmOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    std::vector<int>::size_type v8 = [v7 multiArrayValue];
    unint64_t v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    unint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    uint64_t v12 = [v11 multiArrayValue];
    unint64_t v13 = [(period_lstmOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = *(void (**)(uint64_t, void, period_lstmOutput *))(v14 + 16);
    unint64_t v13 = a3;
    v15(v14, 0, v13);
  }
}

void __65__fwEnddet_rf_loadContentsOfURL_configuration_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    int v3 = [[fwEnddet_rf alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void __56__fwEnddet_rf_predictionFromFeatures_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v14 = a2;
  if (v14)
  {
    id v5 = a3;
    uint64_t v6 = [fwEnddet_rfOutput alloc];
    uint64_t v7 = [v14 featureValueForName:@"classLabel"];
    uint64_t v8 = [v7 int64Value];
    unint64_t v9 = [v14 featureValueForName:@"classProbability"];
    uint64_t v10 = [v9 dictionaryValue];
    unint64_t v11 = [(fwEnddet_rfOutput *)v6 initWithClassLabel:v8 classProbability:v10];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = *(void (**)(uint64_t, void, fwEnddet_rfOutput *))(v12 + 16);
    unint64_t v11 = a3;
    v13(v12, 0, v11);
  }
}

void __64__fwEnddet_rf_predictionFromFeatures_options_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v14 = a2;
  if (v14)
  {
    id v5 = a3;
    uint64_t v6 = [fwEnddet_rfOutput alloc];
    uint64_t v7 = [v14 featureValueForName:@"classLabel"];
    uint64_t v8 = [v7 int64Value];
    unint64_t v9 = [v14 featureValueForName:@"classProbability"];
    uint64_t v10 = [v9 dictionaryValue];
    unint64_t v11 = [(fwEnddet_rfOutput *)v6 initWithClassLabel:v8 classProbability:v10];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 32);
    unint64_t v13 = *(void (**)(uint64_t, void, fwEnddet_rfOutput *))(v12 + 16);
    unint64_t v11 = a3;
    v13(v12, 0, v11);
  }
}

void __67__fwEnddet_lstm_loadContentsOfURL_configuration_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    int v3 = [[fwEnddet_lstm alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void __58__fwEnddet_lstm_predictionFromFeatures_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    uint64_t v6 = [fwEnddet_lstmOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    uint64_t v8 = [v7 multiArrayValue];
    unint64_t v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    unint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    uint64_t v12 = [v11 multiArrayValue];
    unint64_t v13 = [(fwEnddet_lstmOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = *(void (**)(uint64_t, void, fwEnddet_lstmOutput *))(v14 + 16);
    unint64_t v13 = a3;
    v15(v14, 0, v13);
  }
}

void __66__fwEnddet_lstm_predictionFromFeatures_options_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    uint64_t v6 = [fwEnddet_lstmOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    uint64_t v8 = [v7 multiArrayValue];
    unint64_t v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    unint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    uint64_t v12 = [v11 multiArrayValue];
    unint64_t v13 = [(fwEnddet_lstmOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = *(void (**)(uint64_t, void, fwEnddet_lstmOutput *))(v14 + 16);
    unint64_t v13 = a3;
    v15(v14, 0, v13);
  }
}

void Nightingale::ngt_dnn_period_predict_t::ngt_dnn_period_predict_t(Nightingale::ngt_dnn_period_predict_t *this, const Nightingale::ngt_Config *a2)
{
}

void sub_257D37FF8(_Unwind_Exception *exception_object)
{
  int v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::periodPredictorWrapper_t::init(Nightingale::periodPredictorWrapper_t *this, const Nightingale::ngt_Config *a2)
{
  id v5 = (char *)*((void *)a2 + 27);
  int v3 = (char *)a2 + 216;
  id v4 = v5;
  if (v3[23] >= 0) {
    uint64_t v6 = v3;
  }
  else {
    uint64_t v6 = v4;
  }
  uint64_t v7 = [NSString stringWithUTF8String:v6];
  uint64_t v8 = [NSURL fileURLWithPath:v7];
  uint64_t v9 = objc_opt_new();
  uint64_t v10 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v9;

  unint64_t v11 = (void *)*((void *)this + 2);
  if (!v11)
  {
    id v14 = 0;
    goto LABEL_13;
  }
  [v11 setComputeUnits:0];
  uint64_t v12 = *((void *)this + 2);
  id v29 = 0;
  uint64_t v13 = [MEMORY[0x263F00D80] modelWithContentsOfURL:v8 configuration:v12 error:&v29];
  id v14 = v29;
  int v15 = (void *)*((void *)this + 4);
  *((void *)this + 4) = v13;

  if (v14)
  {
LABEL_13:
    BOOL v24 = 0;
    goto LABEL_14;
  }
  id v16 = [*((id *)this + 4) modelDescription];
  float v17 = [v16 inputDescriptionsByName];
  unint64_t v18 = [v17 objectForKeyedSubscript:@"in"];
  std::vector<int>::pointer v19 = [v18 multiArrayConstraint];
  int64_t v20 = [v19 shape];

  unint64_t v21 = [v20 objectAtIndexedSubscript:0];
  if ([v20 count] == 1 && objc_msgSend(v21, "intValue") == 5)
  {

    int64_t v20 = &unk_27069BD20;
  }
  id v28 = 0;
  uint64_t v22 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:v20 dataType:65600 error:&v28];
  id v14 = v28;
  unint64_t v23 = *(void **)this;
  *(void *)this = v22;

  BOOL v24 = *(void *)this != 0;
  if (*(void *)this)
  {
    BOOL v25 = [[model_period_LstmInput alloc] initWithIn:*(void *)this lstm_1_h_in:0 lstm_1_c_in:0];
    uint64_t v26 = (void *)*((void *)this + 3);
    *((void *)this + 3) = v25;
  }
LABEL_14:

  return v24;
}

void sub_257D38240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_dnn_period_predict_t::~ngt_dnn_period_predict_t(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_dnn_period_predict_t::ngt_dnn_process_period(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::periodPredictorWrapper_t::predictPeriod(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::vector<double>::vector(&__p, 0xE1uLL);
  uint64_t v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = __p;
  uint64_t v9 = (char *)__p + 16;
  uint64_t v10 = a2[3];
  uint64_t v11 = a2[6];
  uint64_t v12 = a2[9];
  uint64_t v13 = a2[12];
  do
  {
    *(v9 - 2) = *(void *)(v7 + v6);
    *(v9 - 1) = *(void *)(v10 + v6);
    void *v9 = *(void *)(v11 + v6);
    v9[1] = *(void *)(v12 + v6);
    id v9[2] = *(void *)(v13 + v6);
    v6 += 8;
    v9 += 5;
  }
  while (v6 != 360);
  id v14 = v47;
  int v15 = (void *)[*(id *)a1 dataPointer];
  if (v14 != v8) {
    memmove(v15, v8, v14 - v8);
  }
  uint64_t v17 = *(void *)(a1 + 24);
  id v16 = *(void **)(a1 + 32);
  id v45 = 0;
  unint64_t v18 = [v16 predictionFromFeatures:v17 error:&v45];
  id v44 = v45;
  std::vector<int>::pointer v19 = [model_period_LstmOutput alloc];
  int64_t v20 = [v18 featureValueForName:@"out"];
  unint64_t v21 = [v20 multiArrayValue];
  uint64_t v22 = [v18 featureValueForName:@"lstm_1_h_out"];
  unint64_t v23 = [v22 multiArrayValue];
  BOOL v24 = [v18 featureValueForName:@"lstm_1_c_out"];
  BOOL v25 = [v24 multiArrayValue];
  uint64_t v26 = [(model_period_LstmOutput *)v19 initWithOut:v21 lstm_1_h_out:v23 lstm_1_c_out:v25];

  for (uint64_t i = 0; i != 32; ++i)
  {
    id v28 = [(model_period_LstmOutput *)v26 out];
    id v29 = [v28 objectAtIndexedSubscript:i];
    [v29 doubleValue];
    float v31 = v30;
    std::vector<int>::pointer v33 = *(float **)(a3 + 8);
    unint64_t v32 = *(void *)(a3 + 16);
    if ((unint64_t)v33 >= v32)
    {
      int v35 = *(float **)a3;
      uint64_t v36 = ((uint64_t)v33 - *(void *)a3) >> 2;
      unint64_t v37 = v36 + 1;
      if ((unint64_t)(v36 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v38 = v32 - (void)v35;
      if (v38 >> 1 > v37) {
        unint64_t v37 = v38 >> 1;
      }
      if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v39 = v37;
      }
      if (v39)
      {
        std::vector<int> v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v39);
        int v35 = *(float **)a3;
        std::vector<int>::pointer v33 = *(float **)(a3 + 8);
      }
      else
      {
        std::vector<int> v40 = 0;
      }
      unint64_t v41 = (float *)&v40[4 * v36];
      *unint64_t v41 = v31;
      int v34 = v41 + 1;
      while (v33 != v35)
      {
        int v42 = *((_DWORD *)v33-- - 1);
        *((_DWORD *)v41-- - 1) = v42;
      }
      *(void *)a3 = v41;
      *(void *)(a3 + 8) = v34;
      *(void *)(a3 + 16) = &v40[4 * v39];
      if (v35) {
        operator delete(v35);
      }
    }
    else
    {
      *std::vector<int>::pointer v33 = v31;
      int v34 = v33 + 1;
    }
    *(void *)(a3 + 8) = v34;
  }
  if (__p)
  {
    uint64_t v47 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D38604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double Nightingale::periodPredictorWrapper_t::periodPredictorWrapper_t(Nightingale::periodPredictorWrapper_t *this)
{
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void Nightingale::ngt_dnn_period_predict_transformer_t::ngt_dnn_period_predict_transformer_t()
{
}

void sub_257D38730(_Unwind_Exception *exception_object)
{
  int v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::periodPredictorTransformerWrapper_t::init(uint64_t *a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = (uint64_t *)*a2;
  }
  id v4 = [NSString stringWithUTF8String:v3];
  id v5 = [NSURL fileURLWithPath:v4];
  uint64_t v6 = objc_opt_new();
  uint64_t v7 = (void *)a1[2];
  a1[2] = v6;

  uint64_t v8 = (void *)a1[2];
  if (v8)
  {
    [v8 setComputeUnits:0];
    id v21 = 0;
    uint64_t v9 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BD38 dataType:65568 error:&v21];
    id v10 = v21;
    uint64_t v11 = (void *)*a1;
    *a1 = v9;

    if (*a1)
    {
      uint64_t v12 = a1[2];
      id v20 = v10;
      uint64_t v13 = [MEMORY[0x263F00D80] modelWithContentsOfURL:v5 configuration:v12 error:&v20];
      id v14 = v20;

      int v15 = (void *)a1[4];
      a1[4] = v13;

      if (v14)
      {
        uint64_t v16 = 0;
        id v10 = v14;
      }
      else
      {
        uint64_t v17 = [[model_period_TFInput alloc] initWithIn:*a1];
        unint64_t v18 = (void *)a1[3];
        a1[3] = (uint64_t)v17;

        id v10 = 0;
        uint64_t v16 = 1;
      }
    }
    else
    {
      uint64_t v16 = 0;
    }
  }
  else
  {
    uint64_t v16 = 0;
    id v10 = 0;
  }

  return v16;
}

void sub_257D388EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_dnn_period_predict_transformer_t::~ngt_dnn_period_predict_transformer_t(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_dnn_period_predict_transformer_t::predict(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::periodPredictorTransformerWrapper_t::predictPeriod(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::vector<float>::vector(&__p, 0xE1uLL);
  uint64_t v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = __p;
  uint64_t v9 = (float *)((char *)__p + 8);
  uint64_t v10 = a2[3];
  uint64_t v11 = a2[6];
  uint64_t v12 = a2[9];
  uint64_t v13 = a2[12];
  do
  {
    float v14 = *(double *)(v7 + v6);
    *(v9 - 2) = v14;
    float v15 = *(double *)(v10 + v6);
    *(v9 - 1) = v15;
    float v16 = *(double *)(v11 + v6);
    float *v9 = v16;
    float v17 = *(double *)(v12 + v6);
    v9[1] = v17;
    float v18 = *(double *)(v13 + v6);
    id v9[2] = v18;
    v6 += 8;
    v9 += 5;
  }
  while (v6 != 360);
  std::vector<int>::pointer v19 = v50;
  id v20 = (void *)[*(id *)a1 dataPointer];
  if (v19 != v8) {
    memmove(v20, v8, v19 - v8);
  }
  uint64_t v22 = *(void *)(a1 + 24);
  id v21 = *(void **)(a1 + 32);
  id v48 = 0;
  unint64_t v23 = [v21 predictionFromFeatures:v22 error:&v48];
  id v47 = v48;
  BOOL v24 = [model_period_TFOutput alloc];
  BOOL v25 = [v23 featureValueForName:@"out"];
  uint64_t v26 = [v25 multiArrayValue];
  int v27 = [(model_period_TFOutput *)v24 initWithOut:v26];

  uint64_t v28 = 0;
  char v29 = 1;
  do
  {
    char v30 = v29;
    float v31 = [(model_period_TFOutput *)v27 out];
    unint64_t v32 = [v31 objectAtIndexedSubscript:v28];
    [v32 floatValue];
    int v34 = v33;
    uint64_t v36 = *(_DWORD **)(a3 + 8);
    unint64_t v35 = *(void *)(a3 + 16);
    if ((unint64_t)v36 >= v35)
    {
      uint64_t v38 = *(_DWORD **)a3;
      uint64_t v39 = ((uint64_t)v36 - *(void *)a3) >> 2;
      unint64_t v40 = v39 + 1;
      if ((unint64_t)(v39 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v41 = v35 - (void)v38;
      if (v41 >> 1 > v40) {
        unint64_t v40 = v41 >> 1;
      }
      if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v42 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v42 = v40;
      }
      if (v42)
      {
        unint64_t v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v42);
        uint64_t v38 = *(_DWORD **)a3;
        uint64_t v36 = *(_DWORD **)(a3 + 8);
      }
      else
      {
        unint64_t v43 = 0;
      }
      id v44 = &v43[4 * v39];
      *(_DWORD *)id v44 = v34;
      unint64_t v37 = v44 + 4;
      while (v36 != v38)
      {
        int v45 = *--v36;
        *((_DWORD *)v44 - 1) = v45;
        v44 -= 4;
      }
      *(void *)a3 = v44;
      *(void *)(a3 + 8) = v37;
      *(void *)(a3 + 16) = &v43[4 * v42];
      if (v38) {
        operator delete(v38);
      }
    }
    else
    {
      *uint64_t v36 = v33;
      unint64_t v37 = v36 + 1;
    }
    *(void *)(a3 + 8) = v37;

    char v29 = 0;
    uint64_t v28 = 1;
  }
  while ((v30 & 1) != 0);

  if (__p)
  {
    unint64_t v50 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D38C20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double Nightingale::periodPredictorTransformerWrapper_t::periodPredictorTransformerWrapper_t(Nightingale::periodPredictorTransformerWrapper_t *this)
{
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void Nightingale::ngt_dnn_period_predict_Ensemble_t::ngt_dnn_period_predict_Ensemble_t()
{
}

void sub_257D38D1C(_Unwind_Exception *exception_object)
{
  int v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::periodPredictorEnsembleWrapper_t::init(uint64_t *a1, uint64_t *a2)
{
  if (*((char *)a2 + 23) >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = (uint64_t *)*a2;
  }
  id v4 = [NSString stringWithUTF8String:v3];
  id v5 = [NSURL fileURLWithPath:v4];
  uint64_t v6 = objc_opt_new();
  uint64_t v7 = (void *)a1[2];
  a1[2] = v6;

  uint64_t v8 = (void *)a1[2];
  if (v8)
  {
    [v8 setComputeUnits:0];
    uint64_t v9 = a1[2];
    id v20 = 0;
    uint64_t v10 = [MEMORY[0x263F00D80] modelWithContentsOfURL:v5 configuration:v9 error:&v20];
    id v11 = v20;
    uint64_t v12 = (void *)a1[4];
    a1[4] = v10;

    if (v11
      || (id v19 = 0,
          v14 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BD50 dataType:65568 error:&v19], id v11 = v19, v15 = (void *)*a1, *a1 = v14, v15, !*a1))
    {
      uint64_t v13 = 0;
    }
    else
    {
      float v16 = [[model_period_EnsembleInput alloc] initWithIn:*a1];
      float v17 = (void *)a1[3];
      a1[3] = (uint64_t)v16;

      uint64_t v13 = 1;
    }
  }
  else
  {
    uint64_t v13 = 0;
    id v11 = 0;
  }

  return v13;
}

void sub_257D38EBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_dnn_period_predict_Ensemble_t::~ngt_dnn_period_predict_Ensemble_t(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_dnn_period_predict_Ensemble_t::predict(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  return 0;
}

uint64_t Nightingale::periodPredictorEnsembleWrapper_t::predictPeriod(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  std::vector<double>::vector(__p, 0xE1uLL);
  uint64_t v6 = *(unsigned char **)a2;
  uint64_t v7 = *(unsigned char **)(a2 + 8);
  uint64_t v8 = (void *)[*(id *)a1 dataPointer];
  if (v7 != v6) {
    memmove(v8, v6, v7 - v6);
  }
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v9 = *(void **)(a1 + 32);
  id v20 = 0;
  id v11 = [v9 predictionFromFeatures:v10 error:&v20];
  id v12 = v20;
  uint64_t v13 = [model_period_TFOutput alloc];
  uint64_t v14 = [v11 featureValueForName:@"out"];
  float v15 = [v14 multiArrayValue];
  float v16 = [(model_period_TFOutput *)v13 initWithOut:v15];

  float v17 = [(model_period_TFOutput *)v16 out];
  float v18 = [v17 objectAtIndexedSubscript:0];
  *a3 = [v18 intValue];

  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }

  return 0;
}

void sub_257D39098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double Nightingale::periodPredictorEnsembleWrapper_t::periodPredictorEnsembleWrapper_t(Nightingale::periodPredictorEnsembleWrapper_t *this)
{
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

void *std::vector<float>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    id v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_257D39190(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::periodEstimatorCalendar::periodEstimatorCalendar(Nightingale::periodEstimatorCalendar *this, const Nightingale::ngt_Config *a2)
{
  uint64_t result = Nightingale::periodEstimatorBase::periodEstimatorBase(this, a2);
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (((int)*((float *)a2 + 12) - 18) < 0x1B || *((unsigned char *)a2 + 52) == 0) {
    int v5 = 16;
  }
  else {
    int v5 = 36;
  }
  *(_DWORD *)(result + 24) = v5;
  return result;
}

{
  uint64_t result;
  int v5;

  uint64_t result = Nightingale::periodEstimatorBase::periodEstimatorBase(this, a2);
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (((int)*((float *)a2 + 12) - 18) < 0x1B || *((unsigned char *)a2 + 52) == 0) {
    int v5 = 16;
  }
  else {
    int v5 = 36;
  }
  *(_DWORD *)(result + 24) = v5;
  return result;
}

double Nightingale::periodEstimatorCalendar::predict1stPeriodStartCal@<D0>(Nightingale::periodEstimatorCalendar *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  Nightingale::CGradient::CGradient(a6);
  if (*(unsigned char *)(a2 + 36) && *(unsigned char *)(a2 + 44))
  {
    if ((a3 & 0xFF00000000) != 0) {
      uint64_t v13 = (a3 + 1) | 0x100000000;
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t NullPoint = Nightingale::periodEstimatorBase::getNullPoint((uint64_t)a1, v13, a4, *(_DWORD *)a2);
    if (!*(unsigned char *)(a2 + 36)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if (!*(unsigned char *)(a2 + 44)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    float v15 = *(float *)(a2 + 40);
    float v16 = 0.0;
    if (a5 != -2) {
      float v16 = *(float *)(a2 + 40);
    }
    if ((a5 & 0xFF00000000) != 0) {
      float v15 = v16;
    }
    Nightingale::periodEstimatorCalendar::getCalBasedPeriodStartGradient(a1, NullPoint, (uint64_t)&v18, *(float *)(a2 + 32), v15);
    float v17 = *(void **)a6;
    if (*(void *)a6)
    {
      *(void *)(a6 + 8) = v17;
      operator delete(v17);
      *(void *)a6 = 0;
      *(void *)(a6 + 8) = 0;
      *(void *)(a6 + 16) = 0;
    }
    *(_OWORD *)a6 = v18;
    *(void *)(a6 + 16) = v19;
    *(_OWORD *)(a6 + 24) = v20[0];
    double result = *(double *)((char *)v20 + 9);
    *(_OWORD *)(a6 + 33) = *(_OWORD *)((char *)v20 + 9);
  }
  return result;
}

void sub_257D3935C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::periodEstimatorCalendar::getCalBasedPeriodStartGradient(Nightingale::periodEstimatorCalendar *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, float a4@<S0>, float a5@<S1>)
{
  Nightingale::periodEstimatorCalendar::getPeriodStartGradient(a1, a4, a5, a3);
  if ((a2 & 0xFF00000000) != 0)
  {
    Nightingale::periodEstimatorCalendar::adjustForGradientNull(v9, a2, (Nightingale::CGradient *)a3, a4, a5);
  }
  else
  {
    *(float *)(a3 + 36) = a4;
    *(unsigned char *)(a3 + 40) = 1;
    *(float *)(a3 + 44) = sqrtf(a5);
    *(unsigned char *)(a3 + 48) = 1;
  }
}

void sub_257D393F4(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::periodEstimatorCalendar::getPeriodStartGradient@<D0>(Nightingale::periodEstimatorCalendar *this@<X0>, float a2@<S0>, float a3@<S1>, uint64_t a4@<X8>)
{
  Nightingale::CGradient::CGradient(a4);
  int GradientLength = Nightingale::periodEstimatorCalendar::getGradientLength(this, a2, a3);
  Nightingale::periodEstimatorCalendar::getGradient(a2, a3, GradientLength, (Nightingale::CGradient *)&v11);
  int v9 = *(void **)a4;
  if (*(void *)a4)
  {
    *(void *)(a4 + 8) = v9;
    operator delete(v9);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  *(_OWORD *)a4 = v11;
  *(void *)(a4 + 16) = v12;
  *(_OWORD *)(a4 + 24) = v13[0];
  double result = *(double *)((char *)v13 + 9);
  *(_OWORD *)(a4 + 33) = *(_OWORD *)((char *)v13 + 9);
  return result;
}

void sub_257D394B0(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::periodEstimatorCalendar::adjustForGradientNull(int a1, uint64_t a2, Nightingale::CGradient *this, float a4, float a5)
{
  uint64_t result = Nightingale::CGradient::get_vGrad_empty(this);
  if ((result & 1) == 0 && (a2 & 0xFF00000000) != 0)
  {
    if ((int)a2 <= (int)llround(a4 + sqrtf(a5) * 1.64999998))
    {
      Nightingale::CGradient::annihilateEarly((char **)this, (int)a2 + 1);
      uint64_t result = Nightingale::CGradient::normalize((uint64_t)this);
      *((unsigned char *)this + 34) = 1;
    }
    else
    {
      *((unsigned char *)this + 33) = 1;
      *((void *)this + 1) = *(void *)this;
    }
  }
  return result;
}

uint64_t Nightingale::periodEstimatorCalendar::getGradientLength(Nightingale::periodEstimatorCalendar *this, float a2, float a3)
{
  double v5 = sqrtf(a3) * 10.0;
  if (v5 >= 20.0) {
    double v6 = v5;
  }
  else {
    double v6 = 20.0;
  }
  if (Nightingale::check2Real_t_equal(this, fabsf(a3), 0.0)) {
    double v6 = sqrt((double)*((int *)this + 6)) * 10.0;
  }
  return (int)(v6 + a2);
}

uint64_t Nightingale::periodEstimatorCalendar::getGradient@<X0>(float a1@<S0>, float a2@<S1>, int a3@<W1>, Nightingale::CGradient *a4@<X8>)
{
  int v9 = (Nightingale *)Nightingale::CGradient::CGradient((uint64_t)a4);
  if (a3 >= 1)
  {
    int v10 = 0;
    double v11 = a1;
    double v12 = a2;
    do
    {
      double v13 = Nightingale::gaussian_pdf(v9, (double)v10, v11, v12);
      Nightingale::CGradient::push_back(a4, v13);
      ++v10;
    }
    while (a3 != v10);
  }
  return Nightingale::CGradient::normalize((uint64_t)a4);
}

void sub_257D39670(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::periodEstimatorCalendarWithEnd::periodEstimatorCalendarWithEnd(Nightingale::periodEstimatorCalendarWithEnd *this, const Nightingale::ngt_Config *a2)
{
  uint64_t result = Nightingale::periodEstimatorBase::periodEstimatorBase(this, a2);
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (((int)*((float *)a2 + 12) - 18) < 0x1B || *((unsigned char *)a2 + 52) == 0) {
    int v5 = 16;
  }
  else {
    int v5 = 36;
  }
  *(_DWORD *)(result + 24) = v5;
  return result;
}

{
  uint64_t result;
  int v5;

  uint64_t result = Nightingale::periodEstimatorBase::periodEstimatorBase(this, a2);
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  if (((int)*((float *)a2 + 12) - 18) < 0x1B || *((unsigned char *)a2 + 52) == 0) {
    int v5 = 16;
  }
  else {
    int v5 = 36;
  }
  *(_DWORD *)(result + 24) = v5;
  return result;
}

void Nightingale::periodEstimatorCalendarWithEnd::getPeriodEndProjection(uint64_t a1@<X1>, Nightingale::CGradient *a2@<X2>, uint64_t a3@<X8>)
{
  Nightingale::CGradient::CGradient(a3);
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 60) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  if (*(unsigned char *)(a1 + 60)) {
    BOOL v6 = *(unsigned char *)(a1 + 52) == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    long long v7 = *(_OWORD *)(a1 + 48);
    _OWORD v16[2] = *(_OWORD *)(a1 + 32);
    *(_OWORD *)float v17 = v7;
    *(void *)&v17[13] = *(void *)(a1 + 61);
    long long v8 = *(_OWORD *)(a1 + 16);
    v16[0] = *(_OWORD *)a1;
    v16[1] = v8;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    int v9 = *(const void **)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 80);
    __n128 __p = 0;
    std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&__p, v9, v10, v10 - (void)v9);
    Nightingale::periodEstimatorCalendarWithEnd::get_period_duration_pdf((uint64_t)v16, (uint64_t)v21);
    if (__p)
    {
      uint64_t v19 = __p;
      operator delete(__p);
    }
    Nightingale::CGradient::get_list_reference((Nightingale::CGradient *)v21, v15);
    Nightingale::CGradient::get_list_reference(a2, v11);
    Nightingale::periodEstimatorCalendarWithEnd::get_period_end_gradient((uint64_t)v15, (uint64_t *)v11, (uint64_t)&v12);
    if (v11[0])
    {
      v11[1] = v11[0];
      operator delete(v11[0]);
    }
    if (&v12 != (void **)a3) {
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a3, (char *)v12, (uint64_t)v13, (v13 - (unsigned char *)v12) >> 2);
    }
    *(_OWORD *)(a3 + 24) = v14[0];
    *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v14 + 9);
    if (v12)
    {
      double v13 = v12;
      operator delete(v12);
    }
    if (v15[0])
    {
      v15[1] = v15[0];
      operator delete(v15[0]);
    }
    if (v21[0])
    {
      v21[1] = v21[0];
      operator delete(v21[0]);
    }
  }
}

void sub_257D3988C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  if (__p) {
    operator delete(__p);
  }
  if (a20) {
    operator delete(a20);
  }
  uint64_t v36 = *(void **)(v34 - 88);
  if (v36)
  {
    *(void *)(v34 - 80) = v36;
    operator delete(v36);
  }
  unint64_t v37 = *(void **)v33;
  if (*(void *)v33)
  {
    *(void *)(v33 + 8) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::periodEstimatorCalendarWithEnd::get_period_duration_pdf(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  Nightingale::CGradient::CGradient(a2);
  if (*(unsigned char *)(a1 + 52) && *(unsigned char *)(a1 + 60))
  {
    Nightingale::periodEstimatorCalendar::getGradient(*(float *)(a1 + 48) + -1.0, *(float *)(a1 + 56), 60, (Nightingale::CGradient *)&v5);
    id v4 = *(void **)a2;
    if (*(void *)a2)
    {
      *(void *)(a2 + 8) = v4;
      operator delete(v4);
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
    }
    *(_OWORD *)a2 = v5;
    *(void *)(a2 + 16) = v6;
    *(_OWORD *)(a2 + 24) = v7[0];
    *(_OWORD *)(a2 + 33) = *(_OWORD *)((char *)v7 + 9);
  }
  else
  {
    *(unsigned char *)(a2 + 33) = 1;
    *(void *)(a2 + 8) = *(void *)a2;
  }
}

void sub_257D399C4(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::periodEstimatorCalendarWithEnd::get_period_end_gradient(uint64_t a1@<X1>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  __n128 __p = 0;
  long long v5 = 0;
  uint64_t v6 = 0;
  Nightingale::convolve_on_top(a2, a1, (uint64_t)&__p, 0);
  Nightingale::CGradient::CGradient(a3, &__p);
  Nightingale::CGradient::normalize(a3);
  if (__p)
  {
    long long v5 = __p;
    operator delete(__p);
  }
}

void sub_257D39A44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  double v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition(Nightingale::wristTemperatureInputAcquisition *this)
{
  uint64_t v1 = Nightingale::sensorInputProcessBase::sensorInputProcessBase(this);
  *(void *)(v1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)uint64_t v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  return result;
}

{
  uint64_t v1;
  double result;

  uint64_t v1 = Nightingale::sensorInputProcessBase::sensorInputProcessBase(this);
  *(void *)(v1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(v1 + 32) = 0u;
  *(_OWORD *)(v1 + 48) = 0u;
  *(_OWORD *)uint64_t v1 = 0u;
  *(_OWORD *)(v1 + 16) = 0u;
  return result;
}

void Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition(Nightingale::wristTemperatureInputAcquisition *this)
{
  int v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  int v3 = (void *)*((void *)this + 3);
  if (v3)
  {
    *((void *)this + 4) = v3;
    operator delete(v3);
  }
  id v4 = (void **)this;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  Nightingale::sensorInputProcessBase::~sensorInputProcessBase(this);
}

uint64_t Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp(uint64_t a1, unsigned int **a2)
{
  int v2 = (char *)*a2;
  int v3 = a2[1];
  int64_t v4 = (char *)v3 - (char *)*a2;
  if (v3 == *a2) {
    return 0;
  }
  uint64_t v5 = 0;
  unint64_t v6 = v4 / 60;
  if (v6 <= 1) {
    unint64_t v6 = 1;
  }
  while (!v2[56])
  {
    v5 -= 0x100000000;
    v2 += 60;
    if (!--v6) {
      return 0;
    }
  }
  return *(unsigned int *)v2 - v5;
}

unint64_t Nightingale::wristTemperatureInputAcquisition::getAWTmpEntryDailyData(uint64_t a1, void *a2, int *a3, int a4)
{
  unint64_t v4 = *a3;
  unint64_t v5 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a2[1] - *a2) >> 2);
  if (v5 <= v4)
  {
LABEL_5:
    unint64_t v8 = 0;
    LOBYTE(v9) = 0;
  }
  else
  {
    unint64_t v6 = (unsigned char *)(*a2 + 60 * (int)v4 + 56);
    int v7 = v4 + 1;
    while (*((_DWORD *)v6 - 14) != a4)
    {
      ++v4;
      v6 += 60;
      ++v7;
      if (v5 <= v4) {
        goto LABEL_5;
      }
    }
    if (*v6)
    {
      uint64_t v9 = *((void *)v6 - 1);
      unint64_t v8 = v9 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
      unint64_t v8 = 0;
      LOBYTE(v9) = 0;
    }
    *a3 = v7;
  }
  return v8 & 0xFFFFFFFFFFFFFF00 | v9;
}

void Nightingale::wristTemperatureInputAcquisition::extractKaliInputsJDayRange(unint64_t AWTmpEntryDailyData@<X0>, void *a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X4>, int a6@<W5>, uint64_t a7@<X8>)
{
  uint64_t v155 = a5;
  int v156 = a6;
  *(void *)(a7 + 8) = 0;
  *(void *)(a7 + 16) = 0;
  *(void *)a7 = 0;
  *(void *)(a7 + 24) = -1;
  *(_OWORD *)(a7 + 32) = 0u;
  *(_OWORD *)(a7 + 48) = 0u;
  *(_OWORD *)(a7 + 64) = 0u;
  if (!(_BYTE)a6 || a4 == -1 || a3 == -1 || a4 < a3) {
    return;
  }
  uint64_t v137 = (void **)(a7 + 32);
  v152 = 0;
  v153 = 0;
  unint64_t v154 = 0;
  v149 = 0;
  v150 = 0;
  unint64_t v151 = 0;
  __src = 0;
  v147 = 0;
  int v7 = a3;
  unint64_t v148 = 0;
  do
  {
    if (!(_BYTE)v156) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    AWTmpEntryDailyData = Nightingale::wristTemperatureInputAcquisition::getAWTmpEntryDailyData(AWTmpEntryDailyData, a2, (int *)&v155 + 1, v7);
    if (v8)
    {
      char v9 = AWTmpEntryDailyData;
      if (*(_DWORD *)(a7 + 24) == -1) {
        *(_DWORD *)(a7 + 24) = v7;
      }
      unint64_t v142 = HIDWORD(AWTmpEntryDailyData);
      uint64_t v11 = (char *)__src;
      uint64_t v10 = v147;
      if (__src == v147)
      {
        if ((unint64_t)__src >= v148)
        {
          unint64_t v60 = 2 * (v148 - (void)__src);
          if (v60 <= 1) {
            unint64_t v60 = 1;
          }
          if (v148 - (unint64_t)__src >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v61 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v61 = v60;
          }
          char v62 = (char *)operator new(v61);
          char *v62 = v9;
          unint64_t v35 = v62 + 1;
          __src = v62;
          v147 = v62 + 1;
          unint64_t v148 = (unint64_t)&v62[v61];
          if (v11) {
            operator delete(v11);
          }
        }
        else
        {
          *(unsigned char *)__src = AWTmpEntryDailyData;
          unint64_t v35 = v11 + 1;
        }
        v147 = v35;
        unint64_t v63 = v150;
        if ((unint64_t)v150 >= v151)
        {
          int v65 = v149;
          uint64_t v66 = ((char *)v150 - (unsigned char *)v149) >> 2;
          unint64_t v67 = v66 + 1;
          if ((unint64_t)(v66 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v68 = v151 - (void)v149;
          if ((uint64_t)(v151 - (void)v149) >> 1 > v67) {
            unint64_t v67 = v68 >> 1;
          }
          if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v69 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v69 = v67;
          }
          if (v69)
          {
            int v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v151, v69);
            int v65 = v149;
            unint64_t v63 = v150;
          }
          else
          {
            int v70 = 0;
          }
          int v107 = &v70[4 * v66];
          *(_DWORD *)int v107 = v142;
          unint64_t v64 = v107 + 4;
          while (v63 != v65)
          {
            int v108 = *--v63;
            *((_DWORD *)v107 - 1) = v108;
            v107 -= 4;
          }
          v149 = v107;
          v150 = v64;
          unint64_t v151 = (unint64_t)&v70[4 * v69];
          if (v65) {
            operator delete(v65);
          }
        }
        else
        {
          _DWORD *v150 = v142;
          unint64_t v64 = v63 + 1;
        }
        v150 = v64;
        unint64_t v109 = v153;
        if ((unint64_t)v153 >= v154)
        {
LABEL_185:
          AWTmpEntryDailyData = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>((uint64_t *)&v152, (uint64_t)&v149);
          goto LABEL_186;
        }
LABEL_184:
        void *v153 = 0;
        v109[1] = 0;
        v109[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v109, v149, (uint64_t)v150, ((char *)v150 - (unsigned char *)v149) >> 2);
        AWTmpEntryDailyData = (unint64_t)(v109 + 3);
LABEL_186:
        v153 = (void *)AWTmpEntryDailyData;
        continue;
      }
      AWTmpEntryDailyData = (unint64_t)memchr(__src, (char)AWTmpEntryDailyData, v147 - (unsigned char *)__src);
      if (AWTmpEntryDailyData) {
        double v12 = (char *)AWTmpEntryDailyData;
      }
      else {
        double v12 = v10;
      }
      if (v12 == v10)
      {
        unint64_t v36 = 0;
        do
        {
          if (0xAAAAAAAAAAAAAAABLL * (v153 - v152) <= v36) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          unint64_t v37 = (char **)&v152[3 * v36];
          uint64_t v39 = v37 + 1;
          uint64_t v38 = v37[1];
          uint64_t v41 = v37 + 2;
          unint64_t v40 = (unint64_t)v37[2];
          if ((unint64_t)v38 >= v40)
          {
            unint64_t v43 = *v37;
            uint64_t v44 = (v38 - *v37) >> 2;
            unint64_t v45 = v44 + 1;
            if ((unint64_t)(v44 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v46 = v40 - (void)v43;
            if (v46 >> 1 > v45) {
              unint64_t v45 = v46 >> 1;
            }
            if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v47 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v47 = v45;
            }
            if (v47)
            {
              id v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v41, v47);
              uint64_t v38 = *v39;
              unint64_t v43 = *v37;
            }
            else
            {
              id v48 = 0;
            }
            uint64_t v49 = &v48[4 * v44];
            *(_DWORD *)uint64_t v49 = -1082130432;
            unint64_t v42 = v49 + 4;
            while (v38 != v43)
            {
              int v50 = *((_DWORD *)v38 - 1);
              v38 -= 4;
              *((_DWORD *)v49 - 1) = v50;
              v49 -= 4;
            }
            *unint64_t v37 = v49;
            char *v39 = v42;
            *uint64_t v41 = &v48[4 * v47];
            if (v43) {
              operator delete(v43);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v38 = -1082130432;
            unint64_t v42 = v38 + 4;
          }
          char *v39 = v42;
          ++v36;
          uint64_t v51 = (char *)__src;
          unint64_t v52 = v147;
          uint64_t v53 = v147 - (unsigned char *)__src;
        }
        while (v147 - (unsigned char *)__src > v36);
        if ((unint64_t)v147 >= v148)
        {
          unint64_t v71 = v53 + 1;
          if (v53 + 1 < 0) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          unint64_t v72 = v148 - (void)__src;
          if (2 * (v148 - (unint64_t)__src) > v71) {
            unint64_t v71 = 2 * v72;
          }
          if (v72 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v73 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v73 = v71;
          }
          if (v73) {
            long long v74 = (char *)operator new(v73);
          }
          else {
            long long v74 = 0;
          }
          uint64_t v110 = &v74[v53];
          v74[v53] = v9;
          uint64_t v54 = &v74[v53 + 1];
          if (v52 != v51)
          {
            uint64_t v111 = &v52[~(unint64_t)v51];
            do
            {
              char v112 = *--v52;
              (v111--)[(void)v74] = v112;
            }
            while (v52 != v51);
            unint64_t v52 = (char *)__src;
            uint64_t v110 = v74;
          }
          __src = v110;
          v147 = &v74[v53 + 1];
          unint64_t v148 = (unint64_t)&v74[v73];
          if (v52) {
            operator delete(v52);
          }
        }
        else
        {
          char *v147 = v9;
          uint64_t v54 = v52 + 1;
        }
        v147 = v54;
        v150 = v149;
        std::vector<float>::assign((char **)&v149, ((uint64_t)(v152[1] - *v152) >> 2) - 1, &Nightingale::INVALID_TMP);
        unint64_t v113 = v150;
        if ((unint64_t)v150 >= v151)
        {
          uint64_t v115 = v149;
          uint64_t v116 = ((char *)v150 - (unsigned char *)v149) >> 2;
          unint64_t v117 = v116 + 1;
          if ((unint64_t)(v116 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v118 = v151 - (void)v149;
          if ((uint64_t)(v151 - (void)v149) >> 1 > v117) {
            unint64_t v117 = v118 >> 1;
          }
          if ((unint64_t)v118 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v119 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v119 = v117;
          }
          if (v119)
          {
            unint64_t v120 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v151, v119);
            uint64_t v115 = v149;
            unint64_t v113 = v150;
          }
          else
          {
            unint64_t v120 = 0;
          }
          v121 = &v120[4 * v116];
          *(_DWORD *)v121 = v142;
          int v114 = v121 + 4;
          while (v113 != v115)
          {
            int v122 = *--v113;
            *((_DWORD *)v121 - 1) = v122;
            v121 -= 4;
          }
          v149 = v121;
          v150 = v114;
          unint64_t v151 = (unint64_t)&v120[4 * v119];
          if (v115) {
            operator delete(v115);
          }
        }
        else
        {
          _DWORD *v150 = v142;
          int v114 = v113 + 1;
        }
        v150 = v114;
        unint64_t v109 = v153;
        if ((unint64_t)v153 >= v154) {
          goto LABEL_185;
        }
        goto LABEL_184;
      }
      uint64_t v14 = v152;
      double v13 = v153;
      if (v152 == v153)
      {
        unint64_t v15 = 0;
        __n128 __p = 0;
        v144 = 0;
        uint64_t v145 = 0;
        do
        {
          if ((unint64_t)v14 >= v154)
          {
            uint64_t v14 = (void *)std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>((uint64_t *)&v152, (uint64_t)&__p);
          }
          else
          {
            *uint64_t v14 = 0;
            v14[1] = 0;
            _OWORD v14[2] = 0;
            std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v14, __p, (uint64_t)v144, (v144 - (unsigned char *)__p) >> 2);
            v14 += 3;
          }
          v153 = v14;
          ++v15;
          uint64_t v11 = (char *)__src;
        }
        while (v147 - (unsigned char *)__src > v15);
        AWTmpEntryDailyData = (unint64_t)__p;
        if (__p)
        {
          v144 = (char *)__p;
          operator delete(__p);
          uint64_t v11 = (char *)__src;
          uint64_t v14 = v153;
        }
        double v13 = v14;
        uint64_t v14 = v152;
      }
      if (0xAAAAAAAAAAAAAAABLL * (v13 - v14) <= v12 - v11) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      float v16 = &v14[3 * (v12 - v11)];
      long long v18 = (_DWORD **)(v16 + 1);
      float v17 = (_DWORD *)v16[1];
      unint64_t v19 = v16[2];
      if ((unint64_t)v17 >= v19)
      {
        AWTmpEntryDailyData = *v16;
        uint64_t v55 = (uint64_t)((uint64_t)v17 - *v16) >> 2;
        unint64_t v56 = v55 + 1;
        if ((unint64_t)(v55 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v57 = v19 - AWTmpEntryDailyData;
        if (v57 >> 1 > v56) {
          unint64_t v56 = v57 >> 1;
        }
        if ((unint64_t)v57 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v58 = v56;
        }
        if (v58)
        {
          unint64_t v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v16 + 2), v58);
          float v17 = *v18;
          AWTmpEntryDailyData = *v16;
        }
        else
        {
          unint64_t v59 = 0;
        }
        double v75 = &v59[4 * v55];
        *(_DWORD *)double v75 = v142;
        uint64_t v20 = v75 + 4;
        while (v17 != (_DWORD *)AWTmpEntryDailyData)
        {
          int v76 = *--v17;
          *((_DWORD *)v75 - 1) = v76;
          v75 -= 4;
        }
        *float v16 = (unint64_t)v75;
        *long long v18 = v20;
        _OWORD v16[2] = (unint64_t)&v59[4 * v58];
        if (AWTmpEntryDailyData) {
          operator delete((void *)AWTmpEntryDailyData);
        }
      }
      else
      {
        *float v17 = v142;
        uint64_t v20 = v17 + 1;
      }
      *long long v18 = v20;
      long long v77 = __src;
      int v78 = v12 - __src;
      if ((int)v12 - (int)__src >= 1)
      {
        unint64_t v79 = 0;
        do
        {
          if (0xAAAAAAAAAAAAAAABLL * (v153 - v152) <= v79) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          int v80 = &v152[3 * v79];
          unint64_t v82 = (_DWORD **)(v80 + 1);
          long long v81 = (_DWORD *)v80[1];
          int v84 = v80 + 2;
          unint64_t v83 = v80[2];
          if ((unint64_t)v81 >= v83)
          {
            AWTmpEntryDailyData = *v80;
            uint64_t v86 = (uint64_t)((uint64_t)v81 - *v80) >> 2;
            unint64_t v87 = v86 + 1;
            if ((unint64_t)(v86 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v88 = v83 - AWTmpEntryDailyData;
            if (v88 >> 1 > v87) {
              unint64_t v87 = v88 >> 1;
            }
            if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v89 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v89 = v87;
            }
            if (v89)
            {
              uint64_t v90 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v84, v89);
              long long v81 = *v82;
              AWTmpEntryDailyData = *v80;
            }
            else
            {
              uint64_t v90 = 0;
            }
            BOOL v91 = &v90[4 * v86];
            *(_DWORD *)BOOL v91 = -1082130432;
            uint64_t v85 = v91 + 4;
            while (v81 != (_DWORD *)AWTmpEntryDailyData)
            {
              int v92 = *--v81;
              *((_DWORD *)v91 - 1) = v92;
              v91 -= 4;
            }
            unint64_t *v80 = (unint64_t)v91;
            *unint64_t v82 = v85;
            *int v84 = &v90[4 * v89];
            if (AWTmpEntryDailyData) {
              operator delete((void *)AWTmpEntryDailyData);
            }
          }
          else
          {
            _DWORD *v81 = -1082130432;
            uint64_t v85 = v81 + 1;
          }
          *unint64_t v82 = v85;
          ++v79;
          long long v77 = __src;
          int v78 = v12 - __src;
        }
        while ((uint64_t)v79 < (int)v12 - (int)__src);
      }
      int v93 = v78 + 1;
      if (v147 - v77 > (unint64_t)(v78 + 1))
      {
        unint64_t v94 = v93;
        do
        {
          if (0xAAAAAAAAAAAAAAABLL * (v153 - v152) <= v94) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v95 = &v152[3 * v94];
          uint64_t v97 = (_DWORD **)(v95 + 1);
          uint64_t v96 = (_DWORD *)v95[1];
          unint64_t v98 = v95[2];
          if ((unint64_t)v96 >= v98)
          {
            AWTmpEntryDailyData = *v95;
            uint64_t v100 = (uint64_t)((uint64_t)v96 - *v95) >> 2;
            unint64_t v101 = v100 + 1;
            if ((unint64_t)(v100 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v102 = v98 - AWTmpEntryDailyData;
            if (v102 >> 1 > v101) {
              unint64_t v101 = v102 >> 1;
            }
            if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v103 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v103 = v101;
            }
            if (v103)
            {
              uint64_t v104 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v95 + 2), v103);
              uint64_t v96 = *v97;
              AWTmpEntryDailyData = *v95;
            }
            else
            {
              uint64_t v104 = 0;
            }
            int v105 = &v104[4 * v100];
            *(_DWORD *)int v105 = -1082130432;
            int v99 = v105 + 4;
            while (v96 != (_DWORD *)AWTmpEntryDailyData)
            {
              int v106 = *--v96;
              *((_DWORD *)v105 - 1) = v106;
              v105 -= 4;
            }
            *uint64_t v95 = (unint64_t)v105;
            char *v97 = v99;
            v95[2] = (unint64_t)&v104[4 * v103];
            if (AWTmpEntryDailyData) {
              operator delete((void *)AWTmpEntryDailyData);
            }
          }
          else
          {
            *uint64_t v96 = -1082130432;
            int v99 = v96 + 1;
          }
          char *v97 = v99;
          unint64_t v94 = ++v93;
        }
        while (v147 - (unsigned char *)__src > (unint64_t)v93);
      }
    }
    else if (v152 != v153 && v147 != __src)
    {
      unint64_t v21 = 0;
      do
      {
        if (0xAAAAAAAAAAAAAAABLL * (v153 - v152) <= v21) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        uint64_t v22 = &v152[3 * v21];
        BOOL v24 = (_DWORD **)(v22 + 1);
        unint64_t v23 = (_DWORD *)v22[1];
        uint64_t v26 = v22 + 2;
        unint64_t v25 = v22[2];
        if ((unint64_t)v23 >= v25)
        {
          AWTmpEntryDailyData = *v22;
          uint64_t v28 = (uint64_t)((uint64_t)v23 - *v22) >> 2;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v30 = v25 - AWTmpEntryDailyData;
          if (v30 >> 1 > v29) {
            unint64_t v29 = v30 >> 1;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            unint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v26, v31);
            unint64_t v23 = *v24;
            AWTmpEntryDailyData = *v22;
          }
          else
          {
            unint64_t v32 = 0;
          }
          uint64_t v33 = &v32[4 * v28];
          *(_DWORD *)uint64_t v33 = -1082130432;
          int v27 = v33 + 4;
          while (v23 != (_DWORD *)AWTmpEntryDailyData)
          {
            int v34 = *--v23;
            *((_DWORD *)v33 - 1) = v34;
            v33 -= 4;
          }
          *uint64_t v22 = (unint64_t)v33;
          *BOOL v24 = v27;
          *uint64_t v26 = &v32[4 * v31];
          if (AWTmpEntryDailyData) {
            operator delete((void *)AWTmpEntryDailyData);
          }
        }
        else
        {
          _DWORD *v23 = -1082130432;
          int v27 = v23 + 1;
        }
        *BOOL v24 = v27;
        ++v21;
      }
      while (v147 - (unsigned char *)__src > v21);
    }
  }
  while (v7++ != a4);
  *(_DWORD *)(a7 + 28) = a4;
  uint64_t v125 = v152;
  uint64_t v124 = v153;
  if (__src == v147)
  {
    v127 = v152;
    int v126 = a3;
    if (v153 != v152)
    {
      v128 = v153;
      do
      {
        long long v130 = (void *)*(v128 - 3);
        v128 -= 3;
        unint64_t v129 = v130;
        if (v130)
        {
          *(v124 - 2) = (uint64_t)v129;
          operator delete(v129);
        }
        uint64_t v124 = v128;
      }
      while (v128 != v125);
      v127 = v152;
    }
    v153 = v125;
    uint64_t v124 = v125;
    uint64_t v125 = v127;
  }
  else
  {
    int v126 = a3;
  }
  if (v125 != v124)
  {
    int v131 = v125;
    do
    {
      char v132 = (float *)*v131;
      v133 = (float *)v131[1];
      while (v132 != v133)
      {
        if (*v132 > 38.5) {
          *char v132 = -1.0;
        }
        ++v132;
      }
      v131 += 3;
    }
    while (v131 != v124);
  }
  int v134 = *(_DWORD *)(a7 + 24);
  int v135 = v134 - v126;
  if (v134 > v126)
  {
    if (!(_BYTE)v156) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if ((int)v155 <= v126)
    {
      if (v125 != v124)
      {
        do
        {
          std::vector<float>::vector(&__p, v135, &Nightingale::INVALID_TMP);
          std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)v125, *v125, (char *)__p, v144, (v144 - (unsigned char *)__p) >> 2);
          if (__p)
          {
            v144 = (char *)__p;
            operator delete(__p);
          }
          v125 += 3;
        }
        while (v125 != v124);
        int v134 = *(_DWORD *)(a7 + 24);
      }
      *(_DWORD *)(a7 + 24) = v134 - v135;
    }
  }
  if (&v152 != (void **)a7) {
    std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a7, (uint64_t)v152, (uint64_t)v153, 0xAAAAAAAAAAAAAAABLL * (v153 - v152));
  }
  uint64_t v136 = (char *)__src;
  if (v137 != &__src)
  {
    std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v137, (char *)__src, v147, v147 - (unsigned char *)__src);
    uint64_t v136 = (char *)__src;
  }
  if (v136)
  {
    v147 = v136;
    operator delete(v136);
  }
  if (v149)
  {
    v150 = v149;
    operator delete(v149);
  }
  v149 = &v152;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v149);
}

void sub_257D3A850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  a24 = (void *)(v26 - 128);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn(v25);
  _Unwind_Resume(a1);
}

char *std::vector<float>::assign(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  double result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 2)
  {
    double v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 2;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 2;
    }
    if (v15)
    {
      float v16 = result;
      do
      {
        *(_DWORD *)float v16 = *a3;
        v16 += 4;
        --v15;
      }
      while (v15);
    }
    if (a2 <= v14)
    {
      a1[1] = &result[4 * a2];
    }
    else
    {
      float v17 = &v13[4 * (a2 - v14)];
      uint64_t v18 = 4 * a2 - 4 * v14;
      do
      {
        *(_DWORD *)double v13 = *a3;
        v13 += 4;
        v18 -= 4;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 1;
    if (v6 >> 1 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    double result = std::vector<float>::__vallocate[abi:ne180100](a1, v9);
    uint64_t v10 = a1[1];
    uint64_t v11 = &v10[4 * a2];
    uint64_t v12 = 4 * a2;
    do
    {
      *(_DWORD *)uint64_t v10 = *a3;
      v10 += 4;
      v12 -= 4;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void Nightingale::wristTemperatureInputAcquisition::removeOutlierUsingSlidingWin(float a1, uint64_t a2, uint64_t *a3, int a4, int a5)
{
  unint64_t v5 = a4;
  uint64_t v6 = *a3;
  if (a4 < (unint64_t)((a3[1] - *a3) >> 2))
  {
    uint64_t v9 = 0;
    unint64_t v10 = a5;
    uint64_t v11 = 4 * a4;
    uint64_t v12 = v11 + 4 * a5;
    do
    {
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v19, (const void *)(v9 + v6), v11 + v9 + v6, v11 >> 2);
      double v13 = (const void *)(v11 + v9 + *a3);
      uint64_t v14 = v12 + v9 + *a3;
      float v17 = 0;
      uint64_t v18 = 0;
      __n128 __p = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v13, v14, v10);
      uint64_t MeanDiffOf2Windows = Nightingale::getMeanDiffOf2Windows((uint64_t)&v19, (float **)&__p, -1.0);
      if ((MeanDiffOf2Windows & 0xFF00000000) != 0 && COERCE_FLOAT(MeanDiffOf2Windows & 0x7FFFFFFF) >= a1)
      {
        if (v5 >= (a3[1] - *a3) >> 2) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        *(_DWORD *)(*a3 + 4 * v5) = -1082130432;
      }
      if (__p)
      {
        float v17 = __p;
        operator delete(__p);
      }
      if (v19)
      {
        uint64_t v20 = v19;
        operator delete(v19);
      }
      ++v5;
      uint64_t v6 = *a3;
      v9 += 4;
    }
    while (v5 < (a3[1] - *a3) >> 2);
  }
}

void sub_257D3AB60(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::wristTemperatureInputAcquisition::getOutlierRmvSegLen(Nightingale::wristTemperatureInputAcquisition *this, int a2, int a3)
{
  if (a3 - a2 < 30) {
    return 30;
  }
  LODWORD(result) = 31;
  do
    uint64_t result = (result - 1);
  while ((a3 - a2) % (int)result < 7);
  return result;
}

void Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, signed int a4@<W3>, void *a5@<X4>, unint64_t a6@<X5>, uint64_t a7@<X8>)
{
  signed int v7 = a6;
  unint64_t v14 = HIDWORD(a6);
  std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
  a1[4] = a1[3];
  a1[7] = a1[6];
  unint64_t v15 = -286331153 * ((a5[1] - *a5) >> 2);
  while ((int)v15 >= 1)
  {
    if (*(_DWORD *)(*a5 + 60 * --v15) <= a4) {
      goto LABEL_6;
    }
  }
  unint64_t v15 = 0;
LABEL_6:
  if (v7 <= a4) {
    uint64_t v16 = a4;
  }
  else {
    uint64_t v16 = v7;
  }
  if (v7 > a4) {
    unint64_t v15 = v14;
  }
  uint64_t v17 = v16 | (v15 << 32);
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(a1, a3 - a2 + 1 - v16, a3 - a2, a5, v17, (uint64_t)v18);
  if (__p)
  {
    uint64_t v22 = __p;
    operator delete(__p);
  }
  if (v19)
  {
    uint64_t v20 = v19;
    operator delete(v19);
  }
  unint64_t v23 = (void **)v18;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v23);
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(a1, a2, a3, a5, v17, a7);
}

void Nightingale::wristTemperatureInputAcquisition::reset(Nightingale::wristTemperatureInputAcquisition *this)
{
  *((void *)this + 4) = *((void *)this + 3);
  *((void *)this + 7) = *((void *)this + 6);
}

void Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(uint64_t *a1@<X0>, int a2@<W1>, int a3@<W2>, void *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  Nightingale::wristTemperatureInputAcquisition::extractKaliInputsJDayRange((unint64_t)a1, a4, a3 - a2 + 1, a3, a5, 1, a6);
  uint64_t v9 = *(float ***)a6;
  unint64_t v10 = *(float ***)(a6 + 8);
  if (*(float ***)a6 != v10 && *v9 != v9[1])
  {
    __n128 __p = 0;
    unint64_t v82 = 0;
    unint64_t v83 = 0;
    int v76 = a1 + 3;
    if (a1[3] != a1[4])
    {
      uint64_t v11 = *(char **)(a6 + 32);
      uint64_t v12 = *(char **)(a6 + 40);
      if (v11 != v12)
      {
        double v13 = 0;
        unsigned __int8 v14 = 0;
        while (1)
        {
          uint64_t v16 = (void *)a1[3];
          uint64_t v15 = a1[4];
          uint64_t v8 = (char *)memchr(v16, *v11, v15 - (void)v16);
          if (v8) {
            uint64_t v17 = v8;
          }
          else {
            uint64_t v17 = (unsigned char *)v15;
          }
          if (v17 == (unsigned char *)v15)
          {
            if ((unint64_t)v13 >= v83)
            {
              uint64_t v8 = (char *)__p;
              uint64_t v27 = (v13 - (unsigned char *)__p) >> 2;
              unint64_t v28 = v27 + 1;
              if ((unint64_t)(v27 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v29 = v83 - (void)__p;
              if ((uint64_t)(v83 - (void)__p) >> 1 > v28) {
                unint64_t v28 = v29 >> 1;
              }
              if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v30 = v28;
              }
              if (v30)
              {
                unint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v83, v30);
                uint64_t v8 = (char *)__p;
                double v13 = v82;
              }
              else
              {
                unint64_t v31 = 0;
              }
              unint64_t v35 = &v31[4 * v27];
              *(_DWORD *)unint64_t v35 = 0;
              uint64_t v21 = v35 + 4;
              while (v13 != v8)
              {
                int v36 = *((_DWORD *)v13 - 1);
                v13 -= 4;
                *((_DWORD *)v35 - 1) = v36;
                v35 -= 4;
              }
              int v34 = &v31[4 * v30];
              __n128 __p = v35;
              goto LABEL_43;
            }
            *(_DWORD *)double v13 = 0;
            uint64_t v21 = v13 + 4;
          }
          else
          {
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 3) <= v14) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            unint64_t v18 = v17 - (unsigned char *)v16;
            if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) <= v18) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v8 = std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>(*(void *)a6 + 24 * v14, *(void *)(*(void *)a6 + 24 * v14), *(char **)(*a1 + 24 * v18), *(char **)(*a1 + 24 * v18 + 8), (uint64_t)(*(void *)(*a1 + 24 * v18 + 8) - *(void *)(*a1 + 24 * v18)) >> 2);
            if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) <= v18) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v19 = (*(void *)(*a1 + 24 * v18 + 8) - *(void *)(*a1 + 24 * v18)) >> 2;
            uint64_t v20 = v82;
            if ((unint64_t)v82 >= v83)
            {
              uint64_t v8 = (char *)__p;
              uint64_t v22 = (v82 - (unsigned char *)__p) >> 2;
              unint64_t v23 = v22 + 1;
              if ((unint64_t)(v22 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v24 = v83 - (void)__p;
              if ((uint64_t)(v83 - (void)__p) >> 1 > v23) {
                unint64_t v23 = v24 >> 1;
              }
              if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v23;
              }
              if (v25)
              {
                uint64_t v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v83, v25);
                uint64_t v8 = (char *)__p;
                uint64_t v20 = v82;
              }
              else
              {
                uint64_t v26 = 0;
              }
              unint64_t v32 = &v26[4 * v22];
              *(_DWORD *)unint64_t v32 = v19;
              uint64_t v21 = v32 + 4;
              while (v20 != v8)
              {
                int v33 = *((_DWORD *)v20 - 1);
                v20 -= 4;
                *((_DWORD *)v32 - 1) = v33;
                v32 -= 4;
              }
              int v34 = &v26[4 * v25];
              __n128 __p = v32;
LABEL_43:
              unint64_t v82 = v21;
              unint64_t v83 = (unint64_t)v34;
              if (v8) {
                operator delete(v8);
              }
              goto LABEL_45;
            }
            *(_DWORD *)unint64_t v82 = v19;
            uint64_t v21 = v20 + 4;
          }
LABEL_45:
          unint64_t v82 = v21;
          ++v14;
          ++v11;
          double v13 = v21;
          if (v11 == v12)
          {
            uint64_t v9 = *(float ***)a6;
            unint64_t v10 = *(float ***)(a6 + 8);
            break;
          }
        }
      }
    }
    if (v9 != v10)
    {
      unsigned __int8 v37 = 0;
      do
      {
        if (__p == v82) {
          goto LABEL_53;
        }
        unint64_t v38 = (v82 - (unsigned char *)__p) >> 2;
        if (v38 - 1 < v37) {
          goto LABEL_53;
        }
        if (v38 <= v37) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        if (*((_DWORD *)__p + v37) || (id v48 = *v9, v49 = v9[1], *v9 == v49))
        {
LABEL_53:
          uint64_t v39 = 0;
        }
        else
        {
          uint64_t v39 = 0;
          do
          {
            if (*v48 >= 0.0) {
              break;
            }
            ++v39;
            ++v48;
          }
          while (v48 != v49);
        }
        uint64_t v40 = (uint64_t)v9[1];
        uint64_t v41 = &(*v9)[v39];
        int v78 = 0;
        unint64_t v79 = 0;
        uint64_t v80 = 0;
        unint64_t v42 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v78, v41, v40, (v40 - (uint64_t)v41) >> 2);
        Nightingale::wristTemperatureInputAcquisition::removeOutlierUsingSlidingWin(1.0, (uint64_t)v42, (uint64_t *)&v78, 7, 1);
        if (v79 != v78) {
          memmove(&(*v9)[v39], v78, v79 - (unsigned char *)v78);
        }
        if (__p != v82)
        {
          if (v37 >= (unint64_t)((v82 - (unsigned char *)__p) >> 2)) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v43 = *((int *)__p + v37);
          if (v43)
          {
            unint64_t v45 = *v9;
            uint64_t v44 = v9[1];
            uint64_t v46 = &(*v9)[v43];
            int64_t v47 = (char *)v44 - (char *)v46;
            if (v44 != v46) {
              memmove(*v9, v46, (char *)v44 - (char *)v46);
            }
            v9[1] = (float *)((char *)v45 + v47);
          }
        }
        uint64_t v8 = (char *)v78;
        if (v78)
        {
          unint64_t v79 = v78;
          operator delete(v78);
        }
        ++v37;
        v9 += 3;
      }
      while (v9 != v10);
    }
    LOBYTE(v77) = 0;
    BYTE4(v77) = 0;
    int v50 = (char *)a1[6];
    uint64_t v51 = a1[7];
    unint64_t v52 = (uint64_t *)(a6 + 56);
    if (v50 == (char *)v51)
    {
      if (*(void *)(a6 + 56) == *(void *)(a6 + 64))
      {
        uint64_t v8 = std::vector<std::optional<float>>::assign((char **)(a6 + 56), *(void *)(a6 + 40) - *(void *)(a6 + 32), (int *)&v77);
      }
      else
      {
        log = ha_get_log();
        uint64_t v8 = (char *)os_log_type_enabled(log, OS_LOG_TYPE_FAULT);
        if (v8) {
          Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(log);
        }
      }
    }
    else
    {
      if (v52 != a1 + 6) {
        uint64_t v8 = std::vector<std::optional<float>>::__assign_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>((char *)(a6 + 56), v50, v51, (v51 - (uint64_t)v50) >> 3);
      }
      unint64_t v53 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 3);
      uint64_t v54 = *(void *)(a6 + 56);
      uint64_t v55 = *(char **)(a6 + 64);
      unint64_t v56 = (uint64_t)&v55[-v54] >> 3;
      BOOL v57 = v56 >= v53;
      unint64_t v58 = v56 - v53;
      if (v58 != 0 && v57)
      {
        unint64_t v59 = (char *)(v54 + 8 * v58);
        int64_t v60 = v55 - v59;
        if (v55 != v59) {
          uint64_t v8 = (char *)memmove(*(void **)(a6 + 56), v59, v60 - 3);
        }
        *(void *)(a6 + 64) = v54 + v60;
      }
      else if (v58)
      {
        char v62 = (void *)(a6 + 72);
        do
        {
          if ((unint64_t)v55 >= *v62)
          {
            unint64_t v63 = v56 + 1;
            if ((v56 + 1) >> 61) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v64 = *v62 - v54;
            if (v64 >> 2 > v63) {
              unint64_t v63 = v64 >> 2;
            }
            if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v65 = v63;
            }
            if (v65) {
              uint64_t v8 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(a6 + 72, v65);
            }
            else {
              uint64_t v8 = 0;
            }
            uint64_t v66 = &v8[8 * v56];
            *(void *)uint64_t v66 = v77;
            uint64_t v55 = v66 + 8;
            uint64_t v68 = *(unsigned char **)(a6 + 56);
            unint64_t v67 = *(unsigned char **)(a6 + 64);
            if (v67 != v68)
            {
              do
              {
                int v69 = *((_DWORD *)v67 - 2);
                v67 -= 8;
                char v70 = v67[4];
                *((_DWORD *)v66 - 2) = v69;
                v66 -= 8;
                v66[4] = v70;
              }
              while (v67 != v68);
              unint64_t v67 = (unsigned char *)*v52;
            }
            *(void *)(a6 + 56) = v66;
            *(void *)(a6 + 64) = v55;
            *(void *)(a6 + 72) = &v8[8 * v65];
            if (v67) {
              operator delete(v67);
            }
          }
          else
          {
            *(void *)uint64_t v55 = v77;
            v55 += 8;
          }
          *(void *)(a6 + 64) = v55;
          uint64_t v54 = *(void *)(a6 + 56);
          unint64_t v56 = (uint64_t)&v55[-v54] >> 3;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 3) != v56);
      }
    }
    Nightingale::wristTemperatureInputAcquisition::getLastValidSamplesFromRawTmp((Nightingale *)v8, (float ***)a6, (uint64_t)(a1 + 6));
    if (*(void *)(*(void *)a6 + 8) - **(void **)a6 > 0x1BuLL)
    {
      std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
      unint64_t v71 = *(float ***)a6;
      unint64_t v72 = *(float ***)(a6 + 8);
      while (v71 != v72)
      {
        uint64_t v73 = (uint64_t)v71[1];
        int v78 = 0;
        unint64_t v79 = 0;
        uint64_t v80 = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v78, (const void *)(v73 - 28), v73, 7uLL);
        unint64_t v74 = a1[1];
        if (v74 >= a1[2])
        {
          uint64_t v75 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(a1, (uint64_t)&v78);
        }
        else
        {
          std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)a1, (uint64_t)&v78);
          uint64_t v75 = v74 + 24;
        }
        a1[1] = v75;
        if (v78)
        {
          unint64_t v79 = v78;
          operator delete(v78);
        }
        v71 += 3;
      }
    }
    else if (*a1 == a1[1] && a1 != (uint64_t *)a6)
    {
      std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((uint64_t)a1, *(void *)a6, *(void *)(a6 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a6 + 8) - *(void *)a6) >> 3));
    }
    if (v76 != (void *)(a6 + 32)) {
      std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v76, *(char **)(a6 + 32), *(char **)(a6 + 40), *(void *)(a6 + 40) - *(void *)(a6 + 32));
    }
    if (__p)
    {
      unint64_t v82 = (char *)__p;
      operator delete(__p);
    }
  }
}

void sub_257D3B424(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn(v17);
  _Unwind_Resume(a1);
}

char *std::vector<std::optional<float>>::assign(char **a1, unint64_t a2, int *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 3)
  {
    unint64_t v13 = (a1[1] - result) >> 3;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - result) >> 3;
    }
    for (; v14; --v14)
    {
      int v15 = *a3;
      result[4] = *((unsigned char *)a3 + 4);
      *(_DWORD *)uint64_t result = v15;
      result += 8;
    }
    if (a2 <= v13)
    {
      a1[1] = &(*a1)[8 * a2];
    }
    else
    {
      uint64_t v16 = a1[1];
      uint64_t v17 = &v16[8 * (a2 - v13)];
      uint64_t v18 = 8 * a2 - 8 * v13;
      do
      {
        *(void *)uint64_t v16 = *(void *)a3;
        v16 += 8;
        v18 -= 8;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 2;
    if (v6 >> 2 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](a1, v9);
    unint64_t v10 = a1[1];
    uint64_t v11 = &v10[8 * a2];
    uint64_t v12 = 8 * a2;
    do
    {
      *(void *)unint64_t v10 = *(void *)a3;
      v10 += 8;
      v12 -= 8;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void Nightingale::wristTemperatureInputAcquisition::getLastValidSamplesFromRawTmp(Nightingale *a1, float ***a2, uint64_t a3)
{
  if (*a2 != a2[1] && **a2 != (*a2)[1])
  {
    unint64_t v4 = a2[4];
    unint64_t v5 = a2[5];
    if (v4 != v5)
    {
      LOBYTE(v27) = 0;
      BYTE4(v27) = 0;
      signed int v7 = *(void **)(a3 + 8);
      if (*(void **)a3 == v7)
      {
        a1 = (Nightingale *)std::vector<std::optional<float>>::assign((char **)a3, (char *)v5 - (char *)v4, (int *)&v27);
        signed int v7 = *(void **)(a3 + 8);
      }
      else
      {
        uint64_t v8 = (uint64_t)v7 - *(void *)a3;
        if ((char *)v5 - (char *)v4 > (unint64_t)(int)((unint64_t)v8 >> 3))
        {
          unint64_t v9 = (int)(v8 >> 3);
          unint64_t v10 = (void *)(a3 + 16);
          do
          {
            if ((unint64_t)v7 >= *v10)
            {
              uint64_t v11 = ((uint64_t)v7 - *(void *)a3) >> 3;
              if ((unint64_t)(v11 + 1) >> 61) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v12 = *v10 - *(void *)a3;
              uint64_t v13 = v12 >> 2;
              if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
                uint64_t v13 = v11 + 1;
              }
              if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v14 = v13;
              }
              if (v14) {
                a1 = (Nightingale *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(a3 + 16, v14);
              }
              else {
                a1 = 0;
              }
              int v15 = (char *)a1 + 8 * v11;
              *(void *)int v15 = v27;
              signed int v7 = v15 + 8;
              uint64_t v17 = *(char **)a3;
              uint64_t v16 = *(char **)(a3 + 8);
              if (v16 != *(char **)a3)
              {
                do
                {
                  int v18 = *((_DWORD *)v16 - 2);
                  v16 -= 8;
                  char v19 = v16[4];
                  *((_DWORD *)v15 - 2) = v18;
                  v15 -= 8;
                  v15[4] = v19;
                }
                while (v16 != v17);
                uint64_t v16 = *(char **)a3;
              }
              *(void *)a3 = v15;
              *(void *)(a3 + 8) = v7;
              *(void *)(a3 + 16) = (char *)a1 + 8 * v14;
              if (v16) {
                operator delete(v16);
              }
            }
            else
            {
              *v7++ = v27;
            }
            *(void *)(a3 + 8) = v7;
            ++v9;
          }
          while ((char *)a2[5] - (char *)a2[4] > v9);
        }
      }
      uint64_t v20 = *a2;
      uint64_t v21 = a2[1];
      if (0xAAAAAAAAAAAAAAABLL * (v21 - *a2) > ((uint64_t)v7 - *(void *)a3) >> 3)
      {
        log = ha_get_log();
        if (os_log_type_enabled(log, OS_LOG_TYPE_FAULT)) {
          Nightingale::wristTemperatureInputAcquisition::getLastValidSamplesFromRawTmp(log);
        }
        *(void *)(a3 + 8) = *(void *)a3;
        a1 = (Nightingale *)std::vector<std::optional<float>>::assign((char **)a3, 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2), (int *)&v27);
        uint64_t v20 = *a2;
        uint64_t v21 = a2[1];
      }
      if (v20 != v21)
      {
        unint64_t v23 = 0;
        do
        {
          uint64_t v24 = v20[1];
          while (v24 != *v20)
          {
            float v25 = *--v24;
            LOBYTE(a1) = Nightingale::check2Real_t_equal(a1, v25, -1.0);
            if ((a1 & 1) == 0)
            {
              if (v23 >= (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) {
                std::vector<int>::__throw_out_of_range[abi:ne180100]();
              }
              uint64_t v26 = *(void *)a3 + 8 * v23;
              *(float *)uint64_t v26 = *v24;
              *(unsigned char *)(v26 + 4) = 1;
              break;
            }
          }
          ++v23;
          v20 += 3;
        }
        while (v20 != v21);
      }
    }
  }
}

void Nightingale::wristTemperatureInputProcess::constructVectorOfSlicesFromMultipleWatches(Nightingale::extractKaliInputsRtn *a1@<X1>, int a2@<W2>, int a3@<W3>, int a4@<W4>, uint64_t a5@<X8>)
{
  *(void *)(a5 + 64) = 0;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  uint64_t v97 = 0;
  unint64_t v98 = 0;
  unint64_t v99 = 0;
  if (Nightingale::assertVectorOfVectors((uint64_t)a1))
  {
    int v10 = *((_DWORD *)a1 + 6);
    if (v10 != -1 && *((_DWORD *)a1 + 7) != -1)
    {
      uint64_t v12 = *((void *)a1 + 4);
      uint64_t v13 = *((void *)a1 + 5);
      if (v12 != v13)
      {
        uint64_t v14 = v13 - v12;
        if (v14 == 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a1 + 1) - *(void *)a1) >> 3)
          && v14 == (uint64_t)(*((void *)a1 + 8) - *((void *)a1 + 7)) >> 3)
        {
          unint64_t v15 = (v10 - a4);
          if ((int)v15 >= 1)
          {
            std::vector<float>::vector(&__p, v15, &Nightingale::INVALID_TMP);
            uint64_t v17 = *(uint64_t **)a1;
            uint64_t v16 = (uint64_t *)*((void *)a1 + 1);
            while (v17 != v16)
            {
              std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)v17, *v17, (char *)__p, v95, (v95 - (unsigned char *)__p) >> 2);
              v17 += 3;
            }
            if (__p)
            {
              uint64_t v95 = (char *)__p;
              operator delete(__p);
            }
          }
          if (a3 >= 1)
          {
            __int16 v18 = 0;
            uint64_t v85 = (void *)(a5 + 48);
            uint64_t v86 = (unint64_t *)(a5 + 24);
            do
            {
              __n128 __p = 0;
              uint64_t v95 = 0;
              unint64_t v96 = 0;
              uint64_t v20 = *(void **)a1;
              char v19 = (void *)*((void *)a1 + 1);
              if (*(void **)a1 == v19)
              {
                int v34 = 0;
                int v36 = 0;
              }
              else
              {
                do
                {
                  uint64_t v21 = (const void *)(*v20 + 4 * v18);
                  BOOL v91 = 0;
                  int v92 = 0;
                  uint64_t v93 = 0;
                  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v91, v21, (uint64_t)v21 + 4 * a2, a2);
                  int MissingCnt = Nightingale::getMissingCnt((float **)&v91);
                  int v23 = MissingCnt;
                  uint64_t v24 = v95;
                  if ((unint64_t)v95 >= v96)
                  {
                    uint64_t v26 = (char *)__p;
                    int64_t v27 = (v95 - (unsigned char *)__p) >> 2;
                    unint64_t v28 = v27 + 1;
                    if ((unint64_t)(v27 + 1) >> 62) {
                      std::vector<float>::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v29 = v96 - (void)__p;
                    if ((uint64_t)(v96 - (void)__p) >> 1 > v28) {
                      unint64_t v28 = v29 >> 1;
                    }
                    if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
                      unint64_t v30 = 0x3FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v30 = v28;
                    }
                    if (v30)
                    {
                      unint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v96, v30);
                      uint64_t v26 = (char *)__p;
                      uint64_t v24 = v95;
                    }
                    else
                    {
                      unint64_t v31 = 0;
                    }
                    unint64_t v32 = &v31[4 * v27];
                    *(_DWORD *)unint64_t v32 = v23;
                    float v25 = v32 + 4;
                    while (v24 != v26)
                    {
                      int v33 = *((_DWORD *)v24 - 1);
                      v24 -= 4;
                      *((_DWORD *)v32 - 1) = v33;
                      v32 -= 4;
                    }
                    __n128 __p = v32;
                    uint64_t v95 = v25;
                    unint64_t v96 = (unint64_t)&v31[4 * v30];
                    if (v26) {
                      operator delete(v26);
                    }
                  }
                  else
                  {
                    *(_DWORD *)uint64_t v95 = MissingCnt;
                    float v25 = v24 + 4;
                  }
                  uint64_t v95 = v25;
                  if (v91)
                  {
                    int v92 = v91;
                    operator delete(v91);
                  }
                  v20 += 3;
                }
                while (v20 != v19);
                int v34 = __p;
                if (__p == v95)
                {
                  int v36 = __p;
                }
                else
                {
                  unint64_t v35 = (char *)__p + 4;
                  int v36 = __p;
                  if ((char *)__p + 4 != v95)
                  {
                    int v37 = *(_DWORD *)__p;
                    int v36 = __p;
                    unint64_t v38 = (char *)__p + 4;
                    do
                    {
                      int v40 = *(_DWORD *)v38;
                      v38 += 4;
                      int v39 = v40;
                      if (v40 < v37)
                      {
                        int v37 = v39;
                        int v36 = v35;
                      }
                      unint64_t v35 = v38;
                    }
                    while (v38 != v95);
                  }
                }
              }
              unint64_t v41 = v36 - v34;
              uint64_t v43 = *(unsigned char **)(a5 + 32);
              unint64_t v42 = *(void *)(a5 + 40);
              unint64_t v44 = v41 >> 2;
              if ((unint64_t)v43 >= v42)
              {
                unint64_t v46 = *v86;
                int64_t v47 = &v43[-*v86];
                unint64_t v48 = (unint64_t)(v47 + 1);
                if ((uint64_t)(v47 + 1) < 0) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                unint64_t v49 = v42 - v46;
                if (2 * v49 > v48) {
                  unint64_t v48 = 2 * v49;
                }
                if (v49 >= 0x3FFFFFFFFFFFFFFFLL) {
                  size_t v50 = 0x7FFFFFFFFFFFFFFFLL;
                }
                else {
                  size_t v50 = v48;
                }
                if (v50) {
                  uint64_t v51 = (char *)operator new(v50);
                }
                else {
                  uint64_t v51 = 0;
                }
                unint64_t v52 = &v47[(void)v51];
                unint64_t v53 = &v47[(void)v51];
                *unint64_t v53 = v44;
                unint64_t v45 = v53 + 1;
                if (v43 != (unsigned char *)v46)
                {
                  uint64_t v54 = &v43[~v46];
                  do
                  {
                    char v55 = *--v43;
                    (v54--)[(void)v51] = v55;
                  }
                  while (v43 != (unsigned char *)v46);
                  uint64_t v43 = (unsigned char *)*v86;
                  unint64_t v52 = v51;
                }
                *(void *)(a5 + 24) = v52;
                *(void *)(a5 + 32) = v45;
                *(void *)(a5 + 40) = &v51[v50];
                if (v43) {
                  operator delete(v43);
                }
              }
              else
              {
                *uint64_t v43 = v44;
                unint64_t v45 = v43 + 1;
              }
              *(void *)(a5 + 32) = v45;
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a1 + 1) - *(void *)a1) >> 3) <= v44) {
                std::vector<int>::__throw_out_of_range[abi:ne180100]();
              }
              unint64_t v56 = (v41 >> 2);
              BOOL v57 = (const void *)(*(void *)(*(void *)a1 + 24 * v56) + 4 * v18);
              BOOL v91 = 0;
              int v92 = 0;
              uint64_t v93 = 0;
              std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v91, v57, (uint64_t)v57 + 4 * a2, a2);
              unint64_t v58 = v98;
              if ((unint64_t)v98 >= v99)
              {
                unint64_t v59 = (void *)std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(&v97, (uint64_t)&v91);
              }
              else
              {
                void *v98 = 0;
                v58[1] = 0;
                v58[2] = 0;
                std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v58, v91, (uint64_t)v92, (v92 - (unsigned char *)v91) >> 2);
                unint64_t v59 = v58 + 3;
              }
              unint64_t v98 = v59;
              uint64_t v60 = *((void *)a1 + 7);
              if (v56 >= (*((void *)a1 + 8) - v60) >> 3) {
                std::vector<int>::__throw_out_of_range[abi:ne180100]();
              }
              uint64_t v61 = v60 + 8 * v56;
              float v62 = *(float *)v61;
              char v63 = *(unsigned char *)(v61 + 4);
              int v64 = *(unsigned __int8 *)(v61 + 7);
              int v65 = *(unsigned __int16 *)(v61 + 5);
              if (v18 < 1)
              {
                float v69 = *(float *)v61;
              }
              else
              {
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a1 + 1) - *(void *)a1) >> 3) <= v56) {
                  std::vector<int>::__throw_out_of_range[abi:ne180100]();
                }
                uint64_t v66 = *(const void **)(*(void *)a1 + 24 * v56);
                uint64_t v88 = 0;
                unint64_t v89 = 0;
                uint64_t v90 = 0;
                std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v88, v66, (uint64_t)v66 + 4 * v18, v18);
                unint64_t v67 = v89;
                while (v67 != v88)
                {
                  float v68 = *--v67;
                  float v69 = v68;
                  if (v68 > 0.0)
                  {
                    char v63 = 1;
                    if (!v88) {
                      goto LABEL_78;
                    }
                    goto LABEL_77;
                  }
                }
                float v69 = v62;
                if (!v88) {
                  goto LABEL_78;
                }
LABEL_77:
                unint64_t v89 = v88;
                operator delete(v88);
              }
LABEL_78:
              int v70 = v65 | (v64 << 16);
              unint64_t v71 = *(void *)(a5 + 56);
              unint64_t v72 = *(void *)(a5 + 64);
              if (v71 >= v72)
              {
                uint64_t v74 = (uint64_t)(v71 - *v85) >> 3;
                unint64_t v75 = v74 + 1;
                if ((unint64_t)(v74 + 1) >> 61) {
                  std::vector<float>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v76 = v72 - *v85;
                if (v76 >> 2 > v75) {
                  unint64_t v75 = v76 >> 2;
                }
                if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v77 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v77 = v75;
                }
                if (v77) {
                  int v78 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(a5 + 64, v77);
                }
                else {
                  int v78 = 0;
                }
                unint64_t v79 = &v78[8 * v74];
                *(float *)unint64_t v79 = v69;
                v79[4] = v63;
                v79[7] = BYTE2(v70);
                *(_WORD *)(v79 + 5) = v65;
                long long v81 = *(unsigned char **)(a5 + 48);
                uint64_t v80 = *(unsigned char **)(a5 + 56);
                unint64_t v82 = v79;
                if (v80 != v81)
                {
                  do
                  {
                    int v83 = *((_DWORD *)v80 - 2);
                    v80 -= 8;
                    char v84 = v80[4];
                    *((_DWORD *)v82 - 2) = v83;
                    v82 -= 8;
                    v82[4] = v84;
                  }
                  while (v80 != v81);
                  uint64_t v80 = (unsigned char *)*v85;
                }
                uint64_t v73 = v79 + 8;
                *(void *)(a5 + 48) = v82;
                *(void *)(a5 + 56) = v79 + 8;
                *(void *)(a5 + 64) = &v78[8 * v77];
                if (v80) {
                  operator delete(v80);
                }
              }
              else
              {
                *(float *)unint64_t v71 = v69;
                *(unsigned char *)(v71 + 4) = v63;
                *(_WORD *)(v71 + 5) = v65;
                *(unsigned char *)(v71 + 7) = BYTE2(v70);
                uint64_t v73 = (char *)(v71 + 8);
              }
              *(void *)(a5 + 56) = v73;
              if (v91)
              {
                int v92 = v91;
                operator delete(v91);
              }
              if (__p)
              {
                uint64_t v95 = (char *)__p;
                operator delete(__p);
              }
              ++v18;
            }
            while (a3 > v18);
          }
          if (&v97 != (uint64_t *)a5) {
            std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a5, v97, (uint64_t)v98, 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v98 - v97) >> 3));
          }
        }
      }
    }
  }
  __n128 __p = &v97;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_257D3BE90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,char *__p,uint64_t a23,uint64_t a24,char a25,uint64_t a26)
{
  __n128 __p = &a25;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  Nightingale::pickSlicesStruct::~pickSlicesStruct(v26);
  _Unwind_Resume(a1);
}

void Nightingale::wristTemperatureInputProcess::clearDLSlices(uint64_t a1, uint64_t *a2)
{
  a2[19] = a2[18];
  a2[4] = a2[3];
  a2[10] = 0;
  a2[16] = 0;
  a2[13] = 0;
  a2[7] = a2[6];
  a2[22] = a2[21];
}

void Nightingale::addEntryToNewextractedLunaDayStreamSlice(uint64_t *a1, void *a2, int a3)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2[1] - *a2) >> 3) <= a3) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  unint64_t v5 = a3;
  uint64_t v6 = *a2 + 24 * a3;
  unint64_t v7 = a1[1];
  if (v7 >= a1[2])
  {
    uint64_t v8 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(a1, v6);
  }
  else
  {
    std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>((uint64_t)a1, v6);
    uint64_t v8 = v7 + 24;
  }
  a1[1] = v8;
  uint64_t v9 = a2[18];
  if (v5 >= (a2[19] - v9) >> 2) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  unint64_t v10 = a1[20];
  uint64_t v11 = (char *)a1[19];
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v13 = (char *)a1[18];
    uint64_t v14 = (v11 - v13) >> 2;
    if ((unint64_t)(v14 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = v10 - (void)v13;
    unint64_t v16 = (uint64_t)(v10 - (void)v13) >> 1;
    if (v16 <= v14 + 1) {
      unint64_t v16 = v14 + 1;
    }
    if (v15 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    if (v17)
    {
      __int16 v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 20), v17);
      uint64_t v13 = (char *)a1[18];
      uint64_t v11 = (char *)a1[19];
    }
    else
    {
      __int16 v18 = 0;
    }
    char v19 = &v18[4 * v14];
    uint64_t v20 = &v18[4 * v17];
    *(_DWORD *)char v19 = *(_DWORD *)(v9 + 4 * v5);
    uint64_t v12 = v19 + 4;
    while (v11 != v13)
    {
      int v21 = *((_DWORD *)v11 - 1);
      v11 -= 4;
      *((_DWORD *)v19 - 1) = v21;
      v19 -= 4;
    }
    a1[18] = (uint64_t)v19;
    a1[19] = (uint64_t)v12;
    a1[20] = (uint64_t)v20;
    if (v13) {
      operator delete(v13);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v11 = *(_DWORD *)(v9 + 4 * v5);
    uint64_t v12 = v11 + 4;
  }
  a1[19] = (uint64_t)v12;
  uint64_t v22 = a2[3];
  if (a2[4] - v22 <= v5) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  uint64_t v24 = (unsigned char *)a1[4];
  unint64_t v23 = a1[5];
  if ((unint64_t)v24 >= v23)
  {
    uint64_t v26 = a1[3];
    int64_t v27 = &v24[-v26];
    uint64_t v28 = (uint64_t)&v24[-v26 + 1];
    if (v28 < 0) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v29 = v23 - v26;
    if (2 * v29 > v28) {
      uint64_t v28 = 2 * v29;
    }
    if (v29 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v30 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v30 = v28;
    }
    if (v30) {
      uint64_t v31 = (uint64_t)operator new(v30);
    }
    else {
      uint64_t v31 = 0;
    }
    unint64_t v32 = (char *)(v31 + v30);
    v27[v31] = *(unsigned char *)(v22 + v5);
    uint64_t v25 = (uint64_t)&v27[v31 + 1];
    if (v24 == (unsigned char *)v26)
    {
      v31 += (uint64_t)v27;
    }
    else
    {
      int v33 = &v24[~v26];
      do
      {
        char v34 = *--v24;
        (v33--)[v31] = v34;
      }
      while (v24 != (unsigned char *)v26);
      uint64_t v24 = (unsigned char *)a1[3];
    }
    a1[3] = v31;
    a1[4] = v25;
    a1[5] = (uint64_t)v32;
    if (v24) {
      operator delete(v24);
    }
  }
  else
  {
    *uint64_t v24 = *(unsigned char *)(v22 + v5);
    uint64_t v25 = (uint64_t)(v24 + 1);
  }
  a1[4] = v25;
  if (a2[10] <= v5) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  unint64_t v35 = v5 >> 6;
  uint64_t v36 = 1 << v5;
  BOOL v65 = (*(void *)(a2[9] + 8 * (v5 >> 6)) & (1 << v5)) != 0;
  std::vector<BOOL>::push_back((uint64_t)(a1 + 9), &v65);
  if (a2[16] <= v5) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  BOOL v64 = (*(void *)(a2[15] + 8 * v35) & v36) != 0;
  std::vector<BOOL>::push_back((uint64_t)(a1 + 15), &v64);
  if (a2[13] <= v5) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  BOOL v63 = (*(void *)(a2[12] + 8 * v35) & v36) != 0;
  std::vector<BOOL>::push_back((uint64_t)(a1 + 12), &v63);
  uint64_t v37 = a2[6];
  if (v5 >= (a2[7] - v37) >> 2) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  unint64_t v38 = a1[8];
  int v39 = (char *)a1[7];
  if ((unint64_t)v39 >= v38)
  {
    unint64_t v41 = (char *)a1[6];
    uint64_t v42 = (v39 - v41) >> 2;
    if ((unint64_t)(v42 + 1) >> 62) {
      goto LABEL_87;
    }
    unint64_t v43 = v38 - (void)v41;
    unint64_t v44 = (uint64_t)(v38 - (void)v41) >> 1;
    if (v44 <= v42 + 1) {
      unint64_t v44 = v42 + 1;
    }
    if (v43 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v45 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v45 = v44;
    }
    if (v45)
    {
      unint64_t v46 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 8), v45);
      unint64_t v41 = (char *)a1[6];
      int v39 = (char *)a1[7];
    }
    else
    {
      unint64_t v46 = 0;
    }
    int64_t v47 = &v46[4 * v42];
    unint64_t v48 = &v46[4 * v45];
    *(_DWORD *)int64_t v47 = *(_DWORD *)(v37 + 4 * v5);
    int v40 = v47 + 4;
    while (v39 != v41)
    {
      int v49 = *((_DWORD *)v39 - 1);
      v39 -= 4;
      *((_DWORD *)v47 - 1) = v49;
      v47 -= 4;
    }
    a1[6] = (uint64_t)v47;
    a1[7] = (uint64_t)v40;
    a1[8] = (uint64_t)v48;
    if (v41) {
      operator delete(v41);
    }
  }
  else
  {
    *(_DWORD *)int v39 = *(_DWORD *)(v37 + 4 * v5);
    int v40 = v39 + 4;
  }
  a1[7] = (uint64_t)v40;
  uint64_t v50 = a2[21];
  if (v5 >= (a2[22] - v50) >> 2) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  unint64_t v51 = a1[23];
  unint64_t v52 = (char *)a1[22];
  if ((unint64_t)v52 < v51)
  {
    *(_DWORD *)unint64_t v52 = *(_DWORD *)(v50 + 4 * v5);
    unint64_t v53 = v52 + 4;
    goto LABEL_78;
  }
  uint64_t v54 = (char *)a1[21];
  uint64_t v55 = (v52 - v54) >> 2;
  if ((unint64_t)(v55 + 1) >> 62) {
LABEL_87:
  }
    std::vector<float>::__throw_length_error[abi:ne180100]();
  unint64_t v56 = v51 - (void)v54;
  unint64_t v57 = (uint64_t)(v51 - (void)v54) >> 1;
  if (v57 <= v55 + 1) {
    unint64_t v57 = v55 + 1;
  }
  if (v56 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v58 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v58 = v57;
  }
  if (v58)
  {
    unint64_t v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 23), v58);
    uint64_t v54 = (char *)a1[21];
    unint64_t v52 = (char *)a1[22];
  }
  else
  {
    unint64_t v59 = 0;
  }
  uint64_t v60 = &v59[4 * v55];
  uint64_t v61 = &v59[4 * v58];
  *(_DWORD *)uint64_t v60 = *(_DWORD *)(v50 + 4 * v5);
  unint64_t v53 = v60 + 4;
  while (v52 != v54)
  {
    int v62 = *((_DWORD *)v52 - 1);
    v52 -= 4;
    *((_DWORD *)v60 - 1) = v62;
    v60 -= 4;
  }
  a1[21] = (uint64_t)v60;
  a1[22] = (uint64_t)v53;
  a1[23] = (uint64_t)v61;
  if (v54) {
    operator delete(v54);
  }
LABEL_78:
  a1[22] = (uint64_t)v53;
}

uint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::computeDay2DayNoise(uint64_t **a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (char *)a1[1] - (char *)*a1;
  if (v2) {
    BOOL v3 = v2 >= 0xC;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    unint64_t v7 = operator new(0xCuLL);
    uint64_t v37 = v7 + 3;
    unint64_t v38 = (char *)(v7 + 3);
    *(void *)unint64_t v7 = 0x3F800000BF000000;
    _OWORD v7[2] = -1090519040;
    uint64_t v36 = v7;
    uint64_t v8 = *v1;
    int v9 = *((_DWORD *)v1 + 2);
    unint64_t v10 = operator new(0xCuLL);
    int v11 = 0;
    LODWORD(v12) = 0;
    char v34 = (char *)(v10 + 3);
    unint64_t v35 = (char *)(v10 + 3);
    *(void *)unint64_t v10 = v8;
    id v10[2] = v9;
    float v13 = 0.0;
    unint64_t v14 = 2;
    __n128 __p = v10;
    do
    {
      float SmoothedPow_aSample = Nightingale::getSmoothedPow_aSample((float **)&__p, (uint64_t)&v36);
      BOOL v17 = Nightingale::check2Real_t_equal(v16, SmoothedPow_aSample, -1.0);
      if (v17) {
        float SmoothedPow_aSample = -0.0;
      }
      __int16 v18 = *a1;
      unint64_t v19 = ((char *)a1[1] - (char *)*a1) >> 2;
      if (v19 - 1 <= v14)
      {
        ++v14;
      }
      else
      {
        uint64_t v20 = (char *)__p;
        int64_t v21 = v34 - ((unsigned char *)__p + 4);
        if (v34 != (char *)__p + 4)
        {
          memmove(__p, (char *)__p + 4, v34 - ((unsigned char *)__p + 4));
          __int16 v18 = *a1;
          unint64_t v19 = ((char *)a1[1] - (char *)*a1) >> 2;
        }
        uint64_t v22 = &v20[v21];
        char v34 = &v20[v21];
        if (v19 <= ++v14) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        if (v22 >= v35)
        {
          uint64_t v24 = (char *)__p;
          uint64_t v25 = (v22 - (unsigned char *)__p) >> 2;
          unint64_t v26 = v25 + 1;
          if ((unint64_t)(v25 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v27 = v35 - (unsigned char *)__p;
          if ((v35 - (unsigned char *)__p) >> 1 > v26) {
            unint64_t v26 = v27 >> 1;
          }
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28)
          {
            unint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v35, v28);
            uint64_t v24 = (char *)__p;
            uint64_t v22 = v34;
          }
          else
          {
            unint64_t v29 = 0;
          }
          size_t v30 = &v29[4 * v25];
          *(_DWORD *)size_t v30 = *((_DWORD *)v18 + v14);
          unint64_t v23 = v30 + 4;
          while (v22 != v24)
          {
            int v31 = *((_DWORD *)v22 - 1);
            v22 -= 4;
            *((_DWORD *)v30 - 1) = v31;
            v30 -= 4;
          }
          __n128 __p = v30;
          char v34 = v23;
          unint64_t v35 = &v29[4 * v28];
          if (v24) {
            operator delete(v24);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v22 = *((_DWORD *)v18 + v14);
          unint64_t v23 = v22 + 4;
        }
        char v34 = v23;
        unint64_t v19 = ((char *)a1[1] - (char *)*a1) >> 2;
      }
      uint64_t v12 = (v12 + v17);
      float v13 = v13 + SmoothedPow_aSample;
      v11 += !v17;
    }
    while (v19 > v14);
    if (v11) {
      float v5 = v13 / (float)((float)v11 * 1.5);
    }
    else {
      float v5 = NAN;
    }
    if (__p)
    {
      char v34 = (char *)__p;
      operator delete(__p);
    }
    if (v36)
    {
      uint64_t v37 = v36;
      operator delete(v36);
    }
    uint64_t v4 = v12 << 32;
  }
  else
  {
    uint64_t v4 = 0;
    float v5 = NAN;
  }
  return v4 | LODWORD(v5);
}

void sub_257D3C6C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpDay2dayNoiseHigh(float a1, uint64_t a2, uint64_t a3)
{
  if (a1 < 0.0 || *(void *)a3 == *(void *)(a3 + 8))
  {
    BOOL v4 = 0;
    uint64_t v7 = 2143289344;
  }
  else
  {
    uint64_t v7 = Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::computeDay2DayNoise((uint64_t **)a3);
    BOOL v4 = *(float *)&v7 > a1 || ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2) - 2 == v7 >> 32;
  }
  return v4 | (v7 << 32);
}

unint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpSnrLow(float a1, uint64_t a2, const void **a3, unsigned int a4)
{
  float v4 = 0.0;
  if ((a4 & 0x80000000) != 0 || (uint64_t v6 = a4, v7 = *a3, a4 > (unint64_t)(((unsigned char *)a3[1] - (unsigned char *)v7) >> 2)))
  {
    BOOL v9 = 0;
  }
  else
  {
    uint64_t v20 = 0;
    int64_t v21 = 0;
    uint64_t v22 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v20, v7, (uint64_t)v7 + 4 * a4, a4);
    uint64_t v11 = (uint64_t)a3[1];
    uint64_t v12 = (char *)*a3 + 4 * v6;
    __int16 v18 = 0;
    uint64_t v19 = 0;
    __n128 __p = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v12, v11, (v11 - (uint64_t)v12) >> 2);
    Nightingale::pooledVar2Win((float **)&v20, (float **)&__p, -1);
    float v14 = v13;
    if (v13 >= 1.0e-12
      && (uint64_t MeanDiffOf2Windows = Nightingale::getMeanDiffOf2Windows((uint64_t)&v20, (float **)&__p, -1.0),
          (MeanDiffOf2Windows & 0xFF00000000) != 0))
    {
      float v4 = (float)(*(float *)&MeanDiffOf2Windows * *(float *)&MeanDiffOf2Windows) / v14;
      BOOL v9 = v4 < a1;
    }
    else
    {
      BOOL v9 = 1;
    }
    if (__p)
    {
      __int16 v18 = __p;
      operator delete(__p);
    }
    if (v20)
    {
      int64_t v21 = v20;
      operator delete(v20);
    }
  }
  return v9 | ((unint64_t)LODWORD(v4) << 32);
}

void sub_257D3C898(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpMissingCntHigh(float a1, uint64_t a2, uint64_t a3, int a4)
{
  if (*(void *)(a3 + 8) == *(void *)a3) {
    return 0xBF80000000000000;
  }
  *(float *)&unsigned int v6 = (float)(int)Nightingale::getMissingCnt((float **)a3);
  return ((float)(*(float *)&v6 / (float)a4) > a1) | ((unint64_t)v6 << 32);
}

unint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpEarlyWinMissingCntHigh(float a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if ((a4 & 0x80000000) != 0
    || (float v4 = *(const void **)a3, a4 > (unint64_t)((uint64_t)(*(void *)(a3 + 8) - (void)v4) >> 2)))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0xBF80000000000000;
  }
  else
  {
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v15, v4, (uint64_t)v4 + 4 * a4, a4);
    unint64_t v10 = v16;
    unint64_t v11 = (char *)v16 - (char *)v15;
    if (v16 == v15)
    {
      unint64_t v13 = 0xBF80000000000000;
    }
    else
    {
      *(float *)&unsigned int v12 = (float)(int)Nightingale::getMissingCnt(&v15);
      unint64_t v13 = ((float)(*(float *)&v12 / (float)(int)(v11 >> 2)) > a1) | ((unint64_t)v12 << 32);
      unint64_t v10 = v15;
    }
    unint64_t v8 = v13 & 0xFFFFFFFF00000000;
    if (v10)
    {
      unint64_t v16 = v10;
      operator delete(v10);
    }
    uint64_t v7 = v13 & 0xFFFFFF00;
    uint64_t v6 = v13;
  }
  return v8 | v6 | v7;
}

void sub_257D3CA08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpLaterWinMissingCntHigh(float a1, uint64_t a2, void *a3, unsigned int a4)
{
  if ((a4 & 0x80000000) != 0 || (v4 = a4, uint64_t v5 = a3[1], v4 > (v5 - *a3) >> 2))
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    unint64_t v8 = 0xBF80000000000000;
  }
  else
  {
    unint64_t v10 = (const void *)(*a3 + 4 * v4);
    unint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v16, v10, v5, (v5 - (uint64_t)v10) >> 2);
    unint64_t v11 = v17;
    unint64_t v12 = (char *)v17 - (char *)v16;
    if (v17 == v16)
    {
      unint64_t v14 = 0xBF80000000000000;
    }
    else
    {
      *(float *)&unsigned int v13 = (float)(int)Nightingale::getMissingCnt(&v16);
      unint64_t v14 = ((float)(*(float *)&v13 / (float)(int)(v12 >> 2)) > a1) | ((unint64_t)v13 << 32);
      unint64_t v11 = v16;
    }
    unint64_t v8 = v14 & 0xFFFFFFFF00000000;
    if (v11)
    {
      uint64_t v17 = v11;
      operator delete(v11);
    }
    uint64_t v7 = v14 & 0xFFFFFF00;
    uint64_t v6 = v14;
  }
  return v8 | v6 | v7;
}

void sub_257D3CAFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::wristTemperatureInputValidation::checkListOfConditions(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X3>, void *a5@<X4>, char a6@<W5>, void **a7@<X8>)
{
  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 != v8)
  {
    unint64_t v14 = 0;
    uint64_t v30 = (uint64_t)(a7 + 2);
    do
    {
      if (v14 >= (uint64_t)(a4[1] - *a4) >> 2) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (v14 >= (uint64_t)(a5[1] - *a5) >> 2) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      uint64_t v15 = std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::operator()(v7, a1, a3, *(_DWORD *)(*a4 + 4 * v14), *(float *)(*a5 + 4 * v14));
      uint64_t v16 = v15;
      uint64_t v18 = (uint64_t *)a7[1];
      unint64_t v17 = (unint64_t)a7[2];
      if ((unint64_t)v18 >= v17)
      {
        uint64_t v20 = ((char *)v18 - (unsigned char *)*a7) >> 3;
        if ((unint64_t)(v20 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v21 = v17 - (void)*a7;
        uint64_t v22 = v21 >> 2;
        if (v21 >> 2 <= (unint64_t)(v20 + 1)) {
          uint64_t v22 = v20 + 1;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v23) {
          uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(v30, v23);
        }
        else {
          uint64_t v24 = 0;
        }
        uint64_t v25 = (uint64_t *)&v24[8 * v20];
        *uint64_t v25 = v16;
        uint64_t v19 = v25 + 1;
        uint64_t v27 = (char *)*a7;
        unint64_t v26 = (char *)a7[1];
        if (v26 != *a7)
        {
          do
          {
            uint64_t v28 = *((void *)v26 - 1);
            v26 -= 8;
            *--uint64_t v25 = v28;
          }
          while (v26 != v27);
          unint64_t v26 = (char *)*a7;
        }
        *a7 = v25;
        a7[1] = v19;
        a7[2] = &v24[8 * v23];
        if (v26) {
          operator delete(v26);
        }
      }
      else
      {
        *uint64_t v18 = v15;
        uint64_t v19 = v18 + 1;
      }
      a7[1] = v19;
      char v29 = a6;
      if (!(_BYTE)v16) {
        char v29 = 0;
      }
      if (v29) {
        break;
      }
      ++v14;
      v7 += 32;
    }
    while (v7 != v8);
  }
}

void sub_257D3CCBC(_Unwind_Exception *exception_object)
{
  BOOL v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float a5)
{
  int v8 = a4;
  float v7 = a5;
  uint64_t v5 = *(void *)(a1 + 24);
  if (!v5) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, float *))(*(void *)v5 + 48))(v5, a2, a3, &v8, &v7);
}

void *std::vector<std::vector<float>>::__construct_one_at_end[abi:ne180100]<std::vector<float> const&>(uint64_t a1, uint64_t a2)
{
  BOOL v3 = *(void **)(a1 + 8);
  void *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  uint64_t result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v3, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  *(void *)(a1 + 8) = v3 + 3;
  return result;
}

void sub_257D3CD84(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  uint64_t v15 = v11;
  uint64_t v16 = &v10[24 * v9];
  *(void *)unint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_257D3CE90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<float>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_257D3CF0C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  unint64_t v9 = *(char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::string>::__vallocate[abi:ne180100]((void *)a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v20, a2, v13, v9);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, v13, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v21, a2, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    uint64_t v17 = *(void *)(a1 + 8);
    do
    {
      uint64_t v19 = *(void **)(v17 - 24);
      v17 -= 24;
      uint64_t v18 = v19;
      if (v19)
      {
        *(void *)(v16 - 16) = v18;
        operator delete(v18);
      }
      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_257D3D0A4(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_257D3D0AC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a4, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 2);
      }
      v5 += 24;
      a4 += 24;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

char *std::vector<std::optional<float>>::__assign_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  unint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](v7, v11);
    uint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    unint64_t v9 = v13;
LABEL_16:
    uint64_t v17 = a3 - (void)__src;
    if (v17)
    {
      size_t v18 = v17 - 3;
      uint64_t v19 = v9;
      char v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9 - 3);
    unint64_t v9 = (char *)*v12;
  }
  uint64_t v17 = a3 - (void)v16;
  if (v17)
  {
    size_t v18 = v17 - 3;
    uint64_t v19 = v9;
    char v20 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

void std::__throw_bad_function_call[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
}

void std::bad_function_call::~bad_function_call(std::bad_function_call *this)
{
  std::exception::~exception(this);
  JUMPOUT(0x25A2C1380);
}

Nightingale::ngt_HistoricalAnalyzer *Nightingale::ngt_HistoricalAnalyzer::ngt_HistoricalAnalyzer(Nightingale::ngt_HistoricalAnalyzer *this, Nightingale::ngt_Config *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *((void *)this + 19) = 0;
  *((void *)this + 18) = (char *)this + 152;
  *((void *)this + 20) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  Nightingale::ngt_Config::ngt_Config((Nightingale::ngt_HistoricalAnalyzer *)((char *)this + 168), a2);
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = 6;
    strcpy((char *)__p, "4.12.1");
    *(_DWORD *)buf = 136315138;
    uint64_t v8 = __p;
    _os_log_impl(&dword_257C1A000, log, OS_LOG_TYPE_DEFAULT, "\"HistoricalAnalyzer\": \"%s\",\n", buf, 0xCu);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  return this;
}

void sub_257D3D3D4(_Unwind_Exception *a1)
{
  Nightingale::ngt_Config::~ngt_Config(v3);
  std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy(v2, *(void **)(v1 + 152));
  uint64_t v5 = *(void **)(v1 + 120);
  if (v5)
  {
    *(void *)(v1 + 128) = v5;
    operator delete(v5);
  }
  std::pair<std::vector<float>,std::vector<float>>::~pair(v1 + 72);
  char v6 = *(void **)(v1 + 48);
  if (v6)
  {
    *(void *)(v1 + 56) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)(v1 + 24);
  if (v7)
  {
    *(void *)(v1 + 32) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void Nightingale::ngt_HistoricalAnalyzer::~ngt_HistoricalAnalyzer(void **this)
{
  Nightingale::ngt_Config::~ngt_Config(this + 21);
  std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy((uint64_t)(this + 18), this[19]);
  uint64_t v2 = this[15];
  if (v2)
  {
    this[16] = v2;
    operator delete(v2);
  }
  uint64_t v3 = this[12];
  if (v3)
  {
    this[13] = v3;
    operator delete(v3);
  }
  unint64_t v4 = this[9];
  if (v4)
  {
    this[10] = v4;
    operator delete(v4);
  }
  uint64_t v5 = this[6];
  if (v5)
  {
    this[7] = v5;
    operator delete(v5);
  }
  char v6 = this[3];
  if (v6)
  {
    this[4] = v6;
    operator delete(v6);
  }
  uint64_t v7 = *this;
  if (*this)
  {
    this[1] = v7;
    operator delete(v7);
  }
}

void Nightingale::ngt_HistoricalAnalyzer::appendDay(void **a1, long long *a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v2 - (unsigned char *)*a1) >> 2);
  if (v4 <= 0x2AC5)
  {
    unint64_t v9 = (unint64_t)a1[2];
    uint64_t v7 = (uint64_t)(a1 + 2);
    unint64_t v8 = v9;
    if ((unint64_t)v2 >= v9)
    {
      unint64_t v14 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v8 - (void)v3) >> 2);
      if (2 * v14 <= v4 + 1) {
        uint64_t v15 = v4 + 1;
      }
      else {
        uint64_t v15 = 2 * v14;
      }
      if (v14 >= 0x222222222222222) {
        unint64_t v16 = 0x444444444444444;
      }
      else {
        unint64_t v16 = v15;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_DayInput>>(v7, v16);
      size_t v18 = &v17[60 * v4];
      char v20 = &v17[60 * v19];
      long long v21 = *a2;
      long long v22 = a2[1];
      long long v23 = a2[2];
      *(_OWORD *)(v18 + 44) = *(long long *)((char *)a2 + 44);
      *((_OWORD *)v18 + 1) = v22;
      *((_OWORD *)v18 + 2) = v23;
      *(_OWORD *)size_t v18 = v21;
      uint64_t v13 = v18 + 60;
      uint64_t v25 = (char *)*a1;
      uint64_t v24 = (char *)a1[1];
      if (v24 != *a1)
      {
        do
        {
          long long v26 = *(_OWORD *)(v24 - 60);
          long long v27 = *(_OWORD *)(v24 - 44);
          long long v28 = *(_OWORD *)(v24 - 28);
          *((_OWORD *)v18 - 1) = *((_OWORD *)v24 - 1);
          *(_OWORD *)(v18 - 28) = v28;
          *(_OWORD *)(v18 - 44) = v27;
          *(_OWORD *)(v18 - 60) = v26;
          v18 -= 60;
          v24 -= 60;
        }
        while (v24 != v25);
        uint64_t v24 = (char *)*a1;
      }
      *a1 = v18;
      a1[1] = v13;
      a1[2] = v20;
      if (v24) {
        operator delete(v24);
      }
    }
    else
    {
      long long v10 = *a2;
      long long v11 = a2[1];
      long long v12 = a2[2];
      *(_OWORD *)((char *)v2 + 44) = *(long long *)((char *)a2 + 44);
      v2[1] = v11;
      v2[2] = v12;
      *uint64_t v2 = v10;
      uint64_t v13 = (char *)v2 + 60;
    }
    a1[1] = v13;
  }
}

void Nightingale::ngt_HistoricalAnalyzer::appendPhaseSet(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a1[3];
  char v6 = (_DWORD *)a1[4];
  uint64_t v5 = (uint64_t)(a1 + 3);
  uint64_t v7 = (uint64_t)v6 - v4;
  if ((unint64_t)v6 - v4 <= 0xAB17)
  {
    uint64_t v10 = (uint64_t)(a1 + 5);
    unint64_t v11 = a1[5];
    if ((unint64_t)v6 >= v11)
    {
      uint64_t v13 = v7 >> 2;
      uint64_t v14 = v11 - v4;
      if (v14 >> 1 <= (unint64_t)((v7 >> 2) + 1)) {
        uint64_t v15 = v13 + 1;
      }
      else {
        uint64_t v15 = v14 >> 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v10, v16);
      size_t v18 = (char *)a1[3];
      uint64_t v19 = (char *)a1[4];
      char v20 = &v17[4 * v13];
      long long v22 = &v17[4 * v21];
      *(_DWORD *)char v20 = a3;
      long long v12 = v20 + 4;
      while (v19 != v18)
      {
        int v23 = *((_DWORD *)v19 - 1);
        v19 -= 4;
        *((_DWORD *)v20 - 1) = v23;
        v20 -= 4;
      }
      a1[3] = v20;
      a1[4] = v12;
      a1[5] = v22;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      _DWORD *v6 = a3;
      long long v12 = v6 + 1;
    }
    unint64_t v24 = a1[8];
    a1[4] = v12;
    uint64_t v25 = (void *)a1[7];
    if ((unint64_t)v25 >= v24)
    {
      uint64_t v27 = a1[6];
      uint64_t v28 = ((uint64_t)v25 - v27) >> 3;
      if ((unint64_t)(v28 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v29 = v24 - v27;
      uint64_t v30 = v29 >> 2;
      if (v29 >> 2 <= (unint64_t)(v28 + 1)) {
        uint64_t v30 = v28 + 1;
      }
      if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v31 = v30;
      }
      if (v31) {
        unint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)(a1 + 8), v31);
      }
      else {
        unint64_t v32 = 0;
      }
      int v33 = &v32[8 * v28];
      char v34 = &v32[8 * v31];
      *(void *)int v33 = a2;
      long long v26 = v33 + 8;
      uint64_t v36 = (char *)a1[6];
      unint64_t v35 = (char *)a1[7];
      if (v35 != v36)
      {
        do
        {
          uint64_t v37 = *((void *)v35 - 1);
          v35 -= 8;
          *((void *)v33 - 1) = v37;
          v33 -= 8;
        }
        while (v35 != v36);
        unint64_t v35 = (char *)a1[6];
      }
      a1[6] = v33;
      a1[7] = v26;
      a1[8] = v34;
      if (v35) {
        operator delete(v35);
      }
    }
    else
    {
      *uint64_t v25 = a2;
      long long v26 = v25 + 1;
    }
    a1[7] = v26;
  }
  std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100]<std::vector<int>&,std::vector<Nightingale::PhaseSet>&,0>(__p, v5, (uint64_t)(a1 + 6));
  unint64_t v38 = (void *)a1[9];
  if (v38)
  {
    a1[10] = v38;
    operator delete(v38);
  }
  *(_OWORD *)(a1 + 9) = *(_OWORD *)__p;
  a1[11] = v41;
  __p[1] = 0;
  uint64_t v41 = 0;
  __p[0] = 0;
  int v39 = (void *)a1[12];
  if (v39)
  {
    a1[13] = v39;
    operator delete(v39);
    int v39 = __p[0];
  }
  *((_OWORD *)a1 + 6) = v42;
  a1[14] = v43;
  uint64_t v43 = 0;
  long long v42 = 0uLL;
  if (v39)
  {
    __p[1] = v39;
    operator delete(v39);
  }
}

void Nightingale::ngt_HistoricalAnalyzer::constructePseudo1stCycle(int a1@<W1>, int a2@<W2>, uint64_t a3@<X3>, char a4@<W4>, void *a5@<X5>, uint64_t a6@<X8>)
{
  *(unsigned char *)(a6 + 4) = 0;
  *(unsigned char *)(a6 + 8) = 0;
  *(unsigned char *)(a6 + 12) = 0;
  *(unsigned char *)(a6 + 16) = 0;
  *(unsigned char *)(a6 + 20) = 0;
  *(unsigned char *)(a6 + 24) = 0;
  *(unsigned char *)(a6 + 32) = 0;
  *(unsigned char *)(a6 + 36) = 0;
  *(unsigned char *)(a6 + 40) = 0;
  *(unsigned char *)(a6 + 44) = 0;
  *(unsigned char *)(a6 + 48) = 0;
  *(unsigned char *)(a6 + 52) = 0;
  *(unsigned char *)(a6 + 56) = 0;
  *(unsigned char *)(a6 + 60) = 0;
  *(unsigned char *)(a6 + 64) = 0;
  *(unsigned char *)(a6 + 68) = 0;
  *(void *)(a6 + 80) = 0;
  *(void *)(a6 + 88) = 0;
  *(void *)(a6 + 72) = 0;
  if (a2 < 0)
  {
    if (!a4) {
      goto LABEL_6;
    }
    if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(a5[1] - *a5) >> 2) <= a3 >> 32) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    int v6 = *(_DWORD *)(*a5 + 60 * SHIDWORD(a3));
    if (a1 - v6 <= 18) {
LABEL_6:
    }
      int v6 = a1 - 28;
  }
  else
  {
    *(_DWORD *)(a6 + 12) = a2;
    *(unsigned char *)(a6 + 16) = 1;
    int v6 = a2 - 4;
  }
  *(_DWORD *)a6 = v6;
  *(_DWORD *)(a6 + 20) = a1 - 1;
  *(unsigned char *)(a6 + 24) = 1;
}

uint64_t **Nightingale::ngt_HistoricalAnalyzer::begin_phase(uint64_t a1, unsigned int a2, int a3)
{
  return Nightingale::PhaseCondenser::begin_phase((uint64_t **)(a1 + 144), a2, a3);
}

uint64_t **Nightingale::ngt_HistoricalAnalyzer::end_phase(uint64_t a1, unsigned int a2, int a3)
{
  return Nightingale::PhaseCondenser::end_phase((uint64_t **)(a1 + 144), a2, a3);
}

void Nightingale::ngt_HistoricalAnalyzer::analyze(Nightingale::ngt_HistoricalAnalyzer *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  Nightingale::uiLogProcessor::uiLogProcessor((Nightingale::uiLogProcessor *)v102);
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v101);
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v100);
  Nightingale::fwHEstimation::fwHEstimation((Nightingale::fwHEstimation *)&v99);
  uint64_t v97 = 0;
  unint64_t v96 = 0;
  uint64_t v98 = 0;
  *(unsigned char *)(a3 + 216) = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 24) = 0;
  Nightingale::PhaseCondenser::phase_updates((Nightingale::ngt_HistoricalAnalyzer *)((char *)this + 144), (uint64_t)__p);
  uint64_t v5 = *(void *)__p;
  uint64_t v6 = *(void *)&__p[8];
  if (*(void *)__p != *(void *)&__p[8])
  {
    do
    {
      Nightingale::ngt_HistoricalAnalyzer::appendPhaseSet(this, *(void *)v5, *(_DWORD *)(v5 + 8));
      v5 += 16;
    }
    while (v5 != v6);
    uint64_t v5 = *(void *)__p;
  }
  if (v5)
  {
    *(void *)&__p[8] = v5;
    operator delete((void *)v5);
  }
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_HistoricalAnalyzer::analyze();
  }
  float v68 = (uint64_t *)((char *)this + 72);
  Nightingale::uiLogProcessor::hist_process((uint64_t)this, (uint64_t *)this + 9, (uint64_t)&v94);
  if (v94 == v95)
  {
    unint64_t v31 = ha_get_log();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
  }
  else
  {
    uint64_t JDayIdx1stTmp = Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp((uint64_t)v100, (unsigned int **)this);
    int v9 = v8;
    int jDayLastOPKPosBfr1stPeriodSt = Nightingale::uiLogProcessor::get_jDayLastOPKPosBfr1stPeriodSt((uint64_t)v102, *v94, this);
    int v66 = v9;
    Nightingale::ngt_HistoricalAnalyzer::constructePseudo1stCycle(*v94, jDayLastOPKPosBfr1stPeriodSt, JDayIdx1stTmp, v9, this, (uint64_t)v91);
    std::vector<Nightingale::cycleInfo>::insert((uint64_t *)&v94, (uint64_t)v94, (unint64_t)v91);
    v83[0] = 0;
    v83[4] = 0;
    v83[8] = 0;
    v83[12] = 0;
    *(_DWORD *)&v83[16] = 3;
    v84[0] = 0;
    *(void *)&v83[20] = 0;
    *(_WORD *)&v83[28] = 0;
    *(int32x4_t *)&v84[4] = vdupq_n_s32(0x7FC00000u);
    v84[20] = 0;
    v84[24] = 0;
    v84[28] = 0;
    char v85 = 0;
    LOBYTE(v86[0]) = 0;
    char v87 = 0;
    LOBYTE(v88[0]) = 0;
    char v89 = 0;
    v90[0] = 0;
    v90[4] = 0;
    *(void *)&v90[8] = 0x17FC00000;
    *(_DWORD *)&v90[16] = 0;
    *(_WORD *)&v90[20] = 0;
    memset(v82, 0, sizeof(v82));
    unint64_t v11 = ha_get_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__n128 __p = 0;
      _os_log_impl(&dword_257C1A000, v11, OS_LOG_TYPE_DEFAULT, "\"Cycles\":[ \n", __p, 2u);
    }
    long long v12 = v94;
    BOOL v65 = v95;
    if (v94 != v95)
    {
      uint64_t v13 = 0;
      do
      {
        LOBYTE(v73) = 0;
        BYTE4(v73) = 0;
        BYTE8(v73) = 0;
        BYTE12(v73) = 0;
        int v78 = 0;
        uint64_t v79 = 0;
        unint64_t v77 = 0;
        LODWORD(v80) = 3;
        uint64_t v14 = ha_get_log();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = *v12;
          *(_DWORD *)__n128 __p = 67109376;
          *(_DWORD *)&__p[4] = v13;
          *(_WORD *)&__p[8] = 1024;
          *(_DWORD *)&__p[10] = v15;
          _os_log_impl(&dword_257C1A000, v14, OS_LOG_TYPE_DEFAULT, "\t{\"idx\": %d, \"jDayCycleStart\": %d ", __p, 0xEu);
        }
        std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100](v70, (uint64_t)v68);
        Nightingale::fwHEstimation::processPerCycle((uint64_t)v12, this, JDayIdx1stTmp, v66, (uint64_t *)v70, v100, a2, (uint64_t)__p, (Nightingale::ngt_HistoricalAnalyzer *)((char *)this + 168));
        *(_OWORD *)int v83 = *(_OWORD *)__p;
        *(_OWORD *)&v83[14] = *(_OWORD *)&__p[14];
        *(_OWORD *)char v84 = v104;
        *(_OWORD *)&v84[16] = v105;
        char v85 = v106;
        std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<float>,false>>((uint64_t)v86, (__n128 *)((char *)&v106 + 8));
        std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<float>,false>>((uint64_t)v88, (__n128 *)&v108[1]);
        *(_OWORD *)uint64_t v90 = *(_OWORD *)&v110[8];
        *(void *)&v90[14] = *(void *)&v110[22];
        if (v110[0] && v108[1])
        {
          *(void **)&long long v109 = v108[1];
          operator delete(v108[1]);
        }
        if (LOBYTE(v108[0]) && *((void *)&v106 + 1))
        {
          *(void *)&long long v107 = *((void *)&v106 + 1);
          operator delete(*((void **)&v106 + 1));
        }
        if (v71)
        {
          unint64_t v72 = v71;
          operator delete(v71);
        }
        if (v70[0])
        {
          v70[1] = v70[0];
          operator delete(v70[0]);
        }
        if (a2) {
          std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::push_back[abi:ne180100]((uint64_t *)v82, (long long *)v84);
        }
        if (v13)
        {
          LODWORD(v73) = *(_DWORD *)v83;
          BYTE4(v73) = v83[4];
          DWORD2(v73) = *(_DWORD *)&v83[8];
          BYTE12(v73) = v83[12];
          char v76 = *((unsigned char *)v12 + 28);
          int v74 = *v12;
          uint64_t v80 = *(void *)&v83[16];
          int v81 = *(_DWORD *)&v83[24];
          if (v12 + 18 != (int *)&v77) {
            std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v77, *((char **)v12 + 9), *((char **)v12 + 10), *((void *)v12 + 10) - *((void *)v12 + 9));
          }
          if (*((unsigned char *)v12 + 8))
          {
            int v75 = v12[1];
            unint64_t v16 = *(void *)(a3 + 8);
            if (v16 >= *(void *)(a3 + 16))
            {
              uint64_t v17 = std::vector<Nightingale::ngt_HistoricCycle>::__push_back_slow_path<Nightingale::ngt_HistoricCycle const&>((uint64_t *)a3, &v73);
            }
            else
            {
              std::vector<Nightingale::ngt_HistoricCycle>::__construct_one_at_end[abi:ne180100]<Nightingale::ngt_HistoricCycle const&>(a3, &v73);
              uint64_t v17 = v16 + 72;
            }
            *(void *)(a3 + 8) = v17;
          }
        }
        if (0xAAAAAAAAAAAAAAABLL * (((char *)v95 - (char *)v94) >> 5) <= v13 + 1)
        {
          uint64_t v21 = ha_get_log();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__n128 __p = 0;
            uint64_t v19 = v21;
            char v20 = "\t} \n ";
            goto LABEL_40;
          }
        }
        else
        {
          size_t v18 = ha_get_log();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__n128 __p = 0;
            uint64_t v19 = v18;
            char v20 = "\t}, \n ";
LABEL_40:
            _os_log_impl(&dword_257C1A000, v19, OS_LOG_TYPE_DEFAULT, v20, __p, 2u);
          }
        }
        if (v77)
        {
          int v78 = v77;
          operator delete(v77);
        }
        v12 += 24;
        ++v13;
      }
      while (v12 != v65);
    }
    long long v22 = ha_get_log();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__n128 __p = 0;
      _os_log_impl(&dword_257C1A000, v22, OS_LOG_TYPE_DEFAULT, "], \n", __p, 2u);
    }
    Nightingale::phaseFactorHist::tagHistReproductive((uint64_t)&v96, (void *)a3, v68);
    int v23 = ha_get_log();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
    uint64_t v24 = *(void *)(a3 + 8);
    if (*(void *)a3 == v24)
    {
      unint64_t v32 = ha_get_log();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
        Nightingale::uiLogProcessor::genCycleSlide();
      }
    }
    else
    {
      if (v24 - *(void *)a3 != 72)
      {
        uint64_t v25 = 0;
        unint64_t v26 = 0;
        do
        {
          uint64_t v27 = ha_get_log();
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
          {
            if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) <= v26) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v28 = *(void *)a3 + v25;
            if (*(unsigned char *)(v28 + 4)) {
              int v29 = *(_DWORD *)v28;
            }
            else {
              int v29 = -1;
            }
            *(_DWORD *)__n128 __p = 67109120;
            *(_DWORD *)&__p[4] = v29;
            _os_log_debug_impl(&dword_257C1A000, v27, OS_LOG_TYPE_DEBUG, "%d, ", __p, 8u);
          }
          ++v26;
          v25 += 72;
        }
        while (-1 - 0x71C71C71C71C71C7 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) > v26);
      }
      uint64_t v30 = ha_get_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    int v33 = ha_get_log();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
    uint64_t v34 = *(void *)(a3 + 8);
    if (*(void *)a3 == v34)
    {
      uint64_t v41 = ha_get_log();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    else
    {
      if (v34 - *(void *)a3 != 72)
      {
        uint64_t v35 = 0;
        unint64_t v36 = 0;
        do
        {
          uint64_t v37 = ha_get_log();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          {
            if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) <= v36) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            uint64_t v38 = *(void *)a3 + v35;
            if (*(unsigned char *)(v38 + 12)) {
              int v39 = *(_DWORD *)(v38 + 8);
            }
            else {
              int v39 = -1;
            }
            *(_DWORD *)__n128 __p = 67109120;
            *(_DWORD *)&__p[4] = v39;
            _os_log_debug_impl(&dword_257C1A000, v37, OS_LOG_TYPE_DEBUG, "%d, ", __p, 8u);
          }
          ++v36;
          v35 += 72;
        }
        while (-1 - 0x71C71C71C71C71C7 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) > v36);
      }
      int v40 = ha_get_log();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    long long v42 = ha_get_log();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
    uint64_t v43 = *(void *)(a3 + 8);
    if (*(void *)a3 == v43)
    {
      int v49 = ha_get_log();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    else
    {
      if (v43 - *(void *)a3 != 72)
      {
        unint64_t v44 = 0;
        uint64_t v45 = 56;
        do
        {
          unint64_t v46 = ha_get_log();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) <= v44) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            int v47 = *(_DWORD *)(*(void *)a3 + v45);
            *(_DWORD *)__n128 __p = 67109120;
            *(_DWORD *)&__p[4] = v47;
            _os_log_debug_impl(&dword_257C1A000, v46, OS_LOG_TYPE_DEBUG, "%d, ", __p, 8u);
          }
          ++v44;
          v45 += 72;
        }
        while (-1 - 0x71C71C71C71C71C7 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) > v44);
      }
      unint64_t v48 = ha_get_log();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    uint64_t v50 = ha_get_log();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
    uint64_t v51 = *(void *)(a3 + 8);
    if (*(void *)a3 == v51)
    {
      unint64_t v57 = ha_get_log();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    else
    {
      if (v51 - *(void *)a3 != 72)
      {
        unint64_t v52 = 0;
        uint64_t v53 = 60;
        do
        {
          uint64_t v54 = ha_get_log();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            if (0x8E38E38E38E38E39 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) <= v52) {
              std::vector<int>::__throw_out_of_range[abi:ne180100]();
            }
            int v55 = *(_DWORD *)(*(void *)a3 + v53);
            *(_DWORD *)__n128 __p = 67109120;
            *(_DWORD *)&__p[4] = v55;
            _os_log_debug_impl(&dword_257C1A000, v54, OS_LOG_TYPE_DEBUG, "%d, ", __p, 8u);
          }
          ++v52;
          v53 += 72;
        }
        while (-1 - 0x71C71C71C71C71C7 * ((uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3) > v52);
      }
      unint64_t v56 = ha_get_log();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_HistoricalAnalyzer::analyze();
      }
    }
    unint64_t v58 = ha_get_log();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_HistoricalAnalyzer::analyze();
    }
    if (a2)
    {
      Nightingale::ngt_HistoricalAnalyzer::getCoreAnalyticsContent(this, (uint64_t *)&v94, JDayIdx1stTmp, v66, v82, (uint64_t)__p);
      long long v59 = *(_OWORD *)v110;
      *(_OWORD *)(a3 + 168) = *(_OWORD *)&v110[16];
      long long v60 = v112;
      *(_OWORD *)(a3 + 184) = v111;
      *(_OWORD *)(a3 + 200) = v60;
      long long v61 = v106;
      *(_OWORD *)(a3 + 104) = v107;
      long long v62 = v109;
      *(_OWORD *)(a3 + 120) = *(_OWORD *)v108;
      *(_OWORD *)(a3 + 136) = v62;
      *(_OWORD *)(a3 + 152) = v59;
      long long v63 = *(_OWORD *)__p;
      *(_OWORD *)(a3 + 40) = *(_OWORD *)&__p[16];
      long long v64 = v105;
      *(_OWORD *)(a3 + 56) = v104;
      *(_OWORD *)(a3 + 72) = v64;
      *(_OWORD *)(a3 + 88) = v61;
      *(unsigned char *)(a3 + 216) = v113;
      *(_OWORD *)(a3 + 24) = v63;
    }
    *(void *)__n128 __p = v82;
    std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
    if (v89 && v88[0])
    {
      v88[1] = v88[0];
      operator delete(v88[0]);
    }
    if (v87 && v86[0])
    {
      v86[1] = v86[0];
      operator delete(v86[0]);
    }
    if (v92)
    {
      uint64_t v93 = v92;
      operator delete(v92);
    }
  }
  *(void *)__n128 __p = &v94;
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v96)
  {
    uint64_t v97 = v96;
    operator delete(v96);
  }
  Nightingale::fwHEstimation::~fwHEstimation((Nightingale::fwHEstimation *)&v99);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v100);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&v101);
  Nightingale::uiLogProcessor::~uiLogProcessor((Nightingale::uiLogProcessor *)v102);
}

void sub_257D3E534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45)
{
  STACK[0x3E0] = (unint64_t)&a42;
  std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3E0]);
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle((Nightingale::fwEstimatorHistOutACycle *)&a45);
  unint64_t v46 = (void *)STACK[0x210];
  if (STACK[0x210])
  {
    STACK[0x218] = (unint64_t)v46;
    operator delete(v46);
  }
  STACK[0x3E0] = (unint64_t)&STACK[0x228];
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x3E0]);
  std::vector<Nightingale::ngt_HistoricCycle>::__destroy_vector::operator()[abi:ne180100]((void ***)&a45);
  int v47 = (void *)STACK[0x2B0];
  if (STACK[0x2B0])
  {
    STACK[0x2B8] = (unint64_t)v47;
    operator delete(v47);
  }
  Nightingale::fwHEstimation::~fwHEstimation((Nightingale::fwHEstimation *)&STACK[0x2CF]);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)&STACK[0x2D0]);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)&STACK[0x31F]);
  Nightingale::uiLogProcessor::~uiLogProcessor((Nightingale::uiLogProcessor *)&STACK[0x320]);
  _Unwind_Resume(a1);
}

void *Nightingale::phaseFactorHist::phaseFactorHist(void *this)
{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

{
  *this = 0;
  this[1] = 0;
  this[2] = 0;
  return this;
}

unint64_t std::vector<Nightingale::cycleInfo>::insert(uint64_t *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v4 = a2;
  uint64_t v7 = *a1;
  unint64_t v6 = a1[1];
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a2 - *a1) >> 5);
  unint64_t v11 = a1[2];
  uint64_t v9 = (uint64_t)(a1 + 2);
  unint64_t v10 = v11;
  if (v6 >= v11)
  {
    unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - v7) >> 5) + 1;
    if (v15 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - v7) >> 5);
    if (2 * v16 > v15) {
      unint64_t v15 = 2 * v16;
    }
    if (v16 >= 0x155555555555555) {
      unint64_t v17 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v17 = v15;
    }
    uint64_t v24 = v9;
    if (v17) {
      size_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(v9, v17);
    }
    else {
      size_t v18 = 0;
    }
    char v20 = v18;
    uint64_t v21 = &v18[96 * v8];
    long long v22 = v21;
    int v23 = &v18[96 * v17];
    std::__split_buffer<Nightingale::cycleInfo>::push_back[abi:ne180100](&v20, a3);
    unint64_t v4 = std::vector<Nightingale::cycleInfo>::__swap_out_circular_buffer(a1, &v20, v4);
    std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer((uint64_t)&v20);
  }
  else if (a2 == v6)
  {
    std::vector<Nightingale::cycleInfo>::__construct_one_at_end[abi:ne180100]<Nightingale::cycleInfo const&>((uint64_t)a1, a3);
  }
  else
  {
    std::vector<Nightingale::cycleInfo>::__move_range((uint64_t)a1, a2, v6, a2 + 96);
    if (v4 <= a3) {
      a3 += 96 * (a1[1] > a3);
    }
    *(_OWORD *)unint64_t v4 = *(_OWORD *)a3;
    long long v12 = *(_OWORD *)(a3 + 16);
    long long v13 = *(_OWORD *)(a3 + 32);
    long long v14 = *(_OWORD *)(a3 + 48);
    *(void *)(v4 + 61) = *(void *)(a3 + 61);
    *(_OWORD *)(v4 + 32) = v13;
    *(_OWORD *)(v4 + 48) = v14;
    *(_OWORD *)(v4 + 16) = v12;
    if (v4 != a3) {
      std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)(v7 + 96 * v8 + 72), *(char **)(a3 + 72), *(char **)(a3 + 80), *(void *)(a3 + 80) - *(void *)(a3 + 72));
    }
  }
  return v4;
}

void sub_257D3E868(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::push_back[abi:ne180100](uint64_t *a1, long long *a2)
{
  unint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  unint64_t v7 = *(void *)(v4 - 8);
  if (v7 >= v6)
  {
    uint64_t v10 = (uint64_t)(v7 - *a1) >> 7;
    if ((unint64_t)(v10 + 1) >> 57) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v5 - *a1;
    uint64_t v12 = v11 >> 6;
    if (v11 >> 6 <= (unint64_t)(v10 + 1)) {
      uint64_t v12 = v10 + 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFF80) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    uint64_t v19 = v4;
    if (v13) {
      long long v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::coreAnalyticsHistPerCycle_t>>(v4, v13);
    }
    else {
      long long v14 = 0;
    }
    unint64_t v15 = v14;
    unint64_t v16 = &v14[128 * v10];
    size_t v18 = &v14[128 * v13];
    std::construct_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t const&,Nightingale::coreAnalyticsHistPerCycle_t*>((uint64_t)v16, a2);
    unint64_t v17 = v16 + 128;
    std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::__swap_out_circular_buffer(a1, &v15);
    uint64_t v9 = a1[1];
    uint64_t result = std::__split_buffer<Nightingale::coreAnalyticsHistPerCycle_t>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t result = std::construct_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t const&,Nightingale::coreAnalyticsHistPerCycle_t*>(*(void *)(v4 - 8), a2);
    uint64_t v9 = v7 + 128;
    a1[1] = v7 + 128;
  }
  a1[1] = v9;
  return result;
}

void sub_257D3E970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  *(void *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void Nightingale::phaseFactorHist::tagHistReproductive(uint64_t a1, void *a2, uint64_t *a3)
{
  if (*a3 != a3[1])
  {
    __n128 __p = 0;
    size_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v4 = a2[1];
    unint64_t v5 = 0x8E38E38E38E38E39 * ((v4 - *a2) >> 3);
    if ((int)v5 >= 1)
    {
      if (v5 != 1)
      {
        uint64_t v8 = 0;
        unint64_t v9 = 0;
        uint64_t v10 = (v5 - 1);
        do
        {
          unint64_t v11 = 0x8E38E38E38E38E39 * ((uint64_t)(a2[1] - *a2) >> 3);
          if (v11 <= v9) {
            goto LABEL_17;
          }
          unint64_t v12 = v9 + 1;
          if (v11 <= v9 + 1) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          Nightingale::phaseFactorProcessor::tagPhaseJDayRange(a1, *(unsigned int *)(*a2 + v8 + 16) | ((unint64_t)(*(_DWORD *)(*a2 + v8 + 88) - 1) << 32), a3, (unint64_t *)&__p);
          unint64_t v13 = v12 - 1;
          if (0x8E38E38E38E38E39 * ((uint64_t)(a2[1] - *a2) >> 3) <= v13) {
LABEL_17:
          }
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          long long v14 = (void **)(*a2 + v8 + 32);
          if (v14 != &__p) {
            std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v14, (char *)__p, v18, v18 - (unsigned char *)__p);
          }
          v8 += 72;
          unint64_t v9 = v13 + 1;
        }
        while (v13 + 1 != v10);
        uint64_t v4 = a2[1];
      }
      Nightingale::phaseFactorProcessor::tagPhaseJDayRange(a1, *(unsigned int *)(v4 - 56) | 0xFFFFFFFF00000000, a3, (unint64_t *)&__p);
      unint64_t v15 = (void **)(a2[1] - 40);
      unint64_t v16 = (char *)__p;
      if (v15 != &__p)
      {
        std::vector<Nightingale::Phase>::__assign_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(v15, (char *)__p, v18, v18 - (unsigned char *)__p);
        unint64_t v16 = (char *)__p;
      }
      if (v16)
      {
        size_t v18 = v16;
        operator delete(v16);
      }
    }
  }
}

void sub_257D3EB34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngt_HistoricalAnalyzer::getCoreAnalyticsContent(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, long long **a5@<X4>, uint64_t a6@<X8>)
{
  *(unsigned char *)a6 = 0;
  *(unsigned char *)(a6 + 192) = 0;
  unint64_t v12 = a5[1];
  if (*a5 == v12 || (uint64_t v14 = *a2, v13 = a2[1], *a2 == v13))
  {
    if ((unint64_t)((char *)v12 - (char *)*a5) < 0x100) {
      return;
    }
    uint64_t v14 = *a2;
    uint64_t v13 = a2[1];
    if (0xAAAAAAAAAAAAAAABLL * ((v13 - *a2) >> 5) < 2) {
      return;
    }
  }
  std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,Nightingale::cycleInfo *,Nightingale::cycleInfo *,Nightingale::cycleInfo *,0>(v14 + 96, v13, v14);
  uint64_t v16 = v15;
  uint64_t v17 = a2[1];
  if (v17 != v15)
  {
    do
    {
      size_t v18 = *(void **)(v17 - 24);
      if (v18)
      {
        *(void *)(v17 - 16) = v18;
        operator delete(v18);
      }
      v17 -= 96;
    }
    while (v17 != v16);
  }
  a2[1] = v16;
  std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t *,Nightingale::coreAnalyticsHistPerCycle_t *,Nightingale::coreAnalyticsHistPerCycle_t *>((uint64_t)&v353, *a5 + 8, a5[1], (uint64_t)*a5);
  char v20 = v19;
  uint64_t v21 = (uint64_t)a5[1];
  if ((long long *)v21 != v19)
  {
    do
    {
      v21 -= 128;
      std::__destroy_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,0>(v21);
    }
    while ((long long *)v21 != v20);
  }
  a5[1] = v20;
  uint64_t v22 = *a2;
  uint64_t v23 = a2[1];
  uint64_t v302 = *a2;
  if (*a2 == v23)
  {
    int v25 = 0;
    int v24 = 0;
  }
  else
  {
    int v24 = 0;
    int v25 = 0;
    do
    {
      if (*(unsigned char *)(v22 + 8) && *(_DWORD *)v22 == *(_DWORD *)(v22 + 4)) {
        ++v24;
      }
      v25 += *(unsigned __int8 *)(v22 + 16);
      v22 += 96;
    }
    while (v22 != v23);
  }
  int v301 = v24;
  unint64_t v26 = *(void **)(v23 - 24);
  uint64_t v304 = a2[1];
  if (v26)
  {
    *(void *)(v23 - 16) = v26;
    operator delete(v26);
    uint64_t v23 = v304;
    char v20 = a5[1];
  }
  a2[1] = v23 - 96;
  std::__destroy_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,0>((uint64_t)(v20 - 8));
  a5[1] = v20 - 8;
  char HasMultipleWatchHist = Nightingale::ngt_HistoricalAnalyzer::getHasMultipleWatchHist(a1, 60, a3, a4);
  v353 = 0;
  unint64_t v354 = 0;
  uint64_t v355 = 0;
  v350 = 0;
  unint64_t v351 = 0;
  uint64_t v352 = 0;
  v347 = 0;
  v348 = 0;
  v349 = 0;
  v344 = 0;
  v345 = 0;
  v346 = 0;
  v341 = 0;
  v342 = 0;
  v343 = 0;
  v338 = 0;
  v339 = 0;
  v340 = 0;
  __n128 __p = 0;
  v336 = 0;
  v337 = 0;
  v332 = 0;
  v333 = 0;
  v334 = 0;
  v329 = 0;
  v330 = 0;
  v331 = 0;
  v326 = 0;
  v327 = 0;
  v328 = 0;
  v323 = 0;
  v324 = 0;
  v325 = 0;
  v320 = 0;
  __dst = 0;
  uint64_t v322 = 0;
  v317 = 0;
  v318 = 0;
  uint64_t v28 = (unsigned __int8 *)*a5;
  uint64_t v27 = (unsigned __int8 *)a5[1];
  unint64_t v29 = (unint64_t)(v27 - (unsigned __int8 *)*a5) >> 7;
  uint64_t v319 = 0;
  if ((int)v29 <= 12) {
    int v30 = 12;
  }
  else {
    int v30 = v29;
  }
  if ((int)v29 <= 15) {
    LODWORD(v29) = 15;
  }
  v314 = 0;
  v315 = 0;
  v316 = 0;
  if (v27 == v28)
  {
    unint64_t v138 = 0;
    v139 = 0;
  }
  else
  {
    unsigned int v31 = 0;
    unsigned int v32 = v30 - 12;
    unsigned int v33 = v29 - 15;
    do
    {
      if (*v28)
      {
        v358[0] = *((float *)v28 + 1) != 0.0;
        std::vector<BOOL>::push_back((uint64_t)&v353, v358);
        if (*v28)
        {
          uint64_t v34 = v348;
          if (v348 >= v349)
          {
            unint64_t v36 = v347;
            uint64_t v37 = v348 - v347;
            unint64_t v38 = v37 + 1;
            if ((unint64_t)(v37 + 1) >> 62) {
              goto LABEL_698;
            }
            uint64_t v39 = (char *)v349 - (char *)v347;
            if (((char *)v349 - (char *)v347) >> 1 > v38) {
              unint64_t v38 = v39 >> 1;
            }
            if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v40 = v38;
            }
            if (v40)
            {
              uint64_t v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v349, v40);
              unint64_t v36 = v347;
              uint64_t v34 = v348;
            }
            else
            {
              uint64_t v41 = 0;
            }
            long long v42 = (float *)&v41[4 * v37];
            *long long v42 = *((float *)v28 + 2);
            uint64_t v35 = v42 + 1;
            while (v34 != v36)
            {
              int v43 = *((_DWORD *)v34-- - 1);
              *((_DWORD *)v42-- - 1) = v43;
            }
            v347 = v42;
            v348 = v35;
            v349 = (float *)&v41[4 * v40];
            if (v36) {
              operator delete(v36);
            }
          }
          else
          {
            float *v348 = *((float *)v28 + 2);
            uint64_t v35 = v34 + 1;
          }
          v348 = v35;
          unint64_t v44 = v336;
          if (v336 >= v337)
          {
            unint64_t v46 = (char *)__p;
            uint64_t v47 = (v336 - (unsigned char *)__p) >> 2;
            unint64_t v48 = v47 + 1;
            if ((unint64_t)(v47 + 1) >> 62) {
              goto LABEL_698;
            }
            uint64_t v49 = v337 - (unsigned char *)__p;
            if ((v337 - (unsigned char *)__p) >> 1 > v48) {
              unint64_t v48 = v49 >> 1;
            }
            if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v50 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v50 = v48;
            }
            if (v50)
            {
              uint64_t v51 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v337, v50);
              unint64_t v46 = (char *)__p;
              unint64_t v44 = v336;
            }
            else
            {
              uint64_t v51 = 0;
            }
            unint64_t v52 = &v51[4 * v47];
            *(_DWORD *)unint64_t v52 = *((_DWORD *)v28 + 3);
            uint64_t v45 = v52 + 4;
            while (v44 != v46)
            {
              int v53 = *((_DWORD *)v44 - 1);
              v44 -= 4;
              *((_DWORD *)v52 - 1) = v53;
              v52 -= 4;
            }
            __n128 __p = v52;
            v336 = v45;
            v337 = &v51[4 * v50];
            if (v46) {
              operator delete(v46);
            }
          }
          else
          {
            *(_DWORD *)v336 = *((_DWORD *)v28 + 3);
            uint64_t v45 = v44 + 4;
          }
          v336 = v45;
          if (v28[108])
          {
            uint64_t v54 = v339;
            if (v339 >= v340)
            {
              unint64_t v56 = v338;
              uint64_t v57 = v339 - v338;
              unint64_t v58 = v57 + 1;
              if ((unint64_t)(v57 + 1) >> 62) {
                goto LABEL_698;
              }
              uint64_t v59 = (char *)v340 - (char *)v338;
              if (((char *)v340 - (char *)v338) >> 1 > v58) {
                unint64_t v58 = v59 >> 1;
              }
              if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v60 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v60 = v58;
              }
              if (v60)
              {
                long long v61 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v340, v60);
                unint64_t v56 = v338;
                uint64_t v54 = v339;
              }
              else
              {
                long long v61 = 0;
              }
              long long v62 = (float *)&v61[4 * v57];
              float *v62 = *((float *)v28 + 26);
              int v55 = v62 + 1;
              while (v54 != v56)
              {
                int v63 = *((_DWORD *)v54-- - 1);
                *((_DWORD *)v62-- - 1) = v63;
              }
              v338 = v62;
              v339 = v55;
              v340 = (float *)&v61[4 * v60];
              if (v56) {
                operator delete(v56);
              }
            }
            else
            {
              float *v339 = *((float *)v28 + 26);
              int v55 = v54 + 1;
            }
            v339 = v55;
          }
        }
      }
      int v64 = *v28;
      if (v31 >= v32 && *v28)
      {
        BOOL v65 = v345;
        if (v345 >= v346)
        {
          unint64_t v67 = v344;
          uint64_t v68 = (v345 - (char *)v344) >> 2;
          unint64_t v69 = v68 + 1;
          if ((unint64_t)(v68 + 1) >> 62) {
            goto LABEL_698;
          }
          uint64_t v70 = v346 - (char *)v344;
          if ((v346 - (char *)v344) >> 1 > v69) {
            unint64_t v69 = v70 >> 1;
          }
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v71 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v71 = v69;
          }
          if (v71)
          {
            unint64_t v72 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v346, v71);
            unint64_t v67 = v344;
            BOOL v65 = v345;
          }
          else
          {
            unint64_t v72 = 0;
          }
          long long v73 = &v72[4 * v68];
          *(_DWORD *)long long v73 = *((_DWORD *)v28 + 4);
          int v66 = v73 + 4;
          while (v65 != (char *)v67)
          {
            int v74 = *((_DWORD *)v65 - 1);
            v65 -= 4;
            *((_DWORD *)v73 - 1) = v74;
            v73 -= 4;
          }
          v344 = (float *)v73;
          v345 = v66;
          v346 = &v72[4 * v71];
          if (v67) {
            operator delete(v67);
          }
        }
        else
        {
          *(_DWORD *)v345 = *((_DWORD *)v28 + 4);
          int v66 = v65 + 4;
        }
        v345 = v66;
        int v75 = v315;
        if (v315 >= v316)
        {
          unint64_t v77 = (char *)v314;
          uint64_t v78 = (v315 - (unsigned char *)v314) >> 2;
          unint64_t v79 = v78 + 1;
          if ((unint64_t)(v78 + 1) >> 62) {
            goto LABEL_698;
          }
          uint64_t v80 = v316 - (unsigned char *)v314;
          if ((v316 - (unsigned char *)v314) >> 1 > v79) {
            unint64_t v79 = v80 >> 1;
          }
          if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v81 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v81 = v79;
          }
          if (v81)
          {
            unint64_t v82 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v316, v81);
            unint64_t v77 = (char *)v314;
            int v75 = v315;
          }
          else
          {
            unint64_t v82 = 0;
          }
          int v83 = &v82[4 * v78];
          *(_DWORD *)int v83 = *((_DWORD *)v28 + 30);
          char v76 = v83 + 4;
          while (v75 != v77)
          {
            int v84 = *((_DWORD *)v75 - 1);
            v75 -= 4;
            *((_DWORD *)v83 - 1) = v84;
            v83 -= 4;
          }
          v314 = v83;
          v315 = v76;
          v316 = &v82[4 * v81];
          if (v77) {
            operator delete(v77);
          }
        }
        else
        {
          *(_DWORD *)v315 = *((_DWORD *)v28 + 30);
          char v76 = v75 + 4;
        }
        v315 = v76;
        int v64 = *v28;
      }
      if (v31 >= v33 && v64)
      {
        char v85 = v342;
        if (v342 >= v343)
        {
          char v87 = v341;
          uint64_t v88 = (v342 - v341) >> 2;
          unint64_t v89 = v88 + 1;
          if ((unint64_t)(v88 + 1) >> 62) {
            goto LABEL_698;
          }
          uint64_t v90 = v343 - v341;
          if ((v343 - v341) >> 1 > v89) {
            unint64_t v89 = v90 >> 1;
          }
          if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v91 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v91 = v89;
          }
          if (v91)
          {
            int v92 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v343, v91);
            char v87 = v341;
            char v85 = v342;
          }
          else
          {
            int v92 = 0;
          }
          uint64_t v93 = &v92[4 * v88];
          *(_DWORD *)uint64_t v93 = *((_DWORD *)v28 + 2);
          uint64_t v86 = v93 + 4;
          while (v85 != v87)
          {
            int v94 = *((_DWORD *)v85 - 1);
            v85 -= 4;
            *((_DWORD *)v93 - 1) = v94;
            v93 -= 4;
          }
          v341 = v93;
          v342 = v86;
          v343 = &v92[4 * v91];
          if (v87) {
            operator delete(v87);
          }
        }
        else
        {
          *(_DWORD *)v342 = *((_DWORD *)v28 + 2);
          uint64_t v86 = v85 + 4;
        }
        v342 = v86;
        uint64_t v95 = v333;
        if (v333 >= v334)
        {
          uint64_t v97 = (char *)v332;
          uint64_t v98 = (v333 - (unsigned char *)v332) >> 2;
          unint64_t v99 = v98 + 1;
          if ((unint64_t)(v98 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v100 = v334 - (unsigned char *)v332;
          if ((v334 - (unsigned char *)v332) >> 1 > v99) {
            unint64_t v99 = v100 >> 1;
          }
          if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v101 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v101 = v99;
          }
          if (v101)
          {
            uint64_t v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v334, v101);
            uint64_t v97 = (char *)v332;
            uint64_t v95 = v333;
          }
          else
          {
            uint64_t v102 = 0;
          }
          unint64_t v103 = &v102[4 * v98];
          *(_DWORD *)unint64_t v103 = *((_DWORD *)v28 + 29);
          unint64_t v96 = v103 + 4;
          while (v95 != v97)
          {
            int v104 = *((_DWORD *)v95 - 1);
            v95 -= 4;
            *((_DWORD *)v103 - 1) = v104;
            v103 -= 4;
          }
          v332 = v103;
          v333 = v96;
          v334 = &v102[4 * v101];
          if (v97) {
            operator delete(v97);
          }
        }
        else
        {
          *(_DWORD *)v333 = *((_DWORD *)v28 + 29);
          unint64_t v96 = v95 + 4;
        }
        v333 = v96;
        if (v28[125]) {
          std::vector<BOOL>::push_back((uint64_t)&v350, v28 + 124);
        }
      }
      if (v31 >= v32)
      {
        int v105 = *((_DWORD *)v28 + 28);
        long long v106 = v330;
        if (v330 >= v331)
        {
          int v108 = (char *)v329;
          uint64_t v109 = (v330 - (unsigned char *)v329) >> 2;
          unint64_t v110 = v109 + 1;
          if ((unint64_t)(v109 + 1) >> 62) {
            goto LABEL_698;
          }
          uint64_t v111 = v331 - (unsigned char *)v329;
          if ((v331 - (unsigned char *)v329) >> 1 > v110) {
            unint64_t v110 = v111 >> 1;
          }
          if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v112 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v112 = v110;
          }
          if (v112)
          {
            char v113 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v331, v112);
            int v108 = (char *)v329;
            long long v106 = v330;
            int v105 = *((_DWORD *)v28 + 28);
          }
          else
          {
            char v113 = 0;
          }
          uint64_t v114 = &v113[4 * v109];
          *(_DWORD *)uint64_t v114 = v105;
          long long v107 = v114 + 4;
          while (v106 != v108)
          {
            int v115 = *((_DWORD *)v106 - 1);
            v106 -= 4;
            *((_DWORD *)v114 - 1) = v115;
            v114 -= 4;
          }
          v329 = v114;
          v330 = v107;
          v331 = &v113[4 * v112];
          if (v108) {
            operator delete(v108);
          }
        }
        else
        {
          *(_DWORD *)v330 = v105;
          long long v107 = v106 + 4;
        }
        v330 = v107;
      }
      if (v28[24])
      {
        int v116 = *((_DWORD *)v28 + 5);
        unint64_t v117 = v327;
        if (v327 >= v328)
        {
          unint64_t v119 = (char *)v326;
          uint64_t v120 = (v327 - (unsigned char *)v326) >> 2;
          unint64_t v121 = v120 + 1;
          if ((unint64_t)(v120 + 1) >> 62) {
            goto LABEL_698;
          }
          uint64_t v122 = v328 - (unsigned char *)v326;
          if ((v328 - (unsigned char *)v326) >> 1 > v121) {
            unint64_t v121 = v122 >> 1;
          }
          if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v123 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v123 = v121;
          }
          if (v123)
          {
            uint64_t v124 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v328, v123);
            unint64_t v119 = (char *)v326;
            unint64_t v117 = v327;
            int v116 = *((_DWORD *)v28 + 5);
          }
          else
          {
            uint64_t v124 = 0;
          }
          uint64_t v125 = &v124[4 * v120];
          *(_DWORD *)uint64_t v125 = v116;
          uint64_t v118 = v125 + 4;
          while (v117 != v119)
          {
            int v126 = *((_DWORD *)v117 - 1);
            v117 -= 4;
            *((_DWORD *)v125 - 1) = v126;
            v125 -= 4;
          }
          v326 = v125;
          v327 = v118;
          v328 = &v124[4 * v123];
          if (v119) {
            operator delete(v119);
          }
        }
        else
        {
          *(_DWORD *)v327 = v116;
          uint64_t v118 = v117 + 4;
        }
        v327 = v118;
      }
      if (v28[32])
      {
        int v127 = *((_DWORD *)v28 + 7);
        v128 = v324;
        if (v324 >= v325)
        {
          long long v130 = (char *)v323;
          uint64_t v131 = (v324 - (unsigned char *)v323) >> 2;
          unint64_t v132 = v131 + 1;
          if ((unint64_t)(v131 + 1) >> 62) {
LABEL_698:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          uint64_t v133 = v325 - (unsigned char *)v323;
          if ((v325 - (unsigned char *)v323) >> 1 > v132) {
            unint64_t v132 = v133 >> 1;
          }
          if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v134 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v134 = v132;
          }
          if (v134)
          {
            int v135 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v325, v134);
            long long v130 = (char *)v323;
            v128 = v324;
            int v127 = *((_DWORD *)v28 + 7);
          }
          else
          {
            int v135 = 0;
          }
          uint64_t v136 = &v135[4 * v131];
          *(_DWORD *)uint64_t v136 = v127;
          unint64_t v129 = v136 + 4;
          while (v128 != v130)
          {
            int v137 = *((_DWORD *)v128 - 1);
            v128 -= 4;
            *((_DWORD *)v136 - 1) = v137;
            v136 -= 4;
          }
          v323 = v136;
          v324 = v129;
          v325 = &v135[4 * v134];
          if (v130) {
            operator delete(v130);
          }
        }
        else
        {
          *(_DWORD *)v324 = v127;
          unint64_t v129 = v128 + 4;
        }
        v324 = v129;
      }
      if (v28[64]) {
        std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v320, (uint64_t)__dst, *((char **)v28 + 5), *((char **)v28 + 6), (uint64_t)(*((void *)v28 + 6) - *((void *)v28 + 5)) >> 2);
      }
      if (v28[96]) {
        std::vector<float>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v317, (uint64_t)v318, *((char **)v28 + 9), *((char **)v28 + 10), (uint64_t)(*((void *)v28 + 10) - *((void *)v28 + 9)) >> 2);
      }
      ++v31;
      v28 += 128;
    }
    while (v28 != v27);
    v139 = v353;
    unint64_t v138 = v354;
  }
  if (v138 > 0x3F || (float v140 = 0.0, (v138 & 0x3F) != 0))
  {
    int v141 = 0;
    unint64_t v142 = &v139[v138 >> 6];
    float v140 = 0.0;
    do
    {
      if ((*v139 >> v141)) {
        float v143 = 1.0;
      }
      else {
        float v143 = 0.0;
      }
      float v140 = v140 + v143;
      v139 += v141 == 63;
      if (v141 == 63) {
        int v141 = 0;
      }
      else {
        ++v141;
      }
    }
    while (v141 != (v138 & 0x3F) || v139 != v142);
  }
  float v144 = v140 / (float)v138;
  if (v144 >= 0.0 && v144 <= 1.0)
  {
    if (v144 == 1.0) {
      int v146 = 9;
    }
    else {
      int v146 = (int)(float)(v144 / 0.1);
    }
  }
  else
  {
    int v146 = -1;
  }
  int v313 = v146;
  unint64_t v148 = v347;
  v147 = v348;
  if (v347 == v348)
  {
    v147 = v347;
  }
  else
  {
    do
      ++v148;
    while (v148 != v348);
  }
  if (v347 == v147)
  {
    int v153 = -1;
    int v310 = -1;
    int v312 = -1;
    int v311 = -1;
    int v308 = -1;
LABEL_263:
    int v309 = v153;
    goto LABEL_264;
  }
  std::__sort<std::__less<float,float> &,float *>();
  float Percentile = Nightingale::getPercentile((uint64_t *)&v347, 0, 0.5);
  BOOL v151 = Nightingale::check2Real_t_equal(v150, Percentile, -1.0);
  if (v151)
  {
    int v152 = -1;
  }
  else if (Percentile >= 0.1)
  {
    if (Percentile >= 0.8) {
      int v152 = 15;
    }
    else {
      int v152 = (int)(float)((float)((float)(Percentile + -0.1) / 0.05) + 1.0);
    }
  }
  else
  {
    int v152 = 0;
  }
  float v154 = *(v348 - 1);
  BOOL v155 = Nightingale::check2Real_t_equal((Nightingale *)v151, v154, -1.0);
  if (v155)
  {
    int v156 = -1;
  }
  else if (v154 >= 0.1)
  {
    if (v154 >= 0.8) {
      int v156 = 15;
    }
    else {
      int v156 = (int)(float)((float)((float)(v154 + -0.1) / 0.05) + 1.0);
    }
  }
  else
  {
    int v156 = 0;
  }
  float v157 = *v347;
  if (Nightingale::check2Real_t_equal((Nightingale *)v155, *v347, -1.0))
  {
    int v158 = -1;
LABEL_253:
    int v312 = v158;
    goto LABEL_256;
  }
  if (v157 >= 0.1)
  {
    if (v157 >= 0.8) {
      int v158 = 15;
    }
    else {
      int v158 = (int)(float)((float)((float)(v157 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_253;
  }
  int v312 = 0;
LABEL_256:
  float v159 = Nightingale::getPercentile((uint64_t *)&v347, 0, 0.75);
  if (Nightingale::check2Real_t_equal(v160, v159, -1.0))
  {
    int v161 = -1;
LABEL_258:
    int v311 = v161;
    goto LABEL_261;
  }
  if (v159 >= 0.1)
  {
    if (v159 >= 0.8) {
      int v161 = 15;
    }
    else {
      int v161 = (int)(float)((float)((float)(v159 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_258;
  }
  int v311 = 0;
LABEL_261:
  float v162 = Nightingale::getPercentile((uint64_t *)&v347, 0, 0.25);
  int v310 = v156;
  int v308 = v152;
  if (Nightingale::check2Real_t_equal(v163, v162, -1.0))
  {
    int v153 = -1;
    goto LABEL_263;
  }
  if (v162 >= 0.1)
  {
    if (v162 >= 0.8) {
      int v153 = 15;
    }
    else {
      int v153 = (int)(float)((float)((float)(v162 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_263;
  }
  int v309 = 0;
LABEL_264:
  v165 = (char *)__p;
  v164 = v336;
  if (__p == v336)
  {
    v164 = __p;
  }
  else
  {
    do
      v165 += 4;
    while (v165 != v336);
  }
  if (__p == v164)
  {
    int v170 = -1;
    int v306 = -1;
    int v305 = -1;
    int v303 = -1;
    int v307 = -1;
    goto LABEL_294;
  }
  std::__sort<std::__less<float,float> &,float *>();
  float v166 = Nightingale::getPercentile((uint64_t *)&__p, 0, 0.5);
  BOOL v168 = Nightingale::check2Real_t_equal(v167, v166, -1.0);
  if (v168)
  {
    int v169 = -1;
LABEL_271:
    int v307 = v169;
    goto LABEL_275;
  }
  if (v166 >= 0.1)
  {
    if (v166 >= 0.8) {
      int v169 = 15;
    }
    else {
      int v169 = (int)(float)((float)((float)(v166 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_271;
  }
  int v307 = 0;
LABEL_275:
  float v171 = *((float *)v336 - 1);
  BOOL v172 = Nightingale::check2Real_t_equal((Nightingale *)v168, v171, -1.0);
  if (v172)
  {
    int v173 = -1;
LABEL_277:
    int v306 = v173;
    goto LABEL_282;
  }
  if (v171 >= 0.1)
  {
    if (v171 >= 0.8) {
      int v173 = 15;
    }
    else {
      int v173 = (int)(float)((float)((float)(v171 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_277;
  }
  int v306 = 0;
LABEL_282:
  float v174 = *(float *)__p;
  if (Nightingale::check2Real_t_equal((Nightingale *)v172, *(float *)__p, -1.0))
  {
    int v175 = -1;
LABEL_284:
    int v305 = v175;
    goto LABEL_287;
  }
  if (v174 >= 0.1)
  {
    if (v174 >= 0.8) {
      int v175 = 15;
    }
    else {
      int v175 = (int)(float)((float)((float)(v174 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_284;
  }
  int v305 = 0;
LABEL_287:
  float v176 = Nightingale::getPercentile((uint64_t *)&__p, 0, 0.75);
  if (Nightingale::check2Real_t_equal(v177, v176, -1.0))
  {
    int v178 = -1;
LABEL_289:
    int v303 = v178;
    goto LABEL_292;
  }
  if (v176 >= 0.1)
  {
    if (v176 >= 0.8) {
      int v178 = 15;
    }
    else {
      int v178 = (int)(float)((float)((float)(v176 + -0.1) / 0.05) + 1.0);
    }
    goto LABEL_289;
  }
  int v303 = 0;
LABEL_292:
  float v179 = Nightingale::getPercentile((uint64_t *)&__p, 0, 0.25);
  if (Nightingale::check2Real_t_equal(v180, v179, -1.0))
  {
    int v170 = -1;
  }
  else
  {
    if (v179 < 0.1)
    {
      int v299 = 0;
      goto LABEL_295;
    }
    if (v179 >= 0.8) {
      int v170 = 15;
    }
    else {
      int v170 = (int)(float)((float)((float)(v179 + -0.1) / 0.05) + 1.0);
    }
  }
LABEL_294:
  int v299 = v170;
LABEL_295:
  if (v338 == v339)
  {
    int v185 = -1;
    int v295 = -1;
    int v296 = -1;
    int v297 = -1;
    int v298 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v181 = Nightingale::getPercentile((uint64_t *)&v338, 0, 0.5);
    CAFwEndEstimateError = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(v182, v181);
    int v298 = (int)CAFwEndEstimateError;
    v184 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(CAFwEndEstimateError, *(v339 - 1));
    int v185 = (int)v184;
    int v297 = Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(v184, *v338);
    float v186 = Nightingale::getPercentile((uint64_t *)&v338, 0, 0.75);
    float v187 = Nightingale::getPercentile((uint64_t *)&v338, 0, 0.25);
    v189 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(v188, v186);
    int v296 = (int)v189;
    int v295 = Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(v189, v187);
  }
  v191 = (char *)v344;
  v190 = (float *)v345;
  if (v344 == (float *)v345)
  {
    v190 = v344;
  }
  else
  {
    do
      v191 += 4;
    while (v191 != v345);
  }
  if (v344 == v190)
  {
    int v196 = -1;
  }
  else
  {
    float v192 = 0.0;
    v193 = v344;
    do
    {
      float v194 = *v193++;
      float v192 = v192 + v194;
    }
    while (v193 != v190);
    float v195 = sqrtf(v192 / (float)(unint64_t)(v190 - v344));
    if (v195 >= 0.35) {
      int v196 = 7;
    }
    else {
      int v196 = (int)(float)(v195 / 0.05);
    }
  }
  int v294 = v196;
  v197 = (Nightingale::ngt_HistoricalAnalyzer *)v314;
  if (v314 == v315
    || (std::__sort<std::__less<float,float> &,float *>(),
        float v198 = Nightingale::getPercentile((uint64_t *)&v314, 0, 0.5),
        v198 < 0.0))
  {
    int v199 = -1;
  }
  else if (v198 >= 0.9)
  {
    int v199 = 9;
  }
  else
  {
    int v199 = (int)(float)(v198 / 0.1);
  }
  int v293 = v199;
  v200 = (char *)v332;
  v201 = v333;
  if (v332 == v333)
  {
    int v283 = -1;
    int v284 = -1;
    int v286 = -1;
    int v287 = -1;
    int v285 = -1;
    int v288 = -1;
    int v289 = -1;
    int v290 = -1;
    int v291 = -1;
    int v292 = -1;
  }
  else
  {
    unsigned int v202 = 0;
    v203 = (char *)v332;
    do
    {
      int v204 = *(_DWORD *)v203;
      v203 += 4;
      if (v204 == 1) {
        ++v202;
      }
    }
    while (v203 != v333);
    CANumberOfCycles = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v197, (int)(float)(unint64_t)((v333 - (unsigned char *)v332) >> 2));
    int v292 = (int)CANumberOfCycles;
    uint64_t v206 = 0;
    v207 = v200;
    do
    {
      int v208 = *(_DWORD *)v207;
      v207 += 4;
      if (v208 == 2) {
        ++v206;
      }
    }
    while (v207 != v201);
    uint64_t v209 = 0;
    unsigned int v210 = (int)(float)v206;
    v211 = v200;
    do
    {
      int v212 = *(_DWORD *)v211;
      v211 += 4;
      if (v212 == 3) {
        ++v209;
      }
    }
    while (v211 != v201);
    v213 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(CANumberOfCycles, v202);
    int v291 = (int)v213;
    uint64_t v214 = 0;
    unsigned int v215 = (int)(float)v209;
    v216 = v200;
    do
    {
      int v217 = *(_DWORD *)v216;
      v216 += 4;
      if (v217 == 4) {
        ++v214;
      }
    }
    while (v216 != v201);
    v218 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v213, v210);
    int v290 = (int)v218;
    uint64_t v219 = 0;
    v220 = v200;
    do
    {
      int v221 = *(_DWORD *)v220;
      v220 += 4;
      if (!v221) {
        ++v219;
      }
    }
    while (v220 != v201);
    v222 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v218, v215);
    int v289 = (int)v222;
    uint64_t v223 = 0;
    v224 = v200;
    do
    {
      int v225 = *(_DWORD *)v224;
      v224 += 4;
      if (v225 == 6) {
        ++v223;
      }
    }
    while (v224 != v201);
    v226 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v222, (int)(float)v214);
    int v288 = (int)v226;
    uint64_t v227 = 0;
    do
    {
      int v228 = *(_DWORD *)v200;
      v200 += 4;
      if (v228 == 7) {
        ++v227;
      }
    }
    while (v200 != v201);
    v229 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v226, (int)(float)v219);
    int v287 = (int)v229;
    v230 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v229, (int)(float)v223);
    int v286 = (int)v230;
    v231 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v230, (int)(float)v227);
    int v285 = (int)v231;
    v232 = v341;
    if (v341 == v342)
    {
      int v233 = 0;
    }
    else
    {
      int v233 = 0;
      do
      {
        v232 += 4;
        ++v233;
      }
      while (v232 != v342);
    }
    int v234 = v351 & 0x3F;
    if (v351 <= 0x3F && v234 == 0)
    {
      LODWORD(v237) = 0;
    }
    else
    {
      int v236 = 0;
      uint64_t v237 = 0;
      v238 = v350;
      do
      {
        v237 += (*(void *)v238 >> v236) & 1;
        v238 += 8 * (v236 == 63);
        if (v236 == 63) {
          int v236 = 0;
        }
        else {
          ++v236;
        }
      }
      while (v236 != v234 || v238 != &v350[8 * (v351 >> 6)]);
    }
    v239 = (Nightingale::ngt_HistoricalAnalyzer *)Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v231, v233 + (int)v237);
    int v284 = (int)v239;
    int v283 = Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(v239, v237);
  }
  if (v329 == v330)
  {
    int v281 = -1;
    int v282 = -1;
    int v278 = -1;
    int v279 = -1;
    int v280 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v240 = Nightingale::getPercentile((uint64_t *)&v329, 0, 0.5);
    if (v240 >= 6.0)
    {
      if (v240 >= 9.0)
      {
        if (v240 >= 12.0)
        {
          if (v240 >= 15.0)
          {
            if (v240 >= 18.0)
            {
              if (v240 >= 21.0)
              {
                if (v240 >= 24.0) {
                  int v241 = 7;
                }
                else {
                  int v241 = 6;
                }
              }
              else
              {
                int v241 = 5;
              }
            }
            else
            {
              int v241 = 4;
            }
          }
          else
          {
            int v241 = 3;
          }
        }
        else
        {
          int v241 = 2;
        }
      }
      else
      {
        int v241 = 1;
      }
      int v282 = v241;
    }
    else
    {
      int v282 = 0;
    }
    float v242 = *((float *)v330 - 1);
    if (v242 >= 6.0)
    {
      if (v242 >= 9.0)
      {
        if (v242 >= 12.0)
        {
          if (v242 >= 15.0)
          {
            if (v242 >= 18.0)
            {
              if (v242 >= 21.0)
              {
                if (v242 >= 24.0) {
                  int v243 = 7;
                }
                else {
                  int v243 = 6;
                }
              }
              else
              {
                int v243 = 5;
              }
            }
            else
            {
              int v243 = 4;
            }
          }
          else
          {
            int v243 = 3;
          }
        }
        else
        {
          int v243 = 2;
        }
      }
      else
      {
        int v243 = 1;
      }
      int v281 = v243;
    }
    else
    {
      int v281 = 0;
    }
    float v244 = *(float *)v329;
    if (*(float *)v329 >= 6.0)
    {
      if (v244 >= 9.0)
      {
        if (v244 >= 12.0)
        {
          if (v244 >= 15.0)
          {
            if (v244 >= 18.0)
            {
              if (v244 >= 21.0)
              {
                if (v244 >= 24.0) {
                  int v245 = 7;
                }
                else {
                  int v245 = 6;
                }
              }
              else
              {
                int v245 = 5;
              }
            }
            else
            {
              int v245 = 4;
            }
          }
          else
          {
            int v245 = 3;
          }
        }
        else
        {
          int v245 = 2;
        }
      }
      else
      {
        int v245 = 1;
      }
      int v280 = v245;
    }
    else
    {
      int v280 = 0;
    }
    float v246 = Nightingale::getPercentile((uint64_t *)&v329, 0, 0.75);
    if (v246 >= 6.0)
    {
      if (v246 >= 9.0)
      {
        if (v246 >= 12.0)
        {
          if (v246 >= 15.0)
          {
            if (v246 >= 18.0)
            {
              if (v246 >= 21.0)
              {
                if (v246 >= 24.0) {
                  int v247 = 7;
                }
                else {
                  int v247 = 6;
                }
              }
              else
              {
                int v247 = 5;
              }
            }
            else
            {
              int v247 = 4;
            }
          }
          else
          {
            int v247 = 3;
          }
        }
        else
        {
          int v247 = 2;
        }
      }
      else
      {
        int v247 = 1;
      }
      int v279 = v247;
    }
    else
    {
      int v279 = 0;
    }
    float v248 = Nightingale::getPercentile((uint64_t *)&v329, 0, 0.25);
    if (v248 >= 6.0)
    {
      if (v248 >= 9.0)
      {
        if (v248 >= 12.0)
        {
          if (v248 >= 15.0)
          {
            if (v248 >= 18.0)
            {
              if (v248 >= 21.0)
              {
                if (v248 >= 24.0) {
                  int v249 = 7;
                }
                else {
                  int v249 = 6;
                }
              }
              else
              {
                int v249 = 5;
              }
            }
            else
            {
              int v249 = 4;
            }
          }
          else
          {
            int v249 = 3;
          }
        }
        else
        {
          int v249 = 2;
        }
      }
      else
      {
        int v249 = 1;
      }
      int v278 = v249;
    }
    else
    {
      int v278 = 0;
    }
  }
  if (v326 == v327)
  {
    int v276 = -1;
    int v277 = -1;
    int v251 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v250 = Nightingale::getPercentile((uint64_t *)&v326, 0, 0.5);
    if (v250 >= 1.0)
    {
      if (v250 >= 5.0)
      {
        if (v250 >= 10.0)
        {
          if (v250 >= 15.0)
          {
            if (v250 >= 20.0)
            {
              if (v250 >= 25.0)
              {
                if (v250 >= 30.0) {
                  int v252 = 7;
                }
                else {
                  int v252 = 6;
                }
              }
              else
              {
                int v252 = 5;
              }
            }
            else
            {
              int v252 = 4;
            }
          }
          else
          {
            int v252 = 3;
          }
        }
        else
        {
          int v252 = 2;
        }
      }
      else
      {
        int v252 = 1;
      }
      int v277 = v252;
    }
    else
    {
      int v277 = 0;
    }
    float v253 = *((float *)v327 - 1);
    if (v253 >= 1.0)
    {
      if (v253 >= 5.0)
      {
        if (v253 >= 10.0)
        {
          if (v253 >= 15.0)
          {
            if (v253 >= 20.0)
            {
              if (v253 >= 25.0)
              {
                if (v253 >= 30.0) {
                  int v254 = 7;
                }
                else {
                  int v254 = 6;
                }
              }
              else
              {
                int v254 = 5;
              }
            }
            else
            {
              int v254 = 4;
            }
          }
          else
          {
            int v254 = 3;
          }
        }
        else
        {
          int v254 = 2;
        }
      }
      else
      {
        int v254 = 1;
      }
      int v276 = v254;
    }
    else
    {
      int v276 = 0;
    }
    float v255 = *(float *)v326;
    if (*(float *)v326 >= 1.0)
    {
      if (v255 >= 5.0)
      {
        if (v255 >= 10.0)
        {
          if (v255 >= 15.0)
          {
            if (v255 >= 20.0)
            {
              if (v255 >= 25.0)
              {
                if (v255 >= 30.0) {
                  int v251 = 7;
                }
                else {
                  int v251 = 6;
                }
              }
              else
              {
                int v251 = 5;
              }
            }
            else
            {
              int v251 = 4;
            }
          }
          else
          {
            int v251 = 3;
          }
        }
        else
        {
          int v251 = 2;
        }
      }
      else
      {
        int v251 = 1;
      }
    }
    else
    {
      int v251 = 0;
    }
  }
  if (v323 == v324)
  {
    int v258 = -1;
    int v259 = -1;
    int v257 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v256 = Nightingale::getPercentile((uint64_t *)&v323, 0, 0.5);
    if (v256 >= 1.0)
    {
      if (v256 >= 5.0)
      {
        if (v256 >= 10.0)
        {
          if (v256 >= 15.0)
          {
            if (v256 >= 20.0)
            {
              if (v256 >= 25.0)
              {
                if (v256 >= 30.0) {
                  int v257 = 7;
                }
                else {
                  int v257 = 6;
                }
              }
              else
              {
                int v257 = 5;
              }
            }
            else
            {
              int v257 = 4;
            }
          }
          else
          {
            int v257 = 3;
          }
        }
        else
        {
          int v257 = 2;
        }
      }
      else
      {
        int v257 = 1;
      }
    }
    else
    {
      int v257 = 0;
    }
    float v260 = *((float *)v324 - 1);
    if (v260 >= 1.0)
    {
      if (v260 >= 5.0)
      {
        if (v260 >= 10.0)
        {
          if (v260 >= 15.0)
          {
            if (v260 >= 20.0)
            {
              if (v260 >= 25.0)
              {
                if (v260 >= 30.0) {
                  int v258 = 7;
                }
                else {
                  int v258 = 6;
                }
              }
              else
              {
                int v258 = 5;
              }
            }
            else
            {
              int v258 = 4;
            }
          }
          else
          {
            int v258 = 3;
          }
        }
        else
        {
          int v258 = 2;
        }
      }
      else
      {
        int v258 = 1;
      }
    }
    else
    {
      int v258 = 0;
    }
    float v261 = *(float *)v323;
    if (*(float *)v323 >= 1.0)
    {
      if (v261 >= 5.0)
      {
        if (v261 >= 10.0)
        {
          if (v261 >= 15.0)
          {
            if (v261 >= 20.0)
            {
              if (v261 >= 25.0)
              {
                if (v261 >= 30.0) {
                  int v259 = 7;
                }
                else {
                  int v259 = 6;
                }
              }
              else
              {
                int v259 = 5;
              }
            }
            else
            {
              int v259 = 4;
            }
          }
          else
          {
            int v259 = 3;
          }
        }
        else
        {
          int v259 = 2;
        }
      }
      else
      {
        int v259 = 1;
      }
    }
    else
    {
      int v259 = 0;
    }
  }
  if (v320 == __dst)
  {
    int v264 = -1;
    int v265 = -1;
    int v263 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v262 = Nightingale::getPercentile((uint64_t *)&v320, 0, 0.5);
    if (v262 >= 1.0)
    {
      if (v262 >= 5.0)
      {
        if (v262 >= 10.0)
        {
          if (v262 >= 15.0)
          {
            if (v262 >= 20.0)
            {
              if (v262 >= 25.0)
              {
                if (v262 >= 30.0) {
                  int v263 = 7;
                }
                else {
                  int v263 = 6;
                }
              }
              else
              {
                int v263 = 5;
              }
            }
            else
            {
              int v263 = 4;
            }
          }
          else
          {
            int v263 = 3;
          }
        }
        else
        {
          int v263 = 2;
        }
      }
      else
      {
        int v263 = 1;
      }
    }
    else
    {
      int v263 = 0;
    }
    float v266 = *((float *)__dst - 1);
    if (v266 >= 1.0)
    {
      if (v266 >= 5.0)
      {
        if (v266 >= 10.0)
        {
          if (v266 >= 15.0)
          {
            if (v266 >= 20.0)
            {
              if (v266 >= 25.0)
              {
                if (v266 >= 30.0) {
                  int v264 = 7;
                }
                else {
                  int v264 = 6;
                }
              }
              else
              {
                int v264 = 5;
              }
            }
            else
            {
              int v264 = 4;
            }
          }
          else
          {
            int v264 = 3;
          }
        }
        else
        {
          int v264 = 2;
        }
      }
      else
      {
        int v264 = 1;
      }
    }
    else
    {
      int v264 = 0;
    }
    float v267 = *(float *)v320;
    if (*(float *)v320 >= 1.0)
    {
      if (v267 >= 5.0)
      {
        if (v267 >= 10.0)
        {
          if (v267 >= 15.0)
          {
            if (v267 >= 20.0)
            {
              if (v267 >= 25.0)
              {
                if (v267 >= 30.0) {
                  int v265 = 7;
                }
                else {
                  int v265 = 6;
                }
              }
              else
              {
                int v265 = 5;
              }
            }
            else
            {
              int v265 = 4;
            }
          }
          else
          {
            int v265 = 3;
          }
        }
        else
        {
          int v265 = 2;
        }
      }
      else
      {
        int v265 = 1;
      }
    }
    else
    {
      int v265 = 0;
    }
  }
  if (v317 == v318)
  {
    int v270 = -1;
    int v271 = -1;
    int v269 = -1;
  }
  else
  {
    std::__sort<std::__less<float,float> &,float *>();
    float v268 = Nightingale::getPercentile((uint64_t *)&v317, 0, 0.5);
    if (v268 >= 1.0)
    {
      if (v268 >= 5.0)
      {
        if (v268 >= 10.0)
        {
          if (v268 >= 15.0)
          {
            if (v268 >= 20.0)
            {
              if (v268 >= 25.0)
              {
                if (v268 >= 30.0) {
                  int v269 = 7;
                }
                else {
                  int v269 = 6;
                }
              }
              else
              {
                int v269 = 5;
              }
            }
            else
            {
              int v269 = 4;
            }
          }
          else
          {
            int v269 = 3;
          }
        }
        else
        {
          int v269 = 2;
        }
      }
      else
      {
        int v269 = 1;
      }
    }
    else
    {
      int v269 = 0;
    }
    float v272 = *((float *)v318 - 1);
    if (v272 >= 1.0)
    {
      if (v272 >= 5.0)
      {
        if (v272 >= 10.0)
        {
          if (v272 >= 15.0)
          {
            if (v272 >= 20.0)
            {
              if (v272 >= 25.0)
              {
                if (v272 >= 30.0) {
                  int v270 = 7;
                }
                else {
                  int v270 = 6;
                }
              }
              else
              {
                int v270 = 5;
              }
            }
            else
            {
              int v270 = 4;
            }
          }
          else
          {
            int v270 = 3;
          }
        }
        else
        {
          int v270 = 2;
        }
      }
      else
      {
        int v270 = 1;
      }
    }
    else
    {
      int v270 = 0;
    }
    float v273 = *(float *)v317;
    if (*(float *)v317 >= 1.0)
    {
      if (v273 >= 5.0)
      {
        if (v273 >= 10.0)
        {
          if (v273 >= 15.0)
          {
            if (v273 >= 20.0)
            {
              if (v273 >= 25.0)
              {
                if (v273 >= 30.0) {
                  int v271 = 7;
                }
                else {
                  int v271 = 6;
                }
              }
              else
              {
                int v271 = 5;
              }
            }
            else
            {
              int v271 = 4;
            }
          }
          else
          {
            int v271 = 3;
          }
        }
        else
        {
          int v271 = 2;
        }
      }
      else
      {
        int v271 = 1;
      }
    }
    else
    {
      int v271 = 0;
    }
  }
  *(unsigned char *)(a6 + 8) = HasMultipleWatchHist;
  *(_DWORD *)(a6 + 12) = v313;
  *(_DWORD *)(a6 + 16) = v309;
  *(_DWORD *)(a6 + 20) = v308;
  *(_DWORD *)(a6 + 24) = v311;
  *(_DWORD *)(a6 + 28) = v312;
  *(_DWORD *)(a6 + 32) = v310;
  *(_DWORD *)(a6 + 36) = v299;
  *(_DWORD *)(a6 + 40) = v307;
  *(_DWORD *)(a6 + 44) = v303;
  *(_DWORD *)(a6 + 48) = v305;
  *(_DWORD *)(a6 + 52) = v306;
  *(_DWORD *)(a6 + 56) = v294;
  *(_DWORD *)(a6 + 60) = v293;
  *(_DWORD *)(a6 + 64) = v297;
  *(_DWORD *)(a6 + 68) = v295;
  *(_DWORD *)(a6 + 72) = v298;
  float v274 = (float)(0xAAAAAAAAAAAAAAABLL * ((v304 - v302) >> 5));
  int v275 = *(unsigned __int8 *)(a6 + 192);
  *(_WORD *)(a6 + 9) = v356;
  *(unsigned char *)(a6 + 11) = v357;
  *(_DWORD *)(a6 + 76) = v296;
  *(_DWORD *)(a6 + 80) = v185;
  *(_DWORD *)(a6 + 84) = v280;
  *(_DWORD *)(a6 + 88) = v278;
  *(_DWORD *)(a6 + 92) = v282;
  *(_DWORD *)(a6 + 96) = v279;
  *(_DWORD *)(a6 + 100) = v281;
  *(_DWORD *)(a6 + 104) = v277;
  *(_DWORD *)(a6 + 108) = v251;
  *(_DWORD *)(a6 + 112) = v276;
  *(_DWORD *)(a6 + 116) = v257;
  *(_DWORD *)(a6 + 120) = v259;
  *(_DWORD *)(a6 + 124) = v258;
  *(_DWORD *)(a6 + 128) = v263;
  *(_DWORD *)(a6 + 132) = v265;
  *(_DWORD *)(a6 + 136) = v264;
  *(_DWORD *)(a6 + 140) = v269;
  *(_DWORD *)(a6 + 144) = v271;
  *(_DWORD *)(a6 + 148) = v270;
  *(_DWORD *)(a6 + 152) = v292;
  *(_DWORD *)(a6 + 156) = v291;
  *(_DWORD *)(a6 + 160) = v290;
  *(_DWORD *)(a6 + 164) = v289;
  *(_DWORD *)(a6 + 168) = v288;
  *(_DWORD *)(a6 + 172) = v286;
  *(_DWORD *)(a6 + 176) = v285;
  *(_DWORD *)(a6 + 180) = v287;
  *(_DWORD *)(a6 + 184) = v284;
  *(_DWORD *)(a6 + 188) = v283;
  *(float *)a6 = (float)v301 / v274;
  *(float *)(a6 + 4) = (float)v25 / v274;
  if (!v275) {
    *(unsigned char *)(a6 + 192) = 1;
  }
  if (v314)
  {
    v315 = (char *)v314;
    operator delete(v314);
  }
  if (v317)
  {
    v318 = v317;
    operator delete(v317);
  }
  if (v320)
  {
    __dst = v320;
    operator delete(v320);
  }
  if (v323)
  {
    v324 = (char *)v323;
    operator delete(v323);
  }
  if (v326)
  {
    v327 = (char *)v326;
    operator delete(v326);
  }
  if (v329)
  {
    v330 = (char *)v329;
    operator delete(v329);
  }
  if (v332)
  {
    v333 = (char *)v332;
    operator delete(v332);
  }
  if (__p)
  {
    v336 = (char *)__p;
    operator delete(__p);
  }
  if (v338)
  {
    v339 = v338;
    operator delete(v338);
  }
  if (v341)
  {
    v342 = v341;
    operator delete(v341);
  }
  if (v344)
  {
    v345 = (char *)v344;
    operator delete(v344);
  }
  if (v347)
  {
    v348 = v347;
    operator delete(v347);
  }
  if (v350) {
    operator delete(v350);
  }
  if (v353) {
    operator delete(v353);
  }
}

void sub_257D40F04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,void *a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,void *a56,uint64_t a57)
{
  if (__p) {
    operator delete(__p);
  }
  if (a38) {
    operator delete(a38);
  }
  if (a41) {
    operator delete(a41);
  }
  if (a44) {
    operator delete(a44);
  }
  if (a47) {
    operator delete(a47);
  }
  if (a50) {
    operator delete(a50);
  }
  if (a53) {
    operator delete(a53);
  }
  if (a56) {
    operator delete(a56);
  }
  uint64_t v59 = *(void **)(v57 - 256);
  if (v59)
  {
    *(void *)(v57 - 248) = v59;
    operator delete(v59);
  }
  unint64_t v60 = *(void **)(v57 - 232);
  if (v60)
  {
    *(void *)(v57 - 224) = v60;
    operator delete(v60);
  }
  long long v61 = *(void **)(v57 - 208);
  if (v61)
  {
    *(void *)(v57 - 200) = v61;
    operator delete(v61);
  }
  long long v62 = *(void **)(v57 - 184);
  if (v62)
  {
    *(void *)(v57 - 176) = v62;
    operator delete(v62);
  }
  int v63 = *(void **)(v57 - 160);
  if (v63) {
    operator delete(v63);
  }
  int v64 = *(void **)(v57 - 136);
  if (v64) {
    operator delete(v64);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::phaseFactorHist::~phaseFactorHist(Nightingale::phaseFactorHist *this)
{
  uint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

{
  void *v2;

  uint64_t v2 = *(void **)this;
  if (v2)
  {
    *((void *)this + 1) = v2;
    operator delete(v2);
  }
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getHasMultipleWatchHist(void *a1, int a2, uint64_t a3, int a4)
{
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v22);
  Nightingale::wristTemperatureInputAcquisition::extractKaliInputsJDayRange((unint64_t)v22, a1, *(_DWORD *)(a1[1] - 60) - a2 + 1, *(_DWORD *)(a1[1] - 60), a3, a4, (uint64_t)&v16);
  if (v18 == v19 || v19 - (unsigned char *)v18 == 1) {
    goto LABEL_3;
  }
  if ((unint64_t)(v19 - (unsigned char *)v18) <= 2)
  {
    uint64_t v10 = v16;
    uint64_t v11 = v17;
    if (v16 == v17)
    {
LABEL_3:
      uint64_t v8 = 0;
      goto LABEL_4;
    }
    do
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v13, *(const void **)v10, *(void *)(v10 + 8), (uint64_t)(*(void *)(v10 + 8) - *(void *)v10) >> 2);
      uint64_t v8 = Nightingale::checkNumTmpSwitches((float **)&v13, 2, 30.0);
      if (v13)
      {
        uint64_t v14 = v13;
        operator delete(v13);
      }
      v10 += 24;
      if (v10 == v11) {
        char v12 = 1;
      }
      else {
        char v12 = v8;
      }
    }
    while ((v12 & 1) == 0);
  }
  else
  {
    uint64_t v8 = 1;
  }
LABEL_4:
  if (__p)
  {
    uint64_t v21 = __p;
    operator delete(__p);
  }
  if (v18)
  {
    uint64_t v19 = v18;
    operator delete(v18);
  }
  uint64_t v23 = (void **)&v16;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v23);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)v22);
  return v8;
}

void sub_257D41198(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCAFractionOfCycles(Nightingale::ngt_HistoricalAnalyzer *this, float a2)
{
  if (a2 < 0.0 || a2 > 1.0) {
    return 0xFFFFFFFFLL;
  }
  if (a2 == 1.0) {
    return 9;
  }
  return (int)(float)(a2 / 0.1);
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCASignalAtFwEndEstimate(Nightingale::ngt_HistoricalAnalyzer *this, float a2)
{
  if (Nightingale::check2Real_t_equal(this, a2, -1.0)) {
    return 0xFFFFFFFFLL;
  }
  if (a2 < 0.1) {
    return 0;
  }
  if (a2 >= 0.8) {
    return 15;
  }
  return (int)(float)((float)((float)(a2 + -0.1) / 0.05) + 1.0);
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCAFwEndEstimateError(Nightingale::ngt_HistoricalAnalyzer *this, float a2)
{
  if (a2 < -7.0) {
    return 0;
  }
  if (a2 < -5.0) {
    return 1;
  }
  if (a2 < -3.0) {
    return 2;
  }
  if (a2 < -1.0) {
    return 3;
  }
  if (a2 < 1.0) {
    return 4;
  }
  if (a2 >= 7.0) {
    int v3 = 8;
  }
  else {
    int v3 = 7;
  }
  if (a2 >= 5.0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 6;
  }
  if (a2 >= 3.0) {
    return v4;
  }
  else {
    return 5;
  }
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCANumberOfCycles(Nightingale::ngt_HistoricalAnalyzer *this, unsigned int a2)
{
  if (a2 >= 0x10) {
    return 0xFFFFFFFFLL;
  }
  else {
    return a2;
  }
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCAEstimatedLutealPhaseLength(Nightingale::ngt_HistoricalAnalyzer *this, float a2)
{
  if (a2 < 6.0) {
    return 0;
  }
  if (a2 < 9.0) {
    return 1;
  }
  if (a2 < 12.0) {
    return 2;
  }
  if (a2 < 15.0) {
    return 3;
  }
  if (a2 >= 24.0) {
    int v3 = 7;
  }
  else {
    int v3 = 6;
  }
  if (a2 >= 21.0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 5;
  }
  if (a2 >= 18.0) {
    return v4;
  }
  else {
    return 4;
  }
}

uint64_t Nightingale::ngt_HistoricalAnalyzer::getCADaysLoggedBeforeOrAfterCycleStart(Nightingale::ngt_HistoricalAnalyzer *this, float a2)
{
  if (a2 < 1.0) {
    return 0;
  }
  if (a2 < 5.0) {
    return 1;
  }
  if (a2 < 10.0) {
    return 2;
  }
  if (a2 < 15.0) {
    return 3;
  }
  if (a2 >= 30.0) {
    int v3 = 7;
  }
  else {
    int v3 = 6;
  }
  if (a2 >= 25.0) {
    unsigned int v4 = v3;
  }
  else {
    unsigned int v4 = 5;
  }
  if (a2 >= 20.0) {
    return v4;
  }
  else {
    return 4;
  }
}

uint64_t Nightingale::phaseFactorHist::suppressFWHist(uint64_t result, unsigned int **a2, uint64_t *a3)
{
  int v3 = *a2;
  unsigned int v4 = a2[1];
  if (*a2 != v4)
  {
    uint64_t v6 = result;
    do
    {
      uint64_t result = Nightingale::phaseFactorProcessor::suppressFWStEnd(v6, v3, v3 + 2, a3);
      v3 += 18;
    }
    while (v3 != v4);
  }
  return result;
}

void std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t std::vector<Nightingale::cycleInfo>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v9 = v7;
    uint64_t v8 = *(void *)(a1 + 8);
    do
    {
      *(_OWORD *)uint64_t v8 = *(_OWORD *)v9;
      long long v10 = *(_OWORD *)(v9 + 16);
      long long v11 = *(_OWORD *)(v9 + 32);
      long long v12 = *(_OWORD *)(v9 + 48);
      *(void *)(v8 + 61) = *(void *)(v9 + 61);
      *(_OWORD *)(v8 + 32) = v11;
      *(_OWORD *)(v8 + 48) = v12;
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(v8 + 80) = 0;
      *(void *)(v8 + 88) = 0;
      *(void *)(v8 + 72) = 0;
      *(_OWORD *)(v8 + 72) = *(_OWORD *)(v9 + 72);
      *(void *)(v8 + 88) = *(void *)(v9 + 88);
      *(void *)(v9 + 72) = 0;
      *(void *)(v9 + 80) = 0;
      *(void *)(v9 + 88) = 0;
      v8 += 96;
      v9 += 96;
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,Nightingale::cycleInfo *,Nightingale::cycleInfo *,Nightingale::cycleInfo *,0>(a2, v7, v6);
}

void *std::__split_buffer<Nightingale::cycleInfo>::push_back[abi:ne180100](void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    uint64_t v6 = *a1;
    unint64_t v5 = a1[1];
    if (v5 <= *a1)
    {
      uint64_t v12 = v4 - v6;
      BOOL v11 = v12 == 0;
      uint64_t v13 = 0x5555555555555556 * (v12 >> 5);
      if (v11) {
        unint64_t v14 = 1;
      }
      else {
        unint64_t v14 = v13;
      }
      unint64_t v15 = v14 >> 2;
      uint64_t v35 = a1[4];
      uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(v35, v14);
      size_t v18 = &v16[96 * v15];
      unint64_t v19 = a1[1];
      unint64_t v20 = a1[2] - v19;
      if (v20)
      {
        uint64_t v21 = &v18[v20];
        uint64_t v22 = &v16[96 * v15];
        do
        {
          *(_OWORD *)uint64_t v22 = *(_OWORD *)v19;
          long long v23 = *(_OWORD *)(v19 + 16);
          long long v24 = *(_OWORD *)(v19 + 32);
          long long v25 = *(_OWORD *)(v19 + 48);
          *(void *)(v22 + 61) = *(void *)(v19 + 61);
          *((_OWORD *)v22 + 2) = v24;
          *((_OWORD *)v22 + 3) = v25;
          *((_OWORD *)v22 + 1) = v23;
          *((void *)v22 + 10) = 0;
          *((void *)v22 + 11) = 0;
          *((void *)v22 + 9) = 0;
          *(_OWORD *)(v22 + 72) = *(_OWORD *)(v19 + 72);
          *((void *)v22 + 11) = *(void *)(v19 + 88);
          *(void *)(v19 + 72) = 0;
          *(void *)(v19 + 80) = 0;
          *(void *)(v19 + 88) = 0;
          v22 += 96;
          v19 += 96;
        }
        while (v22 != v21);
        int64x2_t v26 = *(int64x2_t *)(a1 + 1);
      }
      else
      {
        int64x2_t v26 = vdupq_n_s64(v19);
        uint64_t v21 = &v16[96 * v15];
      }
      uint64_t v32 = *a1;
      *a1 = v16;
      a1[1] = v18;
      int64x2_t v33 = v26;
      uint64_t v27 = a1[3];
      a1[2] = v21;
      a1[3] = &v16[96 * v17];
      uint64_t v34 = v27;
      std::__split_buffer<Nightingale::cycleInfo>::~__split_buffer((uint64_t)&v32);
      uint64_t v4 = a1[2];
    }
    else
    {
      int64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 5);
      if (v7 >= -1) {
        uint64_t v8 = v7 + 1;
      }
      else {
        uint64_t v8 = v7 + 2;
      }
      uint64_t v9 = -3 * (v8 >> 1);
      std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,Nightingale::cycleInfo *,Nightingale::cycleInfo *,Nightingale::cycleInfo *,0>(v5, v4, v5 - 96 * (v8 >> 1));
      uint64_t v4 = v10;
      a1[1] += 32 * v9;
      a1[2] = v10;
    }
  }
  *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
  long long v28 = *(_OWORD *)(a2 + 16);
  long long v29 = *(_OWORD *)(a2 + 32);
  long long v30 = *(_OWORD *)(a2 + 48);
  *(void *)(v4 + 61) = *(void *)(a2 + 61);
  *(_OWORD *)(v4 + 32) = v29;
  *(_OWORD *)(v4 + 48) = v30;
  *(_OWORD *)(v4 + 16) = v28;
  *(void *)(v4 + 80) = 0;
  *(void *)(v4 + 88) = 0;
  *(void *)(v4 + 72) = 0;
  uint64_t result = std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)(v4 + 72), *(const void **)(a2 + 72), *(void *)(a2 + 80), *(void *)(a2 + 80) - *(void *)(a2 + 72));
  a1[2] += 96;
  return result;
}

uint64_t std::vector<Nightingale::cycleInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = (uint64_t)(a1 + 2);
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>,std::reverse_iterator<Nightingale::cycleInfo*>>((uint64_t)(a1 + 2), a3, a3, *a1, *a1, v6, v6);
  a2[1] = v8;
  a2[2] = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*,Nightingale::cycleInfo*,Nightingale::cycleInfo*>(v7, a3, a1[1], a2[2]);
  uint64_t v9 = *a1;
  *a1 = a2[1];
  a2[1] = v9;
  uint64_t v10 = a1[1];
  a1[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = a1[2];
  a1[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_backward_loop<std::_ClassicAlgPolicy>,std::__move_backward_trivial>,Nightingale::cycleInfo *,Nightingale::cycleInfo *,Nightingale::cycleInfo *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a1)
  {
    uint64_t v5 = a2;
    do
    {
      uint64_t v6 = v5 - 96;
      uint64_t v7 = a3 - 96;
      *(_OWORD *)(a3 - 96) = *(_OWORD *)(v5 - 96);
      long long v8 = *(_OWORD *)(v5 - 80);
      long long v9 = *(_OWORD *)(v5 - 64);
      long long v10 = *(_OWORD *)(v5 - 48);
      *(void *)(a3 - 35) = *(void *)(v5 - 35);
      *(_OWORD *)(a3 - 64) = v9;
      *(_OWORD *)(a3 - 48) = v10;
      *(_OWORD *)(a3 - 80) = v8;
      std::vector<float>::__move_assign(a3 - 24, (__n128 *)(v5 - 24));
      a3 = v7;
      uint64_t v5 = v6;
    }
    while (v6 != a1);
  }
  return a2;
}

uint64_t std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,Nightingale::cycleInfo *,Nightingale::cycleInfo *,Nightingale::cycleInfo *,0>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1;
  if (a1 == a2) {
    return a1;
  }
  uint64_t v5 = a2;
  do
  {
    *(_OWORD *)a3 = *(_OWORD *)v4;
    long long v6 = *(_OWORD *)(v4 + 16);
    long long v7 = *(_OWORD *)(v4 + 32);
    long long v8 = *(_OWORD *)(v4 + 48);
    *(void *)(a3 + 61) = *(void *)(v4 + 61);
    *(_OWORD *)(a3 + 32) = v7;
    *(_OWORD *)(a3 + 48) = v8;
    *(_OWORD *)(a3 + 16) = v6;
    std::vector<float>::__move_assign(a3 + 72, (__n128 *)(v4 + 72));
    a3 += 96;
    v4 += 96;
  }
  while (v4 != v5);
  return v5;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*,Nightingale::cycleInfo*,Nightingale::cycleInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v12 = a4;
  uint64_t v11 = a4;
  v9[0] = a1;
  v9[1] = &v11;
  id v9[2] = &v12;
  if (a2 != a3)
  {
    do
    {
      *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
      long long v5 = *(_OWORD *)(a2 + 16);
      long long v6 = *(_OWORD *)(a2 + 32);
      long long v7 = *(_OWORD *)(a2 + 48);
      *(void *)(v4 + 61) = *(void *)(a2 + 61);
      *(_OWORD *)(v4 + 32) = v6;
      *(_OWORD *)(v4 + 48) = v7;
      *(_OWORD *)(v4 + 16) = v5;
      *(void *)(v4 + 80) = 0;
      *(void *)(v4 + 88) = 0;
      *(void *)(v4 + 72) = 0;
      *(_OWORD *)(v4 + 72) = *(_OWORD *)(a2 + 72);
      *(void *)(v4 + 88) = *(void *)(a2 + 88);
      *(void *)(a2 + 72) = 0;
      *(void *)(a2 + 80) = 0;
      *(void *)(a2 + 88) = 0;
      v4 += 96;
      a2 += 96;
    }
    while (a2 != a3);
    uint64_t v12 = v4;
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::cycleInfo>,Nightingale::cycleInfo*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void *std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100](void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  std::vector<Nightingale::PhaseSet>::__init_with_size[abi:ne180100]<std::__wrap_iter<Nightingale::PhaseSet*>,std::__wrap_iter<Nightingale::PhaseSet*>>(a1 + 3, *(const void **)(a2 + 24), *(void *)(a2 + 32), (uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3);
  return a1;
}

void sub_257D41A6C(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<float>,false>>(uint64_t a1, __n128 *a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == a2[1].n128_u8[8])
  {
    if (*(unsigned char *)(a1 + 24))
    {
      result.n128_u64[0] = std::vector<float>::__move_assign(a1, a2).n128_u64[0];
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    uint64_t v4 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v4;
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    __n128 result = *a2;
    *(__n128 *)a1 = *a2;
    *(void *)(a1 + 16) = a2[1].n128_u64[0];
    a2->n128_u64[0] = 0;
    a2->n128_u64[1] = 0;
    a2[1].n128_u64[0] = 0;
    *(unsigned char *)(a1 + 24) = 1;
  }
  return result;
}

uint64_t std::construct_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t const&,Nightingale::coreAnalyticsHistPerCycle_t*>(uint64_t a1, long long *a2)
{
  long long v4 = *a2;
  long long v5 = a2[1];
  *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  std::__optional_copy_base<std::vector<float>,false>::__optional_copy_base[abi:ne180100](a1 + 40, (uint64_t)a2 + 40);
  std::__optional_copy_base<std::vector<float>,false>::__optional_copy_base[abi:ne180100](a1 + 72, (uint64_t)a2 + 72);
  long long v6 = *(long long *)((char *)a2 + 104);
  *(void *)(a1 + 118) = *(void *)((char *)a2 + 118);
  *(_OWORD *)(a1 + 104) = v6;
  return a1;
}

void sub_257D41B8C(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 64))
  {
    long long v4 = *v2;
    if (*v2)
    {
      *(void *)(v1 + 48) = v4;
      operator delete(v4);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__optional_copy_base<std::vector<float>,false>::__optional_copy_base[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(unsigned char *)(a1 + 24) = 0;
  std::__optional_storage_base<std::vector<float>,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::vector<float>,false> const&>((void *)a1, a2);
  return a1;
}

void sub_257D41BE0(_Unwind_Exception *exception_object)
{
  if (*(unsigned char *)(v1 + 24)) {
    std::__optional_copy_base<std::vector<float>,false>::__optional_copy_base[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__optional_storage_base<std::vector<float>,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::vector<float>,false> const&>(void *result, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 24))
  {
    uint64_t v2 = result;
    *__n128 result = 0;
    result[1] = 0;
    result[2] = 0;
    __n128 result = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(result, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *((unsigned char *)v2 + 24) = 1;
  }
  return result;
}

void std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  long long v5 = (long long *)*a1;
  long long v4 = (long long *)a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 128;
    v4 -= 8;
    std::construct_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t*>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::coreAnalyticsHistPerCycle_t>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 57) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(a2 << 7);
}

__n128 std::construct_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t,Nightingale::coreAnalyticsHistPerCycle_t*>(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  long long v3 = a2[1];
  *(unsigned char *)(a1 + 32) = *((unsigned char *)a2 + 32);
  *(_OWORD *)a1 = v2;
  *(_OWORD *)(a1 + 16) = v3;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  if (*((unsigned char *)a2 + 64))
  {
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(_OWORD *)(a1 + 40) = *(long long *)((char *)a2 + 40);
    *(void *)(a1 + 56) = *((void *)a2 + 7);
    *((void *)a2 + 5) = 0;
    *((void *)a2 + 6) = 0;
    *((void *)a2 + 7) = 0;
    *(unsigned char *)(a1 + 64) = 1;
  }
  *(unsigned char *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 96) = 0;
  if (*((unsigned char *)a2 + 96))
  {
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 72) = *(long long *)((char *)a2 + 72);
    *(void *)(a1 + 88) = *((void *)a2 + 11);
    *((void *)a2 + 9) = 0;
    *((void *)a2 + 10) = 0;
    *((void *)a2 + 11) = 0;
    *(unsigned char *)(a1 + 96) = 1;
  }
  __n128 result = *(__n128 *)((char *)a2 + 104);
  *(void *)(a1 + 118) = *(void *)((char *)a2 + 118);
  *(__n128 *)(a1 + 104) = result;
  return result;
}

void std::__destroy_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,0>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 96))
  {
    long long v2 = *(void **)(a1 + 72);
    if (v2)
    {
      *(void *)(a1 + 80) = v2;
      operator delete(v2);
    }
  }
  if (*(unsigned char *)(a1 + 64))
  {
    long long v3 = *(void **)(a1 + 40);
    if (v3)
    {
      *(void *)(a1 + 48) = v3;
      operator delete(v3);
    }
  }
}

uint64_t std::__split_buffer<Nightingale::coreAnalyticsHistPerCycle_t>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 128;
    std::__destroy_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,0>(i - 128);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<Nightingale::ngt_HistoricCycle>::__construct_one_at_end[abi:ne180100]<Nightingale::ngt_HistoricCycle const&>(uint64_t a1, long long *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  long long v5 = *a2;
  *(_OWORD *)(v4 + 9) = *(long long *)((char *)a2 + 9);
  *(_OWORD *)uint64_t v4 = v5;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  *(void *)(v4 + 32) = 0;
  __n128 result = std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)(v4 + 32), *((const void **)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 5) - *((void *)a2 + 4));
  uint64_t v7 = *((void *)a2 + 7);
  *(_DWORD *)(v4 + 64) = *((_DWORD *)a2 + 16);
  *(void *)(v4 + 56) = v7;
  *(void *)(a1 + 8) = v4 + 72;
  return result;
}

void sub_257D41EDC(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<Nightingale::ngt_HistoricCycle>::__push_back_slow_path<Nightingale::ngt_HistoricCycle const&>(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0x8E38E38E38E38E39 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x38E38E38E38E38ELL) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x8E38E38E38E38E39 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x1C71C71C71C71C7) {
    unint64_t v9 = 0x38E38E38E38E38ELL;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v20 = a1 + 2;
  if (v9) {
    char v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_HistoricCycle>>(v7, v9);
  }
  else {
    char v10 = 0;
  }
  uint64_t v11 = &v10[72 * v4];
  v17[0] = v10;
  v17[1] = v11;
  size_t v18 = v11;
  unint64_t v19 = &v10[72 * v9];
  long long v12 = *a2;
  *(_OWORD *)(v11 + 9) = *(long long *)((char *)a2 + 9);
  *(_OWORD *)uint64_t v11 = v12;
  *((void *)v11 + 5) = 0;
  *((void *)v11 + 6) = 0;
  *((void *)v11 + 4) = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>((void *)v11 + 4, *((const void **)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 5) - *((void *)a2 + 4));
  uint64_t v13 = &v10[72 * v4];
  uint64_t v14 = *((void *)a2 + 7);
  *((_DWORD *)v13 + 16) = *((_DWORD *)a2 + 16);
  *((void *)v13 + 7) = v14;
  v18 += 72;
  std::vector<Nightingale::ngt_HistoricCycle>::__swap_out_circular_buffer(a1, v17);
  uint64_t v15 = a1[1];
  std::__split_buffer<Nightingale::ngt_HistoricCycle>::~__split_buffer((uint64_t)v17);
  return v15;
}

void sub_257D42024(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Nightingale::ngt_HistoricCycle>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Nightingale::ngt_HistoricCycle>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_HistoricCycle>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(72 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _OWORD v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      long long v8 = *(_OWORD *)(a3 - 72);
      *(_OWORD *)(v7 - 63) = *(_OWORD *)(a3 - 63);
      *(_OWORD *)(v7 - 72) = v8;
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 40) = 0;
      *(_OWORD *)(v7 - 40) = *(_OWORD *)(a3 - 40);
      *(void *)(v7 - 24) = *(void *)(a3 - 24);
      *(void *)(a3 - 40) = 0;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 24) = 0;
      uint64_t v9 = *(void *)(a3 - 16);
      *(_DWORD *)(v7 - 8) = *(_DWORD *)(a3 - 8);
      *(void *)(v7 - 16) = v9;
      uint64_t v7 = *((void *)&v15 + 1) - 72;
      *((void *)&v15 + 1) -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Nightingale::ngt_HistoricCycle>,std::reverse_iterator<Nightingale::ngt_HistoricCycle*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)(v1 + 32);
    if (v3)
    {
      *(void *)(v1 + 40) = v3;
      operator delete(v3);
    }
    v1 += 72;
  }
}

uint64_t std::__split_buffer<Nightingale::ngt_HistoricCycle>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<Nightingale::ngt_HistoricCycle>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    *(void *)(a1 + 16) = v2 - 72;
    uint64_t v5 = *(void **)(v2 - 40);
    if (v5)
    {
      *(void *)(v2 - 32) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 72;
    }
  }
}

void std::vector<Nightingale::coreAnalyticsHistPerCycle_t>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 128;
        std::__destroy_at[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<Nightingale::ngt_HistoricCycle>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<Nightingale::ngt_HistoricCycle>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<Nightingale::ngt_HistoricCycle>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72)
  {
    uint64_t v4 = *(void **)(i - 40);
    if (v4)
    {
      *(void *)(i - 32) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

long long *std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Nightingale::coreAnalyticsHistPerCycle_t *,Nightingale::coreAnalyticsHistPerCycle_t *,Nightingale::coreAnalyticsHistPerCycle_t *>(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t v4 = a3;
  do
  {
    long long v5 = *a2;
    long long v6 = a2[1];
    *(unsigned char *)(a4 + 32) = *((unsigned char *)a2 + 32);
    *(_OWORD *)a4 = v5;
    *(_OWORD *)(a4 + 16) = v6;
    uint64_t v7 = a4 + 40;
    uint64_t v8 = (uint64_t)a2 + 40;
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<float>,false>>(a4 + 40, (__n128 *)((char *)a2 + 40));
    v7 += 32;
    v8 += 32;
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_move_assign_base<std::vector<float>,false>>(v7, (__n128 *)v8);
    long long v9 = *(_OWORD *)(v8 + 32);
    *(void *)(v7 + 46) = *(void *)(v8 + 46);
    *(_OWORD *)(v7 + 32) = v9;
    a2 = (long long *)(v8 + 56);
    a4 = v7 + 56;
  }
  while ((long long *)(v8 + 56) != v4);
  return v4;
}

void __71__model_fwEnd_10pct_loadContentsOfURL_configuration_completionHandler___block_invoke(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    uint64_t v3 = [[model_fwEnd_10pct alloc] initWithMLModel:v4];
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void __62__model_fwEnd_10pct_predictionFromFeatures_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    long long v6 = [model_fwEnd_10pctOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    uint64_t v8 = [v7 multiArrayValue];
    long long v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    uint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    long long v12 = [v11 multiArrayValue];
    char v13 = [(model_fwEnd_10pctOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    long long v15 = *(void (**)(uint64_t, void, model_fwEnd_10pctOutput *))(v14 + 16);
    char v13 = a3;
    v15(v14, 0, v13);
  }
}

void __70__model_fwEnd_10pct_predictionFromFeatures_options_completionHandler___block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  if (v16)
  {
    id v5 = a3;
    long long v6 = [model_fwEnd_10pctOutput alloc];
    uint64_t v7 = [v16 featureValueForName:@"out"];
    uint64_t v8 = [v7 multiArrayValue];
    long long v9 = [v16 featureValueForName:@"lstm_1_h_out"];
    uint64_t v10 = [v9 multiArrayValue];
    uint64_t v11 = [v16 featureValueForName:@"lstm_1_c_out"];
    long long v12 = [v11 multiArrayValue];
    char v13 = [(model_fwEnd_10pctOutput *)v6 initWithOut:v8 lstm_1_h_out:v10 lstm_1_c_out:v12];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    uint64_t v14 = *(void *)(a1 + 32);
    long long v15 = *(void (**)(uint64_t, void, model_fwEnd_10pctOutput *))(v14 + 16);
    char v13 = a3;
    v15(v14, 0, v13);
  }
}

void Nightingale::fwHEstimation::processPerCycle(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X3>, int a4@<W4>, uint64_t *a5@<X5>, uint64_t *a6@<X6>, int a7@<W7>, uint64_t a8@<X8>, const Nightingale::ngt_Config *a9)
{
  Nightingale::fwEstimatorCalendar::fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v69);
  Nightingale::fwEstimatorOPK::fwEstimatorOPK((Nightingale::fwEstimatorOPK *)v68);
  uint64_t v15 = Nightingale::fwEstimatorLuna::fwEstimatorLuna((Nightingale::fwEstimatorLuna *)v67, a9);
  *(unsigned char *)a8 = 0;
  *(unsigned char *)(a8 + 4) = 0;
  *(unsigned char *)(a8 + 8) = 0;
  *(unsigned char *)(a8 + 12) = 0;
  *(void *)(a8 + 20) = 0;
  uint64_t v27 = (_DWORD *)(a8 + 20);
  *(_DWORD *)(a8 + 16) = 3;
  *(unsigned char *)(a8 + 32) = 0;
  id v16 = (_OWORD *)(a8 + 32);
  *(_WORD *)(a8 + 28) = 0;
  *(int32x4_t *)(a8 + 36) = vdupq_n_s32(0x7FC00000u);
  *(unsigned char *)(a8 + 52) = 0;
  *(unsigned char *)(a8 + 56) = 0;
  *(unsigned char *)(a8 + 60) = 0;
  *(unsigned char *)(a8 + 64) = 0;
  *(unsigned char *)(a8 + 72) = 0;
  *(unsigned char *)(a8 + 96) = 0;
  *(unsigned char *)(a8 + 104) = 0;
  *(unsigned char *)(a8 + 128) = 0;
  *(unsigned char *)(a8 + 136) = 0;
  uint64_t v17 = (float *)(a8 + 136);
  *(unsigned char *)(a8 + 140) = 0;
  *(void *)(a8 + 144) = 0x17FC00000;
  *(_DWORD *)(a8 + 152) = 0;
  *(_WORD *)(a8 + 156) = 0;
  if (!*(unsigned char *)(a1 + 24)) {
    goto LABEL_50;
  }
  long long v29 = (int *)a1;
  unint64_t JDayCycleEnd = Nightingale::fwEstimatorLuna::getJDayCycleEnd(v15, a1);
  std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100](v55, (uint64_t)a5);
  Nightingale::fwEstimatorLuna::getHistFwKali((uint64_t)v67, (uint64_t)v29, a2, a3, a4, (uint64_t *)v55, JDayCycleEnd, a6, (uint64_t)v58, a7);
  if (__p)
  {
    uint64_t v57 = __p;
    operator delete(__p);
  }
  if (v55[0])
  {
    v55[1] = v55[0];
    operator delete(v55[0]);
  }
  std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100](v43, (uint64_t)a5);
  Nightingale::fwEstimatorOPK::getHistFwOpk((uint64_t)v68, (uint64_t)v29, (uint64_t *)v43, JDayCycleEnd, (uint64_t)v46);
  if (v44)
  {
    uint64_t v45 = v44;
    operator delete(v44);
  }
  if (v43[0])
  {
    v43[1] = v43[0];
    operator delete(v43[0]);
  }
  std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100](v31, (uint64_t)a5);
  Nightingale::fwEstimatorCalendar::getHistFwCal((uint64_t)v69, v29, JDayCycleEnd, (uint64_t *)v31, (uint64_t)v34);
  if (v32)
  {
    int64x2_t v33 = v32;
    operator delete(v32);
  }
  if (v31[0])
  {
    v31[1] = v31[0];
    operator delete(v31[0]);
  }
  if (*(_DWORD *)&v46[16])
  {
    if (!v58[12])
    {
      *(_OWORD *)a8 = *(_OWORD *)v34;
      *(_OWORD *)(a8 + 14) = *(_OWORD *)&v34[14];
      long long v24 = v36;
      *id v16 = v35;
      *(_OWORD *)(a8 + 48) = v24;
      *(unsigned char *)(a8 + 64) = v37;
      std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 72, (uint64_t)v38);
      std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 104, (uint64_t)v40);
      *(_OWORD *)uint64_t v17 = *(_OWORD *)v42;
      *(void *)(a8 + 150) = *(void *)&v42[14];
      *uint64_t v27 = *(_DWORD *)&v58[20];
      goto LABEL_20;
    }
    long long v19 = v59;
    *(_OWORD *)a8 = *(_OWORD *)v58;
    *(_OWORD *)(a8 + 14) = *(_OWORD *)&v58[14];
    long long v20 = v60;
    *id v16 = v19;
    *(_OWORD *)(a8 + 48) = v20;
    *(unsigned char *)(a8 + 64) = v61;
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 72, (uint64_t)v62);
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 104, (uint64_t)v64);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v66;
    uint64_t v21 = *(void *)&v66[14];
  }
  else
  {
    long long v22 = v47;
    *(_OWORD *)a8 = *(_OWORD *)v46;
    *(_OWORD *)(a8 + 14) = *(_OWORD *)&v46[14];
    long long v23 = v48;
    *id v16 = v22;
    *(_OWORD *)(a8 + 48) = v23;
    *(unsigned char *)(a8 + 64) = v49;
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 72, (uint64_t)v50);
    std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 104, (uint64_t)v52);
    *(_OWORD *)uint64_t v17 = *(_OWORD *)v54;
    uint64_t v21 = *(void *)&v54[14];
  }
  *(void *)(a8 + 150) = v21;
LABEL_20:
  long long v25 = v60;
  *id v16 = v59;
  *(_OWORD *)(a8 + 48) = v25;
  *(unsigned char *)(a8 + 64) = v61;
  std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 72, (uint64_t)v62);
  std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(a8 + 104, (uint64_t)v64);
  *(_OWORD *)uint64_t v17 = *(_OWORD *)v66;
  *(void *)(a8 + 150) = *(void *)&v66[14];
  *(_DWORD *)(a8 + 24) = *(_DWORD *)&v58[24];
  Nightingale::fwEstimatorLuna::updateAFwCycleFactorCAItems(v67, a8, (unsigned int *)v29, a5, a7, a2);
  if (!*(_DWORD *)(a8 + 16))
  {
    *(_DWORD *)(a8 + 148) = 0;
    *(_DWORD *)(a8 + 20) = 0;
  }
  if (v46[12] && v58[12])
  {
    if (!*(unsigned char *)(a8 + 12)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    int v26 = *(_DWORD *)&v58[8] - *(_DWORD *)(a8 + 8);
    if (!*(unsigned char *)(a8 + 140)) {
      *(unsigned char *)(a8 + 140) = 1;
    }
    *uint64_t v17 = (float)v26;
  }
  if (v46[29] || v34[29] || v58[29]) {
    *uint64_t v27 = 3;
  }
  if (v41 && v40[0])
  {
    v40[1] = v40[0];
    operator delete(v40[0]);
  }
  if (v39 && v38[0])
  {
    v38[1] = v38[0];
    operator delete(v38[0]);
  }
  if (v53 && v52[0])
  {
    v52[1] = v52[0];
    operator delete(v52[0]);
  }
  if (v51 && v50[0])
  {
    v50[1] = v50[0];
    operator delete(v50[0]);
  }
  if (v65 && v64[0])
  {
    v64[1] = v64[0];
    operator delete(v64[0]);
  }
  if (v63 && v62[0])
  {
    v62[1] = v62[0];
    operator delete(v62[0]);
  }
LABEL_50:
  Nightingale::fwEstimatorLuna::~fwEstimatorLuna((Nightingale::fwEstimatorLuna *)v67);
  Nightingale::fwEstimatorOPK::~fwEstimatorOPK((Nightingale::fwEstimatorOPK *)v68);
  Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)v69);
}

void sub_257D43C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle((Nightingale::fwEstimatorHistOutACycle *)&a20);
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle((Nightingale::fwEstimatorHistOutACycle *)&a46);
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle((Nightingale::fwEstimatorHistOutACycle *)&a72);
  Nightingale::fwEstimatorHistOutACycle::~fwEstimatorHistOutACycle(v72);
  Nightingale::fwEstimatorLuna::~fwEstimatorLuna((Nightingale::fwEstimatorLuna *)(v73 - 184));
  Nightingale::fwEstimatorOPK::~fwEstimatorOPK((Nightingale::fwEstimatorOPK *)(v73 - 136));
  Nightingale::fwEstimatorCalendar::~fwEstimatorCalendar((Nightingale::fwEstimatorCalendar *)(v73 - 112));
  _Unwind_Resume(a1);
}

void std::__optional_storage_base<std::vector<float>,false>::__assign_from[abi:ne180100]<std::__optional_copy_assign_base<std::vector<float>,false> const&>(uint64_t a1, uint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 24) == *(unsigned __int8 *)(a2 + 24))
  {
    if (a1 != a2 && *(unsigned char *)(a1 + 24))
    {
      uint64_t v3 = *(void *)(a2 + 8);
      unint64_t v4 = (v3 - *(void *)a2) >> 2;
      id v5 = *(char **)a2;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1, v5, v3, v4);
    }
  }
  else if (*(unsigned char *)(a1 + 24))
  {
    long long v6 = *(void **)a1;
    if (*(void *)a1)
    {
      *(void *)(a1 + 8) = v6;
      operator delete(v6);
    }
    *(unsigned char *)(a1 + 24) = 0;
  }
  else
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a1, *(const void **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
    *(unsigned char *)(a1 + 24) = 1;
  }
}

void deviationInput(NgtMenstrualAlgorithmsDeviationInput *a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = a1;
  *a2 = 0;
  a2[4] = 0;
  a2[8] = 0;
  a2[12] = 0;
  a2[16] = 0;
  a2[20] = 0;
  a2[24] = 0;
  a2[28] = 0;
  a2[32] = 0;
  a2[36] = 0;
  a2[40] = 0;
  a2[44] = 0;
  a2[48] = 0;
  a2[52] = 0;
  a2[56] = 0;
  a2[60] = 0;
  if (v3)
  {
    long long v20 = v3;
    unint64_t v4 = [(NgtMenstrualAlgorithmsDeviationInput *)v3 julianDayMinAnalysisWindowStartIrregular];
    uint64_t v5 = julianDayMinAnalysisWindow(v4);
    *(_DWORD *)a2 = v5;
    a2[4] = BYTE4(v5);

    long long v6 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowEndIrregular];
    uint64_t v7 = julianDayMinAnalysisWindow(v6);
    *((_DWORD *)a2 + 8) = v7;
    a2[36] = BYTE4(v7);

    uint64_t v8 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowStartInfrequent];
    uint64_t v9 = julianDayMinAnalysisWindow(v8);
    *((_DWORD *)a2 + 2) = v9;
    a2[12] = BYTE4(v9);

    uint64_t v10 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowEndInfrequent];
    uint64_t v11 = julianDayMinAnalysisWindow(v10);
    *((_DWORD *)a2 + 10) = v11;
    a2[44] = BYTE4(v11);

    long long v12 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowStartProlonged];
    uint64_t v13 = julianDayMinAnalysisWindow(v12);
    *((_DWORD *)a2 + 4) = v13;
    a2[20] = BYTE4(v13);

    uint64_t v14 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowEndProlonged];
    uint64_t v15 = julianDayMinAnalysisWindow(v14);
    *((_DWORD *)a2 + 12) = v15;
    a2[52] = BYTE4(v15);

    id v16 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowStartSpotting];
    uint64_t v17 = julianDayMinAnalysisWindow(v16);
    *((_DWORD *)a2 + 6) = v17;
    a2[28] = BYTE4(v17);

    size_t v18 = [(NgtMenstrualAlgorithmsDeviationInput *)v20 julianDayMinAnalysisWindowEndSpotting];
    uint64_t v19 = julianDayMinAnalysisWindow(v18);
    *((_DWORD *)a2 + 14) = v19;
    a2[60] = BYTE4(v19);

    uint64_t v3 = v20;
  }
}

void sub_257D43F30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t julianDayMinAnalysisWindow(NSNumber *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    unsigned int v3 = [(NSNumber *)v1 unsignedIntValue];
    unsigned int v4 = v3 & 0xFFFFFF00;
    int v5 = v3;
    uint64_t v6 = 0x100000000;
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = 0;
    unsigned int v4 = 0;
  }

  return v6 | v4 | v5;
}

void sub_257D43FE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id deviation(uint64_t a1)
{
  if (!*(unsigned char *)a1 || (*(_DWORD *)(a1 + 4) & 0x80000000) != 0 || (*(_DWORD *)(a1 + 8) & 0x80000000) != 0)
  {
    uint64_t v2 = 0;
  }
  else
  {
    uint64_t v2 = objc_opt_new();
    [v2 setJulianDayOfAnalysisWindowStart:*(unsigned int *)(a1 + 4)];
    [v2 setJulianDayOfAnalysisWindowEnd:*(unsigned int *)(a1 + 8)];
  }
  return v2;
}

void sub_257D44070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id deviationAnalysis(uint64_t a1)
{
  uint64_t v2 = objc_opt_new();
  unsigned int v3 = deviation(a1);
  [v2 setIrregularBleeding:v3];

  unsigned int v4 = deviation(a1 + 12);
  [v2 setInfrequentBleeding:v4];

  int v5 = deviation(a1 + 24);
  [v2 setProlongedBleeding:v5];

  uint64_t v6 = deviation(a1 + 36);
  [v2 setSpotting:v6];

  return v2;
}

void sub_257D4414C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D44300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D44530(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D447F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D44AEC(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D44EA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D45134(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D452F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D453AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D454A8(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D456E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D45A30(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D4600C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D467B8(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D46BD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D46C8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_257D46D94(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D4708C(_Unwind_Exception *a1)
{
  int v5 = v4;

  _Unwind_Resume(a1);
}

void sub_257D473B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D47694(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D477C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D47954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D47B74(_Unwind_Exception *a1)
{
  int v5 = v4;

  _Unwind_Resume(a1);
}

void sub_257D47D38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v11 = v10;

  _Unwind_Resume(a1);
}

void sub_257D48168(_Unwind_Exception *a1)
{
  unsigned int v4 = v3;

  _Unwind_Resume(a1);
}

void sub_257D48388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D487E4(_Unwind_Exception *a1)
{
  int v5 = v4;

  _Unwind_Resume(a1);
}

void sub_257D48A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D48D0C(_Unwind_Exception *a1)
{
  int v5 = v3;

  _Unwind_Resume(a1);
}

void sub_257D48E44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D49634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, std::__split_buffer<std::string> *a6, uint64_t a7, void *__p, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, void *__pa,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,...)
{
  va_start(va, a30);

  Nightingale::ngt_Config::~ngt_Config((void **)va);
  _Unwind_Resume(a1);
}

void sub_257D49864(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D49A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void convert_day_input(NgtMenstrualAlgorithmsDayInput *a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  int v5 = a1;
  *(_DWORD *)(a3 + 12) = 0;
  *(unsigned char *)(a3 + 16) = 0;
  *(unsigned char *)(a3 + 20) = 0;
  *(unsigned char *)(a3 + 24) = 0;
  *(unsigned char *)(a3 + 28) = 0;
  *(unsigned char *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 36) = 0;
  *(unsigned char *)(a3 + 40) = 0;
  *(unsigned char *)(a3 + 44) = 0;
  *(unsigned char *)(a3 + 48) = 0;
  *(unsigned char *)(a3 + 56) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 8) = 0;
  uint64_t v21 = v5;
  *(_DWORD *)a3 = [(NgtMenstrualAlgorithmsDayInput *)v5 julianDay];
  *(_DWORD *)(a3 + 4) = [(NgtMenstrualAlgorithmsDayInput *)v21 flow];
  *(unsigned char *)(a3 + 8) = [(NgtMenstrualAlgorithmsDayInput *)v21 spotting];
  *(_DWORD *)(a3 + 12) = [(NgtMenstrualAlgorithmsDayInput *)v21 ovulationTestResult];
  uint64_t v6 = [(NgtMenstrualAlgorithmsDayInput *)v21 sedentaryHeartRateStatistics];
  uint64_t v7 = [v6 lowerPercentile];

  if (v7)
  {
    uint64_t v8 = [v6 lowerPercentile];
    [v8 floatValue];
    *(_DWORD *)(a3 + 16) = v9;
    *(unsigned char *)(a3 + 20) = 1;

    int v10 = [v6 sampleCount];
    *(unsigned char *)(a3 + 36) = 1;
    *(_DWORD *)(a3 + 32) = v10;
  }
  else
  {
    *(_DWORD *)(a3 + 32) = 0;
    *(unsigned char *)(a3 + 36) = 1;
  }

  uint64_t v11 = [(NgtMenstrualAlgorithmsDayInput *)v21 sleepHeartRateStatistics];
  long long v12 = [v11 lowerPercentile];

  if (v12)
  {
    uint64_t v13 = [v11 lowerPercentile];
    [v13 floatValue];
    *(_DWORD *)(a3 + 24) = v14;
    *(unsigned char *)(a3 + 28) = 1;

    int v15 = [v11 sampleCount];
    *(unsigned char *)(a3 + 44) = 1;
    *(_DWORD *)(a3 + 40) = v15;
  }
  else
  {
    *(_DWORD *)(a3 + 40) = 0;
    *(unsigned char *)(a3 + 44) = 1;
  }

  id v16 = [(NgtMenstrualAlgorithmsDayInput *)v21 wristTemperature];

  if (v16)
  {
    uint64_t v17 = [(NgtMenstrualAlgorithmsDayInput *)v21 wristTemperature];
    [v17 temperatureCelsius];
    double v19 = v18;

    float v20 = v19;
    *(_DWORD *)(a3 + 48) = a2;
    *(float *)(a3 + 52) = v20;
    *(unsigned char *)(a3 + 56) = 1;
  }
}

void sub_257D49C2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D49D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D4A858(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::pair<std::vector<float>,std::vector<float>>::~pair((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_257D4ADF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  uint64_t v7 = v6;
  MEMORY[0x25A2C1380](v7, 0x10B2C40BD969C95);
  Nightingale::ngt_Config::~ngt_Config((void **)va);

  _Unwind_Resume(a1);
}

void sub_257D4AF24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_257D4B0C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D4B1B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_257D4B46C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    uint64_t v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    uint64_t v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      unint64_t v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);
  return std::string::__assign_external(this, __s, v4);
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  std::vector<int>::pointer begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  std::vector<int>::pointer end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  Swift::Float value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  _OWORD v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      int v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        int v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void *std::string::basic_string[abi:ne180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    unint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    unint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

Nightingale::ngt_DayStreamProcessor *std::unique_ptr<Nightingale::ngt_DayStreamProcessor>::reset[abi:ne180100](Nightingale::ngt_DayStreamProcessor **a1, Nightingale::ngt_DayStreamProcessor *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    Nightingale::ngt_DayStreamProcessor::~ngt_DayStreamProcessor(result);
    JUMPOUT(0x25A2C1380);
  }
  return result;
}

Nightingale::ngt_HistoricalAnalyzer *std::unique_ptr<Nightingale::ngt_HistoricalAnalyzer>::reset[abi:ne180100](Nightingale::ngt_HistoricalAnalyzer **a1, Nightingale::ngt_HistoricalAnalyzer *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    Nightingale::ngt_HistoricalAnalyzer::~ngt_HistoricalAnalyzer(result);
    JUMPOUT(0x25A2C1380);
  }
  return result;
}

Nightingale::ngt_DayStreamProcessor *Nightingale::ngt_DayStreamProcessor::ngt_DayStreamProcessor(Nightingale::ngt_DayStreamProcessor *this, Nightingale::ngt_Config *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *((void *)this + 14) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  Nightingale::ngt_Config::ngt_Config((Nightingale::ngt_DayStreamProcessor *)((char *)this + 120), a2);
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 29) = 0u;
  *((void *)this + 60) = (char *)this + 488;
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
  {
    char v6 = 6;
    strcpy((char *)__p, "4.12.1");
    *(_DWORD *)buf = 136315138;
    uint64_t v8 = __p;
    _os_log_impl(&dword_257C1A000, log, OS_LOG_TYPE_DEFAULT, "\"DayStreamProcessor\": \"%s\",\n", buf, 0xCu);
    if (v6 < 0) {
      operator delete(__p[0]);
    }
  }
  return this;
}

void sub_257D4BB14(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy(v3, *(void **)(v1 + 488));
  char v6 = *(void **)(v1 + 456);
  if (v6)
  {
    *(void *)(v1 + 464) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v4;
  if (*v4)
  {
    *(void *)(v1 + 440) = v7;
    operator delete(v7);
  }
  Nightingale::ngt_Config::~ngt_Config(v2);
  std::pair<std::vector<float>,std::vector<float>>::~pair(v1 + 72);
  uint64_t v8 = *(void **)(v1 + 48);
  if (v8)
  {
    *(void *)(v1 + 56) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(void **)(v1 + 24);
  if (v9)
  {
    *(void *)(v1 + 32) = v9;
    operator delete(v9);
  }
  long long v10 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v10;
    operator delete(v10);
  }
  _Unwind_Resume(a1);
}

void Nightingale::ngt_DayStreamProcessor::~ngt_DayStreamProcessor(Nightingale::ngt_DayStreamProcessor *this)
{
  std::__tree<std::__value_type<int,std::array<short,9ul>>,std::__map_value_compare<int,std::__value_type<int,std::array<short,9ul>>,std::less<int>,true>,std::allocator<std::__value_type<int,std::array<short,9ul>>>>::destroy((uint64_t)this + 480, *((void **)this + 61));
  uint64_t v2 = (void *)*((void *)this + 57);
  if (v2)
  {
    *((void *)this + 58) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 54);
  if (v3)
  {
    *((void *)this + 55) = v3;
    operator delete(v3);
  }
  Nightingale::ngt_Config::~ngt_Config((void **)this + 15);
  size_t v4 = (void *)*((void *)this + 12);
  if (v4)
  {
    *((void *)this + 13) = v4;
    operator delete(v4);
  }
  size_t v5 = (void *)*((void *)this + 9);
  if (v5)
  {
    *((void *)this + 10) = v5;
    operator delete(v5);
  }
  char v6 = (void *)*((void *)this + 6);
  if (v6)
  {
    *((void *)this + 7) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 3);
  if (v7)
  {
    *((void *)this + 4) = v7;
    operator delete(v7);
  }
  uint64_t v8 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v8;
    operator delete(v8);
  }
}

void Nightingale::ngt_DayStreamProcessor::appendDay(void **a1, long long *a2)
{
  uint64_t v3 = (char *)*a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * (((char *)v2 - (unsigned char *)*a1) >> 2);
  if (v4 <= 0x2AC5)
  {
    unint64_t v9 = (unint64_t)a1[2];
    uint64_t v7 = (uint64_t)(a1 + 2);
    unint64_t v8 = v9;
    if ((unint64_t)v2 >= v9)
    {
      unint64_t v14 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v8 - (void)v3) >> 2);
      if (2 * v14 <= v4 + 1) {
        uint64_t v15 = v4 + 1;
      }
      else {
        uint64_t v15 = 2 * v14;
      }
      if (v14 >= 0x222222222222222) {
        unint64_t v16 = 0x444444444444444;
      }
      else {
        unint64_t v16 = v15;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_DayInput>>(v7, v16);
      double v18 = &v17[60 * v4];
      float v20 = &v17[60 * v19];
      long long v21 = *a2;
      long long v22 = a2[1];
      long long v23 = a2[2];
      *(_OWORD *)(v18 + 44) = *(long long *)((char *)a2 + 44);
      *((_OWORD *)v18 + 1) = v22;
      *((_OWORD *)v18 + 2) = v23;
      *(_OWORD *)double v18 = v21;
      char v13 = v18 + 60;
      long long v25 = (char *)*a1;
      long long v24 = (char *)a1[1];
      if (v24 != *a1)
      {
        do
        {
          long long v26 = *(_OWORD *)(v24 - 60);
          long long v27 = *(_OWORD *)(v24 - 44);
          long long v28 = *(_OWORD *)(v24 - 28);
          *((_OWORD *)v18 - 1) = *((_OWORD *)v24 - 1);
          *(_OWORD *)(v18 - 28) = v28;
          *(_OWORD *)(v18 - 44) = v27;
          *(_OWORD *)(v18 - 60) = v26;
          v18 -= 60;
          v24 -= 60;
        }
        while (v24 != v25);
        long long v24 = (char *)*a1;
      }
      *a1 = v18;
      a1[1] = v13;
      a1[2] = v20;
      if (v24) {
        operator delete(v24);
      }
    }
    else
    {
      long long v10 = *a2;
      long long v11 = a2[1];
      long long v12 = a2[2];
      *(_OWORD *)((char *)v2 + 44) = *(long long *)((char *)a2 + 44);
      v2[1] = v11;
      v2[2] = v12;
      *uint64_t v2 = v10;
      char v13 = (char *)v2 + 60;
    }
    a1[1] = v13;
  }
}

void Nightingale::ngt_DayStreamProcessor::appendPhaseSet(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a1[3];
  char v6 = (_DWORD *)a1[4];
  uint64_t v5 = (uint64_t)(a1 + 3);
  uint64_t v7 = (uint64_t)v6 - v4;
  if ((unint64_t)v6 - v4 <= 0xAB17)
  {
    uint64_t v10 = (uint64_t)(a1 + 5);
    unint64_t v11 = a1[5];
    if ((unint64_t)v6 >= v11)
    {
      uint64_t v13 = v7 >> 2;
      uint64_t v14 = v11 - v4;
      if (v14 >> 1 <= (unint64_t)((v7 >> 2) + 1)) {
        uint64_t v15 = v13 + 1;
      }
      else {
        uint64_t v15 = v14 >> 1;
      }
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v16 = v15;
      }
      uint64_t v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v10, v16);
      double v18 = (char *)a1[3];
      uint64_t v19 = (char *)a1[4];
      float v20 = &v17[4 * v13];
      long long v22 = &v17[4 * v21];
      *(_DWORD *)float v20 = a3;
      long long v12 = v20 + 4;
      while (v19 != v18)
      {
        int v23 = *((_DWORD *)v19 - 1);
        v19 -= 4;
        *((_DWORD *)v20 - 1) = v23;
        v20 -= 4;
      }
      a1[3] = v20;
      a1[4] = v12;
      a1[5] = v22;
      if (v18) {
        operator delete(v18);
      }
    }
    else
    {
      _DWORD *v6 = a3;
      long long v12 = v6 + 1;
    }
    unint64_t v24 = a1[8];
    a1[4] = v12;
    long long v25 = (void *)a1[7];
    if ((unint64_t)v25 >= v24)
    {
      uint64_t v27 = a1[6];
      uint64_t v28 = ((uint64_t)v25 - v27) >> 3;
      if ((unint64_t)(v28 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v29 = v24 - v27;
      uint64_t v30 = v29 >> 2;
      if (v29 >> 2 <= (unint64_t)(v28 + 1)) {
        uint64_t v30 = v28 + 1;
      }
      if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v31 = v30;
      }
      if (v31) {
        uint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)(a1 + 8), v31);
      }
      else {
        uint64_t v32 = 0;
      }
      int64x2_t v33 = &v32[8 * v28];
      uint64_t v34 = &v32[8 * v31];
      *(void *)int64x2_t v33 = a2;
      long long v26 = v33 + 8;
      long long v36 = (char *)a1[6];
      long long v35 = (char *)a1[7];
      if (v35 != v36)
      {
        do
        {
          uint64_t v37 = *((void *)v35 - 1);
          v35 -= 8;
          *((void *)v33 - 1) = v37;
          v33 -= 8;
        }
        while (v35 != v36);
        long long v35 = (char *)a1[6];
      }
      a1[6] = v33;
      a1[7] = v26;
      a1[8] = v34;
      if (v35) {
        operator delete(v35);
      }
    }
    else
    {
      *long long v25 = a2;
      long long v26 = v25 + 1;
    }
    a1[7] = v26;
  }
  std::pair<std::vector<int>,std::vector<Nightingale::PhaseSet>>::pair[abi:ne180100]<std::vector<int>&,std::vector<Nightingale::PhaseSet>&,0>(__p, v5, (uint64_t)(a1 + 6));
  unint64_t v38 = (void *)a1[9];
  if (v38)
  {
    a1[10] = v38;
    operator delete(v38);
  }
  *(_OWORD *)(a1 + 9) = *(_OWORD *)__p;
  a1[11] = v41;
  __p[1] = 0;
  uint64_t v41 = 0;
  __p[0] = 0;
  char v39 = (void *)a1[12];
  if (v39)
  {
    a1[13] = v39;
    operator delete(v39);
    char v39 = __p[0];
  }
  *((_OWORD *)a1 + 6) = v42;
  a1[14] = v43;
  uint64_t v43 = 0;
  long long v42 = 0uLL;
  if (v39)
  {
    __p[1] = v39;
    operator delete(v39);
  }
}

uint64_t **Nightingale::ngt_DayStreamProcessor::begin_phase(uint64_t a1, unsigned int a2, int a3)
{
  return Nightingale::PhaseCondenser::begin_phase((uint64_t **)(a1 + 480), a2, a3);
}

uint64_t **Nightingale::ngt_DayStreamProcessor::end_phase(uint64_t a1, unsigned int a2, int a3)
{
  return Nightingale::PhaseCondenser::end_phase((uint64_t **)(a1 + 480), a2, a3);
}

void Nightingale::ngt_DayStreamProcessor::analyze(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v186 = *MEMORY[0x263EF8340];
  Nightingale::PhaseCondenser::phase_updates((Nightingale::PhaseCondenser *)(a1 + 480), (uint64_t)&__p);
  unint64_t v8 = (char *)__p;
  unint64_t v9 = v124;
  if (__p != v124)
  {
    do
    {
      Nightingale::ngt_DayStreamProcessor::appendPhaseSet((void *)a1, *(void *)v8, *((_DWORD *)v8 + 2));
      v8 += 16;
    }
    while (v8 != v9);
    unint64_t v8 = (char *)__p;
  }
  if (v8)
  {
    uint64_t v124 = v8;
    operator delete(v8);
  }
  *(unsigned char *)(a4 + 52) = 0;
  *(unsigned char *)(a4 + 56) = 0;
  *(unsigned char *)(a4 + 60) = 0;
  *(unsigned char *)(a4 + 64) = 0;
  *(unsigned char *)(a4 + 68) = 0;
  *(unsigned char *)(a4 + 72) = 0;
  *(unsigned char *)(a4 + 76) = 0;
  *(unsigned char *)(a4 + 80) = 0;
  *(unsigned char *)(a4 + 84) = 0;
  *(unsigned char *)(a4 + 88) = 0;
  *(unsigned char *)(a4 + 92) = 0;
  *(unsigned char *)(a4 + 96) = 0;
  *(unsigned char *)(a4 + 100) = 0;
  *(unsigned char *)(a4 + 104) = 0;
  *(unsigned char *)(a4 + 108) = 0;
  *(unsigned char *)(a4 + 112) = 0;
  *(unsigned char *)(a4 + 116) = 0;
  *(unsigned char *)(a4 + 120) = 0;
  *(unsigned char *)(a4 + 256) = 0;
  *(unsigned char *)(a4 + 261) = 0;
  *(unsigned char *)(a4 + 264) = 0;
  *(unsigned char *)(a4 + 496) = 0;
  *(unsigned char *)(a4 + 504) = 0;
  *(unsigned char *)(a4 + 596) = 0;
  *(unsigned char *)(a4 + 48) = 0;
  *(_OWORD *)(a4 + 16) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  log = ha_get_log();
  BOOL v11 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
  if (v11) {
    Nightingale::ngt_DayStreamProcessor::analyze();
  }
  Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(v11, (uint64_t *)a1, (void *)(a1 + 72), a1 + 120);
  *(_DWORD *)(a1 + 160) = a2;
  *(unsigned char *)(a1 + 164) = BYTE4(a2);
  Nightingale::uiLogProcessor::uiLogProcessor((uint64_t)v184, *(void *)(a1 + 168));
  Nightingale::uiLogProcessor::extractCycles((uint64_t)v184, a1, (uint64_t *)(a1 + 72), a1 + 120, (uint64_t)&v180);
  uint64_t v12 = a1 + 432;
  uint64_t v13 = *(char **)(a1 + 432);
  *(void *)(a1 + 440) = v13;
  uint64_t v14 = a1 + 456;
  *(void *)(a1 + 464) = *(void *)(a1 + 456);
  if (v180 != v181 && v182 && *(unsigned char *)(a1 + 156))
  {
    memset(v174, 0, sizeof(v174));
    std::vector<Nightingale::cycleInfo>::__init_with_size[abi:ne180100]<Nightingale::cycleInfo*,Nightingale::cycleInfo*>(v174, (uint64_t)v180, (uint64_t)v181, 0xAAAAAAAAAAAAAAABLL * (((char *)v181 - (char *)v180) >> 5));
    Nightingale::ngt_DayStreamProcessor::compute_stats((uint64_t)v174, a1 + 120, (uint64_t *)(a1 + 72), v183, &v175);
    __n128 __p = v174;
    std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
    BOOL v41 = Nightingale::ngt_DayStreamProcessor::inactiveDetect(v15, (uint64_t)&v180, (uint64_t *)(a1 + 72), v175, *(void *)(a1 + 152));
    int v164 = 0;
    __int16 v165 = 0;
    memset(&v185[2], 255, 20);
    int v162 = 0;
    __int16 v163 = 0;
    int v160 = 0;
    __int16 v161 = 0;
    int v158 = 0;
    __int16 v159 = 0;
    if (*(unsigned char *)(a1 + 248))
    {
      Nightingale::ngt_deviationAnalyzer::ngt_deviationAnalyzer((Nightingale::ngt_deviationAnalyzer *)&v111);
      Nightingale::ngt_deviationAnalyzer::deviation_process((uint64_t)&v111, a1 + 120, a1, (uint64_t)&v180, (uint64_t *)(a1 + 72), a3, (uint64_t)&__p);
      __int16 v172 = *(_WORD *)((char *)&__p + 1);
      char v173 = BYTE3(__p);
      int v50 = HIDWORD(__p);
      int v51 = (int)v124;
      LOBYTE(v62) = BYTE4(v124);
      BYTE4(v62) = (_BYTE)__p;
      __int16 v170 = *(_WORD *)((char *)&v124 + 5);
      char v171 = HIBYTE(v124);
      int v52 = v125;
      int v53 = v126;
      __int16 v168 = v128;
      char v169 = v129;
      int v54 = v130;
      int v55 = v131;
      LOBYTE(v61) = v132;
      BYTE4(v61) = v127;
      char v167 = v134;
      __int16 v166 = v133;
      int v56 = v135;
      int v57 = v136;
      __int16 v165 = v138;
      int v164 = v137;
      *(void *)&v185[14] = *(void *)&v139[14];
      *(_OWORD *)int v185 = *(_OWORD *)v139;
      __int16 v163 = v141;
      int v162 = v140;
      int v48 = v143;
      int v49 = v144;
      int v60 = v145;
      __int16 v161 = v147;
      int v160 = v146;
      __int16 v43 = v148;
      __int16 v44 = v142;
      int v46 = v149;
      int v47 = v150;
      __int16 v159 = v153;
      int v158 = v152;
      __int16 v42 = v154;
      int v16 = v155;
      int v45 = v156;
      int v58 = v151;
      int v59 = v157;
      Nightingale::ngt_deviationAnalyzer::~ngt_deviationAnalyzer((Nightingale::ngt_deviationAnalyzer *)&v111);
    }
    else
    {
      uint64_t v61 = 0;
      uint64_t v62 = 0;
      int v45 = -1;
      int v46 = -1;
      int v16 = -1;
      int v58 = -1;
      int v59 = -1;
      int v47 = -1;
      int v48 = -1;
      int v60 = -1;
      int v49 = -1;
      int v50 = -1;
      int v56 = -1;
      int v57 = -1;
      int v54 = -1;
      int v55 = -1;
      int v52 = -1;
      int v53 = -1;
      int v51 = -1;
    }
    Nightingale::ngtProjector::ngtProjector(&__p, a1, a1 + 120, &v180, a1 + 72);
    BYTE8(v111) = 0;
    LOBYTE(v112) = 0;
    BYTE8(v112) = 0;
    LOBYTE(v113) = 0;
    BYTE8(v113) = 0;
    BYTE12(v113) = 0;
    LOBYTE(v114) = 0;
    BYTE4(v114) = 0;
    BYTE8(v114) = 0;
    LOBYTE(v115) = 0;
    BYTE8(v115) = 0;
    LOBYTE(v116) = 0;
    BYTE8(v116) = 0;
    BYTE12(v116) = 0;
    LOBYTE(v117) = 0;
    BYTE4(v117) = 0;
    BYTE8(v117) = 0;
    BYTE12(v117) = 0;
    v118[0] = 0;
    v118[4] = 0;
    *(_WORD *)&v118[8] = 0;
    *(void *)&v118[12] = -4294967291;
    *(_DWORD *)&v118[20] = 0;
    *(void *)&long long v119 = -1;
    *(void *)&v118[24] = -1;
    BYTE8(v119) = 0;
    BYTE12(v119) = 0;
    DWORD1(v120) = -1082130432;
    *((void *)&v120 + 1) = -1;
    *(void *)unint64_t v121 = -1;
    __asm { FMOV            V0.4S, #-1.0 }
    *(_OWORD *)&v121[8] = _Q0;
    __asm { FMOV            V0.2S, #-1.0 }
    *(void *)&v121[24] = _Q0;
    *(_WORD *)uint64_t v122 = 0;
    v122[2] = 0;
    *(_OWORD *)&v122[4] = xmmword_257D5F6F0;
    *(_DWORD *)&v122[20] = 9;
    Nightingale::ngtProjector::projector((uint64_t)&__p, (uint64_t *)(a1 + 432), (uint64_t *)(a1 + 456), (uint64_t)v184, a3, (uint64_t)&v111);
    Nightingale::uiLogProcessor::print_anUILog((uint64_t)v184, &v180);
    int v23 = *(unsigned __int8 *)(a4 + 496);
    long long v24 = *(_OWORD *)v122;
    *(_OWORD *)(a4 + 456) = *(_OWORD *)&v121[16];
    *(_OWORD *)(a4 + 472) = v24;
    *(void *)(a4 + 488) = *(void *)&v122[16];
    long long v25 = v119;
    *(_OWORD *)(a4 + 392) = *(_OWORD *)&v118[16];
    *(_OWORD *)(a4 + 408) = v25;
    long long v26 = *(_OWORD *)v121;
    *(_OWORD *)(a4 + 424) = v120;
    *(_OWORD *)(a4 + 440) = v26;
    long long v27 = v116;
    *(_OWORD *)(a4 + 328) = v115;
    *(_OWORD *)(a4 + 344) = v27;
    long long v28 = *(_OWORD *)v118;
    *(_OWORD *)(a4 + 360) = v117;
    *(_OWORD *)(a4 + 376) = v28;
    long long v29 = v112;
    *(_OWORD *)(a4 + 264) = v111;
    *(_OWORD *)(a4 + 280) = v29;
    long long v30 = v114;
    *(_OWORD *)(a4 + 296) = v113;
    *(_OWORD *)(a4 + 312) = v30;
    if (!v23) {
      *(unsigned char *)(a4 + 496) = 1;
    }
    long long v107 = v176;
    long long v108 = v177;
    long long v109 = v178;
    uint64_t v110 = v179;
    long long v106 = v175;
    Nightingale::ngt_DayStreamProcessor::printStats();
    char v65 = BYTE4(v62);
    __int16 v66 = v172;
    char v67 = v173;
    int v68 = v50;
    int v69 = v51;
    char v70 = v62;
    __int16 v71 = v170;
    char v72 = v171;
    int v73 = v52;
    int v74 = v53;
    char v75 = BYTE4(v61);
    __int16 v76 = v168;
    char v77 = v169;
    int v78 = v54;
    int v79 = v55;
    char v80 = v61;
    char v82 = v167;
    __int16 v81 = v166;
    int v83 = v56;
    int v84 = v57;
    __int16 v86 = v165;
    int v85 = v164;
    *(void *)&v87[14] = *(void *)&v185[14];
    *(_OWORD *)char v87 = *(_OWORD *)v185;
    __int16 v89 = v163;
    int v88 = v162;
    __int16 v90 = v44;
    int v91 = v48;
    int v92 = v49;
    __int16 v95 = v161;
    int v93 = v60;
    int v94 = v160;
    __int16 v96 = v43;
    int v97 = v46;
    int v98 = v47;
    __int16 v101 = v159;
    int v99 = v58;
    int v100 = v158;
    __int16 v102 = v42;
    int v103 = v16;
    int v104 = v45;
    int v105 = v59;
    Nightingale::ngt_DayStreamProcessor::printDeviations(v31, (uint64_t)&v65);
    uint64_t v32 = ha_get_log();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_DayStreamProcessor::analyze();
    }
    *(unsigned char *)(a4 + 260) = v183;
    if (v12 != a4) {
      std::vector<Nightingale::ngt_Prediction>::__assign_with_size[abi:ne180100]<Nightingale::ngt_Prediction*,Nightingale::ngt_Prediction*>((char *)a4, *(char **)(a1 + 432), *(void *)(a1 + 440), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 440) - *(void *)(a1 + 432)) >> 3));
    }
    if (a4 + 24 != v14) {
      std::vector<Nightingale::ngt_Prediction>::__assign_with_size[abi:ne180100]<Nightingale::ngt_Prediction*,Nightingale::ngt_Prediction*>((char *)(a4 + 24), *(char **)(a1 + 456), *(void *)(a1 + 464), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 464) - *(void *)(a1 + 456)) >> 3));
    }
    long long v33 = v178;
    *(_OWORD *)(a4 + 80) = v177;
    *(_OWORD *)(a4 + 96) = v33;
    *(void *)(a4 + 112) = v179;
    long long v34 = v176;
    *(_OWORD *)(a4 + 48) = v175;
    *(_OWORD *)(a4 + 64) = v34;
    if (*(unsigned char *)(a1 + 248))
    {
      int v35 = *(unsigned __int8 *)(a4 + 256);
      *(unsigned char *)(a4 + 120) = BYTE4(v62);
      *(_WORD *)(a4 + 121) = v172;
      *(unsigned char *)(a4 + 123) = v173;
      *(_DWORD *)(a4 + 124) = v50;
      *(_DWORD *)(a4 + 128) = v51;
      *(unsigned char *)(a4 + 132) = v62;
      *(_WORD *)(a4 + 133) = v170;
      *(unsigned char *)(a4 + 135) = v171;
      *(_DWORD *)(a4 + 136) = v52;
      *(_DWORD *)(a4 + 140) = v53;
      *(unsigned char *)(a4 + 144) = BYTE4(v61);
      __int16 v36 = v168;
      *(unsigned char *)(a4 + 147) = v169;
      *(_WORD *)(a4 + 145) = v36;
      *(_DWORD *)(a4 + 148) = v54;
      *(_DWORD *)(a4 + 152) = v55;
      *(unsigned char *)(a4 + 156) = v61;
      *(_WORD *)(a4 + 157) = v166;
      *(unsigned char *)(a4 + 159) = v167;
      *(_DWORD *)(a4 + 160) = v56;
      *(_DWORD *)(a4 + 164) = v57;
      *(_DWORD *)(a4 + 168) = v164;
      *(_WORD *)(a4 + 172) = v165;
      *(void *)(a4 + 188) = *(void *)&v185[14];
      *(_OWORD *)(a4 + 174) = *(_OWORD *)v185;
      *(_WORD *)(a4 + 200) = v163;
      *(_DWORD *)(a4 + 196) = v162;
      *(_WORD *)(a4 + 202) = v44;
      *(_DWORD *)(a4 + 204) = v48;
      *(_DWORD *)(a4 + 208) = v49;
      *(_WORD *)(a4 + 220) = v161;
      int v37 = v160;
      *(_DWORD *)(a4 + 212) = v60;
      *(_DWORD *)(a4 + 216) = v37;
      *(_WORD *)(a4 + 222) = v43;
      *(_DWORD *)(a4 + 224) = v46;
      *(_DWORD *)(a4 + 228) = v47;
      int v38 = v158;
      *(_WORD *)(a4 + 240) = v159;
      *(_DWORD *)(a4 + 232) = v58;
      *(_DWORD *)(a4 + 236) = v38;
      *(_WORD *)(a4 + 242) = v42;
      *(_DWORD *)(a4 + 244) = v16;
      *(_DWORD *)(a4 + 248) = v45;
      *(_DWORD *)(a4 + 252) = v59;
      if (!v35) {
        *(unsigned char *)(a4 + 256) = 1;
      }
    }
    *(unsigned char *)(a4 + 261) = v41;
    Nightingale::ngtProjector::getEnsembleTelemetry((Nightingale::ngtProjector *)&__p, v63);
    long long v39 = v63[3];
    *(_OWORD *)(a4 + 536) = v63[2];
    *(_OWORD *)(a4 + 552) = v39;
    *(_OWORD *)(a4 + 568) = v64[0];
    *(_OWORD *)(a4 + 581) = *(_OWORD *)((char *)v64 + 13);
    long long v40 = v63[1];
    *(_OWORD *)(a4 + 504) = v63[0];
    *(_OWORD *)(a4 + 520) = v40;
    Nightingale::ngtProjector::~ngtProjector((Nightingale::ngtProjector *)&__p);
  }
  else
  {
    *(unsigned char *)(a4 + 260) = 0;
    if (v12 != a4) {
      std::vector<Nightingale::ngt_Prediction>::__assign_with_size[abi:ne180100]<Nightingale::ngt_Prediction*,Nightingale::ngt_Prediction*>((char *)a4, v13, (uint64_t)v13, 0);
    }
    if (a4 + 24 != v14) {
      std::vector<Nightingale::ngt_Prediction>::__assign_with_size[abi:ne180100]<Nightingale::ngt_Prediction*,Nightingale::ngt_Prediction*>((char *)(a4 + 24), *(char **)(a1 + 456), *(void *)(a1 + 464), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a1 + 464) - *(void *)(a1 + 456)) >> 3));
    }
    uint64_t v17 = ha_get_log();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_DayStreamProcessor::analyze();
    }
  }
  __n128 __p = &v180;
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  Nightingale::uiLogProcessor::~uiLogProcessor((Nightingale::uiLogProcessor *)v184);
}

void sub_257D4C918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  Nightingale::ngt_deviationAnalyzer::~ngt_deviationAnalyzer((Nightingale::ngt_deviationAnalyzer *)&a61);
  STACK[0x288] = (unint64_t)&STACK[0x618];
  std::vector<Nightingale::cycleInfo>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x288]);
  Nightingale::uiLogProcessor::~uiLogProcessor((Nightingale::uiLogProcessor *)&STACK[0x6A0]);
  std::pair<std::vector<float>,std::vector<float>>::~pair(v61);
  _Unwind_Resume(a1);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
  }
  uint64_t v7 = *a2;
  uint64_t v8 = a2[1];
  unint64_t v9 = ha_get_log();
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
  if (v7 != v8)
  {
    char v72 = a3;
    if (v10) {
      Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
    }
    uint64_t v11 = *a2;
    uint64_t v12 = a2[1];
    uint64_t v13 = v12 - *a2;
    if (v13 == 60)
    {
LABEL_7:
      int v15 = *(_DWORD *)(v12 - 60);
      int v14 = *(_DWORD *)(v12 - 56);
      char v16 = *(unsigned char *)(v12 - 52);
      int v17 = *(_DWORD *)(v12 - 48);
      float v18 = *(float *)(v12 - 44);
      int v19 = *(unsigned __int8 *)(v12 - 40);
      float v20 = *(float *)(v12 - 36);
      int v21 = *(unsigned __int8 *)(v12 - 32);
      int v22 = *(unsigned __int8 *)(v12 - 24);
      int v78 = *(_DWORD *)(v12 - 28);
      int v80 = *(_DWORD *)(v12 - 20);
      int v23 = *(unsigned __int8 *)(v12 - 16);
      unsigned __int8 v76 = *(unsigned char *)(v12 - 12);
      float v24 = *(float *)(v12 - 8);
      int v25 = *(unsigned __int8 *)(v12 - 4);
      long long v26 = ha_get_log();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)int v83 = v15;
        *(_WORD *)&v83[4] = 1024;
        *(_DWORD *)&v83[6] = v14;
        *(_WORD *)&v83[10] = 1024;
        *(_DWORD *)&v83[12] = v16 & 1;
        *(_WORD *)&v83[16] = 1024;
        *(_DWORD *)int v84 = v17;
        _os_log_debug_impl(&dword_257C1A000, v26, OS_LOG_TYPE_DEBUG, "\t{\"jDay\": %d, \"flow\": %d, \"spotting\": %d, \"opk\": %d, ", buf, 0x1Au);
      }
      long long v27 = ha_get_log();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
      {
        double v67 = v18;
        double v68 = -1.0;
        if (!v19) {
          double v67 = -1.0;
        }
        if (v21) {
          double v68 = v20;
        }
        *(_DWORD *)buf = 134218752;
        *(double *)int v83 = v67;
        int v69 = v78;
        if (!v22) {
          int v69 = -1;
        }
        *(_WORD *)&v83[8] = 2048;
        *(double *)&v83[10] = v68;
        *(_WORD *)int v84 = 1024;
        *(_DWORD *)&v84[2] = v69;
        int v70 = v80;
        if (!v23) {
          int v70 = -1;
        }
        __int16 v85 = 1024;
        int v86 = v70;
        _os_log_debug_impl(&dword_257C1A000, v27, OS_LOG_TYPE_DEBUG, "\"sensor\": {\"aHR\": %5.2f, \"sHR\": %5.2f, \"aHRCnt\": %d, \"sHRCnt\": %d, ", buf, 0x22u);
      }
      long long v28 = ha_get_log();
      BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG);
      if (v25)
      {
        a3 = v72;
        if (v29) {
          Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(v76, v28, v24);
        }
      }
      else
      {
        a3 = v72;
        if (v29) {
          Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(v28);
        }
      }
      int v52 = ha_get_log();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
        Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
      }
      goto LABEL_41;
    }
    unint64_t v30 = 0;
    unint64_t v31 = 0xEEEEEEEEEEEEEEEFLL * (v13 >> 2);
    uint64_t v32 = 56;
    while (1)
    {
      if (v31 <= v30) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      long long v33 = (unsigned __int8 *)(v11 + v32);
      int v34 = *((_DWORD *)v33 - 14);
      int v35 = *((_DWORD *)v33 - 13);
      char v36 = *(v33 - 48);
      int v37 = *((_DWORD *)v33 - 11);
      float v38 = *((float *)v33 - 10);
      int v39 = *(v33 - 36);
      float v40 = *((float *)v33 - 8);
      int v74 = *(v33 - 28);
      int v75 = *(v33 - 20);
      int v79 = *((_DWORD *)v33 - 6);
      int v81 = *((_DWORD *)v33 - 4);
      int v77 = *(v33 - 12);
      int v73 = *(v33 - 8);
      float v41 = *((float *)v33 - 1);
      int v42 = *v33;
      __int16 v43 = ha_get_log();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)int v83 = v34;
        *(_WORD *)&v83[4] = 1024;
        *(_DWORD *)&v83[6] = v35;
        *(_WORD *)&v83[10] = 1024;
        *(_DWORD *)&v83[12] = v36 & 1;
        *(_WORD *)&v83[16] = 1024;
        *(_DWORD *)int v84 = v37;
        _os_log_debug_impl(&dword_257C1A000, v43, OS_LOG_TYPE_DEBUG, "\t{\"jDay\": %d, \"flow\": %d, \"spotting\": %d, \"opk\": %d, ", buf, 0x1Au);
      }
      __int16 v44 = ha_get_log();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        double v48 = v38;
        if (!v39) {
          double v48 = -1.0;
        }
        double v49 = v40;
        if (!v74) {
          double v49 = -1.0;
        }
        *(_DWORD *)buf = 134218752;
        *(double *)int v83 = v48;
        int v50 = v79;
        if (!v75) {
          int v50 = -1;
        }
        *(_WORD *)&v83[8] = 2048;
        *(double *)&v83[10] = v49;
        *(_WORD *)int v84 = 1024;
        *(_DWORD *)&v84[2] = v50;
        int v51 = v81;
        if (!v77) {
          int v51 = -1;
        }
        __int16 v85 = 1024;
        int v86 = v51;
        _os_log_debug_impl(&dword_257C1A000, v44, OS_LOG_TYPE_DEBUG, "\"sensor\": {\"aHR\": %5.2f, \"sHR\": %5.2f, \"aHRCnt\": %d, \"sHRCnt\": %d,", buf, 0x22u);
      }
      int v45 = ha_get_log();
      BOOL v46 = os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG);
      if (v42)
      {
        if (v46)
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)int v83 = v73;
          *(_WORD *)&v83[4] = 2048;
          *(double *)&v83[6] = v41;
          int v47 = v45;
LABEL_36:
          _os_log_debug_impl(&dword_257C1A000, v47, OS_LOG_TYPE_DEBUG, "\"wTmp\": {\"watchID\": %d, \"tp\": %5.2f}}},\n", buf, 0x12u);
        }
      }
      else if (v46)
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)int v83 = -1;
        *(_WORD *)&v83[4] = 2048;
        *(void *)&v83[6] = 0xBFF0000000000000;
        int v47 = v45;
        goto LABEL_36;
      }
      ++v30;
      uint64_t v11 = *a2;
      uint64_t v12 = a2[1];
      unint64_t v31 = 0xEEEEEEEEEEEEEEEFLL * ((v12 - *a2) >> 2);
      v32 += 60;
      if (v31 - 1 <= v30) {
        goto LABEL_7;
      }
    }
  }
  if (v10) {
    Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
  }
LABEL_41:
  uint64_t v53 = *a3;
  uint64_t v54 = a3[1];
  int v55 = ha_get_log();
  BOOL v56 = os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG);
  if (v53 == v54)
  {
    if (v56) {
      Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
    }
  }
  else
  {
    if (v56) {
      Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
    }
    if (a3[1] - *a3 != 4)
    {
      unint64_t v62 = 0;
      do
      {
        char v63 = ha_get_log();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          if (v62 >= (uint64_t)(a3[1] - *a3) >> 2) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          uint64_t v64 = a3[3];
          if (v62 >= (a3[4] - v64) >> 3) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          int v65 = *(_DWORD *)(*a3 + 4 * v62);
          int v66 = (unsigned __int16)*(void *)(v64 + 8 * v62);
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)int v83 = v65;
          *(_WORD *)&v83[4] = 1024;
          *(_DWORD *)&v83[6] = v66;
          _os_log_debug_impl(&dword_257C1A000, v63, OS_LOG_TYPE_DEBUG, "\t{\"jDay\": %d, \"phase\": %d}, \n", buf, 0xEu);
        }
        ++v62;
      }
      while (((uint64_t)(a3[1] - *a3) >> 2) - 1 > v62);
    }
    int v57 = ha_get_log();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(a3 + 1, (uint64_t)a3, v57);
    }
    int v58 = ha_get_log();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG)) {
      Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
    }
  }
  int v59 = ha_get_log();
  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(a4, v59);
  }
  int v60 = ha_get_log();
  if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
  }
  uint64_t v61 = ha_get_log();
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc();
  }
}

void Nightingale::ngt_DayStreamProcessor::compute_stats(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t *a3@<X3>, char a4@<W4>, unsigned char *a5@<X8>)
{
  *a5 = 0;
  a5[4] = 0;
  a5[8] = 0;
  a5[12] = 0;
  a5[16] = 0;
  a5[20] = 0;
  a5[24] = 0;
  a5[28] = 0;
  a5[32] = 0;
  a5[36] = 0;
  a5[40] = 0;
  a5[44] = 0;
  a5[48] = 0;
  a5[52] = 0;
  a5[56] = 0;
  a5[60] = 0;
  a5[64] = 0;
  a5[68] = 0;
  __int16 v85 = 0;
  int v86 = 0;
  uint64_t v87 = 0;
  if (!*(unsigned char *)(a2 + 36)) {
    return;
  }
  uint64_t v7 = *(_DWORD **)a1;
  uint64_t v8 = *(_DWORD **)(a1 + 8);
  if (*(_DWORD **)a1 == v8) {
    return;
  }
  int v10 = *(_DWORD *)(a2 + 32);
  if (v10 < 365 || v10 < *(v8 - 24)) {
    return;
  }
  uint64_t v12 = 0;
  int v13 = 0;
  __n128 __p = 0;
  int v83 = 0;
  int v84 = 0;
  do
  {
    if (!*(unsigned char *)(a2 + 36)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if ((*(_DWORD *)(a2 + 32) - *v7) <= 0x16C)
    {
      if (v12 >= v84)
      {
        int v15 = (char *)__p;
        uint64_t v16 = (v12 - (unsigned char *)__p) >> 2;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v84 - (unsigned char *)__p;
        if ((v84 - (unsigned char *)__p) >> 1 > v17) {
          unint64_t v17 = v18 >> 1;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          float v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v84, v19);
          int v15 = (char *)__p;
          uint64_t v12 = v83;
        }
        else
        {
          float v20 = 0;
        }
        int v21 = &v20[4 * v16];
        *(_DWORD *)int v21 = v13;
        int v14 = v21 + 4;
        while (v12 != v15)
        {
          int v22 = *((_DWORD *)v12 - 1);
          v12 -= 4;
          *((_DWORD *)v21 - 1) = v22;
          v21 -= 4;
        }
        __n128 __p = v21;
        int v83 = v14;
        int v84 = &v20[4 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v12 = v13;
        int v14 = v12 + 4;
      }
      int v83 = v14;
      uint64_t v12 = v14;
    }
    ++v13;
    v7 += 24;
  }
  while (v7 != v8);
  int v23 = (char *)__p;
  if (__p != v12)
  {
    float v24 = *(_DWORD **)a1;
    uint64_t v25 = *(void *)(a1 + 8);
    unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((v25 - *(void *)a1) >> 5);
    long long v27 = (int *)__p;
    if (v26 - 1 == *((_DWORD *)v12 - 1))
    {
      *((_DWORD *)a5 + 16) = *(_DWORD *)(v25 - 96);
      a5[68] = 1;
      long long v27 = (int *)v23;
    }
    while (1)
    {
      unint64_t v28 = *v27;
      if (v26 <= v28) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      if (LOBYTE(v24[24 * (int)v28 + 6])) {
        break;
      }
      if (++v27 == (int *)v12) {
        goto LABEL_34;
      }
    }
    *((_DWORD *)a5 + 14) = v24[24 * (int)v28];
    a5[60] = 1;
LABEL_34:
    int v79 = 0;
    int v80 = 0;
    int v81 = 0;
    unsigned __int8 v76 = 0;
    int v77 = 0;
    int v78 = 0;
    do
    {
      unint64_t v29 = *(int *)v23;
      unint64_t v30 = *(_DWORD **)a1;
      unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5);
      if (v31 <= v29) {
        goto LABEL_101;
      }
      uint64_t v32 = &v30[24 * (int)v29];
      if (*((unsigned char *)v32 + 8))
      {
        int v33 = v32[1] - v30[24 * (int)v29] + 1;
        int v34 = v77;
        if (v77 >= v78)
        {
          char v36 = (int *)v76;
          uint64_t v37 = ((char *)v77 - (unsigned char *)v76) >> 2;
          unint64_t v38 = v37 + 1;
          if ((unint64_t)(v37 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v39 = (char *)v78 - (unsigned char *)v76;
          if (((char *)v78 - (unsigned char *)v76) >> 1 > v38) {
            unint64_t v38 = v39 >> 1;
          }
          if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v40 = v38;
          }
          if (v40)
          {
            float v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v78, v40);
            char v36 = (int *)v76;
            int v34 = v77;
          }
          else
          {
            float v41 = 0;
          }
          int v42 = (int *)&v41[4 * v37];
          *int v42 = v33;
          int v35 = v42 + 1;
          while (v34 != v36)
          {
            int v43 = *--v34;
            *--int v42 = v43;
          }
          unsigned __int8 v76 = v42;
          int v77 = v35;
          int v78 = (int *)&v41[4 * v40];
          if (v36) {
            operator delete(v36);
          }
        }
        else
        {
          *int v77 = v33;
          int v35 = v34 + 1;
        }
        int v77 = v35;
        unint64_t v29 = *(int *)v23;
        unint64_t v30 = *(_DWORD **)a1;
        unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 5);
      }
      if (v31 <= v29) {
LABEL_101:
      }
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      __int16 v44 = &v30[24 * (int)v29];
      if (*((unsigned char *)v44 + 24))
      {
        uint64_t v45 = v30[24 * (int)v29];
        uint64_t v46 = v44[5];
        int v73 = 0;
        int v74 = 0;
        int v75 = 0;
        int v47 = operator new(1uLL);
        int v73 = v47;
        *int v47 = 0;
        int v74 = v47 + 1;
        int v75 = v47 + 1;
        char v48 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v85, v45 | (v46 << 32), (uint64_t *)&v73, a3);
        if (v73)
        {
          int v74 = v73;
          operator delete(v73);
        }
        if (!v48)
        {
          int v49 = v46 - v45 + 1;
          int v50 = v80;
          if (v80 >= v81)
          {
            int v52 = (char *)v79;
            uint64_t v53 = (v80 - (unsigned char *)v79) >> 2;
            unint64_t v54 = v53 + 1;
            if ((unint64_t)(v53 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v55 = v81 - (unsigned char *)v79;
            if ((v81 - (unsigned char *)v79) >> 1 > v54) {
              unint64_t v54 = v55 >> 1;
            }
            if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v56 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v56 = v54;
            }
            if (v56)
            {
              int v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v81, v56);
              int v52 = (char *)v79;
              int v50 = v80;
            }
            else
            {
              int v57 = 0;
            }
            int v58 = &v57[4 * v53];
            *(_DWORD *)int v58 = v49;
            int v51 = v58 + 4;
            while (v50 != v52)
            {
              int v59 = *((_DWORD *)v50 - 1);
              v50 -= 4;
              *((_DWORD *)v58 - 1) = v59;
              v58 -= 4;
            }
            int v79 = v58;
            int v80 = v51;
            int v81 = &v57[4 * v56];
            if (v52) {
              operator delete(v52);
            }
          }
          else
          {
            *(_DWORD *)int v80 = v49;
            int v51 = v50 + 4;
          }
          int v80 = v51;
        }
      }
      v23 += 4;
    }
    while (v23 != v12);
    if ((a4 & 1) != 0 && v77 != v76) {
      --v77;
    }
    uint64_t v60 = v80 - (unsigned char *)v79;
    if (v80 != v79)
    {
      std::__sort<std::__less<int,int> &,int *>();
      unint64_t v61 = (unint64_t)(v60 >> 2) >> 1;
      unint64_t v62 = v79;
      if ((v60 & 4) != 0)
      {
        unsigned int v64 = *((_DWORD *)v79 + v61);
        a5[4] = 1;
      }
      else
      {
        float v63 = (float)(*((_DWORD *)v79 + v61) + *((_DWORD *)v79 + v61 - 1)) * 0.5;
        a5[4] = 1;
        unsigned int v64 = llroundf(v63);
      }
      double v65 = (double)(unint64_t)((v60 >> 2) - 1);
      int v66 = v62[llround(v65 * 0.125)];
      *(_DWORD *)a5 = v64;
      *((_DWORD *)a5 + 8) = v66;
      a5[36] = 1;
      *((_DWORD *)a5 + 10) = v62[llround(v65 * 0.875)];
      a5[44] = 1;
    }
    double v67 = v77;
    uint64_t v68 = (char *)v77 - (unsigned char *)v76;
    if (v77 == v76)
    {
      *((_DWORD *)a5 + 12) = (unint64_t)v60 >> 2;
      a5[52] = 1;
      if (!v67) {
        goto LABEL_93;
      }
    }
    else
    {
      std::__sort<std::__less<int,int> &,int *>();
      unint64_t v69 = (unint64_t)(v68 >> 2) >> 1;
      double v67 = (int *)v76;
      if ((v68 & 4) != 0)
      {
        *((_DWORD *)a5 + 2) = *((_DWORD *)v76 + v69);
        a5[12] = 1;
      }
      else
      {
        float v70 = (float)(*((_DWORD *)v76 + v69) + *((_DWORD *)v76 + v69 - 1)) * 0.5;
        a5[12] = 1;
        *((_DWORD *)a5 + 2) = llroundf(v70);
      }
      double v71 = (double)(unint64_t)((v68 >> 2) - 1);
      *((_DWORD *)a5 + 4) = v67[llround(v71 * 0.125)];
      a5[20] = 1;
      *((_DWORD *)a5 + 6) = v67[llround(v71 * 0.875)];
      a5[28] = 1;
      *((_DWORD *)a5 + 12) = (unint64_t)v60 >> 2;
      a5[52] = 1;
    }
    int v77 = v67;
    operator delete(v67);
LABEL_93:
    if (v79)
    {
      int v80 = (char *)v79;
      operator delete(v79);
    }
    uint64_t v12 = (char *)__p;
  }
  if (v12)
  {
    int v83 = v12;
    operator delete(v12);
  }
  if (v85)
  {
    int v86 = v85;
    operator delete(v85);
  }
}

void sub_257D4D760(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::ngt_DayStreamProcessor::inactiveDetect(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  if ((a4 & 0xFF00000000) == 0) {
    return 0;
  }
  if (!*(unsigned char *)(a2 + 60) || (a5 & 0xFF00000000) == 0) {
    return 0;
  }
  int v8 = a4;
  int v10 = *(_DWORD *)(a2 + 56);
  char v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v11 = operator new(1uLL);
  __n128 __p = v11;
  unsigned char *v11 = 0;
  int v34 = v11 + 1;
  int v35 = v11 + 1;
  unsigned __int8 v12 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v36, (a5 + 4294967235) | 0xFFFFFFFF00000000, (uint64_t *)&__p, a3);
  if (__p)
  {
    int v34 = __p;
    operator delete(__p);
  }
  int v13 = operator new(1uLL);
  unint64_t v30 = v13;
  unsigned char *v13 = 1;
  unint64_t v31 = v13 + 1;
  uint64_t v32 = v13 + 1;
  char v14 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v36, (a5 - 61) | (unint64_t)(a5 << 32), (uint64_t *)&v30, a3);
  if (v30)
  {
    unint64_t v31 = v30;
    operator delete(v30);
  }
  int v15 = operator new(1uLL);
  long long v27 = v15;
  *int v15 = 1;
  unint64_t v28 = v15 + 1;
  unint64_t v29 = v15 + 1;
  unsigned __int8 v16 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v36, a5 | 0xFFFFFFFF00000000, (uint64_t *)&v27, a3);
  if (v27)
  {
    unint64_t v28 = v27;
    operator delete(v27);
  }
  unint64_t v17 = operator new(1uLL);
  float v24 = v17;
  *unint64_t v17 = 0;
  uint64_t v25 = v17 + 1;
  unint64_t v26 = v17 + 1;
  char v18 = Nightingale::phaseFactorProcessor::detectPhases((uint64_t)&v36, (a5 - 181) | (unint64_t)(a5 << 32), (uint64_t *)&v24, a3);
  int v19 = a5 - v10;
  int v20 = 2 * v8;
  if (v24)
  {
    uint64_t v25 = v24;
    operator delete(v24);
  }
  BOOL v21 = v14 == 0;
  if (!v18) {
    BOOL v21 = 1;
  }
  if (v16 | v12) {
    BOOL v22 = 1;
  }
  else {
    BOOL v22 = v19 < v20;
  }
  BOOL v7 = !v22 && v21;
  if (v36)
  {
    uint64_t v37 = v36;
    operator delete(v36);
  }
  return v7;
}

void sub_257D4D9DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a22) {
    operator delete(a22);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngt_DayStreamProcessor::printStats()
{
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  uint64_t v1 = ha_get_log();
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  uint64_t v2 = ha_get_log();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  uint64_t v3 = ha_get_log();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  uint64_t v4 = ha_get_log();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  uint64_t v5 = ha_get_log();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  char v6 = ha_get_log();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  BOOL v7 = ha_get_log();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  int v8 = ha_get_log();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  unint64_t v9 = ha_get_log();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
  int v10 = ha_get_log();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printStats();
  }
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\n\t}, \n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"julianDayOfCurrentCycleStart\": %d", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"julianDayOfFirstCompleteCycleStart\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"numberOfCompleteCyclesFound\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"upperCycleLengthPercentile\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"lowerCycleLengthPercentile\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"upperMenstruationLengthPercentile\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"lowerMenstruationLengthPercentile\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"medianMenstruationLength\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"medianCycleLength\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"stats\": {\n", v2, v3, v4, v5, v6);
}

void Nightingale::ngt_DayStreamProcessor::printDeviations(uint64_t a1, uint64_t a2)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  log = ha_get_log();
  if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
  uint64_t v4 = ha_get_log();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
  uint64_t v5 = ha_get_log();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
  char v6 = ha_get_log();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
  BOOL v7 = ha_get_log();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
  char v8 = *(unsigned char *)(a2 + 48);
  char v9 = *(unsigned char *)(a2 + 49);
  char v10 = *(unsigned char *)(a2 + 50);
  char v11 = *(unsigned char *)(a2 + 51);
  char v12 = *(unsigned char *)(a2 + 52);
  char v13 = *(unsigned char *)(a2 + 53);
  int v14 = *(_DWORD *)(a2 + 56);
  int v15 = ha_get_log();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    int v41 = *(_DWORD *)(a2 + 60);
    int v42 = *(_DWORD *)(a2 + 64);
    int v43 = *(_DWORD *)(a2 + 68);
    int v44 = *(_DWORD *)(a2 + 72);
    int v51 = 67111680;
    int v52 = v8 & 1;
    __int16 v53 = 1024;
    int v54 = v9 & 1;
    __int16 v55 = 1024;
    int v56 = v10 & 1;
    __int16 v57 = 1024;
    int v58 = v11 & 1;
    __int16 v59 = 1024;
    int v60 = v12 & 1;
    __int16 v61 = 1024;
    int v62 = v13 & 1;
    __int16 v63 = 1024;
    int v64 = v14;
    __int16 v65 = 1024;
    int v66 = v41;
    __int16 v67 = 1024;
    int v68 = v42;
    __int16 v69 = 1024;
    int v70 = v43;
    __int16 v71 = 1024;
    int v72 = v44;
    _os_log_debug_impl(&dword_257C1A000, v15, OS_LOG_TYPE_DEBUG, "\"irregMeta\": {\"common\": {\"bfrRule\": %d, \"minWS\": %d, \"minWE\": %d,\"enough\": %d, \"washout\": %d,\"inWin\": %d,\"age\": %d}, \"win1CycleLenDiff\": %d, \"win2CycleLenDiff\": %d, \"win1NumCycles\": %d, \"win2NumCycles\": %d},\n", (uint8_t *)&v51, 0x44u);
  }
  char v16 = *(unsigned char *)(a2 + 76);
  char v17 = *(unsigned char *)(a2 + 77);
  char v18 = *(unsigned char *)(a2 + 78);
  char v19 = *(unsigned char *)(a2 + 79);
  char v20 = *(unsigned char *)(a2 + 80);
  char v21 = *(unsigned char *)(a2 + 81);
  int v22 = *(_DWORD *)(a2 + 84);
  int v23 = ha_get_log();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    int v45 = *(_DWORD *)(a2 + 88);
    int v46 = *(_DWORD *)(a2 + 92);
    int v51 = 67111168;
    int v52 = v16 & 1;
    __int16 v53 = 1024;
    int v54 = v17 & 1;
    __int16 v55 = 1024;
    int v56 = v18 & 1;
    __int16 v57 = 1024;
    int v58 = v19 & 1;
    __int16 v59 = 1024;
    int v60 = v20 & 1;
    __int16 v61 = 1024;
    int v62 = v21 & 1;
    __int16 v63 = 1024;
    int v64 = v22;
    __int16 v65 = 1024;
    int v66 = v45;
    __int16 v67 = 1024;
    int v68 = v46;
    _os_log_debug_impl(&dword_257C1A000, v23, OS_LOG_TYPE_DEBUG, "\"infreqMeta\": {\"common\": {\"bfrRule\": %d, \"minWS\": %d, \"minWE\": %d,\"enough\": %d, \"washout\": %d,\"inWin\": %d,\"age\": %d}, \"win1NumPeriods\": %d, \"win2NumPeriods\": %d}, \n", (uint8_t *)&v51, 0x38u);
  }
  char v24 = *(unsigned char *)(a2 + 96);
  char v25 = *(unsigned char *)(a2 + 97);
  char v26 = *(unsigned char *)(a2 + 98);
  char v27 = *(unsigned char *)(a2 + 99);
  char v28 = *(unsigned char *)(a2 + 100);
  char v29 = *(unsigned char *)(a2 + 101);
  int v30 = *(_DWORD *)(a2 + 104);
  unint64_t v31 = ha_get_log();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
  {
    int v48 = *(_DWORD *)(a2 + 108);
    int v47 = *(_DWORD *)(a2 + 112);
    int v51 = 67111168;
    int v52 = v24 & 1;
    __int16 v53 = 1024;
    int v54 = v25 & 1;
    __int16 v55 = 1024;
    int v56 = v26 & 1;
    __int16 v57 = 1024;
    int v58 = v27 & 1;
    __int16 v59 = 1024;
    int v60 = v28 & 1;
    __int16 v61 = 1024;
    int v62 = v29 & 1;
    __int16 v63 = 1024;
    int v64 = v30;
    __int16 v65 = 1024;
    int v66 = v47;
    __int16 v67 = 1024;
    int v68 = v48;
    _os_log_debug_impl(&dword_257C1A000, v31, OS_LOG_TYPE_DEBUG, "\"prolongMeta\": {\"common\": {\"bfrRule\": %d, \"minWS\": %d, \"minWE\": %d,\"enough\": %d, \"washout\": %d,\"inWin\": %d,\"age\": %d}, \"numLongPeriodsDetected\": %d, \"numPeriodsUsed\": %d}, \n", (uint8_t *)&v51, 0x38u);
  }
  char v32 = *(unsigned char *)(a2 + 116);
  char v33 = *(unsigned char *)(a2 + 117);
  char v34 = *(unsigned char *)(a2 + 118);
  char v35 = *(unsigned char *)(a2 + 119);
  char v36 = *(unsigned char *)(a2 + 120);
  char v37 = *(unsigned char *)(a2 + 121);
  int v38 = *(_DWORD *)(a2 + 124);
  uint64_t v39 = ha_get_log();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
  {
    int v49 = *(_DWORD *)(a2 + 128);
    int v50 = *(_DWORD *)(a2 + 132);
    int v51 = 67111168;
    int v52 = v32 & 1;
    __int16 v53 = 1024;
    int v54 = v33 & 1;
    __int16 v55 = 1024;
    int v56 = v34 & 1;
    __int16 v57 = 1024;
    int v58 = v35 & 1;
    __int16 v59 = 1024;
    int v60 = v36 & 1;
    __int16 v61 = 1024;
    int v62 = v37 & 1;
    __int16 v63 = 1024;
    int v64 = v38;
    __int16 v65 = 1024;
    int v66 = v49;
    __int16 v67 = 1024;
    int v68 = v50;
    _os_log_debug_impl(&dword_257C1A000, v39, OS_LOG_TYPE_DEBUG, "\"spottingMeta\": {\"common\": {\"bfrRule\": %d, \"minWS\": %d, \"minWE\": %d,\"enough\": %d, \"washout\": %d,\"inWin\": %d,\"age\": %d}, \"win1NumSpottingDays\": %d, \"win2NumSpottingDays\": %d}", (uint8_t *)&v51, 0x38u);
  }
  unint64_t v40 = ha_get_log();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
    Nightingale::ngt_DayStreamProcessor::printDeviations();
  }
}

char *std::vector<Nightingale::ngt_Prediction>::__assign_with_size[abi:ne180100]<Nightingale::ngt_Prediction*,Nightingale::ngt_Prediction*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  BOOL v7 = result;
  uint64_t v8 = *((void *)result + 2);
  char v9 = *(char **)result;
  if (0x4EC4EC4EC4EC4EC5 * ((v8 - *(void *)result) >> 3) < a4)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 > 0x276276276276276) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x4EC4EC4EC4EC4EC5 * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x13B13B13B13B13BLL) {
      unint64_t v12 = 0x276276276276276;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t result = std::vector<Nightingale::ngt_Prediction>::__vallocate[abi:ne180100](v7, v12);
    int v14 = (char *)v7[1];
    char v13 = (void **)(v7 + 1);
    char v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      char v18 = v9;
      char v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  char v13 = (void **)(result + 8);
  int v15 = (unsigned char *)*((void *)result + 1);
  if (0x4EC4EC4EC4EC4EC5 * ((v15 - v9) >> 3) >= a4) {
    goto LABEL_16;
  }
  char v16 = &__src[8 * ((v15 - v9) >> 3)];
  if (v15 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v15 - v9);
    char v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    char v18 = v9;
    char v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  unsigned char *v13 = &v9[v17];
  return result;
}

char *std::vector<Nightingale::ngt_Prediction>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::ngt_Prediction>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void OUTLINED_FUNCTION_5_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x14u);
}

void Nightingale::ngt_dnn_fw_predict_t::ngt_dnn_fw_predict_t(Nightingale::ngt_dnn_fw_predict_t *this, const Nightingale::ngt_Config *a2)
{
}

void sub_257D4E2BC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  *uint64_t v1 = 0;
  if (v3) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)v1, v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::fwPredictorWrapper_t::init(Nightingale::fwPredictorWrapper_t *this, const Nightingale::ngt_Config *a2)
{
  uint64_t v5 = (char *)*((void *)a2 + 30);
  uint64_t v3 = (char *)a2 + 240;
  uint64_t v4 = v5;
  if (v3[23] >= 0) {
    char v6 = v3;
  }
  else {
    char v6 = v4;
  }
  BOOL v7 = [NSString stringWithUTF8String:v6];
  uint64_t v8 = [NSURL fileURLWithPath:v7];
  uint64_t v9 = objc_opt_new();
  unint64_t v10 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v9;

  uint64_t v11 = (void *)*((void *)this + 2);
  if (v11)
  {
    [v11 setComputeUnits:0];
    id v25 = 0;
    uint64_t v12 = [objc_alloc(MEMORY[0x263F00DA8]) initWithShape:&unk_27069BD98 dataType:65600 error:&v25];
    id v13 = v25;
    int v14 = *(void **)this;
    *(void *)this = v12;

    if (*(void *)this)
    {
      int v15 = [model_fwEnd_10pct alloc];
      uint64_t v16 = *((void *)this + 2);
      id v24 = v13;
      uint64_t v17 = [(model_fwEnd_10pct *)v15 initWithContentsOfURL:v8 configuration:v16 error:&v24];
      id v18 = v24;

      char v19 = (void *)*((void *)this + 4);
      *((void *)this + 4) = v17;

      if (v18)
      {
        uint64_t v20 = 0;
        id v13 = v18;
      }
      else
      {
        char v21 = [[model_fwEnd_10pctInput alloc] initWithIn:*(void *)this lstm_1_h_in:0 lstm_1_c_in:0];
        int v22 = (void *)*((void *)this + 3);
        *((void *)this + 3) = v21;

        id v13 = 0;
        uint64_t v20 = 1;
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
  }
  else
  {
    uint64_t v20 = 0;
    id v13 = 0;
  }

  return v20;
}

void sub_257D4E480(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Nightingale::ngt_dnn_fw_predict_t::~ngt_dnn_fw_predict_t(id **this)
{
  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

{
  id *v1;

  uint64_t v1 = *this;
  *this = 0;
  if (v1) {
    std::default_delete<Nightingale::PeriodPredictorWrapper_t>::operator()[abi:ne180100]((uint64_t)this, v1);
  }
}

uint64_t Nightingale::ngt_dnn_fw_predict_t::ngt_dnn_process_fw(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return 0;
}

uint64_t Nightingale::fwPredictorWrapper_t::predictFW(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  std::vector<double>::vector(&__p, 0xE1uLL);
  uint64_t v6 = 0;
  uint64_t v7 = *a2;
  uint64_t v8 = __p;
  uint64_t v9 = (char *)__p + 16;
  uint64_t v10 = a2[3];
  uint64_t v11 = a2[6];
  uint64_t v12 = a2[9];
  uint64_t v13 = a2[12];
  do
  {
    *(v9 - 2) = *(void *)(v7 + v6);
    *(v9 - 1) = *(void *)(v10 + v6);
    void *v9 = *(void *)(v11 + v6);
    v9[1] = *(void *)(v12 + v6);
    id v9[2] = *(void *)(v13 + v6);
    v6 += 8;
    v9 += 5;
  }
  while (v6 != 360);
  int v14 = v48;
  int v15 = (void *)[*(id *)a1 dataPointer];
  size_t v16 = v14 - v8;
  if (v14 != v8) {
    memmove(v15, v8, v16);
  }
  uint64_t v17 = objc_msgSend(*(id *)(a1 + 32), "model", v16);
  uint64_t v18 = *(void *)(a1 + 24);
  id v46 = 0;
  char v19 = [v17 predictionFromFeatures:v18 error:&v46];
  id v45 = v46;

  uint64_t v20 = [model_fwEnd_10pctOutput alloc];
  char v21 = [v19 featureValueForName:@"out"];
  int v22 = [v21 multiArrayValue];
  int v23 = [v19 featureValueForName:@"lstm_1_h_out"];
  id v24 = [v23 multiArrayValue];
  id v25 = [v19 featureValueForName:@"lstm_1_c_out"];
  char v26 = [v25 multiArrayValue];
  char v27 = [(model_fwEnd_10pctOutput *)v20 initWithOut:v22 lstm_1_h_out:v24 lstm_1_c_out:v26];

  for (uint64_t i = 0; i != 32; ++i)
  {
    char v29 = [(model_fwEnd_10pctOutput *)v27 out];
    int v30 = [v29 objectAtIndexedSubscript:i];
    [v30 doubleValue];
    float v32 = v31;
    char v34 = *(float **)(a3 + 8);
    unint64_t v33 = *(void *)(a3 + 16);
    if ((unint64_t)v34 >= v33)
    {
      char v36 = *(float **)a3;
      uint64_t v37 = ((uint64_t)v34 - *(void *)a3) >> 2;
      unint64_t v38 = v37 + 1;
      if ((unint64_t)(v37 + 1) >> 62) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v39 = v33 - (void)v36;
      if (v39 >> 1 > v38) {
        unint64_t v38 = v39 >> 1;
      }
      if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v40 = v38;
      }
      if (v40)
      {
        int v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a3 + 16, v40);
        char v36 = *(float **)a3;
        char v34 = *(float **)(a3 + 8);
      }
      else
      {
        int v41 = 0;
      }
      int v42 = (float *)&v41[4 * v37];
      *int v42 = v32;
      char v35 = v42 + 1;
      while (v34 != v36)
      {
        int v43 = *((_DWORD *)v34-- - 1);
        *((_DWORD *)v42-- - 1) = v43;
      }
      *(void *)a3 = v42;
      *(void *)(a3 + 8) = v35;
      *(void *)(a3 + 16) = &v41[4 * v40];
      if (v36) {
        operator delete(v36);
      }
    }
    else
    {
      *char v34 = v32;
      char v35 = v34 + 1;
    }
    *(void *)(a3 + 8) = v35;
  }
  if (__p)
  {
    int v48 = __p;
    operator delete(__p);
  }

  return 0;
}

void sub_257D4E808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

double Nightingale::fwPredictorWrapper_t::fwPredictorWrapper_t(Nightingale::fwPredictorWrapper_t *this)
{
  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

{
  double result;

  *((void *)this + 4) = 0;
  double result = 0.0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

float Nightingale::vVar<float>(float *a1, int a2, char a3)
{
  if (!a2) {
    return 0.0;
  }
  if (a2 < 1) {
    goto LABEL_12;
  }
  int v3 = 0;
  float v4 = 0.0;
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  do
  {
    float v7 = *v5++;
    float v8 = v7;
    int v9 = LODWORD(v7) & 0x7FFFFFFF;
    if ((LODWORD(v7) & 0x7FFFFFFFu) >= 0x7F800000) {
      float v8 = -0.0;
    }
    float v4 = v4 + v8;
    if (v9 < 2139095040) {
      ++v3;
    }
    --v6;
  }
  while (v6);
  if (v3) {
    float v10 = v4 / (float)v3;
  }
  else {
LABEL_12:
  }
    float v10 = NAN;
  int v12 = 0;
  if (a2 <= 1) {
    LODWORD(v13) = 1;
  }
  else {
    LODWORD(v13) = a2;
  }
  uint64_t v13 = (int)v13;
  float result = 0.0;
  do
  {
    float v14 = *a1++;
    float v15 = v14 - v10;
    int v16 = LODWORD(v14) & 0x7FFFFFFF;
    if ((LODWORD(v14) & 0x7FFFFFFFu) < 0x7F800000) {
      float result = result + (float)(v15 * v15);
    }
    if (v16 < 2139095040) {
      ++v12;
    }
    --v13;
  }
  while (v13);
  if (a3)
  {
    if (a2 == 1) {
      return result;
    }
    --v12;
  }
  return result / (float)v12;
}

float Nightingale::vMean<float>(float *a1, int a2)
{
  if (a2 < 1) {
    return NAN;
  }
  int v2 = 0;
  uint64_t v3 = a2;
  float v4 = 0.0;
  do
  {
    float v5 = *a1++;
    float v6 = v5;
    int v7 = LODWORD(v5) & 0x7FFFFFFF;
    if ((LODWORD(v5) & 0x7FFFFFFFu) >= 0x7F800000) {
      float v6 = -0.0;
    }
    float v4 = v4 + v6;
    if (v7 < 2139095040) {
      ++v2;
    }
    --v3;
  }
  while (v3);
  if (v2) {
    return v4 / (float)v2;
  }
  else {
    return NAN;
  }
}

double Nightingale::vVar<double>(float *a1, int a2, char a3)
{
  if (!a2) {
    return 0.0;
  }
  if (a2 < 1) {
    goto LABEL_12;
  }
  int v3 = 0;
  double v4 = 0.0;
  float v5 = a1;
  uint64_t v6 = a2;
  do
  {
    float v7 = *v5++;
    double v8 = v7;
    int v9 = LODWORD(v7) & 0x7FFFFFFF;
    double v10 = -0.0;
    if ((LODWORD(v7) & 0x7FFFFFFFu) < 0x7F800000) {
      double v10 = v8;
    }
    double v4 = v4 + v10;
    if (v9 < 2139095040) {
      ++v3;
    }
    --v6;
  }
  while (v6);
  if (v3) {
    double v11 = v4 / (double)v3;
  }
  else {
LABEL_12:
  }
    double v11 = NAN;
  int v13 = 0;
  if (a2 <= 1) {
    LODWORD(v14) = 1;
  }
  else {
    LODWORD(v14) = a2;
  }
  uint64_t v14 = (int)v14;
  double result = 0.0;
  do
  {
    float v15 = *a1++;
    int v16 = LODWORD(v15) & 0x7FFFFFFF;
    double v17 = result + (v15 - v11) * (v15 - v11);
    if ((LODWORD(v15) & 0x7FFFFFFFu) < 0x7F800000) {
      double result = v17;
    }
    if (v16 < 2139095040) {
      ++v13;
    }
    --v14;
  }
  while (v14);
  if (a3)
  {
    if (a2 == 1) {
      return result;
    }
    --v13;
  }
  return result / (double)v13;
}

double Nightingale::vMean<double>(float *a1, int a2)
{
  if (a2 < 1) {
    return NAN;
  }
  int v2 = 0;
  double v3 = 0.0;
  uint64_t v4 = a2;
  do
  {
    float v5 = *a1++;
    double v6 = v5;
    int v7 = LODWORD(v5) & 0x7FFFFFFF;
    double v8 = -0.0;
    if ((LODWORD(v5) & 0x7FFFFFFFu) < 0x7F800000) {
      double v8 = v6;
    }
    double v3 = v3 + v8;
    if (v7 < 2139095040) {
      ++v2;
    }
    --v4;
  }
  while (v4);
  if (v2) {
    return v3 / (double)v2;
  }
  else {
    return NAN;
  }
}

float Nightingale::vMedian<float>(const void *a1, int a2)
{
  if (!a2) {
    return 0.0;
  }
  __n128 __p = 0;
  int v9 = 0;
  uint64_t v10 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, a1, (uint64_t)a1 + 4 * a2, a2);
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = a2 + 1;
  }
  uint64_t v4 = (float *)((char *)__p + 4 * (v3 >> 1) + 4);
  if (__p != v4) {
    std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>,std::__wrap_iter<float *>>((float *)__p, v4, v9, (uint64_t)&v11);
  }
  uint64_t v5 = (uint64_t)v3 >> 1;
  if (a2) {
    float v6 = *((float *)__p + v5);
  }
  else {
    float v6 = (float)(*((float *)__p + (int)v5 - 1) + *((float *)__p + v5)) * 0.5;
  }
  int v9 = (float *)__p;
  operator delete(__p);
  return v6;
}

void sub_257D4EBFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::vMedian<double>(const void *a1, int a2)
{
  if (!a2) {
    return 0.0;
  }
  __n128 __p = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, a1, (uint64_t)a1 + 4 * a2, a2);
  if (a2 >= 0) {
    int v3 = a2;
  }
  else {
    int v3 = a2 + 1;
  }
  uint64_t v4 = (float *)((char *)__p + 4 * (v3 >> 1) + 4);
  if (__p != v4) {
    std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>,std::__wrap_iter<float *>>((float *)__p, v4, v10, (uint64_t)&v12);
  }
  uint64_t v5 = (uint64_t)v3 >> 1;
  if (a2) {
    float v6 = *((float *)__p + v5);
  }
  else {
    float v6 = (float)(*((float *)__p + (int)v5 - 1) + *((float *)__p + v5)) * 0.5;
  }
  double v7 = v6;
  uint64_t v10 = (float *)__p;
  operator delete(__p);
  return v7;
}

void sub_257D4ECDC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::getLowRangeStartDur@<X0>(float a1@<S0>, float a2@<S1>, uint64_t a3@<X8>)
{
  LODWORD(a3) = llroundf(a1);
  LODWORD(v4) = llround((float)(a2 - a1) + 1.0);
  return a3 | (v4 << 32);
}

uint64_t Nightingale::getIdxOfMinValFromVec(__int32 **a1)
{
  uint64_t v1 = *a1;
  int v2 = a1[1];
  if (*a1 == v2) {
    return 0;
  }
  int v3 = v1 + 1;
  if (v1 + 1 != v2)
  {
    __int32 v4 = *v1;
    uint64_t v5 = v1 + 1;
    do
    {
      __int32 v7 = *v5++;
      __int32 v6 = v7;
      BOOL v9 = __OFSUB__(v7, v4);
      BOOL v8 = v7 - v4 < 0;
      if (v7 < v4) {
        __int32 v4 = v6;
      }
      if (v8 != v9) {
        uint64_t v1 = v3;
      }
      int v3 = v5;
    }
    while (v5 != v2);
  }
  return Nightingale::getIdxOfValFromVec<int>(a1, *v1);
}

uint64_t Nightingale::getIdxOfValFromVec<int>(__int32 **a1, __int32 a2)
{
  int v3 = *a1;
  __int32 v4 = a1[1];
  if (v3 == v4 || ((v5 = wmemchr(v3, a2, v4 - v3)) != 0 ? (__int32 v6 = v5) : (__int32 v6 = v4), v6 == a1[1]))
  {
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v7 = v6 - *a1;
    uint64_t v8 = v7 & 0xFFFFFF00;
    uint64_t v9 = v7;
    uint64_t v10 = 0x100000000;
  }
  return v9 | v10 | v8;
}

void Nightingale::getVarianceWin(uint64_t a1, int a2)
{
  __int32 v4 = *(float **)a1;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = v5 - *(void *)a1;
  if (v6 == 4)
  {
    if (v4 == (float *)v5 || *v4 == (float)a2) {
      return;
    }
  }
  else if (v4 == (float *)v5)
  {
    return;
  }
  __n128 __p = 0;
  char v19 = 0;
  uint64_t v20 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v4, v5, v6 >> 2);
  float Mean = Nightingale::getMeanWin<float>((float **)&__p, a2);
  if (__p)
  {
    char v19 = __p;
    operator delete(__p);
  }
  uint64_t v10 = *(float **)a1;
  uint64_t v9 = *(float **)(a1 + 8);
  float v11 = (float)a2;
  if (v9 != *(float **)a1)
  {
    int v12 = 0;
    int v13 = *(float **)a1;
    do
    {
      float v14 = *v13++;
      if (v14 == v11) {
        ++v12;
      }
    }
    while (v13 != v9);
    if ((((unint64_t)v9 - *(void *)a1) >> 2) != v12)
    {
      float v15 = 0.0;
      while (v10 != v9)
      {
        float v16 = *v10++;
        float v17 = v15 + (float)((float)(v16 - Mean) * (float)(v16 - Mean));
        if (vabds_f32(v16, v11) >= 1.0e-12) {
          float v15 = v17;
        }
      }
    }
  }
}

void sub_257D4EF04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::pooledVar2Win(float **a1, float **a2, int a3)
{
  __int32 v4 = *a1;
  uint64_t v5 = a1[1];
  if (*a1 != v5)
  {
    uint64_t v7 = *a2;
    uint64_t v8 = a2[1];
    if (*a2 != v8)
    {
      int v9 = 0;
      unint64_t v10 = (char *)v5 - (char *)v4;
      float v11 = (float)a3;
      do
      {
        float v12 = *v4++;
        if (v12 == v11) {
          ++v9;
        }
      }
      while (v4 != v5);
      int v13 = 0;
      unint64_t v14 = v10 >> 2;
      unint64_t v15 = (char *)v8 - (char *)v7;
      do
      {
        float v16 = *v7++;
        if (v16 == v11) {
          ++v13;
        }
      }
      while (v7 != v8);
      if (v14 != v9 && (v15 >> 2) != v13 && (int)((v15 >> 2) - v13 + v14 - v9) >= 3)
      {
        Nightingale::getVarianceWin((uint64_t)a1, a3);
        Nightingale::getVarianceWin((uint64_t)a2, a3);
      }
    }
  }
}

uint64_t Nightingale::getMeanDiffOf2Windows(uint64_t a1, float **a2, float a3)
{
  uint64_t v5 = *(float **)a1;
  uint64_t v6 = *(void *)(a1 + 8);
  if (*(void *)a1 == v6)
  {
    int v10 = 0;
  }
  else
  {
    double v7 = 0.0;
    uint64_t v8 = *(float **)a1;
    do
    {
      float v9 = *v8++;
      double v7 = v7 + v9;
    }
    while (v8 != (float *)v6);
    int v10 = (int)v7;
  }
  float v11 = a2[1];
  if (*a2 == v11)
  {
    int v15 = 0;
  }
  else
  {
    double v12 = 0.0;
    int v13 = *a2;
    do
    {
      float v14 = *v13++;
      double v12 = v12 + v14;
    }
    while (v13 != v11);
    int v15 = (int)v12;
  }
  unint64_t v16 = (v6 - (uint64_t)v5) >> 2;
  if (v10 == (int)(float)((float)v16 * a3) || v15 == (int)(float)((float)(unint64_t)(v11 - *a2) * a3))
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
  else
  {
    __n128 __p = 0;
    char v26 = 0;
    uint64_t v27 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v5, v6, v16);
    float Mean = Nightingale::getMeanWin<float>((float **)&__p, (int)a3);
    if (__p)
    {
      char v26 = __p;
      operator delete(__p);
    }
    int v22 = 0;
    int v23 = 0;
    uint64_t v24 = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v22, *a2, (uint64_t)a2[1], a2[1] - *a2);
    float v20 = Nightingale::getMeanWin<float>((float **)&v22, (int)a3);
    if (v22)
    {
      int v23 = v22;
      operator delete(v22);
    }
    uint64_t v17 = 0x100000000;
    if (Mean != a3 && v20 != a3)
    {
      uint64_t v18 = COERCE_UNSIGNED_INT(v20 - Mean);
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
    }
  }
  return v18 | v17;
}

void sub_257D4F1B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (__p)
  {
    *double v12 = __p;
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float Nightingale::getSigmoid(Nightingale *this, float a2)
{
  return 1.0 / (float)(expf(-a2) + 1.0);
}

float Nightingale::getLogit(Nightingale *this, float a2)
{
  return -logf((float)(1.0 / a2) + -1.0);
}

BOOL Nightingale::check2Real_t_equal(Nightingale *this, float a2, float a3)
{
  return vabds_f32(a2, a3) < 1.0e-12;
}

float Nightingale::getSlidingWinScore(uint64_t a1, float **a2, float a3)
{
  float v3 = a3;
  uint64_t MeanDiffOf2Windows = Nightingale::getMeanDiffOf2Windows(a1, a2, a3);
  if ((MeanDiffOf2Windows & 0xFF00000000) != 0) {
    return 1.0 / (float)(expf(-*(float *)&MeanDiffOf2Windows) + 1.0);
  }
  return v3;
}

float Nightingale::getSmoothedPow_aSample(float **a1, uint64_t a2)
{
  int v2 = *a1;
  float v3 = **a1;
  float result = -1.0;
  if (v3 != -1.0)
  {
    float v5 = v2[1];
    if (v5 != -1.0)
    {
      float v6 = v2[2];
      if (v6 != -1.0)
      {
        float v7 = (float)(v5 * *(float *)(*(void *)a2 + 4)) + (float)(v3 * **(float **)a2);
        return (float)(v7 + (float)(v6 * *(float *)(*(void *)a2 + 8)))
             * (float)(v7 + (float)(v6 * *(float *)(*(void *)a2 + 8)));
      }
    }
  }
  return result;
}

uint64_t Nightingale::getMissingCnt(float **a1)
{
  uint64_t v1 = *a1;
  int v2 = a1[1];
  if (*a1 == v2) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    float v4 = *v1++;
    if (v4 >= 0.0) {
      uint64_t result = result;
    }
    else {
      uint64_t result = (result + 1);
    }
  }
  while (v1 != v2);
  return result;
}

BOOL Nightingale::passMissingRateASlice(float **a1, double a2, float a3)
{
  float v3 = a1[1];
  if (*a1 == v3) {
    return 0;
  }
  int v4 = 0;
  float v5 = *a1;
  do
  {
    float v6 = *v5++;
    if (v6 < 0.0) {
      ++v4;
    }
  }
  while (v5 != v3);
  return (float)((float)(unint64_t)(v3 - *a1) * a3) >= (float)v4;
}

uint64_t Nightingale::checkNumTmpSwitches(float **a1, int a2, float a3)
{
  float v3 = *a1;
  int v4 = a1[1];
  if (*a1 == v4) {
    return 0;
  }
  int v5 = 0;
  float v6 = *v3;
  while (1)
  {
    float v7 = v6;
    float v6 = *v3;
    if (vabds_f32(*v3, v7) >= a3) {
      break;
    }
LABEL_6:
    if (++v3 == v4) {
      return 0;
    }
  }
  if (v5 < a2)
  {
    ++v5;
    goto LABEL_6;
  }
  return 1;
}

long double Nightingale::gaussian_pdf(Nightingale *this, double a2, double a3, double a4)
{
  if (a4 != 0.0) {
    return 1.0 / sqrt(a4 * 6.28318531) * exp(-((a2 - a3) * (a2 - a3)) / (a4 + a4));
  }
  BOOL v4 = round(a3) == a2;
  long double result = 0.0;
  if (v4) {
    return 1.0;
  }
  return result;
}

long double Nightingale::gamma_pdf(Nightingale *this, long double a2, double a3, double a4)
{
  double v5 = a3 / a4;
  long double v6 = a3 * a3 / a4;
  double v7 = pow(a3 / a4, v6);
  long double v8 = v7 * pow(a2, v6 + -1.0);
  long double v9 = exp(-(v5 * a2)) * v8;
  return v9 / tgamma(v6);
}

void Nightingale::get_cdf(float **a1, uint64_t a2, char a3)
{
  long double v6 = *a1;
  double v5 = a1[1];
  unint64_t v7 = v5 - *a1;
  long double v8 = *(float **)a2;
  *(void *)(a2 + 8) = *(void *)a2;
  if (a3)
  {
    long double v9 = a1[1];
    double v10 = 0.0;
    if (v6 != v9)
    {
      float v11 = v6;
      do
      {
        float v12 = *v11++;
        double v10 = v10 + v12;
      }
      while (v11 != v9);
    }
    if (v5 != v6)
    {
      uint64_t v13 = 0;
      float v14 = (void *)(a2 + 16);
      if (v7 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v7;
      }
      do
      {
        float v16 = v10;
        if ((unint64_t)v8 >= *v14)
        {
          uint64_t v18 = *(float **)a2;
          uint64_t v19 = ((uint64_t)v8 - *(void *)a2) >> 2;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 62) {
            goto LABEL_50;
          }
          uint64_t v21 = *v14 - (void)v18;
          if (v21 >> 1 > v20) {
            unint64_t v20 = v21 >> 1;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            int v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a2 + 16, v22);
            uint64_t v18 = *(float **)a2;
            long double v8 = *(float **)(a2 + 8);
          }
          else
          {
            int v23 = 0;
          }
          uint64_t v24 = (float *)&v23[4 * v19];
          *uint64_t v24 = v16;
          uint64_t v17 = v24 + 1;
          while (v8 != v18)
          {
            int v25 = *((_DWORD *)v8-- - 1);
            *((_DWORD *)v24-- - 1) = v25;
          }
          *(void *)a2 = v24;
          *(void *)(a2 + 8) = v17;
          *(void *)(a2 + 16) = &v23[4 * v22];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          float *v8 = v16;
          uint64_t v17 = v8 + 1;
        }
        float v26 = (*a1)[v13];
        *(void *)(a2 + 8) = v17;
        double v10 = v10 - v26;
        ++v13;
        long double v8 = v17;
      }
      while (v13 != v15);
    }
  }
  else if (v5 != v6)
  {
    uint64_t v27 = 0;
    char v28 = (void *)(a2 + 16);
    if (v7 <= 1) {
      uint64_t v29 = 1;
    }
    else {
      uint64_t v29 = v7;
    }
    double v30 = 0.0;
    do
    {
      double v30 = v30 + (*a1)[v27];
      float v31 = v30;
      if ((unint64_t)v8 >= *v28)
      {
        unint64_t v33 = *(float **)a2;
        uint64_t v34 = ((uint64_t)v8 - *(void *)a2) >> 2;
        unint64_t v35 = v34 + 1;
        if ((unint64_t)(v34 + 1) >> 62) {
LABEL_50:
        }
          std::vector<float>::__throw_length_error[abi:ne180100]();
        uint64_t v36 = *v28 - (void)v33;
        if (v36 >> 1 > v35) {
          unint64_t v35 = v36 >> 1;
        }
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v37 = v35;
        }
        if (v37)
        {
          unint64_t v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a2 + 16, v37);
          unint64_t v33 = *(float **)a2;
          long double v8 = *(float **)(a2 + 8);
        }
        else
        {
          unint64_t v38 = 0;
        }
        uint64_t v39 = (float *)&v38[4 * v34];
        float *v39 = v31;
        float v32 = v39 + 1;
        while (v8 != v33)
        {
          int v40 = *((_DWORD *)v8-- - 1);
          *((_DWORD *)v39-- - 1) = v40;
        }
        *(void *)a2 = v39;
        *(void *)(a2 + 8) = v32;
        *(void *)(a2 + 16) = &v38[4 * v37];
        if (v33) {
          operator delete(v33);
        }
      }
      else
      {
        float *v8 = v31;
        float v32 = v8 + 1;
      }
      *(void *)(a2 + 8) = v32;
      ++v27;
      long double v8 = v32;
    }
    while (v27 != v29);
  }
}

double Nightingale::get_mad(float **a1, int a2)
{
  int v2 = *a1;
  float v3 = a1[1];
  uint64_t v5 = (char *)v3 - (char *)v2;
  if (v3 == v2) {
    return 0.0;
  }
  unint64_t v6 = v5 >> 2;
  if (!a2) {
    Nightingale::vMedian<double>();
  }
  if ((int)((unint64_t)v5 >> 2) < 1) {
    goto LABEL_14;
  }
  int v7 = 0;
  uint64_t v8 = ((unint64_t)v5 >> 2);
  double v9 = 0.0;
  double v10 = v2;
  do
  {
    float v11 = *v10++;
    double v12 = v11;
    int v13 = LODWORD(v11) & 0x7FFFFFFF;
    double v14 = -0.0;
    if ((LODWORD(v11) & 0x7FFFFFFFu) < 0x7F800000) {
      double v14 = v12;
    }
    double v9 = v9 + v14;
    if (v13 < 2139095040) {
      ++v7;
    }
    --v8;
  }
  while (v8);
  if (v7) {
    double v15 = v9 / (double)v7;
  }
  else {
LABEL_14:
  }
    double v15 = NAN;
  if (v6 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v6;
  }
  double v18 = 0.0;
  do
  {
    float v19 = *v2++;
    double v18 = v18 + vabdd_f64(v19, v15);
    --v17;
  }
  while (v17);
  return v18 / (double)v6;
}

void sub_257D4F920(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::convolve(void *a1, float **a2, uint64_t a3)
{
  uint64_t v3 = (a1[1] - *a1) >> 2;
  uint64_t v5 = *a2;
  BOOL v4 = a2[1];
  unint64_t v6 = *(float **)a3;
  *(void *)(a3 + 8) = *(void *)a3;
  if (v3)
  {
    unsigned int v10 = 0;
    unint64_t v11 = (unint64_t)((char *)v4 - (char *)v5) >> 2;
    double v12 = (void *)(a3 + 16);
    unint64_t v13 = 1;
    do
    {
      unsigned int v14 = v10 + 1;
      if (v13 >= v11) {
        unint64_t v15 = v11;
      }
      else {
        unint64_t v15 = v13;
      }
      if (v14 < v11) {
        unsigned int v16 = v10 + 1;
      }
      else {
        unsigned int v16 = v11;
      }
      if (v16)
      {
        uint64_t v17 = *a2;
        double v18 = 0.0;
        do
        {
          float v19 = *v17++;
          double v18 = v18 + (float)(*(float *)(*a1 + 4 * v10--) * v19);
          --v15;
        }
        while (v15);
      }
      else
      {
        double v18 = 0.0;
      }
      float v20 = v18;
      if ((unint64_t)v6 >= *v12)
      {
        unint64_t v22 = *(float **)a3;
        uint64_t v23 = ((uint64_t)v6 - *(void *)a3) >> 2;
        unint64_t v24 = v23 + 1;
        if ((unint64_t)(v23 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v25 = *v12 - (void)v22;
        if (v25 >> 1 > v24) {
          unint64_t v24 = v25 >> 1;
        }
        if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v26 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26)
        {
          uint64_t v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v26);
          unint64_t v22 = *(float **)a3;
          unint64_t v6 = *(float **)(a3 + 8);
        }
        else
        {
          uint64_t v27 = 0;
        }
        char v28 = (float *)&v27[4 * v23];
        *char v28 = v20;
        uint64_t v21 = v28 + 1;
        while (v6 != v22)
        {
          int v29 = *((_DWORD *)v6-- - 1);
          *((_DWORD *)v28-- - 1) = v29;
        }
        *(void *)a3 = v28;
        *(void *)(a3 + 8) = v21;
        *(void *)(a3 + 16) = &v27[4 * v26];
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        float *v6 = v20;
        uint64_t v21 = v6 + 1;
      }
      *(void *)(a3 + 8) = v21;
      ++v13;
      unint64_t v6 = v21;
      unsigned int v10 = v14;
    }
    while (v14 != v3);
  }
}

void Nightingale::convolve_on_top(uint64_t *a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v6 = *(float **)a3;
  *(void *)(a3 + 8) = *(void *)a3;
  uint64_t v7 = v4 - v5;
  if (v7)
  {
    uint64_t v11 = v7 >> 2;
    double v12 = (void *)(a3 + 16);
    if ((unint64_t)(v7 >> 2) <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v7 >> 2;
    }
    if (a4)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      unint64_t v16 = v7 >> 2;
      do
      {
        uint64_t v17 = v11 - v15;
        double v18 = *(float **)a2;
        unint64_t v19 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
        if (v19 < v11 - v15) {
          uint64_t v17 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
        }
        if (v17)
        {
          if (v19 >= v16) {
            unint64_t v19 = v16;
          }
          float v20 = (float *)(*a1 + v14);
          double v21 = 0.0;
          do
          {
            float v22 = *v20++;
            float v23 = v22;
            float v24 = *v18++;
            double v21 = v21 + (float)(v23 * v24);
            --v19;
          }
          while (v19);
        }
        else
        {
          double v21 = 0.0;
        }
        float v25 = v21;
        if ((unint64_t)v6 >= *v12)
        {
          uint64_t v27 = *(float **)a3;
          uint64_t v28 = ((uint64_t)v6 - *(void *)a3) >> 2;
          unint64_t v29 = v28 + 1;
          if ((unint64_t)(v28 + 1) >> 62) {
            goto LABEL_63;
          }
          uint64_t v30 = *v12 - (void)v27;
          if (v30 >> 1 > v29) {
            unint64_t v29 = v30 >> 1;
          }
          if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v31 = v29;
          }
          if (v31)
          {
            float v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v31);
            uint64_t v27 = *(float **)a3;
            unint64_t v6 = *(float **)(a3 + 8);
          }
          else
          {
            float v32 = 0;
          }
          unint64_t v33 = (float *)&v32[4 * v28];
          *unint64_t v33 = v25;
          unint64_t v26 = v33 + 1;
          while (v6 != v27)
          {
            int v34 = *((_DWORD *)v6-- - 1);
            *((_DWORD *)v33-- - 1) = v34;
          }
          *(void *)a3 = v33;
          *(void *)(a3 + 8) = v26;
          *(void *)(a3 + 16) = &v32[4 * v31];
          if (v27) {
            operator delete(v27);
          }
        }
        else
        {
          float *v6 = v25;
          unint64_t v26 = v6 + 1;
        }
        ++v15;
        *(void *)(a3 + 8) = v26;
        --v16;
        v14 += 4;
        unint64_t v6 = v26;
      }
      while (v15 != v13);
    }
    else
    {
      uint64_t v35 = 0;
      unint64_t v36 = 0;
      unint64_t v37 = 1;
      do
      {
        unint64_t v38 = v36++;
        uint64_t v39 = *(float **)a2;
        unint64_t v40 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
        if (v40 >= v36) {
          uint64_t v41 = v38 + 1;
        }
        else {
          uint64_t v41 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
        }
        if (v41)
        {
          if (v40 >= v37) {
            unint64_t v40 = v37;
          }
          int v42 = (float *)(*a1 + v35);
          double v43 = 0.0;
          do
          {
            float v44 = *v42--;
            float v45 = v44;
            float v46 = *v39++;
            double v43 = v43 + (float)(v45 * v46);
            --v40;
          }
          while (v40);
        }
        else
        {
          double v43 = 0.0;
        }
        float v47 = v43;
        if ((unint64_t)v6 >= *v12)
        {
          int v49 = *(float **)a3;
          uint64_t v50 = ((uint64_t)v6 - *(void *)a3) >> 2;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62) {
LABEL_63:
          }
            std::vector<float>::__throw_length_error[abi:ne180100]();
          uint64_t v52 = *v12 - (void)v49;
          if (v52 >> 1 > v51) {
            unint64_t v51 = v52 >> 1;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v53 = v51;
          }
          if (v53)
          {
            int v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v53);
            int v49 = *(float **)a3;
            unint64_t v6 = *(float **)(a3 + 8);
          }
          else
          {
            int v54 = 0;
          }
          __int16 v55 = (float *)&v54[4 * v50];
          *__int16 v55 = v47;
          int v48 = v55 + 1;
          while (v6 != v49)
          {
            int v56 = *((_DWORD *)v6-- - 1);
            *((_DWORD *)v55-- - 1) = v56;
          }
          *(void *)a3 = v55;
          *(void *)(a3 + 8) = v48;
          *(void *)(a3 + 16) = &v54[4 * v53];
          if (v49) {
            operator delete(v49);
          }
        }
        else
        {
          float *v6 = v47;
          int v48 = v6 + 1;
        }
        *(void *)(a3 + 8) = v48;
        ++v37;
        v35 += 4;
        unint64_t v6 = v48;
      }
      while (v36 != v13);
    }
  }
}

BOOL Nightingale::checkOffsetGetSegFromVector(Nightingale *this, int a2, int a3)
{
  return (int)this >= 0 && (int)this <= a3 && a2 >= (int)this && a2 <= a3;
}

uint64_t Nightingale::assertVectorOfVectors(uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  int v2 = *(void **)(a1 + 8);
  if (*(void **)a1 != v2)
  {
    uint64_t v3 = v1[1];
    if (*v1 != v3)
    {
      uint64_t v4 = (int)((v3 - *v1) >> 2);
      while (1)
      {
        uint64_t v5 = v1[1];
        if (*v1 == v5 || v4 != (v5 - *v1) >> 2) {
          break;
        }
        v1 += 3;
        if (v1 == v2) {
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t Nightingale::getSubVecLenVecOfVecs(uint64_t a1)
{
  uint64_t result = Nightingale::assertVectorOfVectors(a1);
  if (result) {
    return (*(void *)(*(void *)a1 + 8) - **(void **)a1) >> 2;
  }
  return result;
}

unint64_t Nightingale::getFWFromPeriodStart(Nightingale *this)
{
  return (int)(float)((float)(int)this + -18.0) | ((unint64_t)(int)(float)((float)(int)this + -13.0) << 32);
}

unint64_t Nightingale::lutealPhaseCheck(Nightingale *this, float a2, float a3)
{
  float v3 = roundf(a2) - (float)(int)this;
  return ((int)a3 <= (int)v3) | ((unint64_t)COERCE_UNSIGNED_INT((float)(int)v3) << 32);
}

BOOL Nightingale::passLutealPhaseCheck(Nightingale *this, float a2, float a3)
{
  return (float)(roundf(a2) - (float)(int)this) >= (float)(int)a3;
}

unint64_t Nightingale::follicularPhaseCheck(Nightingale *this, int a2, int a3)
{
  BOOL v4 = (int)this >= a2 && (int)this <= a3;
  return v4 | ((unint64_t)COERCE_UNSIGNED_INT((float)(int)this) << 32);
}

uint64_t Nightingale::CGradient::CGradient(uint64_t this)
{
  *(_WORD *)(this + 32) = 0;
  *(unsigned char *)(this + 34) = 0;
  *(unsigned char *)(this + 36) = 0;
  *(unsigned char *)(this + 40) = 0;
  *(unsigned char *)(this + 44) = 0;
  *(unsigned char *)(this + 48) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = 0;
  return this;
}

{
  *(_WORD *)(this + 32) = 0;
  *(unsigned char *)(this + 34) = 0;
  *(unsigned char *)(this + 36) = 0;
  *(unsigned char *)(this + 40) = 0;
  *(unsigned char *)(this + 44) = 0;
  *(unsigned char *)(this + 48) = 0;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)this = 0;
  return this;
}

uint64_t Nightingale::CGradient::CGradient(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 34) = 0;
  *(unsigned char *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 44) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  if (a1 != a2) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a1, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  }
  return a1;
}

void sub_257D4FF7C(_Unwind_Exception *exception_object)
{
  float v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::CGradient::set_delta_at(Nightingale::CGradient *this, uint64_t a2)
{
  uint64_t v5 = *(_DWORD **)this;
  uint64_t v4 = *((void *)this + 1);
  if (*(void *)this == v4)
  {
    if (a2 != -1)
    {
      uint64_t v6 = 0;
      uint64_t v7 = (void *)((char *)this + 16);
      do
      {
        if ((unint64_t)v5 >= *v7)
        {
          double v9 = *(_DWORD **)this;
          uint64_t v10 = ((uint64_t)v5 - *(void *)this) >> 2;
          unint64_t v11 = v10 + 1;
          if ((unint64_t)(v10 + 1) >> 62) {
            std::vector<float>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v12 = *v7 - (void)v9;
          if (v12 >> 1 > v11) {
            unint64_t v11 = v12 >> 1;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v11;
          }
          if (v13)
          {
            uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 16, v13);
            double v9 = *(_DWORD **)this;
            uint64_t v5 = (_DWORD *)*((void *)this + 1);
          }
          else
          {
            uint64_t v14 = 0;
          }
          uint64_t v15 = &v14[4 * v10];
          *(_DWORD *)uint64_t v15 = 0;
          uint64_t v8 = v15 + 4;
          while (v5 != v9)
          {
            int v16 = *--v5;
            *((_DWORD *)v15 - 1) = v16;
            v15 -= 4;
          }
          *(void *)this = v15;
          *((void *)this + 1) = v8;
          *((void *)this + 2) = &v14[4 * v13];
          if (v9) {
            operator delete(v9);
          }
        }
        else
        {
          _DWORD *v5 = 0;
          uint64_t v8 = v5 + 1;
        }
        *((void *)this + 1) = v8;
        uint64_t v5 = v8;
      }
      while (v6++ != a2);
    }
  }
  else
  {
    int v18 = 0;
    std::vector<float>::assign((char **)this, (v4 - (uint64_t)v5) >> 2, &v18);
  }
  *(_DWORD *)(*(void *)this + 4 * a2) = 1065353216;
  *((unsigned char *)this + 32) = 1;
}

void Nightingale::CGradient::push_back(Nightingale::CGradient *this, double a2)
{
  float v3 = (float *)*((void *)this + 1);
  if (*((unsigned char *)this + 32))
  {
    uint64_t v4 = *(float **)this;
    if (v3 != *(float **)this)
    {
      unint64_t v5 = ((uint64_t)v3 - *(void *)this) >> 2;
      double v6 = *((double *)this + 3);
      if (v5 <= 1) {
        unint64_t v5 = 1;
      }
      do
      {
        float v7 = v6 * *v4;
        *v4++ = v7;
        --v5;
      }
      while (v5);
    }
    *((unsigned char *)this + 32) = 0;
  }
  float v8 = a2;
  unint64_t v9 = *((void *)this + 2);
  if ((unint64_t)v3 >= v9)
  {
    unint64_t v11 = *(float **)this;
    uint64_t v12 = ((uint64_t)v3 - *(void *)this) >> 2;
    unint64_t v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v14 = v9 - (void)v11;
    if (v14 >> 1 > v13) {
      unint64_t v13 = v14 >> 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v15 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      int v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 16, v15);
      unint64_t v11 = *(float **)this;
      float v3 = (float *)*((void *)this + 1);
    }
    else
    {
      int v16 = 0;
    }
    uint64_t v17 = (float *)&v16[4 * v12];
    int v18 = &v16[4 * v15];
    *uint64_t v17 = v8;
    uint64_t v10 = v17 + 1;
    while (v3 != v11)
    {
      int v19 = *((_DWORD *)v3-- - 1);
      *((_DWORD *)v17-- - 1) = v19;
    }
    *(void *)this = v17;
    *((void *)this + 1) = v10;
    *((void *)this + 2) = v18;
    if (v11) {
      operator delete(v11);
    }
  }
  else
  {
    float *v3 = v8;
    uint64_t v10 = v3 + 1;
  }
  *((void *)this + 1) = v10;
}

void Nightingale::CGradient::annihilateEarly(char **this, unint64_t a2)
{
  float v3 = *this;
  if (a2 <= (this[1] - v3) >> 2)
  {
    if (a2) {
      bzero(v3, 4 * a2);
    }
  }
  else
  {
    int v5 = 0;
    std::vector<float>::assign(this, a2, &v5);
  }
  *((unsigned char *)this + 32) = 0;
}

uint64_t Nightingale::CGradient::normalize(uint64_t this)
{
  if (!*(unsigned char *)(this + 32))
  {
    uint64_t v1 = *(float **)this;
    int v2 = *(float **)(this + 8);
    if (*(float **)this == v2)
    {
      *(void *)(this + 24) = 0;
    }
    else
    {
      double v3 = 0.0;
      uint64_t v4 = *(float **)this;
      do
      {
        float v5 = *v4++;
        double v3 = v3 + v5;
      }
      while (v4 != v2);
      *(double *)(this + 24) = v3;
      if (v3 > 0.0)
      {
        unint64_t v6 = v2 - v1;
        if (v6 <= 1) {
          unint64_t v6 = 1;
        }
        do
        {
          float v7 = *v1 / v3;
          *v1++ = v7;
          --v6;
        }
        while (v6);
      }
    }
    *(unsigned char *)(this + 32) = 1;
  }
  return this;
}

void *Nightingale::CGradient::get_list_reference@<X0>(Nightingale::CGradient *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a2, *(const void **)this, *((void *)this + 1), (uint64_t)(*((void *)this + 1) - *(void *)this) >> 2);
}

char *Nightingale::CGradient::set_vGrad(char *result, uint64_t a2)
{
  int v2 = result;
  if (result != (char *)a2) {
    uint64_t result = std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(result, *(char **)a2, *(void *)(a2 + 8), (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  }
  v2[32] = 0;
  return result;
}

uint64_t Nightingale::CGradient::get_isNull(Nightingale::CGradient *this)
{
  return *((unsigned __int8 *)this + 33);
}

uint64_t Nightingale::CGradient::get_adjusted(Nightingale::CGradient *this)
{
  return *((unsigned __int8 *)this + 34);
}

uint64_t Nightingale::CGradient::set_isNull_if_grad_allZeros(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 8);
  if (*(void *)this == v1)
  {
    BOOL v4 = 1;
  }
  else
  {
    uint64_t v2 = *(void *)this + 4;
    do
    {
      float v3 = fabsf(*(float *)(v2 - 4));
      BOOL v4 = v3 < 1.0e-12;
      BOOL v5 = v3 >= 1.0e-12 || v2 == v1;
      v2 += 4;
    }
    while (!v5);
  }
  *(unsigned char *)(this + 33) = v4;
  return this;
}

double Nightingale::CGradient::get_expectation(float **this)
{
  uint64_t v2 = *this;
  uint64_t v1 = this[1];
  if (v1 == *this)
  {
    double v5 = 0.0;
    double v6 = 0.0;
  }
  else
  {
    unint64_t v3 = 0;
    unint64_t v4 = v1 - *this;
    if (v4 <= 1) {
      unint64_t v4 = 1;
    }
    double v5 = 0.0;
    do
    {
      double v5 = v5 + (float)(v2[v3] * (float)v3);
      ++v3;
    }
    while (v4 != v3);
    double v6 = 0.0;
    do
    {
      float v7 = *v2++;
      double v6 = v6 + v7;
    }
    while (v2 != v1);
  }
  if (v6 <= 0.0) {
    double v6 = 1.0;
  }
  return v5 / v6;
}

double Nightingale::CGradient::get_variance(float **this)
{
  double expectation = Nightingale::CGradient::get_expectation(this);
  unint64_t v3 = this[1];
  uint64_t v4 = (char *)v3 - (char *)*this;
  if (v3 == *this) {
    return 0.0;
  }
  unint64_t v5 = 0;
  unint64_t v6 = v4 >> 2;
  if (v6 <= 1) {
    unint64_t v6 = 1;
  }
  double v7 = 0.0;
  do
  {
    double v7 = v7 + ((double)v5 - expectation) * ((double)v5 - expectation) * (*this)[v5];
    ++v5;
  }
  while (v6 != v5);
  return v7;
}

double Nightingale::CGradient::get_std(float **this)
{
  return sqrt(Nightingale::CGradient::get_variance(this));
}

BOOL Nightingale::CGradient::get_vGrad_empty(Nightingale::CGradient *this)
{
  return *(void *)this == *((void *)this + 1);
}

uint64_t Nightingale::CGradient::get_vGrad_len(Nightingale::CGradient *this)
{
  return (*((void *)this + 1) - *(void *)this) >> 2;
}

float Nightingale::cumsum@<S0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(a2, *(const void **)a1, *(void *)(a1 + 8), (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2);
  if (*(void *)a1 != *(void *)(a1 + 8))
  {
    uint64_t v5 = a2[1] - *a2;
    if ((unint64_t)v5 >= 5)
    {
      unint64_t v6 = v5 >> 2;
      uint64_t v7 = 2;
      if (v6 > 2) {
        uint64_t v7 = v6;
      }
      float v8 = (float *)(*a2 + 4);
      uint64_t v9 = v7 - 1;
      do
      {
        if (!v6) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        float result = *(v8 - 1) + *v8;
        *v8++ = result;
        --v6;
        --v9;
      }
      while (v9);
    }
  }
  return result;
}

void sub_257D50564(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t Nightingale::argquantile(void *a1, float a2)
{
  Nightingale::cumsum((uint64_t)a1, &__p);
  if (*a1 == a1[1] || __p == v15)
  {
    float v11 = 0.0;
    uint64_t v12 = 1;
    if (!__p) {
      return v12 | ((unint64_t)LODWORD(v11) << 32);
    }
  }
  else
  {
    uint64_t v4 = (float *)__p;
    while (*v4 < a2)
    {
      if (++v4 == v15)
      {
        uint64_t v4 = v15;
        break;
      }
    }
    uint64_t v5 = (char *)v4 - (unsigned char *)__p;
    unint64_t v6 = (unint64_t)v5 >> 2;
    unint64_t v7 = ((char *)v15 - (unsigned char *)__p) >> 2;
    if (v7 <= (int)((unint64_t)v5 >> 2) || (int v8 = v6 - 1, v7 <= (int)v6 - 1)) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    float v9 = *((float *)__p + (int)(v5 >> 2));
    float v10 = *((float *)__p + v8);
    if (v9 == v10)
    {
      float v11 = 0.0;
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v12 = 0;
      float v11 = (float)((float)(a2 - v10) / (float)(v9 - v10)) + (float)v8;
    }
  }
  unint64_t v15 = (float *)__p;
  operator delete(__p);
  return v12 | ((unint64_t)LODWORD(v11) << 32);
}

void sub_257D50684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float Nightingale::getPercentile(uint64_t *a1, int a2, float a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v5 = ((v4 - *a1) >> 2) - 1;
  float v6 = (float)(unint64_t)v5 * a3;
  if (a2)
  {
    int v7 = (int)v6;
    float v8 = v6 - (float)(int)v6;
    if (v8 == 0.0) {
      return *(float *)(v3 + 4 * v7);
    }
    else {
      return *(float *)(v3 + 4 * v7)
    }
           + (float)((float)(*(float *)(v3 + 4 * v7 + 4) - *(float *)(v3 + 4 * v7)) * v8);
  }
  else
  {
    unint64_t v10 = (unint64_t)((1.0 - a3) * (double)(unint64_t)v5);
    float result = *(float *)(v3 + 4 * (unint64_t)v6);
    float v11 = *(float *)(v4 - 4 * v10 - 4);
    if (result != v11) {
      return (float)(result + v11) * 0.5;
    }
  }
  return result;
}

uint64_t *Nightingale::removeNANFromVector(uint64_t *result)
{
  uint64_t v2 = *result;
  uint64_t v1 = result[1];
  if (*result != v1)
  {
    do
      v2 += 4;
    while (v2 != v1);
  }
  return result;
}

uint64_t Nightingale::getIdxOfDailyInFromJDay(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)a1;
  uint64_t v3 = *(_DWORD **)(a1 + 8);
  if (*(_DWORD **)a1 == v3 || *(v3 - 15) < a2)
  {
LABEL_6:
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    int v7 = 0;
  }
  else
  {
    int v4 = 0;
    while (*v2 != a2)
    {
      ++v4;
      v2 += 15;
      if (v2 == v3) {
        goto LABEL_6;
      }
    }
    int v7 = v4 & 0x7FFFFF00;
    unsigned int v6 = v4;
    uint64_t v5 = 0x100000000;
  }
  return v5 | v7 | v6;
}

uint64_t Nightingale::getIdxOfDailyInGreaterThanJayDay(uint64_t a1, int a2)
{
  uint64_t v2 = *(_DWORD **)a1;
  uint64_t v3 = *(_DWORD **)(a1 + 8);
  if (*(_DWORD **)a1 == v3 || *(v3 - 15) < a2)
  {
LABEL_6:
    uint64_t v5 = 0;
    unsigned int v6 = 0;
    int v7 = 0;
  }
  else
  {
    int v4 = 0;
    while (*v2 < a2)
    {
      ++v4;
      v2 += 15;
      if (v2 == v3) {
        goto LABEL_6;
      }
    }
    int v7 = v4 & 0x7FFFFF00;
    unsigned int v6 = v4;
    uint64_t v5 = 0x100000000;
  }
  return v5 | v7 | v6;
}

float *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>,std::__wrap_iter<float *>>(float *a1, float *a2, float *a3, uint64_t a4)
{
  if (a1 != a2)
  {
    unsigned int v6 = a2;
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    if (v6 == a3)
    {
      a3 = v6;
    }
    else
    {
      unint64_t v13 = v6;
      do
      {
        float v14 = *v13;
        if (*v13 < *a1)
        {
          float *v13 = *a1;
          *a1 = v14;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>((uint64_t)a1, a4, v9, a1);
        }
        ++v13;
      }
      while (v13 != a3);
    }
    if (v8 >= 5)
    {
      uint64_t v15 = (unint64_t)v8 >> 2;
      do
      {
        uint64_t v16 = 0;
        float v17 = *a1;
        int v18 = a1;
        do
        {
          int v19 = v18;
          v18 += v16 + 1;
          uint64_t v20 = 2 * v16;
          uint64_t v16 = (2 * v16) | 1;
          uint64_t v21 = v20 + 2;
          if (v21 < v15 && *v18 < v18[1])
          {
            ++v18;
            uint64_t v16 = v21;
          }
          *int v19 = *v18;
        }
        while (v16 <= (uint64_t)((unint64_t)(v15 - 2) >> 1));
        if (v18 != --v6)
        {
          *int v18 = *v6;
          float *v6 = v17;
          uint64_t v22 = (char *)v18 - (char *)a1 + 4;
          if (v22 < 5) {
            continue;
          }
          unint64_t v23 = (((unint64_t)v22 >> 2) - 2) >> 1;
          float v24 = &a1[v23];
          float v25 = *v24;
          float v17 = *v18;
          if (*v24 >= *v18) {
            continue;
          }
          do
          {
            *int v18 = v25;
            int v18 = v24;
            if (!v23) {
              break;
            }
            unint64_t v23 = (v23 - 1) >> 1;
            float v24 = &a1[v23];
            float v25 = *v24;
          }
          while (*v24 < v17);
        }
        *int v18 = v17;
      }
      while (v15-- > 2);
    }
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<float *>>(uint64_t result, uint64_t a2, uint64_t a3, float *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      uint64_t v6 = v4 >> 1;
      uint64_t v7 = (v4 >> 1) | 1;
      uint64_t v8 = (float *)(result + 4 * v7);
      uint64_t v9 = v6 + 2;
      if (v9 < a3 && *v8 < v8[1])
      {
        ++v8;
        uint64_t v7 = v9;
      }
      float v10 = *v8;
      float v11 = *a4;
      if (*v8 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7) {
            break;
          }
          uint64_t v12 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (float *)(result + 4 * v7);
          uint64_t v13 = v12 + 2;
          if (v13 < a3 && *v8 < v8[1])
          {
            ++v8;
            uint64_t v7 = v13;
          }
          float v10 = *v8;
        }
        while (*v8 >= v11);
        *a4 = v11;
      }
    }
  }
  return result;
}

char *Nightingale::lstmModelCommonFw::fwDLPostProcess@<X0>(float **a1@<X1>, int a2@<W2>, int a3@<W3>, uint64_t a4@<X8>)
{
  int v7 = 0;
  *(unsigned char *)a4 = 0;
  *(unsigned char *)(a4 + 4) = 0;
  *(unsigned char *)(a4 + 8) = 0;
  *(unsigned char *)(a4 + 12) = 0;
  *(void *)(a4 + 16) = 0;
  uint64_t v8 = (char *)(a4 + 16);
  *(void *)(a4 + 24) = 0;
  *(void *)(a4 + 32) = 0;
  if (a2)
  {
    uint64_t v9 = *a1;
    uint64_t v10 = (uint64_t)(a1[1] - 1);
    a1[1] = (float *)v10;
    uint64_t v11 = v10 - (void)(v9 + 1);
    if ((float *)v10 == v9 + 1)
    {
      uint64_t v12 = v9;
    }
    else
    {
      memmove(v9, v9 + 1, v10 - (void)(v9 + 1));
      uint64_t v12 = *a1;
    }
    uint64_t v13 = (float *)((char *)v9 + v11);
    a1[1] = (float *)((char *)v9 + v11);
    if (v12 != (float *)((char *)v9 + v11))
    {
      double v14 = 0.0;
      uint64_t v15 = v12;
      do
      {
        float v16 = *v15++;
        double v14 = v14 + v16;
      }
      while (v15 != v13);
      float v17 = 1.0 / v14;
      do
      {
        *uint64_t v12 = *v12 * v17;
        ++v12;
      }
      while (v12 != v13);
    }
    int v7 = 1;
  }
  unint64_t v18 = Nightingale::argquantile(a1, 0.2);
  float result = (char *)Nightingale::argquantile(a1, 0.8);
  if (((v18 | result) & 1) == 0)
  {
    *(_DWORD *)a4 = (int)(float)(roundf((float)(*((float *)&v18 + 1) + *((float *)&result + 1)) * 0.5) + (float)(v7 + a3));
    *(unsigned char *)(a4 + 4) = 1;
    *(float *)(a4 + 8) = *((float *)&result + 1) - *((float *)&v18 + 1);
    *(unsigned char *)(a4 + 12) = 1;
    if (v8 != (char *)a1) {
      return std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(v8, (char *)*a1, (uint64_t)a1[1], a1[1] - *a1);
    }
  }
  return result;
}

void sub_257D50CA0(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::lstmModelCommonPeriod::periodDLPostProcess(void *a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  Nightingale::CGradient::CGradient((uint64_t)__p);
  unint64_t v6 = Nightingale::argquantile(a1, 0.1);
  unint64_t v7 = Nightingale::argquantile(a1, 0.2);
  unint64_t v8 = Nightingale::argquantile(a1, 0.8);
  unint64_t v9 = Nightingale::argquantile(a1, 0.9);
  if (v6 & 1) != 0 || (v7 & 1) != 0 || (v8 & 1) != 0 || (v9)
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)a3, __p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
    *(_OWORD *)(a3 + 24) = v24[0];
    *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v24 + 9);
    *(_DWORD *)(a3 + 56) = 0;
    *(unsigned char *)(a3 + 60) = 1;
    *(_DWORD *)(a3 + 64) = 0;
    *(unsigned char *)(a3 + 68) = 1;
    *(unsigned char *)(a3 + 72) = 0;
    *(unsigned char *)(a3 + 76) = 0;
    *(unsigned char *)(a3 + 80) = 0;
    *(unsigned char *)(a3 + 84) = 0;
    goto LABEL_28;
  }
  int v10 = (int)(float)(roundf((float)(*((float *)&v7 + 1) + *((float *)&v8 + 1)) * 0.5) + 0.0);
  int v11 = v10 - (int)*((float *)&v6 + 1);
  int v12 = (int)*((float *)&v9 + 1) - v10;
  if (SHIDWORD(v9) != SHIDWORD(v6))
  {
    int v11 = llroundf((float)v11 * 0.85);
    int v12 = llroundf((float)v12 * 0.85);
  }
  if (v12 >= 6) {
    int v13 = 6;
  }
  else {
    int v13 = v12;
  }
  if (v11 >= 6) {
    int v14 = 6;
  }
  else {
    int v14 = v11;
  }
  if (v11 + v12 > 12)
  {
    int v12 = v13;
    int v11 = v14;
  }
  int v15 = v10 - v11;
  if (v15 <= 1) {
    int v15 = 1;
  }
  int v16 = v15 + a2;
  int v17 = v10 + a2 + v12;
  Nightingale::lstmModelCommonPeriod::constructPeriodGradFromDLOut(a1, v15 + a2, v17, a2, (Nightingale::CGradient *)&v19);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  *(_OWORD *)__n128 __p = v19;
  uint64_t v23 = v20;
  v24[0] = v21[0];
  *(_OWORD *)((char *)v24 + 9) = *(_OWORD *)((char *)v21 + 9);
  Nightingale::CGradient::CGradient(a3);
  *(unsigned char *)(a3 + 56) = 0;
  *(unsigned char *)(a3 + 60) = 0;
  *(unsigned char *)(a3 + 64) = 0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  *(unsigned char *)(a3 + 76) = 0;
  *(unsigned char *)(a3 + 80) = 0;
  *(unsigned char *)(a3 + 84) = 0;
  if (__p == (void **)a3)
  {
    *(_OWORD *)(a3 + 24) = v24[0];
    *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v24 + 9);
LABEL_24:
    *(unsigned char *)(a3 + 60) = 1;
    goto LABEL_25;
  }
  std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a3, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
  int v18 = *(unsigned __int8 *)(a3 + 60);
  *(_OWORD *)(a3 + 24) = v24[0];
  *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v24 + 9);
  if (!v18) {
    goto LABEL_24;
  }
LABEL_25:
  *(float *)(a3 + 56) = (float)v16;
  if (!*(unsigned char *)(a3 + 68)) {
    *(unsigned char *)(a3 + 68) = 1;
  }
  *(float *)(a3 + 64) = (float)v17;
LABEL_28:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
}

void sub_257D50F6C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  uint64_t v20 = *(void **)v18;
  if (*(void *)v18)
  {
    *(void *)(v18 + 8) = v20;
    operator delete(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::lstmModelCommonPeriod::constructPeriodGradFromDLOut@<X0>(void *a1@<X1>, int a2@<W2>, int a3@<W3>, int a4@<W4>, Nightingale::CGradient *a5@<X8>)
{
  uint64_t result = Nightingale::CGradient::CGradient((uint64_t)a5);
  if (a1[1] - *a1 == 128)
  {
    if (a4 >= -31)
    {
      uint64_t v11 = 0;
      uint64_t v12 = (a4 + 32);
      uint64_t v13 = -(uint64_t)a4;
      uint64_t v14 = -4 * a4;
      do
      {
        double v15 = 0.0;
        if (v11 >= a2 && v11 <= a3)
        {
          if (v13 + v11 >= (unint64_t)((uint64_t)(a1[1] - *a1) >> 2)) {
            std::vector<int>::__throw_out_of_range[abi:ne180100]();
          }
          double v15 = *(float *)(*a1 + v14 + 4 * v11);
        }
        Nightingale::CGradient::push_back(a5, v15);
        ++v11;
      }
      while (v12 != v11);
    }
    return Nightingale::CGradient::normalize((uint64_t)a5);
  }
  return result;
}

void sub_257D51090(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::lstmModelCommonPeriod::periodDLTransformerPostProcess(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v4 = *(float **)a1;
  if (*(void *)(a1 + 8) - *(void *)a1 <= 4uLL) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  float v5 = v4[1];
  float v6 = v5 * 31.0;
  float v7 = (float)(v5 * (float)(1.0 - *v4)) * 31.0;
  float v8 = (float)a2;
  float v9 = (float)(v5 * 31.0) - v7;
  float v10 = v9 / 1.28;
  float v11 = v10 * v10;
  double v12 = (float)((float)(v5 * 31.0) + (float)a2);
  int v13 = (int)(fmax((float)(sqrtf(v10 * v10) * 10.0), 20.0) + v12);
  uint64_t v14 = (Nightingale *)Nightingale::CGradient::CGradient((uint64_t)&__p);
  if (v13 >= 1)
  {
    int v15 = 0;
    double v16 = v11;
    do
    {
      double v17 = Nightingale::gaussian_pdf(v14, (double)v15, v12, v16);
      Nightingale::CGradient::push_back((Nightingale::CGradient *)&__p, v17);
      ++v15;
    }
    while (v13 != v15);
  }
  Nightingale::CGradient::CGradient(a3);
  if (&__p != (void **)a3) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a3, (char *)__p, (uint64_t)v19, (v19 - (unsigned char *)__p) >> 2);
  }
  *(_OWORD *)(a3 + 24) = v20[0];
  *(_OWORD *)(a3 + 33) = *(_OWORD *)((char *)v20 + 9);
  *(float *)(a3 + 56) = v7 + v8;
  *(float *)(a3 + 60) = (float)(v6 + v9) + v8;
  if (__p)
  {
    long long v19 = __p;
    operator delete(__p);
  }
}

void sub_257D5120C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  int v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::lstmModelCommonPeriod::applyNoflowUpdateDL(Nightingale::lstmModelCommonPeriod *this, Nightingale::CGradient *a2, int a3)
{
  if ((int)Nightingale::CGradient::get_vGrad_len(a2) < a3) {
    *((unsigned char *)a2 + 33) = 1;
  }
  Nightingale::CGradient::annihilateEarly((char **)a2, a3 + 1);
  Nightingale::CGradient::normalize((uint64_t)a2);
  Nightingale::CGradient::set_isNull_if_grad_allZeros((uint64_t)a2);
  uint64_t result = Nightingale::CGradient::get_isNull(a2);
  if (result) {
    *((void *)a2 + 1) = *(void *)a2;
  }
  *((unsigned char *)a2 + 34) = 1;
  return result;
}

BOOL Nightingale::periodEstimatorAggregation::period1stProjFromSensor(uint64_t a1, _DWORD *a2)
{
  return *a2 < 4u;
}

BOOL Nightingale::periodEstimatorAggregation::period1stProjFromluna(uint64_t a1, _DWORD *a2)
{
  return *a2 < 3u;
}

BOOL Nightingale::periodEstimatorAggregation::period1stProjFromHR(uint64_t a1, _DWORD *a2)
{
  return *a2 == 3;
}

void Nightingale::periodEstimatorAggregation::deriveRestPeriodProjs(Nightingale::ngt_Config *a1@<X3>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W4>, int a5@<W5>, int a6@<W6>, int a7@<W7>, uint64_t *a8@<X8>)
{
  Nightingale::periodEstimatorCalendarWithEnd::periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)v69, a1);
  *a8 = 0;
  a8[1] = 0;
  a8[2] = 0;
  uint64_t v14 = *(void *)(a3 + 8);
  v63[0] = *(_OWORD *)(v14 - 96);
  long long v15 = *(_OWORD *)(v14 - 80);
  long long v16 = *(_OWORD *)(v14 - 64);
  long long v17 = *(_OWORD *)(v14 - 48);
  *(void *)&v65[13] = *(void *)(v14 - 35);
  long long v64 = v16;
  *(_OWORD *)__int16 v65 = v17;
  v63[1] = v15;
  __int16 v67 = 0;
  uint64_t v68 = 0;
  int v66 = 0;
  std::vector<Nightingale::Phase>::__init_with_size[abi:ne180100]<Nightingale::Phase*,Nightingale::Phase*>(&v66, *(const void **)(v14 - 24), *(void *)(v14 - 16), *(void *)(v14 - 16) - *(void *)(v14 - 24));
  if (!Nightingale::CGradient::get_vGrad_empty((Nightingale::CGradient *)a2)
    && *(unsigned char *)(a2 + 76)
    && BYTE4(v64)
    && BYTE12(v64))
  {
    int v37 = *(_DWORD *)(a3 + 124);
    Nightingale::CGradient::CGradient((uint64_t)v55);
    char v57 = 0;
    char v58 = 0;
    char v59 = 0;
    char v60 = 0;
    LOBYTE(v61) = 0;
    char v62 = 0;
    Nightingale::CGradient::CGradient((uint64_t)v51);
    v54[0] = 0;
    v54[4] = 0;
    v54[8] = 0;
    v54[12] = 0;
    v54[16] = 0;
    v54[20] = 0;
    Nightingale::CGradient::CGradient((uint64_t)__p);
    if (!*(unsigned char *)(a2 + 76) || (double expectation = *(float *)(a2 + 72), !BYTE12(v64))) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    double v71 = *((float *)&v64 + 2);
    if (a7)
    {
      if (*(unsigned char *)(a2 + 48)) {
        double variance = (float)(*(float *)(a2 + 44) * *(float *)(a2 + 44));
      }
      else {
        double variance = Nightingale::CGradient::get_variance((float **)a2);
      }
      double v71 = variance;
    }
    if (a4 >= 1)
    {
      int v19 = 0;
      int v36 = a5 - *(char *)(a3 + 128);
      do
      {
        if (!BYTE4(v64) || (double v20 = expectation + *(float *)&v64, expectation = v20, !BYTE12(v64))) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        double v21 = v71 + *((float *)&v64 + 2);
        if (v37 == -2) {
          double v21 = 0.0;
        }
        double v71 = v21;
        float v22 = v20;
        float v23 = v21;
        int v24 = (*(unsigned char *)(a3 + 112) - LOBYTE(v63[0]));
        if (*(unsigned char *)(a3 + 116)) {
          unsigned int v8 = (*(_DWORD *)(a3 + 112) - LODWORD(v63[0])) >> 8;
        }
        else {
          int v24 = 0;
        }
        Nightingale::periodEstimatorCalendar::getCalBasedPeriodStartGradient((Nightingale::periodEstimatorCalendar *)v69, v24 | (v8 << 8) | ((unint64_t)*(unsigned __int8 *)(a3 + 116) << 32), (uint64_t)v40, v22, v23);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        *(_OWORD *)__n128 __p = *(_OWORD *)v40;
        uint64_t v49 = v41;
        v50[0] = v42[0];
        *(_OWORD *)((char *)v50 + 9) = *(_OWORD *)((char *)v42 + 9);
        if (a6)
        {
          double expectation = Nightingale::CGradient::get_expectation((float **)__p);
          double std = Nightingale::CGradient::get_std((float **)__p);
        }
        else
        {
          double std = sqrt(v71);
        }
        float v26 = std;
        if (v26 >= 7.8125 && v19 >= v36) {
          break;
        }
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)v55, (char *)__p[0], (uint64_t)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 2);
        v56[0] = v50[0];
        *(_OWORD *)((char *)v56 + 9) = *(_OWORD *)((char *)v50 + 9);
        if (!v62) {
          char v62 = 1;
        }
        float v28 = expectation;
        float v61 = v28;
        Nightingale::periodEstimatorCalendarWithEnd::getPeriodEndProjection((uint64_t)v63, (Nightingale::CGradient *)__p, (uint64_t)v40);
        if (v51[0])
        {
          v51[1] = v51[0];
          operator delete(v51[0]);
        }
        *(_OWORD *)unint64_t v51 = *(_OWORD *)v40;
        uint64_t v52 = v41;
        v53[0] = v42[0];
        *(_OWORD *)((char *)v53 + 9) = *(_OWORD *)((char *)v42 + 9);
        *(_OWORD *)int v54 = *(_OWORD *)v43;
        *(void *)&v54[13] = *(void *)&v43[13];
        std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>::pair[abi:ne180100]<Nightingale::periodEstimationOutStruct&,Nightingale::periodEstimationOutStruct&,0>((uint64_t)v40, (uint64_t)v55, (uint64_t)v51);
        unint64_t v29 = a8[1];
        if (v29 >= a8[2])
        {
          uint64_t v34 = std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__push_back_slow_path<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>(a8, (uint64_t)v40);
          uint64_t v35 = v44[0];
          a8[1] = v34;
          if (v35)
          {
            v44[1] = v35;
            operator delete(v35);
          }
        }
        else
        {
          *(void *)unint64_t v29 = 0;
          *(void *)(v29 + 8) = 0;
          *(void *)(v29 + 16) = 0;
          *(_OWORD *)unint64_t v29 = *(_OWORD *)v40;
          *(void *)(v29 + 16) = v41;
          v40[0] = 0;
          v40[1] = 0;
          uint64_t v41 = 0;
          long long v30 = *(_OWORD *)((char *)v42 + 9);
          *(_OWORD *)(v29 + 24) = v42[0];
          *(_OWORD *)(v29 + 33) = v30;
          uint64_t v31 = *(void *)&v43[13];
          *(_OWORD *)(v29 + 56) = *(_OWORD *)v43;
          *(void *)(v29 + 69) = v31;
          *(void *)(v29 + 80) = 0;
          *(void *)(v29 + 88) = 0;
          *(void *)(v29 + 96) = 0;
          *(_OWORD *)(v29 + 80) = *(_OWORD *)v44;
          *(void *)(v29 + 96) = v45;
          v44[0] = 0;
          v44[1] = 0;
          uint64_t v45 = 0;
          long long v32 = v46[0];
          *(_OWORD *)(v29 + 113) = *(_OWORD *)((char *)v46 + 9);
          *(_OWORD *)(v29 + 104) = v32;
          long long v33 = *(_OWORD *)v47;
          *(void *)(v29 + 149) = *(void *)&v47[13];
          *(_OWORD *)(v29 + 136) = v33;
          a8[1] = v29 + 160;
        }
        if (v40[0])
        {
          v40[1] = v40[0];
          operator delete(v40[0]);
        }
        ++v19;
      }
      while (a4 != v19);
    }
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v51[0])
    {
      v51[1] = v51[0];
      operator delete(v51[0]);
    }
    if (v55[0])
    {
      v55[1] = v55[0];
      operator delete(v55[0]);
    }
  }
  if (v66)
  {
    __int16 v67 = v66;
    operator delete(v66);
  }
  Nightingale::periodEstimatorCalendarWithEnd::~periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)v69);
}

void sub_257D517B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54)
{
  if (__p)
  {
    a36 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a43)
  {
    a44 = (uint64_t)a43;
    operator delete(a43);
  }
  if (a53)
  {
    a54 = (uint64_t)a53;
    operator delete(a53);
  }
  int v56 = *(void **)(v54 - 168);
  if (v56)
  {
    *(void *)(v54 - 160) = v56;
    operator delete(v56);
  }
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a15);
  Nightingale::periodEstimatorCalendarWithEnd::~periodEstimatorCalendarWithEnd((Nightingale::periodEstimatorCalendarWithEnd *)(v54 - 136));
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__push_back_slow_path<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 5);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x199999999999999) {
    std::vector<float>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xCCCCCCCCCCCCCCLL) {
    unint64_t v9 = 0x199999999999999;
  }
  else {
    unint64_t v9 = v5;
  }
  void v18[4] = a1 + 2;
  if (v9) {
    float v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>>(v7, v9);
  }
  else {
    float v10 = 0;
  }
  uint64_t v11 = &v10[160 * v4];
  v18[0] = v10;
  v18[1] = v11;
  v18[3] = &v10[160 * v9];
  *(void *)uint64_t v11 = 0;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(_OWORD *)uint64_t v11 = *(_OWORD *)a2;
  *((void *)v11 + 2) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v12 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v11 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(v11 + 24) = v12;
  long long v13 = *(_OWORD *)(a2 + 56);
  *(void *)(v11 + 69) = *(void *)(a2 + 69);
  *(_OWORD *)(v11 + 56) = v13;
  *((void *)v11 + 11) = 0;
  *((void *)v11 + 12) = 0;
  *((void *)v11 + 10) = 0;
  *((_OWORD *)v11 + 5) = *(_OWORD *)(a2 + 80);
  *((void *)v11 + 12) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  long long v14 = *(_OWORD *)(a2 + 104);
  *(_OWORD *)(v11 + 113) = *(_OWORD *)(a2 + 113);
  *(_OWORD *)(v11 + 104) = v14;
  long long v15 = *(_OWORD *)(a2 + 136);
  *(void *)(v11 + 149) = *(void *)(a2 + 149);
  *(_OWORD *)(v11 + 136) = v15;
  v18[2] = v11 + 160;
  std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__swap_out_circular_buffer(a1, v18);
  uint64_t v16 = a1[1];
  std::__split_buffer<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::~__split_buffer((uint64_t)v18);
  return v16;
}

void sub_257D519C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v4;
  uint64_t v5 = *a1;
  *a1 = v4;
  a2[1] = v5;
  uint64_t v6 = a1[1];
  a1[1] = a2[2];
  a2[2] = v6;
  uint64_t v7 = a1[2];
  a1[2] = a2[3];
  a2[3] = v7;
  *a2 = a2[1];
}

__n128 std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>,std::reverse_iterator<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a7 + v7;
      uint64_t v9 = a3 + v7;
      *(void *)(v8 - 160) = 0;
      *(void *)(v8 - 152) = 0;
      *(void *)(v8 - 144) = 0;
      *(_OWORD *)(v8 - 160) = *(_OWORD *)(a3 + v7 - 160);
      *(void *)(v8 - 144) = *(void *)(a3 + v7 - 144);
      *(void *)(v9 - 160) = 0;
      *(void *)(v9 - 152) = 0;
      *(void *)(v9 - 144) = 0;
      long long v10 = *(_OWORD *)(a3 + v7 - 136);
      *(_OWORD *)(v8 - 127) = *(_OWORD *)(a3 + v7 - 127);
      *(_OWORD *)(v8 - 136) = v10;
      long long v11 = *(_OWORD *)(a3 + v7 - 104);
      *(void *)(v8 - 91) = *(void *)(a3 + v7 - 91);
      *(void *)(v8 - 72) = 0;
      *(void *)(v8 - 64) = 0;
      *(void *)(v8 - 80) = 0;
      *(_OWORD *)(v8 - 104) = v11;
      *(_OWORD *)(v8 - 80) = *(_OWORD *)(a3 + v7 - 80);
      *(void *)(v8 - 64) = *(void *)(a3 + v7 - 64);
      *(void *)(v9 - 80) = 0;
      *(void *)(v9 - 72) = 0;
      *(void *)(v9 - 64) = 0;
      long long v12 = *(_OWORD *)(a3 + v7 - 56);
      *(_OWORD *)(v8 - 47) = *(_OWORD *)(a3 + v7 - 47);
      *(_OWORD *)(v8 - 56) = v12;
      __n128 result = *(__n128 *)(a3 + v7 - 24);
      *(void *)(v8 - 11) = *(void *)(a3 + v7 - 11);
      *(__n128 *)(v8 - 24) = result;
      v7 -= 160;
    }
    while (a3 + v7 != a5);
  }
  return result;
}

uint64_t std::__split_buffer<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 160;
    std::__destroy_at[abi:ne180100]<std::pair<Nightingale::periodEstimationOutStruct,Nightingale::periodEstimationOutStruct>,0>(i - 160);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t Nightingale::lstmHr::lstmHr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = &unk_2706973F0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(unsigned char *)(a1 + 108) = 0;
  *(unsigned char *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 116) = 0;
  *(_WORD *)(a1 + 120) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(unsigned char *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(void *)(a1 + 176) = a2;
  *(void *)(a1 + 184) = a3;
  *(void *)(a1 + 192) = a4;
  *(void *)(a1 + 200) = a5;
  *(unsigned char *)(a1 + 236) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(unsigned char *)(a1 + 244) = 0;
  *(unsigned char *)(a1 + 232) = 0;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 360) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  Nightingale::heartRateInputAcquisition::heartRateInputAcquisition((Nightingale::heartRateInputAcquisition *)(a1 + 372));
  return a1;
}

void sub_257D51C2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  uint64_t v6 = (void *)v3[43];
  if (v6)
  {
    v3[44] = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void *)v3[40];
  if (v7)
  {
    v3[41] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)v3[37];
  if (v8)
  {
    v3[38] = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)v3[34];
  if (v9)
  {
    v3[35] = v9;
    operator delete(v9);
  }
  long long v10 = *v4;
  if (*v4)
  {
    v3[32] = v10;
    operator delete(v10);
  }
  std::vector<std::vector<BOOL>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  Nightingale::hrSlicesStruct::~hrSlicesStruct(v2);
  _Unwind_Resume(a1);
}

void Nightingale::hrSlicesStruct::~hrSlicesStruct(Nightingale::hrSlicesStruct *this)
{
  uint64_t v2 = (void *)*((void *)this + 18);
  if (v2)
  {
    *((void *)this + 19) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 15);
  if (v3)
  {
    *((void *)this + 16) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 9);
  if (v4)
  {
    *((void *)this + 10) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 6);
  if (v5)
  {
    *((void *)this + 7) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 3);
  if (v6)
  {
    *((void *)this + 4) = v6;
    operator delete(v6);
  }
  uint64_t v7 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v7;
    operator delete(v7);
  }
}

void Nightingale::lstmHr::~lstmHr(Nightingale::lstmHr *this)
{
  *(void *)this = &unk_2706973F0;
  Nightingale::heartRateInputAcquisition::~heartRateInputAcquisition((Nightingale::lstmHr *)((char *)this + 372));
  uint64_t v2 = (void *)*((void *)this + 43);
  if (v2)
  {
    *((void *)this + 44) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 40);
  if (v3)
  {
    *((void *)this + 41) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 37);
  if (v4)
  {
    *((void *)this + 38) = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 34);
  if (v5)
  {
    *((void *)this + 35) = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)*((void *)this + 31);
  if (v6)
  {
    *((void *)this + 32) = v6;
    operator delete(v6);
  }
  long long v13 = (void **)((char *)this + 208);
  std::vector<std::vector<BOOL>>::__destroy_vector::operator()[abi:ne180100](&v13);
  uint64_t v7 = (void *)*((void *)this + 19);
  if (v7)
  {
    *((void *)this + 20) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 16);
  if (v8)
  {
    *((void *)this + 17) = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void *)*((void *)this + 10);
  if (v9)
  {
    *((void *)this + 11) = v9;
    operator delete(v9);
  }
  long long v10 = (void *)*((void *)this + 7);
  if (v10)
  {
    *((void *)this + 8) = v10;
    operator delete(v10);
  }
  long long v11 = (void *)*((void *)this + 4);
  if (v11)
  {
    *((void *)this + 5) = v11;
    operator delete(v11);
  }
  long long v12 = (void *)*((void *)this + 1);
  if (v12)
  {
    *((void *)this + 2) = v12;
    operator delete(v12);
  }
}

uint64_t Nightingale::lstmHr::acquireHr(Nightingale::lstmHr *this)
{
  uint64_t JDay1stValidAwakeHr = Nightingale::lstmHr::getJDay1stValidAwakeHr(this);
  uint64_t result = 0;
  if ((JDay1stValidAwakeHr & 0xFF00000000) != 0
    && *(_DWORD *)(*(void *)(*((void *)this + 23) + 8) - 96) - 39 >= (int)JDay1stValidAwakeHr)
  {
    (**(void (***)(Nightingale::lstmHr *))this)(this);
    if (*((unsigned char *)this + 108) && *((unsigned char *)this + 116))
    {
      uint64_t v4 = *((void *)this + 8);
      uint64_t v9 = 0;
      long long v8 = 0uLL;
      std::vector<std::optional<float>>::__init_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(&v8, (const void *)(v4 - 360), v4, 0x2DuLL);
      uint64_t v5 = (void *)*((void *)this + 31);
      if (v5)
      {
        *((void *)this + 32) = v5;
        operator delete(v5);
      }
      *(_OWORD *)((char *)this + 248) = v8;
      *((void *)this + 33) = v9;
      uint64_t v6 = *((void *)this + 11);
      uint64_t v9 = 0;
      long long v8 = 0uLL;
      std::vector<std::optional<float>>::__init_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(&v8, (const void *)(v6 - 360), v6, 0x2DuLL);
      uint64_t v7 = (void *)*((void *)this + 34);
      if (v7)
      {
        *((void *)this + 35) = v7;
        operator delete(v7);
      }
      *((_OWORD *)this + 17) = v8;
      *((void *)this + 36) = v9;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL Nightingale::lstmHr::enoughHrSamplesToRunLstmHr(Nightingale::lstmHr *this)
{
  uint64_t JDay1stValidAwakeHr = Nightingale::lstmHr::getJDay1stValidAwakeHr(this);
  return (JDay1stValidAwakeHr & 0xFF00000000) != 0
      && *(_DWORD *)(*(void *)(*((void *)this + 23) + 8) - 96) - 39 >= (int)JDay1stValidAwakeHr;
}

uint64_t Nightingale::lstmHr::getJDay1stValidAwakeHr(Nightingale::lstmHr *this)
{
  uint64_t v1 = (unsigned int **)*((void *)this + 22);
  uint64_t v2 = *v1;
  uint64_t v3 = v1[1];
  while (1)
  {
    if (v2 == v3)
    {
      uint64_t v4 = 0;
      uint64_t v5 = 0;
      return v5 | v4;
    }
    if (*((unsigned char *)v2 + 20) && *((unsigned char *)v2 + 36) && (signed int)v2[8] >= *(_DWORD *)(*((void *)this + 24) + 132)) {
      break;
    }
    v2 += 15;
  }
  uint64_t v5 = *v2;
  uint64_t v4 = 0x100000000;
  return v5 | v4;
}

uint64_t Nightingale::lstmHr::acquireHrSlices(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 192);
  if (*(unsigned char *)(v1 + 36))
  {
    uint64_t v2 = this;
    uint64_t v3 = (Nightingale::heartRateInputAcquisition *)(this + 372);
    Nightingale::heartRateInputAcquisition::acquireSlicesFwDayStream(this + 372, *(uint64_t **)(this + 176), *(unsigned int *)(v1 + 32), *(void *)(*(void *)(this + 184) + 80), this + 8);
    this = Nightingale::heartRateInputAcquisition::get1stJDayDailyIdx(v3);
    *(_DWORD *)(v2 + 232) = this;
    *(unsigned char *)(v2 + 236) = BYTE4(this);
    *(_DWORD *)(v2 + 240) = v4;
    *(unsigned char *)(v2 + 244) = v5;
  }
  return this;
}

BOOL Nightingale::lstmHr::validateHr(Nightingale::lstmHr *this, int a2)
{
  Nightingale::heartRateInputValidation::heartRateInputValidation((Nightingale::heartRateInputValidation *)v12, *((const Nightingale::ngt_Config **)this + 24));
  Nightingale::heartRateInputValidation::process((uint64_t)v12, (void *)this + 1, (uint64_t *)this + 26, a2);
  if (*((unsigned char *)this + 108) && *((unsigned char *)this + 116) && (uint64_t v4 = *((void *)this + 24), *(unsigned char *)(v4 + 36)))
  {
    int v5 = *(_DWORD *)(*(void *)(*((void *)this + 23) + 8) - 96);
    int v6 = *(_DWORD *)(v4 + 32) - v5 + 39;
    if (v6 < 0) {
      int v7 = -1;
    }
    else {
      int v7 = v6;
    }
    int v8 = 38 - v7;
    if (v6 >= 100) {
      int v9 = -61;
    }
    else {
      int v9 = v8;
    }
    BOOL v10 = (int)(v9 + *((_DWORD *)this + 26) + ((*((void *)this + 2) - *((void *)this + 1)) >> 3)) <= v5;
  }
  else
  {
    BOOL v10 = 0;
  }
  Nightingale::heartRateInputValidation::~heartRateInputValidation(v12);
  return v10;
}

void sub_257D52120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

BOOL Nightingale::lstmHr::preConditionHr(Nightingale::lstmHr *this)
{
  Nightingale::heartRateInputPreCondition::heartRateInputPreCondition(v3, *((void *)this + 22), (char *)this + 8, *((void *)this + 24));
  BOOL v1 = Nightingale::heartRateInputPreCondition::preConditionHr((unsigned int ***)v3);
  Nightingale::heartRateInputPreCondition::~heartRateInputPreCondition(v3);
  return v1;
}

void sub_257D52184(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

BOOL Nightingale::lstmHr::prepareUiVectors(Nightingale::lstmHr *this, int a2, int a3, int a4)
{
  int v19 = a2;
  char v20 = 1;
  int v21 = a3;
  char v22 = 1;
  int v23 = a4;
  char v24 = 1;
  uint64_t v5 = *((void *)this + 22);
  uint64_t v6 = *((void *)this + 23);
  uint64_t v7 = *((void *)this + 24);
  long long v16 = xmmword_257D5FB40;
  uint64_t v17 = 0x3FB8CEF8402F005CLL;
  Nightingale::uiProcessForLstm::uiProcessForLstm((uint64_t)v18, v5, v6, v7, (__n128 *)&v16);
  Nightingale::uiProcessForLstm::prepareUiLogForDL((uint64_t)v18, (uint64_t)&v19, (uint64_t)this + 296, (float **)this + 40, (float **)this + 43);
  uint64_t v8 = *((void *)this + 37);
  uint64_t v9 = *((void *)this + 38);
  if (v8 == v9 || (v10 = *((void *)this + 40), uint64_t v11 = *((void *)this + 41), v10 == v11))
  {
    BOOL v12 = 0;
  }
  else
  {
    BOOL v12 = 0;
    if ((unint64_t)(v11 - v10) >= 0xB4 && (unint64_t)(v9 - v8) >= 0xB4)
    {
      uint64_t v13 = *((void *)this + 43);
      uint64_t v14 = *((void *)this + 44);
      if (v13 != v14 && (unint64_t)(v14 - v13) >= 0xB4) {
        BOOL v12 = 0xEEEEEEEEEEEEEEEFLL
      }
            * ((uint64_t)(*(void *)(*((void *)this + 22) + 8) - **((void **)this + 22)) >> 2) > 0x2C;
    }
  }
  Nightingale::uiProcessForLstm::~uiProcessForLstm((Nightingale::uiProcessForLstm *)v18);
  return v12;
}

void sub_257D522A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  Nightingale::uiProcessForLstm::~uiProcessForLstm((Nightingale::uiProcessForLstm *)va);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::lstmHrFw::lstmHrFw(uint64_t a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4, uint64_t a5)
{
  uint64_t v7 = (void *)Nightingale::lstmHr::lstmHr(a1, a2, a3, (uint64_t)a4, a5);
  void *v7 = &unk_270697408;
  unsigned __int8 v14 = 0;
  std::vector<BOOL>::vector(v7 + 49, 8uLL, &v14);
  *(unsigned char *)(a1 + 444) = 0;
  *(unsigned char *)(a1 + 448) = 0;
  *(unsigned char *)(a1 + 452) = 0;
  *(void *)(a1 + 464) = 0;
  *(void *)(a1 + 472) = 0;
  *(void *)(a1 + 456) = 0;
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 440) = 0;
  Nightingale::ngt_dnn_fw_predict_t::ngt_dnn_fw_predict_t((Nightingale::ngt_dnn_fw_predict_t *)(a1 + 480), a4);
  Nightingale::lstmModelCommonFw::lstmModelCommonFw((Nightingale::lstmModelCommonFw *)(a1 + 488));
  *(unsigned char *)(a1 + 492) = 0;
  *(unsigned char *)(a1 + 496) = 0;
  *(unsigned char *)(a1 + 500) = 0;
  *(unsigned char *)(a1 + 504) = 0;
  *(unsigned char *)(a1 + 508) = 0;
  *(unsigned char *)(a1 + 512) = 0;
  *(unsigned char *)(a1 + 516) = 0;
  *(unsigned char *)(a1 + 520) = 0;
  *(unsigned char *)(a1 + 524) = 0;
  *(unsigned char *)(a1 + 528) = 0;
  *(unsigned char *)(a1 + 532) = 0;
  *(unsigned char *)(a1 + 536) = 0;
  *(_DWORD *)(a1 + 540) = -1082130432;
  *(void *)(a1 + 544) = -1;
  *(void *)(a1 + 552) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)(a1 + 560) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a1 + 576) = _Q0;
  *(unsigned char *)(a1 + 584) = 0;
  *(unsigned char *)(a1 + 588) = 0;
  return a1;
}

void sub_257D523BC(_Unwind_Exception *a1)
{
  Nightingale::ngt_dnn_fw_predict_t::~ngt_dnn_fw_predict_t(v3);
  uint64_t v5 = v1 + 52;
  uint64_t v6 = v1[57];
  if (v6)
  {
    v1[58] = v6;
    operator delete(v6);
  }
  uint64_t v7 = *v5;
  if (*v5)
  {
    v1[53] = v7;
    operator delete(v7);
  }
  if (*v2) {
    operator delete(*v2);
  }
  Nightingale::lstmHr::~lstmHr((Nightingale::lstmHr *)v1);
  _Unwind_Resume(a1);
}

void Nightingale::lstmHrFw::~lstmHrFw(id **this)
{
  *this = (id *)&unk_270697408;
  Nightingale::lstmModelCommonFw::~lstmModelCommonFw((Nightingale::lstmModelCommonFw *)(this + 61));
  Nightingale::ngt_dnn_fw_predict_t::~ngt_dnn_fw_predict_t(this + 60);
  uint64_t v2 = this[57];
  if (v2)
  {
    this[58] = v2;
    operator delete(v2);
  }
  uint64_t v3 = this[52];
  if (v3)
  {
    this[53] = v3;
    operator delete(v3);
  }
  uint64_t v4 = this[49];
  if (v4) {
    operator delete(v4);
  }
  Nightingale::lstmHr::~lstmHr((Nightingale::lstmHr *)this);
}

__n128 Nightingale::lstmHrFw::getFWEndHr@<Q0>(Nightingale::lstmHrFw *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 12) = 0;
  *(unsigned char *)(a3 + 16) = 0;
  *(unsigned char *)(a3 + 20) = 0;
  *(_DWORD *)(a3 + 24) = -1082130432;
  *(void *)(a3 + 28) = -1;
  *(void *)(a3 + 36) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)(a3 + 44) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a3 + 60) = _Q0;
  *(unsigned char *)(a3 + 68) = 0;
  *(unsigned char *)(a3 + 72) = 0;
  if (Nightingale::lstmHr::acquireHr(this)
    && Nightingale::lstmHr::validateHr(this, 1)
    && Nightingale::lstmHr::preConditionHr(this))
  {
    if (!*((unsigned char *)this + 108) || !*((unsigned char *)this + 116) || !*((unsigned char *)this + 236)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    if (Nightingale::lstmHr::prepareUiVectors(this, *((_DWORD *)this + 26), *((_DWORD *)this + 28), *((_DWORD *)this + 58)))
    {
      Nightingale::lstmHrFw::applyAlgs((uint64_t)this);
      Nightingale::lstmHrFw::computeHrFwCA(this, a2);
      long long v12 = *(_OWORD *)((char *)this + 564);
      *(_OWORD *)(a3 + 32) = *(_OWORD *)((char *)this + 548);
      *(_OWORD *)(a3 + 48) = v12;
      *(_OWORD *)(a3 + 60) = *((_OWORD *)this + 36);
      __n128 result = *(__n128 *)((char *)this + 532);
      *(_OWORD *)a3 = *(_OWORD *)((char *)this + 516);
      *(__n128 *)(a3 + 16) = result;
    }
  }
  return result;
}

uint64_t Nightingale::lstmHrFw::applyAlgs(uint64_t this)
{
  if (!*(unsigned char *)(this + 108) || (uint64_t v1 = this, !*(unsigned char *)(this + 116))) {
LABEL_23:
  }
    std::__throw_bad_optional_access[abi:ne180100]();
  int v2 = *(_DWORD *)(this + 104) + 44;
  int v3 = *(_DWORD *)(this + 112);
  if (v2 <= v3)
  {
    for (int i = 0; ; ++i)
    {
      int v5 = v2 + i;
      Nightingale::lstmHrFw::applyAlgsADay((Nightingale::lstmHrFw *)v1, (unsigned __int16)i);
      if (*(unsigned char *)(v1 + 444)
        && !*(unsigned char *)(v1 + 520)
        && Nightingale::lstmHrFw::validateFwRsltADay((Nightingale::lstmHrFw *)v1, v2 + i))
      {
        if (!*(unsigned char *)(v1 + 444)) {
          goto LABEL_23;
        }
        *(_DWORD *)(v1 + 516) = v2 + i + *(_DWORD *)(v1 + 440);
        *(unsigned char *)(v1 + 520) = 1;
        *(_DWORD *)(v1 + 524) = v5;
        *(unsigned char *)(v1 + 528) = 1;
      }
      uint64_t v6 = *(void *)(v1 + 208);
      if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v1 + 216) - v6) >> 3) <= (unsigned __int16)i) {
        std::vector<int>::__throw_out_of_range[abi:ne180100]();
      }
      unint64_t v7 = *(void *)(v6 + 24 * (unsigned __int16)i + 8) - 1;
      int v8 = ((*(void *)(*(void *)(v6 + 24 * (unsigned __int16)i) + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v7) & 1) != 0
        && *(unsigned char *)(v1 + 536) == 0;
      this = Nightingale::lstmHrFw::validateToRunPeriodADay((Nightingale::lstmHrFw *)v1, v2 + i, v8);
      if (this)
      {
        *(_DWORD *)(v1 + 532) = v5;
        *(unsigned char *)(v1 + 536) = 1;
      }
      if (*(unsigned char *)(v1 + 520) && *(unsigned char *)(v1 + 528) && *(unsigned char *)(v1 + 536) || v5 >= v3) {
        break;
      }
    }
  }
  return this;
}

void Nightingale::lstmHrFw::computeHrFwCA(Nightingale::lstmHrFw *this, int a2)
{
  if (a2)
  {
    if (*((void *)this + 31) != *((void *)this + 32))
    {
      Nightingale::lstmHrFw::computeHrSignalQuality(this, (uint64_t)&v5);
      long long v3 = *(_OWORD *)v6;
      *(_OWORD *)((char *)this + 540) = v5;
      *(_OWORD *)((char *)this + 556) = v3;
      *(_OWORD *)((char *)this + 568) = *(_OWORD *)&v6[12];
      uint64_t v4 = *((void *)this + 23);
      if (*(unsigned char *)(v4 + 108))
      {
        if (*((unsigned char *)this + 520))
        {
          *((_DWORD *)this + 146) = *((_DWORD *)this + 129) + ~*(_DWORD *)(v4 + 104);
          *((unsigned char *)this + 588) = 1;
        }
      }
    }
  }
}

void Nightingale::lstmHrFw::applyAlgsADay(Nightingale::lstmHrFw *this, unsigned int a2)
{
  uint64_t v3 = *((void *)this + 26);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)this + 27) - v3) >> 3);
  if (a2 < (unsigned __int16)v4)
  {
    if (v4 <= a2) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    uint64_t v6 = a2;
    if (**(unsigned char **)(v3 + 24 * a2))
    {
      unint64_t v7 = a2 + 44;
      if (v7 < (uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 3
        && v7 < (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 3
        && v7 < (uint64_t)(*((void *)this + 38) - *((void *)this + 37)) >> 2
        && v7 < (uint64_t)(*((void *)this + 41) - *((void *)this + 40)) >> 2
        && v7 < (uint64_t)(*((void *)this + 44) - *((void *)this + 43)) >> 2)
      {
        uint64_t v8 = a2 + 45;
        char v20 = 0;
        int v21 = 0;
        uint64_t v22 = 0;
        uint64_t v19 = 0;
        long long v17 = 0u;
        *(_OWORD *)uint64_t v18 = 0u;
        *(_OWORD *)__src = 0u;
        *(_OWORD *)long long v16 = 0u;
        memset(v14, 0, sizeof(v14));
        Nightingale::lstmHr::copyASliceToLstmStruct((uint64_t)this, (uint64_t)v14, (void *)this + 1, a2, (unsigned __int16)(a2 + 45));
        Nightingale::lstmHr::copyASliceToLstmStruct((uint64_t)this, (uint64_t)&v14[1] + 8, (void *)this + 4, a2, (unsigned __int16)(a2 + 45));
        std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)__src, (char *)__src[0], (float *)(*((void *)this + 37) + 4 * a2), (float *)(*((void *)this + 37) + 4 * v8), v8 - v6);
        std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v16[1], (char *)v16[1], (float *)(*((void *)this + 40) + 4 * v6), (float *)(*((void *)this + 40) + 4 * v8), v8 - v6);
        std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)v18, (char *)v18[0], (float *)(*((void *)this + 43) + 4 * v6), (float *)(*((void *)this + 43) + 4 * v8), v8 - v6);
        if ((Nightingale::ngt_dnn_fw_predict_t::ngt_dnn_process_fw((uint64_t *)this + 60, (uint64_t *)v14, (uint64_t)&v20) & 1) == 0)
        {
          Nightingale::lstmModelCommonFw::fwDLPostProcess(&v20, 0, -16, (uint64_t)v11);
          *((void *)this + 55) = v11[0];
          *(void *)((char *)this + 445) = *(void *)((char *)v11 + 5);
          uint64_t v9 = (void *)((char *)this + 456);
          uint64_t v10 = (void *)*((void *)this + 57);
          if (v10)
          {
            *((void *)this + 58) = v10;
            operator delete(v10);
            void *v9 = 0;
            *((void *)this + 58) = 0;
            *((void *)this + 59) = 0;
          }
          *(_OWORD *)uint64_t v9 = v12;
          *((void *)this + 59) = v13;
        }
        Nightingale::ngt_hr_DLin_t::~ngt_hr_DLin_t((Nightingale::ngt_hr_DLin_t *)v14);
        if (v20)
        {
          int v21 = v20;
          operator delete(v20);
        }
      }
    }
  }
}

void sub_257D529CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  Nightingale::ngt_hr_DLin_t::~ngt_hr_DLin_t((Nightingale::ngt_hr_DLin_t *)va);
  uint64_t v9 = *(void **)(v7 - 88);
  if (v9)
  {
    *(void *)(v7 - 80) = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t Nightingale::lstmHrFw::validateFwRsltADay(Nightingale::lstmHrFw *this, int a2)
{
  if (!*((unsigned char *)this + 444)) {
    return 0;
  }
  if (*((void *)this + 57) == *((void *)this + 58)) {
    return 0;
  }
  if (!*((unsigned char *)this + 452)) {
    return 0;
  }
  uint64_t v3 = *(void *)(*((void *)this + 23) + 8);
  if (!*(unsigned char *)(v3 - 60)) {
    return 0;
  }
  unint64_t v4 = (unint64_t **)((char *)this + 392);
  if (*((void *)this + 50) <= 7uLL) {
    goto LABEL_41;
  }
  int v5 = *((_DWORD *)this + 110);
  float v6 = *(float *)(v3 - 64);
  int v7 = *(_DWORD *)(v3 - 96);
  uint64_t v8 = (unint64_t *)*((void *)this + 49);
  unint64_t v9 = *v8 & 0xFFFFFFFFFFFFFF7FLL | ((unint64_t)*((unsigned __int8 *)this + 520) << 7);
  unint64_t *v8 = v9;
  unint64_t v10 = *((void *)this + 50);
  int v11 = v10 & 0x3F;
  if (v10 > 0x3F || v11 != 5)
  {
    int v12 = 5;
    uint64_t v13 = v8;
    while (((*v13 >> v12) & 1) == 0)
    {
      v13 += v12 == 63;
      if (v12 == 63) {
        int v12 = 0;
      }
      else {
        ++v12;
      }
      if (v12 == v11 && v13 == &v8[v10 >> 6]) {
        goto LABEL_15;
      }
    }
    return 0;
  }
LABEL_15:
  if (!v10) {
    goto LABEL_41;
  }
  unint64_t v14 = v9 & 0xFFFFFFFFFFFFFFFELL | (*((float *)this + 112) < 10.0);
  unint64_t *v8 = v14;
  if (*((void *)this + 50) <= 1uLL) {
    goto LABEL_41;
  }
  unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFFDLL | (2 * ((v5 & 0xFFFFFFFE) == 2));
  unint64_t *v8 = v15;
  if (*((void *)this + 50) <= 3uLL) {
    goto LABEL_41;
  }
  long long v16 = (Nightingale *)(a2 - v7 + v5);
  float v17 = (float)(int)v16;
  float v18 = roundf(v6 + -13.0);
  unint64_t *v8 = v15 & 0xFFFFFFFFFFFFFFF7 | (8 * (v18 < (float)(int)v16));
  char v19 = Nightingale::follicularPhaseCheck(v16, 6, 100);
  if (*((void *)this + 50) <= 2uLL) {
    goto LABEL_41;
  }
  **((void **)this + 49) = **((void **)this + 49) & 0xFFFFFFFFFFFFFFFBLL | (4 * (v19 & 1));
  BOOL v20 = Nightingale::passLutealPhaseCheck(v16, v6, 6.0);
  if (*((void *)this + 50) <= 4uLL) {
    goto LABEL_41;
  }
  int v21 = 0;
  uint64_t v22 = *v4;
  uint64_t v23 = 16;
  if (!v20) {
    uint64_t v23 = 0;
  }
  unint64_t v24 = **v4 & 0xFFFFFFFFFFFFFFEFLL | v23;
  *uint64_t v22 = v24;
  float v25 = v22;
  do
  {
    if (((*v25 >> v21) & 1) == 0) {
      return 0;
    }
    v25 += v21 == 63;
    if (v21 == 63) {
      int v21 = 0;
    }
    else {
      ++v21;
    }
  }
  while (v21 != 3 || v25 != v22);
  if (v18 < v17 && v20) {
    return 1;
  }
  unint64_t v28 = *((void *)this + 50);
  if (v18 >= v17)
  {
    if (v28 > 5)
    {
      uint64_t v29 = 32;
      goto LABEL_40;
    }
LABEL_41:
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  if (v28 <= 6) {
    goto LABEL_41;
  }
  uint64_t v29 = 64;
LABEL_40:
  uint64_t result = 0;
  *uint64_t v22 = v24 | v29;
  return result;
}

uint64_t Nightingale::lstmHrFw::validateToRunPeriodADay(Nightingale::lstmHrFw *this, int a2, int a3)
{
  if (*((unsigned char *)this + 536)) {
    return 0;
  }
  unint64_t v4 = this;
  if (!*((unsigned char *)this + 444)
    || *((void *)this + 57) == *((void *)this + 58)
    || !*((unsigned char *)this + 452)
    || !*(unsigned char *)(*(void *)(*((void *)this + 23) + 8) - 60))
  {
    return 0;
  }
  int v7 = *((_DWORD *)this + 110);
  uint64_t v8 = (Nightingale::lstmHrFw **)((char *)this + 416);
  int v9 = v7 + a2;
  int v11 = (Nightingale::lstmHrFw *)*((void *)this + 53);
  unint64_t v10 = *((void *)this + 54);
  if ((unint64_t)v11 >= v10)
  {
    this = *v8;
    uint64_t v13 = (v11 - *v8) >> 2;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = v10 - (void)this;
    if (v15 >> 1 > v14) {
      unint64_t v14 = v15 >> 1;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      float v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v4 + 432, v16);
      this = (Nightingale::lstmHrFw *)*((void *)v4 + 52);
      int v11 = (Nightingale::lstmHrFw *)*((void *)v4 + 53);
    }
    else
    {
      float v17 = 0;
    }
    float v18 = &v17[4 * v13];
    char v19 = &v17[4 * v16];
    *(_DWORD *)float v18 = v9;
    int v12 = v18 + 4;
    while (v11 != this)
    {
      int v20 = *((_DWORD *)v11 - 1);
      int v11 = (Nightingale::lstmHrFw *)((char *)v11 - 4);
      *((_DWORD *)v18 - 1) = v20;
      v18 -= 4;
    }
    *((void *)v4 + 52) = v18;
    *((void *)v4 + 53) = v12;
    *((void *)v4 + 54) = v19;
    if (this) {
      operator delete(this);
    }
  }
  else
  {
    *(_DWORD *)int v11 = v9;
    int v12 = (_DWORD *)((char *)v11 + 4);
  }
  *((void *)v4 + 53) = v12;
  uint64_t v21 = *((void *)v4 + 52);
  if ((unint64_t)v12 - v21 >= 0x11)
  {
    size_t v22 = (size_t)v12 - v21 - 4;
    if (v22) {
      this = (Nightingale::lstmHrFw *)memmove(*((void **)v4 + 52), (const void *)(v21 + 4), v22);
    }
    *((void *)v4 + 53) = v21 + v22;
  }
  BOOL v23 = Nightingale::lstmHrFw::consistencyCheck((uint64_t)this, (void *)v4 + 52, 4);
  uint64_t result = 0;
  if (v23 && (v7 + 5) >= 0xFFFFFFF1)
  {
    if (a3)
    {
      *((_DWORD *)v4 + 133) = a2;
      uint64_t result = 1;
      *((unsigned char *)v4 + 536) = 1;
    }
  }
  return result;
}

void Nightingale::lstmHr::copyASliceToLstmStruct(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, unsigned int a5)
{
  float v6 = (const void *)(*a3 + 8 * a4);
  uint64_t v7 = *a3 + 8 * a5;
  unint64_t v24 = 0;
  uint64_t v25 = 0;
  BOOL v23 = 0;
  std::vector<std::optional<float>>::__init_with_size[abi:ne180100]<std::optional<float>*,std::optional<float>*>(&v23, v6, v7, a5 - (unint64_t)a4);
  uint64_t v8 = v23;
  int v9 = v24;
  if (v23 != v24)
  {
    do
    {
      if (*((unsigned char *)v8 + 4)) {
        float v10 = *v8;
      }
      else {
        float v10 = -1.0;
      }
      double v11 = v10;
      uint64_t v13 = *(double **)(a2 + 8);
      unint64_t v12 = *(void *)(a2 + 16);
      if ((unint64_t)v13 >= v12)
      {
        uint64_t v15 = *(double **)a2;
        uint64_t v16 = ((uint64_t)v13 - *(void *)a2) >> 3;
        unint64_t v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 61) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v18 = v12 - (void)v15;
        if (v18 >> 2 > v17) {
          unint64_t v17 = v18 >> 2;
        }
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v17;
        }
        if (v19)
        {
          int v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>(a2 + 16, v19);
          uint64_t v15 = *(double **)a2;
          uint64_t v13 = *(double **)(a2 + 8);
        }
        else
        {
          int v20 = 0;
        }
        uint64_t v21 = (double *)&v20[8 * v16];
        *uint64_t v21 = v11;
        unint64_t v14 = v21 + 1;
        while (v13 != v15)
        {
          uint64_t v22 = *((void *)v13-- - 1);
          *((void *)v21-- - 1) = v22;
        }
        *(void *)a2 = v21;
        *(void *)(a2 + 8) = v14;
        *(void *)(a2 + 16) = &v20[8 * v19];
        if (v15) {
          operator delete(v15);
        }
      }
      else
      {
        double *v13 = v11;
        unint64_t v14 = v13 + 1;
      }
      *(void *)(a2 + 8) = v14;
      v8 += 2;
    }
    while (v8 != v9);
    uint64_t v8 = v23;
  }
  if (v8)
  {
    unint64_t v24 = v8;
    operator delete(v8);
  }
}

void sub_257D52F54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::ngt_hr_DLin_t::~ngt_hr_DLin_t(Nightingale::ngt_hr_DLin_t *this)
{
  int v2 = (void *)*((void *)this + 12);
  if (v2)
  {
    *((void *)this + 13) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 9);
  if (v3)
  {
    *((void *)this + 10) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 6);
  if (v4)
  {
    *((void *)this + 7) = v4;
    operator delete(v4);
  }
  int v5 = (void *)*((void *)this + 3);
  if (v5)
  {
    *((void *)this + 4) = v5;
    operator delete(v5);
  }
  float v6 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v6;
    operator delete(v6);
  }
}

BOOL Nightingale::lstmHrFw::consistencyCheck(uint64_t a1, void *a2, int a3)
{
  unint64_t v3 = (uint64_t)(a2[1] - *a2) >> 2;
  if (v3 < a3) {
    return 0;
  }
  unint64_t v5 = v3 - 1;
  if (v3 == 1) {
    return 1;
  }
  int v6 = 0;
  if (v3 <= 1) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = (uint64_t)(a2[1] - *a2) >> 2;
  }
  unint64_t v8 = v7 - 1;
  unint64_t v9 = v3 - 2;
  float v10 = (_DWORD *)(*a2 + 4);
  do
  {
    if (v8 <= v9) {
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    int v6 = *v10 + v6 - *(v10 - 1);
    ++v10;
    --v5;
  }
  while (v5);
  return v6 == 0;
}

void Nightingale::lstmHrFw::computeHrSignalQuality(Nightingale::lstmHrFw *this@<X0>, uint64_t a2@<X8>)
{
  *(_DWORD *)a2 = -1082130432;
  *(void *)(a2 + 4) = -1;
  unint64_t v4 = (_DWORD *)(a2 + 4);
  *(void *)(a2 + 12) = -1;
  __asm { FMOV            V0.4S, #-1.0 }
  *(_OWORD *)(a2 + 20) = _Q0;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(a2 + 36) = _Q0;
  uint64_t v11 = *((void *)this + 31);
  uint64_t v10 = *((void *)this + 32);
  if (v10 == v11)
  {
    *(void *)(a2 + 24) = 0;
    *(_DWORD *)(a2 + 20) = 0;
    *(void *)a2 = 1065353216;
    *(_DWORD *)(a2 + 12) = 0;
    goto LABEL_63;
  }
  uint64_t v12 = 0;
  uint64_t v13 = (v10 - v11) >> 3;
  uint64_t v14 = *((void *)this + 31);
  do
  {
    if (!*(unsigned char *)(v14 + 4)) {
      ++v12;
    }
    v14 += 8;
  }
  while (v14 != v10);
  uint64_t v15 = 0;
  float v16 = (float)(unint64_t)v13;
  *(float *)a2 = (float)v12 / (float)(unint64_t)v13;
  uint64_t v17 = v11;
  do
  {
    if (*(unsigned char *)(v17 + 4) && *(int *)v17 > 11) {
      ++v15;
    }
    v17 += 8;
  }
  while (v17 != v10);
  uint64_t v18 = 0;
  *(float *)(a2 + 20) = (float)v15 / v16;
  uint64_t v19 = v11;
  do
  {
    if (*(unsigned char *)(v19 + 4) && *(int *)v19 > 17) {
      ++v18;
    }
    v19 += 8;
  }
  while (v19 != v10);
  uint64_t v20 = 0;
  *(float *)(a2 + 24) = (float)v18 / v16;
  uint64_t v21 = v11;
  do
  {
    if (*(unsigned char *)(v21 + 4) && *(int *)v21 > 23) {
      ++v20;
    }
    v21 += 8;
  }
  while (v21 != v10);
  uint64_t v22 = 0;
  *(float *)(a2 + 28) = (float)v20 / v16;
  __n128 __p = 0;
  __int16 v67 = 0;
  uint64_t v68 = 0;
  do
  {
    if (*(unsigned char *)(v11 + 4))
    {
      float v23 = (float)*(int *)v11;
      if (v22 < (float *)v68)
      {
        *v22++ = v23;
        goto LABEL_54;
      }
      unint64_t v24 = (float *)__p;
      uint64_t v25 = ((char *)v22 - (unsigned char *)__p) >> 2;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 62) {
        goto LABEL_122;
      }
      uint64_t v27 = v68 - (unsigned char *)__p;
      if ((v68 - (unsigned char *)__p) >> 1 > v26) {
        unint64_t v26 = v27 >> 1;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v26;
      }
      if (v28)
      {
        uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v68, v28);
        unint64_t v24 = (float *)__p;
        uint64_t v22 = v67;
      }
      else
      {
        uint64_t v29 = 0;
      }
      long long v33 = (float *)&v29[4 * v25];
      *long long v33 = v23;
      uint64_t v34 = v33 + 1;
      while (v22 != v24)
      {
        int v35 = *((_DWORD *)v22-- - 1);
        *((_DWORD *)v33-- - 1) = v35;
      }
    }
    else
    {
      if (v22 < (float *)v68)
      {
        *v22++ = 0.0;
        goto LABEL_54;
      }
      unint64_t v24 = (float *)__p;
      uint64_t v30 = ((char *)v22 - (unsigned char *)__p) >> 2;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 62) {
LABEL_122:
      }
        std::vector<float>::__throw_length_error[abi:ne180100]();
      uint64_t v32 = v68 - (unsigned char *)__p;
      if ((v68 - (unsigned char *)__p) >> 1 > v31) {
        unint64_t v31 = v32 >> 1;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v28 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v31;
      }
      if (v28)
      {
        uint64_t v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v68, v28);
        unint64_t v24 = (float *)__p;
        uint64_t v22 = v67;
      }
      else
      {
        uint64_t v29 = 0;
      }
      long long v33 = (float *)&v29[4 * v30];
      *long long v33 = 0.0;
      uint64_t v34 = v33 + 1;
      while (v22 != v24)
      {
        int v36 = *((_DWORD *)v22-- - 1);
        *((_DWORD *)v33-- - 1) = v36;
      }
    }
    __n128 __p = v33;
    __int16 v67 = v34;
    uint64_t v68 = &v29[4 * v28];
    if (v24) {
      operator delete(v24);
    }
    uint64_t v22 = v34;
LABEL_54:
    __int16 v67 = v22;
    v11 += 8;
  }
  while (v11 != v10);
  if (v22 == __p) {
    goto LABEL_61;
  }
  std::__sort<std::__less<float,float> &,float *>();
  float Percentile = Nightingale::getPercentile((uint64_t *)&__p, 1, 0.5);
  if (Percentile > 50.0) {
    float Percentile = 50.0;
  }
  _DWORD *v4 = llroundf(Percentile);
  float v38 = Nightingale::getPercentile((uint64_t *)&__p, 1, 0.3);
  if (v38 > 50.0) {
    float v38 = 50.0;
  }
  *(_DWORD *)(a2 + 12) = llroundf(v38);
  uint64_t v22 = (float *)__p;
  if (__p)
  {
LABEL_61:
    __int16 v67 = v22;
    operator delete(v22);
  }
LABEL_63:
  uint64_t v40 = *((void *)this + 34);
  uint64_t v39 = *((void *)this + 35);
  if (v39 == v40)
  {
    *(void *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    *(_DWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    return;
  }
  uint64_t v41 = 0;
  uint64_t v42 = (v39 - v40) >> 3;
  uint64_t v43 = *((void *)this + 34);
  do
  {
    if (*(unsigned char *)(v43 + 4) && *(int *)v43 > 11) {
      ++v41;
    }
    v43 += 8;
  }
  while (v43 != v39);
  uint64_t v44 = 0;
  float v45 = (float)(unint64_t)v42;
  *(float *)(a2 + 32) = (float)v41 / (float)(unint64_t)v42;
  uint64_t v46 = v40;
  do
  {
    if (*(unsigned char *)(v46 + 4) && *(int *)v46 > 17) {
      ++v44;
    }
    v46 += 8;
  }
  while (v46 != v39);
  uint64_t v47 = 0;
  *(float *)(a2 + 36) = (float)v44 / v45;
  uint64_t v48 = v40;
  do
  {
    if (*(unsigned char *)(v48 + 4) && *(int *)v48 > 23) {
      ++v47;
    }
    v48 += 8;
  }
  while (v48 != v39);
  uint64_t v49 = 0;
  *(float *)(a2 + 40) = (float)v47 / v45;
  __n128 __p = 0;
  __int16 v67 = 0;
  uint64_t v68 = 0;
  while (2)
  {
    if (*(unsigned char *)(v40 + 4))
    {
      float v50 = (float)*(int *)v40;
      if (v49 < (float *)v68)
      {
        *v49++ = v50;
        goto LABEL_112;
      }
      unint64_t v51 = (float *)__p;
      uint64_t v52 = ((char *)v49 - (unsigned char *)__p) >> 2;
      unint64_t v53 = v52 + 1;
      if ((unint64_t)(v52 + 1) >> 62) {
        goto LABEL_123;
      }
      uint64_t v54 = v68 - (unsigned char *)__p;
      if ((v68 - (unsigned char *)__p) >> 1 > v53) {
        unint64_t v53 = v54 >> 1;
      }
      if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v55 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v53;
      }
      if (v55)
      {
        int v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v68, v55);
        unint64_t v51 = (float *)__p;
        uint64_t v49 = v67;
      }
      else
      {
        int v56 = 0;
      }
      char v60 = (float *)&v56[4 * v52];
      *char v60 = v50;
      float v61 = v60 + 1;
      while (v49 != v51)
      {
        int v62 = *((_DWORD *)v49-- - 1);
        *((_DWORD *)v60-- - 1) = v62;
      }
LABEL_109:
      __n128 __p = v60;
      __int16 v67 = v61;
      uint64_t v68 = &v56[4 * v55];
      if (v51) {
        operator delete(v51);
      }
      uint64_t v49 = v61;
    }
    else
    {
      if (v49 >= (float *)v68)
      {
        unint64_t v51 = (float *)__p;
        uint64_t v57 = ((char *)v49 - (unsigned char *)__p) >> 2;
        unint64_t v58 = v57 + 1;
        if ((unint64_t)(v57 + 1) >> 62) {
LABEL_123:
        }
          std::vector<float>::__throw_length_error[abi:ne180100]();
        uint64_t v59 = v68 - (unsigned char *)__p;
        if ((v68 - (unsigned char *)__p) >> 1 > v58) {
          unint64_t v58 = v59 >> 1;
        }
        if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v55 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v55 = v58;
        }
        if (v55)
        {
          int v56 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v68, v55);
          unint64_t v51 = (float *)__p;
          uint64_t v49 = v67;
        }
        else
        {
          int v56 = 0;
        }
        char v60 = (float *)&v56[4 * v57];
        *char v60 = 0.0;
        float v61 = v60 + 1;
        while (v49 != v51)
        {
          int v63 = *((_DWORD *)v49-- - 1);
          *((_DWORD *)v60-- - 1) = v63;
        }
        goto LABEL_109;
      }
      *v49++ = 0.0;
    }
LABEL_112:
    __int16 v67 = v49;
    v40 += 8;
    if (v40 != v39) {
      continue;
    }
    break;
  }
  if (v49 == __p) {
    goto LABEL_119;
  }
  std::__sort<std::__less<float,float> &,float *>();
  float v64 = Nightingale::getPercentile((uint64_t *)&__p, 1, 0.5);
  if (v64 > 50.0) {
    float v64 = 50.0;
  }
  *(_DWORD *)(a2 + 8) = llroundf(v64);
  float v65 = Nightingale::getPercentile((uint64_t *)&__p, 1, 0.3);
  if (v65 > 50.0) {
    float v65 = 50.0;
  }
  *(_DWORD *)(a2 + 16) = llroundf(v65);
  uint64_t v49 = (float *)__p;
  if (__p)
  {
LABEL_119:
    __int16 v67 = v49;
    operator delete(v49);
  }
}

void sub_257D53664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

double Nightingale::lstmHrFw::getHrSignalQuality@<D0>(Nightingale::lstmHrFw *this@<X0>, uint64_t a2@<X8>)
{
  if (Nightingale::lstmHr::acquireHr(this))
  {
    Nightingale::lstmHrFw::computeHrSignalQuality(this, a2);
  }
  else
  {
    *(_DWORD *)a2 = -1082130432;
    *(void *)(a2 + 4) = -1;
    *(void *)(a2 + 12) = -1;
    __asm { FMOV            V0.4S, #-1.0 }
    *(_OWORD *)(a2 + 20) = _Q0;
    __asm { FMOV            V0.2S, #-1.0 }
    *(double *)(a2 + 36) = result;
  }
  return result;
}

unsigned char *Nightingale::lstmHrPeriod::lstmHrPeriod(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v8 = (void *)Nightingale::lstmHr::lstmHr((uint64_t)a1, a2, a3, a4, a5);
  void *v8 = &unk_270697420;
  *(void *)((char *)v8 + 388) = a6;
  Nightingale::CGradient::CGradient((uint64_t)(v8 + 50));
  a1[456] = 0;
  a1[460] = 0;
  a1[464] = 0;
  a1[468] = 0;
  a1[472] = 0;
  a1[476] = 0;
  a1[480] = 0;
  a1[484] = 0;
  a1[488] = 0;
  a1[580] = 0;
  return a1;
}

void sub_257D53790(_Unwind_Exception *a1)
{
  Nightingale::lstmHr::~lstmHr(v1);
  _Unwind_Resume(a1);
}

void Nightingale::lstmHrPeriod::~lstmHrPeriod(Nightingale::lstmHrPeriod *this)
{
  *(void *)this = &unk_270697420;
  int v2 = (void *)*((void *)this + 50);
  if (v2)
  {
    *((void *)this + 51) = v2;
    operator delete(v2);
  }
  Nightingale::lstmHr::~lstmHr(this);
}

__n128 Nightingale::lstmHrPeriod::estimatePeriodStartHr@<Q0>(Nightingale::lstmHrPeriod *this@<X0>, uint64_t a2@<X8>)
{
  Nightingale::CGradient::CGradient(a2);
  *(unsigned char *)(a2 + 56) = 0;
  *(unsigned char *)(a2 + 60) = 0;
  *(unsigned char *)(a2 + 64) = 0;
  *(unsigned char *)(a2 + 68) = 0;
  *(unsigned char *)(a2 + 72) = 0;
  *(unsigned char *)(a2 + 76) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  *(unsigned char *)(a2 + 84) = 0;
  if (*((unsigned char *)this + 392))
  {
    uint64_t v5 = *(void *)(*((void *)this + 23) + 104);
    uint64_t v6 = *(void *)((char *)this + 388);
    uint64_t v7 = v5 & 0xFF00000000;
    int v8 = v5 + 1;
    BOOL v9 = !v7 || (v6 & 0xFF00000000) == 0;
    BOOL v10 = v9 || v8 < (int)v6;
    if (v10
      && Nightingale::lstmHr::acquireHr(this)
      && Nightingale::lstmHr::validateHr(this, 0)
      && Nightingale::lstmHr::preConditionHr(this))
    {
      if (!*((unsigned char *)this + 108) || !*((unsigned char *)this + 116) || !*((unsigned char *)this + 236)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      Nightingale::lstmHr::prepareUiVectors(this, *((_DWORD *)this + 26), *((_DWORD *)this + 28), *((_DWORD *)this + 58));
      Nightingale::lstmHrPeriod::applyAlgs(this);
      if ((Nightingale::lstmHrPeriod *)((char *)this + 400) != (Nightingale::lstmHrPeriod *)a2) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a2, *((char **)this + 50), *((void *)this + 51), (uint64_t)(*((void *)this + 51) - *((void *)this + 50)) >> 2);
      }
      *(_OWORD *)(a2 + 24) = *(_OWORD *)((char *)this + 424);
      *(_OWORD *)(a2 + 33) = *(_OWORD *)((char *)this + 433);
      *(_OWORD *)(a2 + 56) = *(_OWORD *)((char *)this + 456);
      __n128 result = *(__n128 *)((char *)this + 469);
      *(__n128 *)(a2 + 69) = result;
    }
  }
  return result;
}

void sub_257D5393C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::lstmHrPeriod::checkDayToRunPeriodDLLessThanOPK(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((a2 & 0xFF00000000) == 0) {
    return 0;
  }
  if ((a3 & 0xFF00000000) != 0) {
    return (int)a2 + 1 >= (int)a3;
  }
  return 0;
}

void Nightingale::lstmHrPeriod::applyAlgs(Nightingale::lstmHrPeriod *this)
{
  Nightingale::lstmModelCommonPeriod::lstmModelCommonPeriod((Nightingale::lstmModelCommonPeriod *)&v3);
  Nightingale::lstmHrPeriod::getPeriodProjFromLstmModel(this, (Nightingale::lstmModelCommonPeriod *)&v3);
  uint64_t v2 = *((void *)this + 23);
  if (*(unsigned char *)(v2 + 100)) {
    Nightingale::lstmModelCommonPeriod::applyNoflowUpdateDL((Nightingale::lstmModelCommonPeriod *)&v3, (Nightingale::lstmHrPeriod *)((char *)this + 400), *(_DWORD *)(v2 + 96) - *(_DWORD *)(*(void *)(v2 + 8) - 96));
  }
  *((_DWORD *)this + 118) = *((_DWORD *)this + 97);
  *((unsigned char *)this + 476) = *((unsigned char *)this + 392);
  Nightingale::lstmModelCommonPeriod::~lstmModelCommonPeriod((Nightingale::lstmModelCommonPeriod *)&v3);
}

void sub_257D53A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
}

__n128 Nightingale::lstmHrPeriod::getEnsembleTelemetry@<Q0>(Nightingale::lstmHrPeriod *this@<X0>, uint64_t a2@<X8>)
{
  long long v2 = *(_OWORD *)((char *)this + 536);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)((char *)this + 520);
  *(_OWORD *)(a2 + 48) = v2;
  long long v3 = *(_OWORD *)((char *)this + 568);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)((char *)this + 552);
  *(_OWORD *)(a2 + 80) = v3;
  __n128 result = *(__n128 *)((char *)this + 488);
  long long v5 = *(_OWORD *)((char *)this + 504);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v5;
  return result;
}

uint64_t Nightingale::lstmHrPeriod::acquireHrSlices(Nightingale::lstmHrPeriod *this)
{
  if (!*((unsigned char *)this + 392)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  long long v2 = (Nightingale::lstmHrPeriod *)((char *)this + 372);
  Nightingale::heartRateInputAcquisition::acquireSlicesPeriodDayStream((uint64_t)this + 372, *((uint64_t **)this + 22), *((_DWORD *)this + 97), (uint64_t)this + 8);
  uint64_t result = Nightingale::heartRateInputAcquisition::get1stJDayDailyIdx(v2);
  *((_DWORD *)this + 58) = result;
  *((unsigned char *)this + 236) = BYTE4(result);
  *((_DWORD *)this + 60) = v4;
  *((unsigned char *)this + 244) = v5;
  return result;
}

void Nightingale::lstmHrPeriod::getPeriodProjFromLstmModel(Nightingale::lstmHrPeriod *this, Nightingale::lstmModelCommonPeriod *a2)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  long long v33 = 0;
  uint64_t v34 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  Nightingale::lstmHr::copyASliceToLstmStruct((uint64_t)this, (uint64_t)&v24, (void *)this + 1, 0, 0x2Du);
  Nightingale::lstmHr::copyASliceToLstmStruct((uint64_t)this, (uint64_t)&v25 + 8, (void *)this + 4, 0, 0x2Du);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v27, (char *)v27, *((float **)this + 37), (float *)(*((void *)this + 37) + 180), 45);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v28 + 8, *((char **)&v28 + 1), *((float **)this + 40), (float *)(*((void *)this + 40) + 180), 45);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v30, (char *)v30, *((float **)this + 43), (float *)(*((void *)this + 43) + 180), 45);
  Nightingale::ngt_dnn_period_predict_t::ngt_dnn_period_predict_t((Nightingale::ngt_dnn_period_predict_t *)&v23, *((const Nightingale::ngt_Config **)this + 24));
  if ((Nightingale::ngt_dnn_period_predict_t::ngt_dnn_process_period((uint64_t *)&v23, (uint64_t *)&v24, (uint64_t)&v32) & 1) == 0)
  {
    if (!*((unsigned char *)this + 392)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    int v3 = *((_DWORD *)this + 97) - *(_DWORD *)(*(void *)(*((void *)this + 23) + 8) - 96);
    Nightingale::lstmModelCommonPeriod::periodDLPostProcess(&v32, v3, (uint64_t)v36);
    int v4 = (void *)*((void *)this + 50);
    if (v4)
    {
      *((void *)this + 51) = v4;
      operator delete(v4);
      *((void *)this + 50) = 0;
      *((void *)this + 51) = 0;
      *((void *)this + 52) = 0;
    }
    char v5 = *(const void **)v36;
    *((void *)this + 50) = *(void *)v36;
    uint64_t v6 = *(void *)&v36[8];
    *(_OWORD *)((char *)this + 408) = *(_OWORD *)&v36[8];
    *(_OWORD *)((char *)this + 424) = v37[0];
    *(_OWORD *)((char *)this + 433) = *(_OWORD *)((char *)v37 + 9);
    *(_OWORD *)((char *)this + 456) = v38[0];
    *(_OWORD *)((char *)this + 469) = *(_OWORD *)((char *)v38 + 13);
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    memset(v36, 0, sizeof(v36));
    std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v36, v5, v6, (v6 - (uint64_t)v5) >> 2);
    v37[0] = *(_OWORD *)((char *)this + 424);
    *(_OWORD *)((char *)v37 + 9) = *(_OWORD *)((char *)this + 433);
    v38[0] = *(_OWORD *)((char *)this + 456);
    *(_OWORD *)((char *)v38 + 13) = *(_OWORD *)((char *)this + 469);
    int v39 = 0;
    std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::insert(&v20, 0, (uint64_t)v36);
    std::__variant_detail::__dtor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v36);
    uint64_t v7 = *((void *)this + 24);
    uint64_t v8 = *(void *)(v7 + 264);
    uint64_t v9 = *(void *)(v7 + 272);
    if (v9 == v8) {
      goto LABEL_21;
    }
    if (*(char *)(v7 + 311) < 0)
    {
      if (!*(void *)(v7 + 296))
      {
LABEL_21:
        *(void *)int v36 = &v20;
        std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);
        goto LABEL_22;
      }
    }
    else if (!*(unsigned char *)(v7 + 311))
    {
      goto LABEL_21;
    }
    int v12 = v3;
    while (1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      BOOL v10 = (uint64_t *)Nightingale::ngt_dnn_period_predict_transformer_t::ngt_dnn_period_predict_transformer_t(buf, v8);
      if (Nightingale::ngt_dnn_period_predict_transformer_t::predict(v10, (uint64_t *)&v24, (uint64_t)&v17)) {
        break;
      }
      if (!*((unsigned char *)this + 392)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      uint64_t v11 = v21;
      Nightingale::lstmModelCommonPeriod::periodDLTransformerPostProcess((uint64_t)&v17, *((_DWORD *)this + 97) - *(_DWORD *)(*(void *)(*((void *)this + 23) + 8) - 96), (uint64_t)__p);
      *(_OWORD *)int v36 = *(_OWORD *)__p;
      *(void *)&v36[16] = v14;
      __p[1] = 0;
      uint64_t v14 = 0;
      __p[0] = 0;
      v37[0] = v15[0];
      *(_OWORD *)((char *)v37 + 9) = *(_OWORD *)((char *)v15 + 9);
      *(void *)&v38[0] = v16;
      int v39 = 1;
      std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::insert(&v20, v11, (uint64_t)v36);
      std::__variant_detail::__dtor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v36);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      Nightingale::ngt_dnn_period_predict_transformer_t::~ngt_dnn_period_predict_transformer_t((id **)buf);
      if (v17)
      {
        uint64_t v18 = v17;
        operator delete(v17);
      }
      v8 += 24;
      if (v8 == v9) {
        Nightingale::lstmHrPeriod::getEnsembleInput((uint64_t)this, (uint64_t)&v20, v12, v36);
      }
    }
    Nightingale::ngt_dnn_period_predict_transformer_t::~ngt_dnn_period_predict_transformer_t((id **)buf);
    if (v17)
    {
      uint64_t v18 = v17;
      operator delete(v17);
    }
    goto LABEL_21;
  }
LABEL_22:
  Nightingale::ngt_dnn_period_predict_t::~ngt_dnn_period_predict_t(&v23);
  if ((void)v30)
  {
    *((void *)&v30 + 1) = v30;
    operator delete((void *)v30);
  }
  if (*((void *)&v28 + 1))
  {
    *(void *)&long long v29 = *((void *)&v28 + 1);
    operator delete(*((void **)&v28 + 1));
  }
  if ((void)v27)
  {
    *((void *)&v27 + 1) = v27;
    operator delete((void *)v27);
  }
  if (*((void *)&v25 + 1))
  {
    *(void *)&long long v26 = *((void *)&v25 + 1);
    operator delete(*((void **)&v25 + 1));
  }
  if ((void)v24)
  {
    *((void *)&v24 + 1) = v24;
    operator delete((void *)v24);
  }
  if (v32)
  {
    long long v33 = v32;
    operator delete(v32);
  }
}

void sub_257D54004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,id *a26,__int16 a27,char a28,char a29)
{
  Nightingale::ngt_dnn_period_predict_Ensemble_t::~ngt_dnn_period_predict_Ensemble_t((id **)&a20);
  if (__p) {
    operator delete(__p);
  }
  v29[20] = &a23;
  std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v30 - 208));
  Nightingale::ngt_dnn_period_predict_t::~ngt_dnn_period_predict_t(&a26);
  Nightingale::ngt_hr_DLin_t::~ngt_hr_DLin_t((Nightingale::ngt_hr_DLin_t *)&a27);
  uint64_t v32 = (void *)v29[15];
  if (v32)
  {
    v29[16] = v32;
    operator delete(v32);
  }
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::insert(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  unint64_t v6 = a1[1];
  unint64_t v9 = a1[2];
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = v9;
  if (v6 >= v9)
  {
    uint64_t v10 = *a1;
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *a1) >> 5) + 1;
    if (v11 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v10) >> 5);
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v8 - v10) >> 5);
    unint64_t v14 = 2 * v13;
    if (2 * v13 <= v11) {
      unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *a1) >> 5) + 1;
    }
    if (v13 >= 0x155555555555555) {
      unint64_t v15 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v14;
    }
    uint64_t v22 = v7;
    if (v15) {
      uint64_t v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(v7, v15);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v18 = v16;
    uint64_t v19 = &v16[96 * v12];
    uint64_t v20 = v19;
    uint64_t v21 = &v16[96 * v15];
    std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::push_back(&v18, a3);
    uint64_t v4 = std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__swap_out_circular_buffer(a1, &v18, v4);
    std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::~__split_buffer((uint64_t)&v18);
  }
  else if (a2 == v6)
  {
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(a2, a3);
    a1[1] = v4 + 96;
  }
  else
  {
    std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__move_range((uint64_t)a1, a2, v6, a2 + 96);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(v4, a3);
  }
  return v4;
}

void sub_257D5424C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void Nightingale::lstmHrPeriod::getEnsembleInput(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, _DWORD *a4@<X8>)
{
  Nightingale::uiLogProcessor::uiLogProcessor((uint64_t)v16, *(void *)(*(void *)(a1 + 192) + 48));
  Nightingale::uiLogProcessor::getEnsembleInput((uint64_t)v16, *(uint64_t **)(a1 + 184), *(void *)(a1 + 192), (uint64_t)a4);
  if (*(void *)(a2 + 8) != *(void *)a2)
  {
    Nightingale::get_width_and_days_to_drs(*(unsigned int **)a2, a3);
    a4[3] = v8;
    a4[4] = v9;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5) > 1)
    {
      Nightingale::get_width_and_days_to_drs((unsigned int *)(*(void *)a2 + 96), a3);
      a4[5] = v10;
      a4[6] = v11;
      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 5) > 2)
      {
        Nightingale::get_width_and_days_to_drs((unsigned int *)(*(void *)a2 + 192), a3);
        a4[7] = v12;
        a4[8] = v13;
        uint64_t v14 = *(void *)(a1 + 192);
        if (*(unsigned char *)(v14 + 52)) {
          int v15 = *(_DWORD *)(v14 + 48);
        }
        else {
          int v15 = 2143289344;
        }
        a4[9] = v15;
        Nightingale::vMean<float>();
      }
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  std::vector<int>::__throw_out_of_range[abi:ne180100]();
}

void sub_257D546B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  Nightingale::uiLogProcessor::~uiLogProcessor((Nightingale::uiLogProcessor *)&a15);
  _Unwind_Resume(a1);
}

uint64_t Nightingale::get_phase_day_format(Nightingale *this)
{
  uint64_t v1 = 0x100000000;
  if (this == -2)
  {
    int v2 = 254;
  }
  else
  {
    uint64_t v1 = 0;
    int v2 = 0;
  }
  if (this == -2) {
    unsigned int v3 = -256;
  }
  else {
    unsigned int v3 = 0;
  }
  if ((int)this >= 0)
  {
    uint64_t v1 = 0x100000000;
    int v2 = ((_BYTE)this - 1);
    unsigned int v3 = (this - 1) & 0xFFFFFF00;
  }
  return v1 | v3 | v2;
}

uint64_t Nightingale::get_days_since(uint64_t a1, int a2)
{
  unsigned int v2 = a2 - a1;
  if (a2 <= (int)a1 || a1 == -2) {
    unsigned int v2 = -1;
  }
  if ((a1 & 0xFF00000000) != 0) {
    return v2;
  }
  else {
    return 4294967293;
  }
}

uint64_t Nightingale::get_width_and_days_to_drs(unsigned int *a1, int a2)
{
  int v5 = a2;
  v4[0] = &v5;
  v4[1] = &v5;
  uint64_t v2 = a1[22];
  if (v2 == -1) {
    std::__throw_bad_variant_access[abi:ne180100]();
  }
  unint64_t v6 = v4;
  return off_270697498[v2]((int)&v6, (Nightingale::CGradient *)a1);
}

void std::vector<std::vector<BOOL>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<BOOL>>::__clear[abi:ne180100]((uint64_t *)v2);
    unsigned int v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::vector<BOOL>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    int v5 = *(void **)(i - 24);
    uint64_t v4 = v5;
    if (v5) {
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:ne180100](a1, a2);
    int v6 = *a3;
    unint64_t v7 = a1[1];
    unint64_t v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      unint64_t v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        uint64_t v13 = *a1 + 8 * (v7 >> 6);
        int v14 = v7 & 0x3F;
        if (v6) {
          std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v13, a2);
        }
        else {
          std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        }
        return a1;
      }
    }
    else
    {
      unint64_t v9 = v8 - 1;
    }
    unint64_t v10 = v9 >> 6;
    if (v8 >= 0x41) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = 0;
    }
    *(void *)(*a1 + 8 * v11) = 0;
    goto LABEL_10;
  }
  return a1;
}

void *std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  unsigned int v3 = result;
  int v4 = *((_DWORD *)result + 2);
  int v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *uint64_t result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    uint64_t result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    unint64_t v8 = &v5[v7];
    void *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  int v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    unint64_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

uint64_t std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  unint64_t v7 = a2 + v6 - a4;
  uint64_t v8 = v6;
  if (v7 < a3)
  {
    unint64_t v10 = a2 + v6 - a4;
    uint64_t v8 = v6;
    do
    {
      uint64_t v11 = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(v8, v10);
      v10 += 96;
      uint64_t v8 = v11 + 96;
    }
    while (v10 < a3);
  }
  *(void *)(a1 + 8) = v8;
  return std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *>((uint64_t)&v13, a2, v7, v6);
}

uint64_t std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::push_back(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[2];
  if (v4 == a1[3])
  {
    unint64_t v5 = a1[1];
    if (v5 <= *a1)
    {
      if (v4 == *a1) {
        unint64_t v10 = 1;
      }
      else {
        unint64_t v10 = 0x5555555555555556 * ((v4 - *a1) >> 5);
      }
      unint64_t v11 = v10 >> 2;
      uint64_t v12 = a1[4];
      uint64_t v29 = a1[4];
      char v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Nightingale::cycleInfo>>(v12, v10);
      int v14 = &v13[96 * v11];
      uint64_t v16 = &v13[96 * v15];
      unint64_t v17 = a1[1];
      int64_t v18 = a1[2] - v17;
      if (v18)
      {
        uint64_t v19 = v18 / 96;
        uint64_t v20 = &v14[96 * v19];
        uint64_t v21 = 96 * v19;
        uint64_t v22 = (uint64_t)v14;
        do
        {
          uint64_t v22 = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(v22, v17)+ 96;
          v17 += 96;
          v21 -= 96;
        }
        while (v21);
        int64x2_t v23 = *(int64x2_t *)(a1 + 1);
      }
      else
      {
        int64x2_t v23 = vdupq_n_s64(v17);
        uint64_t v20 = v14;
      }
      uint64_t v26 = *a1;
      *a1 = v13;
      a1[1] = v14;
      int64x2_t v27 = v23;
      uint64_t v24 = a1[3];
      a1[2] = v20;
      a1[3] = v16;
      uint64_t v28 = v24;
      std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::~__split_buffer((uint64_t)&v26);
      uint64_t v4 = a1[2];
    }
    else
    {
      int64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 5);
      if (v6 >= -1) {
        uint64_t v7 = v6 + 1;
      }
      else {
        uint64_t v7 = v6 + 2;
      }
      uint64_t v8 = -3 * (v7 >> 1);
      std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *>((uint64_t)&v26, v5, v4, v5 - 96 * (v7 >> 1));
      uint64_t v4 = v9;
      a1[1] += 32 * v8;
      a1[2] = v9;
    }
  }
  uint64_t result = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(v4, a2);
  a1[2] += 96;
  return result;
}

uint64_t std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (v7 != a3)
  {
    uint64_t v9 = a3;
    uint64_t v8 = a2[1];
    do
    {
      v9 -= 96;
      uint64_t v8 = std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(v8 - 96, v9);
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v10 = a1[1];
  uint64_t v11 = a2[2];
  if (v10 != v3)
  {
    do
    {
      std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(v11, v3);
      v3 += 96;
      v11 += 96;
    }
    while (v3 != v10);
    uint64_t v8 = a2[1];
  }
  a2[2] = v11;
  uint64_t v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::__move_constructor(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 88) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(a1, a2);
  return a1;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 88);
  if (v4 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))off_270697468[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 88) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 88);
  if (v5 != -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_270697478[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 88) = v5;
  }
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  long long v3 = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(a2 + 33) = *(_OWORD *)(a3 + 33);
  *(_OWORD *)(a2 + 24) = v3;
  __n128 result = *(__n128 *)(a3 + 56);
  *(_OWORD *)(a2 + 69) = *(_OWORD *)(a3 + 69);
  *(__n128 *)(a2 + 56) = result;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISB_LNS0_6_TraitE1EEEEEvRSC_OT_EUlRSI_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSQ_EEEDcSI_DpT0_(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(void *)(a2 + 16) = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  __n128 result = *(__n128 *)(a3 + 24);
  *(_OWORD *)(a2 + 33) = *(_OWORD *)(a3 + 33);
  *(__n128 *)(a2 + 24) = result;
  *(void *)(a2 + 56) = *(void *)(a3 + 56);
  return result;
}

uint64_t std::__move_backward_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v7 = a4 - 96;
  uint64_t v8 = a3;
  while (v8 != a2)
  {
    v8 -= 96;
    v4 -= 96;
    uint64_t v9 = v7 - 96;
    std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(v7, v8);
    uint64_t v7 = v9;
  }
  return a3;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 88);
  uint64_t v4 = *(unsigned int *)(a2 + 88);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_270697468[v3])(&v6, result, a2);
    *(_DWORD *)(v2 + 88) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_270697488[v4])(&v5, result, a2);
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSP_EEEDcSH_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&double result = std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__assign_alt[abi:ne180100]<0ul,Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodOutStruct>(*a1, a2, a3).n128_u64[0];
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJN11Nightingale19lstmPeriodOutStructENS8_21lstmPeriodTFOutStructEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISB_LNS0_6_TraitE1EEEEEvOT_EUlRSH_OT0_E_JRNS0_6__baseILSF_1EJS9_SA_EEEOSP_EEEDcSH_DpT0_(uint64_t *a1, uint64_t a2, uint64_t a3)
{
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__assign_alt[abi:ne180100]<0ul,Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodOutStruct>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 88))
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__emplace[abi:ne180100]<0ul,Nightingale::lstmPeriodOutStruct>(a1, a3);
  }
  else
  {
    std::vector<float>::__move_assign(a2, (__n128 *)a3);
    long long v6 = *(_OWORD *)(a3 + 24);
    *(_OWORD *)(a2 + 33) = *(_OWORD *)(a3 + 33);
    *(_OWORD *)(a2 + 24) = v6;
    __n128 result = *(__n128 *)(a3 + 56);
    *(_OWORD *)(a2 + 69) = *(_OWORD *)(a3 + 69);
    *(__n128 *)(a2 + 56) = result;
  }
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__emplace[abi:ne180100]<0ul,Nightingale::lstmPeriodOutStruct>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 88);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_270697468[v4])(&v8, a1);
  }
  *(_DWORD *)(a1 + 88) = -1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v5 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v5;
  long long v6 = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(a1 + 69) = *(_OWORD *)(a2 + 69);
  *(_OWORD *)(a1 + 56) = v6;
  *(_DWORD *)(a1 + 88) = 0;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__assign_alt[abi:ne180100]<1ul,Nightingale::lstmPeriodTFOutStruct,Nightingale::lstmPeriodTFOutStruct>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 88) == 1)
  {
    std::vector<float>::__move_assign(a2, (__n128 *)a3);
    long long v5 = *(_OWORD *)(a3 + 24);
    *(_OWORD *)(a2 + 33) = *(_OWORD *)(a3 + 33);
    *(_OWORD *)(a2 + 24) = v5;
    *(void *)(a2 + 56) = *(void *)(a3 + 56);
  }
  else
  {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__emplace[abi:ne180100]<1ul,Nightingale::lstmPeriodTFOutStruct>(a1, a3);
  }
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__emplace[abi:ne180100]<1ul,Nightingale::lstmPeriodTFOutStruct>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 88);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_270697468[v4])(&v7, a1);
  }
  *(_DWORD *)(a1 + 88) = -1;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v5 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 33) = *(_OWORD *)(a2 + 33);
  *(_OWORD *)(a1 + 24) = v5;
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_DWORD *)(a1 + 88) = 1;
  return a1;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *,std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      std::__variant_detail::__assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>>(a4, v5);
      v5 += 96;
      a4 += 96;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

uint64_t std::__split_buffer<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 96;
    std::__variant_detail::__dtor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::~__dtor(i - 96);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 88);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_270697468[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 88) = -1;
  return a1;
}

void std::__throw_bad_variant_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x263F8C3A8] + 16;
  __cxa_throw(exception, MEMORY[0x263F8C1F8], (void (*)(void *))std::bad_variant_access::~bad_variant_access);
}

void std::vector<std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = std::__variant_detail::__dtor<std::__variant_detail::__traits<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct>,(std::__variant_detail::_Trait)1>::~__dtor(v4 - 96);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

float std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<Nightingale::overloaded<Nightingale::get_width_and_days_to_drs(std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&,int)::$_0,Nightingale::get_width_and_days_to_drs(std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&,int)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&>(int a1, float **this)
{
  if (!*((unsigned char *)this + 68) || !*((unsigned char *)this + 60)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  return roundf((float)(*((float *)this + 16) - *((float *)this + 14)) + 1.0);
}

float std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<Nightingale::overloaded<Nightingale::get_width_and_days_to_drs(std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&,int)::$_0,Nightingale::get_width_and_days_to_drs(std::variant<Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&,int)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,Nightingale::lstmPeriodOutStruct,Nightingale::lstmPeriodTFOutStruct> const&>(uint64_t a1, float **this)
{
  return roundf((float)(*((float *)this + 15) - *((float *)this + 14)) + 1.0);
}

uint64_t Nightingale::lstmLuna::lstmLuna(uint64_t a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4)
{
  *(void *)a1 = &unk_2706974B8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = -1;
  *(_DWORD *)(a1 + 180) = 0;
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 220) = 0;
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 228) = 0;
  *(unsigned char *)(a1 + 260) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 176) = 0;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(unsigned char *)(a1 + 216) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(unsigned char *)(a1 + 256) = 0;
  Nightingale::wristTemperatureInputAcquisition::wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(a1 + 296));
  Nightingale::wristTemperatureInputProcess::wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(a1 + 368));
  Nightingale::wristTemperatureInputValidation::wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)(a1 + 369));
  Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fw_dl_tmp_process((Nightingale::ngt_luna_fw_dl_tmp_process *)(a1 + 376), a4);
  Nightingale::lstmModelCommonFw::lstmModelCommonFw((Nightingale::lstmModelCommonFw *)(a1 + 384));
  return a1;
}

void sub_257D55620(_Unwind_Exception *a1)
{
  Nightingale::ngt_luna_fw_dl_tmp_process::~ngt_luna_fw_dl_tmp_process(v6);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation(v5);
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess(v4);
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition(v3);
  uint64_t v10 = (void *)v1[33];
  if (v10)
  {
    v1[34] = v10;
    operator delete(v10);
  }
  uint64_t v11 = *v8;
  if (*v8)
  {
    v1[30] = v11;
    operator delete(v11);
  }
  uint64_t v12 = *v7;
  if (*v7)
  {
    v1[25] = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)v1[19];
  if (v13)
  {
    v1[20] = v13;
    operator delete(v13);
  }
  uint64_t v14 = (void *)v1[16];
  if (v14)
  {
    v1[17] = v14;
    operator delete(v14);
  }
  Nightingale::extractKaliInputsRtn::~extractKaliInputsRtn(v2);
  _Unwind_Resume(a1);
}

void Nightingale::lstmLuna::~lstmLuna(id **this)
{
  *this = (id *)&unk_2706974B8;
  Nightingale::lstmModelCommonFw::~lstmModelCommonFw((Nightingale::lstmModelCommonFw *)(this + 48));
  Nightingale::ngt_luna_fw_dl_tmp_process::~ngt_luna_fw_dl_tmp_process(this + 47);
  Nightingale::wristTemperatureInputValidation::~wristTemperatureInputValidation((Nightingale::wristTemperatureInputValidation *)((char *)this + 369));
  Nightingale::wristTemperatureInputProcess::~wristTemperatureInputProcess((Nightingale::wristTemperatureInputProcess *)(this + 46));
  Nightingale::wristTemperatureInputAcquisition::~wristTemperatureInputAcquisition((Nightingale::wristTemperatureInputAcquisition *)(this + 37));
  uint64_t v2 = this[33];
  if (v2)
  {
    this[34] = v2;
    operator delete(v2);
  }
  uint64_t v3 = this[29];
  if (v3)
  {
    this[30] = v3;
    operator delete(v3);
  }
  uint64_t v4 = this[24];
  if (v4)
  {
    this[25] = v4;
    operator delete(v4);
  }
  uint64_t v5 = this[19];
  if (v5)
  {
    this[20] = v5;
    operator delete(v5);
  }
  long long v6 = this[16];
  if (v6)
  {
    this[17] = v6;
    operator delete(v6);
  }
  char v7 = this[13];
  if (v7)
  {
    this[14] = v7;
    operator delete(v7);
  }
  char v8 = this[10];
  if (v8)
  {
    this[11] = v8;
    operator delete(v8);
  }
  uint64_t v9 = (void **)(this + 6);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v9);
}

BOOL Nightingale::lstmLuna::acquireWTmp(Nightingale::lstmLuna *this, int a2, int a3)
{
  long long v6 = (uint64_t *)((char *)this + 296);
  Nightingale::wristTemperatureInputAcquisition::reset((Nightingale::lstmLuna *)((char *)this + 296));
  unint64_t JDayIdx1stTmp = Nightingale::wristTemperatureInputAcquisition::getJDayIdx1stTmp((uint64_t)v6, *((unsigned int ***)this + 1));
  if (*((unsigned __int8 *)this + 40) != v8)
  {
    if (!*((unsigned char *)this + 40))
    {
      *((void *)this + 4) = JDayIdx1stTmp;
      *((unsigned char *)this + 40) = 1;
      goto LABEL_8;
    }
    *((unsigned char *)this + 40) = 0;
LABEL_6:
    BOOL v9 = 0;
    *((unsigned char *)this + 184) = 1;
    return v9;
  }
  if (!*((unsigned char *)this + 40)) {
    goto LABEL_6;
  }
  *((void *)this + 4) = JDayIdx1stTmp;
LABEL_8:
  memset(v23, 0, sizeof(v23));
  Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf_fromCycleOffset(v6, a3 - a2 + 1, a3, *(_DWORD *)(*(void *)(*((void *)this + 2) + 8) - 96) - 43, *((void **)this + 1), JDayIdx1stTmp, (uint64_t)&v16);
  std::vector<std::vector<float>>::__vdeallocate((uint64_t *)this + 6);
  *((_OWORD *)this + 3) = v16;
  uint64_t v10 = (void *)*((void *)this + 10);
  uint64_t v11 = v17;
  uint64_t v12 = v18;
  uint64_t v17 = 0;
  long long v16 = 0uLL;
  *((void *)this + 8) = v11;
  *((void *)this + 9) = v12;
  if (v10)
  {
    *((void *)this + 11) = v10;
    operator delete(v10);
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    *((void *)this + 12) = 0;
  }
  uint64_t v13 = (void *)*((void *)this + 13);
  *((_OWORD *)this + 5) = *(_OWORD *)__p;
  *((void *)this + 12) = v20;
  __p[1] = 0;
  uint64_t v20 = 0;
  __p[0] = 0;
  if (v13)
  {
    *((void *)this + 14) = v13;
    operator delete(v13);
    *((void *)this + 13) = 0;
    *((void *)this + 14) = 0;
    *((void *)this + 15) = 0;
    uint64_t v13 = __p[0];
  }
  *(_OWORD *)((char *)this + 104) = v21;
  *((void *)this + 15) = v22;
  uint64_t v22 = 0;
  long long v21 = 0uLL;
  if (v13)
  {
    __p[1] = v13;
    operator delete(v13);
  }
  uint64_t v24 = (void **)&v16;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v24);
  if (*((void *)this + 6) == *((void *)this + 7))
  {
    BOOL v9 = 0;
    *((unsigned char *)this + 184) = 1;
  }
  else
  {
    Nightingale::wristTemperatureInputProcess::constructVectorOfSlicesFromMultipleWatches((Nightingale::lstmLuna *)((char *)this + 48), 45, 1, a2, (uint64_t)&v16);
    uint64_t v14 = v16;
    BOOL v9 = v16 != *((void *)&v16 + 1);
    if ((void)v16 == *((void *)&v16 + 1))
    {
      *((unsigned char *)this + 184) = 1;
    }
    else
    {
      if ((Nightingale::lstmLuna *)((char *)this + 128) != (Nightingale::lstmLuna *)v16)
      {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)this + 128, *(char **)v16, *(void *)(v16 + 8), (uint64_t)(*(void *)(v16 + 8) - *(void *)v16) >> 2);
        uint64_t v14 = v16;
      }
      if ((Nightingale::lstmLuna *)((char *)this + 152) != (Nightingale::lstmLuna *)v14) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)this + 152, *(char **)v14, *(void *)(v14 + 8), (uint64_t)(*(void *)(v14 + 8) - *(void *)v14) >> 2);
      }
      *((unsigned char *)this + 176) = *(unsigned char *)v18;
    }
    if (v20)
    {
      *(void *)&long long v21 = v20;
      operator delete(v20);
    }
    if (v18)
    {
      __p[0] = v18;
      operator delete(v18);
    }
    uint64_t v24 = (void **)&v16;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v24);
  }
  *(void *)&long long v16 = v23;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v16);
  return v9;
}

void sub_257D55A24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  a9 = &a19;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  _Unwind_Resume(a1);
}

BOOL Nightingale::lstmLuna::validateWTmp(Nightingale::lstmLuna *this, int a2, float a3)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  memset(v75, 0, sizeof(v75));
  uint64_t v7 = *((void *)this + 16);
  uint64_t v8 = *((void *)this + 17);
  long long v6 = (float **)((char *)this + 128);
  BOOL v9 = operator new(4uLL);
  int v72 = v9;
  _DWORD *v9 = (unint64_t)(v8 - v7) >> 2;
  uint64_t v73 = v9 + 1;
  int v74 = v9 + 1;
  uint64_t v10 = (float *)operator new(4uLL);
  __int16 v69 = v10;
  *uint64_t v10 = a3;
  int v70 = v10 + 1;
  double v71 = v10 + 1;
  unsigned __int8 v76 = (uint64_t *)&unk_2706971D0;
  int v77 = Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpMissingCntHigh;
  uint64_t v78 = 0;
  int v79 = (void **)&v76;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v75, (uint64_t)&v76);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&v76);
  __int16 v67 = 0;
  uint64_t v68 = 0;
  __n128 __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v72, (uint64_t)v73, (v73 - (unsigned char *)v72) >> 2);
  uint64_t v11 = *((void *)this + 13);
  unint64_t v12 = *((unsigned __int8 *)this + 176);
  if (v12 >= (*((void *)this + 14) - v11) >> 3) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  if (*(unsigned char *)(v11 + 8 * v12 + 4) || **v6 >= 0.0)
  {
    Nightingale::wristTemperatureInputValidation::checkListOfConditions((uint64_t)this + 369, v75, (uint64_t)v6, &__p, &v69, 1, (void **)&v76);
    uint64_t v13 = *v76;
    int v77 = (unint64_t (*)(float, uint64_t, uint64_t, int))v76;
    operator delete(v76);
  }
  else
  {
    uint64_t v13 = 0x3F80000000000001;
  }
  uint64_t v14 = (char **)((char *)this + 192);
  long long v16 = (void *)((char *)this + 208);
  unint64_t v15 = *((void *)this + 26);
  uint64_t v17 = (uint64_t *)*((void *)this + 25);
  if ((unint64_t)v17 >= v15)
  {
    uint64_t v19 = ((char *)v17 - *v14) >> 3;
    if ((unint64_t)(v19 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v20 = v15 - (void)*v14;
    uint64_t v21 = v20 >> 2;
    if (v20 >> 2 <= (unint64_t)(v19 + 1)) {
      uint64_t v21 = v19 + 1;
    }
    if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v21;
    }
    if (v22) {
      int64x2_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)this + 208, v22);
    }
    else {
      int64x2_t v23 = 0;
    }
    uint64_t v24 = (uint64_t *)&v23[8 * v19];
    long long v25 = &v23[8 * v22];
    *uint64_t v24 = v13;
    int64_t v18 = v24 + 1;
    int64x2_t v27 = (char *)*((void *)this + 24);
    uint64_t v26 = (char *)*((void *)this + 25);
    if (v26 != v27)
    {
      do
      {
        uint64_t v28 = *((void *)v26 - 1);
        v26 -= 8;
        *--uint64_t v24 = v28;
      }
      while (v26 != v27);
      uint64_t v26 = *v14;
    }
    *((void *)this + 24) = v24;
    *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v18;
    *((void *)this + 26) = v25;
    if (v26) {
      operator delete(v26);
    }
  }
  else
  {
    *uint64_t v17 = v13;
    int64_t v18 = v17 + 1;
  }
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v18;
  if (__p)
  {
    __int16 v67 = __p;
    operator delete(__p);
  }
  uint64_t v29 = *((void *)this + 17);
  int v77 = 0;
  uint64_t v78 = 0;
  unsigned __int8 v76 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v76, (const void *)(v29 - 84), v29, 0x15uLL);
  float v64 = Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpDay2dayNoiseHigh;
  float v65 = 0;
  std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::operator=<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),void>((void *)v75[0], (uint64_t *)&v64);
  *(_DWORD *)int v72 = (unint64_t)((char *)v77 - (char *)v76) >> 2;
  *(_DWORD *)__int16 v69 = 1039851848;
  Nightingale::wristTemperatureInputValidation::checkListOfConditions((uint64_t)this + 369, v75, (uint64_t)&v76, &v72, &v69, 1, &v64);
  uint64_t v30 = v65;
  uint64_t v32 = (char *)*((void *)this + 25);
  unint64_t v31 = *((void *)this + 26);
  if ((unint64_t)v32 >= v31)
  {
    uint64_t v34 = (v32 - *v14) >> 3;
    if ((unint64_t)(v34 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v35 = v31 - (void)*v14;
    uint64_t v36 = v35 >> 2;
    if (v35 >> 2 <= (unint64_t)(v34 + 1)) {
      uint64_t v36 = v34 + 1;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v37 = v36;
    }
    if (v37) {
      float v38 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)this + 208, v37);
    }
    else {
      float v38 = 0;
    }
    int v39 = &v38[8 * v34];
    uint64_t v40 = &v38[8 * v37];
    *(void *)int v39 = *(v30 - 1);
    long long v33 = v39 + 8;
    uint64_t v42 = (char *)*((void *)this + 24);
    uint64_t v41 = (char *)*((void *)this + 25);
    if (v41 != v42)
    {
      do
      {
        uint64_t v43 = *((void *)v41 - 1);
        v41 -= 8;
        *((void *)v39 - 1) = v43;
        v39 -= 8;
      }
      while (v41 != v42);
      uint64_t v41 = *v14;
    }
    *((void *)this + 24) = v39;
    *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v33;
    *((void *)this + 26) = v40;
    if (v41) {
      operator delete(v41);
    }
  }
  else
  {
    *(void *)uint64_t v32 = *(v65 - 1);
    long long v33 = v32 + 8;
  }
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v33;
  uint64_t v44 = *(void *)(*((void *)this + 2) + 8);
  if (!*(unsigned char *)(v44 - 60)) {
    std::__throw_bad_optional_access[abi:ne180100]();
  }
  int v45 = *(_DWORD *)(v44 - 96) - a2 + (int)(float)(roundf(*(float *)(v44 - 64)) + -13.0);
  BOOL v46 = v45 > 0;
  float v47 = (float)v45;
  if ((unint64_t)v33 >= *v16)
  {
    uint64_t v49 = (v33 - *v14) >> 3;
    if ((unint64_t)(v49 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v50 = *v16 - (void)*v14;
    uint64_t v51 = v50 >> 2;
    if (v50 >> 2 <= (unint64_t)(v49 + 1)) {
      uint64_t v51 = v49 + 1;
    }
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v52 = v51;
    }
    if (v52) {
      unint64_t v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)this + 208, v52);
    }
    else {
      unint64_t v53 = 0;
    }
    uint64_t v54 = &v53[8 * v49];
    unint64_t v55 = &v53[8 * v52];
    *(_DWORD *)uint64_t v54 = v46;
    *((float *)v54 + 1) = v47;
    uint64_t v48 = v54 + 8;
    uint64_t v57 = (char *)*((void *)this + 24);
    int v56 = (char *)*((void *)this + 25);
    if (v56 != v57)
    {
      do
      {
        uint64_t v58 = *((void *)v56 - 1);
        v56 -= 8;
        *((void *)v54 - 1) = v58;
        v54 -= 8;
      }
      while (v56 != v57);
      int v56 = *v14;
    }
    *((void *)this + 24) = v54;
    *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v48;
    *((void *)this + 26) = v55;
    if (v56) {
      operator delete(v56);
    }
  }
  else
  {
    *(_DWORD *)long long v33 = v46;
    *((float *)v33 + 1) = v47;
    uint64_t v48 = v33 + 8;
  }
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v48;
  *((_DWORD *)this + 45) = 3;
  uint64_t v59 = (unsigned char *)*((void *)this + 24);
  *((unsigned char *)this + 184) = *v59;
  if (v59 == v48)
  {
    BOOL v61 = 1;
  }
  else
  {
    char v60 = v59 + 8;
    do
    {
      BOOL v61 = (*((void *)v60 - 1) & 1) == 0;
      if (*((void *)v60 - 1)) {
        break;
      }
      BOOL v62 = v60 == v48;
      v60 += 8;
    }
    while (!v62);
  }
  if (v64)
  {
    float v65 = v64;
    operator delete(v64);
  }
  if (v76)
  {
    int v77 = (unint64_t (*)(float, uint64_t, uint64_t, int))v76;
    operator delete(v76);
  }
  if (v69)
  {
    int v70 = v69;
    operator delete(v69);
  }
  if (v72)
  {
    uint64_t v73 = v72;
    operator delete(v72);
  }
  unsigned __int8 v76 = v75;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v76);
  return v61;
}

void sub_257D55F90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, char *a18, char *a19, uint64_t a20,char a21)
{
  if (__p) {
    operator delete(__p);
  }
  int64x2_t v23 = *(void **)(v21 - 104);
  if (v23)
  {
    *(void *)(v21 - 96) = v23;
    operator delete(v23);
  }
  if (a15) {
    operator delete(a15);
  }
  if (a18)
  {
    a19 = a18;
    operator delete(a18);
  }
  a18 = &a21;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a18);
  _Unwind_Resume(a1);
}

void *std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::operator=<std::pair<BOOL,float> (Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::*)(std::vector<float> const&,int,float),void>(void *a1, uint64_t *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v7 = 0;
  if (v4 & 1 | v3)
  {
    v6[0] = &unk_2706971D0;
    v6[1] = v3;
    v6[2] = v4;
    uint64_t v7 = v6;
  }
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::swap[abi:ne180100](v6, a1);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](v6);
  return a1;
}

uint64_t Nightingale::lstmLuna::preCondition(uint64_t a1, float a2, float a3)
{
  uint64_t v4 = *(void *)(a1 + 104);
  uint64_t v3 = *(void *)(a1 + 112);
  if (v4 == v3 || (unint64_t v5 = *(unsigned __int8 *)(a1 + 176), v5 >= (v3 - v4) >> 3))
  {
    uint64_t v15 = 0;
    *(unsigned char *)(a1 + 184) = 1;
  }
  else
  {
    uint64_t v7 = *(float **)(a1 + 152);
    uint64_t v8 = *(float **)(a1 + 160);
    uint64_t v6 = a1 + 152;
    if (v7 != v8)
    {
      uint64_t v9 = v4 + 8 * v5;
      if (*(unsigned char *)(v9 + 4)) {
        float v10 = *(float *)v9;
      }
      else {
        float v10 = -1.0;
      }
      unint64_t v11 = v8 - v7;
      if (v11 <= 1) {
        unint64_t v11 = 1;
      }
      unint64_t v12 = v7;
      unint64_t v13 = v11;
      do
      {
        float v14 = *v12;
        if (fabsf(*v12 + 1.0) < 1.0e-12)
        {
          *unint64_t v12 = v10;
          float v14 = v10;
        }
        ++v12;
        float v10 = v14;
        --v13;
      }
      while (v13);
      if (a3 != 0.0)
      {
        do
        {
          float *v7 = (float)(*v7 - a2) / a3;
          ++v7;
          --v11;
        }
        while (v11);
      }
    }
    Nightingale::vDemean<float>(v6);
    return 1;
  }
  return v15;
}

uint64_t Nightingale::lstmLuna::reset(uint64_t this)
{
  *(void *)(this + 200) = *(void *)(this + 192);
  *(void *)(this + 272) = *(void *)(this + 264);
  *(unsigned char *)(this + 184) = 0;
  return this;
}

void *Nightingale::lstmLunaFw::lstmLunaFw(uint64_t a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4)
{
  __n128 result = (void *)Nightingale::lstmLuna::lstmLuna(a1, a2, a3, a4);
  *__n128 result = &unk_2706974D8;
  return result;
}

{
  void *result;

  __n128 result = (void *)Nightingale::lstmLuna::lstmLuna(a1, a2, a3, a4);
  *__n128 result = &unk_2706974D8;
  return result;
}

uint64_t Nightingale::lstmLunaFw::getOngoingFwLstmLuna(Nightingale::lstmLunaFw *this, uint64_t a2)
{
  if (Nightingale::lstmLuna::acquireWTmp(this, a2 - 44, a2)
    && (**(unsigned int (***)(Nightingale::lstmLunaFw *, uint64_t, float))this)(this, a2, 0.3)
    && (*(unsigned int (**)(Nightingale::lstmLunaFw *, float, float))(*(void *)this + 8))(this, 36.048, 0.46548)&& (Nightingale::lstmLunaFw::applyLunaAlgs(this), Nightingale::lstmLunaFw::validateLunaRslt(this, a2)))
  {
    if (!*((unsigned char *)this + 260)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    int v4 = (*((_DWORD *)this + 64) + a2) & 0xFFFFFF00;
    unsigned int v5 = (*((unsigned char *)this + 256) + a2);
    uint64_t v6 = 0x100000000;
  }
  else
  {
    uint64_t v6 = 0;
    unsigned int v5 = 0;
    int v4 = 0;
  }
  return v6 | v4 | v5;
}

void Nightingale::lstmLunaFw::applyLunaAlgs(Nightingale::lstmLunaFw *this)
{
  float v10 = 0;
  unint64_t v11 = 0;
  uint64_t v12 = 0;
  std::vector<double>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(&v10, *((float **)this + 19), *((float **)this + 20), (uint64_t)(*((void *)this + 20) - *((void *)this + 19)) >> 2);
  __n128 __p = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if ((Nightingale::ngt_luna_fw_dl_tmp_process::ngt_luna_fwEndFlagDLTmp((uint64_t *)this + 47, (uint64_t *)&v10, (uint64_t)&__p) & 1) == 0)
  {
    Nightingale::lstmModelCommonFw::fwDLPostProcess((float **)&__p, 1, -17, (uint64_t)v4);
    uint64_t v2 = (void *)*((void *)this + 29);
    *((void *)this + 27) = v4[0];
    *(void *)((char *)this + 221) = *(void *)((char *)v4 + 5);
    if (v2)
    {
      *((void *)this + 30) = v2;
      operator delete(v2);
      *((void *)this + 29) = 0;
      *((void *)this + 30) = 0;
      *((void *)this + 31) = 0;
    }
    *(_OWORD *)((char *)this + 232) = v5;
    *((void *)this + 31) = v6;
    if (*((unsigned char *)this + 220))
    {
      uint64_t v3 = Nightingale::lstmLunaFw::adjustLSTMFwEnd((uint64_t)v2, (uint64_t)this + 128, *((_DWORD *)this + 54));
      *((_DWORD *)this + 64) = v3;
      *((unsigned char *)this + 260) = BYTE4(v3);
    }
  }
  if (__p)
  {
    uint64_t v8 = __p;
    operator delete(__p);
  }
  if (v10)
  {
    unint64_t v11 = v10;
    operator delete(v10);
  }
}

void sub_257D56450(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p) {
    operator delete(__p);
  }
  int64_t v18 = *(void **)(v16 - 40);
  if (v18)
  {
    *(void *)(v16 - 32) = v18;
    operator delete(v18);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::lstmLunaFw::validateLunaRslt(Nightingale::lstmLunaFw *this, int a2)
{
  if (!*((unsigned char *)this + 220)) {
    return 0;
  }
  uint64_t v4 = *((int *)this + 54);
  int v5 = (int)v4 >= -2 ? -2 : *((_DWORD *)this + 54);
  int v6 = v5 <= -15 ? -15 : v5;
  BOOL v7 = v4 == v6;
  uint64_t v8 = (char **)((char *)this + 264);
  float v9 = (float)(int)v4;
  float v10 = (void *)((char *)this + 280);
  unint64_t v12 = *((void *)this + 34);
  unint64_t v11 = *((void *)this + 35);
  if (v12 >= v11)
  {
    uint64_t v14 = (uint64_t)(v12 - (void)*v8) >> 3;
    unint64_t v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = v11 - (void)*v8;
    if (v16 >> 2 > v15) {
      unint64_t v15 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17) {
      int64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)this + 280, v17);
    }
    else {
      int64_t v18 = 0;
    }
    uint64_t v19 = (float *)&v18[8 * v14];
    uint64_t v20 = &v18[8 * v17];
    *(_DWORD *)uint64_t v19 = v7;
    v19[1] = v9;
    unint64_t v13 = (char *)(v19 + 2);
    unint64_t v22 = (char *)*((void *)this + 33);
    uint64_t v21 = (char *)*((void *)this + 34);
    if (v21 != v22)
    {
      do
      {
        uint64_t v23 = *((void *)v21 - 1);
        v21 -= 8;
        *((void *)v19 - 1) = v23;
        v19 -= 2;
      }
      while (v21 != v22);
      uint64_t v21 = *v8;
    }
    *((void *)this + 33) = v19;
    *((void *)this + 34) = v13;
    *((void *)this + 35) = v20;
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *(_DWORD *)unint64_t v12 = v7;
    *(float *)(v12 + 4) = v9;
    unint64_t v13 = (char *)(v12 + 8);
  }
  *((void *)this + 34) = v13;
  if (v4 != v6) {
    return 0;
  }
  uint64_t v24 = *((void *)this + 17);
  if (1 - ((v24 - *((void *)this + 16)) >> 2) > (unint64_t)(v4 - 7)) {
    return 0;
  }
  long long v114 = 0;
  long long v115 = 0;
  uint64_t v116 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v114, (const void *)(v24 + 4 * (v4 - 7)), v24, (-4 * (v4 - 7)) >> 2);
  __n128 __p = 0;
  long long v112 = 0;
  uint64_t v113 = 0;
  int64x2_t v27 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v114, (uint64_t)v115, (v115 - (unsigned char *)v114) >> 2);
  uint64_t v28 = Nightingale::lstmLunaFw::signalShiftHighCheck(0.15, 1.0, (uint64_t)v27, 7, (uint64_t)&__p);
  if (__p)
  {
    long long v112 = __p;
    operator delete(__p);
  }
  uint64_t v30 = (uint64_t *)*((void *)this + 34);
  unint64_t v29 = *((void *)this + 35);
  if ((unint64_t)v30 >= v29)
  {
    uint64_t v32 = ((char *)v30 - *v8) >> 3;
    if ((unint64_t)(v32 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v33 = v29 - (void)*v8;
    uint64_t v34 = v33 >> 2;
    if (v33 >> 2 <= (unint64_t)(v32 + 1)) {
      uint64_t v34 = v32 + 1;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v35 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v34;
    }
    if (v35) {
      uint64_t v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)v10, v35);
    }
    else {
      uint64_t v36 = 0;
    }
    unint64_t v37 = (uint64_t *)&v36[8 * v32];
    float v38 = &v36[8 * v35];
    *unint64_t v37 = v28;
    unint64_t v31 = v37 + 1;
    uint64_t v40 = (char *)*((void *)this + 33);
    int v39 = (char *)*((void *)this + 34);
    if (v39 != v40)
    {
      do
      {
        uint64_t v41 = *((void *)v39 - 1);
        v39 -= 8;
        *--unint64_t v37 = v41;
      }
      while (v39 != v40);
      int v39 = *v8;
    }
    *((void *)this + 33) = v37;
    *((void *)this + 34) = v31;
    *((void *)this + 35) = v38;
    if (v39) {
      operator delete(v39);
    }
  }
  else
  {
    *uint64_t v30 = v28;
    unint64_t v31 = v30 + 1;
  }
  *((void *)this + 34) = v31;
  if (*((unsigned char *)this + 260))
  {
    uint64_t v42 = (Nightingale *)(*((_DWORD *)this + 64)
                                      + a2
                                      - *(_DWORD *)(*(void *)(*((void *)this + 2) + 8) - 96));
    unint64_t v43 = Nightingale::follicularPhaseCheck(v42, 6, 100);
    unint64_t v44 = v43;
    BOOL v46 = (unint64_t *)*((void *)this + 34);
    unint64_t v45 = *((void *)this + 35);
    if ((unint64_t)v46 >= v45)
    {
      uint64_t v48 = ((char *)v46 - *v8) >> 3;
      if ((unint64_t)(v48 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v49 = v45 - (void)*v8;
      uint64_t v50 = v49 >> 2;
      if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
        uint64_t v50 = v48 + 1;
      }
      if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v51 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v51 = v50;
      }
      if (v51) {
        unint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)v10, v51);
      }
      else {
        unint64_t v52 = 0;
      }
      unint64_t v53 = (unint64_t *)&v52[8 * v48];
      uint64_t v54 = &v52[8 * v51];
      *unint64_t v53 = v44;
      float v47 = v53 + 1;
      int v56 = (char *)*((void *)this + 33);
      unint64_t v55 = (char *)*((void *)this + 34);
      if (v55 != v56)
      {
        do
        {
          unint64_t v57 = *((void *)v55 - 1);
          v55 -= 8;
          *--unint64_t v53 = v57;
        }
        while (v55 != v56);
        unint64_t v55 = *v8;
      }
      *((void *)this + 33) = v53;
      *((void *)this + 34) = v47;
      *((void *)this + 35) = v54;
      if (v55) {
        operator delete(v55);
      }
    }
    else
    {
      *BOOL v46 = v43;
      float v47 = v46 + 1;
    }
    *((void *)this + 34) = v47;
    uint64_t v58 = *(void *)(*((void *)this + 2) + 8);
    if (!*(unsigned char *)(v58 - 60)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    unint64_t v59 = Nightingale::lutealPhaseCheck(v42, *(float *)(v58 - 64), 1.0);
    unint64_t v60 = v59;
    BOOL v62 = (unint64_t *)*((void *)this + 34);
    unint64_t v61 = *((void *)this + 35);
    if ((unint64_t)v62 >= v61)
    {
      uint64_t v64 = ((char *)v62 - *v8) >> 3;
      if ((unint64_t)(v64 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v65 = v61 - (void)*v8;
      uint64_t v66 = v65 >> 2;
      if (v65 >> 2 <= (unint64_t)(v64 + 1)) {
        uint64_t v66 = v64 + 1;
      }
      if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v67 = v66;
      }
      if (v67) {
        uint64_t v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)v10, v67);
      }
      else {
        uint64_t v68 = 0;
      }
      __int16 v69 = (unint64_t *)&v68[8 * v64];
      int v70 = &v68[8 * v67];
      *__int16 v69 = v60;
      int v63 = v69 + 1;
      int v72 = (char *)*((void *)this + 33);
      double v71 = (char *)*((void *)this + 34);
      if (v71 != v72)
      {
        do
        {
          unint64_t v73 = *((void *)v71 - 1);
          v71 -= 8;
          *--__int16 v69 = v73;
        }
        while (v71 != v72);
        double v71 = *v8;
      }
      *((void *)this + 33) = v69;
      *((void *)this + 34) = v63;
      *((void *)this + 35) = v70;
      if (v71) {
        operator delete(v71);
      }
    }
    else
    {
      unint64_t *v62 = v59;
      int v63 = v62 + 1;
    }
    *((void *)this + 34) = v63;
    uint64_t v74 = *(void *)(*((void *)this + 2) + 8);
    if (!*(unsigned char *)(v74 - 60) || !*(unsigned char *)(v74 - 52)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    float v75 = sqrtf(*(float *)(v74 - 56));
    float v76 = *(float *)(v74 - 64) + -13.0;
    LODWORD(v74) = (float)((float)(v76 + fminf(fmaxf(v75 * 9.0, 5.0), 15.0)) + 0.001) > (float)(int)v42;
    if ((float)((float)(v76 - fminf(fmaxf(v75 * 4.0, 5.0), 15.0)) + -0.001) < (float)(int)v42) {
      uint64_t v74 = v74;
    }
    else {
      uint64_t v74 = 0;
    }
    unint64_t v77 = v74 | ((unint64_t)LODWORD(v76) << 32);
    if ((unint64_t)v63 >= *v10)
    {
      uint64_t v79 = ((char *)v63 - *v8) >> 3;
      if ((unint64_t)(v79 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v80 = *v10 - (void)*v8;
      uint64_t v81 = v80 >> 2;
      if (v80 >> 2 <= (unint64_t)(v79 + 1)) {
        uint64_t v81 = v79 + 1;
      }
      if ((unint64_t)v80 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v82 = v81;
      }
      if (v82) {
        int v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)v10, v82);
      }
      else {
        int v83 = 0;
      }
      int v84 = (unint64_t *)&v83[8 * v79];
      __int16 v85 = &v83[8 * v82];
      *int v84 = v77;
      uint64_t v78 = v84 + 1;
      uint64_t v87 = (char *)*((void *)this + 33);
      int v86 = (char *)*((void *)this + 34);
      if (v86 != v87)
      {
        do
        {
          unint64_t v88 = *((void *)v86 - 1);
          v86 -= 8;
          *--int v84 = v88;
        }
        while (v86 != v87);
        int v86 = *v8;
      }
      *((void *)this + 33) = v84;
      *((void *)this + 34) = v78;
      *((void *)this + 35) = v85;
      if (v86) {
        operator delete(v86);
      }
    }
    else
    {
      unint64_t *v63 = v77;
      uint64_t v78 = v63 + 1;
    }
    *((void *)this + 34) = v78;
    if (!*((unsigned char *)this + 260)) {
      std::__throw_bad_optional_access[abi:ne180100]();
    }
    int v89 = *((_DWORD *)this + 64);
    long long v109 = 0;
    uint64_t v110 = 0;
    long long v108 = 0;
    __int16 v90 = std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v108, *((const void **)this + 16), *((void *)this + 17), (uint64_t)(*((void *)this + 17) - *((void *)this + 16)) >> 2);
    unint64_t v91 = Nightingale::lstmLunaFw::missingRateAtDetectionCheck(0.3, (uint64_t)v90, v89, &v108);
    unint64_t v92 = v91;
    int v94 = (unint64_t *)*((void *)this + 34);
    unint64_t v93 = *((void *)this + 35);
    if ((unint64_t)v94 >= v93)
    {
      uint64_t v96 = ((char *)v94 - *v8) >> 3;
      if ((unint64_t)(v96 + 1) >> 61) {
        std::vector<float>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v97 = v93 - (void)*v8;
      uint64_t v98 = v97 >> 2;
      if (v97 >> 2 <= (unint64_t)(v96 + 1)) {
        uint64_t v98 = v96 + 1;
      }
      if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v99 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v99 = v98;
      }
      if (v99) {
        int v100 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)v10, v99);
      }
      else {
        int v100 = 0;
      }
      __int16 v101 = (unint64_t *)&v100[8 * v96];
      __int16 v102 = &v100[8 * v99];
      *__int16 v101 = v92;
      __int16 v95 = v101 + 1;
      int v104 = (char *)*((void *)this + 33);
      int v103 = (char *)*((void *)this + 34);
      if (v103 != v104)
      {
        do
        {
          unint64_t v105 = *((void *)v103 - 1);
          v103 -= 8;
          *--__int16 v101 = v105;
        }
        while (v103 != v104);
        int v103 = *v8;
      }
      *((void *)this + 33) = v101;
      *((void *)this + 34) = v95;
      *((void *)this + 35) = v102;
      if (v103) {
        operator delete(v103);
      }
    }
    else
    {
      unint64_t *v94 = v91;
      __int16 v95 = v94 + 1;
    }
    *((void *)this + 34) = v95;
    if (v108)
    {
      long long v109 = v108;
      operator delete(v108);
      __int16 v95 = (void *)*((void *)this + 34);
    }
    if (*v8 == (char *)v95)
    {
      BOOL v25 = 1;
    }
    else
    {
      uint64_t v106 = (uint64_t)(*v8 + 8);
      do
      {
        BOOL v25 = *(unsigned char *)(v106 - 8) != 0;
        if (*(unsigned char *)(v106 - 8)) {
          BOOL v107 = v106 == (void)v95;
        }
        else {
          BOOL v107 = 1;
        }
        v106 += 8;
      }
      while (!v107);
    }
  }
  else
  {
    BOOL v25 = 0;
  }
  if (v114)
  {
    long long v115 = v114;
    operator delete(v114);
  }
  return v25;
}

void sub_257D56B68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p) {
    operator delete(__p);
  }
  if (a16) {
    operator delete(a16);
  }
  _Unwind_Resume(exception_object);
}

BOOL Nightingale::lstmLunaFw::getOngoingFwLstmLunaAvailibilityFail(Nightingale::lstmLunaFw *this, uint64_t a2, float a3)
{
  if (*((void *)this + 24) == *((void *)this + 25))
  {
    if (Nightingale::lstmLuna::acquireWTmp(this, a2 - 44, a2)) {
      (**(void (***)(Nightingale::lstmLunaFw *, uint64_t, float))this)(this, a2, a3);
    }
    int v4 = *((unsigned __int8 *)this + 184);
    *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = *((void *)this + 24);
    *((void *)this + 34) = *((void *)this + 33);
    *((unsigned char *)this + 184) = 0;
  }
  else
  {
    int v4 = *((unsigned __int8 *)this + 184);
  }
  return v4 != 0;
}

uint64_t Nightingale::lstmLunaFw::adjustLSTMFwEnd(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 <= 0)
  {
    uint64_t v7 = 0;
    uint64_t v8 = -4 * a3;
    uint64_t v9 = 4 * a3;
    float v10 = 0.0;
    unsigned int v4 = a3;
    while (1)
    {
      uint64_t v12 = v9 + *(void *)(a2 + 8);
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      unint64_t v22 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v22, (const void *)(v12 - 28), v12, 7uLL);
      uint64_t v13 = *(void *)(a2 + 8);
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      __n128 __p = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, (const void *)(v9 + v13), v13, v8 >> 2);
      uint64_t MeanDiffOf2Windows = Nightingale::getMeanDiffOf2Windows((uint64_t)&v22, (float **)&__p, -1.0);
      float v15 = *(float *)&MeanDiffOf2Windows;
      BOOL v16 = (MeanDiffOf2Windows & 0xFF00000000) == 0;
      if (*(float *)&MeanDiffOf2Windows < 0.2) {
        BOOL v16 = 1;
      }
      char v17 = (float)(*(float *)&MeanDiffOf2Windows - v10) < 0.04 || v16;
      if (__p)
      {
        uint64_t v20 = __p;
        operator delete(__p);
      }
      if (v22)
      {
        uint64_t v23 = v22;
        operator delete(v22);
      }
      if (v17) {
        break;
      }
      if (v7 == -2)
      {
        unsigned int v4 = a3 - 2;
        break;
      }
      unsigned int v4 = a3 + v7;
      v8 += 4;
      v9 -= 4;
      --v7;
      float v10 = v15;
    }
    uint64_t v3 = 0x100000000;
  }
  else
  {
    uint64_t v3 = 0;
    unsigned int v4 = 0;
  }
  return v3 | v4;
}

void sub_257D56DC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Nightingale::lstmLunaFw::signalShiftHighCheck(float a1, float a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v9 = *(const void **)a5;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v19, v9, (uint64_t)v9 + 4 * a4, a4);
  uint64_t v10 = *(void *)(a5 + 8);
  unint64_t v11 = (const void *)(*(void *)a5 + 4 * a4);
  char v17 = 0;
  uint64_t v18 = 0;
  __n128 __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v11, v10, (v10 - (uint64_t)v11) >> 2);
  uint64_t MeanDiffOf2Windows = Nightingale::getMeanDiffOf2Windows((uint64_t)&v19, (float **)&__p, -1.0);
  if (__p)
  {
    char v17 = __p;
    operator delete(__p);
  }
  if (v19)
  {
    uint64_t v20 = v19;
    operator delete(v19);
  }
  LODWORD(v13) = BYTE4(MeanDiffOf2Windows) != 0;
  uint64_t v14 = MeanDiffOf2Windows << 32;
  if (!BYTE4(MeanDiffOf2Windows)) {
    uint64_t v14 = 0x41F0000000000000;
  }
  if (*(float *)&MeanDiffOf2Windows < a1) {
    LODWORD(v13) = 0;
  }
  if (*(float *)&MeanDiffOf2Windows <= a2) {
    uint64_t v13 = v13;
  }
  else {
    uint64_t v13 = 0;
  }
  return v14 | v13;
}

void sub_257D56ED4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t Nightingale::lstmLunaFw::closeToCalOvuCheck(Nightingale::lstmLunaFw *this, int a2, float a3, float a4)
{
  float v4 = a3 + -13.0;
  LODWORD(v5) = (float)((float)(v4 + fminf(fmaxf(a4 * 9.0, 5.0), 15.0)) + 0.001) > (float)a2;
  if ((float)((float)(v4 - fminf(fmaxf(a4 * 4.0, 5.0), 15.0)) + -0.001) < (float)a2) {
    uint64_t v5 = v5;
  }
  else {
    uint64_t v5 = 0;
  }
  return v5 | ((unint64_t)LODWORD(v4) << 32);
}

unint64_t Nightingale::lstmLunaFw::missingRateAtDetectionCheck(float a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v7 = a4[1];
  if (a3 >= 1 && *a4 == v7) {
    return 0xBF80000000000000;
  }
  __n128 __p = 0;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, (const void *)(v7 + 4 * a3), v7, (-4 * a3) >> 2);
  int MissingCnt = Nightingale::getMissingCnt((float **)&__p);
  if (a3)
  {
    float v10 = (float)MissingCnt;
    BOOL v11 = (float)((float)MissingCnt / (float)-a3) <= a1;
  }
  else
  {
    BOOL v11 = MissingCnt == 0;
    float v10 = (float)MissingCnt;
  }
  if (__p)
  {
    uint64_t v13 = __p;
    operator delete(__p);
  }
  return v11 | ((unint64_t)LODWORD(v10) << 32);
}

void sub_257D5704C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float Nightingale::lstmLunaFw::getSignalShift(Nightingale::lstmLunaFw *this)
{
  uint64_t v1 = *((void *)this + 33);
  unint64_t v2 = *((void *)this + 34) - v1;
  float result = -1.0;
  if (v2) {
    BOOL v4 = v2 >= 9;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    return *(float *)(v1 + 12);
  }
  return result;
}

uint64_t Nightingale::lstmLunaFw::getFwConfirmationFailureReason(Nightingale::lstmLunaFw *this)
{
  unint64_t v2 = (unsigned char *)*((void *)this + 24);
  uint64_t v1 = (unsigned char *)*((void *)this + 25);
  if (v2 != v1)
  {
    unint64_t v3 = v1 - v2;
    unint64_t v4 = (unint64_t)(v1 - v2) >> 3;
    if ((int)v4 >= 1 && !*v2)
    {
      uint64_t v7 = *((void *)this + 33);
      uint64_t v6 = *((void *)this + 34);
      if (v7 != v6 && (int)((unint64_t)(v6 - v7) >> 3) >= 2)
      {
        if ((unint64_t)(v6 - v7) <= 8) {
          goto LABEL_21;
        }
        if (!*(unsigned char *)(v7 + 8)) {
          return 3;
        }
      }
      if (v4 >= 2)
      {
        if (v3 <= 8) {
          std::vector<int>::__throw_out_of_range[abi:ne180100]();
        }
        if (v2[8]) {
          return 2;
        }
      }
      if (v7 == v6 || (int)((unint64_t)(v6 - v7) >> 3) < 6) {
        return 8;
      }
      if ((unint64_t)(v6 - v7) > 0x28)
      {
        if (!*(unsigned char *)(v7 + 40)) {
          return 5;
        }
        return 8;
      }
LABEL_21:
      std::vector<int>::__throw_out_of_range[abi:ne180100]();
    }
  }
  return 1;
}

unsigned char *Nightingale::lstmLunaPeriod::lstmLunaPeriod(unsigned char *a1, uint64_t a2, uint64_t a3, const Nightingale::ngt_Config *a4, uint64_t a5)
{
  uint64_t v8 = Nightingale::lstmLuna::lstmLuna((uint64_t)a1, a2, a3, a4);
  *(void *)uint64_t v8 = &unk_2706974F8;
  *(void *)(v8 + 388) = a5;
  *(_OWORD *)(v8 + 400) = 0u;
  *(_OWORD *)(v8 + 416) = 0u;
  *(_OWORD *)(v8 + 432) = 0u;
  *(_OWORD *)(v8 + 448) = 0u;
  *(void *)(v8 + 464) = 0;
  Nightingale::CGradient::CGradient(v8 + 472);
  a1[528] = 0;
  a1[532] = 0;
  a1[536] = 0;
  a1[540] = 0;
  a1[544] = 0;
  a1[548] = 0;
  a1[552] = 0;
  a1[556] = 0;
  Nightingale::ngt_luna_period_dl_tmp_process::ngt_luna_period_dl_tmp_process((Nightingale::ngt_luna_period_dl_tmp_process *)(a1 + 560), a4);
  Nightingale::lstmModelCommonPeriod::lstmModelCommonPeriod((Nightingale::lstmModelCommonPeriod *)(a1 + 568));
  return a1;
}

void sub_257D57214(_Unwind_Exception *a1)
{
  Nightingale::ngt_luna_period_dl_tmp_process::~ngt_luna_period_dl_tmp_process(v3);
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 480) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(v1 + 448);
  if (v6)
  {
    *(void *)(v1 + 456) = v6;
    operator delete(v6);
  }
  uint64_t v7 = (void **)(v1 + 400);
  uint64_t v8 = *(void **)(v1 + 424);
  if (v8)
  {
    *(void *)(v1 + 432) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *v7;
  if (*v7)
  {
    *(void *)(v1 + 408) = v9;
    operator delete(v9);
  }
  Nightingale::lstmLuna::~lstmLuna((id **)v1);
  _Unwind_Resume(a1);
}

void Nightingale::lstmLunaPeriod::~lstmLunaPeriod(id **this)
{
  *this = (id *)&unk_2706974F8;
  Nightingale::lstmModelCommonPeriod::~lstmModelCommonPeriod((Nightingale::lstmModelCommonPeriod *)(this + 71));
  Nightingale::ngt_luna_period_dl_tmp_process::~ngt_luna_period_dl_tmp_process(this + 70);
  unint64_t v2 = this[59];
  if (v2)
  {
    this[60] = v2;
    operator delete(v2);
  }
  unint64_t v3 = this[56];
  if (v3)
  {
    this[57] = v3;
    operator delete(v3);
  }
  unint64_t v4 = this[53];
  if (v4)
  {
    this[54] = v4;
    operator delete(v4);
  }
  uint64_t v5 = this[50];
  if (v5)
  {
    this[51] = v5;
    operator delete(v5);
  }
  Nightingale::lstmLuna::~lstmLuna(this);
}

__n128 Nightingale::lstmLunaPeriod::estimatePeriodStartLuna@<Q0>(Nightingale::lstmLunaPeriod *this@<X0>, uint64_t a2@<X8>)
{
  Nightingale::CGradient::CGradient(a2);
  *(unsigned char *)(a2 + 56) = 0;
  *(unsigned char *)(a2 + 60) = 0;
  *(unsigned char *)(a2 + 64) = 0;
  *(unsigned char *)(a2 + 68) = 0;
  *(unsigned char *)(a2 + 72) = 0;
  *(unsigned char *)(a2 + 76) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  *(unsigned char *)(a2 + 84) = 0;
  uint64_t v4 = *((unsigned int *)this + 97);
  if ((int)v4 <= *((_DWORD *)this + 98))
  {
    do
    {
      Nightingale::lstmLunaPeriod::getLunaPeriodEstimationADay(this, v4 - 44, v4);
      if (*((unsigned char *)this + 556)) {
        break;
      }
      BOOL v5 = (int)v4 < *((_DWORD *)this + 98);
      uint64_t v4 = (v4 + 1);
    }
    while (v5);
  }
  if ((Nightingale::lstmLunaPeriod *)((char *)this + 472) != (Nightingale::lstmLunaPeriod *)a2) {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>((char *)a2, *((char **)this + 59), *((void *)this + 60), (uint64_t)(*((void *)this + 60) - *((void *)this + 59)) >> 2);
  }
  *(_OWORD *)(a2 + 24) = *((_OWORD *)this + 31);
  *(_OWORD *)(a2 + 33) = *(_OWORD *)((char *)this + 505);
  *(_OWORD *)(a2 + 56) = *((_OWORD *)this + 33);
  __n128 result = *(__n128 *)((char *)this + 541);
  *(__n128 *)(a2 + 69) = result;
  return result;
}

void sub_257D57400(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Nightingale::lstmLunaPeriod::getLunaPeriodEstimationADay(Nightingale::lstmLunaPeriod *this, int a2, uint64_t a3)
{
  if (Nightingale::lstmLuna::acquireWTmp(this, a2, a3)
    && ((**(uint64_t (***)(Nightingale::lstmLunaPeriod *, uint64_t, float))this)(this, a3, 0.3) & 1) != 0)
  {
    if ((*(unsigned int (**)(Nightingale::lstmLunaPeriod *, float, float))(*(void *)this + 8))(this, 36.054, 0.46308))
    {
      if (!*((unsigned char *)this + 40)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      if (Nightingale::lstmLunaPeriod::prepareUiVectors(this, a2, a3, *((_DWORD *)this + 8)))
      {
        Nightingale::lstmLunaPeriod::applyAlgs(this, a3);
      }
    }
  }
  else
  {
    *((_DWORD *)this + 138) = a3;
    *((unsigned char *)this + 556) = 1;
  }
}

BOOL Nightingale::lstmLunaPeriod::prepareUiVectors(Nightingale::lstmLunaPeriod *this, int a2, int a3, int a4)
{
  int v23 = a2;
  char v24 = 1;
  int v25 = a3;
  char v26 = 1;
  int v27 = a4;
  char v28 = 1;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v7 = *((void *)this + 3);
  long long v20 = xmmword_257D5FBD0;
  uint64_t v21 = 0x3FB09540401F4DA4;
  Nightingale::uiProcessForLstm::uiProcessForLstm((uint64_t)v22, v5, v6, v7, (__n128 *)&v20);
  Nightingale::uiProcessForLstm::prepareUiLogForDL((uint64_t)v22, (uint64_t)&v23, (uint64_t)this + 400, (float **)this + 53, (float **)this + 56);
  uint64_t v8 = *((void *)this + 50);
  uint64_t v9 = *((void *)this + 51);
  if (v8 == v9 || (v10 = *((void *)this + 53), uint64_t v11 = *((void *)this + 54), v10 == v11))
  {
    BOOL v18 = 0;
  }
  else
  {
    uint64_t v12 = *((void *)this + 56);
    uint64_t v13 = *((void *)this + 57);
    unint64_t v14 = v9 - v8;
    unint64_t v15 = v11 - v10;
    BOOL v16 = (unint64_t)(v13 - v12) > 0xB3;
    if (v12 == v13) {
      BOOL v16 = 0;
    }
    BOOL v17 = v14 >= 0xB4 && v16;
    BOOL v18 = v15 >= 0xB4 && v17;
  }
  Nightingale::uiProcessForLstm::~uiProcessForLstm((Nightingale::uiProcessForLstm *)v22);
  return v18;
}

void sub_257D57608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  Nightingale::uiProcessForLstm::~uiProcessForLstm((Nightingale::uiProcessForLstm *)va);
  _Unwind_Resume(a1);
}

void Nightingale::lstmLunaPeriod::applyAlgs(Nightingale::lstmLunaPeriod *this, int a2)
{
  uint64_t v4 = (Nightingale::lstmLunaPeriod *)((char *)this + 568);
  Nightingale::lstmLunaPeriod::getPeriodProjFromLstmModel(this, (Nightingale::lstmLunaPeriod *)((char *)this + 568), a2);
  *((_DWORD *)this + 136) = a2;
  *((unsigned char *)this + 548) = 1;
  *((_DWORD *)this + 138) = a2;
  *((unsigned char *)this + 556) = 1;
  uint64_t v5 = *((void *)this + 2);
  if (*(unsigned char *)(v5 + 100))
  {
    if (*((unsigned char *)this + 532))
    {
      int v6 = *(_DWORD *)(v5 + 96) - *(_DWORD *)(*(void *)(v5 + 8) - 96);
      if (*((float *)this + 132) <= (float)v6)
      {
        Nightingale::lstmModelCommonPeriod::applyNoflowUpdateDL(v4, (Nightingale::lstmLunaPeriod *)((char *)this + 472), v6);
      }
    }
  }
}

BOOL Nightingale::lstmLunaPeriod::validateWTmp(Nightingale::lstmLunaPeriod *this, float a2)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  memset(v36, 0, sizeof(v36));
  uint64_t v4 = *((void *)this + 16);
  uint64_t v5 = *((void *)this + 17);
  unint64_t v3 = (float **)((char *)this + 128);
  int v6 = operator new(4uLL);
  _DWORD *v6 = (unint64_t)(v5 - v4) >> 2;
  uint64_t v7 = operator new(4uLL);
  uint64_t v33 = v7;
  _DWORD *v7 = 1050253722;
  uint64_t v34 = v7 + 1;
  unint64_t v35 = v7 + 1;
  __n128 __p = &unk_2706971D0;
  float v38 = Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems::checkWTmpMissingCntHigh;
  uint64_t v39 = 0;
  p_p = &__p;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::push_back[abi:ne180100](v36, (uint64_t)&__p);
  std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::~__value_func[abi:ne180100](&__p);
  unint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v30 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v30, v6, (uint64_t)(v6 + 1), 1uLL);
  uint64_t v8 = *((void *)this + 13);
  unint64_t v9 = *((unsigned __int8 *)this + 176);
  if (v9 >= (*((void *)this + 14) - v8) >> 3) {
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  }
  if (*(unsigned char *)(v8 + 8 * v9 + 4) || **v3 >= 0.0)
  {
    Nightingale::wristTemperatureInputValidation::checkListOfConditions((uint64_t)this + 369, v36, (uint64_t)v3, &v30, &v33, 1, &__p);
    uint64_t v10 = *(void *)__p;
    float v38 = __p;
    operator delete(__p);
  }
  else
  {
    uint64_t v10 = 0x3F80000000000001;
  }
  unint64_t v11 = *((void *)this + 26);
  uint64_t v12 = (uint64_t *)*((void *)this + 25);
  if ((unint64_t)v12 >= v11)
  {
    uint64_t v14 = *((void *)this + 24);
    uint64_t v15 = ((uint64_t)v12 - v14) >> 3;
    if ((unint64_t)(v15 + 1) >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v16 = v11 - v14;
    uint64_t v17 = v16 >> 2;
    if (v16 >> 2 <= (unint64_t)(v15 + 1)) {
      uint64_t v17 = v15 + 1;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v17;
    }
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::optional<float>>>((uint64_t)this + 208, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    long long v20 = (uint64_t *)&v19[8 * v15];
    uint64_t v21 = &v19[8 * v18];
    *long long v20 = v10;
    uint64_t v13 = v20 + 1;
    int v23 = (char *)*((void *)this + 24);
    unint64_t v22 = (char *)*((void *)this + 25);
    if (v22 != v23)
    {
      do
      {
        uint64_t v24 = *((void *)v22 - 1);
        v22 -= 8;
        *--long long v20 = v24;
      }
      while (v22 != v23);
      unint64_t v22 = (char *)*((void *)this + 24);
    }
    *((void *)this + 24) = v20;
    *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v13;
    *((void *)this + 26) = v21;
    if (v22) {
      operator delete(v22);
    }
  }
  else
  {
    *uint64_t v12 = v10;
    uint64_t v13 = v12 + 1;
  }
  *((void *)this + std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)this + 25) = v13;
  if (v30)
  {
    unint64_t v31 = v30;
    operator delete(v30);
    uint64_t v13 = (void *)*((void *)this + 25);
  }
  BOOL v25 = 1;
  *((_DWORD *)this + 45) = 1;
  char v26 = (unsigned char *)*((void *)this + 24);
  *((unsigned char *)this + 184) = *v26;
  if (v26 != (unsigned char *)v13)
  {
    int v27 = v26 + 8;
    do
    {
      BOOL v25 = (*((void *)v27 - 1) & 1) == 0;
      if (*((void *)v27 - 1)) {
        break;
      }
      BOOL v28 = v27 == (unsigned char *)v13;
      v27 += 8;
    }
    while (!v28);
  }
  if (v33)
  {
    uint64_t v34 = v33;
    operator delete(v33);
  }
  operator delete(v6);
  __n128 __p = v36;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  return v25;
}

void sub_257D57990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char *__p, char *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18)
{
  if (__p)
  {
    a13 = __p;
    operator delete(__p);
  }
  operator delete(v18);
  __n128 __p = &a15;
  std::vector<std::function<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void Nightingale::lstmLunaPeriod::getPeriodProjFromLstmModel(Nightingale::lstmLunaPeriod *this, Nightingale::lstmModelCommonPeriod *a2, int a3)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  unint64_t v18 = 0;
  int v5 = *(_DWORD *)(*(void *)(*((void *)this + 2) + 8) - 96);
  *(_OWORD *)__n128 __p = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  *(_OWORD *)uint64_t v15 = 0u;
  *(_OWORD *)__src = 0u;
  *(_OWORD *)uint64_t v13 = 0u;
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&__p[1], 0, *((float **)this + 19), *((float **)this + 20), (uint64_t)(*((void *)this + 20) - *((void *)this + 19)) >> 2);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)__src, 0, *((float **)this + 50), *((float **)this + 51), (uint64_t)(*((void *)this + 51) - *((void *)this + 50)) >> 2);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)&v13[1], (char *)v13[1], *((float **)this + 53), *((float **)this + 54), (uint64_t)(*((void *)this + 54) - *((void *)this + 53)) >> 2);
  std::vector<double>::__insert_with_size[abi:ne180100]<std::__wrap_iter<float const*>,std::__wrap_iter<float const*>>((uint64_t)v15, (char *)v15[0], *((float **)this + 56), *((float **)this + 57), (uint64_t)(*((void *)this + 57) - *((void *)this + 56)) >> 2);
  Nightingale::ngt_luna_period_dl_tmp_process::ngt_luna_periodRegressorLSTM((void **)this + 70, (uint64_t **)__src, (uint64_t)&v18);
  Nightingale::lstmModelCommonPeriod::periodDLPostProcess(&v18, a3 - v5, (uint64_t)&v8);
  int v6 = (void *)((char *)this + 472);
  uint64_t v7 = (void *)*((void *)this + 59);
  if (v7)
  {
    *((void *)this + 60) = v7;
    operator delete(v7);
    void *v6 = 0;
    *((void *)this + 60) = 0;
    *((void *)this + 61) = 0;
  }
  *(_OWORD *)int v6 = v8;
  *((void *)this + 61) = v9;
  *((_OWORD *)this + 31) = v10[0];
  *(_OWORD *)((char *)this + 505) = *(_OWORD *)((char *)v10 + 9);
  *((_OWORD *)this + 33) = v11[0];
  *(_OWORD *)((char *)this + 541) = *(_OWORD *)((char *)v11 + 13);
  if (__p[1])
  {
    *(void **)&long long v17 = __p[1];
    operator delete(__p[1]);
  }
  if (v15[0])
  {
    v15[1] = v15[0];
    operator delete(v15[0]);
  }
  if (v13[1])
  {
    *(void **)&long long v14 = v13[1];
    operator delete(v13[1]);
  }
  if (__src[0])
  {
    __src[1] = __src[0];
    operator delete(__src[0]);
  }
  if (v18)
  {
    uint64_t v19 = v18;
    operator delete(v18);
  }
}

void sub_257D57B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  Nightingale::ngt_luna_DLin_periodRegressorLSTM_t::~ngt_luna_DLin_periodRegressorLSTM_t((Nightingale::ngt_luna_DLin_periodRegressorLSTM_t *)va);
  uint64_t v15 = *(void **)(v13 - 72);
  if (v15)
  {
    *(void *)(v13 - 64) = v15;
    operator delete(v15);
  }
  _Unwind_Resume(a1);
}

void Nightingale::ngt_luna_DLin_periodRegressorLSTM_t::~ngt_luna_DLin_periodRegressorLSTM_t(Nightingale::ngt_luna_DLin_periodRegressorLSTM_t *this)
{
  unint64_t v2 = (void *)*((void *)this + 9);
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 6);
  if (v3)
  {
    *((void *)this + 7) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 3);
  if (v4)
  {
    *((void *)this + 4) = v4;
    operator delete(v4);
  }
  int v5 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v5;
    operator delete(v5);
  }
}

char *std::vector<double>::__assign_with_size[abi:ne180100]<std::__wrap_iter<float *>,std::__wrap_iter<float *>>(void *a1, float *a2, float *a3, unint64_t a4)
{
  int v6 = a2;
  uint64_t v8 = a1[2];
  __n128 result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 3)
  {
    unint64_t v18 = (char *)a1[1];
    uint64_t v13 = a1 + 1;
    uint64_t v12 = v18;
    unint64_t v19 = (v18 - result) >> 3;
    if (v19 >= a4)
    {
      char v26 = result;
      if (a2 != a3)
      {
        int v27 = (double *)result;
        do
        {
          float v28 = *v6++;
          *v27++ = v28;
          v26 += 8;
        }
        while (v6 != a3);
      }
      long long v17 = (char *)(v26 - result);
      uint64_t v12 = result;
    }
    else
    {
      uint64_t v20 = &a2[v19];
      if (v12 != result)
      {
        uint64_t v21 = 4 * v19;
        do
        {
          float v22 = *v6++;
          *(double *)__n128 result = v22;
          result += 8;
          v21 -= 4;
        }
        while (v21);
      }
      int v23 = v12;
      if (v20 != a3)
      {
        uint64_t v24 = (double *)v12;
        do
        {
          float v25 = *v20++;
          *v24++ = v25;
          v23 += 8;
        }
        while (v20 != a3);
      }
      long long v17 = (char *)(v23 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<std::optional<float>>::__vallocate[abi:ne180100](a1, v11);
    long long v14 = (double *)a1[1];
    uint64_t v13 = a1 + 1;
    uint64_t v12 = (char *)v14;
    uint64_t v15 = v14;
    if (v6 != a3)
    {
      uint64_t v15 = (double *)v12;
      do
      {
        float v16 = *v6++;
        *v15++ = v16;
      }
      while (v6 != a3);
    }
    long long v17 = (char *)((char *)v15 - v12);
  }
  void *v13 = &v17[(void)v12];
  return result;
}

void *std::__function::__value_func<std::pair<BOOL,float> ()(Nightingale::wristTemperatureInputValidation::wristTemperatureInputCheckItems &,std::vector<float> const&,int,float)>::swap[abi:ne180100](void *result, void *a2)
{
  void v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    unint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    int v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_257D57FEC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void Nightingale::phaseFactorProcessor::ccMenstCycleLen_handling(int a1, NSObject *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl(&dword_257C1A000, a2, OS_LOG_TYPE_DEBUG, "\t\"ccMenstCycleLen_handling\": {\"jDayLastEndOfCC\": %d}\n\n)", (uint8_t *)v2, 8u);
}

void Nightingale::ngtProjector::projector(uint64_t a1)
{
  unint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void Nightingale::ngtProjector::isFinite_aProj(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl(&dword_257C1A000, log, OS_LOG_TYPE_FAULT, "endProb contains values that are not finite.\n", v1, 2u);
}

{
  uint8_t v1[16];

  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl(&dword_257C1A000, log, OS_LOG_TYPE_FAULT, "startProb contains values that are not finite.\n", v1, 2u);
}

void Nightingale::ngtProjector::isFinite_aGrad()
{
  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0(&dword_257C1A000, v0, v1, "lowRangeEnd (%f) is not finite.\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0(&dword_257C1A000, v0, v1, "lowRangeStart (%f) is not finite.\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0(&dword_257C1A000, v0, v1, "stddev (%f) is not finite.\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0(&dword_257C1A000, v0, v1, "mean (%f) is not finite.\n", v2, v3, v4, v5, v6);
}

void Nightingale::uiLogProcessor::genPeriodSlide(void *a1)
{
  OUTLINED_FUNCTION_6(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_7(&dword_257C1A000, v1, v2, "%3.1f],\n\n", v3);
}

{
  NSObject *v1;
  uint64_t v2;
  uint8_t v3[24];

  OUTLINED_FUNCTION_6(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_7(&dword_257C1A000, v1, v2, "%3.1f],\n", v3);
}

void Nightingale::uiLogProcessor::genPeriodSlide()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"periodSlideAftOutlierRm\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"periodSlideBfrOutlierRm\": [", v2, v3, v4, v5, v6);
}

void Nightingale::uiLogProcessor::genCycleSlide()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"cycleSlideAftOutlierRm\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"cycleSlideBfrOutlierRm\": [", v2, v3, v4, v5, v6);
}

void Nightingale::uiLogProcessor::process()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "]\n },\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d]\n\t},\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\"output_isDeterminant\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\"output_jDayPerEnd\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\"output_jDayPerStart\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d], \n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\"input_flows\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"extract_periods\": {\n\t\"input_days\": [", v2, v3, v4, v5, v6);
}

void Nightingale::uiLogProcessor::print_anUILog()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"inPeriodNow\": %d},\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayEndLastCCChunk\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayStartLastCCChunk\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayNullPoint\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDay1stOPKAftLastPeriodStart\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastNoFlowAftLastPeriodStart\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDay2ndToLastPeriodStart\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastPeriodStart\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayFirstOPK\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastBleeding\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastFlow\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastNoFlow\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDayLastLog\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDay1stFlow\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_5();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "\"jDay1stLog\": %d, ", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"anUILog.specialJDays\": {", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "], \n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  uint64_t v1;
  double *v2;
  uint64_t v3;
  float *v4;
  float v5;
  uint64_t v6;
  uint8_t *v7;
  NSObject *v8;

  OUTLINED_FUNCTION_8();
  uint64_t v5 = -1.0;
  if (*(unsigned char *)(v1 + 60)) {
    uint64_t v5 = *(float *)(v1 + 56);
  }
  OUTLINED_FUNCTION_10(v5, 3.852e-34, v0, v1, v2, v3, v4);
  OUTLINED_FUNCTION_7(&dword_257C1A000, v8, v6, "\"periodSlideVar\": %f, ", v7);
}

{
  uint64_t v0;
  uint64_t v1;
  double *v2;
  uint64_t v3;
  float *v4;
  float v5;
  uint64_t v6;
  uint8_t *v7;
  NSObject *v8;

  OUTLINED_FUNCTION_8();
  uint64_t v5 = -1.0;
  if (*(unsigned char *)(v1 + 52)) {
    uint64_t v5 = *(float *)(v1 + 48);
  }
  OUTLINED_FUNCTION_10(v5, 3.852e-34, v0, v1, v2, v3, v4);
  OUTLINED_FUNCTION_7(&dword_257C1A000, v8, v6, "\"periodSlideMean\": %f, ", v7);
}

{
  uint64_t v0;
  uint64_t v1;
  double *v2;
  uint64_t v3;
  float *v4;
  float v5;
  uint64_t v6;
  uint8_t *v7;
  NSObject *v8;

  OUTLINED_FUNCTION_8();
  uint64_t v5 = -1.0;
  if (*(unsigned char *)(v1 + 44)) {
    uint64_t v5 = *(float *)(v1 + 40);
  }
  OUTLINED_FUNCTION_10(v5, 3.852e-34, v0, v1, v2, v3, v4);
  OUTLINED_FUNCTION_7(&dword_257C1A000, v8, v6, "\"cycleSlideVar\": %f, ", v7);
}

{
  uint64_t v0;
  uint64_t v1;
  double *v2;
  uint64_t v3;
  float *v4;
  float v5;
  uint64_t v6;
  uint8_t *v7;
  NSObject *v8;

  OUTLINED_FUNCTION_8();
  uint64_t v5 = -1.0;
  if (*(unsigned char *)(v1 + 36)) {
    uint64_t v5 = *(float *)(v1 + 32);
  }
  OUTLINED_FUNCTION_10(v5, 3.852e-34, v0, v1, v2, v3, v4);
  OUTLINED_FUNCTION_7(&dword_257C1A000, v8, v6, "\"cycleSlideMean\": %f, ", v7);
}

{
  uint64_t v0;
  int *v1;
  uint8_t *v2;
  NSObject *v3;
  int v4;

  OUTLINED_FUNCTION_8();
  if (*(unsigned char *)(v0 + 16)) {
    uint64_t v4 = *(_DWORD *)(v0 + 12);
  }
  else {
    uint64_t v4 = -1;
  }
  *(_DWORD *)uint64_t v2 = 67109120;
  *uint64_t v1 = v4;
  OUTLINED_FUNCTION_11(&dword_257C1A000, "\"jDayOPKPostive\": %d, ", v2, v3);
}

{
  uint64_t v0;
  int *v1;
  uint8_t *v2;
  NSObject *v3;
  int v4;

  OUTLINED_FUNCTION_8();
  if (*(unsigned char *)(v0 + 24)) {
    uint64_t v4 = *(_DWORD *)(v0 + 20);
  }
  else {
    uint64_t v4 = -1;
  }
  *(_DWORD *)uint64_t v2 = 67109120;
  *uint64_t v1 = v4;
  OUTLINED_FUNCTION_11(&dword_257C1A000, "\"jDayCycleEnd\": %d, ", v2, v3);
}

{
  uint64_t v0;
  int *v1;
  uint8_t *v2;
  NSObject *v3;
  int v4;

  OUTLINED_FUNCTION_8();
  if (*(unsigned char *)(v0 + 8)) {
    uint64_t v4 = *(_DWORD *)(v0 + 4);
  }
  else {
    uint64_t v4 = -1;
  }
  *(_DWORD *)uint64_t v2 = 67109120;
  *uint64_t v1 = v4;
  OUTLINED_FUNCTION_11(&dword_257C1A000, "\"jDayPeriodEnd\": %d, ", v2, v3);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"anUILog.vCycleInfo\": [\n", v2, v3, v4, v5, v6);
}

void Nightingale::uiLogProcessor::print_anUILog(unsigned char *a1, unsigned char *a2)
{
  OUTLINED_FUNCTION_9(a1, a2);
  OUTLINED_FUNCTION_2_0(&dword_257C1A000, v2, (uint64_t)v2, ",\n", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_9(a1, a2);
  OUTLINED_FUNCTION_2_0(&dword_257C1A000, v2, (uint64_t)v2, "]} ", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_9(a1, a2);
  OUTLINED_FUNCTION_2_0(&dword_257C1A000, v2, (uint64_t)v2, ", ", v3);
}

{
  NSObject *v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_9(a1, a2);
  OUTLINED_FUNCTION_2_0(&dword_257C1A000, v2, (uint64_t)v2, "\"phases\": [", v3);
}

void Nightingale::wristTemperatureInputAcquisition::extractWTmp_removeOutlier_withBuf(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl(&dword_257C1A000, log, OS_LOG_TYPE_FAULT, "vPreSamples not empty when vLastValidSamples are empty!", v1, 2u);
}

void Nightingale::wristTemperatureInputAcquisition::getLastValidSamplesFromRawTmp(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_fault_impl(&dword_257C1A000, log, OS_LOG_TYPE_FAULT, "size of lastValidSamplesFromRawTmp is less than that of rawTmp.vTmp!", v1, 2u);
}

void Nightingale::ngt_HistoricalAnalyzer::analyze()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, " \"dummy_key\":0 \n},\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "]},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d]},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\t\t\"FailureCode\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\t\t\"algUsed\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\t\t\t\"fwEnd\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_0();
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_0_0(&dword_257C1A000, v0, v1, "%d],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"CycleProcessHistOut\": {\"fwStart\": [", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\"Historical Analyzer debug message\": {\n", v2, v3, v4, v5, v6);
}

void std::__optional_copy_base<std::vector<float>,false>::__optional_copy_base[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  if (v2)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

void Nightingale::ngt_DayStreamProcessor::analyze()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, " \"dummy_key\": 0\n}\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "}\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\"Day Stream Processor debug message\":\n", v2, v3, v4, v5, v6);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, ",\n\n", v2, v3, v4, v5, v6);
}

{
  __int16 v0;
  int v1;
  os_log_t v2;
  uint8_t v3[20];
  __int16 v4;
  int v5;
  uint64_t v6;

  uint8_t v6 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_1_1();
  uint64_t v4 = v0;
  uint64_t v5 = v1;
  _os_log_debug_impl(&dword_257C1A000, v2, OS_LOG_TYPE_DEBUG, "\t\"URCycleLen\": %d, \"jDayURCycleLen\": %d, \"URMenstLen\": %d, \"jDayURMenstLen\": %d}", v3, 0x1Au);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"m_vJDayPhasePair\": [],\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  ],\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"m_vJDayPhasePair\": [\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"m_vDailyData\": [],\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"m_vDailyData\": [\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "{\n", v2, v3, v4, v5, v6);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(uint64_t a1, NSObject *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  double v2 = -1.0;
  if (*(unsigned char *)(a1 + 52)) {
    double v2 = *(float *)(a1 + 48);
  }
  if (*(unsigned char *)(a1 + 36)) {
    int v3 = *(_DWORD *)(a1 + 32);
  }
  else {
    int v3 = -1;
  }
  if (*(unsigned char *)(a1 + 44)) {
    int v4 = *(_DWORD *)(a1 + 40);
  }
  else {
    int v4 = -1;
  }
  int v5 = 134218496;
  double v6 = v2;
  __int16 v7 = 1024;
  int v8 = v3;
  __int16 v9 = 1024;
  int v10 = v4;
  _os_log_debug_impl(&dword_257C1A000, a2, OS_LOG_TYPE_DEBUG, "  \"mConfig\": {\"age\": %5.2f, \"jDayCurrentDay\": %d, \"jDayMostRecentMenstrualFlowUpdated\": %d, ", (uint8_t *)&v5, 0x18u);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(void *a1, uint64_t a2, os_log_t log)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(*a1 - 4);
  int v4 = *(unsigned __int16 *)(*(void *)(a2 + 32) - 8);
  v5[0] = 67109376;
  v5[1] = v3;
  __int16 v6 = 1024;
  int v7 = v4;
  _os_log_debug_impl(&dword_257C1A000, log, OS_LOG_TYPE_DEBUG, "\t{\"jDay\": %d, \"phase\": %d}", (uint8_t *)v5, 0xEu);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(os_log_t log)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  v1[0] = 67109376;
  v1[1] = -1;
  __int16 v2 = 2048;
  unint64_t v3 = 0xBFF0000000000000;
  _os_log_debug_impl(&dword_257C1A000, log, OS_LOG_TYPE_DEBUG, "\"wTmp\": {\"watchID\": %d, \"tp\": %5.2f}}},\n", (uint8_t *)v1, 0x12u);
}

void Nightingale::ngt_DayStreamProcessor::printInputDayStreamProc(unsigned __int8 a1, NSObject *a2, float a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 2048;
  double v5 = a3;
  _os_log_debug_impl(&dword_257C1A000, a2, OS_LOG_TYPE_DEBUG, "\"wTmp\": {\"watchID\": %d, \"tp\": %5.2f}}},\n", (uint8_t *)v3, 0x12u);
}

void Nightingale::ngt_DayStreamProcessor::printDeviations()
{
  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "\n\t} \n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1_1();
  OUTLINED_FUNCTION_5_0(&dword_257C1A000, v0, v1, "\"spottingOut\": {\"exist\": %d, \"jDayAnalysisWinStart\": %d, \"jDayAnalysisWinEnd\": %d},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1_1();
  OUTLINED_FUNCTION_5_0(&dword_257C1A000, v0, v1, "\"prolongOut\": {\"exist\": %d, \"jDayAnalysisWinStart\": %d, \"jDayAnalysisWinEnd\": %d},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1_1();
  OUTLINED_FUNCTION_5_0(&dword_257C1A000, v0, v1, "\"infreqOut\": {\"exist\": %d, \"jDayAnalysisWinStart\": %d, \"jDayAnalysisWinEnd\": %d},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_1_1();
  OUTLINED_FUNCTION_5_0(&dword_257C1A000, v0, v1, "\"irregOut\": {\"exist\": %d, \"jDayAnalysisWinStart\": %d, \"jDayAnalysisWinEnd\": %d},\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4();
  OUTLINED_FUNCTION_1_0(&dword_257C1A000, v0, v1, "  \"deviations\": {\n", v2, v3, v4, v5, v6);
}

uint64_t DateInterval.intersects(_:)()
{
  return MEMORY[0x270EEE2B0]();
}

uint64_t DateInterval.end.getter()
{
  return MEMORY[0x270EEE2F0]();
}

uint64_t DateInterval.init(start:end:)()
{
  return MEMORY[0x270EEE2F8]();
}

uint64_t DateInterval.start.getter()
{
  return MEMORY[0x270EEE308]();
}

uint64_t type metadata accessor for DateInterval()
{
  return MEMORY[0x270EEE338]();
}

NSDateComponents __swiftcall DateComponents._bridgeToObjectiveC()()
{
  return (NSDateComponents)MEMORY[0x270EEE738]();
}

uint64_t static DateComponents._unconditionallyBridgeFromObjectiveC(_:)()
{
  return MEMORY[0x270EEE760]();
}

uint64_t DateComponents.day.getter()
{
  return MEMORY[0x270EEE768]();
}

uint64_t DateComponents.day.setter()
{
  return MEMORY[0x270EEE780]();
}

uint64_t DateComponents.date.getter()
{
  return MEMORY[0x270EEE7B0]();
}

uint64_t DateComponents.hour.setter()
{
  return MEMORY[0x270EEE7C8]();
}

uint64_t DateComponents.year.getter()
{
  return MEMORY[0x270EEE7D8]();
}

uint64_t DateComponents.year.setter()
{
  return MEMORY[0x270EEE7F0]();
}

uint64_t DateComponents.month.getter()
{
  return MEMORY[0x270EEE800]();
}

uint64_t DateComponents.month.setter()
{
  return MEMORY[0x270EEE810]();
}

uint64_t DateComponents.minute.setter()
{
  return MEMORY[0x270EEE838]();
}

uint64_t DateComponents.init(calendar:timeZone:era:year:month:day:hour:minute:second:nanosecond:weekday:weekdayOrdinal:quarter:weekOfMonth:weekOfYear:yearForWeekOfYear:)()
{
  return MEMORY[0x270EEE890]();
}

uint64_t type metadata accessor for DateComponents()
{
  return MEMORY[0x270EEE8E8]();
}

uint64_t _convertErrorToNSError(_:)()
{
  return MEMORY[0x270EEF830]();
}

uint64_t _convertNSErrorToError(_:)()
{
  return MEMORY[0x270EEF840]();
}

uint64_t type metadata accessor for URL.DirectoryHint()
{
  return MEMORY[0x270EEFC10]();
}

void __swiftcall URL._bridgeToObjectiveC()(NSURL *__return_ptr retstr)
{
}

uint64_t URL.init(filePath:directoryHint:relativeTo:)()
{
  return MEMORY[0x270EEFF18]();
}

uint64_t type metadata accessor for URL()
{
  return MEMORY[0x270EEFF68]();
}

uint64_t Data.init<A>(buffer:)()
{
  return MEMORY[0x270EF01F8]();
}

{
  return MEMORY[0x270EF0200]();
}

uint64_t static Date.distantPast.getter()
{
  return MEMORY[0x270EF0700]();
}

NSDate __swiftcall Date._bridgeToObjectiveC()()
{
  return (NSDate)MEMORY[0x270EF0998]();
}

uint64_t static Date.< infix(_:_:)()
{
  return MEMORY[0x270EF09B8]();
}

uint64_t Date.timeIntervalSinceNow.getter()
{
  return MEMORY[0x270EF09E0]();
}

uint64_t Date.timeIntervalSince1970.getter()
{
  return MEMORY[0x270EF0AF8]();
}

uint64_t static Date._unconditionallyBridgeFromObjectiveC(_:)()
{
  return MEMORY[0x270EF0BA8]();
}

uint64_t Date.init()()
{
  return MEMORY[0x270EF0C30]();
}

uint64_t type metadata accessor for Date()
{
  return MEMORY[0x270EF0C40]();
}

uint64_t type metadata accessor for Calendar.Identifier()
{
  return MEMORY[0x270EF10C8]();
}

uint64_t Calendar.init(identifier:)()
{
  return MEMORY[0x270EF10D8]();
}

uint64_t Calendar.ordinality(of:in:for:)()
{
  return MEMORY[0x270EF10F0]();
}

uint64_t Calendar.dateComponents(_:from:)()
{
  return MEMORY[0x270EF1258]();
}

uint64_t Calendar.date(from:)()
{
  return MEMORY[0x270EF1368]();
}

uint64_t Calendar.date(byAdding:value:to:wrappingComponents:)()
{
  return MEMORY[0x270EF1388]();
}

uint64_t static Calendar.current.getter()
{
  return MEMORY[0x270EF13D8]();
}

uint64_t Calendar.timeZone.setter()
{
  return MEMORY[0x270EF1410]();
}

uint64_t type metadata accessor for Calendar.Component()
{
  return MEMORY[0x270EF1428]();
}

uint64_t type metadata accessor for Calendar()
{
  return MEMORY[0x270EF1440]();
}

uint64_t TimeZone.init(secondsFromGMT:)()
{
  return MEMORY[0x270EF15A8]();
}

uint64_t type metadata accessor for TimeZone()
{
  return MEMORY[0x270EF1608]();
}

uint64_t autoreleasepool<A>(invoking:)()
{
  return MEMORY[0x270FA1120]();
}

uint64_t PFLTaskResult.__allocating_init(json:vector:)()
{
  return MEMORY[0x270F56FD8]();
}

uint64_t type metadata accessor for PFLTaskResult()
{
  return MEMORY[0x270F56FE8]();
}

Swift::Bool __swiftcall PFLTaskRunner.isDataAvailable()()
{
  return MEMORY[0x270F56FF0]();
}

uint64_t PFLTaskRunner.performCustomTargeting(task:useCase:)()
{
  return MEMORY[0x270F57000]();
}

uint64_t ShuffleMethod.init(rawValue:)()
{
  return MEMORY[0x270F57010]();
}

uint64_t ShuffleMethod.rawValue.getter()
{
  return MEMORY[0x270F57018]();
}

uint64_t type metadata accessor for ShuffleMethod()
{
  return MEMORY[0x270F57020]();
}

uint64_t dispatch thunk of EspressoTrainer.extractOutputs(function:)()
{
  return MEMORY[0x270F57028]();
}

uint64_t dispatch thunk of EspressoTrainer.extractWeights(function:)()
{
  return MEMORY[0x270F57030]();
}

uint64_t dispatch thunk of EspressoTrainer.eval(_:featureSizes:numSamples:)()
{
  return MEMORY[0x270F57038]();
}

uint64_t dispatch thunk of EspressoTrainer.load(path:functions:inputs:outputs:weights:)()
{
  return MEMORY[0x270F57040]();
}

uint64_t dispatch thunk of EspressoTrainer.train(_:featureSizes:numSamples:epochs:shuffleMethod:fullBatch:)()
{
  return MEMORY[0x270F57048]();
}

uint64_t dispatch thunk of EspressoTrainer.unload(functions:)()
{
  return MEMORY[0x270F57050]();
}

uint64_t dispatch thunk of EspressoTrainer.finalize(batchSize:learningRate:)()
{
  return MEMORY[0x270F57058]();
}

uint64_t static EspressoFunction.evaluation.getter()
{
  return MEMORY[0x270F57060]();
}

uint64_t static EspressoFunction.training.getter()
{
  return MEMORY[0x270F57068]();
}

uint64_t type metadata accessor for EspressoFunction()
{
  return MEMORY[0x270F57070]();
}

uint64_t type metadata accessor for EspressoEIRTrainer()
{
  return MEMORY[0x270F57078]();
}

uint64_t EspressoEIRTrainer.__allocating_init(_:)()
{
  return MEMORY[0x270F57080]();
}

uint64_t type metadata accessor for EspressoMILTrainer()
{
  return MEMORY[0x270F57088]();
}

uint64_t EspressoMILTrainer.__allocating_init(_:)()
{
  return MEMORY[0x270F57090]();
}

uint64_t dispatch thunk of PerformanceMeasure.start(_:)()
{
  return MEMORY[0x270F57098]();
}

uint64_t dispatch thunk of PerformanceMeasure.finish(_:)()
{
  return MEMORY[0x270F570A0]();
}

uint64_t PerformanceMeasure.__allocating_init()()
{
  return MEMORY[0x270F570A8]();
}

uint64_t type metadata accessor for PerformanceMeasure()
{
  return MEMORY[0x270F570B0]();
}

uint64_t dispatch thunk of PFLTask.attachmentPath(name:)()
{
  return MEMORY[0x270F570B8]();
}

uint64_t dispatch thunk of PFLTask.recipe.getter()
{
  return MEMORY[0x270F570C0]();
}

uint64_t dispatch thunk of PFLTask.parameter<A>(for:default:)()
{
  return MEMORY[0x270F570D0]();
}

uint64_t type metadata accessor for PFLError()
{
  return MEMORY[0x270F570D8]();
}

uint64_t static PFLStats.meanAndStd(_:)()
{
  return MEMORY[0x270F570E0]();
}

uint64_t static PFLStats.greaterEqual<A>(vector:value:)()
{
  return MEMORY[0x270F570E8]();
}

uint64_t static PFLStats.sum(_:)()
{
  return MEMORY[0x270F570F0]();
}

uint64_t static PFLStats.less<A>(vector:value:)()
{
  return MEMORY[0x270F570F8]();
}

uint64_t static PFLStats.mean(_:)()
{
  return MEMORY[0x270F57100]();
}

uint64_t static PFLStats.cumsum(vector:)()
{
  return MEMORY[0x270F57108]();
}

uint64_t static PFLStats.l2Norm(_:)()
{
  return MEMORY[0x270F57110]();
}

uint64_t static PFLStats.greater<A>(vector:value:)()
{
  return MEMORY[0x270F57118]();
}

uint64_t static PFLStats.lessEqual<A>(vector:value:)()
{
  return MEMORY[0x270F57120]();
}

uint64_t static PFLUtils.throwIfFalse(error:for:)()
{
  return MEMORY[0x270F57128]();
}

uint64_t static PFLUtils.rethrow<A>(_:for:)()
{
  return MEMORY[0x270F57138]();
}

uint64_t Logger.logObject.getter()
{
  return MEMORY[0x270FA2E00]();
}

uint64_t Logger.init(subsystem:category:)()
{
  return MEMORY[0x270FA2E08]();
}

uint64_t type metadata accessor for Logger()
{
  return MEMORY[0x270FA2E20]();
}

uint64_t type metadata accessor for DispatchTimeInterval()
{
  return MEMORY[0x270FA0970]();
}

uint64_t static DispatchTimeoutResult.== infix(_:_:)()
{
  return MEMORY[0x270FA0988]();
}

uint64_t static DispatchQoS.unspecified.getter()
{
  return MEMORY[0x270FA09E8]();
}

uint64_t type metadata accessor for DispatchQoS()
{
  return MEMORY[0x270FA0A48]();
}

uint64_t static DispatchTime.now()()
{
  return MEMORY[0x270FA0AC0]();
}

uint64_t type metadata accessor for DispatchTime()
{
  return MEMORY[0x270FA0B00]();
}

uint64_t + infix(_:_:)()
{
  return MEMORY[0x270FA0BB0]();
}

uint64_t static HKCategoryValuePredicateProviding<>.predicateForSamples(equalTo:)()
{
  return MEMORY[0x270EF3278]();
}

uint64_t Dictionary.init()()
{
  return MEMORY[0x270F9CFB0]();
}

uint64_t Array.init()()
{
  return MEMORY[0x270F9CFC0]();
}

uint64_t specialized Array.init()()
{
  return MEMORY[0x270FA13F8]();
}

{
  return MEMORY[0x270FA1400]();
}

{
  return MEMORY[0x270FA1410]();
}

uint64_t Set.init()()
{
  return MEMORY[0x270F9CFC8]();
}

uint64_t static BinaryFloatingPoint<>.random(in:)()
{
  return MEMORY[0x270F9D028]();
}

NSDictionary __swiftcall Dictionary._bridgeToObjectiveC()()
{
  return (NSDictionary)MEMORY[0x270EF1818]();
}

uint64_t static Dictionary._unconditionallyBridgeFromObjectiveC(_:)()
{
  return MEMORY[0x270EF1840]();
}

uint64_t Dictionary.removeValue(forKey:)()
{
  return MEMORY[0x270F9D068]();
}

uint64_t Dictionary.makeIterator()()
{
  return MEMORY[0x270F9D080]();
}

uint64_t Dictionary.init(dictionaryLiteral:)()
{
  return MEMORY[0x270F9D0A8]();
}

uint64_t Dictionary.keys.getter()
{
  return MEMORY[0x270F9D0F0]();
}

uint64_t Dictionary.count.getter()
{
  return MEMORY[0x270F9D120]();
}

uint64_t Dictionary.merge(_:uniquingKeysWith:)()
{
  return MEMORY[0x270F9D130]();
}

uint64_t Dictionary.filter(_:)()
{
  return MEMORY[0x270F9D150]();
}

uint64_t Dictionary.values.getter()
{
  return MEMORY[0x270F9D160]();
}

uint64_t Dictionary.isEmpty.getter()
{
  return MEMORY[0x270F9D168]();
}

uint64_t Dictionary.merging(_:uniquingKeysWith:)()
{
  return MEMORY[0x270F9D170]();
}

uint64_t Dictionary.Iterator.next()()
{
  return MEMORY[0x270F9D178]();
}

uint64_t Dictionary.mapValues<A>(_:)()
{
  return MEMORY[0x270F9D1C0]();
}

Swift::Void __swiftcall Dictionary.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
}

uint64_t Dictionary.subscript.modify()
{
  return MEMORY[0x270F9D200]();
}

uint64_t Dictionary.subscript.getter()
{
  return MEMORY[0x270F9D208]();
}

uint64_t Dictionary.subscript.setter()
{
  return MEMORY[0x270F9D210]();
}

uint64_t dispatch thunk of FloatingPoint.rounded(_:)()
{
  return MEMORY[0x270F9D2C8]();
}

uint64_t dispatch thunk of FloatingPoint.isFinite.getter()
{
  return MEMORY[0x270F9D2D8]();
}

uint64_t dispatch thunk of static FloatingPoint.ulpOfOne.getter()
{
  return MEMORY[0x270F9D2E0]();
}

Swift::Int __swiftcall Hashable._rawHashValue(seed:)(Swift::Int seed)
{
  return MEMORY[0x270F9D330](seed);
}

uint64_t BidirectionalCollection.last.getter()
{
  return MEMORY[0x270F9D428]();
}

uint64_t specialized BidirectionalCollection.reversed()()
{
  return MEMORY[0x270FA1418]();
}

uint64_t dispatch thunk of static Comparable.> infix(_:_:)()
{
  return MEMORY[0x270F9D480]();
}

uint64_t dispatch thunk of static Comparable.< infix(_:_:)()
{
  return MEMORY[0x270F9D488]();
}

uint64_t dispatch thunk of static Comparable.>= infix(_:_:)()
{
  return MEMORY[0x270F9D490]();
}

uint64_t dispatch thunk of static Comparable.<= infix(_:_:)()
{
  return MEMORY[0x270F9D498]();
}

uint64_t type metadata accessor for ClosedRange()
{
  return MEMORY[0x270F9D550]();
}

uint64_t dispatch thunk of static Equatable.== infix(_:_:)()
{
  return MEMORY[0x270F9D598]();
}

NSString __swiftcall String._bridgeToObjectiveC()()
{
  return (NSString)MEMORY[0x270EF19B0]();
}

uint64_t static String._unconditionallyBridgeFromObjectiveC(_:)()
{
  return MEMORY[0x270EF19E8]();
}

uint64_t String.init<A>(describing:)()
{
  return MEMORY[0x270F9D5E8]();
}

uint64_t String.init(stringInterpolation:)()
{
  return MEMORY[0x270F9D6C0]();
}

Swift::String __swiftcall String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)(Builtin::RawPointer _builtinStringLiteral, Builtin::Word utf8CodeUnitCount, Builtin::Int1 isASCII)
{
  uint64_t v3 = MEMORY[0x270F9D6D8](_builtinStringLiteral, utf8CodeUnitCount, isASCII);
  result._object = v4;
  result._countAndFlagsBits = v3;
  return result;
}

uint64_t static String.== infix(_:_:)()
{
  return MEMORY[0x270F9D6E8]();
}

uint64_t static String.+= infix(_:_:)()
{
  return MEMORY[0x270F9D6F0]();
}

Swift::Int __swiftcall String.UTF8View._foreignCount()()
{
  return MEMORY[0x270F9D7E0]();
}

Swift::String __swiftcall String.init(repeating:count:)(Swift::String repeating, Swift::Int count)
{
  uint64_t v2 = MEMORY[0x270F9D898](repeating._countAndFlagsBits, repeating._object, count);
  result._object = v3;
  result._countAndFlagsBits = v2;
  return result;
}

uint64_t dispatch thunk of Sequence.makeIterator()()
{
  return MEMORY[0x270F9D8F8]();
}

uint64_t dispatch thunk of Sequence.underestimatedCount.getter()
{
  return MEMORY[0x270F9D908]();
}

uint64_t Sequence.allSatisfy(_:)()
{
  return MEMORY[0x270F9D930]();
}

uint64_t Sequence.compactMap<A>(_:)()
{
  return MEMORY[0x270F9D938]();
}

uint64_t Sequence.enumerated()()
{
  return MEMORY[0x270F9D940]();
}

uint64_t Sequence.max(by:)()
{
  return MEMORY[0x270F9D970]();
}

uint64_t Sequence.min(by:)()
{
  return MEMORY[0x270F9D978]();
}

uint64_t Sequence.first(where:)()
{
  return MEMORY[0x270F9D988]();
}

uint64_t Sequence.filter(_:)()
{
  return MEMORY[0x270F9D990]();
}

uint64_t Sequence.reduce<A>(into:_:)()
{
  return MEMORY[0x270F9D9A0]();
}

uint64_t Sequence.reduce<A>(_:_:)()
{
  return MEMORY[0x270F9D9A8]();
}

uint64_t Sequence.sorted(by:)()
{
  return MEMORY[0x270F9D9B0]();
}

uint64_t Sequence.flatMap<A>(_:)()
{
  return MEMORY[0x270F9D9C0]();
}

uint64_t Sequence.forEach(_:)()
{
  return MEMORY[0x270F9D9D0]();
}

uint64_t Sequence.reversed()()
{
  return MEMORY[0x270F9D9E0]();
}

uint64_t Sequence<>.sorted()()
{
  return MEMORY[0x270F9DA00]();
}

uint64_t Sequence<>.contains(_:)()
{
  return MEMORY[0x270F9DA18]();
}

uint64_t UnsignedInteger<>.init<A>(_:)()
{
  return MEMORY[0x270F9DA30]();
}

uint64_t RawRepresentable<>.hashValue.getter()
{
  return MEMORY[0x270F9DAE8]();
}

uint64_t RawRepresentable<>._rawHashValue(seed:)()
{
  return MEMORY[0x270F9DAF0]();
}

uint64_t RawRepresentable<>.hash(into:)()
{
  return MEMORY[0x270F9DAF8]();
}

uint64_t SignedInteger<>.init<A>(_:)()
{
  return MEMORY[0x270F9DB98]();
}

NSArray __swiftcall Array._bridgeToObjectiveC()()
{
  return (NSArray)MEMORY[0x270EF1B88]();
}

uint64_t static Array._unconditionallyBridgeFromObjectiveC(_:)()
{
  return MEMORY[0x270EF1BB8]();
}

uint64_t specialized Array.reserveCapacity(_:)()
{
  return MEMORY[0x270FA1420]();
}

uint64_t static Array.+ infix(_:_:)()
{
  return MEMORY[0x270F9DC00]();
}

uint64_t static Array._allocateUninitialized(_:)()
{
  return MEMORY[0x270F9DC10]();
}

uint64_t Array.withUnsafeBufferPointer<A>(_:)()
{
  return MEMORY[0x270F9DC18]();
}

uint64_t Array.toData()()
{
  return MEMORY[0x270F57140]();
}

uint64_t static Array._allocateBufferUninitialized(minimumCapacity:)()
{
  return MEMORY[0x270F9DC20]();
}

uint64_t Array.withUnsafeMutableBufferPointer<A>(_:)()
{
  return MEMORY[0x270F9DC40]();
}

uint64_t Array.count.getter()
{
  return MEMORY[0x270F9DC60]();
}

uint64_t specialized Array.count.getter()
{
  return MEMORY[0x270FA1438]();
}

{
  return MEMORY[0x270FA1448]();
}

uint64_t Array.append<A>(contentsOf:)()
{
  return MEMORY[0x270F9DC80]();
}

uint64_t Array.append(_:)()
{
  return MEMORY[0x270F9DC88]();
}

uint64_t specialized Array.append(_:)()
{
  return MEMORY[0x270FA1450]();
}

{
  return MEMORY[0x270FA1458]();
}

{
  return MEMORY[0x270FA1460]();
}

{
  return MEMORY[0x270FA1470]();
}

uint64_t Array.insert(_:at:)()
{
  return MEMORY[0x270F9DC90]();
}

Swift::Void __swiftcall Array.removeAll(keepingCapacity:)(Swift::Bool keepingCapacity)
{
}

uint64_t specialized Array.removeAll(keepingCapacity:)()
{
  return MEMORY[0x270FA1478]();
}

uint64_t specialized default argument 0 of Array.removeAll(keepingCapacity:)()
{
  return MEMORY[0x270FA1480]();
}

uint64_t Array.init(repeating:count:)()
{
  return MEMORY[0x270F9DCD0]();
}

uint64_t specialized Array.init(repeating:count:)()
{
  return MEMORY[0x270FA1488]();
}

{
  return MEMORY[0x270FA1490]();
}

uint64_t type metadata accessor for Array()
{
  return MEMORY[0x270F9DCD8]();
}

uint64_t Array.init<A>(_:)()
{
  return MEMORY[0x270F9DD08]();
}

uint64_t Array.subscript.getter()
{
  return MEMORY[0x270F9DD10]();
}

{
  return MEMORY[0x270F9DD28]();
}

uint64_t Array.subscript.setter()
{
  return MEMORY[0x270F9DD18]();
}

uint64_t Array.subscript.modify()
{
  return MEMORY[0x270F9DD20]();
}

uint64_t specialized Array.subscript.modify()
{
  return MEMORY[0x270FA1498]();
}

{
  return MEMORY[0x270FA14A0]();
}

uint64_t specialized Array.subscript.getter()
{
  return MEMORY[0x270FA14B8]();
}

{
  return MEMORY[0x270FA14C0]();
}

{
  return MEMORY[0x270FA14C8]();
}

NSNumber __swiftcall Bool._bridgeToObjectiveC()()
{
  return (NSNumber)MEMORY[0x270EF1BD8]();
}

uint64_t dispatch thunk of Actor.unownedExecutor.getter()
{
  return MEMORY[0x270FA1DF8]();
}

uint64_t CheckedContinuation.resume(throwing:)()
{
  return MEMORY[0x270FA1E18]();
}

uint64_t CheckedContinuation.resume(returning:)()
{
  return MEMORY[0x270FA1E20]();
}

uint64_t TaskPriority.rawValue.getter()
{
  return MEMORY[0x270FA1F08]();
}

uint64_t type metadata accessor for TaskPriority()
{
  return MEMORY[0x270FA1F10]();
}

uint64_t ThrowingTaskGroup.makeAsyncIterator()()
{
  return MEMORY[0x270FA2040]();
}

NSNumber __swiftcall Double._bridgeToObjectiveC()()
{
  return (NSNumber)MEMORY[0x270EF1C18]();
}

Swift::Double __swiftcall Double.init(_:)(Swift::Float a1)
{
  MEMORY[0x270F9DDD0](a1);
  return result;
}

uint64_t Double.init<A>(_:)()
{
  return MEMORY[0x270F9DDE8]();
}

NSNumber __swiftcall Float._bridgeToObjectiveC()()
{
  return (NSNumber)MEMORY[0x270EF1C48]();
}

uint64_t Float._roundSlowPath(_:)()
{
  return MEMORY[0x270F9DE08]();
}

uint64_t static Float.greatestFiniteMagnitude.getter()
{
  return MEMORY[0x270F9DE20]();
}

uint64_t static Float.nan.getter()
{
  return MEMORY[0x270F9DE28]();
}

uint64_t Float.sign.getter()
{
  return MEMORY[0x270F9DE40]();
}

uint64_t Float.isFinite.getter()
{
  return MEMORY[0x270F9DE60]();
}

uint64_t static Float.ulpOfOne.getter()
{
  return MEMORY[0x270F9DE68]();
}

Swift::Float __swiftcall Float.init(_:)(Swift::Float a1)
{
  MEMORY[0x270F9DE78](a1);
  return result;
}

Swift::Float __swiftcall Float.init(_:)(Swift::Double a1)
{
  MEMORY[0x270F9DE80](a1);
  return result;
}

uint64_t Float.init<A>(_:)()
{
  return MEMORY[0x270F9DE98]();
}

uint64_t Set.init(arrayLiteral:)()
{
  return MEMORY[0x270F9DED0]();
}

uint64_t Set.isEmpty.getter()
{
  return MEMORY[0x270F9DF70]();
}

uint64_t Set.contains(_:)()
{
  return MEMORY[0x270F9DF90]();
}

uint64_t Set.formUnion<A>(_:)()
{
  return MEMORY[0x270F9DFB8]();
}

uint64_t Set.init<A>(_:)()
{
  return MEMORY[0x270F9DFE8]();
}

NSNumber __swiftcall Int._bridgeToObjectiveC()()
{
  return (NSNumber)MEMORY[0x270EF1CE0]();
}

uint64_t dispatch thunk of Collection.startIndex.getter()
{
  return MEMORY[0x270F9E080]();
}

uint64_t dispatch thunk of Collection.count.getter()
{
  return MEMORY[0x270F9E0A0]();
}

uint64_t dispatch thunk of Collection.formIndex(after:)()
{
  return MEMORY[0x270F9E0E0]();
}

uint64_t Collection.firstIndex(where:)()
{
  return MEMORY[0x270F9E0F0]();
}

uint64_t Collection.first.getter()
{
  return MEMORY[0x270F9E140]();
}

uint64_t Collection.prefix(upTo:)()
{
  return MEMORY[0x270F9E158]();
}

uint64_t Collection.isEmpty.getter()
{
  return MEMORY[0x270F9E178]();
}

uint64_t Collection.dropLast(_:)()
{
  return MEMORY[0x270F9E188]();
}

uint64_t Collection.dropFirst(_:)()
{
  return MEMORY[0x270F9E190]();
}

uint64_t Collection<>.makeIterator()()
{
  return MEMORY[0x270F9E1C8]();
}

uint64_t specialized Collection<>.makeIterator()()
{
  return MEMORY[0x270FA14D8]();
}

uint64_t dispatch thunk of Collection.subscript.read()
{
  return MEMORY[0x270F9E1E0]();
}

uint64_t RangeReplaceableCollection.removeFirst()()
{
  return MEMORY[0x270F9E240]();
}

uint64_t static RangeReplaceableCollection.+ infix<A>(_:_:)()
{
  return MEMORY[0x270F9E268]();
}

uint64_t static os_log_type_t.debug.getter()
{
  return MEMORY[0x270FA2E58]();
}

uint64_t static os_log_type_t.error.getter()
{
  return MEMORY[0x270FA2E60]();
}

HKCategoryType __swiftcall HKCategoryType.init(_:)(HKCategoryTypeIdentifier a1)
{
  return (HKCategoryType)MEMORY[0x270EF33E8](a1);
}

HKQuantityType __swiftcall HKQuantityType.init(_:)(HKQuantityTypeIdentifier a1)
{
  return (HKQuantityType)MEMORY[0x270EF33F8](a1);
}

uint64_t OS_dispatch_group.wait(timeout:)()
{
  return MEMORY[0x270FA0C08]();
}

uint64_t type metadata accessor for OS_dispatch_queue.Attributes()
{
  return MEMORY[0x270FA0C50]();
}

uint64_t type metadata accessor for OS_dispatch_queue.AutoreleaseFrequency()
{
  return MEMORY[0x270FA0D50]();
}

uint64_t OS_dispatch_queue.init(label:qos:attributes:autoreleaseFrequency:target:)()
{
  return MEMORY[0x270FA0DB8]();
}

uint64_t static NSObject.== infix(_:_:)()
{
  return MEMORY[0x270FA1180]();
}

uint64_t _NSRange.lowerBound.getter()
{
  return MEMORY[0x270EF21D0]();
}

uint64_t _NSRange.upperBound.getter()
{
  return MEMORY[0x270EF21D8]();
}

Swift::Void __swiftcall UnsafeMutablePointer.deallocate()()
{
}

uint64_t UnsafeMutablePointer.deinitialize(count:)()
{
  return MEMORY[0x270F9E378]();
}

uint64_t static UnsafeMutablePointer.allocate(capacity:)()
{
  return MEMORY[0x270F9E398]();
}

uint64_t type metadata accessor for Optional()
{
  return MEMORY[0x270F9E3C0]();
}

uint64_t UnsafeMutableBufferPointer.baseAddress.getter()
{
  return MEMORY[0x270F9E400]();
}

uint64_t dispatch thunk of IteratorProtocol.next()()
{
  return MEMORY[0x270F9E518]();
}

uint64_t UnsafeMutableRawBufferPointer.copyMemory(from:)()
{
  return MEMORY[0x270F9E530]();
}

uint64_t UnsafeMutableRawBufferPointer.subscript.setter()
{
  return MEMORY[0x270F9E560]();
}

uint64_t ArraySlice.withUnsafeMutableBufferPointer<A>(_:)()
{
  return MEMORY[0x270F9E6E8]();
}

uint64_t ArraySlice.count.getter()
{
  return MEMORY[0x270F9E6F8]();
}

uint64_t SetAlgebra<>.init(arrayLiteral:)()
{
  return MEMORY[0x270F9E7A0]();
}

uint64_t SetAlgebra.isDisjoint(with:)()
{
  return MEMORY[0x270F9E7A8]();
}

uint64_t SetAlgebra.isSuperset(of:)()
{
  return MEMORY[0x270F9E7B0]();
}

uint64_t SetAlgebra.subtracting(_:)()
{
  return MEMORY[0x270F9E7B8]();
}

uint64_t SetAlgebra.isEmpty.getter()
{
  return MEMORY[0x270F9E7C0]();
}

uint64_t SetAlgebra.isSubset(of:)()
{
  return MEMORY[0x270F9E7C8]();
}

uint64_t SetAlgebra.subtract(_:)()
{
  return MEMORY[0x270F9E7D0]();
}

uint64_t SetAlgebra.init<A>(_:)()
{
  return MEMORY[0x270F9E7D8]();
}

uint64_t dispatch thunk of SetAlgebra.init<A>(_:)()
{
  return MEMORY[0x270F9E7E8]();
}

uint64_t _expectEnd<A>(of:is:)()
{
  return MEMORY[0x270F9E890]();
}

uint64_t _hashValue<A>(for:)()
{
  return MEMORY[0x270F9E898]();
}

uint64_t _StringGuts.copyUTF8(into:)()
{
  return MEMORY[0x270F9E9B0]();
}

uint64_t numericCast<A, B>(_:)()
{
  return MEMORY[0x270F9E9C0]();
}

uint64_t type metadata accessor for Zip2Sequence()
{
  return MEMORY[0x270F9EA08]();
}

uint64_t _StringObject.sharedUTF8.getter()
{
  return MEMORY[0x270F9EB28]();
}

uint64_t _ArrayProtocol.filter(_:)()
{
  return MEMORY[0x270F9EB80]();
}

Swift::Void __swiftcall ContiguousArray.reserveCapacity(_:)(Swift::Int a1)
{
}

uint64_t ContiguousArray.append(_:)()
{
  return MEMORY[0x270F9EC48]();
}

uint64_t ContiguousArray.init()()
{
  return MEMORY[0x270F9EC88]();
}

uint64_t type metadata accessor for ContiguousArray()
{
  return MEMORY[0x270F9EC90]();
}

uint64_t _arrayForceCast<A, B>(_:)()
{
  return MEMORY[0x270F9ED68]();
}

uint64_t IndexingIterator.next()()
{
  return MEMORY[0x270F9ED88]();
}

uint64_t specialized IndexingIterator.next()()
{
  return MEMORY[0x270FA14E8]();
}

uint64_t type metadata accessor for IndexingIterator()
{
  return MEMORY[0x270F9ED90]();
}

uint64_t dispatch thunk of static FixedWidthInteger.bitWidth.getter()
{
  return MEMORY[0x270F9EE10]();
}

uint64_t FixedWidthInteger.init<A>(_:)()
{
  return MEMORY[0x270F9EED0]();
}

uint64_t _assertionFailure(_:_:file:line:flags:)()
{
  return MEMORY[0x270F9EFE8]();
}

{
  return MEMORY[0x270F9EFF0]();
}

uint64_t _dictionaryUpCast<A, B, C, D>(_:)()
{
  return MEMORY[0x270F9F008]();
}

uint64_t dispatch thunk of static AdditiveArithmetic.+ infix(_:_:)()
{
  return MEMORY[0x270F9F010]();
}

uint64_t dispatch thunk of static AdditiveArithmetic.- infix(_:_:)()
{
  return MEMORY[0x270F9F018]();
}

uint64_t dispatch thunk of static AdditiveArithmetic.+= infix(_:_:)()
{
  return MEMORY[0x270F9F020]();
}

uint64_t dispatch thunk of static AdditiveArithmetic.zero.getter()
{
  return MEMORY[0x270F9F030]();
}

uint64_t EnumeratedSequence.makeIterator()()
{
  return MEMORY[0x270F9F038]();
}

uint64_t EnumeratedSequence.Iterator.next()()
{
  return MEMORY[0x270F9F040]();
}

uint64_t _fatalErrorMessage(_:_:file:line:flags:)()
{
  return MEMORY[0x270F9F0C0]();
}

uint64_t _convertToAnyHashable<A>(_:)()
{
  return MEMORY[0x270F9F228]();
}

Swift::Int __swiftcall _findStringSwitchCase(cases:string:)(Swift::OpaquePointer cases, Swift::String string)
{
  return MEMORY[0x270F9F230](cases._rawValue, string._countAndFlagsBits, string._object);
}

uint64_t dispatch thunk of CustomStringConvertible.description.getter()
{
  return MEMORY[0x270F9F4E0]();
}

uint64_t type metadata accessor for FloatingPointRoundingRule()
{
  return MEMORY[0x270F9F750]();
}

uint64_t DefaultStringInterpolation.appendInterpolation<A>(_:)()
{
  return MEMORY[0x270F9F770]();
}

{
  return MEMORY[0x270F9F778]();
}

{
  return MEMORY[0x270F9F780]();
}

Swift::Void __swiftcall DefaultStringInterpolation.appendLiteral(_:)(Swift::String a1)
{
}

uint64_t DefaultStringInterpolation.init(literalCapacity:interpolationCount:)()
{
  return MEMORY[0x270F9F790]();
}

uint64_t dispatch thunk of ExpressibleByIntegerLiteral.init(integerLiteral:)()
{
  return MEMORY[0x270F9F7B0]();
}

uint64_t _allocateUninitializedArray<A>(_:)()
{
  return MEMORY[0x270F9F7B8]();
}

uint64_t specialized _allocateUninitializedArray<A>(_:)()
{
  return MEMORY[0x270FA14F0]();
}

uint64_t == infix<A>(_:_:)()
{
  return MEMORY[0x270F9F940]();
}

uint64_t _convertInOutToPointerArgument<A>(_:)()
{
  return MEMORY[0x270F9FA20]();
}

uint64_t dispatch thunk of _ExpressibleByBuiltinIntegerLiteral.init(_builtinIntegerLiteral:)()
{
  return MEMORY[0x270F9FA80]();
}

uint64_t abs<A>(_:)()
{
  return MEMORY[0x270F9FA90]();
}

uint64_t max<A>(_:_:)()
{
  return MEMORY[0x270F9FA98]();
}

uint64_t min<A>(_:_:)()
{
  return MEMORY[0x270F9FAA8]();
}

uint64_t zip<A, B>(_:_:)()
{
  return MEMORY[0x270F9FAB8]();
}

uint64_t Error._getEmbeddedNSError()()
{
  return MEMORY[0x270F9FB30]();
}

uint64_t Error._domain.getter()
{
  return MEMORY[0x270F9FB40]();
}

uint64_t Error._userInfo.getter()
{
  return MEMORY[0x270F9FB48]();
}

uint64_t Error<>._code.getter()
{
  return MEMORY[0x270F9FB50]();
}

uint64_t Hasher.combine<A>(_:)()
{
  return MEMORY[0x270F9FC58]();
}

NSNumber __swiftcall UInt32._bridgeToObjectiveC()()
{
  return (NSNumber)MEMORY[0x270EF2760]();
}

uint64_t OptionSet<>.insert(_:)()
{
  return MEMORY[0x270FA00C8]();
}

uint64_t OptionSet<>.remove(_:)()
{
  return MEMORY[0x270FA00D0]();
}

uint64_t OptionSet<>.update(with:)()
{
  return MEMORY[0x270FA00D8]();
}

uint64_t OptionSet<>.contains(_:)()
{
  return MEMORY[0x270FA00E0]();
}

uint64_t OptionSet.intersection(_:)()
{
  return MEMORY[0x270FA00E8]();
}

uint64_t OptionSet.symmetricDifference(_:)()
{
  return MEMORY[0x270FA00F0]();
}

uint64_t OptionSet.union(_:)()
{
  return MEMORY[0x270FA00F8]();
}

uint64_t OptionSet<>.formIntersection(_:)()
{
  return MEMORY[0x270FA0100]();
}

uint64_t OptionSet<>.formSymmetricDifference(_:)()
{
  return MEMORY[0x270FA0108]();
}

uint64_t OptionSet<>.formUnion(_:)()
{
  return MEMORY[0x270FA0110]();
}

uint64_t OptionSet<>.init()()
{
  return MEMORY[0x270FA0118]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x270F18A48]();
}

uint64_t HKMCCycleFactorsTypes()
{
  return MEMORY[0x270F35C80]();
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x270EF2C38](aSelector);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_release(const void *aBlock)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void Nightingale::vVar<double>()
{
  while (1)
    ;
}

void Nightingale::vVar<float>()
{
  while (1)
    ;
}

void Nightingale::vMean<double>()
{
  while (1)
    ;
}

void Nightingale::vMean<float>()
{
  while (1)
    ;
}

void Nightingale::vMedian<double>()
{
  while (1)
    ;
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

uint64_t std::__sort<std::__less<float,float> &,float *>()
{
  return MEMORY[0x270F98BE0]();
}

uint64_t std::__sort<std::__less<int,int> &,int *>()
{
  return MEMORY[0x270F98BE8]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _swift_stdlib_bridgeErrorToNSError()
{
  return MEMORY[0x270FA0158]();
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cblas_saxpy_NEWLAPACK()
{
  return MEMORY[0x270EDE408]();
}

uint64_t cblas_scopy_NEWLAPACK()
{
  return MEMORY[0x270EDE418]();
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

void free(void *a1)
{
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

void *__cdecl malloc(size_t __size)
{
  return (void *)MEMORY[0x270EDA328](__size);
}

size_t malloc_size(const void *ptr)
{
  return MEMORY[0x270EDA378](ptr);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x270EDA458](__s, *(void *)&__c, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

id objc_allocWithZone(Class a1)
{
  return (id)MEMORY[0x270F9A538](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSend(id a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6D0](a1, a2);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t self
{
  return MEMORY[0x270F9A730]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A888](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A890](a1);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

long double round(long double __x)
{
  MEMORY[0x270EDB288](__x);
  return result;
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

uint64_t swift_allocBox()
{
  return MEMORY[0x270FA0180]();
}

uint64_t swift_allocError()
{
  return MEMORY[0x270FA0190]();
}

uint64_t swift_allocObject()
{
  return MEMORY[0x270FA0198]();
}

uint64_t swift_allocateGenericClassMetadata()
{
  return MEMORY[0x270FA01A0]();
}

uint64_t swift_allocateGenericValueMetadata()
{
  return MEMORY[0x270FA01A8]();
}

uint64_t swift_beginAccess()
{
  return MEMORY[0x270FA01E0]();
}

uint64_t swift_bridgeObjectRelease()
{
  return MEMORY[0x270FA01E8]();
}

uint64_t swift_bridgeObjectRetain()
{
  return MEMORY[0x270FA01F8]();
}

uint64_t swift_checkMetadataState()
{
  return MEMORY[0x270FA0208]();
}

uint64_t swift_deallocClassInstance()
{
  return MEMORY[0x270FA0228]();
}

uint64_t swift_deallocObject()
{
  return MEMORY[0x270FA0238]();
}

uint64_t swift_dynamicCast()
{
  return MEMORY[0x270FA0260]();
}

uint64_t swift_dynamicCastObjCClassUnconditional()
{
  return MEMORY[0x270FA0290]();
}

uint64_t swift_endAccess()
{
  return MEMORY[0x270FA02C0]();
}

uint64_t swift_errorRelease()
{
  return MEMORY[0x270FA02C8]();
}

uint64_t swift_errorRetain()
{
  return MEMORY[0x270FA02D0]();
}

uint64_t swift_getAssociatedConformanceWitness()
{
  return MEMORY[0x270FA02F8]();
}

uint64_t swift_getAssociatedTypeWitness()
{
  return MEMORY[0x270FA0300]();
}

uint64_t swift_getEnumTagSinglePayloadGeneric()
{
  return MEMORY[0x270FA0340]();
}

uint64_t swift_getForeignTypeMetadata()
{
  return MEMORY[0x270FA0370]();
}

uint64_t swift_getGenericMetadata()
{
  return MEMORY[0x270FA03B0]();
}

uint64_t swift_getObjCClassFromMetadata()
{
  return MEMORY[0x270FA03D0]();
}

uint64_t swift_getObjCClassMetadata()
{
  return MEMORY[0x270FA03E0]();
}

uint64_t swift_getObjectType()
{
  return MEMORY[0x270FA03E8]();
}

uint64_t swift_getTupleTypeMetadata2()
{
  return MEMORY[0x270FA0428]();
}

uint64_t swift_getTypeByMangledNameInContext2()
{
  return MEMORY[0x270FA0440]();
}

uint64_t swift_getTypeByMangledNameInContextInMetadataState2()
{
  return MEMORY[0x270FA0448]();
}

uint64_t swift_getWitnessTable()
{
  return MEMORY[0x270FA0450]();
}

uint64_t swift_initClassMetadata2()
{
  return MEMORY[0x270FA0458]();
}

uint64_t swift_initStructMetadata()
{
  return MEMORY[0x270FA0488]();
}

uint64_t swift_isEscapingClosureAtFileLocation()
{
  return MEMORY[0x270FA0498]();
}

uint64_t swift_isUniquelyReferenced_nonNull_native()
{
  return MEMORY[0x270FA04C8]();
}

uint64_t swift_lookUpClassMethod()
{
  return MEMORY[0x270FA04D0]();
}

uint64_t swift_makeBoxUnique()
{
  return MEMORY[0x270FA04D8]();
}

uint64_t swift_once()
{
  return MEMORY[0x270FA04F0]();
}

uint64_t swift_release()
{
  return MEMORY[0x270FA0520]();
}

uint64_t swift_retain()
{
  return MEMORY[0x270FA0530]();
}

uint64_t swift_slowAlloc()
{
  return MEMORY[0x270FA0558]();
}

uint64_t swift_storeEnumTagSinglePayloadGeneric()
{
  return MEMORY[0x270FA0580]();
}

uint64_t swift_task_alloc()
{
  return MEMORY[0x270FA2450]();
}

uint64_t swift_task_create()
{
  return MEMORY[0x270FA2458]();
}

uint64_t swift_task_dealloc()
{
  return MEMORY[0x270FA2460]();
}

uint64_t swift_unknownObjectRelease()
{
  return MEMORY[0x270FA0590]();
}

uint64_t swift_unknownObjectRetain()
{
  return MEMORY[0x270FA05A0]();
}

uint64_t swift_willThrow()
{
  return MEMORY[0x270FA0670]();
}

long double tgamma(long double __x)
{
  MEMORY[0x270EDB8E0](__x);
  return result;
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_normalize(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, float *__Mean, float *__StandardDeviation, vDSP_Length __N)
{
}

void vDSP_vsdiv(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x270EDBBE8](__s, *(void *)&__c, __n);
}