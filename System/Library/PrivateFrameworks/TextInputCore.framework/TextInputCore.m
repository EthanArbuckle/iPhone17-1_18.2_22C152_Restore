id TIAssetsOSLogFacility()
{
  void *v0;
  uint64_t vars8;

  if (TIAssetsOSLogFacility_onceToken != -1) {
    dispatch_once(&TIAssetsOSLogFacility_onceToken, &__block_literal_global_67);
  }
  v0 = (void *)TIAssetsOSLogFacility_logFacility;

  return v0;
}

Class ___ZL22getSRSensorWriterClassv_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!SensorKitLibraryCore(char **)::frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = ___ZL20SensorKitLibraryCorePPc_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6E292B8;
    uint64_t v6 = 0;
    SensorKitLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
    v2 = (void *)v4[0];
    if (!SensorKitLibraryCore(char **)::frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("SRSensorWriter");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getSRSensorWriterClass(void)::softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t ___ZL20SensorKitLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  SensorKitLibraryCore(char **)::frameworkLibrary = result;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(unint64_t a1)
{
  if (a1 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(8 * a1);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
}

Class __getLAContextClass_block_invoke(uint64_t a1)
{
  LocalAuthenticationLibrary();
  Class result = objc_getClass("LAContext");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getLAContextClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)deviceClassString(v3);
  }
  return result;
}

id deviceClassString()
{
  v0 = (void *)MGCopyAnswer();

  return v0;
}

Class __getLARatchetManagerClass_block_invoke(uint64_t a1)
{
  LocalAuthenticationLibrary();
  Class result = objc_getClass("LARatchetManager");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getLARatchetManagerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)__68__TIAppAutofillManager_shouldAcceptAutofill_withPayload_completion___block_invoke_375(v3);
  }
  return result;
}

void LocalAuthenticationLibrary()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  if (!LocalAuthenticationLibraryCore_frameworkLibrary)
  {
    v1[1] = MEMORY[0x1E4F143A8];
    v1[2] = 3221225472;
    v1[3] = __LocalAuthenticationLibraryCore_block_invoke;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_1E6E295C8;
    uint64_t v3 = 0;
    LocalAuthenticationLibraryCore_frameworkLibrary = _sl_dlopen();
    v0 = (void *)v1[0];
    if (LocalAuthenticationLibraryCore_frameworkLibrary)
    {
      if (!v1[0]) {
        return;
      }
    }
    else
    {
      v0 = (void *)abort_report_np();
    }
    free(v0);
  }
}

uint64_t __LocalAuthenticationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  LocalAuthenticationLibraryCore_frameworkLibrary = result;
  return result;
}

Class __getMCProfileConnectionClass_block_invoke(uint64_t a1)
{
  ManagedConfigurationLibrary();
  Class result = objc_getClass("MCProfileConnection");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getMCProfileConnectionClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v3 = abort_report_np();
    return (Class)__getMCFeatureAuthenticationBeforeAutoFillRequiredSymbolLoc_block_invoke(v3);
  }
  return result;
}

void *__getMCFeatureAuthenticationBeforeAutoFillRequiredSymbolLoc_block_invoke(uint64_t a1)
{
  long long v2 = (void *)ManagedConfigurationLibrary();
  Class result = dlsym(v2, "MCFeatureAuthenticationBeforeAutoFillRequired");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getMCFeatureAuthenticationBeforeAutoFillRequiredSymbolLoc_ptr = *(void *)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                            + 24);
  return result;
}

uint64_t ManagedConfigurationLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!ManagedConfigurationLibraryCore_frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = __ManagedConfigurationLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    v3[5] = v3;
    long long v4 = xmmword_1E6E295B0;
    uint64_t v5 = 0;
    ManagedConfigurationLibraryCore_frameworkLibrary = _sl_dlopen();
    v1 = (void *)v3[0];
    uint64_t v0 = ManagedConfigurationLibraryCore_frameworkLibrary;
    if (ManagedConfigurationLibraryCore_frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return ManagedConfigurationLibraryCore_frameworkLibrary;
}

uint64_t __ManagedConfigurationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  ManagedConfigurationLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t __Block_byref_object_copy__74(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__75(uint64_t a1)
{
}

Class __getCoreTelephonyClientClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!CoreTelephonyLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = __CoreTelephonyLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6E29598;
    uint64_t v6 = 0;
    CoreTelephonyLibraryCore_frameworkLibrary = _sl_dlopen();
    long long v2 = (void *)v4[0];
    if (!CoreTelephonyLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("CoreTelephonyClient");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    long long v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getCoreTelephonyClientClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreTelephonyLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreTelephonyLibraryCore_frameworkLibrary = result;
  return result;
}

void __getSFAutoFillPasskeyClass_block_invoke(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("SFAutoFillPasskey");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getSFAutoFillPasskeyClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    abort_report_np();
    SafariFoundationLibrary();
  }
}

void SafariFoundationLibrary()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v1[0] = 0;
  if (!SafariFoundationLibraryCore_frameworkLibrary)
  {
    v1[1] = MEMORY[0x1E4F143A8];
    v1[2] = 3221225472;
    v1[3] = __SafariFoundationLibraryCore_block_invoke;
    v1[4] = &__block_descriptor_40_e5_v8__0l;
    v1[5] = v1;
    long long v2 = xmmword_1E6E29580;
    uint64_t v3 = 0;
    SafariFoundationLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v0 = (void *)v1[0];
    if (SafariFoundationLibraryCore_frameworkLibrary)
    {
      if (!v1[0]) {
        return;
      }
    }
    else
    {
      uint64_t v0 = (void *)abort_report_np();
    }
    free(v0);
  }
}

uint64_t __SafariFoundationLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  SafariFoundationLibraryCore_frameworkLibrary = result;
  return result;
}

void __getSFAppAutoFillPasskeyProviderClass_block_invoke(uint64_t a1)
{
  SafariFoundationLibrary();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("SFAppAutoFillPasskeyProvider");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    getSFAppAutoFillPasskeyProviderClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    long long v2 = (void *)abort_report_np();
    +[TIAppAutofillManager _fetchCredentialsWithPasskeyProvider:v4 autofillContext:v5 textContentType:v6 applicationIdentifier:v7 auditToken:v8 completion:v9];
  }
}

void *KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::FilterContactWordsConflictingWithValidInput *this, unint64_t **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v15[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)a4 + 2);
  if (v7) {
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  }
  uint64_t v8 = *(void *)(v7 + 8);
  uint64_t result = WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  v10 = *a2;
  v11 = a2[1];
  if (*a2 != v11)
  {
    uint64_t v12 = v8 + 144;
    while (1)
    {
      if ((*(unsigned char *)(v10[1] + 240 * *v10 - 134) & 0x80) == 0)
      {
        uint64_t result = (void *)KB::CandidateFilter::candidate_matches_input((uint64_t)v10, (uint64_t)a3, v12);
        if (result)
        {
          uint64_t result = (void *)KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(v10, (unint64_t *)a3, v12);
          if (!result) {
            break;
          }
        }
      }
      v10 += 125;
      if (v10 == v11)
      {
        v10 = v11;
        break;
      }
    }
    if (v10 != a2[1])
    {
      uint64_t v13 = *((void *)a4 + 7);
      v14 = operator new(0x20uLL);
      void *v14 = &unk_1F3F71658;
      v14[1] = a3;
      v14[2] = v12;
      v14[3] = a2;
      v15[3] = v14;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v13, (uint64_t)"CandidateFilterContactWordsConflictingWithValidInput", (uint64_t)v15);
      return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v15);
    }
  }
  return result;
}

uint64_t KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(unint64_t *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v4 = *a1;
  if (*a1) {
    BOOL v5 = *a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    unint64_t v8 = 0;
LABEL_13:
    if (v4 == v8)
    {
      return 0;
    }
    else
    {
      uint64_t v13 = -240 * v8 + 240 * v4;
      for (i = (void *)(240 * v8 + a1[1] + 224); ; i += 30)
      {
        int v15 = *((_DWORD *)i - 30);
        BOOL v17 = (v15 & 0x80020100) != 0 || *i != 0;
        BOOL v18 = (*(_DWORD *)(i - 15) & 0x2000) == 0;
        if ((v15 & 0x80) == 0) {
          BOOL v18 = 0;
        }
        if ((v15 & 0x40000) == 0) {
          BOOL v18 = 1;
        }
        if (v17 && (~v15 & 0x2002000) != 0 && v18) {
          break;
        }
        v13 -= 240;
        if (!v13) {
          return 0;
        }
      }
      return 1;
    }
  }
  else
  {
    unint64_t v8 = 0;
    unsigned int v9 = 1;
    while (1)
    {
      uint64_t v10 = *(void *)(a3 + 24);
      if (!v10) {
        break;
      }
      int v11 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t))(*(void *)v10 + 48))(v10, a1[1] + 240 * v8, a2[1] + 240 * v8);
      unint64_t v4 = *a1;
      if (v11)
      {
        unint64_t v8 = v9;
        BOOL v12 = v4 > v9++;
        BOOL v12 = v12 && *a2 > v8;
        if (v12) {
          continue;
        }
      }
      goto LABEL_13;
    }
    v21 = (char *)std::__throw_bad_function_call[abi:nn180100]();
    return (uint64_t)std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v21);
  }
}

void *std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, unint64_t *a2, KB::String **a3)
{
  v25[3] = *MEMORY[0x1E4F143B8];
  BOOL v5 = *a3;
  uint64_t v6 = KB::FilterContactWordsConflictingWithValidInput::candidate_contains_non_input_contact_word(a2, *(unint64_t **)(a1 + 8), *(void *)(a1 + 16));
  uint64_t v7 = v6;
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v23);
    unsigned int v9 = (const char *)v24;
    if (!v24) {
      unsigned int v9 = (const char *)v25;
    }
    if ((_WORD)v23) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = "";
    }
    KB::String::append_format(v5, "Candidate '%s' contains a contact word suggestion in a collection with a non contact suggestion", v10);
    if (v24 && BYTE6(v23) == 1) {
      free(v24);
    }
  }
  if (v7)
  {
    int v11 = *(uint64_t **)(a1 + 24);
    BOOL v12 = (KB::Candidate *)v11[4];
    unint64_t v13 = v11[5];
    if ((unint64_t)v12 >= v13)
    {
      uint64_t v15 = v11[3];
      uint64_t v16 = 0x1CAC083126E978D5 * (((uint64_t)v12 - v15) >> 3);
      if ((unint64_t)(v16 + 1) > 0x4189374BC6A7EFLL) {
        abort();
      }
      unint64_t v17 = 0x1CAC083126E978D5 * ((uint64_t)(v13 - v15) >> 3);
      uint64_t v18 = 2 * v17;
      if (2 * v17 <= v16 + 1) {
        uint64_t v18 = v16 + 1;
      }
      if (v17 >= 0x20C49BA5E353F7) {
        unint64_t v19 = 0x4189374BC6A7EFLL;
      }
      else {
        unint64_t v19 = v18;
      }
      v25[2] = v11 + 5;
      if (v19) {
        unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      v21 = (char *)(v19 + 1000 * v16);
      unint64_t v23 = v19;
      v24 = v21;
      v25[1] = v19 + 1000 * v20;
      KB::Candidate::Candidate((KB::Candidate *)v21, (const KB::Candidate *)a2);
      v25[0] = v21 + 1000;
      std::vector<KB::Candidate>::__swap_out_circular_buffer(v11 + 3, &v23);
      v14 = (char *)v11[4];
      std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v23);
    }
    else
    {
      v14 = (char *)KB::Candidate::Candidate(v12, (const KB::Candidate *)a2) + 1000;
    }
    v11[4] = (uint64_t)v14;
  }
  return v7;
}

uint64_t std::vector<KB::Candidate>::push_back[abi:nn180100](uint64_t *a1, const KB::Candidate *a2)
{
  unint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  uint64_t v6 = (KB::Candidate *)a1[1];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v9 = 0x1CAC083126E978D5 * (((uint64_t)v6 - *a1) >> 3);
    if ((unint64_t)(v9 + 1) > 0x4189374BC6A7EFLL) {
      abort();
    }
    unint64_t v10 = 0x1CAC083126E978D5 * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x20C49BA5E353F7) {
      unint64_t v12 = 0x4189374BC6A7EFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    uint64_t v18 = v4;
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = v12;
    uint64_t v15 = (KB::Candidate *)(v12 + 1000 * v9);
    unint64_t v17 = v12 + 1000 * v13;
    KB::Candidate::Candidate(v15, a2);
    uint64_t v16 = (char *)v15 + 1000;
    std::vector<KB::Candidate>::__swap_out_circular_buffer(a1, &v14);
    uint64_t v8 = a1[1];
    uint64_t result = std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v14);
  }
  else
  {
    uint64_t result = (uint64_t)KB::Candidate::Candidate(v6, a2);
    uint64_t v8 = result + 1000;
  }
  a1[1] = v8;
  return result;
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, const KB::Candidate *a2)
{
  unint64_t v4 = WTF::Vector<KB::Word,3ul>::Vector(this, a2);
  long long v5 = *(_OWORD *)((char *)a2 + 744);
  long long v6 = *(_OWORD *)((char *)a2 + 760);
  v4[97] = *((void *)a2 + 97);
  *(_OWORD *)(v4 + 93) = v5;
  *(_OWORD *)(v4 + 95) = v6;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)(v4 + 98), (const KB::Candidate *)((char *)a2 + 784));
  KB::String::String((KB::Candidate *)((char *)this + 888), (const KB::Candidate *)((char *)a2 + 888));
  uint64_t v7 = (std::string *)((char *)this + 920);
  if (*((char *)a2 + 943) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *((const std::string::value_type **)a2 + 115), *((void *)a2 + 116));
  }
  else
  {
    long long v8 = *(_OWORD *)((char *)a2 + 920);
    *((void *)this + 117) = *((void *)a2 + 117);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  unint64_t v9 = *((unsigned __int16 *)a2 + 472);
  if (v9 >= 0xF)
  {
    *((_WORD *)this + 472) = v9;
    operator new[]();
  }
  *((_OWORD *)this + 59) = *((_OWORD *)a2 + 59);
  *((_OWORD *)this + 60) = *((_OWORD *)a2 + 60);
  unint64_t v10 = (const void *)*((void *)a2 + 122);
  *((void *)this + 122) = v10;
  if (v10)
  {
    CFRetain(v10);
    *((void *)this + 122) = v10;
  }
  uint64_t v11 = (const void *)*((void *)a2 + 123);
  *((void *)this + 123) = v11;
  if (v11)
  {
    CFRetain(v11);
    *((void *)this + 123) = v11;
  }
  *((_DWORD *)this + 248) = *((_DWORD *)a2 + 248);
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(unint64_t a1)
{
  if (a1 >= 0x4189374BC6A7F0) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(1000 * a1);
}

uint64_t std::vector<KB::Candidate>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 1000;
    uint64_t result = KB::Candidate::Candidate(result - 1000, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::Candidate>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 1000;
    KB::Candidate::~Candidate((KB::Candidate *)(i - 1000));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t KB::Candidate::Candidate(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = a1 + 24;
  *(void *)(a1 + 16) = 3;
  *(void *)a1 = *(void *)a2;
  *(void *)a2 = 0;
  WTF::VectorBuffer<KB::Word,3ul>::swap((void *)(a1 + 8), (void *)(a2 + 8));
  long long v4 = *(_OWORD *)(a2 + 744);
  long long v5 = *(_OWORD *)(a2 + 760);
  *(void *)(a1 + 776) = *(void *)(a2 + 776);
  *(_OWORD *)(a1 + 744) = v4;
  *(_OWORD *)(a1 + 760) = v5;
  KB::LanguageModelContext::LanguageModelContext(a1 + 784, a2 + 784);
  *(_DWORD *)(a1 + 888) = 0x100000;
  *(_WORD *)(a1 + 892) = 0;
  *(unsigned char *)(a1 + 894) = 0;
  *(void *)(a1 + 896) = 0;
  KB::String::operator=(a1 + 888, (KB::String *)(a2 + 888));
  long long v6 = *(_OWORD *)(a2 + 920);
  *(void *)(a1 + 936) = *(void *)(a2 + 936);
  *(_OWORD *)(a1 + 920) = v6;
  *(_OWORD *)(a2 + 920) = 0u;
  *(void *)(a2 + 936) = 0;
  unsigned int v7 = *(unsigned __int16 *)(a2 + 944);
  *(_OWORD *)(a1 + 944) = *(_OWORD *)(a2 + 944);
  if (v7 >= 0xF) {
    *(_WORD *)(a2 + 944) = 0;
  }
  *(_OWORD *)(a1 + 960) = *(_OWORD *)(a2 + 960);
  long long v8 = *(_OWORD *)(a2 + 976);
  *(_OWORD *)(a2 + 976) = 0uLL;
  *(_OWORD *)(a1 + 976) = v8;
  *(_DWORD *)(a1 + 992) = *(_DWORD *)(a2 + 992);
  return a1;
}

void *WTF::VectorBuffer<KB::Word,3ul>::swap(void *result, void *a2)
{
  uint64_t v3 = result + 2;
  long long v2 = (void *)*result;
  long long v5 = a2 + 2;
  long long v4 = (void *)*a2;
  if ((void *)*result == result + 2)
  {
    if (v4 == v5)
    {
      for (uint64_t i = 0; i != 720; ++i)
      {
        char v11 = *((unsigned char *)v2 + i);
        *((unsigned char *)v2 + i) = *((unsigned char *)v4 + i);
        *((unsigned char *)v4 + i) = v11;
      }
    }
    else
    {
      uint64_t v6 = 0;
      *uint64_t result = v4;
      *a2 = v5;
      do
      {
        char v7 = *((unsigned char *)v2 + v6);
        *((unsigned char *)v2 + v6) = *((unsigned char *)v5 + v6);
        *((unsigned char *)v5 + v6++) = v7;
      }
      while (v6 != 720);
    }
  }
  else if (v4 == v5)
  {
    uint64_t v8 = 0;
    *a2 = v2;
    *uint64_t result = v3;
    do
    {
      char v9 = *((unsigned char *)v3 + v8);
      *((unsigned char *)v3 + v8) = *((unsigned char *)v4 + v8);
      *((unsigned char *)v4 + v8++) = v9;
    }
    while (v8 != 720);
  }
  else
  {
    *uint64_t result = v4;
    *a2 = v2;
  }
  uint64_t v12 = result[1];
  result[1] = a2[1];
  a2[1] = v12;
  return result;
}

uint64_t KB::LanguageModelContext::LanguageModelContext(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  long long v4 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v4;
  language_modeling::v1::LinguisticContext::LinguisticContext();
  language_modeling::v1::LinguisticContext::LinguisticContext();
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 96) = 0;
  return a1;
}

void *WTF::Vector<KB::Word,3ul>::Vector(void *a1, void *a2)
{
  unint64_t v4 = a2[2];
  long long v5 = (KB::Word *)(a1 + 3);
  *a1 = *a2;
  a1[1] = v5;
  a1[2] = 3;
  if (v4 < 4 || (a1[2] = v4, long long v5 = (KB::Word *)malloc_type_malloc(240 * v4, 0x10B2040DF775671uLL), (a1[1] = v5) != 0))
  {
    uint64_t v6 = *a2;
    if (*a2)
    {
      char v7 = (size_t *)a2[1];
      uint64_t v8 = 240 * v6;
      do
      {
        long long v5 = (KB::Word *)((char *)KB::Word::Word(v5, v7) + 240);
        v7 += 30;
        v8 -= 240;
      }
      while (v8);
    }
  }
  return a1;
}

KB::LanguageModelContext *KB::LanguageModelContext::LanguageModelContext(KB::LanguageModelContext *this, const KB::LanguageModelContext *a2)
{
  uint64_t v4 = *((void *)a2 + 1);
  *(void *)this = *(void *)a2;
  *((void *)this + 1) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<TITokenID>::vector((void *)this + 2, (uint64_t)a2 + 16);
  long long v5 = *(_OWORD *)((char *)a2 + 40);
  *((void *)this + 7) = *((void *)a2 + 7);
  *(_OWORD *)((char *)this + 40) = v5;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::LanguageModelContext *)((char *)this + 64), (const KB::LanguageModelContext *)((char *)a2 + 64));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::LanguageModelContext *)((char *)this + 72), (const KB::LanguageModelContext *)((char *)a2 + 72));
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)((char *)this + 80), *((long long **)a2 + 10), *((long long **)a2 + 11), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)a2 + 11) - *((void *)a2 + 10)) >> 3));
  return this;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  long long v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    long long v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void *std::vector<TITokenID>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<TITokenID>::__vallocate[abi:nn180100](a1, v5 >> 3);
    std::string::size_type v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

std::string *std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(std::string *result, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    std::string::size_type v6 = result;
    std::vector<std::string>::__vallocate[abi:nn180100](result, a4);
    uint64_t result = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(a2, a3, (std::string *)v6->__r_.__value_.__l.__size_);
    v6->__r_.__value_.__l.__size_ = (std::string::size_type)result;
  }
  return result;
}

char *std::vector<std::string>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(long long *a1, long long *a2, std::string *this)
{
  if (a1 != a2)
  {
    int64_t v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((void *)v5 + 1));
      }
      else
      {
        long long v6 = *v5;
        this->__r_.__value_.__r.__words[2] = *((void *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }
      int64_t v5 = (long long *)((char *)v5 + 24);
      ++this;
    }
    while (v5 != a2);
  }
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(unint64_t a1)
{
  if (a1 >= 0xAAAAAAAAAAAAAABLL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(24 * a1);
}

char *std::vector<TITokenID>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

KB::Word *KB::Word::Word(KB::Word *this, size_t *a2)
{
  KB::String::String(this, (const KB::String *)a2);
  unint64_t v5 = *((unsigned __int16 *)a2 + 16);
  if (v5 >= 0xF)
  {
    *((_WORD *)this + 16) = v5;
    operator new[]();
  }
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  size_t v6 = a2[6];
  *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
  *((void *)this + 6) = v6;
  KB::String::String((KB::Word *)((char *)this + 64), (const KB::String *)(a2 + 8));
  long long v7 = *((_OWORD *)a2 + 6);
  long long v8 = *((_OWORD *)a2 + 7);
  long long v9 = *((_OWORD *)a2 + 9);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 8);
  *((_OWORD *)this + 9) = v9;
  *((_OWORD *)this + 6) = v7;
  *((_OWORD *)this + 7) = v8;
  KB::String::String((KB::Word *)((char *)this + 160), (const KB::String *)(a2 + 20));
  char v10 = *((unsigned char *)a2 + 192);
  *(_OWORD *)((char *)this + 200) = 0u;
  char v11 = (uint64_t *)((char *)this + 200);
  *((unsigned char *)this + 192) = v10;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = *((_DWORD *)a2 + 58);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)this + 200, a2[26]);
  uint64_t v12 = (void *)a2[27];
  if (v12)
  {
    uint64_t v13 = (void *)((char *)this + 216);
    unint64_t v14 = *((void *)this + 26);
    do
    {
      unint64_t v15 = v12[2];
      if (v14)
      {
        uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v14);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          unint64_t v2 = v12[2];
          if (v15 >= v14) {
            unint64_t v2 = v15 % v14;
          }
        }
        else
        {
          unint64_t v2 = (v14 - 1) & v15;
        }
        unint64_t v17 = *(void **)(*v11 + 8 * v2);
        if (v17)
        {
          for (uint64_t i = (void *)*v17; i; uint64_t i = (void *)*i)
          {
            unint64_t v19 = i[1];
            if (v19 == v15)
            {
              if (i[2] == v15) {
                goto LABEL_43;
              }
            }
            else
            {
              if (v16.u32[0] > 1uLL)
              {
                if (v19 >= v14) {
                  v19 %= v14;
                }
              }
              else
              {
                v19 &= v14 - 1;
              }
              if (v19 != v2) {
                break;
              }
            }
          }
        }
      }
      uint64_t v20 = operator new(0x18uLL);
      *uint64_t v20 = 0;
      v20[1] = v15;
      v20[2] = v12[2];
      float v21 = (float)(unint64_t)(*((void *)this + 28) + 1);
      float v22 = *((float *)this + 58);
      if (!v14 || (float)(v22 * (float)v14) < v21)
      {
        BOOL v23 = (v14 & (v14 - 1)) != 0;
        if (v14 < 3) {
          BOOL v23 = 1;
        }
        unint64_t v24 = v23 | (2 * v14);
        unint64_t v25 = vcvtps_u32_f32(v21 / v22);
        if (v24 <= v25) {
          size_t v26 = v25;
        }
        else {
          size_t v26 = v24;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)this + 200, v26);
        unint64_t v14 = *((void *)this + 26);
        if ((v14 & (v14 - 1)) != 0)
        {
          if (v15 >= v14) {
            unint64_t v2 = v15 % v14;
          }
          else {
            unint64_t v2 = v15;
          }
        }
        else
        {
          unint64_t v2 = (v14 - 1) & v15;
        }
      }
      uint64_t v27 = *v11;
      v28 = *(void **)(*v11 + 8 * v2);
      if (v28)
      {
        *uint64_t v20 = *v28;
      }
      else
      {
        *uint64_t v20 = *v13;
        *uint64_t v13 = v20;
        *(void *)(v27 + 8 * v2) = v13;
        if (!*v20) {
          goto LABEL_42;
        }
        unint64_t v29 = *(void *)(*v20 + 8);
        if ((v14 & (v14 - 1)) != 0)
        {
          if (v29 >= v14) {
            v29 %= v14;
          }
        }
        else
        {
          v29 &= v14 - 1;
        }
        v28 = (void *)(*v11 + 8 * v29);
      }
      void *v28 = v20;
LABEL_42:
      ++*((void *)this + 28);
LABEL_43:
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  return this;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime <= *(void *)&v4)
  {
    if (prime >= *(void *)&v4) {
      return;
    }
    unint64_t v11 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v12 = (uint8x8_t)vcnt_s8(v4), v12.i16[0] = vaddlv_u8(v12), v12.u32[0] > 1uLL))
    {
      unint64_t v11 = std::__next_prime(v11);
    }
    else
    {
      uint64_t v13 = 1 << -(char)__clz(v11 - 1);
      if (v11 >= 2) {
        unint64_t v11 = v13;
      }
    }
    if (prime <= v11) {
      size_t prime = v11;
    }
    if (prime >= *(void *)&v4) {
      return;
    }
    if (!prime)
    {
      uint8x8_t v16 = *(void **)a1;
      *(void *)a1 = 0;
      if (v16) {
        operator delete(v16);
      }
      *(void *)(a1 + 8) = 0;
      return;
    }
  }
  if (prime >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v5 = operator new(8 * prime);
  size_t v6 = *(void **)a1;
  *(void *)a1 = v5;
  if (v6) {
    operator delete(v6);
  }
  uint64_t v7 = 0;
  *(void *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v7++) = 0;
  while (prime != v7);
  long long v8 = *(void **)(a1 + 16);
  if (v8)
  {
    size_t v9 = v8[1];
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)prime);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      if (v9 >= prime) {
        v9 %= prime;
      }
    }
    else
    {
      v9 &= prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v9) = a1 + 16;
    unint64_t v14 = (void *)*v8;
    if (*v8)
    {
      do
      {
        size_t v15 = v14[1];
        if (v10.u32[0] > 1uLL)
        {
          if (v15 >= prime) {
            v15 %= prime;
          }
        }
        else
        {
          v15 &= prime - 1;
        }
        if (v15 != v9)
        {
          if (!*(void *)(*(void *)a1 + 8 * v15))
          {
            *(void *)(*(void *)a1 + 8 * v15) = v8;
            goto LABEL_31;
          }
          void *v8 = *v14;
          void *v14 = **(void **)(*(void *)a1 + 8 * v15);
          **(void **)(*(void *)a1 + 8 * v15) = v14;
          unint64_t v14 = v8;
        }
        size_t v15 = v9;
LABEL_31:
        long long v8 = v14;
        unint64_t v14 = (void *)*v14;
        size_t v9 = v15;
      }
      while (v14);
    }
  }
}

__n128 std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)unint64_t v2 = &unk_1F3F71658;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterContactWordsConflictingWithValidInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *std::__throw_bad_function_call[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_function_call was thrown in -fno-exceptions mode");
  return KB::FilterContactWordsConflictingWithValidInput::filter_description(v0);
}

const char *KB::FilterContactWordsConflictingWithValidInput::filter_description(KB::FilterContactWordsConflictingWithValidInput *this)
{
  return "CandidateFilterContactWordsConflictingWithValidInput";
}

void KB::FilterContactWordsConflictingWithValidInput::~FilterContactWordsConflictingWithValidInput(KB::FilterContactWordsConflictingWithValidInput *this)
{
}

void KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::FilterWordsConflictingWithValidContactNames *this, KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a3 + 2000)) {
    uint64_t v7 = (unsigned __int16 *)((char *)a3 + 1000);
  }
  else {
    uint64_t v7 = (unsigned __int16 *)a3;
  }
  if (!v7[444]) {
    KB::Candidate::compute_string((KB::Candidate *)v7);
  }
  WORD2(v83) = 0;
  BYTE6(v83) = 0;
  v84 = " \t\n";
  LODWORD(v83) = 1048579;
  char v85 = 0;
  KB::sbs_string_tokenize(v7 + 444, (const KB::String *)&v83, v80);
  if (v84 && BYTE6(v83) == 1) {
    free(v84);
  }
  v67 = v7;
  uint64_t v8 = *((void *)a4 + 2);
  if (v8) {
    atomic_fetch_add((atomic_uint *volatile)v8, 1u);
  }
  uint64_t v9 = *(void *)(v8 + 8);
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  unint64_t v11 = *a2;
  uint8x8_t v10 = a2[1];
  v69 = a4;
  if (*a2 != v10)
  {
    while (1)
    {
      uint8x8_t v12 = v11;
      if (*(void *)v11) {
        break;
      }
LABEL_22:
      unint64_t v11 = (KB::Candidate *)((char *)v12 + 1000);
      if ((KB::Candidate *)((char *)v12 + 1000) == v10)
      {
        unint64_t v11 = v10;
        goto LABEL_25;
      }
    }
    uint64_t v13 = *((void *)v11 + 1);
    uint64_t v14 = v13 + 240 * *(void *)v11;
    while ((*(unsigned char *)(v13 + 106) & 2) == 0)
    {
LABEL_15:
      v13 += 240;
      if (v13 == v14) {
        goto LABEL_22;
      }
    }
    uint64_t v15 = v80[0];
    uint64_t v16 = v80[1];
    while (1)
    {
      if (v15 == v16) {
        goto LABEL_15;
      }
      uint64_t v17 = *(void *)(v9 + 168);
      if (!v17) {
        break;
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 48))(v17, v15, v13))
      {
        unint64_t v11 = v12;
        goto LABEL_25;
      }
      v15 += 32;
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_104:
    abort();
  }
LABEL_25:
  if (v11 != a2[1] && v11 != *a2)
  {
    v64 = (char *)a3 + 2032;
    v65 = (KB::CandidateCollection *)a2;
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v73, (const KB::CandidateFilterLookupContext *)((char *)a3 + 2032));
    v66 = v11;
    if (*(void *)v11)
    {
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      float v21 = 0;
      uint64_t v22 = *((void *)v11 + 1);
      uint64_t v23 = v22 + 240 * *(void *)v11;
      do
      {
        if ((*(unsigned char *)(v22 + 106) & 2) != 0) {
          *(_DWORD *)(v22 + 136) = 0;
        }
        BOOL is_linguistically_void = KB::Word::is_linguistically_void((KB::Word *)v22);
        BOOL v25 = is_linguistically_void;
        __int16 v26 = !is_linguistically_void;
        if ((unint64_t)v20 >= v19)
        {
          uint64_t v29 = v20 - v21;
          if (v20 - v21 <= -3) {
            goto LABEL_104;
          }
          uint64_t v30 = v29 >> 1;
          if (v19 - (unint64_t)v21 <= (v29 >> 1) + 1) {
            uint64_t v31 = v30 + 1;
          }
          else {
            uint64_t v31 = v19 - (void)v21;
          }
          if (v19 - (unint64_t)v21 >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v32 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v32 = v31;
          }
          if (v32) {
            uint64_t v32 = (uint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v32);
          }
          else {
            uint64_t v33 = 0;
          }
          v34 = (char *)(v32 + 2 * v30);
          if (v25) {
            __int16 v35 = 256;
          }
          else {
            __int16 v35 = 0;
          }
          *(_WORD *)v34 = v35 | v26;
          v28 = v34 + 2;
          if (v20 != v21)
          {
            do
            {
              __int16 v36 = *((_WORD *)v20 - 1);
              v20 -= 2;
              *((_WORD *)v34 - 1) = v36;
              v34 -= 2;
            }
            while (v20 != v21);
            uint64_t v20 = v21;
          }
          float v21 = v34;
          unint64_t v19 = v32 + 2 * v33;
          if (v20) {
            operator delete(v20);
          }
        }
        else
        {
          if (is_linguistically_void) {
            __int16 v27 = 256;
          }
          else {
            __int16 v27 = 0;
          }
          *(_WORD *)uint64_t v20 = v27 | v26;
          v28 = v20 + 2;
        }
        v22 += 240;
        uint64_t v20 = v28;
      }
      while (v22 != v23);
    }
    else
    {
      v28 = 0;
      float v21 = 0;
    }
    uint64_t v37 = *((void *)v69 + 3);
    v38 = (std::__shared_weak_count *)*((void *)v69 + 4);
    if (v38) {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v37)
    {
      uint64_t v39 = *((void *)v69 + 3);
      v40 = (std::__shared_weak_count *)*((void *)v69 + 4);
      if (v40) {
        atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v41 = (*(uint64_t (**)(uint64_t))(*(void *)v39 + 16))(v39) ^ 1;
      if (v40) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v40);
      }
      if (!v38) {
        goto LABEL_68;
      }
    }
    else
    {
      char v41 = 1;
      if (!v38) {
        goto LABEL_68;
      }
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v38);
LABEL_68:
    if ((v41 & 1) == 0)
    {
      uint64_t v43 = *((void *)v69 + 3);
      v42 = (std::__shared_weak_count *)*((void *)v69 + 4);
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      KB::Candidate::Candidate((KB::Candidate *)&v83, v66);
      v44 = (KB::Candidate *)operator new(0x3E8uLL);
      v45 = (char *)v44 + 1000;
      v71[0] = v44;
      v71[2] = (char *)v44 + 1000;
      KB::Candidate::Candidate(v44, (const KB::Candidate *)&v83);
      v71[1] = v45;
      uint64_t v46 = v28 - v21;
      if (v28 == v21)
      {
        v47 = 0;
        v48 = 0;
      }
      else
      {
        if (v28 - v21 < 0) {
          goto LABEL_104;
        }
        v47 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(v46 >> 1);
        memmove(v47, v21, v28 - v21);
        v48 = &v47[v46];
      }
      v49 = (void **)operator new(0x18uLL);
      v50 = v49 + 3;
      v70[0] = v49;
      v70[2] = v49 + 3;
      v49[1] = 0;
      v49[2] = 0;
      *v49 = 0;
      int64_t v51 = v48 - v47;
      if (v48 != v47)
      {
        v52 = v49;
        std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v49, v51 >> 1);
        v53 = (char *)v52[1];
        memmove(v53, v47, v51);
        v52[1] = &v53[v51];
      }
      v70[1] = v50;
      (*(void (**)(void *__return_ptr, uint64_t, void *, void ***, char *, void, uint64_t))(*(void *)v43 + 432))(v72, v43, v71, v70, v64, *((void *)v69 + 7), 1);
      v81 = v70;
      std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v81);
      if (v47) {
        operator delete(v47);
      }
      v70[0] = (void **)v71;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v70);
      KB::Candidate::~Candidate((KB::Candidate *)&v83);
      if (v42) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v42);
      }
      if (v72[1] != v72[0])
      {
        v54 = *(float **)v72[0];
        uint64_t v55 = *(void *)(v72[0] + 8) - *(void *)v72[0];
        if (v55)
        {
          unint64_t v56 = v55 / 40;
          if (v56 <= 1) {
            unint64_t v56 = 1;
          }
          float v57 = 1.0;
          v58 = v21;
          v59 = v66;
          do
          {
            int v60 = *v58;
            v58 += 2;
            if (v60) {
              float v57 = v57 * *v54;
            }
            v54 += 10;
            --v56;
          }
          while (v56);
        }
        else
        {
          float v57 = 1.0;
          v59 = v66;
        }
        float v61 = *((float *)v59 + 187);
        float v62 = *((float *)v59 + 189);
        if ((float)(v61 + (float)(*((float *)this + 2) * (float)(logf(v57) + v62))) >= (float)(*(float *)(*(void *)v65 + 748)
                                                                                              + (float)(*((float *)this + 2) * (float)(*(float *)(*(void *)v65 + 752) + *(float *)(*(void *)v65 + 756)))))
        {
          uint64_t v63 = *((void *)v69 + 7);
          v82[0] = &unk_1F3F716A0;
          v82[1] = v67;
          v82[2] = v9 + 144;
          v82[3] = v82;
          KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)v65, v63, (uint64_t)"FilterWordsConflictingWithValidContactNames", (uint64_t)v82);
          std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v82);
        }
      }
      v83 = (void **)v72;
      std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](&v83);
    }
    if (v21) {
      operator delete(v21);
    }
    v83 = (void **)&v79;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v83);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v78);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v77);
    if (__p)
    {
      v76 = __p;
      operator delete(__p);
    }
    if (v74) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v74);
    }
  }
  v83 = (void **)v80;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v83);
}

BOOL KB::Word::is_linguistically_void(KB::Word *this)
{
  if ((*((unsigned char *)this + 135) & 4) != 0) {
    return 1;
  }
  v1 = *((void *)this + 1) ? (const char *)*((void *)this + 1) : (char *)this + 16;
  return !strcmp(v1, " ") || *v1 == 0;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(uint64_t a1)
{
  if (a1 < 0) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(2 * a1);
}

void std::__shared_weak_count::__release_shared[abi:nn180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

char *std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](void *a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::TokenMetadata>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      size_t v6 = (char *)v1[1];
      do
      {
        uint64_t v8 = (void *)*((void *)v6 - 3);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *((void *)v4 - 2) = v7;
          operator delete(v7);
        }
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        KB::Candidate::~Candidate((KB::Candidate *)(v4 - 1000));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        size_t v6 = v4;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        size_t v6 = (void *)*((void *)v4 - 3);
        if (v6 && *(v4 - 26) == 1) {
          free(v6);
        }
        v4 -= 32;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::string>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 1) < 0) {
          operator delete(*(v4 - 3));
        }
        v4 -= 5;
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

BOOL std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  if (*(void *)a2)
  {
    uint64_t v5 = 240 * *(void *)a2 - 240;
    size_t v6 = (int *)(*(void *)(a2 + 8) + 104);
    do
    {
      int v7 = *v6;
      v6 += 60;
      BOOL v8 = (v7 & 0x20000) == 0;
      if ((v7 & 0x20000) != 0) {
        break;
      }
      uint64_t v9 = v5;
      v5 -= 240;
    }
    while (v9);
  }
  else
  {
    BOOL v8 = 1;
  }
  uint8x8_t v10 = *a3;
  uint64_t v11 = *(void *)(a1 + 16);
  if (!*(_WORD *)(a2 + 888)) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  uint8x8_t v12 = *(KB::Candidate **)(a1 + 8);
  if (!*((_WORD *)v12 + 444)) {
    KB::Candidate::compute_string(v12);
  }
  uint64_t v13 = *(void *)(v11 + 24);
  if (!v13) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t, _WORD *))(*(void *)v13 + 48))(v13, a2 + 888, (_WORD *)v12 + 444))
  {
    BOOL v14 = 0;
  }
  else
  {
    BOOL v14 = v8;
  }
  if (v10 && v14)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)v18);
    uint64_t v15 = (const char *)v20;
    if (!v20) {
      uint64_t v15 = (const char *)v21;
    }
    if (v18[0]) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = "";
    }
    KB::String::append_format(v10, "Candidate list contains a valid contact name matching input, and '%s' is not a valid contact name nor sortkey equivalent to what the user typed", v16);
    if (v20 && v19 == 1) {
      free(v20);
    }
  }
  return v14;
}

__n128 std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F716A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F716A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterWordsConflictingWithValidContactNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterWordsConflictingWithValidContactNames::filter_description(KB::FilterWordsConflictingWithValidContactNames *this)
{
  return "FilterWordsConflictingWithValidContactNames";
}

void KB::FilterWordsConflictingWithValidContactNames::~FilterWordsConflictingWithValidContactNames(KB::FilterWordsConflictingWithValidContactNames *this)
{
}

void KB::LikelihoodInfo::~LikelihoodInfo(void **this)
{
  if (*((char *)this + 39) < 0) {
    operator delete(this[2]);
  }
}

Class __getUITextCheckerClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!UIKitLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = __UIKitLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6E29618;
    uint64_t v6 = 0;
    UIKitLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!UIKitLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("UITextChecker");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getUITextCheckerClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __UIKitLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  UIKitLibraryCore_frameworkLibrary = result;
  return result;
}

id get_KSUserWordsSynchroniserClass()
{
  uint64_t v4 = 0;
  long long v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)get_KSUserWordsSynchroniserClass_softClass;
  uint64_t v7 = get_KSUserWordsSynchroniserClass_softClass;
  if (!get_KSUserWordsSynchroniserClass_softClass)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = __get_KSUserWordsSynchroniserClass_block_invoke;
    v3[3] = &unk_1E6E2E248;
    v3[4] = &v4;
    __get_KSUserWordsSynchroniserClass_block_invoke((uint64_t)v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

uint64_t KeyboardServicesLibrary()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!KeyboardServicesLibraryCore_frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    v3[3] = __KeyboardServicesLibraryCore_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E6E29630;
    uint64_t v5 = 0;
    KeyboardServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    id v1 = (void *)v3[0];
    uint64_t v0 = KeyboardServicesLibraryCore_frameworkLibrary;
    if (KeyboardServicesLibraryCore_frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      id v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return KeyboardServicesLibraryCore_frameworkLibrary;
}

uint64_t __KeyboardServicesLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  KeyboardServicesLibraryCore_frameworkLibrary = result;
  return result;
}

void KB::createLanguageModelParameters(id *a1@<X0>, uint64_t *a2@<X8>)
{
  id v3 = *a1;
  if (v3)
  {
    id v10 = v3;
    long long v4 = [v3 objectForKeyedSubscript:*MEMORY[0x1E4F72400]];
    uint64_t v5 = v4;
    if (v4 && [v4 count])
    {
      uint64_t v6 = [v5 objectAtIndexedSubscript:0];
      uint64_t v7 = v6;
      if (v6)
      {
        uint64_t v8 = [v6 objectForKeyedSubscript:@"URL"];
        uint64_t v9 = (void *)v8;
        if (v8)
        {
          uint64_t v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithContentsOfURL:v8];
        }
        *a2 = v8;
      }
      else
      {
        *a2 = 0;
      }
    }
    else
    {
      *a2 = 0;
    }

    id v3 = v10;
  }
  else
  {
    *a2 = 0;
  }
}

BOOL isInlineCompletionDefaultAllowlistedApp(KB::String *a1)
{
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, "com.apple.MobileSMS");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, "com.apple.mobilemail");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, "com.apple.reminders");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, "com.apple.mobilenotes");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, "com.apple.mobilecal");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, "com.apple.Typist");
    __cxa_atexit((void (*)(void *))KB::String::~String, &isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, &dword_1E3F0E000);
  }
  if (KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobileSMS, 1)
    || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilemail, 1)
    || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::reminders, 1)
    || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilenotes, 1)
    || KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::mobilecal, 1))
  {
    return 1;
  }

  return KB::String::equal(a1, (const KB::String *)&isInlineCompletionDefaultAllowlistedApp(KB::String)::typist, 1);
}

void TIInlineCompletion::TIInlineCompletion(std::string *this, long long *a2, int a3, double a4)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v7 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
  }
  this[1].__r_.__value_.__r.__words[0] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  *(double *)&this[2].__r_.__value_.__l.__data_ = a4;
  LODWORD(this[2].__r_.__value_.__r.__words[1]) = a3;
  this[2].__r_.__value_.__s.__data_[16] = 0;
  this[3].__r_.__value_.__s.__data_[0] = 0;
}

uint64_t TIInlineCompletion::TIInlineCompletion(uint64_t a1, language_modeling::v1::InlineCompletion *a2)
{
  language_modeling::v1::InlineCompletion::string(a2);
  language_modeling::v1::InlineCompletion::log(a2);
  *(void *)(a1 + 48) = language_modeling::v1::InlineCompletion::probability(a2);
  unsigned int v4 = language_modeling::v1::InlineCompletion::source(a2) - 4;
  if (v4 > 3) {
    int v5 = 4;
  }
  else {
    int v5 = dword_1E4154E50[v4];
  }
  *(_DWORD *)(a1 + 56) = v5;
  *(unsigned char *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  MEMORY[0x1E4E7B4C0](a1 + 64, a2);
  *(unsigned char *)(a1 + 72) = 1;
  return a1;
}

uint64_t TIInlineCompletion::source(TIInlineCompletion *this)
{
  return *((unsigned int *)this + 14);
}

void TIInlineCompletion::string(TIInlineCompletion *this@<X0>, std::string *a2@<X8>)
{
  if (*((char *)this + 23) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)this, *((void *)this + 1));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)this;
    a2->__r_.__value_.__r.__words[2] = *((void *)this + 2);
  }
}

uint64_t TIInlineCompletion::probability(TIInlineCompletion *this)
{
  if (*((unsigned char *)this + 72)) {
    return language_modeling::v1::InlineCompletion::probability((TIInlineCompletion *)((char *)this + 64));
  }
  else {
    return *((void *)this + 6);
  }
}

uint64_t TIInlineCompletion::wordBoundaryAt(TIInlineCompletion *this)
{
  if (*((unsigned char *)this + 72)) {
    return language_modeling::v1::InlineCompletion::wordBoundaryAt((TIInlineCompletion *)((char *)this + 64));
  }
  else {
    return 0;
  }
}

uint64_t UkLoadKeyMap(const char *a1, int *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t result = UkLoadKeyOrderMap(a1);
  if (result)
  {
    memset_pattern16(a2, &unk_1E4154E80, 0x400uLL);
    return 1;
  }
  return result;
}

uint64_t UkLoadKeyOrderMap(const char *a1)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (fopen(a1, "r"))
  {
    memset_pattern16(__b, &unk_1E4154E80, 0x400uLL);
    operator new[]();
  }
  CFLog();
  return 0;
}

void initKeyMap(int *a1)
{
}

uint64_t UkStoreKeyOrderMap(const char *a1, uint64_t a2, int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v5 = fopen(a1, "wt");
  if (v5)
  {
    uint64_t v6 = v5;
    fputs("; This is UniKey user-defined key mapping file, generated from UniKey (Windows)\n\n", v5);
    if (a3 >= 1)
    {
      uint64_t v7 = 0;
      do
      {
        uint64_t v8 = 0;
        uint64_t v9 = "\n";
        while (1)
        {
          int v10 = *(_DWORD *)v9;
          v9 += 36;
          if (v10 == *(_DWORD *)(a2 + 8 * v7 + 4)) {
            break;
          }
          if (++v8 == 32) {
            goto LABEL_10;
          }
        }
        if (v8 != -1)
        {
          snprintf(__str, 0x80uLL, "%c = %s\n", *(unsigned __int8 *)(a2 + 8 * v7), &UkEvLabelList[36 * (int)v8]);
          fputs(__str, v6);
        }
LABEL_10:
        ++v7;
      }
      while (v7 != a3);
    }
    fclose(v6);
    return 1;
  }
  else
  {
    CFLog();
    return 0;
  }
}

uint64_t getLabelIndex(int a1)
{
  uint64_t result = 0;
  uint64_t v3 = "\n";
  while (1)
  {
    int v4 = *(_DWORD *)v3;
    v3 += 36;
    if (v4 == a1) {
      break;
    }
    if (++result == 32) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

Class __getLSApplicationProxyClass_block_invoke(uint64_t a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v4[0] = 0;
  if (!CoreServicesLibraryCore_frameworkLibrary)
  {
    v4[1] = MEMORY[0x1E4F143A8];
    v4[2] = 3221225472;
    v4[3] = __CoreServicesLibraryCore_block_invoke;
    v4[4] = &__block_descriptor_40_e5_v8__0l;
    v4[5] = v4;
    long long v5 = xmmword_1E6E29648;
    uint64_t v6 = 0;
    CoreServicesLibraryCore_frameworkLibrary = _sl_dlopen();
    uint64_t v2 = (void *)v4[0];
    if (!CoreServicesLibraryCore_frameworkLibrary)
    {
      abort_report_np();
      goto LABEL_7;
    }
    if (v4[0]) {
      goto LABEL_8;
    }
  }
  while (1)
  {
    Class result = objc_getClass("LSApplicationProxy");
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      break;
    }
LABEL_7:
    uint64_t v2 = (void *)abort_report_np();
LABEL_8:
    free(v2);
  }
  getLSApplicationProxyClass_softClass = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __CoreServicesLibraryCore_block_invoke()
{
  uint64_t result = _sl_dlopen();
  CoreServicesLibraryCore_frameworkLibrary = result;
  return result;
}

uint64_t __Block_byref_object_copy__475(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__476(uint64_t a1)
{
}

BOOL NSRangeInRange(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  return a1 <= a3 && a1 + a2 >= a4 + a3;
}

BOOL NSRangeIsValidAndNonZeroLength(uint64_t a1, uint64_t a2)
{
  return a1 != 0x7FFFFFFFFFFFFFFFLL && a2 != 0x7FFFFFFFFFFFFFFFLL && a2 != 0;
}

uint64_t NSRangeEndPosition(uint64_t a1, uint64_t a2)
{
  return a1 + a2;
}

id asMCNearbyKeys(void *a1)
{
  unint64_t v2 = [(id)objc_opt_class() maxNearbyKeysCountDefault];

  return asMCNearbyKeys(a1, v2);
}

id asMCNearbyKeys(void *a1, unint64_t a2)
{
  int v4 = [MEMORY[0x1E4F1CA48] array];
  if (*a1)
  {
    unint64_t v5 = 0;
    uint64_t v6 = a1[1];
    uint64_t v7 = 8 * *a1 - 8;
    do
    {
      uint64_t v8 = *(void *)(*(void *)v6 + 8);
      if (!*(_WORD *)(v8 + 12))
      {
        KB::String::compute_length((unsigned __int16 *)(v8 + 8));
        if (!*(_WORD *)(v8 + 12)) {
          goto LABEL_8;
        }
      }
      uint64_t v9 = [MCNearbyKey alloc];
      uint64_t v10 = *(void *)(v8 + 16);
      if (!v10) {
        uint64_t v10 = v8 + 24;
      }
      uint64_t v17 = v10;
      int v11 = *(unsigned __int16 *)(v8 + 8);
      int v18 = 0;
      int v19 = v11;
      int v20 = 0;
      KB::String::iterator::initialize(&v17);
      LODWORD(v12) = *(_DWORD *)(*(void *)v6 + 32);
      uint64_t v13 = [(MCNearbyKey *)v9 initWithCharacter:(unsigned __int16)v20 logLikelihood:v12];
      [v4 addObject:v13];
      ++v5;

LABEL_8:
      if (v5 >= a2) {
        break;
      }
      v6 += 8;
      uint64_t v14 = v7;
      v7 -= 8;
    }
    while (v14);
  }
  uint64_t v15 = (void *)[v4 copy];

  return v15;
}

void TILXEntryGetSupplementalItemIdentifiers(uint64_t a1@<X8>)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = ICLXEntryGetEntities();
  int v4 = v3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (v3)
  {
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, (unint64_t)(float)(unint64_t)[v3 count]);
    long long v31 = 0u;
    long long v32 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    v28 = v4;
    id v5 = v4;
    uint64_t v6 = [v5 countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (!v6) {
      goto LABEL_47;
    }
    uint64_t v7 = v6;
    uint64_t v8 = *(void *)v30;
    uint64_t v9 = (void *)(a1 + 16);
    while (1)
    {
      for (uint64_t i = 0; i != v7; ++i)
      {
        if (*(void *)v30 != v8) {
          objc_enumerationMutation(v5);
        }
        unint64_t v11 = [*(id *)(*((void *)&v29 + 1) + 8 * i) data];
        unint64_t v12 = v11;
        unint64_t v13 = *(void *)(a1 + 8);
        if (v13)
        {
          uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
          v14.i16[0] = vaddlv_u8(v14);
          if (v14.u32[0] > 1uLL)
          {
            unint64_t v1 = v11;
            if (v11 >= v13) {
              unint64_t v1 = v11 % v13;
            }
          }
          else
          {
            unint64_t v1 = (v13 - 1) & v11;
          }
          uint64_t v15 = *(void **)(*(void *)a1 + 8 * v1);
          if (v15)
          {
            for (j = (void *)*v15; j; j = (void *)*j)
            {
              unint64_t v17 = j[1];
              if (v17 == v11)
              {
                if (j[2] == v11) {
                  goto LABEL_45;
                }
              }
              else
              {
                if (v14.u32[0] > 1uLL)
                {
                  if (v17 >= v13) {
                    v17 %= v13;
                  }
                }
                else
                {
                  v17 &= v13 - 1;
                }
                if (v17 != v1) {
                  break;
                }
              }
            }
          }
        }
        int v18 = operator new(0x18uLL);
        *int v18 = 0;
        v18[1] = v12;
        v18[2] = v12;
        float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
        float v20 = *(float *)(a1 + 32);
        if (!v13 || (float)(v20 * (float)v13) < v19)
        {
          BOOL v21 = (v13 & (v13 - 1)) != 0;
          if (v13 < 3) {
            BOOL v21 = 1;
          }
          unint64_t v22 = v21 | (2 * v13);
          unint64_t v23 = vcvtps_u32_f32(v19 / v20);
          if (v22 <= v23) {
            size_t v24 = v23;
          }
          else {
            size_t v24 = v22;
          }
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v24);
          unint64_t v13 = *(void *)(a1 + 8);
          if ((v13 & (v13 - 1)) != 0)
          {
            if (v12 >= v13) {
              unint64_t v1 = v12 % v13;
            }
            else {
              unint64_t v1 = v12;
            }
          }
          else
          {
            unint64_t v1 = (v13 - 1) & v12;
          }
        }
        uint64_t v25 = *(void *)a1;
        __int16 v26 = *(void **)(*(void *)a1 + 8 * v1);
        if (v26)
        {
          *int v18 = *v26;
LABEL_43:
          *__int16 v26 = v18;
          goto LABEL_44;
        }
        *int v18 = *v9;
        *uint64_t v9 = v18;
        *(void *)(v25 + 8 * v1) = v9;
        if (*v18)
        {
          unint64_t v27 = *(void *)(*v18 + 8);
          if ((v13 & (v13 - 1)) != 0)
          {
            if (v27 >= v13) {
              v27 %= v13;
            }
          }
          else
          {
            v27 &= v13 - 1;
          }
          __int16 v26 = (void *)(*(void *)a1 + 8 * v27);
          goto LABEL_43;
        }
LABEL_44:
        ++*(void *)(a1 + 24);
LABEL_45:
        ;
      }
      uint64_t v7 = [v5 countByEnumeratingWithState:&v29 objects:v33 count:16];
      if (!v7)
      {
LABEL_47:

        int v4 = v28;
        break;
      }
    }
  }
}

uint64_t TILXEntryIsPartOfHyphenatedWord()
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v0 = ICLXEntryGetEntities();
  if (v0)
  {
    unint64_t v1 = ICLXEntryGetTransientLexicon();
    long long v10 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    id v2 = v0;
    uint64_t v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)v11;
      while (2)
      {
        for (uint64_t i = 0; i != v4; ++i)
        {
          if (*(void *)v11 != v5) {
            objc_enumerationMutation(v2);
          }
          uint64_t v7 = *(void *)(*((void *)&v10 + 1) + 8 * i);
          if ((objc_opt_respondsToSelector() & 1) == 0
            || !objc_msgSend(v1, "entityIsHyphenatedWord:", v7, (void)v10))
          {
            uint64_t v8 = 0;
            goto LABEL_15;
          }
        }
        uint64_t v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
        uint64_t v8 = 1;
        if (v4) {
          continue;
        }
        break;
      }
    }
    else
    {
      uint64_t v8 = 1;
    }
LABEL_15:
  }
  else
  {
    uint64_t v8 = 0;
  }

  return v8;
}

uint64_t TI::Favonius::UnigramCandidateGenerator::combined_word_id(TI::Favonius::UnigramCandidateGenerator *this, const KB::Candidate *a2, TITokenID *a3)
{
  uint64_t v3 = (KB::DictionaryContainer *)*((void *)this + 2);
  if (!*((void *)v3 + 4)) {
    return 0;
  }
  uint64_t v4 = *((void *)a2 + 1);
  uint64_t v5 = *(void *)a2 - 1;
  if ((a3[16].word_id & (*(_DWORD *)(v4 + 240 * v5 + 132) >> 12) & 0xFFF) == 0) {
    return 0;
  }
  TITokenID v6 = *(TITokenID *)(v4 + 240 * v5 + 136);
  TITokenID v7 = a3[17];
  return KB::DictionaryContainer::combined_word_id(v3, v6, v7);
}

BOOL TI::Favonius::UnigramCandidateGenerator::should_combine_candidate_and_word(TI::Favonius::UnigramCandidateGenerator *this, const Candidate *a2, const KB::Word *a3)
{
  unsigned int v3 = *(_DWORD *)(*((void *)a2 + 1) + 240 * *(void *)a2 - 108);
  if ((v3 & 0x4000000) != 0) {
    return 1;
  }
  int v4 = *((_DWORD *)a3 + 33);
  return (v4 & 0x4000000) != 0 || (v4 & (v3 >> 12) & 0xFFF) != 0 || *(unsigned char *)(*((void *)this + 2) + 64) != 0;
}

void TI::Favonius::UnigramCandidateGenerator::score_candidate_without_termination(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float v9 = (*(float (**)(uint64_t))(*(void *)a5 + 104))(a5);
  if (*(void *)a4)
  {
    uint64_t v10 = 240 * *(void *)a4;
    long long v11 = (float *)(*(void *)(a4 + 8) + 48);
    float v12 = 1.0;
    do
    {
      float v13 = *v11;
      v11 += 60;
      float v12 = v12 * v13;
      v10 -= 240;
    }
    while (v10);
  }
  else
  {
    float v12 = 1.0;
  }
  float v14 = v9 + logf(v12);
  float v15 = (*(float (**)(uint64_t))(*(void *)a5 + 96))(a5);
  *(float *)(a4 + 748) = a1;
  *(float *)(a4 + 752) = v14;
  *(float *)(a4 + 756) = v15;
  *(float *)(a4 + 760) = a2;
  *(_DWORD *)(a4 + 764) = -8388608;
  float v16 = expf(a1 + (float)(a2 * (float)(v14 + v15)));
  *(float *)(a4 + 744) = logf(v16);
}

void TI::Favonius::UnigramCandidateGenerator::score_candidate(float a1, float a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float v9 = (*(float (**)(uint64_t))(*(void *)a5 + 104))(a5);
  (*(void (**)(uint64_t))(*(void *)a5 + 80))(a5);
  if (*(void *)a4)
  {
    uint64_t v11 = 240 * *(void *)a4;
    float v12 = (float *)(*(void *)(a4 + 8) + 48);
    float v13 = 1.0;
    do
    {
      float v14 = *v12;
      v12 += 60;
      float v13 = v13 * v14;
      v11 -= 240;
    }
    while (v11);
  }
  else
  {
    float v13 = 1.0;
  }
  float v15 = v9 + logf(v10);
  float v16 = v15 + logf(v13);
  float v17 = (*(float (**)(uint64_t))(*(void *)a5 + 96))(a5);
  *(float *)(a4 + 748) = a1;
  *(float *)(a4 + 752) = v16;
  *(float *)(a4 + 756) = v17;
  *(float *)(a4 + 760) = a2;
  *(_DWORD *)(a4 + 764) = -8388608;
  float v18 = expf(a1 + (float)(a2 * (float)(v16 + v17)));
  *(float *)(a4 + 744) = logf(v18);
}

void TI::Favonius::UnigramCandidateGenerator::generate_candidates(uint64_t a1, uint64_t a2, uint64_t a3, KB::CandidateCollection *a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  int v11 = 0;
  memset(v9, 0, sizeof(v9));
  memset(v10, 0, sizeof(v10));
  uint64_t v8 = operator new(0x20uLL);
  void *v8 = &unk_1F3F717B0;
  v8[1] = a1;
  v8[2] = v9;
  v8[3] = a3;
  float v14 = v8;
  (*(void (**)(uint64_t, void *))(*(void *)a2 + 112))(a2, v13);
  if (v14 == v13)
  {
    (*(void (**)(void *))(v13[0] + 32))(v13);
  }
  else if (v14)
  {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  KB::CandidateCollection::add(a4, (const KB::Candidate **)v9);
  float v12 = (void **)&v10[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v12);
  float v12 = (void **)v10;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v12);
  float v12 = (void **)&v9[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v12);
  float v12 = (void **)v9;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v12);
}

uint64_t *KB::CandidateCollection::add(KB::CandidateCollection *this, const KB::Candidate **a2)
{
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this, *((void *)this + 1), *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 3, *((void *)this + 4), a2[3], a2[4], 0x1CAC083126E978D5 * ((a2[4] - a2[3]) >> 3));
  std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 6, *((void *)this + 7), a2[6], a2[7], 0x1CAC083126E978D5 * ((a2[7] - a2[6]) >> 3));
  uint64_t v4 = *((void *)this + 10);
  uint64_t v5 = a2[9];
  TITokenID v6 = a2[10];

  return std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)this + 9, v4, v5, v6, 0x1CAC083126E978D5 * ((v6 - v5) >> 3));
}

uint64_t *std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>(uint64_t *result, uint64_t a2, const KB::Candidate *a3, const KB::Candidate *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  TITokenID v6 = a3;
  uint64_t v7 = a2;
  uint64_t v8 = result;
  float v9 = result + 2;
  uint64_t v10 = result[2];
  unint64_t v11 = result[1];
  if (0x1CAC083126E978D5 * ((uint64_t)(v10 - v11) >> 3) >= a5)
  {
    uint64_t v20 = v11 - a2;
    if (0x1CAC083126E978D5 * ((uint64_t)(v11 - a2) >> 3) >= a5)
    {
      unint64_t v22 = (const KB::Candidate *)((char *)a3 + 1000 * a5);
    }
    else
    {
      unint64_t v22 = (const KB::Candidate *)((char *)a3 + 8 * ((uint64_t)(v11 - a2) >> 3));
      if (v22 == a4)
      {
        uint64_t result = (uint64_t *)result[1];
      }
      else
      {
        unint64_t v23 = (const KB::Candidate *)((char *)a3 + 8 * ((uint64_t)(v11 - a2) >> 3));
        uint64_t result = (uint64_t *)result[1];
        do
        {
          size_t v24 = KB::Candidate::Candidate((KB::Candidate *)result, v23);
          unint64_t v23 = (const KB::Candidate *)((char *)v23 + 1000);
          uint64_t result = (uint64_t *)((char *)v24 + 1000);
        }
        while (v23 != a4);
      }
      v8[1] = (uint64_t)result;
      if (v20 < 1) {
        return result;
      }
    }
    for (uint64_t result = std::vector<KB::Candidate>::__move_range((uint64_t)v8, v7, v11, v7 + 1000 * a5); v6 != v22; v7 += 1000)
    {
      uint64_t result = (uint64_t *)KB::Candidate::operator=(v7, (uint64_t)v6);
      TITokenID v6 = (const KB::Candidate *)((char *)v6 + 1000);
    }
  }
  else
  {
    uint64_t v12 = *result;
    unint64_t v13 = a5 + 0x1CAC083126E978D5 * ((uint64_t)(v11 - *result) >> 3);
    if (v13 > 0x4189374BC6A7EFLL) {
      abort();
    }
    uint64_t v14 = 0x1CAC083126E978D5 * ((a2 - v12) >> 3);
    unint64_t v15 = 0x1CAC083126E978D5 * ((v10 - v12) >> 3);
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v13) {
      uint64_t v16 = v13;
    }
    if (v15 >= 0x20C49BA5E353F7) {
      unint64_t v17 = 0x4189374BC6A7EFLL;
    }
    else {
      unint64_t v17 = v16;
    }
    v28[4] = v9;
    if (v17)
    {
      float v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v17);
    }
    else
    {
      float v19 = 0;
      uint64_t v18 = 0;
    }
    uint64_t v25 = (KB::Candidate *)&v19[1000 * v14];
    v28[0] = v19;
    v28[1] = v25;
    v28[3] = &v19[1000 * v18];
    uint64_t v26 = 1000 * a5;
    unint64_t v27 = (char *)v25 + 1000 * a5;
    do
    {
      uint64_t v25 = (KB::Candidate *)((char *)KB::Candidate::Candidate(v25, v6) + 1000);
      TITokenID v6 = (const KB::Candidate *)((char *)v6 + 1000);
      v26 -= 1000;
    }
    while (v26);
    v28[2] = v27;
    std::vector<KB::Candidate>::__swap_out_circular_buffer(v8, v28, v7);
    return (uint64_t *)std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v28);
  }
  return result;
}

uint64_t *std::vector<KB::Candidate>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = v7 - a4;
  unint64_t v9 = a2 + v7 - a4;
  if (v9 >= a3)
  {
    uint64_t result = *(uint64_t **)(a1 + 8);
  }
  else
  {
    uint64_t result = *(uint64_t **)(a1 + 8);
    do
    {
      uint64_t v12 = KB::Candidate::Candidate((uint64_t)result, v9);
      v9 += 1000;
      uint64_t result = (uint64_t *)(v12 + 1000);
    }
    while (v9 < a3);
  }
  *(void *)(a1 + 8) = result;
  if (v7 != a4)
  {
    uint64_t result = (uint64_t *)(v7 - 1000);
    uint64_t v13 = 8 * (v8 >> 3);
    uint64_t v14 = a2 - 1000;
    do
    {
      uint64_t result = KB::Candidate::operator=(result, (uint64_t *)(v14 + v13)) - 125;
      v13 -= 1000;
    }
    while (v13);
  }
  return result;
}

uint64_t std::vector<KB::Candidate>::__swap_out_circular_buffer(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = a2[1];
  uint64_t v7 = *a1;
  uint64_t v8 = v6;
  if (v7 != a3)
  {
    uint64_t v9 = a3;
    uint64_t v8 = a2[1];
    do
    {
      v9 -= 1000;
      uint64_t v8 = KB::Candidate::Candidate(v8 - 1000, v9);
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v10 = a1[1];
  uint64_t v11 = a2[2];
  if (v10 != v3)
  {
    do
    {
      KB::Candidate::Candidate(v11, v3);
      v3 += 1000;
      v11 += 1000;
    }
    while (v3 != v10);
    uint64_t v8 = a2[1];
  }
  a2[2] = v11;
  uint64_t v12 = *a1;
  *a1 = v8;
  a2[1] = v12;
  uint64_t v13 = a1[1];
  a1[1] = a2[2];
  a2[2] = v13;
  uint64_t v14 = a1[2];
  a1[2] = a2[3];
  a2[3] = v14;
  *a2 = a2[1];
  return v6;
}

uint64_t KB::Candidate::operator=(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    unint64_t v4 = *(void *)a1;
    unint64_t v5 = *(void *)a2;
    if (*(void *)a1 <= *(void *)a2)
    {
      BOOL v9 = v5 > *(void *)(a1 + 16);
      unint64_t v5 = *(void *)a1;
      if (v9)
      {
        WTF::Vector<KB::Word,3ul>::shrinkCapacity((void *)a1);
        WTF::Vector<KB::Word,3ul>::reserveCapacity((void *)a1, *(void *)a2);
        if (!*(void *)(a1 + 8)) {
          goto LABEL_22;
        }
        unint64_t v5 = *(void *)a1;
      }
    }
    else
    {
      uint64_t v6 = (KB::Word *)(*(void *)(a1 + 8) + 240 * v5);
      uint64_t v7 = -240 * v5 + 240 * v4;
      do
      {
        KB::Word::~Word(v6);
        uint64_t v6 = (KB::Word *)(v8 + 240);
        v7 -= 240;
      }
      while (v7);
      *(void *)a1 = v5;
    }
    uint64_t v10 = *(void *)(a2 + 8);
    if (v5)
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)(a1 + 8);
      uint64_t v13 = 240 * v5;
      do
      {
        uint64_t v14 = v12 + v11;
        uint64_t v15 = v10 + v11;
        KB::String::operator=((KB::String *)(v12 + v11), (KB::String *)(v10 + v11));
        KB::ByteString::operator=((unsigned __int16 *)(v12 + v11 + 32), (unsigned __int16 *)(v10 + v11 + 32));
        uint64_t v16 = *(void *)(v10 + v11 + 48);
        *(_DWORD *)(v14 + 56) = *(_DWORD *)(v10 + v11 + 56);
        *(void *)(v14 + 48) = v16;
        KB::String::operator=((KB::String *)(v12 + v11 + 64), (KB::String *)(v10 + v11 + 64));
        long long v17 = *(_OWORD *)(v10 + v11 + 96);
        long long v18 = *(_OWORD *)(v10 + v11 + 112);
        long long v19 = *(_OWORD *)(v10 + v11 + 144);
        *(_OWORD *)(v14 + 128) = *(_OWORD *)(v10 + v11 + 128);
        *(_OWORD *)(v14 + 144) = v19;
        *(_OWORD *)(v14 + 96) = v17;
        *(_OWORD *)(v14 + 112) = v18;
        KB::String::operator=((KB::String *)(v12 + v11 + 160), (KB::String *)(v10 + v11 + 160));
        *(unsigned char *)(v14 + 192) = *(unsigned char *)(v10 + v11 + 192);
        if (v10 != v12)
        {
          *(_DWORD *)(v14 + 232) = *(_DWORD *)(v15 + 232);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(v14 + 200), *(void **)(v15 + 216));
        }
        v11 += 240;
      }
      while (v13 != v11);
      uint64_t v10 = *(void *)(a2 + 8);
      unint64_t v20 = *(void *)a1;
    }
    else
    {
      unint64_t v20 = 0;
    }
    if (v20 != *(void *)a2)
    {
      uint64_t v21 = 240 * v20;
      unint64_t v22 = (KB::Word *)(*(void *)(a1 + 8) + v21);
      unint64_t v23 = (size_t *)(v10 + v21);
      uint64_t v24 = 240 * *(void *)a2 - v21;
      do
      {
        unint64_t v22 = (KB::Word *)((char *)KB::Word::Word(v22, v23) + 240);
        v23 += 30;
        v24 -= 240;
      }
      while (v24);
      unint64_t v20 = *(void *)a2;
    }
    *(void *)a1 = v20;
  }
LABEL_22:
  *(_DWORD *)(a1 + 744) = *(_DWORD *)(a2 + 744);
  long long v25 = *(_OWORD *)(a2 + 748);
  *(_OWORD *)(a1 + 760) = *(_OWORD *)(a2 + 760);
  *(_OWORD *)(a1 + 748) = v25;
  *(void *)(a1 + 776) = *(void *)(a2 + 776);
  KB::LanguageModelContext::operator=(a1 + 784, (uint64_t *)(a2 + 784));
  KB::String::operator=((KB::String *)(a1 + 888), (KB::String *)(a2 + 888));
  std::string::operator=((std::string *)(a1 + 920), (const std::string *)(a2 + 920));
  KB::ByteString::operator=((unsigned __int16 *)(a1 + 944), (unsigned __int16 *)(a2 + 944));
  *(_OWORD *)(a1 + 960) = *(_OWORD *)(a2 + 960);
  KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + 976), *(CFTypeRef *)(a2 + 976));
  uint64_t v26 = *(const void **)(a2 + 984);
  unint64_t v27 = *(const void **)(a1 + 984);
  if (v27 != v26)
  {
    if (v26)
    {
      CFRetain(*(CFTypeRef *)(a2 + 984));
      unint64_t v27 = *(const void **)(a1 + 984);
    }
    if (v27) {
      CFRelease(v27);
    }
    *(void *)(a1 + 984) = v26;
  }
  *(_DWORD *)(a1 + 992) = *(_DWORD *)(a2 + 992);
  return a1;
}

uint64_t KB::LanguageModelContext::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v7 = *(char **)(a1 + 16);
    uint64_t v8 = (char *)a2[2];
    BOOL v9 = (unsigned char *)a2[3];
    size_t v10 = v9 - v8;
    unint64_t v11 = (v9 - v8) >> 3;
    uint64_t v12 = *(void *)(a1 + 32);
    if (v11 <= (v12 - (uint64_t)v7) >> 3)
    {
      uint64_t v15 = *(unsigned char **)(a1 + 24);
      unint64_t v16 = (v15 - v7) >> 3;
      if (v16 < v11)
      {
        long long v17 = &v8[8 * v16];
        if (v15 != v7)
        {
          memmove(*(void **)(a1 + 16), (const void *)a2[2], v15 - v7);
          uint64_t v7 = *(char **)(a1 + 24);
        }
        size_t v10 = v9 - v17;
        if (v9 == v17) {
          goto LABEL_25;
        }
        long long v18 = v7;
        long long v19 = v17;
        goto LABEL_24;
      }
    }
    else
    {
      if (v7)
      {
        *(void *)(a1 + 24) = v7;
        operator delete(v7);
        uint64_t v12 = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)(a1 + 24) = 0;
        *(void *)(a1 + 32) = 0;
      }
      if ((v10 & 0x8000000000000000) != 0) {
        abort();
      }
      uint64_t v13 = v12 >> 2;
      if (v12 >> 2 <= v11) {
        uint64_t v13 = (v9 - v8) >> 3;
      }
      if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v13;
      }
      std::vector<TITokenID>::__vallocate[abi:nn180100]((void *)(a1 + 16), v14);
      uint64_t v7 = *(char **)(a1 + 24);
    }
    if (v9 == v8)
    {
LABEL_25:
      *(void *)(a1 + 24) = &v7[v10];
      long long v20 = *(_OWORD *)(a2 + 5);
      *(void *)(a1 + 56) = a2[7];
      *(_OWORD *)(a1 + 40) = v20;
      language_modeling::v1::LinguisticContext::operator=();
      language_modeling::v1::LinguisticContext::operator=();
      std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>((std::vector<std::string> *)(a1 + 80), (std::string *)a2[10], (std::string *)a2[11], 0xAAAAAAAAAAAAAAABLL * ((a2[11] - a2[10]) >> 3));
      return a1;
    }
    long long v18 = v7;
    long long v19 = v8;
LABEL_24:
    memmove(v18, v19, v10);
    goto LABEL_25;
  }
  language_modeling::v1::LinguisticContext::operator=();
  language_modeling::v1::LinguisticContext::operator=();
  return a1;
}

const void **KB::retain_ptr<__CFDictionary const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3 = *a1;
  if (v3 != cf)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v3 = *a1;
    }
    if (v3) {
      CFRelease(v3);
    }
    *a1 = cf;
  }
  return a1;
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string*,std::string*>(std::vector<std::string> *this, std::string *__str, std::string *a3, unint64_t a4)
{
  uint64_t v6 = __str;
  begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) < a4)
  {
    std::vector<std::string>::__vdeallocate(this);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0x5555555555555556 * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_cap_.__value_ - (char *)this->__begin_) >> 3) >= 0x555555555555555) {
      unint64_t v10 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<std::string>::__vallocate[abi:nn180100](this, v10);
    end = this->__end_;
    uint64_t v12 = (long long *)v6;
    uint64_t v13 = (long long *)a3;
LABEL_15:
    this->__end_ = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string*,std::string*,std::string*>(v12, v13, end);
    return;
  }
  std::vector<std::string>::pointer v14 = this->__end_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)v14 - (char *)begin) >> 3) < a4)
  {
    uint64_t v15 = (long long *)(&__str->__r_.__value_.__l.__data_ + (((char *)v14 - (char *)begin) >> 3));
    if (v14 != begin)
    {
      uint64_t v16 = 8 * (((char *)v14 - (char *)begin) >> 3);
      do
      {
        std::string::operator=(begin++, v6++);
        v16 -= 24;
      }
      while (v16);
      begin = this->__end_;
    }
    uint64_t v12 = v15;
    uint64_t v13 = (long long *)a3;
    end = begin;
    goto LABEL_15;
  }
  if (__str != a3)
  {
    do
      std::string::operator=(begin++, v6++);
    while (v6 != a3);
    std::vector<std::string>::pointer v14 = this->__end_;
  }
  while (v14 != begin)
  {
    if (SHIBYTE(v14[-1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v14[-1].__r_.__value_.__l.__data_);
    }
    --v14;
  }
  this->__end_ = begin;
}

void std::vector<std::string>::__vdeallocate(std::vector<std::string> *this)
{
  if (this->__begin_)
  {
    std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this);
    operator delete(this->__begin_);
    this->__begin_ = 0;
    this->__end_ = 0;
    this->__end_cap_.__value_ = 0;
  }
}

void KB::Word::~Word(KB::Word *this)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)this + 200);
  id v2 = (void *)*((void *)this + 21);
  if (v2 && *((unsigned char *)this + 166) == 1) {
    free(v2);
  }
  CFTypeRef v3 = (void *)*((void *)this + 9);
  if (v3 && *((unsigned char *)this + 70) == 1) {
    free(v3);
  }
  if (*((unsigned __int16 *)this + 16) >= 0xFu)
  {
    uint64_t v4 = *((void *)this + 5);
    if (v4) {
      MEMORY[0x1E4E7BC00](v4, 0x1000C8077774924);
    }
  }
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    if (*((unsigned char *)this + 6) == 1) {
      free(v5);
    }
  }
}

void *WTF::Vector<KB::Word,3ul>::shrinkCapacity(void *result)
{
  if (result[2])
  {
    unint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      CFTypeRef v3 = (KB::Word *)result[1];
      uint64_t v4 = 240 * v2;
      do
      {
        KB::Word::~Word(v3);
        CFTypeRef v3 = (KB::Word *)(v5 + 240);
        v4 -= 240;
      }
      while (v4);
      void *v1 = 0;
    }
    uint64_t v6 = v1 + 1;
    uint64_t result = (void *)v1[1];
    if (v1 + 3 != result)
    {
      *uint64_t v6 = 0;
      v1[2] = 0;
      free(result);
      uint64_t result = (void *)*v6;
    }
    if (!result)
    {
      v1[1] = v1 + 3;
      v1[2] = 3;
    }
  }
  return result;
}

void WTF::Vector<KB::Word,3ul>::reserveCapacity(void *a1, unint64_t a2)
{
  if (a1[2] >= a2) {
    return;
  }
  uint64_t v4 = (void **)(a1 + 1);
  CFTypeRef v3 = (size_t *)a1[1];
  uint64_t v5 = *a1;
  if (a2 <= 3)
  {
    uint64_t v6 = (KB::Word *)(a1 + 3);
    a1[1] = a1 + 3;
    a1[2] = 3;
    if (!v5) {
      goto LABEL_9;
    }
    goto LABEL_7;
  }
  a1[2] = a2;
  uint64_t v6 = (KB::Word *)malloc_type_malloc(240 * a2, 0x10B2040DF775671uLL);
  a1[1] = v6;
  if (v6 && v5)
  {
LABEL_7:
    uint64_t v7 = 240 * v5;
    uint64_t v8 = v3;
    do
    {
      KB::Word::Word(v6, v8);
      KB::Word::~Word((KB::Word *)v8);
      uint64_t v6 = (KB::Word *)((char *)v6 + 240);
      v8 += 30;
      v7 -= 240;
    }
    while (v7);
  }
LABEL_9:
  if (a1 + 3 != v3)
  {
    if (*v4 == v3)
    {
      *uint64_t v4 = 0;
      v4[1] = 0;
    }
    free(v3);
  }
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  uint64_t v6 = (void *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      unint64_t v7 = a2[2];
      v6[2] = v7;
      uint64_t v8 = (void *)*v6;
      v6[1] = v7;
      inserted = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v7, v6 + 2);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v6, inserted);
      a2 = (void *)*a2;
      uint64_t v6 = v8;
      if (!v8) {
        goto LABEL_7;
      }
    }
    do
    {
      uint64_t v13 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v13;
    }
    while (v13);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      unint64_t v10 = operator new(0x18uLL);
      void *v10 = 0;
      unint64_t v11 = a2[2];
      v10[2] = v11;
      v10[1] = v11;
      uint64_t v12 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare((uint64_t)a1, v11, v10 + 2);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(a1, v10, v12);
      a2 = (void *)*a2;
    }
  }
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    BOOL v9 = 1;
    if (v6 >= 3) {
      BOOL v9 = (v6 & (v6 - 1)) != 0;
    }
    unint64_t v10 = v9 | (2 * v6);
    unint64_t v11 = vcvtps_u32_f32(v7 / v8);
    if (v10 <= v11) {
      int8x8_t prime = (int8x8_t)v11;
    }
    else {
      int8x8_t prime = (int8x8_t)v10;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v6 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v6) {
      goto LABEL_74;
    }
    if (*(void *)&prime >= v6) {
      goto LABEL_43;
    }
    unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v6 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
    {
      unint64_t v19 = std::__next_prime(v19);
    }
    else
    {
      uint64_t v21 = 1 << -(char)__clz(v19 - 1);
      if (v19 >= 2) {
        unint64_t v19 = v21;
      }
    }
    if (*(void *)&prime <= v19) {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime >= v6)
    {
      unint64_t v6 = *(void *)(a1 + 8);
      goto LABEL_43;
    }
    if (prime)
    {
LABEL_74:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = operator new(8 * *(void *)&prime);
      std::vector<std::string>::pointer v14 = *(void **)a1;
      *(void *)a1 = v13;
      if (v14) {
        operator delete(v14);
      }
      uint64_t v15 = 0;
      *(int8x8_t *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v15++) = 0;
      while (*(void *)&prime != v15);
      uint64_t v16 = *(void **)(a1 + 16);
      if (v16)
      {
        unint64_t v17 = v16[1];
        uint8x8_t v18 = (uint8x8_t)vcnt_s8(prime);
        v18.i16[0] = vaddlv_u8(v18);
        if (v18.u32[0] > 1uLL)
        {
          if (v17 >= *(void *)&prime) {
            v17 %= *(void *)&prime;
          }
        }
        else
        {
          v17 &= *(void *)&prime - 1;
        }
        *(void *)(*(void *)a1 + 8 * v17) = a1 + 16;
        for (uint64_t i = (void *)*v16; *v16; uint64_t i = (void *)*v16)
        {
          unint64_t v23 = i[1];
          if (v18.u32[0] > 1uLL)
          {
            if (v23 >= *(void *)&prime) {
              v23 %= *(void *)&prime;
            }
          }
          else
          {
            v23 &= *(void *)&prime - 1;
          }
          if (v23 == v17)
          {
            uint64_t v16 = i;
          }
          else
          {
            uint64_t v24 = i;
            if (*(void *)(*(void *)a1 + 8 * v23))
            {
              do
              {
                long long v25 = v24;
                uint64_t v24 = (void *)*v24;
              }
              while (v24 && i[2] == v24[2]);
              *uint64_t v16 = v24;
              *long long v25 = **(void **)(*(void *)a1 + 8 * v23);
              **(void **)(*(void *)a1 + 8 * v23) = i;
            }
            else
            {
              *(void *)(*(void *)a1 + 8 * v23) = v16;
              uint64_t v16 = i;
              unint64_t v17 = v23;
            }
          }
        }
      }
      unint64_t v6 = (unint64_t)prime;
    }
    else
    {
      __int16 v35 = *(void **)a1;
      *(void *)a1 = 0;
      if (v35) {
        operator delete(v35);
      }
      unint64_t v6 = 0;
      *(void *)(a1 + 8) = 0;
    }
  }
LABEL_43:
  uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    unint64_t v27 = a2;
    if (v6 <= a2) {
      unint64_t v27 = a2 % v6;
    }
  }
  else
  {
    unint64_t v27 = (v6 - 1) & a2;
  }
  v28 = *(void **)(*(void *)a1 + 8 * v27);
  if (!v28) {
    return 0;
  }
  int v29 = 0;
  do
  {
    uint64_t result = v28;
    v28 = (void *)*v28;
    if (!v28) {
      break;
    }
    unint64_t v31 = v28[1];
    if (v26.u32[0] > 1uLL)
    {
      unint64_t v32 = v28[1];
      if (v31 >= v6) {
        unint64_t v32 = v31 % v6;
      }
    }
    else
    {
      unint64_t v32 = v31 & (v6 - 1);
    }
    if (v32 != v27) {
      break;
    }
    BOOL v33 = v31 == a2 && v28[2] == *a3;
    int v34 = v29 & !v33;
    v29 |= v33;
  }
  while (v34 != 1);
  return result;
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__node_insert_multi_perform(void *result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)result[1];
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  if (!a3)
  {
    *a2 = result[2];
    result[2] = a2;
    *(void *)(*result + 8 * v4) = result + 2;
    if (!*a2) {
      goto LABEL_19;
    }
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
LABEL_18:
    *(void *)(*result + 8 * v6) = a2;
    goto LABEL_19;
  }
  *a2 = *a3;
  *a3 = a2;
  if (*a2)
  {
    unint64_t v6 = *(void *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v6 >= *(void *)&v3) {
        v6 %= *(void *)&v3;
      }
    }
    else
    {
      v6 &= *(void *)&v3 - 1;
    }
    if (v6 != v4) {
      goto LABEL_18;
    }
  }
LABEL_19:
  ++result[3];
  return result;
}

uint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int8x8_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *KB::Candidate::operator=(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  *a1 = *a2;
  *a2 = v4;
  WTF::VectorBuffer<KB::Word,3ul>::swap(a1 + 1, a2 + 1);
  long long v5 = *(_OWORD *)(a2 + 93);
  long long v6 = *(_OWORD *)(a2 + 95);
  a1[97] = a2[97];
  *(_OWORD *)(a1 + 93) = v5;
  *(_OWORD *)(a1 + 95) = v6;
  long long v7 = *((_OWORD *)a2 + 49);
  *((_OWORD *)a2 + 49) = 0u;
  float v8 = (std::__shared_weak_count *)a1[99];
  *((_OWORD *)a1 + 49) = v7;
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v8);
  }
  BOOL v9 = (void *)a1[100];
  if (v9)
  {
    a1[101] = (uint64_t)v9;
    operator delete(v9);
    a1[100] = 0;
    a1[101] = 0;
    a1[102] = 0;
  }
  *((_OWORD *)a1 + 50) = *((_OWORD *)a2 + 50);
  a1[102] = a2[102];
  a2[100] = 0;
  a2[101] = 0;
  a2[102] = 0;
  long long v10 = *(_OWORD *)(a2 + 103);
  a1[105] = a2[105];
  *(_OWORD *)(a1 + 103) = v10;
  language_modeling::v1::LinguisticContext::operator=();
  language_modeling::v1::LinguisticContext::operator=();
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)a1 + 36);
  *((_OWORD *)a1 + 54) = *((_OWORD *)a2 + 54);
  a1[110] = a2[110];
  a2[109] = 0;
  a2[108] = 0;
  a2[110] = 0;
  KB::String::operator=((uint64_t)(a1 + 111), (KB::String *)(a2 + 111));
  unint64_t v11 = (void **)(a1 + 115);
  if (*((char *)a1 + 943) < 0) {
    operator delete(*v11);
  }
  long long v12 = *(_OWORD *)(a2 + 115);
  a1[117] = a2[117];
  *(_OWORD *)unint64_t v11 = v12;
  *((unsigned char *)a2 + 943) = 0;
  *((unsigned char *)a2 + 920) = 0;
  KB::ByteString::operator=((unsigned __int16 *)a1 + 472, (unsigned __int16 *)a2 + 472);
  *((_OWORD *)a1 + 60) = *((_OWORD *)a2 + 60);
  uint64_t v13 = (const void *)a1[122];
  if (v13) {
    CFRelease(v13);
  }
  a1[122] = 0;
  uint64_t v14 = a2[122];
  a2[122] = 0;
  a1[122] = v14;
  uint64_t v15 = (const void *)a1[123];
  if (v15) {
    CFRelease(v15);
  }
  a1[123] = 0;
  uint64_t v16 = a2[123];
  a2[123] = 0;
  a1[123] = v16;
  *((_DWORD *)a1 + 248) = *((_DWORD *)a2 + 248);
  return a1;
}

void std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)*a2 + 176))(*a2);
  int v6 = v5;
  int64_t v51 = 0;
  v52 = 0;
  uint64_t v53 = 0;
  TI::Favonius::UnigramCandidateGenerator::words_for_input_segment(v5, v3, v7, (uint64_t *)&v51);
  int64x2_t v49 = 0uLL;
  unint64_t v50 = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 136))(v3);
  uint64_t v48 = a1;
  if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 144))(v8))
  {
    long long v10 = v51;
    for (uint64_t i = v52; v10 != i; v10 += 30)
    {
      KB::Word::Word((KB::Word *)&v62, v10);
      if ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 168))(v3))
      {
        unint64_t v67 = 0;
      }
      else if ((v66 & 0x80060100) == 0 && HIDWORD(v67) == 0 && v68 == 0)
      {
        v66 |= 4u;
      }
      if (v49.i64[1] >= v50)
      {
        unint64_t v14 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
        if (v14 > 0x4189374BC6A7EFLL) {
          goto LABEL_89;
        }
        if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v14) {
          unint64_t v14 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
        }
        if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7) {
          unint64_t v15 = 0x4189374BC6A7EFLL;
        }
        else {
          unint64_t v15 = v14;
        }
        v72 = &v50;
        if (v15) {
          unint64_t v15 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v15);
        }
        else {
          uint64_t v16 = 0;
        }
        unint64_t v17 = (KB::Candidate *)(v15 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
        size_t v69 = v15;
        v70.i64[0] = (uint64_t)v17;
        unint64_t v71 = v15 + 1000 * v16;
        KB::Candidate::Candidate(v17, (size_t *)&v62);
        uint64_t v13 = (char *)v17 + 1000;
        v70.i64[1] = (uint64_t)v17 + 1000;
        uint64_t v18 = v49.i64[1];
        uint64_t v19 = v70.i64[0];
        if (v49.i64[1] == v49.i64[0])
        {
          int64x2_t v20 = vdupq_n_s64(v49.u64[1]);
        }
        else
        {
          do
          {
            v18 -= 1000;
            uint64_t v19 = KB::Candidate::Candidate(v19 - 1000, v18);
          }
          while (v18 != v49.i64[0]);
          int64x2_t v20 = v49;
          uint64_t v13 = (char *)v70.i64[1];
        }
        v49.i64[0] = v19;
        v49.i64[1] = (uint64_t)v13;
        int64x2_t v70 = v20;
        unint64_t v21 = v50;
        unint64_t v50 = v71;
        unint64_t v71 = v21;
        size_t v69 = v20.i64[0];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v69);
      }
      else
      {
        uint64_t v13 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (size_t *)&v62) + 1000;
      }
      v49.i64[1] = (uint64_t)v13;
      KB::LanguageModelContext::operator=((uint64_t)(v13 - 216), *(uint64_t **)(v48 + 24));
      if (v6) {
        *(unsigned char *)(v49.i64[1] - 38) = 1;
      }
      KB::Word::~Word((KB::Word *)&v62);
    }
  }
  else
  {
    unint64_t v22 = *(uint64_t ***)(a1 + 16);
    unint64_t v23 = *v22;
    v47 = v22[1];
    if (*v22 != v47)
    {
      do
      {
        long long v25 = v51;
        for (j = v52; v25 != j; v25 += 30)
        {
          KB::Word::Word((KB::Word *)&v69, v25);
          if ((*(unsigned int (**)(uint64_t, uint64_t *, size_t *))(*(void *)v4 + 40))(v4, v23, &v69))
          {
            unint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t *, size_t *))(*(void *)v4 + 48))(v4, v23, &v69);
            if (HIDWORD(v26))
            {
              TITokenID v27 = (TITokenID)v26;
              KB::Candidate::Candidate((KB::Candidate *)&v62, (const KB::Candidate *)v23);
              KB::Word::Word((KB::Word *)v58, (size_t *)(v23[1] + 240 * *v23 - 240));
              TITokenID v28 = v27;
              KB::Word::append_suffix((KB::Word *)v58, (const KB::Word *)v25, 0, v28);
              KB::Candidate::pop_last_word((KB::Candidate *)&v62);
              if ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 168))(v3))
              {
                unint64_t v60 = 0;
              }
              else if ((v59 & 0x80060100) == 0 && !HIDWORD(v60) && !v61)
              {
                v59 |= 4u;
              }
              if (v49.i64[1] >= v50)
              {
                unint64_t v33 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
                if (v33 > 0x4189374BC6A7EFLL) {
LABEL_89:
                }
                  abort();
                if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v33) {
                  unint64_t v33 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
                }
                if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7) {
                  unint64_t v34 = 0x4189374BC6A7EFLL;
                }
                else {
                  unint64_t v34 = v33;
                }
                float v57 = &v50;
                if (v34) {
                  unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v34);
                }
                else {
                  uint64_t v35 = 0;
                }
                v40 = (KB::Candidate *)(v34 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
                unint64_t v54 = v34;
                v55.i64[0] = (uint64_t)v40;
                unint64_t v56 = v34 + 1000 * v35;
                KB::Candidate::Candidate(v40, (const KB::Candidate *)&v62, v58);
                int v29 = (char *)v40 + 1000;
                v55.i64[1] = (uint64_t)v40 + 1000;
                uint64_t v41 = v49.i64[1];
                uint64_t v42 = v55.i64[0];
                if (v49.i64[1] == v49.i64[0])
                {
                  int64x2_t v43 = vdupq_n_s64(v49.u64[1]);
                }
                else
                {
                  do
                  {
                    v41 -= 1000;
                    uint64_t v42 = KB::Candidate::Candidate(v42 - 1000, v41);
                  }
                  while (v41 != v49.i64[0]);
                  int64x2_t v43 = v49;
                  int v29 = (char *)v55.i64[1];
                }
                v49.i64[0] = v42;
                v49.i64[1] = (uint64_t)v29;
                int64x2_t v55 = v43;
                unint64_t v45 = v50;
                unint64_t v50 = v56;
                unint64_t v56 = v45;
                unint64_t v54 = v43.i64[0];
                std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v54);
              }
              else
              {
                int v29 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (const KB::Candidate *)&v62, v58)
                    + 1000;
              }
              v49.i64[1] = (uint64_t)v29;
              KB::Word::~Word((KB::Word *)v58);
              KB::Candidate::~Candidate((KB::Candidate *)&v62);
            }
            else
            {
              if ((*(uint64_t (**)(uint64_t))(*(void *)v3 + 168))(v3))
              {
                unint64_t v74 = 0;
              }
              else if ((v73 & 0x80060100) == 0 && !HIDWORD(v74) && !v75)
              {
                v73 |= 4u;
              }
              if (v49.i64[1] >= v50)
              {
                unint64_t v30 = 0x1CAC083126E978D5 * ((v49.i64[1] - v49.i64[0]) >> 3) + 1;
                if (v30 > 0x4189374BC6A7EFLL) {
                  goto LABEL_89;
                }
                if (0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3) > v30) {
                  unint64_t v30 = 0x395810624DD2F1AALL * ((uint64_t)(v50 - v49.i64[0]) >> 3);
                }
                if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v50 - v49.i64[0]) >> 3)) >= 0x20C49BA5E353F7) {
                  unint64_t v31 = 0x4189374BC6A7EFLL;
                }
                else {
                  unint64_t v31 = v30;
                }
                v65 = &v50;
                if (v31) {
                  unint64_t v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v31);
                }
                else {
                  uint64_t v32 = 0;
                }
                __int16 v36 = (KB::Candidate *)(v31 + 8 * ((v49.i64[1] - v49.i64[0]) >> 3));
                float v62 = (int64x2_t *)v31;
                v63.i64[0] = (uint64_t)v36;
                unint64_t v64 = v31 + 1000 * v32;
                KB::Candidate::Candidate(v36, (const KB::Candidate *)v23, &v69);
                int v29 = (char *)v36 + 1000;
                v63.i64[1] = (uint64_t)v36 + 1000;
                uint64_t v37 = v49.i64[1];
                uint64_t v38 = v63.i64[0];
                if (v49.i64[1] == v49.i64[0])
                {
                  int64x2_t v39 = vdupq_n_s64(v49.u64[1]);
                }
                else
                {
                  do
                  {
                    v37 -= 1000;
                    uint64_t v38 = KB::Candidate::Candidate(v38 - 1000, v37);
                  }
                  while (v37 != v49.i64[0]);
                  int64x2_t v39 = v49;
                  int v29 = (char *)v63.i64[1];
                }
                v49.i64[0] = v38;
                v49.i64[1] = (uint64_t)v29;
                int64x2_t v63 = v39;
                unint64_t v44 = v50;
                unint64_t v50 = v64;
                unint64_t v64 = v44;
                float v62 = (int64x2_t *)v39.i64[0];
                std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v62);
              }
              else
              {
                int v29 = (char *)KB::Candidate::Candidate((KB::Candidate *)v49.i64[1], (const KB::Candidate *)v23, &v69)
                    + 1000;
              }
              v49.i64[1] = (uint64_t)v29;
            }
            KB::LanguageModelContext::operator=((uint64_t)(v29 - 216), v23 + 98);
            if (v6) {
              *(unsigned char *)(v49.i64[1] - 38) = 1;
            }
          }
          KB::Word::~Word((KB::Word *)&v69);
        }
        v23 += 125;
      }
      while (v23 != v47);
    }
  }
  uint64_t v46 = *(void *)(v48 + 16);
  std::vector<KB::Candidate>::__vdeallocate((void **)v46);
  *(int64x2_t *)uint64_t v46 = v49;
  *(void *)(v46 + 16) = v50;
  int64x2_t v49 = 0uLL;
  unint64_t v50 = 0;
  float v62 = &v49;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v62);
  float v62 = (int64x2_t *)&v51;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v62);
}

uint64_t TI::Favonius::UnigramCandidateGenerator::words_for_input_segment(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a2 + 128))(a2, a4);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 168))(a2);
  uint64_t v7 = *a4;
  if (result)
  {
    *(void *)(v7 + 136) = 0;
  }
  else
  {
    for (uint64_t i = a4[1]; v7 != i; v7 += 240)
    {
      int v9 = *(_DWORD *)(v7 + 104);
      if ((v9 & 0x40000) == 0
        && (v9 & 0x80020100) == 0
        && HIDWORD(*(void *)(v7 + 136)) == 0
        && !*(void *)(v7 + 224))
      {
        *(_DWORD *)(v7 + 104) = v9 | 4;
      }
    }
  }
  return result;
}

void std::vector<KB::Candidate>::__vdeallocate(void **a1)
{
  unint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v1;
    if (v3 != v1)
    {
      do
        KB::Candidate::~Candidate((KB::Candidate *)(v3 - 1000));
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        KB::Word::~Word((KB::Word *)(v4 - 240));
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this, size_t *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1E4154B40;
  *((void *)this + 95) = 0xFF8000003F800000;
  *((void *)this + 105) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 848));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((void *)this + 109) = 0;
  *((void *)this + 108) = 0;
  *((void *)this + 110) = 0;
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((unsigned char *)this + 894) = 0;
  *((void *)this + 112) = 0;
  *((unsigned char *)this + 904) = 0;
  *((void *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((unsigned char *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  KB::Candidate::append((unsigned __int16 *)this, a2);
  return this;
}

__n128 std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F717B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F717B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0,std::allocator<TI::Favonius::UnigramCandidateGenerator::generate_candidates(TI::Favonius::TypingHypothesis const*,KB::LanguageModelContext const&,KB::CandidateCollection &)::$_0>,void ()(TI::Favonius::TypingHypothesis const*)>::~__func()
{
}

void TI::Favonius::UnigramCandidateGenerator::~UnigramCandidateGenerator(TI::Favonius::UnigramCandidateGenerator *this)
{
  *(void *)this = &unk_1F3F71768;
  unint64_t v1 = (unsigned int *)*((void *)this + 2);
  if (v1) {
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
  }

  JUMPOUT(0x1E4E7BC20);
}

{
  unsigned int *v1;

  *(void *)this = &unk_1F3F71768;
  unint64_t v1 = (unsigned int *)*((void *)this + 2);
  if (v1) {
    WTF::RefCounted<KB::DictionaryContainer>::deref(v1);
  }
}

unsigned int *WTF::RefCounted<KB::DictionaryContainer>::deref(unsigned int *result)
{
  unsigned int v1 = atomic_load(result);
  if (v1 == 1)
  {
    KB::DictionaryContainer::~DictionaryContainer((KB::DictionaryContainer *)result);
    JUMPOUT(0x1E4E7BC20);
  }
  atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  return result;
}

void TI::Favonius::UnigramCandidateGenerator::create()
{
}

uint64_t TI::Favonius::UnigramCandidateGenerator::UnigramCandidateGenerator(uint64_t result, atomic_uint **a2)
{
  *(_DWORD *)(result + 8) = 1;
  *(void *)__n128 result = &unk_1F3F71768;
  uint64_t v2 = *a2;
  *(void *)(result + 16) = *a2;
  if (v2) {
    atomic_fetch_add(v2, 1u);
  }
  return result;
}

{
  atomic_uint *v2;

  *(_DWORD *)(result + 8) = 1;
  *(void *)__n128 result = &unk_1F3F71768;
  uint64_t v2 = *a2;
  *(void *)(result + 16) = *a2;
  if (v2) {
    atomic_fetch_add(v2, 1u);
  }
  return result;
}

BOOL TI::Favonius::UnigramCandidateGenerator::should_suggest_word_combination(TI::Favonius::UnigramCandidateGenerator *this, const KB::Candidate *a2, const KB::Word *a3)
{
  if (*(void *)this)
  {
    uint64_t v4 = *((void *)this + 1);
    uint64_t v5 = 240 * *(void *)this;
    while (1)
    {
      unsigned int v6 = *(unsigned __int16 *)(v4 + 4);
      if (!*(_WORD *)(v4 + 4))
      {
        KB::String::compute_length((unsigned __int16 *)v4);
        unsigned int v6 = *(unsigned __int16 *)(v4 + 4);
      }
      if (v6 >= 2 && *(_DWORD *)(v4 + 120)) {
        return 0;
      }
      v4 += 240;
      v5 -= 240;
      if (!v5) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    unsigned int v7 = *((unsigned __int16 *)a2 + 2);
    if (!*((_WORD *)a2 + 2))
    {
      KB::String::compute_length((unsigned __int16 *)a2);
      unsigned int v7 = *((unsigned __int16 *)a2 + 2);
    }
    return v7 < 2 || *((_DWORD *)a2 + 30) == 0;
  }
}

uint64_t TI::Favonius::UnigramCandidateGenerator::update_word(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 168))(a3);
  if (result)
  {
    *(void *)(a2 + 136) = 0;
  }
  else
  {
    int v5 = *(_DWORD *)(a2 + 104);
    if ((v5 & 0x80060100) == 0 && HIDWORD(*(void *)(a2 + 136)) == 0 && *(void *)(a2 + 224) == 0) {
      *(_DWORD *)(a2 + 104) = v5 | 4;
    }
  }
  return result;
}

uint64_t KB::LanguageModelStr::last_set_supplemental_phrase_lexicon(KB::LanguageModelStr *this)
{
  return *((void *)this + 30);
}

uint64_t KB::LanguageModelStr::last_set_supplemental_word_lexicon(KB::LanguageModelStr *this)
{
  return *((void *)this + 29);
}

void KB::LanguageModelStr::do_store(KB::LanguageModelStr *this, int a2)
{
  uint64_t v4 = (KB::LanguageModel *)(*(uint64_t (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this);
  if (v4)
  {
    if (a2)
    {
      uint64_t v5 = *((void *)this + 23);
      if (v5) {
        atomic_store(1u, (unsigned __int8 *)(v5 + 760));
      }
      std::mutex::lock(*((std::mutex **)this + 17));
      uint64_t v6 = *((void *)this + 23);
      if (v6) {
        atomic_store(0, (unsigned __int8 *)(v6 + 760));
      }
      language_modeling::v1::LanguageModelSession::flushCacheAndRecencyData(*((language_modeling::v1::LanguageModelSession **)this
                                                                            + 25));
      std::mutex::unlock(*((std::mutex **)this + 17));
    }
    v9[0] = 0;
    v9[1] = v9;
    v9[2] = 0x3802000000;
    _OWORD v9[3] = __Block_byref_object_copy__34;
    uint64_t v8 = *((void *)this + 21);
    unsigned int v7 = (std::__shared_weak_count *)*((void *)this + 22);
    v9[4] = __Block_byref_object_dispose__35;
    v9[5] = v8;
    long long v10 = v7;
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    KB::LanguageModel::background_loading_queue(v4);
    TIDispatchAsync();
    _Block_object_dispose(v9, 8);
    if (v10) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v10);
    }
  }
}

__n128 __Block_byref_object_copy__34(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__35(uint64_t a1)
{
  unsigned int v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
}

void ___ZN2KB16LanguageModelStr8do_storeEb_block_invoke(uint64_t a1)
{
  language_modeling::v1::LanguageModel::flushDynamicData(*(language_modeling::v1::LanguageModel **)(*(void *)(*(void *)(a1 + 32) + 8)
                                                                                                  + 40));
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v3 = *(std::__shared_weak_count **)(v2 + 48);
  *(void *)(v2 + 40) = 0;
  *(void *)(v2 + 48) = 0;
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

uint64_t KB::LanguageModelStr::background_load(KB::LanguageModelStr *this)
{
  return (*(uint64_t (**)(KB::LanguageModelStr *, uint64_t))(*(void *)this + 72))(this, 1);
}

void KB::LanguageModelStr::updateAdditionalLexicons(const _LXLexicon **this)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if ((*((uint64_t (**)(const _LXLexicon **))*this + 2))(this))
  {
    *(void *)uint64_t v2 = TITransientLexiconManagerGetActiveSupplementalLexiconWords();
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 29, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E4F72080]);
    *(void *)uint64_t v2 = TITransientLexiconManagerGetActiveSupplementalLexiconPhrases();
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 30, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E4F720D0]);
    *(void *)uint64_t v2 = KB::LanguageModel::get_word_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 31, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E4F72068]);
    *(void *)uint64_t v2 = KB::LanguageModel::get_phrase_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 32, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E4F720B0]);
    *(void *)uint64_t v2 = KB::LanguageModel::get_contacts_lexicon((KB::LanguageModel *)this);
    KB::LanguageModelStr::checkAndUpdateLexicon((KB::LanguageModelStr *)this, this + 33, (const _LXLexicon **)v2, (char *)*MEMORY[0x1E4F72070]);
  }
  else if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v2 = 136315138;
    *(void *)&v2[4] = "updateAdditionalLexicons";
    _os_log_error_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s  LM model is not valid yet", v2, 0xCu);
  }
}

void KB::LanguageModelStr::checkAndUpdateLexicon(KB::LanguageModelStr *this, const _LXLexicon **a2, const _LXLexicon **a3, char *a4)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*a2 != *a3)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__p = 136315394;
      *(void *)&__p[4] = "checkAndUpdateLexicon";
      __int16 v9 = 2080;
      long long v10 = a4;
      _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  Removing lexicon for %s in Language Model", __p, 0x16u);
    }
    std::string::basic_string[abi:nn180100]<0>(__p, a4);
    language_modeling::v1::LanguageModel::removeLexicon();
    if (v11 < 0) {
      operator delete(*(void **)__p);
    }
    if (*a3)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__p = 136315394;
        *(void *)&__p[4] = "checkAndUpdateLexicon";
        __int16 v9 = 2080;
        long long v10 = a4;
        _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  Setting lexicon for %s in Language Model", __p, 0x16u);
      }
      std::string::basic_string[abi:nn180100]<0>(__p, a4);
      language_modeling::v1::LanguageModel::addLexicon();
      if (v11 < 0) {
        operator delete(*(void **)__p);
      }
      unsigned int v7 = *a3;
    }
    else
    {
      unsigned int v7 = 0;
    }
    *a2 = v7;
  }
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void KB::LanguageModelStr::register_inline_completion_acceptance_rejection(uint64_t a1, const KB::String *a2, const KB::String *a3, const KB::String *a4, int a5)
{
  uint64_t v5 = *(void *)(a1 + 184);
  if (v5) {
    TIInlineCompletionEventDispatcher::did_register_completion_acceptance(*(void *)(v5 + 744), a2, a3, a4, a5);
  }
}

void KB::LanguageModelStr::inline_completions_with_stems(uint64_t a1@<X0>, uint64_t *a2@<X1>, const KB::LanguageModelContext *a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    v20[0] = 0;
    v20[1] = 0;
    __p[0] = 0;
    convert_to_lm_completion_stem(a2, (int64x2_t *)v20, 0);
    LODWORD(v19) = *(_DWORD *)(a1 + 88);
    HIDWORD(v19) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    TIInlineCompletionGeneratorImpl::cachedCompletionsForContextAndStem(*(TIInlineCompletionGeneratorImpl **)(a1 + 184), a3, v20[0], (uint64_t)v35);
    if (v36)
    {
      KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()((uint64_t *)&v27, (uint64_t)&v19, (const TIInlineCompletion *)v35[0], (const TIInlineCompletion *)v35[1]);
      *(_OWORD *)a6 = v27;
      *(void *)(a6 + 16) = v28;
      uint64_t v28 = 0;
      long long v27 = 0uLL;
      *(unsigned char *)(a6 + 24) = 1;
      int v29 = (void **)&v27;
      std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v29);
      *(void *)&long long v27 = v35;
      std::vector<TIInlineCompletion>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 184);
      uint64_t v30 = v19;
      std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v31, a5);
      KB::Candidate::Candidate((KB::Candidate *)v33, (const KB::Candidate *)*a2);
      unint64_t v14 = operator new(0x418uLL);
      unint64_t v15 = v14;
      uint64_t v16 = v30;
      unint64_t v17 = v32;
      void *v14 = &unk_1F3F71CB8;
      v14[1] = v16;
      if (v17)
      {
        if (v17 == v31)
        {
          v14[5] = v14 + 2;
          (*(void (**)(void *))(v31[0] + 24))(v31);
        }
        else
        {
          v14[5] = v17;
          uint64_t v32 = 0;
        }
      }
      else
      {
        v14[5] = 0;
      }
      KB::Candidate::Candidate((uint64_t)(v15 + 6), (uint64_t)v33);
      v34[3] = v15;
      TIInlineCompletionGeneratorImpl::enumerateInlineCompletionsWithLM(v13, a3, v20, a4, (uint64_t)v34);
      std::__function::__value_func<void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v34);
      KB::Candidate::~Candidate((KB::Candidate *)v33);
      std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v31);
      *(unsigned char *)a6 = 0;
      *(unsigned char *)(a6 + 24) = 0;
    }
    v35[0] = (void **)v20;
    std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](v35);
  }
  else
  {
    long long v27 = 0uLL;
    uint64_t v28 = 0;
    bzero(v35, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v35);
    uint64_t v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    *(_OWORD *)int64x2_t v20 = 0u;
    *(_OWORD *)__p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
    long long v25 = 0uLL;
    uint64_t v26 = 0;
    uint64_t v12 = *(void *)(a5 + 24);
    if (v12)
    {
      (*(void (**)(uint64_t, long long *, void ***, language_modeling::v1::CompletionStem **))(*(void *)v12 + 48))(v12, &v27, v35, v20);
      int v29 = (void **)&v25;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v29);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v24 + 8));
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v20[1]) {
        std::__shared_weak_count::__release_shared[abi:nn180100]((std::__shared_weak_count *)v20[1]);
      }
      KB::Candidate::~Candidate((KB::Candidate *)v35);
      *(unsigned char *)a6 = 0;
      *(unsigned char *)(a6 + 24) = 0;
      v35[0] = (void **)&v27;
      std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](v35);
    }
    else
    {
      uint64_t v18 = (KB::Candidate *)std::__throw_bad_function_call[abi:nn180100]();
      KB::Candidate::Candidate(v18);
    }
  }
}

KB::Candidate *KB::Candidate::Candidate(KB::Candidate *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = (char *)this + 24;
  *((void *)this + 2) = 3;
  *(_OWORD *)((char *)this + 744) = xmmword_1E4154B40;
  *((void *)this + 95) = 0xFF8000003F800000;
  *((void *)this + 105) = 0;
  *(_OWORD *)((char *)this + 776) = 0u;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *(_OWORD *)((char *)this + 824) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 848));
  language_modeling::v1::LinguisticContext::LinguisticContext((KB::Candidate *)((char *)this + 856));
  *((void *)this + 109) = 0;
  *((void *)this + 108) = 0;
  *((void *)this + 110) = 0;
  *((_DWORD *)this + 222) = 0x100000;
  *((_WORD *)this + 446) = 0;
  *((unsigned char *)this + 894) = 0;
  *((void *)this + 112) = 0;
  *((unsigned char *)this + 904) = 0;
  *((void *)this + 115) = 0;
  *((_OWORD *)this + 58) = 0u;
  *((_WORD *)this + 472) = 0;
  *((_DWORD *)this + 240) = 0;
  *((unsigned char *)this + 964) = 0;
  *((_OWORD *)this + 61) = 0u;
  *((_DWORD *)this + 248) = 0;
  return this;
}

void std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 160;
        std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void convert_to_lm_completion_stem(uint64_t *a1, int64x2_t *a2, int a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (a1[1] != *a1)
  {
    unint64_t v5 = 0;
    unint64_t v33 = a2 + 1;
    do
    {
      language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v36);
      int v41 = 0x100000;
      __int16 v42 = 0;
      char v43 = 0;
      unint64_t v44 = 0;
      v45[0] = 0;
      uint64_t v6 = *a1;
      if (*(void *)(*a1 + 1000 * v5))
      {
        uint64_t v7 = 0;
        uint64_t v8 = 0;
        do
        {
          uint64_t v9 = v8;
          long long v10 = (KB::Word *)(*(void *)(v6 + 1000 * v5 + 8) + v7);
          if (KB::Word::is_linguistically_void(v10))
          {
            char v11 = (char *)v44;
            if (!v44) {
              char v11 = v45;
            }
            if ((_WORD)v41) {
              uint64_t v12 = v11;
            }
            else {
              uint64_t v12 = "";
            }
            std::string::basic_string[abi:nn180100]<0>(&__p, v12);
            if (v9) {
              uint64_t v13 = *(void *)(*(void *)(*a1 + 1000 * v5 + 8) + 240 * (v9 - 1) + 136);
            }
            else {
              uint64_t v13 = 0;
            }
            uint64_t v35 = v13;
            KB::LanguageModelContext::linguistic_token((uint64_t)&__p, (TITokenID)&v35, (uint64_t)&v46);
            if (v40 < 0) {
              operator delete(__p);
            }
            language_modeling::v1::CompletionStem::try_push_back();
            LODWORD(__p) = 0x100000;
            WORD2(__p) = 0;
            BYTE6(__p) = 0;
            uint64_t v38 = 0;
            char v39 = 0;
            KB::String::operator=((uint64_t)&v41, (KB::String *)&__p);
            if (v38 && BYTE6(__p) == 1) {
              free(v38);
            }
            if (SHIBYTE(v47[1]) < 0) {
              operator delete(v46);
            }
          }
          else
          {
            KB::Word::capitalized_string(v10, (uint64_t)&v46);
            unint64_t v14 = (void **)v47[0];
            if (!v47[0]) {
              unint64_t v14 = &v47[1];
            }
            if ((_WORD)v46) {
              unint64_t v15 = (const char *)v14;
            }
            else {
              unint64_t v15 = "";
            }
            KB::String::append((unsigned __int16 *)&v41, v15, 0xFFFFuLL);
            if (v47[0] && BYTE6(v46) == 1) {
              free(v47[0]);
            }
          }
          uint64_t v8 = v9 + 1;
          uint64_t v6 = *a1;
          v7 += 240;
        }
        while (*(void *)(*a1 + 1000 * v5) > (unint64_t)(v9 + 1));
        if ((_WORD)v41)
        {
          if (v44) {
            uint64_t v16 = (char *)v44;
          }
          else {
            uint64_t v16 = v45;
          }
          std::string::basic_string[abi:nn180100]<0>(&__p, v16);
          unint64_t v17 = (void *)(*a1 + 1000 * v5);
          if (*v17 <= (unint64_t)(int)v9) {
            uint64_t v18 = 0;
          }
          else {
            uint64_t v18 = *(void *)(v17[1] + 240 * (int)v9 + 136);
          }
          uint64_t v35 = v18;
          KB::LanguageModelContext::linguistic_token((uint64_t)&__p, (TITokenID)&v35, (uint64_t)&v46);
          if (v40 < 0) {
            operator delete(__p);
          }
          language_modeling::v1::CompletionStem::try_push_back();
          if (SHIBYTE(v47[1]) < 0) {
            operator delete(v46);
          }
        }
      }
      if (a3)
      {
        std::string::basic_string[abi:nn180100]<0>(&v46, "");
        LODWORD(v48) = 0;
        language_modeling::v1::CompletionStem::try_push_back();
        if (SHIBYTE(v47[1]) < 0) {
          operator delete(v46);
        }
      }
      language_modeling::v1::CompletionStem::set_unique_id((language_modeling::v1::CompletionStem *)v36);
      language_modeling::v1::CompletionStem::set_score((language_modeling::v1::CompletionStem *)v36, *(float *)(*a1 + 1000 * v5 + 748) / 2.30258509 / *(float *)(*a1 + 1000 * v5 + 760));
      uint64_t v19 = (language_modeling::v1::CompletionStem *)a2->i64[1];
      unint64_t v20 = a2[1].u64[0];
      if ((unint64_t)v19 >= v20)
      {
        uint64_t v22 = ((uint64_t)v19 - a2->i64[0]) >> 3;
        if ((unint64_t)(v22 + 1) >> 61) {
          abort();
        }
        uint64_t v23 = v20 - a2->i64[0];
        uint64_t v24 = v23 >> 2;
        if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
          uint64_t v24 = v22 + 1;
        }
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v25 = v24;
        }
        int64x2_t v49 = (uint64_t *)v33;
        if (v25) {
          unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v25);
        }
        else {
          uint64_t v26 = 0;
        }
        unint64_t v27 = v25 + 8 * v22;
        uint64_t v46 = (void *)v25;
        v47[0] = (void *)v27;
        unint64_t v48 = v25 + 8 * v26;
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v27, (const language_modeling::v1::CompletionStem *)v36);
        unint64_t v21 = (void *)(v27 + 8);
        v47[1] = (void *)(v27 + 8);
        uint64_t v29 = a2->i64[0];
        unint64_t v28 = a2->u64[1];
        uint64_t v30 = v47[0];
        if (v28 == a2->i64[0])
        {
          int64x2_t v31 = vdupq_n_s64(v28);
        }
        else
        {
          do
          {
            v28 -= 8;
            uint64_t v30 = (void *)language_modeling::v1::CompletionStem::CompletionStem();
          }
          while (v28 != v29);
          int64x2_t v31 = *a2;
          unint64_t v21 = v47[1];
        }
        a2->i64[0] = (uint64_t)v30;
        a2->i64[1] = (uint64_t)v21;
        *(int64x2_t *)v47 = v31;
        unint64_t v32 = a2[1].u64[0];
        a2[1].i64[0] = v48;
        unint64_t v48 = v32;
        uint64_t v46 = (void *)v31.i64[0];
        std::__split_buffer<language_modeling::v1::CompletionStem>::~__split_buffer((uint64_t)&v46);
      }
      else
      {
        unint64_t v21 = (void *)(language_modeling::v1::CompletionStem::CompletionStem(v19, (const language_modeling::v1::CompletionStem *)v36)+ 8);
      }
      a2->i64[1] = (uint64_t)v21;
      if (v44)
      {
        if (v43 == 1) {
          free(v44);
        }
      }
      language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)v36);
      ++v5;
    }
    while (0x1CAC083126E978D5 * ((a1[1] - *a1) >> 3) > v5);
  }
}

void KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()(uint64_t *a1, uint64_t a2, const TIInlineCompletion *a3, const TIInlineCompletion *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3 != a4)
  {
    unint64_t v5 = a3;
    uint64_t v22 = (void **)(a1 + 2);
    do
    {
      KB::LanguageModel::PredictionInfo::PredictionInfo((KB::LanguageModel::PredictionInfo *)v24, v5, *(_DWORD *)(a2 + 4));
      unint64_t v7 = a1[1];
      unint64_t v8 = a1[2];
      if (v7 >= v8)
      {
        unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *a1) >> 5);
        unint64_t v14 = v13 + 1;
        if (v13 + 1 > 0x199999999999999) {
          abort();
        }
        unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v8 - *a1) >> 5);
        if (2 * v15 > v14) {
          unint64_t v14 = 2 * v15;
        }
        if (v15 >= 0xCCCCCCCCCCCCCCLL) {
          unint64_t v16 = 0x199999999999999;
        }
        else {
          unint64_t v16 = v14;
        }
        v37[4] = v22;
        if (v16) {
          unint64_t v16 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v16);
        }
        else {
          uint64_t v17 = 0;
        }
        unint64_t v18 = v16 + 160 * v13;
        v37[0] = (void **)v16;
        v37[1] = (void **)v18;
        v37[3] = (void **)(v16 + 160 * v17);
        *(void *)unint64_t v18 = 0;
        *(void *)(v18 + 8) = 0;
        *(void *)(v18 + 16) = 0;
        *(_OWORD *)unint64_t v18 = *(_OWORD *)v24;
        *(void *)(v18 + 16) = v25;
        v24[0] = 0;
        v24[1] = 0;
        uint64_t v25 = 0;
        long long v19 = v26;
        *(_DWORD *)(v18 + 40) = v27;
        *(_OWORD *)(v18 + 24) = v19;
        long long v20 = v28;
        *(void *)(v18 + 64) = v29;
        *(_OWORD *)(v18 + 48) = v20;
        uint64_t v29 = 0;
        long long v28 = 0uLL;
        long long v21 = __p;
        *(void *)(v18 + 88) = v31;
        *(_OWORD *)(v18 + 72) = v21;
        uint64_t v31 = 0;
        long long __p = 0uLL;
        *(void *)(v18 + 96) = 0;
        *(void *)(v18 + 104) = 0;
        *(void *)(v18 + 112) = 0;
        *(_OWORD *)(v18 + 96) = v32;
        *(void *)(v18 + 112) = v33;
        long long v32 = 0uLL;
        uint64_t v33 = 0;
        *(void *)(v18 + 120) = 0;
        *(void *)(v18 + 128) = 0;
        *(void *)(v18 + 136) = 0;
        *(_OWORD *)(v18 + 120) = v34;
        *(void *)(v18 + 136) = v35;
        long long v34 = 0uLL;
        uint64_t v35 = 0;
        *(_OWORD *)(v18 + 144) = v36;
        v37[2] = (void **)(v18 + 160);
        std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(a1, v37);
        uint64_t v12 = a1[1];
        std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v37);
      }
      else
      {
        *(void *)unint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
        *(void *)(v7 + 16) = 0;
        *(_OWORD *)unint64_t v7 = *(_OWORD *)v24;
        *(void *)(v7 + 16) = v25;
        v24[0] = 0;
        v24[1] = 0;
        uint64_t v25 = 0;
        int v9 = v27;
        *(_OWORD *)(v7 + 24) = v26;
        *(_DWORD *)(v7 + 40) = v9;
        uint64_t v10 = v29;
        *(_OWORD *)(v7 + 48) = v28;
        *(void *)(v7 + 64) = v10;
        uint64_t v29 = 0;
        long long v28 = 0uLL;
        long long v11 = __p;
        *(void *)(v7 + 88) = v31;
        *(void *)(v7 + 96) = 0;
        *(_OWORD *)(v7 + 72) = v11;
        uint64_t v31 = 0;
        long long __p = 0uLL;
        *(void *)(v7 + 104) = 0;
        *(void *)(v7 + 112) = 0;
        *(_OWORD *)(v7 + 96) = v32;
        long long v32 = 0uLL;
        *(void *)(v7 + 112) = v33;
        *(void *)(v7 + 120) = 0;
        uint64_t v33 = 0;
        *(void *)(v7 + 128) = 0;
        *(void *)(v7 + 136) = 0;
        *(_OWORD *)(v7 + 120) = v34;
        *(void *)(v7 + 136) = v35;
        long long v34 = 0uLL;
        uint64_t v35 = 0;
        *(_OWORD *)(v7 + 144) = v36;
        uint64_t v12 = v7 + 160;
      }
      a1[1] = v12;
      v37[0] = (void **)&v34;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v37);
      v37[0] = (void **)&v32;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v37);
      if (SHIBYTE(v31) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v29) < 0) {
        operator delete((void *)v28);
      }
      if (v24[0])
      {
        v24[1] = v24[0];
        operator delete(v24[0]);
      }
      unint64_t v5 = (const TIInlineCompletion *)((char *)v5 + 80);
    }
    while (v5 != a4);
  }
}

uint64_t std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::vector<TIInlineCompletion>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<TIInlineCompletion,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(v4 - 8));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:nn180100]<TIInlineCompletion,0>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72)) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 64));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, const TIInlineCompletion **a2, uint64_t a3)
{
  KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)const::$_0::operator()(v7, a1 + 8, *a2, a2[1]);
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5)
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v5 + 48))(v5, v7, a1 + 48, a3);
    unint64_t v8 = (void **)v7;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v8);
  }
  else
  {
    uint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
    std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::destroy_deallocate(v6);
  }
}

void std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::destroy_deallocate(void *a1)
{
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::destroy(uint64_t a1)
{
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 48));

  return std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100]((void *)(a1 + 16));
}

KB::Candidate *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F71CB8;
  a2[1] = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(a2 + 2), a1 + 16);

  return KB::Candidate::Candidate((KB::Candidate *)(a2 + 6), (const KB::Candidate *)(a1 + 48));
}

void *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x418uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_1F3F71CB8;
  v2[1] = v3;
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)(v2 + 2), a1 + 16);
  KB::Candidate::Candidate((KB::Candidate *)(v2 + 6), (const KB::Candidate *)(a1 + 48));
  return v2;
}

void std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__func(void *a1)
{
  *a1 = &unk_1F3F71CB8;
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](a1 + 2);

  JUMPOUT(0x1E4E7BC20);
}

void *std::__function::__func<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1,std::allocator<KB::LanguageModelStr::inline_completions_with_stems(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,BOOL,std::function<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>)::$_1>,void ()(std::vector<TIInlineCompletion> const&,KB::LanguageModelContext const&)>::~__func(void *a1)
{
  *a1 = &unk_1F3F71CB8;
  KB::Candidate::~Candidate((KB::Candidate *)(a1 + 6));
  std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](a1 + 2);
  return a1;
}

__n128 std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  long long v2 = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v2;
  long long v3 = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(_OWORD *)(a1 + 48) = v3;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 48) = 0;
  long long v4 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v4;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 112) = *(void *)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a2 + 120);
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  __n128 result = *(__n128 *)(a2 + 144);
  *(__n128 *)(a1 + 144) = result;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(unint64_t a1)
{
  if (a1 >= 0x19999999999999ALL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(160 * a1);
}

void std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v4 -= 160;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo*>(v6 - 160, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

uint64_t std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 160;
    std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(i - 160);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,0>(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 120);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  uint64_t v3 = (void **)(a1 + 96);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  long long v2 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

uint64_t std::__split_buffer<language_modeling::v1::CompletionStem>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 8;
    language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(i - 8));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void KB::LanguageModelStr::predictions_with_stems(uint64_t a1, void *a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1) && a2[1] != *a2)
  {
    kdebug_trace();
    log = kac_get_log();
    uint64_t v5 = (const void *)(a1 ^ 0xCC);
    os_signpost_id_t v6 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCC));
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v7 = v6;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, log, OS_SIGNPOST_INTERVAL_BEGIN, v7, "kbdManager.languageModel.toucanGenerateCompletionsAndPredictions", (const char *)&unk_1E41704BE, buf, 2u);
      }
    }
    uint64_t v8 = *(void *)(a1 + 184);
    if (v8) {
      atomic_store(1u, (unsigned __int8 *)(v8 + 760));
    }
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    uint64_t v9 = *(void *)(a1 + 184);
    if (v9) {
      atomic_store(0, (unsigned __int8 *)(v9 + 760));
    }
    language_modeling::v1::LanguageModelSession::enumeratePredictions();
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    kdebug_trace();
    uint64_t v10 = kac_get_log();
    os_signpost_id_t v11 = os_signpost_id_make_with_pointer(v10, v5);
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v12 = v11;
      if (os_signpost_enabled(v10))
      {
        *(_WORD *)unint64_t v13 = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, v10, OS_SIGNPOST_INTERVAL_END, v12, "kbdManager.languageModel.toucanGenerateCompletionsAndPredictions", (const char *)&unk_1E41704BE, v13, 2u);
      }
    }
  }
}

uint64_t KB::LanguageModelStr::completions(uint64_t a1, const KB::Candidate **a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  v32[4] = *MEMORY[0x1E4F143B8];
  int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
  if (a6 == 1 && v12)
  {
    if (a2[1] != *a2)
    {
      std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v32, a4);
      LOBYTE(a2) = (*(uint64_t (**)(uint64_t, const KB::Candidate **, uint64_t, void *, void))(*(void *)a1 + 512))(a1, a2, a3, v32, 0);
      std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v32);
      return a2 & 1;
    }
LABEL_6:
    LOBYTE(a2) = 0;
    return a2 & 1;
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1)) {
    goto LABEL_6;
  }
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate *)&v24, *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  unint64_t v13 = v24;
  unint64_t v14 = v25;
  unint64_t v15 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((v25 - (char *)v24) >> 3));
  if (v25 == (char *)v24) {
    uint64_t v16 = 0;
  }
  else {
    uint64_t v16 = v15;
  }
  std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(v24, (uint64_t *)v25, v16, 1);
  if (v14 == (char *)v13)
  {
    LOBYTE(a2) = 0;
  }
  else
  {
    LODWORD(a2) = 0;
    uint64_t v17 = v13;
    do
    {
      KB::Candidate::Candidate((KB::Candidate *)v31, v17);
      KB::Candidate::pop_last_word((KB::Candidate *)v31);
      if (v31[0])
      {
        v30[0] = &unk_1F3F71BA8;
        v30[1] = v13;
        v30[2] = a4;
        v30[3] = v30;
        KB::Candidate::Candidate((KB::Candidate *)v29, (const KB::Candidate *)v31);
        long long v21 = (KB::Candidate *)operator new(0x3E8uLL);
        uint64_t v22 = v21;
        unint64_t v18 = (KB::Candidate *)((char *)v21 + 1000);
        uint64_t v23 = (char *)v21 + 1000;
        KB::Candidate::Candidate(v21, (const KB::Candidate *)v29);
        uint64_t v22 = v18;
        std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v28, (uint64_t)v30);
        (*(void (**)(uint64_t, KB::Candidate **, uint64_t, void *, void))(*(void *)a1 + 512))(a1, &v21, a3, v28, 0);
        std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v28);
        int v27 = &v21;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v27);
        KB::Candidate::~Candidate((KB::Candidate *)v29);
        uint64_t v19 = *(void *)(a5 + 24);
        if (!v19) {
          std::__throw_bad_function_call[abi:nn180100]();
        }
        LODWORD(a2) = a2 | (*(uint64_t (**)(uint64_t, const KB::Candidate *))(*(void *)v19 + 48))(v19, v17);
        std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v30);
      }
      KB::Candidate::~Candidate((KB::Candidate *)v31);
      uint64_t v17 = (const KB::Candidate *)((char *)v17 + 1000);
      unint64_t v13 = (KB::Candidate *)((char *)v13 + 1000);
    }
    while (v17 != (const KB::Candidate *)v14);
  }
  v31[0] = (void **)&v24;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v31);
  return a2 & 1;
}

uint64_t std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  uint64_t v3;

  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = v3;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

KB::Candidate *std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(KB::Candidate *result, const KB::Candidate *a2, const KB::Candidate *a3, unint64_t a4)
{
  if (a4)
  {
    os_signpost_id_t v6 = result;
    std::vector<KB::Candidate>::__vallocate[abi:nn180100](result, a4);
    __n128 result = (KB::Candidate *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      os_signpost_id_t v7 = KB::Candidate::Candidate(result, a2);
      a2 = (const KB::Candidate *)((char *)a2 + 1000);
      __n128 result = (KB::Candidate *)((char *)v7 + 1000);
    }
    *((void *)v6 + 1) = result;
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(KB::Candidate *a1, uint64_t *a2, uint64_t a3, char a4)
{
  v42[2] = *MEMORY[0x1E4F143B8];
LABEL_2:
  uint64_t v10 = (uint64_t *)a1;
  os_signpost_id_t v11 = (KB::Candidate *)((char *)a1 + 1000);
  int v12 = (KB::Candidate *)((char *)a1 + 2000);
  unint64_t v13 = (KB::Candidate *)((char *)a1 - 1000);
  --a3;
  while (1)
  {
    uint64_t v14 = (char *)a2 - (char *)v10;
    unint64_t v15 = 0x1CAC083126E978D5 * (a2 - v10);
    if (!(!v5 & v4)) {
      break;
    }
    if (v14 <= 23999)
    {
      if (a4) {
        std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v10, a2);
      }
      else {
        std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v10, a2);
      }
      return;
    }
    if (a3 == -1)
    {
      std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,KB::Candidate*>((uint64_t)v10, (KB::Candidate *)a2, (KB::Candidate *)a2);
      return;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = (KB::Candidate *)&v10[125 * (v15 >> 1)];
    unint64_t v18 = (KB::Candidate *)(a2 - 125);
    if ((unint64_t)v14 >= 0x1F401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v10, (KB::Candidate *)&v10[125 * (v15 >> 1)], v18);
      uint64_t v19 = (KB::Candidate *)&v10[125 * v16];
      long long v20 = (KB::Candidate *)((char *)v19 - 1000);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v11, (KB::Candidate *)((char *)v19 - 1000), (KB::Candidate *)(a2 - 250));
      uint64_t v19 = (KB::Candidate *)((char *)v19 + 1000);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v12, v19, (KB::Candidate *)(a2 - 375));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(v20, v17, v19);
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v10, (uint64_t *)v17);
      if (a4) {
        goto LABEL_26;
      }
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)&v10[125 * (v15 >> 1)], (KB::Candidate *)v10, v18);
      if (a4) {
        goto LABEL_26;
      }
    }
    KB::Candidate::capitalized_string(v13, (uint64_t)v39);
    KB::Candidate::capitalized_string((KB::Candidate *)v10, (uint64_t)v35);
    long long v21 = v41;
    if (v41) {
      uint64_t v22 = (const char *)v41;
    }
    else {
      uint64_t v22 = (const char *)v42;
    }
    uint64_t v23 = v37;
    if (v37) {
      uint64_t v24 = (const char *)v37;
    }
    else {
      uint64_t v24 = v38;
    }
    int v25 = strcmp(v22, v24);
    if (v23 && v36 == 1)
    {
      free(v23);
      long long v21 = v41;
    }
    if (v21 && v40 == 1) {
      free(v21);
    }
    if ((v25 & 0x80000000) == 0)
    {
      a1 = std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(v10, (KB::Candidate *)a2);
      a4 = 0;
      goto LABEL_2;
    }
LABEL_26:
    uint64_t v26 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>((uint64_t)v10, (KB::Candidate *)a2);
    if ((v27 & 1) == 0) {
      goto LABEL_31;
    }
    char v28 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t)v10, (KB::Candidate *)v26);
    a1 = (KB::Candidate *)(v26 + 125);
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t)(v26 + 125), (KB::Candidate *)a2))
    {
      if (v28) {
        goto LABEL_2;
      }
LABEL_31:
      std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,false>(v10, v26, a3, a4 & 1);
      a4 = 0;
      a1 = (KB::Candidate *)(v26 + 125);
      goto LABEL_2;
    }
    --a3;
    a2 = v26;
    if (v28) {
      return;
    }
  }
  switch(v15)
  {
    case 0uLL:
    case 1uLL:
      return;
    case 2uLL:
      uint64_t v29 = (KB::Candidate *)(a2 - 125);
      KB::Candidate::capitalized_string(v29, (uint64_t)v39);
      KB::Candidate::capitalized_string((KB::Candidate *)v10, (uint64_t)v35);
      uint64_t v30 = v41;
      if (v41) {
        uint64_t v31 = (const char *)v41;
      }
      else {
        uint64_t v31 = (const char *)v42;
      }
      long long v32 = v37;
      if (v37) {
        uint64_t v33 = (const char *)v37;
      }
      else {
        uint64_t v33 = v38;
      }
      int v34 = strcmp(v31, v33);
      if (v32 && v36 == 1)
      {
        free(v32);
        uint64_t v30 = v41;
      }
      if (v30 && v40 == 1) {
        free(v30);
      }
      if (v34 < 0) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v10, (uint64_t *)v29);
      }
      break;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v10, (KB::Candidate *)(v10 + 125), (KB::Candidate *)(a2 - 125));
      break;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)v10, (KB::Candidate *)(v10 + 125), (KB::Candidate *)(v10 + 250), (KB::Candidate *)(a2 - 125));
      break;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>((KB::Candidate *)v10, (KB::Candidate *)(v10 + 125), (KB::Candidate *)(v10 + 250), (KB::Candidate *)(v10 + 375), (KB::Candidate *)(a2 - 125));
      break;
    default:
      JUMPOUT(0);
  }
}

void std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, KB::LanguageModelContext *a4)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v18, a4);
  os_signpost_id_t v7 = *(const char **)(a2 + 120);
  if (*(const char **)(a2 + 128) != v7)
  {
    if (v7[23] < 0) {
      os_signpost_id_t v7 = *(const char **)v7;
    }
    KB::String::String((KB::String *)&v25, v7);
    uint64_t v8 = *(void *)(*(void *)(a1 + 8) + 8) + 240 * **(void **)(a1 + 8);
    unsigned int v11 = *(unsigned __int16 *)(v8 - 240);
    uint64_t v10 = v8 - 240;
    size_t v9 = v11;
    if (v11 <= (unsigned __int16)v25)
    {
      int v12 = (const char *)(v26 ? v26 : v27);
      uint64_t v13 = *(void *)(v10 + 8);
      uint64_t v14 = v10 + 16;
      unint64_t v15 = (const char *)(v13 ? v13 : v14);
      if (!strncasecmp(v12, v15, v9))
      {
        uint64_t v16 = *(void *)(*(void *)(a1 + 16) + 24);
        if (!v16)
        {
          uint64_t v17 = (char *)std::__throw_bad_function_call[abi:nn180100]();
          std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy_deallocate(v17);
          return;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v16 + 48))(v16, a2, a3, &v18);
      }
    }
    if (v26 && BYTE6(v25) == 1) {
      free(v26);
    }
  }
  int v25 = (void **)&v24;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v25);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v23);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v22);
  if (__p)
  {
    long long v21 = __p;
    operator delete(__p);
  }
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
}

__n128 std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71BA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x18uLL);
  *(void *)long long v2 = &unk_1F3F71BA8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1,std::allocator<KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_1>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(uint64_t *a1, uint64_t *a2)
{
  v4[125] = *MEMORY[0x1E4F143B8];
  KB::Candidate::Candidate((uint64_t)v4, (uint64_t)a1);
  KB::Candidate::operator=(a1, a2);
  KB::Candidate::operator=(a2, v4);
  KB::Candidate::~Candidate((KB::Candidate *)v4);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3)
{
  v41[2] = *MEMORY[0x1E4F143B8];
  KB::Candidate::capitalized_string(a2, (uint64_t)v38);
  KB::Candidate::capitalized_string(a1, (uint64_t)v34);
  os_signpost_id_t v6 = v40;
  if (v40) {
    os_signpost_id_t v7 = (const char *)v40;
  }
  else {
    os_signpost_id_t v7 = (const char *)v41;
  }
  uint64_t v8 = v36;
  if (v36) {
    size_t v9 = (const char *)v36;
  }
  else {
    size_t v9 = v37;
  }
  int v10 = strcmp(v7, v9);
  if (v8) {
    BOOL v11 = v35 == 1;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    free(v8);
    os_signpost_id_t v6 = v40;
  }
  if (v6 && v39 == 1) {
    free(v6);
  }
  if (v10 < 0)
  {
    KB::Candidate::capitalized_string(a3, (uint64_t)v38);
    KB::Candidate::capitalized_string(a2, (uint64_t)v34);
    uint64_t v24 = v40;
    if (v40) {
      int v25 = (const char *)v40;
    }
    else {
      int v25 = (const char *)v41;
    }
    uint64_t v26 = v36;
    if (v36) {
      char v27 = (const char *)v36;
    }
    else {
      char v27 = v37;
    }
    int v28 = strcmp(v25, v27);
    if (v26 && v35 == 1)
    {
      free(v26);
      uint64_t v24 = v40;
    }
    if (v24 && v39 == 1) {
      free(v24);
    }
    uint64_t v22 = (uint64_t *)a1;
    if ((v28 & 0x80000000) == 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      KB::Candidate::capitalized_string(a3, (uint64_t)v38);
      KB::Candidate::capitalized_string(a2, (uint64_t)v34);
      uint64_t v29 = v40;
      if (v40) {
        uint64_t v30 = (const char *)v40;
      }
      else {
        uint64_t v30 = (const char *)v41;
      }
      uint64_t v31 = v36;
      if (v36) {
        long long v32 = (const char *)v36;
      }
      else {
        long long v32 = v37;
      }
      int v33 = strcmp(v30, v32);
      if (v31 && v35 == 1)
      {
        free(v31);
        uint64_t v29 = v40;
      }
      if (v29 && v39 == 1) {
        free(v29);
      }
      if ((v33 & 0x80000000) == 0) {
        return;
      }
      uint64_t v22 = (uint64_t *)a2;
    }
    uint64_t v23 = (uint64_t *)a3;
    goto LABEL_72;
  }
  KB::Candidate::capitalized_string(a3, (uint64_t)v38);
  KB::Candidate::capitalized_string(a2, (uint64_t)v34);
  int v12 = v40;
  if (v40) {
    uint64_t v13 = (const char *)v40;
  }
  else {
    uint64_t v13 = (const char *)v41;
  }
  uint64_t v14 = v36;
  if (v36) {
    unint64_t v15 = (const char *)v36;
  }
  else {
    unint64_t v15 = v37;
  }
  int v16 = strcmp(v13, v15);
  if (v14 && v35 == 1)
  {
    free(v14);
    int v12 = v40;
  }
  if (v12 && v39 == 1) {
    free(v12);
  }
  if (v16 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
    KB::Candidate::capitalized_string(a2, (uint64_t)v38);
    KB::Candidate::capitalized_string(a1, (uint64_t)v34);
    uint64_t v17 = v40;
    if (v40) {
      uint64_t v18 = (const char *)v40;
    }
    else {
      uint64_t v18 = (const char *)v41;
    }
    uint64_t v19 = v36;
    if (v36) {
      long long v20 = (const char *)v36;
    }
    else {
      long long v20 = v37;
    }
    int v21 = strcmp(v18, v20);
    if (v19 && v35 == 1)
    {
      free(v19);
      uint64_t v17 = v40;
    }
    if (v17)
    {
      if (v39 == 1) {
        free(v17);
      }
    }
    if (v21 < 0)
    {
      uint64_t v22 = (uint64_t *)a1;
      uint64_t v23 = (uint64_t *)a2;
LABEL_72:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v22, v23);
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4)
{
  v30[2] = *MEMORY[0x1E4F143B8];
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, a2, a3);
  KB::Candidate::capitalized_string(a4, (uint64_t)v27);
  KB::Candidate::capitalized_string(a3, (uint64_t)v23);
  uint64_t v8 = v29;
  if (v29) {
    size_t v9 = (const char *)v29;
  }
  else {
    size_t v9 = (const char *)v30;
  }
  int v10 = v25;
  if (v25) {
    BOOL v11 = (const char *)v25;
  }
  else {
    BOOL v11 = v26;
  }
  int v12 = strcmp(v9, v11);
  if (v10 && v24 == 1)
  {
    free(v10);
    uint64_t v8 = v29;
  }
  if (v8 && v28 == 1) {
    free(v8);
  }
  if (v12 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
    KB::Candidate::capitalized_string(a3, (uint64_t)v27);
    KB::Candidate::capitalized_string(a2, (uint64_t)v23);
    uint64_t v13 = v29;
    if (v29) {
      uint64_t v14 = (const char *)v29;
    }
    else {
      uint64_t v14 = (const char *)v30;
    }
    unint64_t v15 = v25;
    if (v25) {
      int v16 = (const char *)v25;
    }
    else {
      int v16 = v26;
    }
    int v17 = strcmp(v14, v16);
    if (v15 && v24 == 1)
    {
      free(v15);
      uint64_t v13 = v29;
    }
    if (v13 && v28 == 1) {
      free(v13);
    }
    if (v17 < 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
      KB::Candidate::capitalized_string(a2, (uint64_t)v27);
      KB::Candidate::capitalized_string(a1, (uint64_t)v23);
      uint64_t v18 = v29;
      if (v29) {
        uint64_t v19 = (const char *)v29;
      }
      else {
        uint64_t v19 = (const char *)v30;
      }
      long long v20 = v25;
      if (v25) {
        int v21 = (const char *)v25;
      }
      else {
        int v21 = v26;
      }
      int v22 = strcmp(v19, v21);
      if (v20 && v24 == 1)
      {
        free(v20);
        uint64_t v18 = v29;
      }
      if (v18 && v28 == 1) {
        free(v18);
      }
      if (v22 < 0) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      }
    }
  }
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>(KB::Candidate *a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4, KB::Candidate *a5)
{
  v37[2] = *MEMORY[0x1E4F143B8];
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, a2, a3, a4);
  KB::Candidate::capitalized_string(a5, (uint64_t)v34);
  KB::Candidate::capitalized_string(a4, (uint64_t)v30);
  int v10 = v36;
  if (v36) {
    BOOL v11 = (const char *)v36;
  }
  else {
    BOOL v11 = (const char *)v37;
  }
  int v12 = v32;
  if (v32) {
    uint64_t v13 = (const char *)v32;
  }
  else {
    uint64_t v13 = v33;
  }
  int v14 = strcmp(v11, v13);
  if (v12 && v31 == 1)
  {
    free(v12);
    int v10 = v36;
  }
  if (v10 && v35 == 1) {
    free(v10);
  }
  if (v14 < 0)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a4, (uint64_t *)a5);
    KB::Candidate::capitalized_string(a4, (uint64_t)v34);
    KB::Candidate::capitalized_string(a3, (uint64_t)v30);
    unint64_t v15 = v36;
    if (v36) {
      int v16 = (const char *)v36;
    }
    else {
      int v16 = (const char *)v37;
    }
    int v17 = v32;
    if (v32) {
      uint64_t v18 = (const char *)v32;
    }
    else {
      uint64_t v18 = v33;
    }
    int v19 = strcmp(v16, v18);
    if (v17 && v31 == 1)
    {
      free(v17);
      unint64_t v15 = v36;
    }
    if (v15 && v35 == 1) {
      free(v15);
    }
    if (v19 < 0)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
      KB::Candidate::capitalized_string(a3, (uint64_t)v34);
      KB::Candidate::capitalized_string(a2, (uint64_t)v30);
      long long v20 = v36;
      if (v36) {
        int v21 = (const char *)v36;
      }
      else {
        int v21 = (const char *)v37;
      }
      int v22 = v32;
      if (v32) {
        uint64_t v23 = (const char *)v32;
      }
      else {
        uint64_t v23 = v33;
      }
      int v24 = strcmp(v21, v23);
      if (v22 && v31 == 1)
      {
        free(v22);
        long long v20 = v36;
      }
      if (v20 && v35 == 1) {
        free(v20);
      }
      if (v24 < 0)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
        KB::Candidate::capitalized_string(a2, (uint64_t)v34);
        KB::Candidate::capitalized_string(a1, (uint64_t)v30);
        int v25 = v36;
        if (v36) {
          uint64_t v26 = (const char *)v36;
        }
        else {
          uint64_t v26 = (const char *)v37;
        }
        char v27 = v32;
        if (v32) {
          char v28 = (const char *)v32;
        }
        else {
          char v28 = v33;
        }
        int v29 = strcmp(v26, v28);
        if (v27 && v31 == 1)
        {
          free(v27);
          int v25 = v36;
        }
        if (v25 && v35 == 1) {
          free(v25);
        }
        if (v29 < 0) {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
        }
      }
    }
  }
}

void std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t *a1, uint64_t *a2)
{
  v31[2] = *MEMORY[0x1E4F143B8];
  if (a1 != a2)
  {
    long long v2 = a2;
    char v4 = (KB::Candidate *)(a1 + 125);
    if (a1 + 125 != a2)
    {
      uint64_t v5 = 0;
      uint64_t v6 = (uint64_t)a1;
      do
      {
        os_signpost_id_t v7 = (KB::Candidate *)v6;
        uint64_t v6 = (uint64_t)v4;
        KB::Candidate::capitalized_string(v4, (uint64_t)&v22);
        KB::Candidate::capitalized_string(v7, (uint64_t)v28);
        uint64_t v8 = v23;
        if (v23) {
          size_t v9 = (const char *)v23;
        }
        else {
          size_t v9 = (const char *)&v24;
        }
        int v10 = v30;
        if (v30) {
          BOOL v11 = (const char *)v30;
        }
        else {
          BOOL v11 = (const char *)v31;
        }
        int v12 = strcmp(v9, v11);
        if (v10) {
          BOOL v13 = v29 == 1;
        }
        else {
          BOOL v13 = 0;
        }
        if (v13)
        {
          free(v10);
          uint64_t v8 = v23;
        }
        if (v8 && BYTE6(v22) == 1) {
          free(v8);
        }
        if (v12 < 0)
        {
          KB::Candidate::Candidate((uint64_t)&v22, v6);
          uint64_t v14 = v5;
          while (1)
          {
            KB::Candidate::operator=((uint64_t *)((char *)a1 + v14 + 1000), (uint64_t *)((char *)a1 + v14));
            if (!v14) {
              break;
            }
            KB::Candidate::capitalized_string((KB::Candidate *)&v22, (uint64_t)v28);
            KB::Candidate::capitalized_string((KB::Candidate *)((char *)a1 + v14 - 1000), (uint64_t)v25);
            unint64_t v15 = v30;
            if (v30) {
              int v16 = (const char *)v30;
            }
            else {
              int v16 = (const char *)v31;
            }
            int v17 = v26;
            if (v26) {
              uint64_t v18 = (const char *)v26;
            }
            else {
              uint64_t v18 = (const char *)&v27;
            }
            int v19 = strcmp(v16, v18);
            if (v17 && v25[6] == 1)
            {
              free(v17);
              unint64_t v15 = v30;
            }
            if (v15)
            {
              if (v29 == 1) {
                free(v15);
              }
            }
            v14 -= 1000;
            if ((v19 & 0x80000000) == 0)
            {
              long long v20 = (uint64_t *)((char *)a1 + v14 + 1000);
              goto LABEL_37;
            }
          }
          long long v20 = a1;
LABEL_37:
          KB::Candidate::operator=(v20, &v22);
          KB::Candidate::~Candidate((KB::Candidate *)&v22);
          long long v2 = a2;
        }
        char v4 = (KB::Candidate *)(v6 + 1000);
        v5 += 1000;
      }
      while ((uint64_t *)(v6 + 1000) != v2);
    }
  }
}

void std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t *a1, uint64_t *a2)
{
  v26[2] = *MEMORY[0x1E4F143B8];
  if (a1 != a2)
  {
    uint64_t v3 = a1;
    char v4 = (KB::Candidate *)(a1 + 125);
    if (a1 + 125 != a2)
    {
      do
      {
        uint64_t v5 = (uint64_t)v4;
        KB::Candidate::capitalized_string(v4, (uint64_t)&v17);
        KB::Candidate::capitalized_string((KB::Candidate *)v3, (uint64_t)v23);
        uint64_t v6 = v18;
        if (v18) {
          os_signpost_id_t v7 = (const char *)v18;
        }
        else {
          os_signpost_id_t v7 = (const char *)&v19;
        }
        uint64_t v8 = v25;
        if (v25) {
          size_t v9 = (const char *)v25;
        }
        else {
          size_t v9 = (const char *)v26;
        }
        int v10 = strcmp(v7, v9);
        if (v8) {
          BOOL v11 = v24 == 1;
        }
        else {
          BOOL v11 = 0;
        }
        if (v11)
        {
          free(v8);
          uint64_t v6 = v18;
        }
        if (v6 && BYTE6(v17) == 1) {
          free(v6);
        }
        if (v10 < 0)
        {
          KB::Candidate::Candidate((uint64_t)&v17, v5);
          do
          {
            KB::Candidate::operator=(v3 + 125, v3);
            v3 -= 125;
            KB::Candidate::capitalized_string((KB::Candidate *)&v17, (uint64_t)v23);
            KB::Candidate::capitalized_string((KB::Candidate *)v3, (uint64_t)v20);
            int v12 = v25;
            if (v25) {
              BOOL v13 = (const char *)v25;
            }
            else {
              BOOL v13 = (const char *)v26;
            }
            uint64_t v14 = v21;
            if (v21) {
              unint64_t v15 = (const char *)v21;
            }
            else {
              unint64_t v15 = (const char *)&v22;
            }
            int v16 = strcmp(v13, v15);
            if (v14 && v20[6] == 1)
            {
              free(v14);
              int v12 = v25;
            }
            if (v12)
            {
              if (v24 == 1) {
                free(v12);
              }
            }
          }
          while (v16 < 0);
          KB::Candidate::operator=(v3 + 125, &v17);
          KB::Candidate::~Candidate((KB::Candidate *)&v17);
        }
        char v4 = (KB::Candidate *)(v5 + 1000);
        uint64_t v3 = (uint64_t *)v5;
      }
      while ((uint64_t *)(v5 + 1000) != a2);
    }
  }
}

void std::__partial_sort[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,KB::Candidate*>(uint64_t a1, KB::Candidate *a2, KB::Candidate *a3)
{
  v61[2] = *MEMORY[0x1E4F143B8];
  if ((KB::Candidate *)a1 != a2)
  {
    uint64_t v6 = (uint64_t)a2 - a1;
    uint64_t v7 = ((uint64_t)a2 - a1) / 1000;
    if ((uint64_t)a2 - a1 >= 1001)
    {
      unint64_t v8 = (unint64_t)(v7 - 2) >> 1;
      unint64_t v9 = v8 + 1;
      int v10 = (KB::Candidate *)(a1 + 1000 * v8);
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(a1, v7, v10);
        int v10 = (KB::Candidate *)((char *)v10 - 1000);
        --v9;
      }
      while (v9);
    }
    unint64_t v48 = (KB::Candidate *)a1;
    BOOL v11 = (uint64_t *)a2;
    if (a2 != a3)
    {
      int v12 = a2;
      do
      {
        KB::Candidate::capitalized_string(v12, (uint64_t)&v52);
        KB::Candidate::capitalized_string(v48, (uint64_t)&v49);
        BOOL v13 = v53;
        if (v53) {
          uint64_t v14 = (const char *)v53;
        }
        else {
          uint64_t v14 = v54;
        }
        unint64_t v15 = v50;
        if (v50) {
          int v16 = (const char *)v50;
        }
        else {
          int v16 = (const char *)&v51;
        }
        int v17 = strcmp(v14, v16);
        if (v15) {
          BOOL v18 = BYTE6(v49) == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18)
        {
          free(v15);
          BOOL v13 = v53;
        }
        if (v13 && BYTE6(v52) == 1) {
          free(v13);
        }
        if (v17 < 0)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v12, (uint64_t *)v48);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((uint64_t)v48, v7, v48);
        }
        int v12 = (KB::Candidate *)((char *)v12 + 1000);
      }
      while (v12 != a3);
    }
    uint64_t v19 = (uint64_t)v48;
    if (v6 >= 1001)
    {
      long long v20 = v11;
      int64_t v21 = v6 / 0x3E8uLL;
      do
      {
        v47 = v20;
        KB::Candidate::Candidate((uint64_t)&v49, v19);
        uint64_t v22 = 0;
        uint64_t v23 = (uint64_t *)v19;
        do
        {
          uint64_t v24 = (uint64_t)&v23[125 * v22 + 125];
          uint64_t v25 = (2 * v22) | 1;
          uint64_t v26 = 2 * v22 + 2;
          if (v26 < v21)
          {
            KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)&v52);
            KB::Candidate::capitalized_string((KB::Candidate *)(v24 + 1000), (uint64_t)v58);
            uint64_t v27 = v53;
            if (v53) {
              char v28 = (const char *)v53;
            }
            else {
              char v28 = v54;
            }
            char v29 = v60;
            if (v60) {
              uint64_t v30 = (const char *)v60;
            }
            else {
              uint64_t v30 = (const char *)v61;
            }
            int v31 = strcmp(v28, v30);
            if (v29 && v59 == 1)
            {
              free(v29);
              uint64_t v27 = v53;
            }
            if (v27 && BYTE6(v52) == 1) {
              free(v27);
            }
            if (v31 < 0)
            {
              v24 += 1000;
              uint64_t v25 = v26;
            }
          }
          KB::Candidate::operator=(v23, (uint64_t *)v24);
          uint64_t v23 = (uint64_t *)v24;
          uint64_t v22 = v25;
        }
        while (v25 <= (uint64_t)((unint64_t)(v21 - 2) >> 1));
        long long v20 = v47 - 125;
        if ((uint64_t *)v24 == v47 - 125)
        {
          KB::Candidate::operator=((uint64_t *)v24, &v49);
          uint64_t v19 = (uint64_t)v48;
        }
        else
        {
          KB::Candidate::operator=((uint64_t *)v24, v47 - 125);
          KB::Candidate::operator=(v20, &v49);
          uint64_t v19 = (uint64_t)v48;
          uint64_t v32 = v24 - (void)v48 + 1000;
          if (v32 >= 1001)
          {
            unint64_t v33 = (v32 / 0x3E8uLL - 2) >> 1;
            int v34 = (KB::Candidate *)((char *)v48 + 1000 * v33);
            KB::Candidate::capitalized_string(v34, (uint64_t)&v52);
            KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)v58);
            char v35 = v53;
            if (v53) {
              char v36 = (const char *)v53;
            }
            else {
              char v36 = v54;
            }
            uint64_t v37 = v60;
            if (v60) {
              uint64_t v38 = (const char *)v60;
            }
            else {
              uint64_t v38 = (const char *)v61;
            }
            int v39 = strcmp(v36, v38);
            if (v37 && v59 == 1)
            {
              free(v37);
              char v35 = v53;
            }
            if (v35 && BYTE6(v52) == 1) {
              free(v35);
            }
            if (v39 < 0)
            {
              KB::Candidate::Candidate((uint64_t)&v52, v24);
              do
              {
                char v40 = (uint64_t *)v34;
                KB::Candidate::operator=((uint64_t *)v24, (uint64_t *)v34);
                if (!v33) {
                  break;
                }
                unint64_t v33 = (v33 - 1) >> 1;
                int v34 = (KB::Candidate *)((char *)v48 + 1000 * v33);
                KB::Candidate::capitalized_string(v34, (uint64_t)v58);
                KB::Candidate::capitalized_string((KB::Candidate *)&v52, (uint64_t)v55);
                int v41 = v60;
                if (v60) {
                  __int16 v42 = (const char *)v60;
                }
                else {
                  __int16 v42 = (const char *)v61;
                }
                char v43 = v56;
                if (v56) {
                  unint64_t v44 = (const char *)v56;
                }
                else {
                  unint64_t v44 = (const char *)&v57;
                }
                int v45 = strcmp(v42, v44);
                if (v43 && v55[6] == 1)
                {
                  free(v43);
                  int v41 = v60;
                }
                if (v41)
                {
                  if (v59 == 1) {
                    free(v41);
                  }
                }
                uint64_t v24 = (uint64_t)v40;
              }
              while (v45 < 0);
              KB::Candidate::operator=(v40, &v52);
              KB::Candidate::~Candidate((KB::Candidate *)&v52);
            }
          }
        }
        KB::Candidate::~Candidate((KB::Candidate *)&v49);
      }
      while (v21-- > 2);
    }
  }
}

KB::Candidate *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(uint64_t *a1, KB::Candidate *a2)
{
  v49[2] = *MEMORY[0x1E4F143B8];
  KB::Candidate::Candidate((uint64_t)v41, (uint64_t)a1);
  KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
  KB::Candidate::capitalized_string((KB::Candidate *)((char *)a2 - 1000), (uint64_t)v42);
  char v4 = v48;
  if (v48) {
    uint64_t v5 = (const char *)v48;
  }
  else {
    uint64_t v5 = (const char *)v49;
  }
  uint64_t v6 = v44;
  if (v44) {
    uint64_t v7 = (const char *)v44;
  }
  else {
    uint64_t v7 = v45;
  }
  int v8 = strcmp(v5, v7);
  if (v6 && v43 == 1)
  {
    free(v6);
    char v4 = v48;
  }
  if (v4 && v47 == 1) {
    free(v4);
  }
  if (v8 < 0)
  {
    int v10 = (KB::Candidate *)a1;
    do
    {
      int v10 = (KB::Candidate *)((char *)v10 + 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      int v16 = v48;
      if (v48) {
        int v17 = (const char *)v48;
      }
      else {
        int v17 = (const char *)v49;
      }
      BOOL v18 = v44;
      if (v44) {
        uint64_t v19 = (const char *)v44;
      }
      else {
        uint64_t v19 = v45;
      }
      int v20 = strcmp(v17, v19);
      if (v18) {
        BOOL v21 = v43 == 1;
      }
      else {
        BOOL v21 = 0;
      }
      if (v21)
      {
        free(v18);
        int v16 = v48;
      }
      if (v16 && v47 == 1) {
        free(v16);
      }
    }
    while ((v20 & 0x80000000) == 0);
  }
  else
  {
    unint64_t v9 = (KB::Candidate *)(a1 + 125);
    do
    {
      int v10 = v9;
      if (v9 >= a2) {
        break;
      }
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      BOOL v11 = v48;
      if (v48) {
        int v12 = (const char *)v48;
      }
      else {
        int v12 = (const char *)v49;
      }
      BOOL v13 = v44;
      if (v44) {
        uint64_t v14 = (const char *)v44;
      }
      else {
        uint64_t v14 = v45;
      }
      int v15 = strcmp(v12, v14);
      if (v13 && v43 == 1)
      {
        free(v13);
        BOOL v11 = v48;
      }
      if (v11 && v47 == 1) {
        free(v11);
      }
      unint64_t v9 = (KB::Candidate *)((char *)v10 + 1000);
    }
    while ((v15 & 0x80000000) == 0);
  }
  if (v10 < a2)
  {
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(a2, (uint64_t)v42);
      uint64_t v22 = v48;
      if (v48) {
        uint64_t v23 = (const char *)v48;
      }
      else {
        uint64_t v23 = (const char *)v49;
      }
      uint64_t v24 = v44;
      if (v44) {
        uint64_t v25 = (const char *)v44;
      }
      else {
        uint64_t v25 = v45;
      }
      int v26 = strcmp(v23, v25);
      if (v24) {
        BOOL v27 = v43 == 1;
      }
      else {
        BOOL v27 = 0;
      }
      if (v27)
      {
        free(v24);
        uint64_t v22 = v48;
      }
      if (v22 && v47 == 1) {
        free(v22);
      }
    }
    while (v26 < 0);
  }
  while (v10 < a2)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v10, (uint64_t *)a2);
    do
    {
      int v10 = (KB::Candidate *)((char *)v10 + 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(v10, (uint64_t)v42);
      char v28 = v48;
      if (v48) {
        char v29 = (const char *)v48;
      }
      else {
        char v29 = (const char *)v49;
      }
      uint64_t v30 = v44;
      if (v44) {
        int v31 = (const char *)v44;
      }
      else {
        int v31 = v45;
      }
      int v32 = strcmp(v29, v31);
      if (v30) {
        BOOL v33 = v43 == 1;
      }
      else {
        BOOL v33 = 0;
      }
      if (v33)
      {
        free(v30);
        char v28 = v48;
      }
      if (v28 && v47 == 1) {
        free(v28);
      }
    }
    while ((v32 & 0x80000000) == 0);
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string((KB::Candidate *)v41, (uint64_t)v46);
      KB::Candidate::capitalized_string(a2, (uint64_t)v42);
      int v34 = v48;
      if (v48) {
        char v35 = (const char *)v48;
      }
      else {
        char v35 = (const char *)v49;
      }
      char v36 = v44;
      if (v44) {
        uint64_t v37 = (const char *)v44;
      }
      else {
        uint64_t v37 = v45;
      }
      int v38 = strcmp(v35, v37);
      if (v36) {
        BOOL v39 = v43 == 1;
      }
      else {
        BOOL v39 = 0;
      }
      if (v39)
      {
        free(v36);
        int v34 = v48;
      }
      if (v34 && v47 == 1) {
        free(v34);
      }
    }
    while (v38 < 0);
  }
  if ((uint64_t *)((char *)v10 - 1000) != a1) {
    KB::Candidate::operator=(a1, (uint64_t *)v10 - 125);
  }
  KB::Candidate::operator=((uint64_t *)v10 - 125, v41);
  KB::Candidate::~Candidate((KB::Candidate *)v41);
  return v10;
}

uint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,KB::Candidate *,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &>(uint64_t a1, KB::Candidate *a2)
{
  v47[2] = *MEMORY[0x1E4F143B8];
  KB::Candidate::Candidate((uint64_t)v39, a1);
  char v4 = (KB::Candidate *)a1;
  do
  {
    char v4 = (KB::Candidate *)((char *)v4 + 1000);
    KB::Candidate::capitalized_string(v4, (uint64_t)v44);
    KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
    uint64_t v5 = v46;
    if (v46) {
      uint64_t v6 = (const char *)v46;
    }
    else {
      uint64_t v6 = (const char *)v47;
    }
    uint64_t v7 = v42;
    if (v42) {
      int v8 = (const char *)v42;
    }
    else {
      int v8 = v43;
    }
    int v9 = strcmp(v6, v8);
    if (v7) {
      BOOL v10 = v41 == 1;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10)
    {
      free(v7);
      uint64_t v5 = v46;
    }
    if (v5 && v45 == 1) {
      free(v5);
    }
  }
  while (v9 < 0);
  BOOL v11 = (uint64_t *)((char *)v4 - 1000);
  int v38 = (uint64_t *)a1;
  if ((KB::Candidate *)((char *)v4 - 1000) == (KB::Candidate *)a1)
  {
    do
    {
      if (v4 >= a2) {
        break;
      }
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string(a2, (uint64_t)v44);
      KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
      BOOL v18 = v46;
      if (v46) {
        uint64_t v19 = (const char *)v46;
      }
      else {
        uint64_t v19 = (const char *)v47;
      }
      int v20 = v42;
      if (v42) {
        BOOL v21 = (const char *)v42;
      }
      else {
        BOOL v21 = v43;
      }
      int v22 = strcmp(v19, v21);
      if (v20 && v41 == 1)
      {
        free(v20);
        BOOL v18 = v46;
      }
      if (v18 && v45 == 1) {
        free(v18);
      }
    }
    while ((v22 & 0x80000000) == 0);
  }
  else
  {
    do
    {
      a2 = (KB::Candidate *)((char *)a2 - 1000);
      KB::Candidate::capitalized_string(a2, (uint64_t)v44);
      KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
      int v12 = v46;
      if (v46) {
        BOOL v13 = (const char *)v46;
      }
      else {
        BOOL v13 = (const char *)v47;
      }
      uint64_t v14 = v42;
      if (v42) {
        int v15 = (const char *)v42;
      }
      else {
        int v15 = v43;
      }
      int v16 = strcmp(v13, v15);
      if (v14) {
        BOOL v17 = v41 == 1;
      }
      else {
        BOOL v17 = 0;
      }
      if (v17)
      {
        free(v14);
        int v12 = v46;
      }
      if (v12 && v45 == 1) {
        free(v12);
      }
    }
    while ((v16 & 0x80000000) == 0);
  }
  if (v4 < a2)
  {
    uint64_t v23 = (uint64_t *)v4;
    uint64_t v24 = (uint64_t *)a2;
    do
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v23, v24);
      do
      {
        v23 += 125;
        KB::Candidate::capitalized_string((KB::Candidate *)v23, (uint64_t)v44);
        KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
        uint64_t v25 = v46;
        if (v46) {
          int v26 = (const char *)v46;
        }
        else {
          int v26 = (const char *)v47;
        }
        BOOL v27 = v42;
        if (v42) {
          char v28 = (const char *)v42;
        }
        else {
          char v28 = v43;
        }
        int v29 = strcmp(v26, v28);
        if (v27) {
          BOOL v30 = v41 == 1;
        }
        else {
          BOOL v30 = 0;
        }
        if (v30)
        {
          free(v27);
          uint64_t v25 = v46;
        }
        if (v25 && v45 == 1) {
          free(v25);
        }
      }
      while (v29 < 0);
      BOOL v11 = v23 - 125;
      do
      {
        v24 -= 125;
        KB::Candidate::capitalized_string((KB::Candidate *)v24, (uint64_t)v44);
        KB::Candidate::capitalized_string((KB::Candidate *)v39, (uint64_t)v40);
        int v31 = v46;
        if (v46) {
          int v32 = (const char *)v46;
        }
        else {
          int v32 = (const char *)v47;
        }
        BOOL v33 = v42;
        if (v42) {
          int v34 = (const char *)v42;
        }
        else {
          int v34 = v43;
        }
        int v35 = strcmp(v32, v34);
        if (v33) {
          BOOL v36 = v41 == 1;
        }
        else {
          BOOL v36 = 0;
        }
        if (v36)
        {
          free(v33);
          int v31 = v46;
        }
        if (v31 && v45 == 1) {
          free(v31);
        }
      }
      while ((v35 & 0x80000000) == 0);
    }
    while (v23 < v24);
  }
  if (v11 != v38) {
    KB::Candidate::operator=(v38, v11);
  }
  KB::Candidate::operator=(v11, v39);
  KB::Candidate::~Candidate((KB::Candidate *)v39);
  return v11;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t a1, KB::Candidate *a2)
{
  long long v2 = a2;
  v38[2] = *MEMORY[0x1E4F143B8];
  BOOL v4 = 1;
  switch(0x1CAC083126E978D5 * (((uint64_t)a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      KB::Candidate::capitalized_string((KB::Candidate *)((char *)a2 - 1000), (uint64_t)&v29);
      KB::Candidate::capitalized_string((KB::Candidate *)a1, (uint64_t)v35);
      uint64_t v5 = v30;
      if (v30) {
        uint64_t v6 = (const char *)v30;
      }
      else {
        uint64_t v6 = v31;
      }
      uint64_t v7 = v37;
      if (v37) {
        int v8 = (const char *)v37;
      }
      else {
        int v8 = (const char *)v38;
      }
      int v9 = strcmp(v6, v8);
      if (v7 && v36 == 1)
      {
        free(v7);
        uint64_t v5 = v30;
      }
      if (v5 && BYTE6(v29) == 1) {
        free(v5);
      }
      if (v9 < 0) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)v2 - 125);
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*,0>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000), (KB::Candidate *)(a1 + 3000), (KB::Candidate *)((char *)a2 - 1000));
      return v4;
    default:
      BOOL v10 = (KB::Candidate *)(a1 + 2000);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>((KB::Candidate *)a1, (KB::Candidate *)(a1 + 1000), (KB::Candidate *)(a1 + 2000));
      BOOL v11 = (KB::Candidate *)(a1 + 3000);
      if ((KB::Candidate *)(a1 + 3000) == v2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      char v28 = v2;
      break;
  }
  while (1)
  {
    KB::Candidate::capitalized_string(v11, (uint64_t)&v29);
    KB::Candidate::capitalized_string(v10, (uint64_t)v35);
    uint64_t v14 = v30;
    if (v30) {
      int v15 = (const char *)v30;
    }
    else {
      int v15 = v31;
    }
    int v16 = v37;
    if (v37) {
      BOOL v17 = (const char *)v37;
    }
    else {
      BOOL v17 = (const char *)v38;
    }
    int v18 = strcmp(v15, v17);
    if (v16) {
      BOOL v19 = v36 == 1;
    }
    else {
      BOOL v19 = 0;
    }
    if (v19)
    {
      free(v16);
      uint64_t v14 = v30;
    }
    if (v14 && BYTE6(v29) == 1) {
      free(v14);
    }
    if ((v18 & 0x80000000) == 0) {
      goto LABEL_53;
    }
    KB::Candidate::Candidate((uint64_t)&v29, (uint64_t)v11);
    uint64_t v20 = v12;
    while (1)
    {
      KB::Candidate::operator=((uint64_t *)(a1 + v20 + 3000), (uint64_t *)(a1 + v20 + 2000));
      if (v20 == -2000) {
        break;
      }
      KB::Candidate::capitalized_string((KB::Candidate *)&v29, (uint64_t)v35);
      KB::Candidate::capitalized_string((KB::Candidate *)(a1 + v20 + 1000), (uint64_t)v32);
      BOOL v21 = v37;
      if (v37) {
        int v22 = (const char *)v37;
      }
      else {
        int v22 = (const char *)v38;
      }
      uint64_t v23 = v33;
      if (v33) {
        uint64_t v24 = (const char *)v33;
      }
      else {
        uint64_t v24 = (const char *)&v34;
      }
      int v25 = strcmp(v22, v24);
      if (v23 && v32[6] == 1)
      {
        free(v23);
        BOOL v21 = v37;
      }
      if (v21 && v36 == 1) {
        free(v21);
      }
      v20 -= 1000;
      if ((v25 & 0x80000000) == 0)
      {
        int v26 = (uint64_t *)(a1 + v20 + 3000);
        goto LABEL_51;
      }
    }
    int v26 = (uint64_t *)a1;
LABEL_51:
    KB::Candidate::operator=(v26, &v29);
    ++v13;
    long long v2 = v28;
    if (v13 == 8) {
      break;
    }
    KB::Candidate::~Candidate((KB::Candidate *)&v29);
LABEL_53:
    BOOL v10 = v11;
    v12 += 1000;
    BOOL v11 = (KB::Candidate *)((char *)v11 + 1000);
    if (v11 == v2) {
      return 1;
    }
  }
  BOOL v4 = (KB::Candidate *)((char *)v11 + 1000) == v28;
  KB::Candidate::~Candidate((KB::Candidate *)&v29);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelStr::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0 &,KB::Candidate*>(uint64_t a1, uint64_t a2, KB::Candidate *a3)
{
  v45[2] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a2 - 2;
  if (a2 >= 2)
  {
    BOOL v4 = a3;
    uint64_t v34 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * (((uint64_t)a3 - a1) >> 3))
    {
      uint64_t v6 = a2;
      uint64_t v7 = (0x395810624DD2F1AALL * (((uint64_t)a3 - a1) >> 3)) | 1;
      uint64_t v8 = a1 + 1000 * v7;
      uint64_t v9 = 0x395810624DD2F1AALL * (((uint64_t)a3 - a1) >> 3) + 2;
      if (v9 < a2)
      {
        KB::Candidate::capitalized_string((KB::Candidate *)(a1 + 1000 * v7), (uint64_t)&v35);
        KB::Candidate::capitalized_string((KB::Candidate *)(v8 + 1000), (uint64_t)v42);
        BOOL v10 = v36;
        if (v36) {
          BOOL v11 = (const char *)v36;
        }
        else {
          BOOL v11 = v37;
        }
        uint64_t v12 = v44;
        if (v44) {
          int v13 = (const char *)v44;
        }
        else {
          int v13 = (const char *)v45;
        }
        int v14 = strcmp(v11, v13);
        if (v12 && v43 == 1)
        {
          free(v12);
          BOOL v10 = v36;
        }
        if (v10 && BYTE6(v35) == 1) {
          free(v10);
        }
        if (v14 < 0)
        {
          v8 += 1000;
          uint64_t v7 = v9;
        }
        uint64_t v6 = a2;
      }
      KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)&v35);
      KB::Candidate::capitalized_string(v4, (uint64_t)v42);
      int v15 = v36;
      if (v36) {
        int v16 = (const char *)v36;
      }
      else {
        int v16 = v37;
      }
      BOOL v17 = v44;
      if (v44) {
        int v18 = (const char *)v44;
      }
      else {
        int v18 = (const char *)v45;
      }
      int v19 = strcmp(v16, v18);
      if (v17 && v43 == 1)
      {
        free(v17);
        int v15 = v36;
      }
      if (v15 && BYTE6(v35) == 1) {
        free(v15);
      }
      if ((v19 & 0x80000000) == 0)
      {
        uint64_t v33 = a1;
        KB::Candidate::Candidate((uint64_t)&v35, (uint64_t)v4);
        do
        {
          uint64_t v20 = (uint64_t *)v8;
          KB::Candidate::operator=((uint64_t *)v4, (uint64_t *)v8);
          if (v34 < v7) {
            break;
          }
          uint64_t v21 = (2 * v7) | 1;
          uint64_t v8 = v33 + 1000 * v21;
          uint64_t v7 = 2 * v7 + 2;
          if (v7 >= v6)
          {
            uint64_t v7 = v21;
          }
          else
          {
            KB::Candidate::capitalized_string((KB::Candidate *)(v33 + 1000 * v21), (uint64_t)v42);
            KB::Candidate::capitalized_string((KB::Candidate *)(v8 + 1000), (uint64_t)v38);
            int v22 = v44;
            if (v44) {
              uint64_t v23 = (const char *)v44;
            }
            else {
              uint64_t v23 = (const char *)v45;
            }
            uint64_t v24 = v40;
            if (v40) {
              int v25 = (const char *)v40;
            }
            else {
              int v25 = v41;
            }
            int v26 = strcmp(v23, v25);
            if (v24 && v39 == 1)
            {
              free(v24);
              int v22 = v44;
            }
            if (v22 && v43 == 1) {
              free(v22);
            }
            if (v26 >= 0) {
              uint64_t v7 = v21;
            }
            else {
              v8 += 1000;
            }
            uint64_t v6 = a2;
          }
          KB::Candidate::capitalized_string((KB::Candidate *)v8, (uint64_t)v42);
          KB::Candidate::capitalized_string((KB::Candidate *)&v35, (uint64_t)v38);
          BOOL v27 = v44;
          if (v44) {
            char v28 = (const char *)v44;
          }
          else {
            char v28 = (const char *)v45;
          }
          uint64_t v29 = v40;
          if (v40) {
            BOOL v30 = (const char *)v40;
          }
          else {
            BOOL v30 = v41;
          }
          int v31 = strcmp(v28, v30);
          if (v29 && v39 == 1)
          {
            free(v29);
            BOOL v27 = v44;
          }
          if (v27)
          {
            if (v43 == 1) {
              free(v27);
            }
          }
          BOOL v4 = (KB::Candidate *)v20;
        }
        while ((v31 & 0x80000000) == 0);
        KB::Candidate::operator=(v20, &v35);
        KB::Candidate::~Candidate((KB::Candidate *)&v35);
      }
    }
  }
}

char *std::vector<KB::Candidate>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x4189374BC6A7F0) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[1000 * v4];
  return result;
}

BOOL KB::LanguageModelStr::predictions(void *a1, uint64_t *a2, const KB::LanguageModelContext *a3, void **a4, int a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  char v23 = 0;
  v22[0] = (uint64_t)a1;
  v22[1] = (uint64_t)a3;
  if ((*(unsigned int (**)(void *))(*a1 + 144))(a1))
  {
    if (a2[1] == *a2) {
      return 0;
    }
    int64x2_t v20 = 0uLL;
    long long __p = 0;
    convert_to_lm_completion_stem(a2, &v20, a5);
    uint64_t v24 = 0;
    uint64_t v9 = (void ***)operator new(0x40uLL);
    *uint64_t v9 = (void **)&unk_1F3F71BF0;
    v9[1] = (void **)a2;
    v9[2] = (void **)a3;
    _OWORD v9[3] = (void **)v22;
    v9[4] = a4;
    v9[5] = (void **)a1;
    void v9[6] = (void **)&v23;
    v9[7] = (void **)&v24;
    char v28 = v9;
    (*(void (**)(void *, int64x2_t *))(*a1 + 528))(a1, &v20);
    if (v28 == v27)
    {
      (*((void (**)(void ***))v27[0] + 4))(v27);
    }
    else if (v28)
    {
      ((void (*)(void))(*v28)[5])();
    }
    v27[0] = (void **)&v20;
    std::vector<language_modeling::v1::CompletionStem>::__destroy_vector::operator()[abi:nn180100](v27);
  }
  else
  {
    BOOL v10 = (const KB::Candidate *)*a2;
    if (*a2 != a2[1])
    {
      KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v20, a3);
      KB::Candidate::Candidate((KB::Candidate *)v27, v10);
      KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(v22, (KB::LanguageModelContext *)&v20, (uint64_t)v27[0], (uint64_t)v27[1]);
      KB::LanguageModelStr::cache_key_for_candidate(v10, (uint64_t)&v24);
      uint64_t v11 = a1[42];
      if (v11)
      {
        if (v25) {
          uint64_t v12 = (const char *)v25;
        }
        else {
          uint64_t v12 = (const char *)&v26;
        }
        int v13 = a1 + 42;
        do
        {
          if (*(void *)(v11 + 40)) {
            int v14 = *(const char **)(v11 + 40);
          }
          else {
            int v14 = (const char *)(v11 + 48);
          }
          int v15 = strcmp(v14, v12);
          int v16 = (uint64_t *)(v11 + 8);
          if (v15 >= 0)
          {
            int v16 = (uint64_t *)v11;
            int v13 = (void *)v11;
          }
          uint64_t v11 = *v16;
        }
        while (*v16);
        if (a1 + 42 != v13)
        {
          if (v13[5]) {
            BOOL v17 = (const char *)v13[5];
          }
          else {
            BOOL v17 = (const char *)(v13 + 6);
          }
          strcmp(v12, v17);
        }
      }
      operator new();
    }
  }
  return v23 != 0;
}

void KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(uint64_t *a1, KB::LanguageModelContext *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = 240 * a3;
    do
    {
      if ((*(unsigned char *)(a4 + 135) & 4) == 0) {
        goto LABEL_9;
      }
      __int16 v14 = 0;
      char v15 = 0;
      int v16 = " ";
      int v13 = 1048577;
      char v17 = 0;
      if ((int *)a4 != &v13)
      {
        BOOL v9 = KB::String::equal((KB::String *)a4, (const KB::String *)&v13, 1);
        if (v16 && v15 == 1) {
          free(v16);
        }
        if (!v9)
        {
LABEL_9:
          *(float *)(a4 + 96) = (*(float (**)(uint64_t, void, uint64_t))(*(void *)v7 + 456))(v7, *(unsigned int *)(a4 + 136), a1[1]);
          TITokenID v10 = *(TITokenID *)(a4 + 136);
          KB::Word::capitalized_string((KB::Word *)a4, (uint64_t)&v13);
          TITokenID v11 = v10;
          KB::LanguageModelContext::append(a2, v11, (const KB::String *)&v13, 0);
          if (v16) {
            BOOL v12 = v15 == 1;
          }
          else {
            BOOL v12 = 0;
          }
          if (v12) {
            free(v16);
          }
        }
      }
      a4 += 240;
      v8 -= 240;
    }
    while (v8);
  }
}

void KB::LanguageModelStr::cache_key_for_candidate(KB::LanguageModelStr *this@<X0>, uint64_t a2@<X8>)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  *(_DWORD *)a2 = 0x100000;
  *(_WORD *)(a2 + 4) = 0;
  *(unsigned char *)(a2 + 6) = 0;
  *(void *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 16) = 0;
  uint64_t v5 = -3 * (*((void *)this + 101) - (*((void *)this + 100) + 8 * *((void *)this + 103)));
  if (v5)
  {
    uint64_t v6 = *((void *)this + 109);
    do
    {
      uint64_t v7 = (const char *)(v6 + v5);
      if (*(char *)(v6 + v5 + 23) < 0) {
        uint64_t v7 = *(const char **)v7;
      }
      KB::String::append_format((KB::String *)a2, "%s ", v7);
      v5 += 24;
    }
    while (v5);
  }
  KB::String::append((unsigned __int16 *)a2, "| ", 0xFFFFuLL);
  uint64_t v8 = *(void *)this;
  if (*(void *)this)
  {
    uint64_t v9 = *((void *)this + 1);
    uint64_t v10 = 240 * v8;
    do
    {
      if (*(_WORD *)v9)
      {
        if ((*(unsigned char *)(v9 + 135) & 4) == 0
          || (*(void *)(v9 + 8) ? (TITokenID v11 = *(const char **)(v9 + 8)) : (TITokenID v11 = (const char *)(v9 + 16)), strcmp(v11, " ")))
        {
          KB::Word::capitalized_string((KB::Word *)v9, (uint64_t)v14);
          BOOL v12 = (const char *)v16;
          if (!v16) {
            BOOL v12 = (const char *)v17;
          }
          if (v14[0]) {
            int v13 = v12;
          }
          else {
            int v13 = "";
          }
          KB::String::append_format((KB::String *)a2, "%s ", v13);
          if (v16)
          {
            if (v15 == 1) {
              free(v16);
            }
          }
        }
      }
      v9 += 240;
      v10 -= 240;
    }
    while (v10);
  }
}

void *std::__function::__value_func<void ()(KB::LanguageModel::PredictionInfo const&)>::~__value_func[abi:nn180100](void *a1)
{
  long long v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  unint64_t v5 = v4[1];
  unint64_t v6 = v4[2];
  if (v5 >= v6)
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v5 - *v4) >> 5);
    if (v8 + 1 > 0x199999999999999) {
      goto LABEL_16;
    }
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *v4) >> 5);
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= v8 + 1) {
      uint64_t v10 = v8 + 1;
    }
    if (v9 >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v11 = 0x199999999999999;
    }
    else {
      unint64_t v11 = v10;
    }
    int v19 = v4 + 2;
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v15 = v11;
    uint64_t v16 = v11 + 160 * v8;
    unint64_t v18 = v11 + 160 * v12;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v16, a2);
    uint64_t v17 = v16 + 160;
    std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(v4, &v15);
    uint64_t v7 = v4[1];
    std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    uint64_t v7 = std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v5, a2)+ 160;
  }
  v4[1] = v7;
  uint64_t v13 = *(void *)(*(void *)(a1 + 24) + 24);
  if (!v13)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_16:
    abort();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void))(*(void *)v13 + 48))(v13, a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
  **(unsigned char **)(a1 + 16) |= result;
  return result;
}

uint64_t std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = std::vector<TITokenID>::vector((void *)a1, a2);
  long long v5 = *(_OWORD *)(a2 + 24);
  *((_DWORD *)v4 + 10) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)(v4 + 3) = v5;
  unint64_t v6 = (std::string *)(v4 + 6);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v7 = *(_OWORD *)(a2 + 48);
    v6->__r_.__value_.__r.__words[2] = *(void *)(a2 + 64);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  unint64_t v8 = (std::string *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a1 + 96), *(long long **)(a2 + 96), *(long long **)(a2 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3));
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a1 + 120), *(long long **)(a2 + 120), *(long long **)(a2 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 3));
  *(_OWORD *)(a1 + 144) = *(_OWORD *)(a2 + 144);
  return a1;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71C38;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1)
{
  long long v2 = (char *)operator new(0x30uLL);
  *(void *)long long v2 = &unk_1F3F71C38;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_2>,void ()(KB::LanguageModel::PredictionInfo const&)>::~__func()
{
}

void std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2)
  {
    long long v5 = (void **)(v2 + 32);
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v5);
    long long v3 = *(void **)(v2 + 8);
    if (v3 && *(unsigned char *)(v2 + 6) == 1) {
      free(v3);
    }
    MEMORY[0x1E4E7BC20](v2, 0x1030C4086507075);
  }
  uint64_t v4 = *(void **)(a1 + 8);
  if (v4 && *(unsigned char *)(a1 + 6) == 1)
  {
    free(v4);
  }
}

uint64_t *std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  long long v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      long long v3 = a2;
      goto LABEL_7;
    }
    do
    {
      long long v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  unint64_t v6 = (uint64_t **)v3[2];
  long long v7 = *v6;
  if (*v6 == v3)
  {
    *unint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      long long v7 = 0;
      __n128 result = (uint64_t *)v2;
    }
    else
    {
      long long v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *long long v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      __n128 result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 16) = v12;
      }
      v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 16) = v7;
      if (result == (uint64_t *)v12) {
        __n128 result = v7;
      }
      long long v7 = *(uint64_t **)v12;
    }
    int v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    int64x2_t v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        int64x2_t v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 16) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        *int64x2_t v20 = (uint64_t)v7;
        v7[2] = (uint64_t)v20;
        int v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      uint64_t v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 16) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    long long v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 16) = v12;
    }
    v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *uint64_t v13 = v12;
    *(void *)(v12 + 16) = v13;
    if (result == (uint64_t *)*v7) {
      __n128 result = v7;
    }
    long long v7 = *(uint64_t **)(*v7 + 8);
  }
  unint64_t v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    uint64_t v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  uint64_t v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    unint64_t v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    *long long v7 = v22;
    if (v22) {
      *(void *)(v22 + 16) = v7;
    }
    v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    v7[2] = (uint64_t)v15;
    uint64_t v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  uint64_t v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 16) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  uint64_t *v24 = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      long long v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), int v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              long long v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *uint64_t v9 = v2;
            v2[2] = (uint64_t)v9;
            long long v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *long long v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), int v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          uint64_t *v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            long long v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          long long v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        uint64_t *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *int v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

BOOL std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::operator()(uint64_t a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  language_modeling::v1::Prediction::Prediction();
  uint64_t v2 = *(void *)(a1 + 40);
  long long v3 = *(void **)(a1 + 8);
  uint64_t v4 = language_modeling::v1::Prediction::unique_id((language_modeling::v1::Prediction *)v13);
  KB::Candidate::Candidate((KB::Candidate *)&v28, (const KB::Candidate *)(*v3 + 1000 * v4));
  for (uint64_t i = v28; v28; uint64_t i = v28)
  {
    if (KB::Word::is_linguistically_void((KB::Word *)(v29 + 240 * i - 240))) {
      break;
    }
    KB::Candidate::pop_last_word((KB::Candidate *)&v28);
  }
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v20, *(const KB::LanguageModelContext **)(a1 + 16));
  KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)const::$_0::operator()(*(uint64_t **)(a1 + 24), (KB::LanguageModelContext *)v20, v28, v29);
  uint64_t v6 = *(void *)(a1 + 32);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2);
  KB::LanguageModel::PredictionInfo::PredictionInfo((KB::LanguageModel::PredictionInfo *)v14, (const language_modeling::v1::Prediction *)v13, v7);
  uint64_t v8 = *(void *)(v6 + 24);
  if (!v8) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  int v9 = (*(uint64_t (**)(uint64_t, void **, uint64_t *, unsigned char *))(*(void *)v8 + 48))(v8, v14, &v28, v20);
  uint64_t v27 = (void **)&v19;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v27);
  uint64_t v27 = (void **)&v18;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v27);
  if (v17 < 0) {
    operator delete(__p);
  }
  if (v15 < 0) {
    operator delete(v14[6]);
  }
  if (v14[0])
  {
    v14[1] = v14[0];
    operator delete(v14[0]);
  }
  **(unsigned char **)(a1 + 48) |= v9;
  uint64_t v10 = *(unint64_t **)(a1 + 56);
  unint64_t v11 = *v10;
  if (v9) {
    unint64_t *v10 = ++v11;
  }
  v14[0] = &v26;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)v14);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v25);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v24);
  if (v22)
  {
    uint64_t v23 = v22;
    operator delete(v22);
  }
  if (v21) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v21);
  }
  KB::Candidate::~Candidate((KB::Candidate *)&v28);
  language_modeling::v1::Prediction::~Prediction((language_modeling::v1::Prediction *)v13);
  return v11 < 5;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71BF0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 56) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_1F3F71BF0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + 7) = *(void *)(a1 + 56);
  return result;
}

void std::__function::__func<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1,std::allocator<KB::LanguageModelStr::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_1>,BOOL ()(language_modeling::v1::Prediction const&)>::~__func()
{
}

BOOL KB::LanguageModelStr::is_text_blocklisted(KB::LanguageModel *a1, int a2, int a3, const KB::LanguageModelContext *a4, uint64_t a5)
{
  KB::LanguageModel::lexicon_id_active(a1, a3);
  if (!(*(unsigned int (**)(KB::LanguageModel *))(*(void *)a1 + 16))(a1)
    || !*(void *)a5
    || **(void **)(*(void *)a5 + 8) == *(void *)(*(void *)(*(void *)a5 + 8) + 8))
  {
    return 1;
  }
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  v10[0] = 0;
  v10[1] = v10;
  v10[2] = 0x9002000000;
  _OWORD v10[3] = __Block_byref_object_copy__826;
  v10[4] = __Block_byref_object_dispose__827;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v11, a4);
  KB::LanguageModelImplBase::tokenize_text((uint64_t)a1);
  BOOL v8 = *((unsigned char *)v19 + 24) != 0;
  _Block_object_dispose(v10, 8);
  uint64_t v22 = (void **)&v17;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v22);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v16);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v15);
  if (__p)
  {
    uint64_t v14 = __p;
    operator delete(__p);
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v12);
  }
  _Block_object_dispose(&v18, 8);
  return v8;
}

uint64_t __Block_byref_object_copy__826(uint64_t a1, uint64_t a2)
{
  return KB::LanguageModelContext::LanguageModelContext(a1 + 40, a2 + 40);
}

void __Block_byref_object_dispose__827(uint64_t a1)
{
  long long v4 = (void **)(a1 + 120);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v4);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 112));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 104));
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  long long v3 = *(std::__shared_weak_count **)(a1 + 48);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void ___ZNK2KB16LanguageModelStr19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke(uint64_t a1, unsigned __int16 *a2, TITokenID *a3)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) && a3->word_id - 500 <= 0xFFFFFE0C)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    int v7 = *(KB::DictionaryContainer ***)(a1 + 56);
    uint64_t v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    *(_OWORD *)long long __p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v19);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v19 + 8));
    long long v20 = 0uLL;
    uint64_t v21 = 0;
    KB::LanguageModelImplBase::static_words_for_string(v6, a2, v7, (uint64_t)&v15, 1, 1, (uint64_t)&v22);
    uint64_t v24 = (void **)&v20;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v24);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v19 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v19);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*((void *)&v15 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v15 + 1));
    }
    if (v22 == v23)
    {
      LOBYTE(v10) = 0;
    }
    else
    {
      uint64_t v8 = v22 + 240;
      do
      {
        unsigned int v9 = *(_DWORD *)(v8 - 136);
        int v10 = (v9 >> 1) & 1;
        if ((v9 & 2) == 0) {
          break;
        }
        BOOL v11 = v8 == v23;
        v8 += 240;
      }
      while (!v11);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v10;
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v12 + 24))
    {
      char v13 = 1;
    }
    else
    {
      char v13 = (*(uint64_t (**)(uint64_t, unsigned __int16 *, TITokenID, uint64_t, void))(*(void *)v6 + 488))(v6, a2, *a3, *(void *)(*(void *)(a1 + 40) + 8) + 40, *(unsigned int *)(a1 + 64));
      uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    *(unsigned char *)(v12 + 24) = v13;
    TITokenID v14 = *a3;
    KB::LanguageModelContext::append((KB::LanguageModelContext *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v14, (const KB::String *)a2, 0);
    *(void *)&long long v15 = &v22;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v15);
  }
}

BOOL KB::LanguageModelStr::is_token_blocklisted(KB::LanguageModel *a1, KB::String *a2, int a3)
{
  v14[2] = *MEMORY[0x1E4F143B8];
  BOOL v4 = KB::LanguageModel::lexicon_id_active(a1, a3);
  KB::String::space((KB::String *)v4);
  KB::String::trim(a2, (const KB::String *)&KB::String::space(void)::space, (uint64_t)v11);
  if (v11[0])
  {
    if (v13) {
      int v5 = (char *)v13;
    }
    else {
      int v5 = (char *)v14;
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, v5);
    int v10 = 0;
    BOOL v6 = language_modeling::v1::LanguageModel::blocklistStatus() != 0;
    if (v9 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    BOOL v6 = 0;
  }
  if (v13 && v12 == 1) {
    free(v13);
  }
  return v6;
}

void KB::LanguageModelStr::create_prediction_enumerator(KB::LanguageModelStr *this@<X0>, const KB::LanguageModelContext *a2@<X1>, unsigned int a3@<W2>, void *a4@<X8>)
{
  uint64_t v8 = operator new(0x40uLL);
  v8[1] = 0;
  v8[2] = 0;
  void *v8 = &unk_1F3F71C80;
  v8[3] = &unk_1F3F71A90;
  *((_OWORD *)v8 + 3) = 0u;
  *((_OWORD *)v8 + 2) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)this, (uint64_t)a2, a3, v8 + 4);
  *a4 = v8 + 3;
  a4[1] = v8;
}

void KB::LanguageModelStr::get_predictions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    uint64_t v8 = *(void *)(a1 + 184);
    if (v8) {
      atomic_store(1u, (unsigned __int8 *)(v8 + 760));
    }
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    uint64_t v9 = *(void *)(a1 + 184);
    if (v9) {
      atomic_store(0, (unsigned __int8 *)(v9 + 760));
    }
    MEMORY[0x1E4E7B840](&v24, *(void *)(a1 + 200), a2 + 72, a3);
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    int v10 = v24;
    BOOL v11 = v25;
    if (v24 != v25)
    {
      do
      {
        int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
        char v13 = (KB::LanguageModel::PredictionInfo *)a4[1];
        unint64_t v14 = a4[2];
        if ((unint64_t)v13 >= v14)
        {
          unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v13 - *a4) >> 5);
          unint64_t v17 = v16 + 1;
          if (v16 + 1 > 0x199999999999999) {
            abort();
          }
          unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - *a4) >> 5);
          if (2 * v18 > v17) {
            unint64_t v17 = 2 * v18;
          }
          if (v18 >= 0xCCCCCCCCCCCCCCLL) {
            unint64_t v19 = 0x199999999999999;
          }
          else {
            unint64_t v19 = v17;
          }
          v26[4] = a4 + 2;
          if (v19) {
            unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v19);
          }
          else {
            uint64_t v20 = 0;
          }
          uint64_t v21 = (KB::LanguageModel::PredictionInfo *)(v19 + 160 * v16);
          v26[0] = v19;
          v26[1] = v21;
          void v26[3] = v19 + 160 * v20;
          KB::LanguageModel::PredictionInfo::PredictionInfo(v21, v10, v12);
          v26[2] = (char *)v21 + 160;
          std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(a4, v26);
          long long v15 = (char *)a4[1];
          std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v26);
        }
        else
        {
          long long v15 = (char *)KB::LanguageModel::PredictionInfo::PredictionInfo(v13, v10, v12) + 160;
        }
        a4[1] = (uint64_t)v15;
        int v10 = (const language_modeling::v1::Prediction *)((char *)v10 + 8);
      }
      while (v10 != v11);
      int v10 = v24;
    }
    if (v10)
    {
      uint64_t v22 = v25;
      uint64_t v23 = v10;
      if (v25 != v10)
      {
        do
          language_modeling::v1::Prediction::~Prediction((const language_modeling::v1::Prediction *)((char *)v22 - 8));
        while (v22 != v10);
        uint64_t v23 = v24;
      }
      uint64_t v25 = v10;
      operator delete(v23);
    }
  }
}

BOOL KB::LanguageModelStr::PredictionEnumeratorStr::advance(KB::LanguageModelStr::PredictionEnumeratorStr *this)
{
  uint64_t v1 = *((void *)this + 4);
  *((void *)this + 4) = v1 + 1;
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 5);
  if (v1 + 1 >= v2) {
    *((void *)this + 4) = v1;
  }
  return v1 + 1 < v2;
}

__n128 KB::LanguageModelStr::PredictionEnumeratorStr::get_prediction@<Q0>(KB::LanguageModelStr::PredictionEnumeratorStr *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 4);
  uint64_t v4 = *((void *)this + 1);
  uint64_t v5 = v4 + 160 * v3;
  std::vector<TITokenID>::vector((void *)a2, v5);
  long long v6 = *(_OWORD *)(v5 + 24);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(v5 + 40);
  *(_OWORD *)(a2 + 24) = v6;
  int v7 = (std::string *)(a2 + 48);
  uint64_t v8 = (const std::string::value_type **)(v5 + 48);
  if (*(char *)(v5 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *v8, *(void *)(v4 + 160 * v3 + 56));
  }
  else
  {
    long long v9 = *(_OWORD *)v8;
    *(void *)(a2 + 64) = *(void *)(v5 + 64);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  int v10 = (std::string *)(a2 + 72);
  BOOL v11 = (const std::string::value_type **)(v4 + 160 * v3 + 72);
  if (*(char *)(v5 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *v11, *(void *)(v4 + 160 * v3 + 80));
  }
  else
  {
    long long v12 = *(_OWORD *)v11;
    *(void *)(a2 + 88) = *(void *)(v4 + 160 * v3 + 88);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v12;
  }
  uint64_t v13 = v4 + 160 * v3;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a2 + 96), *(long long **)(v13 + 96), *(long long **)(v13 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v13 + 104) - *(void *)(v13 + 96)) >> 3));
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  uint64_t v14 = a2 + 120;
  *(void *)(v14 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)v14, *(long long **)(v13 + 120), *(long long **)(v13 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v13 + 128) - *(void *)(v13 + 120)) >> 3));
  __n128 result = *(__n128 *)(v13 + 144);
  *(__n128 *)(v14 + 24) = result;
  return result;
}

void KB::LanguageModelStr::PredictionEnumeratorStr::~PredictionEnumeratorStr(KB::LanguageModelStr::PredictionEnumeratorStr *this)
{
  *(void *)this = &unk_1F3F71A90;
  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v1);

  JUMPOUT(0x1E4E7BC20);
}

{
  void **v1;

  *(void *)this = &unk_1F3F71A90;
  uint64_t v1 = (void **)((char *)this + 8);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v1);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71C80;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::LanguageModelStr::PredictionEnumeratorStr>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71C80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::LanguageModelStr::clear_prediction_cache(KB::LanguageModelStr *this)
{
  unint64_t v2 = (char *)this + 336;
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*((void **)this + 42));
  *((void *)this + 42) = 0;
  *((void *)this + 43) = 0;
  *((void *)this + 40) = 0;
  *((void *)this + 41) = v2;
  *((void *)this + 39) = 0;
}

void std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*a1);
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

float KB::LanguageModelStr::predictions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    kdebug_trace();
    log = kac_get_log();
    int v10 = (const void *)(a1 ^ 0xCB);
    os_signpost_id_t v11 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCB));
    if (v11 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v12 = v11;
      if (os_signpost_enabled(log))
      {
        LOWORD(v22) = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, log, OS_SIGNPOST_INTERVAL_BEGIN, v12, "kbdManager.languageModel.tokenIDGenerateCompletionsAndPredictions", (const char *)&unk_1E41704BE, (uint8_t *)&v22, 2u);
      }
    }
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    KB::LanguageModelStr::get_predictions(a1, a2, a3, &v22);
    uint64_t v13 = v22;
    uint64_t v14 = v23;
    while (v13 != v14)
    {
      uint64_t v15 = *(void *)(a4 + 24);
      if (!v15)
      {
        unint64_t v19 = (KB::LanguageModel *)std::__throw_bad_function_call[abi:nn180100]();
        return KB::LanguageModel::probability_of_lexicon_given_context(v19, v20, v21);
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)v15 + 48))(v15, v13);
      v13 += 160;
    }
    kdebug_trace();
    unint64_t v16 = kac_get_log();
    os_signpost_id_t v17 = os_signpost_id_make_with_pointer(v16, v10);
    if (v17 - 1 < 0xFFFFFFFFFFFFFFFELL)
    {
      os_signpost_id_t v18 = v17;
      if (os_signpost_enabled(v16))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, v16, OS_SIGNPOST_INTERVAL_END, v18, "kbdManager.languageModel.tokenIDGenerateCompletionsAndPredictions", (const char *)&unk_1E41704BE, buf, 2u);
      }
    }
    *(void *)buf = &v22;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  }
  return result;
}

float KB::LanguageModel::probability_of_lexicon_given_context(KB::LanguageModel *this, unsigned int a2, const LanguageModelContext *a3)
{
  return 1.0;
}

uint64_t KB::LanguageModelImplBase::most_probable_lexicon_for_context(KB::LanguageModelImplBase *this, const LanguageModelContext *a2, float *a3)
{
  *a3 = 1.0;
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

uint64_t KB::LanguageModelImplBase::most_probable_lexicon_for_context(KB::LanguageModelImplBase *this, const LanguageModelContext *a2)
{
  return (*(uint64_t (**)(void))(*(void *)this + 40))();
}

void KB::LanguageModelStr::conditional_likelihood_batched(uint64_t a1@<X0>, unsigned int **a2@<X1>, int a3@<W5>, void *a4@<X8>)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)
    && (!a3
     || (language_modeling::v1::LanguageModelSession::supportsNormalizedNameTokenProbability(*(language_modeling::v1::LanguageModelSession **)(a1 + 200)) & 1) != 0))
  {
    char v88 = a3;
    kdebug_trace();
    log = kac_get_log();
    uint64_t v89 = a1;
    ptr = (void *)(a1 ^ 0xCA);
    os_signpost_id_t v8 = os_signpost_id_make_with_pointer(log, (const void *)(a1 ^ 0xCA));
    if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v9 = v8;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, log, OS_SIGNPOST_INTERVAL_BEGIN, v9, "kbdManager.languageModel.conditionalLikelihoodBatched", (const char *)&unk_1E41704BE, buf, 2u);
      }
    }
    v98 = 0;
    v99 = 0;
    unint64_t v100 = 0;
    int v10 = *a2;
    v90 = a2[1];
    if (*a2 != v90)
    {
      do
      {
        v97 = 0;
        long long v96 = 0uLL;
        if (*(void *)v10)
        {
          os_signpost_id_t v11 = (KB::Word *)*((void *)v10 + 1);
          os_signpost_id_t v12 = (KB::Word *)((char *)v11 + 240 * *(void *)v10);
          do
          {
            KB::Word::capitalized_string(v11, (uint64_t)&v104);
            uint64_t v13 = (char *)*((void *)&v104 + 1);
            if (!*((void *)&v104 + 1)) {
              uint64_t v13 = (char *)&v105;
            }
            if ((_WORD)v104) {
              uint64_t v14 = v13;
            }
            else {
              uint64_t v14 = "";
            }
            std::string::basic_string[abi:nn180100]<0>(__p, v14);
            uint64_t v93 = *((void *)v11 + 17);
            KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)&v93, (uint64_t)buf);
            uint64_t v15 = *((void *)&v96 + 1);
            if (*((void *)&v96 + 1) >= (unint64_t)v97)
            {
              uint64_t v16 = (uint64_t)(*((void *)&v96 + 1) - v96) >> 5;
              unint64_t v17 = v16 + 1;
              if ((unint64_t)(v16 + 1) >> 59) {
                goto LABEL_117;
              }
              uint64_t v18 = (uint64_t)&v97[-v96];
              if ((uint64_t)&v97[-v96] >> 4 > v17) {
                unint64_t v17 = v18 >> 4;
              }
              if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFE0) {
                unint64_t v19 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v19 = v17;
              }
              unsigned int v20 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v19);
              uint64_t v22 = &v20[32 * v16];
              *((void *)v22 + 2) = *(void *)&buf[16];
              *(_OWORD *)uint64_t v22 = *(_OWORD *)buf;
              memset(buf, 0, sizeof(buf));
              *((_DWORD *)v22 + 6) = v102;
              uint64_t v23 = *((void *)&v96 + 1);
              uint64_t v24 = v96;
              if (*((void *)&v96 + 1) == (void)v96)
              {
                int64x2_t v27 = vdupq_n_s64(*((unint64_t *)&v96 + 1));
                uint64_t v25 = &v20[32 * v16];
              }
              else
              {
                uint64_t v25 = &v20[32 * v16];
                do
                {
                  long long v26 = *(_OWORD *)(v23 - 32);
                  *((void *)v25 - 2) = *(void *)(v23 - 16);
                  *((_OWORD *)v25 - 2) = v26;
                  *(void *)(v23 - 24) = 0;
                  *(void *)(v23 - 16) = 0;
                  *(void *)(v23 - 32) = 0;
                  *((_DWORD *)v25 - 2) = *(_DWORD *)(v23 - 8);
                  v25 -= 32;
                  v23 -= 32;
                }
                while (v23 != v24);
                int64x2_t v27 = (int64x2_t)v96;
              }
              uint64_t v28 = v22 + 32;
              *(void *)&long long v96 = v25;
              *((void *)&v96 + 1) = v22 + 32;
              v97 = &v20[32 * v21];
              uint64_t v29 = (void **)v27.i64[1];
              uint64_t v30 = (void **)v27.i64[0];
              while (v29 != v30)
              {
                if (*((char *)v29 - 9) < 0) {
                  operator delete(*(v29 - 4));
                }
                v29 -= 4;
              }
              if (v30)
              {
                operator delete(v30);
                *((void *)&v96 + 1) = v28;
                if ((char)buf[23] < 0) {
                  operator delete(*(void **)buf);
                }
              }
              else
              {
                *((void *)&v96 + 1) = v28;
              }
            }
            else
            {
              **((_OWORD **)&v96 + 1) = *(_OWORD *)buf;
              *(void *)(v15 + 16) = *(void *)&buf[16];
              *(_DWORD *)(v15 + 24) = v102;
              *((void *)&v96 + 1) = v15 + 32;
            }
            if (SHIBYTE(v95) < 0) {
              operator delete(__p[0]);
            }
            if (*((void *)&v104 + 1) && BYTE6(v104) == 1) {
              free(*((void **)&v104 + 1));
            }
            os_signpost_id_t v11 = (KB::Word *)((char *)v11 + 240);
          }
          while (v11 != v12);
        }
        int v31 = v99;
        if ((unint64_t)v99 >= v100)
        {
          unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * (((char *)v99 - (unsigned char *)v98) >> 3);
          unint64_t v34 = v33 + 1;
          if (v33 + 1 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_117;
          }
          if (0x5555555555555556 * ((uint64_t)(v100 - (void)v98) >> 3) > v34) {
            unint64_t v34 = 0x5555555555555556 * ((uint64_t)(v100 - (void)v98) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v100 - (void)v98) >> 3) >= 0x555555555555555) {
            unint64_t v35 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v35 = v34;
          }
          if (v35)
          {
            if (v35 > 0xAAAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            char v36 = (char *)operator new(24 * v35);
          }
          else
          {
            char v36 = 0;
          }
          uint64_t v37 = &v36[24 * v33];
          int v38 = &v36[24 * v35];
          *(void *)uint64_t v37 = 0;
          *((void *)v37 + 1) = 0;
          *((void *)v37 + 2) = 0;
          std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(v37, v96, *((uint64_t *)&v96 + 1), (uint64_t)(*((void *)&v96 + 1) - v96) >> 5);
          int v32 = v37 + 24;
          char v39 = v98;
          char v40 = v99;
          if (v99 == v98)
          {
            v98 = v37;
            v99 = v37 + 24;
            unint64_t v100 = (unint64_t)v38;
            if (!v40) {
              goto LABEL_62;
            }
          }
          else
          {
            do
            {
              *((void *)v37 - 3) = 0;
              *((void *)v37 - 2) = 0;
              v37 -= 24;
              *((void *)v37 + 2) = 0;
              long long v41 = *(_OWORD *)(v40 - 3);
              v40 -= 3;
              *(_OWORD *)uint64_t v37 = v41;
              *((void *)v37 + 2) = v40[2];
              void *v40 = 0;
              v40[1] = 0;
              v40[2] = 0;
            }
            while (v40 != v39);
            __int16 v42 = v98;
            char v40 = v99;
            v98 = v37;
            v99 = v32;
            unint64_t v100 = (unint64_t)v38;
            if (v40 != v42)
            {
              do
              {
                v40 -= 3;
                *(void *)buf = v40;
                std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
              }
              while (v40 != v42);
              char v40 = v42;
            }
            if (!v40) {
              goto LABEL_62;
            }
          }
          operator delete(v40);
        }
        else
        {
          void *v99 = 0;
          v31[1] = 0;
          v31[2] = 0;
          std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(v31, v96, *((uint64_t *)&v96 + 1), (uint64_t)(*((void *)&v96 + 1) - v96) >> 5);
          int v32 = v31 + 3;
        }
LABEL_62:
        v99 = v32;
        *(void *)buf = &v96;
        std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v10 += 250;
      }
      while (v10 != v90);
    }
    long long v96 = 0uLL;
    v97 = 0;
    uint64_t v55 = *(void *)(a1 + 184);
    if (v55) {
      atomic_store(1u, (unsigned __int8 *)(v55 + 760));
    }
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    uint64_t v56 = *(void *)(a1 + 184);
    if (v56) {
      atomic_store(0, (unsigned __int8 *)(v56 + 760));
    }
    if (v88) {
      language_modeling::v1::LanguageModelSession::normalizedNameTokenConditionalProbability();
    }
    else {
      language_modeling::v1::LanguageModelSession::detailedConditionalProbability();
    }
    std::vector<std::vector<language_modeling::v1::Probability>>::__vdeallocate((void ***)&v96);
    long long v91 = *(_OWORD *)buf;
    long long v96 = *(_OWORD *)buf;
    v97 = *(char **)&buf[16];
    memset(buf, 0, sizeof(buf));
    *(void *)&long long v104 = buf;
    std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v104);
    uint64_t v57 = (language_modeling::v1::Probability **)v91;
    std::mutex::unlock(*(std::mutex **)(v89 + 136));
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    if ((void)v91 != *((void *)&v91 + 1))
    {
      do
      {
        __p[0] = 0;
        __p[1] = 0;
        v95 = 0;
        char v59 = *v57;
        v58 = v57[1];
        while (v59 != v58)
        {
          language_modeling::v1::Probability::probability();
          *(float *)&double v60 = v60;
          LODWORD(v104) = __exp10f(*(float *)&v60);
          language_modeling::v1::Probability::probability();
          *(float *)&double v61 = v61;
          DWORD1(v104) = __exp10f(*(float *)&v61);
          BYTE8(v104) = language_modeling::v1::Probability::flags(v59) & 3;
          DWORD2(v104) = BYTE8(v104);
          language_modeling::v1::Probability::log((uint64_t *)&v105, v59);
          float v62 = __p[1];
          if (__p[1] >= v95)
          {
            unint64_t v65 = 0xCCCCCCCCCCCCCCCDLL * (((char *)__p[1] - (char *)__p[0]) >> 3);
            unint64_t v66 = v65 + 1;
            if (v65 + 1 > 0x666666666666666) {
              goto LABEL_117;
            }
            if (0x999999999999999ALL * ((v95 - (char *)__p[0]) >> 3) > v66) {
              unint64_t v66 = 0x999999999999999ALL * ((v95 - (char *)__p[0]) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((v95 - (char *)__p[0]) >> 3) >= 0x333333333333333) {
              unint64_t v67 = 0x666666666666666;
            }
            else {
              unint64_t v67 = v66;
            }
            v103 = (void **)&v95;
            if (v67) {
              unint64_t v67 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v67);
            }
            else {
              uint64_t v68 = 0;
            }
            unint64_t v69 = v67 + 40 * v65;
            uint64_t v70 = v104;
            *(_DWORD *)(v69 + 8) = DWORD2(v104);
            *(void *)unint64_t v69 = v70;
            long long v71 = v105;
            *(void *)(v69 + 32) = v106;
            *(_OWORD *)(v69 + 16) = v71;
            uint64_t v106 = 0;
            long long v105 = 0uLL;
            int v73 = (char *)__p[0];
            v72 = (char *)__p[1];
            if (__p[1] == __p[0])
            {
              int64x2_t v78 = vdupq_n_s64((unint64_t)__p[1]);
              unint64_t v74 = v67 + 40 * v65;
            }
            else
            {
              unint64_t v74 = v67 + 40 * v65;
              do
              {
                uint64_t v75 = *((void *)v72 - 5);
                v72 -= 40;
                int v76 = *((_DWORD *)v72 + 2);
                *(void *)(v74 - 40) = v75;
                v74 -= 40;
                *(_DWORD *)(v74 + 8) = v76;
                long long v77 = *((_OWORD *)v72 + 1);
                *(void *)(v74 + 32) = *((void *)v72 + 4);
                *(_OWORD *)(v74 + 16) = v77;
                *((void *)v72 + 3) = 0;
                *((void *)v72 + 4) = 0;
                *((void *)v72 + 2) = 0;
              }
              while (v72 != v73);
              int64x2_t v78 = *(int64x2_t *)__p;
            }
            uint64_t v79 = (void *)(v69 + 40);
            __p[0] = (void *)v74;
            __p[1] = (void *)(v69 + 40);
            *(int64x2_t *)&uint8_t buf[8] = v78;
            v80 = v95;
            v95 = (char *)(v67 + 40 * v68);
            v102 = v80;
            *(void *)buf = v78.i64[0];
            std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer((uint64_t)buf);
            __p[1] = v79;
            if (SHIBYTE(v106) < 0) {
              operator delete((void *)v105);
            }
          }
          else
          {
            uint64_t v63 = v104;
            *((_DWORD *)__p[1] + 2) = DWORD2(v104);
            *float v62 = v63;
            long long v64 = v105;
            v62[4] = v106;
            *((_OWORD *)v62 + 1) = v64;
            __p[1] = v62 + 5;
          }
          char v59 = (language_modeling::v1::Probability *)((char *)v59 + 8);
        }
        std::vector<std::vector<KB::LikelihoodInfo>>::emplace_back<std::vector<KB::LikelihoodInfo>&>(a4, (long long **)__p);
        *(void *)buf = __p;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v57 += 3;
      }
      while (v57 != *((language_modeling::v1::Probability ***)&v91 + 1));
    }
    kdebug_trace();
    v81 = kac_get_log();
    os_signpost_id_t v82 = os_signpost_id_make_with_pointer(v81, ptr);
    if (v82 - 1 < 0xFFFFFFFFFFFFFFFELL)
    {
      os_signpost_id_t v83 = v82;
      if (os_signpost_enabled(v81))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, v81, OS_SIGNPOST_INTERVAL_END, v83, "kbdManager.languageModel.conditionalLikelihoodBatched", (const char *)&unk_1E41704BE, buf, 2u);
      }
    }
    *(void *)buf = &v96;
    std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    v84 = v98;
    if (v98)
    {
      char v85 = v99;
      uint64_t v86 = v98;
      if (v99 != v98)
      {
        do
        {
          v85 -= 3;
          *(void *)buf = v85;
          std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        }
        while (v85 != v84);
        uint64_t v86 = v98;
      }
      v99 = v84;
      operator delete(v86);
    }
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    char v43 = *a2;
    unint64_t v44 = a2[1];
    if (*a2 != v44)
    {
      do
      {
        std::vector<KB::LikelihoodInfo>::vector(&v104, *v43, (uint64_t)&KB::k_invalid_likelihood_value);
        char v45 = (void *)a4[1];
        unint64_t v46 = a4[2];
        if ((unint64_t)v45 >= v46)
        {
          unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v45 - *a4) >> 3);
          unint64_t v49 = v48 + 1;
          if (v48 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_117:
          }
            abort();
          unint64_t v50 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - *a4) >> 3);
          if (2 * v50 > v49) {
            unint64_t v49 = 2 * v50;
          }
          if (v50 >= 0x555555555555555) {
            unint64_t v51 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v51 = v49;
          }
          v103 = (void **)(a4 + 2);
          uint64_t v52 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v51);
          uint64_t v53 = &v52[24 * v48];
          *(void *)buf = v52;
          *(void *)&uint8_t buf[8] = v53;
          v102 = &v52[24 * v54];
          *((void *)v53 + 1) = 0;
          *((void *)v53 + 2) = 0;
          *(void *)uint64_t v53 = 0;
          *(_OWORD *)uint64_t v53 = v104;
          *((void *)v53 + 2) = v105;
          long long v104 = 0uLL;
          *(void *)&long long v105 = 0;
          *(void *)&uint8_t buf[16] = v53 + 24;
          std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a4, buf);
          char v47 = (void *)a4[1];
          std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)buf);
        }
        else
        {
          void *v45 = 0;
          v45[1] = 0;
          v45[2] = 0;
          *(_OWORD *)char v45 = v104;
          v45[2] = v105;
          long long v104 = 0uLL;
          *(void *)&long long v105 = 0;
          char v47 = v45 + 3;
        }
        a4[1] = v47;
        *(void *)buf = &v104;
        std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        v43 += 250;
      }
      while (v43 != v44);
    }
  }
}

void *std::vector<KB::LikelihoodInfo>::vector(void *a1, unint64_t a2, uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](a1, a2);
    uint64_t v6 = a1[1];
    uint64_t v7 = v6 + 40 * a2;
    uint64_t v8 = 40 * a2;
    os_signpost_id_t v9 = (std::string *)(v6 + 16);
    do
    {
      std::string::size_type v10 = *(void *)a3;
      LODWORD(v9[-1].__r_.__value_.__r.__words[2]) = *(_DWORD *)(a3 + 8);
      v9[-1].__r_.__value_.__l.__size_ = v10;
      if (*(char *)(a3 + 39) < 0)
      {
        std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)(a3 + 16), *(void *)(a3 + 24));
      }
      else
      {
        long long v11 = *(_OWORD *)(a3 + 16);
        v9->__r_.__value_.__r.__words[2] = *(void *)(a3 + 32);
        *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v11;
      }
      os_signpost_id_t v9 = (std::string *)((char *)v9 + 40);
      v8 -= 40;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void *std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(void *result, void *a2)
{
  uint64_t v3 = (void *)*result;
  unint64_t v2 = (void *)result[1];
  uint64_t v4 = a2[1];
  while (v2 != v3)
  {
    *(void *)(v4 - 24) = 0;
    *(void *)(v4 - 16) = 0;
    v4 -= 24;
    *(void *)(v4 + 16) = 0;
    long long v5 = *(_OWORD *)(v2 - 3);
    v2 -= 3;
    *(_OWORD *)uint64_t v4 = v5;
    *(void *)(v4 + 16) = v2[2];
    void *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;
  }
  a2[1] = v4;
  uint64_t v6 = (void *)*result;
  *float result = v4;
  a2[1] = v6;
  uint64_t v7 = result[1];
  result[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = result[2];
  result[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v6 = v4;
    std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100](&v6);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<language_modeling::v1::Token>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        if (*((char *)v4 - 9) < 0) {
          operator delete(*(v4 - 4));
        }
        v4 -= 4;
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(unint64_t a1)
{
  if (a1 >> 59) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(32 * a1);
}

void std::vector<std::vector<language_modeling::v1::Probability>>::__vdeallocate(void ***a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        long long v5 = v3;
        std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](&v5);
      }
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<language_modeling::v1::Probability>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    long long v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        uint64_t v6 = v4;
        std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      long long v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<KB::LikelihoodInfo>>::emplace_back<std::vector<KB::LikelihoodInfo>&>(void *a1, long long **a2)
{
  uint64_t v4 = a1 + 2;
  unint64_t v5 = a1[2];
  uint64_t v6 = (void *)a1[1];
  if ((unint64_t)v6 >= v5)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v6 - *a1) >> 3);
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= v8 + 1) {
      uint64_t v10 = v8 + 1;
    }
    if (v9 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    v14[4] = v4;
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v13 = (void *)(v11 + 24 * v8);
    v14[0] = v11;
    v14[1] = v13;
    void v14[3] = v11 + 24 * v12;
    *uint64_t v13 = 0;
    v13[1] = 0;
    v13[2] = 0;
    std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(v13, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    v14[2] = v13 + 3;
    std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a1, v14);
    uint64_t v7 = (void *)a1[1];
    std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)v14);
  }
  else
  {
    *uint64_t v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(v6, *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 3));
    uint64_t v7 = v6 + 3;
  }
  a1[1] = v7;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(unint64_t a1)
{
  if (a1 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(40 * a1);
}

uint64_t std::__split_buffer<KB::LikelihoodInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<KB::LikelihoodInfo>::__init_with_size[abi:nn180100]<KB::LikelihoodInfo*,KB::LikelihoodInfo*>(void *a1, long long *a2, long long *a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](a1, a4);
    uint64_t v7 = (std::string::value_type *)a1[1];
    if (a2 != a3)
    {
      unint64_t v8 = a2 + 1;
      unint64_t v9 = (std::string *)(v7 + 16);
      do
      {
        unint64_t v11 = v8 - 1;
        std::string::size_type v10 = *((void *)v8 - 2);
        LODWORD(v9[-1].__r_.__value_.__r.__words[2]) = *((_DWORD *)v8 - 2);
        v9[-1].__r_.__value_.__l.__size_ = v10;
        if (*((char *)v8 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v9, *(const std::string::value_type **)v8, *((void *)v8 + 1));
        }
        else
        {
          long long v12 = *v8;
          v9->__r_.__value_.__r.__words[2] = *((void *)v8 + 2);
          *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v12;
        }
        unint64_t v8 = (long long *)((char *)v8 + 40);
        unint64_t v9 = (std::string *)((char *)v9 + 40);
      }
      while ((long long *)((char *)v11 + 40) != a3);
      uint64_t v7 = &v9[-1].__r_.__value_.__s.__data_[8];
    }
    a1[1] = v7;
  }
}

char *std::vector<KB::LikelihoodInfo>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    abort();
  }
  float result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

void std::vector<language_modeling::v1::Probability>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    unint64_t v5 = v2;
    if (v4 != v2)
    {
      do
        language_modeling::v1::Probability::~Probability((language_modeling::v1::Probability *)(v4 - 8));
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<language_modeling::v1::Token>::__init_with_size[abi:nn180100]<language_modeling::v1::Token*,language_modeling::v1::Token*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 59) {
      abort();
    }
    uint64_t v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(a4);
    *a1 = v7;
    a1[1] = v7;
    a1[2] = &v7[32 * v8];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        std::string::size_type v10 = (long long *)(a2 + v9);
        unint64_t v11 = (std::string *)&v7[v9];
        if (*(char *)(a2 + v9 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)v10, *((void *)v10 + 1));
        }
        else
        {
          long long v12 = *v10;
          v11->__r_.__value_.__r.__words[2] = *((void *)v10 + 2);
          *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
        }
        *(_DWORD *)&v7[v9 + 24] = *(_DWORD *)(a2 + v9 + 24);
        v9 += 32;
      }
      while (a2 + v9 != a3);
      v7 += v9;
    }
    a1[1] = v7;
  }
}

void KB::LanguageModelStr::conditional_likelihood(unint64_t this@<X0>, const KB::String *a2@<X1>, const TITokenID *a3@<X2>, float a4@<S0>, uint64_t a5@<X8>)
{
  if ((*(uint64_t (**)(unint64_t, float))(*(void *)this + 16))(this, a4))
  {
    kdebug_trace();
    log = kac_get_log();
    long long v12 = (const void *)(this ^ 0xC9);
    os_signpost_id_t v13 = os_signpost_id_make_with_pointer(log, (const void *)(this ^ 0xC9));
    if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v14 = v13;
      if (os_signpost_enabled(log))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, log, OS_SIGNPOST_INTERVAL_BEGIN, v14, "kbdManager.languageModel.conditionalLikelihood", (const char *)&unk_1E41704BE, buf, 2u);
      }
    }
    uint64_t v15 = (char *)*((void *)a2 + 1);
    if (!v15) {
      uint64_t v15 = (char *)a2 + 16;
    }
    if (*(_WORD *)a2) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(__p, v16);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)buf);
    if (v29 < 0) {
      operator delete(__p[0]);
    }
    *(void *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    *(void *)(a5 + 24) = 0;
    *(void *)(a5 + 32) = 0;
    uint64_t v17 = *(void *)(this + 184);
    if (v17) {
      atomic_store(1u, (unsigned __int8 *)(v17 + 760));
    }
    std::mutex::lock(*(std::mutex **)(this + 136));
    uint64_t v18 = *(void *)(this + 184);
    if (v18) {
      atomic_store(0, (unsigned __int8 *)(v18 + 760));
    }
    language_modeling::v1::LanguageModelSession::detailedConditionalProbability();
    language_modeling::v1::Probability::probability();
    *(float *)&double v19 = v19;
    *(float *)a5 = __exp10f(*(float *)&v19);
    language_modeling::v1::Probability::probability();
    *(float *)&double v20 = v20;
    *(float *)(a5 + 4) = __exp10f(*(float *)&v20);
    *(_DWORD *)(a5 + 8) = language_modeling::v1::Probability::flags((language_modeling::v1::Probability *)__p) & 3;
    language_modeling::v1::Probability::log((uint64_t *)(a5 + 16), (language_modeling::v1::Probability *)__p);
    std::mutex::unlock(*(std::mutex **)(this + 136));
    kdebug_trace();
    uint64_t v21 = kac_get_log();
    os_signpost_id_t v22 = os_signpost_id_make_with_pointer(v21, v12);
    if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v23 = v22;
      if (os_signpost_enabled(v21))
      {
        *(_WORD *)int64x2_t v27 = 0;
        _os_signpost_emit_with_name_impl(&dword_1E3F0E000, v21, OS_SIGNPOST_INTERVAL_END, v23, "kbdManager.languageModel.conditionalLikelihood", (const char *)&unk_1E41704BE, v27, 2u);
      }
    }
    language_modeling::v1::Probability::~Probability((language_modeling::v1::Probability *)__p);
    if (v31 < 0) {
      operator delete(*(void **)buf);
    }
  }
  else
  {
    *(void *)a5 = KB::k_invalid_likelihood_value;
    *(_DWORD *)(a5 + 8) = dword_1EAE3D128;
    uint64_t v24 = (std::string *)(a5 + 16);
    if (byte_1EAE3D147 < 0)
    {
      uint64_t v25 = *(const std::string::value_type **)aInvalidLikelih;
      std::string::size_type v26 = *(void *)&aInvalidLikelih[8];
      std::string::__init_copy_ctor_external(v24, v25, v26);
    }
    else
    {
      *(_OWORD *)&v24->__r_.__value_.__l.__data_ = *(_OWORD *)aInvalidLikelih;
      *(void *)(a5 + 32) = *(void *)&aInvalidLikelih[16];
    }
  }
}

float KB::LanguageModelStr::marginal_likelihood(std::mutex **this, const KB::String *a2, const TITokenID *a3)
{
  float v6 = 0.0;
  if ((*(unsigned int (**)(std::mutex **))&(*this)->__m_.__opaque[8])(this))
  {
    BOOL v7 = KB::LanguageModel::lexicon_id_active((KB::LanguageModel *)this, a3->lexicon_id);
    if (a3->word_id < 0x1F4 || v7)
    {
      uint64_t v9 = (char *)*((void *)a2 + 1);
      if (!v9) {
        uint64_t v9 = (char *)a2 + 16;
      }
      if (*(_WORD *)a2) {
        std::string::size_type v10 = v9;
      }
      else {
        std::string::size_type v10 = "";
      }
      std::string::basic_string[abi:nn180100]<0>(__p, v10);
      KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v17);
      if (v16 < 0) {
        operator delete(__p[0]);
      }
      unint64_t v11 = this[23];
      if (v11) {
        atomic_store(1u, (unsigned __int8 *)&v11[11].__m_.__opaque[48]);
      }
      std::mutex::lock(this[17]);
      long long v12 = this[23];
      if (v12) {
        atomic_store(0, (unsigned __int8 *)&v12[11].__m_.__opaque[48]);
      }
      language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)__p);
      double v13 = COERCE_DOUBLE(language_modeling::v1::LanguageModelSession::conditionalProbability());
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)__p);
      std::mutex::unlock(this[17]);
      if (v18 < 0) {
        operator delete(v17);
      }
      return v13;
    }
  }
  return v6;
}

uint64_t KB::LanguageModelStr::can_reason_about(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3)
{
  if (!(*(unsigned int (**)(KB::LanguageModelStr *, const KB::String *, const TITokenID *))(*(void *)this + 16))(this, a2, a3))return 0; {
  unint64_t v5 = (char *)*((void *)a2 + 1);
  }
  if (!v5) {
    unint64_t v5 = (char *)a2 + 16;
  }
  if (*(_WORD *)a2) {
    float v6 = v5;
  }
  else {
    float v6 = "";
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, v6);
  uint64_t v7 = *((void *)this + 23);
  if (v7) {
    atomic_store(1u, (unsigned __int8 *)(v7 + 760));
  }
  std::mutex::lock(*((std::mutex **)this + 17));
  uint64_t v8 = *((void *)this + 23);
  if (v8) {
    atomic_store(0, (unsigned __int8 *)(v8 + 760));
  }
  uint64_t canReasonAbout = language_modeling::v1::LanguageModelSession::canReasonAbout();
  std::mutex::unlock(*((std::mutex **)this + 17));
  if (v12 < 0) {
    operator delete(__p);
  }
  return canReasonAbout;
}

BOOL KB::LanguageModelStr::is_swear_word_policy_enabled(language_modeling::v1::LanguageModel **this)
{
  if (!(*((unsigned int (**)(language_modeling::v1::LanguageModel **))*this + 2))(this)) {
    return 0;
  }
  CFDictionaryRef v2 = (const __CFDictionary *)language_modeling::v1::LanguageModel::parameters(this[21]);
  if (!v2) {
    return 0;
  }
  CFDictionaryRef v3 = v2;
  uint64_t v4 = (const void **)MEMORY[0x1E4F723E8];
  if (CFDictionaryContainsKey(v2, (const void *)*MEMORY[0x1E4F723E8]))
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v3, *v4);
    BOOL v6 = CFBooleanGetValue(Value) != 0;
  }
  else
  {
    BOOL v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

void KB::LanguageModelStr::adapt_to_paragraph(uint64_t a1, uint64_t a2, double a3, uint64_t a4, const __CFString *a5, int a6)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    unint64_t v11 = *(char **)(a2 + 8);
    if (!v11) {
      unint64_t v11 = (char *)(a2 + 16);
    }
    if (*(_WORD *)a2) {
      char v12 = v11;
    }
    else {
      char v12 = "";
    }
    double v13 = (language_modeling::v1 *)std::string::basic_string[abi:nn180100]<0>(&__p, v12);
    language_modeling::v1::convertAbsoluteTime(v13, a3);
    if (a6 == 2)
    {
      if (!a5)
      {
        char v18 = TILanguageModelLogFacility();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136315138;
          os_signpost_id_t v22 = "adapt_to_paragraph";
          _os_log_fault_impl(&dword_1E3F0E000, v18, OS_LOG_TYPE_FAULT, "%s Received an adapt to paragraph with NULL Sender Identifier", buf, 0xCu);
        }
        goto LABEL_23;
      }
      uint64_t v16 = *(void *)(a1 + 184);
      if (v16) {
        atomic_store(1u, (unsigned __int8 *)(v16 + 760));
      }
      std::mutex::lock(*(std::mutex **)(a1 + 136));
      uint64_t v17 = *(void *)(a1 + 184);
      if (v17) {
        atomic_store(0, (unsigned __int8 *)(v17 + 760));
      }
      CFStringCompare(a5, (CFStringRef)*MEMORY[0x1E4F721A0], 1uLL);
      language_modeling::v1::LanguageModelSession::addPriorText();
    }
    else
    {
      if (a6 != 1) {
        goto LABEL_23;
      }
      if (!*(_DWORD *)(a1 + 64))
      {
        *(_DWORD *)(a1 + 64) = 1;
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 288))(a1, 1);
      }
      *(CFAbsoluteTime *)(a1 + 224) = CFAbsoluteTimeGetCurrent();
      uint64_t v14 = *(void *)(a1 + 184);
      if (v14) {
        atomic_store(1u, (unsigned __int8 *)(v14 + 760));
      }
      std::mutex::lock(*(std::mutex **)(a1 + 136));
      uint64_t v15 = *(void *)(a1 + 184);
      if (v15) {
        atomic_store(0, (unsigned __int8 *)(v15 + 760));
      }
      language_modeling::v1::LanguageModelSession::adaptToText();
    }
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
LABEL_23:
    if (v20 < 0) {
      operator delete(__p);
    }
  }
}

uint64_t KB::LanguageModelStr::should_adapt_to_paragraph(KB::LanguageModelStr *this, const __CFString *a2)
{
  return 1;
}

double KB::LanguageModelStr::last_offline_adaptation_time(KB::LanguageModelStr *this)
{
  return *((double *)this + 28);
}

void KB::LanguageModelStr::record_usage_with_differential_privacy(KB::LanguageModel *a1, const __CFString *a2, int a3, char a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a3 && (*(unsigned int (**)(KB::LanguageModel *))(*(void *)a1 + 16))(a1))
  {
    if (KB::LanguageModel::lexicon_id_active(a1, a3))
    {
      uint64_t v8 = *((void *)a1 + 23);
      if (v8) {
        atomic_store(1u, (unsigned __int8 *)(v8 + 760));
      }
      std::mutex::lock(*((std::mutex **)a1 + 17));
      uint64_t v9 = *((void *)a1 + 23);
      if (v9) {
        atomic_store(0, (unsigned __int8 *)(v9 + 760));
      }
      if ((a4 & 2) != 0)
      {
        KB::utf8_string(a2, (uint64_t)buf);
        std::string::size_type v10 = *(char **)&v17[4];
        if (!*(void *)&v17[4]) {
          std::string::size_type v10 = &v17[12];
        }
        if (*(_WORD *)buf) {
          unint64_t v11 = v10;
        }
        else {
          unint64_t v11 = "";
        }
        std::string::basic_string[abi:nn180100]<0>(&__p, v11);
        language_modeling::v1::LanguageModelSession::recordWordRevision();
        if (v15 < 0) {
          operator delete(__p);
        }
        if (*(void *)&v17[4])
        {
          if (v17[2] == 1) {
            free(*(void **)&v17[4]);
          }
        }
      }
      std::mutex::unlock(*((std::mutex **)a1 + 17));
    }
    else
    {
      char v12 = TILanguageModelLogFacility();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = (*(uint64_t (**)(KB::LanguageModel *))(*(void *)a1 + 40))(a1);
        *(_DWORD *)buf = 136315650;
        *(void *)uint64_t v17 = "record_usage_with_differential_privacy";
        *(_WORD *)&v17[8] = 1024;
        *(_DWORD *)&v17[10] = a3;
        __int16 v18 = 1024;
        int v19 = v13;
        _os_log_error_impl(&dword_1E3F0E000, v12, OS_LOG_TYPE_ERROR, "%s mismatched lexicon_id=%d for language model with lexicon_id=%d", buf, 0x18u);
      }
    }
  }
}

void KB::LanguageModelStr::register_negative_evidence(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    uint64_t v4 = *(char **)(a2 + 8);
    if (!v4) {
      uint64_t v4 = (char *)(a2 + 16);
    }
    if (*(_WORD *)a2) {
      unint64_t v5 = v4;
    }
    else {
      unint64_t v5 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, v5);
    uint64_t v6 = *(void *)(a1 + 184);
    if (v6) {
      atomic_store(1u, (unsigned __int8 *)(v6 + 760));
    }
    std::mutex::lock(*(std::mutex **)(a1 + 136));
    uint64_t v7 = *(void *)(a1 + 184);
    if (v7) {
      atomic_store(0, (unsigned __int8 *)(v7 + 760));
    }
    language_modeling::v1::LanguageModelSession::registerNegativeEvidence();
    std::mutex::unlock(*(std::mutex **)(a1 + 136));
    if (v9 < 0) {
      operator delete(__p);
    }
  }
}

void KB::LanguageModelStr::decrement_usage_count(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    uint64_t v7 = (char *)*((void *)a2 + 1);
    if (!v7) {
      uint64_t v7 = (char *)a2 + 16;
    }
    if (*(_WORD *)a2) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(__p, v8);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v13);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = *((void *)this + 23);
    if (v9) {
      atomic_store(1u, (unsigned __int8 *)(v9 + 760));
    }
    std::mutex::lock(*((std::mutex **)this + 17));
    uint64_t v10 = *((void *)this + 23);
    if (v10) {
      atomic_store(0, (unsigned __int8 *)(v10 + 760));
    }
    language_modeling::v1::LanguageModelSession::unAdaptToToken();
    std::mutex::unlock(*((std::mutex **)this + 17));
    if (v14 < 0) {
      operator delete(v13);
    }
  }
}

void KB::LanguageModelStr::increment_usage_count(KB::LanguageModelStr *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    uint64_t v7 = (char *)*((void *)a2 + 1);
    if (!v7) {
      uint64_t v7 = (char *)a2 + 16;
    }
    if (*(_WORD *)a2) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(__p, v8);
    KB::LanguageModelContext::linguistic_token((uint64_t)__p, (TITokenID)a3, (uint64_t)&v13);
    if (v12 < 0) {
      operator delete(__p[0]);
    }
    uint64_t v9 = *((void *)this + 23);
    if (v9) {
      atomic_store(1u, (unsigned __int8 *)(v9 + 760));
    }
    std::mutex::lock(*((std::mutex **)this + 17));
    uint64_t v10 = *((void *)this + 23);
    if (v10) {
      atomic_store(0, (unsigned __int8 *)(v10 + 760));
    }
    language_modeling::v1::LanguageModelSession::adaptToToken();
    std::mutex::unlock(*((std::mutex **)this + 17));
    if (v14 < 0) {
      operator delete(v13);
    }
  }
}

uint64_t KB::LanguageModelStr::add_dynamic_word(KB::LanguageModelStr *this, const __CFString *a2)
{
  return 0;
}

uint64_t KB::LanguageModelStr::is_dynamic_word_id(KB::LanguageModelStr *this, TITokenID a2)
{
  return 0;
}

uint64_t KB::LanguageModelStr::start_session_with_context(KB::LanguageModelStr *this, const __CFString *a2, const __CFDictionary *a3)
{
  (*(void (**)(KB::LanguageModelStr *, const __CFString *))(*(void *)this + 272))(this, a2);
  (*(void (**)(KB::LanguageModelStr *, const __CFDictionary *))(*(void *)this + 280))(this, a3);
  uint64_t v5 = *((unsigned int *)this + 16);
  uint64_t v6 = *(uint64_t (**)(KB::LanguageModelStr *, uint64_t))(*(void *)this + 288);

  return v6(this, v5);
}

void KB::LanguageModelStr::start_session(_DWORD *a1, int a2)
{
  if ((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 16))(a1))
  {
    KB::LanguageModelStr::__start_session((uint64_t)a1, a2);
  }
  else
  {
    a1[16] = a2;
  }
}

void KB::LanguageModelStr::__start_session(uint64_t a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v28 = (uint64_t *)v29;
  uint64_t v4 = *(void *)(a1 + 184);
  if (v4) {
    atomic_store(1u, (unsigned __int8 *)(v4 + 760));
  }
  std::mutex::lock(*(std::mutex **)(a1 + 136));
  uint64_t v5 = *(void *)(a1 + 184);
  if (v5) {
    atomic_store(0, (unsigned __int8 *)(v5 + 760));
  }
  KB::utf8_string(*(const __CFString **)(a1 + 48), (uint64_t)&v31);
  size = (char *)v31.__r_.__value_.__l.__size_;
  if (!v31.__r_.__value_.__l.__size_) {
    size = &v31.__r_.__value_.__s.__data_[16];
  }
  if (LOWORD(v31.__r_.__value_.__l.__data_)) {
    uint64_t v7 = size;
  }
  else {
    uint64_t v7 = "";
  }
  std::string::basic_string[abi:nn180100]<0>(&v27, v7);
  if (v31.__r_.__value_.__l.__size_ && v31.__r_.__value_.__s.__data_[6] == 1) {
    free((void *)v31.__r_.__value_.__l.__size_);
  }
  BOOL v8 = a2 != 0;
  std::string::basic_string[abi:nn180100]<0>(&v31, (char *)*MEMORY[0x1E4F720C0]);
  uint64_t v9 = std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v28, &v31, (uint64_t)&v31);
  uint64_t v10 = v9;
  uint64_t v11 = *((unsigned int *)v9 + 20);
  if (v11 != -1)
  {
    char v12 = (BOOL *)(v9 + 7);
    if (!v11)
    {
      *char v12 = v8;
      goto LABEL_18;
    }
    ((void (*)(void **, BOOL *))off_1F3F71B50[v11])(__p, v12);
  }
  *((_DWORD *)v10 + 14) = v8;
  *((_DWORD *)v10 + 20) = 0;
LABEL_18:
  if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v31.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v31, v27.__r_.__value_.__l.__data_, v27.__r_.__value_.__l.__size_);
  }
  else {
    std::string v31 = v27;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, (char *)*MEMORY[0x1E4F720F8]);
  int v13 = std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&v28, __p, (uint64_t)__p);
  char v14 = v13;
  char v15 = (void **)(v13 + 7);
  uint64_t v16 = *((unsigned int *)v13 + 20);
  if (v16 == -1) {
    goto LABEL_29;
  }
  if (v16 != 1)
  {
    ((void (*)(char *, void **))off_1F3F71B50[v16])(&v30, v15);
LABEL_29:
    *(std::string *)char v15 = v31;
    memset(&v31, 0, sizeof(v31));
    *((_DWORD *)v14 + 20) = 1;
    goto LABEL_30;
  }
  if (*((char *)v13 + 79) < 0) {
    operator delete(*v15);
  }
  *(std::string *)char v15 = v31;
  v31.__r_.__value_.__s.__data_[0] = 0;
LABEL_30:
  if (v26 < 0) {
    operator delete(__p[0]);
  }
  language_modeling::v1::LanguageModel::makeSession();
  if (v31.__r_.__value_.__r.__words[0]) {
    operator new();
  }
  v31.__r_.__value_.__r.__words[0] = 0;
  uint64_t v17 = *(std::__shared_weak_count **)(a1 + 208);
  *(_OWORD *)(a1 + 200) = 0u;
  if (v17)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v17);
    __int16 v18 = (language_modeling::v1::LanguageModelSession *)v31.__r_.__value_.__r.__words[0];
    v31.__r_.__value_.__r.__words[0] = 0;
    if (v18)
    {
      language_modeling::v1::LanguageModelSession::~LanguageModelSession(v18);
      MEMORY[0x1E4E7BC20]();
    }
  }
  else
  {
    v31.__r_.__value_.__r.__words[0] = 0;
  }
  std::mutex::unlock(*(std::mutex **)(a1 + 136));
  uint64_t v19 = *(void *)(a1 + 184);
  if (v19)
  {
    uint64_t v20 = *(std::__shared_weak_count **)(a1 + 144);
    v24[0] = *(void *)(a1 + 136);
    v24[1] = v20;
    if (v20) {
      atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v21 = *(void *)(a1 + 200);
    os_signpost_id_t v22 = *(std::__shared_weak_count **)(a1 + 208);
    v23[0] = v21;
    v23[1] = (uint64_t)v22;
    if (v22)
    {
      atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
      TIInlineCompletionGeneratorImpl::initialize(v19, (uint64_t)v24, v23);
      std::__shared_weak_count::__release_shared[abi:nn180100](v22);
      if (!v20) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
    TIInlineCompletionGeneratorImpl::initialize(v19, (uint64_t)v24, v23);
    if (v20) {
LABEL_43:
    }
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
  }
LABEL_44:
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(v29[0]);
}

uint64_t **std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        uint64_t v6 = (uint64_t **)v5;
        BOOL v8 = v5 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a2, v5 + 4) & 0x80) == 0) {
          break;
        }
        uint64_t v5 = *v6;
        uint64_t v9 = v6;
        if (!*v6) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a2) & 0x80) == 0) {
        return v6;
      }
      uint64_t v9 = v6 + 1;
      uint64_t v5 = v6[1];
    }
    while (v5);
  }
  else
  {
    uint64_t v9 = a1 + 1;
  }
LABEL_9:
  uint64_t v10 = (uint64_t *)v6;
  uint64_t v6 = (uint64_t **)operator new(0x58uLL);
  *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
  v6[6] = *(uint64_t **)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 14) = 0;
  *((_DWORD *)v6 + 20) = 0;
  *uint64_t v6 = 0;
  v6[1] = 0;
  v6[2] = v10;
  *uint64_t v9 = (uint64_t *)v6;
  uint64_t v11 = (uint64_t *)**a1;
  char v12 = (uint64_t *)v6;
  if (v11)
  {
    *a1 = v11;
    char v12 = *v9;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return v6;
}

void std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<language_modeling::v1::SessionType,std::string>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<language_modeling::v1::SessionType,std::string>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<language_modeling::v1::SessionType,std::string>>,0>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1F3F71B50[v2])(&v3, a1 + 24);
  }
  *(_DWORD *)(a1 + 48) = -1;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

language_modeling::v1::LanguageModelSession *std::__shared_ptr_pointer<language_modeling::v1::LanguageModelSession  *>::__on_zero_shared(uint64_t a1)
{
  float result = *(language_modeling::v1::LanguageModelSession **)(a1 + 24);
  if (result)
  {
    language_modeling::v1::LanguageModelSession::~LanguageModelSession(result);
    JUMPOUT(0x1E4E7BC20);
  }
  return result;
}

void std::__shared_ptr_pointer<language_modeling::v1::LanguageModelSession  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN17language_modeling2v111SessionTypeENS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSI_1EJSA_SG_EEEEEEDcSK_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(void *a1, void *a2)
{
  size_t v2 = a1[1];
  if (*((char *)a1 + 23) >= 0)
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  else
  {
    a1 = (void *)*a1;
    size_t v3 = v2;
  }
  size_t v4 = a2[1];
  if (*((char *)a2 + 23) >= 0)
  {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else
  {
    a2 = (void *)*a2;
    size_t v5 = v4;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  int v7 = memcmp(a1, a2, v6);
  if (v7)
  {
    if ((v7 & 0x80000000) == 0) {
      return 1;
    }
  }
  else
  {
    if (v3 == v5) {
      return 0;
    }
    if (v3 >= v5) {
      return 1;
    }
  }
  return 255;
}

void KB::LanguageModelStr::set_inline_completion_personalization(KB::LanguageModelStr *this, const KB::String *a2)
{
  size_t v2 = (CFMutableDictionaryRef *)*((void *)this + 23);
  if (v2) {
    TIInlineCompletionGeneratorImpl::setInlineCompletionPersonalization(v2, a2);
  }
}

void KB::LanguageModelStr::set_inline_completion_analytics_metadata(KB::LanguageModelStr *this, const TIInlineCompletionAnalyticsMetadata *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  size_t v2 = (TIInlineCompletionGeneratorImpl *)*((void *)this + 23);
  if (v2)
  {
    KB::String::String((KB::String *)&v4, (const KB::String *)a2);
    KB::String::String((KB::String *)&v4.var1, (const KB::String *)&a2->var1);
    KB::String::String((KB::String *)&v4.var2, (const KB::String *)&a2->var2);
    KB::String::String((KB::String *)&v4.var3, (const KB::String *)&a2->var3);
    KB::String::String((KB::String *)&v4.var4, (const KB::String *)&a2->var4);
    KB::String::String((KB::String *)&v4.var5, (const KB::String *)&a2->var5);
    v4.var6 = a2->var6;
    KB::String::String((KB::String *)&v4.var7, (const KB::String *)&a2->var7);
    KB::String::String((KB::String *)&v4.var8, (const KB::String *)&a2->var8);
    KB::String::String((KB::String *)&v4.var9, (const KB::String *)&a2->var9);
    KB::String::String((KB::String *)&v4.var10, (const KB::String *)&a2->var10);
    TIInlineCompletionGeneratorImpl::setAnalyticsMetaData(v2, &v4);
    if (v4.var10.var4 && v4.var10.var3 == 1) {
      free(v4.var10.var4);
    }
    if (v4.var9.var4 && v4.var9.var3 == 1) {
      free(v4.var9.var4);
    }
    if (v4.var8.var4 && v4.var8.var3 == 1) {
      free(v4.var8.var4);
    }
    if (v4.var7.var4 && v4.var7.var3 == 1) {
      free(v4.var7.var4);
    }
    if (v4.var5.var4 && v4.var5.var3 == 1) {
      free(v4.var5.var4);
    }
    if (v4.var4.var4 && v4.var4.var3 == 1) {
      free(v4.var4.var4);
    }
    if (v4.var3.var4 && v4.var3.var3 == 1) {
      free(v4.var3.var4);
    }
    if (v4.var2.var4 && v4.var2.var3 == 1) {
      free(v4.var2.var4);
    }
    if (v4.var1.var4 && v4.var1.var3 == 1) {
      free(v4.var1.var4);
    }
    if (v4.var0.var4)
    {
      if (v4.var0.var3 == 1) {
        free(v4.var0.var4);
      }
    }
  }
}

unsigned int *KB::LanguageModelStr::set_dictionaries(unsigned int *result, atomic_uint **a2)
{
  uint64_t v2 = *((void *)result + 23);
  if (v2)
  {
    size_t v3 = *a2;
    if (*a2)
    {
      atomic_fetch_add(v3, 1u);
      atomic_fetch_add(v3, 1u);
    }
    float result = *(unsigned int **)(v2 + 400);
    *(void *)(v2 + 400) = v3;
    if (result) {
      float result = WTF::RefCounted<KB::DictionaryContainer>::deref(result);
    }
    if (v3)
    {
      return WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v3);
    }
  }
  return result;
}

void KB::LanguageModelStr::set_current_recipient_names(uint64_t a1, const KB::String **a2)
{
  uint64_t v2 = *(void *)(a1 + 184);
  if (v2)
  {
    memset(v3, 0, sizeof(v3));
    std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>((KB::String *)v3, *a2, a2[1], (a2[1] - *a2) >> 5);
    TIInlineCompletionGeneratorImpl::setCurrentRecipientNames(v2, (uint64_t)v3);
    TIInlineCompletionAnalyticsMetadata v4 = (void **)v3;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v4);
  }
}

KB::String *std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>(KB::String *result, const KB::String *a2, const KB::String *a3, unint64_t a4)
{
  if (a4)
  {
    size_t v6 = result;
    std::vector<KB::String>::__vallocate[abi:nn180100](result, a4);
    float result = (KB::String *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      int v7 = KB::String::String(result, a2);
      a2 = (const KB::String *)((char *)a2 + 32);
      float result = (KB::String *)((char *)v7 + 32);
    }
    *((void *)v6 + 1) = result;
  }
  return result;
}

char *std::vector<KB::String>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 59) {
    abort();
  }
  float result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void KB::LanguageModelStr::copyLinguisticDataFiles(language_modeling::v1::LanguageModel **this@<X0>, void *a2@<X8>)
{
  if ((*((unsigned int (**)(language_modeling::v1::LanguageModel **))*this + 2))(this))
  {
    *a2 = language_modeling::v1::LanguageModel::copyLinguisticDataFileInfo(this[21]);
  }
  else
  {
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    *a2 = CFDictionaryCreate(v4, MEMORY[0x1E4F72400], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    if (values) {
      CFRelease(values);
    }
  }
}

uint64_t KB::LanguageModelStr::get_num_candidates@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2 == 5
    && (v4 = result, float result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result), result)
    && *(void *)(v4 + 272)
    && (float result = language_modeling::v1::LanguageModelSession::supportsFragmentsBasedConditionalProbability(*(language_modeling::v1::LanguageModelSession **)(v4 + 200)),
        (result & 1) != 0)
    && (float result = CFDictionaryContainsKey(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumQuickPathCandidatesSupported), result)&& (float result = CFDictionaryContainsKey(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumRetrocorrectionQuickPathCandidatesSupported), result))
  {
    uint64_t v8 = 0;
    uint64_t valuePtr = 0;
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumQuickPathCandidatesSupported);
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
    CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 272), (const void *)kLMLanguageModelMaxNumRetrocorrectionQuickPathCandidatesSupported);
    float result = CFNumberGetValue(v6, kCFNumberIntType, &v8);
    uint64_t v7 = v8;
    *(void *)a3 = valuePtr;
    *(void *)(a3 + 8) = v7;
    *(unsigned char *)(a3 + 16) = 1;
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
  }
  return result;
}

uint64_t KB::LanguageModelStr::unwire_memory(language_modeling::v1::LanguageModel **this)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if (result)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
    {
      int v3 = 136315138;
      uint64_t v4 = "unwire_memory";
      _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  Unwiring memory", (uint8_t *)&v3, 0xCu);
    }
    return language_modeling::v1::LanguageModel::unwireMemory(this[21]);
  }
  return result;
}

uint64_t KB::LanguageModelStr::wire_memory(language_modeling::v1::LanguageModel **this)
{
  uint64_t result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if (result)
  {
    int v3 = this[21];
    return language_modeling::v1::LanguageModel::wireMemory(v3);
  }
  return result;
}

uint64_t KB::LanguageModelStr::should_score_completion_candidate(KB::LanguageModelStr *this, const Candidate *a2)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *, const Candidate *))(*(void *)this + 16))(this, a2)) {
    return (*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 144))(this) ^ 1;
  }
  else {
    return 1;
  }
}

uint64_t KB::LanguageModelStr::supports_fragment_based_conditional_prob(language_modeling::v1::LanguageModelSession **this)
{
  uint64_t result = (*((uint64_t (**)(language_modeling::v1::LanguageModelSession **))*this + 2))(this);
  if (result)
  {
    int v3 = this[25];
    return language_modeling::v1::LanguageModelSession::supportsFragmentsBasedConditionalProbability(v3);
  }
  return result;
}

const __CFArray *KB::LanguageModelStr::does_provide_inline_completions_for_locale(const __CFArray **this, const KB::String *a2)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  CFArrayRef result = (const __CFArray *)(*((uint64_t (**)(const __CFArray **))*this + 2))(this);
  if (result)
  {
    CFArrayRef result = this[2];
    if (result)
    {
      CFIndex Count = CFArrayGetCount(result);
      if (Count < 1) {
        return 0;
      }
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      while (1)
      {
        ValueAtIndex = (KB *)CFArrayGetValueAtIndex(this[2], v7);
        KB::kb_string_from_locale(ValueAtIndex, v9, (KB::String *)v17);
        uint64_t v10 = v18;
        uint64_t v11 = (const char *)(v18 ? v18 : v19);
        char v12 = *((void *)a2 + 1) ? (const char *)*((void *)a2 + 1) : (char *)a2 + 16;
        int v13 = strcmp(v11, v12);
        if (v10 && v17[6] == 1) {
          free(v10);
        }
        if (!v13) {
          break;
        }
        if (v6 == ++v7) {
          return 0;
        }
      }
      CFArrayRef v15 = this[23];
      if (v15)
      {
        unsigned __int8 v16 = atomic_load((unsigned __int8 *)v15 + 16);
        return (const __CFArray *)(v16 & 1);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t KB::LanguageModelStr::does_provide_inline_completions(KB::LanguageModelStr *this)
{
  uint64_t result = (*(uint64_t (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this);
  if (result)
  {
    uint64_t v3 = *((void *)this + 23);
    if (v3)
    {
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v3 + 16));
      return v4 & 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t KB::LanguageModelStr::advanced_models_loaded(KB::LanguageModelStr *this)
{
  return (*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 160))(this);
}

uint64_t KB::LanguageModelStr::does_provide_completions(KB::LanguageModelStr *this)
{
  uint64_t result = (*(uint64_t (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this);
  if (result)
  {
    uint64_t v3 = *((void *)this + 25);
    return MEMORY[0x1F412A4C0](v3);
  }
  return result;
}

void KB::LanguageModelStr::reset_state_cache(uint64_t a1, unsigned int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)) {
    return;
  }
  unsigned __int8 v4 = TILanguageModelLogFacility();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2) {
      uint64_t v5 = "cache-strategy: unknown";
    }
    else {
      uint64_t v5 = off_1E6E2D378[a2];
    }
    int v15 = 136315394;
    unsigned __int8 v16 = "reset_state_cache";
    __int16 v17 = 2080;
    __int16 v18 = v5;
    _os_log_impl(&dword_1E3F0E000, v4, OS_LOG_TYPE_DEFAULT, "%s Handling %s reset request", (uint8_t *)&v15, 0x16u);
  }
  if (a2 != 2)
  {
    if (a2 == 1)
    {
      char v12 = TILanguageModelLogFacility();
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v15 = 136315138;
      unsigned __int8 v16 = "reset_state_cache";
      CFLocaleRef v9 = "%s Not resetting the cache";
      uint64_t v10 = v12;
      goto LABEL_17;
    }
    if (a2) {
      return;
    }
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
    CFIndex v7 = TILanguageModelLogFacility();
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (!v8) {
        return;
      }
      int v15 = 136315138;
      unsigned __int8 v16 = "reset_state_cache";
      CFLocaleRef v9 = "%s Model provides completions, not resetting the cache";
      uint64_t v10 = v7;
LABEL_17:
      _os_log_impl(&dword_1E3F0E000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, 0xCu);
      return;
    }
    if (!v8) {
      goto LABEL_21;
    }
    int v15 = 136315138;
    unsigned __int8 v16 = "reset_state_cache";
    uint64_t v11 = "%s Resetting the state cache in Language Model";
    goto LABEL_20;
  }
  CFIndex v7 = TILanguageModelLogFacility();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 136315138;
    unsigned __int8 v16 = "reset_state_cache";
    uint64_t v11 = "%s Resetting the cache";
LABEL_20:
    _os_log_impl(&dword_1E3F0E000, v7, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0xCu);
  }
LABEL_21:
  uint64_t v13 = *(void *)(a1 + 184);
  if (v13) {
    atomic_store(1u, (unsigned __int8 *)(v13 + 760));
  }
  std::mutex::lock(*(std::mutex **)(a1 + 136));
  uint64_t v14 = *(void *)(a1 + 184);
  if (v14) {
    atomic_store(0, (unsigned __int8 *)(v14 + 760));
  }
  language_modeling::v1::LanguageModel::deallocateInternalBuffers(*(language_modeling::v1::LanguageModel **)(a1 + 168));
  std::mutex::unlock(*(std::mutex **)(a1 + 136));
}

void KB::LanguageModelStr::clear_recent_text_cache(KB::LanguageModelStr *this)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    uint64_t v2 = *((void *)this + 23);
    if (v2) {
      atomic_store(1u, (unsigned __int8 *)(v2 + 760));
    }
    std::mutex::lock(*((std::mutex **)this + 17));
    uint64_t v3 = *((void *)this + 23);
    if (v3) {
      atomic_store(0, (unsigned __int8 *)(v3 + 760));
    }
    language_modeling::v1::LanguageModelSession::clearPriorText(*((language_modeling::v1::LanguageModelSession **)this
                                                                + 25));
    unsigned __int8 v4 = (std::mutex *)*((void *)this + 17);
    std::mutex::unlock(v4);
  }
}

void KB::LanguageModelStr::clear_dynamic_learning_cache(KB::LanguageModelStr *this)
{
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    uint64_t v2 = *((void *)this + 23);
    if (v2) {
      atomic_store(1u, (unsigned __int8 *)(v2 + 760));
    }
    std::mutex::lock(*((std::mutex **)this + 17));
    uint64_t v3 = *((void *)this + 23);
    if (v3) {
      atomic_store(0, (unsigned __int8 *)(v3 + 760));
    }
    language_modeling::v1::LanguageModelSession::clearDynamicLearningCache(*((language_modeling::v1::LanguageModelSession **)this
                                                                           + 25));
    unsigned __int8 v4 = (std::mutex *)*((void *)this + 17);
    std::mutex::unlock(v4);
  }
}

uint64_t KB::LanguageModelStr::set_dynamic_resource_directory(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 200);
  if (result) {
    return MEMORY[0x1F412A4C8]();
  }
  return result;
}

uint64_t KB::LanguageModelStr::remove_dynamic_resource_directory(KB::LanguageModelStr *this)
{
  uint64_t result = *((void *)this + 25);
  if (result) {
    return MEMORY[0x1F412A4D0]();
  }
  return result;
}

void KB::LanguageModelStr::reload_with_locales(KB::LanguageModelStr *this, const __CFArray *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned int (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)this + 217);
    if ((v4 & 1) == 0)
    {
      uint64_t v5 = *((void *)this + 23);
      if (v5) {
        atomic_store(1u, (unsigned __int8 *)(v5 + 760));
      }
      std::mutex::lock(*((std::mutex **)this + 17));
      uint64_t v6 = *((void *)this + 23);
      if (v6) {
        atomic_store(0, (unsigned __int8 *)(v6 + 760));
      }
      atomic_store(0, (unsigned __int8 *)this + 216);
      atomic_store(1u, (unsigned __int8 *)this + 217);
      language_modeling::v1::LanguageModel::reloadWithLocales(v12, *((language_modeling::v1::LanguageModel **)this + 21), a2);
      int v7 = v12[0];
      if (TICanLogMessageAtLevel_onceToken != -1) {
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
      }
      BOOL v8 = TIOSLogFacility();
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
      if (v7)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136315138;
          int v15 = "reload_with_locales";
          _os_log_debug_impl(&dword_1E3F0E000, v8, OS_LOG_TYPE_DEBUG, "%s Language model reload FAILED", buf, 0xCu);
        }
        v11[0] = 0;
        v11[1] = 0;
        uint64_t v10 = v11;
        std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v10, *((long long **)this + 35), (long long *)this + 18);
        KB::LanguageModelStr::draft_radar_for_model_creation_failure((uint64_t)this, (uint64_t)&v10, 1);
        std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v11[0]);
      }
      else if (v9)
      {
        *(_DWORD *)buf = 136315138;
        int v15 = "reload_with_locales";
        _os_log_debug_impl(&dword_1E3F0E000, v8, OS_LOG_TYPE_DEBUG, "%s Language model reload SUCCEEDED", buf, 0xCu);
      }
      atomic_store(1u, (unsigned __int8 *)this + 216);
      atomic_store(0, (unsigned __int8 *)this + 217);
      std::mutex::unlock(*((std::mutex **)this + 17));
      if (v13 < 0) {
        operator delete((void *)v12[1]);
      }
    }
  }
}

void std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>(uint64_t a1, long long *a2, long long *a3)
{
  if (a2 != a3)
  {
    v21[11] = v3;
    v21[12] = v4;
    uint64_t v6 = a2;
    BOOL v8 = (void *)(a1 + 8);
    do
    {
      uint64_t v9 = *(void *)(a1 + 8);
      uint64_t v10 = v8;
      if (*(void **)a1 == v8) {
        goto LABEL_10;
      }
      uint64_t v11 = *(void **)(a1 + 8);
      char v12 = v8;
      if (v9)
      {
        do
        {
          uint64_t v10 = v11;
          uint64_t v11 = (void *)v11[1];
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v12[2];
          BOOL v13 = *v10 == (void)v12;
          char v12 = v10;
        }
        while (v13);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v10 + 4, (void *)v6 + 4) & 0x80) != 0)
      {
LABEL_10:
        uint64_t v15 = (uint64_t)v8;
        uint64_t v14 = (uint64_t **)v8;
        if (!v9) {
          goto LABEL_14;
        }
        v21[0] = v10;
        uint64_t v14 = (uint64_t **)(v10 + 1);
      }
      else
      {
        uint64_t v14 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(a1, v21, (void *)v6 + 4);
      }
      if (!*v14)
      {
        uint64_t v15 = v21[0];
LABEL_14:
        uint64_t v16 = (char *)operator new(0x58uLL);
        v19[1] = v8;
        std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100]((std::string *)(v16 + 32), v6 + 2);
        char v20 = 1;
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at((uint64_t **)a1, v15, v14, (uint64_t *)v16);
        v19[0] = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v19);
      }
      __int16 v17 = (long long *)*((void *)v6 + 1);
      if (v17)
      {
        do
        {
          __int16 v18 = v17;
          __int16 v17 = *(long long **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          __int16 v18 = (long long *)*((void *)v6 + 2);
          BOOL v13 = *(void *)v18 == (void)v6;
          uint64_t v6 = v18;
        }
        while (!v13);
      }
      uint64_t v6 = v18;
    }
    while (v18 != a3);
  }
}

void KB::LanguageModelStr::draft_radar_for_model_creation_failure(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = (KB::LanguageModelConfig *)(a1 + 8);
  KB::string_from_locale(*(KB **)(a1 + 8), (const __CFLocale *)a2, v38);
  if (v39 >= 0) {
    uint64_t v6 = v38;
  }
  else {
    uint64_t v6 = (void **)v38[0];
  }
  if (a3) {
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"it could not reload resources for locale %s", v6);
  }
  else {
    CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"it could not load resources for locale %s", v6);
  }
  CFStringRef v8 = v7;
  Mutable = CFStringCreateMutable(0, 0);
  uint64_t v10 = Mutable;
  if (v39 >= 0) {
    uint64_t v11 = v38;
  }
  else {
    uint64_t v11 = (void **)v38[0];
  }
  CFStringAppendFormat(Mutable, 0, @"Locale: %s\n\n", v11);
  CFStringAppend(v10, @"Options: \n");
  v37[0] = 0;
  v37[1] = 0;
  char v36 = v37;
  std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v36, *(long long **)a2, (long long *)(a2 + 8));
  *(_OWORD *)&v30.__r_.__value_.__r.__words[1] = 0uLL;
  v30.__r_.__value_.__r.__words[0] = (std::string::size_type)&v30.__r_.__value_.__l.__size_;
  char v12 = v36;
  if (v36 != v37)
  {
    do
    {
      if (*((char *)v12 + 55) < 0) {
        std::string::__init_copy_ctor_external(&v33, (const std::string::value_type *)v12[4], (std::string::size_type)v12[5]);
      }
      else {
        std::string v33 = *(std::string *)(v12 + 4);
      }
      uint64_t v13 = *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)&v36, &v40, &v33);
      if (!v13) {
        abort();
      }
      int v14 = *(_DWORD *)(v13 + 80);
      if (v14)
      {
        if (v14 == 1)
        {
          uint64_t v15 = (const std::string *)(v13 + 56);
          char v40 = &v33;
          uint64_t v16 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v30, &v33, (long long **)&v40);
          std::string::operator=((std::string *)(v16 + 7), v15);
        }
      }
      else
      {
        char v40 = &v33;
        __int16 v17 = std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)&v30, &v33, (long long **)&v40);
        if (*((char *)v17 + 79) < 0)
        {
          unsigned char v17[8] = 4;
          __int16 v18 = (char *)v17[7];
        }
        else
        {
          __int16 v18 = (char *)(v17 + 7);
          *((unsigned char *)v17 + 79) = 4;
        }
        strcpy(v18, "true");
      }
      if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v33.__r_.__value_.__l.__data_);
      }
      uint64_t v19 = v12[1];
      if (v19)
      {
        do
        {
          char v20 = (void **)v19;
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          char v20 = (void **)v12[2];
          BOOL v21 = *v20 == v12;
          char v12 = v20;
        }
        while (!v21);
      }
      char v12 = v20;
    }
    while (v20 != v37);
  }
  debugStringFromMap((CFStringRef *)&v40, &v30);
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy((void *)v30.__r_.__value_.__l.__size_);
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v37[0]);
  os_signpost_id_t v22 = (long long *)v40;
  CFStringAppend(v10, (CFStringRef)v40);
  CFStringAppend(v10, @"\nTrial Parameters: \n");
  KB::LanguageModelConfig::trial_parameters(v5, v23, (uint64_t)&v33);
  if (v35[16])
  {
    if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&v30, v33.__r_.__value_.__l.__data_, v33.__r_.__value_.__l.__size_);
    }
    else {
      std::string v30 = v33;
    }
    v32[0] = 0;
    v32[1] = 0;
    std::string v31 = (uint64_t *)v32;
    uint64_t v24 = v34;
    if (v34 != (long long *)v35)
    {
      do
      {
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(&v31, (uint64_t *)v32, (void *)v24 + 4, v24 + 2);
        uint64_t v25 = (long long *)*((void *)v24 + 1);
        if (v25)
        {
          do
          {
            char v26 = v25;
            uint64_t v25 = *(long long **)v25;
          }
          while (v25);
        }
        else
        {
          do
          {
            char v26 = (long long *)*((void *)v24 + 2);
            BOOL v21 = *(void *)v26 == (void)v24;
            uint64_t v24 = v26;
          }
          while (!v21);
        }
        uint64_t v24 = v26;
      }
      while (v26 != (long long *)v35);
    }
    if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string v27 = &v30;
    }
    else {
      std::string v27 = (std::string *)v30.__r_.__value_.__r.__words[0];
    }
    CFStringAppendFormat(v10, 0, @"languageModelBundlePath: %s\n", v27);
    debugStringFromMap(&appendedString, &v31);
    CFStringRef v28 = appendedString;
    CFStringAppend(v10, appendedString);
    if (v28) {
      CFRelease(v28);
    }
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v32[0]);
    if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v30.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    CFStringAppend(v10, @"<no trial parameters>\n");
  }
  createTapToRadarDraft((uint64_t)v8, (uint64_t)v10);
  CFRelease(v8);
  CFRelease(v10);
  std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v33);
  if (v22) {
    CFRelease(v22);
  }
  if (v39 < 0) {
    operator delete(v38[0]);
  }
}

void std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 48);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_1F3F71B20[v2])(&v3, a1 + 24);
  }
  *(_DWORD *)(a1 + 48) = -1;
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSF_1EJbSD_EEEEEEDcSH_DpT0_(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, void *a2, long long **a3)
{
  uint64_t v5 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v14, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    CFStringRef v7 = v5;
    uint64_t v6 = (uint64_t *)operator new(0x50uLL);
    v12[1] = a1 + 1;
    CFStringRef v8 = (std::string *)(v6 + 4);
    uint64_t v9 = *a3;
    if (*((char *)*a3 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)v9, *((void *)v9 + 1));
    }
    else
    {
      long long v10 = *v9;
      v6[6] = *((void *)v9 + 2);
      *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v10;
    }
    v6[7] = 0;
    v6[8] = 0;
    v6[9] = 0;
    char v13 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v14, v7, v6);
    v12[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v12);
  }
  return v6;
}

void debugStringFromMap(CFStringRef *a1, void *a2)
{
  memset(&v25, 0, sizeof(v25));
  char v3 = a2 + 1;
  uint64_t v4 = (void *)*a2;
  if ((void *)*a2 == a2 + 1)
  {
    char v20 = &v25;
  }
  else
  {
    do
    {
      if (*((char *)v4 + 55) >= 0) {
        size_t v5 = *((unsigned __int8 *)v4 + 55);
      }
      else {
        size_t v5 = v4[5];
      }
      std::string::basic_string[abi:nn180100]((uint64_t)&v21, v5 + 4);
      if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v6 = &v21;
      }
      else {
        uint64_t v6 = (std::string *)v21.__r_.__value_.__r.__words[0];
      }
      if (v5)
      {
        if (*((char *)v4 + 55) >= 0) {
          CFStringRef v7 = v4 + 4;
        }
        else {
          CFStringRef v7 = (const void *)v4[4];
        }
        memmove(v6, v7, v5);
      }
      strcpy((char *)v6 + v5, ":\n\t ");
      int v8 = *((char *)v4 + 79);
      if (v8 >= 0) {
        uint64_t v9 = (const std::string::value_type *)(v4 + 7);
      }
      else {
        uint64_t v9 = (const std::string::value_type *)v4[7];
      }
      if (v8 >= 0) {
        std::string::size_type v10 = *((unsigned __int8 *)v4 + 79);
      }
      else {
        std::string::size_type v10 = v4[8];
      }
      uint64_t v11 = std::string::append(&v21, v9, v10);
      std::string::size_type v12 = v11->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v22.__r_.__value_.__l.__data_ = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v22.__r_.__value_.__r.__words[2] = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      char v13 = std::string::append(&v22, "\n", 1uLL);
      std::string::size_type v14 = v13->__r_.__value_.__r.__words[2];
      *(_OWORD *)long long __p = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
      uint64_t v24 = v14;
      v13->__r_.__value_.__l.__size_ = 0;
      v13->__r_.__value_.__r.__words[2] = 0;
      v13->__r_.__value_.__r.__words[0] = 0;
      if (v24 >= 0) {
        uint64_t v15 = __p;
      }
      else {
        uint64_t v15 = (void **)__p[0];
      }
      if (v24 >= 0) {
        std::string::size_type v16 = HIBYTE(v24);
      }
      else {
        std::string::size_type v16 = (std::string::size_type)__p[1];
      }
      std::string::append(&v25, (const std::string::value_type *)v15, v16);
      if (SHIBYTE(v24) < 0) {
        operator delete(__p[0]);
      }
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v22.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v21.__r_.__value_.__l.__data_);
      }
      __int16 v17 = (void *)v4[1];
      if (v17)
      {
        do
        {
          __int16 v18 = v17;
          __int16 v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          __int16 v18 = (void *)v4[2];
          BOOL v19 = *v18 == (void)v4;
          uint64_t v4 = v18;
        }
        while (!v19);
      }
      uint64_t v4 = v18;
    }
    while (v18 != v3);
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      char v20 = &v25;
    }
    else {
      char v20 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
  }
  *a1 = CFStringCreateWithCString(0, (const char *)v20, 0x8000100u);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v25.__r_.__value_.__l.__data_);
  }
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*a1);
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

uint64_t std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(*(void **)(a1 + 32));
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

void std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::string> const&>(uint64_t **a1, uint64_t *a2, void *a3, long long *a4)
{
  uint64_t v6 = a2;
  int v8 = a1 + 1;
  if (a1 + 1 == (uint64_t **)a2
    || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, a2 + 4) & 0x80) != 0)
  {
    uint64_t v10 = *v6;
    if (*a1 == v6)
    {
      std::string::size_type v12 = v6;
    }
    else
    {
      if (v10)
      {
        uint64_t v11 = (uint64_t *)*v6;
        do
        {
          std::string::size_type v12 = v11;
          uint64_t v11 = (uint64_t *)v11[1];
        }
        while (v11);
      }
      else
      {
        uint64_t v15 = v6;
        do
        {
          std::string::size_type v12 = (uint64_t *)v15[2];
          BOOL v16 = *v12 == (void)v15;
          uint64_t v15 = v12;
        }
        while (v16);
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v12 + 4, a3) & 0x80) == 0) {
        goto LABEL_19;
      }
    }
    if (!v10)
    {
      std::string v22 = v6;
      uint64_t v9 = (uint64_t **)v6;
      goto LABEL_25;
    }
    std::string v22 = v12;
    uint64_t v9 = (uint64_t **)(v12 + 1);
    goto LABEL_22;
  }
  if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v6 + 4, a3) & 0x80) != 0)
  {
    uint64_t v13 = v6[1];
    if (v13)
    {
      std::string::size_type v14 = (uint64_t *)v6[1];
      do
      {
        uint64_t v9 = (uint64_t **)v14;
        std::string::size_type v14 = (uint64_t *)*v14;
      }
      while (v14);
    }
    else
    {
      __int16 v18 = (uint64_t **)v6;
      do
      {
        uint64_t v9 = (uint64_t **)v18[2];
        BOOL v16 = *v9 == (uint64_t *)v18;
        __int16 v18 = v9;
      }
      while (!v16);
    }
    if (v9 == v8
      || (std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v9 + 4) & 0x80) != 0)
    {
      if (v13)
      {
        std::string v22 = (uint64_t *)v9;
      }
      else
      {
        std::string v22 = v6;
        uint64_t v9 = (uint64_t **)(v6 + 1);
      }
LABEL_22:
      if (*v9) {
        return;
      }
      goto LABEL_23;
    }
LABEL_19:
    uint64_t v9 = (uint64_t **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v22, a3);
    goto LABEL_22;
  }
  std::string v21 = v6;
  std::string v22 = v6;
  uint64_t v9 = &v21;
  if (v6) {
    return;
  }
LABEL_23:
  uint64_t v6 = v22;
LABEL_25:
  __int16 v17 = (char *)operator new(0x50uLL);
  v19[1] = v8;
  std::pair<std::string const,std::string>::pair[abi:nn180100]((std::string *)(v17 + 32), a4);
  char v20 = 1;
  std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, (uint64_t)v6, v9, (uint64_t *)v17);
  v19[0] = 0;
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100]((uint64_t)v19);
}

std::string *std::pair<std::string const,std::string>::pair[abi:nn180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  size_t v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  return this;
}

uint64_t *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  size_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::string>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::string>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::string>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void *std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>(uint64_t a1, void *a2, void *a3)
{
  size_t v5 = (void *)(a1 + 8);
  long long v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        CFStringRef v7 = v4;
        int v8 = v4 + 4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        long long v4 = (void *)*v7;
        size_t v5 = v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v8, a3) & 0x80) == 0) {
        break;
      }
      size_t v5 = v7 + 1;
      long long v4 = (void *)v7[1];
    }
    while (v4);
  }
  else
  {
    CFStringRef v7 = (void *)(a1 + 8);
  }
LABEL_9:
  *a2 = v7;
  return v5;
}

uint64_t std::string::basic_string[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    long long v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

std::string *std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100](std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  this[1].__r_.__value_.__s.__data_[0] = 0;
  LODWORD(this[2].__r_.__value_.__l.__data_) = -1;
  uint64_t v5 = *((unsigned int *)a2 + 12);
  if (v5 != -1)
  {
    ((void (*)(char *))*(&off_1F3F71B30 + v5))(&v7);
    LODWORD(this[2].__r_.__value_.__l.__data_) = v5;
  }
  return this;
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::variant<BOOL,std::string>>,0>((uint64_t)v1 + 32);
    }
    operator delete(v1);
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSV_EEEDcSN_DpT0_(int a1, std::string *this, long long *a3)
{
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v3 = *a3;
    this->__r_.__value_.__r.__words[2] = *((void *)a3 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
  }
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_6__ctorINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE19__generic_constructB8nn180100IRKNS0_18__copy_constructorISE_LNS0_6_TraitE1EEEEEvRSF_OT_EUlRSN_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSV_EEEDcSN_DpT0_(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  *a2 = *a3;
}

void KB::LanguageModelStr::load(KB::LanguageModelStr *this, int a2)
{
  long long v3 = this;
  v176[2] = *MEMORY[0x1E4F143B8];
  if ((*(uint64_t (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this)) {
    return;
  }
  atomic_store(0, (unsigned __int8 *)v3 + 216);
  atomic_store(0, (unsigned __int8 *)v3 + 217);
  long long v165 = 0uLL;
  v164 = &v165;
  KB::string_from_locale(*((KB **)v3 + 1), v4, &__p);
  std::string::basic_string[abi:nn180100]<0>(&v175, (char *)*MEMORY[0x1E4F720C8]);
  v172.n128_u64[0] = (unint64_t)&v175;
  uint64_t v5 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v175, &v172);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v5 + 56), (uint64_t)v5 + 56, (__n128 *)&__p);
  if (SHIBYTE(v176[0]) < 0) {
    operator delete((void *)v175.n128_u64[0]);
  }
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  char v6 = *((unsigned char *)v3 + 80);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72100]);
  v175.n128_u64[0] = (unint64_t)&__p;
  char v7 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  int v8 = v7;
  uint64_t v9 = *((unsigned int *)v7 + 20);
  if (v9 != -1)
  {
    uint64_t v10 = (char *)v7 + 56;
    if (!v9)
    {
      unsigned char *v10 = v6;
      goto LABEL_11;
    }
    ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v9])(&v175, v10);
  }
  *((unsigned char *)v8 + 56) = v6;
  *((_DWORD *)v8 + 20) = 0;
LABEL_11:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72130]);
  v175.n128_u64[0] = (unint64_t)&__p;
  uint64_t v11 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  std::string::size_type v12 = v11;
  uint64_t v13 = *((unsigned int *)v11 + 20);
  if (v13 != -1)
  {
    std::string::size_type v14 = (char *)v11 + 56;
    if (!v13)
    {
      unsigned char *v14 = 1;
      goto LABEL_18;
    }
    ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v13])(&v175, v14);
  }
  *((unsigned char *)v12 + 56) = 1;
  *((_DWORD *)v12 + 20) = 0;
LABEL_18:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72048]);
  v175.n128_u64[0] = (unint64_t)&__p;
  uint64_t v15 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  BOOL v16 = v15;
  uint64_t v17 = *((unsigned int *)v15 + 20);
  if (v17 != -1)
  {
    __int16 v18 = (char *)v15 + 56;
    if (!v17)
    {
      *__int16 v18 = 1;
      goto LABEL_25;
    }
    ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v17])(&v175, v18);
  }
  *((unsigned char *)v16 + 56) = 1;
  *((_DWORD *)v16 + 20) = 0;
LABEL_25:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72160]);
  v175.n128_u64[0] = (unint64_t)&__p;
  BOOL v19 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v19 + 56, (std::string *)((char *)v19 + 56), MEMORY[0x1E4F72168]);
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  char v20 = (char **)MEMORY[0x1E4F72180];
  std::string v21 = (char **)MEMORY[0x1E4F72188];
  int v22 = *((_DWORD *)v3 + 24);
  if (v22 != 80) {
    std::string v21 = (char **)MEMORY[0x1E4F72190];
  }
  if (v22 != 70) {
    char v20 = v21;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, *v20);
  std::string::basic_string[abi:nn180100]<0>(&v175, (char *)*MEMORY[0x1E4F72198]);
  v172.n128_u64[0] = (unint64_t)&v175;
  CFDictionaryRef v23 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v175, &v172);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v23 + 56), (uint64_t)v23 + 56, (__n128 *)&__p);
  if (SHIBYTE(v176[0]) < 0) {
    operator delete((void *)v175.n128_u64[0]);
  }
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  char v24 = *((unsigned char *)v3 + 81);
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72050]);
  v175.n128_u64[0] = (unint64_t)&__p;
  std::string v25 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  char v26 = v25;
  uint64_t v27 = *((unsigned int *)v25 + 20);
  if (v27 != -1)
  {
    CFStringRef v28 = (char *)v25 + 56;
    if (!v27)
    {
      unsigned char *v28 = v24;
      goto LABEL_42;
    }
    ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v27])(&v175, v28);
  }
  *((unsigned char *)v26 + 56) = v24;
  *((_DWORD *)v26 + 20) = 0;
LABEL_42:
  if (SHIBYTE(__p.__end_) < 0)
  {
    operator delete(__p.__first_);
    if (a2) {
      goto LABEL_53;
    }
  }
  else if (a2)
  {
    goto LABEL_53;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72060]);
  v175.n128_u64[0] = (unint64_t)&__p;
  char v29 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  std::string v30 = v29;
  uint64_t v31 = *((unsigned int *)v29 + 20);
  if (v31 != -1)
  {
    uint64_t v32 = (char *)v29 + 56;
    if (!v31)
    {
      *uint64_t v32 = 1;
      goto LABEL_51;
    }
    ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v31])(&v175, v32);
  }
  *((unsigned char *)v30 + 56) = 1;
  *((_DWORD *)v30 + 20) = 0;
LABEL_51:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
LABEL_53:
  int64x2_t v162 = 0uLL;
  v163 = 0;
  CFArrayRef v33 = (const __CFArray *)*((void *)v3 + 2);
  v155 = (KB::LanguageModelStr *)((char *)v3 + 8);
  int v154 = a2;
  if (v33 && (CFIndex Count = CFArrayGetCount(v33), Count >= 1))
  {
    CFIndex v35 = Count;
    CFIndex v36 = 0;
    char v37 = 0;
    do
    {
      ValueAtIndex = (KB *)CFArrayGetValueAtIndex(*((CFArrayRef *)v3 + 2), v36);
      KB::string_from_locale(ValueAtIndex, v39, &v175);
      char v40 = (__n128 *)v162.i64[1];
      if (v162.i64[1] >= (unint64_t)v163)
      {
        unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((v162.i64[1] - v162.i64[0]) >> 3) + 1;
        if (v42 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        if (0x5555555555555556 * (((uint64_t)v163 - v162.i64[0]) >> 3) > v42) {
          unint64_t v42 = 0x5555555555555556 * (((uint64_t)v163 - v162.i64[0]) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v163 - v162.i64[0]) >> 3) >= 0x555555555555555) {
          unint64_t v43 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v43 = v42;
        }
        __p.__end_cap_.__value_ = (std::allocator<std::string> *)&v163;
        if (v43)
        {
          unint64_t v44 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v43);
          uint64_t v46 = v45;
        }
        else
        {
          unint64_t v44 = 0;
          uint64_t v46 = 0;
        }
        unint64_t v48 = (std::string *)&v44[8 * ((v162.i64[1] - v162.i64[0]) >> 3)];
        if (SHIBYTE(v176[0]) < 0)
        {
          std::string::__init_copy_ctor_external(v48, (const std::string::value_type *)v175.n128_u64[0], v175.n128_u64[1]);
        }
        else
        {
          __n128 v49 = v175;
          v48->__r_.__value_.__r.__words[2] = v176[0];
          *(__n128 *)&v48->__r_.__value_.__l.__data_ = v49;
        }
        uint64_t v50 = v162.i64[1];
        uint64_t v51 = v162.i64[0];
        if (v162.i64[1] == v162.i64[0])
        {
          int64x2_t v54 = vdupq_n_s64(v162.u64[1]);
          uint64_t v52 = v48;
        }
        else
        {
          uint64_t v52 = v48;
          do
          {
            long long v53 = *(_OWORD *)(v50 - 24);
            v52[-1].__r_.__value_.__r.__words[2] = *(void *)(v50 - 8);
            *(_OWORD *)&v52[-1].__r_.__value_.__l.__data_ = v53;
            --v52;
            *(void *)(v50 - 16) = 0;
            *(void *)(v50 - 8) = 0;
            *(void *)(v50 - 24) = 0;
            v50 -= 24;
          }
          while (v50 != v51);
          int64x2_t v54 = v162;
        }
        char v47 = v48 + 1;
        v162.i64[0] = (uint64_t)v52;
        v162.i64[1] = (uint64_t)v47;
        *(int64x2_t *)&__p.__begin_ = v54;
        uint64_t v55 = v163;
        v163 = (std::string *)&v44[24 * v46];
        __p.__end_cap_.__value_ = v55;
        __p.__first_ = (std::__split_buffer<std::string>::pointer)v54.i64[0];
        std::__split_buffer<std::string>::~__split_buffer(&__p);
      }
      else
      {
        if (SHIBYTE(v176[0]) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v162.i64[1], (const std::string::value_type *)v175.n128_u64[0], v175.n128_u64[1]);
        }
        else
        {
          __n128 v41 = v175;
          *(void *)(v162.i64[1] + 16) = v176[0];
          __n128 *v40 = v41;
        }
        char v47 = (std::string *)&v40[1].n128_i8[8];
      }
      v162.i64[1] = (uint64_t)v47;
      if (_os_feature_enabled_impl()) {
        char v37 = 1;
      }
      if (SHIBYTE(v176[0]) < 0) {
        operator delete((void *)v175.n128_u64[0]);
      }
      ++v36;
    }
    while (v36 != v35);
  }
  else
  {
    char v37 = 0;
  }
  std::string::basic_string[abi:nn180100]<0>(&__str, "");
  uint64_t v56 = v162.i64[1];
  uint64_t v156 = (uint64_t)v3;
  if (v162.i64[1] != v162.i64[0])
  {
    uint64_t v57 = v162.i64[0] + 24;
    if (*(char *)(v162.i64[0] + 23) < 0) {
      std::string::__init_copy_ctor_external(&v160, *(const std::string::value_type **)v162.i64[0], *(void *)(v162.i64[0] + 8));
    }
    else {
      std::string v160 = *(std::string *)v162.i64[0];
    }
    char v153 = v37;
    if (v57 != v56)
    {
      std::string::size_type size = HIBYTE(v160.__r_.__value_.__r.__words[2]);
      char v59 = (std::string *)v160.__r_.__value_.__r.__words[0];
      while (1)
      {
        int v60 = (char)size;
        if ((size & 0x80u) != 0) {
          std::string::size_type size = v160.__r_.__value_.__l.__size_;
        }
        std::string::basic_string[abi:nn180100]((uint64_t)&__p, size + 1);
        if (SHIBYTE(__p.__end_) >= 0) {
          std::__split_buffer<std::string>::pointer p_p = (std::__split_buffer<std::string>::pointer)&__p;
        }
        else {
          std::__split_buffer<std::string>::pointer p_p = __p.__first_;
        }
        if (size)
        {
          if (v60 >= 0) {
            float v62 = &v160;
          }
          else {
            float v62 = v59;
          }
          memmove(p_p, v62, size);
        }
        *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + size) = 44;
        int v63 = *(char *)(v57 + 23);
        if (v63 >= 0) {
          long long v64 = (const std::string::value_type *)v57;
        }
        else {
          long long v64 = *(const std::string::value_type **)v57;
        }
        if (v63 >= 0) {
          std::string::size_type v65 = *(unsigned __int8 *)(v57 + 23);
        }
        else {
          std::string::size_type v65 = *(void *)(v57 + 8);
        }
        unint64_t v66 = std::string::append((std::string *)&__p, v64, v65);
        std::string::size_type v67 = v66->__r_.__value_.__r.__words[0];
        v175.n128_u64[0] = v66->__r_.__value_.__l.__size_;
        *(unint64_t *)((char *)v175.n128_u64 + 7) = *(std::string::size_type *)((char *)&v66->__r_.__value_.__r.__words[1]
                                                                                     + 7);
        std::string::size_type size = HIBYTE(v66->__r_.__value_.__r.__words[2]);
        v66->__r_.__value_.__r.__words[0] = 0;
        v66->__r_.__value_.__l.__size_ = 0;
        v66->__r_.__value_.__r.__words[2] = 0;
        if (SHIBYTE(__p.__end_) < 0)
        {
          operator delete(__p.__first_);
          if (v60 < 0) {
LABEL_113:
          }
            operator delete(v59);
        }
        else if (v60 < 0)
        {
          goto LABEL_113;
        }
        v160.__r_.__value_.__r.__words[0] = v67;
        v160.__r_.__value_.__l.__size_ = v175.n128_u64[0];
        *(std::string::size_type *)((char *)&v160.__r_.__value_.__r.__words[1] + 7) = *(unint64_t *)((char *)v175.n128_u64 + 7);
        *((unsigned char *)&v160.__r_.__value_.__s + 23) = size;
        v57 += 24;
        char v59 = (std::string *)v67;
        if (v57 == v56) {
          goto LABEL_115;
        }
      }
    }
    std::string::size_type v67 = v160.__r_.__value_.__r.__words[0];
    LOBYTE(size) = *((unsigned char *)&v160.__r_.__value_.__s + 23);
LABEL_115:
    __p.__first_ = (std::__split_buffer<std::string>::pointer)v160.__r_.__value_.__l.__size_;
    *(std::__split_buffer<std::string>::pointer *)((char *)&__p.__first_ + 7) = *(std::__split_buffer<std::string>::pointer *)((char *)&v160.__r_.__value_.__r.__words[1] + 7);
    memset(&v160, 0, sizeof(v160));
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    __str.__r_.__value_.__r.__words[0] = v67;
    __str.__r_.__value_.__l.__size_ = (std::string::size_type)__p.__first_;
    *(std::string::size_type *)((char *)&__str.__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)&__p.__first_ + 7);
    *((unsigned char *)&__str.__r_.__value_.__s + 23) = size;
    long long v3 = (KB::LanguageModelStr *)v156;
    char v37 = v153;
  }
  std::string::basic_string[abi:nn180100]<0>(&v175, (char *)*MEMORY[0x1E4F72090]);
  __p.__first_ = (std::__split_buffer<std::string>::pointer)&v175;
  uint64_t v68 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v175, &__p);
  unint64_t v69 = (char *)v68 + 56;
  int v70 = *((_DWORD *)v68 + 20);
  if (v70 == 1)
  {
    std::string::operator=((std::string *)((char *)v68 + 56), &__str);
  }
  else
  {
    long long v71 = v68;
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external((std::string *)&__p, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
      int v70 = *((_DWORD *)v71 + 20);
    }
    else
    {
      *(_OWORD *)&__p.__first_ = *(_OWORD *)&__str.__r_.__value_.__l.__data_;
      __p.__end_ = (std::__split_buffer<std::string>::pointer)__str.__r_.__value_.__r.__words[2];
    }
    if (v70 != -1) {
      ((void (*)(__n128 *, char *))off_1F3F71B20[v70])(&v172, v69);
    }
    *(_OWORD *)unint64_t v69 = *(_OWORD *)&__p.__first_;
    *((void *)v69 + 2) = __p.__end_;
    *((_DWORD *)v71 + 20) = 1;
  }
  if (SHIBYTE(v176[0]) < 0) {
    operator delete((void *)v175.n128_u64[0]);
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72128]);
  v175.n128_u64[0] = (unint64_t)&__p;
  v72 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  int v73 = v72;
  uint64_t v74 = *((unsigned int *)v72 + 20);
  if (v74 != -1)
  {
    uint64_t v75 = (char *)v72 + 56;
    if (!v74)
    {
      *uint64_t v75 = v37;
      goto LABEL_133;
    }
    ((void (*)(__n128 *, char *))off_1F3F71B20[v74])(&v175, v75);
  }
  *((unsigned char *)v73 + 56) = v37;
  *((_DWORD *)v73 + 20) = 0;
LABEL_133:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72178]);
  v175.n128_u64[0] = (unint64_t)&__p;
  int v76 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
  long long v77 = v76;
  uint64_t v78 = *((unsigned int *)v76 + 20);
  if (v78 != -1)
  {
    uint64_t v79 = (char *)v76 + 56;
    if (!v78)
    {
      *uint64_t v79 = v37;
      goto LABEL_140;
    }
    ((void (*)(__n128 *, char *))off_1F3F71B20[v78])(&v175, v79);
  }
  *((unsigned char *)v77 + 56) = v37;
  *((_DWORD *)v77 + 20) = 0;
LABEL_140:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  CFArrayRef v80 = (const __CFArray *)*((void *)v3 + 4);
  if (v80 && CFArrayGetCount(*((CFArrayRef *)v3 + 4)) >= 1)
  {
    CFStringRef v81 = CFStringCreateByCombiningStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v80, @",");
    KB::utf8_string(v81, (uint64_t)&__p);
    begin = (char *)__p.__begin_;
    if (!__p.__begin_) {
      begin = (char *)&__p.__end_;
    }
    if (LOWORD(__p.__first_)) {
      os_signpost_id_t v83 = begin;
    }
    else {
      os_signpost_id_t v83 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(&v175, v83);
    std::string::basic_string[abi:nn180100]<0>(&v172, (char *)*MEMORY[0x1E4F72138]);
    *(void *)&long long v166 = &v172;
    v84 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v172, (_OWORD **)&v166);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v84 + 56), (uint64_t)v84 + 56, &v175);
    if (v173 < 0) {
      operator delete((void *)v172.n128_u64[0]);
    }
    if (SHIBYTE(v176[0]) < 0) {
      operator delete((void *)v175.n128_u64[0]);
    }
    if (__p.__begin_ && BYTE6(__p.__first_) == 1) {
      free(__p.__begin_);
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F720E0]);
    v175.n128_u64[0] = (unint64_t)&__p;
    char v85 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v175);
    uint64_t v86 = v85;
    uint64_t v87 = *((unsigned int *)v85 + 20);
    if (v87 != -1)
    {
      char v88 = (char *)v85 + 56;
      if (!v87)
      {
        *char v88 = 1;
LABEL_161:
        if (SHIBYTE(__p.__end_) < 0) {
          operator delete(__p.__first_);
        }
        if (v81) {
          CFRelease(v81);
        }
        goto LABEL_165;
      }
      ((void (*)(__n128 *, unsigned char *))off_1F3F71B20[v87])(&v175, v88);
    }
    *((unsigned char *)v86 + 56) = 1;
    *((_DWORD *)v86 + 20) = 0;
    goto LABEL_161;
  }
LABEL_165:
  uint64_t v89 = CFArrayGetValueAtIndex(*((CFArrayRef *)v3 + 2), 0);
  CFStringRef v90 = (const __CFString *)MEMORY[0x1E4E79AD0](v89);
  KB::utf8_string(v90, (uint64_t)&__p);
  if (*((unsigned char *)v3 + 81)) {
    long long v91 = "Siri-TextInput-Dynamic.";
  }
  else {
    long long v91 = "TextInput-Dynamic.";
  }
  v92 = (unsigned __int16 *)KB::String::String((KB::String *)&v175, v91);
  KB::String::append(v92, (const KB::String *)&__p);
  if (__p.__begin_ && BYTE6(__p.__first_) == 1) {
    free(__p.__begin_);
  }
  uint64_t v93 = (char *)v175.n128_u64[1];
  if (!v175.n128_u64[1]) {
    uint64_t v93 = (char *)v176;
  }
  if (v175.n128_u16[0]) {
    v94 = v93;
  }
  else {
    v94 = "";
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, v94);
  std::string::basic_string[abi:nn180100]<0>(&v172, (char *)*MEMORY[0x1E4F720F0]);
  *(void *)&long long v166 = &v172;
  v95 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v172, (_OWORD **)&v166);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v95 + 56), (uint64_t)v95 + 56, (__n128 *)&__p);
  if (v173 < 0) {
    operator delete((void *)v172.n128_u64[0]);
  }
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
  if (v37)
  {
    KB::String::String((KB::String *)&v172, "mul");
    if (*((unsigned char *)v3 + 81)) {
      long long v96 = "Siri-TextInput-Dynamic.";
    }
    else {
      long long v96 = "TextInput-Dynamic.";
    }
    KB::String::String((KB::String *)&__p, v96);
    KB::String::append((unsigned __int16 *)&__p, (const KB::String *)&v172);
    if (v172.n128_u64[1] && v172.n128_u8[6] == 1) {
      free((void *)v172.n128_u64[1]);
    }
    p_end = (char *)__p.__begin_;
    if (!__p.__begin_) {
      p_end = (char *)&__p.__end_;
    }
    if (LOWORD(__p.__first_)) {
      v98 = p_end;
    }
    else {
      v98 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(&v172, v98);
    std::string::basic_string[abi:nn180100]<0>(&v166, (char *)*MEMORY[0x1E4F72140]);
    *(void *)buf = &v166;
    v99 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v166, (_OWORD **)buf);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v99 + 56), (uint64_t)v99 + 56, &v172);
    if (SHIBYTE(v167) < 0) {
      operator delete((void *)v166);
    }
    if (v173 < 0) {
      operator delete((void *)v172.n128_u64[0]);
    }
    if (__p.__begin_ && BYTE6(__p.__first_) == 1) {
      free(__p.__begin_);
    }
  }
  CFStringRef v100 = (const __CFString *)*((void *)v3 + 5);
  v101 = (char **)MEMORY[0x1E4F720B8];
  if (v100)
  {
    KB::utf8_string(v100, (uint64_t)&__p);
    v102 = (char *)__p.__begin_;
    if (!__p.__begin_) {
      v102 = (char *)&__p.__end_;
    }
    if (LOWORD(__p.__first_)) {
      v103 = v102;
    }
    else {
      v103 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(&v172, v103);
    std::string::basic_string[abi:nn180100]<0>(&v166, (char *)*MEMORY[0x1E4F72150]);
    *(void *)buf = &v166;
    long long v104 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v166, (_OWORD **)buf);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>((__n128 *)((char *)v104 + 56), (uint64_t)v104 + 56, &v172);
    if (SHIBYTE(v167) < 0) {
      operator delete((void *)v166);
    }
    if (v173 < 0) {
      operator delete((void *)v172.n128_u64[0]);
    }
    if (__p.__begin_ && BYTE6(__p.__first_) == 1) {
      free(__p.__begin_);
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, *v101);
    v172.n128_u64[0] = (unint64_t)&__p;
    long long v105 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v172);
    uint64_t v107 = v105;
    uint64_t v108 = *((unsigned int *)v105 + 20);
    if (v108 != -1)
    {
      CFDictionaryRef v106 = (const __CFDictionary *)((char *)v105 + 56);
      if (!v108)
      {
        *(unsigned char *)CFDictionaryRef v106 = 1;
        goto LABEL_223;
      }
      ((void (*)(__n128 *, const __CFDictionary *))off_1F3F71B20[v108])(&v172, v106);
    }
    *((unsigned char *)v107 + 56) = 1;
  }
  else
  {
    std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F720B8]);
    v172.n128_u64[0] = (unint64_t)&__p;
    v109 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v172);
    uint64_t v107 = v109;
    uint64_t v110 = *((unsigned int *)v109 + 20);
    if (v110 != -1)
    {
      CFDictionaryRef v106 = (const __CFDictionary *)((char *)v109 + 56);
      if (!v110)
      {
        *(unsigned char *)CFDictionaryRef v106 = 0;
        goto LABEL_223;
      }
      ((void (*)(__n128 *, const __CFDictionary *))off_1F3F71B20[v110])(&v172, v106);
    }
    *((unsigned char *)v107 + 56) = 0;
  }
  *((_DWORD *)v107 + 20) = 0;
LABEL_223:
  if (SHIBYTE(__p.__end_) < 0)
  {
    operator delete(__p.__first_);
    if (!v154) {
      goto LABEL_251;
    }
  }
  else if (!v154)
  {
    goto LABEL_251;
  }
  if (*((unsigned char *)v3 + 92))
  {
    int v111 = s_use_lm_transformer;
    if (s_use_lm_transformer)
    {
      if (*((_DWORD *)v3 + 17) == 1 || !*((_DWORD *)v3 + 18))
      {
        std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72158]);
        v172.n128_u64[0] = (unint64_t)&__p;
        v112 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v172);
        std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v112 + 56, (std::string *)((char *)v112 + 56), MEMORY[0x1E4F72078]);
        if (SHIBYTE(__p.__end_) < 0) {
          operator delete(__p.__first_);
        }
        int v111 = s_use_lm_transformer;
      }
      if ((v111 == 2 || v111 == -1) && (*((_DWORD *)v3 + 17) == 1 || !*((_DWORD *)v3 + 18)))
      {
        std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72148]);
        v172.n128_u64[0] = (unint64_t)&__p;
        v113 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v172);
        std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>((uint64_t)v113 + 56, (std::string *)((char *)v113 + 56), MEMORY[0x1E4F72078]);
        if (SHIBYTE(__p.__end_) < 0) {
          operator delete(__p.__first_);
        }
      }
    }
    int v114 = *((_DWORD *)v3 + 19);
    if (v114 != 2)
    {
      if (v114) {
        v115 = "ToucanLanguageModelDisabled";
      }
      else {
        v115 = (std::string::value_type *)*MEMORY[0x1E4F72078];
      }
      std::string::basic_string[abi:nn180100]<0>(&v172, (char *)*MEMORY[0x1E4F72170]);
      __p.__first_ = (std::__split_buffer<std::string>::pointer)&v172;
      v116 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &v172, &__p);
      v117 = (char *)v116 + 56;
      if (*((_DWORD *)v116 + 20) == 1)
      {
        std::string::__assign_external((std::string *)((char *)v116 + 56), v115);
      }
      else
      {
        v118 = v116;
        std::string::basic_string[abi:nn180100]<0>(&__p, v115);
        uint64_t v119 = *((unsigned int *)v118 + 20);
        if (v119 != -1) {
          ((void (*)(long long *, char *))off_1F3F71B20[v119])(&v166, v117);
        }
        *(_OWORD *)v117 = *(_OWORD *)&__p.__first_;
        *((void *)v117 + 2) = __p.__end_;
        *((_DWORD *)v118 + 20) = 1;
      }
      long long v3 = (KB::LanguageModelStr *)v156;
      if (v173 < 0) {
        operator delete((void *)v172.n128_u64[0]);
      }
    }
  }
LABEL_251:
  if (!*((unsigned char *)v3 + 82)) {
    goto LABEL_259;
  }
  std::string::basic_string[abi:nn180100]<0>(&__p, (char *)*MEMORY[0x1E4F72110]);
  v172.n128_u64[0] = (unint64_t)&__p;
  v120 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v164, &__p, &v172);
  v121 = v120;
  uint64_t v122 = *((unsigned int *)v120 + 20);
  if (v122 != -1)
  {
    CFDictionaryRef v106 = (const __CFDictionary *)((char *)v120 + 56);
    if (!v122)
    {
      *(unsigned char *)CFDictionaryRef v106 = 1;
      goto LABEL_257;
    }
    ((void (*)(__n128 *, const __CFDictionary *))off_1F3F71B20[v122])(&v172, v106);
  }
  *((unsigned char *)v121 + 56) = 1;
  *((_DWORD *)v121 + 20) = 0;
LABEL_257:
  if (SHIBYTE(__p.__end_) < 0) {
    operator delete(__p.__first_);
  }
LABEL_259:
  v123 = (uint64_t **)((char *)v3 + 280);
  if (v123 != (uint64_t **)&v164)
  {
    v124 = v164;
    if (*(void *)(v156 + 296))
    {
      uint64_t v125 = *(void *)(v156 + 280);
      uint64_t v126 = *(void *)(v156 + 288);
      *(void *)(v156 + 280) = v156 + 288;
      *(void *)(v126 + 16) = 0;
      *(void *)(v156 + 288) = 0;
      *(void *)(v156 + 296) = 0;
      if (*(void *)(v125 + 8)) {
        uint64_t v127 = *(void *)(v125 + 8);
      }
      else {
        uint64_t v127 = v125;
      }
      if (v127)
      {
        v128 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next(v127);
        if (v124 != &v165)
        {
          v129 = v124;
          while (1)
          {
            v130 = v128;
            std::string::operator=((std::string *)(v127 + 32), (const std::string *)(v129 + 2));
            uint64_t v131 = *(unsigned int *)(v127 + 80);
            uint64_t v132 = *((unsigned int *)v129 + 20);
            if (v131 == -1)
            {
              if (v132 != -1)
              {
LABEL_271:
                __p.__first_ = (std::__split_buffer<std::string>::pointer)(v127 + 56);
                ((void (*)(std::__split_buffer<std::string> *, uint64_t, char *))*(&off_1F3F71B40 + v132))(&__p, v127 + 56, (char *)v129 + 56);
              }
            }
            else
            {
              if (v132 != -1) {
                goto LABEL_271;
              }
              ((void (*)(std::__split_buffer<std::string> *, uint64_t))off_1F3F71B20[v131])(&__p, v127 + 56);
              *(_DWORD *)(v127 + 80) = -1;
            }
            leaf_high = (uint64_t **)std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high((uint64_t)v123, &__p, (void *)(v127 + 32));
            std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(v123, (uint64_t)__p.__first_, leaf_high, (uint64_t *)v127);
            if (v128) {
              v128 = std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next((uint64_t)v128);
            }
            else {
              v128 = 0;
            }
            v134 = (long long *)*((void *)v129 + 1);
            if (v134)
            {
              do
              {
                v124 = v134;
                v134 = *(long long **)v134;
              }
              while (v134);
            }
            else
            {
              do
              {
                v124 = (long long *)*((void *)v129 + 2);
                BOOL v135 = *(void *)v124 == (void)v129;
                v129 = v124;
              }
              while (!v135);
            }
            if (v130)
            {
              uint64_t v127 = (uint64_t)v130;
              v129 = v124;
              if (v124 != &v165) {
                continue;
              }
            }
            goto LABEL_285;
          }
        }
        v130 = (void *)v127;
        v124 = &v165;
LABEL_285:
        std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v130);
        if (!v128) {
          goto LABEL_290;
        }
        for (uint64_t i = (void *)v128[2]; i; uint64_t i = (void *)i[2])
          v128 = i;
        v136 = v128;
      }
      else
      {
        v136 = 0;
      }
      std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v136);
    }
LABEL_290:
    if (v124 != &v165)
    {
      do
      {
        v138 = (char *)operator new(0x58uLL);
        __p.__begin_ = (std::__split_buffer<std::string>::pointer)(v156 + 288);
        std::pair<std::string const,std::variant<BOOL,std::string>>::pair[abi:nn180100]((std::string *)(v138 + 32), v124 + 2);
        LOBYTE(__p.__end_) = 1;
        v139 = (uint64_t **)std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high((uint64_t)v123, &v172, (void *)v138 + 4);
        std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(v123, v172.n128_i64[0], v139, (uint64_t *)v138);
        __p.__first_ = 0;
        std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)&__p);
        v140 = (long long *)*((void *)v124 + 1);
        if (v140)
        {
          do
          {
            v141 = v140;
            v140 = *(long long **)v140;
          }
          while (v140);
        }
        else
        {
          do
          {
            v141 = (long long *)*((void *)v124 + 2);
            BOOL v135 = *(void *)v141 == (void)v124;
            v124 = v141;
          }
          while (!v135);
        }
        v124 = v141;
      }
      while (v141 != &v165);
    }
  }
  KB::LanguageModelConfig::trial_parameters(v155, v106, (uint64_t)&__p);
  language_modeling::v1::LanguageModel::init();
  std::__optional_destruct_base<LM::TrialParameters,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&__p);
  std::string::basic_string[abi:nn180100]<0>(&v166, "Success");
  LODWORD(__p.__first_) = 0;
  if (SHIBYTE(v167) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)&__p.__begin_, (const std::string::value_type *)v166, *((std::string::size_type *)&v166 + 1));
    if (SHIBYTE(v167) < 0) {
      operator delete((void *)v166);
    }
  }
  else
  {
    *(_OWORD *)&__p.__begin_ = v166;
    __p.__end_cap_.__value_ = v167;
  }
  if (v172.n128_u32[0] | LODWORD(__p.__first_))
  {
    v158[0] = 0;
    v158[1] = 0;
    v157 = v158;
    std::map<std::string,std::variant<BOOL,std::string>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *> *,long>>>((uint64_t)&v157, v164, &v165);
    KB::LanguageModelStr::draft_radar_for_model_creation_failure(v156, (uint64_t)&v157, 0);
    std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(v158[0]);
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    v149 = TIOSLogFacility();
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
    {
      KB::string_from_locale(*(KB **)v155, v150, &v166);
      v151 = SHIBYTE(v167) >= 0 ? &v166 : (long long *)v166;
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "load";
      __int16 v169 = 2080;
      v170 = v151;
      _os_log_debug_impl(&dword_1E3F0E000, v149, OS_LOG_TYPE_DEBUG, "%s Language model load for locale %s FAILED", buf, 0x16u);
      if (SHIBYTE(v167) < 0) {
        operator delete((void *)v166);
      }
    }
  }
  else
  {
    KB::LanguageModelStr::__start_session(v156, *(_DWORD *)(v156 + 64));
    v142 = *(language_modeling::v1::LanguageModel **)(v156 + 168);
    SharedVocabulary = (void *)LMVocabularyGetSharedVocabulary();
    language_modeling::v1::LanguageModel::addVocabulary(v142, SharedVocabulary);
    language_modeling::v1::LanguageModel::wireMemory(*(language_modeling::v1::LanguageModel **)(v156 + 168));
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    v144 = TIOSLogFacility();
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
    {
      KB::string_from_locale(*(KB **)v155, v145, &v166);
      v152 = SHIBYTE(v167) >= 0 ? &v166 : (long long *)v166;
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "load";
      __int16 v169 = 2080;
      v170 = v152;
      _os_log_debug_impl(&dword_1E3F0E000, v144, OS_LOG_TYPE_DEBUG, "%s Language model load for locale %s SUCCEEDED", buf, 0x16u);
      if (SHIBYTE(v167) < 0) {
        operator delete((void *)v166);
      }
    }
    v146 = (void *)language_modeling::v1::LanguageModel::copyLinguisticDataFileInfo(*(language_modeling::v1::LanguageModel **)(v156 + 168));
    v147 = v146;
    id v159 = v146;
    if (v146)
    {
      CFRetain(v146);
      id v159 = v147;
    }
    KB::createLanguageModelParameters(&v159, (uint64_t *)&v166);
    v148 = *(const void **)(v156 + 272);
    if (v148) {
      CFRelease(v148);
    }
    *(void *)(v156 + 272) = v166;
    if (v147)
    {
      CFRelease(v147);
      id v159 = 0;
      atomic_store(1u, (unsigned __int8 *)(v156 + 216));
      CFRelease(v147);
    }
    else
    {
      id v159 = 0;
      atomic_store(1u, (unsigned __int8 *)(v156 + 216));
    }
  }
  if (SHIBYTE(__p.__end_cap_.__value_) < 0) {
    operator delete(__p.__begin_);
  }
  if (v174 < 0) {
    operator delete((void *)v172.n128_u64[1]);
  }
  if (v175.n128_u64[1] && v175.n128_u8[6] == 1) {
    free((void *)v175.n128_u64[1]);
  }
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
  __p.__first_ = (std::__split_buffer<std::string>::pointer)&v162;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&__p);
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy((void *)v165);
}

_OWORD *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, void *a2, _OWORD **a3)
{
  uint64_t v5 = (void **)std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__find_equal<std::string>((uint64_t)a1, &v13, a2);
  char v6 = *v5;
  if (!*v5)
  {
    char v7 = (uint64_t **)v5;
    char v6 = operator new(0x58uLL);
    v11[1] = a1 + 1;
    int v8 = *a3;
    uint64_t v9 = *((void *)*a3 + 2);
    v6[2] = **a3;
    *((void *)v6 + 6) = v9;
    void *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    *((unsigned char *)v6 + 56) = 0;
    *((_DWORD *)v6 + 20) = 0;
    char v12 = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::__insert_node_at(a1, v13, v7, (uint64_t *)v6);
    v11[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::variant<BOOL,std::string>>,void *>>>>::reset[abi:nn180100]((uint64_t)v11);
  }
  return v6;
}

__n128 std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,std::string>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  uint64_t v5 = a1[1].n128_u32[2];
  if (v5 == -1) {
    goto LABEL_7;
  }
  if (v5 != 1)
  {
    ((void (*)(char *, __n128 *))off_1F3F71B20[v5])(&v8, a1);
LABEL_7:
    a1[1].n128_u32[2] = -1;
    __n128 result = *a3;
    a1[1].n128_u64[0] = a3[1].n128_u64[0];
    *a1 = result;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
    a1[1].n128_u32[2] = 1;
    return result;
  }
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  __n128 result = *a3;
  *(void *)(a2 + 16) = a3[1].n128_u64[0];
  *(__n128 *)a2 = result;
  a3[1].n128_u8[7] = 0;
  a3->n128_u8[0] = 0;
  return result;
}

double std::__variant_detail::__assignment<std::__variant_detail::__traits<BOOL,std::string>>::__assign_alt[abi:nn180100]<1ul,std::string,char const*&>(uint64_t a1, std::string *this, char **a3)
{
  if (*(_DWORD *)(a1 + 24) == 1)
  {
    CFLocaleRef v4 = *a3;
    std::string::__assign_external(this, v4);
  }
  else
  {
    std::string::basic_string[abi:nn180100]<0>(&v8, *a3);
    uint64_t v7 = *(unsigned int *)(a1 + 24);
    if (v7 != -1) {
      ((void (*)(char *, uint64_t))off_1F3F71B20[v7])(&v10, a1);
    }
    double result = *(double *)&v8;
    *(_OWORD *)a1 = v8;
    *(void *)(a1 + 16) = v9;
    *(_DWORD *)(a1 + 24) = 1;
  }
  return result;
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  std::__split_buffer<std::string>::pointer begin = this->__begin_;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  if (end != begin)
  {
    do
    {
      std::__split_buffer<std::string>::pointer v4 = end - 1;
      this->__end_ = end - 1;
      if (SHIBYTE(end[-1].__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v4->__r_.__value_.__l.__data_);
        std::__split_buffer<std::string>::pointer v4 = this->__end_;
      }
      std::__split_buffer<std::string>::pointer end = v4;
    }
    while (v4 != begin);
  }
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  double result = *(void **)(a1 + 16);
  if (result)
  {
    long long v3 = (void *)*result;
    if (*result == a1)
    {
      *double result = 0;
      while (1)
      {
        std::__split_buffer<std::string>::pointer v4 = (void *)result[1];
        if (!v4) {
          break;
        }
        do
        {
          double result = v4;
          std::__split_buffer<std::string>::pointer v4 = (void *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; long long v3 = (void *)result[1])
      {
        do
        {
          double result = v3;
          long long v3 = (void *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

void *std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::__find_leaf_high(uint64_t a1, void *a2, void *a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  std::__split_buffer<std::string>::pointer v4 = *(void **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v4;
        if ((std::operator<=>[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(a3, v4 + 4) & 0x80) == 0) {
          break;
        }
        std::__split_buffer<std::string>::pointer v4 = (void *)*v5;
        double result = v5;
        if (!*v5) {
          goto LABEL_8;
        }
      }
      std::__split_buffer<std::string>::pointer v4 = (void *)v5[1];
    }
    while (v4);
    double result = v5 + 1;
  }
  else
  {
    double result = (void *)(a1 + 8);
  }
LABEL_8:
  *a2 = v5;
  return result;
}

double _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSU_EEEDcSM_DpT0_(uint64_t *a1, std::string *this, std::string *__str)
{
  uint64_t v3 = *a1;
  int v4 = *(_DWORD *)(*a1 + 24);
  if (v4 == 1)
  {
    std::string::operator=(this, __str);
  }
  else
  {
    if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::__init_copy_ctor_external(&v6, __str->__r_.__value_.__l.__data_, __str->__r_.__value_.__l.__size_);
      int v4 = *(_DWORD *)(v3 + 24);
    }
    else
    {
      std::string v6 = *__str;
    }
    if (v4 != -1) {
      ((void (*)(char *, uint64_t))off_1F3F71B20[v4])(&v7, v3);
    }
    double result = *(double *)&v6.__r_.__value_.__l.__data_;
    *(std::string *)uint64_t v3 = v6;
    *(_DWORD *)(v3 + 24) = 1;
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8nn180100IOZNS0_12__assignmentINS0_8__traitsIJbNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEEEEE16__generic_assignB8nn180100IRKNS0_17__copy_assignmentISE_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSI_1EJbSD_EEERKSU_EEEDcSM_DpT0_(uint64_t result, unsigned char *a2, unsigned char *a3)
{
  uint64_t v4 = *(void *)result;
  uint64_t v5 = *(unsigned int *)(*(void *)result + 24);
  if (v5 != -1)
  {
    if (!v5)
    {
      *a2 = *a3;
      return result;
    }
    double result = ((uint64_t (*)(char *, uint64_t))off_1F3F71B20[v5])(&v6, v4);
  }
  *(unsigned char *)uint64_t v4 = *a3;
  *(_DWORD *)(v4 + 24) = 0;
  return result;
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s)
{
  std::string::size_type v4 = strlen(__s);

  return std::string::__assign_external(this, __s, v4);
}

std::string *__cdecl std::string::__assign_external(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  if ((v6 & 0x80000000) != 0)
  {
    unint64_t v10 = this->__r_.__value_.__r.__words[2];
    unint64_t v9 = (v10 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    if (v9 < __n)
    {
      std::string::size_type size = this->__r_.__value_.__l.__size_;
      goto LABEL_6;
    }
    unint64_t v6 = HIBYTE(v10);
    char v7 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  else
  {
    char v7 = this;
    if (__n > 0x16)
    {
      std::string::size_type size = HIBYTE(this->__r_.__value_.__r.__words[2]);
      unint64_t v9 = 22;
LABEL_6:
      std::string::__grow_by_and_replace(this, v9, __n - v9, size, 0, size, __n, __s);
      return this;
    }
  }
  if (__n)
  {
    memmove(v7, __s, __n);
    LOBYTE(v6) = *((unsigned char *)&this->__r_.__value_.__s + 23);
  }
  if ((v6 & 0x80) != 0) {
    this->__r_.__value_.__l.__size_ = __n;
  }
  else {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __n & 0x7F;
  }
  v7->__r_.__value_.__s.__data_[__n] = 0;
  return this;
}

CFIndex KB::LanguageModelStr::active_locale_identifiers_vector@<X0>(language_modeling::v1::LanguageModel **this@<X0>, uint64_t **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  CFIndex result = (*((uint64_t (**)(language_modeling::v1::LanguageModel **))*this + 2))(this);
  if (result)
  {
    CFArrayRef LanguageLocales = (const __CFArray *)language_modeling::v1::LanguageModel::getLanguageLocales(this[21]);
    unint64_t v6 = 0;
    for (CFIndex i = 0; ; ++i)
    {
      CFIndex result = CFArrayGetCount(LanguageLocales);
      if (result <= i) {
        break;
      }
      ValueAtIndex = CFArrayGetValueAtIndex(LanguageLocales, i);
      uint64_t v9 = MEMORY[0x1E4E79AD0](ValueAtIndex);
      if (v9)
      {
        uint64_t v10 = v9;
        unint64_t v11 = (unint64_t)a2[2];
        if ((unint64_t)v6 >= v11)
        {
          uint64_t v13 = *a2;
          uint64_t v14 = v6 - *a2;
          unint64_t v15 = v14 + 1;
          if ((unint64_t)(v14 + 1) >> 61) {
            abort();
          }
          uint64_t v16 = v11 - (void)v13;
          if (v16 >> 2 > v15) {
            unint64_t v15 = v16 >> 2;
          }
          if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v15;
          }
          if (v17) {
            unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
          }
          else {
            uint64_t v18 = 0;
          }
          BOOL v19 = (uint64_t *)(v17 + 8 * v14);
          *BOOL v19 = v10;
          char v12 = v19 + 1;
          if (v6 != v13)
          {
            do
            {
              uint64_t v20 = *--v6;
              *--BOOL v19 = v20;
            }
            while (v6 != v13);
            unint64_t v6 = *a2;
          }
          *a2 = v19;
          a2[1] = v12;
          a2[2] = (uint64_t *)(v17 + 8 * v18);
          if (v6) {
            operator delete(v6);
          }
        }
        else
        {
          *unint64_t v6 = v9;
          char v12 = v6 + 1;
        }
        a2[1] = v12;
        unint64_t v6 = v12;
      }
    }
  }
  return result;
}

__n128 KB::LanguageModelStr::lexicon_id_vector@<Q0>(KB::LanguageModelStr *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  if ((*(uint64_t (**)(KB::LanguageModelStr *))(*(void *)this + 16))(this))
  {
    CFDictionaryRef v23 = (__n128 *)a2;
    CFArrayRef LanguageLocales = (const __CFArray *)language_modeling::v1::LanguageModel::getLanguageLocales(*((language_modeling::v1::LanguageModel **)this
                                                                                                  + 21));
    unint64_t v5 = 0;
    CFIndex v6 = 0;
    __n128 v24 = 0u;
    while (CFArrayGetCount(LanguageLocales) > v6)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(LanguageLocales, v6);
      CFStringRef v8 = (const __CFString *)MEMORY[0x1E4E79AD0](ValueAtIndex);
      if (v8)
      {
        KB::std_string(v8, __p);
        if (v28 >= 0) {
          uint64_t v9 = (char *)__p;
        }
        else {
          uint64_t v9 = (char *)__p[0];
        }
        int v10 = TILexiconIDForLocaleIdentifier(v9);
        int v11 = v10;
        unint64_t v12 = v24.n128_u64[1];
        v13.n128_u64[0] = v24.n128_u64[0];
        if (v24.n128_u64[1] >= v5)
        {
          unint64_t v15 = (void *)v24.n128_u64[0];
          uint64_t v16 = (uint64_t)(v24.n128_u64[1] - v24.n128_u64[0]) >> 2;
          unint64_t v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 62) {
            abort();
          }
          if ((uint64_t)(v5 - v24.n128_u64[0]) >> 1 > v17) {
            unint64_t v17 = (uint64_t)(v5 - v24.n128_u64[0]) >> 1;
          }
          if (v5 - v24.n128_u64[0] >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v17;
          }
          if (v18) {
            unint64_t v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
          }
          else {
            uint64_t v19 = 0;
          }
          uint64_t v20 = (_DWORD *)(v18 + 4 * v16);
          *uint64_t v20 = v11;
          uint64_t v14 = (uint64_t)(v20 + 1);
          while (v12 != v24.n128_u64[0])
          {
            int v21 = *(_DWORD *)(v12 - 4);
            v12 -= 4;
            *--uint64_t v20 = v21;
          }
          unint64_t v5 = v18 + 4 * v19;
          v13.n128_u64[0] = (unint64_t)v20;
          if (v24.n128_u64[0])
          {
            std::string v25 = v20;
            operator delete(v15);
            v13.n128_u64[0] = (unint64_t)v25;
          }
        }
        else
        {
          *(_DWORD *)v24.n128_u64[1] = v10;
          uint64_t v14 = v24.n128_u64[1] + 4;
        }
        if (v28 < 0)
        {
          unint64_t v26 = v13.n128_u64[0];
          operator delete(__p[0]);
          v13.n128_u64[0] = v26;
        }
        v13.n128_u64[1] = v14;
      }
      else
      {
        __n128 v13 = v24;
      }
      __n128 v24 = v13;
      ++v6;
    }
    __n128 result = v24;
    *CFDictionaryRef v23 = v24;
    v23[1].n128_u64[0] = v5;
  }
  else
  {
    std::vector<unsigned int>::vector(a2, (const std::vector<unsigned int> *)((char *)this + 104));
  }
  return result;
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, const std::vector<unsigned int> *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::pointer begin = __x->__begin_;
  std::__split_buffer<std::string>::pointer end = __x->__end_;
  int64_t v5 = (char *)end - (char *)__x->__begin_;
  if (end != __x->__begin_)
  {
    std::vector<unsigned int>::__vallocate[abi:nn180100](this, v5 >> 2);
    std::vector<unsigned int>::pointer v6 = this->__end_;
    memmove(v6, begin, v5);
    this->__end_ = (std::vector<unsigned int>::pointer)((char *)v6 + v5);
  }
  return this;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(unint64_t a1)
{
  if (a1 >> 62) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(4 * a1);
}

char *std::vector<unsigned int>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

uint64_t KB::LanguageModelStr::lexicon_id(KB::LanguageModelStr *this)
{
  (*(void (**)(unsigned int **__return_ptr))(*(void *)this + 48))(&v4);
  if (v5 != v4)
  {
    uint64_t v1 = *v4;
LABEL_4:
    int64_t v5 = v4;
    operator delete(v4);
    return v1;
  }
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  if (v5) {
    goto LABEL_4;
  }
  return v2;
}

uint64_t KB::LanguageModel::supports_prediction(KB::LanguageModel *this)
{
  return 1;
}

uint64_t KB::LanguageModelStr::is_string_based_lm_model(KB::LanguageModelStr *this)
{
  return 1;
}

BOOL KB::LanguageModelStr::is_valid(KB::LanguageModelStr *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 216);
  if ((v1 & 1) == 0) {
    return 0;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)this + 217);
  return (v3 & 1) == 0;
}

void KB::LanguageModelStr::~LanguageModelStr(KB::LanguageModelStr *this)
{
  KB::LanguageModelStr::~LanguageModelStr(this);

  JUMPOUT(0x1E4E7BC20);
}

{
  unsigned __int8 v2;
  unsigned __int8 v3;
  const void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  const void *v10;
  void *v11;

  *(void *)this = &unk_1F3F71818;
  uint64_t v2 = atomic_load((unsigned __int8 *)this + 216);
  if (v2)
  {
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)this + 217);
    if ((v3 & 1) == 0) {
      language_modeling::v1::LanguageModel::unwireMemory(*((language_modeling::v1::LanguageModel **)this + 21));
    }
  }
  atomic_store(0, (unsigned __int8 *)this + 216);
  atomic_store(0, (unsigned __int8 *)this + 217);
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node,std::default_delete<KB::LRUCache<KB::String,std::vector<KB::LanguageModel::PredictionInfo>>::Node>>>>>::destroy(*((void **)this + 42));
  std::__tree<std::__value_type<std::string,std::variant<BOOL,std::string>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::variant<BOOL,std::string>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::variant<BOOL,std::string>>>>::destroy(*((void **)this + 36));
  uint64_t v4 = (const void *)*((void *)this + 34);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 34) = 0;
  int64_t v5 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  std::vector<unsigned int>::pointer v6 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  char v7 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  CFStringRef v8 = (std::__shared_weak_count *)*((void *)this + 20);
  if (v8) {
    std::__shared_weak_count::__release_weak(v8);
  }
  *(void *)this = &unk_1F3F777B0;
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  int v10 = (const void *)*((void *)this + 16);
  if (v10) {
    _Block_release(v10);
  }
  *((void *)this + 16) = 0;
  int v11 = (void *)*((void *)this + 13);
  if (v11)
  {
    *((void *)this + 14) = v11;
    operator delete(v11);
  }
  KB::LanguageModelConfig::~LanguageModelConfig((KB::LanguageModelStr *)((char *)this + 8));
}

void KB::LanguageModelConfig::~LanguageModelConfig(KB::LanguageModelConfig *this)
{
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 6) = 0;
  unsigned __int8 v3 = (const void *)*((void *)this + 5);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 5) = 0;
  uint64_t v4 = (const void *)*((void *)this + 4);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 4) = 0;
  int64_t v5 = (const void *)*((void *)this + 3);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 3) = 0;
  std::vector<unsigned int>::pointer v6 = (const void *)*((void *)this + 2);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 2) = 0;
  char v7 = (const void *)*((void *)this + 1);
  if (v7) {
    CFRelease(v7);
  }
  *((void *)this + 1) = 0;
  if (*(void *)this) {
    CFRelease(*(CFTypeRef *)this);
  }
  *(void *)this = 0;
}

KB::LanguageModelStr *KB::LanguageModelStr::LanguageModelStr(const __CFLocale **this, const __CFString **a2)
{
  uint64_t v4 = KB::LanguageModelImplBase::LanguageModelImplBase((KB::LanguageModelImplBase *)this, (const KB::LanguageModelConfig *)a2);
  *((void *)v4 + 19) = 0;
  *((void *)v4 + 20) = 0;
  *(void *)uint64_t v4 = &unk_1F3F71818;
  int64_t v5 = operator new(0x20uLL);
  v5[1] = 0;
  v5[2] = 0;
  *int64_t v5 = &unk_1F3F71AC0;
  this[21] = (const __CFLocale *)language_modeling::v1::LanguageModel::LanguageModel((language_modeling::v1::LanguageModel *)(v5 + 3));
  this[22] = (const __CFLocale *)v5;
  if (*((unsigned char *)this + 94) && *((unsigned char *)this + 93))
  {
    CFLocaleRef v6 = this[1];
    CFStringRef v7 = a2[4];
    CFStringRef v8 = (std::__shared_weak_count *)operator new(0x318uLL);
    v8->__shared_owners_ = 0;
    v8->__shared_weak_owners_ = 0;
    v8->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71AF8;
    TIInlineCompletionGeneratorImpl::TIInlineCompletionGeneratorImpl((TIInlineCompletionGeneratorImpl *)&v8[1], v6, 1, 3, 1, v7);
    this[23] = (const __CFLocale *)v9;
    this[24] = (const __CFLocale *)v8;
    shared_owners = (std::__shared_weak_count *)v8[1].__shared_owners_;
    if (!shared_owners)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v8[1].__vftable = v9;
      v8[1].__shared_owners_ = (uint64_t)v8;
      goto LABEL_8;
    }
    if (shared_owners->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v8->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v8[1].__vftable = (std::__shared_weak_count_vtbl *)&v8[1];
      v8[1].__shared_owners_ = (uint64_t)v8;
      std::__shared_weak_count::__release_weak(shared_owners);
LABEL_8:
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }
  else
  {
    this[23] = 0;
    this[24] = 0;
  }
  this[36] = 0;
  this[37] = 0;
  this[25] = 0;
  this[26] = 0;
  *((_WORD *)this + 108) = 0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  this[34] = 0;
  this[35] = (const __CFLocale *)(this + 36);
  this[42] = 0;
  this[43] = 0;
  this[38] = (const __CFLocale *)32;
  this[39] = 0;
  this[40] = 0;
  this[41] = (const __CFLocale *)(this + 42);
  return (KB::LanguageModelStr *)this;
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::__on_zero_shared(uint64_t a1)
{
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71AF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<TIInlineCompletionGeneratorImpl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71AF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::__on_zero_shared(uint64_t a1)
{
  return MEMORY[0x1F412A3B0](a1 + 24);
}

void std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71AC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<language_modeling::v1::LanguageModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F71AC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::LanguageModelStr::lock_language_model(KB::LanguageModelStr *this)
{
  uint64_t v2 = *((void *)this + 23);
  if (v2) {
    atomic_store(1u, (unsigned __int8 *)(v2 + 760));
  }
  std::mutex::lock(*((std::mutex **)this + 17));
  uint64_t v3 = *((void *)this + 23);
  if (v3) {
    atomic_store(0, (unsigned __int8 *)(v3 + 760));
  }
}

void KB::LanguageModelStr::unlock_language_model(std::mutex **this)
{
}

BOOL convertBlocklistSensitivityLevel(int a1)
{
  return a1 == 1;
}

KB::LanguageModelStr::PredictionEnumeratorStr *KB::LanguageModelStr::PredictionEnumeratorStr::PredictionEnumeratorStr(KB::LanguageModelStr::PredictionEnumeratorStr *this, const KB::LanguageModelStr *a2, const KB::LanguageModelContext *a3, unsigned int a4)
{
  *(void *)this = &unk_1F3F71A90;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)a2, (uint64_t)a3, a4, (uint64_t *)this + 1);
  return this;
}

{
  *(void *)this = &unk_1F3F71A90;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  KB::LanguageModelStr::get_predictions((uint64_t)a2, (uint64_t)a3, a4, (uint64_t *)this + 1);
  return this;
}

id TICreateNameReadingPairsFromContactCollection(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", 6 * objc_msgSend(v1, "count"));
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = v1;
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        CFStringRef v8 = objc_msgSend(v3, "objectForKeyedSubscript:", *(void *)(*((void *)&v10 + 1) + 8 * i), (void)v10);
        TICreateNameReadingPairFromContactAndAppendToArray(v8, 0, 0, v2);
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v5);
  }

  return v2;
}

void TICreateNameReadingPairFromContactAndAppendToArray(void *a1, int a2, void *a3, void *a4)
{
  id v26 = a1;
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = [v26 firstName];
  long long v10 = [v26 lastName];
  if (a2 == 2)
  {
    long long v11 = [v7 contactNameWubiCodePairsForFirstName:v9 lastName:v10];
    [v8 addObjectsFromArray:v11];
  }
  else
  {
    uint64_t v12 = [v26 nickname];
    long long v11 = (void *)v12;
    if (v9 || v10 || v12)
    {
      long long v13 = [v26 phoneticFirstName];
      uint64_t v14 = [v13 lowercaseString];

      uint64_t v15 = [v26 phoneticLastName];
      uint64_t v16 = [v15 lowercaseString];

      unint64_t v17 = TIGenerateReading(v14, v9, a2, v7);

      unint64_t v18 = TIGenerateReading(v16, v10, a2, v7);

      uint64_t v19 = TIGenerateReading(0, v11, a2, v7);
      if (v9
        && v10
        && (([v9 _containsIdeographicCharacters] & 1) != 0
         || ([v9 _containsHiraganaOrKatakana] & 1) != 0
         || [v9 _containsKorean])
        && (([v10 _containsIdeographicCharacters] & 1) != 0
         || ([v10 _containsHiraganaOrKatakana] & 1) != 0
         || [v10 _containsKorean]))
      {
        uint64_t v20 = [v10 stringByAppendingString:v9];
        if ([v17 length] && objc_msgSend(v18, "length"))
        {
          uint64_t v21 = [v18 stringByAppendingString:v17];
        }
        else
        {
          uint64_t v21 = [MEMORY[0x1E4F1CA98] null];
        }
        int v22 = (void *)v21;
        [v8 addObject:v20];
        [v8 addObject:v22];
      }
      if ([v10 length])
      {
        [v8 addObject:v10];
        if ([v18 length])
        {
          [v8 addObject:v18];
        }
        else
        {
          CFDictionaryRef v23 = [MEMORY[0x1E4F1CA98] null];
          [v8 addObject:v23];
        }
      }
      if ([v9 length])
      {
        [v8 addObject:v9];
        if ([v17 length])
        {
          [v8 addObject:v17];
        }
        else
        {
          __n128 v24 = [MEMORY[0x1E4F1CA98] null];
          [v8 addObject:v24];
        }
      }
      if ([v11 length])
      {
        [v8 addObject:v11];
        if ([v19 length])
        {
          [v8 addObject:v19];
        }
        else
        {
          std::string v25 = [MEMORY[0x1E4F1CA98] null];
          [v8 addObject:v25];
        }
      }
    }
  }
}

id TIGenerateReading(void *a1, void *a2, int a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  long long v10 = v9;
  if (a3 == 3)
  {
    if ([v7 length] && (objc_msgSend(v7, "_containsBopomofoOnly") & 1) != 0
      || ![v8 _containsIdeographicCharacters])
    {
      goto LABEL_17;
    }
    uint64_t v12 = [v8 _stringByTransliteratingToZhuyin];
LABEL_14:
    long long v11 = v7;
    goto LABEL_15;
  }
  if (a3 == 2)
  {
    if (!v9) {
      goto LABEL_17;
    }
    uint64_t v12 = [v9 readingForWubiWord:v8];
    goto LABEL_14;
  }
  if (a3 == 1 && ![v7 length])
  {
    if (![v8 _containsIdeographicCharacters])
    {
      long long v11 = [v8 stringByFoldingWithOptions:129 locale:0];
      uint64_t v14 = [MEMORY[0x1E4F28B88] pinyinInputCharacterSet];
      uint64_t v15 = [v14 invertedSet];

      if ([v11 rangeOfCharacterFromSet:v15] == 0x7FFFFFFFFFFFFFFFLL)
      {
        id v16 = v11;

        id v7 = v16;
      }

      goto LABEL_16;
    }
    long long v11 = [v8 _stringByTransliteratingToPinyin];

    if ([v11 length])
    {
      uint64_t v12 = [v11 stringByFoldingWithOptions:129 locale:0];
LABEL_15:
      id v7 = (id)v12;
LABEL_16:

      goto LABEL_17;
    }
    id v7 = v11;
  }
LABEL_17:

  return v7;
}

void __TIGetKeyboardForceSpaceCorrectionsValue_block_invoke()
{
  id v0 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  [v0 _configureKey:@"KeyboardForceSpaceCorrections" domain:@"com.apple.keyboard" defaultValue:MEMORY[0x1E4F1CC28]];
}

void __TIGetKeyboardDisableSpaceCorrectionsValue_block_invoke()
{
  id v0 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  [v0 _configureKey:@"KeyboardDisableSpaceCorrections" domain:@"com.apple.keyboard" defaultValue:MEMORY[0x1E4F1CC28]];
}

void KB::FilterLearnedTypo::filter_candidates(KB::FilterLearnedTypo *this, uint64_t **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  if ((unint64_t)(0x1CAC083126E978D5 * (a2[1] - *a2)) >= 2)
  {
    uint64_t v5 = v4[1];
    uint64_t v6 = *v4 - 1;
    id v7 = (unsigned __int16 *)(v5 + 240 * v6);
    if ((*((_DWORD *)v7 + 26) & 0x2040000) == 0x2000000 && *(_DWORD *)(v5 + 240 * v6 + 124) <= 1u)
    {
      unint64_t v8 = v4[125];
      if (*v4 < v8)
      {
        v44[0] = &unk_1F3F71D60;
        uint64_t v45 = v44;
        if (*((void *)v7 + 1)) {
          uint64_t v11 = *((void *)v7 + 1);
        }
        else {
          uint64_t v11 = (uint64_t)(v7 + 8);
        }
        uint64_t v34 = v11;
        int v12 = *v7;
        int v35 = 0;
        int v36 = v12;
        int v37 = 0;
        KB::String::iterator::initialize(&v34);
        uint64_t v30 = v11;
        int v31 = v12;
        int v32 = v12;
        int v33 = 0;
        KB::String::iterator::initialize(&v30);
        int v13 = v35;
        uint64_t v14 = (v8 - 1);
        if ((int)v14 >= 0)
        {
          while (v13 < v31)
          {
            uint64_t v15 = (unsigned __int16 *)(v4[126] + 240 * v14);
            if ((*((unsigned char *)v15 + 135) & 4) != 0)
            {
              KB::String::iterator::operator--((KB::String::iterator *)&v30);
              uint64_t v19 = *((void *)v15 + 1);
              if (!v19) {
                uint64_t v19 = (uint64_t)(v15 + 8);
              }
              uint64_t v41 = v19;
              LODWORD(v42) = 0;
              HIDWORD(v42) = *v15;
              int v43 = 0;
              KB::String::iterator::initialize(&v41);
              LODWORD(v41) = v43;
              LODWORD(v38) = v33;
              if (!v45)
              {
                char v28 = std::__throw_bad_function_call[abi:nn180100]();
                std::vector<KB::Candidate>::erase[abi:nn180100]((uint64_t)v28, v29);
                return;
              }
              if (((*(uint64_t (**)(void *, uint64_t *, uint64_t *))(*v45 + 48))(v45, &v41, &v38) & 1) == 0) {
                goto LABEL_50;
              }
            }
            else
            {
              if (*((void *)v15 + 1)) {
                uint64_t v16 = *((void *)v15 + 1);
              }
              else {
                uint64_t v16 = (uint64_t)(v15 + 8);
              }
              uint64_t v41 = v16;
              LODWORD(v42) = 0;
              int v17 = *v15;
              HIDWORD(v42) = v17;
              int v43 = 0;
              KB::String::iterator::initialize(&v41);
              uint64_t v38 = v16;
              LODWORD(v39) = v17;
              HIDWORD(v39) = v17;
              int v40 = 0;
              KB::String::iterator::initialize(&v38);
              int v18 = (int)v42;
              while (v18 < (int)v39)
              {
                KB::String::iterator::operator--((KB::String::iterator *)&v30);
                KB::String::iterator::operator--((KB::String::iterator *)&v38);
                if (v31 < v13 || v40 != v33) {
                  goto LABEL_50;
                }
              }
            }
            if (v14-- <= 0)
            {
              LODWORD(v14) = -1;
              break;
            }
          }
        }
        if (v13 >= v31 && *v4 - 2 == (int)v14)
        {
          if ((v14 & 0x80000000) != 0)
          {
LABEL_32:
            int v22 = (__CFString *)*((void *)a4 + 7);
            if (v22)
            {
              KB::Candidate::capitalized_string((KB::Candidate *)v4, (uint64_t)&v41);
              CFDictionaryRef v23 = (const char *)v42;
              if (!v42) {
                CFDictionaryRef v23 = (const char *)&v43;
              }
              if ((_WORD)v41) {
                __n128 v24 = v23;
              }
              else {
                __n128 v24 = "";
              }
              KB::Candidate::capitalized_string((KB::Candidate *)(v4 + 125), (uint64_t)&v38);
              id v26 = (const char *)v39;
              if (!v39) {
                id v26 = (const char *)&v40;
              }
              if ((_WORD)v38) {
                uint64_t v27 = v26;
              }
              else {
                uint64_t v27 = "";
              }
              KB::append_format(v22, (__CFString *)"Removing top candidate [%s] who appears to be a typo of a second candidate [%s]\n", v25, v24, v27);
              if (v39 && BYTE6(v38) == 1) {
                free(v39);
              }
              if (v42 && BYTE6(v41) == 1) {
                free(v42);
              }
            }
            std::vector<KB::Candidate>::erase[abi:nn180100]((uint64_t)a2, *a2);
          }
          else
          {
            while (*(void *)(v4[1] + 240 * v14 + 136) == *(void *)(v4[126]
                                                                                      + 240 * v14
                                                                                      + 136))
            {
              BOOL v21 = __OFSUB__(v14, 1);
              LODWORD(v14) = v14 - 1;
              if ((int)v14 < 0 != v21) {
                goto LABEL_32;
              }
            }
          }
        }
LABEL_50:
        std::__function::__value_func<BOOL ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](v44);
      }
    }
  }
}

void std::vector<KB::Candidate>::erase[abi:nn180100](uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = a2 + 125;
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  if (a2 + 125 != v5)
  {
    do
    {
      uint64_t v6 = v2;
      v2 += 125;
    }
    while (KB::Candidate::operator=(v6, v2) + 250 != v5);
    uint64_t v4 = *(uint64_t **)(a1 + 8);
  }
  while (v4 != v2)
    KB::Candidate::~Candidate((KB::Candidate *)(v4 - 125));
  *(void *)(a1 + 8) = v2;
}

void *std::__function::__value_func<BOOL ()(unsigned int,unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::operator()(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  if (*a2 != 32) {
    return 0;
  }
  unsigned int v3 = *a3 - 98;
  BOOL v4 = v3 > 0x16;
  unsigned int v5 = (0x501003u >> v3) & 1;
  if (v4) {
    return 0;
  }
  else {
    return v5;
  }
}

void std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F71D60;
}

void *std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F71D60;
  return result;
}

void std::__function::__func<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterLearnedTypo::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(unsigned int,unsigned int)>::~__func()
{
}

const char *KB::FilterLearnedTypo::filter_description(KB::FilterLearnedTypo *this)
{
  return "FilterLearnedTypo";
}

void KB::FilterLearnedTypo::~FilterLearnedTypo(KB::FilterLearnedTypo *this)
{
}

void KB::FilterTopDynamicWordsWithStaticVariant::filter_candidates(KB::FilterTopDynamicWordsWithStaticVariant *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v28[2] = *MEMORY[0x1E4F143B8];
  if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3)) >= 2)
  {
    uint64_t v8 = *((void *)a4 + 2);
    if (v8) {
      atomic_fetch_add((atomic_uint *volatile)v8, 1u);
    }
    uint64_t v9 = *(void *)(v8 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
    long long v10 = *(void **)a2;
    while (1)
    {
      unsigned int v11 = KB::Candidate::num_words_preserving_input(v10, a3, v9);
      uint64_t v12 = *v10;
      BOOL v13 = *v10 == v11 && *(void *)a3 == v11;
      if (v13 || v12 == v11) {
        break;
      }
      uint64_t v14 = v10[1] + 240 * v11 + 104;
      uint64_t v15 = 240 * v12 - 240 * v11;
      while (1)
      {
        BOOL v16 = (*(_DWORD *)v14 & 0x70000) != 0 || *(_WORD *)(v14 - 104) == 0;
        BOOL v17 = !v16 && (*(unsigned char *)(v14 + 31) & 4) == 0;
        if (v17 || (*(_DWORD *)v14 & 0x80000000) != 0) {
          break;
        }
        v14 += 240;
        v15 -= 240;
        if (!v15) {
          goto LABEL_34;
        }
      }
      int v18 = (KB::Candidate *)(v10 + 125);
      unint64_t v19 = 0x1CAC083126E978D5 * ((uint64_t)(*((void *)a2 + 1) - (void)(v10 + 125)) >> 3);
      if (v19 >= 0xA) {
        unint64_t v19 = 10;
      }
      KB::FilterTopDynamicWordsWithStaticVariant::should_remove_dynamic_variant_given_alternates((uint64_t)this, (KB::Candidate *)v10, (KB::Candidate *)(v10 + 125), (KB::Candidate *)((char *)v18 + 1000 * v19), (unint64_t *)a3, v9);
      if (!v20) {
        break;
      }
      BOOL v21 = (__CFString *)*((void *)a4 + 7);
      if (v21)
      {
        KB::Candidate::capitalized_string((KB::Candidate *)v10, (uint64_t)v25);
        CFDictionaryRef v23 = (const char *)v27;
        if (!v27) {
          CFDictionaryRef v23 = (const char *)v28;
        }
        __n128 v24 = "";
        if (v25[0]) {
          __n128 v24 = v23;
        }
        KB::append_format(v21, (__CFString *)"Candidate '%s' has dynamic case variants while there exists a suitable lower-ranked candidate with static case-variants\n", v22, v24);
        if (v27)
        {
          if (v26 == 1) {
            free(v27);
          }
        }
      }
      v10 += 125;
      if (v18 == *((KB::Candidate **)a2 + 1)) {
        goto LABEL_35;
      }
    }
LABEL_34:
    int v18 = (KB::Candidate *)v10;
LABEL_35:
    std::vector<KB::Candidate>::erase((uint64_t)a2, *(uint64_t **)a2, v18);
  }
}

void KB::FilterTopDynamicWordsWithStaticVariant::should_remove_dynamic_variant_given_alternates(uint64_t a1, KB::Candidate *a2, KB::Candidate *a3, KB::Candidate *a4, unint64_t *a5, uint64_t a6)
{
  if (a3 != a4)
  {
    uint64_t v9 = a3;
    uint64_t v12 = (_WORD *)((char *)a2 + 888);
    do
    {
      if (*(void *)a2 == *(void *)v9)
      {
        if (!*v12) {
          KB::Candidate::compute_string(a2);
        }
        if (!*((_WORD *)v9 + 444)) {
          KB::Candidate::compute_string(v9);
        }
        uint64_t v13 = *(void *)(a6 + 24);
        if (!v13)
        {
          uint64_t v14 = std::__throw_bad_function_call[abi:nn180100]();
          std::vector<KB::Candidate>::erase((uint64_t)v14, v15, v16);
          return;
        }
        if (*(unsigned int (**)(uint64_t, _WORD *, _WORD *))(*(void *)v13 + 48))(v13, v12, (_WORD *)v9 + 444)&& *(void *)a2 == KB::Candidate::num_words_matching_input(a2, v9, a6)&& *(void *)v9 == KB::Candidate::num_words_matching_input(v9, a2, a6)&& (KB::FilterTopDynamicWordsWithStaticVariant::prefer_candidate_over_dynamic_variant(a1, (uint64_t)v9, (uint64_t)a2, a5, a6))
        {
          return;
        }
      }
      uint64_t v9 = (KB::Candidate *)((char *)v9 + 1000);
    }
    while (v9 != a4);
  }
}

void std::vector<KB::Candidate>::erase(uint64_t a1, uint64_t *a2, KB::Candidate *a3)
{
  if (a2 != (uint64_t *)a3)
  {
    unsigned int v3 = a3;
    BOOL v4 = a2;
    uint64_t v6 = *(uint64_t **)(a1 + 8);
    if (a3 != (KB::Candidate *)v6)
    {
      uint64_t v7 = (a3 - (KB::Candidate *)a2) >> 3;
      do
      {
        KB::Candidate::operator=(v4, &v4[v7]);
        v4 += 125;
      }
      while (&v4[v7] != v6);
      unsigned int v3 = *(KB::Candidate **)(a1 + 8);
    }
    while (v3 != (KB::Candidate *)v4)
    {
      unsigned int v3 = (KB::Candidate *)((char *)v3 - 1000);
      KB::Candidate::~Candidate(v3);
    }
    *(void *)(a1 + 8) = v4;
  }
}

uint64_t KB::FilterTopDynamicWordsWithStaticVariant::prefer_candidate_over_dynamic_variant(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4, uint64_t a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*(void *)a3) {
    BOOL v5 = *(void *)a2 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5) {
    return 0;
  }
  uint64_t v11 = 0;
  int v12 = 0;
  int v13 = 0;
  unint64_t v14 = 1;
  do
  {
    KB::Word::Word((KB::Word *)v26, (size_t *)(*(void *)(a3 + 8) + v11));
    KB::Word::Word((KB::Word *)v21, (size_t *)(*(void *)(a2 + 8) + v11));
    unint64_t v15 = *a4;
    if (v14 - 1 >= *a4)
    {
      char v16 = 0;
    }
    else
    {
      char v16 = KB::Word::preserves_input((KB::String *)v26, (KB::String *)(a4[1] + v11), a5);
      unint64_t v15 = *a4;
    }
    if (v14 - 1 >= v15) {
      char v17 = 0;
    }
    else {
      char v17 = KB::Word::preserves_input((KB::String *)v21, (KB::String *)(a4[1] + v11), a5);
    }
    if (!(((v26[0] == 0) | (v30 >> 2) | ((v27 & 0x70000) != 0)) & (v27 >= 0) | v16 & 1) && (v22 & 0x40002) == 0x40000)
    {
      ++v12;
      v13 -= (uint64_t)(v28 - (unint64_t)v29) < *(unsigned int *)(a1 + 8);
    }
    if (!(((v21[0] == 0) | (v25 >> 2) | ((v22 & 0x70000) != 0)) & (v22 >= 0) | v17 & 1) && (v27 & 0x40002) == 0x40000)
    {
      --v12;
      if ((uint64_t)(v23 - (unint64_t)v24) < *(unsigned int *)(a1 + 8)) {
        ++v13;
      }
    }
    KB::Word::~Word((KB::Word *)v21);
    KB::Word::~Word((KB::Word *)v26);
    if (v14 >= *(void *)a3) {
      break;
    }
    v11 += 240;
  }
  while (v14++ < *(void *)a2);
  if (v13 < 0) {
    return 1;
  }
  if (v12 >= 1
    && ((float v19 = expf(*(float *)(a3 + 744)), v19 == 0.0) || (float)(v19 / expf(*(float *)(a2 + 744))) < *(float *)(a1 + 12)))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}

const char *KB::FilterTopDynamicWordsWithStaticVariant::filter_description(KB::FilterTopDynamicWordsWithStaticVariant *this)
{
  return "FilterTopDynamicWordsWithStaticVariant";
}

void KB::FilterTopDynamicWordsWithStaticVariant::~FilterTopDynamicWordsWithStaticVariant(KB::FilterTopDynamicWordsWithStaticVariant *this)
{
}

void KB::FilterInvalidTextReplacement::filter_candidates(KB::FilterInvalidTextReplacement *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  KB::Candidate::capitalized_string(a3, (uint64_t)v9);
  uint64_t v6 = *((void *)a4 + 7);
  v8[0] = &unk_1F3F71DA8;
  v8[1] = v9;
  v8[3] = v8;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v6, (uint64_t)"FilterInvalidTextReplacement", (uint64_t)v8);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v8);
  if (v10) {
    BOOL v7 = v9[6] == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v10);
  }
}

uint64_t std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, const KB::String *a3)
{
  v14[2] = *MEMORY[0x1E4F143B8];
  if (!*(void *)a2) {
    return 0;
  }
  BOOL v4 = *(KB::String **)a3;
  BOOL v5 = (const KB::String *)*((void *)a2 + 1);
  uint64_t v6 = *(KB **)(a1 + 8);
  uint64_t v7 = 240 * *(void *)a2;
  while ((*((unsigned char *)v5 + 106) & 1) == 0 || KB::should_match_input_with_shortcut(v6, v5, a3))
  {
    BOOL v5 = (const KB::String *)((char *)v5 + 240);
    v7 -= 240;
    if (!v7) {
      return 0;
    }
  }
  if (v4)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v11);
    uint64_t v9 = (const char *)v13;
    if (!v13) {
      uint64_t v9 = (const char *)v14;
    }
    if (v11[0]) {
      long long v10 = v9;
    }
    else {
      long long v10 = "";
    }
    KB::String::append_format(v4, "Candidate '%s' contains invalid text replacement", v10);
    if (v13)
    {
      if (v12 == 1) {
        free(v13);
      }
    }
  }
  return 1;
}

uint64_t std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F71DA8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3F71DA8;
  result[1] = v3;
  return result;
}

void std::__function::__func<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterInvalidTextReplacement::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterInvalidTextReplacement::filter_description(KB::FilterInvalidTextReplacement *this)
{
  return "FilterInvalidTextReplacement";
}

void KB::FilterInvalidTextReplacement::~FilterInvalidTextReplacement(KB::FilterInvalidTextReplacement *this)
{
}

void *KB::FilterWithoutSupplementalWords::filter_candidates(KB::FilterWithoutSupplementalWords *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v7[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a4 + 7);
  v7[0] = &unk_1F3F71DF0;
  uint64_t v7[3] = v7;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterWithoutSupplementalWords", (uint64_t)v7);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v7);
}

BOOL std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  v15[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a3;
  if (*(void *)a2)
  {
    uint64_t v4 = 240 * *(void *)a2 - 240;
    uint64_t v5 = (uint64_t *)(*((void *)a2 + 1) + 224);
    do
    {
      uint64_t v6 = *v5;
      v5 += 30;
      BOOL v7 = v6 != 0;
      if (v6) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = v4 == 0;
      }
      v4 -= 240;
    }
    while (!v8);
    if (!v3) {
      return !v7;
    }
  }
  else
  {
    BOOL v7 = 0;
    if (!v3) {
      return !v7;
    }
  }
  if (!v7)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    uint64_t v9 = (const char *)v14;
    if (!v14) {
      uint64_t v9 = (const char *)v15;
    }
    if (v12[0]) {
      long long v10 = v9;
    }
    else {
      long long v10 = "";
    }
    KB::String::append_format(v3, "Candidate '%s' does not contain supplemental lexicons", v10);
    if (v14 && v13 == 1) {
      free(v14);
    }
  }
  return !v7;
}

void std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F71DF0;
}

void *std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F71DF0;
  return result;
}

void std::__function::__func<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWithoutSupplementalWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterWithoutSupplementalWords::filter_description(KB::FilterWithoutSupplementalWords *this)
{
  return "FilterWithoutSupplementalWords";
}

void KB::FilterWithoutSupplementalWords::~FilterWithoutSupplementalWords(KB::FilterWithoutSupplementalWords *this)
{
}

void *KB::FilterPartOfHyphenatedWord::filter_candidates(KB::FilterPartOfHyphenatedWord *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v6[4] = *MEMORY[0x1E4F143B8];
  if (!*((unsigned char *)a3 + 3173))
  {
    uint64_t v4 = *((void *)a4 + 7);
    v6[0] = &unk_1F3F71E38;
    v6[3] = v6;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v4, (uint64_t)"FilterPartOfHyphenatedWord", (uint64_t)v6);
    return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v6);
  }
  return result;
}

uint64_t std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  v15[2] = *MEMORY[0x1E4F143B8];
  if (!*(void *)a2) {
    return 0;
  }
  uint64_t v3 = *a3;
  uint64_t v4 = 240 * *(void *)a2 - 240;
  uint64_t v5 = (unsigned int *)(*((void *)a2 + 1) + 104);
  do
  {
    unsigned int v7 = *v5;
    v5 += 60;
    unsigned int v6 = v7;
    if ((v7 & 0x10) != 0) {
      break;
    }
    uint64_t v8 = v4;
    v4 -= 240;
  }
  while (v8);
  uint64_t result = (v6 >> 4) & 1;
  if (v3 && (v6 & 0x10) != 0)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    long long v10 = (const char *)v14;
    if (!v14) {
      long long v10 = (const char *)v15;
    }
    if (v12[0]) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = "";
    }
    KB::String::append_format(v3, "Candidate '%s' is an incomplete hyphenated word", v11);
    if (v14)
    {
      if (v13 == 1) {
        free(v14);
      }
    }
    return 1;
  }
  return result;
}

void std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F71E38;
}

void *std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1F3F71E38;
  return result;
}

void std::__function::__func<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterPartOfHyphenatedWord::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterPartOfHyphenatedWord::filter_description(KB::FilterPartOfHyphenatedWord *this)
{
  return "FilterPartOfHyphenatedWord";
}

void KB::FilterPartOfHyphenatedWord::~FilterPartOfHyphenatedWord(KB::FilterPartOfHyphenatedWord *this)
{
}

void KB::FilterCommonLearnedTypos::filter_candidates(KB::FilterCommonLearnedTypos *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v8)
  {
    uint64_t v9 = std::__shared_weak_count::lock(v8);
    if (v9 && *((void *)this + 7)) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *((void *)a4 + 3);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)a4 + 4);
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v10)
  {
    uint64_t v12 = *((void *)a4 + 3);
    char v13 = (std::__shared_weak_count *)*((void *)a4 + 4);
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
    if (v13) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v13);
    }
    if (!v11) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  int v14 = 0;
  if (v11) {
LABEL_14:
  }
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
LABEL_15:
  if (v14)
  {
    uint64_t v15 = *((void *)a4 + 3);
    char v16 = (std::__shared_weak_count *)*((void *)a4 + 4);
    if (v16)
    {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v16->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    char v17 = (std::__shared_weak_count *)*((void *)this + 8);
    *((void *)this + 7) = v15;
    *((void *)this + 8) = v16;
    if (v17) {
      std::__shared_weak_count::__release_weak(v17);
    }
    if (v16) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v16);
    }
    KB::FilterCommonLearnedTypos::update_common_typos_dict(this);
  }
LABEL_23:
  long long v29 = 0u;
  long long v30 = 0u;
  int v31 = 1065353216;
  if (*(void *)a3)
  {
    int v18 = (KB::Word *)*((void *)a3 + 1);
    float v19 = (KB::Word *)((char *)v18 + 240 * *(void *)a3);
    int v20 = (void *)((char *)this + 16);
    do
    {
      KB::Word::capitalized_string(v18, (uint64_t)&v33);
      std::string::size_type size = (char *)v33.__r_.__value_.__l.__size_;
      if (!v33.__r_.__value_.__l.__size_) {
        std::string::size_type size = &v33.__r_.__value_.__s.__data_[16];
      }
      if (LOWORD(v33.__r_.__value_.__l.__data_)) {
        int v22 = size;
      }
      else {
        int v22 = "";
      }
      std::string::basic_string[abi:nn180100]<0>(__p, v22);
      if (v33.__r_.__value_.__l.__size_) {
        BOOL v23 = v33.__r_.__value_.__s.__data_[6] == 1;
      }
      else {
        BOOL v23 = 0;
      }
      if (v23) {
        free((void *)v33.__r_.__value_.__l.__size_);
      }
      unsigned int v24 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(v20, (uint64_t)__p);
      if (v24)
      {
        for (uint64_t i = (uint64_t *)*((void *)v24 + 7); i; uint64_t i = (uint64_t *)*i)
        {
          if (*((char *)i + 39) < 0) {
            std::string::__init_copy_ctor_external(&v33, (const std::string::value_type *)i[2], i[3]);
          }
          else {
            std::string v33 = *(std::string *)(i + 2);
          }
          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v29, (uint64_t)&v33, (uint64_t)&v33);
          if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v33.__r_.__value_.__l.__data_);
          }
        }
      }
      if (v28 < 0) {
        operator delete(__p[0]);
      }
      int v18 = (KB::Word *)((char *)v18 + 240);
    }
    while (v18 != v19);
    if (*((void *)&v30 + 1))
    {
      uint64_t v26 = *((void *)a4 + 7);
      v32[0] = &unk_1F3F71E80;
      v32[1] = &v29;
      v32[2] = a3;
      v32[3] = v32;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v26, (uint64_t)"FilterCommonLearnedTypos", (uint64_t)v32);
      std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v32);
    }
  }
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v29);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
}

void KB::FilterCommonLearnedTypos::update_common_typos_dict(KB::FilterCommonLearnedTypos *this)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 5))
  {
    std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(*((void **)this + 4));
    *((void *)this + 4) = 0;
    uint64_t v3 = *((void *)this + 3);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*((void *)this + 2) + 8 * i) = 0;
    }
    *((void *)this + 5) = 0;
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v5)
  {
    unsigned int v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      unsigned int v7 = v6;
      uint64_t v8 = *((void *)this + 7);
      if (v8
        && ((*(void (**)(void **__return_ptr))(*(void *)v8 + 232))(__p), (uint64_t v9 = __p[0]) != 0))
      {
        uint64_t v10 = v9;
        uint64_t v11 = [v9 objectForKeyedSubscript:*MEMORY[0x1E4F72400]];
        uint64_t v12 = v11;
        if (v11)
        {
          if ([v11 count])
          {
            char v13 = [v12 objectAtIndexedSubscript:0];
            if (v13)
            {
              int v14 = v13;
              uint64_t v15 = [v13 objectForKeyedSubscript:@"URL"];
              if (v15)
              {
                unint64_t v66 = v14;
                std::string::size_type v67 = v12;
                uint64_t v68 = v10;
                unint64_t v69 = v7;
                std::string::size_type v65 = v15;
                char v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithContentsOfURL:v15];
                long long v86 = 0u;
                long long v87 = 0u;
                long long v88 = 0u;
                long long v89 = 0u;
                uint64_t v73 = [v16 countByEnumeratingWithState:&v86 objects:v91 count:16];
                if (v73)
                {
                  long long v71 = v16;
                  uint64_t v72 = *(void *)v87;
                  int v70 = (void *)((char *)this + 32);
                  do
                  {
                    uint64_t v17 = 0;
                    do
                    {
                      if (*(void *)v87 != v72) {
                        objc_enumerationMutation(v16);
                      }
                      int v18 = *(void **)(*((void *)&v86 + 1) + 8 * v17);
                      *(_OWORD *)__n = 0u;
                      long long v84 = 0u;
                      int v85 = 1065353216;
                      float v19 = [v16 objectForKeyedSubscript:v18];
                      objc_opt_class();
                      char isKindOfClass = objc_opt_isKindOfClass();

                      uint64_t v74 = v17;
                      if (isKindOfClass)
                      {
                        id v21 = [v16 objectForKeyedSubscript:v18];
                        long long v79 = 0u;
                        long long v80 = 0u;
                        long long v81 = 0u;
                        long long v82 = 0u;
                        uint64_t v22 = [v21 countByEnumeratingWithState:&v79 objects:v90 count:16];
                        if (v22)
                        {
                          uint64_t v23 = v22;
                          uint64_t v24 = *(void *)v80;
                          do
                          {
                            for (uint64_t j = 0; j != v23; ++j)
                            {
                              if (*(void *)v80 != v24) {
                                objc_enumerationMutation(v21);
                              }
                              std::string::basic_string[abi:nn180100]<0>(__p, (char *)[*(id *)(*((void *)&v79 + 1) + 8 * j) UTF8String]);
                              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__n, (uint64_t)__p, (uint64_t)__p);
                              if (SHIBYTE(v76) < 0) {
                                operator delete(__p[0]);
                              }
                            }
                            uint64_t v23 = [v21 countByEnumeratingWithState:&v79 objects:v90 count:16];
                          }
                          while (v23);
                        }
                      }
                      else
                      {
                        id v21 = [v16 objectForKeyedSubscript:v18];
                        std::string::basic_string[abi:nn180100]<0>(__p, (char *)[v21 UTF8String]);
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__n, (uint64_t)__p, (uint64_t)__p);
                        if (SHIBYTE(v76) < 0) {
                          operator delete(__p[0]);
                        }
                      }

                      std::string::basic_string[abi:nn180100]<0>(__p, (char *)[v18 UTF8String]);
                      memset(v77, 0, sizeof(v77));
                      int v78 = v85;
                      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v77, __n[1]);
                      for (k = (void *)v84; k; k = (void *)*k)
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v77, (uint64_t)(k + 2), (uint64_t)(k + 2));
                      int v27 = SHIBYTE(v76);
                      long long v29 = (const std::string::value_type *)__p[0];
                      char v28 = __p[1];
                      if (v76 >= 0) {
                        long long v30 = (uint64_t *)__p;
                      }
                      else {
                        long long v30 = (uint64_t *)__p[0];
                      }
                      if (v76 >= 0) {
                        unint64_t v31 = HIBYTE(v76);
                      }
                      else {
                        unint64_t v31 = (unint64_t)__p[1];
                      }
                      unint64_t v32 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v30, v31);
                      unint64_t v33 = v32;
                      unint64_t v34 = *((void *)this + 3);
                      if (v34)
                      {
                        uint8x8_t v35 = (uint8x8_t)vcnt_s8((int8x8_t)v34);
                        v35.i16[0] = vaddlv_u8(v35);
                        unint64_t v36 = v35.u32[0];
                        if (v35.u32[0] > 1uLL)
                        {
                          unint64_t v1 = v32;
                          if (v32 >= v34) {
                            unint64_t v1 = v32 % v34;
                          }
                        }
                        else
                        {
                          unint64_t v1 = (v34 - 1) & v32;
                        }
                        int v37 = *(unsigned __int8 ***)(*((void *)this + 2) + 8 * v1);
                        if (v37)
                        {
                          for (m = *v37; m; m = *(unsigned __int8 **)m)
                          {
                            unint64_t v39 = *((void *)m + 1);
                            if (v39 == v33)
                            {
                              if (std::equal_to<std::string>::operator()[abi:nn180100](m + 16, (unsigned __int8 *)__p)) {
                                goto LABEL_115;
                              }
                            }
                            else
                            {
                              if (v36 > 1)
                              {
                                if (v39 >= v34) {
                                  v39 %= v34;
                                }
                              }
                              else
                              {
                                v39 &= v34 - 1;
                              }
                              if (v39 != v1) {
                                break;
                              }
                            }
                          }
                        }
                      }
                      int v40 = operator new(0x50uLL);
                      void *v40 = 0;
                      v40[1] = v33;
                      uint64_t v41 = (std::string *)(v40 + 2);
                      if (v27 < 0)
                      {
                        std::string::__init_copy_ctor_external(v41, v29, (std::string::size_type)v28);
                      }
                      else
                      {
                        *(_OWORD *)&v41->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
                        v40[4] = v76;
                      }
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__hash_table((uint64_t)(v40 + 5), v77);
                      float v42 = (float)(unint64_t)(*((void *)this + 5) + 1);
                      float v43 = *((float *)this + 12);
                      if (!v34 || (float)(v43 * (float)v34) < v42)
                      {
                        BOOL v44 = (v34 & (v34 - 1)) != 0;
                        if (v34 < 3) {
                          BOOL v44 = 1;
                        }
                        unint64_t v45 = v44 | (2 * v34);
                        unint64_t v46 = vcvtps_u32_f32(v42 / v43);
                        if (v45 <= v46) {
                          int8x8_t prime = (int8x8_t)v46;
                        }
                        else {
                          int8x8_t prime = (int8x8_t)v45;
                        }
                        if (*(void *)&prime == 1)
                        {
                          int8x8_t prime = (int8x8_t)2;
                        }
                        else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
                        {
                          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
                        }
                        unint64_t v34 = *((void *)this + 3);
                        if (*(void *)&prime <= v34)
                        {
                          if (*(void *)&prime < v34)
                          {
                            unint64_t v54 = vcvtps_u32_f32((float)*((unint64_t *)this + 5) / *((float *)this + 12));
                            if (v34 < 3
                              || (uint8x8_t v55 = (uint8x8_t)vcnt_s8((int8x8_t)v34), v55.i16[0] = vaddlv_u8(v55),
                                                                           v55.u32[0] > 1uLL))
                            {
                              unint64_t v54 = std::__next_prime(v54);
                            }
                            else
                            {
                              uint64_t v56 = 1 << -(char)__clz(v54 - 1);
                              if (v54 >= 2) {
                                unint64_t v54 = v56;
                              }
                            }
                            if (*(void *)&prime <= v54) {
                              int8x8_t prime = (int8x8_t)v54;
                            }
                            if (*(void *)&prime >= v34)
                            {
                              unint64_t v34 = *((void *)this + 3);
                            }
                            else
                            {
                              if (prime) {
                                goto LABEL_71;
                              }
                              int v63 = (void *)*((void *)this + 2);
                              *((void *)this + 2) = 0;
                              if (v63) {
                                operator delete(v63);
                              }
                              unint64_t v34 = 0;
                              *((void *)this + 3) = 0;
                            }
                          }
                        }
                        else
                        {
LABEL_71:
                          if (*(void *)&prime >> 61) {
                            std::__throw_bad_array_new_length[abi:nn180100]();
                          }
                          unint64_t v48 = operator new(8 * *(void *)&prime);
                          __n128 v49 = (void *)*((void *)this + 2);
                          *((void *)this + 2) = v48;
                          if (v49) {
                            operator delete(v49);
                          }
                          uint64_t v50 = 0;
                          *((int8x8_t *)this + 3) = prime;
                          do
                            *(void *)(*((void *)this + 2) + 8 * v50++) = 0;
                          while (*(void *)&prime != v50);
                          uint64_t v51 = (void *)*v70;
                          if (*v70)
                          {
                            unint64_t v52 = v51[1];
                            uint8x8_t v53 = (uint8x8_t)vcnt_s8(prime);
                            v53.i16[0] = vaddlv_u8(v53);
                            if (v53.u32[0] > 1uLL)
                            {
                              if (v52 >= *(void *)&prime) {
                                v52 %= *(void *)&prime;
                              }
                            }
                            else
                            {
                              v52 &= *(void *)&prime - 1;
                            }
                            *(void *)(*((void *)this + 2) + 8 * v52) = v70;
                            uint64_t v57 = (void *)*v51;
                            if (*v51)
                            {
                              do
                              {
                                unint64_t v58 = v57[1];
                                if (v53.u32[0] > 1uLL)
                                {
                                  if (v58 >= *(void *)&prime) {
                                    v58 %= *(void *)&prime;
                                  }
                                }
                                else
                                {
                                  v58 &= *(void *)&prime - 1;
                                }
                                if (v58 != v52)
                                {
                                  uint64_t v59 = *((void *)this + 2);
                                  if (!*(void *)(v59 + 8 * v58))
                                  {
                                    *(void *)(v59 + 8 * v58) = v51;
                                    goto LABEL_96;
                                  }
                                  *uint64_t v51 = *v57;
                                  *uint64_t v57 = **(void **)(*((void *)this + 2) + 8 * v58);
                                  **(void **)(*((void *)this + 2) + 8 * v58) = v57;
                                  uint64_t v57 = v51;
                                }
                                unint64_t v58 = v52;
LABEL_96:
                                uint64_t v51 = v57;
                                uint64_t v57 = (void *)*v57;
                                unint64_t v52 = v58;
                              }
                              while (v57);
                            }
                          }
                          unint64_t v34 = (unint64_t)prime;
                        }
                        if ((v34 & (v34 - 1)) != 0)
                        {
                          if (v33 >= v34) {
                            unint64_t v1 = v33 % v34;
                          }
                          else {
                            unint64_t v1 = v33;
                          }
                        }
                        else
                        {
                          unint64_t v1 = (v34 - 1) & v33;
                        }
                      }
                      uint64_t v60 = *((void *)this + 2);
                      double v61 = *(void **)(v60 + 8 * v1);
                      if (v61)
                      {
                        void *v40 = *v61;
LABEL_113:
                        *double v61 = v40;
                        goto LABEL_114;
                      }
                      void *v40 = *v70;
                      *int v70 = v40;
                      *(void *)(v60 + 8 * v1) = v70;
                      if (*v40)
                      {
                        unint64_t v62 = *(void *)(*v40 + 8);
                        if ((v34 & (v34 - 1)) != 0)
                        {
                          if (v62 >= v34) {
                            v62 %= v34;
                          }
                        }
                        else
                        {
                          v62 &= v34 - 1;
                        }
                        double v61 = (void *)(*((void *)this + 2) + 8 * v62);
                        goto LABEL_113;
                      }
LABEL_114:
                      ++*((void *)this + 5);
LABEL_115:
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v77);
                      if (SHIBYTE(v76) < 0) {
                        operator delete(__p[0]);
                      }
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)__n);
                      uint64_t v17 = v74 + 1;
                      char v16 = v71;
                    }
                    while (v74 + 1 != v73);
                    uint64_t v64 = [v71 countByEnumeratingWithState:&v86 objects:v91 count:16];
                    uint64_t v73 = v64;
                  }
                  while (v64);
                }

                uint64_t v10 = v68;
                unsigned int v7 = v69;
                int v14 = v66;
                uint64_t v12 = v67;
                uint64_t v15 = v65;
              }
            }
          }
        }

        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
        CFRelease(v10);
      }
      else
      {
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
      }
    }
  }
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(void *a1, uint64_t a2)
{
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (uint64_t *)a2;
  }
  else {
    uint64_t v5 = *(uint64_t **)a2;
  }
  if (v4 >= 0) {
    unint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v6 = *(void *)(a2 + 8);
  }
  unint64_t v7 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v5, v6);
  int8x8_t v8 = (int8x8_t)a1[1];
  if (!*(void *)&v8) {
    return 0;
  }
  unint64_t v9 = v7;
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v8);
  v10.i16[0] = vaddlv_u8(v10);
  unint64_t v11 = v10.u32[0];
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v12 = v7;
    if (v7 >= *(void *)&v8) {
      unint64_t v12 = v7 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v12 = (*(void *)&v8 - 1) & v7;
  }
  char v13 = *(unsigned __int8 ***)(*a1 + 8 * v12);
  if (!v13) {
    return 0;
  }
  for (uint64_t i = *v13; i; uint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v15 = *((void *)i + 1);
    if (v15 == v9)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
        return i;
      }
    }
    else
    {
      if (v11 > 1)
      {
        if (v15 >= *(void *)&v8) {
          v15 %= *(void *)&v8;
        }
      }
      else
      {
        v15 &= *(void *)&v8 - 1;
      }
      if (v15 != v12) {
        return 0;
      }
    }
  }
  return i;
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int8x8_t v8 = (uint64_t *)a2;
  }
  else {
    int8x8_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    unint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  int v18 = operator new(0x28uLL);
  v18[1] = v11;
  float v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    v18[4] = *(void *)(a3 + 16);
  }
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v26 = *(void *)a1;
  int v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *int v18 = *v27;
LABEL_47:
    *int v27 = v18;
    goto LABEL_48;
  }
  uint64_t v28 = *(void *)(a1 + 16);
  *int v18 = v28;
  *(void *)(a1 + 16) = v18;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (v28)
  {
    unint64_t v29 = *(void *)(v28 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v29 >= v12) {
        v29 %= v12;
      }
    }
    else
    {
      v29 &= v12 - 1;
    }
    int v27 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_47;
  }
LABEL_48:
  ++*(void *)(a1 + 24);
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unint64_t v3 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  uint64_t v23[2] = *MEMORY[0x1E4F143B8];
  if (!*(void *)a2) {
    return 0;
  }
  uint64_t v5 = *a3;
  unint64_t v6 = (KB::Word *)*((void *)a2 + 1);
  int v7 = *(void **)(a1 + 8);
  uint64_t v8 = 240 * *(void *)a2;
  while (1)
  {
    KB::Word::capitalized_string(v6, (uint64_t)v20);
    unint64_t v9 = (char *)v22;
    if (!v22) {
      unint64_t v9 = (char *)v23;
    }
    if (v20[0]) {
      unint64_t v10 = v9;
    }
    else {
      unint64_t v10 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, v10);
    unint64_t v11 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(v7, (uint64_t)&__p);
    if ((v19[7] & 0x80000000) != 0) {
      operator delete(__p);
    }
    if (v22 && v21 == 1) {
      free(v22);
    }
    if (v11) {
      break;
    }
    unint64_t v6 = (KB::Word *)((char *)v6 + 240);
    v8 -= 240;
    if (!v8) {
      return 0;
    }
  }
  if (v5)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v20);
    uint8x8_t v13 = (const char *)v22;
    if (!v22) {
      uint8x8_t v13 = (const char *)v23;
    }
    if (v20[0]) {
      unint64_t v14 = v13;
    }
    else {
      unint64_t v14 = "";
    }
    KB::Candidate::capitalized_string(*(KB::Candidate **)(a1 + 16), (uint64_t)&__p);
    unint64_t v15 = (const char *)v18;
    if (!v18) {
      unint64_t v15 = v19;
    }
    if ((_WORD)__p) {
      char v16 = v15;
    }
    else {
      char v16 = "";
    }
    KB::String::append_format(v5, "Candidate '%s' & user input '%s' is/has a known pair of autocorrection candidates to avoid", v14, v16);
    if (v18 && BYTE6(__p) == 1) {
      free(v18);
    }
    if (v22)
    {
      if (v21 == 1) {
        free(v22);
      }
    }
  }
  return 1;
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](uint64_t *a1, unint64_t a2)
{
  if (a2 > 0x20)
  {
    if (a2 <= 0x40)
    {
      uint64_t v5 = *(uint64_t *)((char *)a1 + a2 - 16);
      uint64_t v6 = *a1 - 0x3C5A37A36834CED9 * (v5 + a2);
      uint64_t v8 = a1[2];
      uint64_t v7 = a1[3];
      uint64_t v9 = __ROR8__(v6 + v7, 52);
      uint64_t v10 = v6 + a1[1];
      uint64_t v11 = __ROR8__(v10, 7);
      uint64_t v12 = v10 + v8;
      uint64_t v13 = *(uint64_t *)((char *)a1 + a2 - 32) + v8;
      uint64_t v14 = *(uint64_t *)((char *)a1 + a2 - 8) + v7;
      uint64_t v15 = __ROR8__(v14 + v13, 52);
      uint64_t v16 = v11 + __ROR8__(*a1 - 0x3C5A37A36834CED9 * (v5 + a2), 37) + v9;
      uint64_t v17 = __ROR8__(v13, 37);
      uint64_t v18 = *(uint64_t *)((char *)a1 + a2 - 24) + v13;
      uint64_t v19 = __ROR8__(v18, 7);
      uint64_t v20 = v16 + __ROR8__(v12, 31);
      uint64_t v21 = v18 + v5;
      uint64_t v22 = v21 + v14;
      unint64_t v23 = 0x9AE16A3B2F90404FLL;
      unint64_t v24 = 0xC3A5C85C97CB3127 * (v22 + v20) - 0x651E95C4D06FBFB1 * (v12 + v7 + v17 + v19 + v15 + __ROR8__(v21, 31));
      unint64_t v25 = v20 - 0x3C5A37A36834CED9 * (v24 ^ (v24 >> 47));
      return (v25 ^ (v25 >> 47)) * v23;
    }
    unint64_t v4 = 0x9DDFEA08EB382D69;
    uint64_t v32 = *(uint64_t *)((char *)a1 + a2 - 48);
    uint64_t v33 = *(uint64_t *)((char *)a1 + a2 - 40);
    uint64_t v34 = *(uint64_t *)((char *)a1 + a2 - 24);
    uint64_t v36 = *(uint64_t *)((char *)a1 + a2 - 64);
    uint64_t v35 = *(uint64_t *)((char *)a1 + a2 - 56);
    uint64_t v37 = *(uint64_t *)((char *)a1 + a2 - 16);
    uint64_t v38 = *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v39 = v35 + v37;
    unint64_t v40 = 0x9DDFEA08EB382D69
        * (v34 ^ ((0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))) >> 47) ^ (0x9DDFEA08EB382D69 * (v34 ^ (v32 + a2))));
    unint64_t v41 = 0x9DDFEA08EB382D69 * (v40 ^ (v40 >> 47));
    unint64_t v42 = v36 + a2 + v35 + v32;
    uint64_t v43 = v42 + v33;
    unint64_t v44 = __ROR8__(v42, 44) + v36 + a2 + __ROR8__(v33 + v36 + a2 - 0x622015F714C7D297 * (v40 ^ (v40 >> 47)), 21);
    uint64_t v45 = v35 + v37 + *(uint64_t *)((char *)a1 + a2 - 32) - 0x4B6D499041670D8DLL;
    uint64_t v46 = v45 + v34 + v37;
    uint64_t v47 = __ROR8__(v46, 44);
    uint64_t v48 = v46 + v38;
    uint64_t v49 = v47 + v45 + __ROR8__(v45 + v33 + v38, 21);
    uint64_t v51 = *a1;
    uint64_t v50 = a1 + 4;
    unint64_t v52 = v51 - 0x4B6D499041670D8DLL * v33;
    uint64_t v53 = -(uint64_t)((a2 - 1) & 0xFFFFFFFFFFFFFFC0);
    do
    {
      uint64_t v54 = *(v50 - 3);
      uint64_t v55 = v52 + v43 + v39 + v54;
      uint64_t v56 = v50[2];
      uint64_t v57 = v50[3];
      uint64_t v58 = v50[1];
      unint64_t v39 = v58 + v43 - 0x4B6D499041670D8DLL * __ROR8__(v39 + v44 + v56, 42);
      uint64_t v59 = v41 + v48;
      uint64_t v60 = *(v50 - 2);
      uint64_t v61 = *(v50 - 1);
      uint64_t v62 = *(v50 - 4) - 0x4B6D499041670D8DLL * v44;
      uint64_t v63 = v62 + v48 + v61;
      uint64_t v64 = v62 + v54 + v60;
      uint64_t v43 = v64 + v61;
      uint64_t v65 = __ROR8__(v64, 44) + v62;
      unint64_t v66 = (0xB492B66FBE98F273 * __ROR8__(v55, 37)) ^ v49;
      unint64_t v52 = 0xB492B66FBE98F273 * __ROR8__(v59, 33);
      unint64_t v44 = v65 + __ROR8__(v63 + v66, 21);
      unint64_t v67 = v52 + v49 + *v50;
      uint64_t v48 = v67 + v58 + v56 + v57;
      uint64_t v49 = __ROR8__(v67 + v58 + v56, 44) + v67 + __ROR8__(v39 + v60 + v67 + v57, 21);
      v50 += 8;
      unint64_t v41 = v66;
      v53 += 64;
    }
    while (v53);
    unint64_t v68 = v52
        - 0x622015F714C7D297
        * ((0x9DDFEA08EB382D69
          * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) ^ ((0x9DDFEA08EB382D69 * (v49 ^ ((0x9DDFEA08EB382D69 * (v49 ^ v44)) >> 47) ^ (0x9DDFEA08EB382D69 * (v49 ^ v44)))) >> 47));
    unint64_t v69 = 0x9DDFEA08EB382D69
        * (v68 ^ (v66
                - 0x4B6D499041670D8DLL * (v39 ^ (v39 >> 47))
                - 0x622015F714C7D297
                * ((0x9DDFEA08EB382D69
                  * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) ^ ((0x9DDFEA08EB382D69 * (v48 ^ ((0x9DDFEA08EB382D69 * (v48 ^ v43)) >> 47) ^ (0x9DDFEA08EB382D69 * (v48 ^ v43)))) >> 47))));
    unint64_t v70 = 0x9DDFEA08EB382D69 * (v68 ^ (v69 >> 47) ^ v69);
    goto LABEL_13;
  }
  if (a2 > 0x10)
  {
    uint64_t v26 = a1[1];
    unint64_t v27 = 0xB492B66FBE98F273 * *a1;
    uint64_t v28 = __ROR8__(0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8), 30) + __ROR8__(v27 - v26, 43);
    unint64_t v29 = v27 + a2 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(uint64_t *)((char *)a1 + a2 - 8);
    unint64_t v23 = 0x9DDFEA08EB382D69;
    unint64_t v30 = 0x9DDFEA08EB382D69 * (v29 ^ (v28 - 0x3C5A37A36834CED9 * *(uint64_t *)((char *)a1 + a2 - 16)));
    unint64_t v31 = v29 ^ (v30 >> 47) ^ v30;
LABEL_8:
    unint64_t v25 = 0x9DDFEA08EB382D69 * v31;
    return (v25 ^ (v25 >> 47)) * v23;
  }
  if (a2 < 9)
  {
    if (a2 >= 4)
    {
      uint64_t v72 = *(unsigned int *)((char *)a1 + a2 - 4);
      unint64_t v23 = 0x9DDFEA08EB382D69;
      unint64_t v73 = 0x9DDFEA08EB382D69 * (((8 * *(_DWORD *)a1) + a2) ^ v72);
      unint64_t v31 = v72 ^ (v73 >> 47) ^ v73;
      goto LABEL_8;
    }
    unint64_t v4 = 0x9AE16A3B2F90404FLL;
    if (!a2) {
      return v4;
    }
    unint64_t v70 = (0xC949D7C7509E6557 * (a2 + 4 * *((unsigned __int8 *)a1 + a2 - 1))) ^ (0x9AE16A3B2F90404FLL
                                                                                   * (*(unsigned __int8 *)a1 | ((unint64_t)*((unsigned __int8 *)a1 + (a2 >> 1)) << 8)));
LABEL_13:
    v4 *= v70 ^ (v70 >> 47);
    return v4;
  }
  uint64_t v2 = *(uint64_t *)((char *)a1 + a2 - 8);
  uint64_t v3 = __ROR8__(v2 + a2, a2);
  return (0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69
          * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) ^ ((0x9DDFEA08EB382D69 * (v3 ^ ((0x9DDFEA08EB382D69 * (v3 ^ *a1)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ *a1)))) >> 47))) ^ v2;
}

BOOL std::equal_to<std::string>::operator()[abi:nn180100](unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1[23];
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = a1[23];
  }
  else {
    uint64_t v3 = *((void *)a1 + 1);
  }
  uint64_t v4 = a2[23];
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *((void *)a2 + 1);
  }
  if (v3 != v4) {
    return 0;
  }
  if (v5 < 0) {
    a2 = *(unsigned __int8 **)a2;
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
  }
  if (!a1[23]) {
    return 1;
  }
  uint64_t v6 = v2 - 1;
  do
  {
    int v8 = *a1++;
    int v7 = v8;
    int v10 = *a2++;
    int v9 = v10;
    BOOL v12 = v6-- != 0;
    BOOL v13 = v7 == v9;
    BOOL v14 = v7 == v9;
  }
  while (v13 && v12);
  return v14;
}

__n128 std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F71E80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCommonLearnedTypos::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int v8 = (uint64_t *)a2;
  }
  else {
    int v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    uint64_t v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v18 = operator new(0x28uLL);
  v18[1] = v11;
  *((_OWORD *)v18 + 1) = *(_OWORD *)a3;
  v18[4] = *(void *)(a3 + 16);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v12 || (float)(v20 * (float)v12) < v19)
  {
    BOOL v21 = 1;
    if (v12 >= 3) {
      BOOL v21 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v12);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t v24 = v23;
    }
    else {
      size_t v24 = v22;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v24);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v25 = *(void *)a1;
  uint64_t v26 = *(void **)(*(void *)a1 + 8 * v3);
  if (v26)
  {
    *uint64_t v18 = *v26;
LABEL_44:
    *uint64_t v26 = v18;
    goto LABEL_45;
  }
  uint64_t v27 = *(void *)(a1 + 16);
  *uint64_t v18 = v27;
  *(void *)(a1 + 16) = v18;
  *(void *)(v25 + 8 * v3) = a1 + 16;
  if (v27)
  {
    unint64_t v28 = *(void *)(v27 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }
    else
    {
      v28 &= v12 - 1;
    }
    uint64_t v26 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>(uint64_t a1)
{
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 24);
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

uint64_t std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__hash_table(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  *(void *)__n128 result = v2;
  *(void *)(result + 8) = a2[1];
  a2[1] = 0;
  uint64_t v5 = a2[2];
  unint64_t v3 = a2 + 2;
  uint64_t v4 = v5;
  *(void *)(result + 16) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 24) = v6;
  *(_DWORD *)(result + 32) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 16;
    *unint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    unint64_t v1 = a1;
    do
    {
      uint64_t v2 = (void *)*v1;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::unordered_set<std::string>>,0>((uint64_t)(v1 + 2));
      operator delete(v1);
      unint64_t v1 = v2;
    }
    while (v2);
  }
}

const char *KB::FilterCommonLearnedTypos::filter_description(KB::FilterCommonLearnedTypos *this)
{
  return "FilterCommonLearnedTypos";
}

void KB::FilterCommonLearnedTypos::~FilterCommonLearnedTypos(KB::FilterCommonLearnedTypos *this)
{
  *(void *)this = &unk_1F3F73520;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)this + 16);

  JUMPOUT(0x1E4E7BC20);
}

{
  std::__shared_weak_count *v2;

  *(void *)this = &unk_1F3F73520;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table((uint64_t)this + 16);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void *KB::FilterAppNames::filter_candidates(KB::FilterAppNames *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)a4 + 2);
  if (v7) {
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  }
  uint64_t v8 = *(void *)(v7 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  uint64_t v9 = *((void *)a4 + 7);
  v11[0] = &unk_1F3F71EC8;
  v11[1] = v8;
  void v11[2] = a3;
  _WORD v11[3] = v11;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v9, (uint64_t)"FilterAppNames", (uint64_t)v11);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v11);
}

uint64_t std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  v15[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a3;
  unsigned int v5 = KB::Candidate::num_words_matching_input(a2, *(void **)(a1 + 16), *(void *)(a1 + 8));
  if (*(void *)a2 == v5) {
    return 0;
  }
  uint64_t v6 = (int *)(240 * v5 + *((void *)a2 + 1) + 104);
  uint64_t v7 = -240 * v5 + 240 * *(void *)a2;
  while (1)
  {
    int v8 = *v6;
    v6 += 60;
    if (v8 < 0) {
      break;
    }
    v7 -= 240;
    if (!v7) {
      return 0;
    }
  }
  if (v4)
  {
    KB::Candidate::capitalized_string(a2, (uint64_t)v12);
    unint64_t v10 = (const char *)v14;
    if (!v14) {
      unint64_t v10 = (const char *)v15;
    }
    if (v12[0]) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = "";
    }
    KB::String::append_format(v4, "Candidate '%s' is a completion for an app name", v11);
    if (v14)
    {
      if (v13 == 1) {
        free(v14);
      }
    }
  }
  return 1;
}

__n128 std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F71EC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F71EC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAppNames::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterAppNames::filter_description(KB::FilterAppNames *this)
{
  return "FilterAppNames";
}

void KB::FilterAppNames::~FilterAppNames(KB::FilterAppNames *this)
{
}

id TIACCorrectionTypeValues()
{
  v6[6] = *MEMORY[0x1E4F143B8];
  v6[0] = kTIACCorrectionTypeNone;
  v6[1] = kTIACSingleWordCountType;
  id v0 = [kTIACSingleWordCountType stringByAppendingString:kTIACMessageBeginsWithAsterisk];
  v6[2] = v0;
  unint64_t v1 = [kTIACSingleWordCountType stringByAppendingString:kTIACMessageEndsWithAsterisk];
  v6[3] = v1;
  uint64_t v2 = [kTIACMultiWordCountType stringByAppendingString:kTIACMessageBeginsWithAsterisk];
  v6[4] = v2;
  unint64_t v3 = [kTIACMultiWordCountType stringByAppendingString:kTIACMessageEndsWithAsterisk];
  void v6[5] = v3;
  uint64_t v4 = [MEMORY[0x1E4F1C978] arrayWithObjects:v6 count:6];

  return v4;
}

void *TIACAllowedAppIds()
{
  return &unk_1F3FA76E8;
}

uint64_t KB::LanguageModelContext::LanguageModelContext(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 64));
  language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 72));
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  for (*(void *)(a1 + 96) = 0; a3; --a3)
  {
    unint64_t v8 = *a2++;
    KB::LanguageModelContext::append((KB::LanguageModelContext *)a1, v8, a4, 0);
    a4 += 24;
  }
  return a1;
}

void KB::LanguageModelContext::append(KB::LanguageModelContext *this, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v46 = a2;
  if (HIDWORD(a2) == 1)
  {
    unint64_t v8 = *((void *)this + 6) + 1;
    *((void *)this + 6) = v8;
    if (v8 >= 4)
    {
      KB::LanguageModelContext::pop_first_sentence(this);
      uint64_t v9 = (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3;
      *((void *)this + 5) = v9;
      *((void *)this + 7) = v9;
      language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
    }
  }
  else if (*((void *)this + 3) == *((void *)this + 2))
  {
    ++*((void *)this + 6);
  }
  KB::LanguageModelContext::linguistic_token(a3, (TITokenID)&v46, (uint64_t)&__p);
  if (language_modeling::v1::LinguisticContext::try_push_back())
  {
    unint64_t v11 = (unint64_t *)*((void *)this + 3);
    unint64_t v10 = *((void *)this + 4);
    if ((unint64_t)v11 >= v10)
    {
      uint64_t v13 = *((void *)this + 2);
      uint64_t v14 = ((uint64_t)v11 - v13) >> 3;
      if ((unint64_t)(v14 + 1) >> 61) {
        goto LABEL_52;
      }
      uint64_t v15 = v10 - v13;
      uint64_t v16 = v15 >> 2;
      if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
        uint64_t v16 = v14 + 1;
      }
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v17 = v16;
      }
      if (v17) {
        unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
      }
      else {
        uint64_t v18 = 0;
      }
      float v19 = (unint64_t *)(v17 + 8 * v14);
      unint64_t v20 = v17 + 8 * v18;
      *float v19 = a2;
      unint64_t v12 = v19 + 1;
      unint64_t v22 = (char *)*((void *)this + 2);
      BOOL v21 = (char *)*((void *)this + 3);
      if (v21 != v22)
      {
        do
        {
          unint64_t v23 = *((void *)v21 - 1);
          v21 -= 8;
          *--float v19 = v23;
        }
        while (v21 != v22);
        BOOL v21 = (char *)*((void *)this + 2);
      }
      *((void *)this + 2) = v19;
      *((void *)this + 3) = v12;
      *((void *)this + 4) = v20;
      if (v21) {
        operator delete(v21);
      }
    }
    else
    {
      unint64_t *v11 = a2;
      unint64_t v12 = v11 + 1;
    }
    unint64_t v24 = *((void *)this + 12);
    *((void *)this + 3) = v12;
    unint64_t v25 = *((void *)this + 11);
    if (v25 < v24)
    {
      if (*(char *)(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(*((std::string **)this + 11), *(const std::string::value_type **)a3, *(void *)(a3 + 8));
      }
      else
      {
        long long v26 = *(_OWORD *)a3;
        *(void *)(v25 + 16) = *(void *)(a3 + 16);
        *(_OWORD *)unint64_t v25 = v26;
      }
      uint64_t v35 = (std::string *)(v25 + 24);
LABEL_46:
      *((void *)this + 11) = v35;
      if (a4)
      {
        *((void *)this + 7) = (uint64_t)(*((void *)this + 3) - *((void *)this + 2)) >> 3;
        language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
      }
      else
      {
        language_modeling::v1::LinguisticContext::try_push_back();
      }
      goto LABEL_49;
    }
    uint64_t v27 = *((void *)this + 10);
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v25 - v27) >> 3);
    if (v28 + 1 <= 0xAAAAAAAAAAAAAAALL)
    {
      unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v24 - v27) >> 3);
      uint64_t v30 = 2 * v29;
      if (2 * v29 <= v28 + 1) {
        uint64_t v30 = v28 + 1;
      }
      if (v29 >= 0x555555555555555) {
        unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v31 = v30;
      }
      v47.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 96);
      if (v31)
      {
        uint64_t v32 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v31);
        uint64_t v34 = v33;
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v34 = 0;
      }
      uint64_t v36 = (std::string *)&v32[24 * v28];
      if (*(char *)(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v36, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
      }
      else
      {
        long long v37 = *(_OWORD *)a3;
        v36->__r_.__value_.__r.__words[2] = *(void *)(a3 + 16);
        *(_OWORD *)&v36->__r_.__value_.__l.__data_ = v37;
      }
      uint64_t v39 = *((void *)this + 10);
      unint64_t v38 = *((void *)this + 11);
      if (v38 == v39)
      {
        int64x2_t v42 = vdupq_n_s64(v38);
        unint64_t v40 = v36;
      }
      else
      {
        unint64_t v40 = v36;
        do
        {
          long long v41 = *(_OWORD *)(v38 - 24);
          v40[-1].__r_.__value_.__r.__words[2] = *(void *)(v38 - 8);
          *(_OWORD *)&v40[-1].__r_.__value_.__l.__data_ = v41;
          --v40;
          *(void *)(v38 - 16) = 0;
          *(void *)(v38 - 8) = 0;
          *(void *)(v38 - 24) = 0;
          v38 -= 24;
        }
        while (v38 != v39);
        int64x2_t v42 = *((int64x2_t *)this + 5);
      }
      uint64_t v35 = v36 + 1;
      *((void *)this + 10) = v40;
      *((void *)this + 11) = v36 + 1;
      *(int64x2_t *)&v47.__begin_ = v42;
      uint64_t v43 = (std::string *)*((void *)this + 12);
      *((void *)this + 12) = &v32[24 * v34];
      v47.__end_cap_.__value_ = v43;
      v47.__first_ = (std::__split_buffer<std::string>::pointer)v42.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v47);
      goto LABEL_46;
    }
LABEL_52:
    abort();
  }
LABEL_49:
  if (v45 < 0) {
    operator delete(__p);
  }
}

void KB::LanguageModelContext::pop_first_sentence(KB::LanguageModelContext *this)
{
  unint64_t v3 = (char *)*((void *)this + 2);
  uint64_t v2 = (char *)*((void *)this + 3);
  uint64_t v4 = v3 + 8;
  if (v3 + 8 == v2) {
    goto LABEL_6;
  }
  while (*((_DWORD *)v4 + 1) != 1)
  {
    v4 += 8;
    if (v4 == v2)
    {
      uint64_t v4 = (char *)*((void *)this + 3);
      break;
    }
  }
  if (v3 != v4)
  {
LABEL_6:
    int64_t v5 = v2 - v4;
    if (v2 == v4)
    {
      uint64_t v6 = (char *)*((void *)this + 2);
    }
    else
    {
      memmove(*((void **)this + 2), v4, v2 - v4);
      uint64_t v6 = (char *)*((void *)this + 2);
    }
    *((void *)this + 3) = &v3[v5];
    unint64_t v3 = v6;
  }
  BOOL v7 = v4 == v3;
  uint64_t v8 = (v4 - v3) >> 3;
  if (!v7)
  {
    uint64_t v9 = *((void *)this + 10);
    uint64_t v10 = *((void *)this + 11);
    uint64_t v11 = v9 + 24 * v8;
    if (v11 != v10)
    {
      uint64_t v12 = 24 * v8;
      do
      {
        if (*(char *)(v9 + 23) < 0) {
          operator delete(*(void **)v9);
        }
        uint64_t v13 = (unsigned char *)(v9 + v12);
        long long v14 = *(_OWORD *)(v9 + 24 * v8);
        *(void *)(v9 + 16) = *(void *)(v9 + v12 + 16);
        *(_OWORD *)uint64_t v9 = v14;
        v9 += 24;
        v13[23] = 0;
        *uint64_t v13 = 0;
      }
      while (v9 + v12 != v10);
      uint64_t v11 = *((void *)this + 11);
    }
    while (v11 != v9)
    {
      if (*(char *)(v11 - 1) < 0) {
        operator delete(*(void **)(v11 - 24));
      }
      v11 -= 24;
    }
    *((void *)this + 11) = v9;
  }
  language_modeling::v1::LinguisticContext::remove_first((KB::LanguageModelContext *)((char *)this + 64));
  --*((void *)this + 6);
  uint64_t v15 = *(uint64_t **)this;
  if (*(void *)this)
  {
    uint64_t v17 = *v15;
    for (uint64_t i = v15[1]; i != v17; std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(i))
      i -= 104;
    v15[1] = v17;
  }
}

void KB::LanguageModelContext::linguistic_token(uint64_t a1@<X0>, TITokenID a2@<X1>, uint64_t a3@<X8>)
{
  int64_t v5 = **(KB ***)&a2;
  int v7 = KB::LanguageModelContext::linguistic_token_type(**(void **)&a2, a2);
  if (v7 == 3)
  {
    KB::class_token_text(v5, v6, &__p);
  }
  else if (*(char *)(a1 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a1, *(void *)(a1 + 8));
  }
  else
  {
    std::string __p = *(std::string *)a1;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)a3, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    int v8 = SHIBYTE(__p.__r_.__value_.__r.__words[2]);
    *(_DWORD *)(a3 + 24) = v7;
    if (v8 < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    *(std::string *)a3 = __p;
    *(_DWORD *)(a3 + 24) = v7;
  }
}

unint64_t KB::LanguageModelContext::linguistic_token_type(unint64_t this, TITokenID a2)
{
  unint64_t result = HIDWORD(this);
  if ((int)result > 62)
  {
    if ((result - 63) < 2 || (result - 130) < 2 || result == 499) {
      return 3;
    }
    else {
      return 0;
    }
  }
  else
  {
    switch((int)result)
    {
      case 1:
        return result;
      case 2:
        unint64_t result = 2;
        break;
      case 3:
      case 5:
      case 6:
      case 7:
        return 3;
      default:
        return 0;
    }
  }
  return result;
}

void *KB::class_token_text@<X0>(KB *this@<X0>, TITokenID a2@<0:X1>, void *a3@<X8>)
{
  if (SHIDWORD(this) <= 63)
  {
    switch(HIDWORD(this))
    {
      case 3:
        unint64_t v3 = (char **)MEMORY[0x1E4F72030];
        goto LABEL_19;
      case 4:
        goto LABEL_13;
      case 5:
        unint64_t v3 = (char **)MEMORY[0x1E4F72020];
        goto LABEL_19;
      case 6:
        unint64_t v3 = (char **)MEMORY[0x1E4F720E8];
        goto LABEL_19;
      case 7:
        unint64_t v3 = (char **)MEMORY[0x1E4F72028];
        goto LABEL_19;
      default:
        if (HIDWORD(this) != 63) {
          goto LABEL_13;
        }
        unint64_t v3 = (char **)MEMORY[0x1E4F72038];
        break;
    }
    goto LABEL_19;
  }
  if (SHIDWORD(this) > 130)
  {
    if (HIDWORD(this) == 131)
    {
      unint64_t v3 = (char **)MEMORY[0x1E4F72058];
      goto LABEL_19;
    }
    if (HIDWORD(this) == 499)
    {
      unint64_t v3 = (char **)MEMORY[0x1E4F72108];
      goto LABEL_19;
    }
  }
  else
  {
    if (HIDWORD(this) == 64)
    {
      unint64_t v3 = (char **)MEMORY[0x1E4F72040];
      goto LABEL_19;
    }
    if (HIDWORD(this) == 130)
    {
      unint64_t v3 = (char **)MEMORY[0x1E4F72088];
LABEL_19:
      uint64_t v4 = *v3;
      return std::string::basic_string[abi:nn180100]<0>(a3, v4);
    }
  }
LABEL_13:
  uint64_t v4 = "";
  return std::string::basic_string[abi:nn180100]<0>(a3, v4);
}

void std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(uint64_t a1)
{
  uint64_t v4 = (void **)(a1 + 80);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v4);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 72));
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 24) = v2;
    operator delete(v2);
  }
  unint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

BOOL KB::LanguageModelContext::is_beginning_of_sentence(KB::LanguageModelContext *this)
{
  uint64_t v1 = language_modeling::v1::LinguisticContext::tokenSpan((KB::LanguageModelContext *)((char *)this + 64));
  return v2 && *(_DWORD *)(v1 + 32 * v2 - 8) == 1;
}

uint64_t KB::LanguageModelContext::is_linguistically_void(KB::LanguageModelContext *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3) - v1;
  if (v2)
  {
    uint64_t v3 = 8 * (v2 >> 3);
    while ((*(_DWORD *)(v1 + 4) - 1) < 0x1F3)
    {
      v1 += 8;
      v3 -= 8;
      if (!v3) {
        goto LABEL_5;
      }
    }
    return 0;
  }
  else
  {
LABEL_5:
    uint64_t v4 = *(KB::LanguageModelContext ***)this;
    if (!*(void *)this) {
      return 1;
    }
    int64_t v5 = *v4;
    TITokenID v6 = v4[1];
    if (*v4 == v6)
    {
      return 1;
    }
    else
    {
      do
      {
        uint64_t result = KB::LanguageModelContext::is_linguistically_void(v5);
        if (!result) {
          break;
        }
        int64_t v5 = (KB::LanguageModelContext *)((char *)v5 + 104);
      }
      while (v5 != v6);
    }
  }
  return result;
}

void KB::LanguageModelContext::debug_string_for_token(uint64_t a1@<X1>, uint64_t a2@<X2>, KB::String *a3@<X8>)
{
  if (HIDWORD(a1) > 0x1F3)
  {
    if (*(char *)(a2 + 23) >= 0) {
      int64_t v5 = (const char *)a2;
    }
    else {
      int64_t v5 = *(const char **)a2;
    }
    KB::String::String(a3, v5);
  }
  else
  {
    CFStringRef StringForSpecialTokenID = (const __CFString *)LMLanguageModelCreateStringForSpecialTokenID();
    KB::utf8_string(StringForSpecialTokenID, (uint64_t)a3);
    if (StringForSpecialTokenID)
    {
      CFRelease(StringForSpecialTokenID);
    }
  }
}

void KB::LanguageModelContext::description(int **this@<X0>, KB::String *a2@<X8>)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v34 = 0;
  uint64_t v35 = (unsigned __int16 *)&v34;
  uint64_t v36 = 0x4802000000;
  long long v37 = __Block_byref_object_copy__1594;
  unint64_t v38 = __Block_byref_object_dispose__1595;
  int v39 = 0x100000;
  __int16 v40 = 0;
  char v41 = 0;
  int64x2_t v42 = 0;
  char v43 = 0;
  v24[0] = MEMORY[0x1E4F143A8];
  v24[1] = 0x40000000;
  unint64_t v25 = ___ZNK2KB20LanguageModelContext11descriptionEv_block_invoke;
  long long v26 = &unk_1E6E29918;
  uint64_t v27 = &v34;
  unint64_t v28 = (KB::LanguageModelContext *)this;
  uint64_t v4 = this[7];
  int64_t v5 = this[5];
  if (v4 != v5) {
    KB::String::append((unsigned __int16 *)&v39, "<blocklisted> ", 0xFFFFuLL);
  }
  uint64_t v6 = (uint64_t)this[10];
  int v7 = this[11];
  if ((int *)v6 != v7)
  {
    int v8 = (uint64_t *)this[2];
    do
    {
      if (v4 != v5 && v8 == (uint64_t *)&this[2][2 * (void)this[7]]) {
        KB::String::append(v35 + 20, "</blocklisted> ", 0xFFFFuLL);
      }
      uint64_t v9 = *v8++;
      v25((uint64_t)v24, v9, v6);
      v6 += 24;
    }
    while ((int *)v6 != v7);
  }
  uint64_t v10 = v35;
  uint64_t v12 = this[2];
  uint64_t v11 = this[3];
  uint64_t v13 = (char *)v11 - (char *)v12;
  if (v11 == v12)
  {
    __int16 v30 = 0;
    char v31 = 0;
    uint64_t v32 = "(empty)";
    int v29 = 1048583;
    v33[1] = 0;
  }
  else
  {
    int v29 = 0x100000;
    __int16 v30 = 0;
    char v31 = 0;
    uint64_t v32 = 0;
    v33[0] = 0;
    unint64_t v14 = TILocaleIdentifierForLexiconID(*v12);
    if (v14) {
      uint64_t v15 = (const char *)v14;
    }
    else {
      uint64_t v15 = "";
    }
    KB::String::append_format((KB::String *)&v29, "[%s]%u", v15, v12[1]);
    if (v13 != 8)
    {
      unsigned int v16 = 2;
      uint64_t v17 = 1;
      do
      {
        uint64_t v18 = &v12[2 * v17];
        unint64_t v19 = TILocaleIdentifierForLexiconID(*(void *)v18);
        if (v19) {
          unint64_t v20 = (const char *)v19;
        }
        else {
          unint64_t v20 = "";
        }
        KB::String::append_format((KB::String *)&v29, " [%s]%u", v20, v18[1]);
        uint64_t v17 = v16;
      }
      while (v13 >> 3 > (unint64_t)v16++);
    }
  }
  unint64_t v22 = (const char *)v32;
  if (!v32) {
    unint64_t v22 = v33;
  }
  if ((_WORD)v29) {
    unint64_t v23 = v22;
  }
  else {
    unint64_t v23 = "";
  }
  KB::String::append_format((KB::String *)(v10 + 20), "(%s)", v23);
  if (v32 && v31 == 1) {
    free(v32);
  }
  KB::String::String(a2, (const KB::String *)(v35 + 20));
  _Block_object_dispose(&v34, 8);
  if (v42)
  {
    if (v41 == 1) {
      free(v42);
    }
  }
}

uint64_t __Block_byref_object_copy__1594(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 40) = 0x100000;
  uint64_t v2 = a1 + 40;
  *(_WORD *)(v2 + 4) = 0;
  *(unsigned char *)(v2 + 6) = 0;
  *(void *)(v2 + 8) = 0;
  return KB::String::operator=(v2, (KB::String *)(a2 + 40));
}

void __Block_byref_object_dispose__1595(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 46) == 1) {
      free(v2);
    }
  }
}

void ___ZNK2KB20LanguageModelContext11descriptionEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v9[2] = *MEMORY[0x1E4F143B8];
  KB::LanguageModelContext::debug_string_for_token(a2, a3, (KB::String *)v6);
  uint64_t v4 = (const char *)v8;
  if (!v8) {
    uint64_t v4 = (const char *)v9;
  }
  if (v6[0]) {
    int64_t v5 = v4;
  }
  else {
    int64_t v5 = "";
  }
  KB::String::append_format((KB::String *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), "%s ", v5);
  if (v8)
  {
    if (v7 == 1) {
      free(v8);
    }
  }
}

uint64_t KB::LanguageModelContext::clear(KB::LanguageModelContext *this)
{
  *((void *)this + 3) = *((void *)this + 2);
  std::vector<std::string>::__clear[abi:nn180100]((uint64_t *)this + 10);
  language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 64));
  uint64_t result = language_modeling::v1::LinguisticContext::clear((KB::LanguageModelContext *)((char *)this + 72));
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  return result;
}

void KB::LanguageModelContext::append(KB::LanguageModelContext *this, TITokenID a2, const KB::String *a3, int a4)
{
  char v7 = (char *)*((void *)a3 + 1);
  if (!v7) {
    char v7 = (char *)a3 + 16;
  }
  if (*(_WORD *)a3) {
    int v8 = v7;
  }
  else {
    int v8 = "";
  }
  std::string::basic_string[abi:nn180100]<0>(__p, v8);
  KB::LanguageModelContext::append(this, *(void *)&a2, (uint64_t)__p, a4);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
}

void *KB::LanguageModelContext::pop_back(void *this)
{
  uint64_t v1 = this[3];
  if (v1 != this[2] && *(_DWORD *)(v1 - 4) != 1)
  {
    uint64_t v2 = this;
    this[3] = v1 - 8;
    uint64_t v3 = this[11];
    uint64_t v4 = (void **)(v3 - 24);
    if (*(char *)(v3 - 1) < 0) {
      operator delete(*v4);
    }
    v2[11] = v4;
    language_modeling::v1::LinguisticContext::pop_back((language_modeling::v1::LinguisticContext *)(v2 + 8));
    uint64_t v5 = v2[3] - v2[2];
    if (v2[7] > (unint64_t)(v5 >> 3)) {
      v2[7] = v5 >> 3;
    }
    uint64_t v6 = (language_modeling::v1::LinguisticContext *)(v2 + 9);
    this = (void *)language_modeling::v1::LinguisticContext::tokenSpan(v6);
    if (v7)
    {
      return (void *)language_modeling::v1::LinguisticContext::pop_back(v6);
    }
  }
  return this;
}

unint64_t KB::LanguageModelContext::suffix_len_from_lexicon(KB::LanguageModelContext *this, int a2)
{
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = *((void *)this + 3) - v2;
  unint64_t result = v3 >> 3;
  if (v3)
  {
    uint64_t v5 = 0;
    if (result <= 1) {
      unint64_t v6 = 1;
    }
    else {
      unint64_t v6 = result;
    }
    uint64_t v7 = (uint64_t *)(v2 + 8 * result - 8);
    while (1)
    {
      uint64_t v9 = *v7--;
      unsigned int v8 = HIDWORD(v9);
      if (v9 != a2 && v8 > 0x1F3) {
        break;
      }
      if (v6 == ++v5) {
        return result;
      }
    }
    return v5;
  }
  return result;
}

uint64_t KB::LanguageModelContext::most_recent_lexicon_id(KB::LanguageModelContext *this)
{
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = *((void *)this + 3) - v1;
  if (!v2) {
    return 0;
  }
  unint64_t v3 = (v2 & 0xFFFFFFFFFFFFFFF8) - 8;
  do
  {
    if (*(_DWORD *)(v1 + v3 + 4) >= 0x1F4u) {
      uint64_t result = *(unsigned int *)(v1 + v3);
    }
    else {
      uint64_t result = 0;
    }
    if (!v3) {
      break;
    }
    v3 -= 8;
  }
  while (!result);
  return result;
}

uint64_t KB::LanguageModelContext::most_recent_token_with_predicate(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void *)(a1 + 24); i != *(void *)(a1 + 16); i -= 8)
  {
    uint64_t v6 = *(void *)(i - 8);
    uint64_t v5 = v6;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a2 + 16))(a2, v6)) {
      return v5;
    }
  }
  return 0;
}

void KB::LanguageModelContext::set_predominant_locale(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v4, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v4 = *(std::string *)a2;
  }
  language_modeling::v1::LinguisticContext::set_predominant_locale();
  if (SHIBYTE(v4.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v4.__r_.__value_.__l.__data_);
  }
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  language_modeling::v1::LinguisticContext::set_predominant_locale();
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

uint64_t WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = atomic_load((unsigned int *)result);
  if (v2 == 1)
  {
    unint64_t v3 = *(void **)(result + 216);
    if (v3 && *(unsigned char *)(v1 + 214) == 1) {
      free(v3);
    }
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(void **)(v1 + 184));
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*(void **)(v1 + 160));
    std::string v4 = *(unsigned __int16 **)(v1 + 88);
    if (v4)
    {
      do
      {
        uint64_t v5 = *(unsigned __int16 **)v4;
        std::__destroy_at[abi:nn180100]<std::pair<KB::ByteString const,WTF::RefPtr<TI::Favonius::LayoutKey>>,0>(v4 + 8);
        operator delete(v4);
        std::string v4 = v5;
      }
      while (v5);
    }
    uint64_t v6 = *(void **)(v1 + 72);
    *(void *)(v1 + 72) = 0;
    if (v6) {
      operator delete(v6);
    }
    uint64_t v7 = *(void **)(v1 + 48);
    if (v7)
    {
      do
      {
        unsigned int v8 = (void *)*v7;
        uint64_t v9 = v7[3];
        if (v9) {
          WTF::RefCounted<TI::Favonius::Key>::deref(v9);
        }
        operator delete(v7);
        uint64_t v7 = v8;
      }
      while (v8);
    }
    char v10 = *(void **)(v1 + 32);
    *(void *)(v1 + 32) = 0;
    if (v10) {
      operator delete(v10);
    }
    uint64_t v11 = (void **)(v1 + 8);
    std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](&v11);
    JUMPOUT(0x1E4E7BC20);
  }
  atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  return result;
}

void std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(*a1);
    std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void std::vector<WTF::RefPtr<TI::Favonius::LayoutKey>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = (char *)**a1;
  if (v2)
  {
    std::string v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = *((void *)v4 - 1);
        v4 -= 8;
        uint64_t v6 = v7;
        if (v7) {
          WTF::RefCounted<TI::Favonius::Key>::deref(v6);
        }
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t WTF::RefCounted<TI::Favonius::Key>::deref(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = atomic_load((unsigned int *)result);
  if (v2 == 1)
  {
    if (*(unsigned __int16 *)(result + 40) >= 0xFu)
    {
      uint64_t v3 = *(void *)(result + 48);
      if (v3) {
        MEMORY[0x1E4E7BC00](v3, 0x1000C8077774924);
      }
    }
    std::string v4 = *(void **)(v1 + 16);
    if (v4 && *(unsigned char *)(v1 + 14) == 1) {
      free(v4);
    }
    JUMPOUT(0x1E4E7BC20);
  }
  atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  return result;
}

uint64_t std::__destroy_at[abi:nn180100]<std::pair<KB::ByteString const,WTF::RefPtr<TI::Favonius::LayoutKey>>,0>(unsigned __int16 *a1)
{
  uint64_t result = *((void *)a1 + 2);
  if (result) {
    uint64_t result = WTF::RefCounted<TI::Favonius::Key>::deref(result);
  }
  if (*a1 >= 0xFu)
  {
    uint64_t result = *((void *)a1 + 1);
    if (result)
    {
      JUMPOUT(0x1E4E7BC00);
    }
  }
  return result;
}

uint64_t __Block_byref_object_copy__265(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__266(uint64_t a1)
{
}

id chineseJapaneseResponseKitBackgroundQueue(void)
{
  if (chineseJapaneseResponseKitBackgroundQueue(void)::onceToken != -1) {
    dispatch_once(&chineseJapaneseResponseKitBackgroundQueue(void)::onceToken, &__block_literal_global_1821);
  }
  id v0 = (void *)chineseJapaneseResponseKitBackgroundQueue(void)::_instance;

  return v0;
}

void ___Z41chineseJapaneseResponseKitBackgroundQueuev_block_invoke()
{
  unsigned int v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  dispatch_queue_t v0 = dispatch_queue_create("com.apple.TextInput.ResponseKit.chineseJapaneseResponseKitBackgroundQueue", v2);
  uint64_t v1 = (void *)chineseJapaneseResponseKitBackgroundQueue(void)::_instance;
  chineseJapaneseResponseKitBackgroundQueue(void)::_instance = (uint64_t)v0;
}

void *WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::Vector(void *a1, void *a2)
{
  uint64_t v3 = a2[2];
  *a1 = *a2;
  a1[1] = 0;
  a1[2] = 0;
  if (v3)
  {
    a1[2] = v3;
    uint64_t v5 = malloc_type_malloc(8 * v3, 0x2004093837F09uLL);
    a1[1] = v5;
    if (v5)
    {
      if (*a2)
      {
        uint64_t v6 = (atomic_uint **)a2[1];
        uint64_t v7 = 8 * *a2;
        do
        {
          unsigned int v8 = *v6;
          *uint64_t v5 = *v6;
          if (v8) {
            atomic_fetch_add(v8, 1u);
          }
          ++v5;
          ++v6;
          v7 -= 8;
        }
        while (v7);
      }
    }
  }
  return a1;
}

void *WTF::Vector<WTF::RefPtr<TI::Favonius::KeyMatch>,0ul>::~Vector(void *a1)
{
  if (*a1)
  {
    unsigned int v2 = (uint64_t *)a1[1];
    uint64_t v3 = 8 * *a1;
    do
    {
      if (*v2) {
        WTF::RefCounted<TI::Favonius::KeyMatch>::deref(*v2);
      }
      ++v2;
      v3 -= 8;
    }
    while (v3);
    *a1 = 0;
  }
  std::string v4 = (void *)a1[1];
  a1[1] = 0;
  a1[2] = 0;
  free(v4);
  return a1;
}

uint64_t WTF::RefCounted<TI::Favonius::KeyMatch>::deref(uint64_t result)
{
  unsigned int v1 = atomic_load((unsigned int *)result);
  if (v1 == 1)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2) {
      WTF::RefCounted<TI::Favonius::Key>::deref(v2);
    }
    JUMPOUT(0x1E4E7BC20);
  }
  atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  return result;
}

void *__Block_byref_object_copy__1859(void *result, void *a2)
{
  result[6] = 0;
  result[7] = 0;
  result[8] = 0;
  uint64_t v2 = a2[7];
  result[6] = a2[6];
  result[7] = v2;
  a2[6] = 0;
  a2[7] = 0;
  uint64_t v3 = result[8];
  result[8] = a2[8];
  a2[8] = v3;
  return result;
}

void *__Block_byref_object_dispose__1860(uint64_t a1)
{
  return WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector((void *)(a1 + 48));
}

void *WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector(void *a1)
{
  if (*a1)
  {
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v3 = 8 * *a1;
    do
    {
      if (*v2) {
        WTF::RefCounted<TI::Favonius::Key>::deref(*v2);
      }
      ++v2;
      v3 -= 8;
    }
    while (v3);
    *a1 = 0;
  }
  std::string v4 = (void *)a1[1];
  a1[1] = 0;
  a1[2] = 0;
  free(v4);
  return a1;
}

unint64_t WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::expandCapacity(void *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unint64_t v5 = a1[1];
  if (v5 > a3 || v5 + 8 * *a1 <= a3)
  {
    unint64_t v9 = a1[2];
    if (v9 >= 0x100) {
      unint64_t v10 = v9 + (v9 >> 1);
    }
    else {
      unint64_t v10 = 2 * v9;
    }
    if (v10 > a2) {
      a2 = v10;
    }
    WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a1, a2);
  }
  else
  {
    unint64_t v6 = a3 - v5;
    unint64_t v7 = a1[2];
    if (v7 >= 0x100) {
      unint64_t v8 = v7 + (v7 >> 1);
    }
    else {
      unint64_t v8 = 2 * v7;
    }
    if (v8 > a2) {
      a2 = v8;
    }
    WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a1, a2);
    return a1[1] + v6;
  }
  return v3;
}

void WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(void *a1, unint64_t a2)
{
  if (a1[2] < a2)
  {
    unint64_t v3 = (void **)(a1 + 1);
    uint64_t v2 = (void *)a1[1];
    uint64_t v4 = *a1;
    a1[2] = a2;
    unint64_t v5 = malloc_type_malloc(8 * a2, 0x2004093837F09uLL);
    *unint64_t v3 = v5;
    if (v5)
    {
      memcpy(v5, v2, 8 * v4);
      unint64_t v6 = *v3;
    }
    else
    {
      unint64_t v6 = 0;
    }
    if (v6 == v2)
    {
      *unint64_t v3 = 0;
      v3[1] = 0;
    }
    free(v2);
  }
}

double TI::CP::PathSample::lerp@<D0>(float64x2_t *this@<X0>, float a2@<S0>, float64x2_t *a3@<X1>, float64x2_t *a4@<X8>)
{
  double result = a2;
  float64x2_t v5 = vmlaq_n_f64(this[1], vsubq_f64(a3[1], this[1]), result);
  *a4 = vmlaq_n_f64(*this, vsubq_f64(*a3, *this), result);
  a4[1] = v5;
  a4[2] = vmlaq_n_f64(this[2], vsubq_f64(a3[2], this[2]), result);
  return result;
}

BOOL TI::CP::operator==(double *a1, double *a2)
{
  BOOL v2 = *a1 == *a2 && a1[1] == a2[1];
  return v2 && a1[3] == a2[3] && a1[2] == a2[2] && a1[5] == a2[5];
}

BOOL TI::CP::operator!=(double *a1, double *a2)
{
  return !TI::CP::operator==(a1, a2);
}

BOOL TI::CP::Path::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v2 - *a1) >> 4);
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v4 != 0xAAAAAAAAAAAAAAABLL * ((v5 - *a2) >> 4)) {
    return 0;
  }
  double v9 = 0.0;
  double v10 = 0.0;
  if (v3 != v2) {
    double v10 = *(double *)(v2 - 16);
  }
  if (v6 != v5) {
    double v9 = *(double *)(v5 - 16);
  }
  if (v10 != v9) {
    return 0;
  }
  if (v3 != v2)
  {
    uint64_t v12 = 0;
    unsigned int v13 = 1;
    while (TI::CP::operator==((double *)(v3 + 48 * v12), (double *)(v6 + 48 * v12)))
    {
      uint64_t v12 = v13;
      if (v4 <= v13++) {
        goto LABEL_12;
      }
    }
    return 0;
  }
LABEL_12:
  uint64_t v15 = (const void *)a1[3];
  size_t v16 = a1[4] - (void)v15;
  uint64_t v17 = (const void *)a2[3];
  if (v16 != a2[4] - (void)v17) {
    return 0;
  }
  return memcmp(v15, v17, v16) == 0;
}

double TI::CP::Path::subpath_length(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  return *(double *)(*(void *)this + 48 * a3 + 32) - *(double *)(*(void *)this + 48 * a2 + 32);
}

long double TI::CP::Path::subpath_excess_length(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = (double *)(*(void *)this + 48 * a2);
  unint64_t v4 = (double *)(*(void *)this + 48 * a3);
  double v5 = v4[4] - v3[4];
  return v5 - hypot(*v4 - *v3, v4[1] - v3[1]);
}

uint64_t TI::CP::Path::inflection_point_count(TI::CP::Path *this)
{
  return (*((void *)this + 4) - *((void *)this + 3)) >> 2;
}

unint64_t TI::CP::Path::inflection_point_count(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = (char *)*((void *)this + 3);
  unint64_t v4 = (char *)*((void *)this + 4);
  if (v4 == v3)
  {
    uint64_t v11 = (char *)*((void *)this + 4);
  }
  else
  {
    unint64_t v5 = (v4 - v3) >> 2;
    do
    {
      unint64_t v6 = v5 >> 1;
      unint64_t v7 = (unsigned int *)&v3[4 * (v5 >> 1)];
      unsigned int v9 = *v7;
      unint64_t v8 = (char *)(v7 + 1);
      v5 += ~(v5 >> 1);
      if (v9 < a2) {
        uint64_t v3 = v8;
      }
      else {
        unint64_t v5 = v6;
      }
    }
    while (v5);
    if (v4 == v3)
    {
      uint64_t v11 = (char *)*((void *)this + 4);
    }
    else
    {
      unint64_t v10 = (v4 - v3) >> 2;
      uint64_t v11 = v3;
      do
      {
        unint64_t v12 = v10 >> 1;
        unsigned int v13 = (unsigned int *)&v11[4 * (v10 >> 1)];
        unsigned int v15 = *v13;
        unint64_t v14 = (char *)(v13 + 1);
        v10 += ~(v10 >> 1);
        if (v15 > a3) {
          unint64_t v10 = v12;
        }
        else {
          uint64_t v11 = v14;
        }
      }
      while (v10);
    }
    unint64_t v4 = v3;
  }
  return (unint64_t)(v11 - v4) >> 2;
}

BOOL TI::CP::Path::is_inflection_point(TI::CP::Path *this, unsigned int a2)
{
  return TI::CP::Path::inflection_point_count(this, a2, a2) != 0;
}

double TI::CP::Path::turn_angle(TI::CP::Path *this, unsigned int a2)
{
  double v2 = 0.0;
  if (a2)
  {
    uint64_t v4 = a2 + 1;
    uint64_t v5 = *(void *)this;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 4) != v4)
    {
      unint64_t v6 = (double *)(v5 + 48 * a2);
      double v7 = *v6;
      double v8 = v6[1];
      unsigned int v9 = (double *)(v5 + 48 * v4);
      double v10 = *v9 - *v6;
      double v11 = v9[1] - v8;
      if (hypot(v10, v11) >= 0.00001)
      {
        uint64_t v12 = 48 * a2;
        while (1)
        {
          uint64_t v13 = v12 - 48;
          if (!v12) {
            break;
          }
          uint64_t v14 = v5 + v12;
          double v15 = v7 - *(double *)(v14 - 48);
          double v16 = v8 - *(double *)(v14 - 40);
          long double v17 = hypot(v15, v16);
          uint64_t v12 = v13;
          if (v17 >= 0.00001)
          {
            double v18 = atan2(v16, v15);
            double v2 = atan2(v11, v10) - v18;
            if (v2 >= -3.14159265)
            {
              if (v2 <= 3.14159265) {
                return v2;
              }
              double v19 = -6.28318531;
            }
            else
            {
              double v19 = 6.28318531;
            }
            return v2 + v19;
          }
        }
      }
    }
  }
  return v2;
}

double TI::CP::Path::subpath_duration(TI::CP::Path *this, unsigned int a2, unsigned int a3)
{
  return *(double *)(*(void *)this + 48 * a3 + 16) - *(double *)(*(void *)this + 48 * a2 + 16);
}

void *TI::CP::Path::clear(void *this)
{
  this[1] = *this;
  this[4] = this[3];
  return this;
}

void TI::CP::Path::resize(TI::CP::Path *this, unsigned int a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(char **)this;
  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *(void *)this) >> 4);
  unint64_t v6 = a2 - v5;
  if (a2 == v5) {
    return;
  }
  if (a2 > v5)
  {
    uint64_t v9 = *((void *)this + 2);
    if (0xAAAAAAAAAAAAAAABLL * ((v9 - v4) >> 4) < v6)
    {
      unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - (uint64_t)v3) >> 4);
      if (2 * v10 > a2) {
        uint64_t v2 = 2 * v10;
      }
      if (v10 >= 0x2AAAAAAAAAAAAAALL) {
        unint64_t v11 = 0x555555555555555;
      }
      else {
        unint64_t v11 = v2;
      }
      uint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v11);
      uint64_t v13 = &v12[48 * v5];
      double v15 = &v12[48 * v14];
      size_t v16 = 48 * ((48 * v6 - 48) / 0x30) + 48;
      bzero(v13, v16);
      long double v17 = &v13[v16];
      double v19 = *(char **)this;
      double v18 = (char *)*((void *)this + 1);
      if (v18 != *(char **)this)
      {
        do
        {
          long long v20 = *((_OWORD *)v18 - 3);
          long long v21 = *((_OWORD *)v18 - 1);
          *((_OWORD *)v13 - 2) = *((_OWORD *)v18 - 2);
          *((_OWORD *)v13 - 1) = v21;
          *((_OWORD *)v13 - 3) = v20;
          v13 -= 48;
          v18 -= 48;
        }
        while (v18 != v19);
        double v18 = *(char **)this;
      }
      *(void *)this = v13;
      *((void *)this + 1) = v17;
      *((void *)this + 2) = v15;
      if (v18) {
        operator delete(v18);
      }
      goto LABEL_18;
    }
    size_t v23 = 48 * ((48 * v6 - 48) / 0x30) + 48;
    bzero(*((void **)this + 1), v23);
    unint64_t v22 = (char *)(v4 + v23);
    goto LABEL_17;
  }
  if (a2 < v5)
  {
    unint64_t v22 = &v3[48 * a2];
LABEL_17:
    *((void *)this + 1) = v22;
  }
LABEL_18:
  unint64_t v25 = (_DWORD *)*((void *)this + 3);
  unint64_t v24 = (_DWORD *)*((void *)this + 4);
  if (v24 == v25)
  {
    unint64_t v25 = (_DWORD *)*((void *)this + 4);
  }
  else
  {
    unint64_t v26 = v24 - v25;
    do
    {
      unint64_t v27 = v26 >> 1;
      unint64_t v28 = &v25[v26 >> 1];
      unsigned int v30 = *v28;
      int v29 = v28 + 1;
      v26 += ~(v26 >> 1);
      if (v30 < a2) {
        unint64_t v25 = v29;
      }
      else {
        unint64_t v26 = v27;
      }
    }
    while (v26);
  }
  if (v24 != v25) {
    *((void *)this + 4) = v25;
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(unint64_t a1)
{
  if (a1 >= 0x555555555555556) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(48 * a1);
}

void TI::CP::Path::append(TI::CP::Path *this, CGPoint a2, CGFloat a3, CGFloat a4, double a5, CGFloat a6)
{
  CGFloat y = a2.y;
  CGFloat x = a2.x;
  if (a5 >= 0.0)
  {
    double v15 = a5;
    uint64_t v12 = (CGFloat *)*((void *)this + 1);
  }
  else
  {
    uint64_t v12 = *(CGFloat **)this;
    uint64_t v13 = (CGFloat *)*((void *)this + 1);
    if (*(CGFloat **)this == v13)
    {
      double v15 = 0.0;
    }
    else
    {
      double v14 = *(v13 - 2);
      double v15 = v14 + hypot(a2.x - *(v13 - 6), a2.y - *(v13 - 5));
      uint64_t v12 = v13;
    }
  }
  unint64_t v16 = *((void *)this + 2);
  if ((unint64_t)v12 >= v16)
  {
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v12 - *(void *)this) >> 4);
    unint64_t v19 = v18 + 1;
    if (v18 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - *(void *)this) >> 4);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v21 = 0x555555555555555;
    }
    else {
      unint64_t v21 = v19;
    }
    unint64_t v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v21);
    size_t v23 = (CGFloat *)&v22[48 * v18];
    unint64_t v25 = &v22[48 * v24];
    *size_t v23 = x;
    v23[1] = y;
    uint64_t v23[2] = a3;
    void v23[3] = a4;
    v23[4] = v15;
    v23[5] = a6;
    long double v17 = v23 + 6;
    unint64_t v27 = *(char **)this;
    unint64_t v26 = (char *)*((void *)this + 1);
    if (v26 != *(char **)this)
    {
      do
      {
        long long v28 = *((_OWORD *)v26 - 3);
        long long v29 = *((_OWORD *)v26 - 1);
        *((_OWORD *)v23 - 2) = *((_OWORD *)v26 - 2);
        *((_OWORD *)v23 - 1) = v29;
        *((_OWORD *)v23 - 3) = v28;
        v23 -= 6;
        v26 -= 48;
      }
      while (v26 != v27);
      unint64_t v26 = *(char **)this;
    }
    *(void *)this = v23;
    *((void *)this + 1) = v17;
    *((void *)this + 2) = v25;
    if (v26) {
      operator delete(v26);
    }
  }
  else
  {
    *uint64_t v12 = x;
    v12[1] = y;
    void v12[2] = a3;
    _WORD v12[3] = a4;
    long double v17 = v12 + 6;
    v12[4] = v15;
    v12[5] = a6;
  }
  *((void *)this + 1) = v17;
}

void TI::CP::Path::append(TI::CP::Path *this, const TI::CP::PathSample *a2)
{
  uint64_t v4 = (_OWORD *)*((void *)this + 1);
  unint64_t v5 = *((void *)this + 2);
  if ((unint64_t)v4 >= v5)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *(void *)this) >> 4);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0x555555555555555) {
      abort();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *(void *)this) >> 4);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x2AAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x555555555555555;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    double v14 = (_OWORD *)(v12 + 48 * v9);
    unint64_t v15 = v12 + 48 * v13;
    long long v16 = *(_OWORD *)a2;
    long long v17 = *((_OWORD *)a2 + 2);
    v14[1] = *((_OWORD *)a2 + 1);
    v14[2] = v17;
    _OWORD *v14 = v16;
    double v8 = v14 + 3;
    unint64_t v19 = *(char **)this;
    unint64_t v18 = (char *)*((void *)this + 1);
    if (v18 != *(char **)this)
    {
      do
      {
        long long v20 = *((_OWORD *)v18 - 3);
        long long v21 = *((_OWORD *)v18 - 1);
        *(v14 - 2) = *((_OWORD *)v18 - 2);
        *(v14 - 1) = v21;
        *(v14 - 3) = v20;
        v14 -= 3;
        v18 -= 48;
      }
      while (v18 != v19);
      unint64_t v18 = *(char **)this;
    }
    *(void *)this = v14;
    *((void *)this + 1) = v8;
    *((void *)this + 2) = v15;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    long long v6 = *(_OWORD *)a2;
    long long v7 = *((_OWORD *)a2 + 2);
    v4[1] = *((_OWORD *)a2 + 1);
    v4[2] = v7;
    *uint64_t v4 = v6;
    double v8 = v4 + 3;
  }
  *((void *)this + 1) = v8;
}

void TI::CP::Path::set_sample_is_inflection_point(TI::CP::Path *this, unsigned int a2)
{
  unsigned int v29 = a2;
  unint64_t v5 = (unsigned int *)*((void *)this + 3);
  uint64_t v3 = (unsigned int *)*((void *)this + 4);
  uint64_t v4 = (std::vector<unsigned int> *)((char *)this + 24);
  long long v6 = v3;
  long long v7 = v5;
  double v8 = v3;
  while (v8 != v5)
  {
    unsigned int v9 = *--v8;
    if (v9 <= a2)
    {
      long long v7 = v8 + 1;
      break;
    }
  }
  if (v7 == v3 || *v7 != a2)
  {
    unint64_t v10 = (std::allocator<unsigned int> *)((char *)this + 40);
    unint64_t v11 = *((void *)this + 5);
    if ((unint64_t)v3 >= v11)
    {
      unint64_t v15 = v3 - v5 + 1;
      if (v15 >> 62) {
        abort();
      }
      uint64_t v16 = (char *)v7 - (char *)v5;
      uint64_t v17 = v7 - v5;
      unint64_t v18 = v11 - (void)v5;
      unint64_t v19 = (uint64_t)(v11 - (void)v5) >> 1;
      if (v19 > v15) {
        unint64_t v15 = v19;
      }
      if (v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v20 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v15;
      }
      __v.__end_cap_.__value_ = v10;
      if (v20)
      {
        unint64_t v22 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v20);
      }
      else
      {
        unint64_t v22 = 0;
        uint64_t v21 = 0;
      }
      uint64_t v24 = &v22[v17];
      __v.__first_ = v22;
      __v.__begin_ = v24;
      __v.__end_cap_.__value_ = &v22[v21];
      if (v17 == v21)
      {
        if (v16 < 1)
        {
          if (v5 == v7) {
            unint64_t v26 = 1;
          }
          else {
            unint64_t v26 = v16 >> 1;
          }
          unint64_t v27 = (unsigned int *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v26);
          uint64_t v24 = (unsigned int *)((char *)v27 + (v26 & 0xFFFFFFFFFFFFFFFCLL));
          __v.__first_ = v27;
          __v.__begin_ = v24;
          __v.__end_cap_.__value_ = &v27[v28];
          if (v22) {
            operator delete(v22);
          }
        }
        else
        {
          unint64_t v25 = v17 + 2;
          if (v17 >= -1) {
            unint64_t v25 = v17 + 1;
          }
          v24 -= v25 >> 1;
          __v.__begin_ = v24;
        }
      }
      unsigned int *v24 = a2;
      __v.__end_ = v24 + 1;
      std::vector<unsigned int>::__swap_out_circular_buffer(v4, &__v, v7);
      if (__v.__first_) {
        operator delete(__v.__first_);
      }
    }
    else if (v7 == v3)
    {
      *uint64_t v3 = a2;
      *((void *)this + 4) = v3 + 1;
    }
    else
    {
      unint64_t v12 = v7 + 1;
      for (uint64_t i = v3 - 1; i < v3; ++i)
      {
        unsigned int v14 = *i;
        *v6++ = v14;
      }
      *((void *)this + 4) = v6;
      if (v3 != v12) {
        memmove(&v3[-(v3 - v12)], v7, (char *)v3 - (char *)v12);
      }
      unsigned int v23 = v29;
      if (v7 > &v29) {
        unsigned int v23 = a2;
      }
      *long long v7 = v23;
    }
  }
}

std::vector<unsigned int>::pointer std::vector<unsigned int>::__swap_out_circular_buffer(std::vector<unsigned int> *this, std::__split_buffer<unsigned int> *__v, std::vector<unsigned int>::pointer __p)
{
  std::vector<unsigned int>::pointer begin = __v->__begin_;
  std::vector<unsigned int>::pointer v6 = this->__begin_;
  long long v7 = begin;
  if (this->__begin_ != __p)
  {
    std::vector<unsigned int>::pointer v8 = __p;
    long long v7 = __v->__begin_;
    do
    {
      unsigned int v9 = *--v8;
      *--long long v7 = v9;
    }
    while (v8 != v6);
  }
  __v->__begin_ = v7;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  std::__split_buffer<unsigned int>::pointer v11 = __v->__end_;
  int64_t v12 = (char *)end - (char *)__p;
  if (end != __p)
  {
    memmove(__v->__end_, __p, (char *)end - (char *)__p);
    long long v7 = __v->__begin_;
  }
  __v->__end_ = (std::__split_buffer<unsigned int>::pointer)((char *)v11 + v12);
  uint64_t v13 = this->__begin_;
  this->__begin_ = v7;
  __v->__begin_ = v13;
  unsigned int v14 = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = v14;
  value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
  return begin;
}

void TI::CP::Path::set_last_sample_is_inflection_point(TI::CP::Path *this)
{
}

void TI::CP::Path::resample(CGPoint **this@<X0>, double a2@<D0>, void *a3@<X8>)
{
  *(double *)int64_t v12 = a2;
  v12[1] = 1;
  char v13 = 1;
  uint64_t v14 = 0x3FD3333333333333;
  char v15 = 0;
  int v23 = 0;
  int v24 = 0;
  *(_OWORD *)uint64_t v16 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)unint64_t v19 = 0u;
  *(_OWORD *)std::string __p = 0u;
  long long v21 = 0u;
  char v22 = 0;
  uint64_t v4 = *this;
  unint64_t v5 = this[1];
  while (v4 != v5)
  {
    TI::CP::PathResampler::append_and_resample((TI::CP::PathResampler *)v12, *v4, v4[1].x, v4[1].y, v4[2].y);
    v4 += 3;
  }
  TI::CP::PathResampler::finalize((TI::CP::PathResampler *)v12);
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  std::vector<unsigned int>::pointer v6 = v16[0];
  int64_t v7 = (char *)v16[1] - (char *)v16[0];
  if (v16[1] != v16[0])
  {
    std::vector<TI::CP::PathSample>::__vallocate[abi:nn180100](a3, 0xAAAAAAAAAAAAAAABLL * (v7 >> 4));
    std::vector<unsigned int>::pointer v8 = (char *)a3[1];
    memmove(v8, v6, v7);
    a3[1] = &v8[v7];
  }
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = 0;
  unsigned int v9 = v17[1];
  int64_t v10 = v18 - (unint64_t)v17[1];
  if ((void *)v18 != v17[1])
  {
    std::vector<unsigned int>::__vallocate[abi:nn180100](a3 + 3, v10 >> 2);
    std::__split_buffer<unsigned int>::pointer v11 = (char *)a3[4];
    memmove(v11, v9, v10);
    a3[4] = &v11[v10];
  }
  if (__p[1])
  {
    *(void **)&long long v21 = __p[1];
    operator delete(__p[1]);
  }
  if (v19[0])
  {
    v19[1] = v19[0];
    operator delete(v19[0]);
  }
  if (v17[1])
  {
    *(void **)&long long v18 = v17[1];
    operator delete(v17[1]);
  }
  if (v16[0])
  {
    v16[1] = v16[0];
    operator delete(v16[0]);
  }
}

char *std::vector<TI::CP::PathSample>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556) {
    abort();
  }
  double result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<TI::CP::PathSample>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

uint64_t TI::CP::Path::is_local_max(void *a1, int a2, uint64_t a3, double a4)
{
  unsigned int v6 = a2;
  std::function<double ()>::operator()(*(void *)(a3 + 24), a2);
  double v9 = v8;
  double v10 = *(double *)(*a1 + 48 * v6 + 32);
  uint64_t v11 = 48 * v6 + 32;
  int v12 = v6 - 1;
  while (v11 != 32 && *(double *)(*a1 + v11) > v10 - a4)
  {
    std::function<double ()>::operator()(*(void *)(a3 + 24), v12);
    v11 -= 48;
    --v12;
    if (v13 >= v9) {
      return 0;
    }
  }
  double v14 = v10 + a4;
  while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a1[1] - *a1) >> 4) > v6 + 1 && *(double *)(*a1 + 48 * v6 + 32) < v14)
  {
    std::function<double ()>::operator()(*(void *)(a3 + 24), ++v6);
    if (v15 > v9) {
      return 0;
    }
  }
  return 1;
}

uint64_t std::function<double ()(unsigned int)>::operator()(uint64_t a1, int a2)
{
  int v5 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 48))(a1, &v5);
  }
  uint64_t v3 = (TI::CP::Path *)std::__throw_bad_function_call[abi:nn180100]();
  return TI::CP::Path::curvature(v3, v4);
}

void TI::CP::Path::curvature(TI::CP::Path *this, unsigned int a2)
{
  if (a2 && 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 4) - 1 != a2)
  {
    float v2 = (*(double *)(*(void *)this + 48 * (a2 + 1) + 32) - *(double *)(*(void *)this + 48 * (a2 - 1) + 32))
       * 0.5;
    if (v2 != 0.0) {
      TI::CP::Path::turn_angle(this, a2);
    }
  }
}

uint64_t TI::CP::Path::is_curvature_local_max(TI::CP::Path *this, unsigned int a2, double a3)
{
  v9[4] = *MEMORY[0x1E4F143B8];
  TI::CP::Path::curvature(this, a2);
  if (fabs(v6) <= 0.02) {
    return 0;
  }
  v9[0] = &unk_1F3F71FB0;
  v9[1] = this;
  void v9[3] = v9;
  is_local_maCGFloat x = TI::CP::Path::is_local_max(this, a2, (uint64_t)v9, a3);
  std::__function::__value_func<double ()>::~__value_func[abi:nn180100](v9);
  return is_local_max;
}

void *std::__function::__value_func<double ()(unsigned int)>::~__value_func[abi:nn180100](void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

double std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::operator()(uint64_t a1, unsigned int *a2)
{
  TI::CP::Path::curvature(*(TI::CP::Path **)(a1 + 8), *a2);
  return fabs(v2);
}

uint64_t std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F71FB0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F3F71FB0;
  result[1] = v3;
  return result;
}

void std::__function::__func<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0,std::allocator<TI::CP::Path::is_curvature_local_max(unsigned int,double)::$_0>,double ()(unsigned int)>::~__func()
{
}

double TI::CP::Path::speed(TI::CP::Path *this, unsigned int a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 1) - *(void *)this) >> 4);
  double result = 0.0;
  if (v2 >= 2)
  {
    unsigned int v4 = a2 - 1;
    if (!a2) {
      unsigned int v4 = 0;
    }
    if (v2 - 1 == a2) {
      unsigned int v5 = a2;
    }
    else {
      unsigned int v5 = a2 + 1;
    }
    return (*(double *)(*(void *)this + 48 * v5 + 32) - *(double *)(*(void *)this + 48 * v4 + 32))
         / (*(double *)(*(void *)this + 48 * v5 + 16) - *(double *)(*(void *)this + 48 * v4 + 16));
  }
  return result;
}

double KB::DataFile::DataFile(KB::DataFile *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 3) = 0;
  return result;
}

{
  double result;

  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 3) = 0;
  return result;
}

KB::DataFile *KB::DataFile::DataFile(KB::DataFile *this, const char *__s1, int a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)this = a3;
  *((_DWORD *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = a4;
  *((unsigned char *)this + 8) = 0;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  int64_t v7 = strdup(__s1);
  *((void *)this + 3) = v7;
  int v8 = open_dprotected_np(v7, a3, 3, 0, a4);
  *((_DWORD *)this + 4) = v8;
  if (v8 < 0)
  {
    *((_DWORD *)this + 3) = *__error();
    if (*__error() != 2)
    {
      if (TICanLogMessageAtLevel_onceToken != -1) {
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
      }
      double v9 = TIOSLogFacility();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v11 = *((void *)this + 3);
        int v12 = __error();
        double v13 = strerror(*v12);
        *(_DWORD *)buf = 136315650;
        double v15 = "DataFile";
        __int16 v16 = 2082;
        uint64_t v17 = v11;
        __int16 v18 = 2082;
        unint64_t v19 = v13;
        _os_log_debug_impl(&dword_1E3F0E000, v9, OS_LOG_TYPE_DEBUG, "%s DataFile: file open error: %{public}s, (%{public}s)", buf, 0x20u);
      }
    }
  }
  else
  {
    *((unsigned char *)this + 8) = 1;
  }
  return this;
}

void KB::DataFile::~DataFile(KB::DataFile *this)
{
  int v2 = *((_DWORD *)this + 4);
  if (v2 != -1) {
    close(v2);
  }
  free(*((void **)this + 3));
  *((unsigned char *)this + 8) = 0;
}

double KB::MappedDataFile::MappedDataFile(KB::MappedDataFile *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  return result;
}

{
  double result;

  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  return result;
}

KB::MappedDataFile *KB::MappedDataFile::MappedDataFile(KB::MappedDataFile *this, const char *a2, int a3, uint64_t a4, int a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v8 = KB::DataFile::DataFile(this, a2, a3, a4);
  *((void *)v8 + 4) = 0;
  *((void *)v8 + 5) = 0;
  double v9 = (off_t *)((char *)v8 + 32);
  *((_DWORD *)v8 + 12) = a5;
  *((void *)v8 + 7) = 0;
  if (*((unsigned char *)v8 + 8))
  {
    if (!a5)
    {
      if (TICanLogMessageAtLevel_onceToken != -1) {
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
      }
      uint64_t v17 = TIOSLogFacility();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_11;
      }
      int v24 = *((_DWORD *)this + 12);
      v29.st_dev = 136315394;
      *(void *)&v29.st_mode = "MappedDataFile";
      WORD2(v29.st_ino) = 1024;
      *(_DWORD *)((char *)&v29.st_ino + 6) = v24;
      double v13 = "%s MappedDataFile: illegal protection mode: %d";
      double v14 = &v29;
      double v15 = v17;
      uint32_t v16 = 18;
LABEL_24:
      _os_log_debug_impl(&dword_1E3F0E000, v15, OS_LOG_TYPE_DEBUG, v13, (uint8_t *)v14, v16);
      goto LABEL_11;
    }
    if (stat(a2, &v29))
    {
      if (TICanLogMessageAtLevel_onceToken != -1) {
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
      }
      double v10 = TIOSLogFacility();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_11;
      }
      uint64_t v11 = __error();
      int v12 = strerror(*v11);
      int v25 = 136315394;
      unint64_t v26 = "MappedDataFile";
      __int16 v27 = 2082;
      uint64_t v28 = v12;
      double v13 = "%s MappedDataFile: stat error: %{public}s";
      double v14 = (stat *)&v25;
      double v15 = v10;
      uint32_t v16 = 22;
      goto LABEL_24;
    }
    st_std::string::size_type size = v29.st_size;
    *double v9 = v29.st_size;
    if (st_size)
    {
      unsigned int v20 = getpagesize();
      unint64_t v21 = st_size / v20;
      if (st_size == v21 * v20)
      {
LABEL_21:
        *((void *)this + 5) = st_size;
        KB::MappedDataFile::map(this, 0);
        return this;
      }
      unint64_t v22 = v20 + v20 * v21;
    }
    else
    {
      if ((*((unsigned char *)this + 48) & 2) == 0)
      {
LABEL_11:
        *((unsigned char *)this + 8) = 0;
        return this;
      }
      unint64_t v22 = getpagesize();
    }
    if (v22 != st_size)
    {
      if ((*((unsigned char *)this + 48) & 2) != 0)
      {
        int v23 = getpagesize();
        KB::MappedDataFile::resize(this, (int)v22 / v23);
        return this;
      }
      st_std::string::size_type size = v22;
    }
    goto LABEL_21;
  }
  return this;
}

BOOL KB::MappedDataFile::resize(KB::MappedDataFile *this, int a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  KB::MappedDataFile::sync((uint64_t)this);
  unsigned int v4 = (void *)*((void *)this + 7);
  if (v4)
  {
    munmap(*((void **)this + 7), *((void *)this + 5));
    *((void *)this + 7) = 0;
  }
  int v5 = getpagesize();
  off_t v6 = (v5 * a2) & ~((v5 * a2) >> 31);
  if (ftruncate(*((_DWORD *)this + 4), v6) < 0)
  {
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    int v8 = TIOSLogFacility();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      double v9 = __error();
      double v10 = strerror(*v9);
      int v11 = 136315394;
      int v12 = "resize";
      __int16 v13 = 2082;
      double v14 = v10;
      _os_log_debug_impl(&dword_1E3F0E000, v8, OS_LOG_TYPE_DEBUG, "%s MappedDataFile: error in resize: %{public}s", (uint8_t *)&v11, 0x16u);
    }
    BOOL result = 0;
    *((unsigned char *)this + 8) = 0;
  }
  else
  {
    *((void *)this + 4) = v6;
    *((void *)this + 5) = v6;
    KB::MappedDataFile::map(this, v4);
    return *((unsigned char *)this + 8) != 0;
  }
  return result;
}

void KB::MappedDataFile::map(KB::MappedDataFile *this, void *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = mmap(a2, *((void *)this + 5), *((_DWORD *)this + 12), 1, *((_DWORD *)this + 4), 0);
  *((void *)this + 7) = v3;
  if (v3 == (void *)-1)
  {
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    unsigned int v4 = TIOSLogFacility();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v5 = __error();
      off_t v6 = strerror(*v5);
      int v7 = 136315394;
      int v8 = "map";
      __int16 v9 = 2082;
      double v10 = v6;
      _os_log_debug_impl(&dword_1E3F0E000, v4, OS_LOG_TYPE_DEBUG, "%s MappedDataFile: mmap error: %{public}s", (uint8_t *)&v7, 0x16u);
    }
    *((unsigned char *)this + 8) = 0;
  }
}

uint64_t KB::MappedDataFile::sync(uint64_t this)
{
  if (*(unsigned char *)(this + 8))
  {
    uint64_t v1 = this;
    if (*(unsigned char *)(this + 52))
    {
      if ((*(unsigned char *)(this + 48) & 2) != 0)
      {
        this = msync(*(void **)(this + 56), *(void *)(this + 40), 16);
        *(unsigned char *)(v1 + 52) = 0;
      }
    }
  }
  return this;
}

void KB::MappedDataFile::~MappedDataFile(KB::MappedDataFile *this)
{
  if (*((unsigned char *)this + 8))
  {
    KB::MappedDataFile::sync((uint64_t)this);
    munmap(*((void **)this + 7), *((void *)this + 5));
  }

  KB::DataFile::~DataFile(this);
}

KB::MappedDataFile *KB::ReadOnlyDataFile::ReadOnlyDataFile(KB::ReadOnlyDataFile *this, const char *a2, int a3)
{
  if (a3) {
    int v3 = 16;
  }
  else {
    int v3 = 0;
  }
  return KB::MappedDataFile::MappedDataFile(this, a2, v3, 256, 1);
}

{
  int v3;

  if (a3) {
    int v3 = 16;
  }
  else {
    int v3 = 0;
  }
  return KB::MappedDataFile::MappedDataFile(this, a2, v3, 256, 1);
}

void *KB::InputStream::InputStream(void *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  *BOOL result = *(void *)(a2 + 56);
  result[1] = v3;
  result[2] = a3;
  return result;
}

{
  uint64_t v3;

  uint64_t v3 = *(void *)(a2 + 32);
  *BOOL result = *(void *)(a2 + 56);
  result[1] = v3;
  result[2] = a3;
  return result;
}

void *KB::InputStream::InputStream(void *this, const void *a2, uint64_t a3)
{
  *this = a2;
  this[1] = a3;
  this[2] = 0;
  return this;
}

{
  *this = a2;
  this[1] = a3;
  this[2] = 0;
  return this;
}

uint64_t KB::InputStream::read_null_terminated_string(KB::InputStream *this, KB::String *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)this;
  unint64_t v5 = *((void *)this + 1);
  uint64_t v6 = *((void *)this + 2);
  int v7 = (const char *)(*(void *)this + v6);
  if (v5) {
    unsigned int v8 = strnlen((const char *)(*(void *)this + v6), v5 - v6);
  }
  else {
    unsigned int v8 = strlen((const char *)(*(void *)this + v6));
  }
  if (v6 + (unint64_t)v8 + 1 > v5) {
    return 0;
  }
  unint64_t v9 = v8 + 1 + v6;
  if (v5)
  {
    if (v9 > v5) {
      return 0;
    }
  }
  *((void *)this + 2) = v9;
  if (!v4) {
    return 0;
  }
  KB::String::String((KB::String *)v11, v7, (unsigned __int16)v8);
  KB::String::operator=((uint64_t)a2, (KB::String *)v11);
  if (v12)
  {
    if (v11[6] == 1) {
      free(v12);
    }
  }
  return 1;
}

uint64_t KB::InputStream::step(KB::InputStream *this, unsigned int a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + a2;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this + v2;
  *((void *)this + 2) = v4;
  return v6;
}

uint64_t KB::InputStream::read_unsigned_int(KB::InputStream *this, unsigned int *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 4;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *a2 = bswap32(*(_DWORD *)(v6 + v2));
  return 1;
}

uint64_t KB::InputStream::read_uint24(KB::InputStream *this, unsigned int *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 3;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *a2 = (*(unsigned __int8 *)(v6 + v2) << 16) | (*(unsigned __int8 *)(v6 + v2 + 1) << 8) | *(unsigned __int8 *)(v6 + v2 + 2);
  return 1;
}

uint64_t KB::InputStream::read_data(KB::InputStream *this, void *__dst, size_t a3)
{
  unint64_t v4 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  unint64_t v5 = v3 + a3;
  if (v4) {
    BOOL v6 = v5 > v4;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    return 0;
  }
  uint64_t v7 = *(void *)this;
  *((void *)this + 2) = v5;
  if (!v7) {
    return 0;
  }
  memcpy(__dst, (const void *)(v7 + v3), a3);
  return 1;
}

uint64_t KB::InputStream::read_unsigned_short(KB::InputStream *this, unsigned __int16 *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 2;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *a2 = bswap32(*(unsigned __int16 *)(v6 + v2)) >> 16;
  return 1;
}

uint64_t KB::InputStream::read_short(KB::InputStream *this, __int16 *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 2;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *a2 = bswap32(*(unsigned __int16 *)(v6 + v2)) >> 16;
  return 1;
}

uint64_t KB::InputStream::read_unsigned_char(KB::InputStream *this, unsigned __int8 *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 1;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *a2 = *(unsigned char *)(v6 + v2);
  return 1;
}

uint64_t KB::InputStream::read_unsigned_int_compressed(KB::InputStream *this, unsigned int *a2)
{
  unint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  unint64_t v4 = v3 + 1;
  if (v2) {
    BOOL v5 = v4 > v2;
  }
  else {
    BOOL v5 = 0;
  }
  if (!v5)
  {
    uint64_t v6 = *(void *)this;
    *((void *)this + 2) = v4;
    if (v6)
    {
      int v7 = *(char *)(v6 + v3);
      unsigned int v8 = *(unsigned __int8 *)(v6 + v3);
      *a2 = v8;
      if ((v7 & 0x80000000) == 0) {
        return 1;
      }
      int v10 = (v8 & 0x7F) << 8;
      *a2 = v10;
      unint64_t v11 = v3 + 2;
      if (!v2 || v11 <= v2)
      {
        *((void *)this + 2) = v11;
        int v12 = v10 | *(unsigned __int8 *)(v6 + v4);
        *a2 = v12;
        if ((v8 & 0x40) == 0) {
          return 1;
        }
        int v13 = (v12 & 0x3FFF) << 16;
        *a2 = v13;
        unint64_t v14 = v3 + 4;
        if (!v2 || v14 <= v2)
        {
          *((void *)this + 2) = v14;
          *a2 = v13 | (bswap32(*(unsigned __int16 *)(v6 + v11)) >> 16);
          return 1;
        }
      }
    }
  }
  return 0;
}

uint64_t KB::InputStream::read_float(KB::InputStream *this, float *a2)
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 4;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *(_DWORD *)a2 = bswap32(*(_DWORD *)(v6 + v2));
  return 1;
}

uint64_t KB::InputStream::read_uversioninfo(KB::InputStream *this, unsigned __int8 (*a2)[4])
{
  unint64_t v3 = *((void *)this + 1);
  uint64_t v2 = *((void *)this + 2);
  unint64_t v4 = v2 + 4;
  if (v3) {
    BOOL v5 = v4 > v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    return 0;
  }
  uint64_t v6 = *(void *)this;
  *((void *)this + 2) = v4;
  if (!v6) {
    return 0;
  }
  *(_DWORD *)a2 = *(_DWORD *)(v6 + v2);
  return 1;
}

double KB::WritableDataFile::WritableDataFile(KB::WritableDataFile *this)
{
  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 3) = 0;
  return result;
}

{
  double result;

  *((unsigned char *)this + 8) = 0;
  *(void *)this = 0;
  double result = NAN;
  *(void *)((char *)this + 12) = 0xFFFFFFFF00000000;
  *((void *)this + 3) = 0;
  return result;
}

KB::DataFile *KB::WritableDataFile::WritableDataFile(KB::DataFile *a1, const char *a2, int a3)
{
  return KB::DataFile::DataFile(a1, a2, a3, 384);
}

{
  return KB::DataFile::DataFile(a1, a2, a3, 384);
}

void KB::WritableDataFile::write_data(KB::WritableDataFile *this, char *a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 8))
  {
    int v6 = 0;
    while (1)
    {
      ssize_t v7 = write(*((_DWORD *)this + 4), &a2[v6], a3 - v6);
      if (!v7) {
        break;
      }
      v6 += v7;
      if (v7 < 0)
      {
        if (TICanLogMessageAtLevel_onceToken != -1) {
          dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
        }
        unsigned int v8 = TIOSLogFacility();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = *((void *)this + 3);
          int v10 = __error();
          unint64_t v11 = strerror(*v10);
          int v12 = 136315650;
          int v13 = "write_data";
          __int16 v14 = 2082;
          uint64_t v15 = v9;
          __int16 v16 = 2082;
          uint64_t v17 = v11;
          _os_log_debug_impl(&dword_1E3F0E000, v8, OS_LOG_TYPE_DEBUG, "%s cannot write to file: %{public}s (%{public}s)", (uint8_t *)&v12, 0x20u);
        }
        *((unsigned char *)this + 8) = 0;
        return;
      }
    }
  }
}

void KB::WritableDataFile::write_string(KB::WritableDataFile *this, char *__s)
{
  size_t v4 = strlen(__s);
  KB::WritableDataFile::write_data(this, __s, v4);
  char v5 = 0;
  KB::WritableDataFile::write_data(this, &v5, 1);
}

void KB::WritableDataFile::write_unsigned_char(KB::WritableDataFile *this, char a2)
{
  char v2 = a2;
  KB::WritableDataFile::write_data(this, &v2, 1);
}

void KB::WritableDataFile::write_string(KB::WritableDataFile *this, const KB::String *a2)
{
  uint64_t v3 = *(unsigned __int16 *)a2;
  size_t v4 = (char *)*((void *)a2 + 1);
  if (!v4) {
    size_t v4 = (char *)a2 + 16;
  }
  if (*(_WORD *)a2) {
    char v5 = v4;
  }
  else {
    char v5 = "";
  }
  KB::WritableDataFile::write_data(this, v5, v3);
  char v6 = 0;
  KB::WritableDataFile::write_data(this, &v6, 1);
}

void KB::WritableDataFile::write_unsigned_int(KB::WritableDataFile *this, unsigned int a2)
{
  unsigned int v2 = bswap32(a2);
  KB::WritableDataFile::write_data(this, (char *)&v2, 4);
}

void KB::WritableDataFile::write_uint24(KB::WritableDataFile *this, int a2)
{
  v2[0] = BYTE2(a2);
  v2[1] = BYTE1(a2);
  v2[2] = a2;
  KB::WritableDataFile::write_data(this, v2, 3);
}

void KB::WritableDataFile::write_unsigned_float(KB::WritableDataFile *this, float a2)
{
  unsigned int v2 = bswap32(LODWORD(a2));
  KB::WritableDataFile::write_data(this, (char *)&v2, 4);
}

void KB::WritableDataFile::write_unsigned_short(KB::WritableDataFile *this, unsigned int a2)
{
  __int16 v2 = __rev16(a2);
  KB::WritableDataFile::write_data(this, (char *)&v2, 2);
}

uint64_t KB::WritableDataFile::size_of_unsigned_int_compressed(KB::WritableDataFile *this)
{
  if (this >= 0x3FFF) {
    unsigned int v1 = 4;
  }
  else {
    unsigned int v1 = 2;
  }
  if (this < 0x7F) {
    return 1;
  }
  else {
    return v1;
  }
}

void KB::WritableDataFile::write_unsigned_int_compressed(KB::WritableDataFile *this, unsigned int a2)
{
  uint64_t v3 = this;
  if (a2 <= 0x7E)
  {
    char v6 = a2;
    size_t v4 = &v6;
LABEL_5:
    this = v3;
    uint64_t v5 = 1;
    goto LABEL_6;
  }
  if (a2 <= 0x3FFE)
  {
    char v7 = BYTE1(a2) | 0x80;
    KB::WritableDataFile::write_data(this, &v7, 1);
    char v8 = a2;
    size_t v4 = &v8;
    goto LABEL_5;
  }
  if (a2 > 0x3FFFFFFE)
  {
    int v12 = -1;
    size_t v4 = (char *)&v12;
    uint64_t v5 = 4;
  }
  else
  {
    char v9 = HIBYTE(a2) | 0xC0;
    KB::WritableDataFile::write_data(this, &v9, 1);
    char v10 = BYTE2(a2);
    KB::WritableDataFile::write_data(v3, &v10, 1);
    __int16 v11 = bswap32(a2) >> 16;
    size_t v4 = (char *)&v11;
    this = v3;
    uint64_t v5 = 2;
  }
LABEL_6:
  KB::WritableDataFile::write_data(this, v4, v5);
}

off_t KB::WritableDataFile::tell(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 1);
}

off_t KB::WritableDataFile::seek(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 1);
}

off_t KB::WritableDataFile::seek_to_end(KB::WritableDataFile *this)
{
  return lseek(*((_DWORD *)this + 4), 0, 2);
}

void UnikeySetInputMethod(unsigned int a1)
{
  if (a1 < 3)
  {
LABEL_4:
    uint64_t v1 = pShMem;
    *(_DWORD *)(pShMem + 48) = a1;
    __int16 v2 = (_DWORD *)(v1 + 48);
    if (a1 >= 4)
    {
      _DWORD *v2 = 0;
      uint64_t v3 = "Z";
    }
    else
    {
      uint64_t v3 = (&off_1E6E2A9B0)[a1];
    }
    UkInputProcessor::useBuiltIn((uint64_t)v2, v3);
    goto LABEL_8;
  }
  if (a1 != 4)
  {
    if (a1 != 5) {
      return;
    }
    goto LABEL_4;
  }
  uint64_t v5 = pShMem;
  if (*(_DWORD *)(pShMem + 1076))
  {
    uint64_t v6 = 0;
    *(_DWORD *)(pShMem + 48) = 4;
    do
    {
      *(_OWORD *)(v5 + v6 + 52) = *(_OWORD *)(v5 + v6 + 1080);
      v6 += 16;
    }
    while (v6 != 1024);
LABEL_8:
    uint64_t v4 = MyKbEngine;
    *(_DWORD *)(MyKbEngine + 3112) = -1;
    *(void *)(v4 + 28) = 0xFFFFFFFFLL;
    *(unsigned char *)(v4 + 3116) = 0;
  }
}

uint64_t UnikeySetCapsState(uint64_t result, int a2)
{
  UnikeyCapsLockOn = a2;
  UnikeyShiftPressed = result;
  return result;
}

uint64_t UnikeySetOutputCharset(int a1)
{
  *(_DWORD *)(pShMem + 2104) = a1;
  uint64_t v1 = MyKbEngine;
  *(_DWORD *)(MyKbEngine + 3112) = -1;
  *(void *)(v1 + 28) = 0xFFFFFFFFLL;
  *(unsigned char *)(v1 + 3116) = 0;
  return 1;
}

double UnikeySetOptions(uint64_t a1)
{
  uint64_t v1 = pShMem;
  *(_OWORD *)(pShMem + 12) = *(_OWORD *)a1;
  *(_DWORD *)(v1 + 28) = *(_DWORD *)(a1 + 16);
  double result = *(double *)(a1 + 28);
  *(double *)(v1 + 40) = result;
  return result;
}

__n128 UnikeyGetOptions(uint64_t a1)
{
  int v1 = *(_DWORD *)(pShMem + 44);
  __n128 result = *(__n128 *)(pShMem + 28);
  *(_OWORD *)a1 = *(_OWORD *)(pShMem + 12);
  *(__n128 *)(a1 + 16) = result;
  *(_DWORD *)(a1 + 32) = v1;
  return result;
}

double CreateDefaultUnikeyOptions(uint64_t a1)
{
  *(_DWORD *)a1 = 1;
  *(void *)(a1 + 12) = 0;
  *(void *)(a1 + 4) = 0;
  *(void *)&double result = 1;
  *(void *)(a1 + 28) = 1;
  return result;
}

void UnikeySetup()
{
  if (!MyKbEngine) {
    operator new();
  }
  SetupUnikeyEngine();
  operator new();
}

_DWORD *UnikeyCheckKbCase(_DWORD *result, int *a2)
{
  *double result = UnikeyShiftPressed;
  *a2 = UnikeyCapsLockOn;
  return result;
}

uint64_t UnikeyCleanup()
{
  if (MyKbEngine) {
    MEMORY[0x1E4E7BC20](MyKbEngine, 0x10B0C407BB03D36);
  }
  uint64_t result = pShMem;
  if (pShMem) {
    uint64_t result = MEMORY[0x1E4E7BC20](pShMem, 0x1000C401C44D41ELL);
  }
  MyKbEngine = 0;
  pShMem = 0;
  return result;
}

uint64_t UnikeyFilter(unsigned int a1)
{
  UnikeyBufChars = 1024;
  return UkEngine::process(MyKbEngine, a1, &UnikeyBackspaces, UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

uint64_t UnikeyPutChar(unsigned int a1)
{
  int v1 = (UkEngine *)MyKbEngine;
  UkInputProcessor::keyCodeToEvent(*(void *)(MyKbEngine + 8) + 48, a1, v3);
  uint64_t result = UkEngine::processAppend(v1, v3);
  UnikeyBufChars = 0;
  UnikeyBackspaces = 0;
  return result;
}

double UnikeyResetBuf()
{
  uint64_t v0 = MyKbEngine;
  *(_DWORD *)(MyKbEngine + 3112) = -1;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(v0 + 28) = 0xFFFFFFFFLL;
  *(unsigned char *)(v0 + 3116) = 0;
  return result;
}

void UnikeySetSingleMode()
{
  *(_DWORD *)(MyKbEngine + 32) = 1;
}

BOOL UnikeyBackspacePress()
{
  UnikeyBufChars = 1024;
  return UkEngine::processBackspace((UkEngine *)MyKbEngine, &UnikeyBackspaces, UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

uint64_t UnikeyRestoreKeyStrokes()
{
  UnikeyBufChars = 1024;
  return UkEngine::restoreKeyStrokes(MyKbEngine, &UnikeyBackspaces, (uint64_t)UnikeyBuf, &UnikeyBufChars, &UnikeyOutput);
}

id rangesOfStringInString(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if ([v8 length])
  {
    char v10 = objc_opt_new();
    unint64_t v11 = [v8 length];
    uint64_t v12 = 0;
    unint64_t v13 = v11;
    do
    {
      uint64_t v14 = objc_msgSend(v8, "rangeOfString:options:range:locale:", v7, a3, v12, v13, v9);
      if (!v15) {
        break;
      }
      uint64_t v16 = v14;
      uint64_t v17 = v15;
      uint64_t v18 = objc_msgSend(MEMORY[0x1E4F29238], "valueWithRange:", v14, v15);
      [v10 addObject:v18];

      uint64_t v12 = v16 + v17;
      unint64_t v13 = v11 - (v16 + v17);
    }
    while (v11 > v16 + v17);
  }
  else
  {
    char v10 = (void *)MEMORY[0x1E4F1CBF0];
  }

  return v10;
}

id TICreateNamedEntityStore(void *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = [a2 items];
  uint64_t v5 = objc_msgSend(objc_alloc(MEMORY[0x1E4F1CA48]), "initWithCapacity:", objc_msgSend(v4, "count"));
  long long v36 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  id v6 = v4;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v36 objects:v46 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v37;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v37 != v9) {
          objc_enumerationMutation(v6);
        }
        objc_msgSend(*(id *)(*((void *)&v36 + 1) + 8 * i), "core_appendEntitiesToArray:", v5);
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v36 objects:v46 count:16];
    }
    while (v8);
  }

  unint64_t v11 = [MEMORY[0x1E4FAE2D8] sharedInputModeController];
  uint64_t v12 = [v11 enabledInputModeIdentifiers];

  unint64_t v13 = [MEMORY[0x1E4F1CA80] set];
  long long v32 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  id v14 = v12;
  uint64_t v15 = [v14 countByEnumeratingWithState:&v32 objects:v45 count:16];
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = *(void *)v33;
    do
    {
      for (uint64_t j = 0; j != v16; ++j)
      {
        if (*(void *)v33 != v17) {
          objc_enumerationMutation(v14);
        }
        unint64_t v19 = TIInputModeGetLanguageWithRegion();
        if (v19) {
          [v13 addObject:v19];
        }
      }
      uint64_t v16 = [v14 countByEnumeratingWithState:&v32 objects:v45 count:16];
    }
    while (v16);
  }

  unsigned int v20 = (void *)[objc_alloc(MEMORY[0x1E4F6F4D0]) initWithName:v3];
  [v20 setMinimumWordLength:1];
  if (objc_opt_respondsToSelector()) {
    [v20 setTreatHyphenatedWordAsPhrase:1];
  }
  unint64_t v21 = (void *)[v13 copy];
  [v20 setAcceptedLanguages:v21];

  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    int64x2_t v42 = "TICreateNamedEntityStore";
    __int16 v43 = 2112;
    uint64_t v44 = v13;
    _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Setting the accepted languages as : %@", buf, 0x16u);
  }
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id v22 = v5;
  uint64_t v23 = [v22 countByEnumeratingWithState:&v28 objects:v40 count:16];
  if (v23)
  {
    uint64_t v24 = v23;
    uint64_t v25 = *(void *)v29;
    do
    {
      for (uint64_t k = 0; k != v24; ++k)
      {
        if (*(void *)v29 != v25) {
          objc_enumerationMutation(v22);
        }
        objc_msgSend(v20, "addEntity:isDurable:", *(void *)(*((void *)&v28 + 1) + 8 * k), 1, (void)v28);
      }
      uint64_t v24 = [v22 countByEnumeratingWithState:&v28 objects:v40 count:16];
    }
    while (v24);
  }

  return v20;
}

uint64_t __Block_byref_object_copy__2023(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2024(uint64_t a1)
{
}

void TIOSLogLines(const __CFString *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFLocaleRef v2 = CFLocaleCopyCurrent();
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  v11.length = CFStringGetLength(a1);
  v11.location = 0;
  uint64_t v4 = CFStringTokenizerCreate(v3, a1, v11, 2uLL, v2);
  if (CFStringTokenizerAdvanceToNextToken(v4))
  {
    uint64_t v5 = MEMORY[0x1E4F14500];
    do
    {
      CFRange CurrentTokenRange = CFStringTokenizerGetCurrentTokenRange(v4);
      CFStringRef v6 = CFStringCreateWithSubstring(v3, a1, CurrentTokenRange);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        CFStringRef v9 = v6;
        _os_log_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
      }
      CFStringTokenizerTokenType Token = CFStringTokenizerAdvanceToNextToken(v4);
      if (v6) {
        CFRelease(v6);
      }
    }
    while (Token);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v2) {
    CFRelease(v2);
  }
}

void createTapToRadarDraft(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  getTapToRadarServiceClass();
  if (objc_opt_class())
  {
    id v4 = objc_alloc_init((Class)getRadarDraftClass());
    uint64_t v5 = [NSString stringWithFormat:@"TextInput fault: %@", a1];
    [v4 setTitle:v5];

    CFStringRef v6 = (void *)[objc_alloc((Class)getRadarComponentClass()) initWithName:@"TextInput" version:@"All" identifier:1139080];
    [v4 setComponent:v6];

    [v4 setClassification:2];
    [v4 setReproducibility:5];
    if (a2) {
      [v4 setProblemDescription:a2];
    }
    uint64_t v7 = [(id)getTapToRadarServiceClass() shared];
    id v11 = 0;
    [v7 createDraft:v4 forProcessNamed:@"Keyboard" withDisplayReason:a1 error:&v11];
    id v8 = v11;

    if (v8)
    {
      CFStringRef v9 = [NSString stringWithFormat:@"Tap-to-Radar Error: %@", v8];
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
      {
        uint64_t v10 = [v9 cStringUsingEncoding:4];
        *(_DWORD *)buf = 136315394;
        unint64_t v13 = "createTapToRadarDraft";
        __int16 v14 = 2080;
        uint64_t v15 = v10;
        _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Tap-to-radar error %s", buf, 0x16u);
      }
    }
  }
}

Class initRadarComponent(void)
{
  if (TapToRadarKitLibrary(void)::sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2151);
  }
  Class result = objc_getClass("RadarComponent");
  classRadarComponent = (uint64_t)result;
  getRadarComponentClass = (uint64_t (*)(void))RadarComponentFunction;
  return result;
}

id RadarComponentFunction(void)
{
  return (id)classRadarComponent;
}

void *___ZL20TapToRadarKitLibraryv_block_invoke()
{
  Class result = dlopen("/AppleInternal/Library/Frameworks/TapToRadarKit.framework/TapToRadarKit", 2);
  TapToRadarKitLibrary(void)::sLib = (uint64_t)result;
  return result;
}

Class initRadarDraft(void)
{
  if (TapToRadarKitLibrary(void)::sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2151);
  }
  Class result = objc_getClass("RadarDraft");
  classRadarDraft = (uint64_t)result;
  getRadarDraftClass = (uint64_t (*)(void))RadarDraftFunction;
  return result;
}

id RadarDraftFunction(void)
{
  return (id)classRadarDraft;
}

Class initTapToRadarService(void)
{
  if (TapToRadarKitLibrary(void)::sOnce != -1) {
    dispatch_once(&TapToRadarKitLibrary(void)::sOnce, &__block_literal_global_2151);
  }
  Class result = objc_getClass("TapToRadarService");
  classTapToRadarService = (uint64_t)result;
  getTapToRadarServiceClass = (uint64_t (*)(void))TapToRadarServiceFunction;
  return result;
}

id TapToRadarServiceFunction(void)
{
  return (id)classTapToRadarService;
}

uint64_t ___typologyProfileOptInManager_block_invoke()
{
  _typologyProfileOptInManager_optInManager = objc_alloc_init(TITypologyProfileOptInManager);

  return MEMORY[0x1F41817F8]();
}

KB::DictionaryCursors *KB::DictionaryCursors::DictionaryCursors(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  id v4 = (const KB::StaticDictionary *)*((void *)a2 + 1);
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
  *((_DWORD *)this + 8) = 0;
  KB::StaticDictionaryCursor::reset(this, v4);
  (*(void (**)(void))(**((void **)a2 + 3) + 16))(*((void *)a2 + 3));
  unsigned int v5 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 3) + 72))(*((void *)a2 + 3), 0xFFFFFFFFLL);
  *((_DWORD *)this + 16) = v5;
  *((float *)this + 17) = 65536.0 / (float)((float)v5 + 65536.0);
  *((_DWORD *)this + 18) = 0;
  return this;
}

float KB::DictionaryCursors::prior_probability_of_static_trie(KB::DictionaryCursors *this, unsigned int a2)
{
  return 65536.0 / (float)((float)a2 + 65536.0);
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2, void (****a3)(void))
{
  for (uint64_t i = 0; i != 24; i += 8)
  {
    uint64_t v7 = *(const void **)(a2 + i);
    *(void *)(a1 + i) = v7;
    if (v7)
    {
      CFRetain(v7);
      *(void *)(a1 + i) = v7;
    }
  }
  long long v8 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v8;
  (***a3)();
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return a1;
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  for (uint64_t i = 0; i != 24; i += 8)
  {
    uint64_t v7 = *(const void **)(a2 + i);
    *(void *)(a1 + i) = v7;
    if (v7)
    {
      CFRetain(v7);
      *(void *)(a1 + i) = v7;
    }
  }
  long long v8 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v8;
  uint64_t v9 = *a3;
  *a3 = 0;
  *(void *)(a1 + 56) = v9;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 48);
  return a1;
}

KB::DictionaryCursors *KB::DictionaryCursors::DictionaryCursors(KB::DictionaryCursors *this, const KB::DictionaryCursors *a2)
{
  for (uint64_t i = 0; i != 24; i += 8)
  {
    unsigned int v5 = *(const void **)((char *)a2 + i);
    *(void *)((char *)this + i) = v5;
    if (v5)
    {
      CFRetain(v5);
      *(void *)((char *)this + i) = v5;
    }
  }
  long long v6 = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 36) = *(_OWORD *)((char *)a2 + 36);
  *(_OWORD *)((char *)this + 24) = v6;
  (***((void (****)(void))a2 + 7))(*((void *)a2 + 7));
  *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
  *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
  *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
  return this;
}

uint64_t KB::DictionaryCursors::DictionaryCursors(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = 0; i != 24; i += 8)
  {
    unsigned int v5 = *(const void **)(a2 + i);
    *(void *)(a1 + i) = v5;
    if (v5)
    {
      CFRetain(v5);
      *(void *)(a1 + i) = v5;
    }
  }
  long long v6 = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
  *(_OWORD *)(a1 + 24) = v6;
  uint64_t v7 = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = 0;
  *(void *)(a1 + 56) = v7;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  return a1;
}

uint64_t KB::DictionaryCursors::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v4 = 0;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    do
    {
      KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + v4), *(CFTypeRef *)(a2 + v4));
      v4 += 8;
    }
    while (v4 != 24);
    long long v5 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 24) = v5;
    (***(void (****)(uint64_t *__return_ptr))(a2 + 56))(&v10);
    uint64_t v6 = v10;
    uint64_t v10 = 0;
    uint64_t v7 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v6;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
      uint64_t v8 = v10;
      uint64_t v10 = 0;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 16))(v8);
      }
    }
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  }
  return a1;
}

{
  uint64_t v4;
  long long v5;
  uint64_t v6;
  uint64_t v7;

  if (a1 != a2)
  {
    uint64_t v4 = 0;
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    do
    {
      KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(a1 + v4), *(CFTypeRef *)(a2 + v4));
      v4 += 8;
    }
    while (v4 != 24);
    long long v5 = *(_OWORD *)(a2 + 24);
    *(_OWORD *)(a1 + 36) = *(_OWORD *)(a2 + 36);
    *(_OWORD *)(a1 + 24) = v5;
    uint64_t v6 = *(void *)(a2 + 56);
    *(void *)(a2 + 56) = 0;
    uint64_t v7 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = v6;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 16))(v7);
    }
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  }
  return a1;
}

uint64_t KB::DictionaryCursors::clear_dynamic_cursors(KB::DictionaryCursors *this)
{
  return (*(uint64_t (**)(void, void *))(**((void **)this + 7) + 48))(*((void *)this + 7), &__block_literal_global_17804);
}

uint64_t KB::DictionaryCursors::finishes_dynamic_words(KB::DynamicDictionaryCursor **this)
{
  return KB::DynamicDictionaryCursor::has_entries(this[7]);
}

uint64_t KB::DictionaryCursors::dynamic_has_children(KB::DynamicDictionaryCursor **this)
{
  return KB::DynamicDictionaryCursor::has_children(this[7]);
}

void KB::DictionaryCursors::probability_of_static_trie(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  if (*((_DWORD *)this + 16)) {
    (*(uint64_t (**)(void, void))(**((void **)this + 7) + 80))(*((void *)this + 7), *((void *)a2 + 3));
  }
}

double KB::DictionaryCursors::dynamic_partial_probability(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  if (!*((_DWORD *)this + 16)) {
    return 0.0;
  }
  *(float *)&double result = (float)(*(unsigned int (**)(void, void))(**((void **)this + 7) + 80))(*((void *)this + 7), *((void *)a2 + 3))/ (float)*((unsigned int *)this + 16);
  return result;
}

void KB::DictionaryCursors::probability_of_static_trie_given_termination(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
}

uint64_t KB::DictionaryCursors::dynamic_termination_probability(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 7) + 72))(*((void *)this + 7), *((void *)a2 + 3));
}

uint64_t KB::DictionaryCursors::dynamic_subtree_usage_count(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 7) + 80))(*((void *)this + 7), *((void *)a2 + 3));
}

float KB::DictionaryCursors::termination_probability(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2)
{
  KB::DictionaryCursors::probability_of_static_trie(this, a2);
  float v5 = v4;
  float v6 = KB::StaticDictionaryCursor::termination_probability(this);
  return (float)((float)(1.0 - v5)
               * (*(float (**)(void, void))(**((void **)this + 7) + 72))(*((void *)this + 7), *((void *)a2 + 3)))+ (float)(v5 * v6);
}

uint64_t KB::DictionaryCursors::for_each_dynamic_trie_node(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 40))();
}

uint64_t KB::DictionaryCursors::dynamic_entry_count(KB::DictionaryCursors *this, const DictionaryContainer *a2)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 7) + 88))(*((void *)this + 7), *((void *)a2 + 3));
}

float KB::DictionaryCursors::advance(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2, const KB::String *a3)
{
  if (*((void *)a3 + 1)) {
    float v5 = (char *)*((void *)a3 + 1);
  }
  else {
    float v5 = (char *)a3 + 16;
  }
  uint64_t v15 = v5;
  int v6 = *(unsigned __int16 *)a3;
  int v16 = 0;
  int v17 = v6;
  unsigned int v18 = 0;
  KB::String::iterator::initialize((uint64_t *)&v15);
  id v11 = v5;
  int v12 = v6;
  int v13 = v6;
  int v14 = 0;
  KB::String::iterator::initialize((uint64_t *)&v11);
  int v7 = v16;
  int v8 = v12;
  float v9 = 1.0;
  while (v7 != v8)
  {
    float v9 = v9 * KB::DictionaryCursors::advance(this, a2, v18);
    KB::String::iterator::operator++((uint64_t *)&v15);
    int v7 = v16;
  }
  return v9;
}

float KB::DictionaryCursors::advance(KB::DictionaryCursors *this, const KB::DictionaryContainer *a2, unsigned int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int IsRoot = LXCursorIsRoot();
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t))(**((void **)a2 + 3) + 72))(*((void *)a2 + 3), 0xFFFFFFFFLL);
  if (IsRoot)
  {
    uint64_t v8 = v7;
    float v9 = 65536.0 / (float)((float)v7 + 65536.0);
  }
  else
  {
    uint64_t v8 = (*(uint64_t (**)(void, void))(**((void **)this + 7) + 80))(*((void *)this + 7), *((void *)a2 + 3));
    KB::DictionaryCursors::probability_of_static_trie(this, a2);
    float v9 = v10;
  }
  float v11 = KB::StaticDictionaryCursor::advance(this, a3);
  uint64_t v12 = *((void *)this + 7);
  uint64_t v13 = *((void *)a2 + 3);
  KB::String::String((uint64_t)v18, a3);
  float v14 = (*(float (**)(uint64_t, uint64_t, unsigned char *, uint64_t))(*(void *)v12 + 56))(v12, v13, v18, v8);
  if (v19 && v18[6] == 1) {
    free(v19);
  }
  if ((KB::StaticDictionaryCursor::valid(this) & 1) == 0
    && !KB::DynamicDictionaryCursor::valid(*((KB::DynamicDictionaryCursor **)this + 7)))
  {
    a3 = 0;
  }
  float v15 = 1.0;
  if (IsRoot) {
    float v15 = 1.0 / v9;
  }
  *((_DWORD *)this + 18) = a3;
  *((float *)this + 17) = v9;
  *((_DWORD *)this + 16) = v8;
  float v16 = (1.0 - v9) * v14;
  return v15 * (float)((float)(v9 * v11) + v16);
}

void KB::DictionaryCursors::fill_vector_with_static_trie_children(KB::StaticDictionaryCursor *this, uint64_t *a2, uint64_t a3)
{
  uint64_t v7 = *a2;
  for (uint64_t i = a2[1]; i != v7; std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(i))
    i -= 80;
  a2[1] = v7;
  KB::StaticDictionaryCursor::children(this, &v24);
  uint64_t v8 = v24;
  uint64_t v9 = v25;
  unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((v25 - v24) >> 3);
  if (0xCCCCCCCCCCCCCCCDLL * ((a2[2] - *a2) >> 4) < v10)
  {
    if (v10 > 0x333333333333333) {
LABEL_24:
    }
      abort();
    uint64_t v11 = a2[1] - *a2;
    long long v30 = a2 + 2;
    unint64_t v26 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v10);
    __int16 v27 = (char *)v26 + v11;
    long long v28 = (char *)v26 + v11;
    long long v29 = &v26[10 * v12];
    std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(a2, &v26);
    std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v26);
  }
  for (; v8 != v9; v8 += 56)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a3 + 24) + 24))(&v23);
    unint64_t v13 = a2[1];
    unint64_t v14 = a2[2];
    if (v13 >= v14)
    {
      unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v13 - *a2) >> 4);
      unint64_t v17 = v16 + 1;
      if (v16 + 1 > 0x333333333333333) {
        goto LABEL_24;
      }
      unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - *a2) >> 4);
      if (2 * v18 > v17) {
        unint64_t v17 = 2 * v18;
      }
      if (v18 >= 0x199999999999999) {
        unint64_t v19 = 0x333333333333333;
      }
      else {
        unint64_t v19 = v17;
      }
      long long v30 = a2 + 2;
      if (v19) {
        unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(v19);
      }
      else {
        uint64_t v20 = 0;
      }
      uint64_t v21 = v19 + 80 * v16;
      unint64_t v26 = (void **)v19;
      __int16 v27 = (char *)v21;
      long long v29 = (void **)(v19 + 80 * v20);
      KB::DictionaryCursors::DictionaryCursors(v21, v8, &v23);
      long long v28 = (char *)(v21 + 80);
      std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(a2, &v26);
      uint64_t v15 = a2[1];
      std::__split_buffer<KB::DictionaryCursors>::~__split_buffer((uint64_t)&v26);
    }
    else
    {
      uint64_t v15 = KB::DictionaryCursors::DictionaryCursors(v13, v8, &v23) + 80;
    }
    a2[1] = v15;
    uint64_t v22 = v23;
    uint64_t v23 = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 16))(v22);
    }
  }
  unint64_t v26 = (void **)&v24;
  std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](&v26);
}

void std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 16))(v2);
  }
  for (uint64_t i = 16; i != -8; i -= 8)
  {
    float v4 = *(const void **)(a1 + i);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + i) = 0;
  }
}

void std::vector<KB::StaticDictionaryCursor>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  int v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    float v4 = (char *)v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        int v6 = v4;
        v4 -= 56;
        for (uint64_t i = -40; i != -64; i -= 8)
        {
          uint64_t v8 = *(const void **)&v6[i];
          if (v8) {
            CFRelease(v8);
          }
          *(void *)&v6[i] = 0;
        }
      }
      while (v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::DictionaryCursors>>(unint64_t a1)
{
  if (a1 >= 0x333333333333334) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(80 * a1);
}

uint64_t std::vector<KB::DictionaryCursors>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 80;
    uint64_t result = KB::DictionaryCursors::DictionaryCursors(result - 80, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::DictionaryCursors>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 80;
    std::__destroy_at[abi:nn180100]<KB::DictionaryCursors,0>(i - 80);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void KB::DictionaryCursors::derive_static_words(KB::StaticDictionaryCursor *this, uint64_t a2)
{
}

void KB::DictionaryCursors::merge_dynamic_children_with_static_siblings(KB::DictionaryCursors *a1, void *a2, const KB::DictionaryContainer *a3)
{
  uint64_t v6 = *((void *)a1 + 7);
  uint64_t v7 = *((void *)a3 + 1);
  uint64_t v8 = *((void *)a3 + 3);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 0x40000000;
  v16[2] = ___ZNK2KB23DynamicDictionaryCursor35merge_children_with_static_siblingsERNSt3__16vectorINS_17DictionaryCursorsENS1_9allocatorIS3_EEEERKNS_16StaticDictionaryERKNS_17DynamicDictionaryE_block_invoke;
  v16[3] = &__block_descriptor_tmp_9_17819;
  v16[4] = a2;
  v16[5] = v7;
  v16[6] = v8;
  (*(void (**)(uint64_t, void *))(*(void *)v6 + 40))(v6, v16);
  int v9 = (*(uint64_t (**)(void, void))(**((void **)a1 + 7) + 80))(*((void *)a1 + 7), *((void *)a3 + 3));
  KB::DictionaryCursors::probability_of_static_trie(a1, a3);
  uint64_t v11 = a2[1] - *a2;
  if (v11)
  {
    unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * (v11 >> 4);
    unint64_t v13 = (_DWORD *)(*a2 + 68);
    unsigned int v14 = 1;
    do
    {
      *(v13 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v9;
      *unint64_t v13 = v10;
      v13 += 20;
    }
    while (v12 > v14++);
  }
}

void KB::DynamicDictionaryContainer::do_enumerate_entries(KB::DynamicDictionary *a1, uint64_t a2)
{
  uint64_t v16 = a2;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    RootCursor = (const void *)LXLexiconCreateRootCursor();
    uint64_t v17 = MEMORY[0x1E4F143A8];
    uint64_t v18 = 0x40000000;
    unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v20 = &__block_descriptor_tmp_24;
    uint64_t v21 = &v16;
    int v22 = 5;
    LXCursorEnumerateEntriesRecursively();
    if (RootCursor) {
      CFRelease(RootCursor);
    }
  }
  uint64_t v4 = *((void *)a1 + 15) - *((void *)a1 + 14);
  if (v4)
  {
    uint64_t v5 = 0;
    unint64_t v6 = v4 >> 3;
    unsigned int v7 = 1;
    do
    {
      if ((*(uint64_t (**)(KB::DynamicDictionary *, uint64_t))(*(void *)a1 + 88))(a1, v5))
      {
        uint64_t v8 = (const void *)LXLexiconCreateRootCursor();
        uint64_t v17 = MEMORY[0x1E4F143A8];
        uint64_t v18 = 0x40000000;
        unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        uint64_t v20 = &__block_descriptor_tmp_24;
        uint64_t v21 = &v16;
        int v22 = 0;
        LXCursorEnumerateEntriesRecursively();
        if (v8) {
          CFRelease(v8);
        }
      }
      uint64_t v5 = v7;
    }
    while (v6 > v7++);
  }
  if (*((void *)a1 + 1))
  {
    int v10 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v17 = MEMORY[0x1E4F143A8];
    uint64_t v18 = 0x40000000;
    unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v20 = &__block_descriptor_tmp_24;
    uint64_t v21 = &v16;
    int v22 = 1;
    LXCursorEnumerateEntriesRecursively();
    if (v10) {
      CFRelease(v10);
    }
  }
  if (*((void *)a1 + 2))
  {
    uint64_t v11 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v17 = MEMORY[0x1E4F143A8];
    uint64_t v18 = 0x40000000;
    unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v20 = &__block_descriptor_tmp_24;
    uint64_t v21 = &v16;
    int v22 = 2;
    LXCursorEnumerateEntriesRecursively();
    if (v11) {
      CFRelease(v11);
    }
  }
  unint64_t v12 = (void **)*((void *)a1 + 3);
  if (v12)
  {
    unint64_t v13 = *v12;
    if (v13)
    {
      if (*v13)
      {
        unsigned int v14 = (const void *)LXLexiconCreateRootCursor();
        uint64_t v17 = MEMORY[0x1E4F143A8];
        uint64_t v18 = 0x40000000;
        unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        uint64_t v20 = &__block_descriptor_tmp_24;
        uint64_t v21 = &v16;
        int v22 = 3;
        LXCursorEnumerateEntriesRecursively();
        if (v14) {
          CFRelease(v14);
        }
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(a1))
  {
    uint64_t v15 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v17 = MEMORY[0x1E4F143A8];
    uint64_t v18 = 0x40000000;
    unint64_t v19 = ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v20 = &__block_descriptor_tmp_24;
    uint64_t v21 = &v16;
    int v22 = 4;
    LXCursorEnumerateEntriesRecursively();
    if (v15) {
      CFRelease(v15);
    }
  }
}

uint64_t ___ZZNK2KB26DynamicDictionaryContainer20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 32) + 16))(**(void **)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

uint64_t KB::DynamicDictionary::named_entity_lexicon(KB::DynamicDictionary *this)
{
  if ((*(unsigned int (**)(KB::DynamicDictionary *))(*(void *)this + 32))(this))
  {
    uint64_t v2 = (*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0);
    if (*(_WORD *)v2)
    {
      if (*(void *)(v2 + 8)) {
        uint64_t v3 = *(const char **)(v2 + 8);
      }
      else {
        uint64_t v3 = (const char *)(v2 + 16);
      }
    }
    else
    {
      uint64_t v3 = "";
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return TITransientLexiconManagerGetNamedEntitiesForLocale((uint64_t)v3);
}

void *KB::DynamicDictionaryContainer::get_persistent_custom_trie_for_locale(void *a1, void *a2)
{
  uint64_t v4 = a1 + 24;
  uint64_t result = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(a1 + 24, a2);
  if (result)
  {
    unint64_t v6 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(v4, a2);
    if (!v6) {
      abort();
    }
    uint64_t v7 = v6[6];
    uint64_t v8 = *(uint64_t (**)(void *, uint64_t))(*a1 + 88);
    return (void *)v8(a1, v7);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(void *a1, void *a2)
{
  if (a2[1]) {
    uint64_t v4 = (KB::String *)a2[1];
  }
  else {
    uint64_t v4 = (KB::String *)(a2 + 2);
  }
  unsigned int v5 = KB::String::hash(v4, (const char *)*(unsigned __int16 *)a2);
  unint64_t v6 = a1[1];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v8.i16[0] = vaddlv_u8(v8);
  unint64_t v9 = v8.u32[0];
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (v6 <= v5) {
      unint64_t v10 = v5 % v6;
    }
  }
  else
  {
    unint64_t v10 = (v6 - 1) & v5;
  }
  uint64_t v11 = *(void **)(*a1 + 8 * v10);
  if (!v11) {
    return 0;
  }
  unint64_t v12 = (void *)*v11;
  if (*v11)
  {
    do
    {
      unint64_t v13 = v12[1];
      if (v13 == v7)
      {
        if (v12 + 2 == a2 || KB::String::equal((KB::String *)(v12 + 2), (const KB::String *)a2, 1)) {
          return v12;
        }
      }
      else
      {
        if (v9 > 1)
        {
          if (v13 >= v6) {
            v13 %= v6;
          }
        }
        else
        {
          v13 &= v6 - 1;
        }
        if (v13 != v10) {
          return 0;
        }
      }
      unint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  return v12;
}

uint64_t KB::DynamicDictionaryContainer::get_persistent_custom_trie(KB::DynamicDictionaryContainer *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 14);
  if (a2 >= (*((void *)this + 15) - v2) >> 3) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t KB::DynamicDictionaryContainer::get_persistent_custom_trie_count(KB::DynamicDictionaryContainer *this)
{
  return (uint64_t)(*((void *)this + 15) - *((void *)this + 14)) >> 3;
}

unint64_t KB::DynamicDictionaryContainer::get_total_usage_count(KB::DynamicDictionaryContainer *this, int a2)
{
  uint64_t v4 = *((void *)this + 14);
  uint64_t v3 = *((void *)this + 15);
  if (a2 == -1)
  {
    uint64_t v13 = v3 - v4;
    if (v13)
    {
      uint64_t v14 = 0;
      unint64_t v15 = v13 >> 3;
      if (v15 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v15;
      }
      float v7 = 0.0;
      do
      {
        float v17 = *(float *)(*((void *)this + 21) + 4 * v14);
        if (*(void *)(*((void *)this + 14) + 8 * v14) && (uint64_t RootCursor = LXLexiconCreateRootCursor()) != 0)
        {
          unint64_t v19 = (const void *)RootCursor;
          int v20 = LXCursorUsageCountRecursive();
          unsigned int v21 = v20 & ~(v20 >> 31);
          CFRelease(v19);
        }
        else
        {
          unsigned int v21 = 0;
        }
        float v7 = v7 + (float)(v17 * (float)v21);
        ++v14;
      }
      while (v16 != v14);
      goto LABEL_24;
    }
LABEL_23:
    float v7 = 0.0;
    goto LABEL_24;
  }
  if (v3 == v4) {
    goto LABEL_23;
  }
  unint64_t v6 = 0;
  float v7 = 0.0;
  uint64_t v8 = 160;
  do
  {
    if (*(_DWORD *)(*((void *)this + 11) + v8) == a2)
    {
      if (*(void *)(v4 + 8 * v6) && (uint64_t v9 = LXLexiconCreateRootCursor()) != 0)
      {
        unint64_t v10 = (const void *)v9;
        int v11 = LXCursorUsageCountRecursive();
        unsigned int v12 = v11 & ~(v11 >> 31);
        CFRelease(v10);
      }
      else
      {
        unsigned int v12 = 0;
      }
      float v7 = v7 + (float)v12;
      uint64_t v4 = *((void *)this + 14);
      uint64_t v3 = *((void *)this + 15);
    }
    ++v6;
    v8 += 176;
  }
  while (v6 < (v3 - v4) >> 3);
LABEL_24:
  float v22 = 0.0;
  float v23 = 0.0;
  if (*((void *)this + 1))
  {
    uint64_t v24 = LXLexiconCreateRootCursor();
    if (v24)
    {
      uint64_t v25 = (const void *)v24;
      int v26 = LXCursorUsageCountRecursive();
      unsigned int v27 = v26 & ~(v26 >> 31);
      CFRelease(v25);
      float v23 = (float)v27;
    }
  }
  if (*((void *)this + 2))
  {
    uint64_t v28 = LXLexiconCreateRootCursor();
    if (v28)
    {
      long long v29 = (const void *)v28;
      int v30 = LXCursorUsageCountRecursive();
      unsigned int v31 = v30 & ~(v30 >> 31);
      CFRelease(v29);
      float v22 = (float)v31;
    }
  }
  long long v32 = (void **)*((void *)this + 3);
  float v33 = 0.0;
  float v34 = 0.0;
  if (v32)
  {
    long long v35 = *v32;
    if (v35)
    {
      if (*v35)
      {
        uint64_t v36 = LXLexiconCreateRootCursor();
        if (v36)
        {
          long long v37 = (const void *)v36;
          int v38 = LXCursorUsageCountRecursive();
          unsigned int v39 = v38 & ~(v38 >> 31);
          CFRelease(v37);
          float v34 = (float)v39;
        }
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(this))
  {
    uint64_t v40 = LXLexiconCreateRootCursor();
    if (v40)
    {
      char v41 = (const void *)v40;
      int v42 = LXCursorUsageCountRecursive();
      unsigned int v43 = v42 & ~(v42 >> 31);
      CFRelease(v41);
      float v33 = (float)v43;
    }
  }
  float v44 = 0.0;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    uint64_t v45 = LXLexiconCreateRootCursor();
    if (v45)
    {
      unint64_t v46 = (const void *)v45;
      int v47 = LXCursorUsageCountRecursive();
      unsigned int v48 = v47 & ~(v47 >> 31);
      CFRelease(v46);
      float v44 = (float)v48;
    }
  }
  return llroundf(ceilf((float)((float)((float)((float)(v7 + v23) + v22) + v34) + v33) + v44));
}

uint64_t KB::DynamicDictionaryContainer::get_user_frequency(KB::DynamicDictionaryContainer *this, _LXLexicon *a2, KB::String *a3)
{
  uint64_t v5 = *((void *)this + 14);
  uint64_t v6 = *((void *)this + 15);
  if (a3 == -1)
  {
    if (v6 == v5)
    {
      float v13 = 0.0;
    }
    else
    {
      unint64_t v12 = 0;
      float v13 = 0.0;
      do
      {
        KB::DynamicDictionary::entry_matching_string(a2, &v18);
        float v14 = *(float *)(*((void *)this + 21) + 4 * v12);
        unint64_t v15 = v18;
        if (v18)
        {
          float v13 = v13 + (float)(v14 * (float)LXEntryGetUsageCount());
          CFRelease(v15);
        }
        else
        {
          float v13 = v13 + (float)(v14 * 0.0);
        }
        ++v12;
      }
      while (v12 < (uint64_t)(*((void *)this + 15) - *((void *)this + 14)) >> 3);
    }
    uint64_t v17 = llroundf(ceilf(v13));
    if (v17 >= 0x7FFFFFFF) {
      return 0x7FFFFFFFLL;
    }
    else {
      return v17;
    }
  }
  else
  {
    if (v6 == v5)
    {
      unsigned int v9 = 0;
    }
    else
    {
      int v7 = (int)a3;
      unint64_t v8 = 0;
      unsigned int v9 = 0;
      uint64_t v10 = 160;
      do
      {
        if (*(_DWORD *)(*((void *)this + 11) + v10) == v7)
        {
          KB::DynamicDictionary::entry_matching_string(a2, &v18);
          int v11 = v18;
          if (v18)
          {
            v9 += LXEntryGetUsageCount();
            CFRelease(v11);
          }
          uint64_t v5 = *((void *)this + 14);
          uint64_t v6 = *((void *)this + 15);
        }
        ++v8;
        v10 += 176;
      }
      while (v8 < (v6 - v5) >> 3);
    }
    if (v9 >= 0x7FFFFFFF) {
      return 0x7FFFFFFFLL;
    }
    else {
      return v9;
    }
  }
}

void KB::DynamicDictionary::entry_matching_string(_LXLexicon *a1@<X1>, void *a2@<X8>)
{
  uint64_t v8 = 0;
  unsigned int v9 = &v8;
  uint64_t v10 = 0x3002000000;
  int v11 = __Block_byref_object_copy__2373;
  unint64_t v12 = __Block_byref_object_dispose__2374;
  CFTypeRef cf = 0;
  KB::cf_string_impl<KB::String>(&v7, (unsigned __int16 *)a1);
  CFStringRef v5 = v7;
  LXLexiconEnumerateEntriesForString();
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)v9[5];
  *a2 = v6;
  if (v6)
  {
    CFRetain(v6);
    *a2 = v6;
  }
  _Block_object_dispose(&v8, 8);
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t __Block_byref_object_copy__2373(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  *(void *)(result + 40) = v2;
  return result;
}

void __Block_byref_object_dispose__2374(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)(a1 + 40) = 0;
}

void ___ZN2KB17DynamicDictionary21entry_matching_stringEPK10_LXLexiconRKNS_6StringEj_block_invoke(uint64_t a1, const void *a2, unsigned char *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  KB::Word::Word((uint64_t)v10, (uint64_t)a2, *(_DWORD *)(a1 + 48));
  KB::Word::capitalized_string((KB::Word *)v10, (uint64_t)v8);
  BOOL v6 = KB::String::equal((KB::String *)v8, *(const KB::String **)(a1 + 40), 1);
  if (v9) {
    BOOL v7 = v8[6] == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v9);
  }
  if (v6)
  {
    KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a2);
    *a3 = 1;
  }
  KB::Word::~Word((KB::Word *)v10);
}

void KB::DynamicDictionaryContainer::get_word_with_string(KB::DynamicDictionaryContainer *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  memset(v28, 0, sizeof(v28));
  memset(v31, 0, sizeof(v31));
  *(_OWORD *)&v38[8] = 0u;
  uint64_t v36 = 0;
  long long v34 = 0uLL;
  memset(v35, 0, sizeof(v35));
  long long v32 = 0u;
  memset(v33, 0, sizeof(v33));
  long long v29 = 0u;
  long long v30 = 0u;
  v28[1] = 16;
  LOBYTE(v28[3]) = 0;
  *(void *)&long long v30 = 0x3F80000000000000;
  DWORD2(v30) = 1065353216;
  v31[1] = 16;
  LOBYTE(v31[3]) = 0;
  __asm { FMOV            V9.2S, #1.0 }
  *(void *)&long long v32 = _D9;
  v35[1] = 16;
  LOBYTE(v35[3]) = 0;
  long long v37 = 0u;
  *(_OWORD *)int v38 = 0u;
  *(_DWORD *)&unsigned char v38[16] = 1065353216;
  if (*((void *)this + 15) != *((void *)this + 14))
  {
    unint64_t v9 = 0;
    unsigned int v10 = 1;
    do
    {
      int v11 = *(_DWORD *)(*((void *)this + 11) + 176 * v9 + 160);
      KB::entry_from_lexicon(&v15);
      unint64_t v12 = v15;
      if (v15)
      {
        KB::Word::Word((uint64_t)v16, (uint64_t)v15, v11);
        CFRelease(v12);
        if (LOWORD(v16[0]))
        {
          if (v28[0])
          {
            *(int32x2_t *)((char *)v33 + 12) = vadd_s32(*(int32x2_t *)((char *)v22 + 12), *(int32x2_t *)((char *)v33 + 12));
          }
          else
          {
            KB::String::operator=((KB::String *)v28, (KB::String *)v16);
            KB::ByteString::operator=((unsigned __int16 *)&v29, (unsigned __int16 *)&v17);
            *(void *)&long long v30 = v18;
            DWORD2(v30) = v19;
            KB::String::operator=((KB::String *)v31, (KB::String *)v20);
            long long v32 = v21;
            v33[0] = v22[0];
            v33[1] = v22[1];
            long long v34 = v23;
            KB::String::operator=((KB::String *)v35, (KB::String *)v24);
            LOBYTE(v36) = v25;
            *(_DWORD *)&unsigned char v38[16] = *(_DWORD *)&v27[16];
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(&v37, *(void **)v27);
            DWORD2(v32) |= 0x2000000u;
          }
        }
      }
      else
      {
        memset(v16, 0, sizeof(v16));
        memset(v20, 0, sizeof(v20));
        *(_OWORD *)&uint8_t v27[8] = 0u;
        uint64_t v25 = 0;
        long long v23 = 0uLL;
        memset(v24, 0, sizeof(v24));
        long long v17 = 0u;
        WORD1(v16[0]) = 16;
        BYTE6(v16[0]) = 0;
        uint64_t v18 = 0x3F80000000000000;
        uint64_t v19 = 1065353216;
        WORD1(v20[0]) = 16;
        BYTE6(v20[0]) = 0;
        long long v21 = _D9;
        memset(v22, 0, sizeof(v22));
        v24[1] = 16;
        LOBYTE(v24[3]) = 0;
        long long v26 = 0u;
        *(_OWORD *)unsigned int v27 = 0u;
        *(_DWORD *)&v27[16] = 1065353216;
      }
      KB::Word::~Word((KB::Word *)v16);
      unint64_t v9 = v10++;
    }
    while (v9 < (uint64_t)(*((void *)this + 15) - *((void *)this + 14)) >> 3);
  }
  float v13 = v16;
  KB::DynamicDictionary::word_from_transient_lexicon_with_string(this, (uint64_t)v16);
  if (v28[0])
  {
    if (LOWORD(v16[0]))
    {
      DWORD2(v32) = DWORD2(v32) & 0x7FFCFEFF | DWORD2(v21) & 0x80030100;
      *(_DWORD *)&unsigned char v38[16] = *(_DWORD *)&v27[16];
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(&v37, *(void **)v27);
    }
    float v13 = v28;
  }
  KB::Word::Word(a3, (uint64_t)v13);
  KB::Word::~Word((KB::Word *)v16);
  KB::Word::~Word((KB::Word *)v28);
}

double KB::Word::Word(KB::Word *this)
{
  *(_DWORD *)this = 0x100000;
  *((_WORD *)this + 2) = 0;
  *((unsigned char *)this + 6) = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((unsigned char *)this + 16) = 0;
  *((_WORD *)this + 16) = 0;
  *((void *)this + 6) = 0x3F80000000000000;
  *((_DWORD *)this + 14) = 1065353216;
  *((_DWORD *)this + 16) = 0x100000;
  *((_WORD *)this + 34) = 0;
  *((unsigned char *)this + 70) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)this + 12) = _D0;
  *((_DWORD *)this + 26) = 0;
  *((void *)this + 19) = 0;
  double result = 0.0;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 0;
  *((_DWORD *)this + 40) = 0x100000;
  *((_WORD *)this + 82) = 0;
  *((unsigned char *)this + 166) = 0;
  *((void *)this + 2TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((unsigned char *)this + 176) = 0;
  *((unsigned char *)this + 192) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 58) = 1065353216;
  return result;
}

double KB::DynamicDictionary::word_from_transient_lexicon_with_string@<D0>(KB::DynamicDictionary *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v5 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0) + 160);
  KB::DynamicDictionary::word_from_supplemental_lexicon((uint64_t)this, v14);
  if (!v15)
  {
    if (*((void *)this + 1))
    {
      KB::entry_from_lexicon(v14);
      BOOL v7 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v7);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        double result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        unsigned int v8 = *(_DWORD *)(a2 + 104) | 0x20000;
LABEL_33:
        *(_DWORD *)(a2 + 104) = v8;
        return result;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    if (*((void *)this + 2))
    {
      KB::entry_from_lexicon(v14);
      unint64_t v9 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v9);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        double result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        unsigned int v8 = *(_DWORD *)(a2 + 104) | 0x80000000;
        goto LABEL_33;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    unsigned int v10 = (void **)*((void *)this + 3);
    if (v10)
    {
      int v11 = *v10;
      if (v11)
      {
        if (*v11)
        {
          KB::entry_from_lexicon(v14);
          unint64_t v12 = (const void *)v14[0];
          if (v14[0])
          {
            KB::Word::Word(a2, v14[0], v5);
            CFRelease(v12);
          }
          else
          {
            *(_OWORD *)(a2 + 208) = 0u;
            *(_OWORD *)(a2 + 224) = 0u;
            *(_OWORD *)(a2 + 176) = 0u;
            *(_OWORD *)(a2 + 192) = 0u;
            *(_OWORD *)(a2 + 144) = 0u;
            *(_OWORD *)(a2 + 160) = 0u;
            *(_OWORD *)(a2 + 112) = 0u;
            *(_OWORD *)(a2 + 128) = 0u;
            *(_OWORD *)(a2 + 80) = 0u;
            *(_OWORD *)(a2 + 96) = 0u;
            *(_OWORD *)(a2 + 48) = 0u;
            *(_OWORD *)(a2 + 64) = 0u;
            *(_OWORD *)(a2 + 16) = 0u;
            *(_OWORD *)(a2 + 32) = 0u;
            *(_OWORD *)a2 = 0u;
            double result = KB::Word::Word((KB::Word *)a2);
          }
          if (*(_WORD *)a2)
          {
            unsigned int v8 = *(_DWORD *)(a2 + 104) | 0x10000;
            goto LABEL_33;
          }
          KB::Word::~Word((KB::Word *)a2);
        }
      }
    }
    if (KB::DynamicDictionary::named_entity_lexicon(this))
    {
      KB::entry_from_lexicon(v14);
      float v13 = (const void *)v14[0];
      if (v14[0])
      {
        KB::Word::Word(a2, v14[0], v5);
        CFRelease(v13);
      }
      else
      {
        *(_OWORD *)(a2 + 208) = 0u;
        *(_OWORD *)(a2 + 224) = 0u;
        *(_OWORD *)(a2 + 176) = 0u;
        *(_OWORD *)(a2 + 192) = 0u;
        *(_OWORD *)(a2 + 144) = 0u;
        *(_OWORD *)(a2 + 160) = 0u;
        *(_OWORD *)(a2 + 112) = 0u;
        *(_OWORD *)(a2 + 128) = 0u;
        *(_OWORD *)(a2 + 80) = 0u;
        *(_OWORD *)(a2 + 96) = 0u;
        *(_OWORD *)(a2 + 48) = 0u;
        *(_OWORD *)(a2 + 64) = 0u;
        *(_OWORD *)(a2 + 16) = 0u;
        *(_OWORD *)(a2 + 32) = 0u;
        *(_OWORD *)a2 = 0u;
        double result = KB::Word::Word((KB::Word *)a2);
      }
      if (*(_WORD *)a2)
      {
        unsigned int v8 = *(_DWORD *)(a2 + 104) | 0x100;
        goto LABEL_33;
      }
      KB::Word::~Word((KB::Word *)a2);
    }
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)a2 = 0u;
    return KB::Word::Word((KB::Word *)a2);
  }
  KB::Word::Word((KB::Word *)a2, v14);
  if (v15) {
    KB::Word::~Word((KB::Word *)v14);
  }
  return result;
}

void KB::entry_from_lexicon(void *a1)
{
  uint64_t RootCursor = (const void *)LXLexiconCreateRootCursor();
  uint64_t v3 = LXCursorCreateByAdvancingWithUTF8();
  if (!v3)
  {
    *a1 = 0;
    if (!RootCursor) {
      return;
    }
    goto LABEL_7;
  }
  uint64_t v4 = (const void *)v3;
  uint64_t v6 = 0;
  BOOL v7 = &v6;
  uint64_t v8 = 0x3002000000;
  unint64_t v9 = __Block_byref_object_copy__2373;
  unsigned int v10 = __Block_byref_object_dispose__2374;
  CFTypeRef cf = 0;
  LXCursorEnumerateEntries();
  int v5 = (const void *)v7[5];
  *a1 = v5;
  if (v5)
  {
    CFRetain(v5);
    *a1 = v5;
  }
  _Block_object_dispose(&v6, 8);
  if (cf) {
    CFRelease(cf);
  }
  CFRelease(v4);
  if (RootCursor) {
LABEL_7:
  }
    CFRelease(RootCursor);
}

uint64_t KB::Word::Word(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = KB::String::operator=(a1, (KB::String *)a2);
  unsigned int v5 = *(unsigned __int16 *)(a2 + 32);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
  if (v5 >= 0xF) {
    *(_WORD *)(a2 + 32) = 0;
  }
  uint64_t v6 = *(void *)(a2 + 48);
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
  *(void *)(a1 + 48) = v6;
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 70) = 0;
  *(void *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, (KB::String *)(a2 + 64));
  long long v7 = *(_OWORD *)(a2 + 96);
  long long v8 = *(_OWORD *)(a2 + 112);
  long long v9 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(a1 + 144) = v9;
  *(_OWORD *)(a1 + 96) = v7;
  *(_OWORD *)(a1 + 112) = v8;
  *(_DWORD *)(a1 + 160) = 0x100000;
  *(_WORD *)(a1 + 164) = 0;
  *(unsigned char *)(a1 + 166) = 0;
  *(void *)(a1 + 168) = 0;
  KB::String::operator=(a1 + 160, (KB::String *)(a2 + 160));
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  uint64_t v10 = *(void *)(a2 + 200);
  *(void *)(a2 + 200) = 0;
  *(void *)(a1 + 200) = v10;
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a2 + 208) = 0;
  uint64_t v13 = *(void *)(a2 + 216);
  uint64_t v12 = a2 + 216;
  uint64_t v11 = v13;
  *(void *)(a1 + 216) = v13;
  uint64_t v14 = *(void *)(v12 + 8);
  *(void *)(a1 + 224) = v14;
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(v12 + 16);
  if (v14)
  {
    unint64_t v15 = *(void *)(v11 + 8);
    unint64_t v16 = *(void *)(a1 + 208);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16) {
        v15 %= v16;
      }
    }
    else
    {
      v15 &= v16 - 1;
    }
    *(void *)(v10 + 8 * v15) = a1 + 216;
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = 0;
  }
  return a1;
}

void ___ZN2KBL18entry_from_lexiconERKNS_6StringEPK10_LXLexiconU13block_pointerFbS2_S2_E_block_invoke(void *a1, const void *a2, unsigned char *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFStringRef v6 = (const __CFString *)LXEntryCopyString();
  KB::utf8_string(v6, (uint64_t)v9);
  uint64_t v7 = a1[4];
  if (v7)
  {
    if (((*(uint64_t (**)(uint64_t, unsigned char *, void))(v7 + 16))(v7, v9, a1[6]) & 1) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  long long v8 = (const KB::String *)a1[6];
  if (v9 == (unsigned char *)v8 || KB::String::equal((KB::String *)v9, v8, 1))
  {
LABEL_6:
    KB::retain_ptr<__CFDictionary const*>::operator=((const void **)(*(void *)(a1[5] + 8) + 40), a2);
    *a3 = 1;
  }
LABEL_7:
  if (v10 && v9[6] == 1) {
    free(v10);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void KB::DynamicDictionary::word_from_supplemental_lexicon(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords() && (KB::entry_from_lexicon(&v10), (uint64_t v4 = v10) != 0))
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, 0);
    KB::Word::Word((uint64_t)v11, (uint64_t)v4, *(_DWORD *)(v5 + 160));
    TILXEntryGetSupplementalItemIdentifiers((uint64_t)v7);
    int v14 = v9;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v13, v8);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v7);
    if (TILXEntryIsPartOfHyphenatedWord()) {
      int v6 = 16;
    }
    else {
      int v6 = 0;
    }
    unsigned int v12 = v12 & 0xFFFFFFEF | v6;
    KB::Word::Word((uint64_t)a2, (uint64_t)v11);
    a2[240] = 1;
    KB::Word::~Word((KB::Word *)v11);
    CFRelease(v4);
  }
  else
  {
    *a2 = 0;
    a2[240] = 0;
  }
}

uint64_t KB::DynamicDictionaryContainer::get_lexicon_info(KB::DynamicDictionaryContainer *this, uint64_t a2)
{
  return *((void *)this + 11) + 176 * a2;
}

uint64_t KB::DynamicDictionaryContainer::do_load(uint64_t a1, unsigned __int16 **a2, int a3)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 112) == *(void *)(a1 + 120))
  {
    uint64_t v5 = (KB::String **)*a2;
    long long v87 = a2[1];
    if (*a2 != v87)
    {
      if (a3) {
        uint64_t v7 = "Siri-TextInput-Dynamic.";
      }
      else {
        uint64_t v7 = "TextInput-Dynamic.";
      }
      int v85 = (uint64_t *)(a1 + 88);
      __s = (char *)v7;
      uint64_t v82 = a1 + 104;
      uint64_t v83 = a1 + 128;
      long long v84 = (void *)(a1 + 208);
      while (1)
      {
        KB::String::String((KB::String *)v93, __s);
        KB::String::append(v93, (const KB::String *)v5);
        KB::cf_string_impl<KB::String>(&v89, v93);
        CFStringRef v8 = v89;
        View = (const void *)LXLexiconRepositoryCreateView();
        if (v8) {
          CFRelease(v8);
        }
        uint64_t v11 = *(void **)(a1 + 120);
        unint64_t v10 = *(void *)(a1 + 128);
        if ((unint64_t)v11 >= v10)
        {
          uint64_t v13 = *(void *)(a1 + 112);
          uint64_t v14 = ((uint64_t)v11 - v13) >> 3;
          if ((unint64_t)(v14 + 1) >> 61) {
            goto LABEL_151;
          }
          uint64_t v15 = v10 - v13;
          uint64_t v16 = v15 >> 2;
          if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
            uint64_t v16 = v14 + 1;
          }
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v17 = v16;
          }
          uint64_t v92 = v83;
          if (v17) {
            unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
          }
          else {
            uint64_t v18 = 0;
          }
          uint64_t v19 = (void *)(v17 + 8 * v14);
          unint64_t v20 = v17 + 8 * v18;
          long long v91 = (char *)v20;
          *uint64_t v19 = View;
          if (View)
          {
            CFRetain(View);
            *uint64_t v19 = View;
          }
          unsigned int v12 = v19 + 1;
          v90.i64[1] = (uint64_t)(v19 + 1);
          float v22 = *(void **)(a1 + 112);
          long long v21 = *(void **)(a1 + 120);
          if (v21 == v22)
          {
            int64x2_t v24 = vdupq_n_s64((unint64_t)v21);
          }
          else
          {
            do
            {
              uint64_t v23 = *--v21;
              void *v21 = 0;
              *--uint64_t v19 = v23;
            }
            while (v21 != v22);
            int64x2_t v24 = *(int64x2_t *)(a1 + 112);
            unsigned int v12 = (void *)v90.i64[1];
            unint64_t v20 = (unint64_t)v91;
          }
          *(void *)(a1 + 112) = v19;
          *(void *)(a1 + 120) = v12;
          int64x2_t v90 = v24;
          uint64_t v25 = *(char **)(a1 + 128);
          *(void *)(a1 + 128) = v20;
          long long v91 = v25;
          CFStringRef v89 = (CFStringRef)v24.i64[0];
          std::__split_buffer<KB::retain_ptr<_LXLexicon const*>>::~__split_buffer((uint64_t)&v89);
        }
        else
        {
          void *v11 = View;
          if (View)
          {
            CFRetain(View);
            void *v11 = View;
          }
          unsigned int v12 = v11 + 1;
        }
        *(void *)(a1 + 120) = v12;
        unint64_t v26 = *(void *)(a1 + 96);
        unint64_t v27 = *(void *)(a1 + 104);
        if (v26 >= v27)
        {
          uint64_t v29 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v26 - *v85) >> 4);
          unint64_t v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) > 0x1745D1745D1745DLL) {
            goto LABEL_151;
          }
          unint64_t v31 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v27 - *v85) >> 4);
          if (2 * v31 > v30) {
            unint64_t v30 = 2 * v31;
          }
          CFStringRef v32 = (const __CFString *)(v31 >= 0xBA2E8BA2E8BA2ELL ? 0x1745D1745D1745DLL : v30);
          uint64_t v92 = v82;
          if (v32) {
            CFStringRef v32 = (const __CFString *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>((unint64_t)v32);
          }
          else {
            uint64_t v33 = 0;
          }
          uint64_t v34 = (uint64_t)v32 + 176 * v29;
          CFStringRef v89 = v32;
          v90.i64[0] = v34;
          long long v91 = (char *)v32 + 176 * v33;
          std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(v34, (uint64_t)v5);
          v90.i64[1] = v34 + 176;
          std::vector<KB::LexiconInfo>::__swap_out_circular_buffer(v85, &v89);
          uint64_t v28 = *(void *)(a1 + 96);
          std::__split_buffer<KB::LexiconInfo>::~__split_buffer((uint64_t)&v89);
        }
        else
        {
          uint64_t v28 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(v26, (uint64_t)v5)+ 176;
        }
        *(void *)(a1 + 96) = v28;
        uint64_t v36 = *(char **)(a1 + 176);
        unint64_t v35 = *(void *)(a1 + 184);
        CFTypeRef cf = View;
        if ((unint64_t)v36 >= v35)
        {
          int v38 = *(char **)(a1 + 168);
          uint64_t v39 = (v36 - v38) >> 2;
          unint64_t v40 = v39 + 1;
          if ((unint64_t)(v39 + 1) >> 62) {
LABEL_151:
          }
            abort();
          uint64_t v41 = v35 - (void)v38;
          if (v41 >> 1 > v40) {
            unint64_t v40 = v41 >> 1;
          }
          BOOL v42 = (unint64_t)v41 >= 0x7FFFFFFFFFFFFFFCLL;
          unint64_t v43 = 0x3FFFFFFFFFFFFFFFLL;
          if (!v42) {
            unint64_t v43 = v40;
          }
          if (v43)
          {
            unint64_t v43 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v43);
            int v38 = *(char **)(a1 + 168);
            uint64_t v36 = *(char **)(a1 + 176);
          }
          else
          {
            uint64_t v44 = 0;
          }
          uint64_t v45 = (_DWORD *)(v43 + 4 * v39);
          _DWORD *v45 = *((_DWORD *)v5 + 42);
          long long v37 = v45 + 1;
          while (v36 != v38)
          {
            int v46 = *((_DWORD *)v36 - 1);
            v36 -= 4;
            *--uint64_t v45 = v46;
          }
          *(void *)(a1 + 168) = v45;
          *(void *)(a1 + 176) = v37;
          *(void *)(a1 + 184) = v43 + 4 * v44;
          if (v38) {
            operator delete(v38);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v36 = *((_DWORD *)v5 + 42);
          long long v37 = v36 + 4;
        }
        *(void *)(a1 + 176) = v37;
        uint64_t v47 = *(void *)(a1 + 112);
        uint64_t v48 = *(void *)(a1 + 120);
        if (v5[1]) {
          uint64_t v49 = v5[1];
        }
        else {
          uint64_t v49 = (KB::String *)(v5 + 2);
        }
        unsigned int v50 = KB::String::hash(v49, (const char *)*(unsigned __int16 *)v5);
        unint64_t v51 = v50;
        unint64_t v52 = *(void *)(a1 + 200);
        if (v52)
        {
          uint64_t v53 = v48;
          uint8x8_t v54 = (uint8x8_t)vcnt_s8((int8x8_t)v52);
          v54.i16[0] = vaddlv_u8(v54);
          unint64_t v55 = v54.u32[0];
          if (v54.u32[0] > 1uLL)
          {
            unint64_t v3 = v50;
            if (v52 <= v50) {
              unint64_t v3 = v50 % v52;
            }
          }
          else
          {
            unint64_t v3 = (v52 - 1) & v50;
          }
          uint64_t v56 = *(void ***)(*(void *)(a1 + 192) + 8 * v3);
          if (v56)
          {
            for (uint64_t i = *v56; i; uint64_t i = (void *)*i)
            {
              unint64_t v58 = i[1];
              if (v58 == v51)
              {
                if (i + 2 == v5 || KB::String::equal((KB::String *)(i + 2), (const KB::String *)v5, 1))
                {
                  uint64_t v48 = v53;
                  uint64_t v74 = cf;
                  goto LABEL_135;
                }
              }
              else
              {
                if (v55 > 1)
                {
                  if (v58 >= v52) {
                    v58 %= v52;
                  }
                }
                else
                {
                  v58 &= v52 - 1;
                }
                if (v58 != v3) {
                  break;
                }
              }
            }
          }
          uint64_t v48 = v53;
        }
        uint64_t i = operator new(0x38uLL);
        void *i = 0;
        i[1] = v51;
        KB::String::String((KB::String *)(i + 2), (const KB::String *)v5);
        i[6] = 0;
        float v59 = (float)(unint64_t)(*(void *)(a1 + 216) + 1);
        float v60 = *(float *)(a1 + 224);
        if (!v52 || (float)(v60 * (float)v52) < v59) {
          break;
        }
LABEL_125:
        uint64_t v78 = *(void *)(a1 + 192);
        long long v79 = *(void **)(v78 + 8 * v3);
        if (v79)
        {
          void *i = *v79;
          uint64_t v74 = cf;
        }
        else
        {
          void *i = *v84;
          void *v84 = i;
          *(void *)(v78 + 8 * v3) = v84;
          uint64_t v74 = cf;
          if (!*i) {
            goto LABEL_134;
          }
          unint64_t v80 = *(void *)(*i + 8);
          if ((v52 & (v52 - 1)) != 0)
          {
            if (v80 >= v52) {
              v80 %= v52;
            }
          }
          else
          {
            v80 &= v52 - 1;
          }
          long long v79 = (void *)(*(void *)(a1 + 192) + 8 * v80);
        }
        *long long v79 = i;
LABEL_134:
        ++*(void *)(a1 + 216);
LABEL_135:
        i[6] = ((v48 - v47) >> 3) - 1;
        if (v74) {
          CFRelease(v74);
        }
        if (v95 && v94 == 1) {
          free(v95);
        }
        v5 += 22;
        if (v5 == (KB::String **)v87) {
          return 1;
        }
      }
      BOOL v61 = (v52 & (v52 - 1)) != 0;
      if (v52 < 3) {
        BOOL v61 = 1;
      }
      unint64_t v62 = v61 | (2 * v52);
      unint64_t v63 = vcvtps_u32_f32(v59 / v60);
      if (v62 <= v63) {
        int8x8_t prime = (int8x8_t)v63;
      }
      else {
        int8x8_t prime = (int8x8_t)v62;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      }
      unint64_t v52 = *(void *)(a1 + 200);
      if (*(void *)&prime > v52) {
        goto LABEL_90;
      }
      if (*(void *)&prime < v52)
      {
        unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 216) / *(float *)(a1 + 224));
        if (v52 < 3 || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v52), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
        {
          unint64_t v71 = std::__next_prime(v71);
        }
        else
        {
          uint64_t v73 = 1 << -(char)__clz(v71 - 1);
          if (v71 >= 2) {
            unint64_t v71 = v73;
          }
        }
        if (*(void *)&prime <= v71) {
          int8x8_t prime = (int8x8_t)v71;
        }
        if (*(void *)&prime >= v52)
        {
          unint64_t v52 = *(void *)(a1 + 200);
        }
        else
        {
          if (prime)
          {
LABEL_90:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v65 = operator new(8 * *(void *)&prime);
            unint64_t v66 = *(void **)(a1 + 192);
            *(void *)(a1 + 192) = v65;
            if (v66) {
              operator delete(v66);
            }
            uint64_t v67 = 0;
            *(int8x8_t *)(a1 + 200) = prime;
            do
              *(void *)(*(void *)(a1 + 192) + 8 * v67++) = 0;
            while (*(void *)&prime != v67);
            unint64_t v68 = (void *)*v84;
            if (*v84)
            {
              unint64_t v69 = v68[1];
              uint8x8_t v70 = (uint8x8_t)vcnt_s8(prime);
              v70.i16[0] = vaddlv_u8(v70);
              if (v70.u32[0] > 1uLL)
              {
                if (v69 >= *(void *)&prime) {
                  v69 %= *(void *)&prime;
                }
              }
              else
              {
                v69 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)(a1 + 192) + 8 * v69) = v84;
              uint64_t v75 = (void *)*v68;
              if (*v68)
              {
                do
                {
                  unint64_t v76 = v75[1];
                  if (v70.u32[0] > 1uLL)
                  {
                    if (v76 >= *(void *)&prime) {
                      v76 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v76 &= *(void *)&prime - 1;
                  }
                  if (v76 != v69)
                  {
                    uint64_t v77 = *(void *)(a1 + 192);
                    if (!*(void *)(v77 + 8 * v76))
                    {
                      *(void *)(v77 + 8 * v76) = v68;
                      goto LABEL_116;
                    }
                    *unint64_t v68 = *v75;
                    *uint64_t v75 = **(void **)(*(void *)(a1 + 192) + 8 * v76);
                    **(void **)(*(void *)(a1 + 192) + 8 * v76) = v75;
                    uint64_t v75 = v68;
                  }
                  unint64_t v76 = v69;
LABEL_116:
                  unint64_t v68 = v75;
                  uint64_t v75 = (void *)*v75;
                  unint64_t v69 = v76;
                }
                while (v75);
              }
            }
            unint64_t v52 = (unint64_t)prime;
            goto LABEL_120;
          }
          long long v81 = *(void **)(a1 + 192);
          *(void *)(a1 + 192) = 0;
          if (v81) {
            operator delete(v81);
          }
          unint64_t v52 = 0;
          *(void *)(a1 + 200) = 0;
        }
      }
LABEL_120:
      if ((v52 & (v52 - 1)) != 0)
      {
        if (v52 <= v51) {
          unint64_t v3 = v51 % v52;
        }
        else {
          unint64_t v3 = v51;
        }
      }
      else
      {
        unint64_t v3 = (v52 - 1) & v51;
      }
      goto LABEL_125;
    }
  }
  return 1;
}

uint64_t std::__split_buffer<KB::retain_ptr<_LXLexicon const*>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  unint64_t v3 = *(void **)(a1 + 16);
  if (v3 != v2)
  {
    do
    {
      int v6 = (const void *)*(v3 - 1);
      uint64_t v5 = v3 - 1;
      uint64_t v4 = v6;
      *(void *)(a1 + 16) = v5;
      uint64_t v7 = v5;
      if (v6)
      {
        CFRelease(v4);
        uint64_t v7 = *(void **)(a1 + 16);
      }
      *uint64_t v5 = 0;
      unint64_t v3 = v7;
    }
    while (v7 != v2);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = KB::String::String((KB::String *)a1, (const KB::String *)a2);
  KB::String::String((KB::String *)((char *)v4 + 32), (const KB::String *)(a2 + 32));
  KB::String::String((KB::String *)(a1 + 64), (const KB::String *)(a2 + 64));
  KB::String::String((KB::String *)(a1 + 96), (const KB::String *)(a2 + 96));
  KB::String::String((KB::String *)(a1 + 128), (const KB::String *)(a2 + 128));
  uint64_t v5 = *(void *)(a2 + 160);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(void *)(a1 + 160) = v5;
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(unint64_t a1)
{
  if (a1 >= 0x1745D1745D1745ELL) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(176 * a1);
}

uint64_t std::vector<KB::LexiconInfo>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 176;
    uint64_t result = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>(result - 176, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::LexiconInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 176;
    std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(i - 176);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 136);
  if (v2 && *(unsigned char *)(a1 + 134) == 1) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 104);
  if (v3 && *(unsigned char *)(a1 + 102) == 1) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 72);
  if (v4 && *(unsigned char *)(a1 + 70) == 1) {
    free(v4);
  }
  uint64_t v5 = *(void **)(a1 + 40);
  if (v5 && *(unsigned char *)(a1 + 38) == 1) {
    free(v5);
  }
  int v6 = *(void **)(a1 + 8);
  if (v6 && *(unsigned char *)(a1 + 6) == 1)
  {
    free(v6);
  }
}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = KB::String::operator=(a1, (KB::String *)a2);
  *(_DWORD *)(v4 + 32) = 0x100000;
  *(_WORD *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 38) = 0;
  *(void *)(a1 + 40) = 0;
  KB::String::operator=(v4 + 32, (KB::String *)(a2 + 32));
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 70) = 0;
  *(void *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, (KB::String *)(a2 + 64));
  *(_DWORD *)(a1 + 96) = 0x100000;
  *(_WORD *)(a1 + 100) = 0;
  *(unsigned char *)(a1 + 102) = 0;
  *(void *)(a1 + 104) = 0;
  KB::String::operator=(a1 + 96, (KB::String *)(a2 + 96));
  *(_DWORD *)(a1 + 128) = 0x100000;
  *(_WORD *)(a1 + 132) = 0;
  *(unsigned char *)(a1 + 134) = 0;
  *(void *)(a1 + 136) = 0;
  KB::String::operator=(a1 + 128, (KB::String *)(a2 + 128));
  uint64_t v5 = *(void *)(a2 + 160);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  *(void *)(a1 + 160) = v5;
  return a1;
}

BOOL KB::DynamicDictionaryContainer::get_valid(KB::DynamicDictionaryContainer *this)
{
  uint64_t v2 = *((void *)this + 14);
  uint64_t v1 = *((void *)this + 15);
  if (v2 == v1) {
    return 0;
  }
  uint64_t v3 = v2 + 8;
  do
  {
    uint64_t v4 = *(void *)(v3 - 8);
    BOOL result = v4 != 0;
    if (v4) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = v3 == v1;
    }
    v3 += 8;
  }
  while (!v6);
  return result;
}

void KB::DynamicDictionaryContainer::do_create_invalid_cursor(KB::DynamicDictionaryContainer *this)
{
}

void KB::DynamicDictionaryContainer::do_create_root_cursor(KB::DynamicDictionaryContainer *this, const KB::DynamicDictionaryContainer *a2)
{
}

void KB::DynamicDictionaryContainer::~DynamicDictionaryContainer(KB::DynamicDictionaryContainer *this)
{
  KB::DynamicDictionaryContainer::~DynamicDictionaryContainer(this);

  JUMPOUT(0x1E4E7BC20);
}

{
  uint64_t v2;
  uint64_t i;
  void *v4;
  void *v5;
  void *v6;
  void **v7;
  uint64_t vars8;

  *(void *)this = &unk_1F3F72098;
  if (*((void *)this + 27))
  {
    std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(*((void **)this + 26));
    *((void *)this + 26) = 0;
    uint64_t v2 = *((void *)this + 25);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*((void *)this + 24) + 8 * i) = 0;
    }
    *((void *)this + 27) = 0;
  }
  std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(*((void **)this + 26));
  uint64_t v4 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 21);
  if (v5)
  {
    *((void *)this + 22) = v5;
    operator delete(v5);
  }
  BOOL v6 = (void *)*((void *)this + 18);
  if (v6 && *((unsigned char *)this + 142) == 1) {
    free(v6);
  }
  uint64_t v7 = (void **)((char *)this + 112);
  std::vector<KB::retain_ptr<_LXLexicon const*>>::__destroy_vector::operator()[abi:nn180100](&v7);
  uint64_t v7 = (void **)((char *)this + 88);
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v7);

  KB::DynamicDictionary::~DynamicDictionary(this);
}

void std::vector<KB::retain_ptr<_LXLexicon const*>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<KB::retain_ptr<_LXLexicon const*>>::__clear[abi:nn180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 176;
        std::__destroy_at[abi:nn180100]<KB::LexiconInfo,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::DynamicDictionary::~DynamicDictionary(KB::DynamicDictionary *this)
{
  *(void *)this = &unk_1F3F72198;
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2 && *((unsigned char *)this + 62) == 1) {
    free(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
}

void std::vector<KB::retain_ptr<_LXLexicon const*>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1];
  if (v3 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      BOOL v6 = *(const void **)(v4 - 8);
      v4 -= 8;
      uint64_t v5 = v6;
      if (v6) {
        CFRelease(v5);
      }
      *(void *)(v3 - 8) = 0;
      uint64_t v3 = v4;
    }
    while (v4 != v2);
  }
  a1[1] = v2;
}

void std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      uint64_t v2 = v1;
      uint64_t v1 = (void *)*v1;
      uint64_t v3 = (void *)v2[3];
      if (v3)
      {
        if (*((unsigned char *)v2 + 22) == 1) {
          free(v3);
        }
      }
      operator delete(v2);
    }
    while (v1);
  }
}

void KB::DynamicDictionarySingle::do_enumerate_entries(KB::DynamicDictionary *a1, uint64_t a2)
{
  uint64_t v11 = a2;
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    uint64_t RootCursor = (const void *)LXLexiconCreateRootCursor();
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v15 = &__block_descriptor_tmp_23;
    uint64_t v16 = &v11;
    int v17 = 5;
    LXCursorEnumerateEntriesRecursively();
    if (RootCursor) {
      CFRelease(RootCursor);
    }
  }
  if ((*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)a1 + 88))(a1, 0))
  {
    uint64_t v4 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v15 = &__block_descriptor_tmp_23;
    uint64_t v16 = &v11;
    int v17 = 0;
    LXCursorEnumerateEntriesRecursively();
    if (v4) {
      CFRelease(v4);
    }
  }
  if (*((void *)a1 + 1))
  {
    uint64_t v5 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v15 = &__block_descriptor_tmp_23;
    uint64_t v16 = &v11;
    int v17 = 1;
    LXCursorEnumerateEntriesRecursively();
    if (v5) {
      CFRelease(v5);
    }
  }
  if (*((void *)a1 + 2))
  {
    BOOL v6 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v15 = &__block_descriptor_tmp_23;
    uint64_t v16 = &v11;
    int v17 = 2;
    LXCursorEnumerateEntriesRecursively();
    if (v6) {
      CFRelease(v6);
    }
  }
  uint64_t v7 = (void **)*((void *)a1 + 3);
  if (v7)
  {
    uint64_t v8 = *v7;
    if (v8)
    {
      if (*v8)
      {
        uint64_t v9 = (const void *)LXLexiconCreateRootCursor();
        uint64_t v12 = MEMORY[0x1E4F143A8];
        uint64_t v13 = 0x40000000;
        uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
        uint64_t v15 = &__block_descriptor_tmp_23;
        uint64_t v16 = &v11;
        int v17 = 3;
        LXCursorEnumerateEntriesRecursively();
        if (v9) {
          CFRelease(v9);
        }
      }
    }
  }
  if (KB::DynamicDictionary::named_entity_lexicon(a1))
  {
    unint64_t v10 = (const void *)LXLexiconCreateRootCursor();
    uint64_t v12 = MEMORY[0x1E4F143A8];
    uint64_t v13 = 0x40000000;
    uint64_t v14 = ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke;
    uint64_t v15 = &__block_descriptor_tmp_23;
    uint64_t v16 = &v11;
    int v17 = 4;
    LXCursorEnumerateEntriesRecursively();
    if (v10) {
      CFRelease(v10);
    }
  }
}

uint64_t ___ZZNK2KB23DynamicDictionarySingle20do_enumerate_entriesEU13block_pointerFvPK8_LXEntryNS_16DynamicEntryTypeEEENK3__0clEPK10_LXLexiconS4__block_invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 32) + 16))(**(void **)(a1 + 32), a2, *(unsigned int *)(a1 + 40));
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie_for_locale(KB::DynamicDictionarySingle *this, String *a2)
{
  return *((void *)this + 33);
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie(KB::DynamicDictionarySingle *this)
{
  return *((void *)this + 33);
}

uint64_t KB::DynamicDictionarySingle::get_persistent_custom_trie_count(KB::DynamicDictionarySingle *this)
{
  return 1;
}

uint64_t KB::DynamicDictionarySingle::get_total_usage_count(KB::DynamicDictionarySingle *this)
{
  if (*((void *)this + 33) && (uint64_t RootCursor = LXLexiconCreateRootCursor()) != 0)
  {
    uint64_t v3 = (const void *)RootCursor;
    int v4 = LXCursorUsageCountRecursive();
    int v5 = v4 & ~(v4 >> 31);
    CFRelease(v3);
  }
  else
  {
    int v5 = 0;
  }
  if (*((void *)this + 1) && (uint64_t v6 = LXLexiconCreateRootCursor()) != 0)
  {
    uint64_t v7 = (const void *)v6;
    int v8 = LXCursorUsageCountRecursive();
    int v9 = v8 & ~(v8 >> 31);
    CFRelease(v7);
  }
  else
  {
    int v9 = 0;
  }
  if (*((void *)this + 2) && (uint64_t v10 = LXLexiconCreateRootCursor()) != 0)
  {
    uint64_t v11 = (const void *)v10;
    int v12 = LXCursorUsageCountRecursive();
    int v13 = v12 & ~(v12 >> 31);
    CFRelease(v11);
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v14 = (void **)*((void *)this + 3);
  if (v14 && (uint64_t v15 = *v14) != 0 && *v15 && (v16 = LXLexiconCreateRootCursor()) != 0)
  {
    int v17 = (const void *)v16;
    int v18 = LXCursorUsageCountRecursive();
    int v19 = v18 & ~(v18 >> 31);
    CFRelease(v17);
  }
  else
  {
    int v19 = 0;
  }
  if (KB::DynamicDictionary::named_entity_lexicon(this) && (uint64_t v20 = LXLexiconCreateRootCursor()) != 0)
  {
    long long v21 = (const void *)v20;
    int v22 = LXCursorUsageCountRecursive();
    int v23 = v22 & ~(v22 >> 31);
    CFRelease(v21);
  }
  else
  {
    int v23 = 0;
  }
  if (TITransientLexiconManagerGetActiveSupplementalLexiconWords() && (uint64_t v24 = LXLexiconCreateRootCursor()) != 0)
  {
    uint64_t v25 = (const void *)v24;
    int v26 = LXCursorUsageCountRecursive();
    int v27 = v26 & ~(v26 >> 31);
    CFRelease(v25);
  }
  else
  {
    int v27 = 0;
  }
  return (v9 + v5 + v13 + v19 + v23 + v27);
}

uint64_t KB::DynamicDictionarySingle::get_user_frequency(KB::DynamicDictionarySingle *this, _LXLexicon *a2)
{
  (*(void (**)(KB::DynamicDictionarySingle *, void))(*(void *)this + 88))(this, 0);
  KB::DynamicDictionary::entry_matching_string(a2, &v7);
  uint64_t v3 = v7;
  if (!v7) {
    return 0;
  }
  UsageCFIndex Count = LXEntryGetUsageCount();
  if (UsageCount >= 0x7FFFFFFF) {
    uint64_t v5 = 0x7FFFFFFFLL;
  }
  else {
    uint64_t v5 = UsageCount;
  }
  CFRelease(v3);
  return v5;
}

void KB::DynamicDictionarySingle::get_word_with_string(KB::DynamicDictionarySingle *this@<X0>, const KB::String *a2@<X1>, KB::Word *a3@<X8>)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  (*(void (**)(KB::DynamicDictionarySingle *, void))(*(void *)this + 88))(this, 0);
  int v5 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionarySingle *, void))(*(void *)this + 48))(this, 0)+ 160);
  KB::entry_from_lexicon(&v12);
  uint64_t v6 = v12;
  if (!v12)
  {
    memset(v13, 0, sizeof(v13));
    long long v16 = 0u;
    long long v17 = 0u;
    uint64_t v21 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    uint64_t v25 = 0;
    *(_OWORD *)&uint8_t v27[8] = 0u;
    WORD1(v13[0]) = 16;
    BYTE6(v13[0]) = 0;
    uint64_t v14 = 0x3F80000000000000;
    uint64_t v15 = 1065353216;
    WORD1(v16) = 16;
    BYTE6(v16) = 0;
    __asm { FMOV            V1.2S, #1.0 }
    long long v18 = _D1;
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v19 = 0u;
    WORD1(v23) = 16;
    BYTE6(v23) = 0;
    long long v26 = 0u;
    *(_OWORD *)int v27 = 0u;
    *(_DWORD *)&v27[16] = 1065353216;
    goto LABEL_5;
  }
  KB::Word::Word((uint64_t)v13, (uint64_t)v12, v5);
  CFRelease(v6);
  if (!LOWORD(v13[0]))
  {
LABEL_5:
    KB::DynamicDictionary::word_from_transient_lexicon_with_string(this, (uint64_t)a3);
    goto LABEL_6;
  }
  KB::Word::Word(a3, (size_t *)v13);
LABEL_6:
  KB::Word::~Word((KB::Word *)v13);
}

uint64_t KB::DynamicDictionarySingle::get_lexicon_info(KB::DynamicDictionarySingle *this)
{
  return (uint64_t)this + 88;
}

uint64_t KB::DynamicDictionarySingle::do_load(uint64_t a1, uint64_t *a2, int a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a2;
  if (*a2 == a2[1])
  {
    int v15 = 0x100000;
    __int16 v16 = 0;
    char v17 = 0;
    long long v18 = 0;
    char v19 = 0;
    int v20 = 0x100000;
    __int16 v21 = 0;
    char v22 = 0;
    long long v23 = 0;
    char v24 = 0;
    int v25 = 0x100000;
    __int16 v26 = 0;
    char v27 = 0;
    uint64_t v28 = 0;
    char v29 = 0;
    int v30 = 0x100000;
    __int16 v31 = 0;
    char v32 = 0;
    uint64_t v33 = 0;
    char v34 = 0;
    int v35 = 0x100000;
    __int16 v36 = 0;
    char v37 = 0;
    int v38 = 0;
    char v39 = 0;
    LODWORD(v40) = 0;
    BYTE4(v40) = 0;
    int v41 = 0;
    KB::String::operator=(a1 + 88, (KB::String *)&v15);
    KB::String::operator=(a1 + 120, (KB::String *)&v20);
    KB::String::operator=(a1 + 152, (KB::String *)&v25);
    KB::String::operator=(a1 + 184, (KB::String *)&v30);
    KB::String::operator=(a1 + 216, (KB::String *)&v35);
    int v12 = v38;
    *(void *)(a1 + 248) = v40;
    *(_DWORD *)(a1 + 256) = v41;
    if (v12 && v37 == 1) {
      free(v12);
    }
    if (v33 && v32 == 1) {
      free(v33);
    }
    if (v28 && v27 == 1) {
      free(v28);
    }
    if (v23 && v22 == 1) {
      free(v23);
    }
    if (v18 && v17 == 1) {
      free(v18);
    }
    int v13 = *(const void **)(a1 + 264);
    if (v13) {
      CFRelease(v13);
    }
    uint64_t result = 0;
    *(void *)(a1 + 264) = 0;
  }
  else
  {
    if (a3) {
      int v5 = "Siri-TextInput-Dynamic.";
    }
    else {
      int v5 = "TextInput-Dynamic.";
    }
    KB::String::String((KB::String *)&v15, v5);
    KB::String::append((unsigned __int16 *)&v15, (const KB::String *)v4);
    KB::cf_string_impl<KB::String>(&v14, (unsigned __int16 *)&v15);
    CFStringRef v6 = v14;
    uint64_t View = LXLexiconRepositoryCreateView();
    int v8 = *(const void **)(a1 + 264);
    if (v8) {
      CFRelease(v8);
    }
    *(void *)(a1 + 264) = View;
    if (v6) {
      CFRelease(v6);
    }
    KB::String::operator=((KB::String *)(a1 + 88), (KB::String *)v4);
    KB::String::operator=((KB::String *)(a1 + 120), (KB::String *)(v4 + 32));
    KB::String::operator=((KB::String *)(a1 + 152), (KB::String *)(v4 + 64));
    KB::String::operator=((KB::String *)(a1 + 184), (KB::String *)(v4 + 96));
    KB::String::operator=((KB::String *)(a1 + 216), (KB::String *)(v4 + 128));
    uint64_t v9 = *(void *)(v4 + 160);
    *(_DWORD *)(a1 + 256) = *(_DWORD *)(v4 + 168);
    *(void *)(a1 + 248) = v9;
    if (v18 && v17 == 1) {
      free(v18);
    }
    uint64_t v10 = *(const void **)(a1 + 264);
    if (v10)
    {
      CFRetain(v10);
      CFRelease(v10);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL KB::DynamicDictionarySingle::get_valid(KB::DynamicDictionarySingle *this)
{
  uint64_t v1 = (const void *)*((void *)this + 33);
  if (v1)
  {
    CFRetain(*((CFTypeRef *)this + 33));
    CFRelease(v1);
  }
  return v1 != 0;
}

void KB::DynamicDictionarySingle::do_create_invalid_cursor(KB::DynamicDictionarySingle *this)
{
}

void KB::DynamicDictionarySingle::do_create_root_cursor(KB::DynamicDictionarySingle *this)
{
}

void KB::DynamicDictionarySingle::~DynamicDictionarySingle(KB::DynamicDictionarySingle *this)
{
  KB::DynamicDictionarySingle::~DynamicDictionarySingle(this);

  JUMPOUT(0x1E4E7BC20);
}

{
  void *v2;
  const void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  uint64_t vars8;

  *(void *)this = &unk_1F3F72118;
  uint64_t v2 = (void *)*((void *)this + 35);
  if (v2 && *((unsigned char *)this + 278) == 1) {
    free(v2);
  }
  uint64_t v3 = (const void *)*((void *)this + 33);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 33) = 0;
  uint64_t v4 = (void *)*((void *)this + 28);
  if (v4 && *((unsigned char *)this + 222) == 1) {
    free(v4);
  }
  int v5 = (void *)*((void *)this + 24);
  if (v5 && *((unsigned char *)this + 190) == 1) {
    free(v5);
  }
  CFStringRef v6 = (void *)*((void *)this + 20);
  if (v6 && *((unsigned char *)this + 158) == 1) {
    free(v6);
  }
  uint64_t v7 = (void *)*((void *)this + 16);
  if (v7 && *((unsigned char *)this + 126) == 1) {
    free(v7);
  }
  int v8 = (void *)*((void *)this + 12);
  if (v8 && *((unsigned char *)this + 94) == 1) {
    free(v8);
  }

  KB::DynamicDictionary::~DynamicDictionary(this);
}

void KB::DynamicDictionary::create_single(KB::DynamicDictionary *this)
{
}

double KB::DynamicDictionarySingle::DynamicDictionarySingle(KB::DynamicDictionarySingle *this)
{
  double result = 0.0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 14) = 0x100000;
  *((_WORD *)this + 30) = 0;
  *((unsigned char *)this + 62) = 0;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  *(void *)this = &unk_1F3F72118;
  *((_DWORD *)this + 22) = 0x100000;
  *((_WORD *)this + 46) = 0;
  *((unsigned char *)this + 94) = 0;
  *((void *)this + 12) = 0;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 30) = 0x100000;
  *((_WORD *)this + 62) = 0;
  *((unsigned char *)this + 126) = 0;
  *((void *)this + 16) = 0;
  *((unsigned char *)this + 136) = 0;
  *((_DWORD *)this + 38) = 0x100000;
  *((_WORD *)this + 78) = 0;
  *((unsigned char *)this + 158) = 0;
  *((void *)this + 20) = 0;
  *((unsigned char *)this + 168) = 0;
  *((_DWORD *)this + 46) = 0x100000;
  *((_WORD *)this + 94) = 0;
  *((unsigned char *)this + 190) = 0;
  *((void *)this + 24) = 0;
  *((unsigned char *)this + 200) = 0;
  *((_DWORD *)this + 54) = 0x100000;
  *((_WORD *)this + 110) = 0;
  *((unsigned char *)this + 222) = 0;
  *((void *)this + 28) = 0;
  *((unsigned char *)this + 232) = 0;
  *((void *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0x100000;
  *((_WORD *)this + 138) = 0;
  *((unsigned char *)this + 278) = 0;
  *((void *)this + 35) = 0;
  *((unsigned char *)this + 288) = 0;
  return result;
}

void KB::DynamicDictionarySingle::create(KB::DynamicDictionarySingle *this)
{
}

void KB::DynamicDictionary::create_container(KB::DynamicDictionary *this)
{
}

void KB::DynamicDictionaryContainer::create(KB::DynamicDictionaryContainer *this)
{
}

uint64_t KB::DynamicDictionary::address_book_trie(KB::DynamicDictionary *this)
{
  return *((void *)this + 1);
}

uint64_t KB::DynamicDictionary::app_trie(KB::DynamicDictionary *this)
{
  return *((void *)this + 2);
}

uint64_t KB::DynamicDictionary::user_dictionary_trie(KB::DynamicDictionary *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  if (v1 && (uint64_t v2 = *v1) != 0) {
    return *(void *)v2;
  }
  else {
    return 0;
  }
}

uint64_t KB::DynamicDictionary::user_dictionary(KB::DynamicDictionary *this)
{
  uint64_t v1 = *((void *)this + 3);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

uint64_t KB::DynamicDictionary::named_entity_phrase_lexicon(KB::DynamicDictionary *this)
{
  if ((*(unsigned int (**)(KB::DynamicDictionary *))(*(void *)this + 32))(this))
  {
    uint64_t v2 = (*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0);
    if (*(_WORD *)v2)
    {
      if (*(void *)(v2 + 8)) {
        uint64_t v3 = *(const char **)(v2 + 8);
      }
      else {
        uint64_t v3 = (const char *)(v2 + 16);
      }
    }
    else
    {
      uint64_t v3 = "";
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return TITransientLexiconManagerGetNamedEntityPhrasesForLocale((uint64_t)v3);
}

unsigned __int16 *KB::DynamicDictionary::dynamic_lexicon_name_with_siri_mode@<X0>(KB::DynamicDictionary *this@<X0>, const KB::String *a2@<X1>, KB::String *a3@<X8>)
{
  if (a2) {
    uint64_t v4 = "Siri-TextInput-Dynamic.";
  }
  else {
    uint64_t v4 = "TextInput-Dynamic.";
  }
  int v5 = (unsigned __int16 *)KB::String::String(a3, v4);

  return KB::String::append(v5, this);
}

unsigned __int16 *KB::DynamicDictionary::dynamic_lexicon_name@<X0>(KB::DynamicDictionary *this@<X0>, KB::String *a2@<X8>)
{
  uint64_t v4 = (unsigned __int16 *)KB::String::String(a2, "TextInput-Dynamic.");

  return KB::String::append(v4, this);
}

void KB::DynamicDictionary::load_address_book(KB::DynamicDictionary *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v4 = 0x100000;
  __int16 v5 = 0;
  char v6 = 0;
  uint64_t v7 = 0;
  char v8 = 0;
  if (!(*(unsigned int (**)(KB::DynamicDictionary *))(*(void *)this + 32))(this)
    || ((v2 = (KB::String *)(*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0), KB::String::operator=((KB::String *)&v4, v2), v7)? (uint64_t v3 = (const char *)v7): (uint64_t v3 = &v8), !(_WORD)v4))
  {
    uint64_t v3 = "";
  }
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = TITransientLexiconManagerGetAddressBookLexiconForLocale((uint64_t)v3);
  if (v7)
  {
    if (v6 == 1) {
      free(v7);
    }
  }
}

void KB::DynamicDictionary::load_app_names(KB::DynamicDictionary *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v4 = 0x100000;
  __int16 v5 = 0;
  char v6 = 0;
  uint64_t v7 = 0;
  char v8 = 0;
  if (!(*(unsigned int (**)(KB::DynamicDictionary *))(*(void *)this + 32))(this)
    || ((v2 = (KB::String *)(*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0), KB::String::operator=((KB::String *)&v4, v2), v7)? (uint64_t v3 = (const char *)v7): (uint64_t v3 = &v8), !(_WORD)v4))
  {
    uint64_t v3 = "";
  }
  *((void *)this + 2) = TITransientLexiconManagerGetAppNameLexiconForLocale((uint64_t)v3);
  if (v7)
  {
    if (v6 == 1) {
      free(v7);
    }
  }
}

BOOL KB::DynamicDictionary::address_book_contains(KB::DynamicDictionary *this, const KB::String *a2)
{
  if (!*((void *)this + 1)) {
    return 0;
  }
  uint64_t RootCursor = (const void *)LXLexiconCreateRootCursor();
  uint64_t v3 = (const void *)LXCursorCreateByAdvancingWithUTF8();
  if (RootCursor) {
    CFRelease(RootCursor);
  }
  BOOL v4 = LXCursorHasEntries() != 0;
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

BOOL KB::DynamicDictionary::app_names_contains(KB::DynamicDictionary *this, const KB::String *a2)
{
  if (!*((void *)this + 2)) {
    return 0;
  }
  uint64_t RootCursor = (const void *)LXLexiconCreateRootCursor();
  uint64_t v3 = (const void *)LXCursorCreateByAdvancingWithUTF8();
  if (RootCursor) {
    CFRelease(RootCursor);
  }
  BOOL v4 = LXCursorHasEntries() != 0;
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

uint64_t KB::DynamicDictionary::filter_phrase(KB::DynamicDictionary *this, const __CFString *a2, const KB::StaticDictionary *a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  KB::utf8_string(a2, (uint64_t)&v22);
  WORD2(v19) = 0;
  BYTE6(v19) = 0;
  int v20 = " \t\n";
  LODWORD(v19) = 1048579;
  char v21 = 0;
  KB::sbs_string_tokenize((unsigned __int16 *)&v22, (const KB::String *)&v19, &v17);
  if (v20) {
    BOOL v7 = BYTE6(v19) == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v20);
  }
  if (v23 && BYTE6(v22) == 1) {
    free(v23);
  }
  char v8 = v17;
  uint64_t v9 = v18;
  if (v17 == v18)
  {
LABEL_28:
    uint64_t v15 = 1;
    goto LABEL_34;
  }
  unsigned int v10 = 0;
  while (1)
  {
    if (!v8[2])
    {
      KB::String::compute_length(v8);
      if (!v8[2]) {
        goto LABEL_27;
      }
    }
    if (KB::string_has_numbers((KB *)v8, v6)) {
      goto LABEL_33;
    }
    v10 += KB::string_has_letters((KB *)v8, v11);
    if (v10 > 3) {
      goto LABEL_33;
    }
    KB::StaticDictionary::candidates_for_string(a3, (const KB::String *)v8, 0, &v19);
    int v12 = v19;
    int v13 = (char *)v20;
    if (v19 == v20) {
      goto LABEL_32;
    }
    if (a4) {
      break;
    }
LABEL_26:
    char v22 = (unsigned __int16 **)&v19;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
LABEL_27:
    v8 += 16;
    if (v8 == v9) {
      goto LABEL_28;
    }
  }
  while (1)
  {
    if (v12[104] < 0 || !*((_DWORD *)v12 + 30)) {
      goto LABEL_25;
    }
    KB::Word::capitalized_string((KB::Word *)v12, (uint64_t)&v22);
    if (&v22 == (unsigned __int16 ***)v8) {
      break;
    }
    BOOL v14 = KB::String::equal((KB::String *)&v22, (const KB::String *)v8, 1);
    if (v23 && BYTE6(v22) == 1) {
      free(v23);
    }
    if (v14) {
      goto LABEL_32;
    }
LABEL_25:
    v12 += 240;
    if (v12 == v13) {
      goto LABEL_26;
    }
  }
  if (v23 && BYTE6(v22) == 1) {
    free(v23);
  }
LABEL_32:
  char v22 = (unsigned __int16 **)&v19;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
LABEL_33:
  uint64_t v15 = 0;
LABEL_34:
  char v22 = &v17;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
  return v15;
}

void KB::DynamicDictionary::retrieve_phrase_candidates(KB::DynamicDictionary *a1, unsigned __int16 *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = KB::DynamicDictionary::named_entity_phrase_lexicon(a1);
  uint64_t ActiveSupplementalLexiconPhrases = TITransientLexiconManagerGetActiveSupplementalLexiconPhrases();
  if (!(v3 | ActiveSupplementalLexiconPhrases)) {
    return;
  }
  if (*((void *)a2 + 1)) {
    __int16 v5 = (unsigned __int16 *)*((void *)a2 + 1);
  }
  else {
    __int16 v5 = a2 + 8;
  }
  char v6 = (unsigned char *)*a2;
  if (!*a2) {
    goto LABEL_16;
  }
  uint64_t v7 = *a2;
  char v8 = v5;
  while (*v8 != 32)
  {
    ++v8;
    if (!--v7)
    {
      char v8 = &v6[(void)v5];
      break;
    }
  }
  if ((unsigned char *)(v8 - (unsigned char *)v5) != v6) {
    goto LABEL_27;
  }
  if (*a2)
  {
    uint64_t v9 = *a2;
    unsigned int v10 = v5;
    while (*v10 != 45)
    {
      ++v10;
      if (!--v9)
      {
        unsigned int v10 = &v6[(void)v5];
        break;
      }
    }
  }
  else
  {
LABEL_16:
    unsigned int v10 = v5;
  }
  if ((unsigned char *)(v10 - (unsigned char *)v5) == v6)
  {
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    if (TICanLogMessageAtLevel_logLevel >= 2)
    {
      uint64_t v11 = TIOSLogFacility();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        int v12 = (const char *)*((void *)a2 + 1);
        if (!v12) {
          int v12 = (const char *)(a2 + 8);
        }
        if (!*a2) {
          int v12 = "";
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "retrieve_phrase_candidates";
        __int16 v23 = 2080;
        uint64_t v24 = v12;
        int v13 = "%s \"%s\" was filtered out from the list of phrase candidate words because it does not contain a space or hyphen";
        BOOL v14 = v11;
        uint32_t v15 = 22;
LABEL_47:
        _os_log_debug_impl(&dword_1E3F0E000, v14, OS_LOG_TYPE_DEBUG, v13, buf, v15);
        return;
      }
    }
    return;
  }
LABEL_27:
  if (ActiveSupplementalLexiconPhrases)
  {
    KB::cf_string_impl<KB::String>((CFStringRef *)buf, a2);
    __int16 v16 = *(const void **)buf;
    LXLexiconEnumerateEntriesForString();
    if (v16) {
      CFRelease(v16);
    }
  }
  if (v3)
  {
    unsigned int v17 = a2[2];
    if (!a2[2])
    {
      KB::String::compute_length(a2);
      unsigned int v17 = a2[2];
    }
    if (v17 <= 3)
    {
      if (TICanLogMessageAtLevel_onceToken != -1) {
        dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
      }
      if (TICanLogMessageAtLevel_logLevel >= 2)
      {
        char v19 = TIOSLogFacility();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          int v20 = (const char *)*((void *)a2 + 1);
          if (!v20) {
            int v20 = (const char *)(a2 + 8);
          }
          if (*a2) {
            char v21 = v20;
          }
          else {
            char v21 = "";
          }
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "retrieve_phrase_candidates";
          __int16 v23 = 2080;
          uint64_t v24 = v21;
          __int16 v25 = 1024;
          int v26 = 4;
          int v13 = "%s \"%s\" was filtered out from the list of phrase candidate words because it's less than %u characters long";
          BOOL v14 = v19;
          uint32_t v15 = 28;
          goto LABEL_47;
        }
      }
    }
    else
    {
      KB::cf_string_impl<KB::String>((CFStringRef *)buf, a2);
      long long v18 = *(const void **)buf;
      LXLexiconEnumerateEntriesForString();
      if (v18) {
        CFRelease(v18);
      }
    }
  }
}

void ___ZN2KB17DynamicDictionary26retrieve_phrase_candidatesERKNS_6StringERKNS_16StaticDictionaryEbRNSt3__16vectorINS_4WordENS7_9allocatorIS9_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  KB::Word::Word((uint64_t)v17, a2, 0);
  TILXEntryGetSupplementalItemIdentifiers((uint64_t)v13);
  int v19 = (int)v16;
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(v18, v14);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)v13);
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  unint64_t v4 = v3[1];
  unint64_t v5 = v3[2];
  if (v4 >= v5)
  {
    unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v4 - *v3) >> 4);
    if (v7 + 1 > 0x111111111111111) {
      abort();
    }
    unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= v7 + 1) {
      uint64_t v9 = v7 + 1;
    }
    if (v8 >= 0x88888888888888) {
      unint64_t v10 = 0x111111111111111;
    }
    else {
      unint64_t v10 = v9;
    }
    __int16 v16 = v3 + 2;
    if (v10) {
      unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = v10 + 240 * v7;
    v13[0] = v10;
    v13[1] = v12;
    unint64_t v15 = v10 + 240 * v11;
    KB::Word::Word(v12, (uint64_t)v17);
    BOOL v14 = (void *)(v12 + 240);
    std::vector<KB::Word>::__swap_out_circular_buffer(v3, v13);
    uint64_t v6 = v3[1];
    std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v13);
  }
  else
  {
    uint64_t v6 = KB::Word::Word(v4, (uint64_t)v17) + 240;
  }
  v3[1] = v6;
  KB::Word::~Word((KB::Word *)v17);
}

void ___ZN2KB17DynamicDictionary26retrieve_phrase_candidatesERKNS_6StringERKNS_16StaticDictionaryEbRNSt3__16vectorINS_4WordENS7_9allocatorIS9_EEEE_block_invoke_4(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a2;
  uint64_t v3 = (__CFString *)LXEntryCopyString();
  if (KB::DynamicDictionary::filter_phrase((KB::DynamicDictionary *)v3, v3, *(const KB::StaticDictionary **)(a1 + 40), *(unsigned __int8 *)(a1 + 56)))
  {
    if (TICanLogMessageAtLevel_onceToken != -1) {
      dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
    }
    if (TICanLogMessageAtLevel_logLevel >= 2)
    {
      unint64_t v4 = TIOSLogFacility();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        KB::utf8_string(v3, (uint64_t)v7);
        unint64_t v5 = (const char *)v9;
        if (!v9) {
          unint64_t v5 = (const char *)&v10;
        }
        if (!v7[0]) {
          unint64_t v5 = "";
        }
        *(_DWORD *)buf = 136315394;
        uint64_t v12 = "retrieve_phrase_candidates_block_invoke";
        __int16 v13 = 2080;
        BOOL v14 = v5;
        _os_log_debug_impl(&dword_1E3F0E000, v4, OS_LOG_TYPE_DEBUG, "%s \"%s\" was filtered out from the list of phrase candidate words", buf, 0x16u);
        if (v9 && v8 == 1) {
          free(v9);
        }
      }
    }
  }
  else
  {
    std::vector<KB::Word>::emplace_back<_LXEntry const*&,unsigned int const&>(*(uint64_t **)(a1 + 48), &v6, &kTILexiconIDUNK);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) - 136) |= 0x100u;
  }
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t std::vector<KB::Word>::emplace_back<_LXEntry const*&,unsigned int const&>(uint64_t *a1, uint64_t *a2, int *a3)
{
  uint64_t v6 = a1 + 2;
  unint64_t v7 = a1[2];
  unint64_t v8 = a1[1];
  if (v8 >= v7)
  {
    unint64_t v11 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v8 - *a1) >> 4);
    if (v11 + 1 > 0x111111111111111) {
      abort();
    }
    unint64_t v12 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v7 - *a1) >> 4);
    uint64_t v13 = 2 * v12;
    if (2 * v12 <= v11 + 1) {
      uint64_t v13 = v11 + 1;
    }
    if (v12 >= 0x88888888888888) {
      unint64_t v14 = 0x111111111111111;
    }
    else {
      unint64_t v14 = v13;
    }
    uint64_t v20 = v6;
    if (v14) {
      unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v14);
    }
    else {
      uint64_t v15 = 0;
    }
    unint64_t v16 = v14;
    uint64_t v17 = v14 + 240 * v11;
    unint64_t v19 = v14 + 240 * v15;
    KB::Word::Word(v17, *a2, *a3);
    uint64_t v18 = v17 + 240;
    std::vector<KB::Word>::__swap_out_circular_buffer(a1, &v16);
    uint64_t v10 = a1[1];
    uint64_t result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v16);
  }
  else
  {
    uint64_t result = KB::Word::Word(v8, *a2, *a3);
    uint64_t v10 = result + 240;
  }
  a1[1] = v10;
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(unint64_t a1)
{
  if (a1 >= 0x111111111111112) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(240 * a1);
}

uint64_t std::vector<KB::Word>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 240;
    uint64_t result = KB::Word::Word(result - 240, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<KB::Word>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 240;
    KB::Word::~Word((KB::Word *)(i - 240));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *KB::DynamicDictionary::load_user_dictionary(void *this)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (!this[3])
  {
    uint64_t v1 = this;
    int v4 = 0x100000;
    __int16 v5 = 0;
    char v6 = 0;
    uint64_t v7 = 0;
    char v8 = 0;
    if ((*(unsigned int (**)(void *))(*this + 32))(this))
    {
      uint64_t v3 = (KB::String *)(*(uint64_t (**)(void *, void))(*v1 + 48))(v1, 0);
      KB::String::operator=((KB::String *)&v4, v3);
    }
    KB::UserDictionaryLoader::create_and_load((KB::UserDictionaryLoader *)&v4, v2);
  }
  return this;
}

void KB::DynamicDictionary::unload_user_dictionary(KB::DynamicDictionary *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 4);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t KB::DynamicDictionary::is_word_in_supplemental_lexicon(KB::DynamicDictionary *this, const KB::String *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!TITransientLexiconManagerGetActiveSupplementalLexiconWords()) {
    return 0;
  }
  int v3 = *(_DWORD *)((*(uint64_t (**)(KB::DynamicDictionary *, void))(*(void *)this + 48))(this, 0) + 160);
  KB::entry_from_lexicon(&v11);
  uint64_t v4 = v11;
  if (v11)
  {
    KB::Word::Word((uint64_t)v12, v11, v3);
    CFRelease((CFTypeRef)v4);
    uint64_t v4 = LOWORD(v12[0]) != 0;
  }
  else
  {
    memset(v12, 0, sizeof(v12));
    long long v15 = 0u;
    long long v16 = 0u;
    uint64_t v20 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    uint64_t v24 = 0;
    *(_OWORD *)&v26[8] = 0u;
    WORD1(v12[0]) = 16;
    BYTE6(v12[0]) = 0;
    uint64_t v13 = 0x3F80000000000000;
    WORD1(v15) = 16;
    WORD1(v22) = 16;
    uint64_t v14 = 1065353216;
    BYTE6(v15) = 0;
    __asm { FMOV            V1.2S, #1.0 }
    long long v17 = _D1;
    uint64_t v21 = 0;
    long long v19 = 0u;
    long long v18 = 0u;
    BYTE6(v22) = 0;
    long long v25 = 0u;
    *(_OWORD *)int v26 = 0u;
    *(_DWORD *)&unsigned char v26[16] = 1065353216;
  }
  KB::Word::~Word((KB::Word *)v12);
  return v4;
}

void TIInlineCompletionEventDispatcher::TIInlineCompletionEventDispatcher(TIInlineCompletionEventDispatcher *this)
{
  *((unsigned char *)this + 48) = 0;
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 88) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 128) = 0;
  *((unsigned char *)this + 136) = 0;
  *((unsigned char *)this + 140) = 0;
  *((unsigned char *)this + 144) = 0;
  *((unsigned char *)this + 472) = 0;
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((unsigned char *)this + 16) = 0;
}

{
  *((unsigned char *)this + 48) = 0;
  *((unsigned char *)this + 56) = 0;
  *((unsigned char *)this + 88) = 0;
  *((unsigned char *)this + 96) = 0;
  *((unsigned char *)this + 128) = 0;
  *((unsigned char *)this + 136) = 0;
  *((unsigned char *)this + 140) = 0;
  *((unsigned char *)this + 144) = 0;
  *((unsigned char *)this + 472) = 0;
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((unsigned char *)this + 16) = 0;
}

void TIInlineCompletionEventDispatcher::did_generate_no_completion(TIInlineCompletionEventDispatcher *this)
{
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v4, *(void *)this, *((std::__shared_weak_count **)this + 1));
  uint64_t v1 = v5;
  if (v5)
  {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v1);
  }
  uint64_t v2 = analytics_queue();
  if (v1)
  {
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    int v3 = v1;
    atomic_fetch_add_explicit(&v1->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    TIDispatchAsync();
    std::__shared_weak_count::__release_weak(v1);
  }
  else
  {
    int v3 = 0;
    TIDispatchAsync();
  }

  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void *std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(void *a1, uint64_t a2, std::__shared_weak_count *this)
{
  *a1 = a2;
  if (this)
  {
    uint64_t v4 = std::__shared_weak_count::lock(this);
    a1[1] = v4;
    if (v4) {
      return a1;
    }
  }
  else
  {
    a1[1] = 0;
  }
  std::__throw_bad_weak_ptr[abi:nn180100]();
  return (void *)analytics_queue();
}

id analytics_queue(void)
{
  if (analytics_queue(void)::onceToken != -1) {
    dispatch_once(&analytics_queue(void)::onceToken, &__block_literal_global_2478);
  }
  uint64_t v0 = (void *)analytics_queue(void)::queue;

  return v0;
}

void ___ZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEv_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        v9[0] = 0;
        v9[80] = 0;
        v8[0] = 0;
        v8[80] = 0;
        char v6 = 0;
        char v7 = 0;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v8);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v9);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void __destroy_helper_block_a8_32c77_ZTSKZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEvE3__0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_a8_32c77_ZTSKZN33TIInlineCompletionEventDispatcher26did_generate_no_completionEvE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void TIInlineCompletionEventDispatcher::_dispatch_event(uint64_t a1)
{
  analytics_send_event_lazy();
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2 && *(unsigned char *)(a1 + 22) == 1) {
      free(v2);
    }
    *(unsigned char *)(a1 + 48) = 0;
  }
  if (*(unsigned char *)(a1 + 88))
  {
    int v3 = *(void **)(a1 + 64);
    if (v3 && *(unsigned char *)(a1 + 62) == 1) {
      free(v3);
    }
    *(unsigned char *)(a1 + 88) = 0;
  }
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v4 = *(void **)(a1 + 104);
    if (v4 && *(unsigned char *)(a1 + 102) == 1) {
      free(v4);
    }
    *(unsigned char *)(a1 + 128) = 0;
  }
  if (*(unsigned char *)(a1 + 140)) {
    *(unsigned char *)(a1 + 140) = 0;
  }
}

uint64_t std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 80))
  {
    if (*(unsigned char *)(a1 + 72)) {
      language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 64));
    }
    if (*(char *)(a1 + 47) < 0) {
      operator delete(*(void **)(a1 + 24));
    }
    if (*(char *)(a1 + 23) < 0) {
      operator delete(*(void **)a1);
    }
  }
  return a1;
}

xpc_object_t ___ZN33TIInlineCompletionEventDispatcher15_dispatch_eventERKNSt3__18optionalI18TIInlineCompletionEES5_RKNS1_IN17language_modeling2v114CompletionStemEEE23TIICSuppressionModalityb_block_invoke(uint64_t a1)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  uint64_t v4 = (const char *)kTIICCompletionSourceNone;
  uint64_t v5 = *(long long **)(a1 + 40);
  if (*((unsigned char *)v5 + 80) && (uint64_t v6 = *(void *)(a1 + 48), *(unsigned char *)(v6 + 80)) && *(unsigned char *)(*(void *)(a1 + 56) + 8))
  {
    uint64_t v7 = *(unsigned int *)(v6 + 56);
    if (v7 > 3) {
      char v8 = kTIICCompletionSourceUnknown;
    }
    else {
      char v8 = off_1E6E29DD8[v7];
    }
    uint64_t v4 = *v8;
    if (*((char *)v5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v5, *((void *)v5 + 1));
    }
    else
    {
      long long v32 = *v5;
      __str.__r_.__value_.__r.__words[2] = *((void *)v5 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v32;
    }
    int64_t v9 = _bounded_word_count((uint64_t)&__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    uint64_t v33 = *(long long **)(a1 + 48);
    if (!*((unsigned char *)v33 + 80)) {
      goto LABEL_130;
    }
    char v34 = *(language_modeling::v1::CompletionStem **)(a1 + 56);
    if (!*((unsigned char *)v34 + 8)) {
      goto LABEL_130;
    }
    if (*((char *)v33 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v33, *((void *)v33 + 1));
    }
    else
    {
      long long v35 = *v33;
      __str.__r_.__value_.__r.__words[2] = *((void *)v33 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v35;
    }
    language_modeling::v1::CompletionStem::prefix((uint64_t *)__p, v34);
    if ((v40 & 0x80u) == 0) {
      std::string::size_type v36 = v40;
    }
    else {
      std::string::size_type v36 = (std::string::size_type)__p[1];
    }
    _completion_with_stem_removed(&v41, &__str, v36);
    if ((char)v40 < 0) {
      operator delete(__p[0]);
    }
    int64_t v10 = _bounded_word_count((uint64_t)&v41);
    if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v41.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    int64_t v9 = 0;
    int64_t v10 = 0;
  }
  xpc_dictionary_set_string(v3, (const char *)kTIICCompletionSourceFieldName, v4);
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsGeneratedFieldName, v9);
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsPresentedFieldName, v10);
  xpc_dictionary_set_BOOL(v3, (const char *)kTIICIsCachedFieldName, *(unsigned char *)(a1 + 68));
  xpc_dictionary_set_int64(v3, (const char *)kTIICSuppressionModality, *(unsigned int *)(a1 + 64));
  if (*(unsigned char *)(v2 + 140))
  {
    uint64_t v11 = *(unsigned int *)(v2 + 136);
    int64_t v12 = v11 + 4;
    if ((v11 - 1) <= 4 && *(unsigned char *)(v2 + 48) && *(unsigned char *)(v2 + 88))
    {
      if (v11 == 2)
      {
        int64_t v13 = 1;
      }
      else
      {
        char v37 = *(char **)(v2 + 24);
        if (!v37) {
          char v37 = (char *)(v2 + 32);
        }
        if (*(_WORD *)(v2 + 16)) {
          int v38 = v37;
        }
        else {
          int v38 = "";
        }
        std::string::basic_string[abi:nn180100]<0>(&__str, v38);
        _completion_with_stem_removed(&v41, &__str, *(unsigned __int16 *)(v2 + 56));
        int64_t v13 = _bounded_word_count((uint64_t)&v41);
        if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v41.__r_.__value_.__l.__data_);
        }
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
      }
    }
    else
    {
      int64_t v13 = 0;
    }
  }
  else
  {
    int64_t v13 = 0;
    int64_t v12 = 3;
  }
  xpc_dictionary_set_int64(v3, (const char *)kTIICWordsAcceptedFieldName, v13);
  xpc_dictionary_set_int64(v3, (const char *)kTIICRevisedModalityFieldName, v12);
  if (*(unsigned char *)(v2 + 472))
  {
    KB::String::String((KB::String *)&__str, (const KB::String *)(v2 + 144));
    KB::String::String((KB::String *)v43, (const KB::String *)(v2 + 176));
    KB::String::String((KB::String *)v45, (const KB::String *)(v2 + 208));
    KB::String::String((KB::String *)v47, (const KB::String *)(v2 + 240));
    KB::String::String((KB::String *)v49, (const KB::String *)(v2 + 272));
    KB::String::String((KB::String *)v51, (const KB::String *)(v2 + 304));
    char v53 = *(unsigned char *)(v2 + 336);
    KB::String::String((KB::String *)v54, (const KB::String *)(v2 + 344));
    KB::String::String((KB::String *)v56, (const KB::String *)(v2 + 376));
    KB::String::String((KB::String *)v58, (const KB::String *)(v2 + 408));
    KB::String::String((KB::String *)v60, (const KB::String *)(v2 + 440));
    if (*(unsigned char *)(v2 + 472))
    {
      if (*(_WORD *)(v2 + 144)) {
        uint64_t v14 = *(void *)(v2 + 152) ? *(const char **)(v2 + 152) : (const char *)(v2 + 160);
      }
      else {
        uint64_t v14 = "";
      }
      xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardLanguageFieldName, v14);
      if (*(unsigned char *)(v2 + 472))
      {
        if (*(_WORD *)(v2 + 176)) {
          long long v15 = *(void *)(v2 + 184) ? *(const char **)(v2 + 184) : (const char *)(v2 + 192);
        }
        else {
          long long v15 = "";
        }
        xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardRegionFieldName, v15);
        if (*(unsigned char *)(v2 + 472))
        {
          if (*(_WORD *)(v2 + 208)) {
            long long v16 = *(void *)(v2 + 216) ? *(const char **)(v2 + 216) : (const char *)(v2 + 224);
          }
          else {
            long long v16 = "";
          }
          xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardVariantFieldName, v16);
          if (*(unsigned char *)(v2 + 472))
          {
            if (*(_WORD *)(v2 + 240)) {
              long long v17 = *(void *)(v2 + 248) ? *(const char **)(v2 + 248) : (const char *)(v2 + 256);
            }
            else {
              long long v17 = "";
            }
            xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardSecondaryLanguageFieldName, v17);
            if (*(unsigned char *)(v2 + 472))
            {
              if (*(_WORD *)(v2 + 272)) {
                long long v18 = *(void *)(v2 + 280) ? *(const char **)(v2 + 280) : (const char *)(v2 + 288);
              }
              else {
                long long v18 = "";
              }
              xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardSecondaryRegionFieldName, v18);
              if (*(unsigned char *)(v2 + 472))
              {
                if (*(_WORD *)(v2 + 304)) {
                  long long v19 = *(void *)(v2 + 312) ? *(const char **)(v2 + 312) : (const char *)(v2 + 320);
                }
                else {
                  long long v19 = "";
                }
                xpc_dictionary_set_string(v3, (const char *)kTIICKeyboardLayoutFieldName, v19);
                if (*(unsigned char *)(v2 + 472))
                {
                  uint64_t v20 = (const char *)kTIICKeyboardTypeFieldName;
                  id v21 = +[TIKBAnalyticsMetricsContext keyboardTypeEnumToString:*(unsigned __int8 *)(v2 + 336)];
                  long long v22 = (const char *)[v21 UTF8String];

                  xpc_dictionary_set_string(v3, v20, v22);
                  if (*(unsigned char *)(v2 + 472))
                  {
                    uint64_t v24 = (const char *)kTIICBundleIdFieldName;
                    long long v25 = KB::ns_string((KB *)(v2 + 344), v23);
                    id v26 = [MEMORY[0x1E4FAE268] appCategoryForBundleID:v25];
                    uint64_t v27 = (const char *)[v26 cStringUsingEncoding:4];

                    xpc_dictionary_set_string(v3, v24, v27);
                    if (*(unsigned char *)(v2 + 472))
                    {
                      if (!*(_WORD *)(v2 + 376)
                        || (*(void *)(v2 + 384)
                          ? (uint64_t v28 = *(const char **)(v2 + 384))
                          : (uint64_t v28 = (const char *)(v2 + 392)),
                            xpc_dictionary_set_string(v3, (const char *)kTIICTrialDeploymentIdFieldName, v28),
                            *(unsigned char *)(v2 + 472)))
                      {
                        if (!*(_WORD *)(v2 + 408)
                          || (*(void *)(v2 + 416)
                            ? (char v29 = *(const char **)(v2 + 416))
                            : (char v29 = (const char *)(v2 + 424)),
                              xpc_dictionary_set_string(v3, (const char *)kTIICTrialExperimentIdFieldName, v29),
                              *(unsigned char *)(v2 + 472)))
                        {
                          if (*(_WORD *)(v2 + 440))
                          {
                            if (*(void *)(v2 + 448)) {
                              int v30 = *(const char **)(v2 + 448);
                            }
                            else {
                              int v30 = (const char *)(v2 + 456);
                            }
                            xpc_dictionary_set_string(v3, (const char *)kTIICTrialTreatmentIdFieldName, v30);
                          }
                          if (v61 && v60[6] == 1) {
                            free(v61);
                          }
                          if (v59 && v58[6] == 1) {
                            free(v59);
                          }
                          if (v57 && v56[6] == 1) {
                            free(v57);
                          }
                          if (v55 && v54[6] == 1) {
                            free(v55);
                          }
                          if (v52 && v51[6] == 1) {
                            free(v52);
                          }
                          if (v50 && v49[6] == 1) {
                            free(v50);
                          }
                          if (v48 && v47[6] == 1) {
                            free(v48);
                          }
                          if (v46 && v45[6] == 1) {
                            free(v46);
                          }
                          if (v44 && v43[6] == 1) {
                            free(v44);
                          }
                          if (__str.__r_.__value_.__l.__size_ && __str.__r_.__value_.__s.__data_[6] == 1) {
                            free((void *)__str.__r_.__value_.__l.__size_);
                          }
                          return v3;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_130:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v3;
}

uint64_t std::__throw_bad_optional_access[abi:nn180100]()
{
  return _bounded_word_count();
}

uint64_t _bounded_word_count(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (*(char *)(a1 + 23) >= 0) {
    uint64_t v1 = (const char *)a1;
  }
  else {
    uint64_t v1 = *(const char **)a1;
  }
  KB::String::String((KB::String *)v12, v1);
  KB::String::String((KB::String *)&v7, " \t\n");
  KB::String::trim((KB::String *)v12, (const KB::String *)&v7, (uint64_t)v10);
  if (v11) {
    BOOL v2 = v10[6] == 1;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2) {
    free(v11);
  }
  if (v8 && BYTE6(v7) == 1) {
    free(v8);
  }
  if (v12[0])
  {
    WORD2(v7) = 0;
    BYTE6(v7) = 0;
    char v8 = " \t\n";
    LODWORD(v7) = 1048579;
    char v9 = 0;
    KB::sbs_string_tokenize(v12, (const KB::String *)&v7, v6);
    if (v8 && BYTE6(v7) == 1) {
      free(v8);
    }
    uint64_t v3 = (v6[1] - v6[0]) >> 5;
    uint64_t v7 = (void **)v6;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v7);
  }
  else
  {
    LODWORD(v3) = 0;
  }
  if (v14 && v13 == 1) {
    free(v14);
  }
  if ((int)v3 >= 5) {
    return 5;
  }
  else {
    return (int)v3;
  }
}

void _completion_with_stem_removed(std::string *this, std::string *__str, std::string::size_type __pos)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  int v7 = (char)size;
  if ((size & 0x80u) != 0) {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
  }
  if (size >= __pos)
  {
    std::string::basic_string(this, __str, __pos, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v9);
  }
  else
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      char v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
      if (v7 >= 0) {
        char v8 = __str;
      }
      int v9 = 136315650;
      int64_t v10 = "_completion_with_stem_removed";
      __int16 v11 = 2048;
      std::string::size_type v12 = __pos;
      __int16 v13 = 2080;
      uint64_t v14 = v8;
      _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  !!! Stem size:%zu should not be longer than completion: %s", (uint8_t *)&v9, 0x20u);
    }
    this->__r_.__value_.__r.__words[0] = 0;
    this->__r_.__value_.__l.__size_ = 0;
    this->__r_.__value_.__r.__words[2] = 0;
  }
}

void ___ZL15analytics_queuev_block_invoke()
{
  uint64_t v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  attr = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_UTILITY, 0);

  dispatch_queue_t v1 = dispatch_queue_create("com.apple.textInput.inlineCompletionEventDispatcher", attr);
  BOOL v2 = (void *)analytics_queue(void)::queue;
  analytics_queue(void)::queue = (uint64_t)v1;
}

uint64_t std::__throw_bad_weak_ptr[abi:nn180100]()
{
  return TIInlineCompletionEventDispatcher::did_generate_new_completion();
}

void TIInlineCompletionEventDispatcher::did_generate_new_completion(uint64_t a1, uint64_t a2, const language_modeling::v1::CompletionStem *a3, int a4)
{
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v10, *(void *)a1, *(std::__shared_weak_count **)(a1 + 8));
  uint64_t v8 = v10;
  int v7 = v11;
  if (v11)
  {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  int v9 = analytics_queue();
  uint64_t v20 = MEMORY[0x1E4F143A8];
  uint64_t v21 = 3321888768;
  long long v22 = ___ZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke;
  long long v23 = &__block_descriptor_144_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0_e5_v8__0l;
  uint64_t v10 = v8;
  __int16 v11 = v7;
  if (v7) {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v12, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v12 = *(std::string *)a2;
  }
  if (*(char *)(a2 + 47) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
  }
  else {
    std::string __p = *(std::string *)(a2 + 24);
  }
  uint64_t v14 = *(void *)(a2 + 48);
  int v15 = *(_DWORD *)(a2 + 56);
  v16[0] = 0;
  char v17 = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    MEMORY[0x1E4E7B4C0](v16, a2 + 64);
    char v17 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v18, a3);
  int v19 = a4;
  uint64_t v24 = v10;
  long long v25 = v11;
  if (v11) {
    atomic_fetch_add_explicit(&v11->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v26, v12.__r_.__value_.__l.__data_, v12.__r_.__value_.__l.__size_);
  }
  else {
    std::string v26 = v12;
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__init_copy_ctor_external(&v27, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
  }
  else {
    std::string v27 = __p;
  }
  uint64_t v28 = v14;
  int v29 = v15;
  v30[0] = 0;
  char v31 = 0;
  if (v17)
  {
    MEMORY[0x1E4E7B4C0](v30, v16);
    char v31 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v32, (const language_modeling::v1::CompletionStem *)&v18);
  v32[2] = v19;
  TIDispatchAsync();
  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v18);
  if (v17) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)v16);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }

  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)v32);
  if (v31) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)v30);
  }
  if (SHIBYTE(v27.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v27.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
  if (v25) {
    std::__shared_weak_count::__release_weak(v25);
  }
  if (v7) {
    std::__shared_weak_count::__release_weak(v7);
  }
}

void ___ZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v9, (long long *)(a1 + 48));
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v8, (long long *)(a1 + 48));
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v6, (const language_modeling::v1::CompletionStem *)(a1 + 128));
        char v7 = 1;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        if (v7) {
          language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v6);
        }
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v8);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v9);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void __destroy_helper_block_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1)
{
  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 128));
  if (*(unsigned char *)(a1 + 120)) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 112));
  }
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t __copy_helper_block_a8_32c166_ZTSKZN33TIInlineCompletionEventDispatcher27did_generate_new_completionERK18TIInlineCompletionRKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::string *)(a1 + 48);
  if (*(char *)(a2 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 48);
    *(void *)(a1 + 64) = *(void *)(a2 + 64);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  char v7 = (std::string *)(a1 + 72);
  if (*(char *)(a2 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 72), *(void *)(a2 + 80));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 72);
    *(void *)(a1 + 88) = *(void *)(a2 + 88);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  uint64_t v9 = *(void *)(a2 + 96);
  int v10 = *(_DWORD *)(a2 + 104);
  *(unsigned char *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 104) = v10;
  *(void *)(a1 + 96) = v9;
  *(unsigned char *)(a1 + 120) = 0;
  if (*(unsigned char *)(a2 + 120))
  {
    MEMORY[0x1E4E7B4C0]();
    *(unsigned char *)(a1 + 120) = 1;
  }
  uint64_t result = language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 128), (const language_modeling::v1::CompletionStem *)(a2 + 128));
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
  return result;
}

std::string *std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(std::string *this, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v4;
  }
  uint64_t v5 = this + 1;
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 24);
    this[1].__r_.__value_.__r.__words[2] = *((void *)a2 + 5);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  std::string::size_type v7 = *((void *)a2 + 6);
  int v8 = *((_DWORD *)a2 + 14);
  this[2].__r_.__value_.__s.__data_[16] = 0;
  LODWORD(this[2].__r_.__value_.__r.__words[1]) = v8;
  this[2].__r_.__value_.__r.__words[0] = v7;
  this[3].__r_.__value_.__s.__data_[0] = 0;
  if (*((unsigned char *)a2 + 72))
  {
    MEMORY[0x1E4E7B4C0]();
    this[3].__r_.__value_.__s.__data_[0] = 1;
  }
  this[3].__r_.__value_.__s.__data_[8] = 1;
  return this;
}

void TIInlineCompletionEventDispatcher::did_generate_cached_completion(uint64_t a1, uint64_t a2, uint64_t a3, const language_modeling::v1::CompletionStem *a4, int a5)
{
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v12, *(void *)a1, *(std::__shared_weak_count **)(a1 + 8));
  uint64_t v10 = v12;
  uint64_t v9 = v13;
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  __int16 v11 = analytics_queue();
  uint64_t v27 = MEMORY[0x1E4F143A8];
  uint64_t v28 = 3321888768;
  int v29 = ___ZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke;
  int v30 = &__block_descriptor_224_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0_e5_v8__0l;
  uint64_t v12 = v10;
  __int16 v13 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v14, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string v14 = *(std::string *)a2;
  }
  if (*(char *)(a2 + 47) < 0) {
    std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
  }
  else {
    std::string v15 = *(std::string *)(a2 + 24);
  }
  uint64_t v16 = *(void *)(a2 + 48);
  int v17 = *(_DWORD *)(a2 + 56);
  v18[0] = 0;
  char v19 = 0;
  if (*(unsigned char *)(a2 + 72))
  {
    MEMORY[0x1E4E7B4C0](v18, a2 + 64);
    char v19 = 1;
  }
  if (*(char *)(a3 + 23) < 0) {
    std::string::__init_copy_ctor_external(&v20, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else {
    std::string v20 = *(std::string *)a3;
  }
  if (*(char *)(a3 + 47) < 0) {
    std::string::__init_copy_ctor_external(&v21, *(const std::string::value_type **)(a3 + 24), *(void *)(a3 + 32));
  }
  else {
    std::string v21 = *(std::string *)(a3 + 24);
  }
  uint64_t v22 = *(void *)(a3 + 48);
  int v23 = *(_DWORD *)(a3 + 56);
  v24[0] = 0;
  char v25 = 0;
  if (*(unsigned char *)(a3 + 72))
  {
    MEMORY[0x1E4E7B4C0](v24, a3 + 64);
    char v25 = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)v26, a4);
  v26[2] = a5;
  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0((uint64_t)v31, (uint64_t)&v12);
  TIDispatchAsync();
  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0((uint64_t)&v12);

  TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0((uint64_t)v31);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

void ___ZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModality_block_invoke(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      long long v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v9, (long long *)(a1 + 48));
        std::__optional_destruct_base<TIInlineCompletion,false>::__optional_destruct_base[abi:nn180100]<TIInlineCompletion const&>(&v8, (long long *)(a1 + 128));
        language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)&v6, (const language_modeling::v1::CompletionStem *)(a1 + 208));
        char v7 = 1;
        TIInlineCompletionEventDispatcher::_dispatch_event(v5);
        if (v7) {
          language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)&v6);
        }
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v8);
        std::__optional_destruct_base<TIInlineCompletion,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v9);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

uint64_t TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a1 = *(void *)a2;
  *(void *)(a1 + 8) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = (std::string *)(a1 + 16);
  if (*(char *)(a2 + 39) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)(a2 + 16), *(void *)(a2 + 24));
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  char v7 = (std::string *)(a1 + 40);
  if (*(char *)(a2 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)(a2 + 40), *(void *)(a2 + 48));
  }
  else
  {
    long long v8 = *(_OWORD *)(a2 + 40);
    *(void *)(a1 + 56) = *(void *)(a2 + 56);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v8;
  }
  uint64_t v9 = *(void *)(a2 + 64);
  int v10 = *(_DWORD *)(a2 + 72);
  *(unsigned char *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 72) = v10;
  *(void *)(a1 + 64) = v9;
  *(unsigned char *)(a1 + 88) = 0;
  if (*(unsigned char *)(a2 + 88))
  {
    MEMORY[0x1E4E7B4C0]();
    *(unsigned char *)(a1 + 88) = 1;
  }
  __int16 v11 = (std::string *)(a1 + 96);
  if (*(char *)(a2 + 119) < 0)
  {
    std::string::__init_copy_ctor_external(v11, *(const std::string::value_type **)(a2 + 96), *(void *)(a2 + 104));
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 96);
    *(void *)(a1 + 112) = *(void *)(a2 + 112);
    *(_OWORD *)&v11->__r_.__value_.__l.__data_ = v12;
  }
  __int16 v13 = (std::string *)(a1 + 120);
  if (*(char *)(a2 + 143) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)(a2 + 120), *(void *)(a2 + 128));
  }
  else
  {
    long long v14 = *(_OWORD *)(a2 + 120);
    *(void *)(a1 + 136) = *(void *)(a2 + 136);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
  }
  uint64_t v15 = *(void *)(a2 + 144);
  int v16 = *(_DWORD *)(a2 + 152);
  *(unsigned char *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 152) = v16;
  *(void *)(a1 + 144) = v15;
  *(unsigned char *)(a1 + 168) = 0;
  if (*(unsigned char *)(a2 + 168))
  {
    MEMORY[0x1E4E7B4C0]();
    *(unsigned char *)(a1 + 168) = 1;
  }
  language_modeling::v1::CompletionStem::CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 176), (const language_modeling::v1::CompletionStem *)(a2 + 176));
  *(_DWORD *)(a1 + 184) = *(_DWORD *)(a2 + 184);
  return a1;
}

uint64_t TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0(uint64_t a1)
{
  language_modeling::v1::CompletionStem::~CompletionStem((language_modeling::v1::CompletionStem *)(a1 + 176));
  if (*(unsigned char *)(a1 + 168)) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 160));
  }
  if (*(char *)(a1 + 143) < 0) {
    operator delete(*(void **)(a1 + 120));
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(unsigned char *)(a1 + 88)) {
    language_modeling::v1::InlineCompletion::~InlineCompletion((language_modeling::v1::InlineCompletion *)(a1 + 80));
  }
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
  if (*(char *)(a1 + 39) < 0) {
    operator delete(*(void **)(a1 + 16));
  }
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t __destroy_helper_block_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1)
{
  return TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::~$_0(a1 + 32);
}

uint64_t __copy_helper_block_a8_32c172_ZTSKZN33TIInlineCompletionEventDispatcher30did_generate_cached_completionERK18TIInlineCompletionS2_RKN17language_modeling2v114CompletionStemE23TIICSuppressionModalityE3__0(uint64_t a1, uint64_t a2)
{
  return TIInlineCompletionEventDispatcher::did_generate_cached_completion(TIInlineCompletion const&,TIInlineCompletion const&,language_modeling::v1::CompletionStem const&,TIICSuppressionModality)::$_0::$_0(a1 + 32, a2 + 32);
}

void TIInlineCompletionEventDispatcher::did_register_completion_acceptance(uint64_t a1, const KB::String *a2, const KB::String *a3, const KB::String *a4, int a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v12, *(void *)a1, *(std::__shared_weak_count **)(a1 + 8));
  uint64_t v10 = v12;
  uint64_t v9 = v13;
  if (v13)
  {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v9);
  }
  __int16 v11 = analytics_queue();
  uint64_t v21 = MEMORY[0x1E4F143A8];
  uint64_t v22 = 3321888768;
  int v23 = ___ZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionType_block_invoke;
  uint64_t v24 = &__block_descriptor_152_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0_e5_v8__0l;
  uint64_t v12 = v10;
  __int16 v13 = v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  KB::String::String((KB::String *)v14, a2);
  KB::String::String((KB::String *)v16, a3);
  KB::String::String((KB::String *)v18, a4);
  int v20 = a5;
  uint64_t v25 = v12;
  std::string v26 = v13;
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  KB::String::String((KB::String *)v27, (const KB::String *)v14);
  KB::String::String((KB::String *)v29, (const KB::String *)v16);
  KB::String::String((KB::String *)v31, (const KB::String *)v18);
  int v33 = v20;
  TIDispatchAsync();
  if (v19 && v18[6] == 1) {
    free(v19);
  }
  if (v17 && v16[6] == 1) {
    free(v17);
  }
  if (v15 && v14[6] == 1) {
    free(v15);
  }
  if (v13) {
    std::__shared_weak_count::__release_weak(v13);
  }

  if (v32 && v31[6] == 1) {
    free(v32);
  }
  if (v30 && v29[6] == 1) {
    free(v30);
  }
  if (v28 && v27[6] == 1) {
    free(v28);
  }
  if (v26) {
    std::__shared_weak_count::__release_weak(v26);
  }
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
}

void ___ZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionType_block_invoke(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 16), (KB::String *)(a1 + 48));
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 56), (KB::String *)(a1 + 80));
        std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>((KB::String *)(v5 + 96), (KB::String *)(a1 + 112));
        *(_DWORD *)(v5 + 136) = *(_DWORD *)(a1 + 144);
        *(unsigned char *)(v5 + 140) = 1;
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

void __destroy_helper_block_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0(uint64_t a1)
{
  BOOL v2 = *(void **)(a1 + 120);
  if (v2 && *(unsigned char *)(a1 + 118) == 1) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 88);
  if (v3 && *(unsigned char *)(a1 + 86) == 1) {
    free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 56);
  if (v4 && *(unsigned char *)(a1 + 54) == 1) {
    free(v4);
  }
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 40);
  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
  }
}

KB::String *__copy_helper_block_a8_32c147_ZTSKZN33TIInlineCompletionEventDispatcher34did_register_completion_acceptanceERKN2KB6StringES3_S3_41TIInlineCompletionAcceptanceRejectionTypeE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  KB::String::String((KB::String *)(a1 + 48), (const KB::String *)(a2 + 48));
  KB::String::String((KB::String *)(a1 + 80), (const KB::String *)(a2 + 80));
  uint64_t result = KB::String::String((KB::String *)(a1 + 112), (const KB::String *)(a2 + 112));
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  return result;
}

KB::String *std::optional<KB::String>::operator=[abi:nn180100]<KB::String const&,void>(KB::String *a1, KB::String *a2)
{
  if (*((unsigned char *)a1 + 32)) {
    return KB::String::operator=(a1, a2);
  }
  uint64_t result = KB::String::String(a1, a2);
  *((unsigned char *)result + 32) = 1;
  return result;
}

void TIInlineCompletionEventDispatcher::did_update_metadata(uint64_t a1, unsigned char *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  std::shared_ptr<TIInlineCompletionEventDispatcher>::shared_ptr[abi:nn180100]<TIInlineCompletionEventDispatcher,void>(&v8, *(void *)a1, *(std::__shared_weak_count **)(a1 + 8));
  uint64_t v4 = v8;
  uint64_t v3 = v9;
  if (v9)
  {
    atomic_fetch_add_explicit(&v9->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
  uint64_t v5 = analytics_queue();
  uint64_t v12 = MEMORY[0x1E4F143A8];
  uint64_t v13 = 3321888768;
  long long v14 = ___ZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEE_block_invoke;
  uint64_t v15 = &__block_descriptor_384_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0_e5_v8__0l;
  uint64_t v8 = v4;
  uint64_t v9 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v10[0] = 0;
  unsigned __int8 v11 = 0;
  int v6 = a2[328];
  if (a2[328])
  {
    std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v10, a2);
    int v6 = 1;
    unsigned __int8 v11 = 1;
    uint64_t v4 = v8;
    char v7 = v9;
  }
  else
  {
    char v7 = v3;
  }
  uint64_t v16 = v4;
  int v17 = v7;
  if (v7)
  {
    atomic_fetch_add_explicit(&v7->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    int v6 = v11;
  }
  v18[0] = 0;
  char v19 = 0;
  if (v6)
  {
    std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v18, v10);
    char v19 = 1;
  }
  TIDispatchAsync();
  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v10);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }

  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v18);
  if (v17) {
    std::__shared_weak_count::__release_weak(v17);
  }
  if (v3) {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void ___ZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEE_block_invoke(uint64_t a1)
{
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5)
      {
        int v6 = (KB::String *)(a1 + 48);
        char v7 = (KB::String *)(v5 + 144);
        if (*(unsigned __int8 *)(v5 + 472) == *(unsigned __int8 *)(a1 + 376))
        {
          if (*(unsigned char *)(v5 + 472))
          {
            KB::String::operator=(v7, v6);
            KB::String::operator=((KB::String *)(v5 + 176), (KB::String *)(a1 + 80));
            KB::String::operator=((KB::String *)(v5 + 208), (KB::String *)(a1 + 112));
            KB::String::operator=((KB::String *)(v5 + 240), (KB::String *)(a1 + 144));
            KB::String::operator=((KB::String *)(v5 + 272), (KB::String *)(a1 + 176));
            KB::String::operator=((KB::String *)(v5 + 304), (KB::String *)(a1 + 208));
            *(unsigned char *)(v5 + 336) = *(unsigned char *)(a1 + 240);
            KB::String::operator=((KB::String *)(v5 + 344), (KB::String *)(a1 + 248));
            KB::String::operator=((KB::String *)(v5 + 376), (KB::String *)(a1 + 280));
            KB::String::operator=((KB::String *)(v5 + 408), (KB::String *)(a1 + 312));
            KB::String::operator=((KB::String *)(v5 + 440), (KB::String *)(a1 + 344));
          }
        }
        else if (*(unsigned char *)(v5 + 472))
        {
          uint64_t v8 = *(void **)(v5 + 448);
          if (v8 && *(unsigned char *)(v5 + 446) == 1) {
            free(v8);
          }
          uint64_t v9 = *(void **)(v5 + 416);
          if (v9 && *(unsigned char *)(v5 + 414) == 1) {
            free(v9);
          }
          uint64_t v10 = *(void **)(v5 + 384);
          if (v10 && *(unsigned char *)(v5 + 382) == 1) {
            free(v10);
          }
          unsigned __int8 v11 = *(void **)(v5 + 352);
          if (v11 && *(unsigned char *)(v5 + 350) == 1) {
            free(v11);
          }
          uint64_t v12 = *(void **)(v5 + 312);
          if (v12 && *(unsigned char *)(v5 + 310) == 1) {
            free(v12);
          }
          uint64_t v13 = *(void **)(v5 + 280);
          if (v13 && *(unsigned char *)(v5 + 278) == 1) {
            free(v13);
          }
          long long v14 = *(void **)(v5 + 248);
          if (v14 && *(unsigned char *)(v5 + 246) == 1) {
            free(v14);
          }
          uint64_t v15 = *(void **)(v5 + 216);
          if (v15 && *(unsigned char *)(v5 + 214) == 1) {
            free(v15);
          }
          uint64_t v16 = *(void **)(v5 + 184);
          if (v16 && *(unsigned char *)(v5 + 182) == 1) {
            free(v16);
          }
          int v17 = *(void **)(v5 + 152);
          if (v17 && *(unsigned char *)(v5 + 150) == 1) {
            free(v17);
          }
          *(unsigned char *)(v5 + 472) = 0;
        }
        else
        {
          std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(v7, v6);
          *(unsigned char *)(v5 + 472) = 1;
        }
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
}

unsigned char *std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(unsigned char *a1, unsigned char *a2)
{
  uint64_t v4 = KB::String::String((KB::String *)a1, (const KB::String *)a2);
  KB::String::String((KB::String *)((char *)v4 + 32), (const KB::String *)(a2 + 32));
  KB::String::String((KB::String *)(a1 + 64), (const KB::String *)(a2 + 64));
  KB::String::String((KB::String *)(a1 + 96), (const KB::String *)(a2 + 96));
  KB::String::String((KB::String *)(a1 + 128), (const KB::String *)(a2 + 128));
  KB::String::String((KB::String *)(a1 + 160), (const KB::String *)(a2 + 160));
  a1[192] = a2[192];
  KB::String::String((KB::String *)(a1 + 200), (const KB::String *)(a2 + 200));
  KB::String::String((KB::String *)(a1 + 232), (const KB::String *)(a2 + 232));
  KB::String::String((KB::String *)(a1 + 264), (const KB::String *)(a2 + 264));
  KB::String::String((KB::String *)(a1 + 296), (const KB::String *)(a2 + 296));
  return a1;
}

uint64_t std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 328))
  {
    BOOL v2 = *(void **)(a1 + 304);
    if (v2 && *(unsigned char *)(a1 + 302) == 1) {
      free(v2);
    }
    uint64_t v3 = *(void **)(a1 + 272);
    if (v3 && *(unsigned char *)(a1 + 270) == 1) {
      free(v3);
    }
    uint64_t v4 = *(void **)(a1 + 240);
    if (v4 && *(unsigned char *)(a1 + 238) == 1) {
      free(v4);
    }
    uint64_t v5 = *(void **)(a1 + 208);
    if (v5 && *(unsigned char *)(a1 + 206) == 1) {
      free(v5);
    }
    int v6 = *(void **)(a1 + 168);
    if (v6 && *(unsigned char *)(a1 + 166) == 1) {
      free(v6);
    }
    char v7 = *(void **)(a1 + 136);
    if (v7 && *(unsigned char *)(a1 + 134) == 1) {
      free(v7);
    }
    uint64_t v8 = *(void **)(a1 + 104);
    if (v8 && *(unsigned char *)(a1 + 102) == 1) {
      free(v8);
    }
    uint64_t v9 = *(void **)(a1 + 72);
    if (v9 && *(unsigned char *)(a1 + 70) == 1) {
      free(v9);
    }
    uint64_t v10 = *(void **)(a1 + 40);
    if (v10 && *(unsigned char *)(a1 + 38) == 1) {
      free(v10);
    }
    unsigned __int8 v11 = *(void **)(a1 + 8);
    if (v11 && *(unsigned char *)(a1 + 6) == 1) {
      free(v11);
    }
  }
  return a1;
}

void __destroy_helper_block_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0(uint64_t a1)
{
  std::__optional_destruct_base<TIInlineCompletionAnalyticsMetadata,false>::~__optional_destruct_base[abi:nn180100](a1 + 48);
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

unsigned char *__copy_helper_block_a8_32c127_ZTSKZN33TIInlineCompletionEventDispatcher19did_update_metadataERKNSt3__18optionalI35TIInlineCompletionAnalyticsMetadataEEE3__0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 48) = 0;
  uint64_t result = (unsigned char *)(a1 + 48);
  *(unsigned char *)(a1 + 376) = 0;
  if (*(unsigned char *)(a2 + 376))
  {
    uint64_t result = std::construct_at[abi:nn180100]<TIInlineCompletionAnalyticsMetadata,TIInlineCompletionAnalyticsMetadata const&,TIInlineCompletionAnalyticsMetadata*>(result, (unsigned char *)(a2 + 48));
    *(unsigned char *)(a1 + 376) = 1;
  }
  return result;
}

void *std::vector<KB::LexiconInfo>::__init_with_size[abi:nn180100]<KB::LexiconInfo*,KB::LexiconInfo*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x1745D1745D1745ELL) {
      abort();
    }
    int v6 = result;
    uint64_t result = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(a4);
    *int v6 = result;
    v6[1] = result;
    v6[2] = &result[22 * v7];
    while (a2 != a3)
    {
      uint64_t v8 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>((uint64_t)result, a2);
      a2 += 176;
      uint64_t result = (void *)(v8 + 176);
    }
    v6[1] = result;
  }
  return result;
}

uint64_t __Block_byref_object_copy__54(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t __Block_byref_object_dispose__55(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::~__hash_table(a1 + 48);
}

uint64_t __Block_byref_object_copy__2588(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2589(uint64_t a1)
{
}

char *std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    unint64_t v8 = (uint64_t *)a2;
  }
  else {
    unint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    uint64_t v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      uint64_t v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          unint64_t v17 = *((void *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12) {
                v17 %= v12;
              }
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3) {
              break;
            }
          }
          uint64_t v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  uint64_t v18 = a1 + 2;
  uint64_t v16 = (char *)operator new(0x60uLL);
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v11;
  char v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }
  v42[0] = 0;
  v42[1] = 0;
  KB::LanguageModelLexiconGroup::LanguageModelLexiconGroup((uint64_t)(v16 + 40), v42);
  float v20 = *((float *)a1 + 8);
  float v21 = (float)(unint64_t)(a1[3] + 1);
  if (!v12 || (float)(v20 * (float)v12) < v21)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v21 / v20);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v12 = a1[1];
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          std::string v26 = operator new(8 * *(void *)&prime);
          uint64_t v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v28++) = 0;
          while (*(void *)&prime != v28);
          int v29 = (void *)*v18;
          if (*v18)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }
            else
            {
              v30 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v30) = v18;
            long long v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }
                else
                {
                  v36 &= *(void *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(void *)(*a1 + 8 * v36))
                  {
                    *(void *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }
                  *int v29 = *v35;
                  *long long v35 = **(void **)(*a1 + 8 * v36);
                  **(void **)(*a1 + 8 * v36) = v35;
                  long long v35 = v29;
                }
                unint64_t v36 = v30;
LABEL_64:
                int v29 = v35;
                long long v35 = (void *)*v35;
                unint64_t v30 = v36;
              }
              while (v35);
            }
          }
          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        std::string v41 = (void *)*a1;
        *a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v37 = *a1;
  int v38 = *(void **)(*a1 + 8 * v3);
  if (v38)
  {
    *(void *)uint64_t v16 = *v38;
LABEL_81:
    void *v38 = v16;
    goto LABEL_82;
  }
  *(void *)uint64_t v16 = *v18;
  *uint64_t v18 = v16;
  *(void *)(v37 + 8 * v3) = v18;
  if (*(void *)v16)
  {
    unint64_t v39 = *(void *)(*(void *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12) {
        v39 %= v12;
      }
    }
    else
    {
      v39 &= v12 - 1;
    }
    int v38 = (void *)(*a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v16;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(unint64_t a1)
{
  if (a1 >> 60) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(16 * a1);
}

uint64_t std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 16) = v2 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v2 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 16;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  dispatch_queue_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
        if (v6) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v6);
        }
        v4 -= 16;
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::allocate_shared[abi:nn180100]<KB::UnigramCandidateRefinery,std::allocator<KB::UnigramCandidateRefinery>,WTF::RefPtr<KB::DictionaryContainer> const&,void>(void *a1, atomic_uint *a2)
{
  uint64_t result = operator new(0x28uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_1F3F76678;
  result[3] = &unk_1F3F796E0;
  result[4] = a2;
  if (a2) {
    atomic_fetch_add(a2, 1u);
  }
  *a1 = result + 3;
  a1[1] = result;
  return result;
}

void std::vector<KB::LanguageModelLexiconGroup>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  dispatch_queue_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 56;
        std::__destroy_at[abi:nn180100]<KB::LanguageModelLexiconGroup,0>(v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,KB::LanguageModelLexiconGroup>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,KB::LanguageModelLexiconGroup>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,KB::LanguageModelLexiconGroup>,0>(uint64_t a1)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 40);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void std::__destroy_at[abi:nn180100]<KB::LanguageModelLexiconGroup,0>(uint64_t a1)
{
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table(a1 + 16);
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
}

uint64_t std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F76678;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::UnigramCandidateRefinery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F76678;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_pointer<KB::LanguageModelContainer *,std::shared_ptr<KB::LanguageModelContainer>::__shared_ptr_default_delete<KB::LanguageModelContainer,KB::LanguageModelContainer>,std::allocator<KB::LanguageModelContainer>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<KB::LanguageModelContainer *,std::shared_ptr<KB::LanguageModelContainer>::__shared_ptr_default_delete<KB::LanguageModelContainer,KB::LanguageModelContainer>,std::allocator<KB::LanguageModelContainer>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

uint64_t std::unordered_map<unsigned int,float>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(void *)(a2 + 8));
  uint64_t v5 = *(uint64_t ***)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 16);
    unint64_t v7 = *(void *)(a1 + 8);
    do
    {
      unint64_t v8 = *((unsigned int *)v5 + 4);
      if (v7)
      {
        uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          unint64_t v2 = *((unsigned int *)v5 + 4);
          if (v7 <= v8) {
            unint64_t v2 = v8 % v7;
          }
        }
        else
        {
          unint64_t v2 = (v7 - 1) & v8;
        }
        unint64_t v10 = *(uint64_t ***)(*(void *)a1 + 8 * v2);
        if (v10)
        {
          for (uint64_t i = *v10; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v12 = i[1];
            if (v12 == v8)
            {
              if (*((_DWORD *)i + 4) == v8) {
                goto LABEL_41;
              }
            }
            else
            {
              if (v9.u32[0] > 1uLL)
              {
                if (v12 >= v7) {
                  v12 %= v7;
                }
              }
              else
              {
                v12 &= v7 - 1;
              }
              if (v12 != v2) {
                break;
              }
            }
          }
        }
      }
      uint8x8_t v13 = operator new(0x18uLL);
      *uint8x8_t v13 = 0;
      v13[1] = v8;
      void v13[2] = v5[2];
      float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v15 = *(float *)(a1 + 32);
      if (!v7 || (float)(v15 * (float)v7) < v14)
      {
        BOOL v16 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3) {
          BOOL v16 = 1;
        }
        unint64_t v17 = v16 | (2 * v7);
        unint64_t v18 = vcvtps_u32_f32(v14 / v15);
        if (v17 <= v18) {
          size_t v19 = v18;
        }
        else {
          size_t v19 = v17;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v19);
        unint64_t v7 = *(void *)(a1 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v8) {
            unint64_t v2 = v8 % v7;
          }
          else {
            unint64_t v2 = v8;
          }
        }
        else
        {
          unint64_t v2 = (v7 - 1) & v8;
        }
      }
      uint64_t v20 = *(void *)a1;
      float v21 = *(void **)(*(void *)a1 + 8 * v2);
      if (v21)
      {
        *uint8x8_t v13 = *v21;
      }
      else
      {
        *uint8x8_t v13 = *v6;
        *uint64_t v6 = v13;
        *(void *)(v20 + 8 * v2) = v6;
        if (!*v13) {
          goto LABEL_40;
        }
        unint64_t v22 = *(void *)(*v13 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v22 >= v7) {
            v22 %= v7;
          }
        }
        else
        {
          v22 &= v7 - 1;
        }
        float v21 = (void *)(*(void *)a1 + 8 * v22);
      }
      void *v21 = v13;
LABEL_40:
      ++*(void *)(a1 + 24);
LABEL_41:
      uint64_t v5 = (uint64_t **)*v5;
    }
    while (v5);
  }
  return a1;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelLexiconGroup>>(unint64_t a1)
{
  if (a1 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(56 * a1);
}

uint64_t __Block_byref_object_copy__45(uint64_t a1, uint64_t a2)
{
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__hash_table(a1 + 48, (uint64_t *)(a2 + 48));
}

uint64_t __Block_byref_object_dispose__46(uint64_t a1)
{
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(a1 + 48);
}

__n128 __Block_byref_object_copy__47(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

void __Block_byref_object_dispose__48(uint64_t a1)
{
  dispatch_queue_t v1 = (void **)(a1 + 48);
  std::vector<KB::LexiconInfo>::__destroy_vector::operator()[abi:nn180100](&v1);
}

uint64_t TIInputManager::advanced_models_loaded(TIInputManager *this)
{
  uint64_t result = *((void *)this + 29);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    if (result) {
      return (*(uint64_t (**)(void))(**((void **)this + 29) + 152))(*((void *)this + 29)) != 0;
    }
  }
  return result;
}

uint64_t __Block_byref_object_copy__2680(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2681(uint64_t a1)
{
}

id TIStatisticsCategoryToLegacyCategoryDictionary()
{
  if (TIStatisticsCategoryToLegacyCategoryDictionary_onceToken != -1) {
    dispatch_once(&TIStatisticsCategoryToLegacyCategoryDictionary_onceToken, &__block_literal_global_3047);
  }
  uint64_t v0 = (void *)TIStatisticsCategoryToLegacyCategoryDictionary_dict;

  return v0;
}

id TIStatisticsDescriptionToLegacyDescriptionDictionary()
{
  if (TIStatisticsDescriptionToLegacyDescriptionDictionary_onceToken != -1) {
    dispatch_once(&TIStatisticsDescriptionToLegacyDescriptionDictionary_onceToken, &__block_literal_global_346);
  }
  uint64_t v0 = (void *)TIStatisticsDescriptionToLegacyDescriptionDictionary_dict;

  return v0;
}

id TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary()
{
  if (TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_onceToken != -1) {
    dispatch_once(&TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_onceToken, &__block_literal_global_348);
  }
  uint64_t v0 = (void *)TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_dict;

  return v0;
}

void __TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_block_invoke()
{
  v3[4] = *MEMORY[0x1E4F143B8];
  v2[0] = @"noMatchUserInpt";
  v2[1] = @"moderatMatchUserInpt";
  v3[0] = @"noMatchUserInpt";
  v3[1] = @"moderatMatchUserInpt";
  v2[2] = @"mildMatchUserInpt";
  char v2[3] = @"exactMatchUserInpt";
  v3[2] = @"mildMatchUserInpt";
  void v3[3] = @"exactMatchUserInpt";
  uint64_t v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:v2 count:4];
  dispatch_queue_t v1 = (void *)TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_dict;
  TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary_dict = v0;
}

void __TIStatisticsDescriptionToLegacyDescriptionDictionary_block_invoke()
{
  v3[49] = *MEMORY[0x1E4F143B8];
  v2[0] = @"None";
  v2[1] = @"NotSupByAp";
  v3[0] = @"None";
  v3[1] = @"NotSupByAp";
  v2[2] = @"DevLocked";
  char v2[3] = @"ItemCrFail";
  v3[2] = @"DevLocked";
  void v3[3] = @"ItemCrFail";
  void v2[4] = @"UnsupSmTyp";
  v2[5] = @"UnauSemClt";
  v3[4] = @"UnsupSmTyp";
  void v3[5] = @"UnauSemClt";
  v2[6] = @"DtCoTmExc";
  v2[7] = @"PBCutoff";
  void v3[6] = @"DtCoTmExc";
  v3[7] = @"PBCutoff";
  v2[8] = @"PBEmpty";
  v2[9] = @"CntSInitTO";
  v3[8] = @"PBEmpty";
  v3[9] = @"CntSInitTO";
  v2[10] = @"FieldsNone";
  v2[11] = @"NoMeCard";
  v3[10] = @"FieldsNone";
  v3[11] = @"NoMeCard";
  v2[12] = @"CntNotHvFd";
  v2[13] = @"SGNmLupFEr";
  v3[12] = @"CntNotHvFd";
  v3[13] = @"SGNmLupFEr";
  v2[14] = @"CNNmLupFEr";
  v2[15] = @"NoNamMatch";
  v3[14] = @"CNNmLupFEr";
  v3[15] = @"NoNamMatch";
  v2[16] = @"TooAmbigus";
  v2[17] = @"3PWoName";
  v3[16] = @"TooAmbigus";
  v3[17] = @"3PWoName";
  v2[18] = @"ESrvInitTO";
  v2[19] = @"EKAccDen";
  v3[18] = @"ESrvInitTO";
  v3[19] = @"EKAccDen";
  v2[20] = @"EKAccTO";
  v2[21] = @"NoEvents";
  v3[20] = @"EKAccTO";
  v3[21] = @"NoEvents";
  v2[22] = @"RPoINoRecp";
  v2[23] = @"NAPoIInEvt";
  v3[22] = @"RPoINoRecp";
  v3[23] = @"NAPoIInEvt";
  unsigned char v2[24] = @"NoFrEvents";
  v2[25] = @"NoBsEvents";
  v3[24] = @"NoFrEvents";
  v3[25] = @"NoBsEvents";
  v2[26] = @"EventNoLoc";
  v2[27] = @"UnsupTimeC";
  v3[26] = @"EventNoLoc";
  v3[27] = @"UnsupTimeC";
  v2[28] = @"DuetNoAct";
  v2[29] = @"DuetQryTO";
  v3[28] = @"DuetNoAct";
  v3[29] = @"DuetQryTO";
  v2[30] = @"CalSrcNoEv";
  v2[31] = @"CalSrcInel";
  v3[30] = @"CalSrcNoEv";
  v3[31] = @"CalSrcInel";
  v2[32] = @"StreetTO";
  v2[33] = @"RouteTO";
  v3[32] = @"StreetTO";
  v3[33] = @"RouteTO";
  v2[34] = @"NavTimeMis";
  v2[35] = @"NavStrMis";
  v3[34] = @"NavTimeMis";
  v3[35] = @"NavStrMis";
  v2[36] = @"NavDistMis";
  v2[37] = @"NavDstMiss";
  v3[36] = @"NavDistMis";
  v3[37] = @"NavDstMiss";
  v2[38] = @"NavNotNav";
  v2[39] = @"NavEnded";
  v3[38] = @"NavNotNav";
  v3[39] = @"NavEnded";
  v2[40] = @"NavGuideTO";
  v2[41] = @"NavInitTO";
  v3[40] = @"NavGuideTO";
  v3[41] = @"NavInitTO";
  v2[42] = @"HKQueryTO";
  v2[43] = @"HKDataNAvl";
  v3[42] = @"HKQueryTO";
  v3[43] = @"HKDataNAvl";
  v2[44] = @"HKSvInitTO";
  v2[45] = @"HKSvNoSamp";
  v3[44] = @"HKSvInitTO";
  v3[45] = @"HKSvNoSamp";
  v2[46] = @"HKError";
  v2[47] = @"CntMkVlSmp";
  v3[46] = @"HKError";
  v3[47] = @"CntMkVlSmp";
  v2[48] = @"PerAppSet";
  v3[48] = @"PerAppSet";
  uint64_t v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:v2 count:49];
  dispatch_queue_t v1 = (void *)TIStatisticsDescriptionToLegacyDescriptionDictionary_dict;
  TIStatisticsDescriptionToLegacyDescriptionDictionary_dict = v0;
}

void __TIStatisticsCategoryToLegacyCategoryDictionary_block_invoke()
{
  v3[21] = *MEMORY[0x1E4F143B8];
  v2[0] = @"1stPerson";
  v2[1] = @"3rdPerson";
  v3[0] = @"1stPersonCategory";
  v3[1] = @"3rdPersonCategory";
  v2[2] = @"contactAnyPhone";
  char v2[3] = @"contactSpecificPhone";
  v3[2] = @"contactCategory.anyPhone";
  void v3[3] = @"contactCategory.specificPhone";
  void v2[4] = @"contactAddressWork";
  v2[5] = @"contactAddressHome";
  v3[4] = @"contactCategory.addressWork";
  void v3[5] = @"contactCategory.addressHome";
  v2[6] = @"contactAnyAddress";
  v2[7] = @"contactFax";
  void v3[6] = @"contactCategory.anyAddress";
  v3[7] = @"contactCategory.fax";
  v2[8] = @"contactEmail";
  v2[9] = @"contactFaceTime";
  v3[8] = @"contactCategory.email";
  v3[9] = @"contactCategory.facetime";
  v2[10] = @"contactBio";
  v2[11] = @"locationAutocompleteSendCurrentButton";
  v3[10] = @"contactCategory.bio";
  v3[11] = @"locationAutocomplete.sendCurrentButton";
  v2[12] = @"recentGenericAddress";
  v2[13] = @"recentAddress";
  v3[12] = @"recentCategory.genericAddress";
  v3[13] = @"recentCategory.address";
  v2[14] = @"recentPhone";
  v2[15] = @"eventAvailability";
  v3[14] = @"recentCategory.phone";
  v3[15] = @"eventCategory.availability";
  v2[16] = @"eventNext";
  v2[17] = @"money";
  v3[16] = @"eventCategory.next";
  v3[17] = @"moneyCategory";
  v2[18] = @"socialMedia";
  v2[19] = @"health";
  v3[18] = @"socialMediaCategory";
  v3[19] = @"healthCategory";
  v2[20] = @"navigation";
  v3[20] = @"navigationCategory";
  uint64_t v0 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v3 forKeys:v2 count:21];
  dispatch_queue_t v1 = (void *)TIStatisticsCategoryToLegacyCategoryDictionary_dict;
  TIStatisticsCategoryToLegacyCategoryDictionary_dict = v0;
}

void TIStatisticsReportCPStats(unsigned int a1, int a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = (void *)[objc_alloc(MEMORY[0x1E4F1CB18]) initWithSuiteName:@"com.apple.keyboard"];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __TIStatisticsReportCPStats_block_invoke;
  block[3] = &unk_1E6E2DE00;
  id v7 = v6;
  id v15 = v7;
  if (TIStatisticsReportCPStats_onceToken != -1) {
    dispatch_once(&TIStatisticsReportCPStats_onceToken, block);
  }
  unsigned int v8 = TIStatisticsReportCPStats_usageCountDefaults;
  if (a1) {
    unsigned int v8 = a1;
  }
  if (TIStatisticsReportCPStats_didDiscover) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v8 > 3;
  }
  char v10 = v9;
  TIStatisticsReportCPStats_didDiscover = v10;
  if (a2)
  {
    uint64_t v11 = *MEMORY[0x1E4FAEE50];
    unint64_t v12 = TIStatisticGetKeyForInputMode();
    TIStatisticScalarSetBoolean();

    [v7 setBool:TIStatisticsReportCPStats_didDiscover forKey:v11];
  }
  uint8x8_t v13 = TIStatisticGetKeyForInputMode();
  TIStatisticScalarSetBoolean();
}

uint64_t __TIStatisticsReportCPStats_block_invoke(uint64_t a1)
{
  TIStatisticsReportCPStats_usageCountDefaults = [*(id *)(a1 + 32) integerForKey:@"kbUserDidPath"];
  uint64_t result = [*(id *)(a1 + 32) BOOLForKey:*MEMORY[0x1E4FAEE50]];
  TIStatisticsReportCPStats_didDiscover = result;
  if (TIStatisticsReportCPStats_usageCountDefaults == 0x7FFFFFFFFFFFFFFFLL) {
    TIStatisticsReportCPStats_usageCountDefaults = 3;
  }
  return result;
}

id TIStatisticsLegacyCategoryForCategory(void *a1)
{
  id v1 = a1;
  unint64_t v2 = TIStatisticsCategoryToLegacyCategoryDictionary();
  uint64_t v3 = [v2 objectForKeyedSubscript:v1];

  return v3;
}

__CFString *TIStatisticsLegacySourceStringFromTrigger(void *a1)
{
  unsigned int v1 = [a1 triggerSourceType];
  if (v1 > 2) {
    return 0;
  }
  else {
    return off_1E6E2A350[v1];
  }
}

id TIStatisticsCategoriesForProactiveTrigger(void *a1)
{
  id v1 = a1;
  int v2 = [v1 triggerSourceType];
  uint64_t v3 = [v1 attributes];

  uint64_t v4 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v5 = [v3 objectForKey:*MEMORY[0x1E4F72330]];
  uint64_t v6 = (void *)v5;
  if (v5) {
    id v7 = (__CFString *)v5;
  }
  else {
    id v7 = &stru_1F3F7A998;
  }
  unsigned int v8 = v7;

  uint64_t v9 = [v3 objectForKey:*MEMORY[0x1E4F72308]];
  char v10 = (void *)v9;
  if (v9) {
    uint64_t v11 = (__CFString *)v9;
  }
  else {
    uint64_t v11 = &stru_1F3F7A998;
  }
  unint64_t v12 = v11;

  uint64_t v13 = [v3 objectForKey:*MEMORY[0x1E4F721D0]];
  float v14 = (void *)v13;
  if (v13) {
    id v15 = (__CFString *)v13;
  }
  else {
    id v15 = &stru_1F3F7A998;
  }
  BOOL v16 = v15;

  uint64_t v17 = [v3 objectForKey:*MEMORY[0x1E4F722F0]];
  unint64_t v18 = (void *)v17;
  if (v17) {
    size_t v19 = (__CFString *)v17;
  }
  else {
    size_t v19 = &stru_1F3F7A998;
  }
  uint64_t v20 = v19;

  if (([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F72228]] & 1) != 0
    || ([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F722F8]]
      ? (BOOL v21 = v2 == 1)
      : (BOOL v21 = 0),
        v21))
  {
    [v4 addObject:@"1stPerson"];
  }
  if ([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F72320]]) {
    [v4 addObject:@"3rdPerson"];
  }
  if ([(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F722C0]])
  {
    if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F722C8]])
    {
      unint64_t v22 = @"contactAnyPhone";
LABEL_60:
      [v4 addObject:v22];
      goto LABEL_61;
    }
    if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72290]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72268]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72350]] & 1) != 0)
    {
      unint64_t v22 = @"contactSpecificPhone";
      goto LABEL_60;
    }
    if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72220]])
    {
      unint64_t v22 = @"contactFax";
      goto LABEL_60;
    }
    if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F721B0]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F722D0]] & 1) != 0)
    {
      unint64_t v22 = @"contactAnyAddress";
      goto LABEL_60;
    }
    if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72258]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72260]] & 1) != 0)
    {
      unint64_t v22 = @"contactAddressHome";
      goto LABEL_60;
    }
    if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72340]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72348]] & 1) != 0)
    {
      unint64_t v22 = @"contactAddressWork";
      goto LABEL_60;
    }
    if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72200]])
    {
      unint64_t v22 = @"contactEmail";
      goto LABEL_60;
    }
    if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72210]])
    {
      unint64_t v22 = @"contactFaceTime";
      goto LABEL_60;
    }
    if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F721B8]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72240]] & 1) != 0
      || ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72310]] & 1) != 0)
    {
      unint64_t v22 = @"contactBio";
      goto LABEL_60;
    }
    if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F72300]])
    {
      unint64_t v22 = @"socialMedia";
      goto LABEL_60;
    }
  }
  else if ([(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F72280]])
  {
    if ([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F721C8]])
    {
      unint64_t v22 = @"locationAutocompleteSendCurrentButton";
      goto LABEL_60;
    }
    if ([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F722E8]])
    {
      if ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F721B0]])
      {
        unint64_t v22 = @"recentGenericAddress";
      }
      else
      {
        if (([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F722C8]] & 1) == 0) {
          goto LABEL_61;
        }
        unint64_t v22 = @"recentPhone";
      }
      goto LABEL_60;
    }
    if ([(__CFString *)v12 isEqualToString:*MEMORY[0x1E4F722E0]]
      && ([(__CFString *)v16 isEqualToString:*MEMORY[0x1E4F721B0]] & 1) != 0)
    {
      unint64_t v22 = @"recentAddress";
      goto LABEL_60;
    }
  }
  else
  {
    if (![(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F72208]])
    {
      if ([(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F962C8]])
      {
        unint64_t v22 = @"money";
      }
      else if ([(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F72250]])
      {
        unint64_t v22 = @"health";
      }
      else
      {
        if (![(__CFString *)v8 isEqualToString:*MEMORY[0x1E4F722A8]]) {
          goto LABEL_61;
        }
        unint64_t v22 = @"navigation";
      }
      goto LABEL_60;
    }
    if (([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F722B8]] & 1) != 0
      || ([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F721E0]] & 1) != 0
      || ([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F72270]] & 1) != 0)
    {
      unint64_t v22 = @"eventAvailability";
      goto LABEL_60;
    }
    if (([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F722B0]] & 1) != 0
      || ([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F72328]] & 1) != 0
      || ([(__CFString *)v20 isEqualToString:*MEMORY[0x1E4F72278]] & 1) != 0)
    {
      unint64_t v22 = @"eventNext";
      goto LABEL_60;
    }
  }
LABEL_61:

  return v4;
}

void TIStatisticLogProactiveInfo(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  context = (void *)MEMORY[0x1E4E7C3D0]();
  uint64_t v11 = [MEMORY[0x1E4F28E78] string];
  [v11 appendString:@"proactive."];
  uint64_t v27 = v8;
  [v11 appendString:v8];
  [v11 appendString:@"."];
  unint64_t v12 = v11;
  uint64_t v13 = (void *)[v11 mutableCopy];
  float v14 = v10;
  [v13 appendString:v10];
  [v13 appendString:@"."];
  int v29 = v7;
  [v13 appendString:v7];
  uint64_t v25 = v13;
  id v15 = TIStatisticGetKey();
  TIStatisticScalarIncrement();

  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  obuint64_t j = v9;
  uint64_t v16 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
  if (v16)
  {
    uint64_t v17 = v16;
    uint64_t v18 = *(void *)v31;
    do
    {
      uint64_t v19 = 0;
      do
      {
        if (*(void *)v31 != v18) {
          objc_enumerationMutation(obj);
        }
        uint64_t v20 = *(void **)(*((void *)&v30 + 1) + 8 * v19);
        BOOL v21 = (void *)MEMORY[0x1E4E7C3D0]();
        unint64_t v22 = TIStatisticsLegacyCategoryForCategory(v20);
        unint64_t v23 = (void *)[v12 mutableCopy];
        [v23 appendString:v22];
        [v23 appendString:@"."];
        [v23 appendString:v14];
        [v23 appendString:@"."];
        [v23 appendString:v29];
        unint64_t v24 = TIStatisticGetKey();
        TIStatisticScalarIncrement();

        ++v19;
      }
      while (v17 != v19);
      uint64_t v17 = [obj countByEnumeratingWithState:&v30 objects:v34 count:16];
    }
    while (v17);
  }
}

__CFString *TIStatisticLegacyStringFromMetricType(int a1)
{
  if ((a1 - 1) > 6) {
    return @"triggered";
  }
  else {
    return off_1E6E2A318[(a1 - 1)];
  }
}

void TIStatisticLogProactive(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v8 = a1;
  id v9 = a2;
  id v10 = a4;
  id v11 = a5;
  if (v9)
  {
    unint64_t v12 = _TIQueueBackground();
    id v15 = v9;
    id v16 = v10;
    id v17 = v8;
    id v18 = v11;
    TIDispatchAsync();

    uint64_t v13 = v15;
  }
  else
  {
    uint64_t v13 = TIProactiveQuickTypeOSLogFacility();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      float v14 = objc_msgSend(NSString, "stringWithFormat:", @"%s %s", "TIStatisticLogProactive", "Unexpected nil trigger");
      *(_DWORD *)buf = 138412290;
      uint64_t v20 = v14;
      _os_log_error_impl(&dword_1E3F0E000, v13, OS_LOG_TYPE_ERROR, "%@", buf, 0xCu);
    }
  }
}

void __TIStatisticLogProactive_block_invoke(uint64_t a1)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  uint64_t v3 = [*(id *)(a1 + 32) attributes];
  uint64_t v4 = [v3 objectForKey:*MEMORY[0x1E4F72330]];
  uint64_t v5 = [v3 objectForKey:*MEMORY[0x1E4F721D0]];
  uint64_t v6 = *(__CFString **)(a1 + 40);
  if (!v6) {
    uint64_t v6 = @"NA";
  }
  id v7 = v6;
  if (![v4 isEqualToString:*MEMORY[0x1E4F722C0]]
    || v5
    && ([MEMORY[0x1E4F1CA98] null],
        id v8 = objc_claimAutoreleasedReturnValue(),
        char v9 = [v5 isEqual:v8],
        v8,
        (v9 & 1) == 0))
  {
    uint64_t v10 = *(unsigned __int8 *)(a1 + 64);
    id v11 = *(id *)(a1 + 32);
    uint64_t v44 = v5;
    unint64_t v43 = v7;
    if (TIStatisticCheckRecentTriggersForTrigger_onceToken != -1) {
      dispatch_once(&TIStatisticCheckRecentTriggersForTrigger_onceToken, &__block_literal_global_632);
    }
    id v12 = (id)TIStatisticCheckRecentTriggersForTrigger_recentByMetricType;
    objc_sync_enter(v12);
    uint64_t v13 = (void *)TIStatisticCheckRecentTriggersForTrigger_recentByMetricType;
    float v14 = [NSNumber numberWithUnsignedChar:v10];
    id v15 = [v13 objectForKeyedSubscript:v14];

    if (!v15)
    {
      id v15 = (void *)[objc_alloc(MEMORY[0x1E4F28BD0]) initWithCapacity:2];
      id v16 = (void *)TIStatisticCheckRecentTriggersForTrigger_recentByMetricType;
      id v17 = [NSNumber numberWithUnsignedChar:v10];
      [v16 setObject:v15 forKeyedSubscript:v17];
    }
    objc_sync_exit(v12);

    id v18 = v15;
    objc_sync_enter(v18);
    int v19 = [v18 containsObject:v11];
    [v18 addObject:v11];
    dispatch_time_t v20 = dispatch_time(0, 300000000000);
    uint64_t v21 = _TIQueueLow();
    *(void *)&blocuint64_t k = MEMORY[0x1E4F143A8];
    *((void *)&block + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 3221225472;
    unint64_t v51 = __TIStatisticCheckRecentTriggersForTrigger_block_invoke_2;
    unint64_t v52 = &unk_1E6E2E220;
    id v53 = v18;
    id v54 = v11;
    id v22 = v18;
    id v23 = v11;
    dispatch_after(v20, v21, &block);

    objc_sync_exit(v22);
    if (v19 && (*(unsigned char *)(a1 + 64) & 0xFE) != 6)
    {
      std::string v26 = TIProactiveQuickTypeOSLogFacility();
      id v7 = v43;
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
LABEL_37:

        goto LABEL_38;
      }
      uint64_t v28 = objc_msgSend(NSString, "stringWithFormat:", @"%s %s", "TIStatisticLogProactive_block_invoke", "Filtering out likely overlogging of offered proactive candidate.");
      LODWORD(block) = 138412290;
      *(void *)((char *)&block + 4) = v28;
      _os_log_debug_impl(&dword_1E3F0E000, v26, OS_LOG_TYPE_DEBUG, "%@", (uint8_t *)&block, 0xCu);
    }
    else
    {
      unsigned int v24 = [*(id *)(a1 + 32) triggerSourceType];
      id v7 = v43;
      if (v24 > 2) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = off_1E6E2A350[v24];
      }
      std::string v26 = TIStatisticsCategoriesForProactiveTrigger(*(void **)(a1 + 32));
      if (*(unsigned __int8 *)(a1 + 64) - 1 > 6) {
        uint64_t v27 = @"triggered";
      }
      else {
        uint64_t v27 = off_1E6E2A318[(*(unsigned char *)(a1 + 64) - 1)];
      }
      TIStatisticLogProactiveInfo(*(void **)(a1 + 48), v25, v26, v27);
      uint64_t v28 = +[_TIStatisticsProactiveTracker sharedInstance];
      switch(*(unsigned char *)(a1 + 64))
      {
        case 0:
          objc_msgSend(v28, "trackTriggeredWithSource:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), v26, *(void *)(a1 + 48), v43);
          break;
        case 1:
        case 2:
        case 3:
          objc_msgSend(v28, "trackFailureWithSource:reason:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), *(unsigned __int8 *)(a1 + 64), v26, *(void *)(a1 + 48), v43);
          break;
        case 4:
          uint64_t v42 = v2;
          uint64_t v29 = [*(id *)(a1 + 32) triggerSourceType];
          uint64_t v30 = *(void *)(a1 + 48);
          std::string v41 = v28;
          long long v31 = v28;
          uint64_t v32 = 1;
          goto LABEL_26;
        case 5:
          uint64_t v42 = v2;
          uint64_t v29 = [*(id *)(a1 + 32) triggerSourceType];
          uint64_t v30 = *(void *)(a1 + 48);
          std::string v41 = v28;
          long long v31 = v28;
          uint64_t v32 = 2;
LABEL_26:
          [v31 trackSuggestedWithSource:v29 count:v32 categories:v26 locale:v30 fieldType:v43];
          uint64_t v33 = 3;
          goto LABEL_28;
        case 6:
          uint64_t v42 = v2;
          std::string v41 = v28;
          objc_msgSend(v28, "trackSelectedWithSource:position:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), 0, v26, *(void *)(a1 + 48), v43);
          uint64_t v33 = 1;
          goto LABEL_28;
        case 7:
          uint64_t v42 = v2;
          uint64_t v33 = 1;
          std::string v41 = v28;
          objc_msgSend(v28, "trackSelectedWithSource:position:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), 1, v26, *(void *)(a1 + 48), v43);
LABEL_28:
          long long v47 = 0u;
          long long v48 = 0u;
          long long v45 = 0u;
          long long v46 = 0u;
          id v34 = *(id *)(a1 + 56);
          uint64_t v35 = [v34 countByEnumeratingWithState:&v45 objects:v49 count:16];
          if (v35)
          {
            uint64_t v36 = v35;
            uint64_t v37 = *(void *)v46;
            do
            {
              for (uint64_t i = 0; i != v36; ++i)
              {
                if (*(void *)v46 != v37) {
                  objc_enumerationMutation(v34);
                }
                uint64_t v39 = *(void *)(*((void *)&v45 + 1) + 8 * i);
                unsigned __int8 v40 = +[TIProactiveQuickTypeManager sharedInstance];
                [v40 provideFeedbackForString:v39 type:v33 style:1];
              }
              uint64_t v36 = [v34 countByEnumeratingWithState:&v45 objects:v49 count:16];
            }
            while (v36);
          }

          int v2 = v42;
          id v7 = v43;
          uint64_t v5 = v44;
          uint64_t v28 = v41;
          break;
        default:
          break;
      }
    }

    goto LABEL_37;
  }
LABEL_38:
}

void __TIStatisticCheckRecentTriggersForTrigger_block_invoke_2(uint64_t a1)
{
  obuint64_t j = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  [*(id *)(a1 + 32) removeObject:*(void *)(a1 + 40)];
  objc_sync_exit(obj);
}

uint64_t __TIStatisticCheckRecentTriggersForTrigger_block_invoke()
{
  TIStatisticCheckRecentTriggersForTrigger_recentByMetricType = [objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:8];

  return MEMORY[0x1F41817F8]();
}

void TIStatisticLogProactiveDescription(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a1;
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  if (v10 && v11)
  {
    float v14 = _TIQueueBackground();
    id v15 = v10;
    id v16 = v13;
    id v17 = v9;
    id v18 = v11;
    id v19 = v12;
    TIDispatchAsync();
  }
}

void __TIStatisticLogProactiveDescription_block_invoke(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  uint64_t v3 = [*(id *)(a1 + 32) attributes];
  uint64_t v4 = [v3 objectForKey:*MEMORY[0x1E4F72330]];
  uint64_t v5 = [v3 objectForKey:*MEMORY[0x1E4F721D0]];
  uint64_t v6 = *(__CFString **)(a1 + 40);
  if (!v6) {
    uint64_t v6 = @"NA";
  }
  id v7 = v6;
  if (![v4 isEqualToString:*MEMORY[0x1E4F722C0]]
    || v5
    && ([MEMORY[0x1E4F1CA98] null],
        id v8 = objc_claimAutoreleasedReturnValue(),
        char v9 = [v5 isEqual:v8],
        v8,
        (v9 & 1) == 0))
  {
    unsigned int v10 = [*(id *)(a1 + 32) triggerSourceType];
    if (v10 > 2) {
      id v11 = 0;
    }
    else {
      id v11 = off_1E6E2A350[v10];
    }
    id v12 = TIStatisticsCategoriesForProactiveTrigger(*(void **)(a1 + 32));
    TIStatisticLogProactiveInfo(*(void **)(a1 + 48), v11, v12, *(void **)(a1 + 56));
    id v13 = +[_TIStatisticsProactiveTracker sharedInstance];
    if ([*(id *)(a1 + 64) isEqualToString:@"suggestion"])
    {
      float v14 = TIStatisticsDescriptionToLegacyDescriptionDictionary();
      id v15 = [v14 allKeys];

      if ([v15 containsObject:*(void *)(a1 + 56)]) {
        objc_msgSend(v13, "trackFailureWithDescription:description:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), *(void *)(a1 + 56), v12, *(void *)(a1 + 48), v7);
      }
    }
    else
    {
      if (![*(id *)(a1 + 64) isEqualToString:@"engagement"])
      {
LABEL_16:

        goto LABEL_17;
      }
      id v16 = TIStatisticsEngagementDescriptionToLegacyDescriptionDictionary();
      id v15 = [v16 allKeys];

      if ([v15 containsObject:*(void *)(a1 + 56)]) {
        objc_msgSend(v13, "trackEngagementFailureWithDescription:description:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 32), "triggerSourceType"), *(void *)(a1 + 56), v12, *(void *)(a1 + 48), v7);
      }
    }

    goto LABEL_16;
  }
LABEL_17:
}

void TIStatisticsLogProactiveTriggered(void *a1, void *a2, void *a3)
{
}

void TIStatisticsLogProactiveSuggestedZeroNoResult(void *a1, void *a2, void *a3)
{
}

void TIStatisticsLogProactiveSuggestedZeroDescription(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = [MEMORY[0x1E4F28B88] whitespaceCharacterSet];
  id v12 = [v9 componentsSeparatedByCharactersInSet:v11];

  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v13 = v12;
  uint64_t v14 = [v13 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = *(void *)v19;
    do
    {
      uint64_t v17 = 0;
      do
      {
        if (*(void *)v19 != v16) {
          objc_enumerationMutation(v13);
        }
        TIStatisticLogProactiveDescription(v7, v8, *(void **)(*((void *)&v18 + 1) + 8 * v17++), @"suggestion", v10);
      }
      while (v15 != v17);
      uint64_t v15 = [v13 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }
    while (v15);
  }
}

void TIStatisticsLogProactiveSuggestedZeroError(void *a1, void *a2, void *a3)
{
}

void TIStatisticsLogProactiveSuggestedZeroTimeout(void *a1, void *a2, void *a3)
{
}

void TIStatisticsLogProactiveSuggestedOne(void *a1, void *a2, void *a3, void *a4)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  v13[0] = a4;
  id v7 = (void *)MEMORY[0x1E4F1C978];
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  id v11 = a1;
  id v12 = [v7 arrayWithObjects:v13 count:1];

  TIStatisticLogProactive(v11, v10, 4, v9, v12);
}

void TIStatisticsLogProactiveSuggestedTwo(void *a1, void *a2, void *a3, void *a4)
{
}

void TIStatisticsLogProactiveSelectedFirst(void *a1, void *a2, void *a3, void *a4)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  v13[0] = a4;
  id v7 = (void *)MEMORY[0x1E4F1C978];
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  id v11 = a1;
  id v12 = [v7 arrayWithObjects:v13 count:1];

  TIStatisticLogProactive(v11, v10, 6, v9, v12);
}

void TIStatisticsLogProactiveSelectedSecond(void *a1, void *a2, void *a3, void *a4)
{
  v13[1] = *MEMORY[0x1E4F143B8];
  v13[0] = a4;
  id v7 = (void *)MEMORY[0x1E4F1C978];
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  id v11 = a1;
  id v12 = [v7 arrayWithObjects:v13 count:1];

  TIStatisticLogProactive(v11, v10, 7, v9, v12);
}

void TIStatisticsLogProactiveTimeOnScreen(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a1;
  id v7 = a2;
  id v8 = a4;
  id v9 = _TIQueueBackground();
  id v13 = v8;
  uint64_t v14 = v7;
  id v10 = v6;
  id v11 = v7;
  id v12 = v8;
  TIDispatchAsync();
}

void __TIStatisticsLogProactiveTimeOnScreen_block_invoke(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  uint64_t v3 = @"NA";
  uint64_t v4 = *(void **)(a1 + 40);
  if (*(void *)(a1 + 32)) {
    uint64_t v3 = *(__CFString **)(a1 + 32);
  }
  uint64_t v5 = v3;
  id v6 = TIStatisticsCategoriesForProactiveTrigger(v4);
  id v7 = +[_TIStatisticsProactiveTracker sharedInstance];
  objc_msgSend(v7, "trackPredictionTimeWithSource:time:selected:categories:locale:fieldType:", objc_msgSend(*(id *)(a1 + 40), "triggerSourceType"), *(unsigned __int8 *)(a1 + 64), v6, *(void *)(a1 + 48), v5, *(double *)(a1 + 56));
}

void TIStatisticsLogProactiveEngagementZeroDescription(void *a1, void *a2, void *a3, void *a4)
{
}

void TIStatisticsLogOfferedCandidateList(void *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = +[_TIStatisticsProactiveTracker sharedInstance];
  [v2 setLastAutocorrectionList:v1];
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v3 = objc_msgSend(v1, "predictions", 0);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v10 + 1) + 8 * i);
        id v9 = [v8 responseKitCategory];

        if (v9)
        {
          [v2 setResponseKitEntryOffered:v8];
          goto LABEL_11;
        }
      }
      uint64_t v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

void TIStatisticsLogCandidateAcceptance(void *a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = +[_TIStatisticsProactiveTracker sharedInstance];
  uint64_t v6 = [v5 lastAutocorrectionList];
  id v7 = _TIQueueBackground();
  uint64_t v39 = MEMORY[0x1E4F143A8];
  uint64_t v40 = 3221225472;
  std::string v41 = __TIStatisticsLogCandidateAcceptance_block_invoke;
  uint64_t v42 = &unk_1E6E2DE00;
  id v8 = v5;
  id v43 = v8;
  TIDispatchAsync();

  if (!v6) {
    goto LABEL_28;
  }
  id v9 = [v6 corrections];
  uint64_t v10 = [v9 autocorrection];
  if (!v10)
  {

LABEL_6:
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    uint64_t v15 = [v6 predictions];
    id v17 = (id)[v15 countByEnumeratingWithState:&v35 objects:v44 count:16];
    if (v17)
    {
      uint64_t v18 = *(void *)v36;
      while (2)
      {
        for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v36 != v18) {
            objc_enumerationMutation(v15);
          }
          long long v20 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          if (([v20 usageTrackingMask] & 0x2000) != 0
            && ([v20 sourceMask] & 0x8000) == 0
            && ([v20 sourceMask] & 0x20000) == 0)
          {
            id v16 = v20;
            goto LABEL_18;
          }
        }
        id v17 = (id)[v15 countByEnumeratingWithState:&v35 objects:v44 count:16];
        if (v17) {
          continue;
        }
        break;
      }
    }
    goto LABEL_20;
  }
  long long v11 = (void *)v10;
  long long v12 = [v6 corrections];
  long long v13 = [v12 autocorrection];
  __int16 v14 = [v13 usageTrackingMask];

  if ((v14 & 0x2000) == 0) {
    goto LABEL_6;
  }
  uint64_t v15 = [v6 corrections];
  id v16 = [v15 autocorrection];
LABEL_18:
  id v17 = v16;

  if (!v17) {
    goto LABEL_21;
  }
  long long v21 = _TIQueueBackground();
  id v34 = v8;
  id v17 = v17;
  TIDispatchAsync();

  uint64_t v15 = v34;
LABEL_20:

LABEL_21:
  if (([v3 usageTrackingMask] & 0x2000) != 0)
  {
    id v22 = _TIQueueBackground();
    id v32 = v8;
    id v33 = v3;
    TIDispatchAsync();
  }
  uint64_t v23 = [v8 responseKitEntryOffered];

  if (v23)
  {
    unsigned int v24 = [v8 responseKitEntryOffered];
    [v8 setResponseKitEntryOffered:0];
    uint64_t v25 = _TIQueueBackground();
    id v26 = v4;
    id v27 = v24;
    TIDispatchAsync();

    uint64_t v28 = [v3 responseKitCategory];

    if (v28)
    {
      uint64_t v29 = _TIQueueBackground();
      id v30 = v26;
      id v31 = v3;
      TIDispatchAsync();
    }
  }

LABEL_28:
}

void __TIStatisticsLogCandidateAcceptance_block_invoke(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  id v3 = [*(id *)(a1 + 32) personalizationWordAcceptanceTracker];
  [v3 trackEventWithPropertyValues:MEMORY[0x1E4F1CBF0]];
}

void __TIStatisticsLogCandidateAcceptance_block_invoke_2(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  id v3 = [*(id *)(a1 + 32) personalizationOfferTracker];
  [v3 trackEventWithPropertyValues:MEMORY[0x1E4F1CBF0]];

  id v4 = +[TITransientLexiconManager sharedInstance];
  uint64_t v5 = [*(id *)(a1 + 40) candidate];
  [v4 provideFeedbackForString:v5 type:3 style:2];
}

void __TIStatisticsLogCandidateAcceptance_block_invoke_3(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  id v3 = [*(id *)(a1 + 32) personalizationEngagementTracker];
  [v3 trackEventWithPropertyValues:MEMORY[0x1E4F1CBF0]];

  id v4 = +[TITransientLexiconManager sharedInstance];
  uint64_t v5 = [*(id *)(a1 + 40) candidate];
  [v4 provideFeedbackForString:v5 type:1 style:*(unsigned __int8 *)(a1 + 48)];
}

void __TIStatisticsLogCandidateAcceptance_block_invoke_4(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  id v3 = (void *)MEMORY[0x1E4F96290];
  uint64_t v4 = *MEMORY[0x1E4F962B8];
  uint64_t v5 = [*(id *)(a1 + 32) normalizedIdentifier];
  uint64_t v6 = TIInputModeGetBaseLanguage();
  [v3 incrementAggdKeyForCategory:0 forAction:v4 withLanguageID:v6];

  id v7 = (void *)MEMORY[0x1E4F96290];
  id v8 = [*(id *)(a1 + 40) responseKitCategory];
  id v9 = [*(id *)(a1 + 32) normalizedIdentifier];
  uint64_t v10 = TIInputModeGetBaseLanguage();
  [v7 incrementAggdKeyForCategory:v8 forAction:v4 withLanguageID:v10];
}

void __TIStatisticsLogCandidateAcceptance_block_invoke_5(uint64_t a1)
{
  int v2 = (void *)MEMORY[0x1E4E7C3D0]();
  id v3 = (void *)MEMORY[0x1E4F96290];
  uint64_t v4 = *MEMORY[0x1E4F962B0];
  uint64_t v5 = [*(id *)(a1 + 32) normalizedIdentifier];
  uint64_t v6 = TIInputModeGetBaseLanguage();
  [v3 incrementAggdKeyForCategory:0 forAction:v4 withLanguageID:v6];

  id v7 = (void *)MEMORY[0x1E4F96290];
  id v8 = [*(id *)(a1 + 40) responseKitCategory];
  id v9 = [*(id *)(a1 + 32) normalizedIdentifier];
  uint64_t v10 = TIInputModeGetBaseLanguage();
  [v7 incrementAggdKeyForCategory:v8 forAction:v4 withLanguageID:v10];
}

void TIStatisticsCoreEnableTestingMode()
{
  id v3 = +[_TIStatisticsProactiveTracker sharedInstance];
  uint64_t v0 = [v3 personalizationWordAcceptanceTracker];
  [v0 enableTestingMode];

  id v1 = [v3 personalizationOfferTracker];
  [v1 enableTestingMode];

  int v2 = [v3 personalizationEngagementTracker];
  [v2 enableTestingMode];
}

void TIStatisticsCoreDisableTestingMode()
{
  id v3 = +[_TIStatisticsProactiveTracker sharedInstance];
  uint64_t v0 = [v3 personalizationWordAcceptanceTracker];
  [v0 disableTestingMode];

  id v1 = [v3 personalizationOfferTracker];
  [v1 disableTestingMode];

  int v2 = [v3 personalizationEngagementTracker];
  [v2 disableTestingMode];
}

id TIStatisticsCoreGetKeyValueDictForPersWordAcceptance()
{
  uint64_t v0 = +[_TIStatisticsProactiveTracker sharedInstance];
  id v1 = [v0 personalizationWordAcceptanceTracker];
  int v2 = [v1 getKeyValueDict];

  return v2;
}

id TIStatisticsCoreGetKeyValueDictForPersOffer()
{
  uint64_t v0 = +[_TIStatisticsProactiveTracker sharedInstance];
  id v1 = [v0 personalizationOfferTracker];
  int v2 = [v1 getKeyValueDict];

  return v2;
}

id TIStatisticsCoreGetKeyValueDictForPersEngagement()
{
  uint64_t v0 = +[_TIStatisticsProactiveTracker sharedInstance];
  id v1 = [v0 personalizationEngagementTracker];
  int v2 = [v1 getKeyValueDict];

  return v2;
}

const void ***std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100](const void ****a1, const void ***a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    KB::StaticDictionary::~StaticDictionary(result);
    JUMPOUT(0x1E4E7BC20);
  }
  return result;
}

__n128 __Block_byref_object_copy__3193(__n128 *a1, __n128 *a2)
{
  __n128 result = a2[3];
  a1[3] = result;
  return result;
}

uint64_t nameVariationsForContactCollection(void *a1)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E4F72460], @"TextInput-SmartSelectionContacts");
  CFErrorRef err = 0;
  uint64_t Transient = LXLexiconCreateTransient();
  uint64_t v5 = [v1 allValues];
  uint64_t v6 = [v5 sortedArrayUsingComparator:&__block_literal_global_8];
  long long v47 = Mutable;
  long long v48 = v1;
  if ((unint64_t)[v1 count] > 0x1F3) {
    uint64_t v7 = 500;
  }
  else {
    uint64_t v7 = [v1 count];
  }
  id v8 = objc_msgSend(v6, "subarrayWithRange:", 0, v7);

  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  obuint64_t j = v8;
  uint64_t v51 = [obj countByEnumeratingWithState:&v61 objects:v67 count:16];
  if (v51)
  {
    uint64_t v50 = *(void *)v62;
    do
    {
      uint64_t v9 = 0;
      do
      {
        if (*(void *)v62 != v50) {
          objc_enumerationMutation(obj);
        }
        uint64_t v53 = v9;
        uint64_t v10 = *(void **)(*((void *)&v61 + 1) + 8 * v9);
        long long v11 = [v10 firstName];
        uint64_t v12 = ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v11);

        long long v13 = [v10 lastName];
        uint64_t v56 = ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v13);

        __int16 v14 = [v10 nickname];
        uint64_t v15 = ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v14);

        id v16 = [v10 middleName];
        id v17 = ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(v16);

        if ([v17 length])
        {
          uint64_t v18 = [v17 rangeOfComposedCharacterSequenceAtIndex:0];
          id v54 = objc_msgSend(v17, "substringWithRange:", v18, v19);
        }
        else
        {
          id v54 = 0;
        }
        id v20 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
        long long v21 = v20;
        id v22 = v56;
        if (v12) {
          [v20 addObject:v12];
        }
        if (v15) {
          [v21 addObject:v15];
        }
        if (v17) {
          [v21 addObject:v17];
        }
        uint64_t v55 = (void *)v15;
        if (v56)
        {
          [v21 addObject:v56];
          if (v12)
          {
            uint64_t v23 = [NSString stringWithFormat:@"%@ %@", v12, v56];
            [v21 addObject:v23];

            id v22 = v56;
            unsigned int v24 = [NSString stringWithFormat:@"%@ %@", v56, v12];
            [v21 addObject:v24];

            uint64_t v25 = [NSString stringWithFormat:@"%@, %@", v56, v12];
            [v21 addObject:v25];
          }
          if (v15)
          {
            id v26 = [NSString stringWithFormat:@"%@ %@", v15, v22];
            [v21 addObject:v26];

            id v22 = v56;
            id v27 = [NSString stringWithFormat:@"%@ %@", v56, v15];
            [v21 addObject:v27];

            uint64_t v28 = [NSString stringWithFormat:@"%@, %@", v56, v15];
            [v21 addObject:v28];
          }
          if (v12 && v17)
          {
            uint64_t v29 = [NSString stringWithFormat:@"%@ %@ %@", v12, v17, v22];
            [v21 addObject:v29];

            id v22 = v56;
            id v30 = [NSString stringWithFormat:@"%@ %@ %@", v56, v12, v17];
            [v21 addObject:v30];

            id v31 = [NSString stringWithFormat:@"%@, %@ %@", v56, v12, v17];
            [v21 addObject:v31];
          }
          if (v15 && v17)
          {
            id v32 = [NSString stringWithFormat:@"%@ %@ %@", v15, v17, v22];
            [v21 addObject:v32];

            id v22 = v56;
            id v33 = [NSString stringWithFormat:@"%@ %@ %@", v56, v15, v17];
            [v21 addObject:v33];

            id v34 = [NSString stringWithFormat:@"%@, %@ %@", v56, v15, v17];
            [v21 addObject:v34];
          }
          if (v12 && v54)
          {
            long long v35 = [NSString stringWithFormat:@"%@ %@ %@", v12, v54, v22];
            [v21 addObject:v35];

            long long v36 = [NSString stringWithFormat:@"%@ %@. %@", v12, v54, v22];
            [v21 addObject:v36];
          }
          if (v15 && v54)
          {
            long long v37 = [NSString stringWithFormat:@"%@ %@ %@", v15, v54, v22];
            [v21 addObject:v37];

            long long v38 = [NSString stringWithFormat:@"%@ %@. %@", v15, v54, v22];
            [v21 addObject:v38];
          }
        }
        unint64_t v52 = (void *)v12;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        id v39 = v21;
        uint64_t v40 = [v39 countByEnumeratingWithState:&v57 objects:v66 count:16];
        if (v40)
        {
          uint64_t v41 = v40;
          uint64_t v42 = *(void *)v58;
          do
          {
            uint64_t v43 = 0;
            do
            {
              if (*(void *)v58 != v42) {
                objc_enumerationMutation(v39);
              }
              uint64_t v44 = *(void *)(*((void *)&v57 + 1) + 8 * v43);
              if (!LXLexiconAdd())
              {
                if (TICanLogMessageAtLevel_onceToken != -1) {
                  dispatch_once(&TICanLogMessageAtLevel_onceToken, &__block_literal_global_23827);
                }
                if (TICanLogMessageAtLevel_logLevel >= 2)
                {
                  uint64_t v45 = TIOSLogFacility();
                  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                  {
                    long long v46 = [NSString stringWithFormat:@"%s TISmartSelection: Failed to add \"%@\" to the contact name variations lexicon.", "nameVariationsForContactCollection", v44];
                    *(_DWORD *)buf = 138412290;
                    unint64_t v69 = v46;
                    _os_log_debug_impl(&dword_1E3F0E000, v45, OS_LOG_TYPE_DEBUG, "%@", buf, 0xCu);
                  }
                }
              }
              ++v43;
            }
            while (v41 != v43);
            uint64_t v41 = [v39 countByEnumeratingWithState:&v57 objects:v66 count:16];
          }
          while (v41);
        }

        uint64_t v9 = v53 + 1;
      }
      while (v53 + 1 != v51);
      uint64_t v51 = [obj countByEnumeratingWithState:&v61 objects:v67 count:16];
    }
    while (v51);
  }

  if (v47) {
    CFRelease(v47);
  }

  return Transient;
}

id ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke(void *a1)
{
  id v1 = a1;
  if (v1
    && ([MEMORY[0x1E4F28B88] whitespaceAndNewlineCharacterSet],
        int v2 = objc_claimAutoreleasedReturnValue(),
        [v1 stringByTrimmingCharactersInSet:v2],
        id v3 = objc_claimAutoreleasedReturnValue(),
        uint64_t v4 = [v3 length],
        v3,
        v2,
        v4))
  {
    id v5 = v1;
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

uint64_t ___Z34nameVariationsForContactCollectionP12NSDictionaryIP8NSStringP10_ICContactE_block_invoke_2(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = NSNumber;
  id v5 = a3;
  [a2 score];
  uint64_t v6 = objc_msgSend(v4, "numberWithDouble:");
  uint64_t v7 = NSNumber;
  [v5 score];
  double v9 = v8;

  uint64_t v10 = [v7 numberWithDouble:v9];
  uint64_t v11 = [v6 compare:v10];

  return v11;
}

id fieldNameSuffices()
{
  char v2[3] = *MEMORY[0x1E4F143B8];
  v2[0] = @"_input";
  v2[1] = @"_autocorrection";
  v2[2] = @"_alternate";
  uint64_t v0 = [MEMORY[0x1E4F1C978] arrayWithObjects:v2 count:3];

  return v0;
}

id fieldSpecWithSuffices(void *a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v27 = [MEMORY[0x1E4F1CA48] array];
  long long v43 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  obuint64_t j = v1;
  uint64_t v28 = [obj countByEnumeratingWithState:&v43 objects:v48 count:16];
  if (v28)
  {
    uint64_t v26 = *(void *)v44;
    do
    {
      for (uint64_t i = 0; i != v28; ++i)
      {
        if (*(void *)v44 != v26) {
          objc_enumerationMutation(obj);
        }
        uint64_t v3 = *(void *)(*((void *)&v43 + 1) + 8 * i);
        uint64_t v4 = (void *)MEMORY[0x1E4FAE250];
        uint64_t v42 = [@"sourceBitset" stringByAppendingString:v3];
        uint64_t v41 = [v4 integerFieldSpecWithName:v42 minValue:&unk_1F3FA7AD8 maxValue:0 significantDigits:0];
        v47[0] = v41;
        id v5 = (void *)MEMORY[0x1E4FAE250];
        uint64_t v40 = [@"length" stringByAppendingString:v3];
        id v39 = [v5 integerFieldSpecWithName:v40 minValue:&unk_1F3FA7AD8 maxValue:0 significantDigits:0];
        v47[1] = v39;
        uint64_t v6 = (void *)MEMORY[0x1E4FAE250];
        long long v38 = [@"capitalization" stringByAppendingString:v3];
        long long v37 = [v6 stringFieldSpecWithName:v38];
        v47[2] = v37;
        uint64_t v7 = (void *)MEMORY[0x1E4FAE250];
        long long v36 = [@"diacritics" stringByAppendingString:v3];
        long long v35 = [v7 BOOLeanFieldSpecWithName:v36];
        v47[3] = v35;
        double v8 = (void *)MEMORY[0x1E4FAE250];
        id v34 = [@"punctuation" stringByAppendingString:v3];
        id v33 = [v8 BOOLeanFieldSpecWithName:v34];
        void v47[4] = v33;
        double v9 = (void *)MEMORY[0x1E4FAE250];
        id v32 = [@"multiword" stringByAppendingString:v3];
        id v31 = [v9 BOOLeanFieldSpecWithName:v32];
        v47[5] = v31;
        uint64_t v10 = (void *)MEMORY[0x1E4FAE250];
        id v30 = [@"geometryScore" stringByAppendingString:v3];
        uint64_t v29 = [v10 integerFieldSpecWithName:v30 minValue:0 maxValue:0 significantDigits:0];
        v47[6] = v29;
        uint64_t v11 = (void *)MEMORY[0x1E4FAE250];
        uint64_t v12 = [@"languageModelScore" stringByAppendingString:v3];
        long long v13 = [v11 integerFieldSpecWithName:v12 minValue:0 maxValue:0 significantDigits:0];
        v47[7] = v13;
        __int16 v14 = (void *)MEMORY[0x1E4FAE250];
        uint64_t v15 = [@"language" stringByAppendingString:v3];
        id v16 = [v14 stringFieldSpecWithName:v15];
        unsigned char v47[8] = v16;
        id v17 = (void *)MEMORY[0x1E4FAE250];
        uint64_t v18 = [@"localUsageCount" stringByAppendingString:v3];
        uint64_t v19 = [v17 integerFieldSpecWithName:v18 minValue:0 maxValue:0 significantDigits:0];
        v47[9] = v19;
        id v20 = (void *)MEMORY[0x1E4FAE250];
        long long v21 = [@"localPenaltyCount" stringByAppendingString:v3];
        id v22 = [v20 integerFieldSpecWithName:v21 minValue:0 maxValue:0 significantDigits:0];
        v47[10] = v22;
        uint64_t v23 = [MEMORY[0x1E4F1C978] arrayWithObjects:v47 count:11];
        [v27 addObjectsFromArray:v23];
      }
      uint64_t v28 = [obj countByEnumeratingWithState:&v43 objects:v48 count:16];
    }
    while (v28);
  }

  return v27;
}

id payloadForWordEntryAligned(void *a1, void *a2)
{
  v65[3] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 originalWord];
  uint64_t v6 = outcomeFor(v5);
  uint64_t v7 = (void *)v6;
  if (v6)
  {
    v65[0] = v6;
    v64[0] = @"outcome";
    v64[1] = @"alignmentConfidence";
    double v8 = alignmentConfidence([v3 inSessionAlignmentConfidence]);
    v65[1] = v8;
    v64[2] = kFeatureStringTypingEngine;
    double v9 = [v5 acceptedCandidate];
    [v9 typingEngine];
    uint64_t v10 = TIKeyboardCandidateTypingEngineTypeToString();
    v65[2] = v10;
    uint64_t v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v65 forKeys:v64 count:3];

    uint64_t v12 = [v5 candidatesOffered];
    long long v13 = [v12 lastObject];

    __int16 v14 = [v13 corrections];
    uint64_t v15 = [v14 autocorrection];

    if ([v15 isAutocorrection])
    {
      long long v48 = v11;
      uint64_t v49 = v7;
      id v50 = v3;
      uint64_t v51 = v4;
      long long v47 = v13;
      id v16 = [v13 predictions];
      unint64_t v52 = v15;
      id v17 = [v15 input];
      long long v57 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      id v18 = v16;
      uint64_t v19 = [v18 countByEnumeratingWithState:&v57 objects:v63 count:16];
      if (v19)
      {
        uint64_t v20 = v19;
        uint64_t v21 = *(void *)v58;
LABEL_5:
        uint64_t v22 = 0;
        while (1)
        {
          if (*(void *)v58 != v21) {
            objc_enumerationMutation(v18);
          }
          uint64_t v23 = *(void **)(*((void *)&v57 + 1) + 8 * v22);
          uint64_t v24 = [v23 candidate];
          if (v24)
          {
            uint64_t v25 = (void *)v24;
            uint64_t v26 = [v23 candidate];
            char v27 = [v26 isEqualToString:v17];

            if (v27) {
              break;
            }
          }
          if (v20 == ++v22)
          {
            uint64_t v20 = [v18 countByEnumeratingWithState:&v57 objects:v63 count:16];
            if (v20) {
              goto LABEL_5;
            }
            goto LABEL_12;
          }
        }
        id v4 = v51;
        uint64_t v29 = payloadForCandidate(v23, @"_input", v51);

        if (v29) {
          goto LABEL_17;
        }
      }
      else
      {
LABEL_12:

        id v4 = v51;
      }
      uint64_t v29 = payloadForText(v17, @"_input", v4);
LABEL_17:
      id v30 = payloadForCandidate(v52, @"_autocorrection", v4);
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      id v31 = v18;
      uint64_t v32 = [v31 countByEnumeratingWithState:&v53 objects:v62 count:16];
      if (v32)
      {
        uint64_t v33 = v32;
        long long v45 = v30;
        long long v46 = v29;
        uint64_t v34 = *(void *)v54;
        while (2)
        {
          for (uint64_t i = 0; i != v33; ++i)
          {
            if (*(void *)v54 != v34) {
              objc_enumerationMutation(v31);
            }
            long long v36 = *(void **)(*((void *)&v53 + 1) + 8 * i);
            uint64_t v37 = objc_msgSend(v36, "candidate", v45, v46);
            if (v37)
            {
              long long v38 = (void *)v37;
              id v39 = [v36 candidate];
              char v40 = [v39 isEqualToString:v17];

              if ((v40 & 1) == 0)
              {
                id v4 = v51;
                uint64_t v41 = payloadForCandidate(v36, @"_alternate", v51);
                id v30 = v45;
                uint64_t v29 = v46;
                goto LABEL_29;
              }
            }
          }
          uint64_t v33 = [v31 countByEnumeratingWithState:&v53 objects:v62 count:16];
          if (v33) {
            continue;
          }
          break;
        }
        id v4 = v51;
        id v30 = v45;
        uint64_t v29 = v46;
      }
      uint64_t v41 = MEMORY[0x1E4F1CC08];
LABEL_29:

      v61[0] = v29;
      v61[1] = v30;
      uint64_t v11 = v48;
      v61[2] = v41;
      v61[3] = v48;
      [MEMORY[0x1E4F1C978] arrayWithObjects:v61 count:4];
      long long v43 = v42 = (void *)v41;
      uint64_t v28 = mergeDicts(v43);

      uint64_t v7 = v49;
      id v3 = v50;
      long long v13 = v47;
      uint64_t v15 = v52;
    }
    else
    {
      uint64_t v28 = 0;
    }
  }
  else
  {
    uint64_t v28 = 0;
  }

  return v28;
}

__CFString *outcomeFor(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = [v1 candidatesOffered];
  id v3 = [v2 lastObject];

  id v4 = [v3 corrections];
  id v5 = [v4 autocorrection];

  uint64_t v6 = [v5 input];
  uint64_t v7 = [v5 candidate];
  double v8 = [v1 acceptedString];
  double v9 = [v8 stringByReplacingOccurrencesOfString:@"’" withString:@"'"];

  if ([v6 isEqualToString:v7])
  {
    uint64_t v10 = 0;
  }
  else if ([v9 isEqualToString:v7])
  {
    if (([v1 wordEntryType] & 4) != 0)
    {
      uint64_t v10 = @"selectedAutocorrection";
    }
    else
    {
      uint64_t v11 = [v1 editedEntry];
      uint64_t v12 = v11;
      if (v11)
      {
        long long v13 = [v11 acceptedString];
        if ([v13 isEqualToString:v6])
        {
          uint64_t v10 = @"revisedToInput";
        }
        else if ([v13 isEqualToString:v9])
        {
          uint64_t v10 = @"revisedBackToAutocorrection";
        }
        else
        {
          long long v26 = 0u;
          long long v27 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          obuint64_t j = [v3 predictions];
          uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
          if (v23)
          {
            uint64_t v19 = v3;
            uint64_t v20 = v12;
            uint64_t v22 = *(void *)v25;
            uint64_t v10 = @"revisedToAlternate";
            while (2)
            {
              for (uint64_t i = 0; i != v23; ++i)
              {
                if (*(void *)v25 != v22) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v15 = [*(id *)(*((void *)&v24 + 1) + 8 * i) candidate];
                id v16 = v13;
                char v17 = [v13 isEqualToString:v15];

                if (v17)
                {
                  uint64_t v12 = v20;
                  long long v13 = v16;
                  goto LABEL_27;
                }
                long long v13 = v16;
              }
              uint64_t v23 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
              if (v23) {
                continue;
              }
              break;
            }
            uint64_t v10 = @"revisedToNew";
            uint64_t v12 = v20;
LABEL_27:
            id v3 = v19;
          }
          else
          {
            uint64_t v10 = @"revisedToNew";
          }
        }
      }
      else
      {
        uint64_t v10 = @"acceptedAutocorrection";
      }
    }
  }
  else if ([v9 isEqualToString:v6])
  {
    if (([v1 wordEntryType] & 4) != 0) {
      uint64_t v10 = @"selectedInput";
    }
    else {
      uint64_t v10 = @"rejectedAutocorrection";
    }
  }
  else
  {
    uint64_t v10 = @"selectedAlternate";
  }

  return v10;
}

id payloadForCandidate(void *a1, void *a2, void *a3)
{
  v58[1] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  double v8 = [@"sourceBitset" stringByAppendingString:v6];
  long long v57 = v8;
  double v9 = objc_msgSend(NSNumber, "numberWithUnsignedInt:", objc_msgSend(v5, "sourceMask"));
  v58[0] = v9;
  uint64_t v10 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v58 forKeys:&v57 count:1];

  uint64_t v11 = [MEMORY[0x1E4F1CA60] dictionary];
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    long long v48 = v10;
    id v12 = v5;
    long long v13 = [@"geometryScore" stringByAppendingString:v6];
    v55[0] = v13;
    __int16 v14 = NSNumber;
    [v12 geometryScore];
    double v17 = v16 * 10.0;
    if (v16 < -10.0) {
      double v17 = -100.0;
    }
    if (v16 <= 0.0) {
      double v18 = v17;
    }
    else {
      double v18 = 0.0;
    }
    LODWORD(v15) = vcvtmd_s64_f64(v18);
    uint64_t v19 = objc_msgSend(v14, "numberWithInt:", v15, v48);
    v56[0] = v19;
    uint64_t v20 = [@"languageModelScore" stringByAppendingString:v6];
    v55[1] = v20;
    uint64_t v21 = NSNumber;
    [v12 wordScore];
    double v24 = v23 * 10.0;
    if (v23 < -10.0) {
      double v24 = -100.0;
    }
    if (v23 <= 0.0) {
      double v25 = v24;
    }
    else {
      double v25 = 0.0;
    }
    LODWORD(v22) = vcvtmd_s64_f64(v25);
    long long v26 = [v21 numberWithInt:v22];
    v56[1] = v26;
    long long v27 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v56 forKeys:v55 count:2];
    [v11 addEntriesFromDictionary:v27];

    uint64_t v28 = [v12 lexiconLocale];

    if (v28)
    {
      uint64_t v29 = [@"language" stringByAppendingString:v6];
      long long v53 = v29;
      id v30 = [v12 lexiconLocale];
      long long v54 = v30;
      id v31 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v54 forKeys:&v53 count:1];
      [v11 addEntriesFromDictionary:v31];
    }
    if (([v12 dynamicUsageCount] & 0x80000000) == 0)
    {
      uint64_t v32 = [@"localUsageCount" stringByAppendingString:v6];
      v51[0] = v32;
      uint64_t v33 = NSNumber;
      uint64_t v34 = [v12 dynamicUsageCount];
      if ((int)v34 > 4095)
      {
        uint64_t v35 = 4096;
      }
      else
      {
        do
        {
          uint64_t v35 = v34;
          uint64_t v34 = (v34 - 1) & v34;
        }
        while (v34);
      }
      long long v36 = [v33 numberWithInt:v35];
      v52[0] = v36;
      uint64_t v37 = [@"localPenaltyCount" stringByAppendingString:v6];
      v51[1] = v37;
      long long v38 = NSNumber;
      uint64_t v39 = [v12 dynamicPenaltyCount];
      if ((int)v39 > 4095)
      {
        uint64_t v40 = 4096;
      }
      else
      {
        do
        {
          uint64_t v40 = v39;
          uint64_t v39 = (v39 - 1) & v39;
        }
        while (v39);
      }
      uint64_t v41 = [v38 numberWithInt:v40];
      v52[1] = v41;
      uint64_t v42 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v52 forKeys:v51 count:2];
      [v11 addEntriesFromDictionary:v42];
    }
    uint64_t v10 = v49;
  }
  v50[0] = v10;
  v50[1] = v11;
  long long v43 = [v5 candidate];
  long long v44 = payloadForText(v43, v6, v7);

  v50[2] = v44;
  long long v45 = [MEMORY[0x1E4F1C978] arrayWithObjects:v50 count:3];
  long long v46 = mergeDicts(v45);

  return v46;
}

uint64_t KB::enum_value_from_string<KB::CandidateFilter::WordEquivalenceType>(uint64_t *a1)
{
  uint64_t v1 = *((unsigned __int8 *)a1 + 23);
  int v2 = (char)v1;
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = a1[1];
  }
  if (v1 == 22)
  {
    if (v2 >= 0) {
      uint64_t v11 = a1;
    }
    else {
      uint64_t v11 = (uint64_t *)*a1;
    }
    uint64_t v12 = *v11;
    uint64_t v13 = v11[1];
    uint64_t v14 = *(uint64_t *)((char *)v11 + 14);
    if (v12 == 0x4665636166727553 && v13 == 0x76697571456D726FLL && v14 == 0x65636E616C617669)
    {
      uint64_t v10 = 0x100000000;
      uint64_t v9 = 1;
      return v9 | v10;
    }
    goto LABEL_27;
  }
  if (v1 != 18
    || (v2 >= 0 ? (id v3 = a1) : (id v3 = (uint64_t *)*a1),
        (v4 = *v3, uint64_t v5 = v3[1], v6 = *((unsigned __int16 *)v3 + 8), v4 == 0x4579656B74726F53)
      ? (BOOL v7 = v5 == 0x6E656C6176697571)
      : (BOOL v7 = 0),
        v7 ? (BOOL v8 = v6 == 25955) : (BOOL v8 = 0),
        !v8))
  {
LABEL_27:
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    return v9 | v10;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 0x100000000;
  return v9 | v10;
}

void KB::CandidateFilter::remove_candidates_satisfying_predicate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v17 = 0x100000;
  __int16 v18 = 0;
  char v19 = 0;
  uint64_t v20 = 0;
  char v21 = 0;
  if (a2)
  {
    BOOL v8 = &v17;
    KB::String::ensure_capacity((KB::String *)&v17, 256);
  }
  else
  {
    BOOL v8 = 0;
  }
  *(void *)&long long v14 = a2;
  *((void *)&v14 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = a3;
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::__value_func[abi:nn180100]((uint64_t)v15, a4);
  double v16 = v8;
  uint64_t v9 = *(KB::Candidate **)a1;
  uint64_t v10 = *(KB::Candidate **)(a1 + 8);
  long long v12 = v14;
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::__value_func[abi:nn180100]((uint64_t)v13, (uint64_t)v15);
  void v13[4] = v16;
  if (v9 != v10)
  {
    while ((KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()((uint64_t)&v12, v9) & 1) == 0)
    {
      uint64_t v9 = (KB::Candidate *)((char *)v9 + 1000);
      if (v9 == v10)
      {
        uint64_t v9 = v10;
        goto LABEL_14;
      }
    }
    if (v9 != v10)
    {
      for (uint64_t i = (uint64_t *)((char *)v9 + 1000); i != (uint64_t *)v10; i += 125)
      {
        if ((KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()((uint64_t)&v12, (KB::Candidate *)i) & 1) == 0)
        {
          KB::Candidate::operator=((uint64_t *)v9, i);
          uint64_t v9 = (KB::Candidate *)((char *)v9 + 1000);
        }
      }
    }
  }
LABEL_14:
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v13);
  std::vector<KB::Candidate>::erase(a1, (uint64_t *)v9, *(KB::Candidate **)(a1 + 8));
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v15);
  if (v20)
  {
    if (v19 == 1) {
      free(v20);
    }
  }
}

uint64_t std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t KB::CandidateFilter::remove_candidates_satisfying_predicate(std::vector<KB::Candidate> &,__CFString *,char const*,std::function<BOOL ()(KB::Candidate const&,KB::String *)>)::$_0::operator()(uint64_t a1, KB::Candidate *a2)
{
  v25[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1 + 40;
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v23 = *(void *)(v4 + 8);
  if (!v3) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, KB::Candidate *, uint64_t *))(*(void *)v3 + 48))(v3, a2, &v23);
  if (v6)
  {
    BOOL v7 = *(__CFString **)a1;
    if (*(void *)a1)
    {
      KB::Candidate::capitalized_string(a2, (uint64_t)&v23);
      BOOL v8 = (const char *)v24;
      if (!v24) {
        BOOL v8 = (const char *)v25;
      }
      uint64_t v9 = "";
      if ((_WORD)v23) {
        uint64_t v10 = v8;
      }
      else {
        uint64_t v10 = "";
      }
      KB::Candidate::token_ids_as_string(a2, (uint64_t)v19);
      long long v12 = (const char *)v21;
      if (!v21) {
        long long v12 = (const char *)&v22;
      }
      if (v19[0]) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = "";
      }
      uint64_t v14 = *(void *)(a1 + 48);
      if (v14 && *(_WORD *)v14)
      {
        uint64_t v15 = *(const char **)(v14 + 8);
        double v16 = (const char *)(v14 + 16);
        if (v15) {
          uint64_t v9 = v15;
        }
        else {
          uint64_t v9 = v16;
        }
      }
      KB::append_format(v7, (__CFString *)"[%s] {%s} removed by %s (%s)\n", v11, v10, v13, *(void *)(a1 + 8), v9);
      if (v21 && v20 == 1) {
        free(v21);
      }
      if (v24 && BYTE6(v23) == 1) {
        free(v24);
      }
    }
  }
  int v17 = *(KB::String **)(a1 + 48);
  if (v17) {
    KB::String::clear(v17);
  }
  return v6;
}

void *KB::CandidateFilter::remove_candidates_with_input_mismatch(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void v18[4] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a6;
  uint64_t v11 = *(void *)(a5 + 16);
  if (v11) {
    atomic_fetch_add((atomic_uint *volatile)v11, 1u);
  }
  uint64_t v12 = *(void *)(v11 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v11);
  uint64_t v13 = *(void *)(a5 + 56);
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v15 = operator new(0x30uLL);
  *(void *)uint64_t v15 = &unk_1F3F724A0;
  v15[2] = a3;
  *((void *)v15 + 2) = a4;
  *((void *)v15 + 3) = a4 + 1000;
  *((void *)v15 + 4) = v12;
  *((void *)v15 + 5) = &v17;
  __int16 v18[3] = v15;
  KB::CandidateFilter::remove_candidates_satisfying_predicate(a2, v13, v14, (uint64_t)v18);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v18);
}

uint64_t std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, void *a2, KB::String **a3)
{
  uint64_t v5 = *a3;
  unsigned int v6 = KB::Candidate::num_words_matching_input(a2, *(void **)(a1 + 16), *(void *)(a1 + 32));
  uint64_t v7 = *(void *)(a1 + 24);
  if (*(unsigned char *)(v7 + 1000)) {
    unsigned int v8 = KB::Candidate::num_words_matching_input(a2, (void *)v7, *(void *)(a1 + 32));
  }
  else {
    unsigned int v8 = 0;
  }
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  if (v9) {
    BOOL v10 = v6 >= v9;
  }
  else {
    BOOL v10 = 1;
  }
  uint64_t v12 = !v10 && v8 < v9;
  if (v5) {
    BOOL v13 = v12 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (!v13) {
    KB::String::append_format(v5, "# candidates words matching input == %u, converted input == %u < %u == required words matching input (%s)", v6, v8, *(_DWORD *)(a1 + 8), **(const char ***)(a1 + 40));
  }
  return v12;
}

__n128 std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F724A0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  int v2 = (char *)operator new(0x30uLL);
  *(void *)int v2 = &unk_1F3F724A0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0,std::allocator<KB::CandidateFilter::remove_candidates_with_input_mismatch(std::vector<KB::Candidate> &,unsigned int,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&,char const*)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

uint64_t KB::CandidateFilter::_sortkey_equal_predicate(KB::CandidateFilter *this, const KB::CandidateFilterResources *a2)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)v2, 1u);
  }
  uint64_t v3 = *(void *)(v2 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v2);
  return v3;
}

uint64_t KB::CandidateFilter::is_suggestible_for_input(uint64_t *a1, void *a2, int a3, KB::WordSuggestionPolicy *a4, uint64_t a5, KB::String *a6)
{
  v35[2] = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (a3 == 1)
    {
      uint64_t v11 = *a1;
      uint64_t v12 = (KB::Word *)a1[1];
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 0x40000000;
      uint64_t v28 = ___ZN2KB15CandidateFilter24is_suggestible_for_inputERKNS_9CandidateES3_NS0_19WordEquivalenceTypeERKNS_20WordSuggestionPolicyERKNSt3__18functionIFiRKNS_6StringESC_EEEPSA__block_invoke;
      uint64_t v29 = &__block_descriptor_tmp_3607;
      id v30 = a4;
      id v31 = a6;
      if (v11)
      {
        BOOL v13 = (KB::Word *)((char *)v12 + 240 * v11);
        uint64_t v14 = 240 * v11;
        while ((((uint64_t (*)(void *, KB::Word *))v28)(v27, v12) & 1) == 0)
        {
          uint64_t v12 = (KB::Word *)((char *)v12 + 240);
          v14 -= 240;
          if (!v14)
          {
            uint64_t v12 = v13;
            break;
          }
        }
        uint64_t v15 = v12;
        uint64_t v11 = *a1;
        uint64_t v12 = (KB::Word *)a1[1];
      }
      else
      {
        uint64_t v15 = v12;
      }
      uint64_t v17 = (KB::Word *)((char *)v12 + 240 * v11);
      if (a6 && v15 != v17)
      {
        KB::Word::capitalized_string(v15, (uint64_t)v32);
        __int16 v18 = (const char *)v34;
        if (!v34) {
          __int16 v18 = (const char *)v35;
        }
        if (v32[0]) {
          char v19 = v18;
        }
        else {
          char v19 = "";
        }
        KB::String::append_format(a6, " => '%s' is never suggestible", v19);
        if (v34 && v33 == 1) {
          free(v34);
        }
      }
      if (v15 != v17) {
        return 0;
      }
      unsigned int v16 = KB::Candidate::num_words_preserving_input(a1, a2, a5);
    }
    else
    {
      unsigned int v16 = 0;
    }
  }
  else
  {
    unsigned int v16 = KB::Candidate::num_words_matching_input(a1, a2, a5);
  }
  if (*a1 <= (unint64_t)v16) {
    return 1;
  }
  uint64_t v20 = v16;
  unsigned int v21 = v16 + 1;
  while (1)
  {
    uint64_t v22 = (const KB::Word *)(a1[1] + 240 * v20);
    if ((KB::WordSuggestionPolicy::is_suggestible(a4, v22, a6) & 1) == 0) {
      break;
    }
    uint64_t v20 = v21;
    if (*a1 <= (unint64_t)v21++) {
      return 1;
    }
  }
  if (a6)
  {
    KB::Word::capitalized_string(v22, (uint64_t)v32);
    double v25 = (const char *)v34;
    if (!v34) {
      double v25 = (const char *)v35;
    }
    if (v32[0]) {
      long long v26 = v25;
    }
    else {
      long long v26 = "";
    }
    KB::String::append_format(a6, " => '%s' does not preserve input and is not predictible", v26);
    if (v34)
    {
      if (v33 == 1) {
        free(v34);
      }
    }
  }
  return 0;
}

BOOL ___ZN2KB15CandidateFilter24is_suggestible_for_inputERKNS_9CandidateES3_NS0_19WordEquivalenceTypeERKNS_20WordSuggestionPolicyERKNSt3__18functionIFiRKNS_6StringESC_EEEPSA__block_invoke(uint64_t a1, const KB::Word *a2)
{
  return KB::WordSuggestionPolicy::is_never_suggestible(*(KB::WordSuggestionPolicy **)(a1 + 32), a2, *(KB::String **)(a1 + 40));
}

uint64_t KB::CandidateFilter::candidate_matches_input(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(_WORD *)(a1 + 888)) {
    KB::Candidate::compute_string((KB::Candidate *)a1);
  }
  if (!*(_WORD *)(a2 + 888)) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  uint64_t v6 = *(void *)(a3 + 24);
  if (v6)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 48))(v6, a1 + 888, a2 + 888);
    if (result)
    {
      if (!*(_WORD *)(a1 + 888)) {
        KB::Candidate::compute_string((KB::Candidate *)a1);
      }
      if (!*(_WORD *)(a2 + 888)) {
        KB::Candidate::compute_string((KB::Candidate *)a2);
      }
      v10[1] = 1;
      v10[0] = &unk_1F3F77D18;
      return KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v10, (const KB::String *)(a1 + 888), (const KB::String *)(a2 + 888), 0, 0);
    }
  }
  else
  {
    unsigned int v8 = (KB::CandidateFilter *)std::__throw_bad_function_call[abi:nn180100]();
    return KB::CandidateFilter::count_linguistic_words(v8, v9);
  }
  return result;
}

uint64_t KB::CandidateFilter::count_linguistic_words(KB::CandidateFilter *this, const Candidate *a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = *((void *)this + 1);
  uint64_t v6 = 240 * v2;
  uint64_t v7 = v5 + 136;
  do
  {
    if ((*(unsigned char *)(v7 - 1) & 4) == 0 && (*(_DWORD *)(v7 + 4) - 500) < 0xFFFFFE0D) {
      ++result;
    }
    v7 += 240;
    v6 -= 240;
  }
  while (v6);
  return result;
}

uint64_t KB::CandidateFilter::language_id_for_context_with_confidence(uint64_t a1, uint64_t a2, float a3)
{
  uint64_t v5 = *(void *)(a2 + 24);
  uint64_t v6 = *(std::__shared_weak_count **)(a2 + 32);
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v9 = 0.0;
  unsigned int v7 = (*(uint64_t (**)(uint64_t, uint64_t, float *))(*(void *)v5 + 448))(v5, a1, &v9);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v6);
  }
  if (v9 >= a3) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t KB::CandidateFilter::language_id_for_context_and_candidate_with_confidence(KB::CandidateFilter *this, const KB::LanguageModelContext *a2, const KB::Candidate *a3, float a4, const KB::CandidateFilterResources *a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (*(void *)a2)
  {
    unint64_t v8 = 0;
    uint64_t v9 = 240 * *(void *)a2;
    uint64_t v10 = *((void *)a2 + 1) + 136;
    do
    {
      if ((*(unsigned char *)(v10 - 1) & 4) == 0 && (*(_DWORD *)(v10 + 4) - 500) < 0xFFFFFE0D) {
        ++v8;
      }
      v10 += 240;
      v9 -= 240;
    }
    while (v9);
  }
  else
  {
    unint64_t v8 = 0;
  }
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v21, this);
  uint64_t v12 = *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v13 = 0;
    uint64_t v14 = *((void *)a2 + 1);
    uint64_t v15 = 240 * v12;
    do
    {
      uint64_t v16 = v13 + 1;
      if (v13 + 1 >= v8) {
        break;
      }
      if ((*(unsigned char *)(v14 + 135) & 4) == 0)
      {
        TITokenID v17 = *(TITokenID *)(v14 + 136);
        KB::Word::capitalized_string((KB::Word *)v14, (uint64_t)&v28);
        TITokenID v18 = v17;
        KB::LanguageModelContext::append((KB::LanguageModelContext *)&v21, v18, (const KB::String *)&v28, 0);
        if (v29 && BYTE6(v28) == 1) {
          free(v29);
        }
        uint64_t v13 = v16;
      }
      v14 += 240;
      v15 -= 240;
    }
    while (v15);
  }
  if (KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)&v21)) {
    uint64_t v19 = 0;
  }
  else {
    uint64_t v19 = KB::CandidateFilter::language_id_for_context_with_confidence((uint64_t)&v21, (uint64_t)a3, a4);
  }
  uint64_t v28 = (void **)&v27;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v28);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v26);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v25);
  if (__p)
  {
    double v24 = __p;
    operator delete(__p);
  }
  if (v22) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v22);
  }
  return v19;
}

uint64_t KB::CandidateFilter::candidate_static_words_from_same_language(KB::CandidateFilter *this, const Candidate *a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *((void *)this + 1);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  unint64_t v8 = ___ZN2KB15CandidateFilter41candidate_static_words_from_same_languageERKNS_9CandidateEj_block_invoke;
  uint64_t v9 = &__block_descriptor_tmp_6_3613;
  int v10 = (int)a2;
  if (!v2) {
    return 1;
  }
  uint64_t v4 = 240 * v2 - 240;
  do
  {
    uint64_t result = ((uint64_t (*)(void *, uint64_t))v8)(v7, v3);
    v3 += 240;
    if (result) {
      BOOL v6 = v4 == 0;
    }
    else {
      BOOL v6 = 1;
    }
    v4 -= 240;
  }
  while (!v6);
  return result;
}

BOOL ___ZN2KB15CandidateFilter41candidate_static_words_from_same_languageERKNS_9CandidateEj_block_invoke(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 106) & 4) == 0) {
    return 1;
  }
  uint64_t v2 = *(void *)(a2 + 136);
  if (*(_DWORD *)(a1 + 32) == v2) {
    return 1;
  }
  if ((*(unsigned char *)(a2 + 135) & 4) != 0) {
    return 1;
  }
  return (HIDWORD(v2) - 1) < 0x1F3;
}

uint64_t KB::CandidateFilter::_sortkey_factory(KB::CandidateFilter *this, const KB::CandidateFilterResources *a2)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)v2, 1u);
  }
  uint64_t v3 = *(void *)(v2 + 8) + 112;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v2);
  return v3;
}

unsigned int *KB::CandidateFilter::_sortkey_for_string@<X0>(_LXLexicon *this@<X0>, const KB::String *a2@<X1>, _WORD *a3@<X8>)
{
  uint64_t v4 = *((void *)a2 + 2);
  if (v4) {
    atomic_fetch_add((atomic_uint *volatile)v4, 1u);
  }
  KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(v4 + 8) + 72), this, a3);

  return WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v4);
}

CFTypeRef KB::LanguageModel::engine_string_to_surface_form@<X0>(CFTypeRef cf@<X1>, void *a2@<X8>)
{
  *a2 = cf;
  if (cf)
  {
    CFTypeRef result = CFRetain(cf);
    *a2 = cf;
  }
  return result;
}

uint64_t KB::LanguageModel::id_for_dynamic_word(uint64_t a1, const __CFString *a2, uint64_t *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)) {
    return 0;
  }
  uint64_t v5 = *a3;
  KB::utf8_string(a2, (uint64_t)v8);
  KB::DynamicDictionary::word_with_string((KB::DynamicDictionary *)v10, *(const String **)(v5 + 24), (uint64_t)v8);
  uint64_t v6 = v11;
  KB::Word::~Word((KB::Word *)v10);
  if (v9 && v8[6] == 1) {
    free(v9);
  }
  return v6;
}

double KB::DynamicDictionary::word_with_string(KB::DynamicDictionary *this, const String *a2, uint64_t a3)
{
  if ((*(unsigned int (**)(const String *))(*(void *)&a2->var0 + 32))(a2))
  {
    uint64_t v6 = *(void (**)(const String *, uint64_t))(*(void *)&a2->var0 + 56);
    v6(a2, a3);
  }
  else
  {
    *((_OWORD *)this + 13) = 0u;
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)this + 12) = 0u;
    *((_OWORD *)this + 9) = 0u;
    *((_OWORD *)this + 10) = 0u;
    *((_OWORD *)this + 7) = 0u;
    *((_OWORD *)this + 8) = 0u;
    *((_OWORD *)this + 5) = 0u;
    *((_OWORD *)this + 6) = 0u;
    *((_OWORD *)this + 3) = 0u;
    *((_OWORD *)this + 4) = 0u;
    *((_OWORD *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)this + 2) = 0u;
    *(_OWORD *)this = 0u;
    return KB::Word::Word(this);
  }
  return result;
}

void KB::LanguageModel::copyLinguisticDataFiles(CFDictionaryRef *a1@<X8>)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  values = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  *a1 = CFDictionaryCreate(v3, MEMORY[0x1E4F72400], (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (values) {
    CFRelease(values);
  }
}

void KB::LanguageModel::get_num_candidates(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[16] = 0;
}

uint64_t KB::LanguageModel::should_score_completion_candidate(KB::LanguageModel *this, const Candidate *a2)
{
  return 1;
}

uint64_t KB::LanguageModel::supports_fragment_based_conditional_prob(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::supports_multilingual(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::does_provide_inline_completions_for_locale(KB::LanguageModel *this, const String *a2)
{
  return 0;
}

uint64_t KB::LanguageModel::does_provide_inline_completions(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::advanced_models_loaded(KB::LanguageModel *this)
{
  return 0;
}

uint64_t KB::LanguageModel::does_provide_completions(KB::LanguageModel *this)
{
  return 0;
}

void KB::LanguageModel::synchronized_load(KB::LanguageModel *this)
{
  uint64_t v1 = KB::LanguageModel::background_loading_queue(this);
  dispatch_assert_queue_not_V2(v1);

  CFAllocatorRef v3 = KB::LanguageModel::background_loading_queue(v2);
  TIDispatchSync();
}

id KB::LanguageModel::background_loading_queue(KB::LanguageModel *this)
{
  if (KB::LanguageModel::background_loading_queue(void)::onceToken != -1) {
    dispatch_once(&KB::LanguageModel::background_loading_queue(void)::onceToken, &__block_literal_global_16);
  }
  uint64_t v1 = (void *)KB::LanguageModel::background_loading_queue(void)::__queue;

  return v1;
}

uint64_t ___ZN2KB13LanguageModel17synchronized_loadEv_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 32) + 72))(*(void *)(a1 + 32), 1);
}

void ___ZN2KB13LanguageModel24background_loading_queueEv_block_invoke()
{
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  dispatch_queue_t v0 = dispatch_queue_create("com.apple.TextInput.language-model.loading", v2);
  uint64_t v1 = (void *)KB::LanguageModel::background_loading_queue(void)::__queue;
  KB::LanguageModel::background_loading_queue(void)::__queue = (uint64_t)v0;
}

void *KB::LanguageModel::LanguageModel(void *this)
{
  *this = &unk_1F3F724E8;
  return this;
}

BOOL KB::LanguageModel::lexicon_id_active(KB::LanguageModel *this, int a2)
{
  (*(void (**)(_DWORD **__return_ptr))(*(void *)this + 48))(&v6);
  CFAllocatorRef v3 = v7;
  uint64_t v4 = v6;
  if (v6 != v7)
  {
    uint64_t v4 = v6;
    while (*v4 != a2)
    {
      if (++v4 == v7)
      {
        uint64_t v4 = v7;
        break;
      }
    }
  }
  if (v6)
  {
    unsigned int v7 = v6;
    operator delete(v6);
  }
  return v4 != v3;
}

BOOL KB::LanguageModel::is_special_id(KB::LanguageModel *this, TITokenID a2)
{
  return (HIDWORD(this) - 3) < 0x1F1;
}

CFIndex KB::LanguageModel::get_prediction_count(KB::LanguageModel *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  Boolean keyExistsAndHasValidFormat = 0;
  AppIntegerCFNumberRef Value = CFPreferencesGetAppIntegerValue(@"LanguageModelPredictionCount", @"com.apple.keyboard", &keyExistsAndHasValidFormat);
  if (!keyExistsAndHasValidFormat) {
    return 50;
  }
  CFIndex v2 = AppIntegerValue;
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v6 = "get_prediction_count";
    __int16 v7 = 2080;
    unint64_t v8 = "get_prediction_count";
    __int16 v9 = 2048;
    CFIndex v10 = v2;
    _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  %s: prediction_count=%zu (overridden by user preferences)", buf, 0x20u);
  }
  return v2;
}

uint64_t KB::LanguageModel::id_for_static_word_with_surface_form(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1)) {
    return 0;
  }
  (*(void (**)(float **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 312))(&v40, a1, a2, a3, a4, (a6 >> 5) & 1, 1);
  if ((a6 & 3) != 0)
  {
    uint64_t v14 = v41;
    if (v40 != v41)
    {
      BOOL v16 = (a6 & 4) == 0 || a5 == 0;
      TITokenID v17 = (uint64_t *)(v40 + 34);
      while (1)
      {
        KB::Word::capitalized_string((KB::Word *)(v17 - 17), (uint64_t)v46);
        if (v46 == (unsigned char *)a2) {
          break;
        }
        BOOL v18 = KB::String::equal((KB::String *)v46, (const KB::String *)a2, 1);
        if (v47) {
          BOOL v19 = v46[6] == 1;
        }
        else {
          BOOL v19 = 0;
        }
        if (v19) {
          free(v47);
        }
        if (v18) {
          goto LABEL_26;
        }
LABEL_28:
        uint64_t v23 = (float *)(v17 + 13);
        v17 += 30;
        if (v23 == v14) {
          goto LABEL_29;
        }
      }
      uint64_t v20 = *(void **)(a2 + 8);
      if (v20) {
        BOOL v21 = *(unsigned char *)(a2 + 6) == 1;
      }
      else {
        BOOL v21 = 0;
      }
      if (v21) {
        free(v20);
      }
LABEL_26:
      if (v16) {
        goto LABEL_75;
      }
      uint64_t v22 = *v17;
      if (*v17 == a5) {
        goto LABEL_76;
      }
      goto LABEL_28;
    }
LABEL_29:
    if ((a6 & 4) != 0)
    {
      double v24 = (KB::Word *)v40;
      uint64_t v25 = (KB::Word *)v41;
      if (v40 != v41)
      {
        uint64_t v26 = (KB::Word *)v40;
        while (1)
        {
          KB::Word::capitalized_string(v26, (uint64_t)v43);
          if (v43 == (unsigned char *)a2) {
            break;
          }
          BOOL v27 = KB::String::equal((KB::String *)v43, (const KB::String *)a2, 1);
          if (v45) {
            BOOL v28 = v44 == 1;
          }
          else {
            BOOL v28 = 0;
          }
          if (v28) {
            free(v45);
          }
          if (v27)
          {
            double v24 = v26;
LABEL_74:
            TITokenID v17 = (uint64_t *)((char *)v24 + 136);
            goto LABEL_75;
          }
          uint64_t v26 = (KB::Word *)((char *)v26 + 240);
          if (v26 == v25) {
            goto LABEL_41;
          }
        }
        uint64_t v37 = *(void **)(a2 + 8);
        if (v37) {
          BOOL v38 = *(unsigned char *)(a2 + 6) == 1;
        }
        else {
          BOOL v38 = 0;
        }
        if (v38) {
          free(v37);
        }
        goto LABEL_74;
      }
    }
LABEL_41:
    if ((a6 & 2) != 0) {
      goto LABEL_66;
    }
  }
  uint64_t v29 = v40;
  if (v40 == v41)
  {
LABEL_66:
    uint64_t v22 = 0;
    goto LABEL_76;
  }
  unsigned int v30 = 0;
  BOOL v32 = (a6 & 4) == 0 || a5 == 0;
  unsigned int v33 = -1;
  float v34 = 0.0;
  uint64_t v35 = v40;
  do
  {
    if (v32 || *((_DWORD *)v35 + 34) == a5)
    {
      if (v33 == -1)
      {
        unsigned int v33 = 0;
      }
      else
      {
        if (v35[12] <= v34)
        {
LABEL_57:
          ++v30;
          goto LABEL_58;
        }
        unsigned int v33 = v30;
      }
      float v34 = v35[12];
      goto LABEL_57;
    }
LABEL_58:
    v35 += 60;
  }
  while (v35 != v41);
  if ((v33 & 0x80000000) != 0) {
    goto LABEL_66;
  }
  if (0xEEEEEEEEEEEEEEEFLL * (((char *)v41 - (char *)v40) >> 4) <= v33) {
    abort();
  }
  unsigned int v36 = v33;
  KB::Word::capitalized_string((KB::Word *)&v40[60 * v33], (uint64_t)v43);
  KB::String::operator=(a7, (KB::String *)v43);
  if (v45 && v44 == 1) {
    free(v45);
  }
  TITokenID v17 = (uint64_t *)&v29[60 * v36 + 34];
LABEL_75:
  uint64_t v22 = *v17;
LABEL_76:
  uint64_t v42 = &v40;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v42);
  return v22;
}

uint64_t KB::LanguageModel::id_for_static_word(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  int v13 = 0x100000;
  __int16 v14 = 0;
  char v15 = 0;
  BOOL v16 = 0;
  char v17 = 0;
  if (a5) {
    unsigned int v9 = 45;
  }
  else {
    unsigned int v9 = 13;
  }
  int v10 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 440))(a1, a4);
  uint64_t v11 = KB::LanguageModel::id_for_static_word_with_surface_form(a1, a2, a3, a4, v10, v9, (uint64_t)&v13);
  if (v16 && v15 == 1) {
    free(v16);
  }
  return v11;
}

uint64_t KB::LanguageModel::id_for_maximum_likelihood_static_word(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = *a1 + 240;
  if (*a1 != v2 && v3 != v2)
  {
    do
    {
      if (*(float *)(v1 + 48) < *(float *)(v3 + 48)) {
        uint64_t v1 = v3;
      }
      v3 += 240;
    }
    while (v3 != v2);
  }
  if (v1 == v2) {
    return 0;
  }
  else {
    return *(void *)(v1 + 136);
  }
}

unint64_t KB::LanguageModel::id_for_maximum_likelihood_word(uint64_t a1, KB::Word **a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v9 = *a2;
  int v10 = a2[1];
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  char v17 = ___ZN2KB13LanguageModel30id_for_maximum_likelihood_wordERKNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextERNS_6StringE_block_invoke;
  uint64_t v18 = &__block_descriptor_48_e15_B24__0r_v8r_v16l;
  uint64_t v19 = a1;
  uint64_t v20 = a4;
  uint64_t v11 = v16;
  uint64_t v12 = (KB::Word *)((char *)v9 + 240);
  if (v9 != v10 && v12 != v10)
  {
    do
    {
      if (((unsigned int (*)(void *, KB::Word *, KB::Word *))v17)(v11, v9, v12)) {
        unsigned int v9 = v12;
      }
      uint64_t v12 = (KB::Word *)((char *)v12 + 240);
    }
    while (v12 != v10);
  }

  if (v9 == a2[1]) {
    return 0;
  }
  unint64_t v14 = *((void *)v9 + 17);
  if (!HIDWORD(v14))
  {
    KB::Word::capitalized_string(v9, (uint64_t)v21);
    unint64_t v14 = KB::LanguageModel::id_for_dynamic_engine_word(a1, v21, a3);
    if (v23)
    {
      if (v22 == 1) {
        free(v23);
      }
    }
  }
  KB::Word::capitalized_string(v9, (uint64_t)v21);
  KB::String::operator=(a5, (KB::String *)v21);
  if (v23 && v22 == 1) {
    free(v23);
  }
  return v14;
}

BOOL ___ZN2KB13LanguageModel30id_for_maximum_likelihood_wordERKNSt3__16vectorINS_4WordENS1_9allocatorIS3_EEEERKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextERNS_6StringE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  BOOL result = (*(unsigned __int8 *)(a3 + 106) >> 2) & 1;
  if (result == (*(unsigned char *)(a2 + 106) & 4) >> 2)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (*(float *)(a2 + 52) == 1.0)
    {
      KB::Word::capitalized_string((KB::Word *)a2, (uint64_t)v15);
      uint64_t v11 = *(void *)(a2 + 136);
      v8.n128_u32[0] = *(_DWORD *)(a2 + 52);
      (*(void (**)(void **__return_ptr, uint64_t, unsigned char *, uint64_t *, void, void, __n128))(*(void *)v7 + 424))(v12, v7, v15, &v11, *(void *)(a1 + 40), 0, v8);
      if (v17 && v16 == 1) {
        free(v17);
      }
      *(_DWORD *)(a2 + 52) = v12[0];
      if (v14 < 0) {
        operator delete(__p);
      }
    }
    float v9 = *(float *)(a3 + 52);
    if (v9 == 1.0)
    {
      KB::Word::capitalized_string((KB::Word *)a3, (uint64_t)v15);
      uint64_t v11 = *(void *)(a3 + 136);
      v10.n128_u32[0] = *(_DWORD *)(a3 + 52);
      (*(void (**)(void **__return_ptr, uint64_t, unsigned char *, uint64_t *, void, void, __n128))(*(void *)v7 + 424))(v12, v7, v15, &v11, *(void *)(a1 + 40), 0, v10);
      if (v17 && v16 == 1) {
        free(v17);
      }
      float v9 = *(float *)v12;
      *(_DWORD *)(a3 + 52) = v12[0];
      if (v14 < 0)
      {
        operator delete(__p);
        float v9 = *(float *)(a3 + 52);
      }
    }
    return *(float *)(a2 + 52) < v9;
  }
  return result;
}

uint64_t KB::LanguageModel::id_for_dynamic_engine_word(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  KB::cf_string_impl<KB::String>(&v8, a2);
  CFStringRef v5 = v8;
  (*(void (**)(CFTypeRef *__return_ptr, uint64_t, CFStringRef))(*(void *)a1 + 568))(&cf, a1, v8);
  if (v5) {
    CFRelease(v5);
  }
  if (!cf) {
    return 0;
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, CFTypeRef, uint64_t))(*(void *)a1 + 320))(a1, cf, a3);
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

uint64_t KB::LanguageModel::is_language_appropriate_vocabulary_word(KB::LanguageModel *this, __CFString *a2)
{
  if (![(__CFString *)a2 hasSuffix:@"'s"]) {
    return 1;
  }
  uint64_t v3 = *(uint64_t (**)(KB::LanguageModel *))(*(void *)this + 64);

  return v3(this);
}

uint64_t KB::LanguageModel::find_vocabulary_words(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, KB::Word **a5, uint64_t *a6)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t result = LMVocabularyGetSharedVocabulary();
  for (uint64_t i = *a5; i != a5[1]; uint64_t i = (KB::Word *)((char *)i + 240))
  {
    if (!HIDWORD(*((void *)i + 17)))
    {
      KB::Word::capitalized_string(i, (uint64_t)&v23);
      KB::LanguageModel::id_for_dynamic_engine_word(a1, (unsigned __int16 *)&v23, a3);
      if (v24 && BYTE6(v23) == 1) {
        free(v24);
      }
    }
    uint64_t result = LMVocabularyGetClassForTokenID();
    if (result)
    {
      if (![a2 hasSuffix:@"'s"]
        || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1), result))
      {
        char v14 = (KB::Word *)a6[1];
        unint64_t v15 = a6[2];
        if ((unint64_t)v14 >= v15)
        {
          unint64_t v17 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v14 - *a6) >> 4);
          unint64_t v18 = v17 + 1;
          if (v17 + 1 > 0x111111111111111) {
            abort();
          }
          unint64_t v19 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v15 - *a6) >> 4);
          if (2 * v19 > v18) {
            unint64_t v18 = 2 * v19;
          }
          if (v19 >= 0x88888888888888) {
            unint64_t v20 = 0x111111111111111;
          }
          else {
            unint64_t v20 = v18;
          }
          BOOL v27 = a6 + 2;
          if (v20) {
            unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v20);
          }
          else {
            uint64_t v21 = 0;
          }
          char v22 = (char *)(v20 + 240 * v17);
          unint64_t v23 = v20;
          uint64_t v24 = v22;
          unint64_t v26 = v20 + 240 * v21;
          KB::Word::Word((KB::Word *)v22, (size_t *)i);
          uint64_t v25 = v22 + 240;
          std::vector<KB::Word>::__swap_out_circular_buffer(a6, &v23);
          uint64_t v16 = a6[1];
          uint64_t result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v23);
        }
        else
        {
          uint64_t result = (uint64_t)KB::Word::Word(v14, (size_t *)i);
          uint64_t v16 = result + 240;
        }
        a6[1] = v16;
      }
    }
  }
  return result;
}

void KB::LanguageModel::find_words_for_sentence_beginning(uint64_t a1, __CFString *a2, uint64_t *a3, uint64_t a4, char a5, uint64_t *a6)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  KB::utf8_string(a2, (uint64_t)v55);
  uint64_t v11 = [(__CFString *)a2 lowercaseStringWithLocale:a4];
  KB::utf8_string(v11, (uint64_t)v53);
  uint64_t v12 = a2;
  KB::utf8_string(v12, (uint64_t)v51);
  long long v49 = 0uLL;
  unint64_t v50 = 0;
  long long v47 = 0uLL;
  unint64_t v48 = 0;
  int v13 = (KB::Word *)*a3;
  if (*a3 == a3[1])
  {
    uint64_t v43 = *a6;
    uint64_t v42 = a6[1];
    BOOL v39 = 1;
  }
  else
  {
    uint64_t v44 = (uint64_t)a6;
    do
    {
      KB::Word::capitalized_string(v13, (uint64_t)&v57);
      BOOL v14 = KB::String::equal((KB::String *)&v57, (const KB::String *)v53, 1);
      if (v58.i64[0]) {
        BOOL v15 = BYTE6(v57) == 1;
      }
      else {
        BOOL v15 = 0;
      }
      if (v15) {
        free((void *)v58.i64[0]);
      }
      if (v14)
      {
        if (*((void *)&v49 + 1) >= v50)
        {
          unint64_t v17 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)&v49 + 1) - v49) >> 4);
          unint64_t v18 = v17 + 1;
          if (v17 + 1 > 0x111111111111111) {
            goto LABEL_76;
          }
          if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v50 - v49) >> 4) > v18) {
            unint64_t v18 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v50 - v49) >> 4);
          }
          if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v50 - v49) >> 4) >= 0x88888888888888) {
            unint64_t v19 = 0x111111111111111;
          }
          else {
            unint64_t v19 = v18;
          }
          long long v60 = &v50;
          if (v19) {
            unint64_t v19 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v19);
          }
          else {
            uint64_t v20 = 0;
          }
          uint64_t v21 = (KB::Word *)(v19 + 240 * v17);
          long long v57 = (void **)v19;
          v58.i64[0] = (uint64_t)v21;
          unint64_t v59 = v19 + 240 * v20;
          KB::Word::Word(v21, (size_t *)v13);
          uint64_t v16 = (char *)v21 + 240;
          v58.i64[1] = (uint64_t)v21 + 240;
          uint64_t v22 = *((void *)&v49 + 1);
          uint64_t v23 = v49;
          uint64_t v24 = v58.i64[0];
          if (*((void *)&v49 + 1) == (void)v49)
          {
            int64x2_t v25 = vdupq_n_s64(*((unint64_t *)&v49 + 1));
          }
          else
          {
            do
            {
              v22 -= 240;
              uint64_t v24 = KB::Word::Word(v24 - 240, v22);
            }
            while (v22 != v23);
            int64x2_t v25 = (int64x2_t)v49;
            uint64_t v16 = (char *)v58.i64[1];
          }
          *(void *)&long long v49 = v24;
          *((void *)&v49 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v16;
          int64x2_t v58 = v25;
          unint64_t v26 = v50;
          unint64_t v50 = v59;
          unint64_t v59 = v26;
          long long v57 = (void **)v25.i64[0];
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v57);
        }
        else
        {
          uint64_t v16 = (char *)KB::Word::Word(*((KB::Word **)&v49 + 1), (size_t *)v13) + 240;
        }
        *((void *)&v49 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v16;
      }
      KB::Word::capitalized_string(v13, (uint64_t)&v57);
      BOOL v27 = KB::String::equal((KB::String *)&v57, (const KB::String *)v51, 1);
      if (v58.i64[0] && BYTE6(v57) == 1) {
        free((void *)v58.i64[0]);
      }
      if (v27)
      {
        if (*((void *)&v47 + 1) >= v48)
        {
          unint64_t v29 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)&v47 + 1) - v47) >> 4) + 1;
          if (v29 > 0x111111111111111) {
LABEL_76:
          }
            abort();
          if (0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v48 - v47) >> 4) > v29) {
            unint64_t v29 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(v48 - v47) >> 4);
          }
          if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v48 - v47) >> 4) >= 0x88888888888888) {
            unint64_t v30 = 0x111111111111111;
          }
          else {
            unint64_t v30 = v29;
          }
          long long v60 = &v48;
          if (v30) {
            unint64_t v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v30);
          }
          else {
            uint64_t v31 = 0;
          }
          BOOL v32 = (KB::Word *)(v30 + 16 * ((uint64_t)(*((void *)&v47 + 1) - v47) >> 4));
          long long v57 = (void **)v30;
          v58.i64[0] = (uint64_t)v32;
          unint64_t v59 = v30 + 240 * v31;
          KB::Word::Word(v32, (size_t *)v13);
          uint64_t v28 = (char *)v32 + 240;
          v58.i64[1] = (uint64_t)v32 + 240;
          uint64_t v33 = *((void *)&v47 + 1);
          uint64_t v34 = v58.i64[0];
          if (*((void *)&v47 + 1) == (void)v47)
          {
            int64x2_t v35 = vdupq_n_s64(*((unint64_t *)&v47 + 1));
          }
          else
          {
            do
            {
              v33 -= 240;
              uint64_t v34 = KB::Word::Word(v34 - 240, v33);
            }
            while (v33 != (void)v47);
            int64x2_t v35 = (int64x2_t)v47;
            uint64_t v28 = (char *)v58.i64[1];
          }
          *(void *)&long long v47 = v34;
          *((void *)&v47 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v28;
          int64x2_t v58 = v35;
          unint64_t v36 = v48;
          unint64_t v48 = v59;
          unint64_t v59 = v36;
          long long v57 = (void **)v35.i64[0];
          std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v57);
        }
        else
        {
          uint64_t v28 = (char *)KB::Word::Word(*((KB::Word **)&v47 + 1), (size_t *)v13) + 240;
        }
        *((void *)&v47 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v28;
      }
      int v13 = (KB::Word *)((char *)v13 + 240);
    }
    while (v13 != (KB::Word *)a3[1]);
    long long v37 = v49;
    long long v38 = v47;
    BOOL v39 = *((void *)&v49 + 1) == (void)v49;
    a6 = (uint64_t *)v44;
    if (*((void *)&v49 + 1) != (void)v49 && *((void *)&v47 + 1) != (void)v47)
    {
      v46[0] = MEMORY[0x1E4F143A8];
      v46[1] = 3221225472;
      v46[2] = ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke;
      v46[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      v46[4] = v44;
      id v40 = std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(v47, *((uint64_t *)&v47 + 1), v46);
      v45[0] = MEMORY[0x1E4F143A8];
      v45[1] = 3221225472;
      v45[2] = ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke_2;
      v45[3] = &__block_descriptor_40_e10_v16__0r_v8l;
      void v45[4] = v44;
      id v41 = std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(v49, *((uint64_t *)&v49 + 1), v45);
    }
    uint64_t v43 = *(void *)v44;
    uint64_t v42 = *(void *)(v44 + 8);
    if (*((void *)&v37 + 1) != (void)v37 && &v49 != (long long *)v44 && v42 == v43)
    {
      std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(v44, v49, *((uint64_t *)&v49 + 1), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)&v49 + 1) - v49) >> 4));
      uint64_t v43 = *(void *)v44;
      uint64_t v42 = *(void *)(v44 + 8);
    }
    if (&v47 != (long long *)v44 && v42 == v43 && *((void *)&v38 + 1) != (void)v38)
    {
      std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(v44, v47, *((uint64_t *)&v47 + 1), 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*((void *)&v47 + 1) - v47) >> 4));
      uint64_t v43 = *(void *)v44;
      uint64_t v42 = *(void *)(v44 + 8);
    }
  }
  if (v39 && a6 != a3 && (a5 & 2) == 0 && v42 == v43) {
    std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>((uint64_t)a6, *a3, a3[1], 0xEEEEEEEEEEEEEEEFLL * ((a3[1] - *a3) >> 4));
  }
  long long v57 = (void **)&v47;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v57);
  long long v57 = (void **)&v49;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v57);
  if (v52 && v51[6] == 1) {
    free(v52);
  }

  if (v54 && v53[6] == 1) {
    free(v54);
  }

  if (v56)
  {
    if (v55[6] == 1) {
      free(v56);
    }
  }
}

uint64_t ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke(uint64_t result, size_t *a2)
{
  if ((a2[13] & 0x2080) != 0x80)
  {
    uint64_t v3 = *(uint64_t **)(result + 32);
    uint64_t v4 = (KB::Word *)v3[1];
    unint64_t v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v4 - *v3) >> 4);
      if (v7 + 1 > 0x111111111111111) {
        abort();
      }
      unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
      uint64_t v9 = 2 * v8;
      if (2 * v8 <= v7 + 1) {
        uint64_t v9 = v7 + 1;
      }
      if (v8 >= 0x88888888888888) {
        unint64_t v10 = 0x111111111111111;
      }
      else {
        unint64_t v10 = v9;
      }
      uint64_t v16 = v3 + 2;
      if (v10) {
        unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
      }
      else {
        uint64_t v11 = 0;
      }
      unint64_t v12 = v10;
      int v13 = (KB::Word *)(v10 + 240 * v7);
      unint64_t v15 = v10 + 240 * v11;
      KB::Word::Word(v13, a2);
      BOOL v14 = (char *)v13 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(v3, &v12);
      uint64_t v6 = v3[1];
      uint64_t result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v12);
    }
    else
    {
      uint64_t result = (uint64_t)KB::Word::Word(v4, a2);
      uint64_t v6 = result + 240;
    }
    v3[1] = v6;
  }
  return result;
}

id std::for_each[abi:nn180100]<std::__wrap_iter<KB::Word *>,void({block_pointer} {__strong})(KB::Word const&)>(uint64_t a1, uint64_t a2, void *a3)
{
  for (uint64_t i = a3; a1 != a2; a1 += 240)
    i[2](i, a1);
  uint64_t v6 = _Block_copy(i);

  return v6;
}

uint64_t ___ZN2KB13LanguageModel33find_words_for_sentence_beginningEPK10__CFStringRKNSt3__16vectorINS_4WordENS4_9allocatorIS6_EEEEPK10__CFLocalejRS9__block_invoke_2(uint64_t result, size_t *a2)
{
  if ((a2[13] & 0x2080) != 0x80)
  {
    uint64_t v3 = *(uint64_t **)(result + 32);
    uint64_t v4 = (KB::Word *)v3[1];
    unint64_t v5 = v3[2];
    if ((unint64_t)v4 >= v5)
    {
      unint64_t v7 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v4 - *v3) >> 4);
      if (v7 + 1 > 0x111111111111111) {
        abort();
      }
      unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - *v3) >> 4);
      uint64_t v9 = 2 * v8;
      if (2 * v8 <= v7 + 1) {
        uint64_t v9 = v7 + 1;
      }
      if (v8 >= 0x88888888888888) {
        unint64_t v10 = 0x111111111111111;
      }
      else {
        unint64_t v10 = v9;
      }
      uint64_t v16 = v3 + 2;
      if (v10) {
        unint64_t v10 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
      }
      else {
        uint64_t v11 = 0;
      }
      unint64_t v12 = v10;
      int v13 = (KB::Word *)(v10 + 240 * v7);
      unint64_t v15 = v10 + 240 * v11;
      KB::Word::Word(v13, a2);
      BOOL v14 = (char *)v13 + 240;
      std::vector<KB::Word>::__swap_out_circular_buffer(v3, &v12);
      uint64_t v6 = v3[1];
      uint64_t result = std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v12);
    }
    else
    {
      uint64_t result = (uint64_t)KB::Word::Word(v4, a2);
      uint64_t v6 = result + 240;
    }
    v3[1] = v6;
  }
  return result;
}

void std::vector<KB::Word>::__assign_with_size[abi:nn180100]<KB::Word*,KB::Word*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = (size_t *)a2;
  unint64_t v8 = *(void **)a1;
  if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a4)
  {
    std::vector<KB::Word>::__vdeallocate((void **)a1);
    if (a4 > 0x111111111111111) {
      goto LABEL_21;
    }
    unint64_t v9 = 0xDDDDDDDDDDDDDDDELL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    unint64_t v10 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) >= 0x88888888888888
        ? 0x111111111111111
        : v9;
    if (v10 > 0x111111111111111) {
LABEL_21:
    }
      abort();
    uint64_t v11 = (KB::Word *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v10);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v11;
    *(void *)(a1 + 16) = (char *)v11 + 240 * v12;
    while (v6 != (size_t *)a3)
    {
      int v13 = KB::Word::Word(v11, v6);
      v6 += 30;
      uint64_t v11 = (KB::Word *)((char *)v13 + 240);
    }
    goto LABEL_16;
  }
  if (0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 4) < a4)
  {
    BOOL v14 = (size_t *)(a2 + 16 * ((uint64_t)(*(void *)(a1 + 8) - (void)v8) >> 4));
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(a2, (uint64_t)v14, (uint64_t)v8);
    uint64_t v11 = *(KB::Word **)(a1 + 8);
    while (v14 != (size_t *)a3)
    {
      unint64_t v15 = KB::Word::Word(v11, v14);
      v14 += 30;
      uint64_t v11 = (KB::Word *)((char *)v15 + 240);
    }
LABEL_16:
    *(void *)(a1 + 8) = v11;
    return;
  }
  uint64_t v16 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(a2, a3, (uint64_t)v8);
  for (uint64_t i = *(void *)(a1 + 8); i != v16; KB::Word::~Word((KB::Word *)(i - 240)))
    ;
  *(void *)(a1 + 8) = v16;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = a3 + v6;
      uint64_t v8 = a1 + v6;
      KB::String::operator=((KB::String *)(a3 + v6), (KB::String *)(a1 + v6));
      KB::ByteString::operator=((unsigned __int16 *)(a3 + v6 + 32), (unsigned __int16 *)(a1 + v6 + 32));
      uint64_t v9 = *(void *)(a1 + v6 + 48);
      *(_DWORD *)(v7 + 56) = *(_DWORD *)(a1 + v6 + 56);
      *(void *)(v7 + 48) = v9;
      KB::String::operator=((KB::String *)(a3 + v6 + 64), (KB::String *)(a1 + v6 + 64));
      long long v10 = *(_OWORD *)(a1 + v6 + 96);
      long long v11 = *(_OWORD *)(a1 + v6 + 112);
      long long v12 = *(_OWORD *)(a1 + v6 + 144);
      *(_OWORD *)(v7 + 128) = *(_OWORD *)(a1 + v6 + 128);
      *(_OWORD *)(v7 + 144) = v12;
      *(_OWORD *)(v7 + 96) = v10;
      *(_OWORD *)(v7 + 112) = v11;
      KB::String::operator=((KB::String *)(a3 + v6 + 160), (KB::String *)(a1 + v6 + 160));
      *(unsigned char *)(v7 + 192) = *(unsigned char *)(a1 + v6 + 192);
      if (a1 != a3)
      {
        *(_DWORD *)(v7 + 232) = *(_DWORD *)(v8 + 232);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(v7 + 200), *(void **)(v8 + 216));
      }
      v6 += 240;
    }
    while (a1 + v6 != a2);
    a3 += v6;
  }
  return a3;
}

void std::vector<KB::Word>::__vdeallocate(void **a1)
{
  uint64_t v1 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = v1;
    if (v3 != v1)
    {
      do
        KB::Word::~Word((KB::Word *)(v3 - 240));
      while (v3 != v1);
      uint64_t v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

BOOL KB::LanguageModel::lexicon_match(KB::LanguageModel *this, int a2, const KB::Word *a3)
{
  if (!a2) {
    return 1;
  }
  int v3 = *((_DWORD *)a3 + 34);
  return v3 == -2 || v3 == 0 || v3 == a2;
}

void KB::LanguageModel::merge_words(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, uint64_t *a5)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1))
  {
    uint64_t v10 = *a2;
    uint64_t v9 = a2[1];
    if (*a2 == v9)
    {
      uint64_t v9 = *a2;
    }
    else
    {
      do
      {
        if (!a4
          || ((v11 = *(_DWORD *)(v10 + 136), v11 != -2) ? (BOOL v12 = v11 == 0) : (BOOL v12 = 1),
              !v12 ? (BOOL v13 = v11 == a4) : (BOOL v13 = 1),
              v13))
        {
          BOOL v14 = (KB::Word *)a5[1];
          unint64_t v15 = a5[2];
          if ((unint64_t)v14 >= v15)
          {
            unint64_t v17 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v14 - *a5) >> 4);
            unint64_t v18 = v17 + 1;
            if (v17 + 1 > 0x111111111111111) {
              goto LABEL_180;
            }
            unint64_t v19 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v15 - *a5) >> 4);
            if (2 * v19 > v18) {
              unint64_t v18 = 2 * v19;
            }
            if (v19 >= 0x88888888888888) {
              unint64_t v20 = 0x111111111111111;
            }
            else {
              unint64_t v20 = v18;
            }
            v113 = a5 + 2;
            if (v20) {
              unint64_t v20 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v20);
            }
            else {
              uint64_t v21 = 0;
            }
            uint64_t v22 = (KB::Word *)(v20 + 240 * v17);
            unint64_t v109 = v20;
            uint64_t v110 = v22;
            unint64_t v112 = v20 + 240 * v21;
            KB::Word::Word(v22, (size_t *)v10);
            int v111 = (char *)v22 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            uint64_t v16 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            uint64_t v16 = (char *)KB::Word::Word(v14, (size_t *)v10) + 240;
          }
          a5[1] = (uint64_t)v16;
          uint64_t v9 = a2[1];
        }
        v10 += 240;
      }
      while (v10 != v9);
    }
    uint64_t v107 = 0;
    uint64_t v108 = 0;
    CFDictionaryRef v106 = &v107;
    if (a4)
    {
      if (a5[1] == *a5)
      {
        uint64_t v38 = *a2;
        if (*a2 != v9)
        {
          do
          {
            BOOL v39 = (KB::Word *)a5[1];
            unint64_t v40 = a5[2];
            if ((unint64_t)v39 >= v40)
            {
              unint64_t v42 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v39 - *a5) >> 4);
              unint64_t v43 = v42 + 1;
              if (v42 + 1 > 0x111111111111111) {
                goto LABEL_180;
              }
              unint64_t v44 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v40 - *a5) >> 4);
              if (2 * v44 > v43) {
                unint64_t v43 = 2 * v44;
              }
              if (v44 >= 0x88888888888888) {
                unint64_t v45 = 0x111111111111111;
              }
              else {
                unint64_t v45 = v43;
              }
              v113 = a5 + 2;
              if (v45) {
                unint64_t v45 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v45);
              }
              else {
                uint64_t v46 = 0;
              }
              long long v47 = (KB::Word *)(v45 + 240 * v42);
              unint64_t v109 = v45;
              uint64_t v110 = v47;
              unint64_t v112 = v45 + 240 * v46;
              KB::Word::Word(v47, (size_t *)v38);
              int v111 = (char *)v47 + 240;
              std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
              id v41 = (char *)a5[1];
              std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
            }
            else
            {
              id v41 = (char *)KB::Word::Word(v39, (size_t *)v38) + 240;
            }
            a5[1] = (uint64_t)v41;
            std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, *(_DWORD *)(v38 + 140), *(_DWORD *)(v38 + 140));
            v38 += 240;
          }
          while (v38 != a2[1]);
        }
      }
    }
    uint64_t v49 = *a3;
    uint64_t v48 = a3[1];
    if (*a3 != v48)
    {
      do
      {
        if ((*(_DWORD *)(v49 + 104) & 0x42000) != 0x40000)
        {
          if (!a4) {
            goto LABEL_82;
          }
          unint64_t v50 = *(void *)(v49 + 136);
          BOOL v51 = v50 == -2 || v50 == 0;
          if (v51 || v50 == a4) {
            goto LABEL_82;
          }
          long long v62 = v107;
          if (v107)
          {
            unint64_t v63 = HIDWORD(v50);
            long long v64 = &v107;
            do
            {
              uint64_t v65 = v62;
              unint64_t v66 = v64;
              unsigned int v67 = *((_DWORD *)v62 + 7);
              unint64_t v68 = v62 + 1;
              if (v67 >= v63)
              {
                unint64_t v68 = v65;
                long long v64 = (void **)v65;
              }
              long long v62 = (void *)*v68;
            }
            while (v62);
            if (v64 != &v107)
            {
              if (v67 < v63) {
                uint64_t v65 = v66;
              }
              if (*((_DWORD *)v65 + 7) <= v63)
              {
LABEL_82:
                long long v53 = (KB::Word *)a5[1];
                unint64_t v54 = a5[2];
                if ((unint64_t)v53 >= v54)
                {
                  unint64_t v56 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v53 - *a5) >> 4);
                  unint64_t v57 = v56 + 1;
                  if (v56 + 1 > 0x111111111111111) {
                    goto LABEL_180;
                  }
                  unint64_t v58 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v54 - *a5) >> 4);
                  if (2 * v58 > v57) {
                    unint64_t v57 = 2 * v58;
                  }
                  if (v58 >= 0x88888888888888) {
                    unint64_t v59 = 0x111111111111111;
                  }
                  else {
                    unint64_t v59 = v57;
                  }
                  v113 = a5 + 2;
                  if (v59) {
                    unint64_t v59 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v59);
                  }
                  else {
                    uint64_t v60 = 0;
                  }
                  uint64_t v61 = (KB::Word *)(v59 + 240 * v56);
                  unint64_t v109 = v59;
                  uint64_t v110 = v61;
                  unint64_t v112 = v59 + 240 * v60;
                  KB::Word::Word(v61, (size_t *)v49);
                  int v111 = (char *)v61 + 240;
                  std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
                  long long v55 = (char *)a5[1];
                  std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
                }
                else
                {
                  long long v55 = (char *)KB::Word::Word(v53, (size_t *)v49) + 240;
                }
                a5[1] = (uint64_t)v55;
                uint64_t v48 = a3[1];
              }
            }
          }
        }
        v49 += 240;
      }
      while (v49 != v48);
    }
    goto LABEL_179;
  }
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  CFDictionaryRef v106 = &v107;
  uint64_t v23 = *a3;
  uint64_t v24 = a3[1];
  if (*a3 != v24)
  {
    do
    {
      if ((*(unsigned char *)(v23 + 106) & 4) != 0)
      {
        if (!a4
          || ((int v25 = *(_DWORD *)(v23 + 136), v25 != -2) ? (v26 = v25 == 0) : (v26 = 1),
              !v26 ? (BOOL v27 = v25 == a4) : (BOOL v27 = 1),
              v27))
        {
          uint64_t v28 = (KB::Word *)a5[1];
          unint64_t v29 = a5[2];
          if ((unint64_t)v28 >= v29)
          {
            unint64_t v31 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v28 - *a5) >> 4);
            unint64_t v32 = v31 + 1;
            if (v31 + 1 > 0x111111111111111) {
LABEL_180:
            }
              abort();
            unint64_t v33 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v29 - *a5) >> 4);
            if (2 * v33 > v32) {
              unint64_t v32 = 2 * v33;
            }
            if (v33 >= 0x88888888888888) {
              unint64_t v34 = 0x111111111111111;
            }
            else {
              unint64_t v34 = v32;
            }
            v113 = a5 + 2;
            if (v34) {
              unint64_t v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v34);
            }
            else {
              uint64_t v35 = 0;
            }
            unint64_t v36 = (KB::Word *)(v34 + 240 * v31);
            unint64_t v109 = v34;
            uint64_t v110 = v36;
            unint64_t v112 = v34 + 240 * v35;
            KB::Word::Word(v36, (size_t *)v23);
            int v111 = (char *)v36 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            unint64_t v30 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            unint64_t v30 = (char *)KB::Word::Word(v28, (size_t *)v23) + 240;
          }
          a5[1] = (uint64_t)v30;
          std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, *(_DWORD *)(v23 + 136), *(_DWORD *)(v23 + 136));
        }
      }
      v23 += 240;
    }
    while (v23 != v24);
    uint64_t v37 = *a3;
    uint64_t v23 = a3[1];
    if (!a4) {
      goto LABEL_127;
    }
    goto LABEL_108;
  }
  uint64_t v37 = *a3;
  if (a4)
  {
LABEL_108:
    if (*a5 == a5[1])
    {
      if (v37 == v23)
      {
        uint64_t v37 = v23;
      }
      else
      {
        do
        {
          if ((*(unsigned char *)(v37 + 106) & 4) != 0)
          {
            unint64_t v69 = (KB::Word *)a5[1];
            unint64_t v70 = a5[2];
            if ((unint64_t)v69 >= v70)
            {
              unint64_t v72 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v69 - *a5) >> 4);
              unint64_t v73 = v72 + 1;
              if (v72 + 1 > 0x111111111111111) {
                goto LABEL_180;
              }
              unint64_t v74 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v70 - *a5) >> 4);
              if (2 * v74 > v73) {
                unint64_t v73 = 2 * v74;
              }
              if (v74 >= 0x88888888888888) {
                unint64_t v75 = 0x111111111111111;
              }
              else {
                unint64_t v75 = v73;
              }
              v113 = a5 + 2;
              if (v75) {
                unint64_t v75 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v75);
              }
              else {
                uint64_t v76 = 0;
              }
              uint64_t v77 = (KB::Word *)(v75 + 240 * v72);
              unint64_t v109 = v75;
              uint64_t v110 = v77;
              unint64_t v112 = v75 + 240 * v76;
              KB::Word::Word(v77, (size_t *)v37);
              int v111 = (char *)v77 + 240;
              std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
              unint64_t v71 = (char *)a5[1];
              std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
            }
            else
            {
              unint64_t v71 = (char *)KB::Word::Word(v69, (size_t *)v37) + 240;
            }
            a5[1] = (uint64_t)v71;
            std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>((uint64_t *)&v106, *(_DWORD *)(v37 + 136), *(_DWORD *)(v37 + 136));
          }
          v37 += 240;
        }
        while (v37 != v23);
        uint64_t v37 = *a3;
        uint64_t v23 = a3[1];
      }
    }
  }
LABEL_127:
  if (v108)
  {
    for (; v37 != v23; v37 += 240)
    {
      if ((*(unsigned char *)(v37 + 106) & 4) == 0)
      {
        uint64_t v78 = v107;
        if (v107)
        {
          unsigned int v79 = *(_DWORD *)(v37 + 136);
          unint64_t v80 = &v107;
          do
          {
            long long v81 = v78;
            uint64_t v82 = v80;
            unsigned int v83 = *((_DWORD *)v78 + 7);
            long long v84 = v78 + 1;
            if (v83 >= v79)
            {
              long long v84 = v81;
              unint64_t v80 = (void **)v81;
            }
            uint64_t v78 = (void *)*v84;
          }
          while (v78);
          if (v80 != &v107)
          {
            if (v83 < v79) {
              long long v81 = v82;
            }
            if (*((_DWORD *)v81 + 7) <= v79)
            {
              int v85 = (KB::Word *)a5[1];
              unint64_t v86 = a5[2];
              if ((unint64_t)v85 >= v86)
              {
                unint64_t v88 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v85 - *a5) >> 4);
                unint64_t v89 = v88 + 1;
                if (v88 + 1 > 0x111111111111111) {
                  goto LABEL_180;
                }
                unint64_t v90 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v86 - *a5) >> 4);
                if (2 * v90 > v89) {
                  unint64_t v89 = 2 * v90;
                }
                if (v90 >= 0x88888888888888) {
                  unint64_t v91 = 0x111111111111111;
                }
                else {
                  unint64_t v91 = v89;
                }
                v113 = a5 + 2;
                if (v91) {
                  unint64_t v91 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v91);
                }
                else {
                  uint64_t v92 = 0;
                }
                uint64_t v93 = (KB::Word *)(v91 + 240 * v88);
                unint64_t v109 = v91;
                uint64_t v110 = v93;
                unint64_t v112 = v91 + 240 * v92;
                KB::Word::Word(v93, (size_t *)v37);
                int v111 = (char *)v93 + 240;
                std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
                long long v87 = (char *)a5[1];
                std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
              }
              else
              {
                long long v87 = (char *)KB::Word::Word(v85, (size_t *)v37) + 240;
              }
              a5[1] = (uint64_t)v87;
            }
          }
        }
      }
    }
  }
  else
  {
    for (; v37 != v23; v37 += 240)
    {
      if ((*(unsigned char *)(v37 + 106) & 4) == 0)
      {
        if (!a4
          || ((int v94 = *(_DWORD *)(v37 + 136), v94 != -2) ? (v95 = v94 == 0) : (v95 = 1),
              !v95 ? (BOOL v96 = v94 == a4) : (BOOL v96 = 1),
              v96))
        {
          v97 = (KB::Word *)a5[1];
          unint64_t v98 = a5[2];
          if ((unint64_t)v97 >= v98)
          {
            unint64_t v100 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v97 - *a5) >> 4);
            unint64_t v101 = v100 + 1;
            if (v100 + 1 > 0x111111111111111) {
              goto LABEL_180;
            }
            unint64_t v102 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v98 - *a5) >> 4);
            if (2 * v102 > v101) {
              unint64_t v101 = 2 * v102;
            }
            if (v102 >= 0x88888888888888) {
              unint64_t v103 = 0x111111111111111;
            }
            else {
              unint64_t v103 = v101;
            }
            v113 = a5 + 2;
            if (v103) {
              unint64_t v103 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v103);
            }
            else {
              uint64_t v104 = 0;
            }
            long long v105 = (KB::Word *)(v103 + 240 * v100);
            unint64_t v109 = v103;
            uint64_t v110 = v105;
            unint64_t v112 = v103 + 240 * v104;
            KB::Word::Word(v105, (size_t *)v37);
            int v111 = (char *)v105 + 240;
            std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v109);
            v99 = (char *)a5[1];
            std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v109);
          }
          else
          {
            v99 = (char *)KB::Word::Word(v97, (size_t *)v37) + 240;
          }
          a5[1] = (uint64_t)v99;
        }
      }
    }
  }
LABEL_179:
  std::__tree<std::__value_type<float,int>,std::__map_value_compare<float,std::__value_type<float,int>,std::less<float>,true>,std::allocator<std::__value_type<float,int>>>::destroy(v107);
}

uint64_t *std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t *result, unsigned int a2, int a3)
{
  uint64_t v4 = result;
  uint64_t v6 = (uint64_t **)(result + 1);
  uint64_t v5 = result[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v7 = (void *)v5;
        unsigned int v8 = *(_DWORD *)(v5 + 28);
        if (v8 <= a2) {
          break;
        }
        uint64_t v5 = *v7;
        uint64_t v6 = (uint64_t **)v7;
        if (!*v7) {
          goto LABEL_9;
        }
      }
      if (v8 >= a2) {
        break;
      }
      uint64_t v5 = v7[1];
      if (!v5)
      {
        uint64_t v6 = (uint64_t **)(v7 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint64_t v7 = result + 1;
LABEL_9:
    uint64_t v9 = operator new(0x20uLL);
    v9[7] = a3;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
    *((void *)v9 + 2) = v7;
    *uint64_t v6 = (uint64_t *)v9;
    uint64_t v10 = *(void *)*v4;
    if (v10)
    {
      *uint64_t v4 = v10;
      int v11 = *v6;
    }
    else
    {
      int v11 = (uint64_t *)v9;
    }
    uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v11);
    ++v4[2];
  }
  return result;
}

unint64_t KB::LanguageModel::select_token_id_from_words(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, uint64_t a9)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(KB::Word **)a2;
  if (*(void *)(a2 + 8) == *(void *)a2) {
    return 0;
  }
  if (((a7 & 0x10) == 0 || (a8 & 1) == 0) && (a7 & 3) != 0)
  {
    uint64_t v16 = *(KB::Word **)a2;
    do
    {
      KB::Word::capitalized_string(v16, (uint64_t)v23);
      if (v23 == (unsigned char *)a5)
      {
        unint64_t v20 = *(void **)(a5 + 8);
        if (v20) {
          BOOL v21 = *(unsigned char *)(a5 + 6) == 1;
        }
        else {
          BOOL v21 = 0;
        }
        if (v21) {
          free(v20);
        }
        goto LABEL_26;
      }
      BOOL v17 = KB::String::equal((KB::String *)a5, (const KB::String *)v23, 1);
      if (v24) {
        BOOL v18 = v23[6] == 1;
      }
      else {
        BOOL v18 = 0;
      }
      if (v18) {
        free(v24);
      }
      if (v17)
      {
        uint64_t v9 = v16;
LABEL_26:
        unint64_t result = *((void *)v9 + 17);
        if (!HIDWORD(result)) {
          return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 320))(a1, a4, a3);
        }
        return result;
      }
      uint64_t v16 = (KB::Word *)((char *)v16 + 240);
    }
    while (v16 != *(KB::Word **)(a2 + 8));
    if ((a7 & 2) != 0) {
      return 0;
    }
  }
  return KB::LanguageModel::id_for_maximum_likelihood_word(a1, (KB::Word **)a2, a3, a6, a9);
}

unint64_t KB::LanguageModel::find_token_id_for_word(uint64_t a1, __CFString *a2, uint64_t *a3, uint64_t a4, unsigned int a5, uint64_t a6, KB::String *this, BOOL *a8)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  KB::String::clear(this);
  *a8 = 0;
  if (![(__CFString *)a2 length]) {
    return 0;
  }
  if (KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)a4)) {
    int v16 = 0;
  }
  else {
    int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 440))(a1, a4);
  }
  KB::utf8_string(a2, (uint64_t)v55);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, unsigned char *, uint64_t *, uint64_t, void, uint64_t))(*(void *)a1 + 312))(&v47, a1, v55, a3, a4, (a5 >> 5) & 1, 1);
  if (v47 != v48)
  {
    uint64_t v18 = v47;
    while ((*(unsigned char *)(v18 + 104) & 2) == 0)
    {
      v18 += 240;
      if (v18 == v48) {
        goto LABEL_12;
      }
    }
    a5 = a5 & 0xFFFFFFFC | 1;
  }
LABEL_12:
  *a8 = v48 != v47;
  long long v45 = 0uLL;
  uint64_t v46 = 0;
  if ((a5 & 8) == 0 || ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1) & 1) == 0)
  {
    int v38 = v16;
    KB::DictionaryContainer::lookup(*a3, v49);
    std::vector<KB::Word>::__vdeallocate((void **)&v45);
    long long v36 = *(_OWORD *)v49;
    long long v45 = *(_OWORD *)v49;
    uint64_t v46 = v50;
    v49[1] = 0;
    uint64_t v50 = 0;
    v49[0] = 0;
    unint64_t v42 = v49;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v42);
    unint64_t v19 = (KB::Word *)*((void *)&v36 + 1);
    uint64_t v20 = v36;
    v51[0] = MEMORY[0x1E4F143A8];
    v51[1] = 3321888768;
    unint64_t v52 = ___ZN2KB13LanguageModel22find_token_id_for_wordEPK10__CFStringRKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextEjPK10__CFLocaleRNS_6StringERb_block_invoke_2;
    long long v53 = &__block_descriptor_65_a8_32c16_ZTSN2KB6StringE_e10_B16__0r_v8l;
    KB::String::String((KB::String *)v54, (const KB::String *)v55);
    v54[32] = (a5 & 8) == 0;
    BOOL v21 = v51;
    if ((void)v36 != *((void *)&v36 + 1))
    {
      while ((((uint64_t (*)(void *, uint64_t))v52)(v21, v20) & 1) == 0)
      {
        v20 += 240;
        if (v20 == *((void *)&v36 + 1)) {
          goto LABEL_25;
        }
      }
    }
    if (v20 == *((void *)&v36 + 1))
    {
LABEL_25:
      uint64_t v20 = *((void *)&v36 + 1);
    }
    else if (v20 + 240 != *((void *)&v36 + 1))
    {
      uint64_t v37 = a3;
      uint64_t v22 = (uint64_t *)(v20 + 440);
      do
      {
        if ((((uint64_t (*)(void *, uint64_t *))v52)(v21, v22 - 25) & 1) == 0)
        {
          KB::String::operator=(v20, (KB::String *)(v22 - 25));
          KB::ByteString::operator=((unsigned __int16 *)(v20 + 32), (unsigned __int16 *)v22 - 84);
          uint64_t v23 = *(v22 - 19);
          *(_DWORD *)(v20 + 56) = *((_DWORD *)v22 - 36);
          *(void *)(v20 + 48) = v23;
          KB::String::operator=(v20 + 64, (KB::String *)(v22 - 17));
          long long v24 = *(_OWORD *)(v22 - 13);
          long long v25 = *(_OWORD *)(v22 - 11);
          long long v26 = *(_OWORD *)(v22 - 7);
          *(_OWORD *)(v20 + 128) = *(_OWORD *)(v22 - 9);
          *(_OWORD *)(v20 + 144) = v26;
          *(_OWORD *)(v20 + 96) = v24;
          *(_OWORD *)(v20 + 112) = v25;
          KB::String::operator=(v20 + 160, (KB::String *)(v22 - 5));
          *(unsigned char *)(v20 + 192) = *((unsigned char *)v22 - 8);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v20 + 200, v22);
          v20 += 240;
        }
        BOOL v27 = v22 + 5;
        v22 += 30;
      }
      while (v27 != *((uint64_t **)&v36 + 1));
      unint64_t v19 = (KB::Word *)*((void *)&v45 + 1);
      a3 = v37;
    }

    std::vector<KB::Word>::erase((uint64_t)&v45, v20, v19);
    uint64_t v28 = (void *)v21[5];
    int v16 = v38;
    if (v28 && *((unsigned char *)v21 + 38) == 1) {
      free(v28);
    }
  }
  unint64_t v42 = 0;
  unint64_t v43 = 0;
  uint64_t v44 = 0;
  KB::LanguageModel::merge_words(a1, &v47, (uint64_t *)&v45, v16 & ((int)(a5 << 29) >> 31), (uint64_t *)&v42);
  if (v43 == v42)
  {
    unint64_t v17 = 0;
  }
  else
  {
    if ((a5 & 8) == 0)
    {
      BOOL v39 = 0;
      unint64_t v40 = 0;
      uint64_t v41 = 0;
      KB::LanguageModel::find_vocabulary_words(a1, a2, (uint64_t)a3, v29, (KB::Word **)&v42, (uint64_t *)&v39);
      if (v40 != v39)
      {
        LODWORD(v49[0]) = 0x100000;
        WORD2(v49[0]) = 0;
        BYTE6(v49[0]) = 0;
        v49[1] = 0;
        LOBYTE(v50) = 0;
        unint64_t v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)&v39, (uint64_t)a3, (uint64_t)a2, (uint64_t)v55, a4, 1, 0, (uint64_t)v49);
        if (v49[1] && BYTE6(v49[0]) == 1) {
          free(v49[1]);
        }
        v49[0] = &v39;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v49);
        goto LABEL_47;
      }
      v49[0] = &v39;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v49);
    }
    uint64_t v30 = language_modeling::v1::LinguisticContext::tokenSpan((language_modeling::v1::LinguisticContext *)(a4 + 64));
    if (v31 && *(_DWORD *)(v30 + 32 * v31 - 8) == 1)
    {
      unint64_t v32 = [(__CFString *)a2 capitalizedStringWithLocale:a6];
      uint64_t v33 = [(__CFString *)a2 isEqualToString:v32];
      if (v33)
      {
        v49[0] = 0;
        v49[1] = 0;
        uint64_t v50 = 0;
        KB::LanguageModel::find_words_for_sentence_beginning(v33, a2, (uint64_t *)&v42, a6, a5, (uint64_t *)v49);
        if (v49[1] == v49[0]
          || (unint64_t v17 = KB::LanguageModel::id_for_maximum_likelihood_word(a1, (KB::Word **)v49, (uint64_t)a3, a4, (uint64_t)this), !HIDWORD(v17)))
        {
          unint64_t v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)v49, (uint64_t)a3, (uint64_t)a2, (uint64_t)v55, a4, 1, 0, (uint64_t)this);
        }
        BOOL v39 = v49;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v39);

        goto LABEL_47;
      }
    }
    unint64_t v34 = [(__CFString *)a2 uppercaseStringWithLocale:a6];
    unint64_t v17 = KB::LanguageModel::select_token_id_from_words(a1, (uint64_t)&v42, (uint64_t)a3, (uint64_t)a2, (uint64_t)v55, a4, a5, [(__CFString *)a2 isEqualToString:v34], (uint64_t)this);
  }
LABEL_47:
  v49[0] = &v42;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v49);
  v49[0] = &v45;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v49);
  v49[0] = &v47;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v49);
  if (v56 && v55[6] == 1) {
    free(v56);
  }
  return v17;
}

BOOL ___ZN2KB13LanguageModel22find_token_id_for_wordEPK10__CFStringRKN3WTF6RefPtrINS_19DictionaryContainerEEERKNS_20LanguageModelContextEjPK10__CFLocaleRNS_6StringERb_block_invoke_2(uint64_t a1, KB::String *a2)
{
  if (!KB::String::equal(a2, (const KB::String *)(a1 + 32), 0)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 64)) {
    return 0;
  }
  return (*((unsigned char *)a2 + 106) & 4) == 0;
}

void std::vector<KB::Word>::erase(uint64_t a1, uint64_t a2, KB::Word *a3)
{
  if ((KB::Word *)a2 != a3)
  {
    int v3 = a3;
    uint64_t v4 = a2;
    uint64_t v6 = *(KB::Word **)(a1 + 8);
    if (a3 != v6)
    {
      uint64_t v7 = 16 * (((uint64_t)a3 - a2) >> 4);
      do
      {
        KB::String::operator=(v4, (KB::String *)(v4 + v7));
        KB::ByteString::operator=((unsigned __int16 *)(v4 + 32), (unsigned __int16 *)(v4 + v7 + 32));
        uint64_t v8 = *(void *)(v4 + v7 + 48);
        *(_DWORD *)(v4 + 56) = *(_DWORD *)(v4 + v7 + 56);
        *(void *)(v4 + 48) = v8;
        KB::String::operator=(v4 + 64, (KB::String *)(v4 + v7 + 64));
        long long v9 = *(_OWORD *)(v4 + v7 + 96);
        long long v10 = *(_OWORD *)(v4 + v7 + 112);
        long long v11 = *(_OWORD *)(v4 + v7 + 144);
        *(_OWORD *)(v4 + 128) = *(_OWORD *)(v4 + v7 + 128);
        *(_OWORD *)(v4 + 144) = v11;
        *(_OWORD *)(v4 + 96) = v9;
        *(_OWORD *)(v4 + 112) = v10;
        KB::String::operator=(v4 + 160, (KB::String *)(v4 + v7 + 160));
        *(unsigned char *)(v4 + 192) = *(unsigned char *)(v4 + v7 + 192);
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v4 + 200, (uint64_t *)(v4 + v7 + 200));
        v4 += 240;
      }
      while ((KB::Word *)(v4 + v7) != v6);
      int v3 = *(KB::Word **)(a1 + 8);
    }
    while (v3 != (KB::Word *)v4)
    {
      int v3 = (KB::Word *)((char *)v3 - 240);
      KB::Word::~Word(v3);
    }
    *(void *)(a1 + 8) = v4;
  }
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 24))
  {
    uint64_t v4 = *(void **)(a1 + 16);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        operator delete(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    *(void *)(a1 + 16) = 0;
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v8 = *a2;
  *a2 = 0;
  long long v9 = *(void **)a1;
  *(void *)a1 = v8;
  if (v9) {
    operator delete(v9);
  }
  uint64_t v12 = a2[2];
  long long v11 = a2 + 2;
  uint64_t v10 = v12;
  uint64_t v13 = *(v11 - 1);
  *(void *)(a1 + 16) = v12;
  *(void *)(a1 + 8) = v13;
  *(v11 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  uint64_t v14 = v11[1];
  *(void *)(a1 + 24) = v14;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v11 + 4);
  if (v14)
  {
    unint64_t v15 = *(void *)(v10 + 8);
    unint64_t v16 = *(void *)(a1 + 8);
    if ((v16 & (v16 - 1)) != 0)
    {
      if (v15 >= v16) {
        v15 %= v16;
      }
    }
    else
    {
      v15 &= v16 - 1;
    }
    *(void *)(*(void *)a1 + 8 * v15) = a1 + 16;
    void *v11 = 0;
    v11[1] = 0;
  }
}

void __destroy_helper_block_a8_32c16_ZTSN2KB6StringE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    if (*(unsigned char *)(a1 + 38) == 1) {
      free(v2);
    }
  }
}

KB::String *__copy_helper_block_a8_32c16_ZTSN2KB6StringE(uint64_t a1, uint64_t a2)
{
  return KB::String::String((KB::String *)(a1 + 32), (const KB::String *)(a2 + 32));
}

void KB::LanguageModel::background_load(uint64_t a1, void *a2)
{
  int v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(std::__shared_weak_count **)(a1 + 8);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = KB::LanguageModel::background_loading_queue(v3);
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = v4;
  TIDispatchAsync();

  if (v5)
  {
    std::__shared_weak_count::__release_weak(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t ___ZN2KB13LanguageModel15background_loadENSt3__110shared_ptrIS0_EEU13block_pointerFvvE_block_invoke(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2)
  {
    int v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[5];
      if (v5 && ((*(uint64_t (**)(void))(*(void *)v5 + 16))(a1[5]) & 1) == 0) {
        (*(void (**)(uint64_t))(*(void *)v5 + 584))(v5);
      }
      std::__shared_weak_count::__release_shared[abi:nn180100](v4);
    }
  }
  uint64_t result = a1[4];
  if (result)
  {
    uint64_t v7 = *(uint64_t (**)(void))(result + 16);
    return v7();
  }
  return result;
}

void __destroy_helper_block_a8_40c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_a8_40c43_ZTSNSt3__18weak_ptrIN2KB13LanguageModelEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void KB::LanguageModel::clear_dynamic_learning_bundles(const void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = (KB::LanguageModel *)CFRetain(a1);
    uint64_t v5 = KB::LanguageModel::background_loading_queue(v4);
    id v6 = v3;
    TIDispatchAsync();
  }
}

void ___ZN2KB13LanguageModel30clear_dynamic_learning_bundlesEPK7__CFURLU13block_pointerFvbE_block_invoke(uint64_t a1)
{
  long long v3 = *(_OWORD *)(a1 + 32);
  id v2 = (id)v3;
  TIDispatchSync();
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t ___ZN2KB13LanguageModel30clear_dynamic_learning_bundlesEPK7__CFURLU13block_pointerFvbE_block_invoke_2(uint64_t a1)
{
  return MEMORY[0x1F412A1E8](*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void KB::LanguageModel::perform_maintenance(void *a1)
{
  uint64_t v1 = a1;
  id v2 = KB::LanguageModel::background_loading_queue(v1);
  uint64_t v4 = v1;
  long long v3 = v1;
  TIDispatchAsync();
}

void ___ZN2KB13LanguageModel19perform_maintenanceEU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  LMLanguageModelPerformMaintenance();
  KB::LanguageModelImplStub::enumerate_cached_wrappers(&__block_literal_global_15373);
  id v2 = *(id *)(a1 + 32);
  TIDispatchSync();
}

uint64_t ___ZN2KB13LanguageModel19perform_maintenanceEU13block_pointerFvvE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t KB::LanguageModel::get_word_lexicon(KB::LanguageModel *this)
{
  id v2 = +[TITransientLexiconManager sharedInstance];
  int v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(void *)this + 40))(this);
  uint64_t v4 = [v2 namedEntityLexiconForLocale:TILocaleIdentifierForLexiconID(v3)];

  return v4;
}

uint64_t KB::LanguageModel::get_phrase_lexicon(KB::LanguageModel *this)
{
  id v2 = +[TITransientLexiconManager sharedInstance];
  int v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(void *)this + 40))(this);
  uint64_t v4 = [v2 namedEntityPhraseLexiconForLocale:TILocaleIdentifierForLexiconID(v3)];

  return v4;
}

uint64_t KB::LanguageModel::get_contacts_lexicon(KB::LanguageModel *this)
{
  id v2 = +[TITransientLexiconManager sharedInstance];
  int v3 = (*(uint64_t (**)(KB::LanguageModel *))(*(void *)this + 40))(this);
  uint64_t v4 = [v2 addressBookLexiconForLocale:TILocaleIdentifierForLexiconID(v3)];

  return v4;
}

void KB::LanguageModel::get_static_unigrams_filepath(KB *a1@<X1>, uint64_t a2@<X8>)
{
  KB::ns_string(a1, a1);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  UIKeyboardStaticUnigramsFile(v4);
  int v3 = (KB *)objc_claimAutoreleasedReturnValue();
  KB::utf8_string(v3, a2);
}

float *KB::LanguageModel::PredictionInfo::PredictionInfo(void *a1, uint64_t a2, uint64_t a3, int a4, float a5)
{
  uint64_t result = (float *)std::vector<TITokenID>::vector(a1, a2);
  result[6] = a5;
  *((void *)result + 4) = a3;
  *((_DWORD *)result + 10) = a4;
  *((void *)result + 19) = 0;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  if (*((void *)result + 1) != *(void *)result) {
    result[36] = **(float **)result;
  }
  return result;
}

{
  float *result;

  uint64_t result = (float *)std::vector<TITokenID>::vector(a1, a2);
  result[6] = a5;
  *((void *)result + 4) = a3;
  *((_DWORD *)result + 10) = a4;
  *((void *)result + 19) = 0;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  if (*((void *)result + 1) != *(void *)result) {
    result[36] = **(float **)result;
  }
  return result;
}

KB::LanguageModel::PredictionInfo *KB::LanguageModel::PredictionInfo::PredictionInfo(KB::LanguageModel::PredictionInfo *this, const TIInlineCompletion *a2, int a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((void *)this + 2) = 0;
  if (*((unsigned char *)a2 + 72)) {
    double v6 = COERCE_DOUBLE(language_modeling::v1::InlineCompletion::probability((const TIInlineCompletion *)((char *)a2 + 64)));
  }
  else {
    double v6 = *((double *)a2 + 6);
  }
  float v7 = v6;
  *((float *)this + 6) = __exp10f(v7);
  *((void *)this + 4) = 0;
  int v8 = *((unsigned __int8 *)a2 + 72);
  if (*((unsigned char *)a2 + 72))
  {
    language_modeling::v1::InlineCompletion::probability((const TIInlineCompletion *)((char *)a2 + 64));
    int v8 = v9 & 3;
  }
  *((_DWORD *)this + 10) = v8;
  uint64_t v10 = (std::string *)((char *)this + 48);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v11 = *(_OWORD *)a2;
    *((void *)this + 8) = *((void *)a2 + 2);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v11;
  }
  uint64_t v12 = (std::string *)((char *)this + 72);
  if (*((char *)a2 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v12, *((const std::string::value_type **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v13 = *(_OWORD *)((char *)a2 + 24);
    *((void *)this + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = *((void *)a2 + 5);
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = v13;
  }
  *((_OWORD *)this + 6) = 0u;
  uint64_t v14 = (int64x2_t *)((char *)this + 96);
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = a3;
  *((unsigned char *)this + 149) = 0;
  *((unsigned char *)this + 150) = *((_DWORD *)a2 + 14) == 3;
  *((void *)this + 19) = 0;
  if (*((char *)a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::__split_buffer<std::string>::pointer p_p = &__p;
  }
  else {
    std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  KB::String::String((KB::String *)&v63, (const char *)p_p);
  WORD2(v61[0]) = 0;
  BYTE6(v61[0]) = 0;
  v61[1] = " \t\n";
  LODWORD(v61[0]) = 1048579;
  BYTE1(v62) = 0;
  KB::sbs_string_tokenize((unsigned __int16 *)&v63, (const KB::String *)v61, &v59);
  if (v61[1] && BYTE6(v61[0]) == 1) {
    free(v61[1]);
  }
  if (v63.__begin_ && BYTE6(v63.__first_) == 1) {
    free(v63.__begin_);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v16 = v59;
  for (uint64_t i = v60; v16 != i; v16 += 32)
  {
    if (*(_WORD *)v16)
    {
      if (*(void *)(v16 + 8)) {
        uint64_t v18 = *(char **)(v16 + 8);
      }
      else {
        uint64_t v18 = (char *)(v16 + 16);
      }
    }
    else
    {
      uint64_t v18 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(v61, v18);
    unint64_t v20 = *((void *)this + 13);
    unint64_t v19 = *((void *)this + 14);
    if (v20 >= v19)
    {
      unint64_t v22 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v20 - v14->i64[0]) >> 3);
      unint64_t v23 = v22 + 1;
      if (v22 + 1 > 0xAAAAAAAAAAAAAAALL) {
        goto LABEL_75;
      }
      unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - v14->i64[0]) >> 3);
      if (2 * v24 > v23) {
        unint64_t v23 = 2 * v24;
      }
      if (v24 >= 0x555555555555555) {
        unint64_t v25 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v25 = v23;
      }
      v63.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 112);
      if (v25) {
        unint64_t v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v25);
      }
      else {
        uint64_t v26 = 0;
      }
      unint64_t v27 = v25 + 24 * v22;
      long long v28 = *(_OWORD *)v61;
      *(void *)(v27 + 16) = v62;
      *(_OWORD *)unint64_t v27 = v28;
      v61[1] = 0;
      uint64_t v62 = 0;
      v61[0] = 0;
      uint64_t v30 = *((void *)this + 12);
      unint64_t v29 = *((void *)this + 13);
      if (v29 == v30)
      {
        int64x2_t v33 = vdupq_n_s64(v29);
        unint64_t v31 = v25 + 24 * v22;
      }
      else
      {
        unint64_t v31 = v25 + 24 * v22;
        do
        {
          long long v32 = *(_OWORD *)(v29 - 24);
          *(void *)(v31 - 8) = *(void *)(v29 - 8);
          *(_OWORD *)(v31 - 24) = v32;
          v31 -= 24;
          *(void *)(v29 - 16) = 0;
          *(void *)(v29 - 8) = 0;
          *(void *)(v29 - 24) = 0;
          v29 -= 24;
        }
        while (v29 != v30);
        int64x2_t v33 = *v14;
      }
      unint64_t v34 = v27 + 24;
      *((void *)this + 12) = v31;
      *((void *)this + 13) = v27 + 24;
      *(int64x2_t *)&v63.__begin_ = v33;
      uint64_t v35 = (std::string *)*((void *)this + 14);
      *((void *)this + 14) = v25 + 24 * v26;
      v63.__end_cap_.__value_ = v35;
      v63.__first_ = (std::__split_buffer<std::string>::pointer)v33.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v63);
      int v36 = SHIBYTE(v62);
      *((void *)this + 13) = v34;
      if (v36 < 0) {
        operator delete(v61[0]);
      }
    }
    else
    {
      long long v21 = *(_OWORD *)v61;
      *(void *)(v20 + 16) = v62;
      *(_OWORD *)unint64_t v20 = v21;
      *((void *)this + 13) = v20 + 24;
    }
    if (*(_WORD *)v16)
    {
      if (*(void *)(v16 + 8)) {
        uint64_t v37 = *(char **)(v16 + 8);
      }
      else {
        uint64_t v37 = (char *)(v16 + 16);
      }
    }
    else
    {
      uint64_t v37 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(v61, v37);
    unint64_t v39 = *((void *)this + 16);
    unint64_t v38 = *((void *)this + 17);
    if (v39 >= v38)
    {
      uint64_t v41 = *((void *)this + 15);
      unint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v39 - v41) >> 3);
      unint64_t v43 = v42 + 1;
      if (v42 + 1 > 0xAAAAAAAAAAAAAAALL) {
LABEL_75:
      }
        abort();
      unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - v41) >> 3);
      if (2 * v44 > v43) {
        unint64_t v43 = 2 * v44;
      }
      if (v44 >= 0x555555555555555) {
        unint64_t v45 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v45 = v43;
      }
      v63.__end_cap_.__value_ = (std::allocator<std::string> *)((char *)this + 136);
      if (v45) {
        unint64_t v45 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v45);
      }
      else {
        uint64_t v46 = 0;
      }
      unint64_t v47 = v45 + 24 * v42;
      long long v48 = *(_OWORD *)v61;
      *(void *)(v47 + 16) = v62;
      *(_OWORD *)unint64_t v47 = v48;
      v61[1] = 0;
      uint64_t v62 = 0;
      v61[0] = 0;
      uint64_t v50 = *((void *)this + 15);
      unint64_t v49 = *((void *)this + 16);
      if (v49 == v50)
      {
        int64x2_t v53 = vdupq_n_s64(v49);
        unint64_t v51 = v45 + 24 * v42;
      }
      else
      {
        unint64_t v51 = v45 + 24 * v42;
        do
        {
          long long v52 = *(_OWORD *)(v49 - 24);
          *(void *)(v51 - 8) = *(void *)(v49 - 8);
          *(_OWORD *)(v51 - 24) = v52;
          v51 -= 24;
          *(void *)(v49 - 16) = 0;
          *(void *)(v49 - 8) = 0;
          *(void *)(v49 - 24) = 0;
          v49 -= 24;
        }
        while (v49 != v50);
        int64x2_t v53 = *(int64x2_t *)((char *)this + 120);
      }
      unint64_t v54 = v47 + 24;
      *((void *)this + 15) = v51;
      *((void *)this + 16) = v47 + 24;
      *(int64x2_t *)&v63.__begin_ = v53;
      long long v55 = (std::string *)*((void *)this + 17);
      *((void *)this + 17) = v45 + 24 * v46;
      v63.__end_cap_.__value_ = v55;
      v63.__first_ = (std::__split_buffer<std::string>::pointer)v53.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v63);
      int v56 = SHIBYTE(v62);
      *((void *)this + 16) = v54;
      if (v56 < 0) {
        operator delete(v61[0]);
      }
    }
    else
    {
      long long v40 = *(_OWORD *)v61;
      *(void *)(v39 + 16) = v62;
      *(_OWORD *)unint64_t v39 = v40;
      *((void *)this + 16) = v39 + 24;
    }
  }
  v63.__first_ = (std::__split_buffer<std::string>::pointer)&v59;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v63);
  return this;
}

KB::LanguageModel::PredictionInfo *KB::LanguageModel::PredictionInfo::PredictionInfo(KB::LanguageModel::PredictionInfo *this, const language_modeling::v1::Prediction *a2, int a3)
{
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((void *)this + 2) = 0;
  float v6 = COERCE_DOUBLE(language_modeling::v1::Prediction::probability(a2));
  *((float *)this + 6) = __exp10f(v6);
  *((void *)this + 4) = language_modeling::v1::Prediction::contextSize(a2);
  language_modeling::v1::Prediction::probability(a2);
  *((_DWORD *)this + 10) = v7 & 3;
  language_modeling::v1::Prediction::string(a2);
  language_modeling::v1::Prediction::log(a2);
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = a3;
  *((unsigned char *)this + 148) = language_modeling::v1::Prediction::source(a2) == 8;
  *(_WORD *)((char *)this + 149) = language_modeling::v1::Prediction::source(a2) == 2;
  *((void *)this + 19) = language_modeling::v1::Prediction::unique_id(a2);
  uint64_t v8 = language_modeling::v1::Prediction::tokenSpan(a2);
  uint64_t v18 = (std::string **)((char *)this + 96);
  if (v9)
  {
    uint64_t v10 = v8;
    uint64_t v11 = 32 * v9;
    do
    {
      if (*(char *)(v10 + 23) < 0) {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v10, *(void *)(v10 + 8));
      }
      else {
        std::string __p = *(std::string *)v10;
      }
      std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](&v18, (long long *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      v10 += 32;
      v11 -= 32;
    }
    while (v11);
  }
  uint64_t v12 = language_modeling::v1::Prediction::exactTokenSpan(a2);
  uint64_t v18 = (std::string **)((char *)this + 120);
  if (v13)
  {
    uint64_t v14 = v12;
    uint64_t v15 = 32 * v13;
    do
    {
      if (*(char *)(v14 + 23) < 0) {
        std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)v14, *(void *)(v14 + 8));
      }
      else {
        std::string __p = *(std::string *)v14;
      }
      std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](&v18, (long long *)&__p);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      v14 += 32;
      v15 -= 32;
    }
    while (v15);
  }
  return this;
}

std::string ***std::back_insert_iterator<std::vector<std::string>>::operator=[abi:nn180100](std::string ***a1, long long *a2)
{
  id v4 = *a1;
  uint64_t v5 = (*a1)[1];
  float v6 = (std::allocator<std::string> *)(*a1 + 2);
  if ((unint64_t)v5 >= *(void *)v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)*v4) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    if (0x5555555555555556 * ((uint64_t)(*(void *)v6 - (void)*v4) >> 3) > v10) {
      unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)v6 - (void)*v4) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)v6 - (void)*v4) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    v22.__end_cap_.__value_ = v6;
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = v11 + 24 * v9;
    long long v14 = *a2;
    *(void *)(v13 + 16) = *((void *)a2 + 2);
    *(_OWORD *)unint64_t v13 = v14;
    *((void *)a2 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    uint64_t v16 = *v4;
    uint64_t v15 = v4[1];
    if (v15 == *v4)
    {
      unint64_t v19 = v4[1];
      unint64_t v17 = v11 + 24 * v9;
    }
    else
    {
      unint64_t v17 = v11 + 24 * v9;
      do
      {
        long long v18 = *(_OWORD *)&v15[-1].__r_.__value_.__l.__data_;
        *(void *)(v17 - 8) = *((void *)&v15[-1].__r_.__value_.__l + 2);
        *(_OWORD *)(v17 - 24) = v18;
        v17 -= 24;
        v15[-1].__r_.__value_.__l.__size_ = 0;
        v15[-1].__r_.__value_.__r.__words[2] = 0;
        v15[-1].__r_.__value_.__r.__words[0] = 0;
        --v15;
      }
      while (v15 != v16);
      unint64_t v19 = *v4;
      uint64_t v15 = v4[1];
    }
    uint64_t v8 = (std::string *)(v13 + 24);
    *id v4 = (std::string *)v17;
    v22.__first_ = v19;
    v22.__begin_ = v19;
    v4[1] = (std::string *)(v13 + 24);
    v22.__end_ = v15;
    unint64_t v20 = v4[2];
    v4[2] = (std::string *)(v11 + 24 * v12);
    v22.__end_cap_.__value_ = v20;
    std::__split_buffer<std::string>::~__split_buffer(&v22);
  }
  else
  {
    long long v7 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v7;
    *((void *)a2 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
    *((void *)a2 + 2) = 0;
    *(void *)a2 = 0;
    uint64_t v8 = v5 + 1;
  }
  v4[1] = v8;
  return a1;
}

uint64_t KB::LanguageModel::PredictionInfo::has_dynamic_contribution(KB::LanguageModel::PredictionInfo *this)
{
  return *((_DWORD *)this + 10) & 1;
}

uint64_t KB::LanguageModel::PredictionInfo::has_recency_contribution(KB::LanguageModel::PredictionInfo *this)
{
  return (*((unsigned __int8 *)this + 40) >> 1) & 1;
}

KB::String *KB::kb_user_directory@<X0>(KB::String *a1@<X8>)
{
  int v3 = (const char *)[ (id) TI_KB_USER_DIRECTORY() fileSystemRepresentation];

  return KB::String::String(a1, v3);
}

uint64_t TI_KB_USER_DIRECTORY()
{
  uint64_t result = s_kb_user_directory;
  if (!s_kb_user_directory)
  {
    uint64_t v1 = &knownAssetRegionAttributes_assetRegionAttributes;
    {
      uint64_t v1 = &knownAssetRegionAttributes_assetRegionAttributes;
      if (v2)
      {
        TI_KB_USER_DIRECTORY::default_kb_user_directorCGFloat y = CreateDefaultKeyboardUserDirectory();
        uint64_t v1 = &knownAssetRegionAttributes_assetRegionAttributes;
      }
    }
    return v1[45];
  }
  return result;
}

uint64_t CreateDefaultKeyboardUserDirectory(void)
{
  dispatch_queue_t v0 = CPSharedResourcesDirectory();
  uint64_t v1 = [v0 stringByAppendingPathComponent:@"/Library/Keyboard"];

  return v1;
}

unsigned __int16 *KB::kb_user_directory_file@<X0>(KB *this@<X0>, KB::String *a2@<X8>)
{
  KB::kb_user_directory(a2);
  KB::String::append((unsigned __int16 *)a2, "/", 0xFFFFuLL);

  return KB::String::append((unsigned __int16 *)a2, this);
}

double KB::system_uptime(KB *this)
{
  uint64_t v1 = [MEMORY[0x1E4F28F80] processInfo];
  [v1 systemUptime];
  double v3 = v2;

  return v3;
}

uint64_t TI_IS_WILDCAT()
{
  return s_interface_idiom_is_pad;
}

uint64_t TI_SET_IS_WILDCAT(uint64_t result)
{
  s_interface_idiom_is_pad = result;
  return result;
}

uint64_t TI_IS_TRACE_LOGGING_ENABLED()
{
  return s_trace_logging_enabled;
}

uint64_t TI_SET_IS_TRACE_LOGGING_ENABLED(uint64_t result)
{
  s_trace_logging_enabled = result;
  return result;
}

uint64_t TI_IS_INTERNAL_INSTALL()
{
  if (TI_IS_INTERNAL_INSTALL::once_token != -1) {
    dispatch_once(&TI_IS_INTERNAL_INSTALL::once_token, &__block_literal_global_3708);
  }
  return TI_IS_INTERNAL_INSTALL::is_internal_install;
}

void *TI_DEVICE_UNLOCKED()
{
  uint64_t v6 = 0;
  long long v7 = &v6;
  uint64_t v8 = 0x2020000000;
  dispatch_queue_t v0 = (uint64_t (*)(void))getMKBGetDeviceLockStateSymbolLoc(void)::ptr;
  unint64_t v9 = getMKBGetDeviceLockStateSymbolLoc(void)::ptr;
  if (!getMKBGetDeviceLockStateSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)MobileKeyBagLibrary();
    _WORD v7[3] = (uint64_t)dlsym(v1, "MKBGetDeviceLockState");
    getMKBGetDeviceLockStateSymbolLoc(void)::ptr = (_UNKNOWN *)v7[3];
    dispatch_queue_t v0 = (uint64_t (*)(void))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    int v2 = v0(0);
    return (void *)(!v2 || v2 == 3);
  }
  else
  {
    dlerror();
    uint64_t v5 = abort_report_np();
    return ___ZL33getMKBGetDeviceLockStateSymbolLocv_block_invoke(v5);
  }
}

void *___ZL33getMKBGetDeviceLockStateSymbolLocv_block_invoke(uint64_t a1)
{
  int v2 = (void *)MobileKeyBagLibrary();
  uint64_t result = dlsym(v2, "MKBGetDeviceLockState");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getMKBGetDeviceLockStateSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t MobileKeyBagLibrary(void)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v3[0] = 0;
  if (!MobileKeyBagLibraryCore(char **)::frameworkLibrary)
  {
    v3[1] = MEMORY[0x1E4F143A8];
    v3[2] = 3221225472;
    void v3[3] = ___ZL23MobileKeyBagLibraryCorePPc_block_invoke;
    v3[4] = &__block_descriptor_40_e5_v8__0l;
    void v3[5] = v3;
    long long v4 = xmmword_1E6E2A678;
    uint64_t v5 = 0;
    MobileKeyBagLibraryCore(char **)::frameworkLibrarCGFloat y = _sl_dlopen();
    uint64_t v1 = (void *)v3[0];
    uint64_t v0 = MobileKeyBagLibraryCore(char **)::frameworkLibrary;
    if (MobileKeyBagLibraryCore(char **)::frameworkLibrary)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      uint64_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return MobileKeyBagLibraryCore(char **)::frameworkLibrary;
}

uint64_t ___ZL23MobileKeyBagLibraryCorePPc_block_invoke()
{
  uint64_t result = _sl_dlopen();
  MobileKeyBagLibraryCore(char **)::frameworkLibrarCGFloat y = result;
  return result;
}

void *TI_DEVICE_UNLOCKED_SINCE_BOOT()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v0 = (unsigned int (*)(void))getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr;
  long long v7 = getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr;
  if (!getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr)
  {
    uint64_t v1 = (void *)MobileKeyBagLibrary();
    v5[3] = (uint64_t)dlsym(v1, "MKBDeviceUnlockedSinceBoot");
    getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr = (_UNKNOWN *)v5[3];
    uint64_t v0 = (unsigned int (*)(void))v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0) {
    return (void *)(v0() == 1);
  }
  dlerror();
  uint64_t v3 = abort_report_np();
  return ___ZL38getMKBDeviceUnlockedSinceBootSymbolLocv_block_invoke(v3);
}

void *___ZL38getMKBDeviceUnlockedSinceBootSymbolLocv_block_invoke(uint64_t a1)
{
  int v2 = (void *)MobileKeyBagLibrary();
  uint64_t result = dlsym(v2, "MKBDeviceUnlockedSinceBoot");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getMKBDeviceUnlockedSinceBootSymbolLoc(void)::ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void TI_SET_KB_USER_DIRECTORY(CFTypeRef cf)
{
  if ((CFTypeRef)s_kb_user_directory != cf)
  {
    if (s_kb_user_directory)
    {
      CFRelease((CFTypeRef)s_kb_user_directory);
      s_kb_user_directorCGFloat y = 0;
    }
    if (cf) {
      s_kb_user_directorCGFloat y = (uint64_t)CFRetain(cf);
    }
  }
}

double TIGetCurrentTime()
{
  if (TIGetCurrentTime::onceToken != -1) {
    dispatch_once(&TIGetCurrentTime::onceToken, &__block_literal_global_4);
  }
  return *(double *)&TIGetCurrentTime::time_scale * (double)mach_absolute_time();
}

double __TIGetCurrentTime_block_invoke()
{
  if (!mach_timebase_info(&info))
  {
    LODWORD(result) = info.numer;
    LODWORD(vTI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = info.denom;
    double result = (double)*(unint64_t *)&result / (double)v1 * 0.000000001;
    TIGetCurrentTime::time_scale = *(void *)&result;
  }
  return result;
}

BOOL TI_SET_PROTECTION_CLASS_C(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = [MEMORY[0x1E4F1CB10] fileURLWithFileSystemRepresentation:a1 isDirectory:0 relativeToURL:0];
  uint64_t v2 = *MEMORY[0x1E4F1C580];
  uint64_t v3 = *MEMORY[0x1E4F1C590];
  id v7 = 0;
  [v1 setResourceValue:v2 forKey:v3 error:&v7];
  id v4 = v7;
  if (v4 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
  {
    uint64_t v6 = [v4 description];
    *(_DWORD *)buf = 136315394;
    unint64_t v9 = "TI_SET_PROTECTION_CLASS_C";
    __int16 v10 = 2112;
    unint64_t v11 = v6;
    _os_log_error_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "%s  couldn't set protection class, error: %@", buf, 0x16u);
  }
  return v4 == 0;
}

uint64_t TI_IS_FILE_CLASS_C(uint64_t a1)
{
  unint64_t v1 = [NSString stringWithUTF8String:a1];
  uint64_t v2 = [MEMORY[0x1E4F28CB8] defaultManager];
  uint64_t v7 = 0;
  uint64_t v3 = [v2 attributesOfItemAtPath:v1 error:&v7];

  id v4 = [v3 objectForKey:*MEMORY[0x1E4F28370]];
  uint64_t v5 = [v4 isEqualToString:*MEMORY[0x1E4F28358]];

  return v5;
}

uint64_t TI_SET_USING_ML_BASED_TAP_TYPING(uint64_t result)
{
  s_ml_based_tap_typing = result;
  return result;
}

uint64_t TI_IS_USING_ML_BASED_TAP_TYPING()
{
  return s_ml_based_tap_typing;
}

uint64_t TI_SET_USING_TOUCAN_LM(uint64_t result)
{
  s_use_lm_transformer = result;
  return result;
}

BOOL TI_IS_USING_TOUCAN_LM_BASED_COMPLETIONS()
{
  return s_use_lm_transformer != 0;
}

BOOL TI_IS_USING_TOUCAN_LM_BASED_AUTOCORRECTION()
{
  return s_use_lm_transformer == -1 || s_use_lm_transformer == 2;
}

uint64_t TI_SET_IS_USING_CUSTOM_DIALECT_LM(uint64_t result)
{
  s_using_custom_dialect_lm = result;
  return result;
}

uint64_t TI_IS_USING_CUSTOM_DIALECT_LM()
{
  return s_using_custom_dialect_lm;
}

void TI_SET_DIALECT_LM_PATH(CFTypeRef cf)
{
  if ((CFTypeRef)s_dialect_lm_path != cf)
  {
    if (s_dialect_lm_path)
    {
      CFRelease((CFTypeRef)s_dialect_lm_path);
      s_dialect_lm_path = 0;
    }
    if (cf) {
      s_dialect_lm_path = (uint64_t)CFRetain(cf);
    }
  }
}

void *TI_DIALECT_LM_PATH()
{
  uint64_t v0 = (void *)s_dialect_lm_path;
  if (!s_dialect_lm_path)
  {
    uint64_t v0 = CPSharedResourcesDirectory();
  }
  return v0;
}

uint64_t TIIsRevision_Enabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TILogProblemSentencesToStdout()
{
  return _os_feature_enabled_impl();
}

uint64_t TIPrintTypingTranscriptToStdout()
{
  return _os_feature_enabled_impl();
}

uint64_t TIIsNumberToLetterCorrectionEnabled()
{
  LODWORD(result) = _os_feature_enabled_impl();
  if (HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled)) {
    return (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  }
  else {
    return result;
  }
}

uint64_t TISetNumberToLetterCorrectionEnabled(uint64_t result)
{
  number_to_letter_correction_locally_enabled(void)::locally_enabled = result | 0x100;
  return result;
}

uint64_t TIAreModernCandidateFiltersEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIMultilingualKeyboardEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIMultilingualDynamicModelEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIUseTransliterationWithContext()
{
  return 0;
}

uint64_t TIMultilingualKeyboardSupportedLanguagesCount()
{
  if (_os_feature_enabled_impl()) {
    return 3;
  }
  else {
    return 2;
  }
}

uint64_t TINonHindiIndiaEmojisEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIPredominantLanguageEmojisEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAreInlineCompletionsEnabled()
{
  if (HIBYTE(inline_completions_override)) {
    return inline_completions_override;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverrideInlineCompletionsFlag(uint64_t result)
{
  inline_completions_override = result | 0x100;
  return result;
}

void TIRestoreInlineCompletionsFlag()
{
  if (HIBYTE(inline_completions_override)) {
    HIBYTE(inline_completions_override) = 0;
  }
}

uint64_t TIInlineCompletionsFullAcceptanceBySpaceEnabled()
{
  if (HIBYTE(inline_completions_full_acceptance_by_space)) {
    return inline_completions_full_acceptance_by_space;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverrideInlineCompletionsFullAcceptanceBySpace(uint64_t result)
{
  inline_completions_full_acceptance_by_space = result | 0x100;
  return result;
}

void TIRestoreInlineCompletionsFullAcceptanceBySpace()
{
  if (HIBYTE(inline_completions_full_acceptance_by_space)) {
    HIBYTE(inline_completions_full_acceptance_by_space) = 0;
  }
}

uint64_t TIPromoteInlineToAutocorrectEnabled()
{
  if (HIBYTE(promote_inline_to_autocorrect)) {
    return promote_inline_to_autocorrect;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverridePromoteInlineToAutocorrect(uint64_t result)
{
  promote_inline_to_autocorrect = result | 0x100;
  return result;
}

void TIRestorePromoteInlineToAutocorrect()
{
  if (HIBYTE(promote_inline_to_autocorrect)) {
    HIBYTE(promote_inline_to_autocorrect) = 0;
  }
}

uint64_t TIPromoteAutocorrectToInlineEnabled()
{
  if (HIBYTE(promote_autocorrect_to_inline)) {
    return promote_autocorrect_to_inline;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverridePromoteAutocorrectToInline(uint64_t result)
{
  promote_autocorrect_to_inline = result | 0x100;
  return result;
}

void TIRestorePromoteAutocorrectToInline()
{
  if (HIBYTE(promote_autocorrect_to_inline)) {
    HIBYTE(promote_autocorrect_to_inline) = 0;
  }
}

uint64_t getInlineCompletionPrecision()
{
  if (byte_1EAE411A0) {
    return inline_completion_precision_point_override;
  }
  if (_os_feature_enabled_impl()) {
    return 80;
  }
  if (_os_feature_enabled_impl()) {
    return 70;
  }
  return 90;
}

void TIRestoreOverrideInlineCompletionPrecision()
{
  if (byte_1EAE411A0) {
    byte_1EAE411A0 = 0;
  }
}

uint64_t TIOverrideInlineCompletionPrecision(uint64_t result)
{
  inline_completion_precision_point_override = result;
  byte_1EAE411A0 = 1;
  return result;
}

uint64_t TIEnableInlineCompletionsForTestingEnabled()
{
  if (HIBYTE(enable_inline_for_testing)) {
    return enable_inline_for_testing;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverrideEnableInlineCompletionForTesting(uint64_t result)
{
  enable_inline_for_testing = result | 0x100;
  return result;
}

void TIRestoreEnableInlineCompletionForTesting()
{
  if (HIBYTE(enable_inline_for_testing)) {
    HIBYTE(enable_inline_for_testing) = 0;
  }
}

uint64_t TIAreInlineCompletionsEnabledEverywhere()
{
  if (HIBYTE(inline_completions_override)) {
    return inline_completions_override;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIIsTransformerLMEnglishMultilingualEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TISwearWordPolicyV1Enabled()
{
  if (simular_swear_word_policy_v1_setting) {
    return [(id)simular_swear_word_policy_v1_setting BOOLValue];
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t setSimularSwearWordPolicyV1Setting(uint64_t a1)
{
  simular_swear_word_policy_v1_setting = [NSNumber numberWithBool:a1];

  return MEMORY[0x1F41817F8]();
}

void restoreSimularSwearWordPolicyV1Setting()
{
  uint64_t v0 = (void *)simular_swear_word_policy_v1_setting;
  simular_swear_word_policy_v1_setting = 0;
}

uint64_t TISwearWordPolicyV2Enabled()
{
  if (simular_swear_word_policy_v2_setting) {
    return [(id)simular_swear_word_policy_v2_setting BOOLValue];
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t setSimularSwearWordPolicyV2Setting(uint64_t a1)
{
  simular_swear_word_policy_v2_setting = [NSNumber numberWithBool:a1];

  return MEMORY[0x1F41817F8]();
}

void restoreSimularSwearWordPolicyV2Setting()
{
  uint64_t v0 = (void *)simular_swear_word_policy_v2_setting;
  simular_swear_word_policy_v2_setting = 0;
}

uint64_t TIAdaptationAutocorrectionRejectionV2Enabled()
{
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override))
  {
    int v0 = adaptation_autocorrection_rejection_v2_override;
    return v0 != 0;
  }
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial))
  {
    int v0 = adaptation_autocorrection_rejection_v2_override_for_trial;
    return v0 != 0;
  }
  return _os_feature_enabled_impl();
}

void TIOverrideAdaptationAutocorrectionRejectionV2Trial(int a1)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    uint64_t v2 = "disabled";
    if (a1) {
      uint64_t v2 = "enabled";
    }
    int v3 = 136315394;
    id v4 = "TIOverrideAdaptationAutocorrectionRejectionV2Trial";
    __int16 v5 = 2080;
    uint64_t v6 = v2;
    _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Trial: overriding adaptation_autocorrection_rejection_v2 to %s", (uint8_t *)&v3, 0x16u);
  }
  adaptation_autocorrection_rejection_v2_override_for_trial = a1 | 0x100;
}

void TIRestoreAdaptationAutocorrectionRejectionV2Trial()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    int v0 = 136315138;
    unint64_t v1 = "TIRestoreAdaptationAutocorrectionRejectionV2Trial";
    _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Trial: removing override of adaptation_autocorrection_rejection_v2", (uint8_t *)&v0, 0xCu);
  }
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial)) {
    HIBYTE(adaptation_autocorrection_rejection_v2_override_for_trial) = 0;
  }
}

uint64_t TIOverrideAdaptationAutocorrectionRejectionV2(uint64_t result)
{
  adaptation_autocorrection_rejection_v2_override = result | 0x100;
  return result;
}

void TIRestoreAdaptationAutocorrectionRejectionV2()
{
  if (HIBYTE(adaptation_autocorrection_rejection_v2_override)) {
    HIBYTE(adaptation_autocorrection_rejection_v2_override) = 0;
  }
}

double TI_GET_SCALED_POINT(double a1, double a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6, double a7, double a8, double a9, CGFloat a10, double a11, CGFloat a12)
{
  v22.origin.CGFloat x = a3;
  v22.origin.CGFloat y = a4;
  v22.size.width = a5;
  v22.size.height = a6;
  v23.origin.CGFloat x = a9;
  v23.origin.CGFloat y = a10;
  v23.size.width = a11;
  v23.size.height = a12;
  if (!CGRectEqualToRect(v22, v23)) {
    return a9 + (a1 - a3) / a5 * a11;
  }
  return a1;
}

uint64_t TIIsTransientLexiconIngestionV2Enabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAddAlternativesForRetrocorrectionEnabled()
{
  if (HIBYTE(add_alternatives_for_retrocorrection_override)) {
    return add_alternatives_for_retrocorrection_override;
  }
  else {
    return _os_feature_enabled_impl();
  }
}

uint64_t TIOverrideAddAlternativesForRetrocorrection(uint64_t result)
{
  add_alternatives_for_retrocorrection_override = result | 0x100;
  return result;
}

void TIRestoreAddAlternativesForRetrocorrection()
{
  if (HIBYTE(add_alternatives_for_retrocorrection_override)) {
    HIBYTE(add_alternatives_for_retrocorrection_override) = 0;
  }
}

uint64_t TIAreTransformerLMForVisionOSEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIAreInlineCompletionForVisionOSEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIIsStickersSuggestionsEnabled()
{
  return _os_feature_enabled_impl();
}

uint64_t TIPerRecipientAdaptationEnabled()
{
  return 1;
}

uint64_t getExcessMemoryInBytes()
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  getpid();
  uint64_t v0 = memorystatus_control();
  if (v0)
  {
    uint64_t v1 = v0;
    uint64_t v2 = TIKeyboardActivityOSLogFacility();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = NSString;
      uint64_t v4 = *__error();
      __int16 v5 = __error();
      uint64_t v6 = [v3 stringWithFormat:@"%s memorystatus_control returned error: %d, errno: %d, error-string: %s", "getExcessMemoryInBytes", v1, v4, strerror(*v5)];
      *(_DWORD *)buf = 138412290;
      unint64_t v9 = v6;
      _os_log_impl(&dword_1E3F0E000, v2, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
    }
  }
  return 0;
}

uint64_t KB::Input::Input(uint64_t this)
{
  *(_DWORD *)this = 0x100000;
  *(_WORD *)(this + 4) = 0;
  *(unsigned char *)(this + 6) = 0;
  *(void *)(this + 8) = 0;
  *(unsigned char *)(this + 16) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

{
  *(_DWORD *)this = 0x100000;
  *(_WORD *)(this + 4) = 0;
  *(unsigned char *)(this + 6) = 0;
  *(void *)(this + 8) = 0;
  *(unsigned char *)(this + 16) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

KB::String *KB::Input::Input(KB::Input *this, const KB::String *a2, int a3)
{
  uint64_t result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = a3;
  return result;
}

{
  KB::String *result;

  uint64_t result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = a3;
  return result;
}

KB::String *KB::Input::Input(KB::Input *this, const KB::Input *a2)
{
  uint64_t result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  return result;
}

{
  KB::String *result;

  uint64_t result = KB::String::String(this, a2);
  *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  return result;
}

KB::String *KB::Input::operator=(KB::String *result, KB::String *a2)
{
  if (result != a2)
  {
    uint64_t result = KB::String::operator=(result, a2);
    *((_DWORD *)result + 8) = *((_DWORD *)a2 + 8);
  }
  return result;
}

uint64_t lookupVSeq(int a1, int a2, int a3)
{
  v5[0] = a1;
  v5[1] = a2;
  v5[2] = a3;
  int v3 = (unsigned int *)bsearch(v5, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
  if (v3) {
    return v3[3];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t tripleVowelCompare(char *a1, char *a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    int v3 = *(_DWORD *)&a1[v2];
    int v4 = *(_DWORD *)&a2[v2];
    if (v3 < v4) {
      break;
    }
    if (v3 > v4) {
      return 1;
    }
    v2 += 4;
    if (v2 == 12) {
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t lookupCSeq(int a1, int a2, int a3)
{
  v5[0] = a1;
  v5[1] = a2;
  v5[2] = a3;
  int v3 = (unsigned int *)bsearch(v5, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
  if (v3) {
    return v3[3];
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t tripleConCompare(char *a1, char *a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    int v3 = *(_DWORD *)&a1[v2];
    int v4 = *(_DWORD *)&a2[v2];
    if (v3 < v4) {
      break;
    }
    if (v3 > v4) {
      return 1;
    }
    v2 += 4;
    if (v2 == 12) {
      return 0;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t UkEngine::processRoof(uint64_t a1, int *a2)
{
  if (*(_DWORD *)(*(void *)(a1 + 8) + 4))
  {
    unsigned int v4 = *(_DWORD *)(a1 + 28);
    if ((v4 & 0x80000000) == 0)
    {
      int v5 = *(_DWORD *)(a1 + 36 * v4 + 3152);
      if ((v5 & 0x80000000) == 0)
      {
        int v6 = *a2;
        if (*a2 == 1)
        {
          char v7 = 0;
          int v8 = 13;
        }
        else if (v6 == 3)
        {
          char v7 = 0;
          int v8 = 109;
        }
        else
        {
          if (v6 != 2)
          {
            int v64 = -1;
            char v7 = 1;
LABEL_15:
            unsigned int v10 = *(_DWORD *)(a1 + 3144 + 36 * (int)(v4 - v5) + 16);
            unint64_t v11 = (_DWORD *)((char *)&VSeqList + 52 * (int)v10);
            int v62 = v4 - v5;
            int v12 = v4 - v5 - *v11 + 1;
            int TonePosition = UkEngine::getTonePosition(a1, v10, v5 == 0);
            int v61 = v12 + TonePosition;
            uint64_t v13 = a1 + 3144 + 36 * (v12 + TonePosition);
            int v16 = *(_DWORD *)(v13 + 24);
            uint64_t v15 = (_DWORD *)(v13 + 24);
            int v14 = v16;
            if (v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0)
            {
              int v20 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 10);
            }
            else
            {
              int v18 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 5);
              __keCGFloat y = 0x6D0000008FLL;
              int v66 = v18;
              unint64_t v19 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
              if (v19) {
                int v20 = v19[3];
              }
              else {
                int v20 = -1;
              }
            }
            if (v20 == -1)
            {
              int v24 = *((_DWORD *)&VSeqList + 13 * (int)v10 + 9);
              if (v24 != -1)
              {
                int v59 = v14;
                int v25 = v24 + v12;
                uint64_t v26 = a1 + 36 * (v24 + v12);
                int v27 = *(_DWORD *)(v26 + 3172);
                char v28 = v27 == v64 ? 1 : v7;
                if (v28)
                {
                  int v29 = v27 == 57 ? 45 : 97;
                  int v30 = v27 == 13 ? 1 : v29;
                  if (*(_DWORD *)(*(void *)(a1 + 8) + 12) || v25 == *(_DWORD *)(a1 + 28))
                  {
                    unint64_t v31 = (int *)(v26 + 3172);
                    int v32 = *(_DWORD *)(a1 + 16);
                    if (v32 > v25)
                    {
                      int v33 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v25, v32 - 1);
                      *(_DWORD *)(a1 + 16) = v25;
                      *(_DWORD *)(a1 + 20) = v33;
                    }
                    *unint64_t v31 = v30;
                    int v34 = v12;
                    if (*v11 == 2)
                    {
                      unsigned int v48 = lookupVSeq(*(_DWORD *)(a1 + 36 * v12 + 3172), *(_DWORD *)(a1 + 36 * v12 + 3208), -1);
                      int v35 = v59;
                      int v36 = v62;
                    }
                    else
                    {
                      int v35 = v59;
                      int v36 = v62;
                      uint64_t v37 = (int *)(a1 + 36 * v12);
                      if (*v11 == 3)
                      {
                        int v49 = v37[802];
                        int v50 = v37[811];
                      }
                      else
                      {
                        int v49 = -1;
                        int v50 = -1;
                      }
                      unsigned int v48 = lookupVSeq(v37[793], v49, v50);
                    }
                    unint64_t v42 = (int *)((char *)&VSeqList + 52 * (int)v48);
                    goto LABEL_73;
                  }
                }
              }
            }
            else if ((v7 & 1) != 0 || *((_DWORD *)&VSeqList + 13 * v20 + *((int *)&VSeqList + 13 * v20 + 9) + 3) == v64)
            {
              int v21 = *(_DWORD *)(a1 + 28);
              int v22 = *(_DWORD *)(a1 + 36 * v21 + 3148);
              int v23 = v22 == -1 ? -1 : *(_DWORD *)(a1 + 36 * (v21 - v22) + 3160);
              int v34 = v12;
              int v38 = *(_DWORD *)(a1 + 36 * v21 + 3156);
              int v39 = v38 == -1 ? -1 : *(_DWORD *)(a1 + 36 * (v21 - v38) + 3160);
              if (isValidCVC(v23, v20, v39))
              {
                int v60 = v14;
                BOOL v40 = v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0;
                int v41 = v12;
                if (v40) {
                  int v41 = *((_DWORD *)&VSeqList + 13 * v20 + 9) + v12;
                }
                if (*(_DWORD *)(*(void *)(a1 + 8) + 12) || v41 == *(_DWORD *)(a1 + 28))
                {
                  unint64_t v42 = (int *)((char *)&VSeqList + 52 * v20);
                  int v43 = *(_DWORD *)(a1 + 16);
                  if (v43 > v41)
                  {
                    int v44 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v41, v43 - 1);
                    *(_DWORD *)(a1 + 16) = v41;
                    *(_DWORD *)(a1 + 20) = v44;
                  }
                  if (v10 - 43 > 0x17 || ((1 << (v10 - 43)) & 0xA00003) == 0)
                  {
                    *(_DWORD *)(a1 + 36 * v41 + 3172) = *((_DWORD *)&VSeqList
                                                          + 13 * v20
                                                          + *((int *)&VSeqList + 13 * v20 + 9)
                                                          + 3);
                  }
                  else
                  {
                    uint64_t v46 = a1 + 36 * v12;
                    *(_DWORD *)(v46 + 3172) = 143;
                    *(_DWORD *)(v46 + 3208) = 109;
                  }
                  unsigned int v48 = v20;
                  int v35 = v60;
                  int v36 = v62;
LABEL_73:
                  if (*v42 >= 1)
                  {
                    uint64_t v51 = 0;
                    long long v52 = (_DWORD *)(a1 + 36 * v34 + 3160);
                    do
                    {
                      _DWORD *v52 = v42[v51 + 6];
                      v52 += 9;
                      ++v51;
                    }
                    while (v51 < *v42);
                  }
                  int v53 = UkEngine::getTonePosition(a1, v48, v36 == *(_DWORD *)(a1 + 28));
                  if (TonePosition != v53 && v35 != 0)
                  {
                    int v55 = v53 + v34;
                    int v56 = *(_DWORD *)(a1 + 16);
                    if (v56 > v53 + v34)
                    {
                      int v57 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v55, v56 - 1);
                      *(_DWORD *)(a1 + 16) = v55;
                      *(_DWORD *)(a1 + 20) = v57;
                      int v56 = v55;
                    }
                    *(_DWORD *)(a1 + 36 * v55 + 3168) = v35;
                    if (v56 > v61)
                    {
                      int v58 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v61, v56 - 1);
                      *(_DWORD *)(a1 + 16) = v61;
                      *(_DWORD *)(a1 + 20) = v58;
                    }
                    *uint64_t v15 = 0;
                  }
                  uint64_t v47 = 1;
                  if (v20 == -1)
                  {
                    *(_DWORD *)(a1 + 32) = 0;
                    UkEngine::processAppend((UkEngine *)a1, a2);
                    *(unsigned char *)(a1 + 3137) = 1;
                  }
                  return v47;
                }
              }
            }
            return UkEngine::processAppend((UkEngine *)a1, a2);
          }
          char v7 = 0;
          int v8 = 57;
        }
        int v64 = v8;
        goto LABEL_15;
      }
    }
  }

  return UkEngine::processAppend((UkEngine *)a1, a2);
}

uint64_t UkEngine::processAppend(UkEngine *this, _DWORD *a2)
{
  switch(a2[1])
  {
    case 0:
      uint64_t v4 = (int)a2[2];
      if (!*((unsigned char *)&IsVnVowel + v4)
        || (unsigned int v5 = *((_DWORD *)this + 7), (v5 & 0x80000000) == 0)
        && *((_DWORD *)this + 9 * v5 + 786) == 2
        && ((int v6 = *(_DWORD *)((char *)StdVnNoTone + ((4 * v4) | 4)), v7 = *((_DWORD *)this + 9 * v5 + 790), v7 == 20)
         && v6 == 143
         || v7 == 6 && v6 == 75))
      {
        return UkEngine::appendConsonnant(this, (uint64_t)a2);
      }
      else
      {
        return UkEngine::appendVowel((uint64_t)this, (uint64_t)a2);
      }
    case 1:
      *((_DWORD *)this + 8) = 0;
      return UkEngine::processWordEnd(this, (uint64_t)a2);
    case 2:
      uint64_t v9 = *((void *)this + 1);
      if (*(_DWORD *)(v9 + 4))
      {
        if (*(_DWORD *)(v9 + 2104) == 10)
        {
          if (UkEngine::checkEscapeVIQR((uint64_t)this, (uint64_t)a2)) {
            return 1;
          }
          uint64_t v9 = *((void *)this + 1);
          BOOL v10 = a2[1] == 1;
          BOOL v11 = *(_DWORD *)(v9 + 4) == 0;
        }
        else
        {
          BOOL v11 = 0;
          BOOL v10 = 0;
        }
      }
      else
      {
        BOOL v10 = 0;
        BOOL v11 = 1;
      }
      uint64_t result = 0;
      uint64_t v12 = *((int *)this + 7) + 1;
      *((_DWORD *)this + 7) = v12;
      uint64_t v13 = (char *)this + 36 * v12;
      *((_DWORD *)v13 + 786) = v10;
      *((_DWORD *)v13 + 789) = -1;
      *(void *)(v13 + 3148) = -1;
      int v14 = a2[2];
      *((_DWORD *)v13 + 794) = a2[3];
      *((_DWORD *)v13 + 793) = v14 | 1;
      *((_DWORD *)v13 + 792) = 0;
      *((_DWORD *)v13 + 79TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = (v14 | 1) != v14;
      if (v11) {
        return result;
      }
      if (*(_DWORD *)(v9 + 2104) != 6) {
        return 0;
      }
      int v15 = *((_DWORD *)this + 4);
      if (v15 > (int)v12)
      {
        int v16 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v15 - 1);
        *((_DWORD *)this + 4) = v12;
        *((_DWORD *)this + 5) = v16;
      }
      return 1;
    case 3:
      uint64_t result = 0;
      *((_DWORD *)this + 778) = -1;
      *(void *)((char *)this + 28) = 0xFFFFFFFFLL;
      *((unsigned char *)this + 3116) = 0;
      return result;
    default:
      return 0;
  }
}

uint64_t UkEngine::getTonePosition(uint64_t a1, unsigned int a2, int a3)
{
  int v3 = *((_DWORD *)&VSeqList + 13 * (int)a2);
  if (v3 == 1) {
    return 0;
  }
  uint64_t v4 = *((unsigned int *)&VSeqList + 13 * (int)a2 + 9);
  if (v4 == -1)
  {
    if (*((_DWORD *)&VSeqList + 13 * (int)a2 + 11) == -1)
    {
      if (v3 == 3 || *(_DWORD *)(*(void *)(a1 + 8) + 16) && a2 <= 0x28 && ((1 << a2) & 0x1000A000000) != 0) {
        return 1;
      }
      else {
        return a3 ^ 1u;
      }
    }
    else
    {
      if (a2 - 44 > 0x17) {
        return *((unsigned int *)&VSeqList + 13 * (int)a2 + 11);
      }
      uint64_t v4 = 1;
      if (((1 << (a2 - 44)) & 0xC00001) == 0) {
        return *((unsigned int *)&VSeqList + 13 * (int)a2 + 11);
      }
    }
  }
  return v4;
}

uint64_t UkEngine::getSeqSteps(UkEngine *this, int a2, int a3)
{
  int v3 = a3 - a2;
  if (a3 < a2) {
    return 0;
  }
  int v7 = *(_DWORD *)(*((void *)this + 1) + 2104);
  if (v7 == 12 || v7 == 0) {
    return (v3 + 1);
  }
  v20[0] = &unk_1F3F75490;
  v20[1] = 0;
  _OWORD v20[2] = 0;
  uint64_t v21 = 0;
  int v22 = 0;
  int v19 = 0;
  uint64_t VnCharset = CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, v7);
  (*(void (**)(uint64_t))(*(void *)VnCharset + 8))(VnCharset);
  int v10 = v3 + 1;
  BOOL v11 = (unsigned int *)((char *)this + 36 * a2 + 3176);
  do
  {
    int v12 = *(v11 - 1);
    if (v12 == -1)
    {
      uint64_t v16 = *v11;
    }
    else
    {
      int v13 = *(v11 - 2);
      if (*(v11 - 3)) {
        int v14 = 0xFFFF;
      }
      else {
        int v14 = 0x10000;
      }
      unsigned int v15 = v14 + v12;
      if (v13) {
        uint64_t v16 = v15 + 2 * v13;
      }
      else {
        uint64_t v16 = v15;
      }
    }
    if (v16 != -1) {
      (*(void (**)(uint64_t, void *, uint64_t, int *))(*(void *)VnCharset + 24))(VnCharset, v20, v16, &v19);
    }
    v11 += 9;
    --v10;
  }
  while (v10);
  if ((int)v21 >= 0) {
    int v17 = v21;
  }
  else {
    int v17 = v21 + 1;
  }
  unsigned int v18 = v17 >> 1;
  if (*(_DWORD *)(*((void *)this + 1) + 2104) == 4) {
    return v18;
  }
  else {
    return v21;
  }
}

uint64_t isValidCVC(int a1, int a2, int a3)
{
  if (a2 == -1) {
    return a1 == -1 || a3 != -1;
  }
  if (a1 != -1)
  {
    BOOL valid = isValidCV(a1, a2);
    if (a3 != -1)
    {
      BOOL v7 = isValidVC(a2, a3);
      if (valid && v7) {
        return 1;
      }
      if (v7) {
        return 0;
      }
      if (a1 == 21 && a2 == 11)
      {
        BOOL valid = 1;
        if (a3 == 14 || a3 == 17) {
          return valid;
        }
      }
      return a1 == 8 && (a2 - 3) <= 1 && (a3 & 0xFFFFFFFE) == 0xE;
    }
    return valid;
  }

  return isValidVC(a2, a3);
}

BOOL isValidVC(int a1, int a2)
{
  if (a2 == -1) {
    return 1;
  }
  uint64_t v6 = v2;
  uint64_t v7 = v3;
  if (!*((_DWORD *)&VSeqList + 13 * a1 + 2) || !*((unsigned char *)&CSeqList + 20 * a2 + 16)) {
    return 0;
  }
  __key[0] = a1;
  __key[1] = a2;
  return bsearch(__key, &VCPairList, 0x99uLL, 8uLL, (int (__cdecl *)(const void *, const void *))VCPairCompare) != 0;
}

BOOL isValidCV(int a1, int a2)
{
  BOOL result = 1;
  if (a1 != -1 && a2 != -1)
  {
    switch(a1)
    {
      case 8:
        BOOL v5 = *((_DWORD *)&VSeqList + 13 * a2 + 3) == 75;
        break;
      case 21:
        BOOL v5 = *((_DWORD *)&VSeqList + 13 * a2 + 3) == 143;
        break;
      case 10:
        uint64_t v4 = 0;
        while (isValidCV(ConSeq,VowelSeq)::kVseq[v4] != a2)
        {
          if (++v4 == 12) {
            return 0;
          }
        }
        BOOL v5 = v4 == 12;
        break;
      default:
        return result;
    }
    return !v5;
  }
  return result;
}

uint64_t VCPairCompare(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  if (*a1 > *a2) {
    return 1;
  }
  int v3 = a1[1];
  int v4 = a2[1];
  BOOL v5 = v3 < v4;
  BOOL v6 = v3 > v4;
  if (v5) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v6;
  }
}

uint64_t UkEngine::processWordEnd(UkEngine *this, uint64_t a2)
{
  int v4 = (_DWORD *)*((void *)this + 1);
  if (v4[5])
  {
    if (UkEngine::macroMatch((uint64_t)this, a2)) {
      return 1;
    }
    int v4 = (_DWORD *)*((void *)this + 1);
  }
  if (!v4[10] || *((_DWORD *)this + 8) || (*((_DWORD *)this + 7) & 0x80000000) != 0 || *((unsigned char *)this + 3139))
  {
    uint64_t result = 0;
    uint64_t v6 = *((int *)this + 7) + 1;
    *((_DWORD *)this + 7) = v6;
    uint64_t v7 = (char *)this + 36 * v6;
    *(_OWORD *)(v7 + 3144) = xmmword_1E4154B60;
    int v8 = *(_DWORD *)(a2 + 8);
    *((_DWORD *)v7 + 794) = *(_DWORD *)(a2 + 12);
    *((_DWORD *)v7 + 793) = v8 | 1;
    *((_DWORD *)v7 + 79TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = (v8 | 1) != v8;
  }
  else
  {
    int v14 = 0;
    if (v4[11])
    {
      if (UkEngine::lastWordIsNonVn(this))
      {
        int v14 = **((_DWORD **)this + 391);
        if (UkEngine::restoreKeyStrokes((uint64_t)this, (_DWORD *)this + 5, *((void *)this + 390), &v14, (_DWORD *)this + 785))
        {
          *((unsigned char *)this + 3138) = 1;
          *((unsigned char *)this + 3136) = 1;
        }
      }
    }
    uint64_t v9 = *((int *)this + 7) + 1;
    *((_DWORD *)this + 7) = v9;
    int v10 = (char *)this + 36 * v9;
    *(_OWORD *)(v10 + 3144) = xmmword_1E4154B60;
    int v12 = *(_DWORD *)(a2 + 8);
    int v11 = *(_DWORD *)(a2 + 12);
    *((_DWORD *)v10 + 794) = v11;
    *((_DWORD *)v10 + 793) = v12 | 1;
    *((_DWORD *)v10 + 79TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = (v12 | 1) != v12;
    if (*((unsigned char *)this + 3138))
    {
      int v13 = v14;
      if (v14 < **((_DWORD **)this + 391))
      {
        *(unsigned char *)(*((void *)this + 390) + v14) = v11;
        **((_DWORD **)this + 39TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v13 + 1;
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t UkEngine::checkEscapeVIQR(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 28);
  if ((v2 & 0x80000000) != 0) {
    return 0;
  }
  int v5 = *(_DWORD *)(a1 + 36 * v2 + 3144);
  if ((v5 - 3) >= 2)
  {
    if (v5) {
      return 0;
    }
    unsigned __int8 v8 = __toupper(*(_DWORD *)(a1 + 36 * v2 + 3176));
    uint64_t result = 0;
    int v7 = *(_DWORD *)(a2 + 12);
    if (v7 <= 62)
    {
      switch(v7)
      {
        case '\'':
        case '.':
          goto LABEL_32;
        case '(':
          if (v8 != 65) {
            return 0;
          }
LABEL_11:
          int v7 = 40;
          goto LABEL_44;
        case '+':
          int v7 = 43;
          if (v8 == 79 || v8 == 85) {
            goto LABEL_44;
          }
          return 0;
        default:
          return result;
      }
    }
    if (v7 > 95)
    {
      if (v7 != 96 && v7 != 126) {
        return result;
      }
    }
    else if (v7 != 63)
    {
      if (v7 != 94) {
        return result;
      }
      if (v8 == 65 || v8 == 79) {
        goto LABEL_44;
      }
      if (v8 != 69) {
        return 0;
      }
      int v7 = 94;
      goto LABEL_44;
    }
LABEL_32:
    if ((v8 & 0xFB) != 0x41)
    {
      unsigned int v10 = v8;
      BOOL v11 = v8 == 89;
      v10 -= 73;
      BOOL v12 = v10 > 0xC;
      int v13 = (1 << v10) & 0x1041;
      if (v12 || v13 == 0)
      {
LABEL_40:
        if (!v11) {
          return 0;
        }
      }
    }
    goto LABEL_44;
  }
  uint64_t result = 0;
  int v7 = *(_DWORD *)(a2 + 12);
  if (v7 > 62)
  {
    if (v7 > 95)
    {
      if (v7 != 96 && v7 != 126) {
        return result;
      }
    }
    else if (v7 != 63)
    {
      if (v7 != 94) {
        return result;
      }
      int v9 = *(_DWORD *)(a1 + 36 * v2 + 3172);
      int v7 = 94;
      if (v9 == 1 || v9 == 45 || v9 == 97) {
        goto LABEL_44;
      }
      return 0;
    }
LABEL_28:
    if (*(_DWORD *)(a1 + 36 * v2 + 3168)) {
      return 0;
    }
LABEL_44:
    int v16 = *(_DWORD *)(a1 + 28);
    uint64_t v17 = a1 + 36 * (v16 + 1);
    BOOL v18 = *(_DWORD *)(a2 + 4) == 1;
    *(_DWORD *)(v17 + 3144) = v18;
    *(_DWORD *)(v17 + 3156) = -1;
    *(void *)(v17 + 3148) = -1;
    *(void *)(v17 + 3172) = 0x3FFFFFFFFFLL;
    *(_DWORD *)(a1 + 28) = v16 + 2;
    *(_DWORD *)(v17 + 3180) = v18;
    *(_DWORD *)(v17 + 3192) = -1;
    *(void *)(v17 + 3184) = -1;
    *(_DWORD *)(v17 + 3212) = v7;
    *(_DWORD *)(v17 + 3208) = -1;
    **(unsigned char **)(a1 + 3120) = 92;
    *(unsigned char *)(*(void *)(a1 + 3120) + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = *(_DWORD *)(a2 + 12);
    **(_DWORD **)(a1 + 3128) = 2;
    uint64_t result = 1;
    *(unsigned char *)(a1 + 3136) = 1;
    return result;
  }
  switch(v7)
  {
    case '\'':
    case '.':
      goto LABEL_28;
    case '(':
      if (*(_DWORD *)(a1 + 36 * v2 + 3172) != 1) {
        return 0;
      }
      goto LABEL_11;
    case '+':
      int v15 = *(_DWORD *)(a1 + 36 * v2 + 3172);
      BOOL v11 = v15 == 143;
      int v7 = 43;
      if (v15 != 97) {
        goto LABEL_40;
      }
      goto LABEL_44;
    default:
      return result;
  }
  return result;
}

uint64_t UkEngine::appendConsonnant(UkEngine *this, uint64_t a2)
{
  int v3 = *((_DWORD *)this + 7);
  int v4 = v3 + 1;
  *((_DWORD *)this + 7) = v3 + 1;
  int v5 = v3 + 1;
  uint64_t v6 = (_DWORD *)((char *)this + 36 * v3 + 36);
  int v7 = v6 + 786;
  int v8 = *(_DWORD *)(a2 + 8);
  int v9 = v8 | 1;
  v6[793] = v8 | 1;
  v6[791] = (v8 | 1) != v8;
  v6[794] = *(_DWORD *)(a2 + 12);
  v6[792] = 0;
  if (v3 == -1 || (uint64_t v10 = *((void *)this + 1), !*(_DWORD *)(v10 + 4)))
  {
    *int v7 = xmmword_1E4154B80;
    *(_DWORD *)int v58 = v8 | 1;
    *(void *)&v58[4] = -1;
    int v16 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    if (v16) {
      int v17 = v16[3];
    }
    else {
      int v17 = -1;
    }
    *((_DWORD *)this + 9 * v5 + 790) = v17;
    uint64_t v18 = *((void *)this + 1);
    if (!*(_DWORD *)(v18 + 4)) {
      return 0;
    }
  }
  else
  {
    BOOL v11 = (int *)((char *)this + 36 * v3 + 3144);
    switch(*v11)
    {
      case 0:
        *int v7 = xmmword_1E4154B70;
        goto LABEL_22;
      case 1:
        *int v7 = xmmword_1E4154B80;
        *(_DWORD *)int v58 = v8 | 1;
        *(void *)&v58[4] = -1;
        int v25 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
        if (v25) {
          int v26 = v25[3];
        }
        else {
          int v26 = -1;
        }
        *((_DWORD *)this + 9 * v5 + 790) = v26;
        goto LABEL_63;
      case 2:
      case 5:
      case 6:
        int v12 = *((_DWORD *)this + 9 * v3 + 790);
        int v13 = *((_DWORD *)&CSeqList + 5 * v12);
        if (v13 == 3) {
          goto LABEL_52;
        }
        if (v13 == 2)
        {
          *(void *)int v58 = *(void *)((char *)&CSeqList + 20 * v12 + 4);
          *(_DWORD *)&unsigned char v58[8] = v9;
          int v14 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
          if (!v14)
          {
            int v15 = -1;
            goto LABEL_28;
          }
        }
        else
        {
          *(_DWORD *)int v58 = *((_DWORD *)&CSeqList + 5 * v12 + 1);
          *(_DWORD *)&v58[4] = v9;
          int v15 = -1;
          *(_DWORD *)&unsigned char v58[8] = -1;
          int v14 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
          if (!v14) {
            goto LABEL_28;
          }
        }
        int v15 = v14[3];
LABEL_28:
        if (v15 == -1) {
          goto LABEL_52;
        }
        int v27 = *v11;
        if ((*v11 - 5) > 1) {
          goto LABEL_49;
        }
        int v28 = *((_DWORD *)this + 9 * v3 + 787);
        int v29 = *((_DWORD *)this + 7);
        if (v28 == -1) {
          int v30 = -1;
        }
        else {
          int v30 = *((_DWORD *)this + 9 * v29 + 9 * ~v28 + 790);
        }
        if (isValidCVC(v30, *((_DWORD *)this + 9 * v29 + 9 * ~*((_DWORD *)this + 9 * v3 + 788) + 790), v15))
        {
          int v27 = *v11;
LABEL_49:
          if (v27 == 5)
          {
            *(void *)int v7 = -4294967291;
            *((_DWORD *)this + 9 * v5 + 789) = 0;
            int v39 = *((_DWORD *)this + 9 * v3 + 788) + 1;
          }
          else if (v27 == 2)
          {
            *(void *)int v7 = 2;
            int v39 = -1;
            *((_DWORD *)this + 9 * v5 + 789) = -1;
          }
          else
          {
            *(_DWORD *)int v7 = 6;
            BOOL v40 = (char *)this + 36 * v3 + 3144;
            int v41 = *((_DWORD *)v40 + 1);
            LODWORD(v40) = *((_DWORD *)v40 + 2);
            unint64_t v42 = (char *)this + 36 * v5 + 3144;
            *((_DWORD *)v42 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v41 + 1;
            *((_DWORD *)v42 + 3) = 0;
            int v39 = v40 + 1;
          }
          int v43 = (char *)this + 36 * v5;
          *((_DWORD *)v43 + 788) = v39;
          *((_DWORD *)v43 + 790) = v15;
        }
        else
        {
LABEL_52:
          *int v7 = xmmword_1E4154B70;
        }
        goto LABEL_63;
      case 3:
      case 4:
        int v19 = (char *)this + 36 * v3;
        uint64_t v20 = *((int *)v19 + 790);
        if (v20 == 43 || v20 == 38) {
          unsigned int v22 = 44;
        }
        else {
          unsigned int v22 = *((_DWORD *)v19 + 790);
        }
        int v23 = *((_DWORD *)v19 + 787);
        if (v23 == -1) {
          int v24 = -1;
        }
        else {
          int v24 = *((_DWORD *)this + 9 * (v3 - v23) + 790);
        }
        *(_DWORD *)int v58 = v8 | 1;
        *(void *)&v58[4] = -1;
        unint64_t v31 = bsearch(v58, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
        if (v31) {
          int v32 = v31[3];
        }
        else {
          int v32 = -1;
        }
        if (!isValidCVC(v24, v22, v32)) {
          goto LABEL_52;
        }
        if (v20 == 43)
        {
          int v33 = *((_DWORD *)this + 7);
          int v34 = *((_DWORD *)this + 4);
          if (v34 >= v33)
          {
            int v35 = v33 - 1;
            int v36 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v33 - 1, v34 - 1);
            *((_DWORD *)this + 4) = v35;
            *((_DWORD *)this + 5) = v36;
          }
          *((_DWORD *)this + 9 * v3 + 793) = 121;
          goto LABEL_43;
        }
        if (v20 == 38)
        {
          UkEngine::markChange(this, *((_DWORD *)this + 7) - 2);
          uint64_t v37 = (char *)this + 36 * *((int *)this + 7);
          *((_DWORD *)v37 + 775) = 155;
          *((_DWORD *)v37 + 772) = 10;
LABEL_43:
          *((_DWORD *)v19 + 790) = 44;
          char v38 = 1;
          goto LABEL_57;
        }
        char v38 = 0;
LABEL_57:
        if (*v11 == 3)
        {
          int v44 = -1;
          int v45 = 5;
        }
        else
        {
          int v44 = *((_DWORD *)v19 + 787) + 1;
          int v45 = 6;
        }
        *(_DWORD *)int v7 = v45;
        uint64_t v46 = (char *)this + 36 * v5 + 3144;
        *((_DWORD *)v46 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v44;
        *((void *)v46 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 1;
        *((_DWORD *)v46 + 4) = v32;
        int v47 = *((_DWORD *)this + 7);
        int v48 = v47 - *((_DWORD *)&VSeqList + 13 * (int)v20);
        int v49 = v48 + UkEngine::getTonePosition((uint64_t)this, v20, 1);
        int v50 = (char *)this + 36 * v49 + 3144;
        int v52 = *((_DWORD *)v50 + 6);
        uint64_t v51 = v50 + 24;
        if (v52)
        {
          int v53 = v47 - *((_DWORD *)&VSeqList + 13 * (int)v22);
          int v54 = v53 + UkEngine::getTonePosition((uint64_t)this, v22, 0);
          if (v54 != v49)
          {
            UkEngine::markChange(this, v54);
            *((_DWORD *)this + 9 * v54 + 792) = *v51;
            UkEngine::markChange(this, v49);
            *uint64_t v51 = 0;
            return 1;
          }
        }
        if (v38) {
          return 1;
        }
LABEL_63:
        uint64_t v18 = *((void *)this + 1);
        break;
      default:
LABEL_22:
        if (*(_DWORD *)(v10 + 2104) == 6) {
          goto LABEL_66;
        }
        return 0;
    }
  }
  if (*(_DWORD *)(v18 + 2104) != 6) {
    return 0;
  }
  int v4 = *((_DWORD *)this + 7);
LABEL_66:
  int v55 = *((_DWORD *)this + 4);
  if (v55 > v4)
  {
    int v56 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v4, v55 - 1);
    *((_DWORD *)this + 4) = v4;
    *((_DWORD *)this + 5) = v56;
  }
  return 1;
}

uint64_t UkEngine::appendVowel(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int *)(a1 + 28);
  uint64_t v4 = v3 + 1;
  *(_DWORD *)(a1 + 28) = v3 + 1;
  int v5 = (_DWORD *)(a1 + 36 * (v3 + 1));
  int v6 = *(_DWORD *)(a2 + 8);
  int v7 = v6 | 1;
  int v8 = StdVnNoTone[v6 | 1];
  int v9 = v5 + 786;
  v5[793] = v8;
  v5[791] = (v6 | 1) != v6;
  int v10 = (v6 | 1) - v8;
  if ((v6 | 1) >= v8) {
    int v11 = (v6 | 1) - v8;
  }
  else {
    int v11 = v10 + 1;
  }
  int v12 = v11 >> 1;
  v5[792] = v11 >> 1;
  int v13 = v5 + 794;
  v5[794] = *(_DWORD *)(a2 + 12);
  if (v3 != -1 && *(_DWORD *)(*(void *)(a1 + 8) + 4))
  {
    uint64_t v14 = a1 + 36 * (int)v3;
    int v15 = v5 + 792;
    switch(*(_DWORD *)(v14 + 3144))
    {
      case 0:
      case 5:
      case 6:
        goto LABEL_7;
      case 1:
        *int v9 = xmmword_1E4154BA0;
        __keCGFloat y = v8;
        uint64_t v64 = -1;
        int v28 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
        if (v28) {
          int v29 = v28[3];
        }
        else {
          int v29 = -1;
        }
        *(_DWORD *)(a1 + 36 * v4 + 3160) = v29;
        goto LABEL_37;
      case 2:
        int v30 = v15;
        __keCGFloat y = v8;
        uint64_t v64 = -1;
        unint64_t v31 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
        if (v31) {
          int v32 = v31[3];
        }
        else {
          int v32 = -1;
        }
        int v33 = *(_DWORD *)(a1 + 36 * (int)v3 + 3160);
        if (!isValidCV(v33, v32))
        {
LABEL_7:
          *int v9 = xmmword_1E4154B70;
          goto LABEL_37;
        }
        *int v9 = xmmword_1E4154B90;
        *(_DWORD *)(a1 + 36 * v4 + 3160) = v32;
        if (v33 != 8) {
          goto LABEL_37;
        }
        uint64_t v34 = a1 + 36 * (int)v3;
        int v35 = *(_DWORD *)(v34 + 3168);
        if (!v35) {
          goto LABEL_37;
        }
        int v36 = (_DWORD *)(v34 + 3168);
        if (!*v30) {
          *int v30 = v35;
        }
        UkEngine::markChange((_DWORD *)a1, *(_DWORD *)(a1 + 28) - 1);
        *int v36 = 0;
        return 1;
      case 3:
      case 4:
        int v56 = v15;
        int v62 = v13;
        unsigned int v19 = *(_DWORD *)(a1 + 3144 + 36 * (int)v3 + 16);
        int v55 = (int *)((char *)&VSeqList + 52 * (int)v19);
        int v58 = *v55;
        int v60 = v4 - *v55;
        unsigned int v57 = v19;
        int v20 = v60 + UkEngine::getTonePosition(a1, v19, 1);
        uint64_t v21 = a1 + 3144 + 36 * v20;
        int v24 = *(_DWORD *)(v21 + 24);
        unsigned int v22 = (int *)(v21 + 24);
        int v23 = v24;
        if (v7 != v8 && v23) {
          goto LABEL_36;
        }
        if (v58 == 3) {
          goto LABEL_36;
        }
        BOOL v25 = v58 == 2;
        int v59 = v22;
        int v26 = v23;
        int v61 = v20;
        int v27 = (char *)&VSeqList + 52 * (int)v57;
        if (v25)
        {
          int v37 = *((_DWORD *)v27 + 4);
          int v38 = v8;
        }
        else
        {
          int v37 = v8;
          int v38 = -1;
        }
        int v39 = lookupVSeq(*((_DWORD *)v27 + 3), v37, v38);
        int v40 = v26;
        unsigned int v41 = v39;
        if (v39 == -1) {
          goto LABEL_36;
        }
        int v42 = *(_DWORD *)(v14 + 3144);
        if (v42 == 4)
        {
          int v43 = *(_DWORD *)(a1 + 3144 + 36 * (int)v3 + 4);
          if (!isValidCV(*(_DWORD *)(a1 + 3144 + 36 * (*(_DWORD *)(a1 + 28) + ~v43) + 16), v39))
          {
LABEL_36:
            *int v9 = xmmword_1E4154B70;
            int v13 = v62;
            goto LABEL_37;
          }
          int v40 = v26;
          *(_DWORD *)int v9 = 4;
          int v44 = v43 + 1;
        }
        else
        {
          *(_DWORD *)int v9 = v42;
          int v44 = -1;
        }
        uint64_t v51 = a1 + 36 * v4;
        *(_DWORD *)(v51 + 3148) = v44;
        *(void *)(v51 + 3152) = 0xFFFFFFFF00000000;
        *(_DWORD *)(v51 + 3160) = v41;
        *int v56 = 0;
        int v13 = v62;
        if (v40)
        {
          int v52 = *(_DWORD *)(a1 + 28) - *v55 + UkEngine::getTonePosition(a1, v41, 1);
          if (v52 != v61)
          {
            UkEngine::markChange((_DWORD *)a1, v61);
            int *v59 = 0;
            UkEngine::markChange((_DWORD *)a1, v52);
            if ((v10 + 1) >= 3) {
              int v54 = v12;
            }
            else {
              int v54 = v26;
            }
            *(_DWORD *)(a1 + 36 * v52 + 3168) = v54;
            return 1;
          }
          if ((v10 + 1) >= 3 && v12 != v26)
          {
            UkEngine::markChange((_DWORD *)a1, v61);
            int *v59 = v12;
            return 1;
          }
        }
        else if ((v10 + 1) >= 3)
        {
          uint64_t v46 = 1;
          int v53 = *(_DWORD *)(a1 + 28) - *v55 + UkEngine::getTonePosition(a1, v41, 1);
          UkEngine::markChange((_DWORD *)a1, v53);
          *(_DWORD *)(a1 + 36 * v53 + 3168) = v12;
          return v46;
        }
LABEL_37:
        uint64_t v18 = *(void *)(a1 + 8);
        goto LABEL_38;
      default:
        goto LABEL_37;
    }
  }
  *int v9 = xmmword_1E4154BA0;
  __keCGFloat y = v8;
  uint64_t v64 = -1;
  int v16 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
  if (v16) {
    int v17 = v16[3];
  }
  else {
    int v17 = -1;
  }
  *(_DWORD *)(a1 + 36 * v4 + 3160) = v17;
  uint64_t v18 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v18 + 4))
  {
LABEL_38:
    if (*(_DWORD *)(v18 + 2104) != 6)
    {
      uint64_t v45 = *v13;
      if (v45 <= 0x7F)
      {
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v45 + 60) & 0x100) != 0) {
          return 0;
        }
      }
      else if (__maskrune(v45, 0x100uLL))
      {
        return 0;
      }
    }
    int v47 = *(_DWORD *)(a1 + 28);
    int v48 = *(_DWORD *)(a1 + 16);
    if (v48 > v47)
    {
      int v49 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, *(_DWORD *)(a1 + 28), v48 - 1);
      *(_DWORD *)(a1 + 16) = v47;
      *(_DWORD *)(a1 + 20) = v49;
    }
    return 1;
  }
  return 0;
}

_DWORD *UkEngine::markChange(_DWORD *this, int a2)
{
  int v2 = this[4];
  if (v2 > a2)
  {
    uint64_t v4 = this;
    this = (_DWORD *)UkEngine::getSeqSteps((UkEngine *)this, a2, v2 - 1);
    int v5 = v4[5] + this;
    v4[4] = a2;
    v4[5] = v5;
  }
  return this;
}

uint64_t UkEngine::macroMatch(uint64_t a1, uint64_t a2)
{
  v44[8] = *MEMORY[0x1E4F143B8];
  int v41 = 0;
  int v42 = 0;
  if (!*(void *)a1
    || ((*(void (**)(int *, int *))a1)(&v41, &v42), !v41)
    || (uint64_t result = 0, v5 = *(_DWORD *)(a2 + 12), v5 != 13) && v5 != 32)
  {
    int v6 = *(_DWORD *)(a1 + 28);
    if ((v6 & 0x80000000) == 0)
    {
      while (1)
      {
        int v7 = *(_DWORD *)(a1 + 28);
        int v8 = v7 - v6;
        if (v7 - v6 > 14) {
          return 0;
        }
        while (1)
        {
          int v9 = *(_DWORD *)(a1 + 36 * v6 + 3144);
          if (v9 == 1) {
            break;
          }
          if (v8 > 14) {
            return 0;
          }
          ++v8;
          BOOL v10 = v6-- <= 0;
          if (v10)
          {
            int v6 = -1;
            goto LABEL_19;
          }
        }
        int v11 = *(_DWORD *)(a1 + 36 * v6 + 3172);
        int v12 = (_DWORD *)(a1 + 36 * v6);
        if (v11 == -1)
        {
          int v14 = v12[794];
        }
        else
        {
          int v13 = v12[791] ? 0xFFFF : 0x10000;
          int v14 = v11 + v13 + 2 * v12[792];
        }
        __key[0] = v14;
LABEL_19:
        int v15 = v7 - v6;
        if (v7 <= v6)
        {
          int v16 = v7 + 1;
        }
        else
        {
          int v16 = v7 + 1;
          int v17 = (int *)(a1 + 3212 + 36 * v6);
          uint64_t v18 = (int *)v44;
          do
          {
            int v19 = *(v17 - 1);
            if (v19 == -1)
            {
              int v21 = *v17;
            }
            else
            {
              if (*(v17 - 3)) {
                int v20 = 0xFFFF;
              }
              else {
                int v20 = 0x10000;
              }
              int v21 = v19 + v20 + 2 * *(v17 - 2);
            }
            *v18++ = v21;
            v17 += 9;
            --v15;
          }
          while (v15);
        }
        __key[v16 - v6] = 0;
        uint64_t v22 = *(void *)(a1 + 8);
        uint64_t v23 = v22 + 10300;
        MacCompareStartMem = v22 + 10300;
        int v24 = (int *)bsearch(v44, (const void *)(v22 + 2108), *(int *)(v22 + 141372), 8uLL, (int (__cdecl *)(const void *, const void *))macKeyCompare);
        if (v24) {
          break;
        }
        if (v9 == 1)
        {
          uint64_t v25 = *(void *)(a1 + 8);
          uint64_t v26 = v25 + 10300;
          MacCompareStartMem = v25 + 10300;
          int v27 = (int *)bsearch(__key, (const void *)(v25 + 2108), *(int *)(v25 + 141372), 8uLL, (int (__cdecl *)(const void *, const void *))macKeyCompare);
          if (v27)
          {
            int v28 = (unsigned __int8 *)(v26 + v27[1]);
            goto LABEL_39;
          }
        }
        BOOL v10 = v6-- <= 0;
        if (v10) {
          return 0;
        }
      }
      int v28 = (unsigned __int8 *)(v23 + v24[1]);
      ++v6;
LABEL_39:
      int v29 = *(_DWORD *)(a1 + 16);
      if (v29 > v6)
      {
        int v30 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v6, v29 - 1);
        *(_DWORD *)(a1 + 16) = v6;
        *(_DWORD *)(a1 + 20) = v30;
      }
      uint64_t v31 = 0;
      do
        int v32 = v31;
      while (*(_DWORD *)&v28[4 * v31++]);
      int v39 = **(_DWORD **)(a1 + 3128);
      int v40 = 4 * v32;
      VnConvert(7, *(_DWORD *)(*(void *)(a1 + 8) + 2104), v28, *(void *)(a1 + 3120), &v40, &v39);
      int v34 = v39;
      int v35 = *(int **)(a1 + 3128);
      if (*v35 > v39)
      {
        int v39 = *v35 - v39;
        int v36 = *(_DWORD *)(a2 + 8);
        if (v36 == -1) {
          int v37 = *(_DWORD *)(a2 + 12);
        }
        else {
          int v37 = v36 + 0x10000;
        }
        int v38 = v37;
        int v40 = 4;
        VnConvert(7, *(_DWORD *)(*(void *)(a1 + 8) + 2104), (unsigned __int8 *)&v38, *(void *)(a1 + 3120) + v34, &v40, &v39);
        v34 += v39;
        int v35 = *(int **)(a1 + 3128);
      }
      *(_DWORD *)(a1 + 3112) = -1;
      *(void *)(a1 + 28) = 0xFFFFFFFFLL;
      *(unsigned char *)(a1 + 3116) = 0;
      uint64_t result = 1;
      *(unsigned char *)(a1 + 3136) = 1;
      *int v35 = v34;
      return result;
    }
    return 0;
  }
  return result;
}

BOOL UkEngine::lastWordIsNonVn(UkEngine *this)
{
  unsigned int v1 = *((_DWORD *)this + 7);
  if ((v1 & 0x80000000) != 0) {
    return 0;
  }
  int v3 = *((_DWORD *)this + 9 * v1 + 786);
  BOOL result = 1;
  switch(v3)
  {
    case 0:
      return result;
    case 3:
    case 4:
      return *((_DWORD *)&VSeqList + 13 * *((int *)this + 9 * v1 + 790) + 1) == 0;
    case 5:
    case 6:
      unsigned int v5 = v1 - *((_DWORD *)this + 9 * v1 + 788);
      unsigned int v6 = *((_DWORD *)this + 9 * (int)v5 + 790);
      int v7 = (_DWORD *)((char *)&VSeqList + 52 * (int)v6);
      if (!v7[1]) {
        return result;
      }
      int v8 = (char *)this + 36 * v1;
      unsigned int v9 = *((_DWORD *)v8 + 790);
      int v10 = *((_DWORD *)v8 + 787);
      int v11 = v10 == -1 ? -1 : *((_DWORD *)this + 9 * (int)(v1 - v10) + 790);
      int valid = isValidCVC(v11, *((_DWORD *)this + 9 * (int)v5 + 790), v9);
      BOOL result = 1;
      if (!valid) {
        return result;
      }
      BOOL v13 = v9 > 0x18 || ((1 << v9) & 0x1040006) == 0;
      if (v13
        || (*((_DWORD *)this
                          + 9 * (int)(v5 + UkEngine::getTonePosition((uint64_t)this, v6, 0) - *v7 + 1)
                          + 792)
                        - 2) >= 3)
      {
        return 0;
      }
      BOOL result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t UkEngine::restoreKeyStrokes(uint64_t a1, _DWORD *a2, uint64_t a3, _DWORD *a4, _DWORD *a5)
{
  *a5 = 1;
  if ((UkEngine::lastWordHasVnMark((UkEngine *)a1) & 1) == 0) {
    goto LABEL_17;
  }
  int v9 = *(_DWORD *)(a1 + 28);
  *(void *)(a1 + 16) = (v9 + 1);
  int v10 = *(_DWORD *)(a1 + 3112);
  if (v10 < 0) {
    goto LABEL_17;
  }
  char v11 = 0;
  while (*(_DWORD *)(a1 + 24 * v10 + 44) != 1)
  {
    v11 |= *(unsigned char *)(a1 + 24 * v10 + 60) != 0;
    BOOL v12 = v10-- <= 0;
    if (v12)
    {
      int v10 = -1;
      break;
    }
  }
  if (v11)
  {
    if (v9 < 0) {
      goto LABEL_18;
    }
    int v13 = v9;
    while (*(_DWORD *)(a1 + 36 * v13 + 3144) != 1)
    {
      *(_DWORD *)(a1 + 28) = v13 - 1;
      BOOL v12 = v13-- <= 0;
      if (v12)
      {
        int v13 = -1;
        break;
      }
    }
    if (v9 <= v13)
    {
LABEL_18:
      int v15 = 0;
    }
    else
    {
      int v14 = v13 + 1;
      int v15 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, v13 + 1, v9);
      *(_DWORD *)(a1 + 16) = v14;
      *(_DWORD *)(a1 + 20) = v15;
    }
    *a2 = v15;
    *(unsigned char *)(a1 + 3139) = 1;
    if (v10 >= *(_DWORD *)(a1 + 3112))
    {
      int v17 = 0;
    }
    else
    {
      int v17 = 0;
      uint64_t v18 = v10;
      uint64_t v19 = a1 + 24 * v10 + 76;
      do
      {
        if (v17 < *a4) {
          *(unsigned char *)(a3 + v17++) = *(_DWORD *)v19;
        }
        ++v18;
        *(unsigned char *)(v19 + 8) = 0;
        UkEngine::processAppend((UkEngine *)a1);
        v19 += 24;
      }
      while (v18 < *(int *)(a1 + 3112));
    }
    *a4 = v17;
    *(unsigned char *)(a1 + 3139) = 0;
    return 1;
  }
  else
  {
LABEL_17:
    uint64_t result = 0;
    *a2 = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t UkEngine::lastWordHasVnMark(UkEngine *this)
{
  unsigned int v1 = *((_DWORD *)this + 7);
  if ((v1 & 0x80000000) == 0)
  {
    while (*((_DWORD *)this + 9 * v1 + 786) != 1)
    {
      int v2 = v1;
      uint64_t v3 = *((int *)this + 9 * v1 + 793);
      if (v3 != -1
        && (*((unsigned char *)&IsVnVowel + v3) && *((_DWORD *)this + 9 * v2 + 792)
         || v3 != StdVnRootChar[v3]))
      {
        return 1;
      }
      unsigned int v1 = v2 - 1;
      if (v2 <= 0) {
        return 0;
      }
    }
  }
  return 0;
}

uint64_t UkEngine::processHookWithUO(UkEngine *this, _DWORD *a2)
{
  int v3 = *((_DWORD *)this + 7);
  int v4 = *((_DWORD *)this + 9 * v3 + 788);
  if (!*(_DWORD *)(*((void *)this + 1) + 12) && v4)
  {
    return UkEngine::processAppend(this, a2);
  }
  unsigned int v6 = *((_DWORD *)this + 9 * (v3 - v4) + 790);
  int v7 = (int *)((char *)&VSeqList + 52 * (int)v6);
  int v10 = *v7;
  int v9 = v7 + 3;
  int v8 = v10;
  int v63 = v3 - v4;
  int v11 = v3 - v4 - v10 + 1;
  int TonePosition = UkEngine::getTonePosition((uint64_t)this, v6, v4 == 0);
  int v61 = v11 + TonePosition;
  int v62 = TonePosition;
  int v13 = (char *)this + 36 * v11 + 36 * TonePosition + 3144;
  int v16 = *((_DWORD *)v13 + 6);
  int v15 = v13 + 24;
  int v14 = v16;
  if (*a2 == 7)
  {
    int v22 = v9[1];
    if (v22 != 109 && v22 != 97)
    {
      int v32 = v9[2];
      __keCGFloat y = 0x610000008FLL;
      int v65 = v32;
      int v33 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v33) {
        unsigned int v20 = v33[3];
      }
      else {
        unsigned int v20 = -1;
      }
      int v19 = v14;
      int v42 = v62;
      int v41 = v63;
      if (*v9 != 155)
      {
        int v26 = v11 + 1;
        int v57 = *((_DWORD *)this + 4);
        if (v57 > v11 + 1)
        {
          int v58 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v57 - 1);
          *((_DWORD *)this + 4) = v26;
          *((_DWORD *)this + 5) = v58;
        }
        goto LABEL_57;
      }
LABEL_54:
      int v46 = *((_DWORD *)this + 4);
      if (v46 > v11)
      {
        int v47 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v46 - 1);
        *((_DWORD *)this + 4) = v11;
        *((_DWORD *)this + 5) = v47;
      }
      *((_DWORD *)this + 9 * v11 + 793) = 143;
      int v26 = v11 + 1;
LABEL_57:
      int v27 = 1;
      int v34 = 97;
      goto LABEL_58;
    }
    if (v4 || v8 != 2 || *((_DWORD *)this + 9 * v3 + 786) != 4 || *((_DWORD *)this + 9 * v3 + 772) != 25)
    {
      int v23 = v9[2];
      __keCGFloat y = 0x790000009BLL;
      int v65 = v23;
      int v24 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v24) {
        unsigned int v20 = v24[3];
      }
      else {
        unsigned int v20 = -1;
      }
      int v19 = v14;
      if (*v9 == 143)
      {
        int v40 = *((_DWORD *)this + 4);
        int v42 = v62;
        int v41 = v63;
        if (v40 > v11)
        {
          int v43 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v40 - 1);
          *((_DWORD *)this + 4) = v11;
          *((_DWORD *)this + 5) = v43;
        }
        int v27 = 0;
        *((_DWORD *)this + 9 * v11 + 793) = 155;
        int v26 = v11 + 1;
      }
      else
      {
        int v26 = v11 + 1;
        int v44 = *((_DWORD *)this + 4);
        int v42 = v62;
        int v41 = v63;
        int v27 = 0;
        if (v44 > v11 + 1)
        {
          int v45 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v44 - 1);
          *((_DWORD *)this + 4) = v26;
          *((_DWORD *)this + 5) = v45;
        }
      }
      int v34 = 121;
      goto LABEL_58;
    }
    goto LABEL_30;
  }
  if (*a2 == 6)
  {
    if (*v9 != 143)
    {
      int v17 = v9[2];
      __keCGFloat y = 0x610000008FLL;
      int v65 = v17;
      uint64_t v18 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      int v19 = v14;
      if (v18) {
        unsigned int v20 = v18[3];
      }
      else {
        unsigned int v20 = -1;
      }
      int v42 = v62;
      int v41 = v63;
      goto LABEL_54;
    }
    goto LABEL_27;
  }
  int v25 = v9[1];
  if (*v9 != 143)
  {
    if (v25 != 97)
    {
      int v38 = v9[2];
      __keCGFloat y = 0x610000008FLL;
      int v65 = v38;
      int v39 = bsearch(&__key, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
      if (v39) {
        unsigned int v20 = v39[3];
      }
      else {
        unsigned int v20 = -1;
      }
      int v19 = v14;
      int v42 = v62;
      int v41 = v63;
      int v59 = *((_DWORD *)this + 4);
      if (v59 > v11)
      {
        int v60 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v59 - 1);
        *((_DWORD *)this + 4) = v11;
        *((_DWORD *)this + 5) = v60;
      }
      *((_DWORD *)this + 9 * v11 + 793) = 143;
      int v26 = v11 + 1;
      int v27 = 1;
      int v34 = 97;
      goto LABEL_58;
    }
LABEL_30:
    unsigned int v20 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    int v26 = v11 + 1;
    int v30 = *((_DWORD *)this + 4);
    int v27 = 0;
    if (v30 > v11 + 1)
    {
      int v31 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11 + 1, v30 - 1);
      *((_DWORD *)this + 4) = v26;
      *((_DWORD *)this + 5) = v31;
    }
    goto LABEL_49;
  }
  if (v25 != 109 && v25 != 97)
  {
LABEL_27:
    unsigned int v20 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    int v28 = *((_DWORD *)this + 4);
    int v19 = v14;
    int v27 = 0;
    if (v28 > v11)
    {
      int v29 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v28 - 1);
      *((_DWORD *)this + 4) = v11;
      *((_DWORD *)this + 5) = v29;
    }
    int v34 = 155;
    int v26 = v11;
    goto LABEL_50;
  }
  if (!v4
    && (v6 & 0xFFFFFFFE) == 0x24
    && *((_DWORD *)this + 9 * v3 + 786) == 4
    && *((_DWORD *)this + 9 * v3 + 772) == 25)
  {
    int v26 = v11 + 1;
    UkEngine::markChange(this, v11 + 1);
    int v27 = 0;
    unsigned int v20 = 38;
  }
  else
  {
    int v35 = *((_DWORD *)&VSeqList + 13 * (int)v6 + 12);
    int v36 = *((_DWORD *)this + 4);
    if (v36 > v11)
    {
      int v37 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v11, v36 - 1);
      *((_DWORD *)this + 4) = v11;
      *((_DWORD *)this + 5) = v37;
    }
    int v27 = 0;
    *((_DWORD *)this + 9 * v11 + 793) = 155;
    unsigned int v20 = *((_DWORD *)&VSeqList + 13 * v35 + 12);
    int v26 = v11 + 1;
  }
LABEL_49:
  int v34 = 121;
  int v19 = v14;
LABEL_50:
  int v42 = v62;
  int v41 = v63;
LABEL_58:
  *((_DWORD *)this + 9 * v26 + 793) = v34;
  int v48 = (int *)((char *)&VSeqList + 52 * (int)v20);
  if (*v48 >= 1)
  {
    uint64_t v49 = 0;
    int v50 = (_DWORD *)((char *)this + 36 * v11 + 3160);
    do
    {
      *int v50 = *((_DWORD *)&VSeqList + 13 * (int)v20 + v49 + 6);
      v50 += 9;
      ++v49;
    }
    while (v49 < *v48);
  }
  int v51 = UkEngine::getTonePosition((uint64_t)this, v20, v41 == *((_DWORD *)this + 7));
  if (v42 != v51 && v19 != 0)
  {
    int v53 = v51 + v11;
    int v54 = *((_DWORD *)this + 4);
    if (v54 > v53)
    {
      int v55 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v53, v54 - 1);
      *((_DWORD *)this + 4) = v53;
      *((_DWORD *)this + 5) = v55;
      int v54 = v53;
    }
    *((_DWORD *)this + 9 * v53 + 792) = v19;
    if (v54 > v61)
    {
      int v56 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v61, v54 - 1);
      *((_DWORD *)this + 4) = v61;
      *((_DWORD *)this + 5) = v56;
    }
    *int v15 = 0;
  }
  if (v27)
  {
    *((_DWORD *)this + 8) = 0;
    UkEngine::processAppend(this, a2);
    *((unsigned char *)this + 3137) = 1;
  }
  return 1;
}

uint64_t UkEngine::processHook(UkEngine *this, int *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (!*(_DWORD *)(v4 + 4)) {
    goto LABEL_60;
  }
  unsigned int v5 = *((_DWORD *)this + 7);
  if ((v5 & 0x80000000) != 0) {
    goto LABEL_60;
  }
  int v6 = *((_DWORD *)this + 9 * v5 + 788);
  if (v6 < 0) {
    goto LABEL_60;
  }
  int v7 = v5 - v6;
  unsigned int v8 = *((_DWORD *)this + 9 * (int)(v5 - v6) + 790);
  int v9 = (int *)((char *)&VSeqList + 52 * (int)v8);
  int v10 = v9 + 3;
  int v11 = *a2;
  BOOL v12 = *v9 < 2 || v11 == 8;
  if (!v12 && (*v10 == 155 || *v10 == 143))
  {
    unsigned int v13 = v9[4] - 97;
    BOOL v14 = v13 > 0x18;
    int v15 = (1 << v13) & 0x1001001;
    if (!v14 && v15 != 0)
    {
      return UkEngine::processHookWithUO(this, a2);
    }
  }
  int v18 = v7 - *v9 + 1;
  int TonePosition = UkEngine::getTonePosition((uint64_t)this, v8, v6 == 0);
  int v20 = TonePosition + v18;
  int v21 = *((_DWORD *)this + 9 * TonePosition + 9 * v18 + 792);
  int v22 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 12);
  if (v22 != -1)
  {
    unsigned int v23 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 12);
    switch(v11)
    {
      case 5:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) == 25) {
          goto LABEL_60;
        }
        break;
      case 6:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 155) {
          goto LABEL_60;
        }
        break;
      case 7:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 121) {
          goto LABEL_60;
        }
        break;
      case 8:
        if (*((_DWORD *)&VSeqList + 13 * v22 + *((int *)&VSeqList + 13 * v22 + 11) + 3) != 25) {
          goto LABEL_60;
        }
        break;
      default:
        break;
    }
    int v31 = *((_DWORD *)this + 9 * v5 + 787);
    int v61 = TonePosition;
    if (v31 == -1) {
      int v32 = -1;
    }
    else {
      int v32 = *((_DWORD *)this + 9 * (int)(v5 - v31) + 790);
    }
    int v33 = *((_DWORD *)this + 9 * v5 + 789);
    int v60 = v20;
    int v59 = (char *)this + 36 * v20;
    int v34 = v21;
    if (v33 == -1) {
      int v35 = -1;
    }
    else {
      int v35 = *((_DWORD *)this + 9 * (int)(v5 - v33) + 790);
    }
    if (isValidCVC(v32, v22, v35))
    {
      int v36 = (char *)&VSeqList + 52 * v22;
      int v39 = *((_DWORD *)v36 + 11);
      int v38 = (int *)(v36 + 44);
      int v37 = v39;
      int v40 = v39 + v18;
      if (*(_DWORD *)(*((void *)this + 1) + 12) || v40 == *((_DWORD *)this + 7))
      {
        int v41 = *((_DWORD *)this + 4);
        if (v41 > v40)
        {
          int v42 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v40, v41 - 1);
          *((_DWORD *)this + 4) = v40;
          *((_DWORD *)this + 5) = v42;
          int v37 = *v38;
        }
        *((_DWORD *)this + 9 * v40 + 793) = *((_DWORD *)&VSeqList + 13 * v22 + v37 + 3);
        unsigned int v43 = v22;
        goto LABEL_70;
      }
    }
LABEL_60:
    return UkEngine::processAppend(this, a2);
  }
  int v24 = *((_DWORD *)&VSeqList + 13 * (int)v8 + 11);
  if (v24 == -1) {
    goto LABEL_60;
  }
  int v25 = v24 + v18;
  int v26 = (char *)this + 36 * v24 + 36 * v18;
  int v27 = *((_DWORD *)v26 + 793);
  int v28 = v27 == 155 ? 143 : 97;
  int v29 = v27 == 25 ? 1 : v28;
  if (v25 != v5 && *(_DWORD *)(v4 + 12) == 0) {
    goto LABEL_60;
  }
  switch(v11)
  {
    case 8:
      if (v27 != 25) {
        goto LABEL_60;
      }
      break;
    case 7:
      if (v27 != 121) {
        goto LABEL_60;
      }
      break;
    case 6:
      if (v27 != 155) {
        goto LABEL_60;
      }
      break;
    default:
      if (v11 == 5 && v27 == 25) {
        goto LABEL_60;
      }
      break;
  }
  int v60 = TonePosition + v18;
  int v61 = TonePosition;
  int v59 = (char *)this + 36 * v20;
  int v34 = *((_DWORD *)this + 9 * TonePosition + 9 * v18 + 792);
  int v44 = (int *)(v26 + 3172);
  UkEngine::markChange(this, v25);
  int *v44 = v29;
  if (*v9 == 2)
  {
    uint64_t v49 = (char *)this + 36 * v18;
    int v46 = *((_DWORD *)v49 + 793);
    int v47 = *((_DWORD *)v49 + 802);
LABEL_68:
    int v48 = -1;
    goto LABEL_69;
  }
  if (*v9 != 3)
  {
    int v46 = *((_DWORD *)this + 9 * v18 + 793);
    int v47 = -1;
    goto LABEL_68;
  }
  int v45 = (_DWORD *)((char *)this + 36 * v18);
  int v46 = v45[793];
  int v47 = v45[802];
  int v48 = v45[811];
LABEL_69:
  unsigned int v43 = lookupVSeq(v46, v47, v48);
  unsigned int v23 = v43;
LABEL_70:
  int v50 = (int *)((char *)&VSeqList + 52 * (int)v23);
  if (*v50 >= 1)
  {
    uint64_t v51 = 0;
    int v52 = (_DWORD *)((char *)this + 36 * v18 + 3160);
    do
    {
      _DWORD *v52 = *((_DWORD *)&VSeqList + 13 * (int)v23 + v51 + 6);
      v52 += 9;
      ++v51;
    }
    while (v51 < *v50);
  }
  int v53 = UkEngine::getTonePosition((uint64_t)this, v43, v7 == *((_DWORD *)this + 7));
  if (v61 != v53 && v34 != 0)
  {
    int v55 = v53 + v18;
    int v56 = *((_DWORD *)this + 4);
    if (v56 > v53 + v18)
    {
      int v57 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v55, v56 - 1);
      *((_DWORD *)this + 4) = v55;
      *((_DWORD *)this + 5) = v57;
      int v56 = v55;
    }
    *((_DWORD *)this + 9 * v55 + 792) = v34;
    if (v56 > v60)
    {
      int v58 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v60, v56 - 1);
      *((_DWORD *)this + 4) = v60;
      *((_DWORD *)this + 5) = v58;
    }
    *((_DWORD *)v59 + 792) = 0;
  }
  if (v22 == -1)
  {
    *((_DWORD *)this + 8) = 0;
    UkEngine::processAppend(this, a2);
    *((unsigned char *)this + 3137) = 1;
  }
  return 1;
}

uint64_t UkEngine::processTone(UkEngine *this, _DWORD *a2)
{
  unsigned int v4 = *((_DWORD *)this + 7);
  if ((v4 & 0x80000000) == 0)
  {
    unsigned int v5 = (_DWORD *)*((void *)this + 1);
    if (v5[1])
    {
      int v6 = *((_DWORD *)this + 9 * v4 + 786);
      if (v6 == 2 && (int v7 = *((_DWORD *)this + 9 * v4 + 790), (v7 & 0xFFFFFFFE) == 8))
      {
        int v8 = v4 - (v7 != 8);
        int v9 = (char *)this + 36 * v8;
        int v10 = *((_DWORD *)v9 + 792);
        int v11 = a2[4];
        if (v10 | v11)
        {
          BOOL v12 = (int *)(v9 + 3168);
          int v13 = *((_DWORD *)this + 4);
          if (v13 > v8)
          {
            int v14 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v8, v13 - 1);
            *((_DWORD *)this + 4) = v8;
            *((_DWORD *)this + 5) = v14;
            int v10 = *v12;
            int v11 = a2[4];
          }
          if (v10 != v11)
          {
LABEL_30:
            *BOOL v12 = v11;
            return 1;
          }
          goto LABEL_27;
        }
      }
      else
      {
        int v15 = *((_DWORD *)this + 9 * v4 + 788);
        if ((v15 & 0x80000000) == 0)
        {
          int v16 = v4 - v15;
          unsigned int v17 = *((_DWORD *)this + 9 * (int)(v4 - v15) + 790);
          if (!v5[10] || v5[3] || *((_DWORD *)&VSeqList + 13 * (int)v17 + 1))
          {
            if ((v6 - 5) > 1
              || ((unsigned int v18 = *((_DWORD *)this + 9 * v4 + 790), v19 = v18 > 0x18, v20 = (1 << v18) & 0x1040006, !v19)
                ? (BOOL v21 = v20 == 0)
                : (BOOL v21 = 1),
                  v21 || (a2[4] - 2) > 2))
            {
              int v22 = v16
                  + UkEngine::getTonePosition((uint64_t)this, v17, v15 == 0)
                  - *((_DWORD *)&VSeqList + 13 * (int)v17)
                  + 1;
              unsigned int v23 = (char *)this + 36 * v22;
              int v24 = *((_DWORD *)v23 + 792);
              int v11 = a2[4];
              if (v24 | v11)
              {
                BOOL v12 = (int *)(v23 + 3168);
                int v26 = *((_DWORD *)this + 4);
                if (v24 != v11)
                {
                  if (v26 > v22)
                  {
                    int v28 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v22, v26 - 1);
                    *((_DWORD *)this + 4) = v22;
                    *((_DWORD *)this + 5) = v28;
                    int v11 = a2[4];
                  }
                  goto LABEL_30;
                }
                if (v26 > v22)
                {
                  int v27 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v22, v26 - 1);
                  *((_DWORD *)this + 4) = v22;
                  *((_DWORD *)this + 5) = v27;
                }
LABEL_27:
                *BOOL v12 = 0;
                *((_DWORD *)this + 8) = 0;
                UkEngine::processAppend(this, a2);
                *((unsigned char *)this + 3137) = 1;
                return 1;
              }
            }
          }
        }
      }
    }
  }

  return UkEngine::processAppend(this, a2);
}

uint64_t UkEngine::processDd(UkEngine *this, _DWORD *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (*(_DWORD *)(v4 + 4))
  {
    unsigned int v5 = *((_DWORD *)this + 7);
    if ((v5 & 0x80000000) == 0)
    {
      int v6 = (char *)this + 36 * v5;
      if (!*((_DWORD *)v6 + 786))
      {
        int v7 = (char *)this + 36 * v5;
        if (*((_DWORD *)v7 + 793) == 41)
        {
          uint64_t v8 = *((int *)this + 9 * (int)(v5 - 1) + 793);
          if (v8 == -1 || !*((unsigned char *)&IsVnVowel + v8))
          {
            unsigned int v17 = v6 + 3144;
            unsigned int v18 = v7 + 3172;
            *((_DWORD *)this + 8) = 1;
            signed int v19 = *((_DWORD *)this + 4);
            if (v19 > (int)v5)
            {
              int v20 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v5, v19 - 1);
              *((_DWORD *)this + 4) = v5;
              *((_DWORD *)this + 5) = v20;
            }
            *((_DWORD *)this + 9 * v5 + 790) = 4;
            *unsigned int v18 = 43;
            *unsigned int v17 = xmmword_1E4154B80;
            return 1;
          }
        }
      }
      int v9 = *((_DWORD *)this + 9 * v5 + 787);
      if ((v9 & 0x80000000) == 0)
      {
        int v10 = *(_DWORD *)(v4 + 12);
        if (!v9 || v10 != 0)
        {
          int v12 = v5 - v9;
          int v13 = (_DWORD *)((char *)this + 36 * v12 + 3160);
          if (*v13 == 4)
          {
            int v21 = *((_DWORD *)this + 4);
            if (v21 > v12)
            {
              int v22 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v21 - 1);
              *((_DWORD *)this + 4) = v12;
              *((_DWORD *)this + 5) = v22;
            }
            *int v13 = 3;
            *((_DWORD *)this + 9 * v12 + 793) = 41;
            *((_DWORD *)this + 8) = 0;
            UkEngine::processAppend(this, a2);
            *((unsigned char *)this + 3137) = 1;
            return 1;
          }
          if (*v13 == 3)
          {
            int v14 = *((_DWORD *)this + 4);
            if (v14 > v12)
            {
              int v15 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v12, v14 - 1);
              *((_DWORD *)this + 4) = v12;
              *((_DWORD *)this + 5) = v15;
            }
            *int v13 = 4;
            *((_DWORD *)this + 9 * v12 + 793) = 43;
            return 1;
          }
        }
      }
    }
  }

  return UkEngine::processAppend(this, a2);
}

uint64_t UkEngine::processMapChar(UkEngine *this, _DWORD *a2)
{
  uint64_t v37 = 0;
  if (*(void *)this)
  {
    (*(void (**)(uint64_t *, char *))this)(&v37, (char *)&v37 + 4);
    if (HIDWORD(v37))
    {
      int v4 = a2[2];
      int v5 = v4 - 1;
      if ((v4 & 1) == 0) {
        int v5 = v4 + 1;
      }
      if (v4 == -1) {
        int v6 = -1;
      }
      else {
        int v6 = v5;
      }
      a2[2] = v6;
    }
  }
  uint64_t result = UkEngine::processAppend(this, a2);
  if (*(_DWORD *)(*((void *)this + 1) + 4))
  {
    unsigned int v8 = *((_DWORD *)this + 7);
    if ((v8 & 0x80000000) != 0) {
      return 0;
    }
    if (*((_DWORD *)this + 9 * v8 + 786) > 1u) {
      return 1;
    }
    uint64_t v9 = (int)v8 - 1;
    *((_DWORD *)this + 7) = v9;
    int v10 = (char *)this + 36 * v9;
    if (*((_DWORD *)v10 + 786) < 2u) {
      goto LABEL_24;
    }
    int v11 = (char *)this + 36 * v9;
    int v12 = *((_DWORD *)v11 + 793);
    if (*((_DWORD *)v11 + 791))
    {
      int v13 = v12 - 1;
      if (v12 == a2[2])
      {
        a2[2] = v13;
        a2[3] = __toupper(a2[3]);
      }
    }
    else
    {
      int v13 = *((_DWORD *)v11 + 793);
    }
    if (v13 == a2[2])
    {
      int v14 = *((_DWORD *)v10 + 786);
      int v15 = *((_DWORD *)this + 7);
      if (v14 == 2)
      {
        int v16 = *((_DWORD *)this + 4);
        if (v16 > v15)
        {
          int v17 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, *((_DWORD *)this + 7), v16 - 1);
          *((_DWORD *)this + 4) = v15;
          *((_DWORD *)this + 5) = v17;
          int v15 = *((_DWORD *)this + 7);
        }
        *((_DWORD *)this + 7) = v15 - 1;
        goto LABEL_34;
      }
      int v19 = *((_DWORD *)this + 9 * v9 + 788);
      unsigned int v20 = *((_DWORD *)this + 9 * (v15 - v19) + 790);
      int v21 = v15 - v19 - *((_DWORD *)&VSeqList + 13 * (int)v20) + 1;
      int TonePosition = UkEngine::getTonePosition((uint64_t)this, v20, v19 == 0);
      unsigned int v23 = (char *)this + 36 * v21 + 36 * TonePosition + 3144;
      int v26 = *((_DWORD *)v23 + 6);
      int v24 = v23 + 24;
      int v25 = v26;
      int v27 = *((_DWORD *)this + 4);
      if (v27 > v15)
      {
        int v28 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v15, v27 - 1);
        *((_DWORD *)this + 4) = v15;
        *((_DWORD *)this + 5) = v28;
        int v15 = *((_DWORD *)this + 7);
      }
      unsigned int v29 = v15 - 1;
      *((_DWORD *)this + 7) = v15 - 1;
      if (v25) {
        BOOL v30 = v15 < 1;
      }
      else {
        BOOL v30 = 1;
      }
      if (v30 || (*((_DWORD *)this + 9 * v29 + 786) - 3) > 1) {
        goto LABEL_34;
      }
      int v18 = 1;
      int v31 = UkEngine::getTonePosition((uint64_t)this, *((_DWORD *)this + 9 * v29 + 790), 1);
      if (v31 != TonePosition)
      {
        int v32 = v31 + v21;
        UkEngine::markChange(this, v31 + v21);
        *((_DWORD *)this + 9 * v32 + 792) = v25;
        UkEngine::markChange(this, v21 + TonePosition);
        _DWORD *v24 = 0;
LABEL_34:
        int v18 = 1;
      }
    }
    else
    {
LABEL_24:
      int v18 = 0;
    }
    *a2 = 19;
    uint64_t v33 = (int)a2[3];
    uint64_t v34 = a2[3];
    if (v33 < 0x100)
    {
      int v36 = UkcMap[v34];
      int v35 = IsoVnLexiMap[v33];
    }
    else if ((int)v34 <= 255)
    {
      int v35 = IsoVnLexiMap[v33];
      int v36 = 2 * (v35 == -1);
    }
    else
    {
      int v35 = -1;
      int v36 = 2;
    }
    a2[1] = v36;
    a2[2] = v35;
    uint64_t result = UkEngine::processAppend(this, a2);
    if (v18)
    {
      *((_DWORD *)this + 8) = 0;
      uint64_t result = 1;
      *((unsigned char *)this + 3137) = 1;
    }
  }
  return result;
}

uint64_t UkEngine::processTelexW(UkEngine *this, int *a2)
{
  if (*(_DWORD *)(*((void *)this + 1) + 4))
  {
    uint64_t v15 = 0;
    if (*(void *)this) {
      (*(void (**)(uint64_t *, char *))this)(&v15, (char *)&v15 + 4);
    }
    if (UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar == 1)
    {
      *a2 = 17;
      uint64_t v4 = a2[3];
      if (v4 <= 0x7F) {
        int v5 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x8000;
      }
      else {
        int v5 = __maskrune(v4, 0x8000uLL);
      }
      if (v5) {
        int v10 = 154;
      }
      else {
        int v10 = 155;
      }
      a2[2] = v10;
      if (HIDWORD(v15))
      {
        if (v10) {
          int v11 = v10 - 1;
        }
        else {
          int v11 = v10 + 1;
        }
        a2[2] = v11;
      }
      a2[1] = 0;
      if (UkEngine::processMapChar(this, a2)) {
        return 1;
      }
      int v12 = *((_DWORD *)this + 7);
      if ((v12 & 0x80000000) == 0) {
        *((_DWORD *)this + 7) = v12 - 1;
      }
      UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 0;
      *a2 = 4;
      return UkEngine::processHook(this, a2);
    }
    else
    {
      *a2 = 4;
      UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 0;
      if (UkEngine::processHook(this, a2)) {
        return 1;
      }
      int v7 = *((_DWORD *)this + 7);
      if ((v7 & 0x80000000) == 0) {
        *((_DWORD *)this + 7) = v7 - 1;
      }
      *a2 = 17;
      uint64_t v8 = a2[3];
      if (v8 <= 0x7F) {
        int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x8000;
      }
      else {
        int v9 = __maskrune(v8, 0x8000uLL);
      }
      if (v9) {
        int v13 = 154;
      }
      else {
        int v13 = 155;
      }
      a2[2] = v13;
      if (HIDWORD(v15))
      {
        if (v13) {
          int v14 = v13 - 1;
        }
        else {
          int v14 = v13 + 1;
        }
        a2[2] = v14;
      }
      a2[1] = 0;
      UkEngine::processTelexW(UkKeyEvent &)::usedAsMapChar = 1;
      return UkEngine::processMapChar(this, a2);
    }
  }
  else
  {
    return UkEngine::processAppend(this, a2);
  }
}

double UkEngine::reset(UkEngine *this)
{
  *((_DWORD *)this + 778) = -1;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)((char *)this + 28) = 0xFFFFFFFFLL;
  *((unsigned char *)this + 3116) = 0;
  return result;
}

uint64_t UkEngine::processEscChar(UkEngine *this, _DWORD *a2)
{
  if (*(_DWORD *)(*((void *)this + 1) + 4))
  {
    unsigned int v2 = *((_DWORD *)this + 7);
    if ((v2 & 0x80000000) == 0 && *((_DWORD *)this + 9 * v2 + 786) >= 2u) {
      *((unsigned char *)this + 3116) = 1;
    }
  }
  return UkEngine::processAppend(this, a2);
}

uint64_t UkEngine::pass(UkEngine *this, unsigned int a2)
{
  UkInputProcessor::keyCodeToEvent(*((void *)this + 1) + 48, a2, v4);
  return UkEngine::processAppend(this, v4);
}

uint64_t UkEngine::processNoSpellCheck(UkEngine *a1, _DWORD *a2)
{
  int v4 = *((_DWORD *)a1 + 7);
  int v5 = (_DWORD *)((char *)a1 + 36 * v4);
  int v6 = v5 + 786;
  uint64_t v7 = (int)v5[793];
  if (*((unsigned char *)&IsVnVowel + v7))
  {
    *int v6 = 3;
    *((_DWORD *)a1 + 9 * v4 + 788) = 0;
    int v17 = v7;
    uint64_t v18 = -1;
    uint64_t v8 = bsearch(&v17, &SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
    if (v8) {
      int v9 = v8[3];
    }
    else {
      int v9 = -1;
    }
    int v12 = (_DWORD *)((char *)a1 + 36 * v4);
    v12[790] = v9;
    v12[789] = -1;
    v12[787] = -1;
  }
  else
  {
    *(_OWORD *)int v6 = xmmword_1E4154B80;
    int v17 = v7;
    uint64_t v18 = -1;
    int v10 = bsearch(&v17, &SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    if (v10) {
      int v11 = v10[3];
    }
    else {
      int v11 = -1;
    }
    *((_DWORD *)a1 + 9 * v4 + 790) = v11;
  }
  if (*a2 == 19 && (*((_DWORD *)a1 + 9 * v4 + 794) & 0xFFFFFFDF) - 65 < 0x1A) {
    return 0;
  }
  int v14 = *((_DWORD *)a1 + 7);
  int v15 = *((_DWORD *)a1 + 4);
  if (v15 > v14)
  {
    int v16 = *((_DWORD *)a1 + 5) + UkEngine::getSeqSteps(a1, *((_DWORD *)a1 + 7), v15 - 1);
    *((_DWORD *)a1 + 4) = v14;
    *((_DWORD *)a1 + 5) = v16;
  }
  return 1;
}

uint64_t UkEngine::process(uint64_t a1, unsigned int a2, _DWORD *a3, unsigned __int8 *a4, int *a5, _DWORD *a6)
{
  UkEngine::prepareBuffer((_DWORD *)a1);
  int v12 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 16) = v12 + 1;
  *(_DWORD *)(a1 + 20) = 0;
  *(void *)(a1 + 3120) = a4;
  *(void *)(a1 + 3128) = a5;
  *(void *)(a1 + 3136) = 0;
  UkInputProcessor::keyCodeToEvent(*(void *)(a1 + 8) + 48, a2, &v24);
  if (!*(unsigned char *)(a1 + 3116))
  {
    uint64_t v17 = ((uint64_t (*)(uint64_t, long long *))UkEngine::process(unsigned int,int &,unsigned char *,int &,UkOutputType &)::UkKeyProcList[2 * (int)v24])(a1, &v24);
LABEL_8:
    uint64_t v16 = v17;
    goto LABEL_9;
  }
  *(unsigned char *)(a1 + 3116) = 0;
  if (v12 < 0 || (v24 & 0xFFFFFFFE) == 0x12)
  {
    uint64_t v17 = UkEngine::processAppend((UkEngine *)a1, &v24);
    goto LABEL_8;
  }
  *(_DWORD *)(a1 + 28) = v12 - 1;
  UkEngine::processAppend((UkEngine *)a1, &v24);
  unsigned int v13 = *(_DWORD *)(a1 + 28);
  int v14 = *(_DWORD *)(a1 + 16);
  if (v14 > (int)v13)
  {
    int v15 = *(_DWORD *)(a1 + 20) + UkEngine::getSeqSteps((UkEngine *)a1, *(_DWORD *)(a1 + 28), v14 - 1);
    *(_DWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 20) = v15;
    uint64_t v16 = 1;
LABEL_9:
    unsigned int v13 = *(_DWORD *)(a1 + 28);
    goto LABEL_10;
  }
  uint64_t v16 = 1;
LABEL_10:
  uint64_t v18 = *(void *)(a1 + 8);
  if (!*(_DWORD *)(v18 + 4)) {
    goto LABEL_16;
  }
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_27;
  }
  if (!(*(_DWORD *)(a1 + 36 * v13 + 3144) | DWORD1(v24)) && (!*(_DWORD *)(v18 + 40) || *(_DWORD *)(a1 + 32)))
  {
    uint64_t v16 = UkEngine::processNoSpellCheck((UkEngine *)a1, &v24);
    unsigned int v13 = *(_DWORD *)(a1 + 28);
LABEL_16:
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_27;
    }
  }
  if (HIDWORD(v24) < 0x100)
  {
    int v19 = UkcMap[HIDWORD(v24)];
  }
  else if (SHIDWORD(v24) > 255 || IsoVnLexiMap[SHIDWORD(v24)] == -1)
  {
    int v19 = 2;
  }
  else
  {
    int v19 = 0;
  }
  DWORD1(v24) = v19;
  uint64_t v20 = *(int *)(a1 + 3112) + 1;
  *(_DWORD *)(a1 + 3112) = v20;
  uint64_t v21 = a1 + 24 * v20;
  *(_DWORD *)(v21 + 56) = v25;
  *(_OWORD *)(v21 + 40) = v24;
  if (v16) {
    BOOL v22 = *(unsigned char *)(a1 + 3138) == 0;
  }
  else {
    BOOL v22 = 0;
  }
  *(unsigned char *)(a1 + 24 * *(int *)(a1 + 3112) + 60) = v22;
LABEL_27:
  if (v16)
  {
    *a3 = *(_DWORD *)(a1 + 20);
    if (!*(unsigned char *)(a1 + 3136)) {
      UkEngine::writeOutput((UkEngine *)a1, a4, a5);
    }
  }
  else
  {
    *a3 = 0;
    *a5 = 0;
  }
  *a6 = *(_DWORD *)(a1 + 3140);
  return v16;
}

_DWORD *UkEngine::prepareBuffer(_DWORD *this)
{
  unsigned int v1 = this;
  unint64_t v2 = this[7];
  if ((v2 & 0x80000000) == 0 && (int)v2 + 10 >= this[6])
  {
    unint64_t v3 = v2 >> 1;
    int v4 = &this[9 * (this[7] >> 1) + 786];
    do
    {
      int v5 = v3;
      if (v3 >= v2) {
        break;
      }
      int v6 = *v4;
      v4 += 9;
      ++v3;
    }
    while (v6 != 1);
    if (v2 == v5)
    {
      int v7 = -1;
    }
    else
    {
      int v8 = v5 + 1;
      int v7 = v2 - v8;
      this = memmove(this + 786, &this[9 * v8 + 786], 36 * ((int)v2 - v8 + 1));
    }
    v1[7] = v7;
  }
  unint64_t v9 = v1[778];
  if ((int)v9 >= 1 && (int)v9 + 1 >= v1[9])
  {
    unint64_t v10 = v9 >> 1;
    this = memmove(v1 + 10, &v1[6 * (v1[778] >> 1) + 10], 24 * ((int)v9 + 1 - (v1[778] >> 1)));
    v1[778] -= v10;
  }
  return this;
}

uint64_t UkEngine::writeOutput(UkEngine *this, unsigned __int8 *a2, int *a3)
{
  int v22 = 0;
  int v5 = *a3;
  v18[0] = &unk_1F3F75490;
  v18[1] = a2;
  v18[2] = a2;
  int v19 = 0;
  int v20 = v5;
  int v21 = 0;
  uint64_t VnCharset = CVnCharsetLib::getVnCharset((CVnCharsetLib *)VnCharsetLibObj, *(_DWORD *)(*((void *)this + 1) + 2104));
  (*(void (**)(uint64_t))(*(void *)VnCharset + 8))(VnCharset);
  uint64_t v7 = *((int *)this + 4);
  int v8 = *((_DWORD *)this + 7);
  if ((int)v7 > v8)
  {
    uint64_t result = 0;
    *a3 = v19;
    return result;
  }
  uint64_t v10 = v7 - 1;
  int v11 = (int *)((char *)this + 36 * (int)v7 + 3176);
  int v12 = 1;
  do
  {
    int v13 = *(v11 - 1);
    if (v13 != -1)
    {
      int v14 = *(v11 - 2);
      if (*(v11 - 3)) {
        int v15 = 0xFFFF;
      }
      else {
        int v15 = 0x10000;
      }
      int v16 = v15 + v13;
      if (v14) {
        int v17 = v16 + 2 * v14;
      }
      else {
        int v17 = v16;
      }
LABEL_13:
      if (v17 == -1) {
        goto LABEL_15;
      }
      goto LABEL_14;
    }
    if (*v11 <= 255)
    {
      int v17 = IsoStdVnCharMap[*v11];
      goto LABEL_13;
    }
LABEL_14:
    int v12 = (*(uint64_t (**)(uint64_t, void *))(*(void *)VnCharset + 24))(VnCharset, v18);
    int v8 = *((_DWORD *)this + 7);
LABEL_15:
    ++v10;
    v11 += 9;
  }
  while (v10 < v8);
  *a3 = v19;
  if (v12) {
    return 0;
  }
  else {
    return 5;
  }
}

uint64_t UkEngine::synchKeyStrokeBuffer(uint64_t this)
{
  unsigned int v1 = *(_DWORD *)(this + 3112);
  if ((v1 & 0x80000000) == 0) {
    *(_DWORD *)(this + 3112) = --v1;
  }
  unsigned int v2 = *(_DWORD *)(this + 28);
  if ((v2 & 0x80000000) == 0 && *(_DWORD *)(this + 36 * v2 + 3144) == 1 && (v1 & 0x80000000) == 0)
  {
    do
    {
      if (*(_DWORD *)(this + 24 * v1 + 44) == 1) {
        break;
      }
      *(_DWORD *)(this + 3112) = v1 - 1;
    }
    while ((int)v1-- > 0);
  }
  return this;
}

BOOL UkEngine::processBackspace(UkEngine *this, _DWORD *a2, unsigned __int8 *a3, int *a4, _DWORD *a5)
{
  *a5 = 0;
  if (!*(_DWORD *)(*((void *)this + 1) + 4) || (int v8 = *((_DWORD *)this + 7), v8 < 0))
  {
    BOOL result = 0;
    *a2 = 0;
    *a4 = 0;
  }
  else
  {
    *((void *)this + 2) = (v8 + 1);
    int v10 = *((_DWORD *)this + 5) + UkEngine::getSeqSteps(this, v8, v8);
    *((_DWORD *)this + 4) = v8;
    *((_DWORD *)this + 5) = v10;
    uint64_t v11 = *((int *)this + 7);
    if (!v11
      || *((_DWORD *)this + 9 * (int)v11 + 786) < 3u
      || ((uint64_t v12 = v11 - 1, v13 = *((_DWORD *)this + 9 * v11 + 777), v14 = v13 > 6, v15 = (1 << v13) & 0x64, !v14)
        ? (BOOL v16 = v15 == 0)
        : (BOOL v16 = 1),
          !v16))
    {
      *((_DWORD *)this + 7) = v11 - 1;
LABEL_10:
      *a2 = v10;
      *a4 = 0;
      UkEngine::synchKeyStrokeBuffer((uint64_t)this);
      return *a2 > 1;
    }
    int v18 = *((_DWORD *)this + 9 * (int)v11 + 788);
    unsigned int v19 = *((_DWORD *)this + 9 * ((int)v11 - v18) + 790);
    int v20 = v11 - v18 - *((_DWORD *)&VSeqList + 13 * (int)v19) + 1;
    unsigned int v32 = *((_DWORD *)this + 9 * v12 + 790);
    int TonePosition = UkEngine::getTonePosition((uint64_t)this, v19, v18 == 0);
    int v30 = v20;
    int v31 = v20 + TonePosition;
    int v22 = TonePosition;
    int v23 = UkEngine::getTonePosition((uint64_t)this, v32, 1);
    long long v24 = (char *)this + 36 * v31 + 3144;
    int v27 = *((_DWORD *)v24 + 6);
    int v25 = v24 + 24;
    int v26 = v27;
    if (v27) {
      BOOL v28 = v22 == v23;
    }
    else {
      BOOL v28 = 1;
    }
    if (v28 || v31 == v11 && *((_DWORD *)this + 9 * (int)v11 + 792))
    {
      *((_DWORD *)this + 7) = v12;
      goto LABEL_10;
    }
    int v29 = v23 + v30;
    UkEngine::markChange(this, v23 + v30);
    *((_DWORD *)this + 9 * v29 + 792) = v26;
    UkEngine::markChange(this, v31);
    *int v25 = 0;
    --*((_DWORD *)this + 7);
    UkEngine::synchKeyStrokeBuffer((uint64_t)this);
    *a2 = *((_DWORD *)this + 5);
    UkEngine::writeOutput(this, a3, a4);
    return 1;
  }
  return result;
}

uint64_t UkEngine::resetKeyBuf(uint64_t this)
{
  *(_DWORD *)(this + 3112) = -1;
  return this;
}

void UkEngine::UkEngine(UkEngine *this)
{
  _createGlobalVnCharsetIfNeeded();
  if (!UkEngine::m_classInit)
  {
    uint64_t v2 = 0;
    unint64_t v3 = &SortedVSeqList;
    int v4 = &qword_1EAE3D4DC;
    do
    {
      *unint64_t v3 = *v4;
      *((_DWORD *)v3 + 2) = *((_DWORD *)v4 + 2);
      *((_DWORD *)v3 + 3) = v2++;
      v3 += 2;
      int v4 = (uint64_t *)((char *)v4 + 52);
    }
    while (v2 != 70);
    uint64_t v5 = 0;
    int v6 = &SortedCSeqList;
    uint64_t v7 = &qword_1EAE3E30C;
    do
    {
      *int v6 = *v7;
      *((_DWORD *)v6 + 2) = *((_DWORD *)v7 + 2);
      *((_DWORD *)v6 + 3) = v5++;
      v6 += 2;
      uint64_t v7 = (uint64_t *)((char *)v7 + 20);
    }
    while (v5 != 29);
    qsort(&SortedVSeqList, 0x46uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleVowelCompare);
    qsort(&SortedCSeqList, 0x1DuLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))tripleConCompare);
    qsort(&VCPairList, 0x99uLL, 8uLL, (int (__cdecl *)(const void *, const void *))VCPairCompare);
    uint64_t v8 = 0;
    *(void *)&long long v9 = 0x101010101010101;
    *((void *)&v9 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0x101010101010101;
    unk_1EAE41256 = v9;
    xmmword_1EAE4123C = v9;
    unk_1EAE4124C = v9;
    xmmword_1EAE4121C = v9;
    unk_1EAE4122C = v9;
    xmmword_1EAE411FC = v9;
    unk_1EAE4120C = v9;
    xmmword_1EAE411DC = v9;
    unk_1EAE411EC = v9;
    xmmword_1EAE411BC = v9;
    unk_1EAE411CC = v9;
    IsVnVowel = v9;
    do
    {
      unsigned int v10 = ((v8 >> 1) | ((_BYTE)v8 << 7));
      BOOL v11 = v10 > 0xC;
      int v12 = (1 << v10) & 0x1495;
      if (v11 || v12 == 0)
      {
        *((unsigned char *)&IsVnVowel + *((int *)&AZLexiLower + v8)) = 0;
        *((unsigned char *)&IsVnVowel + *((int *)&AZLexiUpper + v8)) = 0;
      }
      ++v8;
    }
    while (v8 != 26);
    word_1EAE411D6 = 0;
    UkEngine::m_classInit = 1;
  }
  *((_DWORD *)this + 778) = -1;
  *(_OWORD *)((char *)this + 24) = xmmword_1E4154BB0;
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *(_WORD *)((char *)this + 3137) = 0;
  *((unsigned char *)this + 3116) = 0;
}

uint64_t UkEngine::setSingleMode(uint64_t this)
{
  *(_DWORD *)(this + 32) = 1;
  return this;
}

void SetupUnikeyEngine(void)
{
  SetupInputClassifierTable();
  uint64_t v0 = 0;
  int32x4_t v1 = (int32x4_t)xmmword_1E4154BC0;
  v2.i64[0] = 0x400000004;
  v2.i64[1] = 0x400000004;
  do
  {
    *(int32x4_t *)&IsoStdVnCharMap[v0] = v1;
    int32x4_t v1 = vaddq_s32(v1, v2);
    v0 += 4;
  }
  while (v0 != 256);
  for (uint64_t i = 0; i != 27; ++i)
    IsoStdVnCharMap[SpecialWesternChars[i]] = i + 65722;
  for (uint64_t j = 0; j != 256; ++j)
  {
    int v5 = IsoVnLexiMap[j];
    if (v5 != -1) {
      IsoStdVnCharMap[j] = v5 + 0x10000;
    }
  }
}

BOOL UkEngine::atWordBeginning(UkEngine *this)
{
  unsigned int v1 = *((_DWORD *)this + 7);
  return (v1 & 0x80000000) != 0 || *((_DWORD *)this + 9 * v1 + 786) == 1;
}

id phrasesFilePathForInputMode(uint64_t a1)
{
  unsigned int v1 = +[TIInputMode inputModeWithIdentifier:a1];
  int32x4_t v2 = UIKeyboardPhraseLexiconPathForInputMode(v1);

  return v2;
}

id dynamicFilePathForInputMode(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = [v3 length];
  int v6 = 0;
  if (v4 && v5)
  {
    if ([v3 isEqualToString:@"en_US"])
    {
      uint64_t v7 = @"dynamic-text.dat";
    }
    else
    {
      uint64_t v8 = TIInputModeGetLanguageWithRegion();
      uint64_t v7 = [v8 stringByAppendingString:@"-dynamic-text.dat"];
    }
    if ([(__CFString *)v7 length])
    {
      int v6 = [v4 stringByAppendingPathComponent:v7];
    }
    else
    {
      int v6 = 0;
    }
  }

  return v6;
}

id deltaUnigramsFilePathForInputMode(uint64_t a1)
{
  unsigned int v1 = +[TIInputMode inputModeWithIdentifier:a1];
  int32x4_t v2 = UIKeyboardDeltaLexiconPathForInputMode(v1);

  return v2;
}

void __createAndLoadDictionaryContainer(NSString *a1, NSString *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v4)
  {
    UIKeyboardDynamicDictionaryFileWithSiriMode(v3, v4, 0);
    uint64_t v5 = (NSString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v5 = 0;
  }
  __getLexiconInfo(v3, v5, 1.0, (uint64_t)v61);
  KB::String::String((KB::String *)&v48, (const KB::String *)v61);
  KB::String::String((KB::String *)v50, (const KB::String *)&v62);
  KB::String::String((KB::String *)v53, (const KB::String *)&v63);
  KB::String::String((KB::String *)v55, (const KB::String *)&v64);
  KB::String::String((KB::String *)v57, (const KB::String *)&v65);
  uint64_t v59 = v66;
  int v60 = v67;
  int v6 = (char *)operator new(0xB0uLL);
  uint64_t v7 = v6 + 176;
  v26.i64[0] = (uint64_t)v6;
  int v27 = v6 + 176;
  std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo const&,KB::LexiconInfo*>((uint64_t)v6, (uint64_t)&v48);
  v26.i64[1] = (uint64_t)v7;
  if (v58 && v57[6] == 1) {
    free(v58);
  }
  if (v56 && v55[6] == 1) {
    free(v56);
  }
  if (v54 && v53[6] == 1) {
    free(v54);
  }
  if (v52[0] && v51[0] == 1) {
    free(v52[0]);
  }
  if (v49 && BYTE6(v48) == 1) {
    free(v49);
  }
  uint64_t v8 = v3;
  [(NSString *)v8 UTF8String];
  if (_os_feature_enabled_impl())
  {
    KB::String::String((KB::String *)&v68, "mul-");
    long long v9 = [(NSString *)v8 UTF8String];
    KB::String::String((KB::String *)&v48, (const KB::String *)&v68);
    KB::String::append((unsigned __int16 *)&v48, v9, 0xFFFFuLL);
    KB::String::String((KB::String *)v50, "mul");
    if (v69.i64[0] && BYTE6(v68) == 1) {
      free((void *)v69.i64[0]);
    }
    for (uint64_t i = 0; i != 2; ++i)
    {
      int v43 = 0x100000;
      __int16 v44 = 0;
      char v45 = 0;
      int v46 = 0;
      char v47 = 0;
      int v38 = 0x100000;
      __int16 v39 = 0;
      char v40 = 0;
      int v41 = 0;
      char v42 = 0;
      int v33 = 0x100000;
      __int16 v34 = 0;
      char v35 = 0;
      int v36 = 0;
      char v37 = 0;
      int v28 = 0x100000;
      __int16 v29 = 0;
      char v30 = 0;
      int v31 = 0;
      char v32 = 0;
      char v25 = 0;
      int v24 = 1;
      if (v26.i64[1] >= (unint64_t)v27)
      {
        uint64_t v12 = 0x2E8BA2E8BA2E8BA3 * ((v26.i64[1] - v26.i64[0]) >> 4);
        unint64_t v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) > 0x1745D1745D1745DLL) {
          abort();
        }
        if (0x5D1745D1745D1746 * ((uint64_t)&v27[-v26.i64[0]] >> 4) > v13) {
          unint64_t v13 = 0x5D1745D1745D1746 * ((uint64_t)&v27[-v26.i64[0]] >> 4);
        }
        if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((uint64_t)&v27[-v26.i64[0]] >> 4)) >= 0xBA2E8BA2E8BA2ELL) {
          unint64_t v14 = 0x1745D1745D1745DLL;
        }
        else {
          unint64_t v14 = v13;
        }
        unint64_t v71 = &v27;
        if (v14) {
          unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LexiconInfo>>(v14);
        }
        else {
          uint64_t v15 = 0;
        }
        uint64_t v16 = v14 + 176 * v12;
        unint64_t v68 = v14;
        v69.i64[0] = v16;
        unint64_t v70 = v14 + 176 * v15;
        std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String const&,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(v16, (const KB::String *)(&v48 + 4 * i), (KB::String *)&v43, (KB::String *)&v38, (KB::String *)&v33, (KB::String *)&v28, &v25, &v24);
        uint64_t v11 = v16 + 176;
        v69.i64[1] = v11;
        uint64_t v17 = v26.i64[1];
        uint64_t v18 = v26.i64[0];
        uint64_t v19 = v69.i64[0];
        if (v26.i64[1] == v26.i64[0])
        {
          int64x2_t v20 = vdupq_n_s64(v26.u64[1]);
        }
        else
        {
          do
          {
            v17 -= 176;
            uint64_t v19 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::LexiconInfo,KB::LexiconInfo*>(v19 - 176, v17);
          }
          while (v17 != v18);
          int64x2_t v20 = v26;
          uint64_t v11 = v69.i64[1];
        }
        v26.i64[0] = v19;
        v26.i64[1] = v11;
        int64x2_t v69 = v20;
        int v21 = v27;
        int v27 = (char *)v70;
        unint64_t v70 = (unint64_t)v21;
        unint64_t v68 = v20.i64[0];
        std::__split_buffer<KB::LexiconInfo>::~__split_buffer((uint64_t)&v68);
      }
      else
      {
        uint64_t v11 = std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String const&,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(v26.i64[1], (const KB::String *)(&v48 + 4 * i), (KB::String *)&v43, (KB::String *)&v38, (KB::String *)&v33, (KB::String *)&v28, &v25, &v24)+ 176;
      }
      v26.i64[1] = v11;
      if (v31 && v30 == 1) {
        free(v31);
      }
      if (v36 && v35 == 1) {
        free(v36);
      }
      if (v41 && v40 == 1) {
        free(v41);
      }
      if (v46 && v45 == 1) {
        free(v46);
      }
    }
    for (uint64_t j = 0; j != -8; j -= 4)
    {
      int v23 = v52[j];
      if (v23)
      {
        if (v51[j * 8] == 1) {
          free(v23);
        }
      }
    }
  }
  operator new();
}

void __getLexiconInfo(NSString *a1@<X0>, NSString *a2@<X1>, float a3@<S0>, uint64_t a4@<X8>)
{
  uint64_t v7 = a2;
  uint64_t v8 = a1;
  UIKeyboardStaticUnigramsFile(v8);
  unint64_t v13 = (KB *)objc_claimAutoreleasedReturnValue();
  deltaUnigramsFilePathForInputMode((uint64_t)v8);
  long long v9 = (KB *)objc_claimAutoreleasedReturnValue();
  phrasesFilePathForInputMode((uint64_t)v8);
  unsigned int v10 = (KB *)objc_claimAutoreleasedReturnValue();
  dynamicFilePathForInputMode(v8, v7);
  uint64_t v11 = (KB *)objc_claimAutoreleasedReturnValue();

  uint64_t v12 = v8;
  LODWORD(v8) = TILexiconIDForLocaleIdentifier((char *)[(NSString *)v12 UTF8String]);
  KB::utf8_string((KB *)v12, a4);

  KB::utf8_string(v13, a4 + 32);
  KB::utf8_string(v9, a4 + 64);
  KB::utf8_string(v10, a4 + 96);
  KB::utf8_string(v11, a4 + 128);
  *(_DWORD *)(a4 + 160) = v8;
  *(unsigned char *)(a4 + 164) = 0;
  *(float *)(a4 + 168) = a3;
}

uint64_t std::construct_at[abi:nn180100]<KB::LexiconInfo,KB::String const&,KB::String,KB::String,KB::String,KB::String,unsigned int const&,BOOL,int,KB::LexiconInfo*>(uint64_t a1, const KB::String *a2, KB::String *a3, KB::String *a4, KB::String *a5, KB::String *a6, unsigned char *a7, int *a8)
{
  uint64_t v15 = KB::String::String((KB::String *)a1, a2);
  *((_DWORD *)v15 + 8) = 0x100000;
  *(_WORD *)(a1 + 36) = 0;
  *(unsigned char *)(a1 + 38) = 0;
  *(void *)(a1 + 40) = 0;
  KB::String::operator=((uint64_t)v15 + 32, a3);
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 70) = 0;
  *(void *)(a1 + 72) = 0;
  KB::String::operator=(a1 + 64, a4);
  *(_DWORD *)(a1 + 96) = 0x100000;
  *(_WORD *)(a1 + 100) = 0;
  *(unsigned char *)(a1 + 102) = 0;
  *(void *)(a1 + 104) = 0;
  KB::String::operator=(a1 + 96, a5);
  *(_DWORD *)(a1 + 128) = 0x100000;
  *(_WORD *)(a1 + 132) = 0;
  *(unsigned char *)(a1 + 134) = 0;
  *(void *)(a1 + 136) = 0;
  KB::String::operator=(a1 + 128, a6);
  *(_DWORD *)(a1 + 160) = -2;
  *(unsigned char *)(a1 + 164) = *a7;
  *(float *)(a1 + 168) = (float)*a8;
  return a1;
}

void __createAndLoadLanguageModel(NSString *a1, NSString *a2, int a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (void *)MEMORY[0x1E4F1CA20];
  int v6 = a2;
  uint64_t v7 = a1;
  uint64_t v8 = [v5 localeWithLocaleIdentifier:v7];
  v12[0] = v8;
  long long v9 = [MEMORY[0x1E4F1C978] arrayWithObjects:v12 count:1];
  char v10 = +[TIInputMode inputModeWithIdentifier:v7];
  KB::LanguageModelConfig::LanguageModelConfig((uint64_t)&v11, v8, 0, v9, 0, v6, 0, 0, 0, a3 ^ 1, 0, 0, 1, 90, v10);
  operator new();
}

uint64_t std::__shared_ptr_pointer<KB::LanguageModelStr *,std::shared_ptr<KB::LanguageModel>::__shared_ptr_default_delete<KB::LanguageModel,KB::LanguageModelStr>,std::allocator<KB::LanguageModelStr>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<KB::LanguageModelStr *,std::shared_ptr<KB::LanguageModel>::__shared_ptr_default_delete<KB::LanguageModel,KB::LanguageModelStr>,std::allocator<KB::LanguageModelStr>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

uint64_t KB::LanguageModelConfig::LanguageModelConfig(uint64_t a1, CFTypeRef cf, char a3, CFTypeRef a4, CFTypeRef a5, CFTypeRef a6, CFTypeRef a7, CFTypeRef a8, CFTypeRef cfa, int a10, char a11, int a12, int a13, int a14, char a15)
{
  *(void *)a1 = cf;
  if (cf)
  {
    CFRetain(cf);
    *(void *)a1 = cf;
  }
  *(void *)(a1 + 8) = a4;
  if (a4)
  {
    CFRetain(a4);
    *(void *)(a1 + 8) = a4;
  }
  *(void *)(a1 + 16) = cfa;
  if (cfa)
  {
    CFRetain(cfa);
    *(void *)(a1 + 16) = cfa;
  }
  *(void *)(a1 + 24) = a5;
  if (a5)
  {
    CFRetain(a5);
    *(void *)(a1 + 24) = a5;
  }
  *(void *)(a1 + 32) = a6;
  if (a6)
  {
    CFRetain(a6);
    *(void *)(a1 + 32) = a6;
  }
  *(void *)(a1 + 40) = a7;
  if (a7)
  {
    CFRetain(a7);
    *(void *)(a1 + 40) = a7;
  }
  *(void *)(a1 + 48) = a8;
  if (a8)
  {
    CFRetain(a8);
    *(void *)(a1 + 48) = a8;
  }
  *(_DWORD *)(a1 + 56) = a12;
  *(_DWORD *)(a1 + 60) = a10;
  *(_DWORD *)(a1 + 64) = a13;
  *(unsigned char *)(a1 + 72) = a3;
  *(unsigned char *)(a1 + 73) = a11;
  *(unsigned char *)(a1 + 86) = a15;
  if (TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValue(void)::onceToken != -1) {
    dispatch_once(&TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValue(void)::onceToken, &__block_literal_global_4046);
  }
  int v23 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  int v24 = [v23 valueForPreferenceKey:@"KeyboardLanguageModelingDisableDynamicLanguageModels"];

  LOBYTE(v23) = [v24 BOOLValue];
  *(unsigned char *)(a1 + 74) = (_BYTE)v23;
  char v25 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  int64x2_t v26 = [v25 valueForPreferenceKey:*MEMORY[0x1E4FAE9F8]];
  unint64_t v27 = [v26 integerValue];

  if (v27 > 2) {
    int v28 = 2;
  }
  else {
    int v28 = dword_1E4155430[v27];
  }
  *(_DWORD *)(a1 + 68) = v28;
  __int16 v29 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  char v30 = [v29 valueForPreferenceKey:*MEMORY[0x1E4FAE890]];
  char v31 = [v30 BOOLValue];

  *(unsigned char *)(a1 + 75) = v31;
  char v32 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  int v33 = [v32 valueForPreferenceKey:*MEMORY[0x1E4FAE8A0]];
  int v34 = [v33 integerValue];

  *(_DWORD *)(a1 + 80) = v34;
  char v35 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  int v36 = [v35 valueForPreferenceKey:*MEMORY[0x1E4FAE898]];
  int v37 = [v36 integerValue];

  *(_DWORD *)(a1 + 76) = v37;
  *(_DWORD *)(a1 + 88) = a14;
  *(unsigned char *)(a1 + 84) = 1;
  if (HIBYTE(inline_completions_override)) {
    char v38 = (_BYTE)inline_completions_override != 0;
  }
  else {
    char v38 = _os_feature_enabled_impl();
  }
  *(unsigned char *)(a1 + 85) = v38;
  return a1;
}

{
  return KB::LanguageModelConfig::LanguageModelConfig(a1, cf, a3, a4, a5, a6, a7, a8, cfa, a10, a11, a12, a13, a14, a15);
}

void ___ZL62TIGetKeyboardLanguageModelingDisableDynamicLanguageModelsValuev_block_invoke()
{
  id v0 = [MEMORY[0x1E4FAE3D8] sharedPreferencesController];
  [v0 _configureKey:@"KeyboardLanguageModelingDisableDynamicLanguageModels" domain:@"com.apple.keyboard" defaultValue:MEMORY[0x1E4F1CC28]];
}

uint64_t KB::LanguageModelConfig::set_user_setting_transformer_lm_autocorrection(uint64_t result, int a2)
{
  *(_DWORD *)(result + 68) = a2;
  return result;
}

const void **KB::LanguageModelConfig::_set_app_context_under_mutex(const void **this, const __CFString *a2)
{
  return KB::retain_ptr<__CFDictionary const*>::operator=(this + 5, a2);
}

const void **KB::LanguageModelConfig::_set_recipient_context_under_mutex(const void **this, const __CFDictionary *a2)
{
  return KB::retain_ptr<__CFDictionary const*>::operator=(this + 6, a2);
}

uint64_t KB::LanguageModelConfig::_set_is_online(uint64_t result, int a2)
{
  *(_DWORD *)(result + 56) = a2;
  return result;
}

void KB::LanguageModelConfig::trial_parameters(KB::LanguageModelConfig *this@<X0>, const __CFDictionary *a2@<X1>, uint64_t a3@<X8>)
{
  id v4 = (LM::TrialParameters *)*((void *)this + 2);
  if (v4)
  {
    LM::TrialParameters::createWithEncodedRepresentation((uint64_t *)__p, v4, a2);
    *(_OWORD *)a3 = *(_OWORD *)__p;
    uint64_t v5 = v11;
    int v6 = v12;
    __p[1] = 0;
    uint64_t v11 = 0;
    __p[0] = 0;
    *(void *)(a3 + 16) = v5;
    *(void *)(a3 + 24) = v6;
    uint64_t v7 = v13;
    uint64_t v8 = v14;
    *(void *)(a3 + 32) = v13;
    uint64_t v9 = a3 + 32;
    *(void *)(a3 + 40) = v8;
    if (v8)
    {
      void v7[2] = v9;
      uint64_t v12 = &v13;
      unint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v7 = 0;
    }
    else
    {
      *(void *)(a3 + 24) = v9;
    }
    *(unsigned char *)(a3 + 48) = 1;
    std::__tree<std::__value_type<std::string,std::string>,std::__map_value_compare<std::string,std::__value_type<std::string,std::string>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::string>>>::destroy(v7);
    if (SHIBYTE(v11) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 48) = 0;
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::shared_ptr<KB::AppTrieLoader>>,0>(uint64_t a1)
{
  int32x4_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v2);
  }
  id v3 = *(void **)(a1 + 8);
  if (v3 && *(unsigned char *)(a1 + 6) == 1)
  {
    free(v3);
  }
}

uint64_t __Block_byref_object_copy__50(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = 0;
  *(void *)(result + 48) = v2;
  return result;
}

const void ***__Block_byref_object_dispose__51(uint64_t a1)
{
  return std::unique_ptr<KB::StaticDictionary>::reset[abi:nn180100]((const void ****)(a1 + 48), 0);
}

uint64_t __Block_byref_object_copy__4162(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4163(uint64_t a1)
{
}

uint64_t std::__hash_table<std::__hash_value_type<KB::String,_LXLexicon const*>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,_LXLexicon const*>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    id v3 = v2;
    uint64_t v2 = (void *)*v2;
    id v4 = (void *)v3[3];
    if (v4 && *((unsigned char *)v3 + 22) == 1) {
      free(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void TITransientLexiconManagerLoad()
{
  id v0 = +[TITransientLexiconManager sharedInstance];
  [v0 loadLexicons];
}

uint64_t TITransientLexiconManagerGetNamedEntitiesForLocale(uint64_t a1)
{
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 namedEntityLexiconForLocale:a1];

  return v3;
}

uint64_t TITransientLexiconManagerGetNamedEntityPhrasesForLocale(uint64_t a1)
{
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 namedEntityPhraseLexiconForLocale:a1];

  return v3;
}

uint64_t TITransientLexiconManagerGetAddressBookLexiconForLocale(uint64_t a1)
{
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 addressBookLexiconForLocale:a1];

  return v3;
}

uint64_t TITransientLexiconManagerGetAppNameLexiconForLocale(uint64_t a1)
{
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 appNameLexiconForLocale:a1];

  return v3;
}

void TITransientLexiconManagerLogEntities()
{
  id v0 = +[TITransientLexiconManager sharedInstance];
  [v0 debugLogEntities];
}

uint64_t TITransientLexiconManagerGetActiveSupplementalLexiconWords()
{
  id v0 = +[TITransientLexiconManager sharedInstance];
  int v1 = [v0 isSupplementalLexiconSearchEnabled];

  if (!v1) {
    return 0;
  }
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 supplementalLexicons];
  uint64_t v4 = [v3 activeWordLexicon];

  return v4;
}

uint64_t TITransientLexiconManagerGetActiveSupplementalLexiconPhrases()
{
  id v0 = +[TITransientLexiconManager sharedInstance];
  int v1 = [v0 isSupplementalLexiconSearchEnabled];

  if (!v1) {
    return 0;
  }
  uint64_t v2 = +[TITransientLexiconManager sharedInstance];
  uint64_t v3 = [v2 supplementalLexicons];
  uint64_t v4 = [v3 activePhraseLexicon];

  return v4;
}

uint64_t TITransientLexiconManagerIsSupplementalLexiconSearchEnabled()
{
  id v0 = +[TITransientLexiconManager sharedInstance];
  uint64_t v1 = [v0 isSupplementalLexiconSearchEnabled];

  return v1;
}

__CFString *TINSXPCConnectionCodeSigningIdentifier(void *a1)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a1) {
    [a1 auditToken];
  }
  else {
    memset(&v5, 0, sizeof(v5));
  }
  uint64_t v2 = SecTaskCreateWithAuditToken(v1, &v5);
  uint64_t v3 = (__CFString *)SecTaskCopySigningIdentifier(v2, 0);
  CFRelease(v2);

  return v3;
}

id TITypologyProfileStateLog()
{
  if (TITypologyProfileStateLog_onceToken != -1) {
    dispatch_once(&TITypologyProfileStateLog_onceToken, &__block_literal_global_4302);
  }
  id v0 = (void *)TITypologyProfileStateLog_log;

  return v0;
}

uint64_t __TITypologyProfileStateLog_block_invoke()
{
  TITypologyProfileStateLog_log = (uint64_t)os_log_create("com.apple.TextInput", "typologyProfileState");

  return MEMORY[0x1F41817F8]();
}

uint64_t _areValidFieldValues(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v5;
  if (v8
    && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)
    && ([MEMORY[0x1E4F1C9C8] distantPast],
        uint64_t v9 = objc_claimAutoreleasedReturnValue(),
        int v10 = [v8 isEqualToDate:v9],
        v9,
        !v10))
  {
    unint64_t v13 = [MEMORY[0x1E4F1C9C8] now];
    id v14 = [v8 laterDate:v13];

    if (v14 != v8)
    {
      id v15 = v6;
      if (!v15 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {

        goto LABEL_5;
      }
      uint64_t v16 = [MEMORY[0x1E4F1C9C8] now];
      id v17 = [v15 laterDate:v16];

      if (v17 != v15)
      {
        id v18 = v7;
        if (!v18 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {

          goto LABEL_5;
        }
        if (([v18 isEqualToString:@"None"] & 1) != 0
          || ([v18 isEqualToString:@"Enable"] & 1) != 0
          || [v18 isEqualToString:@"NotNow"])
        {
        }
        else
        {
          int v22 = [v18 isEqualToString:@"Disabled"];

          if (!v22) {
            goto LABEL_5;
          }
        }
        uint64_t v19 = [MEMORY[0x1E4F1C9C8] distantPast];
        int v20 = [v15 isEqualToDate:v19];

        if (v20)
        {
          if (([v18 isEqualToString:@"None"] & 1) == 0) {
            goto LABEL_5;
          }
        }
        else
        {
          id v21 = [v8 laterDate:v15];

          if (v21 == v8) {
            goto LABEL_5;
          }
        }
        uint64_t v11 = 1;
        goto LABEL_6;
      }
    }
  }
  else
  {
  }
LABEL_5:
  uint64_t v11 = 0;
LABEL_6:

  return v11;
}

void KB::RemoveAlternatesIfNoLinguisticCandidate::filter_candidates(uint64_t a1, void *a2, const char *a3, uint64_t a4)
{
  if (*a2 == a2[1])
  {
    uint64_t v7 = a2[3];
    for (uint64_t i = a2[4]; i != v7; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
      ;
    a2[4] = v7;
    id v8 = *(__CFString **)(a4 + 56);
    if (v8)
    {
      KB::append_format(v8, (__CFString *)"Removing alternate corrections as there are no linguistic autocorrection candidate\n", a3);
    }
  }
}

const char *KB::RemoveAlternatesIfNoLinguisticCandidate::filter_description(KB::RemoveAlternatesIfNoLinguisticCandidate *this)
{
  return "RemoveAlternatesIfNoLinguisticCandidate";
}

void KB::RemoveAlternatesIfNoLinguisticCandidate::~RemoveAlternatesIfNoLinguisticCandidate(KB::RemoveAlternatesIfNoLinguisticCandidate *this)
{
}

uint64_t KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v3 = (uint64_t *)(a1 + 48);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 80) = 1065353216;
  *(void *)(a1 + 88) = 0;
  uint64_t v4 = *a2;
  if (a2[1] != *a2)
  {
    unint64_t v5 = 0;
    id v6 = (char **)(a1 + 24);
    while (1)
    {
      CFArrayRef v7 = *(const __CFArray **)(v4 + 8 * v5);
      if (!v7)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      CFRetain(*(CFTypeRef *)(v4 + 8 * v5));
      for (unint64_t i = 0; i < CFArrayGetCount(v7); ++i)
      {
        cf[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v32, v7, i, cf);
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        CFDictionaryRef v9 = (const __CFDictionary *)v32;
        if (v32)
        {
          CFRetain(v32);
          extract_name((uint64_t)cf, v9);
          CFRelease(v9);
          applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, v9, @"Operation");
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
          }
          if (size == 8)
          {
            if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::__split_buffer<std::string>::pointer p_p = &__p;
            }
            else {
              std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
            }
            if (p_p->__r_.__value_.__r.__words[0] == 0x656469727265764FLL) {
              goto LABEL_31;
            }
LABEL_20:
            std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](v6, v9);
          }
          else
          {
            if (size != 6) {
              goto LABEL_20;
            }
            uint64_t v11 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &__p
                : (std::string *)__p.__r_.__value_.__r.__words[0];
            int data = (int)v11->__r_.__value_.__l.__data_;
            int v13 = WORD2(v11->__r_.__value_.__r.__words[0]);
            if (data != 1701602628 || v13 != 25972) {
              goto LABEL_20;
            }
LABEL_31:
            uint64_t v16 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v3, (uint64_t)cf, (uint64_t)cf);
            id v17 = (const void *)*((void *)v16 + 5);
            *((void *)v16 + 5) = v9;
            CFRetain(v9);
            if (v17) {
              CFRelease(v17);
            }
          }
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          if (v31 < 0) {
            operator delete((void *)cf[0]);
          }
          CFRelease(v9);
          continue;
        }
      }
      CFRelease(v7);
      ++v5;
      uint64_t v4 = *a2;
      if (v5 >= (a2[1] - *a2) >> 3)
      {
        uint64_t v2 = a1;
        uint64_t v19 = *(CFTypeRef **)(a1 + 24);
        id v18 = *(CFTypeRef **)(a1 + 32);
        goto LABEL_36;
      }
    }
  }
  id v18 = 0;
  uint64_t v19 = 0;
LABEL_36:
  if ((char *)v18 - (char *)v19 < 1)
  {
LABEL_40:
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v19, v18, v18 - v19, 0, 0);
  }
  else
  {
    int v20 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
    unint64_t v21 = v18 - v19;
    while (1)
    {
      int v22 = (CFTypeRef *)operator new(8 * v21, v20);
      if (v22) {
        break;
      }
      BOOL v23 = v21 > 1;
      v21 >>= 1;
      if (!v23) {
        goto LABEL_40;
      }
    }
    int v24 = v22;
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v19, v18, v18 - v19, v22, v21);
    operator delete(v24);
  }
  return v2;
}

void sub_1E3F95900()
{
}

void std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, unint64_t a3, CFTypeRef *a4, uint64_t a5)
{
  if (a3 < 2) {
    return;
  }
  unint64_t v5 = a2;
  id v6 = a1;
  if (a3 == 2)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)*(a2 - 1);
    if (!v7)
    {
      CFTypeRef v62 = *a1;
      if (!*v6) {
        goto LABEL_65;
      }
      goto LABEL_74;
    }
    CFRetain(*(a2 - 1));
    CFDictionaryRef v8 = (const __CFDictionary *)*v6;
    if (*v6)
    {
      CFRetain(*v6);
      unint64_t v9 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
      uint64_t v11 = v10;
      unint64_t v12 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v8);
      if (v13) {
        unint64_t v14 = v12;
      }
      else {
        unint64_t v14 = -1;
      }
      CFRelease(v8);
      CFRelease(v7);
      if (v11)
      {
        if (v9 < v14)
        {
          CFTypeRef v15 = *v6;
          *id v6 = 0;
          *id v6 = *(v5 - 1);
          *(v5 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v15;
        }
      }
      return;
    }
LABEL_63:
    CFDictionaryRef v60 = v7;
    goto LABEL_64;
  }
  if ((uint64_t)a3 <= 0)
  {
    if (a1 == a2) {
      return;
    }
    int v22 = a1 + 1;
    if (a1 + 1 == a2) {
      return;
    }
    uint64_t v23 = 0;
    int v24 = a1;
    while (1)
    {
      char v25 = v24;
      CFDictionaryRef v7 = (const __CFDictionary *)*v22;
      if (!*v22)
      {
        CFTypeRef v62 = *v24;
        if (!*v24) {
          goto LABEL_65;
        }
LABEL_74:
        CFRetain(v62);
        goto LABEL_65;
      }
      int v24 = v22;
      CFRetain(*v22);
      CFDictionaryRef v26 = (const __CFDictionary *)*v25;
      if (!*v25) {
        goto LABEL_63;
      }
      CFRetain(*v25);
      unint64_t v27 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
      uint64_t v29 = v28;
      unint64_t v30 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v26);
      if (v31) {
        unint64_t v32 = v30;
      }
      else {
        unint64_t v32 = -1;
      }
      CFRelease(v26);
      CFRelease(v7);
      if (v29 && v27 < v32)
      {
        CFDictionaryRef v7 = (const __CFDictionary *)*v24;
        CFTypeRef *v24 = *v25;
        *char v25 = 0;
        if (v25 == v6)
        {
          *id v6 = v7;
        }
        else
        {
          uint64_t v33 = v23;
          if (!v7)
          {
            CFTypeRef v62 = *(v25 - 1);
            if (!v62) {
              goto LABEL_65;
            }
            goto LABEL_74;
          }
          while (1)
          {
            int v34 = (CFTypeRef *)((char *)v6 + v33);
            CFRetain(v7);
            CFDictionaryRef v35 = *(const __CFDictionary **)((char *)v6 + v33 - 8);
            if (!v35) {
              goto LABEL_63;
            }
            CFRetain(*(v34 - 1));
            unint64_t v36 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v7);
            uint64_t v38 = v37;
            unint64_t v39 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v35);
            unint64_t v41 = v40 ? v39 : -1;
            CFRelease(v35);
            CFRelease(v7);
            char v42 = *v34;
            if (!v38 || v36 >= v41) {
              break;
            }
            *(CFTypeRef *)((char *)v6 + v33) = *(v34 - 1);
            *(v34 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v42;
            v33 -= 8;
            if (!v33)
            {
              int v43 = v6;
              goto LABEL_39;
            }
          }
          int v43 = (CFTypeRef *)((char *)v6 + v33);
LABEL_39:
          *int v43 = v7;
          unint64_t v5 = a2;
          if (v42) {
            CFRelease(v42);
          }
        }
      }
      int v22 = v24 + 1;
      v23 += 8;
      if (v24 + 1 == v5) {
        return;
      }
    }
  }
  id v18 = a4;
  uint64_t v19 = a3 >> 1;
  int v20 = &a1[a3 >> 1];
  if ((uint64_t)a3 <= a5)
  {
    v64[0] = (uint64_t)a4;
    v64[1] = (uint64_t)&v65;
    unint64_t v65 = 0;
    std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, &a1[a3 >> 1], a3 >> 1, a4);
    unint64_t v65 = a3 >> 1;
    __int16 v44 = &v18[v19];
    std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(&v6[a3 >> 1], v5, a3 - v19, v44);
    unint64_t v65 = a3;
    char v45 = &v18[a3];
    int v46 = v44;
    while (v46 != v45)
    {
      CFDictionaryRef v47 = (const __CFDictionary *)*v46;
      if (!*v46)
      {
        CFTypeRef v62 = *v18;
        if (!*v18) {
          goto LABEL_65;
        }
        goto LABEL_74;
      }
      CFRetain(*v46);
      CFDictionaryRef v48 = (const __CFDictionary *)*v18;
      if (!*v18)
      {
        CFDictionaryRef v60 = v47;
LABEL_64:
        applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v60);
LABEL_65:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      CFRetain(*v18);
      unint64_t v49 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v47);
      uint64_t v51 = v50;
      unint64_t v52 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v48);
      if (v53) {
        unint64_t v54 = v52;
      }
      else {
        unint64_t v54 = -1;
      }
      CFRelease(v48);
      CFRelease(v47);
      CFTypeRef v55 = *v6;
      if (v51 && v49 < v54)
      {
        *id v6 = *v46;
        *v46++ = v55;
      }
      else
      {
        *id v6 = *v18;
        *v18++ = v55;
      }
      ++v6;
      if (v18 == v44)
      {
        if (v46 != v45)
        {
          uint64_t v56 = 0;
          do
          {
            CFTypeRef v57 = v6[v56];
            v6[v56] = v46[v56];
            v46[v56++] = v57;
          }
          while (&v46[v56] != v45);
        }
        goto LABEL_62;
      }
    }
    if (v18 != v44)
    {
      uint64_t v58 = 0;
      do
      {
        CFTypeRef v59 = v6[v58];
        v6[v58] = v18[v58];
        v18[v58++] = v59;
      }
      while (&v18[v58] != v44);
    }
LABEL_62:
    std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](v64);
  }
  else
  {
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, &a1[a3 >> 1], a3 >> 1, a4, a5);
    uint64_t v21 = a3 - v19;
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v20, v5, v21, v18, a5);
    std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v6, v20, v5, v19, v21, v18, a5);
  }
}

void applesauce::CF::construct_error(applesauce::CF *this)
{
}

void applesauce::CF::at_or<applesauce::CF::DictionaryRef>(void *a1, CFArrayRef theArray, unint64_t a3, void *a4)
{
  if (CFArrayGetCount(theArray) <= a3) {
    goto LABEL_8;
  }
  ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(theArray, a3);
  if (!ValueAtIndex) {
    goto LABEL_8;
  }
  unint64_t v9 = ValueAtIndex;
  CFRetain(ValueAtIndex);
  CFTypeID v10 = CFGetTypeID(v9);
  if (v10 != CFDictionaryGetTypeID())
  {
    CFRelease(v9);
LABEL_8:
    *a1 = *a4;
    *a4 = 0;
    return;
  }
  CFRetain(v9);
  *a1 = v9;

  CFRelease(v9);
}

void extract_name(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!theDict)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, @"FilterName");
  if (!Value)
  {
    LOBYTE(__p[0]) = 0;
    char v11 = 0;
    goto LABEL_7;
  }
  applesauce::CF::convert_as<std::string,0>((uint64_t)__p, Value);
  if (!v11)
  {
LABEL_7:
    std::string::basic_string[abi:nn180100]<0>((void *)a1, "");
    BOOL v4 = v10 < 0;
    goto LABEL_8;
  }
  if ((SHIBYTE(v10) & 0x80000000) == 0)
  {
    *(_OWORD *)a1 = *(_OWORD *)__p;
    *(void *)(a1 + 16) = v10;
    goto LABEL_11;
  }
  std::string::__init_copy_ctor_external((std::string *)a1, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
  BOOL v4 = 1;
LABEL_8:
  if (v11 && v4) {
    operator delete(__p[0]);
  }
LABEL_11:
  uint64_t v5 = *(unsigned __int8 *)(a1 + 23);
  if ((v5 & 0x80u) != 0) {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  if (!v5)
  {
    id v6 = filter_factory_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(@"FilterName", __p);
      if (v10 >= 0) {
        CFDictionaryRef v7 = __p;
      }
      else {
        CFDictionaryRef v7 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315138;
      char v13 = v7;
      _os_log_error_impl(&dword_1E3F0E000, v6, OS_LOG_TYPE_ERROR, "Filter specification must include key '%s' with string value.", buf, 0xCu);
      if (SHIBYTE(v10) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(std::string *a1, CFDictionaryRef theDict, void *key)
{
  if (!key || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, key)) == 0)
  {
    LOBYTE(__p[0]) = 0;
    char v9 = 0;
    goto LABEL_7;
  }
  applesauce::CF::convert_as<std::string,0>((uint64_t)__p, Value);
  if (!v9)
  {
LABEL_7:
    std::string::basic_string[abi:nn180100]<0>(a1, "");
    BOOL v5 = v8 < 0;
    goto LABEL_8;
  }
  if ((SHIBYTE(v8) & 0x80000000) == 0)
  {
    *(_OWORD *)&a1->__r_.__value_.__l.__data_ = *(_OWORD *)__p;
    a1->__r_.__value_.__r.__words[2] = v8;
    return;
  }
  std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
  BOOL v5 = 1;
LABEL_8:
  if (v9 && v5)
  {
    id v6 = __p[0];
    operator delete(v6);
  }
}

char *std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    int64_t v8 = (uint64_t *)a2;
  }
  else {
    int64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = a1[1];
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    CFTypeRef v15 = *(void ***)(*a1 + 8 * v3);
    if (v15)
    {
      uint64_t v16 = (char *)*v15;
      if (*v15)
      {
        do
        {
          unint64_t v17 = *((void *)v16 + 1);
          if (v17 == v11)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)v16 + 16, (unsigned __int8 *)a2))
            {
              return v16;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v17 >= v12) {
                v17 %= v12;
              }
            }
            else
            {
              v17 &= v12 - 1;
            }
            if (v17 != v3) {
              break;
            }
          }
          uint64_t v16 = *(char **)v16;
        }
        while (v16);
      }
    }
  }
  id v18 = a1 + 2;
  uint64_t v16 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v11;
  uint64_t v19 = (std::string *)(v16 + 16);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    *((void *)v16 + 4) = *(void *)(a3 + 16);
  }
  *((void *)v16 + 5) = 0;
  float v20 = (float)(unint64_t)(a1[3] + 1);
  float v21 = *((float *)a1 + 8);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    else {
      int8x8_t prime = (int8x8_t)v23;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v12 = a1[1];
    if (*(void *)&prime > v12) {
      goto LABEL_39;
    }
    if (*(void *)&prime < v12)
    {
      unint64_t v32 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v12 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (*(void *)&prime <= v32) {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime >= v12)
      {
        unint64_t v12 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_39:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          CFDictionaryRef v26 = operator new(8 * *(void *)&prime);
          unint64_t v27 = (void *)*a1;
          *a1 = (uint64_t)v26;
          if (v27) {
            operator delete(v27);
          }
          uint64_t v28 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v28++) = 0;
          while (*(void *)&prime != v28);
          uint64_t v29 = (void *)*v18;
          if (*v18)
          {
            unint64_t v30 = v29[1];
            uint8x8_t v31 = (uint8x8_t)vcnt_s8(prime);
            v31.i16[0] = vaddlv_u8(v31);
            if (v31.u32[0] > 1uLL)
            {
              if (v30 >= *(void *)&prime) {
                v30 %= *(void *)&prime;
              }
            }
            else
            {
              v30 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v30) = v18;
            CFDictionaryRef v35 = (void *)*v29;
            if (*v29)
            {
              do
              {
                unint64_t v36 = v35[1];
                if (v31.u32[0] > 1uLL)
                {
                  if (v36 >= *(void *)&prime) {
                    v36 %= *(void *)&prime;
                  }
                }
                else
                {
                  v36 &= *(void *)&prime - 1;
                }
                if (v36 != v30)
                {
                  if (!*(void *)(*a1 + 8 * v36))
                  {
                    *(void *)(*a1 + 8 * v36) = v29;
                    goto LABEL_64;
                  }
                  *uint64_t v29 = *v35;
                  *CFDictionaryRef v35 = **(void **)(*a1 + 8 * v36);
                  **(void **)(*a1 + 8 * v36) = v35;
                  CFDictionaryRef v35 = v29;
                }
                unint64_t v36 = v30;
LABEL_64:
                uint64_t v29 = v35;
                CFDictionaryRef v35 = (void *)*v35;
                unint64_t v30 = v36;
              }
              while (v35);
            }
          }
          unint64_t v12 = (unint64_t)prime;
          goto LABEL_68;
        }
        unint64_t v41 = (void *)*a1;
        *a1 = 0;
        if (v41) {
          operator delete(v41);
        }
        unint64_t v12 = 0;
        a1[1] = 0;
      }
    }
LABEL_68:
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v37 = *a1;
  uint64_t v38 = *(void **)(*a1 + 8 * v3);
  if (v38)
  {
    *(void *)uint64_t v16 = *v38;
LABEL_81:
    void *v38 = v16;
    goto LABEL_82;
  }
  *(void *)uint64_t v16 = *v18;
  *id v18 = v16;
  *(void *)(v37 + 8 * v3) = v18;
  if (*(void *)v16)
  {
    unint64_t v39 = *(void *)(*(void *)v16 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v39 >= v12) {
        v39 %= v12;
      }
    }
    else
    {
      v39 &= v12 - 1;
    }
    uint64_t v38 = (void *)(*a1 + 8 * v39);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v16;
}

void std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](char **a1, CFTypeRef cf)
{
  BOOL v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    int v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 3;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 2 > v9) {
      unint64_t v9 = v10 >> 2;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v12 = (char *)operator new(8 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint8x8_t v13 = &v12[8 * v8];
    if (cf)
    {
      CFRetain(cf);
      int v7 = *a1;
      BOOL v5 = a1[1];
    }
    unint64_t v14 = &v12[8 * v11];
    *(void *)uint8x8_t v13 = cf;
    id v6 = v13 + 8;
    if (v5 == v7)
    {
      int64x2_t v16 = vdupq_n_s64((unint64_t)v5);
    }
    else
    {
      do
      {
        uint64_t v15 = *((void *)v5 - 1);
        v5 -= 8;
        *((void *)v13 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v15;
        v13 -= 8;
        *(void *)BOOL v5 = 0;
      }
      while (v5 != v7);
      int64x2_t v16 = *(int64x2_t *)a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = v14;
    id v18 = (char *)v16.i64[1];
    unint64_t v17 = (char *)v16.i64[0];
    while (v18 != v17)
    {
      float v20 = (const void *)*((void *)v18 - 1);
      v18 -= 8;
      uint64_t v19 = v20;
      if (v20) {
        CFRelease(v19);
      }
    }
    if (v17) {
      operator delete(v17);
    }
  }
  else
  {
    if (cf) {
      CFRetain(cf);
    }
    *(void *)BOOL v5 = cf;
    id v6 = v5 + 8;
  }
  a1[1] = v6;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,applesauce::CF::DictionaryRef>,0>(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 24);
  if (v2) {
    CFRelease(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

double applesauce::CF::convert_as<std::string,0>(uint64_t a1, const __CFString *a2)
{
  if (a2 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    CStringPtr = (char *)CFStringGetCStringPtr(a2, 0x8000100u);
    if (CStringPtr)
    {
      std::string::basic_string[abi:nn180100]<0>(&__b, CStringPtr);
    }
    else
    {
      CFIndex Length = CFStringGetLength(a2);
      CFIndex maxBufLen = 0;
      v12.location = 0;
      v12.length = Length;
      CFStringGetBytes(a2, v12, 0x8000100u, 0, 0, 0, 0, &maxBufLen);
      std::string::basic_string[abi:nn180100](&__b, maxBufLen, 0);
      if (v10 >= 0) {
        p_b = (UInt8 *)&__b;
      }
      else {
        p_b = (UInt8 *)__b;
      }
      v13.location = 0;
      v13.length = Length;
      CFStringGetBytes(a2, v13, 0x8000100u, 0, 0, p_b, maxBufLen, &maxBufLen);
    }
    double result = *(double *)&__b;
    *(_OWORD *)a1 = __b;
    *(void *)(a1 + 16) = v10;
    *(unsigned char *)(a1 + 24) = 1;
  }
  else
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 24) = 0;
  }
  return result;
}

void *std::string::basic_string[abi:nn180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    id v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *long long __b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    id v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

id filter_factory_log(void)
{
  if (filter_factory_log(void)::once_token != -1) {
    dispatch_once(&filter_factory_log(void)::once_token, &__block_literal_global_323);
  }
  id v0 = (void *)filter_factory_log(void)::log;

  return v0;
}

uint64_t ___ZL18filter_factory_logv_block_invoke()
{
  filter_factory_log(void)::log = (uint64_t)os_log_create("com.apple.TextInput", "candidateFilterFactory");

  return MEMORY[0x1F41817F8]();
}

unint64_t applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(const __CFDictionary *a1)
{
  if (a1)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, @"Position");
    if (Value)
    {
      CFNumberRef v2 = Value;
      CFTypeID TypeID = CFNumberGetTypeID();
      if (TypeID == CFGetTypeID(v2))
      {
        switch(CFNumberGetType(v2))
        {
          case kCFNumberSInt8Type:
            LOBYTE(valuePtr) = 0;
            CFNumberRef v4 = v2;
            CFNumberType v5 = kCFNumberSInt8Type;
            goto LABEL_18;
          case kCFNumberSInt16Type:
            LOWORD(valuePtr) = 0;
            CFNumberRef v11 = v2;
            CFNumberType v12 = kCFNumberSInt16Type;
            goto LABEL_26;
          case kCFNumberSInt32Type:
            LODWORD(valuePtr) = 0;
            CFNumberRef v13 = v2;
            CFNumberType v14 = kCFNumberSInt32Type;
            goto LABEL_28;
          case kCFNumberSInt64Type:
            double valuePtr = 0.0;
            CFNumberRef v15 = v2;
            CFNumberType v16 = kCFNumberSInt64Type;
            goto LABEL_39;
          case kCFNumberFloat32Type:
            LODWORD(valuePtr) = 0;
            CFNumberRef v17 = v2;
            CFNumberType v18 = kCFNumberFloat32Type;
            goto LABEL_35;
          case kCFNumberFloat64Type:
            double valuePtr = 0.0;
            CFNumberRef v19 = v2;
            CFNumberType v20 = kCFNumberFloat64Type;
            goto LABEL_41;
          case kCFNumberCharType:
            LOBYTE(valuePtr) = 0;
            CFNumberRef v4 = v2;
            CFNumberType v5 = kCFNumberCharType;
LABEL_18:
            int v21 = CFNumberGetValue(v4, v5, &valuePtr);
            if (v21) {
              char v22 = LOBYTE(valuePtr);
            }
            else {
              char v22 = 0;
            }
            if (v21 != 0 && SLOBYTE(valuePtr) < 0) {
              unint64_t v9 = -256;
            }
            else {
              unint64_t v9 = 0;
            }
            LOBYTE(v10) = v22;
            break;
          case kCFNumberShortType:
            LOWORD(valuePtr) = 0;
            CFNumberRef v11 = v2;
            CFNumberType v12 = kCFNumberShortType;
LABEL_26:
            BOOL v23 = CFNumberGetValue(v11, v12, &valuePtr) == 0;
            unsigned __int8 v24 = LOBYTE(valuePtr);
            uint64_t v25 = SLOWORD(valuePtr);
            goto LABEL_29;
          case kCFNumberIntType:
            LODWORD(valuePtr) = 0;
            CFNumberRef v13 = v2;
            CFNumberType v14 = kCFNumberIntType;
LABEL_28:
            BOOL v23 = CFNumberGetValue(v13, v14, &valuePtr) == 0;
            unsigned __int8 v24 = LOBYTE(valuePtr);
            uint64_t v25 = SLODWORD(valuePtr);
LABEL_29:
            unint64_t v26 = v25 & 0xFFFFFFFFFFFFFF00 | v24;
            if (v23) {
              unint64_t v10 = 0;
            }
            else {
              unint64_t v10 = v26;
            }
            goto LABEL_45;
          case kCFNumberLongType:
            double valuePtr = 0.0;
            CFNumberRef v15 = v2;
            CFNumberType v16 = kCFNumberLongType;
            goto LABEL_39;
          case kCFNumberLongLongType:
            double valuePtr = 0.0;
            CFNumberRef v15 = v2;
            CFNumberType v16 = kCFNumberLongLongType;
            goto LABEL_39;
          case kCFNumberFloatType:
            LODWORD(valuePtr) = 0;
            CFNumberRef v17 = v2;
            CFNumberType v18 = kCFNumberFloatType;
LABEL_35:
            BOOL v27 = CFNumberGetValue(v17, v18, &valuePtr) == 0;
            unint64_t v10 = (unint64_t)*(float *)&valuePtr;
            goto LABEL_42;
          case kCFNumberDoubleType:
            double valuePtr = 0.0;
            CFNumberRef v19 = v2;
            CFNumberType v20 = kCFNumberDoubleType;
            goto LABEL_41;
          case kCFNumberCFIndexType:
            double valuePtr = 0.0;
            CFNumberRef v15 = v2;
            CFNumberType v16 = kCFNumberCFIndexType;
            goto LABEL_39;
          case kCFNumberNSIntegerType:
            double valuePtr = 0.0;
            CFNumberRef v15 = v2;
            CFNumberType v16 = kCFNumberNSIntegerType;
LABEL_39:
            BOOL v27 = CFNumberGetValue(v15, v16, &valuePtr) == 0;
            unint64_t v10 = *(void *)&valuePtr;
            goto LABEL_42;
          case kCFNumberCGFloatType:
            double valuePtr = 0.0;
            CFNumberRef v19 = v2;
            CFNumberType v20 = kCFNumberCGFloatType;
LABEL_41:
            BOOL v27 = CFNumberGetValue(v19, v20, &valuePtr) == 0;
            unint64_t v10 = (unint64_t)valuePtr;
LABEL_42:
            if (v27) {
              unint64_t v10 = 0;
            }
LABEL_45:
            unint64_t v9 = v10 & 0xFFFFFFFFFFFFFF00;
            break;
          default:
            unint64_t v9 = 0;
            LOBYTE(v10) = 0;
            break;
        }
        unint64_t v7 = v10 | v9;
      }
      else
      {
        CFTypeID v8 = CFBooleanGetTypeID();
        if (v8 == CFGetTypeID(v2)) {
          unint64_t v7 = CFBooleanGetValue(v2);
        }
        else {
          unint64_t v7 = 0;
        }
      }
      unint64_t v6 = v7 & 0xFFFFFFFFFFFFFF00;
      unint64_t v7 = v7;
    }
    else
    {
      unint64_t v6 = 0;
      unint64_t v7 = 0;
    }
  }
  else
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
  }
  return v7 | v6;
}

void std::__stable_sort_move<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, unint64_t a3, CFTypeRef *a4)
{
  if (!a3) {
    return;
  }
  CFNumberRef v4 = a4;
  unint64_t v7 = a1;
  if (a3 == 2)
  {
    CFTypeRef v62 = &v63;
    uint64_t v63 = 0;
    unint64_t v9 = a2 - 1;
    CFTypeRef v8 = *(a2 - 1);
    if (!v8)
    {
LABEL_76:
      CFTypeRef v57 = *v7;
      if (!*v7) {
        goto LABEL_73;
      }
      goto LABEL_72;
    }
    CFRetain(v8);
    CFDictionaryRef v10 = (const __CFDictionary *)*v7;
    if (*v7)
    {
      CFRetain(*v7);
      unint64_t v11 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
      BOOL v13 = v12 != 0;
      unint64_t v14 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v10);
      if (v15) {
        unint64_t v16 = v14;
      }
      else {
        unint64_t v16 = -1;
      }
      BOOL v17 = v11 < v16;
      CFRelease(v10);
      CFRelease(v8);
      if (v13 && v17) {
        CFNumberType v18 = v9;
      }
      else {
        CFNumberType v18 = v7;
      }
      if (v13 && v17) {
        CFNumberRef v19 = v7;
      }
      else {
        CFNumberRef v19 = v9;
      }
      *CFNumberRef v4 = *v18;
      *CFNumberType v18 = 0;
      uint64_t v20 = v63;
      v4[1] = *v19;
      *CFNumberRef v19 = 0;
      uint64_t v21 = v20 + 1;
      goto LABEL_17;
    }
LABEL_69:
    CFDictionaryRef v56 = (const __CFDictionary *)v8;
LABEL_70:
    applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v56);
    goto LABEL_73;
  }
  if (a3 == 1)
  {
    *a4 = *a1;
    *a1 = 0;
    return;
  }
  if ((uint64_t)a3 > 8)
  {
    __int16 v44 = &a1[a3 >> 1];
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, v44, a3 >> 1, a4, a3 >> 1);
    std::__stable_sort<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(&v7[a3 >> 1], a2, a3 - (a3 >> 1), &v4[a3 >> 1], a3 - (a3 >> 1));
    CFTypeRef v62 = &v63;
    uint64_t v63 = 0;
    if (v44 == a2)
    {
      uint64_t v21 = 0;
LABEL_62:
      if (v7 == v44) {
        goto LABEL_18;
      }
      do
      {
        *v4++ = *v7;
        *v7++ = 0;
        ++v21;
      }
      while (v7 != v44);
LABEL_17:
      uint64_t v63 = v21;
      goto LABEL_18;
    }
    char v45 = &v7[a3 >> 1];
    while (1)
    {
      CFDictionaryRef v46 = (const __CFDictionary *)*v45;
      if (!*v45) {
        goto LABEL_76;
      }
      CFRetain(*v45);
      CFDictionaryRef v47 = (const __CFDictionary *)*v7;
      if (!*v7) {
        break;
      }
      CFRetain(*v7);
      unint64_t v48 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v46);
      uint64_t v50 = v49;
      unint64_t v51 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v47);
      if (v52) {
        unint64_t v53 = v51;
      }
      else {
        unint64_t v53 = -1;
      }
      CFRelease(v47);
      CFRelease(v46);
      if (v50 && v48 < v53)
      {
        *CFNumberRef v4 = *v45;
        *v45++ = 0;
      }
      else
      {
        *CFNumberRef v4 = *v7;
        *v7++ = 0;
      }
      uint64_t v54 = v63;
      uint64_t v21 = ++v63;
      if (v7 == v44)
      {
        if (v45 == a2) {
          goto LABEL_18;
        }
        uint64_t v55 = 1;
        do
        {
          v4[v55] = *v45;
          *v45++ = 0;
          ++v55;
        }
        while (v45 != a2);
        uint64_t v21 = v54 + v55;
        goto LABEL_17;
      }
      ++v4;
      if (v45 == a2) {
        goto LABEL_62;
      }
    }
    CFDictionaryRef v56 = v46;
    goto LABEL_70;
  }
  if (a1 != a2)
  {
    int v61 = a4;
    CFTypeRef v62 = &v63;
    *a4 = *a1;
    *a1 = 0;
    char v22 = a1 + 1;
    uint64_t v63 = 1;
    if (a1 + 1 == a2) {
      goto LABEL_18;
    }
    uint64_t v23 = 0;
    unsigned __int8 v24 = a4;
    while (1)
    {
      CFTypeRef v8 = *v22;
      if (!*v22) {
        break;
      }
      CFRetain(*v22);
      CFTypeRef v25 = *v24;
      if (!*v24) {
        goto LABEL_69;
      }
      CFDictionaryRef v60 = v24 + 1;
      CFRetain(v25);
      unint64_t v26 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
      uint64_t v28 = v27;
      unint64_t v29 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v25);
      if (v30) {
        unint64_t v31 = v29;
      }
      else {
        unint64_t v31 = -1;
      }
      CFRelease(v25);
      CFRelease(v8);
      if (!v28 || v26 >= v31)
      {
        ++v24;
        *CFDictionaryRef v60 = *v22;
        *char v22 = 0;
        ++v63;
        goto LABEL_45;
      }
      CFTypeRef v32 = *v24;
      CFTypeRef *v24 = 0;
      v24[1] = v32;
      ++v63;
      uint8x8_t v33 = v4;
      if (v24 == v4) {
        goto LABEL_44;
      }
      uint64_t v34 = v23;
      while (1)
      {
        CFDictionaryRef v35 = (char *)v4 + v34;
        CFTypeRef v8 = *v22;
        if (!*v22)
        {
          CFTypeRef v57 = (CFTypeRef)*((void *)v35 - 1);
          if (v57) {
            goto LABEL_72;
          }
LABEL_73:
          exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
          applesauce::CF::construct_error(exception);
        }
        CFRetain(*v22);
        CFDictionaryRef v36 = (const __CFDictionary *)*((void *)v35 - 1);
        if (!v36) {
          goto LABEL_69;
        }
        CFRetain(*((CFTypeRef *)v35 - 1));
        unint64_t v37 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>((const __CFDictionary *)v8);
        uint64_t v39 = v38;
        unint64_t v40 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v36);
        unint64_t v42 = v41 ? v40 : -1;
        CFRelease(v36);
        CFRelease(v8);
        if (!v39 || v37 >= v42) {
          break;
        }
        *(int8x16_t *)(v35 - 8) = vextq_s8(*(int8x16_t *)(v35 - 8), *(int8x16_t *)(v35 - 8), 8uLL);
        v34 -= 8;
        if (!v34)
        {
          uint8x8_t v33 = v4;
          goto LABEL_44;
        }
      }
      uint8x8_t v33 = (CFTypeRef *)((char *)v4 + v34);
LABEL_44:
      CFTypeRef v43 = *v33;
      *uint8x8_t v33 = *v22;
      *char v22 = v43;
      unsigned __int8 v24 = v60;
LABEL_45:
      ++v22;
      v23 += 8;
      if (v22 == a2)
      {
LABEL_18:
        int v61 = 0;
        std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100]((uint64_t *)&v61);
        return;
      }
    }
    CFTypeRef v57 = *v24;
    if (!*v24) {
      goto LABEL_73;
    }
LABEL_72:
    CFRetain(v57);
    goto LABEL_73;
  }
}

void std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    CFNumberRef v2 = (unint64_t *)a1[1];
    unint64_t v3 = *v2;
    if (*v2)
    {
      unint64_t v4 = 0;
      do
      {
        CFNumberType v5 = *(const void **)(v1 + 8 * v4);
        if (v5)
        {
          CFRelease(v5);
          unint64_t v3 = *v2;
        }
        ++v4;
      }
      while (v4 < v3);
    }
  }
}

void std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(CFTypeRef *a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, CFTypeRef *a6, uint64_t a7)
{
  uint64_t v106 = a5;
  if (a5)
  {
    while (v106 > a7 && a4 > a7)
    {
      if (!a4) {
        return;
      }
      while (1)
      {
        CFDictionaryRef v12 = (const __CFDictionary *)*a2;
        if (!*a2)
        {
          CFTypeRef v96 = *a1;
          if (!*a1) {
            goto LABEL_126;
          }
          goto LABEL_125;
        }
        CFRetain(*a2);
        CFDictionaryRef v13 = (const __CFDictionary *)*a1;
        if (!*a1) {
          goto LABEL_122;
        }
        CFRetain(*a1);
        unint64_t v14 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
        uint64_t v16 = v15;
        unint64_t v17 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v13);
        unint64_t v19 = v18 ? v17 : -1;
        CFRelease(v13);
        CFRelease(v12);
        if (v16)
        {
          if (v14 < v19) {
            break;
          }
        }
        ++a1;
        if (!--a4) {
          return;
        }
      }
      uint64_t v20 = v106;
      uint64_t v104 = a3;
      if (a4 >= v106)
      {
        if (a4 == 1)
        {
          CFTypeRef v90 = *a1;
          *a1 = 0;
          *a1 = *a2;
          *a2 = v90;
          return;
        }
        if (a4 >= 0) {
          uint64_t v39 = a4;
        }
        else {
          uint64_t v39 = a4 + 1;
        }
        uint64_t v38 = v39 >> 1;
        uint64_t v23 = &a1[v39 >> 1];
        char v22 = a2;
        if (a2 != a3)
        {
          uint64_t v99 = v39 >> 1;
          unint64_t v101 = a1;
          unint64_t v103 = a6;
          unint64_t v40 = a3 - a2;
          char v22 = a2;
          while (1)
          {
            char v41 = &v22[v40 >> 1];
            CFDictionaryRef v42 = (const __CFDictionary *)*v41;
            if (!*v41) {
              break;
            }
            CFTypeRef v43 = v22;
            CFRetain(*v41);
            CFDictionaryRef v44 = (const __CFDictionary *)*v23;
            if (!*v23)
            {
              CFDictionaryRef v95 = v42;
LABEL_123:
              applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v95);
              goto LABEL_126;
            }
            char v45 = v23;
            CFRetain(*v23);
            unint64_t v46 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v42);
            BOOL v48 = v47 != 0;
            unint64_t v49 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v44);
            if (v50) {
              unint64_t v51 = v49;
            }
            else {
              unint64_t v51 = -1;
            }
            BOOL v52 = v46 < v51;
            CFRelease(v44);
            CFRelease(v42);
            if (v48 && v52) {
              v40 += ~(v40 >> 1);
            }
            else {
              v40 >>= 1;
            }
            if (v48 && v52) {
              char v22 = v41 + 1;
            }
            else {
              char v22 = v43;
            }
            uint64_t v23 = v45;
            if (!v40)
            {
              a6 = v103;
              uint64_t v38 = v99;
              a1 = v101;
              goto LABEL_52;
            }
          }
          CFTypeRef v96 = *v23;
          if (!*v23) {
            goto LABEL_126;
          }
LABEL_125:
          CFRetain(v96);
          goto LABEL_126;
        }
LABEL_52:
        uint64_t v21 = v22 - a2;
      }
      else
      {
        if (v106 < 0) {
          uint64_t v20 = v106 + 1;
        }
        uint64_t v21 = v20 >> 1;
        char v22 = &a2[v20 >> 1];
        uint64_t v23 = a2;
        if (a2 != a1)
        {
          uint64_t v98 = v20 >> 1;
          unint64_t v100 = a1;
          unint64_t v102 = a6;
          unint64_t v24 = a2 - a1;
          uint64_t v23 = a1;
          while (1)
          {
            CFTypeRef v25 = &v23[v24 >> 1];
            CFDictionaryRef v26 = (const __CFDictionary *)*v22;
            if (!*v22) {
              break;
            }
            unsigned __int8 v27 = v22;
            uint64_t v28 = v23;
            CFRetain(*v22);
            CFDictionaryRef v29 = (const __CFDictionary *)*v25;
            if (!*v25)
            {
              CFDictionaryRef v95 = v26;
              goto LABEL_123;
            }
            CFRetain(*v25);
            unint64_t v30 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v26);
            BOOL v32 = v31 != 0;
            unint64_t v33 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v29);
            if (v34) {
              unint64_t v35 = v33;
            }
            else {
              unint64_t v35 = -1;
            }
            BOOL v36 = v30 < v35;
            CFRelease(v29);
            CFRelease(v26);
            BOOL v37 = !v32 || !v36;
            if (v32 && v36) {
              uint64_t v23 = v28;
            }
            else {
              uint64_t v23 = v25 + 1;
            }
            if (v37) {
              v24 += ~(v24 >> 1);
            }
            else {
              v24 >>= 1;
            }
            char v22 = v27;
            if (!v24)
            {
              a6 = v102;
              uint64_t v21 = v98;
              a1 = v100;
              goto LABEL_32;
            }
          }
          CFTypeRef v96 = *v25;
          if (!*v25)
          {
LABEL_126:
            exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
            applesauce::CF::construct_error(exception);
          }
          goto LABEL_125;
        }
LABEL_32:
        uint64_t v38 = v23 - a1;
      }
      if (v23 == a2)
      {
        uint64_t v54 = v22;
      }
      else if (v22 == a2)
      {
        uint64_t v54 = v23;
      }
      else
      {
        CFTypeRef v53 = *v23;
        *uint64_t v23 = 0;
        *uint64_t v23 = *a2;
        uint64_t v54 = v23 + 1;
        for (unint64_t i = a2; ; *v54++ = *i)
        {
          *i++ = v53;
          if (i == v22) {
            break;
          }
          if (v54 == a2) {
            a2 = i;
          }
          CFTypeRef v53 = *v54;
          CFTypeRef *v54 = 0;
        }
        if (v54 != a2)
        {
          CFDictionaryRef v56 = v54;
          CFTypeRef v57 = a2;
          do
          {
            while (1)
            {
              CFTypeRef v58 = *v56;
              *CFDictionaryRef v56 = 0;
              *v56++ = *v57;
              *v57++ = v58;
              if (v57 == v22) {
                break;
              }
              if (v56 == a2) {
                a2 = v57;
              }
            }
            CFTypeRef v57 = a2;
          }
          while (v56 != a2);
        }
      }
      a4 -= v38;
      uint64_t v59 = v106 - v21;
      if (v38 + v21 >= a4 + v106 - v21)
      {
        std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(v54, v22, v104, a4, v106 - v21, a6, a7);
        a2 = v23;
        uint64_t v59 = v21;
        a4 = v38;
        a3 = v54;
      }
      else
      {
        std::__inplace_merge<std::_ClassicAlgPolicy,KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition(std::vector<applesauce::CF::ArrayRef> const&)::$_0 &,std::__wrap_iter<applesauce::CF::DictionaryRef *>>(a1, v23, v54, v38, v21, a6, a7);
        a1 = v54;
        a2 = v22;
        a3 = v104;
      }
      uint64_t v106 = v59;
      if (!v59) {
        return;
      }
    }
    v108[0] = (uint64_t)a6;
    v108[1] = (uint64_t)&v109;
    uint64_t v109 = 0;
    if (a4 <= v106)
    {
      if (a1 != a2)
      {
        uint64_t v76 = 0;
        uint64_t v77 = 0;
        do
        {
          a6[v76] = a1[v76];
          a1[v76] = 0;
          ++v77;
          ++v76;
        }
        while (&a1[v76] != a2);
        uint64_t v78 = &a6[v76];
        uint64_t v109 = v77;
        if (&a6[v76] != a6)
        {
          unsigned int v79 = a2;
          while (v79 != a3)
          {
            CFDictionaryRef v12 = (const __CFDictionary *)*v79;
            if (!*v79)
            {
              CFTypeRef v96 = *a6;
              if (!*a6) {
                goto LABEL_126;
              }
              goto LABEL_125;
            }
            unint64_t v80 = a3;
            long long v81 = v79;
            CFRetain(*v79);
            CFDictionaryRef v82 = (const __CFDictionary *)*a6;
            if (!*a6)
            {
LABEL_122:
              CFDictionaryRef v95 = v12;
              goto LABEL_123;
            }
            CFRetain(*a6);
            unint64_t v83 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
            uint64_t v85 = v84;
            unint64_t v86 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v82);
            if (v87) {
              unint64_t v88 = v86;
            }
            else {
              unint64_t v88 = -1;
            }
            CFRelease(v82);
            CFRelease(v12);
            CFTypeRef v89 = *a1;
            if (v85 && v83 < v88)
            {
              *a1 = *v81;
              *v81++ = v89;
            }
            else
            {
              *a1 = *a6;
              *a6++ = v89;
            }
            ++a1;
            unsigned int v79 = v81;
            a3 = v80;
            if (a6 == v78) {
              goto LABEL_120;
            }
          }
          uint64_t v93 = 0;
          do
          {
            CFTypeRef v94 = a1[v93];
            a1[v93] = a6[v93];
            a6[v93++] = v94;
          }
          while (&a6[v93 - 1] != v78 - 1);
        }
      }
    }
    else if (a3 != a2)
    {
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      do
      {
        a6[v60] = a2[v60];
        a2[v60] = 0;
        ++v61;
        ++v60;
      }
      while (&a2[v60] != a3);
      CFTypeRef v62 = a2;
      uint64_t v63 = &a6[v60];
      uint64_t v109 = v61;
      if (&a6[v60] != a6)
      {
        uint64_t v64 = a3 - 1;
        while (v62 != a1)
        {
          unint64_t v65 = v62 - 1;
          CFDictionaryRef v12 = (const __CFDictionary *)*(v63 - 1);
          if (!v12)
          {
            CFTypeRef v96 = *v65;
            if (!*v65) {
              goto LABEL_126;
            }
            goto LABEL_125;
          }
          uint64_t v66 = v62;
          CFRetain(*(v63 - 1));
          CFDictionaryRef v67 = (const __CFDictionary *)*v65;
          if (!*v65) {
            goto LABEL_122;
          }
          CFRetain(*v65);
          unint64_t v68 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v12);
          BOOL v107 = v69 != 0;
          unint64_t v70 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v67);
          if (v71) {
            unint64_t v72 = v70;
          }
          else {
            unint64_t v72 = -1;
          }
          BOOL v73 = v68 < v72;
          CFRelease(v67);
          CFRelease(v12);
          CFTypeRef v74 = *v64;
          if (v107 && v73) {
            unint64_t v75 = v66;
          }
          else {
            unint64_t v75 = v63;
          }
          if (v107 && v73) {
            CFTypeRef v62 = v65;
          }
          else {
            CFTypeRef v62 = v66;
          }
          if (!v107 || !v73) {
            --v63;
          }
          *v64-- = *(v75 - 1);
          *(v75 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v74;
          if (v63 == a6) {
            goto LABEL_120;
          }
        }
        uint64_t v91 = 0;
        do
        {
          CFTypeRef v92 = v64[v91];
          v64[v91] = v63[v91 - 1];
          v63[--v91] = v92;
        }
        while (&v63[v91] != a6);
      }
    }
LABEL_120:
    std::unique_ptr<applesauce::CF::DictionaryRef,std::__destruct_n &>::reset[abi:nn180100](v108);
  }
}

void KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = *(void *)(a1 + 88);
  while (1)
  {
    uint64_t v6 = v4;
    unint64_t v7 = v5 + v4;
    uint64_t v8 = *(void *)(a1 + 24);
    if (v7 >= (*(void *)(a1 + 32) - v8) >> 3) {
      break;
    }
    CFDictionaryRef v9 = *(const __CFDictionary **)(v8 + 8 * v5 + 8 * v6);
    if (!v9) {
      goto LABEL_78;
    }
    unint64_t v10 = applesauce::CF::details::find_at_key_or_optional<unsigned long,__CFString const* const&>(v9);
    if (v11) {
      unint64_t v12 = v10;
    }
    else {
      unint64_t v12 = -1;
    }
    uint64_t v4 = v6 + 1;
    if (v12 > v6 + 1 + ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3))
    {
      unint64_t v7 = v5 + v6;
      break;
    }
  }
  for (unint64_t i = *(void *)(a1 + 88); i < v7; *(void *)(a1 + 88) = i)
  {
    uint64_t v14 = *(void *)(a1 + 24);
    if (i >= (*(void *)(a1 + 32) - v14) >> 3) {
      break;
    }
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)a1, *(CFTypeRef *)(v14 + 8 * i));
    unint64_t i = *(void *)(a1 + 88) + 1;
  }
  CFDictionaryRef v15 = (const __CFDictionary *)*a2;
  if (*a2)
  {
    CFRetain(*a2);
    extract_name((uint64_t)v48, v15);
    CFRelease(v15);
  }
  else
  {
    extract_name((uint64_t)v48, 0);
  }
  if ((v49 & 0x80u) == 0) {
    uint64_t v16 = (uint64_t *)v48;
  }
  else {
    uint64_t v16 = (uint64_t *)v48[0];
  }
  if ((v49 & 0x80u) == 0) {
    unint64_t v17 = v49;
  }
  else {
    unint64_t v17 = (unint64_t)v48[1];
  }
  unint64_t v18 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v16, v17);
  int8x8_t v19 = *(int8x8_t *)(a1 + 56);
  if (!*(void *)&v19) {
    goto LABEL_38;
  }
  unint64_t v20 = v18;
  uint8x8_t v21 = (uint8x8_t)vcnt_s8(v19);
  v21.i16[0] = vaddlv_u8(v21);
  unint64_t v22 = v21.u32[0];
  if (v21.u32[0] > 1uLL)
  {
    unint64_t v23 = v18;
    if (v18 >= *(void *)&v19) {
      unint64_t v23 = v18 % *(void *)&v19;
    }
  }
  else
  {
    unint64_t v23 = (*(void *)&v19 - 1) & v18;
  }
  unint64_t v24 = *(unsigned __int8 ***)(*(void *)(a1 + 48) + 8 * v23);
  if (!v24 || (CFTypeRef v25 = *v24) == 0)
  {
LABEL_38:
    std::string::basic_string[abi:nn180100]<0>(&__p, "");
    CFDictionaryRef v27 = 0;
    goto LABEL_39;
  }
  while (1)
  {
    unint64_t v26 = *((void *)v25 + 1);
    if (v20 == v26) {
      break;
    }
    if (v22 > 1)
    {
      if (v26 >= *(void *)&v19) {
        v26 %= *(void *)&v19;
      }
    }
    else
    {
      v26 &= *(void *)&v19 - 1;
    }
    if (v26 != v23) {
      goto LABEL_38;
    }
LABEL_37:
    CFTypeRef v25 = *(unsigned __int8 **)v25;
    if (!v25) {
      goto LABEL_38;
    }
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v25 + 16, (unsigned __int8 *)v48)) {
    goto LABEL_37;
  }
  CFDictionaryRef v42 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t *)(a1 + 48), (uint64_t)v48, (uint64_t)v48);
  CFDictionaryRef v27 = (const __CFDictionary *)*((void *)v42 + 5);
  if (!v27) {
    goto LABEL_38;
  }
  CFRetain(*((CFTypeRef *)v42 + 5));
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, v27, @"Operation");
LABEL_39:
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size != 6)
  {
    if (size == 8)
    {
      std::__split_buffer<std::string>::pointer p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if (p_p->__r_.__value_.__r.__words[0] == 0x656469727265764FLL)
      {
        unint64_t v30 = (char **)a1;
        CFTypeRef v31 = v27;
        goto LABEL_54;
      }
    }
LABEL_53:
    CFTypeRef v31 = *a2;
    unint64_t v30 = (char **)a1;
LABEL_54:
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100](v30, v31);
    goto LABEL_55;
  }
  BOOL v32 = &__p;
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    BOOL v32 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  int data = (int)v32->__r_.__value_.__l.__data_;
  int v34 = WORD2(v32->__r_.__value_.__r.__words[0]);
  if (data != 1701602628 || v34 != 25972) {
    goto LABEL_53;
  }
  if (!v27) {
    goto LABEL_78;
  }
  CFTypeRef cf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&v46, v27, @"Parameters", &cf);
  if (cf) {
    CFRelease(cf);
  }
  CFDictionaryRef v36 = (const __CFDictionary *)*a2;
  if (!*a2)
  {
LABEL_78:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  CFTypeRef v44 = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&cf, v36, @"Parameters", &v44);
  if (v44) {
    CFRelease(v44);
  }
  CFTypeRef v37 = cf;
  uint64_t v38 = v46;
  if (v46)
  {
    if (cf)
    {
      uint64_t v39 = (id)cf;
      char v41 = areDictionariesEqualWithPrecision(v39, v38, v40);

      if ((v41 & 1) == 0) {
        std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)a1, *a2);
      }
      CFRelease(v39);
    }
    CFTypeRef v37 = v38;
  }
  else if (!cf)
  {
    goto LABEL_55;
  }
  CFRelease(v37);
LABEL_55:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (v27) {
    CFRelease(v27);
  }
  if ((char)v49 < 0) {
    operator delete(v48[0]);
  }
}

void sub_1E3F97B44()
{
}

void applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(void *a1, CFDictionaryRef theDict, void *key, void *a4)
{
  if (!key) {
    goto LABEL_8;
  }
  CFNumberRef Value = CFDictionaryGetValue(theDict, key);
  if (!Value) {
    goto LABEL_8;
  }
  unint64_t v7 = Value;
  CFRetain(Value);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFDictionaryGetTypeID())
  {
    CFRelease(v7);
LABEL_8:
    *a1 = *a4;
    *a4 = 0;
    return;
  }
  CFRetain(v7);
  *a1 = v7;

  CFRelease(v7);
}

uint64_t areDictionariesEqualWithPrecision(NSDictionary *a1, NSDictionary *a2, float a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1;
  uint64_t v5 = a2;
  uint64_t v6 = [(NSDictionary *)v4 count];
  if (v6 == [(NSDictionary *)v5 count])
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    unint64_t v7 = v4;
    uint64_t v8 = [(NSDictionary *)v7 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)v22;
      while (2)
      {
        for (uint64_t i = 0; i != v9; ++i)
        {
          if (*(void *)v22 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v12 = *(void *)(*((void *)&v21 + 1) + 8 * i);
          -[NSDictionary objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", v12, (void)v21);
          CFDictionaryRef v13 = (NSDictionary *)objc_claimAutoreleasedReturnValue();
          uint64_t v14 = [(NSDictionary *)v5 objectForKeyedSubscript:v12];
          if (!v14)
          {
LABEL_22:

            uint64_t v19 = 0;
            goto LABEL_24;
          }
          objc_opt_class();
          if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
          {
            if ((areDictionariesEqualWithPrecision(v13, v14, v15) & 1) == 0) {
              goto LABEL_22;
            }
          }
          else
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass() & 1) != 0 && (objc_opt_class(), (objc_opt_isKindOfClass()))
            {
              [(NSDictionary *)v13 floatValue];
              float v17 = v16;
              [(NSDictionary *)v14 floatValue];
              if (vabds_f32(v17, v18) > 0.001) {
                goto LABEL_22;
              }
            }
            else
            {
              objc_opt_class();
              if ((objc_opt_isKindOfClass() & 1) == 0 || ![(NSDictionary *)v13 isEqual:v14]) {
                goto LABEL_22;
              }
            }
          }
        }
        uint64_t v9 = [(NSDictionary *)v7 countByEnumeratingWithState:&v21 objects:v25 count:16];
        uint64_t v19 = 1;
        if (v9) {
          continue;
        }
        break;
      }
    }
    else
    {
      uint64_t v19 = 1;
    }
LABEL_24:
  }
  else
  {
    uint64_t v19 = 0;
  }

  return v19;
}

__n128 KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters@<Q0>(KB::CandidateFilterFactory::FilterStackDefinition *this@<X0>, const KB::CandidateFilterConfiguration *a2@<X1>, void *a3@<X8>)
{
  unint64_t v6 = *((void *)this + 11);
  uint64_t v7 = *((void *)this + 3);
  for (uint64_t i = *((void *)this + 4); v6 < (i - v7) >> 3; uint64_t i = *((void *)this + 4))
  {
    *((void *)this + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v6 + 1;
    std::vector<applesauce::CF::DictionaryRef>::push_back[abi:nn180100]((char **)this, *(CFTypeRef *)(v7 + 8 * v6));
    unint64_t v6 = *((void *)this + 11);
    uint64_t v7 = *((void *)this + 3);
  }
  CFDictionaryRef v36 = 0;
  int64x2_t v35 = 0u;
  uint64_t v9 = *(CFTypeRef **)this;
  uint64_t v10 = (CFTypeRef *)*((void *)this + 1);
  if (*(CFTypeRef **)this == v10)
  {
    uint64_t v28 = 0;
    int64x2_t v32 = 0uLL;
  }
  else
  {
    CFTypeRef v31 = a3;
    char v11 = 0;
    do
    {
      CFTypeRef v12 = *v9;
      if (*v9)
      {
        CFRetain(*v9);
        CFTypeRef v33 = v12;
        KB::CandidateFilterFactory::create_single_filter_from_specification(&v33, (uint64_t)a2, &v34);
        CFRelease(v12);
        if ((void)v34)
        {
          if (v11 >= v36)
          {
            uint64_t v14 = (char *)v35.i64[0];
            uint64_t v15 = (uint64_t)&v11[-v35.i64[0]] >> 4;
            unint64_t v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 60) {
              abort();
            }
            uint64_t v17 = (uint64_t)&v36[-v35.i64[0]];
            if ((uint64_t)&v36[-v35.i64[0]] >> 3 > v16) {
              unint64_t v16 = v17 >> 3;
            }
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v18 = v16;
            }
            if (v18 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v19 = (char *)operator new(16 * v18);
            unint64_t v20 = &v19[16 * v15];
            uint64_t v21 = *((void *)&v34 + 1);
            *(_OWORD *)unint64_t v20 = v34;
            if (v21)
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
              char v11 = (char *)v35.i64[1];
            }
            if (v11 == v14)
            {
              int64x2_t v24 = vdupq_n_s64((unint64_t)v11);
              long long v22 = &v19[16 * v15];
            }
            else
            {
              long long v22 = &v19[16 * v15];
              do
              {
                long long v23 = *((_OWORD *)v11 - 1);
                v11 -= 16;
                *((_OWORD *)v22 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v23;
                v22 -= 16;
                *(void *)char v11 = 0;
                *((void *)v11 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
              }
              while (v11 != v14);
              int64x2_t v24 = v35;
            }
            char v11 = v20 + 16;
            v35.i64[0] = (uint64_t)v22;
            v35.i64[1] = (uint64_t)(v20 + 16);
            CFDictionaryRef v36 = &v19[16 * v18];
            uint64_t v26 = (char *)v24.i64[1];
            CFTypeRef v25 = (char *)v24.i64[0];
            while (v26 != v25)
            {
              CFDictionaryRef v27 = (std::__shared_weak_count *)*((void *)v26 - 1);
              if (v27) {
                std::__shared_weak_count::__release_shared[abi:nn180100](v27);
              }
              v26 -= 16;
            }
            if (v25) {
              operator delete(v25);
            }
          }
          else
          {
            *(void *)char v11 = v34;
            uint64_t v13 = *((void *)&v34 + 1);
            *((void *)v11 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = *((void *)&v34 + 1);
            if (v13) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
            }
            v11 += 16;
          }
          v35.i64[1] = (uint64_t)v11;
        }
        if (*((void *)&v34 + 1)) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v34 + 1));
        }
      }
      ++v9;
    }
    while (v9 != v10);
    int64x2_t v32 = v35;
    uint64_t v28 = v36;
    a3 = v31;
  }
  CFDictionaryRef v29 = (int64x2_t *)operator new(0x38uLL);
  v29->i64[1] = 0;
  v29[1].i64[0] = 0;
  v29->i64[0] = (uint64_t)&unk_1F3F72AB8;
  v29[1].i64[1] = (uint64_t)&unk_1F3F78FE0;
  v29[2] = v32;
  v29[3].i64[0] = (uint64_t)v28;
  CFDictionaryRef v36 = 0;
  int64x2_t v35 = 0uLL;
  *a3 = (char *)v29 + 24;
  a3[1] = v29;
  *(void *)&long long v34 = &v35;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v34);
  return result;
}

void KB::CandidateFilterFactory::create_single_filter_from_specification(CFTypeRef *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v5 = (const __CFDictionary *)*a1;
  if (!v5)
  {
    uint64_t v10 = filter_factory_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1E3F0E000, v10, OS_LOG_TYPE_INFO, "Single filter specification root object is null or not a dictionary.", buf, 2u);
    }

    goto LABEL_11;
  }
  unsigned __int16 v7 = applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v5);
  if (v7 >= 0x100u && v7 == 0)
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    extract_name((uint64_t)__p, v9);
    CFRelease(v9);
  }
  else
  {
    extract_name((uint64_t)__p, 0);
  }
  char v11 = filter_factory_log();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    CFTypeRef v12 = __p;
    if ((v33 & 0x80u) != 0) {
      CFTypeRef v12 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&uint8_t buf[4] = v12;
    _os_log_impl(&dword_1E3F0E000, v11, OS_LOG_TYPE_INFO, "Creating filter '%s'.", buf, 0xCu);
  }

  uint64_t v13 = (const char *)[@"CustomFilter" UTF8String];
  uint64_t v14 = v13;
  if ((v33 & 0x80u) == 0) {
    size_t v15 = v33;
  }
  else {
    size_t v15 = (size_t)__p[1];
  }
  if (v15 == strlen(v13))
  {
    unint64_t v16 = (v33 & 0x80u) == 0 ? __p : (void **)__p[0];
    if (!memcmp(v16, v14, v15))
    {
      uint64_t v26 = *(void *)(a2 + 176);
      *a3 = *(void *)(a2 + 168);
      a3[1] = v26;
      if (v26) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
      }
      goto LABEL_53;
    }
  }
  CFDictionaryRef v17 = (const __CFDictionary *)*a1;
  if (!*a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  *(void *)buf = 0;
  applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&cf, v17, @"Parameters", buf);
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  unint64_t v18 = filter_factory_log();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1E3F0E000, v18, OS_LOG_TYPE_INFO, "Looking for filter factory...", buf, 2u);
  }

  KB::CandidateFilterFactory::filter_factory_for_name((uint64_t)__p, (uint64_t)buf);
  int v19 = v38;
  unint64_t v20 = filter_factory_log();
  uint64_t v21 = v20;
  if (!v19)
  {
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v27 = __p;
      if ((v33 & 0x80u) != 0) {
        CFDictionaryRef v27 = (void **)__p[0];
      }
      *(_DWORD *)long long v34 = 136315138;
      int64x2_t v35 = v27;
      _os_log_error_impl(&dword_1E3F0E000, v21, OS_LOG_TYPE_ERROR, "Unrecognized filter name '%s'", v34, 0xCu);
    }

    *a3 = 0;
    a3[1] = 0;
    goto LABEL_49;
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    long long v22 = __p;
    if ((v33 & 0x80u) != 0) {
      long long v22 = (void **)__p[0];
    }
    *(_DWORD *)long long v34 = 136315138;
    int64x2_t v35 = v22;
    _os_log_impl(&dword_1E3F0E000, v21, OS_LOG_TYPE_INFO, "Found filter factory for '%s'.", v34, 0xCu);
  }

  if (!v38)
  {
    std::__throw_bad_optional_access[abi:nn180100]();
LABEL_63:
    CFDictionaryRef v29 = std::__throw_bad_function_call[abi:nn180100]();
    applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>((const __CFDictionary *)v29);
    return;
  }
  CFTypeRef v23 = cf;
  if (cf) {
    CFRetain(cf);
  }
  CFTypeRef v30 = v23;
  if (!v37) {
    goto LABEL_63;
  }
  (*(void (**)(uint64_t, CFTypeRef *, uint64_t))(*(void *)v37 + 48))(v37, &v30, a2);
  if (v30) {
    CFRelease(v30);
  }
  if (!*a3)
  {
    int64x2_t v24 = filter_factory_log();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
    {
      CFTypeRef v25 = __p;
      if ((v33 & 0x80u) != 0) {
        CFTypeRef v25 = (void **)__p[0];
      }
      *(_DWORD *)long long v34 = 136315138;
      int64x2_t v35 = v25;
      _os_log_impl(&dword_1E3F0E000, v24, OS_LOG_TYPE_INFO, "Skipped filter '%s' for provided specification and configuration.", v34, 0xCu);
    }
  }
LABEL_49:
  if (v38) {
    std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__value_func[abi:nn180100](buf);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_53:
  if ((char)v33 < 0) {
    operator delete(__p[0]);
  }
}

uint64_t applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(const __CFDictionary *a1)
{
  CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(a1, @"Enabled");
  if (Value)
  {
    CFBooleanRef v2 = Value;
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID == CFGetTypeID(v2))
    {
      BOOL v4 = CFBooleanGetValue(v2) != 0;
LABEL_42:
      int v5 = 1;
      return v4 | (v5 << 8);
    }
    CFTypeID v6 = CFNumberGetTypeID();
    if (v6 == CFGetTypeID(v2))
    {
      switch(CFNumberGetType(v2))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          CFNumberRef v7 = v2;
          CFNumberType v8 = kCFNumberSInt8Type;
          goto LABEL_15;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          CFNumberRef v9 = v2;
          CFNumberType v10 = kCFNumberSInt16Type;
          goto LABEL_17;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          CFNumberRef v11 = v2;
          CFNumberType v12 = kCFNumberSInt32Type;
          goto LABEL_19;
        case kCFNumberSInt64Type:
          double valuePtr = 0.0;
          CFNumberRef v13 = v2;
          CFNumberType v14 = kCFNumberSInt64Type;
          goto LABEL_30;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          CFNumberRef v15 = v2;
          CFNumberType v16 = kCFNumberFloat32Type;
          goto LABEL_26;
        case kCFNumberFloat64Type:
          double valuePtr = 0.0;
          CFNumberRef v17 = v2;
          CFNumberType v18 = kCFNumberFloat64Type;
          goto LABEL_34;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          CFNumberRef v7 = v2;
          CFNumberType v8 = kCFNumberCharType;
LABEL_15:
          int v19 = CFNumberGetValue(v7, v8, &valuePtr);
          BOOL v20 = v19 == 0;
          int v21 = LOBYTE(valuePtr);
          goto LABEL_20;
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          CFNumberRef v9 = v2;
          CFNumberType v10 = kCFNumberShortType;
LABEL_17:
          int v19 = CFNumberGetValue(v9, v10, &valuePtr);
          BOOL v20 = v19 == 0;
          int v21 = LOWORD(valuePtr);
          goto LABEL_20;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          CFNumberRef v11 = v2;
          CFNumberType v12 = kCFNumberIntType;
LABEL_19:
          int v19 = CFNumberGetValue(v11, v12, &valuePtr);
          BOOL v20 = v19 == 0;
          int v21 = LODWORD(valuePtr);
LABEL_20:
          BOOL v22 = v20 || v21 == 0;
          break;
        case kCFNumberLongType:
          double valuePtr = 0.0;
          CFNumberRef v13 = v2;
          CFNumberType v14 = kCFNumberLongType;
          goto LABEL_30;
        case kCFNumberLongLongType:
          double valuePtr = 0.0;
          CFNumberRef v13 = v2;
          CFNumberType v14 = kCFNumberLongLongType;
          goto LABEL_30;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          CFNumberRef v15 = v2;
          CFNumberType v16 = kCFNumberFloatType;
LABEL_26:
          int v19 = CFNumberGetValue(v15, v16, &valuePtr);
          BOOL v23 = *(float *)&valuePtr == 0.0;
          goto LABEL_35;
        case kCFNumberDoubleType:
          double valuePtr = 0.0;
          CFNumberRef v17 = v2;
          CFNumberType v18 = kCFNumberDoubleType;
          goto LABEL_34;
        case kCFNumberCFIndexType:
          double valuePtr = 0.0;
          CFNumberRef v13 = v2;
          CFNumberType v14 = kCFNumberCFIndexType;
          goto LABEL_30;
        case kCFNumberNSIntegerType:
          double valuePtr = 0.0;
          CFNumberRef v13 = v2;
          CFNumberType v14 = kCFNumberNSIntegerType;
LABEL_30:
          int v19 = CFNumberGetValue(v13, v14, &valuePtr);
          if (v19) {
            BOOL v22 = *(void *)&valuePtr == 0;
          }
          else {
            BOOL v22 = 1;
          }
          break;
        case kCFNumberCGFloatType:
          double valuePtr = 0.0;
          CFNumberRef v17 = v2;
          CFNumberType v18 = kCFNumberCGFloatType;
LABEL_34:
          int v19 = CFNumberGetValue(v17, v18, &valuePtr);
          BOOL v23 = valuePtr == 0.0;
LABEL_35:
          BOOL v22 = v23 || v19 == 0;
          break;
        default:
          goto LABEL_8;
      }
      BOOL v4 = !v22;
      if (v19) {
        goto LABEL_42;
      }
    }
    else
    {
LABEL_8:
      BOOL v4 = 0;
    }
    int v5 = 0;
    return v4 | (v5 << 8);
  }
  int v5 = 0;
  BOOL v4 = 0;
  return v4 | (v5 << 8);
}

uint64_t KB::CandidateFilterFactory::filter_factory_for_name@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = KB::CandidateFilterFactory::filter_factory_lookup_table((KB::CandidateFilterFactory *)a1);
  memset(v19, 0, sizeof(v19));
  int v20 = *(_DWORD *)(v4 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v19, *(void *)(v4 + 8));
  for (uint64_t i = *(void **)(v4 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>> const&>((uint64_t)v19, (uint64_t)(i + 2), (uint64_t)(i + 2));
  int v6 = *(char *)(a1 + 23);
  if (v6 >= 0) {
    CFNumberRef v7 = (uint64_t *)a1;
  }
  else {
    CFNumberRef v7 = *(uint64_t **)a1;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a1 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  unint64_t v10 = *((void *)&v19[0] + 1);
  if (!*((void *)&v19[0] + 1)) {
    goto LABEL_25;
  }
  unint64_t v11 = v9;
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)v19 + 8));
  v12.i16[0] = vaddlv_u8(v12);
  unint64_t v13 = v12.u32[0];
  if (v12.u32[0] > 1uLL)
  {
    unint64_t v14 = v9;
    if (v9 >= *((void *)&v19[0] + 1)) {
      unint64_t v14 = v9 % *((void *)&v19[0] + 1);
    }
  }
  else
  {
    unint64_t v14 = (*((void *)&v19[0] + 1) - 1) & v9;
  }
  CFNumberRef v15 = *(unsigned __int8 ***)(*(void *)&v19[0] + 8 * v14);
  if (!v15 || (CFNumberType v16 = *v15) == 0)
  {
LABEL_25:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 32) = 0;
    return std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table((uint64_t)v19);
  }
  while (1)
  {
    unint64_t v17 = *((void *)v16 + 1);
    if (v17 == v11) {
      break;
    }
    if (v13 > 1)
    {
      if (v17 >= v10) {
        v17 %= v10;
      }
    }
    else
    {
      v17 &= v10 - 1;
    }
    if (v17 != v14) {
      goto LABEL_25;
    }
LABEL_24:
    CFNumberType v16 = *(unsigned __int8 **)v16;
    if (!v16) {
      goto LABEL_25;
    }
  }
  if (!std::equal_to<std::string>::operator()[abi:nn180100](v16 + 16, (unsigned __int8 *)a1)) {
    goto LABEL_24;
  }
  std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__value_func[abi:nn180100]((uint64_t)v21, (uint64_t)(v16 + 40));
  if (v22)
  {
    if (v22 == v21)
    {
      *(void *)(a2 + 24) = a2;
      (*(void (**)(void *, uint64_t))(v21[0] + 24))(v21, a2);
    }
    else
    {
      *(void *)(a2 + 24) = v22;
      BOOL v22 = 0;
    }
  }
  else
  {
    *(void *)(a2 + 24) = 0;
  }
  *(unsigned char *)(a2 + 32) = 1;
  std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__value_func[abi:nn180100](v21);
  return std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table((uint64_t)v19);
}

void *std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__value_func[abi:nn180100](void *a1)
{
  CFBooleanRef v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t KB::CandidateFilterFactory::filter_factory_lookup_table(KB::CandidateFilterFactory *this)
{
  {
    __cxa_atexit((void (*)(void *))std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::~unique_ptr[abi:nn180100], &KB::CandidateFilterFactory::filter_factory_lookup_table(void)::lookup_table_ptr, &dword_1E3F0E000);
  }
  if (KB::CandidateFilterFactory::filter_factory_lookup_table(void)::once_token != -1) {
    dispatch_once(&KB::CandidateFilterFactory::filter_factory_lookup_table(void)::once_token, &__block_literal_global_4579);
  }
  return KB::CandidateFilterFactory::filter_factory_lookup_table(void)::lookup_table_ptr;
}

uint64_t std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table(uint64_t a1)
{
  CFBooleanRef v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      CFBooleanRef v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,0>(uint64_t a1)
{
  std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__value_func[abi:nn180100]((void *)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
  {
    CFBooleanRef v2 = *(void **)a1;
    operator delete(v2);
  }
}

void std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>> const&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(char *)(a2 + 23);
  if (v7 >= 0) {
    unint64_t v8 = (uint64_t *)a2;
  }
  else {
    unint64_t v8 = *(uint64_t **)a2;
  }
  if (v7 >= 0) {
    unint64_t v9 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v9 = *(void *)(a2 + 8);
  }
  unint64_t v10 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v8, v9);
  unint64_t v11 = v10;
  unint64_t v12 = *(void *)(a1 + 8);
  if (v12)
  {
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v3 = v10;
      if (v10 >= v12) {
        unint64_t v3 = v10 % v12;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v10;
    }
    CFNumberRef v15 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v3);
    if (v15)
    {
      for (uint64_t i = *v15; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v17 = *((void *)i + 1);
        if (v17 == v11)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2)) {
            return;
          }
        }
        else
        {
          if (v14 > 1)
          {
            if (v17 >= v12) {
              v17 %= v12;
            }
          }
          else
          {
            v17 &= v12 - 1;
          }
          if (v17 != v3) {
            break;
          }
        }
      }
    }
  }
  CFNumberType v18 = operator new(0x48uLL);
  *CFNumberType v18 = 0;
  v18[1] = v11;
  int v19 = (std::string *)(v18 + 2);
  if (*(char *)(a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v19, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)&v19->__r_.__value_.__l.__data_ = *(_OWORD *)a3;
    void v18[4] = *(void *)(a3 + 16);
  }
  std::__function::__value_func<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__value_func[abi:nn180100]((uint64_t)(v18 + 5), a3 + 24);
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v12 || (float)(v21 * (float)v12) < v20)
  {
    BOOL v22 = 1;
    if (v12 >= 3) {
      BOOL v22 = (v12 & (v12 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v12);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v25);
    unint64_t v12 = *(void *)(a1 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v11 >= v12) {
        unint64_t v3 = v11 % v12;
      }
      else {
        unint64_t v3 = v11;
      }
    }
    else
    {
      unint64_t v3 = (v12 - 1) & v11;
    }
  }
  uint64_t v26 = *(void *)a1;
  CFDictionaryRef v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *CFNumberType v18 = *v27;
LABEL_47:
    *CFDictionaryRef v27 = v18;
    goto LABEL_48;
  }
  *CFNumberType v18 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v18;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*v18)
  {
    unint64_t v28 = *(void *)(*v18 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      if (v28 >= v12) {
        v28 %= v12;
      }
    }
    else
    {
      v28 &= v12 - 1;
    }
    CFDictionaryRef v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_47;
  }
LABEL_48:
  ++*(void *)(a1 + 24);
}

void ___ZN2KB22CandidateFilterFactory27filter_factory_lookup_tableEv_block_invoke()
{
  v81[4] = *MEMORY[0x1E4F143B8];
  std::string::basic_string[abi:nn180100]<0>(v0, "FilterZeroProbability");
  v1[0] = &unk_1F3F72B10;
  v1[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterZeroProbability>;
  v1[3] = v1;
  std::string::basic_string[abi:nn180100]<0>(v2, "FilterWordsConflictingWithValidContactNames");
  v3[0] = &unk_1F3F72B10;
  v3[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordsConflictingWithValidContactNames>;
  void v3[3] = v3;
  std::string::basic_string[abi:nn180100]<0>(v4, "FilterAppNames");
  v5[0] = &unk_1F3F72B10;
  v5[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAppNames>;
  v5[3] = v5;
  std::string::basic_string[abi:nn180100]<0>(v6, "FilterIncomplete");
  v7[0] = &unk_1F3F72B10;
  v7[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterIncomplete>;
  _WORD v7[3] = v7;
  std::string::basic_string[abi:nn180100]<0>(v8, "FilterControlCharacters");
  v9[0] = &unk_1F3F72B10;
  v9[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterControlCharacters>;
  void v9[3] = v9;
  std::string::basic_string[abi:nn180100]<0>(v10, "FilterNotSuggestibleForInput");
  v11[0] = &unk_1F3F72B10;
  v11[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>;
  _WORD v11[3] = v11;
  std::string::basic_string[abi:nn180100]<0>(v12, "FilterNumberMismatch");
  v13[0] = &unk_1F3F72B10;
  v13[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberMismatch>;
  _OWORD v13[3] = v13;
  std::string::basic_string[abi:nn180100]<0>(v14, "FilterNumberlikeTokenMismatch");
  v15[0] = &unk_1F3F72B10;
  v15[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberlikeTokenMismatch>;
  void v15[3] = v15;
  std::string::basic_string[abi:nn180100]<0>(v16, "FilterCharacterCount");
  v17[0] = &unk_1F3F72B10;
  v17[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>;
  void v17[3] = v17;
  std::string::basic_string[abi:nn180100]<0>(v18, "FilterAlteredURLFragments");
  v19[0] = &unk_1F3F72B10;
  v19[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAlteredURLFragments>;
  _WORD v19[3] = v19;
  std::string::basic_string[abi:nn180100]<0>(v20, "FilterDoubleApostrophe");
  v21[0] = &unk_1F3F72B10;
  v21[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDoubleApostrophe>;
  void v21[3] = v21;
  std::string::basic_string[abi:nn180100]<0>(v22, "FilterWordEndingApostropheBetweenNonseparators");
  v23[0] = &unk_1F3F72B10;
  v23[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordEndingApostropheBetweenNonseparators>;
  void v23[3] = v23;
  std::string::basic_string[abi:nn180100]<0>(v24, "FilterPopupVariantMismatch");
  v25[0] = &unk_1F3F72B10;
  v25[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPopupVariantMismatch>;
  void v25[3] = v25;
  std::string::basic_string[abi:nn180100]<0>(v26, "FilterAllCapsNoSuggestWordsOfLength");
  v27[0] = &unk_1F3F72B10;
  v27[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAllCapsNoSuggestWordsOfLength>;
  void v27[3] = v27;
  std::string::basic_string[abi:nn180100]<0>(v28, "FilterMissingOneLetterWordFromInput");
  v29[0] = &unk_1F3F72B10;
  v29[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterMissingOneLetterWordFromInput>;
  v29[3] = v29;
  std::string::basic_string[abi:nn180100]<0>(v30, "FilterCorrectionsIfAnyCandidateMatchesInput");
  v31[0] = &unk_1F3F72B10;
  v31[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCorrectionsIfAnyCandidateMatchesInput>;
  void v31[3] = v31;
  std::string::basic_string[abi:nn180100]<0>(v32, "FilterNondominantCorrectionOfMoreWords");
  v33[0] = &unk_1F3F72B10;
  v33[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNondominantCorrectionOfMoreWords>;
  v33[3] = v33;
  std::string::basic_string[abi:nn180100]<0>(v34, "FilterInputPrefixMismatch");
  v35[0] = &unk_1F3F72B10;
  v35[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInputPrefixMismatch>;
  void v35[3] = v35;
  std::string::basic_string[abi:nn180100]<0>(v36, "BoostPreferedFormForSortkey");
  v37[0] = &unk_1F3F72B10;
  v37[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostPreferedFormForSortkey>;
  void v37[3] = v37;
  std::string::basic_string[abi:nn180100]<0>(v38, "BoostMinimumVariation");
  v39[0] = &unk_1F3F72B10;
  v39[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostMinimumVariation>;
  v39[3] = v39;
  std::string::basic_string[abi:nn180100]<0>(v40, "BoostCaseVariantsOfTopCandidate");
  v41[0] = &unk_1F3F72B10;
  v41[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostCaseVariantsOfTopCandidate>;
  void v41[3] = v41;
  std::string::basic_string[abi:nn180100]<0>(v42, "ExemptHighFrequencyWordsFromNoSuggest");
  v43[0] = &unk_1F3F72B10;
  v43[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::ExemptHighFrequencyWordsFromNoSuggest>;
  v43[3] = v43;
  std::string::basic_string[abi:nn180100]<0>(v44, "RescoreShortWords");
  v45[0] = &unk_1F3F72B10;
  v45[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::RescoreShortWords>;
  v45[3] = v45;
  std::string::basic_string[abi:nn180100]<0>(v46, "FilterLearnedTypo");
  v47[0] = &unk_1F3F72B10;
  v47[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLearnedTypo>;
  v47[3] = v47;
  std::string::basic_string[abi:nn180100]<0>(v48, "FilterTopDynamicWordsWithStaticVariant");
  v49[0] = &unk_1F3F72B10;
  v49[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterTopDynamicWordsWithStaticVariant>;
  void v49[3] = v49;
  std::string::basic_string[abi:nn180100]<0>(v50, "FilterInvalidTextReplacement");
  v51[0] = &unk_1F3F72B10;
  v51[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInvalidTextReplacement>;
  v51[3] = v51;
  std::string::basic_string[abi:nn180100]<0>(v52, "FilterContactWordsConflictingWithValidInput");
  v53[0] = &unk_1F3F72B10;
  v53[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContactWordsConflictingWithValidInput>;
  v53[3] = v53;
  std::string::basic_string[abi:nn180100]<0>(v54, "FilterWithoutSupplementalWords");
  v55[0] = &unk_1F3F72B10;
  v55[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWithoutSupplementalWords>;
  v55[3] = v55;
  std::string::basic_string[abi:nn180100]<0>(v56, "FilterPartOfHyphenatedWord");
  v57[0] = &unk_1F3F72B10;
  v57[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPartOfHyphenatedWord>;
  v57[3] = v57;
  std::string::basic_string[abi:nn180100]<0>(v58, "FilterLowQualityContinuousPathRetrocorrections");
  v59[0] = &unk_1F3F72B10;
  v59[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLowQualityContinuousPathRetrocorrections>;
  v59[3] = v59;
  std::string::basic_string[abi:nn180100]<0>(v60, "FilterNoPredictContinuousPathAlternates");
  v61[0] = &unk_1F3F72B10;
  v61[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNoPredictContinuousPathAlternates>;
  v61[3] = v61;
  std::string::basic_string[abi:nn180100]<0>(v62, "FilterContinuousPathAlternatesFromOtherLanguage");
  v63[0] = &unk_1F3F72B10;
  v63[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContinuousPathAlternatesFromOtherLanguage>;
  v63[3] = v63;
  std::string::basic_string[abi:nn180100]<0>(v64, "FilterSortkeyMatchFromDifferentLanguage");
  v65[0] = &unk_1F3F72B10;
  v65[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterSortkeyMatchFromDifferentLanguage>;
  v65[3] = v65;
  std::string::basic_string[abi:nn180100]<0>(v66, "FilterDifferentLanguageThanContext");
  v67[0] = &unk_1F3F72B10;
  v67[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDifferentLanguageThanContext>;
  v67[3] = v67;
  std::string::basic_string[abi:nn180100]<0>(v68, "ChooseTopQualityAutocorrection");
  v69[0] = &unk_1F3F72B10;
  v69[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::ChooseTopQualityAutocorrection>;
  v69[3] = v69;
  std::string::basic_string[abi:nn180100]<0>(v70, "RemoveAlternatesIfNoLinguisticCandidate");
  v71[0] = &unk_1F3F72B10;
  v71[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::RemoveAlternatesIfNoLinguisticCandidate>;
  void v71[3] = v71;
  std::string::basic_string[abi:nn180100]<0>(v72, "FilterCommonLearnedTypos");
  v73[0] = &unk_1F3F72B10;
  v73[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCommonLearnedTypos>;
  v73[3] = v73;
  std::string::basic_string[abi:nn180100]<0>(v74, "FilterNonVulgarIfTopCandidateVulgar");
  v75[0] = &unk_1F3F72B10;
  v75[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNonVulgarIfTopCandidateVulgar>;
  v75[3] = v75;
  std::string::basic_string[abi:nn180100]<0>(v76, "AddAlternativesForRetrocorrection");
  v77[0] = &unk_1F3F72B10;
  v77[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::AddAlternativesForRetrocorrection>;
  v77[3] = v77;
  std::string::basic_string[abi:nn180100]<0>(v78, "FilterDuplicates");
  v79[0] = &unk_1F3F72B10;
  v79[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDuplicates>;
  v79[3] = v79;
  std::string::basic_string[abi:nn180100]<0>(v80, "FilterCaseVariantsOfStaticWords");
  v81[0] = &unk_1F3F72B10;
  v81[1] = KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCaseVariantsOfStaticWords>;
  v81[3] = v81;
  operator new();
}

uint64_t std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    std::__hash_table<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>>::~__hash_table(result);
    JUMPOUT(0x1E4E7BC20);
  }
  return result;
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCaseVariantsOfStaticWords>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      unint64_t v10 = "FilterCaseVariantsOfStaticWords";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_1F3F735F8;
  result[3] = &unk_1F3F74130;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F99C34()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F735F8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterCaseVariantsOfStaticWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F735F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDuplicates>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      unint64_t v10 = "FilterDuplicates";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_1F3F735C0;
  result[3] = &unk_1F3F74100;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F99E50()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterDuplicates>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterDuplicates>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F735C0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterDuplicates>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F735C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::AddAlternativesForRetrocorrection>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      unint64_t v10 = "AddAlternativesForRetrocorrection";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_1F3F73588;
  result[3] = &unk_1F3F740D0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9A06C()
{
}

uint64_t std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73588;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::AddAlternativesForRetrocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73588;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNonVulgarIfTopCandidateVulgar>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v9 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterNonVulgarIfTopCandidateVulgar factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v9, 0xCu);
    }
  }
  uint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *uint64_t result = &unk_1F3F72C98;
  result[3] = &unk_1F3F73E60;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9A254()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72C98;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNonVulgarIfTopCandidateVulgar>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72C98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

double KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCommonLearnedTypos>@<D0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v8 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      uint64_t v11 = "FilterCommonLearnedTypos";
      __int16 v12 = 2048;
      CFIndex Count = CFDictionaryGetCount(v8);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
      std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::__deallocate_node(0);
    }
  }
  int v6 = (char *)operator new(0x60uLL);
  *((void *)v6 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((void *)v6 + 2) = 0;
  *(void *)int v6 = &unk_1F3F73550;
  *((void *)v6 + 3) = &unk_1F3F73520;
  *((_DWORD *)v6 + 8) = 51;
  double result = 0.0;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *((_DWORD *)v6 + 18) = 1065353216;
  *((void *)v6 + 10) = 0;
  *((void *)v6 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *a2 = v6 + 24;
  a2[1] = v6;
  return result;
}

void sub_1E3F9A4DC()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73550;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterCommonLearnedTypos>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73550;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::RemoveAlternatesIfNoLinguisticCandidate>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v9 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "RemoveAlternatesIfNoLinguisticCandidate factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v9, 0xCu);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F72FD8;
  result[3] = &unk_1F3F73010;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9A6C4()
{
}

uint64_t std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72FD8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::RemoveAlternatesIfNoLinguisticCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72FD8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::ChooseTopQualityAutocorrection>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 5)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v16 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v19 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v16);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "ChooseTopQualityAutocorrection factory expects 5 parameter, but specification includes %ld", (uint8_t *)&v19, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinLinguisticSynergyForComplexCorrection", 0.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinLinguisticSynergyForComplexCorrection", 0.0, INFINITY);
  }
  if (!HIDWORD(v7)) {
    goto LABEL_27;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v9 = bounded_float_for_key(v8, @"MinSuggestionDominanceRatio", 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    unint64_t v9 = bounded_float_for_key(0, @"MinSuggestionDominanceRatio", 1.0, INFINITY);
  }
  if (!HIDWORD(v9)) {
    goto LABEL_27;
  }
  CFDictionaryRef v10 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v11 = bounded_integer_for_key(v10, @"MinStemLengthForPredictingOneLetter", 0, 0xFFFF);
    CFRelease(v10);
  }
  else
  {
    unint64_t v11 = bounded_integer_for_key(0, @"MinStemLengthForPredictingOneLetter", 0, 0xFFFF);
  }
  if (!HIDWORD(v11)) {
    goto LABEL_27;
  }
  CFDictionaryRef v12 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v13 = bounded_integer_for_key(v12, @"MinStemLengthForPredictingTwoLetters", 0, 0xFFFF);
    CFRelease(v12);
  }
  else
  {
    unint64_t v13 = bounded_integer_for_key(0, @"MinStemLengthForPredictingTwoLetters", 0, 0xFFFF);
  }
  if (!HIDWORD(v13)) {
    goto LABEL_27;
  }
  CFDictionaryRef v14 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v15 = bounded_integer_for_key(v14, @"MinStemLengthForPredictingThreeLetters", 0, 0xFFFF);
    CFRelease(v14);
  }
  else
  {
    unint64_t v15 = bounded_integer_for_key(0, @"MinStemLengthForPredictingThreeLetters", 0, 0xFFFF);
  }
  if (HIDWORD(v15))
  {
    unint64_t v17 = operator new(0x38uLL);
    v17[1] = 0;
    v17[2] = 0;
    *unint64_t v17 = &unk_1F3F72FA0;
    void v17[3] = &unk_1F3F798D8;
    *((_DWORD *)v17 + 8) = v7;
    *((_DWORD *)v17 + 9) = v9;
    *((_DWORD *)v17 + 10) = v11;
    *((_DWORD *)v17 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v13;
    *((_DWORD *)v17 + 12) = v15;
    *a2 = v17 + 3;
    a2[1] = v17;
  }
  else
  {
LABEL_27:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9AAB0()
{
}

uint64_t bounded_float_for_key(const __CFDictionary *a1, const __CFString *key, float a3, float a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  if (key && (CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(a1, key)) != 0)
  {
    CFNumberRef v8 = v7;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v8))
    {
      switch(CFNumberGetType(v8))
      {
        case kCFNumberSInt8Type:
          valuePtr[0] = 0;
          CFNumberRef v10 = v8;
          CFNumberType v11 = kCFNumberSInt8Type;
          goto LABEL_18;
        case kCFNumberSInt16Type:
          *(_WORD *)double valuePtr = 0;
          CFNumberRef v19 = v8;
          CFNumberType v20 = kCFNumberSInt16Type;
          goto LABEL_20;
        case kCFNumberSInt32Type:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v21 = v8;
          CFNumberType v22 = kCFNumberSInt32Type;
          goto LABEL_23;
        case kCFNumberSInt64Type:
          *(void *)double valuePtr = 0;
          CFNumberRef v23 = v8;
          CFNumberType v24 = kCFNumberSInt64Type;
          goto LABEL_31;
        case kCFNumberFloat32Type:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v25 = v8;
          CFNumberType v26 = kCFNumberFloat32Type;
          goto LABEL_27;
        case kCFNumberFloat64Type:
          *(void *)double valuePtr = 0;
          CFNumberRef v27 = v8;
          CFNumberType v28 = kCFNumberFloat64Type;
          goto LABEL_33;
        case kCFNumberCharType:
          valuePtr[0] = 0;
          CFNumberRef v10 = v8;
          CFNumberType v11 = kCFNumberCharType;
LABEL_18:
          int Value = CFNumberGetValue(v10, v11, valuePtr);
          int v30 = valuePtr[0];
          goto LABEL_21;
        case kCFNumberShortType:
          *(_WORD *)double valuePtr = 0;
          CFNumberRef v19 = v8;
          CFNumberType v20 = kCFNumberShortType;
LABEL_20:
          int Value = CFNumberGetValue(v19, v20, valuePtr);
          int v30 = *(__int16 *)valuePtr;
LABEL_21:
          float v31 = (float)v30;
          goto LABEL_34;
        case kCFNumberIntType:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v21 = v8;
          CFNumberType v22 = kCFNumberIntType;
LABEL_23:
          int Value = CFNumberGetValue(v21, v22, valuePtr);
          float v31 = (float)*(int *)valuePtr;
          goto LABEL_34;
        case kCFNumberLongType:
          *(void *)double valuePtr = 0;
          CFNumberRef v23 = v8;
          CFNumberType v24 = kCFNumberLongType;
          goto LABEL_31;
        case kCFNumberLongLongType:
          *(void *)double valuePtr = 0;
          CFNumberRef v23 = v8;
          CFNumberType v24 = kCFNumberLongLongType;
          goto LABEL_31;
        case kCFNumberFloatType:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v25 = v8;
          CFNumberType v26 = kCFNumberFloatType;
LABEL_27:
          int Value = CFNumberGetValue(v25, v26, valuePtr);
          uint64_t v32 = *(unsigned int *)valuePtr;
          goto LABEL_35;
        case kCFNumberDoubleType:
          *(void *)double valuePtr = 0;
          CFNumberRef v27 = v8;
          CFNumberType v28 = kCFNumberDoubleType;
          goto LABEL_33;
        case kCFNumberCFIndexType:
          *(void *)double valuePtr = 0;
          CFNumberRef v23 = v8;
          CFNumberType v24 = kCFNumberCFIndexType;
          goto LABEL_31;
        case kCFNumberNSIntegerType:
          *(void *)double valuePtr = 0;
          CFNumberRef v23 = v8;
          CFNumberType v24 = kCFNumberNSIntegerType;
LABEL_31:
          int Value = CFNumberGetValue(v23, v24, valuePtr);
          float v31 = (float)*(uint64_t *)valuePtr;
          goto LABEL_34;
        case kCFNumberCGFloatType:
          *(void *)double valuePtr = 0;
          CFNumberRef v27 = v8;
          CFNumberType v28 = kCFNumberCGFloatType;
LABEL_33:
          int Value = CFNumberGetValue(v27, v28, valuePtr);
          float v31 = *(double *)valuePtr;
LABEL_34:
          uint64_t v32 = LODWORD(v31);
LABEL_35:
          uint64_t v18 = v32 | 0x100000000;
          if (!Value) {
            uint64_t v18 = 0;
          }
          int v16 = v18 & 0xFFFFFF00;
          uint64_t v17 = v18 & 0x100000000;
          break;
        default:
          int v16 = 0;
          uint64_t v17 = 0;
          LOBYTE(v18) = 0;
          break;
      }
      uint64_t v14 = v17 | v16 & 0xFFFFFF00 | v18;
    }
    else
    {
      CFTypeID v15 = CFBooleanGetTypeID();
      if (v15 == CFGetTypeID(v8)) {
        uint64_t v14 = COERCE_UNSIGNED_INT((float)CFBooleanGetValue(v8)) | 0x100000000;
      }
      else {
        uint64_t v14 = 0;
      }
    }
    unint64_t v13 = v14 & 0x100000000;
    int v12 = v14 & 0xFFFFFF00;
    LODWORD(v14) = v14;
  }
  else
  {
    int v12 = 0;
    unint64_t v13 = 0;
    LODWORD(v14) = 0;
  }
  if (!HIDWORD(v13))
  {
    unsigned __int8 v33 = filter_factory_log();
    a3 = 0.0;
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(key, valuePtr);
      if (v49 >= 0) {
        float v40 = valuePtr;
      }
      else {
        float v40 = *(unsigned char **)valuePtr;
      }
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v40;
      _os_log_error_impl(&dword_1E3F0E000, v33, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or its value is not float", __p, 0xCu);
      if (SHIBYTE(v49) < 0) {
        operator delete(*(void **)valuePtr);
      }
    }
    uint64_t v34 = 0;
LABEL_53:

    float v36 = a3;
    return v34 | LODWORD(v36);
  }
  LODWORD(v35) = v12 | v13 | v14;
  float v36 = v35;
  if (v35 < a3 || v35 > a4)
  {
    unsigned __int8 v33 = filter_factory_log();
    BOOL v38 = os_log_type_enabled(v33, OS_LOG_TYPE_ERROR);
    if (v36 >= a3)
    {
      if (v38)
      {
        KB::std_string(key, __p);
        CFDictionaryRef v42 = v45 >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)double valuePtr = 136315650;
        *(void *)&valuePtr[4] = v42;
        __int16 v47 = 2048;
        double v48 = v36;
        __int16 v49 = 2048;
        double v50 = a4;
        _os_log_error_impl(&dword_1E3F0E000, v33, OS_LOG_TYPE_ERROR, "Key '%s' has value %f, which is greater than upper bound %f", valuePtr, 0x20u);
        if (v45 < 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v34 = 0x100000000;
      a3 = a4;
    }
    else
    {
      if (v38)
      {
        KB::std_string(key, __p);
        char v41 = v45 >= 0 ? __p : *(unsigned char **)__p;
        *(_DWORD *)double valuePtr = 136315650;
        *(void *)&valuePtr[4] = v41;
        __int16 v47 = 2048;
        double v48 = v36;
        __int16 v49 = 2048;
        double v50 = a3;
        _os_log_error_impl(&dword_1E3F0E000, v33, OS_LOG_TYPE_ERROR, "Key '%s' has value %f, which is less than lower bound %f", valuePtr, 0x20u);
        if (v45 < 0) {
          operator delete(*(void **)__p);
        }
      }
      uint64_t v34 = 0x100000000;
    }
    goto LABEL_53;
  }
  uint64_t v34 = 0x100000000;
  return v34 | LODWORD(v36);
}

uint64_t bounded_integer_for_key(const __CFDictionary *a1, const __CFString *key, int a3, int a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  LODWORD(v5) = a3;
  if (key && (CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue(a1, key)) != 0)
  {
    CFNumberRef v8 = v7;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v8))
    {
      switch(CFNumberGetType(v8))
      {
        case kCFNumberSInt8Type:
          valuePtr[0] = 0;
          CFNumberRef v10 = v8;
          CFNumberType v11 = kCFNumberSInt8Type;
          goto LABEL_18;
        case kCFNumberSInt16Type:
          *(_WORD *)double valuePtr = 0;
          CFNumberRef v20 = v8;
          CFNumberType v21 = kCFNumberSInt16Type;
          goto LABEL_25;
        case kCFNumberSInt32Type:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberSInt32Type;
          goto LABEL_36;
        case kCFNumberSInt64Type:
          *(void *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberSInt64Type;
          goto LABEL_36;
        case kCFNumberFloat32Type:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v24 = v8;
          CFNumberType v25 = kCFNumberFloat32Type;
          goto LABEL_32;
        case kCFNumberFloat64Type:
          *(void *)double valuePtr = 0;
          CFNumberRef v26 = v8;
          CFNumberType v27 = kCFNumberFloat64Type;
          goto LABEL_38;
        case kCFNumberCharType:
          valuePtr[0] = 0;
          CFNumberRef v10 = v8;
          CFNumberType v11 = kCFNumberCharType;
LABEL_18:
          int Value = CFNumberGetValue(v10, v11, valuePtr);
          uint64_t v29 = Value != 0;
          if (Value) {
            unsigned __int8 v30 = valuePtr[0];
          }
          else {
            unsigned __int8 v30 = 0;
          }
          int v31 = -256;
          if ((v29 & (valuePtr[0] < 0)) == 0) {
            int v31 = 0;
          }
          uint64_t v19 = v29 << 32;
          LODWORD(v16) = v31 & 0xFFFFFF00 | v30;
          int v18 = v16 & 0xFFFFFF00;
          break;
        case kCFNumberShortType:
          *(_WORD *)double valuePtr = 0;
          CFNumberRef v20 = v8;
          CFNumberType v21 = kCFNumberShortType;
LABEL_25:
          if (CFNumberGetValue(v20, v21, valuePtr)) {
            uint64_t v16 = *(__int16 *)valuePtr & 0xFFFFFFFFLL | 0x100000000;
          }
          else {
            uint64_t v16 = 0;
          }
          goto LABEL_41;
        case kCFNumberIntType:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberIntType;
          goto LABEL_36;
        case kCFNumberLongType:
          *(void *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberLongType;
          goto LABEL_36;
        case kCFNumberLongLongType:
          *(void *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberLongLongType;
          goto LABEL_36;
        case kCFNumberFloatType:
          *(_DWORD *)double valuePtr = 0;
          CFNumberRef v24 = v8;
          CFNumberType v25 = kCFNumberFloatType;
LABEL_32:
          int v32 = CFNumberGetValue(v24, v25, valuePtr);
          uint64_t v33 = (int)*(float *)valuePtr;
          goto LABEL_39;
        case kCFNumberDoubleType:
          *(void *)double valuePtr = 0;
          CFNumberRef v26 = v8;
          CFNumberType v27 = kCFNumberDoubleType;
          goto LABEL_38;
        case kCFNumberCFIndexType:
          *(void *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberCFIndexType;
          goto LABEL_36;
        case kCFNumberNSIntegerType:
          *(void *)double valuePtr = 0;
          CFNumberRef v22 = v8;
          CFNumberType v23 = kCFNumberNSIntegerType;
LABEL_36:
          int v32 = CFNumberGetValue(v22, v23, valuePtr);
          uint64_t v33 = *(unsigned int *)valuePtr;
          goto LABEL_39;
        case kCFNumberCGFloatType:
          *(void *)double valuePtr = 0;
          CFNumberRef v26 = v8;
          CFNumberType v27 = kCFNumberCGFloatType;
LABEL_38:
          int v32 = CFNumberGetValue(v26, v27, valuePtr);
          uint64_t v33 = (int)*(double *)valuePtr;
LABEL_39:
          uint64_t v16 = v33 | 0x100000000;
          if (!v32) {
            uint64_t v16 = 0;
          }
LABEL_41:
          int v18 = v16 & 0xFFFFFF00;
          uint64_t v19 = v16 & 0x100000000;
          break;
        default:
          int v18 = 0;
          uint64_t v19 = 0;
          LOBYTE(v16) = 0;
          break;
      }
      uint64_t v17 = v19 | v18 & 0xFFFFFF00;
      uint64_t v16 = v16;
    }
    else
    {
      CFTypeID v15 = CFBooleanGetTypeID();
      if (v15 == CFGetTypeID(v8))
      {
        uint64_t v16 = CFBooleanGetValue(v8);
        uint64_t v17 = 0x100000000;
      }
      else
      {
        uint64_t v16 = 0;
        uint64_t v17 = 0;
      }
    }
    int v14 = v17 | v16;
    unint64_t v13 = (v17 | v16) & 0x100000000;
    unsigned int v12 = v14 & 0xFFFFFF00;
    int v14 = v14;
  }
  else
  {
    unsigned int v12 = 0;
    unint64_t v13 = 0;
    int v14 = 0;
  }
  if (HIDWORD(v13))
  {
    int v36 = v12 | v13 | v14;
    if (v36 < (int)v5 || v36 > a4)
    {
      uint64_t v37 = filter_factory_log();
      BOOL v38 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      if (v36 >= (int)v5)
      {
        if (v38)
        {
          KB::std_string(key, __p);
          CFDictionaryRef v42 = v45 >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)double valuePtr = 136315650;
          *(void *)&valuePtr[4] = v42;
          __int16 v47 = 1024;
          int v48 = v36;
          __int16 v49 = 1024;
          int v50 = a4;
          _os_log_error_impl(&dword_1E3F0E000, v37, OS_LOG_TYPE_ERROR, "Key '%s' has value %d, which is greater than upper bound %d", valuePtr, 0x18u);
          if (v45 < 0) {
            operator delete(*(void **)__p);
          }
        }

        unsigned int v35 = a4 & 0xFFFFFF00;
        uint64_t v34 = 0x100000000;
        LOBYTE(v5) = a4;
      }
      else
      {
        if (v38)
        {
          KB::std_string(key, __p);
          char v41 = v45 >= 0 ? __p : *(unsigned char **)__p;
          *(_DWORD *)double valuePtr = 136315650;
          *(void *)&valuePtr[4] = v41;
          __int16 v47 = 1024;
          int v48 = v36;
          __int16 v49 = 1024;
          int v50 = (int)v5;
          _os_log_error_impl(&dword_1E3F0E000, v37, OS_LOG_TYPE_ERROR, "Key '%s' has value %d, which is less than lower bound %d", valuePtr, 0x18u);
          if (v45 < 0) {
            operator delete(*(void **)__p);
          }
        }

        unsigned int v35 = 0;
        uint64_t v34 = 0x100000000;
      }
    }
    else
    {
      unsigned int v35 = v36 & 0xFFFFFF00;
      uint64_t v34 = 0x100000000;
      LOBYTE(v5) = v36;
    }
  }
  else
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      KB::std_string(key, valuePtr);
      if (v50 >= 0) {
        float v40 = valuePtr;
      }
      else {
        float v40 = *(unsigned char **)valuePtr;
      }
      *(_DWORD *)std::string __p = 136315138;
      *(void *)&__p[4] = v40;
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or its value is not int32_t", __p, 0xCu);
      if (SHIBYTE(v50) < 0) {
        operator delete(*(void **)valuePtr);
      }
    }

    uint64_t v34 = 0;
    LOBYTE(v5) = 0;
    unsigned int v35 = 0;
  }
  return v34 | v35 | v5;
}

uint64_t std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72FA0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::ChooseTopQualityAutocorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72FA0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDifferentLanguageThanContext>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterDifferentLanguageThanContext factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinConfidenceToEstablishLanguage", 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinConfidenceToEstablishLanguage", 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    CFNumberRef v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72F68;
    void v8[3] = &unk_1F3F756E8;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9B7D4()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72F68;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterDifferentLanguageThanContext>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72F68;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterSortkeyMatchFromDifferentLanguage>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v13 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterSortkeyMatchFromDifferentLanguage factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinConfidenceToEstablishCurrentLanguage", 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinConfidenceToEstablishCurrentLanguage", 0.0, 1.0);
  }
  if (!HIDWORD(v7)) {
    goto LABEL_13;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v9 = bounded_float_for_key(v8, @"SameLanguageSortkeyMatchDominanceRatio", 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    unint64_t v9 = bounded_float_for_key(0, @"SameLanguageSortkeyMatchDominanceRatio", 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    CFNumberRef v10 = operator new(0x28uLL);
    v10[1] = 0;
    void v10[2] = 0;
    void *v10 = &unk_1F3F72F30;
    void v10[3] = &unk_1F3F756B8;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    *a2 = v10 + 3;
    a2[1] = v10;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9BA8C()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72F30;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterSortkeyMatchFromDifferentLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72F30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContinuousPathAlternatesFromOtherLanguage>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterContinuousPathAlternatesFromOtherLanguage factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinConfidenceToEstablishContinuousPathLanguage", 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinConfidenceToEstablishContinuousPathLanguage", 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    CFDictionaryRef v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72EF8;
    void v8[3] = &unk_1F3F75140;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9BCE0()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72EF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterContinuousPathAlternatesFromOtherLanguage>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72EF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNoPredictContinuousPathAlternates>@<X0>(const __CFDictionary **a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  CFDictionaryRef v6 = a1;
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v8 = *a1;
  if (v8 && CFDictionaryGetCount(v8))
  {
    unint64_t v3 = filter_factory_log();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v13 = *v6;
      if (!*v6)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v15 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v13);
      _os_log_error_impl(&dword_1E3F0E000, v3, OS_LOG_TYPE_ERROR, "FilterNoPredictContinuousPathAlternates factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v15, 0xCu);
    }
  }
  uint64_t v9 = *a2;
  if (*((unsigned char *)a2 + 184))
  {
    if (v9 < 7)
    {
      CFNumberRef v10 = (char *)&unk_1E4155518 + 4 * v9;
      LODWORD(a2) = dword_1E4155534[v9];
      int v11 = &unk_1E4155570;
LABEL_10:
      int v4 = *(_DWORD *)v10;
      LODWORD(v3) = dword_1E4155550[(int)v9];
      CFDictionaryRef v6 = (const __CFDictionary **)v11[(int)v9];
    }
  }
  else if (v9 < 7)
  {
    CFNumberRef v10 = (char *)&unk_1E41554C0 + 4 * v9;
    LODWORD(a2) = 402653186;
    int v11 = &unk_1E41554E0;
    goto LABEL_10;
  }
  double result = operator new(0x38uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F72EC0;
  result[3] = &unk_1F3F75110;
  *((_DWORD *)result + 8) = v4;
  *((_DWORD *)result + 9) = 0;
  *((_DWORD *)result + 10) = a2;
  *((_DWORD *)result + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v3;
  result[6] = v6;
  *a3 = result + 3;
  a3[1] = result;
  return result;
}

void sub_1E3F9BF58()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72EC0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNoPredictContinuousPathAlternates>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72EC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLowQualityContinuousPathRetrocorrections>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterLowQualityContinuousPathRetrocorrections factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinOmegaRatioForContinuousPathRetrocorrections", 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinOmegaRatioForContinuousPathRetrocorrections", 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    CFDictionaryRef v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72E88;
    void v8[3] = &unk_1F3F750E0;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9C1AC()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72E88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterLowQualityContinuousPathRetrocorrections>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72E88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPartOfHyphenatedWord>(const __CFDictionary **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v6 = *a1;
  if (v6 && CFDictionaryGetCount(v6))
  {
    unint64_t v7 = filter_factory_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v7, OS_LOG_TYPE_ERROR, "FilterPartOfHyphenatedWord> factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  if (*(unsigned char *)(a2 + 185))
  {
    CFDictionaryRef v8 = operator new(0x20uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72BF8;
    void v8[3] = &unk_1F3F72C30;
    *a3 = v8 + 3;
    a3[1] = v8;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1E3F9C3A8()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72BF8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterPartOfHyphenatedWord>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72BF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWithoutSupplementalWords>(const __CFDictionary **a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v6 = *a1;
  if (v6 && CFDictionaryGetCount(v6))
  {
    unint64_t v7 = filter_factory_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v7, OS_LOG_TYPE_ERROR, "FilterWithoutSupplementalWords factory expects 0 parameters, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  if (*(unsigned char *)(a2 + 185))
  {
    CFDictionaryRef v8 = operator new(0x20uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72B90;
    void v8[3] = &unk_1F3F72BC8;
    *a3 = v8 + 3;
    a3[1] = v8;
  }
  else
  {
    *a3 = 0;
    a3[1] = 0;
  }
}

void sub_1E3F9C5A4()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72B90;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterWithoutSupplementalWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72B90;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterContactWordsConflictingWithValidInput>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFNumberRef v10 = "CandidateFilterContactWordsConflictingWithValidInput";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F734E8;
  result[3] = &unk_1F3F734B8;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9C7C0()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F734E8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterContactWordsConflictingWithValidInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F734E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInvalidTextReplacement>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFNumberRef v10 = "FilterInvalidTextReplacement";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73480;
  result[3] = &unk_1F3F73450;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9C9DC()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73480;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterInvalidTextReplacement>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73480;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterTopDynamicWordsWithStaticVariant>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v13 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterTopDynamicWordsWithStaticVariant factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_integer_for_key(v6, @"MinUsageCountForDynamicCaseVariant", 0, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_integer_for_key(0, @"MinUsageCountForDynamicCaseVariant", 0, 0xFFFF);
  }
  if (!HIDWORD(v7)) {
    goto LABEL_13;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v9 = bounded_float_for_key(v8, @"MinOmegaRatioForDynamicCaseVariant", 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    unint64_t v9 = bounded_float_for_key(0, @"MinOmegaRatioForDynamicCaseVariant", 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    CFNumberRef v10 = operator new(0x28uLL);
    v10[1] = 0;
    void v10[2] = 0;
    void *v10 = &unk_1F3F72E20;
    void v10[3] = &unk_1F3F72E58;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    *a2 = v10 + 3;
    a2[1] = v10;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9CC94()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72E20;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterTopDynamicWordsWithStaticVariant>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72E20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterLearnedTypo>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFNumberRef v10 = "FilterLearnedTypo";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73418;
  result[3] = &unk_1F3F733E8;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9CEB0()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterLearnedTypo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterLearnedTypo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73418;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterLearnedTypo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73418;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::RescoreShortWords>@<X0>(CFDictionaryRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      memset(v9, 0, sizeof(v9));
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      CFIndex Count = CFDictionaryGetCount(*a1);
      *(_DWORD *)buf = 136315394;
      __int16 v11 = "RescoreShortWords";
      __int16 v12 = 2048;
      CFIndex v13 = Count;
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
      std::__function::__value_func<BOOL ()(KB::Candidate &,KB::Candidate &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)>::~__value_func[abi:nn180100](v9);
    }
  }
  double result = operator new(0x40uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F733B0;
  result[4] = 0;
  result[5] = 0;
  result[6] = 0;
  result[7] = 0;
  result[3] = &unk_1F3F75CB8;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9D0F0()
{
}

void *std::__function::__value_func<BOOL ()(KB::Candidate &,KB::Candidate &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)>::~__value_func[abi:nn180100](void *a1)
{
  CFBooleanRef v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<KB::RescoreShortWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::RescoreShortWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F733B0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::RescoreShortWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F733B0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::ExemptHighFrequencyWordsFromNoSuggest>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFNumberRef v10 = "ExemptHighFrequencyWordsFromNoSuggest";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73378;
  result[3] = &unk_1F3F75C88;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9D390()
{
}

uint64_t std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73378;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::ExemptHighFrequencyWordsFromNoSuggest>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73378;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostCaseVariantsOfTopCandidate>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFNumberRef v10 = "BoostCaseVariantsOfTopCandidate";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73340;
  result[3] = &unk_1F3F75C58;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9D5AC()
{
}

uint64_t std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73340;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::BoostCaseVariantsOfTopCandidate>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73340;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostMinimumVariation>(CFTypeRef *a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (!v8 || CFDictionaryGetCount(v8) != 1)
  {
    unint64_t v9 = filter_factory_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v16 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v18 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v16);
      _os_log_error_impl(&dword_1E3F0E000, v9, OS_LOG_TYPE_ERROR, "BoostMinimumVariation factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v18, 0xCu);
    }
  }
  CFDictionaryRef v10 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v11 = bounded_float_for_key(v10, @"MinCandidateDominanceRatio", 1.0, INFINITY);
    CFRelease(v10);
  }
  else
  {
    unint64_t v11 = bounded_float_for_key(0, @"MinCandidateDominanceRatio", 1.0, INFINITY);
  }
  if (!HIDWORD(v11))
  {
    *a3 = 0;
    a3[1] = 0;
    return;
  }
  uint64_t v12 = *a2;
  if (*((unsigned char *)a2 + 184))
  {
    if (v12 < 7)
    {
      uint64_t v13 = (char *)&unk_1E4155518 + 4 * v12;
      LODWORD(a2) = dword_1E4155534[v12];
      uint64_t v14 = &unk_1E4155570;
LABEL_15:
      int v4 = *(_DWORD *)v13;
      LODWORD(v10) = dword_1E4155550[(int)v12];
      uint64_t v3 = v14[(int)v12];
    }
  }
  else if (v12 < 7)
  {
    uint64_t v13 = (char *)&unk_1E41554C0 + 4 * v12;
    LODWORD(a2) = 402653186;
    uint64_t v14 = &unk_1E41554E0;
    goto LABEL_15;
  }
  uint64_t v15 = operator new(0x40uLL);
  v15[1] = 0;
  v15[2] = 0;
  *uint64_t v15 = &unk_1F3F72DE8;
  void v15[3] = &unk_1F3F75C28;
  *((_DWORD *)v15 + 8) = v11;
  *((_DWORD *)v15 + 10) = v4;
  *((_DWORD *)v15 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((_DWORD *)v15 + 12) = a2;
  *((_DWORD *)v15 + 13) = v10;
  v15[7] = v3;
  *a3 = v15 + 3;
  a3[1] = v15;
}

void sub_1E3F9D898()
{
}

uint64_t std::__shared_ptr_emplace<KB::BoostMinimumVariation>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::BoostMinimumVariation>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72DE8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::BoostMinimumVariation>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72DE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::BoostPreferedFormForSortkey>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "BoostPreferedFormForSortkey factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"MinSuggestionDominanceRatio", 1.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"MinSuggestionDominanceRatio", 1.0, INFINITY);
  }
  if (HIDWORD(v7))
  {
    CFDictionaryRef v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72DB0;
    void v8[3] = &unk_1F3F75BF8;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9DAF4()
{
}

uint64_t std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72DB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::BoostPreferedFormForSortkey>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72DB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterInputPrefixMismatch>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v13 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterInputPrefixMismatch factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_integer_for_key(v6, @"MinPrefixMatchLen", 0, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_integer_for_key(0, @"MinPrefixMatchLen", 0, 0xFFFF);
  }
  if (!HIDWORD(v7)) {
    goto LABEL_13;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v9 = bounded_integer_for_key(v8, @"MinTargetCandidates", 0, 0xFFFF);
    CFRelease(v8);
  }
  else
  {
    unint64_t v9 = bounded_integer_for_key(0, @"MinTargetCandidates", 0, 0xFFFF);
  }
  if (HIDWORD(v9))
  {
    CFDictionaryRef v10 = operator new(0x30uLL);
    v10[1] = 0;
    void v10[2] = 0;
    void *v10 = &unk_1F3F72D78;
    void v10[3] = &unk_1F3F740A0;
    *((_DWORD *)v10 + 8) = v7;
    void v10[5] = (int)v9;
    *a2 = v10 + 3;
    a2[1] = v10;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9DDAC()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterInputPrefixMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNondominantCorrectionOfMoreWords>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    int v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v11 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v13 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v11);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterNondominantCorrectionOfMoreWords factory expects 2 parameters, but specification includes %ld", (uint8_t *)&v13, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"SortKeyMatchBoostRatio", 1.0, INFINITY);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"SortKeyMatchBoostRatio", 1.0, INFINITY);
  }
  if (!HIDWORD(v7)) {
    goto LABEL_13;
  }
  CFDictionaryRef v8 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v9 = bounded_float_for_key(v8, @"NonRetrocorrectionBoostRatio", 1.0, INFINITY);
    CFRelease(v8);
  }
  else
  {
    unint64_t v9 = bounded_float_for_key(0, @"NonRetrocorrectionBoostRatio", 1.0, INFINITY);
  }
  if (HIDWORD(v9))
  {
    CFDictionaryRef v10 = operator new(0x28uLL);
    v10[1] = 0;
    void v10[2] = 0;
    void *v10 = &unk_1F3F72D40;
    void v10[3] = &unk_1F3F74070;
    *((_DWORD *)v10 + 8) = v7;
    *((_DWORD *)v10 + 9) = v9;
    *a2 = v10 + 3;
    a2[1] = v10;
  }
  else
  {
LABEL_13:
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9E06C()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNondominantCorrectionOfMoreWords>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCorrectionsIfAnyCandidateMatchesInput>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  CFDictionaryRef v4 = *a1;
  if (!v4) {
    goto LABEL_8;
  }
  if (CFDictionaryGetCount(v4) != 1)
  {
    int v7 = 0x7FFFFFFF;
    goto LABEL_12;
  }
  CFDictionaryRef v5 = *a1;
  if (v5)
  {
    CFRetain(v5);
    unint64_t v6 = bounded_integer_for_key(v5, @"WithinTopXAutocorrectionCandidates", 1, 0x7FFFFFFF);
    if (HIDWORD(v6)) {
      int v7 = v6;
    }
    else {
      int v7 = 0x7FFFFFFF;
    }
    CFRelease(v5);
  }
  else
  {
LABEL_8:
    unint64_t v8 = bounded_integer_for_key(0, @"WithinTopXAutocorrectionCandidates", 1, 0x7FFFFFFF);
    if (HIDWORD(v8)) {
      int v7 = v8;
    }
    else {
      int v7 = 0x7FFFFFFF;
    }
  }
LABEL_12:
  double result = operator new(0x28uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F72B58;
  result[3] = &unk_1F3F74040;
  *((_DWORD *)result + 8) = v7;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

uint64_t std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72B58;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterCorrectionsIfAnyCandidateMatchesInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72B58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterMissingOneLetterWordFromInput>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterMissingOneLetterWordFromInput";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73308;
  result[3] = &unk_1F3F74010;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9E428()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73308;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterMissingOneLetterWordFromInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73308;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAllCapsNoSuggestWordsOfLength>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterAllCapsNoSuggestWordsOfLength factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_integer_for_key(v6, @"Length", 1, 0xFFFF);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_integer_for_key(0, @"Length", 1, 0xFFFF);
  }
  if (HIDWORD(v7))
  {
    unint64_t v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F72D08;
    void v8[3] = &unk_1F3F73FE0;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3F9E67C()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D08;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterAllCapsNoSuggestWordsOfLength>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72D08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterPopupVariantMismatch>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterPopupVariantMismatch";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F732D0;
  result[3] = &unk_1F3F73FB0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9E898()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F732D0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterPopupVariantMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F732D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordEndingApostropheBetweenNonseparators>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterWordEndingApostropheBetweenNonseparators";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73298;
  result[3] = &unk_1F3F73F80;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9EAB4()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73298;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterWordEndingApostropheBetweenNonseparators>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73298;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterDoubleApostrophe>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterDoubleApostrophe";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73260;
  result[3] = &unk_1F3F73F50;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9ECD0()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73260;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterDoubleApostrophe>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73260;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAlteredURLFragments>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterAlteredURLFragments";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73228;
  result[3] = &unk_1F3F73F20;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9EEEC()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73228;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterAlteredURLFragments>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73228;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(CFDictionaryRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (!v4 || CFDictionaryGetCount(v4) != 2)
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v43 = *a1;
      if (!*a1) {
        goto LABEL_112;
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = CFDictionaryGetCount(v43);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterCharacterCount factory expects 2 parameters, but specification includes %ld", (uint8_t *)&__p, 0xCu);
    }
  }
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_keCGFloat y = @"Character";
  }
  if (!*a1)
  {
LABEL_112:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v50, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key);
  if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    std::string::size_type size = HIBYTE(v50.__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&v50.__r_.__value_.__s + 23))
    {
      CFDictionaryRef v7 = &v50;
      goto LABEL_12;
    }
LABEL_78:
    float v40 = filter_factory_log();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key, &__p);
      CFTypeRef v44 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      *(void *)&uint8_t buf[4] = v44;
      _os_log_error_impl(&dword_1E3F0E000, v40, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or is not a UTF-8 string", buf, 0xCu);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    *a2 = 0;
    a2[1] = 0;
    goto LABEL_88;
  }
  std::string::size_type size = v50.__r_.__value_.__l.__size_;
  if (!v50.__r_.__value_.__l.__size_) {
    goto LABEL_78;
  }
  CFDictionaryRef v7 = (std::string *)v50.__r_.__value_.__r.__words[0];
LABEL_12:
  if (size >= 0xFFFF) {
    unsigned int v8 = 0xFFFF;
  }
  else {
    unsigned int v8 = size;
  }
  KB::String::String((KB::String *)&__p, (const char *)v7, v8);
  int v9 = WORD2(__p.__r_.__value_.__r.__words[0]);
  if (!WORD2(__p.__r_.__value_.__r.__words[0]))
  {
    KB::String::compute_length((unsigned __int16 *)&__p);
    int v9 = WORD2(__p.__r_.__value_.__r.__words[0]);
  }
  if (v9 != 1)
  {
    CFDictionaryRef v10 = filter_factory_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::character_key, buf);
      if (v59 >= 0) {
        char v45 = buf;
      }
      else {
        char v45 = *(unsigned char **)buf;
      }
      unint64_t v46 = &v50;
      if ((v50.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        unint64_t v46 = (std::string *)v50.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)uint64_t v51 = 136315394;
      BOOL v52 = v45;
      __int16 v53 = 2080;
      uint64_t v54 = v46;
      _os_log_error_impl(&dword_1E3F0E000, v10, OS_LOG_TYPE_ERROR, "String for key '%s' has more than one code point (string='%s')", v51, 0x16u);
      if (v59 < 0) {
        operator delete(*(void **)buf);
      }
    }
  }
  __int16 v11 = (void *)__p.__r_.__value_.__l.__size_;
  uint64_t v12 = &__p.__r_.__value_.__s.__data_[16];
  if (__p.__r_.__value_.__l.__size_) {
    uint64_t v12 = (std::string::value_type *)__p.__r_.__value_.__l.__size_;
  }
  *(void *)buf = v12;
  *(_DWORD *)&uint8_t buf[8] = 0;
  int data_low = LOWORD(__p.__r_.__value_.__l.__data_);
  int v58 = 0;
  KB::String::iterator::initialize((uint64_t *)buf);
  int v13 = v58;
  if (v11 && __p.__r_.__value_.__s.__data_[6] == 1) {
    free(v11);
  }
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_keCGFloat y = @"CharacterCountRelation";
  }
  if (!*a1) {
    goto LABEL_112;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_key);
  uint64_t v14 = (const char *)[@"LessThanInputCount" UTF8String];
  uint64_t v15 = v14;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v17 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v17 = __p.__r_.__value_.__l.__size_;
  }
  if (v17 == strlen(v14))
  {
    int v18 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v18, v15, v17))
    {
      int v41 = 0;
      goto LABEL_86;
    }
  }
  uint64_t v19 = (const char *)[@"LessThanOrEqualToInputCount" UTF8String];
  uint64_t v20 = v19;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v21 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v21 = __p.__r_.__value_.__l.__size_;
  }
  if (v21 == strlen(v19))
  {
    CFNumberRef v22 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v22, v20, v21))
    {
      int v41 = 1;
      goto LABEL_86;
    }
  }
  CFNumberType v23 = (const char *)[@"EqualToInputCount" UTF8String];
  CFNumberRef v24 = v23;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v25 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v25 = __p.__r_.__value_.__l.__size_;
  }
  if (v25 == strlen(v23))
  {
    CFNumberRef v26 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v26, v24, v25))
    {
      int v41 = 2;
      goto LABEL_86;
    }
  }
  CFNumberType v27 = (const char *)[@"NotEqualToInputCount" UTF8String];
  CFNumberType v28 = v27;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v29 = __p.__r_.__value_.__l.__size_;
  }
  if (v29 == strlen(v27))
  {
    unsigned __int8 v30 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v30, v28, v29))
    {
      int v41 = 3;
      goto LABEL_86;
    }
  }
  int v31 = (const char *)[@"GreaterThanOrEqualToInputCount" UTF8String];
  int v32 = v31;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v33 = __p.__r_.__value_.__l.__size_;
  }
  if (v33 == strlen(v31))
  {
    uint64_t v34 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v34, v32, v33))
    {
      int v41 = 4;
      goto LABEL_86;
    }
  }
  unsigned int v35 = (const char *)[@"GreaterThanInputCount" UTF8String];
  int v36 = v35;
  char v16 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v37 = __p.__r_.__value_.__l.__size_;
  }
  if (v37 == strlen(v35))
  {
    BOOL v38 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &__p
        : (std::string *)__p.__r_.__value_.__r.__words[0];
    if (!memcmp(v38, v36, v37))
    {
      int v41 = 5;
LABEL_86:
      CFDictionaryRef v42 = operator new(0x28uLL);
      v42[1] = 0;
      uint64_t v42[2] = 0;
      void *v42 = &unk_1F3F72CD0;
      void v42[3] = &unk_1F3F73EF0;
      *((_DWORD *)v42 + 8) = v13;
      *((_DWORD *)v42 + 9) = v41;
      *a2 = v42 + 3;
      a2[1] = v42;
      if ((v16 & 0x80) == 0) {
        goto LABEL_88;
      }
      goto LABEL_87;
    }
  }
  uint64_t v39 = filter_factory_log();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterCharacterCount>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::count_relation_key, buf);
    if (v59 >= 0) {
      __int16 v47 = buf;
    }
    else {
      __int16 v47 = *(unsigned char **)buf;
    }
    std::__split_buffer<std::string>::pointer p_p = &__p;
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    *(_DWORD *)uint64_t v51 = 136315394;
    BOOL v52 = v47;
    __int16 v53 = 2080;
    uint64_t v54 = p_p;
    _os_log_error_impl(&dword_1E3F0E000, v39, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v51, 0x16u);
    if (v59 < 0) {
      operator delete(*(void **)buf);
    }
  }

  *a2 = 0;
  a2[1] = 0;
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_87:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_88:
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v50.__r_.__value_.__l.__data_);
  }
}

uint64_t std::__shared_ptr_emplace<KB::FilterCharacterCount>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterCharacterCount>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72CD0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterCharacterCount>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72CD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberlikeTokenMismatch>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterNumberlikeTokenMismatch";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F731F0;
  result[3] = &unk_1F3F73EC0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9F860()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F731F0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNumberlikeTokenMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F731F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNumberMismatch>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)buf = 136315394;
      CFDictionaryRef v10 = "FilterNumberMismatch";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F731B8;
  result[3] = &unk_1F3F73E90;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3F9FA7C()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterNumberMismatch>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNumberMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F731B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNumberMismatch>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F731B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(CFDictionaryRef *a1@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v6 = *a1;
  if (!v6 || CFDictionaryGetCount(v6) != 3)
  {
    CFDictionaryRef v7 = filter_factory_log();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v43 = *a1;
      if (!*a1) {
        goto LABEL_117;
      }
      LODWORD(buf.__r_.__value_.__l.__data_) = 134217984;
      *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = CFDictionaryGetCount(v43);
      _os_log_error_impl(&dword_1E3F0E000, v7, OS_LOG_TYPE_ERROR, "FilterNotSuggestibleForInput factory expects 3 parameters, but specification includes %ld", (uint8_t *)&buf, 0xCu);
    }
  }
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar = @"ShouldRemoveVulgar";
  }
  if (!*a1) {
    goto LABEL_117;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&buf, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar);
  unsigned int v8 = (const char *)[@"RemoveVulgar" UTF8String];
  int v9 = v8;
  size_t v10 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? HIBYTE(buf.__r_.__value_.__r.__words[2])
      : buf.__r_.__value_.__l.__size_;
  if (v10 == strlen(v8)
    && ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (__int16 v11 = &buf)
      : (__int16 v11 = (std::string *)buf.__r_.__value_.__r.__words[0]),
        !memcmp(v11, v9, v10)))
  {
    int v21 = 0;
  }
  else
  {
    uint64_t v12 = (const char *)[@"RemoveVulgarOnlyIfNotAllowlisted" UTF8String];
    uint64_t v13 = v12;
    size_t v14 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(buf.__r_.__value_.__r.__words[2])
        : buf.__r_.__value_.__l.__size_;
    if (v14 == strlen(v12)
      && ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (uint64_t v15 = &buf)
        : (uint64_t v15 = (std::string *)buf.__r_.__value_.__r.__words[0]),
          !memcmp(v15, v13, v14)))
    {
      int v21 = 1;
    }
    else
    {
      char v16 = (const char *)[@"DoNotRemoveVulgar" UTF8String];
      std::string::size_type v17 = v16;
      if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(buf.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = buf.__r_.__value_.__l.__size_;
      }
      if (size != strlen(v16)
        || ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (uint64_t v19 = &buf)
          : (uint64_t v19 = (std::string *)buf.__r_.__value_.__r.__words[0]),
            memcmp(v19, v17, size)))
      {
        uint64_t v20 = filter_factory_log();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::should_remove_vulgar, &v56);
          if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            CFTypeRef v44 = &v56;
          }
          else {
            CFTypeRef v44 = (std::string *)v56.__r_.__value_.__r.__words[0];
          }
          p_std::string buf = &buf;
          if ((buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_std::string buf = (std::string *)buf.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v44;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)p_buf;
          _os_log_error_impl(&dword_1E3F0E000, v20, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", (uint8_t *)&__p, 0x16u);
          if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v56.__r_.__value_.__l.__data_);
          }
        }

        *a3 = 0;
        a3[1] = 0;
        goto LABEL_81;
      }
      int v21 = 2;
    }
  }
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_keCGFloat y = @"WordEquivalenceType";
  }
  if (!*a1) {
    goto LABEL_117;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v56, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_key);
  CFNumberRef v22 = (const char *)[@"SortkeyEquivalence" UTF8String];
  CFNumberType v23 = v22;
  size_t v24 = (v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? HIBYTE(v56.__r_.__value_.__r.__words[2])
      : v56.__r_.__value_.__l.__size_;
  if (v24 == strlen(v22)
    && ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (std::string::size_type v25 = &v56)
      : (std::string::size_type v25 = (std::string *)v56.__r_.__value_.__r.__words[0]),
        !memcmp(v25, v23, v24)))
  {
    int v31 = 0;
  }
  else
  {
    CFNumberRef v26 = (const char *)[@"SurfaceFormEquivalence" UTF8String];
    CFNumberType v27 = v26;
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v28 = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v28 = v56.__r_.__value_.__l.__size_;
    }
    if (v28 != strlen(v26)
      || ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (std::string::size_type v29 = &v56)
        : (std::string::size_type v29 = (std::string *)v56.__r_.__value_.__r.__words[0]),
          memcmp(v29, v27, v28)))
    {
      unsigned __int8 v30 = filter_factory_log();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::word_equivalence_type_key, &__p);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::__split_buffer<std::string>::pointer p_p = &__p;
        }
        else {
          std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        BOOL v52 = &v56;
        if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          BOOL v52 = (std::string *)v56.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)CFTypeRef v57 = 136315394;
        *(void *)&void v57[4] = p_p;
        __int16 v58 = 2080;
        char v59 = v52;
        _os_log_error_impl(&dword_1E3F0E000, v30, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v57, 0x16u);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }

      *a3 = 0;
      a3[1] = 0;
      goto LABEL_79;
    }
    int v31 = 1;
  }
  {
    KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_keCGFloat y = @"ApplyFilterCondition";
  }
  if (!*a1)
  {
LABEL_117:
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  int v32 = &knownAssetRegionAttributes_assetRegionAttributes;
  std::string::size_type v33 = &__p;
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, (void *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_key);
  uint64_t v34 = (const char *)[@"ApplyAlways" UTF8String];
  unsigned int v35 = v34;
  char v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v37 = __p.__r_.__value_.__l.__size_;
  }
  if (v37 == strlen(v34)
    && ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (BOOL v38 = &__p)
      : (BOOL v38 = (std::string *)__p.__r_.__value_.__r.__words[0]),
        !memcmp(v38, v35, v37)))
  {
    int v46 = 0;
  }
  else
  {
    uint64_t v39 = (const char *)[@"ApplyIfCandidatesContainInputMatch" UTF8String];
    float v40 = v39;
    char v36 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v37 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v37 = __p.__r_.__value_.__l.__size_;
    }
    if (v37 != strlen(v39)
      || ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? (int v41 = &__p)
        : (int v41 = (std::string *)__p.__r_.__value_.__r.__words[0]),
          memcmp(v41, v40, v37)))
    {
      CFDictionaryRef v42 = filter_factory_log();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        KB::std_string((const __CFString *)KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterNotSuggestibleForInput>(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)::apply_filter_condition_key, v57);
        if (v60 >= 0) {
          __int16 v53 = v57;
        }
        else {
          __int16 v53 = *(unsigned char **)v57;
        }
        uint64_t v54 = &__p;
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          uint64_t v54 = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        *(_DWORD *)uint64_t v61 = 136315394;
        CFTypeRef v62 = v53;
        __int16 v63 = 2080;
        uint64_t v64 = v54;
        _os_log_error_impl(&dword_1E3F0E000, v42, OS_LOG_TYPE_ERROR, "Key '%s' is missing from specification or has unrecognized value '%s'", v61, 0x16u);
        if (v60 < 0) {
          operator delete(*(void **)v57);
        }
      }

      *a3 = 0;
      a3[1] = 0;
      if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) == 0) {
        goto LABEL_79;
      }
      goto LABEL_78;
    }
    int v46 = 1;
  }
  uint64_t v47 = *a2;
  if (*((unsigned char *)a2 + 184))
  {
    if (v47 >= 7) {
      goto LABEL_101;
    }
    int v48 = (char *)&unk_1E4155518 + 4 * v47;
    LODWORD(a2) = dword_1E4155534[v47];
    __int16 v49 = &unk_1E4155570;
  }
  else
  {
    if (v47 >= 7) {
      goto LABEL_101;
    }
    int v48 = (char *)&unk_1E41554C0 + 4 * v47;
    LODWORD(a2) = 402653186;
    __int16 v49 = &unk_1E41554E0;
  }
  LODWORD(v33) = *(_DWORD *)v48;
  LODWORD(v37) = dword_1E4155550[(int)v47];
  int v32 = (uint64_t *)v49[(int)v47];
LABEL_101:
  std::string v50 = operator new(0x48uLL);
  v50[1] = 0;
  v50[2] = 0;
  *std::string v50 = &unk_1F3F72C60;
  void v50[3] = &unk_1F3F73E30;
  *((_DWORD *)v50 + 8) = v33;
  *((_DWORD *)v50 + 9) = 0;
  *((_DWORD *)v50 + 10) = a2;
  *((_DWORD *)v50 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v37;
  unsigned char v50[6] = v32;
  *((_DWORD *)v50 + 14) = v31;
  *((_DWORD *)v50 + 15) = v46;
  *((_DWORD *)v50 + 16) = v21;
  *a3 = v50 + 3;
  a3[1] = v50;
  if (v36 < 0) {
LABEL_78:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_79:
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v56.__r_.__value_.__l.__data_);
  }
LABEL_81:
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(buf.__r_.__value_.__l.__data_);
  }
}

uint64_t std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72C60;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterNotSuggestibleForInput>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72C60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterControlCharacters>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)std::string buf = 136315394;
      size_t v10 = "FilterControlCharacters";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73180;
  result[3] = &unk_1F3F73E00;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3FA04C8()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterControlCharacters>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterControlCharacters>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73180;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterControlCharacters>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73180;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterIncomplete>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)std::string buf = 136315394;
      size_t v10 = "FilterIncomplete";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73148;
  result[3] = &unk_1F3F73DD0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3FA06E4()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterIncomplete>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterIncomplete>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73148;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterIncomplete>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73148;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterAppNames>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)std::string buf = 136315394;
      size_t v10 = "FilterAppNames";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F73110;
  result[3] = &unk_1F3F730E0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3FA0900()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterAppNames>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterAppNames>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73110;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterAppNames>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73110;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterWordsConflictingWithValidContactNames>(CFTypeRef *a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = (const __CFDictionary *)*a1;
  if (!v4 || CFDictionaryGetCount(v4) != 1)
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v9 = (const __CFDictionary *)*a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      int v11 = 134217984;
      CFIndex Count = CFDictionaryGetCount(v9);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "FilterWordsConflictingWithValidContactNames factory expects 1 parameter, but specification includes %ld", (uint8_t *)&v11, 0xCu);
    }
  }
  CFDictionaryRef v6 = (const __CFDictionary *)*a1;
  if (*a1)
  {
    CFRetain(*a1);
    unint64_t v7 = bounded_float_for_key(v6, @"LanguagePowerRatio", 0.0, 1.0);
    CFRelease(v6);
  }
  else
  {
    unint64_t v7 = bounded_float_for_key(0, @"LanguagePowerRatio", 0.0, 1.0);
  }
  if (HIDWORD(v7))
  {
    unsigned int v8 = operator new(0x28uLL);
    v8[1] = 0;
    v8[2] = 0;
    void *v8 = &unk_1F3F73040;
    void v8[3] = &unk_1F3F73078;
    *((_DWORD *)v8 + 8) = v7;
    *a2 = v8 + 3;
    a2[1] = v8;
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1E3FA0B54()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73040;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterWordsConflictingWithValidContactNames>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73040;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::operator()(uint64_t a1, CFTypeRef *a2, uint64_t a3)
{
  uint64_t v3 = *(void (**)(CFTypeRef *, uint64_t))(a1 + 8);
  CFTypeRef cf = *a2;
  *a2 = 0;
  v3(&cf, a3);
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F72B10;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1F3F72B10;
  result[1] = v3;
  return result;
}

void std::__function::__func<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&),std::allocator<std::shared_ptr<KB::CandidateFilter> (*)(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>,std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>::~__func()
{
}

void *KB::CandidateFilterFactory::create_filter_with_parameters<KB::FilterZeroProbability>@<X0>(const __CFDictionary **a1@<X0>, void *a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef v4 = *a1;
  if (v4 && CFDictionaryGetCount(v4))
  {
    CFDictionaryRef v5 = filter_factory_log();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      CFDictionaryRef v7 = *a1;
      if (!*a1)
      {
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
      *(_DWORD *)std::string buf = 136315394;
      size_t v10 = "FilterZeroProbability";
      __int16 v11 = 2048;
      CFIndex Count = CFDictionaryGetCount(v7);
      _os_log_error_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_ERROR, "%s factory expects 0 parameters, but specification includes %ld", buf, 0x16u);
    }
  }
  double result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *double result = &unk_1F3F730A8;
  result[3] = &unk_1F3F73DA0;
  *a2 = result + 3;
  a2[1] = result;
  return result;
}

void sub_1E3FA0E40()
{
}

uint64_t std::__shared_ptr_emplace<KB::FilterZeroProbability>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::FilterZeroProbability>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F730A8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::FilterZeroProbability>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F730A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::unique_ptr<std::unordered_map<std::string,std::function<std::shared_ptr<KB::CandidateFilter> ()(applesauce::CF::DictionaryRef,KB::CandidateFilterConfiguration const&)>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  return a1;
}

uint64_t std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72AB8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::CompositeCandidateFilter>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F72AB8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void KB::CandidateFilterFactory::create_standard_filter_definition(uint64_t a1, uint64_t a2)
{
  if (KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)(a1 + 144)) - 1 > 1) {
    return;
  }
  int v4 = *(_DWORD *)a1;
  if ((*(_DWORD *)a1 - 1) < 4)
  {
    int v5 = *(_DWORD *)(a1 + 136);
    if (v5)
    {
      if (v5 == 1)
      {
        CFDictionaryRef v6 = filter_factory_log();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl(&dword_1E3F0E000, v6, OS_LOG_TYPE_INFO, "Create standard prediction, completion, or replacement candidate filter (TIFavoniusCandQualityFilter).", buf, 2u);
        }

        KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_favonius_definition(a1, a2);
      }
    }
    else
    {
      size_t v10 = filter_factory_log();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_impl(&dword_1E3F0E000, v10, OS_LOG_TYPE_INFO, "Create standard prediction, completion, or replacement candidate filter (TICandQualityFilter).", v12, 2u);
      }

      KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_defintion(a1, a2);
    }
    return;
  }
  if ((v4 - 5) < 2) {
    goto LABEL_9;
  }
  if (v4) {
    return;
  }
  int v8 = *(_DWORD *)(a1 + 136);
  if (v8)
  {
    if (v8 != 1)
    {
LABEL_9:
      CFDictionaryRef v7 = filter_factory_log();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)size_t v14 = 0;
        _os_log_impl(&dword_1E3F0E000, v7, OS_LOG_TYPE_INFO, "Create standard continuous path candidate filter.", v14, 2u);
      }

      KB::CandidateFilterFactory::create_standard_continuous_path_filter_definition(a1, a2);
      return;
    }
    CFDictionaryRef v9 = filter_factory_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)char v16 = 0;
      _os_log_impl(&dword_1E3F0E000, v9, OS_LOG_TYPE_INFO, "Create standard autocorrect candidate filter (TIFavoniusCandQualityFilter).", v16, 2u);
    }

    KB::CandidateFilterFactory::create_standard_autocorrect_filter_favonius_definition(a1, a2);
  }
  else
  {
    __int16 v11 = filter_factory_log();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl(&dword_1E3F0E000, v11, OS_LOG_TYPE_INFO, "Create standard autocorrect candidate filter (TICandQualityFilter).", v15, 2u);
    }

    KB::CandidateFilterFactory::create_standard_autocorrect_filter_definition(a1, a2);
  }
}

void KB::CandidateFilterFactory::create_standard_autocorrect_filter_favonius_definition(uint64_t a1, uint64_t a2)
{
  v310[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 44);
  int v7 = *(_DWORD *)(a1 + 48);
  int v6 = *(_DWORD *)(a1 + 52);
  int v188 = *(_DWORD *)(a1 + 60);
  uint64_t v9 = *(unsigned int *)(a1 + 80);
  unsigned int v8 = *(_DWORD *)(a1 + 84);
  unsigned int v189 = *(_DWORD *)(a1 + 88);
  int v10 = *(_DWORD *)(a1 + 92);
  int v12 = *(_DWORD *)(a1 + 100);
  int v11 = *(_DWORD *)(a1 + 104);
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  int v14 = *(_DWORD *)(a1 + 120);
  v309 = @"FilterName";
  v310[0] = @"FilterZeroProbability";
  id v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v310 forKeys:&v309 count:1];
  char v16 = v15;
  if (v15)
  {
    CFRetain(v15);
    CFTypeRef v222 = v16;
    CFTypeID v17 = CFGetTypeID(v16);
    int v18 = v16;
    if (v17 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    int v18 = 0;
    CFTypeRef v222 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v222);
  if (v18) {
    CFRelease(v18);
  }

  v307 = @"FilterName";
  v308 = @"FilterIncomplete";
  id v19 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v308 forKeys:&v307 count:1];
  uint64_t v20 = v19;
  if (v19)
  {
    CFRetain(v19);
    CFTypeRef v221 = v20;
    CFTypeID v21 = CFGetTypeID(v20);
    CFNumberRef v22 = v20;
    if (v21 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    CFNumberRef v22 = 0;
    CFTypeRef v221 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v221);
  if (v22) {
    CFRelease(v22);
  }

  unint64_t v23 = 0x1E4F1C000uLL;
  if (*(unsigned char *)(a1 + 185))
  {
    v305 = @"FilterName";
    v306 = @"FilterWithoutSupplementalWords";
    id v24 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v306 forKeys:&v305 count:1];
    std::string::size_type v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      CFTypeRef v220 = v25;
      CFTypeID v26 = CFGetTypeID(v25);
      CFNumberType v27 = v25;
      BOOL v28 = v26 == CFDictionaryGetTypeID();
      unint64_t v23 = 0x1E4F1C000;
      if (!v28) {
        goto LABEL_204;
      }
    }
    else
    {
      CFNumberType v27 = 0;
      CFTypeRef v220 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v220);
    if (v27) {
      CFRelease(v27);
    }

    v303 = @"FilterName";
    v304 = @"FilterPartOfHyphenatedWord";
    id v29 = [*(id *)(v23 + 2536) dictionaryWithObjects:&v304 forKeys:&v303 count:1];
    unsigned __int8 v30 = v29;
    if (v29)
    {
      CFRetain(v29);
      CFTypeRef v219 = v30;
      CFTypeID v31 = CFGetTypeID(v30);
      int v32 = v30;
      if (v31 != CFDictionaryGetTypeID()) {
        goto LABEL_204;
      }
    }
    else
    {
      int v32 = 0;
      CFTypeRef v219 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v219);
    if (v32) {
      CFRelease(v32);
    }

    unint64_t v23 = 0x1E4F1C000uLL;
  }
  uint64_t v34 = *(void *)(a1 + 168);
  std::string::size_type v33 = *(std::__shared_weak_count **)(a1 + 176);
  if (v33)
  {
    atomic_fetch_add_explicit(&v33->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v33);
  }
  if (v34)
  {
    v301 = @"FilterName";
    v302 = @"CustomFilter";
    id v35 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v302 forKeys:&v301 count:1];
    char v36 = v35;
    if (v35)
    {
      CFRetain(v35);
      CFTypeRef v218 = v36;
      CFTypeID v37 = CFGetTypeID(v36);
      BOOL v38 = v36;
      if (v37 != CFDictionaryGetTypeID()) {
        goto LABEL_204;
      }
    }
    else
    {
      BOOL v38 = 0;
      CFTypeRef v218 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v218);
    if (v38) {
      CFRelease(v38);
    }
  }
  int v39 = _os_feature_enabled_impl();
  BOOL v40 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled)) {
    BOOL v40 = v39;
  }
  if (v40)
  {
    v299 = @"FilterName";
    v300 = @"FilterNumberlikeTokenMismatch";
    id v41 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v300 forKeys:&v299 count:1];
    CFDictionaryRef v42 = v41;
    if (v41)
    {
      CFRetain(v41);
      v217 = v42;
      CFTypeID v43 = CFGetTypeID(v42);
      CFTypeRef v44 = v42;
      if (v43 != CFDictionaryGetTypeID()) {
        goto LABEL_204;
      }
    }
    else
    {
      CFTypeRef v44 = 0;
      v217 = 0;
    }

    uint64_t v47 = (CFTypeRef *)&v217;
  }
  else
  {
    v297 = @"FilterName";
    v298 = @"FilterNumberMismatch";
    id v45 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v298 forKeys:&v297 count:1];
    CFDictionaryRef v42 = v45;
    if (v45)
    {
      CFRetain(v45);
      v216 = v42;
      CFTypeID v46 = CFGetTypeID(v42);
      CFTypeRef v44 = v42;
      if (v46 != CFDictionaryGetTypeID()) {
        goto LABEL_204;
      }
    }
    else
    {
      CFTypeRef v44 = 0;
      v216 = 0;
    }

    uint64_t v47 = (CFTypeRef *)&v216;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v47);
  if (v44) {
    CFRelease(v44);
  }

  v295 = @"FilterName";
  v296 = @"FilterControlCharacters";
  id v48 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v296 forKeys:&v295 count:1];
  __int16 v49 = v48;
  if (v48)
  {
    CFRetain(v48);
    CFTypeRef v215 = v49;
    CFTypeID v50 = CFGetTypeID(v49);
    uint64_t v51 = v49;
    if (v50 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v51 = 0;
    CFTypeRef v215 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v215);
  if (v51) {
    CFRelease(v51);
  }

  v293 = @"FilterName";
  v294 = @"FilterAlteredURLFragments";
  id v52 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v294 forKeys:&v293 count:1];
  __int16 v53 = v52;
  if (v52)
  {
    CFRetain(v52);
    CFTypeRef v214 = v53;
    CFTypeID v54 = CFGetTypeID(v53);
    uint64_t v55 = v53;
    if (v54 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v55 = 0;
    CFTypeRef v214 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v214);
  if (v55) {
    CFRelease(v55);
  }

  v291 = @"FilterName";
  v292 = @"FilterDoubleApostrophe";
  id v56 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v292 forKeys:&v291 count:1];
  CFTypeRef v57 = v56;
  if (v56)
  {
    CFRetain(v56);
    CFTypeRef v213 = v57;
    CFTypeID v58 = CFGetTypeID(v57);
    char v59 = v57;
    if (v58 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    char v59 = 0;
    CFTypeRef v213 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v213);
  if (v59) {
    CFRelease(v59);
  }

  v289 = @"FilterName";
  v290 = @"FilterWordEndingApostropheBetweenNonseparators";
  id v60 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v290 forKeys:&v289 count:1];
  uint64_t v61 = v60;
  if (v60)
  {
    CFRetain(v60);
    CFTypeRef v212 = v61;
    CFTypeID v62 = CFGetTypeID(v61);
    __int16 v63 = v61;
    if (v62 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    __int16 v63 = 0;
    CFTypeRef v212 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v212);
  if (v63) {
    CFRelease(v63);
  }

  v288[0] = @"FilterAllCapsNoSuggestWordsOfLength";
  v287[0] = @"FilterName";
  v287[1] = @"Parameters";
  v285 = @"Length";
  v286 = &unk_1F3FA7AF0;
  uint64_t v64 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v286 forKeys:&v285 count:1];
  v288[1] = v64;
  id v65 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v288 forKeys:v287 count:2];
  uint64_t v66 = v65;
  if (v65)
  {
    CFRetain(v65);
    CFTypeRef v211 = v66;
    CFTypeID v67 = CFGetTypeID(v66);
    unint64_t v68 = v66;
    BOOL v28 = v67 == CFDictionaryGetTypeID();
    unint64_t v23 = 0x1E4F1C000;
    if (!v28) {
      goto LABEL_204;
    }
  }
  else
  {
    unint64_t v68 = 0;
    CFTypeRef v211 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v211);
  if (v68) {
    CFRelease(v68);
  }

  v283 = @"FilterName";
  v284 = @"FilterPopupVariantMismatch";
  id v69 = [*(id *)(v23 + 2536) dictionaryWithObjects:&v284 forKeys:&v283 count:1];
  unint64_t v70 = v69;
  if (v69)
  {
    CFRetain(v69);
    CFTypeRef v210 = v70;
    CFTypeID v71 = CFGetTypeID(v70);
    unint64_t v72 = v70;
    if (v71 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    unint64_t v72 = 0;
    CFTypeRef v210 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v210);
  if (v72) {
    CFRelease(v72);
  }

  v282[0] = @"FilterCharacterCount";
  v281[0] = @"FilterName";
  v281[1] = @"Parameters";
  v279[0] = @"Character";
  v279[1] = @"CharacterCountRelation";
  v280[0] = @"&";
  v280[1] = @"GreaterThanOrEqualToInputCount";
  BOOL v73 = [*(id *)(v23 + 2536) dictionaryWithObjects:v280 forKeys:v279 count:2];
  v282[1] = v73;
  id v74 = [*(id *)(v23 + 2536) dictionaryWithObjects:v282 forKeys:v281 count:2];
  unint64_t v75 = v74;
  if (v74)
  {
    CFRetain(v74);
    CFTypeRef v209 = v75;
    CFTypeID v76 = CFGetTypeID(v75);
    uint64_t v77 = v75;
    BOOL v28 = v76 == CFDictionaryGetTypeID();
    unint64_t v23 = 0x1E4F1C000;
    if (!v28) {
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v77 = 0;
    CFTypeRef v209 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v209);
  if (v77) {
    CFRelease(v77);
  }

  v277 = @"FilterName";
  v278 = @"FilterContactWordsConflictingWithValidInput";
  id v78 = [*(id *)(v23 + 2536) dictionaryWithObjects:&v278 forKeys:&v277 count:1];
  unsigned int v79 = v78;
  if (v78)
  {
    CFRetain(v78);
    CFTypeRef v208 = v79;
    CFTypeID v80 = CFGetTypeID(v79);
    long long v81 = v79;
    if (v80 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    long long v81 = 0;
    CFTypeRef v208 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v208);
  if (v81) {
    CFRelease(v81);
  }

  v276[0] = @"FilterWordsConflictingWithValidContactNames";
  v275[0] = @"FilterName";
  v275[1] = @"Parameters";
  v273 = @"LanguagePowerRatio";
  LODWORD(v82) = v14;
  unint64_t v83 = [NSNumber numberWithFloat:v82];
  v274 = v83;
  unsigned __int8 v84 = [*(id *)(v23 + 2536) dictionaryWithObjects:&v274 forKeys:&v273 count:1];
  v276[1] = v84;
  id v85 = [*(id *)(v23 + 2536) dictionaryWithObjects:v276 forKeys:v275 count:2];
  unint64_t v86 = v85;
  if (v85)
  {
    CFRetain(v85);
    CFTypeRef v207 = v86;
    CFTypeID v87 = CFGetTypeID(v86);
    unint64_t v88 = v86;
    if (v87 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    unint64_t v88 = 0;
    CFTypeRef v207 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v207);
  if (v88) {
    CFRelease(v88);
  }

  v271 = @"FilterName";
  v272 = @"RescoreShortWords";
  id v89 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v272 forKeys:&v271 count:1];
  CFTypeRef v90 = v89;
  if (v89)
  {
    CFRetain(v89);
    CFTypeRef v206 = v90;
    CFTypeID v91 = CFGetTypeID(v90);
    CFTypeRef v92 = v90;
    if (v91 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    CFTypeRef v92 = 0;
    CFTypeRef v206 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v206);
  if (v92) {
    CFRelease(v92);
  }

  v269 = @"FilterName";
  v270 = @"FilterMissingOneLetterWordFromInput";
  id v93 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v270 forKeys:&v269 count:1];
  CFTypeRef v94 = v93;
  if (v93)
  {
    CFRetain(v93);
    CFTypeRef v205 = v94;
    CFTypeID v95 = CFGetTypeID(v94);
    CFTypeRef v96 = v94;
    if (v95 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    CFTypeRef v96 = 0;
    CFTypeRef v205 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v205);
  if (v96) {
    CFRelease(v96);
  }

  v267 = @"FilterName";
  v268 = @"FilterCommonLearnedTypos";
  id v97 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v268 forKeys:&v267 count:1];
  uint64_t v98 = v97;
  if (v97)
  {
    CFRetain(v97);
    CFTypeRef v204 = v98;
    CFTypeID v99 = CFGetTypeID(v98);
    unint64_t v100 = v98;
    if (v99 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    unint64_t v100 = 0;
    CFTypeRef v204 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v204);
  if (v100) {
    CFRelease(v100);
  }

  v266[0] = @"FilterSortkeyMatchFromDifferentLanguage";
  v265[0] = @"FilterName";
  v265[1] = @"Parameters";
  v263[0] = @"MinConfidenceToEstablishCurrentLanguage";
  LODWORD(v10TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v10;
  unint64_t v102 = [NSNumber numberWithFloat:v101];
  v264[0] = v102;
  v263[1] = @"SameLanguageSortkeyMatchDominanceRatio";
  LODWORD(v103) = v12;
  uint64_t v104 = [NSNumber numberWithFloat:v103];
  v264[1] = v104;
  long long v105 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v264 forKeys:v263 count:2];
  v266[1] = v105;
  id v106 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v266 forKeys:v265 count:2];
  BOOL v107 = v106;
  if (v106)
  {
    CFRetain(v106);
    CFTypeRef v203 = v107;
    CFTypeID v108 = CFGetTypeID(v107);
    uint64_t v109 = v107;
    if (v108 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v109 = 0;
    CFTypeRef v203 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v203);
  if (v109) {
    CFRelease(v109);
  }

  v262[0] = @"FilterNondominantCorrectionOfMoreWords";
  v261[0] = @"FilterName";
  v261[1] = @"Parameters";
  v259[0] = @"SortKeyMatchBoostRatio";
  LODWORD(v110) = v7;
  int v111 = [NSNumber numberWithFloat:v110];
  v260[0] = v111;
  v259[1] = @"NonRetrocorrectionBoostRatio";
  LODWORD(v112) = v6;
  v113 = [NSNumber numberWithFloat:v112];
  v260[1] = v113;
  int v114 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v260 forKeys:v259 count:2];
  v262[1] = v114;
  id v115 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v262 forKeys:v261 count:2];
  v116 = v115;
  if (v115)
  {
    CFRetain(v115);
    CFTypeRef v202 = v116;
    CFTypeID v117 = CFGetTypeID(v116);
    v118 = v116;
    if (v117 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v118 = 0;
    CFTypeRef v202 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v202);
  if (v118) {
    CFRelease(v118);
  }

  v258[0] = @"FilterNotSuggestibleForInput";
  v257[0] = @"FilterName";
  v257[1] = @"Parameters";
  v255[0] = @"WordEquivalenceType";
  v255[1] = @"ApplyFilterCondition";
  v256[0] = @"SortkeyEquivalence";
  v256[1] = @"ApplyAlways";
  v255[2] = @"ShouldRemoveVulgar";
  v256[2] = @"DoNotRemoveVulgar";
  uint64_t v119 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v256 forKeys:v255 count:3];
  v258[1] = v119;
  id v120 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v258 forKeys:v257 count:2];
  v121 = v120;
  if (v120)
  {
    CFRetain(v120);
    CFTypeRef v201 = v121;
    CFTypeID v122 = CFGetTypeID(v121);
    v123 = v121;
    if (v122 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v123 = 0;
    CFTypeRef v201 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v201);
  if (v123) {
    CFRelease(v123);
  }

  v253 = @"FilterName";
  v254 = @"FilterNonVulgarIfTopCandidateVulgar";
  id v124 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v254 forKeys:&v253 count:1];
  uint64_t v125 = v124;
  if (v124)
  {
    CFRetain(v124);
    CFTypeRef v200 = v125;
    CFTypeID v126 = CFGetTypeID(v125);
    uint64_t v127 = v125;
    if (v126 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    uint64_t v127 = 0;
    CFTypeRef v200 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v200);
  if (v127) {
    CFRelease(v127);
  }

  v252[0] = @"BoostMinimumVariation";
  v251[0] = @"FilterName";
  v251[1] = @"Parameters";
  v249 = @"MinCandidateDominanceRatio";
  LODWORD(v128) = v5;
  v129 = [NSNumber numberWithFloat:v128];
  v250 = v129;
  v130 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v250 forKeys:&v249 count:1];
  v252[1] = v130;
  id v131 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v252 forKeys:v251 count:2];
  uint64_t v132 = v131;
  if (v131)
  {
    CFRetain(v131);
    CFTypeRef v199 = v132;
    CFTypeID v133 = CFGetTypeID(v132);
    v134 = v132;
    if (v133 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v134 = 0;
    CFTypeRef v199 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v199);
  if (v134) {
    CFRelease(v134);
  }

  v247 = @"FilterName";
  v248 = @"FilterInvalidTextReplacement";
  id v135 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v248 forKeys:&v247 count:1];
  v136 = v135;
  if (v135)
  {
    CFRetain(v135);
    CFTypeRef v198 = v136;
    CFTypeID v137 = CFGetTypeID(v136);
    v138 = v136;
    if (v137 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v138 = 0;
    CFTypeRef v198 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v198);
  if (v138) {
    CFRelease(v138);
  }

  v245 = @"FilterName";
  v246 = @"FilterLearnedTypo";
  id v139 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v246 forKeys:&v245 count:1];
  v140 = v139;
  if (v139)
  {
    CFRetain(v139);
    CFTypeRef v197 = v140;
    CFTypeID v141 = CFGetTypeID(v140);
    v142 = v140;
    if (v141 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v142 = 0;
    CFTypeRef v197 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v197);
  if (v142) {
    CFRelease(v142);
  }

  v243 = @"FilterName";
  v244 = @"FilterCaseVariantsOfStaticWords";
  id v143 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v244 forKeys:&v243 count:1];
  v144 = v143;
  if (v143)
  {
    CFRetain(v143);
    CFTypeRef v196 = v144;
    CFTypeID v145 = CFGetTypeID(v144);
    v146 = v144;
    if (v145 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v146 = 0;
    CFTypeRef v196 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v196);
  if (v146) {
    CFRelease(v146);
  }

  v242[0] = @"FilterTopDynamicWordsWithStaticVariant";
  v241[0] = @"FilterName";
  v241[1] = @"Parameters";
  v239[0] = @"MinUsageCountForDynamicCaseVariant";
  v147 = [NSNumber numberWithUnsignedInt:v13];
  v240[0] = v147;
  v239[1] = @"MinOmegaRatioForDynamicCaseVariant";
  LODWORD(v148) = v11;
  v149 = [NSNumber numberWithFloat:v148];
  v240[1] = v149;
  CFLocaleRef v150 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v240 forKeys:v239 count:2];
  v242[1] = v150;
  id v151 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v242 forKeys:v241 count:2];
  v152 = v151;
  if (v151)
  {
    CFRetain(v151);
    CFTypeRef v195 = v152;
    CFTypeID v153 = CFGetTypeID(v152);
    int v154 = v152;
    if (v153 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    int v154 = 0;
    CFTypeRef v195 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v195);
  if (v154) {
    CFRelease(v154);
  }

  v238[0] = @"BoostPreferedFormForSortkey";
  v237[0] = @"FilterName";
  v237[1] = @"Parameters";
  v235 = @"MinSuggestionDominanceRatio";
  LODWORD(v155) = v4;
  uint64_t v156 = [NSNumber numberWithFloat:v155];
  v236 = v156;
  v157 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v236 forKeys:&v235 count:1];
  v238[1] = v157;
  id v158 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v238 forKeys:v237 count:2];
  id v159 = v158;
  if (v158)
  {
    CFRetain(v158);
    CFTypeRef v194 = v159;
    CFTypeID v160 = CFGetTypeID(v159);
    v161 = v159;
    if (v160 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v161 = 0;
    CFTypeRef v194 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v194);
  if (v161) {
    CFRelease(v161);
  }

  v233[0] = @"FilterName";
  v233[1] = @"Parameters";
  v234[0] = @"ChooseTopQualityAutocorrection";
  v231[0] = @"MinLinguisticSynergyForComplexCorrection";
  LODWORD(v162) = v188;
  v163 = [NSNumber numberWithFloat:v162];
  v232[0] = v163;
  v231[1] = @"MinSuggestionDominanceRatio";
  LODWORD(v164) = v4;
  long long v165 = [NSNumber numberWithFloat:v164];
  v232[1] = v165;
  v231[2] = @"MinStemLengthForPredictingOneLetter";
  long long v166 = [NSNumber numberWithUnsignedInt:v9];
  v232[2] = v166;
  v231[3] = @"MinStemLengthForPredictingTwoLetters";
  v167 = [NSNumber numberWithUnsignedInt:v8];
  v232[3] = v167;
  v231[4] = @"MinStemLengthForPredictingThreeLetters";
  v168 = [NSNumber numberWithUnsignedInt:v189];
  v232[4] = v168;
  __int16 v169 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v232 forKeys:v231 count:5];
  v234[1] = v169;
  id v170 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v234 forKeys:v233 count:2];
  v171 = v170;
  if (v170)
  {
    CFRetain(v170);
    CFTypeRef v193 = v171;
    CFTypeID v172 = CFGetTypeID(v171);
    char v173 = v171;
    if (v172 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    char v173 = 0;
    CFTypeRef v193 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v193);
  if (v173) {
    CFRelease(v173);
  }

  v229[0] = @"FilterName";
  v229[1] = @"Parameters";
  v230[0] = @"FilterNotSuggestibleForInput";
  v227[0] = @"WordEquivalenceType";
  v227[1] = @"ApplyFilterCondition";
  v228[0] = @"SurfaceFormEquivalence";
  v228[1] = @"ApplyAlways";
  v227[2] = @"ShouldRemoveVulgar";
  v228[2] = @"RemoveVulgarOnlyIfNotAllowlisted";
  char v174 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v228 forKeys:v227 count:3];
  v230[1] = v174;
  id v175 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v230 forKeys:v229 count:2];
  v176 = v175;
  if (v175)
  {
    CFRetain(v175);
    CFTypeRef v192 = v176;
    CFTypeID v177 = CFGetTypeID(v176);
    v178 = v176;
    if (v177 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v178 = 0;
    CFTypeRef v192 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v192);
  if (v178) {
    CFRelease(v178);
  }

  v225 = @"FilterName";
  v226 = @"RemoveAlternatesIfNoLinguisticCandidate";
  id v179 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v226 forKeys:&v225 count:1];
  v180 = v179;
  if (v179)
  {
    CFRetain(v179);
    CFTypeRef v191 = v180;
    CFTypeID v181 = CFGetTypeID(v180);
    v182 = v180;
    if (v181 != CFDictionaryGetTypeID())
    {
LABEL_204:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  else
  {
    v182 = 0;
    CFTypeRef v191 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v191);
  if (v182) {
    CFRelease(v182);
  }

  v223 = @"FilterName";
  v224 = @"FilterDuplicates";
  id v183 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v224 forKeys:&v223 count:1];
  v184 = v183;
  if (v183)
  {
    CFRetain(v183);
    CFTypeRef v190 = v184;
    CFTypeID v185 = CFGetTypeID(v184);
    v186 = v184;
    if (v185 != CFDictionaryGetTypeID()) {
      goto LABEL_204;
    }
  }
  else
  {
    v186 = 0;
    CFTypeRef v190 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v190);
  if (v186) {
    CFRelease(v186);
  }
}

void KB::CandidateFilterFactory::create_standard_autocorrect_filter_definition(uint64_t a1, uint64_t a2)
{
  v255[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 44);
  int v6 = *(_DWORD *)(a1 + 60);
  unsigned int v7 = *(_DWORD *)(a1 + 80);
  unsigned int v156 = *(_DWORD *)(a1 + 84);
  unsigned int v8 = *(_DWORD *)(a1 + 88);
  int v9 = *(_DWORD *)(a1 + 104);
  uint64_t v10 = *(unsigned int *)(a1 + 108);
  int v11 = *(_DWORD *)(a1 + 120);
  uint64_t v12 = *(unsigned int *)(a1 + 124);
  v254 = @"FilterName";
  v255[0] = @"FilterZeroProbability";
  unint64_t v13 = 0x1E4F1C000uLL;
  id v14 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v255 forKeys:&v254 count:1];
  id v15 = v14;
  if (v14)
  {
    CFRetain(v14);
    CFTypeRef v183 = v15;
    CFTypeID v16 = CFGetTypeID(v15);
    CFTypeID v17 = v15;
    BOOL v18 = v16 == CFDictionaryGetTypeID();
    unint64_t v13 = 0x1E4F1C000;
    if (!v18) {
      goto LABEL_170;
    }
  }
  else
  {
    CFTypeID v17 = 0;
    CFTypeRef v183 = 0;
  }
  unsigned int v155 = v8;

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v183);
  if (v17) {
    CFRelease(v17);
  }

  v252[0] = @"FilterName";
  v252[1] = @"Parameters";
  v253[0] = @"FilterWordsConflictingWithValidContactNames";
  v250 = @"LanguagePowerRatio";
  LODWORD(v19) = v11;
  uint64_t v20 = [NSNumber numberWithFloat:v19];
  v251 = v20;
  uint64_t v21 = [*(id *)(v13 + 2536) dictionaryWithObjects:&v251 forKeys:&v250 count:1];
  unint64_t v22 = v13;
  unint64_t v23 = (void *)v21;
  v253[1] = v21;
  id v24 = [*(id *)(v22 + 2536) dictionaryWithObjects:v253 forKeys:v252 count:2];
  std::string::size_type v25 = v24;
  if (v24)
  {
    CFRetain(v24);
    CFTypeRef v182 = v25;
    CFTypeID v26 = CFGetTypeID(v25);
    CFNumberType v27 = v25;
    if (v26 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    CFNumberType v27 = 0;
    CFTypeRef v182 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v182);
  if (v27) {
    CFRelease(v27);
  }

  v248 = @"FilterName";
  v249 = @"RescoreShortWords";
  id v28 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v249 forKeys:&v248 count:1];
  id v29 = v28;
  if (v28)
  {
    CFRetain(v28);
    CFTypeRef v181 = v29;
    CFTypeID v30 = CFGetTypeID(v29);
    CFTypeID v31 = v29;
    if (v30 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    CFTypeID v31 = 0;
    CFTypeRef v181 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v181);
  if (v31) {
    CFRelease(v31);
  }

  v246 = @"FilterName";
  v247 = @"FilterIncomplete";
  id v32 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v247 forKeys:&v246 count:1];
  std::string::size_type v33 = v32;
  if (v32)
  {
    CFRetain(v32);
    CFTypeRef v180 = v33;
    CFTypeID v34 = CFGetTypeID(v33);
    id v35 = v33;
    if (v34 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    id v35 = 0;
    CFTypeRef v180 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v180);
  if (v35) {
    CFRelease(v35);
  }

  if (*(unsigned char *)(a1 + 185))
  {
    v244 = @"FilterName";
    v245 = @"FilterWithoutSupplementalWords";
    id v36 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v245 forKeys:&v244 count:1];
    CFTypeID v37 = v36;
    if (v36)
    {
      CFRetain(v36);
      CFTypeRef v179 = v37;
      CFTypeID v38 = CFGetTypeID(v37);
      int v39 = v37;
      if (v38 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      int v39 = 0;
      CFTypeRef v179 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v179);
    if (v39) {
      CFRelease(v39);
    }

    v242 = @"FilterName";
    v243 = @"FilterPartOfHyphenatedWord";
    id v40 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v243 forKeys:&v242 count:1];
    id v41 = v40;
    if (v40)
    {
      CFRetain(v40);
      CFTypeRef v178 = v41;
      CFTypeID v42 = CFGetTypeID(v41);
      CFTypeID v43 = v41;
      if (v42 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      CFTypeID v43 = 0;
      CFTypeRef v178 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v178);
    if (v43) {
      CFRelease(v43);
    }
  }
  uint64_t v45 = *(void *)(a1 + 168);
  CFTypeRef v44 = *(std::__shared_weak_count **)(a1 + 176);
  if (v44)
  {
    atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:nn180100](v44);
  }
  if (v45)
  {
    v240 = @"FilterName";
    v241 = @"CustomFilter";
    id v46 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v241 forKeys:&v240 count:1];
    uint64_t v47 = v46;
    if (v46)
    {
      CFRetain(v46);
      CFTypeRef v177 = v47;
      CFTypeID v48 = CFGetTypeID(v47);
      __int16 v49 = v47;
      if (v48 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      __int16 v49 = 0;
      CFTypeRef v177 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v177);
    if (v49) {
      CFRelease(v49);
    }
  }
  v238 = @"FilterName";
  v239 = @"FilterControlCharacters";
  id v50 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v239 forKeys:&v238 count:1];
  uint64_t v51 = v50;
  if (v50)
  {
    CFRetain(v50);
    CFTypeRef v176 = v51;
    CFTypeID v52 = CFGetTypeID(v51);
    __int16 v53 = v51;
    if (v52 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    __int16 v53 = 0;
    CFTypeRef v176 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v176);
  if (v53) {
    CFRelease(v53);
  }

  if (!*(unsigned char *)(a1 + 188))
  {
    v237[0] = @"FilterCorrectionsIfAnyCandidateMatchesInput";
    v236[0] = @"FilterName";
    v236[1] = @"Parameters";
    v234 = @"WithinTopXAutocorrectionCandidates";
    CFTypeID v54 = [NSNumber numberWithInt:v12];
    v235 = v54;
    uint64_t v55 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v235 forKeys:&v234 count:1];
    v237[1] = v55;
    id v56 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v237 forKeys:v236 count:2];
    CFTypeRef v57 = v56;
    if (v56)
    {
      CFRetain(v56);
      CFTypeRef v175 = v57;
      CFTypeID v58 = CFGetTypeID(v57);
      char v59 = v57;
      if (v58 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      char v59 = 0;
      CFTypeRef v175 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v175);
    if (v59) {
      CFRelease(v59);
    }
  }
  v233[0] = @"FilterNotSuggestibleForInput";
  v232[0] = @"FilterName";
  v232[1] = @"Parameters";
  v230[0] = @"WordEquivalenceType";
  v230[1] = @"ApplyFilterCondition";
  v231[0] = @"SortkeyEquivalence";
  v231[1] = @"ApplyIfCandidatesContainInputMatch";
  void v230[2] = @"ShouldRemoveVulgar";
  v231[2] = @"DoNotRemoveVulgar";
  id v60 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v231 forKeys:v230 count:3];
  v233[1] = v60;
  id v61 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v233 forKeys:v232 count:2];
  CFTypeID v62 = v61;
  if (v61)
  {
    CFRetain(v61);
    CFTypeRef v174 = v62;
    CFTypeID v63 = CFGetTypeID(v62);
    uint64_t v64 = v62;
    if (v63 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    uint64_t v64 = 0;
    CFTypeRef v174 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v174);
  if (v64) {
    CFRelease(v64);
  }

  v228 = @"FilterName";
  v229 = @"FilterNonVulgarIfTopCandidateVulgar";
  id v65 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v229 forKeys:&v228 count:1];
  uint64_t v66 = v65;
  if (v65)
  {
    CFRetain(v65);
    CFTypeRef v173 = v66;
    CFTypeID v67 = CFGetTypeID(v66);
    unint64_t v68 = v66;
    if (v67 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    unint64_t v68 = 0;
    CFTypeRef v173 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v173);
  if (v68) {
    CFRelease(v68);
  }

  v227[0] = @"BoostMinimumVariation";
  v226[0] = @"FilterName";
  v226[1] = @"Parameters";
  v224 = @"MinCandidateDominanceRatio";
  LODWORD(v69) = v5;
  unint64_t v70 = [NSNumber numberWithFloat:v69];
  v225 = v70;
  CFTypeID v71 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v225 forKeys:&v224 count:1];
  v227[1] = v71;
  id v72 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v227 forKeys:v226 count:2];
  BOOL v73 = v72;
  if (v72)
  {
    CFRetain(v72);
    CFTypeRef v172 = v73;
    CFTypeID v74 = CFGetTypeID(v73);
    unint64_t v75 = v73;
    if (v74 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    unint64_t v75 = 0;
    CFTypeRef v172 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v172);
  if (v75) {
    CFRelease(v75);
  }

  int v76 = _os_feature_enabled_impl();
  BOOL v77 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled)) {
    BOOL v77 = v76;
  }
  if (v77)
  {
    CFTypeRef v222 = @"FilterName";
    v223 = @"FilterNumberlikeTokenMismatch";
    id v78 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v223 forKeys:&v222 count:1];
    unsigned int v79 = v78;
    if (v78)
    {
      CFRetain(v78);
      v171 = v79;
      CFTypeID v80 = CFGetTypeID(v79);
      long long v81 = v79;
      if (v80 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      long long v81 = 0;
      v171 = 0;
    }

    unsigned __int8 v84 = (CFTypeRef *)&v171;
  }
  else
  {
    CFTypeRef v220 = @"FilterName";
    CFTypeRef v221 = @"FilterNumberMismatch";
    id v82 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v221 forKeys:&v220 count:1];
    unsigned int v79 = v82;
    if (v82)
    {
      CFRetain(v82);
      id v170 = v79;
      CFTypeID v83 = CFGetTypeID(v79);
      long long v81 = v79;
      if (v83 != CFDictionaryGetTypeID()) {
        goto LABEL_170;
      }
    }
    else
    {
      long long v81 = 0;
      id v170 = 0;
    }

    unsigned __int8 v84 = (CFTypeRef *)&v170;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v84);
  if (v81) {
    CFRelease(v81);
  }

  v219[0] = @"FilterCharacterCount";
  v218[0] = @"FilterName";
  v218[1] = @"Parameters";
  v216[0] = @"Character";
  v216[1] = @"CharacterCountRelation";
  v217[0] = @"&";
  v217[1] = @"LessThanOrEqualToInputCount";
  id v85 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v217 forKeys:v216 count:2];
  v219[1] = v85;
  id v86 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v219 forKeys:v218 count:2];
  CFTypeID v87 = v86;
  if (v86)
  {
    CFRetain(v86);
    CFTypeRef v169 = v87;
    CFTypeID v88 = CFGetTypeID(v87);
    id v89 = v87;
    if (v88 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    id v89 = 0;
    CFTypeRef v169 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v169);
  if (v89) {
    CFRelease(v89);
  }

  CFTypeRef v214 = @"FilterName";
  CFTypeRef v215 = @"FilterAlteredURLFragments";
  id v90 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v215 forKeys:&v214 count:1];
  CFTypeID v91 = v90;
  if (v90)
  {
    CFRetain(v90);
    CFTypeRef v168 = v91;
    CFTypeID v92 = CFGetTypeID(v91);
    id v93 = v91;
    if (v92 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    id v93 = 0;
    CFTypeRef v168 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v168);
  if (v93) {
    CFRelease(v93);
  }

  CFTypeRef v212 = @"FilterName";
  CFTypeRef v213 = @"FilterDoubleApostrophe";
  id v94 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v213 forKeys:&v212 count:1];
  CFTypeID v95 = v94;
  if (v94)
  {
    CFRetain(v94);
    CFTypeRef v167 = v95;
    CFTypeID v96 = CFGetTypeID(v95);
    id v97 = v95;
    if (v96 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    id v97 = 0;
    CFTypeRef v167 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v167);
  if (v97) {
    CFRelease(v97);
  }

  CFTypeRef v210 = @"FilterName";
  CFTypeRef v211 = @"FilterWordEndingApostropheBetweenNonseparators";
  id v98 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v211 forKeys:&v210 count:1];
  CFTypeID v99 = v98;
  if (v98)
  {
    CFRetain(v98);
    CFTypeRef v166 = v99;
    CFTypeID v100 = CFGetTypeID(v99);
    double v101 = v99;
    if (v100 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    double v101 = 0;
    CFTypeRef v166 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v166);
  if (v101) {
    CFRelease(v101);
  }

  CFTypeRef v208 = @"FilterName";
  CFTypeRef v209 = @"FilterInvalidTextReplacement";
  id v102 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v209 forKeys:&v208 count:1];
  double v103 = v102;
  if (v102)
  {
    CFRetain(v102);
    CFTypeRef v165 = v103;
    CFTypeID v104 = CFGetTypeID(v103);
    long long v105 = v103;
    if (v104 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    long long v105 = 0;
    CFTypeRef v165 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v165);
  if (v105) {
    CFRelease(v105);
  }

  CFTypeRef v206 = @"FilterName";
  CFTypeRef v207 = @"FilterLearnedTypo";
  id v106 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v207 forKeys:&v206 count:1];
  BOOL v107 = v106;
  if (v106)
  {
    CFRetain(v106);
    CFTypeRef v164 = v107;
    CFTypeID v108 = CFGetTypeID(v107);
    uint64_t v109 = v107;
    if (v108 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    uint64_t v109 = 0;
    CFTypeRef v164 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v164);
  if (v109) {
    CFRelease(v109);
  }

  CFTypeRef v204 = @"FilterName";
  CFTypeRef v205 = @"FilterCaseVariantsOfStaticWords";
  id v110 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v205 forKeys:&v204 count:1];
  int v111 = v110;
  if (v110)
  {
    CFRetain(v110);
    CFTypeRef v163 = v111;
    CFTypeID v112 = CFGetTypeID(v111);
    v113 = v111;
    if (v112 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    v113 = 0;
    CFTypeRef v163 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v163);
  if (v113) {
    CFRelease(v113);
  }

  v203[0] = @"FilterTopDynamicWordsWithStaticVariant";
  v202[0] = @"FilterName";
  v202[1] = @"Parameters";
  v200[0] = @"MinUsageCountForDynamicCaseVariant";
  int v114 = [NSNumber numberWithUnsignedInt:v10];
  v201[0] = v114;
  v200[1] = @"MinOmegaRatioForDynamicCaseVariant";
  LODWORD(v115) = v9;
  v116 = [NSNumber numberWithFloat:v115];
  v201[1] = v116;
  CFTypeID v117 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v201 forKeys:v200 count:2];
  v203[1] = v117;
  id v118 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v203 forKeys:v202 count:2];
  uint64_t v119 = v118;
  if (v118)
  {
    CFRetain(v118);
    CFTypeRef v162 = v119;
    CFTypeID v120 = CFGetTypeID(v119);
    v121 = v119;
    if (v120 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    v121 = 0;
    CFTypeRef v162 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v162);
  if (v121) {
    CFRelease(v121);
  }

  v198[0] = @"FilterName";
  v198[1] = @"Parameters";
  v199[0] = @"BoostPreferedFormForSortkey";
  CFTypeRef v196 = @"MinSuggestionDominanceRatio";
  LODWORD(v122) = v4;
  v123 = [NSNumber numberWithFloat:v122];
  CFTypeRef v197 = v123;
  id v124 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v197 forKeys:&v196 count:1];
  v199[1] = v124;
  id v125 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v199 forKeys:v198 count:2];
  CFTypeID v126 = v125;
  if (v125)
  {
    CFRetain(v125);
    CFTypeRef v161 = v126;
    CFTypeID v127 = CFGetTypeID(v126);
    double v128 = v126;
    if (v127 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    double v128 = 0;
    CFTypeRef v161 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v161);
  if (v128) {
    CFRelease(v128);
  }

  v194[0] = @"FilterName";
  v194[1] = @"Parameters";
  v195[0] = @"ChooseTopQualityAutocorrection";
  v192[0] = @"MinLinguisticSynergyForComplexCorrection";
  LODWORD(v129) = v6;
  v130 = [NSNumber numberWithFloat:v129];
  v193[0] = v130;
  v192[1] = @"MinSuggestionDominanceRatio";
  LODWORD(v13TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v4;
  uint64_t v132 = [NSNumber numberWithFloat:v131];
  v193[1] = v132;
  v192[2] = @"MinStemLengthForPredictingOneLetter";
  CFTypeID v133 = [NSNumber numberWithUnsignedInt:v7];
  v193[2] = v133;
  v192[3] = @"MinStemLengthForPredictingTwoLetters";
  v134 = [NSNumber numberWithUnsignedInt:v156];
  v193[3] = v134;
  v192[4] = @"MinStemLengthForPredictingThreeLetters";
  id v135 = [NSNumber numberWithUnsignedInt:v155];
  v193[4] = v135;
  v136 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v193 forKeys:v192 count:5];
  v195[1] = v136;
  id v137 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v195 forKeys:v194 count:2];
  v138 = v137;
  if (v137)
  {
    CFRetain(v137);
    CFTypeRef v160 = v138;
    CFTypeID v139 = CFGetTypeID(v138);
    v140 = v138;
    if (v139 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    v140 = 0;
    CFTypeRef v160 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v160);
  if (v140) {
    CFRelease(v140);
  }

  v190[1] = @"Parameters";
  v191[0] = @"FilterNotSuggestibleForInput";
  v188[0] = @"WordEquivalenceType";
  v188[1] = @"ApplyFilterCondition";
  v189[0] = @"SurfaceFormEquivalence";
  v189[1] = @"ApplyAlways";
  v188[2] = @"ShouldRemoveVulgar";
  v189[2] = @"RemoveVulgarOnlyIfNotAllowlisted";
  v190[0] = @"FilterName";
  CFTypeID v141 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v189 forKeys:v188 count:3];
  v191[1] = v141;
  id v142 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v191 forKeys:v190 count:2];
  id v143 = v142;
  if (v142)
  {
    CFRetain(v142);
    CFTypeRef v159 = v143;
    CFTypeID v144 = CFGetTypeID(v143);
    CFTypeID v145 = v143;
    if (v144 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    CFTypeID v145 = 0;
    CFTypeRef v159 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v159);
  if (v145) {
    CFRelease(v145);
  }

  v186 = @"FilterName";
  v187 = @"RemoveAlternatesIfNoLinguisticCandidate";
  id v146 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v187 forKeys:&v186 count:1];
  v147 = v146;
  if (v146)
  {
    CFRetain(v146);
    CFTypeRef v158 = v147;
    CFTypeID v148 = CFGetTypeID(v147);
    v149 = v147;
    if (v148 != CFDictionaryGetTypeID())
    {
LABEL_170:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  else
  {
    v149 = 0;
    CFTypeRef v158 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v158);
  if (v149) {
    CFRelease(v149);
  }

  v184 = @"FilterName";
  CFTypeID v185 = @"FilterDuplicates";
  id v150 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v185 forKeys:&v184 count:1];
  id v151 = v150;
  if (v150)
  {
    CFRetain(v150);
    CFTypeRef v157 = v151;
    CFTypeID v152 = CFGetTypeID(v151);
    CFTypeID v153 = v151;
    if (v152 != CFDictionaryGetTypeID()) {
      goto LABEL_170;
    }
  }
  else
  {
    CFTypeID v153 = 0;
    CFTypeRef v157 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v157);
  if (v153) {
    CFRelease(v153);
  }
}

void KB::CandidateFilterFactory::create_standard_continuous_path_filter_definition(uint64_t a1, uint64_t a2)
{
  v109[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 56);
  int v6 = *(_DWORD *)(a1 + 96);
  CFTypeID v108 = @"FilterName";
  v109[0] = @"FilterZeroProbability";
  id v7 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v109 forKeys:&v108 count:1];
  unsigned int v8 = v7;
  if (v7)
  {
    CFRetain(v7);
    CFTypeRef v77 = v8;
    CFTypeID v9 = CFGetTypeID(v8);
    uint64_t v10 = v8;
    if (v9 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    uint64_t v10 = 0;
    CFTypeRef v77 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v77);
  if (v10) {
    CFRelease(v10);
  }

  id v106 = @"FilterName";
  BOOL v107 = @"FilterIncomplete";
  id v11 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v107 forKeys:&v106 count:1];
  uint64_t v12 = v11;
  if (v11)
  {
    CFRetain(v11);
    CFTypeRef v76 = v12;
    CFTypeID v13 = CFGetTypeID(v12);
    id v14 = v12;
    if (v13 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    id v14 = 0;
    CFTypeRef v76 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v76);
  if (v14) {
    CFRelease(v14);
  }

  if (*(unsigned char *)(a1 + 185))
  {
    CFTypeID v104 = @"FilterName";
    long long v105 = @"FilterWithoutSupplementalWords";
    id v15 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v105 forKeys:&v104 count:1];
    CFTypeID v16 = v15;
    if (v15)
    {
      CFRetain(v15);
      CFTypeRef v75 = v16;
      CFTypeID v17 = CFGetTypeID(v16);
      BOOL v18 = v16;
      if (v17 != CFDictionaryGetTypeID()) {
        goto LABEL_73;
      }
    }
    else
    {
      BOOL v18 = 0;
      CFTypeRef v75 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v75);
    if (v18) {
      CFRelease(v18);
    }

    id v102 = @"FilterName";
    double v103 = @"FilterPartOfHyphenatedWord";
    id v19 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v103 forKeys:&v102 count:1];
    uint64_t v20 = v19;
    if (v19)
    {
      CFRetain(v19);
      CFTypeRef v74 = v20;
      CFTypeID v21 = CFGetTypeID(v20);
      unint64_t v22 = v20;
      if (v21 != CFDictionaryGetTypeID()) {
        goto LABEL_73;
      }
    }
    else
    {
      unint64_t v22 = 0;
      CFTypeRef v74 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v74);
    if (v22) {
      CFRelease(v22);
    }
  }
  CFTypeID v100 = @"FilterName";
  double v101 = @"FilterInvalidTextReplacement";
  id v23 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v101 forKeys:&v100 count:1];
  id v24 = v23;
  if (v23)
  {
    CFRetain(v23);
    CFTypeRef v73 = v24;
    CFTypeID v25 = CFGetTypeID(v24);
    CFTypeID v26 = v24;
    if (v25 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    CFTypeID v26 = 0;
    CFTypeRef v73 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v73);
  if (v26) {
    CFRelease(v26);
  }

  id v98 = @"FilterName";
  CFTypeID v99 = @"ExemptHighFrequencyWordsFromNoSuggest";
  id v27 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v99 forKeys:&v98 count:1];
  id v28 = v27;
  if (v27)
  {
    CFRetain(v27);
    CFTypeRef v72 = v28;
    CFTypeID v29 = CFGetTypeID(v28);
    CFTypeID v30 = v28;
    if (v29 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    CFTypeID v30 = 0;
    CFTypeRef v72 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v72);
  if (v30) {
    CFRelease(v30);
  }

  v96[1] = @"Parameters";
  v97[0] = @"FilterNotSuggestibleForInput";
  v94[0] = @"WordEquivalenceType";
  v94[1] = @"ApplyFilterCondition";
  v95[0] = @"SurfaceFormEquivalence";
  v95[1] = @"ApplyAlways";
  v96[0] = @"FilterName";
  v94[2] = @"ShouldRemoveVulgar";
  v95[2] = @"RemoveVulgarOnlyIfNotAllowlisted";
  CFTypeID v31 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v95 forKeys:v94 count:3];
  v97[1] = v31;
  id v32 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v97 forKeys:v96 count:2];
  std::string::size_type v33 = v32;
  if (v32)
  {
    CFRetain(v32);
    CFTypeRef v71 = v33;
    CFTypeID v34 = CFGetTypeID(v33);
    id v35 = v33;
    if (v34 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    id v35 = 0;
    CFTypeRef v71 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v71);
  if (v35) {
    CFRelease(v35);
  }

  v92[1] = @"Parameters";
  v93[0] = @"FilterLowQualityContinuousPathRetrocorrections";
  v92[0] = @"FilterName";
  id v90 = @"MinOmegaRatioForContinuousPathRetrocorrections";
  LODWORD(v36) = v5;
  CFTypeID v37 = [NSNumber numberWithFloat:v36];
  CFTypeID v91 = v37;
  CFTypeID v38 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v91 forKeys:&v90 count:1];
  v93[1] = v38;
  id v39 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v93 forKeys:v92 count:2];
  id v40 = v39;
  if (v39)
  {
    CFRetain(v39);
    CFTypeRef v70 = v40;
    CFTypeID v41 = CFGetTypeID(v40);
    CFTypeID v42 = v40;
    if (v41 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    CFTypeID v42 = 0;
    CFTypeRef v70 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v70);
  if (v42) {
    CFRelease(v42);
  }

  v88[1] = @"Parameters";
  v89[0] = @"BoostPreferedFormForSortkey";
  v88[0] = @"FilterName";
  id v86 = @"MinSuggestionDominanceRatio";
  LODWORD(v43) = v4;
  CFTypeRef v44 = [NSNumber numberWithFloat:v43];
  CFTypeID v87 = v44;
  uint64_t v45 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v87 forKeys:&v86 count:1];
  v89[1] = v45;
  id v46 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v89 forKeys:v88 count:2];
  uint64_t v47 = v46;
  if (v46)
  {
    CFRetain(v46);
    CFTypeRef v69 = v47;
    CFTypeID v48 = CFGetTypeID(v47);
    __int16 v49 = v47;
    if (v48 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    __int16 v49 = 0;
    CFTypeRef v69 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v69);
  if (v49) {
    CFRelease(v49);
  }

  unsigned __int8 v84 = @"FilterName";
  id v85 = @"FilterNoPredictContinuousPathAlternates";
  id v50 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v85 forKeys:&v84 count:1];
  uint64_t v51 = v50;
  if (v50)
  {
    CFRetain(v50);
    CFTypeRef v68 = v51;
    CFTypeID v52 = CFGetTypeID(v51);
    __int16 v53 = v51;
    if (v52 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    __int16 v53 = 0;
    CFTypeRef v68 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v68);
  if (v53) {
    CFRelease(v53);
  }

  if (*(unsigned char *)(a1 + 187))
  {
    id v82 = @"FilterName";
    CFTypeID v83 = @"BoostCaseVariantsOfTopCandidate";
    id v55 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v83 forKeys:&v82 count:1];
    id v56 = v55;
    if (v55)
    {
      CFRetain(v55);
      CFTypeRef v67 = v56;
      CFTypeID v57 = CFGetTypeID(v56);
      CFTypeID v58 = v56;
      if (v57 != CFDictionaryGetTypeID())
      {
LABEL_73:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      CFTypeID v58 = 0;
      CFTypeRef v67 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v67);
    if (v58) {
      CFRelease(v58);
    }
  }
  v80[1] = @"Parameters";
  v81[0] = @"FilterContinuousPathAlternatesFromOtherLanguage";
  v80[0] = @"FilterName";
  id v78 = @"MinConfidenceToEstablishContinuousPathLanguage";
  LODWORD(v54) = v6;
  char v59 = [NSNumber numberWithFloat:v54];
  unsigned int v79 = v59;
  id v60 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v79 forKeys:&v78 count:1];
  v81[1] = v60;
  id v61 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v81 forKeys:v80 count:2];
  CFTypeID v62 = v61;
  if (v61)
  {
    CFRetain(v61);
    CFTypeRef v66 = v62;
    CFTypeID v63 = CFGetTypeID(v62);
    uint64_t v64 = v62;
    if (v63 != CFDictionaryGetTypeID()) {
      goto LABEL_73;
    }
  }
  else
  {
    uint64_t v64 = 0;
    CFTypeRef v66 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v66);
  if (v64) {
    CFRelease(v64);
  }
}

void KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_favonius_definition(uint64_t a1, uint64_t a2)
{
  v179[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 44);
  unsigned int v5 = *(_DWORD *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  int v7 = *(_DWORD *)(a1 + 92);
  CFTypeRef v178 = @"FilterName";
  v179[0] = @"FilterZeroProbability";
  id v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v179 forKeys:&v178 count:1];
  CFTypeID v9 = v8;
  if (v8)
  {
    CFRetain(v8);
    CFTypeRef v125 = v9;
    CFTypeID v10 = CFGetTypeID(v9);
    id v11 = v9;
    if (v10 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    id v11 = 0;
    CFTypeRef v125 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v125);
  if (v11) {
    CFRelease(v11);
  }

  CFTypeRef v176 = @"FilterName";
  CFTypeRef v177 = @"FilterAppNames";
  id v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v177 forKeys:&v176 count:1];
  CFTypeID v13 = v12;
  if (v12)
  {
    CFRetain(v12);
    CFTypeRef v124 = v13;
    CFTypeID v14 = CFGetTypeID(v13);
    id v15 = v13;
    if (v14 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    id v15 = 0;
    CFTypeRef v124 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v124);
  if (v15) {
    CFRelease(v15);
  }

  CFTypeRef v174 = @"FilterName";
  CFTypeRef v175 = @"FilterIncomplete";
  id v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v175 forKeys:&v174 count:1];
  CFTypeID v17 = v16;
  if (v16)
  {
    CFRetain(v16);
    CFTypeRef v123 = v17;
    CFTypeID v18 = CFGetTypeID(v17);
    id v19 = v17;
    if (v18 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    id v19 = 0;
    CFTypeRef v123 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v123);
  if (v19) {
    CFRelease(v19);
  }

  if (*(unsigned char *)(a1 + 185))
  {
    CFTypeRef v172 = @"FilterName";
    CFTypeRef v173 = @"FilterWithoutSupplementalWords";
    id v20 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v173 forKeys:&v172 count:1];
    CFTypeID v21 = v20;
    if (v20)
    {
      CFRetain(v20);
      CFTypeRef v122 = v21;
      CFTypeID v22 = CFGetTypeID(v21);
      id v23 = v21;
      if (v22 != CFDictionaryGetTypeID()) {
        goto LABEL_125;
      }
    }
    else
    {
      id v23 = 0;
      CFTypeRef v122 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v122);
    if (v23) {
      CFRelease(v23);
    }

    id v170 = @"FilterName";
    v171 = @"FilterPartOfHyphenatedWord";
    id v24 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v171 forKeys:&v170 count:1];
    CFTypeID v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      CFTypeRef v121 = v25;
      CFTypeID v26 = CFGetTypeID(v25);
      id v27 = v25;
      if (v26 != CFDictionaryGetTypeID()) {
        goto LABEL_125;
      }
    }
    else
    {
      id v27 = 0;
      CFTypeRef v121 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v121);
    if (v27) {
      CFRelease(v27);
    }
  }
  int v28 = _os_feature_enabled_impl();
  BOOL v29 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled)) {
    BOOL v29 = v28;
  }
  if (v29)
  {
    CFTypeRef v168 = @"FilterName";
    CFTypeRef v169 = @"FilterNumberlikeTokenMismatch";
    id v30 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v169 forKeys:&v168 count:1];
    CFTypeID v31 = v30;
    if (v30)
    {
      CFRetain(v30);
      CFTypeID v120 = v31;
      CFTypeID v32 = CFGetTypeID(v31);
      std::string::size_type v33 = v31;
      if (v32 != CFDictionaryGetTypeID()) {
        goto LABEL_125;
      }
    }
    else
    {
      std::string::size_type v33 = 0;
      CFTypeID v120 = 0;
    }

    double v36 = (CFTypeRef *)&v120;
  }
  else
  {
    CFTypeRef v166 = @"FilterName";
    CFTypeRef v167 = @"FilterNumberMismatch";
    id v34 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v167 forKeys:&v166 count:1];
    CFTypeID v31 = v34;
    if (v34)
    {
      CFRetain(v34);
      uint64_t v119 = v31;
      CFTypeID v35 = CFGetTypeID(v31);
      std::string::size_type v33 = v31;
      if (v35 != CFDictionaryGetTypeID()) {
        goto LABEL_125;
      }
    }
    else
    {
      std::string::size_type v33 = 0;
      uint64_t v119 = 0;
    }

    double v36 = (CFTypeRef *)&v119;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v36);
  if (v33) {
    CFRelease(v33);
  }

  CFTypeRef v164 = @"FilterName";
  CFTypeRef v165 = @"FilterControlCharacters";
  id v37 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v165 forKeys:&v164 count:1];
  CFTypeID v38 = v37;
  if (v37)
  {
    CFRetain(v37);
    CFTypeRef v118 = v38;
    CFTypeID v39 = CFGetTypeID(v38);
    id v40 = v38;
    if (v39 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    id v40 = 0;
    CFTypeRef v118 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v118);
  if (v40) {
    CFRelease(v40);
  }

  CFTypeRef v162 = @"FilterName";
  CFTypeRef v163 = @"FilterDoubleApostrophe";
  id v41 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v163 forKeys:&v162 count:1];
  CFTypeID v42 = v41;
  if (v41)
  {
    CFRetain(v41);
    CFTypeRef v117 = v42;
    CFTypeID v43 = CFGetTypeID(v42);
    CFTypeRef v44 = v42;
    if (v43 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeRef v44 = 0;
    CFTypeRef v117 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v117);
  if (v44) {
    CFRelease(v44);
  }

  CFTypeRef v160 = @"FilterName";
  CFTypeRef v161 = @"FilterWordEndingApostropheBetweenNonseparators";
  id v45 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v161 forKeys:&v160 count:1];
  id v46 = v45;
  if (v45)
  {
    CFRetain(v45);
    CFTypeRef v116 = v46;
    CFTypeID v47 = CFGetTypeID(v46);
    CFTypeID v48 = v46;
    if (v47 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeID v48 = 0;
    CFTypeRef v116 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v116);
  if (v48) {
    CFRelease(v48);
  }

  v159[0] = @"FilterAllCapsNoSuggestWordsOfLength";
  v158[0] = @"FilterName";
  v158[1] = @"Parameters";
  unsigned int v156 = @"Length";
  CFTypeRef v157 = &unk_1F3FA7AF0;
  __int16 v49 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v157 forKeys:&v156 count:1];
  v159[1] = v49;
  id v50 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v159 forKeys:v158 count:2];
  uint64_t v51 = v50;
  if (v50)
  {
    CFRetain(v50);
    CFTypeRef v115 = v51;
    CFTypeID v52 = CFGetTypeID(v51);
    __int16 v53 = v51;
    if (v52 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    __int16 v53 = 0;
    CFTypeRef v115 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v115);
  if (v53) {
    CFRelease(v53);
  }

  int v154 = @"FilterName";
  unsigned int v155 = @"FilterPopupVariantMismatch";
  id v54 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v155 forKeys:&v154 count:1];
  id v55 = v54;
  if (v54)
  {
    CFRetain(v54);
    CFTypeRef v114 = v55;
    CFTypeID v56 = CFGetTypeID(v55);
    CFTypeID v57 = v55;
    if (v56 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeID v57 = 0;
    CFTypeRef v114 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v114);
  if (v57) {
    CFRelease(v57);
  }

  v153[0] = @"FilterCharacterCount";
  v152[0] = @"FilterName";
  v152[1] = @"Parameters";
  v150[0] = @"Character";
  v150[1] = @"CharacterCountRelation";
  v151[0] = @"&";
  v151[1] = @"GreaterThanOrEqualToInputCount";
  CFTypeID v58 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v151 forKeys:v150 count:2];
  v153[1] = v58;
  id v59 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v153 forKeys:v152 count:2];
  id v60 = v59;
  if (v59)
  {
    CFRetain(v59);
    CFTypeRef v113 = v60;
    CFTypeID v61 = CFGetTypeID(v60);
    CFTypeID v62 = v60;
    if (v61 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeID v62 = 0;
    CFTypeRef v113 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v113);
  if (v62) {
    CFRelease(v62);
  }

  v148[1] = @"Parameters";
  v149[0] = @"FilterNotSuggestibleForInput";
  v146[0] = @"WordEquivalenceType";
  v146[1] = @"ApplyFilterCondition";
  v147[0] = @"SortkeyEquivalence";
  v147[1] = @"ApplyAlways";
  v146[2] = @"ShouldRemoveVulgar";
  v147[2] = @"RemoveVulgar";
  v148[0] = @"FilterName";
  CFTypeID v63 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v147 forKeys:v146 count:3];
  v149[1] = v63;
  id v64 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v149 forKeys:v148 count:2];
  id v65 = v64;
  if (v64)
  {
    CFRetain(v64);
    CFTypeRef v112 = v65;
    CFTypeID v66 = CFGetTypeID(v65);
    CFTypeRef v67 = v65;
    if (v66 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeRef v67 = 0;
    CFTypeRef v112 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v112);
  if (v67) {
    CFRelease(v67);
  }
  uint64_t v105 = v6;

  v144[0] = @"FilterName";
  v144[1] = @"Parameters";
  v145[0] = @"BoostMinimumVariation";
  id v142 = @"MinCandidateDominanceRatio";
  LODWORD(v68) = v4;
  CFTypeRef v69 = [NSNumber numberWithFloat:v68];
  id v143 = v69;
  CFTypeRef v70 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v143 forKeys:&v142 count:1];
  v145[1] = v70;
  id v71 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v145 forKeys:v144 count:2];
  CFTypeRef v72 = v71;
  if (v71)
  {
    CFRetain(v71);
    CFTypeRef v111 = v72;
    CFTypeID v73 = CFGetTypeID(v72);
    CFTypeRef v74 = v72;
    if (v73 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeRef v74 = 0;
    CFTypeRef v111 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v111);
  if (v74) {
    CFRelease(v74);
  }

  v140 = @"FilterName";
  CFTypeID v141 = @"FilterInvalidTextReplacement";
  id v75 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v141 forKeys:&v140 count:1];
  CFTypeRef v76 = v75;
  if (v75)
  {
    CFRetain(v75);
    CFTypeRef v110 = v76;
    CFTypeID v77 = CFGetTypeID(v76);
    id v78 = v76;
    if (v77 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    id v78 = 0;
    CFTypeRef v110 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v110);
  if (v78) {
    CFRelease(v78);
  }

  v138[1] = @"Parameters";
  v139[0] = @"FilterNotSuggestibleForInput";
  v136[0] = @"WordEquivalenceType";
  v136[1] = @"ApplyFilterCondition";
  v137[0] = @"SurfaceFormEquivalence";
  v137[1] = @"ApplyAlways";
  v136[2] = @"ShouldRemoveVulgar";
  v137[2] = @"RemoveVulgar";
  v138[0] = @"FilterName";
  unsigned int v79 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v137 forKeys:v136 count:3];
  v139[1] = v79;
  id v80 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v139 forKeys:v138 count:2];
  long long v81 = v80;
  if (v80)
  {
    CFRetain(v80);
    CFTypeRef v109 = v81;
    CFTypeID v82 = CFGetTypeID(v81);
    CFTypeID v83 = v81;
    if (v82 != CFDictionaryGetTypeID()) {
      goto LABEL_125;
    }
  }
  else
  {
    CFTypeID v83 = 0;
    CFTypeRef v109 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v109);
  if (v83) {
    CFRelease(v83);
  }

  v134[1] = @"Parameters";
  v135[0] = @"FilterDifferentLanguageThanContext";
  v134[0] = @"FilterName";
  uint64_t v132 = @"MinConfidenceToEstablishLanguage";
  LODWORD(v84) = v7;
  id v85 = [NSNumber numberWithFloat:v84];
  CFTypeID v133 = v85;
  id v86 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v133 forKeys:&v132 count:1];
  v135[1] = v86;
  id v87 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v135 forKeys:v134 count:2];
  CFTypeID v88 = v87;
  if (v87)
  {
    CFRetain(v87);
    CFTypeRef v108 = v88;
    CFTypeID v89 = CFGetTypeID(v88);
    id v90 = v88;
    BOOL v91 = v89 == CFDictionaryGetTypeID();
    uint64_t v92 = a1;
    if (!v91) {
      goto LABEL_125;
    }
  }
  else
  {
    id v90 = 0;
    CFTypeRef v108 = 0;
    uint64_t v92 = a1;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v108);
  if (v90) {
    CFRelease(v90);
  }

  if (*(unsigned char *)(v92 + 186))
  {
    v130[1] = @"Parameters";
    v131[0] = @"FilterInputPrefixMismatch";
    v130[0] = @"FilterName";
    v128[0] = @"MinPrefixMatchLen";
    id v93 = [NSNumber numberWithInt:v5];
    v128[1] = @"MinTargetCandidates";
    v129[0] = v93;
    id v94 = [NSNumber numberWithUnsignedLong:v105];
    v129[1] = v94;
    CFTypeID v95 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v129 forKeys:v128 count:2];
    v131[1] = v95;
    id v96 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v131 forKeys:v130 count:2];
    id v97 = v96;
    if (v96)
    {
      CFRetain(v96);
      CFTypeRef v107 = v97;
      CFTypeID v98 = CFGetTypeID(v97);
      CFTypeID v99 = v97;
      if (v98 != CFDictionaryGetTypeID())
      {
LABEL_125:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      CFTypeID v99 = 0;
      CFTypeRef v107 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v107);
    if (v99) {
      CFRelease(v99);
    }
  }
  if (*(unsigned char *)(v92 + 187))
  {
    CFTypeID v126 = @"FilterName";
    CFTypeID v127 = @"BoostCaseVariantsOfTopCandidate";
    id v100 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v127 forKeys:&v126 count:1];
    double v101 = v100;
    if (v100)
    {
      CFRetain(v100);
      CFTypeRef v106 = v101;
      CFTypeID v102 = CFGetTypeID(v101);
      double v103 = v101;
      if (v102 != CFDictionaryGetTypeID()) {
        goto LABEL_125;
      }
    }
    else
    {
      double v103 = 0;
      CFTypeRef v106 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v106);
    if (v103) {
      CFRelease(v103);
    }
  }
}

void KB::CandidateFilterFactory::create_standard_prediction_completion_or_replacement_filter_defintion(uint64_t a1, uint64_t a2)
{
  v163[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 44);
  unsigned int v5 = *(_DWORD *)(a1 + 64);
  uint64_t v6 = *(void *)(a1 + 72);
  int v7 = *(_DWORD *)(a1 + 92);
  CFTypeRef v162 = @"FilterName";
  v163[0] = @"FilterZeroProbability";
  id v8 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v163 forKeys:&v162 count:1];
  CFTypeID v9 = v8;
  if (v8)
  {
    CFRetain(v8);
    CFTypeRef v115 = v9;
    CFTypeID v10 = CFGetTypeID(v9);
    id v11 = v9;
    if (v10 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    id v11 = 0;
    CFTypeRef v115 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v115);
  if (v11) {
    CFRelease(v11);
  }

  CFTypeRef v160 = @"FilterName";
  CFTypeRef v161 = @"FilterAppNames";
  id v12 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v161 forKeys:&v160 count:1];
  CFTypeID v13 = v12;
  if (v12)
  {
    CFRetain(v12);
    CFTypeRef v114 = v13;
    CFTypeID v14 = CFGetTypeID(v13);
    id v15 = v13;
    if (v14 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    id v15 = 0;
    CFTypeRef v114 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v114);
  if (v15) {
    CFRelease(v15);
  }

  CFTypeRef v158 = @"FilterName";
  CFTypeRef v159 = @"FilterIncomplete";
  id v16 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v159 forKeys:&v158 count:1];
  CFTypeID v17 = v16;
  if (v16)
  {
    CFRetain(v16);
    CFTypeRef v113 = v17;
    CFTypeID v18 = CFGetTypeID(v17);
    id v19 = v17;
    if (v18 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    id v19 = 0;
    CFTypeRef v113 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v113);
  if (v19) {
    CFRelease(v19);
  }

  if (*(unsigned char *)(a1 + 185))
  {
    unsigned int v156 = @"FilterName";
    CFTypeRef v157 = @"FilterWithoutSupplementalWords";
    id v20 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v157 forKeys:&v156 count:1];
    CFTypeID v21 = v20;
    if (v20)
    {
      CFRetain(v20);
      CFTypeRef v112 = v21;
      CFTypeID v22 = CFGetTypeID(v21);
      id v23 = v21;
      if (v22 != CFDictionaryGetTypeID()) {
        goto LABEL_113;
      }
    }
    else
    {
      id v23 = 0;
      CFTypeRef v112 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v112);
    if (v23) {
      CFRelease(v23);
    }

    int v154 = @"FilterName";
    unsigned int v155 = @"FilterPartOfHyphenatedWord";
    id v24 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v155 forKeys:&v154 count:1];
    CFTypeID v25 = v24;
    if (v24)
    {
      CFRetain(v24);
      CFTypeRef v111 = v25;
      CFTypeID v26 = CFGetTypeID(v25);
      id v27 = v25;
      if (v26 != CFDictionaryGetTypeID()) {
        goto LABEL_113;
      }
    }
    else
    {
      id v27 = 0;
      CFTypeRef v111 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v111);
    if (v27) {
      CFRelease(v27);
    }
  }
  CFTypeID v152 = @"FilterName";
  CFTypeID v153 = @"FilterControlCharacters";
  id v28 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v153 forKeys:&v152 count:1];
  BOOL v29 = v28;
  if (v28)
  {
    CFRetain(v28);
    CFTypeRef v110 = v29;
    CFTypeID v30 = CFGetTypeID(v29);
    CFTypeID v31 = v29;
    if (v30 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeID v31 = 0;
    CFTypeRef v110 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v110);
  if (v31) {
    CFRelease(v31);
  }

  v150[0] = @"FilterName";
  v150[1] = @"Parameters";
  v151[0] = @"FilterNotSuggestibleForInput";
  v148[0] = @"WordEquivalenceType";
  v148[1] = @"ApplyFilterCondition";
  v149[0] = @"SortkeyEquivalence";
  v149[1] = @"ApplyIfCandidatesContainInputMatch";
  void v148[2] = @"ShouldRemoveVulgar";
  void v149[2] = @"RemoveVulgar";
  CFTypeID v32 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v149 forKeys:v148 count:3];
  v151[1] = v32;
  id v33 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v151 forKeys:v150 count:2];
  id v34 = v33;
  if (v33)
  {
    CFRetain(v33);
    CFTypeRef v109 = v34;
    CFTypeID v35 = CFGetTypeID(v34);
    double v36 = v34;
    if (v35 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    double v36 = 0;
    CFTypeRef v109 = 0;
  }
  uint64_t v97 = v6;

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v109);
  if (v36) {
    CFRelease(v36);
  }
  uint64_t v37 = a1;

  v147[0] = @"BoostMinimumVariation";
  v146[0] = @"FilterName";
  v146[1] = @"Parameters";
  CFTypeID v144 = @"MinCandidateDominanceRatio";
  LODWORD(v38) = v4;
  CFTypeID v39 = [NSNumber numberWithFloat:v38];
  CFTypeID v145 = v39;
  id v40 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v145 forKeys:&v144 count:1];
  v147[1] = v40;
  id v41 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v147 forKeys:v146 count:2];
  CFTypeID v42 = v41;
  if (v41)
  {
    CFRetain(v41);
    CFTypeRef v108 = v42;
    CFTypeID v43 = CFGetTypeID(v42);
    CFTypeRef v44 = v42;
    if (v43 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeRef v44 = 0;
    CFTypeRef v108 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v108);
  if (v44) {
    CFRelease(v44);
  }

  int v45 = _os_feature_enabled_impl();
  BOOL v46 = (_BYTE)number_to_letter_correction_locally_enabled(void)::locally_enabled != 0;
  if (!HIBYTE(number_to_letter_correction_locally_enabled(void)::locally_enabled)) {
    BOOL v46 = v45;
  }
  if (v46)
  {
    id v142 = @"FilterName";
    id v143 = @"FilterNumberlikeTokenMismatch";
    id v47 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v143 forKeys:&v142 count:1];
    CFTypeID v48 = v47;
    if (v47)
    {
      CFRetain(v47);
      CFTypeRef v107 = v48;
      CFTypeID v49 = CFGetTypeID(v48);
      id v50 = v48;
      if (v49 != CFDictionaryGetTypeID()) {
        goto LABEL_113;
      }
    }
    else
    {
      id v50 = 0;
      CFTypeRef v107 = 0;
    }

    __int16 v53 = (CFTypeRef *)&v107;
  }
  else
  {
    v140 = @"FilterName";
    CFTypeID v141 = @"FilterNumberMismatch";
    id v51 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v141 forKeys:&v140 count:1];
    CFTypeID v48 = v51;
    if (v51)
    {
      CFRetain(v51);
      CFTypeRef v106 = v48;
      CFTypeID v52 = CFGetTypeID(v48);
      id v50 = v48;
      if (v52 != CFDictionaryGetTypeID()) {
        goto LABEL_113;
      }
    }
    else
    {
      id v50 = 0;
      CFTypeRef v106 = 0;
    }

    __int16 v53 = (CFTypeRef *)&v106;
  }
  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, v53);
  if (v50) {
    CFRelease(v50);
  }

  v138[1] = @"Parameters";
  v139[0] = @"FilterCharacterCount";
  v136[0] = @"Character";
  v136[1] = @"CharacterCountRelation";
  v137[0] = @"&";
  v137[1] = @"LessThanOrEqualToInputCount";
  v138[0] = @"FilterName";
  id v54 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v137 forKeys:v136 count:2];
  v139[1] = v54;
  id v55 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v139 forKeys:v138 count:2];
  CFTypeID v56 = v55;
  if (v55)
  {
    CFRetain(v55);
    CFTypeRef v105 = v56;
    CFTypeID v57 = CFGetTypeID(v56);
    CFTypeID v58 = v56;
    if (v57 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeID v58 = 0;
    CFTypeRef v105 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v105);
  if (v58) {
    CFRelease(v58);
  }

  v134 = @"FilterName";
  id v135 = @"FilterDoubleApostrophe";
  id v59 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v135 forKeys:&v134 count:1];
  id v60 = v59;
  if (v59)
  {
    CFRetain(v59);
    CFTypeRef v104 = v60;
    CFTypeID v61 = CFGetTypeID(v60);
    CFTypeID v62 = v60;
    if (v61 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeID v62 = 0;
    CFTypeRef v104 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v104);
  if (v62) {
    CFRelease(v62);
  }

  uint64_t v132 = @"FilterName";
  CFTypeID v133 = @"FilterWordEndingApostropheBetweenNonseparators";
  id v63 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v133 forKeys:&v132 count:1];
  id v64 = v63;
  if (v63)
  {
    CFRetain(v63);
    CFTypeRef v103 = v64;
    CFTypeID v65 = CFGetTypeID(v64);
    CFTypeID v66 = v64;
    if (v65 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeID v66 = 0;
    CFTypeRef v103 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v103);
  if (v66) {
    CFRelease(v66);
  }

  v130 = @"FilterName";
  double v131 = @"FilterInvalidTextReplacement";
  id v67 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v131 forKeys:&v130 count:1];
  double v68 = v67;
  if (v67)
  {
    CFRetain(v67);
    CFTypeRef v102 = v68;
    CFTypeID v69 = CFGetTypeID(v68);
    CFTypeRef v70 = v68;
    if (v69 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeRef v70 = 0;
    CFTypeRef v102 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v102);
  if (v70) {
    CFRelease(v70);
  }

  v128[1] = @"Parameters";
  v129[0] = @"FilterNotSuggestibleForInput";
  v126[0] = @"WordEquivalenceType";
  v126[1] = @"ApplyFilterCondition";
  v127[0] = @"SurfaceFormEquivalence";
  v127[1] = @"ApplyAlways";
  v126[2] = @"ShouldRemoveVulgar";
  v127[2] = @"RemoveVulgar";
  v128[0] = @"FilterName";
  id v71 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v127 forKeys:v126 count:3];
  v129[1] = v71;
  id v72 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v129 forKeys:v128 count:2];
  CFTypeID v73 = v72;
  if (v72)
  {
    CFRetain(v72);
    CFTypeRef v101 = v73;
    CFTypeID v74 = CFGetTypeID(v73);
    id v75 = v73;
    if (v74 != CFDictionaryGetTypeID()) {
      goto LABEL_113;
    }
  }
  else
  {
    id v75 = 0;
    CFTypeRef v101 = 0;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v101);
  if (v75) {
    CFRelease(v75);
  }

  v124[1] = @"Parameters";
  v125[0] = @"FilterDifferentLanguageThanContext";
  v124[0] = @"FilterName";
  CFTypeRef v122 = @"MinConfidenceToEstablishLanguage";
  LODWORD(v76) = v7;
  CFTypeID v77 = [NSNumber numberWithFloat:v76];
  CFTypeRef v123 = v77;
  id v78 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v123 forKeys:&v122 count:1];
  v125[1] = v78;
  id v79 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v125 forKeys:v124 count:2];
  id v80 = v79;
  if (v79)
  {
    CFRetain(v79);
    CFTypeRef v100 = v80;
    CFTypeID v81 = CFGetTypeID(v80);
    CFTypeID v82 = v80;
    BOOL v83 = v81 == CFDictionaryGetTypeID();
    uint64_t v84 = v37;
    if (!v83) {
      goto LABEL_113;
    }
  }
  else
  {
    CFTypeID v82 = 0;
    CFTypeRef v100 = 0;
    uint64_t v84 = v37;
  }

  KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v100);
  if (v82) {
    CFRelease(v82);
  }

  if (*(unsigned char *)(v84 + 186))
  {
    v120[1] = @"Parameters";
    v121[0] = @"FilterInputPrefixMismatch";
    v120[0] = @"FilterName";
    v118[0] = @"MinPrefixMatchLen";
    id v85 = [NSNumber numberWithInt:v5];
    v118[1] = @"MinTargetCandidates";
    v119[0] = v85;
    id v86 = [NSNumber numberWithUnsignedLong:v97];
    v119[1] = v86;
    id v87 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v119 forKeys:v118 count:2];
    v121[1] = v87;
    id v88 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v121 forKeys:v120 count:2];
    CFTypeID v89 = v88;
    if (v88)
    {
      CFRetain(v88);
      CFTypeRef v99 = v89;
      CFTypeID v90 = CFGetTypeID(v89);
      BOOL v91 = v89;
      if (v90 != CFDictionaryGetTypeID())
      {
LABEL_113:
        exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
        applesauce::CF::construct_error(exception);
      }
    }
    else
    {
      BOOL v91 = 0;
      CFTypeRef v99 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v99);
    if (v91) {
      CFRelease(v91);
    }
  }
  if (*(unsigned char *)(v84 + 187))
  {
    CFTypeRef v116 = @"FilterName";
    CFTypeRef v117 = @"BoostCaseVariantsOfTopCandidate";
    id v92 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:&v117 forKeys:&v116 count:1];
    id v93 = v92;
    if (v92)
    {
      CFRetain(v92);
      CFTypeRef v98 = v93;
      CFTypeID v94 = CFGetTypeID(v93);
      CFTypeID v95 = v93;
      if (v94 != CFDictionaryGetTypeID()) {
        goto LABEL_113;
      }
    }
    else
    {
      CFTypeID v95 = 0;
      CFTypeRef v98 = 0;
    }

    KB::CandidateFilterFactory::FilterStackDefinition::emplace_filter_definition(a2, &v98);
    if (v95) {
      CFRelease(v95);
    }
  }
}

void KB::CandidateFilterFactory::create_empty_filter(void *a1@<X8>)
{
  uint64_t v3 = operator new(0x38uLL);
  v3[1] = 0;
  v3[2] = 0;
  *uint64_t v3 = &unk_1F3F72AB8;
  void v3[3] = &unk_1F3F78FE0;
  void v3[4] = 0;
  void v3[5] = 0;
  void v3[6] = 0;
  memset(v4, 0, sizeof(v4));
  *a1 = v3 + 3;
  a1[1] = v3;
  unsigned int v5 = (void **)v4;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v5);
}

void KB::CandidateFilterFactory::create_standard_filter(KB::CandidateFilterFactory *this@<X0>, void *a2@<X8>)
{
  memset(v8, 0, sizeof(v8));
  KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition((uint64_t)v5, v8);
  KB::CandidateFilterFactory::create_standard_filter_definition((uint64_t)this, (uint64_t)v5);
  KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters((KB::CandidateFilterFactory::FilterStackDefinition *)v5, this, a2);
  std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table((uint64_t)&v7);
  CFTypeID v9 = (void ***)&v6;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)&v9);
  CFTypeID v9 = v5;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)&v9);
  v5[0] = (void **)v8;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](v5);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,applesauce::CF::DictionaryRef>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    int v4 = (char *)v1[1];
    unsigned int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v7 = (const void *)*((void *)v4 - 1);
        v4 -= 8;
        uint64_t v6 = v7;
        if (v7) {
          CFRelease(v6);
        }
      }
      while (v4 != v2);
      unsigned int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::CandidateFilterFactory::select_filter_specification_for_configuration(CFDictionaryRef *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  if (!*a1)
  {
    CFTypeID v9 = filter_factory_log();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_1E3F0E000, v9, OS_LOG_TYPE_INFO, "Specification root object is null or not a dictionary.", buf, 2u);
    }

    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    return;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&__p, *a1, @"PayloadType");
  std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  if (size != 37
    || ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (uint64_t v7 = &__p)
      : (uint64_t v7 = (std::string *)__p.__r_.__value_.__r.__words[0]),
        memcmp(v7, "TextInputCandidateFilterSpecification", 0x25uLL)))
  {
    id v8 = filter_factory_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      std::__split_buffer<std::string>::pointer p_p = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = p_p;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "TextInputCandidateFilterSpecification";
      _os_log_error_impl(&dword_1E3F0E000, v8, OS_LOG_TYPE_ERROR, "Payload type '%s' is not '%s'", buf, 0x16u);
    }

    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    goto LABEL_11;
  }
  if (!*a1) {
    goto LABEL_241;
  }
  applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v101, *a1, @"PayloadVersion");
  std::string::size_type v10 = HIBYTE(v101.__r_.__value_.__r.__words[2]);
  if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v10 = v101.__r_.__value_.__l.__size_;
  }
  if (v10 != 1
    || ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
      ? (id v11 = &v101)
      : (id v11 = (std::string *)v101.__r_.__value_.__r.__words[0]),
        v11->__r_.__value_.__s.__data_[0] != 49))
  {
    CFTypeID v81 = filter_factory_log();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      id v86 = &v101;
      if ((v101.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        id v86 = (std::string *)v101.__r_.__value_.__r.__words[0];
      }
      id v87 = &__p;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        id v87 = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      *(_DWORD *)std::string buf = 136315394;
      *(void *)&uint8_t buf[4] = v86;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v87;
      BOOL v83 = "Unrecognized payload version '%s' for payload type '%s'.";
      uint64_t v84 = v81;
      uint32_t v85 = 22;
      goto LABEL_240;
    }
LABEL_225:

    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    goto LABEL_226;
  }
  CFDictionaryRef v12 = *a1;
  if (!*a1) {
    goto LABEL_241;
  }
  *(void *)std::string buf = 0;
  applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&theArray, v12, @"Payload", buf);
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  CFArrayRef v13 = theArray;
  if (!theArray)
  {
    CFTypeID v81 = filter_factory_log();
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)std::string buf = 0;
      BOOL v83 = "Specification is missing the payload";
      uint64_t v84 = v81;
      uint32_t v85 = 2;
LABEL_240:
      _os_log_error_impl(&dword_1E3F0E000, v84, OS_LOG_TYPE_ERROR, v83, buf, v85);
      goto LABEL_225;
    }
    goto LABEL_225;
  }
  unint64_t v14 = 0;
  id v15 = (unsigned int **)(a2 + 36);
  *(void *)a3 = 0;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  CFTypeID v89 = (KB *)(a2 + 2);
  CFTypeID v90 = (unsigned int **)(a2 + 36);
  BOOL v91 = a2;
  while (v14 < CFArrayGetCount(v13))
  {
    CFTypeRef v99 = 0;
    id v16 = filter_factory_log();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      uint64_t v17 = *a2;
      CFTypeID v18 = "UNKNOWN";
      if (v17 <= 6) {
        CFTypeID v18 = off_1E6E2C580[v17];
      }
      *(_DWORD *)std::string buf = 134218242;
      *(void *)&uint8_t buf[4] = v14;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v18;
      _os_log_impl(&dword_1E3F0E000, v16, OS_LOG_TYPE_INFO, "Try to match rule %ld for lookup type %s", buf, 0x16u);
    }

    *(void *)std::string buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef>(&v98, v13, v14, buf);
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    if (!v98)
    {
      CFTypeID v21 = filter_factory_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_error_impl(&dword_1E3F0E000, v21, OS_LOG_TYPE_ERROR, "Filter specification rule is not a dictionary.", buf, 2u);
      }
      goto LABEL_48;
    }
    *(void *)std::string buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&theDict, (CFDictionaryRef)v98, @"MatchCriteria", buf);
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    CFDictionaryRef v19 = theDict;
    if (!theDict)
    {
      CFTypeID v21 = filter_factory_log();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        KB::utf8_string(@"MatchCriteria", (uint64_t)buf);
        CFTypeID v26 = *(const char **)&buf[8];
        if (!*(void *)&buf[8]) {
          CFTypeID v26 = &buf[16];
        }
        id v27 = "";
        if (*(_WORD *)buf) {
          id v27 = v26;
        }
        LODWORD(v105.__r_.__value_.__l.__data_) = 136315138;
        *(std::string::size_type *)((char *)v105.__r_.__value_.__r.__words + 4) = (std::string::size_type)v27;
        _os_log_error_impl(&dword_1E3F0E000, v21, OS_LOG_TYPE_ERROR, "Filter specification rule is missing key '%s', or key value is not a dictionary.", (uint8_t *)&v105, 0xCu);
        if (*(void *)&buf[8] && buf[6] == 1) {
          free(*(void **)&buf[8]);
        }
      }
LABEL_48:

      CFTypeID v22 = 0;
      goto LABEL_211;
    }
    memset(&v96, 0, sizeof(v96));
    CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"LookupTypes");
    if (Value)
    {
      applesauce::CF::convert_as<std::vector<std::string>,0>((int64x2_t *)buf, Value);
      if (v108)
      {
        memset(&v105, 0, sizeof(v105));
        std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v105, *(long long **)buf, *(long long **)&buf[8], 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
        if (v108)
        {
          v104.__r_.__value_.__r.__words[0] = (std::string::size_type)buf;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v104);
        }
        goto LABEL_51;
      }
    }
    else
    {
      buf[0] = 0;
      char v108 = 0;
    }
    std::string v105 = v96;
    memset(&v96, 0, sizeof(v96));
LABEL_51:
    *(void *)std::string buf = &v96;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    if (v105.__r_.__value_.__r.__words[0] != v105.__r_.__value_.__l.__size_)
    {
      std::string::basic_string[abi:nn180100]<0>(buf, "*");
      std::string::size_type v23 = v105.__r_.__value_.__l.__size_;
      uint64_t v24 = std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v105.__r_.__value_.__l.__data_, v105.__r_.__value_.__l.__size_, (unsigned __int8 **)buf);
      if (v107 < 0) {
        operator delete(*(void **)buf);
      }
      if (v24 == v23)
      {
        switch(*a2)
        {
          case 0u:
            CFTypeID v25 = "Autocorrection";
            goto LABEL_69;
          case 1u:
            CFTypeID v25 = "Completions";
            goto LABEL_69;
          case 3u:
            CFTypeID v25 = "Predictions";
            goto LABEL_69;
          case 4u:
            CFTypeID v25 = "Replacement";
            goto LABEL_69;
          case 5u:
            CFTypeID v25 = "ContinuousPath";
            goto LABEL_69;
          case 6u:
            CFTypeID v25 = "ContinuousPathAlternates";
LABEL_69:
            std::string::basic_string[abi:nn180100]<0>(buf, v25);
            std::string::size_type v28 = v105.__r_.__value_.__l.__size_;
            uint64_t v29 = std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v105.__r_.__value_.__l.__data_, v105.__r_.__value_.__l.__size_, (unsigned __int8 **)buf);
            if (v107 < 0) {
              operator delete(*(void **)buf);
            }
            if (v29 != v28) {
              goto LABEL_72;
            }
            goto LABEL_147;
          default:
LABEL_147:
            *(void *)std::string buf = &v105;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
            CFTypeID v22 = 0;
            break;
        }
        goto LABEL_210;
      }
    }
LABEL_72:
    applesauce::CF::at_or<char const(&)[1],__CFString const* const&>(&v96, v19, @"FilterClass");
    std::string::size_type v30 = HIBYTE(v96.__r_.__value_.__r.__words[2]);
    if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v30 = v96.__r_.__value_.__l.__size_;
    }
    if (v30)
    {
      if (v30 != 1) {
        goto LABEL_79;
      }
      CFTypeID v31 = (std::string *)v96.__r_.__value_.__r.__words[0];
      if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        CFTypeID v31 = &v96;
      }
      if (v31->__r_.__value_.__s.__data_[0] != 42)
      {
LABEL_79:
        unsigned int v32 = a2[34];
        if (v32 == 1)
        {
          if (v30 != 25) {
            goto LABEL_100;
          }
          double v38 = (std::string *)v96.__r_.__value_.__r.__words[0];
          if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v38 = &v96;
          }
          std::string::size_type v39 = v38->__r_.__value_.__r.__words[0];
          std::string::size_type v40 = v38->__r_.__value_.__l.__size_;
          std::string::size_type v41 = v38->__r_.__value_.__r.__words[2];
          int v36 = v38[1].__r_.__value_.__s.__data_[0];
          BOOL v37 = v39 == 0x7375696E6F766146 && v40 == 0x6C617551646E6143 && v41 == 0x65746C6946797469;
        }
        else
        {
          if (v32 || v30 != 17) {
            goto LABEL_100;
          }
          id v33 = (std::string *)v96.__r_.__value_.__r.__words[0];
          if ((v96.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            id v33 = &v96;
          }
          std::string::size_type v34 = v33->__r_.__value_.__r.__words[0];
          std::string::size_type v35 = v33->__r_.__value_.__l.__size_;
          int v36 = v33->__r_.__value_.__s.__data_[16];
          BOOL v37 = v34 == 0x6C617551646E6143 && v35 == 0x65746C6946797469;
        }
        if (!v37 || v36 != 114)
        {
LABEL_100:
          CFTypeID v22 = 0;
          if ((*((unsigned char *)&v96.__r_.__value_.__s + 23) & 0x80) != 0) {
            goto LABEL_208;
          }
          goto LABEL_209;
        }
      }
    }
    *(void *)std::string buf = 0;
    applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(&v95, v19, @"Flags", buf);
    if (*(void *)buf) {
      CFRelease(*(CFTypeRef *)buf);
    }
    int v44 = KB::CandidateFilterFlags::candidate_filter_flag_type(v15);
    CFDictionaryRef v46 = (const __CFDictionary *)v95;
    if (!v95)
    {
      std::vector<KB::FilterFlag>::vector(buf, (uint64_t)v15);
      if (*(void *)buf == *(void *)&buf[8])
      {
        BOOL v58 = 1;
      }
      else
      {
        uint64_t v57 = *(void *)buf + 8;
        do
        {
          BOOL v58 = *(unsigned char *)(v57 - 4) == 0;
          if (*(unsigned char *)(v57 - 4)) {
            BOOL v59 = 1;
          }
          else {
            BOOL v59 = v57 == *(void *)&buf[8];
          }
          v57 += 8;
        }
        while (!v59);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (v58) {
        goto LABEL_152;
      }
LABEL_138:
      CFTypeID v22 = 0;
      a2 = v91;
      goto LABEL_205;
    }
    uint64_t v47 = *((void *)a2 + 18);
    uint64_t v48 = *((void *)a2 + 19);
    if (v47 == v48) {
      goto LABEL_152;
    }
    int v49 = v44;
    char v50 = 1;
    do
    {
      if (*(_DWORD *)v47 == 1)
      {
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(buf, v46, @"PostLMProcessing", &v104);
        CFDictionaryRef v51 = *(const __CFDictionary **)buf;
        if (v104.__r_.__value_.__r.__words[0]) {
          CFRelease(v104.__r_.__value_.__l.__data_);
        }
        if (v51)
        {
          unsigned int v54 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v51);
          if (v54 <= 0x100) {
            LOBYTE(v54) = 0;
          }
          int v55 = v54 != 0;
          if ((v50 & 1) == 0)
          {
LABEL_121:
            char v50 = 0;
            if (v51) {
              goto LABEL_125;
            }
            goto LABEL_126;
          }
        }
        else
        {
          int v55 = 0;
          if ((v50 & 1) == 0) {
            goto LABEL_121;
          }
        }
        if (v49 == 2) {
          char v56 = v55;
        }
        else {
          char v56 = 0;
        }
        if (*(unsigned __int8 *)(v47 + 4) == v55) {
          char v50 = 1;
        }
        else {
          char v50 = v56;
        }
        if (v51) {
          goto LABEL_125;
        }
      }
      else if (!*(_DWORD *)v47)
      {
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::DictionaryRef,__CFString const*>(buf, v46, @"PreLMProcessing", &v104);
        CFDictionaryRef v51 = *(const __CFDictionary **)buf;
        if (v104.__r_.__value_.__r.__words[0]) {
          CFRelease(v104.__r_.__value_.__l.__data_);
        }
        if (v51)
        {
          unsigned int v52 = (unsigned __int16)applesauce::CF::details::find_at_key_or_optional<BOOL,__CFString const* const&>(v51);
          if (v52 <= 0x100) {
            LOBYTE(v52) = 0;
          }
          int v53 = v52 != 0;
        }
        else
        {
          int v53 = 0;
        }
        v50 &= *(unsigned __int8 *)(v47 + 4) == v53;
        if (v51) {
LABEL_125:
        }
          CFRelease(v51);
      }
LABEL_126:
      v47 += 8;
    }
    while (v47 != v48);
    if ((v50 & 1) == 0) {
      goto LABEL_138;
    }
LABEL_152:
    id v60 = KB::ns_string(v89, v45);
    CFStringRef Language = (const __CFString *)TIInputModeGetLanguage();
    KB::std_string(Language, buf);
    v104.__r_.__value_.__r.__words[0] = 0;
    applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, @"Languages", &v104);
    if (v104.__r_.__value_.__r.__words[0]) {
      CFRelease(v104.__r_.__value_.__l.__data_);
    }
    CFTypeRef v62 = cf;
    a2 = v91;
    if (cf)
    {
      __n128 v92 = 0uLL;
      uint64_t v93 = 0;
      applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, (const __CFArray *)cf, &v92);
      CFTypeRef v103 = &v92;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
      std::string::size_type v63 = v104.__r_.__value_.__l.__size_;
      if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
        && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v63)
      {
        std::string::basic_string[abi:nn180100]<0>(&v92, "*");
        long long v65 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
        BOOL v64 = (void)v65
            + 24
            * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v65)/ 24) != *((void *)&v65 + 1);
        if (SHIBYTE(v93) < 0) {
          operator delete((void *)v92.n128_u64[0]);
        }
        v92.n128_u64[0] = (unint64_t)&v104;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
        a2 = v91;
      }
      else
      {
        v92.n128_u64[0] = (unint64_t)&v104;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
        BOOL v64 = 1;
      }
      CFRelease(v62);
    }
    else
    {
      BOOL v64 = 1;
    }
    if (v107 < 0) {
      operator delete(*(void **)buf);
    }
    if (v64)
    {
      CFStringRef Region = (const __CFString *)TIInputModeGetRegion();
      KB::std_string(Region, buf);
      v104.__r_.__value_.__r.__words[0] = 0;
      applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, @"Regions", &v104);
      if (v104.__r_.__value_.__r.__words[0]) {
        CFRelease(v104.__r_.__value_.__l.__data_);
      }
      CFTypeRef v67 = cf;
      if (cf)
      {
        __n128 v92 = 0uLL;
        uint64_t v93 = 0;
        applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, (const __CFArray *)cf, &v92);
        CFTypeRef v103 = &v92;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
        std::string::size_type v68 = v104.__r_.__value_.__l.__size_;
        if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
          && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v68)
        {
          std::string::basic_string[abi:nn180100]<0>(&v92, "*");
          long long v70 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
          BOOL v69 = (void)v70
              + 24
              * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v70)/ 24) != *((void *)&v70 + 1);
          if (SHIBYTE(v93) < 0) {
            operator delete((void *)v92.n128_u64[0]);
          }
          v92.n128_u64[0] = (unint64_t)&v104;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
          a2 = v91;
        }
        else
        {
          v92.n128_u64[0] = (unint64_t)&v104;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
          BOOL v69 = 1;
        }
        CFRelease(v67);
      }
      else
      {
        BOOL v69 = 1;
      }
      if (v107 < 0) {
        operator delete(*(void **)buf);
      }
      if (v69)
      {
        CFStringRef Variant = (const __CFString *)TIInputModeGetVariant();
        KB::std_string(Variant, buf);
        v104.__r_.__value_.__r.__words[0] = 0;
        applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(&cf, v19, @"Variants", &v104);
        if (v104.__r_.__value_.__r.__words[0]) {
          CFRelease(v104.__r_.__value_.__l.__data_);
        }
        if (cf)
        {
          id v72 = (const __CFArray **)applesauce::CF::ArrayRef::operator->(&cf);
          __n128 v92 = 0uLL;
          uint64_t v93 = 0;
          applesauce::CF::convert_or<std::vector<std::string>,0>(&v104, *v72, &v92);
          CFTypeRef v103 = &v92;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v103);
          std::string::size_type v73 = v104.__r_.__value_.__l.__size_;
          if (v104.__r_.__value_.__r.__words[0] != v104.__r_.__value_.__l.__size_
            && std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)buf) == v73)
          {
            std::string::basic_string[abi:nn180100]<0>(&v92, "*");
            long long v75 = *(_OWORD *)&v104.__r_.__value_.__l.__data_;
            BOOL v74 = (void)v75
                + 24
                * ((std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>((uint64_t)v104.__r_.__value_.__l.__data_, v104.__r_.__value_.__l.__size_, (unsigned __int8 **)&v92)- (uint64_t)v75)/ 24) != *((void *)&v75 + 1);
            if (SHIBYTE(v93) < 0) {
              operator delete((void *)v92.n128_u64[0]);
            }
            v92.n128_u64[0] = (unint64_t)&v104;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
            a2 = v91;
          }
          else
          {
            v92.n128_u64[0] = (unint64_t)&v104;
            std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v92);
            BOOL v74 = 1;
          }
          if (cf) {
            CFRelease(cf);
          }
        }
        else
        {
          BOOL v74 = 1;
        }
        if (v107 < 0) {
          operator delete(*(void **)buf);
        }
        if (v74)
        {
          double v76 = filter_factory_log();
          if (os_log_type_enabled(v76, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_1E3F0E000, v76, OS_LOG_TYPE_INFO, "Found matching rule!", buf, 2u);
          }

          CFTypeID v77 = (CFDictionaryRef *)applesauce::CF::ArrayRef::operator->(&v98);
          v104.__r_.__value_.__r.__words[0] = 0;
          applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(buf, *v77, @"FilterStack", &v104);
          CFTypeID v22 = *(const void **)buf;
          CFTypeRef v99 = *(CFTypeRef *)buf;
          if (v104.__r_.__value_.__r.__words[0]) {
            CFRelease(v104.__r_.__value_.__l.__data_);
          }
          if (v22)
          {
            std::vector<applesauce::CF::ArrayRef>::push_back[abi:nn180100]((char **)a3, &v99);
            goto LABEL_204;
          }
          id v78 = filter_factory_log();
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            KB::utf8_string(@"FilterStack", (uint64_t)buf);
            id v79 = *(const char **)&buf[8];
            if (!*(void *)&buf[8]) {
              id v79 = &buf[16];
            }
            id v80 = "";
            if (*(_WORD *)buf) {
              id v80 = v79;
            }
            LODWORD(v104.__r_.__value_.__l.__data_) = 136315138;
            *(std::string::size_type *)((char *)v104.__r_.__value_.__r.__words + 4) = (std::string::size_type)v80;
            _os_log_error_impl(&dword_1E3F0E000, v78, OS_LOG_TYPE_ERROR, "Filter specification rule is missing key '%s', or key value is not an array.", (uint8_t *)&v104, 0xCu);
            if (*(void *)&buf[8] && buf[6] == 1) {
              free(*(void **)&buf[8]);
            }
          }
        }
      }
    }
    CFTypeID v22 = 0;
LABEL_204:

LABEL_205:
    if (v46) {
      CFRelease(v46);
    }
    id v15 = v90;
    if ((*((unsigned char *)&v96.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_208:
    }
      operator delete(v96.__r_.__value_.__l.__data_);
LABEL_209:
    *(void *)std::string buf = &v105;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    if (v19) {
LABEL_210:
    }
      CFRelease(v19);
LABEL_211:
    if (v98) {
      CFRelease(v98);
    }
    if (v22)
    {
      CFRelease(v22);
      CFArrayRef v13 = theArray;
    }
    ++v14;
    if (!v13)
    {
LABEL_241:
      exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
      applesauce::CF::construct_error(exception);
    }
  }
  if (theArray) {
    CFRelease(theArray);
  }
LABEL_226:
  if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v101.__r_.__value_.__l.__data_);
  }
LABEL_11:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1E3FA7270()
{
}

void applesauce::CF::at_or<applesauce::CF::ArrayRef,__CFString const* const&>(void *a1, CFDictionaryRef theDict, void *key, void *a4)
{
  if (!theDict) {
    goto LABEL_9;
  }
  if (!key) {
    goto LABEL_9;
  }
  CFArrayRef Value = CFDictionaryGetValue(theDict, key);
  if (!Value) {
    goto LABEL_9;
  }
  uint64_t v7 = Value;
  CFRetain(Value);
  CFTypeID v8 = CFGetTypeID(v7);
  if (v8 != CFArrayGetTypeID())
  {
    CFRelease(v7);
LABEL_9:
    *a1 = *a4;
    *a4 = 0;
    return;
  }
  CFRetain(v7);
  *a1 = v7;

  CFRelease(v7);
}

uint64_t std::__find_impl[abi:nn180100]<std::string const*,std::string const*,std::string,std::__identity>(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    char v5 = *((unsigned char *)a3 + 23);
    if (v5 >= 0) {
      uint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v6 = a3[1];
    }
    if (v5 >= 0) {
      uint64_t v7 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v7 = *a3;
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0) {
        CFTypeID v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      }
      else {
        CFTypeID v9 = *(unsigned __int8 **)(v3 + 8);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v3, v7, *(void *)(v3 + 8))) {
            return v3;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 23)) {
            return v3;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10) {
              return v3;
            }
          }
        }
      }
      v3 += 24;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

void *std::vector<KB::FilterFlag>::vector(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int v4 = *(const void **)a2;
  uint64_t v3 = *(void *)(a2 + 8);
  int64_t v5 = v3 - *(void *)a2;
  if (v3 != *(void *)a2)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](a1, v5 >> 3);
    uint64_t v6 = (char *)a1[1];
    memmove(v6, v4, v5);
    a1[1] = &v6[v5];
  }
  return a1;
}

__n128 applesauce::CF::convert_or<std::vector<std::string>,0>(std::string *a1, const __CFArray *a2, __n128 *a3)
{
  applesauce::CF::convert_as<std::vector<std::string>,0>(&v6, a2);
  if (v7)
  {
    a1->__r_.__value_.__r.__words[0] = 0;
    a1->__r_.__value_.__l.__size_ = 0;
    a1->__r_.__value_.__r.__words[2] = 0;
    std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(a1, (long long *)v6.i64[0], (long long *)v6.i64[1], 0xAAAAAAAAAAAAAAABLL * ((v6.i64[1] - v6.i64[0]) >> 3));
    uint64_t v8 = &v6;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v8);
  }
  else
  {
    __n128 result = *a3;
    *(__n128 *)&a1->__r_.__value_.__l.__data_ = *a3;
    a1->__r_.__value_.__r.__words[2] = a3[1].n128_u64[0];
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    a3->n128_u64[0] = 0;
  }
  return result;
}

void *applesauce::CF::ArrayRef::operator->(void *result)
{
  if (!*result)
  {
    exception = (applesauce::CF *)__cxa_allocate_exception(0x10uLL);
    applesauce::CF::construct_error(exception);
  }
  return result;
}

void sub_1E3FA7540()
{
}

void std::vector<applesauce::CF::ArrayRef>::push_back[abi:nn180100](char **a1, CFTypeRef *a2)
{
  int64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v8 = (v5 - *a1) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
      abort();
    }
    uint64_t v9 = v4 - (void)*a1;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    if (v11)
    {
      CFDictionaryRef v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
      uint64_t v14 = v13;
    }
    else
    {
      CFDictionaryRef v12 = 0;
      uint64_t v14 = 0;
    }
    id v15 = &v12[8 * v8];
    CFTypeRef v16 = *a2;
    if (v16) {
      CFRetain(v16);
    }
    uint64_t v17 = &v12[8 * v14];
    *(void *)id v15 = v16;
    char v7 = v15 + 8;
    CFDictionaryRef v19 = *a1;
    CFTypeID v18 = a1[1];
    if (v18 == *a1)
    {
      int64x2_t v21 = vdupq_n_s64((unint64_t)v18);
    }
    else
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v15 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v20;
        v15 -= 8;
        *(void *)CFTypeID v18 = 0;
      }
      while (v18 != v19);
      int64x2_t v21 = *(int64x2_t *)a1;
    }
    *a1 = v15;
    a1[1] = v7;
    a1[2] = v17;
    std::string::size_type v23 = (char *)v21.i64[1];
    CFTypeID v22 = (char *)v21.i64[0];
    while (v23 != v22)
    {
      CFTypeID v25 = (const void *)*((void *)v23 - 1);
      v23 -= 8;
      uint64_t v24 = v25;
      if (v25) {
        CFRelease(v24);
      }
    }
    if (v22) {
      operator delete(v22);
    }
  }
  else
  {
    CFTypeRef v6 = *a2;
    if (*a2) {
      CFRetain(*a2);
    }
    *(void *)int64_t v5 = v6;
    char v7 = v5 + 8;
  }
  a1[1] = v7;
}

void applesauce::CF::convert_as<std::vector<std::string>,0>(int64x2_t *a1, const __CFArray *a2)
{
  if (a2 && (CFTypeID TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(a2)))
  {
    CFIndex Count = CFArrayGetCount(a2);
    int v6 = Count;
    int64x2_t v35 = 0uLL;
    int v36 = 0;
    if (Count << 32)
    {
      if (Count << 32 < 0) {
LABEL_39:
      }
        abort();
      v37.__end_cap_.__value_ = (std::allocator<std::string> *)&v36;
      char v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>((int)Count);
      uint64_t v9 = v35.i64[1];
      uint64_t v10 = v35.i64[0];
      if (v35.i64[1] == v35.i64[0])
      {
        int64x2_t v13 = vdupq_n_s64(v35.u64[1]);
        unint64_t v11 = v7;
      }
      else
      {
        unint64_t v11 = v7;
        do
        {
          long long v12 = *(_OWORD *)(v9 - 24);
          *((void *)v11 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = *(void *)(v9 - 8);
          *(_OWORD *)(v11 - 24) = v12;
          v11 -= 24;
          *(void *)(v9 - 16) = 0;
          *(void *)(v9 - 8) = 0;
          *(void *)(v9 - 24) = 0;
          v9 -= 24;
        }
        while (v9 != v10);
        int64x2_t v13 = v35;
      }
      v35.i64[0] = (uint64_t)v11;
      v35.i64[1] = (uint64_t)v7;
      *(int64x2_t *)&v37.__begin_ = v13;
      uint64_t v14 = v36;
      int v36 = (std::string *)&v7[24 * v8];
      v37.__end_cap_.__value_ = v14;
      v37.__first_ = (std::__split_buffer<std::string>::pointer)v13.i64[0];
      std::__split_buffer<std::string>::~__split_buffer(&v37);
    }
    if (v6 < 1)
    {
LABEL_35:
      *a1 = v35;
      a1[1].i64[0] = (uint64_t)v36;
      int v36 = 0;
      int64x2_t v35 = 0uLL;
      a1[1].i8[8] = 1;
    }
    else
    {
      CFIndex v15 = 0;
      while (1)
      {
        ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex(a2, v15);
        applesauce::CF::convert_as<std::string,0>((uint64_t)__p, ValueAtIndex);
        int v17 = v34;
        if (!v34) {
          break;
        }
        uint64_t v18 = v35.i64[1];
        if (v35.i64[1] >= (unint64_t)v36)
        {
          unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v35.i64[1] - v35.i64[0]) >> 3);
          unint64_t v20 = v19 + 1;
          if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
            goto LABEL_39;
          }
          if (0x5555555555555556 * (((uint64_t)v36 - v35.i64[0]) >> 3) > v20) {
            unint64_t v20 = 0x5555555555555556 * (((uint64_t)v36 - v35.i64[0]) >> 3);
          }
          if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v36 - v35.i64[0]) >> 3) >= 0x555555555555555) {
            unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v21 = v20;
          }
          v37.__end_cap_.__value_ = (std::allocator<std::string> *)&v36;
          if (v21) {
            unint64_t v21 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v21);
          }
          else {
            uint64_t v22 = 0;
          }
          unint64_t v23 = v21 + 24 * v19;
          *(void *)(v23 + 16) = v33;
          *(_OWORD *)unint64_t v23 = *(_OWORD *)__p;
          __p[1] = 0;
          uint64_t v33 = 0;
          __p[0] = 0;
          uint64_t v24 = v35.i64[1];
          uint64_t v25 = v35.i64[0];
          if (v35.i64[1] == v35.i64[0])
          {
            char v29 = 0;
            int64x2_t v28 = vdupq_n_s64(v35.u64[1]);
            unint64_t v26 = v23;
          }
          else
          {
            unint64_t v26 = v21 + 24 * v19;
            do
            {
              long long v27 = *(_OWORD *)(v24 - 24);
              *(void *)(v26 - 8) = *(void *)(v24 - 8);
              *(_OWORD *)(v26 - 24) = v27;
              v26 -= 24;
              *(void *)(v24 - 16) = 0;
              *(void *)(v24 - 8) = 0;
              *(void *)(v24 - 24) = 0;
              v24 -= 24;
            }
            while (v24 != v25);
            int64x2_t v28 = v35;
            int v17 = v34;
            char v29 = HIBYTE(v33);
          }
          unint64_t v30 = v23 + 24;
          v35.i64[0] = v26;
          v35.i64[1] = v23 + 24;
          *(int64x2_t *)&v37.__begin_ = v28;
          CFTypeID v31 = v36;
          int v36 = (std::string *)(v21 + 24 * v22);
          v37.__end_cap_.__value_ = v31;
          v37.__first_ = (std::__split_buffer<std::string>::pointer)v28.i64[0];
          std::__split_buffer<std::string>::~__split_buffer(&v37);
          v35.i64[1] = v30;
          if (v17)
          {
            if (v29 < 0) {
              operator delete(__p[0]);
            }
          }
        }
        else
        {
          *(_OWORD *)v35.i64[1] = *(_OWORD *)__p;
          *(void *)(v18 + 16) = v33;
          __p[1] = 0;
          uint64_t v33 = 0;
          __p[0] = 0;
          v35.i64[1] = v18 + 24;
        }
        if (++v15 == v6) {
          goto LABEL_35;
        }
      }
      a1->i8[0] = 0;
      a1[1].i8[8] = 0;
    }
    v37.__first_ = (std::__split_buffer<std::string>::pointer)&v35;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v37);
  }
  else
  {
    a1->i8[0] = 0;
    a1[1].i8[8] = 0;
  }
}

char *std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    abort();
  }
  __n128 result = (char *)operator new(8 * a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * a2];
  return result;
}

void KB::CandidateFilterFactory::create_filter_stack_from_specification(uint64_t *a1@<X0>, const KB::CandidateFilterConfiguration *a2@<X1>, void *a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  KB::CandidateFilterFactory::FilterStackDefinition::FilterStackDefinition((uint64_t)v7, a1);
  KB::CandidateFilterFactory::create_standard_filter_definition((uint64_t)a2, (uint64_t)v7);
  KB::CandidateFilterFactory::FilterStackDefinition::convert_filter_stack_definition_to_filters((KB::CandidateFilterFactory::FilterStackDefinition *)v7, a2, a3);
  int64_t v5 = filter_factory_log();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    if (*a3) {
      int v6 = "yes";
    }
    else {
      int v6 = "no";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl(&dword_1E3F0E000, v5, OS_LOG_TYPE_INFO, "Done creating filter stack (success=%s)", buf, 0xCu);
  }

  std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::~__hash_table((uint64_t)&v9);
  *(void *)std::string buf = &v8;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(void *)std::string buf = v7;
  std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

uint64_t KB::LanguageModelContainer::do_store(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 592))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::updateAdditionalLexicons(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 576))(v3);
  }
  return this;
}

void KB::LanguageModelContainer::engine_string_to_surface_form(KB::LanguageModelContainer *this@<X0>, CFTypeRef cf@<X1>, void *a3@<X8>)
{
  uint64_t v5 = (uint64_t *)*((void *)this + 3);
  if (v5 == *((uint64_t **)this + 4))
  {
    char v7 = 0;
  }
  else
  {
    uint64_t v6 = *v5;
    char v7 = (std::__shared_weak_count *)v5[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v6)
    {
      (*(void (**)(uint64_t, CFTypeRef))(*(void *)v6 + 568))(v6, cf);
      goto LABEL_9;
    }
  }
  *a3 = cf;
  if (cf)
  {
    CFRetain(cf);
    *a3 = cf;
  }
LABEL_9:
  if (v7)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
}

uint64_t KB::LanguageModelContainer::set_string_converter(uint64_t a1, void *a2)
{
  id v3 = a2;
  unint64_t v4 = *(uint64_t **)(a1 + 24);
  if (v4 != *(uint64_t **)(a1 + 32))
  {
    uint64_t v5 = *v4;
    uint64_t v6 = (std::__shared_weak_count *)v4[1];
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v5) {
      (*(void (**)(uint64_t, id))(*(void *)v5 + 560))(v5, v3);
    }
    if (v6) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v6);
    }
  }

  return MEMORY[0x1F41817F8]();
}

uint64_t KB::LanguageModelContainer::tokenize_text(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(uint64_t **)(a1 + 24);
  if (v6 != *(uint64_t **)(a1 + 32))
  {
    uint64_t v7 = *v6;
    uint64_t v8 = (std::__shared_weak_count *)v6[1];
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (v7) {
      (*(void (**)(uint64_t, uint64_t, id))(*(void *)v7 + 552))(v7, a2, v5);
    }
    if (v8) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v8);
    }
  }

  return MEMORY[0x1F4181820]();
}

void KB::LanguageModelContainer::register_inline_completion_acceptance_rejection(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 24);
  if (v1 == *(uint64_t **)(a1 + 32))
  {
    uint64_t v2 = 0;
    id v3 = 0;
  }
  else
  {
    uint64_t v2 = *v1;
    id v3 = (std::__shared_weak_count *)v1[1];
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 544))(v2);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void KB::LanguageModelContainer::inline_completions_with_stems(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, unsigned char *a6@<X8>)
{
  v24[4] = *MEMORY[0x1E4F143B8];
  float v20 = 0.0;
  int v12 = (*(uint64_t (**)(void *, uint64_t, float *))(*a1 + 448))(a1, a3, &v20);
  int64x2_t v13 = (KB::LanguageModelLexiconGroup *)a1[3];
  uint64_t v14 = (KB::LanguageModelLexiconGroup *)a1[4];
  while (v13 != v14)
  {
    if ((*(unsigned int (**)(void))(**(void **)v13 + 160))()
      && KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v13, v12))
    {
      uint64_t v16 = *(void *)v13;
      std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v24, a5);
      (*(void (**)(uint64_t, void *, uint64_t, uint64_t, void *))(*(void *)v16 + 536))(v16, a2, a3, a4, v24);
      std::__function::__value_func<void ()(std::vector<KB::LanguageModel::PredictionInfo> const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v24);
      return;
    }
    int64x2_t v13 = (KB::LanguageModelLexiconGroup *)((char *)v13 + 56);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    unint64_t v17 = TILocaleIdentifierForLexiconID(v12);
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = "inline_completions_with_stems";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v17;
    *(_WORD *)&unsigned char buf[22] = 2048;
    double v23 = v20;
    _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Inline completion not supported on detected language  (language : %s confidence = %f)", buf, 0x20u);
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v15 = *(void *)(a5 + 24);
  if (v15)
  {
    (*(void (**)(uint64_t, uint8_t *, void, uint64_t))(*(void *)v15 + 48))(v15, buf, *a2, a3);
    *a6 = 0;
    a6[24] = 0;
    unint64_t v21 = buf;
    std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
  }
  else
  {
    uint64_t v18 = (KB::LanguageModelLexiconGroup *)std::__throw_bad_function_call[abi:nn180100]();
    KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v18, v19);
  }
}

BOOL KB::LanguageModelLexiconGroup::model_contains_lexicon_id(KB::LanguageModelLexiconGroup *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (v2)
  {
    (*(void (**)(_DWORD **__return_ptr))(*(void *)v2 + 48))(&v7);
    unint64_t v4 = v8;
    id v5 = v7;
    if (v7 != v8)
    {
      id v5 = v7;
      while (*v5 != a2)
      {
        if (++v5 == v8)
        {
          id v5 = v8;
          break;
        }
      }
    }
    if (v7)
    {
      uint64_t v8 = v7;
      operator delete(v7);
    }
  }
  else
  {
    id v5 = 0;
    unint64_t v4 = 0;
  }
  return v5 != v4;
}

uint64_t KB::LanguageModelContainer::completions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, uint64_t a5, int a6)
{
  void v15[4] = *MEMORY[0x1E4F143B8];
  int v13 = a6;
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v15, a4);
  uint64_t v10 = operator new(0x20uLL);
  void *v10 = &unk_1F3F739C8;
  v10[1] = a1;
  void v10[2] = a5;
  void v10[3] = &v13;
  void v14[3] = v10;
  uint64_t v11 = KB::LanguageModelContainer::unified_predictions(a1, a2, a3, (uint64_t)v15, (uint64_t)v14);
  std::__function::__value_func<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__value_func[abi:nn180100](v14);
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v15);
  return v11;
}

uint64_t KB::LanguageModelContainer::unified_predictions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, uint64_t a5)
{
  v58[4] = *MEMORY[0x1E4F143B8];
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v45, a3);
  KB::LanguageModelContainer::update_context_with_predominant_locale(a1, (KB::LanguageModelContext *)v45);
  if ((*(uint64_t (**)(KB::LanguageModelContainer *))(*(void *)a1 + 144))(a1))
  {
    uint64_t v8 = *((void *)a1 + 3);
    uint64_t v9 = *((void *)a1 + 4);
    if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v9 - v8) >> 3)) >= 2)
    {
      int v10 = KB::LanguageModelContainer::most_probable_lexicon_for_context_and_stems(a1, (KB::LanguageModelContext *)v45, a2);
      uint64_t v11 = KB::LanguageModelContainer::index_for_lexicon_id(a1, v10);
      CFTypeID v42 = 0;
      CFTypeID v43 = 0;
      uint64_t v44 = 0;
      int v12 = *(void **)(*((void *)a1 + 3) + 56 * v11);
      if (v12)
      {
        int v12 = (*(void *(**)(void **__return_ptr))(*v12 + 48))(&v39);
      }
      else
      {
        std::string::size_type v39 = 0;
        std::string::size_type v40 = 0;
        uint64_t v41 = 0;
      }
      KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v12, &v39, a2, (uint64_t *)&v42);
      if (v39)
      {
        std::string::size_type v40 = v39;
        operator delete(v39);
      }
      if (v43 == v42)
      {
        uint64_t v18 = v57;
        v57[0] = &unk_1F3F73A10;
        v57[1] = a1;
        v57[2] = a4;
        v57[3] = v57;
        uint64_t v19 = *(void *)(a5 + 24);
        unint64_t v21 = v57;
        float v20 = (void ***)a2;
      }
      else
      {
        uint64_t v18 = v58;
        v58[0] = &unk_1F3F73A10;
        v58[1] = a1;
        v58[2] = a4;
        void v58[3] = v58;
        uint64_t v19 = *(void *)(a5 + 24);
        float v20 = &v42;
        unint64_t v21 = v58;
      }
      char v14 = std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(v19, (uint64_t)v20, (uint64_t)v45, (uint64_t)v21, v11);
      std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v18);
      if (v43 == v42 || (v14 & 1) == 0)
      {
        uint64_t v22 = *((void *)a1 + 3);
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*((void *)a1 + 4) - v22) >> 3)) >= 2)
        {
          BOOL v23 = v11 == 0;
          int v36 = 0;
          std::__split_buffer<std::string> v37 = 0;
          uint64_t v38 = 0;
          uint64_t v24 = *(void **)(v22 + 56 * v23);
          if (v24)
          {
            uint64_t v24 = (*(void *(**)(void **__return_ptr))(*v24 + 48))(&v33);
          }
          else
          {
            uint64_t v33 = 0;
            unsigned __int8 v34 = 0;
            uint64_t v35 = 0;
          }
          KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v24, &v33, a2, (uint64_t *)&v36);
          if (v33)
          {
            unsigned __int8 v34 = v33;
            operator delete(v33);
          }
          if (v37 == v36)
          {
            uint64_t v25 = v55;
            v55[0] = &unk_1F3F73A10;
            v55[1] = a1;
            void v55[2] = a4;
            v55[3] = v55;
            uint64_t v26 = *(void *)(a5 + 24);
            int64x2_t v28 = v55;
            long long v27 = (void ***)a2;
          }
          else
          {
            uint64_t v25 = v56;
            v56[0] = &unk_1F3F73A10;
            v56[1] = a1;
            void v56[2] = a4;
            void v56[3] = v56;
            uint64_t v26 = *(void *)(a5 + 24);
            long long v27 = &v36;
            int64x2_t v28 = v56;
          }
          char v29 = std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(v26, (uint64_t)v27, (uint64_t)v45, (uint64_t)v28, v23);
          std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v25);
          v14 |= v29;
          unsigned int v52 = &v36;
          std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v52);
        }
      }
      else
      {
        char v14 = 1;
      }
      int v36 = (void **)&v42;
      std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v36);
      goto LABEL_36;
    }
  }
  else
  {
    uint64_t v8 = *((void *)a1 + 3);
    uint64_t v9 = *((void *)a1 + 4);
  }
  if (v9 == v8)
  {
    char v14 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    char v14 = 0;
    unint64_t v15 = 0;
    do
    {
      if ((*(unsigned int (**)(void))(**(void **)(v8 + v13) + 144))(*(void *)(v8 + v13)))
      {
        CFTypeID v42 = 0;
        CFTypeID v43 = 0;
        uint64_t v44 = 0;
        uint64_t v16 = (*(void *(**)(void **__return_ptr))(**(void **)(*((void *)a1 + 3) + v13) + 48))(__p);
        KB::LanguageModelContainer::remove_differing_lex_stems((uint64_t)v16, __p, a2, (uint64_t *)&v42);
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        v54[0] = &unk_1F3F73A10;
        v54[1] = a1;
        v54[2] = a4;
        void v54[3] = v54;
        char v17 = std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(*(void *)(a5 + 24), (uint64_t)&v42, (uint64_t)v45, (uint64_t)v54, v15);
        std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v54);
        int v36 = (void **)&v42;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v36);
      }
      else
      {
        v53[0] = &unk_1F3F73A10;
        v53[1] = a1;
        v53[2] = a4;
        v53[3] = v53;
        char v17 = std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(*(void *)(a5 + 24), (uint64_t)a2, (uint64_t)v45, (uint64_t)v53, v15);
        std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v53);
      }
      v14 |= v17;
      ++v15;
      uint64_t v8 = *((void *)a1 + 3);
      v13 += 56;
    }
    while (v15 < 0x6DB6DB6DB6DB6DB7 * ((*((void *)a1 + 4) - v8) >> 3));
  }
LABEL_36:
  CFTypeID v42 = (void **)&v51;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v42);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v50);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v49);
  if (v47)
  {
    uint64_t v48 = v47;
    operator delete(v47);
  }
  if (v46) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v46);
  }
  return v14 & 1;
}

void *std::__function::__value_func<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void KB::LanguageModelContainer::update_context_with_predominant_locale(KB::LanguageModelContainer *this, KB::LanguageModelContext *a2)
{
  int v3 = (*(uint64_t (**)(KB::LanguageModelContainer *))(*(void *)this + 440))(this);
  if (v3)
  {
    unint64_t v4 = (char *)TILocaleIdentifierForLexiconID(v3);
    std::string::basic_string[abi:nn180100]<0>(&v6, v4);
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
      std::string::__init_copy_ctor_external(&__p, v6.__r_.__value_.__l.__data_, v6.__r_.__value_.__l.__size_);
    }
    else {
      std::string __p = v6;
    }
    KB::LanguageModelContext::set_predominant_locale((uint64_t)a2, (uint64_t)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v6.__r_.__value_.__l.__data_);
    }
  }
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context_and_stems(void *a1, KB::LanguageModelContext *a2, const KB::Candidate **a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  long long v47 = 0u;
  long long v48 = 0u;
  int v49 = 1065353216;
  uint64_t v6 = a1[3];
  uint64_t v7 = a1[4];
  while (v6 != v7)
  {
    if (*(void *)v6)
    {
      (*(void (**)(void ***__return_ptr))(**(void **)v6 + 48))(&v53);
      uint64_t v8 = (unsigned int *)v53;
      uint64_t v9 = v54;
      if (v53 != v54)
      {
        do
        {
          int v10 = v8 + 1;
          *((_DWORD *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v47, *v8, v8)+ 5) = 0;
          uint64_t v8 = v10;
        }
        while (v10 != (unsigned int *)v9);
        uint64_t v8 = (unsigned int *)v53;
      }
      if (v8)
      {
        unsigned int v54 = (void **)v8;
        operator delete(v8);
      }
    }
    v6 += 56;
  }
  uint64_t v11 = *a3;
  int v12 = a3[1];
  if (*a3 == v12)
  {
    float v13 = 0.0;
  }
  else
  {
    float v13 = 0.0;
    do
    {
      if (*(void *)v11)
      {
        uint64_t v14 = 240 * *(void *)v11;
        unint64_t v15 = (float *)(*((void *)v11 + 1) + 52);
        float v16 = 1.0;
        do
        {
          float v17 = *v15;
          v15 += 60;
          float v16 = v16 * v17;
          v14 -= 240;
        }
        while (v14);
      }
      else
      {
        float v16 = 1.0;
      }
      KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v40, a2);
      KB::Candidate::Candidate((KB::Candidate *)&v53, v11);
      if ((int)v53 >= 2)
      {
        uint64_t v18 = 0;
        uint64_t v19 = 17;
        do
        {
          TITokenID v20 = (TITokenID)v54[v19];
          KB::Word::capitalized_string((KB::Word *)&v54[v19 - 17], (uint64_t)&v50);
          TITokenID v21 = v20;
          KB::LanguageModelContext::append((KB::LanguageModelContext *)v40, v21, (const KB::String *)&v50, 0);
          if (v52) {
            BOOL v22 = v51 == 1;
          }
          else {
            BOOL v22 = 0;
          }
          if (v22) {
            free(v52);
          }
          ++v18;
          v19 += 30;
        }
        while (v18 < (int)v53 - 1);
      }
      unsigned int v23 = (*(uint64_t (**)(void *, char *))(*a1 + 440))(a1, v40);
      unsigned int v50 = v23;
      if (*((void *)&v47 + 1))
      {
        uint8x8_t v24 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v47 + 8));
        v24.i16[0] = vaddlv_u8(v24);
        if (v24.u32[0] > 1uLL)
        {
          unint64_t v25 = v23;
          if (*((void *)&v47 + 1) <= (unint64_t)v23) {
            unint64_t v25 = (unint64_t)v23 % *((void *)&v47 + 1);
          }
        }
        else
        {
          unint64_t v25 = (DWORD2(v47) - 1) & v23;
        }
        uint64_t v26 = *(uint64_t ***)(v47 + 8 * v25);
        if (v26)
        {
          for (uint64_t i = *v26; i; uint64_t i = (uint64_t *)*i)
          {
            unint64_t v28 = i[1];
            if (v28 == v23)
            {
              if (*((_DWORD *)i + 4) == v23)
              {
                if (*(void *)v11)
                {
                  uint64_t v29 = 240 * *(void *)v11;
                  unint64_t v30 = (float *)(*((void *)v11 + 1) + 52);
                  float v31 = 1.0;
                  do
                  {
                    float v32 = *v30;
                    v30 += 60;
                    float v31 = v31 * v32;
                    v29 -= 240;
                  }
                  while (v29);
                }
                else
                {
                  float v31 = 1.0;
                }
                uint64_t v33 = (float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)&v47, v23, &v50);
                v33[5] = v31 + v33[5];
                break;
              }
            }
            else
            {
              if (v24.u32[0] > 1uLL)
              {
                if (v28 >= *((void *)&v47 + 1)) {
                  v28 %= *((void *)&v47 + 1);
                }
              }
              else
              {
                v28 &= *((void *)&v47 + 1) - 1;
              }
              if (v28 != v25) {
                break;
              }
            }
          }
        }
      }
      KB::Candidate::~Candidate((KB::Candidate *)&v53);
      int v53 = (void **)&v46;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v53);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v45);
      language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v44);
      if (__p)
      {
        CFTypeID v43 = __p;
        operator delete(__p);
      }
      if (v41) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v41);
      }
      float v13 = v13 + v16;
      uint64_t v11 = (const KB::Candidate *)((char *)v11 + 1000);
    }
    while (v11 != v12);
  }
  unsigned __int8 v34 = (float *)v48;
  if ((void)v48)
  {
    uint64_t v35 = (float *)v48;
    do
    {
      v35[5] = v35[5] / v13;
      uint64_t v35 = *(float **)v35;
    }
    while (v35);
    LODWORD(v36) = 0;
    float v37 = -3.4028e38;
    do
    {
      float v38 = v34[5];
      if (v38 <= v37) {
        uint64_t v36 = v36;
      }
      else {
        uint64_t v36 = *((unsigned int *)v34 + 4);
      }
      if (v38 > v37) {
        float v37 = v34[5];
      }
      unsigned __int8 v34 = *(float **)v34;
    }
    while (v34);
  }
  else
  {
    uint64_t v36 = 0;
  }
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::~__hash_table((uint64_t)&v47);
  return v36;
}

uint64_t KB::LanguageModelContainer::index_for_lexicon_id(KB::LanguageModelContainer *this, int a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (*((void *)this + 4) != v2)
  {
    uint64_t v5 = 0;
    unint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(std::__shared_weak_count **)(v2 + v5 + 8);
      if (v7)
      {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v8 = KB::LanguageModelLexiconGroup::model_contains_lexicon_id((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + v5), a2);
        std::__shared_weak_count::__release_shared[abi:nn180100](v7);
        if (v8) {
          return v6;
        }
      }
      else if (KB::LanguageModelLexiconGroup::model_contains_lexicon_id((KB::LanguageModelLexiconGroup *)(v2 + v5), a2))
      {
        return v6;
      }
      ++v6;
      uint64_t v2 = *((void *)this + 3);
      v5 += 56;
    }
    while (v6 < 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 4) - v2) >> 3));
  }
  return -1;
}

void KB::LanguageModelContainer::remove_differing_lex_stems(uint64_t a1, void *a2, const KB::Candidate **a3, uint64_t *a4)
{
  unint64_t v4 = *a3;
  uint64_t v5 = a3[1];
  if (*a3 != v5)
  {
    long long v27 = a4 + 2;
    unint64_t v28 = a3[1];
    do
    {
      if ((int)*(void *)v4 < 2) {
        goto LABEL_17;
      }
      uint64_t v7 = 0;
      BOOL v8 = (_DWORD *)*a2;
      uint64_t v9 = (_DWORD *)a2[1];
      uint64_t v10 = *((void *)v4 + 1);
      uint64_t v11 = (int)(*(void *)v4 - 1);
      char v12 = 1;
      do
      {
        float v13 = (KB::Word *)(v10 + 240 * v7);
        uint64_t v14 = *((void *)v13 + 17);
        unint64_t v15 = v8;
        if (v8 != v9)
        {
          unint64_t v15 = v8;
          while (*v15 != v14)
          {
            if (++v15 == v9)
            {
              unint64_t v15 = v9;
              break;
            }
          }
        }
        if (HIDWORD(v14) >= 0x1F4)
        {
          BOOL is_linguistically_void = KB::Word::is_linguistically_void(v13);
          char v17 = v15 != v9 || is_linguistically_void;
          v12 &= v17;
        }
        ++v7;
      }
      while (v7 < v11);
      uint64_t v5 = v28;
      if (v12)
      {
LABEL_17:
        uint64_t v18 = (KB::Candidate *)a4[1];
        unint64_t v19 = a4[2];
        if ((unint64_t)v18 >= v19)
        {
          uint64_t v21 = 0x1CAC083126E978D5 * (((uint64_t)v18 - *a4) >> 3);
          unint64_t v22 = v21 + 1;
          if ((unint64_t)(v21 + 1) > 0x4189374BC6A7EFLL) {
            abort();
          }
          unint64_t v23 = 0x1CAC083126E978D5 * ((uint64_t)(v19 - *a4) >> 3);
          if (2 * v23 > v22) {
            unint64_t v22 = 2 * v23;
          }
          if (v23 >= 0x20C49BA5E353F7) {
            unint64_t v24 = 0x4189374BC6A7EFLL;
          }
          else {
            unint64_t v24 = v22;
          }
          void v30[4] = v27;
          if (v24) {
            unint64_t v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v24);
          }
          else {
            uint64_t v25 = 0;
          }
          uint64_t v26 = (KB::Candidate *)(v24 + 1000 * v21);
          v30[0] = v24;
          v30[1] = v26;
          void v30[3] = v24 + 1000 * v25;
          KB::Candidate::Candidate(v26, v4);
          v30[2] = (char *)v26 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer(a4, v30);
          TITokenID v20 = (char *)a4[1];
          std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)v30);
        }
        else
        {
          TITokenID v20 = (char *)KB::Candidate::Candidate(v18, v4) + 1000;
        }
        a4[1] = (uint64_t)v20;
      }
      unint64_t v4 = (const KB::Candidate *)((char *)v4 + 1000);
    }
    while (v4 != v5);
  }
}

uint64_t std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = a5;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, a2, a3, a4, &v7);
  }
  unint64_t v6 = std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(v6);
}

void std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  std::vector<TITokenID>::vector(v12, a2);
  long long v13 = *(_OWORD *)(a2 + 24);
  int v14 = *(_DWORD *)(a2 + 40);
  if (*(char *)(a2 + 71) < 0) {
    std::string::__init_copy_ctor_external(&v15, *(const std::string::value_type **)(a2 + 48), *(void *)(a2 + 56));
  }
  else {
    std::string v15 = *(std::string *)(a2 + 48);
  }
  if (*(char *)(a2 + 95) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a2 + 72), *(void *)(a2 + 80));
  }
  else {
    std::string __p = *(std::string *)(a2 + 72);
  }
  memset(&v17, 0, sizeof(v17));
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v17, *(long long **)(a2 + 96), *(long long **)(a2 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3));
  memset(&v18, 0, sizeof(v18));
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(&v18, *(long long **)(a2 + 120), *(long long **)(a2 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 3));
  long long v19 = *(_OWORD *)(a2 + 144);
  float v9 = (*(float (**)(uint64_t, void, uint64_t))(*(void *)v8 + 456))(v8, *(unsigned int *)(a2 + 144), a4);
  *(float *)&long long v13 = v9 * *(float *)&v13;
  uint64_t v10 = *(void *)(*(void *)(a1 + 16) + 24);
  if (v10)
  {
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t))(*(void *)v10 + 48))(v10, v12, a3, a4);
    TITokenID v20 = &v18;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v20);
    TITokenID v20 = &v17;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v20);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v15.__r_.__value_.__l.__data_);
    }
    if (v12[0])
    {
      v12[1] = v12[0];
      operator delete(v12[0]);
    }
  }
  else
  {
    uint64_t v11 = (char *)std::__throw_bad_function_call[abi:nn180100]();
    std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::destroy_deallocate(v11);
  }
}

__n128 std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73A10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F73A10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0,std::allocator<KB::LanguageModelContainer::unified_predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>)::$_0>,BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__func()
{
}

void *std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    float v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  uint64_t v10 = operator new(0x18uLL);
  void *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  long long v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    void *v10 = *v19;
LABEL_38:
    *long long v19 = v10;
    goto LABEL_39;
  }
  void *v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v20 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    long long v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v10;
}

uint64_t std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  void v18[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v15, a4);
  uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 24);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(void *)(*(void *)(a1 + 8) + 32) - v9) >> 3)) <= *a5)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 56 * *a5);
    std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v18, (uint64_t)v15);
    unint64_t v11 = *(void **)(a1 + 16);
    float v12 = (void *)v11[3];
    if (v12)
    {
      if (v12 == v11)
      {
        size_t v17 = v16;
        (*(void (**)(void *, void *))(*v11 + 24))(v11, v16);
      }
      else
      {
        size_t v17 = (void *)(*(uint64_t (**)(void))(*v12 + 16))(v11[3]);
      }
    }
    else
    {
      size_t v17 = 0;
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, void *, void))(*(void *)v10 + 520))(v10, a2, a3, v18, v16, **(unsigned int **)(a1 + 24));
    std::__function::__value_func<BOOL ()(KB::Candidate const&)>::~__value_func[abi:nn180100](v16);
    std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v18);
  }
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v15);
  return v13;
}

void *std::__function::__value_func<BOOL ()(KB::Candidate const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

__n128 std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F739C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F739C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0,std::allocator<KB::LanguageModelContainer::completions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,std::function<BOOL ()(KB::Candidate const&)>,KB::LookupType)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__func()
{
}

uint64_t KB::LanguageModelContainer::predictions(KB::LanguageModelContainer *a1, const KB::Candidate **a2, KB::LanguageModelContext *a3, uint64_t a4, char a5)
{
  v12[4] = *MEMORY[0x1E4F143B8];
  char v10 = a5;
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v12, a4);
  v11[0] = &unk_1F3F73980;
  v11[1] = a1;
  void v11[2] = &v10;
  _WORD v11[3] = v11;
  uint64_t v8 = KB::LanguageModelContainer::unified_predictions(a1, a2, a3, (uint64_t)v12, (uint64_t)v11);
  std::__function::__value_func<BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__value_func[abi:nn180100](v11);
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v12);
  return v8;
}

uint64_t std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  void v14[4] = *MEMORY[0x1E4F143B8];
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v13, a4);
  uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 24);
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * ((*(void *)(*(void *)(a1 + 8) + 32) - v9) >> 3)) <= *a5)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v10 = *(void *)(v9 + 56 * *a5);
    std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::__value_func[abi:nn180100]((uint64_t)v14, (uint64_t)v13);
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)v10 + 512))(v10, a2, a3, v14, **(unsigned __int8 **)(a1 + 16));
    std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v14);
  }
  std::__function::__value_func<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>::~__value_func[abi:nn180100](v13);
  return v11;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F73980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0,std::allocator<KB::LanguageModelContainer::predictions(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,BOOL)::$_0>,BOOL ()(std::vector<KB::Candidate> const&,KB::LanguageModelContext const&,std::function<BOOL ()(KB::LanguageModel::PredictionInfo const&,KB::Candidate const&,KB::LanguageModelContext const&)>,unsigned long)>::~__func()
{
}

uint64_t KB::LanguageModelContainer::should_not_suggest_or_predict_text(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void **)(a1 + 24);
  unint64_t v4 = *(void **)(a1 + 32);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  uint64_t v9 = ___ZNK2KB22LanguageModelContainer34should_not_suggest_or_predict_textERKNS_6StringERKN3WTF6RefPtrINS_19DictionaryContainerEEE_block_invoke;
  uint64_t v10 = &__block_descriptor_48_e10_B16__0r_v8l;
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  uint64_t v5 = v8;
  if (v3 == v4)
  {
    uint64_t v6 = 0;
  }
  else
  {
    do
    {
      uint64_t v6 = v9((uint64_t)v5, v3);
      if (v6) {
        break;
      }
      v3 += 7;
    }
    while (v3 != v4);
  }

  return v6;
}

uint64_t ___ZNK2KB22LanguageModelContainer34should_not_suggest_or_predict_textERKNS_6StringERKN3WTF6RefPtrINS_19DictionaryContainerEEE_block_invoke(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)*a2 + 504))(*a2, *(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t KB::LanguageModelContainer::is_text_blocklisted(KB::LanguageModelContainer *this, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  if (!a3) {
    return 0;
  }
  if (a3 == -1)
  {
    unint64_t v7 = (void *)*((void *)this + 3);
    uint64_t v8 = (void *)*((void *)this + 4);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    unint64_t v15 = ___ZNK2KB22LanguageModelContainer19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke;
    unint64_t v16 = &__block_descriptor_64_e10_B16__0r_v8l;
    uint64_t v17 = a2;
    uint64_t v18 = a4;
    uint64_t v19 = a5;
    int v20 = -1;
    int v21 = a6;
    uint64_t v9 = v14;
    if (v7 == v8)
    {
      uint64_t v10 = 0;
    }
    else
    {
      do
      {
        uint64_t v10 = v15((uint64_t)v9, v7);
        if (v10) {
          break;
        }
        v7 += 7;
      }
      while (v7 != v8);
    }

    return v10;
  }
  uint64_t v11 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3);
  if (v11 == -1) {
    return 1;
  }
  uint64_t v12 = *(uint64_t (**)(void))(**(void **)(*((void *)this + 3) + 56 * v11) + 496);

  return v12();
}

uint64_t ___ZNK2KB22LanguageModelContainer19is_text_blocklistedERKNS_6StringEjRKNS_20LanguageModelContextERKN3WTF6RefPtrINS_19DictionaryContainerEEE27TIBlocklistSensitivityLevel_block_invoke(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void, void, void, void, void, void))(*(void *)*a2 + 496))(*a2, *(void *)(a1 + 32), *(unsigned int *)(a1 + 56), *(void *)(a1 + 40), *(void *)(a1 + 48), *(unsigned int *)(a1 + 60));
}

uint64_t KB::LanguageModelContainer::is_token_blocklisted(KB::LanguageModelContainer *a1, int a2, uint64_t a3)
{
  unsigned int v3 = HIDWORD(a3);
  uint64_t v5 = KB::LanguageModelContainer::index_for_lexicon_id(a1, a3);
  if (v5 == -1) {
    return v3 > 0x1F3;
  }
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(*((void *)a1 + 3) + 56 * v5);
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7)) {
    return 1;
  }
  uint64_t v8 = *(uint64_t (**)(void))(**(void **)(*((void *)a1 + 3) + 56 * v6) + 488);

  return v8();
}

KB::LanguageModelContainer::PredictionEnumeratorContainer *KB::LanguageModelContainer::create_prediction_enumerator@<X0>(KB::LanguageModelContainer *this@<X0>, const KB::LanguageModelContext *a2@<X1>, KB::LanguageModelContainer::PredictionEnumeratorContainer **a3@<X8>)
{
  uint64_t v6 = operator new(0x70uLL);
  v6[1] = 0;
  v6[2] = 0;
  *uint64_t v6 = &unk_1F3F73900;
  __n128 result = KB::LanguageModelContainer::PredictionEnumeratorContainer::PredictionEnumeratorContainer((KB::LanguageModelContainer::PredictionEnumeratorContainer *)(v6 + 3), this, a2);
  *a3 = result;
  a3[1] = (KB::LanguageModelContainer::PredictionEnumeratorContainer *)v6;
  return result;
}

KB::LanguageModelContainer::PredictionEnumeratorContainer *KB::LanguageModelContainer::PredictionEnumeratorContainer::PredictionEnumeratorContainer(KB::LanguageModelContainer::PredictionEnumeratorContainer *this, const KB::LanguageModelContainer *a2, const KB::LanguageModelContext *a3)
{
  *(void *)this = &unk_1F3F738D0;
  *(_OWORD *)((char *)this + 8) = 0u;
  id v72 = (int64x2_t *)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((void *)this + 7) = a2;
  *((void *)this + 8) = a3;
  *((void *)this + 9) = -1;
  *((unsigned char *)this + 80) = 0;
  int64x2_t v74 = 0uLL;
  long long v75 = 0;
  unint64_t v4 = (long long *)*((void *)a2 + 3);
  uint64_t v5 = (long long *)*((void *)a2 + 4);
  if (v4 == v5)
  {
    unint64_t v21 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    do
    {
      if (v6 >= v75)
      {
        uint64_t v8 = (uint64_t)&v6[-v74.i64[0]] >> 4;
        if ((unint64_t)(v8 + 1) >> 60) {
          goto LABEL_74;
        }
        unint64_t v9 = (uint64_t)&v75[-v74.i64[0]] >> 3;
        if (v9 <= v8 + 1) {
          unint64_t v9 = v8 + 1;
        }
        if ((unint64_t)&v75[-v74.i64[0]] >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v9;
        }
        id v79 = &v75;
        uint64_t v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v10);
        uint64_t v13 = &v11[16 * v8];
        long long v14 = *v4;
        *(_OWORD *)uint64_t v13 = *v4;
        if (*((void *)&v14 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v14 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v15 = (void *)v74.i64[1];
        unint64_t v16 = (void *)v74.i64[0];
        if (v74.i64[1] == v74.i64[0])
        {
          int64x2_t v19 = vdupq_n_s64(v74.u64[1]);
          uint64_t v17 = &v11[16 * v8];
        }
        else
        {
          uint64_t v17 = &v11[16 * v8];
          do
          {
            long long v18 = *((_OWORD *)v15 - 1);
            v15 -= 2;
            *((_OWORD *)v17 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v18;
            v17 -= 16;
            *unint64_t v15 = 0;
            v15[1] = 0;
          }
          while (v15 != v16);
          int64x2_t v19 = v74;
        }
        uint64_t v6 = v13 + 16;
        v74.i64[0] = (uint64_t)v17;
        v74.i64[1] = (uint64_t)(v13 + 16);
        int64x2_t v77 = v19;
        int v20 = (void **)v75;
        long long v75 = &v11[16 * v12];
        id v78 = v20;
        double v76 = (int64x2_t *)v19.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v76);
      }
      else
      {
        *(void *)uint64_t v6 = *(void *)v4;
        uint64_t v7 = *((void *)v4 + 1);
        *((void *)v6 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v7;
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        v6 += 16;
      }
      v74.i64[1] = (uint64_t)v6;
      unint64_t v4 = (long long *)((char *)v4 + 56);
    }
    while (v4 != v5);
    unint64_t v21 = (uint64_t)&v6[-v74.i64[0]] >> 4;
  }
  double v76 = &v74;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v76);
  uint64_t v22 = *((void *)this + 1);
  if (v21 > (*((void *)this + 3) - v22) >> 4)
  {
    if (v21 >> 60) {
      goto LABEL_74;
    }
    uint64_t v23 = *((void *)this + 2) - v22;
    id v79 = (char **)((char *)this + 24);
    unint64_t v24 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v21);
    long long v27 = (void *)*((void *)this + 1);
    uint64_t v26 = (void *)*((void *)this + 2);
    if (v26 == v27)
    {
      int64x2_t v30 = vdupq_n_s64((unint64_t)v26);
      unint64_t v28 = &v24[v23];
    }
    else
    {
      unint64_t v28 = &v24[v23];
      do
      {
        long long v29 = *((_OWORD *)v26 - 1);
        v26 -= 2;
        *((_OWORD *)v28 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v29;
        v28 -= 16;
        *uint64_t v26 = 0;
        v26[1] = 0;
      }
      while (v26 != v27);
      int64x2_t v30 = *v72;
    }
    *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v28;
    *((void *)this + 2) = &v24[v23];
    int64x2_t v77 = v30;
    float v31 = (void **)*((void *)this + 3);
    *((void *)this + 3) = &v24[16 * v25];
    id v78 = v31;
    double v76 = (int64x2_t *)v30.i64[0];
    std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v76);
  }
  uint64_t v32 = *((void *)this + 4);
  if (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 6) - v32) >> 5) >= v21) {
    goto LABEL_35;
  }
  if (v21 >= 0x19999999999999ALL) {
LABEL_74:
  }
    abort();
  uint64_t v33 = *((void *)this + 5) - v32;
  id v79 = (char **)((char *)this + 48);
  double v76 = (int64x2_t *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v21);
  v77.i64[0] = (uint64_t)v76->i64 + v33;
  v77.i64[1] = (uint64_t)v76->i64 + v33;
  id v78 = (void **)&v76[10 * v34];
  std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, &v76);
  std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v76);
LABEL_35:
  uint64_t v35 = *((void *)this + 7);
  long long v75 = 0;
  int64x2_t v74 = 0uLL;
  uint64_t v36 = *(long long **)(v35 + 24);
  float v37 = *(long long **)(v35 + 32);
  if (v36 != v37)
  {
    float v38 = 0;
    do
    {
      if (v38 >= v75)
      {
        uint64_t v40 = (uint64_t)&v38[-v74.i64[0]] >> 4;
        if ((unint64_t)(v40 + 1) >> 60) {
          goto LABEL_74;
        }
        unint64_t v41 = (uint64_t)&v75[-v74.i64[0]] >> 3;
        if (v41 <= v40 + 1) {
          unint64_t v41 = v40 + 1;
        }
        if ((unint64_t)&v75[-v74.i64[0]] >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v42 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v42 = v41;
        }
        id v79 = &v75;
        CFTypeID v43 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v42);
        uint64_t v45 = &v43[16 * v40];
        long long v46 = *v36;
        *(_OWORD *)uint64_t v45 = *v36;
        if (*((void *)&v46 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v46 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        long long v47 = (void *)v74.i64[1];
        long long v48 = (void *)v74.i64[0];
        if (v74.i64[1] == v74.i64[0])
        {
          int64x2_t v51 = vdupq_n_s64(v74.u64[1]);
          int v49 = &v43[16 * v40];
        }
        else
        {
          int v49 = &v43[16 * v40];
          do
          {
            long long v50 = *((_OWORD *)v47 - 1);
            v47 -= 2;
            *((_OWORD *)v49 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v50;
            v49 -= 16;
            void *v47 = 0;
            v47[1] = 0;
          }
          while (v47 != v48);
          int64x2_t v51 = v74;
        }
        float v38 = v45 + 16;
        v74.i64[0] = (uint64_t)v49;
        v74.i64[1] = (uint64_t)(v45 + 16);
        int64x2_t v77 = v51;
        unsigned int v52 = (void **)v75;
        long long v75 = &v43[16 * v44];
        id v78 = v52;
        double v76 = (int64x2_t *)v51.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v76);
      }
      else
      {
        *(void *)float v38 = *(void *)v36;
        uint64_t v39 = *((void *)v36 + 1);
        *((void *)v38 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v39;
        if (v39) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
        }
        v38 += 16;
      }
      v74.i64[1] = (uint64_t)v38;
      uint64_t v36 = (long long *)((char *)v36 + 56);
    }
    while (v36 != v37);
    for (uint64_t i = (char *)v74.i64[0]; i != v38; i += 16)
    {
      (*(void (**)(long long *__return_ptr))(**(void **)i + 480))(&v73);
      uint64_t v55 = (_OWORD *)*((void *)this + 2);
      unint64_t v54 = *((void *)this + 3);
      if ((unint64_t)v55 >= v54)
      {
        uint64_t v56 = ((uint64_t)v55 - v72->i64[0]) >> 4;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 60) {
          goto LABEL_74;
        }
        uint64_t v58 = v54 - v72->i64[0];
        if (v58 >> 3 > v57) {
          unint64_t v57 = v58 >> 3;
        }
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v59 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v59 = v57;
        }
        id v79 = (char **)((char *)this + 24);
        id v60 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v59);
        CFTypeRef v62 = &v60[16 * v56];
        *(_OWORD *)CFTypeRef v62 = v73;
        long long v73 = 0uLL;
        BOOL v64 = (void *)*((void *)this + 1);
        std::string::size_type v63 = (void *)*((void *)this + 2);
        if (v63 == v64)
        {
          int64x2_t v67 = vdupq_n_s64((unint64_t)v63);
          long long v65 = &v60[16 * v56];
        }
        else
        {
          long long v65 = &v60[16 * v56];
          do
          {
            long long v66 = *((_OWORD *)v63 - 1);
            v63 -= 2;
            *((_OWORD *)v65 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v66;
            v65 -= 16;
            *std::string::size_type v63 = 0;
            v63[1] = 0;
          }
          while (v63 != v64);
          int64x2_t v67 = *v72;
        }
        std::string::size_type v68 = v62 + 16;
        *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v65;
        *((void *)this + 2) = v62 + 16;
        int64x2_t v77 = v67;
        BOOL v69 = (void **)*((void *)this + 3);
        *((void *)this + 3) = &v60[16 * v61];
        id v78 = v69;
        double v76 = (int64x2_t *)v67.i64[0];
        std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v76);
        long long v70 = (std::__shared_weak_count *)*((void *)&v73 + 1);
        *((void *)this + 2) = v68;
        if (v70) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v70);
        }
      }
      else
      {
        *uint64_t v55 = v73;
        *((void *)this + 2) = v55 + 1;
      }
    }
  }
  double v76 = &v74;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v76);
  return this;
}

BOOL KB::LanguageModelContainer::PredictionEnumeratorContainer::advance(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  if (*((unsigned char *)this + 80))
  {
    uint64_t v2 = *(void *)(*((void *)this + 1) + 16 * *((void *)this + 9));
    if ((*(unsigned int (**)(uint64_t))(*(void *)v2 + 24))(v2))
    {
      uint64_t v3 = *((void *)this + 9);
      uint64_t v4 = *((void *)this + 4);
      uint64_t v5 = (void **)(v4 + 160 * v3);
      (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v2 + 16))(v59, v2);
      uint64_t v6 = (unsigned int *)*v5;
      if (*v5)
      {
        v5[1] = v6;
        operator delete(v6);
      }
      *(_OWORD *)uint64_t v5 = *(_OWORD *)v59;
      v5[2] = v60;
      v59[1] = 0;
      id v60 = 0;
      v59[0] = 0;
      uint64_t v7 = v4 + 160 * v3;
      long long v8 = v61;
      *(_DWORD *)(v7 + 40) = v62;
      *(_OWORD *)(v7 + 24) = v8;
      unint64_t v9 = (void **)(v7 + 48);
      if (*((char *)v5 + 71) < 0) {
        operator delete(*v9);
      }
      long long v10 = *(_OWORD *)v63;
      *(void *)(v7 + 64) = v64[0];
      *(_OWORD *)unint64_t v9 = v10;
      HIBYTE(v64[0]) = 0;
      LOBYTE(v63[0]) = 0;
      uint64_t v11 = (void **)(v4 + 160 * v3 + 72);
      if (*((char *)v5 + 95) < 0) {
        operator delete(*v11);
      }
      long long v12 = *(_OWORD *)&v64[1];
      *(void *)(v4 + 160 * v3 + 88) = v64[3];
      *(_OWORD *)uint64_t v11 = v12;
      HIBYTE(v64[3]) = 0;
      LOBYTE(v64[1]) = 0;
      uint64_t v13 = v4 + 160 * v3;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 96));
      *(_OWORD *)(v13 + 96) = v65[0];
      *(void *)(v13 + 112) = *(void *)&v65[1];
      memset(v65, 0, 24);
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v13 + 120));
      *(_OWORD *)(v13 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
      *(void *)(v13 + 136) = *((void *)&v65[2] + 1);
      memset((char *)&v65[1] + 8, 0, 24);
      *(_OWORD *)(v13 + 144) = v66;
      v67[0] = (void **)&v65[1] + 1;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      v67[0] = (void **)v65;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      if (SHIBYTE(v64[3]) < 0) {
        operator delete((void *)v64[1]);
      }
      if (SHIBYTE(v64[0]) < 0) {
        operator delete(v63[0]);
      }
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
      if (*v5 == v5[1])
      {
LABEL_67:
        BOOL result = 0;
        *((void *)this + 9) = -1;
        return result;
      }
      *(float *)(v7 + 24) = (*(float (**)(void, void, void))(**((void **)this + 7) + 456))(*((void *)this + 7), *(unsigned int *)*v5, *((void *)this + 8))* *(float *)(v7 + 24);
    }
    else
    {
      LODWORD(v6TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
      *((void *)&v61 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
      int v62 = 0;
      *((void *)&v66 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
      *(_OWORD *)std::string::size_type v63 = 0u;
      memset(v64, 0, sizeof(v64));
      memset(v65, 0, sizeof(v65));
      uint64_t v45 = *((void *)this + 9);
      uint64_t v46 = *((void *)this + 4);
      uint64_t v47 = v46 + 160 * v45;
      long long v48 = *(void **)v47;
      if (*(void *)v47)
      {
        *(void *)(v47 + 8) = v48;
        operator delete(v48);
      }
      *(void *)uint64_t v47 = 0;
      *(void *)(v47 + 8) = 0;
      *(void *)(v47 + 16) = 0;
      v59[1] = 0;
      id v60 = 0;
      v59[0] = 0;
      uint64_t v49 = v46 + 160 * v45;
      long long v50 = v61;
      *(_DWORD *)(v49 + 40) = v62;
      *(_OWORD *)(v49 + 24) = v50;
      uint64_t v51 = v49 + 48;
      if (*(char *)(v47 + 71) < 0) {
        operator delete(*(void **)v51);
      }
      long long v52 = *(_OWORD *)v63;
      *(void *)(v51 + 16) = v64[0];
      *(_OWORD *)uint64_t v51 = v52;
      HIBYTE(v64[0]) = 0;
      LOBYTE(v63[0]) = 0;
      int v53 = (void **)(v46 + 160 * v45 + 72);
      if (*(char *)(v47 + 95) < 0) {
        operator delete(*v53);
      }
      long long v54 = *(_OWORD *)&v64[1];
      *(void *)(v46 + 160 * v45 + 88) = v64[3];
      *(_OWORD *)int v53 = v54;
      HIBYTE(v64[3]) = 0;
      LOBYTE(v64[1]) = 0;
      uint64_t v55 = v46 + 160 * v45;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v55 + 96));
      *(void *)(v55 + 96) = 0;
      *(void *)(v55 + 104) = 0;
      *(void *)(v55 + 112) = 0;
      memset(v65, 0, 24);
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v55 + 120));
      *(void *)(v55 + 120) = 0;
      *(void *)(v55 + 128) = 0;
      *(void *)(v55 + 136) = 0;
      memset((char *)&v65[1] + 8, 0, 24);
      *(_OWORD *)(v55 + 144) = v66;
      v67[0] = (void **)&v65[1] + 1;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      v67[0] = (void **)v65;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
      if (SHIBYTE(v64[3]) < 0) {
        operator delete((void *)v64[1]);
      }
      if (SHIBYTE(v64[0]) < 0) {
        operator delete(v63[0]);
      }
      if (v59[0])
      {
        v59[1] = v59[0];
        operator delete(v59[0]);
      }
    }
  }
  else
  {
    *((unsigned char *)this + 80) = 1;
    uint64_t v14 = *((void *)this + 1);
    if (*((void *)this + 2) != v14)
    {
      uint64_t v15 = 0;
      unint64_t v16 = 0;
      uint64_t v17 = (void *)((char *)this + 32);
      uint64_t v58 = (void **)((char *)this + 48);
      do
      {
        uint64_t v18 = *(void *)(v14 + v15);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v18 + 24))(v18))
        {
          (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v18 + 16))(v59, v18);
          unint64_t v19 = *((void *)this + 5);
          unint64_t v20 = *((void *)this + 6);
          if (v19 >= v20)
          {
            unint64_t v28 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v19 - *v17) >> 5);
            unint64_t v29 = v28 + 1;
            if (v28 + 1 > 0x199999999999999) {
              goto LABEL_69;
            }
            unint64_t v30 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v20 - *v17) >> 5);
            if (2 * v30 > v29) {
              unint64_t v29 = 2 * v30;
            }
            if (v30 >= 0xCCCCCCCCCCCCCCLL) {
              unint64_t v31 = 0x199999999999999;
            }
            else {
              unint64_t v31 = v29;
            }
            void v67[4] = v58;
            if (v31) {
              unint64_t v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v31);
            }
            else {
              uint64_t v32 = 0;
            }
            unint64_t v40 = v31 + 160 * v28;
            v67[0] = (void **)v31;
            v67[1] = (void **)v40;
            v67[3] = (void **)(v31 + 160 * v32);
            *(void *)unint64_t v40 = 0;
            *(void *)(v40 + 8) = 0;
            *(void *)(v40 + 16) = 0;
            *(_OWORD *)unint64_t v40 = *(_OWORD *)v59;
            *(void *)(v40 + 16) = v60;
            v59[0] = 0;
            v59[1] = 0;
            id v60 = 0;
            long long v41 = v61;
            *(_DWORD *)(v40 + 40) = v62;
            *(_OWORD *)(v40 + 24) = v41;
            long long v42 = *(_OWORD *)v63;
            *(void *)(v40 + 64) = v64[0];
            *(_OWORD *)(v40 + 48) = v42;
            v63[1] = 0;
            v64[0] = 0;
            v63[0] = 0;
            long long v43 = *(_OWORD *)&v64[1];
            *(void *)(v40 + 88) = v64[3];
            *(_OWORD *)(v40 + 72) = v43;
            memset(&v64[1], 0, 24);
            *(void *)(v40 + 96) = 0;
            *(void *)(v40 + 104) = 0;
            *(void *)(v40 + 112) = 0;
            *(_OWORD *)(v40 + 96) = v65[0];
            *(void *)(v40 + 112) = *(void *)&v65[1];
            memset(v65, 0, 24);
            *(void *)(v40 + 120) = 0;
            *(void *)(v40 + 128) = 0;
            *(void *)(v40 + 136) = 0;
            *(_OWORD *)(v40 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
            *(void *)(v40 + 136) = *((void *)&v65[2] + 1);
            memset((char *)&v65[1] + 8, 0, 24);
            *(_OWORD *)(v40 + 144) = v66;
            v67[2] = (void **)(v40 + 160);
            std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, v67);
            unint64_t v24 = *((void *)this + 5);
            std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v67);
          }
          else
          {
            *(void *)unint64_t v19 = 0;
            *(void *)(v19 + 8) = 0;
            *(void *)(v19 + 16) = 0;
            *(_OWORD *)unint64_t v19 = *(_OWORD *)v59;
            *(void *)(v19 + 16) = v60;
            v59[0] = 0;
            v59[1] = 0;
            id v60 = 0;
            int v21 = v62;
            *(_OWORD *)(v19 + 24) = v61;
            *(_DWORD *)(v19 + 40) = v21;
            uint64_t v22 = v64[0];
            *(_OWORD *)(v19 + 48) = *(_OWORD *)v63;
            *(void *)(v19 + 64) = v22;
            v63[1] = 0;
            v64[0] = 0;
            v63[0] = 0;
            long long v23 = *(_OWORD *)&v64[1];
            *(void *)(v19 + 88) = v64[3];
            *(void *)(v19 + 96) = 0;
            *(_OWORD *)(v19 + 72) = v23;
            memset(&v64[1], 0, 24);
            *(void *)(v19 + 104) = 0;
            *(void *)(v19 + 112) = 0;
            *(_OWORD *)(v19 + 96) = v65[0];
            v65[0] = 0uLL;
            *(void *)(v19 + 112) = *(void *)&v65[1];
            *(void *)(v19 + 120) = 0;
            *(void *)&v65[1] = 0;
            *(void *)(v19 + 128) = 0;
            *(void *)(v19 + 136) = 0;
            *(_OWORD *)(v19 + 120) = *(_OWORD *)((char *)&v65[1] + 8);
            *(void *)(v19 + 136) = *((void *)&v65[2] + 1);
            memset((char *)&v65[1] + 8, 0, 24);
            *(_OWORD *)(v19 + 144) = v66;
            unint64_t v24 = v19 + 160;
          }
          *((void *)this + 5) = v24;
          v67[0] = (void **)&v65[1] + 1;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
          v67[0] = (void **)v65;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v67);
          if (SHIBYTE(v64[3]) < 0) {
            operator delete((void *)v64[1]);
          }
          if (SHIBYTE(v64[0]) < 0) {
            operator delete(v63[0]);
          }
          if (v59[0])
          {
            v59[1] = v59[0];
            operator delete(v59[0]);
          }
          uint64_t v44 = *((void *)this + 5);
          if (*(void *)(v44 - 160) == *(void *)(v44 - 152)) {
            goto LABEL_67;
          }
          *(float *)(v44 - 136) = (*(float (**)(void, void, void))(**((void **)this + 7) + 456))(*((void *)this + 7), *(unsigned int *)(v44 - 16), *((void *)this + 8))* *(float *)(v44 - 136);
        }
        else
        {
          unint64_t v25 = *((void *)this + 5);
          unint64_t v26 = *((void *)this + 6);
          if (v25 >= v26)
          {
            unint64_t v33 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - *v17) >> 5);
            unint64_t v34 = v33 + 1;
            if (v33 + 1 > 0x199999999999999) {
LABEL_69:
            }
              abort();
            unint64_t v35 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v26 - *v17) >> 5);
            if (2 * v35 > v34) {
              unint64_t v34 = 2 * v35;
            }
            if (v35 >= 0xCCCCCCCCCCCCCCLL) {
              unint64_t v36 = 0x199999999999999;
            }
            else {
              unint64_t v36 = v34;
            }
            *((void *)&v61 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v58;
            float v37 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v36);
            float v38 = (unsigned int *)&v37[160 * v33];
            v59[0] = v37;
            v59[1] = v38;
            *(void *)&long long v61 = &v37[160 * v39];
            *((void *)v38 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            *((void *)v38 + 2) = 0;
            *(void *)float v38 = 0;
            unsigned char v38[6] = 0;
            *((void *)v38 + 4) = 0;
            v38[10] = 0;
            *((void *)v38 + 19) = 0;
            *((_OWORD *)v38 + 3) = 0u;
            *((_OWORD *)v38 + 4) = 0u;
            *((_OWORD *)v38 + 5) = 0u;
            *((_OWORD *)v38 + 6) = 0u;
            *((_OWORD *)v38 + 7) = 0u;
            *((_OWORD *)v38 + 8) = 0u;
            id v60 = v38 + 40;
            std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer((uint64_t *)this + 4, v59);
            unint64_t v27 = *((void *)this + 5);
            std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)v59);
          }
          else
          {
            *(void *)unint64_t v25 = 0;
            *(void *)(v25 + 8) = 0;
            *(void *)(v25 + 16) = 0;
            *(_DWORD *)(v25 + 24) = 0;
            *(void *)(v25 + 32) = 0;
            *(_DWORD *)(v25 + 40) = 0;
            *(void *)(v25 + 152) = 0;
            *(_OWORD *)(v25 + 48) = 0u;
            *(_OWORD *)(v25 + 64) = 0u;
            *(_OWORD *)(v25 + 80) = 0u;
            *(_OWORD *)(v25 + 96) = 0u;
            unint64_t v27 = v25 + 160;
            *(_OWORD *)(v25 + 112) = 0u;
            *(_OWORD *)(v25 + 128) = 0u;
          }
          *((void *)this + 5) = v27;
        }
        ++v16;
        uint64_t v14 = *((void *)this + 1);
        v15 += 16;
      }
      while (v16 < (*((void *)this + 2) - v14) >> 4);
    }
  }
  KB::LanguageModelContainer::PredictionEnumeratorContainer::update_next_prediction_index(this);
  uint64_t v56 = *((void *)this + 9);
  return v56 != -1 && *(float *)(*((void *)this + 4) + 160 * v56 + 24) > 0.0;
}

void *KB::LanguageModelContainer::PredictionEnumeratorContainer::update_next_prediction_index(void *this)
{
  uint64_t v2 = this[4];
  uint64_t v1 = this[5];
  uint64_t v3 = v1 - v2;
  if (v1 != v2)
  {
    uint64_t v4 = 0;
    unint64_t v5 = v3 / 160;
    if (v5 <= 1) {
      unint64_t v5 = 1;
    }
    uint64_t v6 = (float *)(v2 + 24);
    float v7 = 0.0;
    uint64_t v8 = -1;
    do
    {
      float v9 = *v6;
      v6 += 40;
      float v10 = v9;
      if (v9 > v7)
      {
        float v7 = v10;
        uint64_t v8 = v4;
      }
      ++v4;
    }
    while (v5 != v4);
    if (v8 != -1) {
      this[9] = v8;
    }
  }
  return this;
}

__n128 KB::LanguageModelContainer::PredictionEnumeratorContainer::get_prediction@<Q0>(KB::LanguageModelContainer::PredictionEnumeratorContainer *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 9);
  uint64_t v4 = *((void *)this + 4);
  uint64_t v5 = v4 + 160 * v3;
  std::vector<TITokenID>::vector((void *)a2, v5);
  long long v6 = *(_OWORD *)(v5 + 24);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(v5 + 40);
  *(_OWORD *)(a2 + 24) = v6;
  float v7 = (std::string *)(a2 + 48);
  uint64_t v8 = (const std::string::value_type **)(v5 + 48);
  if (*(char *)(v5 + 71) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *v8, *(void *)(v4 + 160 * v3 + 56));
  }
  else
  {
    long long v9 = *(_OWORD *)v8;
    *(void *)(a2 + 64) = *(void *)(v5 + 64);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  float v10 = (std::string *)(a2 + 72);
  uint64_t v11 = (const std::string::value_type **)(v4 + 160 * v3 + 72);
  if (*(char *)(v5 + 95) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *v11, *(void *)(v4 + 160 * v3 + 80));
  }
  else
  {
    long long v12 = *(_OWORD *)v11;
    *(void *)(a2 + 88) = *(void *)(v4 + 160 * v3 + 88);
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = v12;
  }
  uint64_t v13 = v4 + 160 * v3;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  *(void *)(a2 + 96) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)(a2 + 96), *(long long **)(v13 + 96), *(long long **)(v13 + 104), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v13 + 104) - *(void *)(v13 + 96)) >> 3));
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  uint64_t v14 = a2 + 120;
  *(void *)(v14 + 16) = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>((std::string *)v14, *(long long **)(v13 + 120), *(long long **)(v13 + 128), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v13 + 128) - *(void *)(v13 + 120)) >> 3));
  __n128 result = *(__n128 *)(v13 + 144);
  *(__n128 *)(v14 + 24) = result;
  return result;
}

void KB::LanguageModelContainer::PredictionEnumeratorContainer::~PredictionEnumeratorContainer(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  *(void *)this = &unk_1F3F738D0;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 32);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v2);

  JUMPOUT(0x1E4E7BC20);
}

{
  void **v1;
  void **v2;

  *(void *)this = &unk_1F3F738D0;
  uint64_t v1 = (void **)((char *)this + 8);
  uint64_t v2 = (void **)((char *)this + 32);
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v2);
  uint64_t v2 = v1;
  std::vector<std::shared_ptr<KB::LanguageModel>>::__destroy_vector::operator()[abi:nn180100](&v2);
}

uint64_t std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73900;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::LanguageModelContainer::PredictionEnumeratorContainer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73900;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t KB::LanguageModelContainer::clear_prediction_cache(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 472))(v3);
  }
  return this;
}

void KB::LanguageModelContainer::predictions(KB::LanguageModelContainer *a1, const KB::LanguageModelContext *a2, uint64_t a3, uint64_t a4)
{
  void v29[4] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  uint64_t v27 = 0;
  KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v18, a2);
  KB::LanguageModelContainer::update_context_with_predominant_locale(a1, (KB::LanguageModelContext *)&v18);
  float v7 = (uint64_t *)*((void *)a1 + 3);
  uint64_t v8 = (uint64_t *)*((void *)a1 + 4);
  if (v7 == v8)
  {
    long long v12 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    do
    {
      uint64_t v9 = *v7;
      v7 += 7;
      float v10 = operator new(0x20uLL);
      void *v10 = &unk_1F3F73938;
      v10[1] = &v25;
      void v10[2] = a1;
      void v10[3] = &v18;
      v29[3] = v10;
      (*(void (**)(uint64_t, void ***, uint64_t, void *))(*(void *)v9 + 464))(v9, &v18, a3, v29);
      std::__function::__value_func<void ()(KB::LanguageModel::PredictionInfo const&)>::~__value_func[abi:nn180100](v29);
    }
    while (v7 != v8);
    uint64_t v11 = v25;
    long long v12 = v26;
  }
  unint64_t v13 = 126 - 2 * __clz(0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v12 - v11) >> 5));
  if (v12 == (std::vector<std::string> *)v11) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = v13;
  }
  std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(v11, v12, v14, 1);
  uint64_t v15 = v25;
  unint64_t v16 = v26;
  while ((std::vector<std::string> *)v15 != v16)
  {
    uint64_t v17 = *(void *)(a4 + 24);
    if (!v17) {
      std::__throw_bad_function_call[abi:nn180100]();
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 48))(v17, v15);
    v15 += 160;
  }
  unint64_t v28 = (void **)&v24;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v28);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v23);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v22);
  if (__p)
  {
    int v21 = __p;
    operator delete(__p);
  }
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v19);
  }
  uint64_t v18 = (void **)&v25;
  std::vector<KB::LanguageModel::PredictionInfo>::__destroy_vector::operator()[abi:nn180100](&v18);
}

void std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(uint64_t a1, std::vector<std::string> *a2, uint64_t a3, char a4)
{
  float v7 = &v259;
  while (2)
  {
    unint64_t v8 = a1;
    p_std::__split_buffer<std::string>::pointer end = (uint64_t)&a2[-7].__end_;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = v8;
        uint64_t v10 = (uint64_t)a2 - v8;
        unint64_t v11 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)((uint64_t)a2 - v8) >> 5);
        a1 = v9;
        if (!(!v5 & v4))
        {
          switch(v11)
          {
            case 0uLL:
            case 1uLL:
              return;
            case 2uLL:
              if (*(float *)&a2[-6].__end_ <= *(float *)(v9 + 24)) {
                return;
              }
              int64x2_t v74 = (std::vector<std::string> *)v9;
              uint64_t v75 = (uint64_t)&a2[-7].__end_;
              break;
            case 3uLL:
              std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v9, (std::vector<std::string> *)(v9 + 160), p_end);
              return;
            case 4uLL:
              std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(v9, v9 + 160, v9 + 320, p_end);
              return;
            case 5uLL:
              double v76 = (std::vector<std::string> *)(v9 + 160);
              int64x2_t v77 = (std::vector<std::string> *)(v9 + 320);
              id v78 = (std::vector<std::string> *)(v9 + 480);
              std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(a1, a1 + 160, a1 + 320, a1 + 480);
              if (*(float *)&a2[-6].__end_ <= *(float *)(a1 + 504)) {
                return;
              }
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v78, p_end);
              if (*(float *)(a1 + 504) <= *(float *)(a1 + 344)) {
                return;
              }
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v77, (uint64_t)v78);
              if (*(float *)(a1 + 344) <= *(float *)(a1 + 184)) {
                return;
              }
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v76, (uint64_t)v77);
              if (*(float *)(a1 + 184) <= *(float *)(a1 + 24)) {
                return;
              }
              int64x2_t v74 = (std::vector<std::string> *)a1;
              uint64_t v75 = (uint64_t)v76;
              break;
            default:
              JUMPOUT(0);
          }
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v74, v75);
          return;
        }
        if (v10 <= 3839)
        {
          if (a4)
          {
            if ((std::vector<std::string> *)v9 != a2)
            {
              uint64_t v79 = v9 + 160;
              if ((std::vector<std::string> *)(v9 + 160) != a2)
              {
                uint64_t v80 = 0;
                uint64_t v81 = v9;
                do
                {
                  uint64_t v82 = v79;
                  if (*(float *)(v81 + 184) > *(float *)(v81 + 24))
                  {
                    long long v257 = *(_OWORD *)v79;
                    uint64_t v258 = *(void *)(v81 + 176);
                    *(void *)uint64_t v79 = 0;
                    *(void *)(v79 + 8) = 0;
                    *(void *)(v79 + 16) = 0;
                    long long v259 = *(_OWORD *)(v81 + 184);
                    int v260 = *(_DWORD *)(v81 + 200);
                    long long v261 = *(_OWORD *)(v81 + 208);
                    uint64_t v262 = *(void *)(v81 + 224);
                    *(void *)(v81 + 208) = 0;
                    *(void *)(v81 + 216) = 0;
                    long long __p = *(_OWORD *)(v81 + 232);
                    uint64_t v264 = *(void *)(v81 + 248);
                    *(void *)(v81 + 224) = 0;
                    *(void *)(v81 + 232) = 0;
                    *(void *)(v81 + 240) = 0;
                    *(void *)(v81 + 248) = 0;
                    long long v265 = *(_OWORD *)(v81 + 256);
                    uint64_t v83 = *(void *)(v81 + 272);
                    *(void *)(v81 + 256) = 0;
                    *(void *)(v81 + 264) = 0;
                    long long v267 = *(_OWORD *)(v81 + 280);
                    uint64_t v84 = *(void *)(v81 + 296);
                    uint64_t v266 = v83;
                    uint64_t v268 = v84;
                    *(void *)(v81 + 272) = 0;
                    *(void *)(v81 + 280) = 0;
                    *(void *)(v81 + 288) = 0;
                    *(void *)(v81 + 296) = 0;
                    uint64_t v85 = v80;
                    long long v269 = *(_OWORD *)(v81 + 304);
                    while (1)
                    {
                      uint64_t v86 = a1 + v85;
                      id v87 = *(void **)(a1 + v85 + 160);
                      if (v87)
                      {
                        *(void *)(v86 + 168) = v87;
                        operator delete(v87);
                        *(void *)(v86 + 176) = 0;
                      }
                      *(_OWORD *)(v86 + 160) = *(_OWORD *)v86;
                      *(void *)(v86 + 176) = *(void *)(v86 + 16);
                      *(void *)(v86 + 8) = 0;
                      *(void *)(v86 + 16) = 0;
                      *(void *)uint64_t v86 = 0;
                      *(_OWORD *)(v86 + 184) = *(_OWORD *)(v86 + 24);
                      *(_DWORD *)(v86 + 200) = *(_DWORD *)(v86 + 40);
                      id v88 = (void **)(v86 + 208);
                      if (*(char *)(v86 + 231) < 0) {
                        operator delete(*v88);
                      }
                      uint64_t v89 = a1 + v85;
                      *(_OWORD *)id v88 = *(_OWORD *)(v86 + 48);
                      *(void *)(v86 + 224) = *(void *)(v86 + 64);
                      *(unsigned char *)(a1 + v85 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                      *(unsigned char *)(v86 + 48) = 0;
                      CFTypeID v90 = (void **)(a1 + v85 + 232);
                      if (*(char *)(a1 + v85 + 255) < 0) {
                        operator delete(*v90);
                      }
                      *(_OWORD *)CFTypeID v90 = *(_OWORD *)(v89 + 72);
                      *(void *)(a1 + v85 + 248) = *(void *)(v89 + 88);
                      *(unsigned char *)(v89 + 95) = 0;
                      *(unsigned char *)(v89 + 72) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v89 + 256));
                      *(_OWORD *)(v89 + 256) = *(_OWORD *)(v89 + 96);
                      *(void *)(v89 + 272) = *(void *)(v89 + 112);
                      *(void *)(v89 + 104) = 0;
                      *(void *)(v89 + 112) = 0;
                      *(void *)(v89 + 96) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v89 + 280));
                      *(_OWORD *)(v89 + 280) = *(_OWORD *)(v89 + 120);
                      *(void *)(v89 + 296) = *(void *)(v89 + 136);
                      *(void *)(v89 + 128) = 0;
                      *(void *)(v89 + 136) = 0;
                      *(void *)(v89 + 120) = 0;
                      *(_OWORD *)(v89 + 304) = *(_OWORD *)(v89 + 144);
                      if (!v85) {
                        break;
                      }
                      uint64_t v91 = a1 + v85;
                      float v92 = *(float *)(a1 + v85 - 136);
                      v85 -= 160;
                      if (*(float *)&v259 <= v92)
                      {
                        uint64_t v93 = v91 + 24;
                        uint64_t v94 = v91 + 48;
                        uint64_t v95 = v91 + 72;
                        std::string v96 = (std::vector<std::string> *)(v91 + 96);
                        uint64_t v97 = (std::vector<std::string> *)(v91 + 120);
                        CFTypeRef v98 = (_OWORD *)(v91 + 144);
                        uint64_t v99 = a1 + v85 + 160;
                        goto LABEL_116;
                      }
                    }
                    uint64_t v93 = a1 + 24;
                    uint64_t v94 = a1 + 48;
                    uint64_t v99 = a1;
                    uint64_t v95 = a1 + 72;
                    std::string v96 = (std::vector<std::string> *)(a1 + 96);
                    uint64_t v97 = (std::vector<std::string> *)(a1 + 120);
                    CFTypeRef v98 = (_OWORD *)(a1 + 144);
LABEL_116:
                    CFTypeRef v100 = *(void **)v99;
                    if (*(void *)v99)
                    {
                      *(void *)(v99 + 8) = v100;
                      operator delete(v100);
                      *(void *)uint64_t v99 = 0;
                      *(void *)(v99 + 8) = 0;
                      *(void *)(v99 + 16) = 0;
                    }
                    *(_OWORD *)uint64_t v99 = v257;
                    *(void *)(v99 + 16) = v258;
                    long long v257 = 0uLL;
                    uint64_t v258 = 0;
                    long long v101 = v259;
                    *(_DWORD *)(v93 + 16) = v260;
                    *(_OWORD *)uint64_t v93 = v101;
                    if (*(char *)(v99 + 71) < 0) {
                      operator delete(*(void **)v94);
                    }
                    long long v102 = v261;
                    *(void *)(v94 + 16) = v262;
                    *(_OWORD *)uint64_t v94 = v102;
                    HIBYTE(v262) = 0;
                    LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                    if (*(char *)(v99 + 95) < 0) {
                      operator delete(*(void **)v95);
                    }
                    long long v103 = __p;
                    *(void *)(v95 + 16) = v264;
                    *(_OWORD *)uint64_t v95 = v103;
                    HIBYTE(v264) = 0;
                    LOBYTE(__p) = 0;
                    std::vector<std::string>::__vdeallocate(v96);
                    v96->__begin_ = (std::vector<std::string>::pointer)v265;
                    *(void *)(v99 + 104) = *((void *)&v265 + 1);
                    *(void *)(v99 + 112) = v266;
                    long long v265 = 0uLL;
                    uint64_t v266 = 0;
                    std::vector<std::string>::__vdeallocate(v97);
                    v97->__begin_ = (std::vector<std::string>::pointer)v267;
                    *(void *)(v99 + 128) = *((void *)&v267 + 1);
                    *(void *)(v99 + 136) = v268;
                    long long v267 = 0uLL;
                    uint64_t v268 = 0;
                    _OWORD *v98 = v269;
                    v242 = &v267;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                    v242 = &v265;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                    if (SHIBYTE(v264) < 0) {
                      operator delete((void *)__p);
                    }
                    if (SHIBYTE(v262) < 0) {
                      operator delete((void *)v261);
                    }
                    if ((void)v257)
                    {
                      *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
                      operator delete((void *)v257);
                    }
                  }
                  uint64_t v79 = v82 + 160;
                  v80 += 160;
                  uint64_t v81 = v82;
                }
                while ((std::vector<std::string> *)(v82 + 160) != a2);
              }
            }
          }
          else if ((std::vector<std::string> *)v9 != a2)
          {
            uint64_t v197 = v9 + 160;
            if ((std::vector<std::string> *)(v9 + 160) != a2)
            {
              do
              {
                uint64_t v198 = v197;
                uint64_t v199 = a1;
                if (*(float *)(a1 + 184) > *(float *)(a1 + 24))
                {
                  long long v257 = *(_OWORD *)v197;
                  uint64_t v258 = *(void *)(a1 + 176);
                  *(void *)uint64_t v197 = 0;
                  *(void *)(v197 + 8) = 0;
                  *(void *)(v197 + 16) = 0;
                  long long v259 = *(_OWORD *)(a1 + 184);
                  int v260 = *(_DWORD *)(a1 + 200);
                  long long v261 = *(_OWORD *)(a1 + 208);
                  uint64_t v262 = *(void *)(a1 + 224);
                  *(void *)(a1 + 208) = 0;
                  *(void *)(a1 + 216) = 0;
                  long long __p = *(_OWORD *)(a1 + 232);
                  uint64_t v264 = *(void *)(a1 + 248);
                  *(void *)(a1 + 224) = 0;
                  *(void *)(a1 + 232) = 0;
                  *(void *)(a1 + 240) = 0;
                  *(void *)(a1 + 248) = 0;
                  long long v265 = *(_OWORD *)(a1 + 256);
                  uint64_t v200 = *(void *)(a1 + 272);
                  *(void *)(a1 + 256) = 0;
                  *(void *)(a1 + 264) = 0;
                  long long v267 = *(_OWORD *)(a1 + 280);
                  uint64_t v201 = *(void *)(a1 + 296);
                  uint64_t v266 = v200;
                  uint64_t v268 = v201;
                  *(void *)(a1 + 272) = 0;
                  *(void *)(a1 + 280) = 0;
                  *(void *)(a1 + 288) = 0;
                  *(void *)(a1 + 296) = 0;
                  long long v269 = *(_OWORD *)(a1 + 304);
                  do
                  {
                    uint64_t v202 = v199;
                    CFTypeRef v203 = *(void **)(v199 + 160);
                    if (v203)
                    {
                      *(void *)(v199 + 168) = v203;
                      operator delete(v203);
                      *(void *)(v202 + 176) = 0;
                    }
                    *(_OWORD *)(v202 + 160) = *(_OWORD *)v202;
                    *(void *)(v202 + 176) = *(void *)(v202 + 16);
                    *(void *)(v202 + 8) = 0;
                    *(void *)(v202 + 16) = 0;
                    *(void *)uint64_t v202 = 0;
                    *(_OWORD *)(v202 + 184) = *(_OWORD *)(v202 + 24);
                    *(_DWORD *)(v202 + 200) = *(_DWORD *)(v202 + 40);
                    CFTypeRef v204 = (void **)(v202 + 208);
                    if (*(char *)(v202 + 231) < 0) {
                      operator delete(*v204);
                    }
                    *(_OWORD *)CFTypeRef v204 = *(_OWORD *)(v202 + 48);
                    *(void *)(v202 + 224) = *(void *)(v202 + 64);
                    *(unsigned char *)(v202 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                    *(unsigned char *)(v202 + 48) = 0;
                    CFTypeRef v205 = (void **)(v202 + 232);
                    if (*(char *)(v202 + 255) < 0) {
                      operator delete(*v205);
                    }
                    *(_OWORD *)CFTypeRef v205 = *(_OWORD *)(v202 + 72);
                    *(void *)(v202 + 248) = *(void *)(v202 + 88);
                    *(unsigned char *)(v202 + 95) = 0;
                    *(unsigned char *)(v202 + 72) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v202 + 256));
                    *(_OWORD *)(v202 + 256) = *(_OWORD *)(v202 + 96);
                    *(void *)(v202 + 272) = *(void *)(v202 + 112);
                    *(void *)(v202 + 104) = 0;
                    *(void *)(v202 + 112) = 0;
                    *(void *)(v202 + 96) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v202 + 280));
                    *(_OWORD *)(v202 + 280) = *(_OWORD *)(v202 + 120);
                    *(void *)(v202 + 296) = *(void *)(v202 + 136);
                    *(void *)(v202 + 128) = 0;
                    *(void *)(v202 + 136) = 0;
                    *(void *)(v202 + 120) = 0;
                    *(_OWORD *)(v202 + 304) = *(_OWORD *)(v202 + 144);
                    uint64_t v199 = v202 - 160;
                  }
                  while (*(float *)&v259 > *(float *)(v202 - 136));
                  CFTypeRef v206 = *(void **)v202;
                  if (*(void *)v202)
                  {
                    *(void *)(v202 + 8) = v206;
                    operator delete(v206);
                    *(void *)uint64_t v202 = 0;
                    *(void *)(v202 + 8) = 0;
                    *(void *)(v202 + 16) = 0;
                  }
                  CFTypeRef v207 = (void **)(v202 + 48);
                  *(_OWORD *)uint64_t v202 = v257;
                  *(void *)(v202 + 16) = v258;
                  uint64_t v258 = 0;
                  long long v257 = 0uLL;
                  long long v208 = v259;
                  *(_DWORD *)(v202 + 40) = v260;
                  *(_OWORD *)(v202 + 24) = v208;
                  if (*(char *)(v202 + 71) < 0) {
                    operator delete(*v207);
                  }
                  CFTypeRef v209 = (void **)(v202 + 72);
                  long long v210 = v261;
                  *(void *)(v202 + 64) = v262;
                  *(_OWORD *)CFTypeRef v207 = v210;
                  HIBYTE(v262) = 0;
                  LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                  if (*(char *)(v202 + 95) < 0) {
                    operator delete(*v209);
                  }
                  long long v211 = __p;
                  *(void *)(v202 + 88) = v264;
                  *(_OWORD *)CFTypeRef v209 = v211;
                  HIBYTE(v264) = 0;
                  LOBYTE(__p) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v202 + 96));
                  *(_OWORD *)(v202 + 96) = v265;
                  *(void *)(v202 + 112) = v266;
                  long long v265 = 0uLL;
                  uint64_t v266 = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v202 + 120));
                  *(_OWORD *)(v202 + 120) = v267;
                  *(void *)(v202 + 136) = v268;
                  long long v267 = 0uLL;
                  uint64_t v268 = 0;
                  *(_OWORD *)(v202 + 144) = v269;
                  v242 = &v267;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                  v242 = &v265;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                  if (SHIBYTE(v264) < 0) {
                    operator delete((void *)__p);
                  }
                  if (SHIBYTE(v262) < 0) {
                    operator delete((void *)v261);
                  }
                  if ((void)v257)
                  {
                    *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
                    operator delete((void *)v257);
                  }
                }
                uint64_t v197 = v198 + 160;
                a1 = v198;
              }
              while ((std::vector<std::string> *)(v198 + 160) != a2);
            }
          }
          return;
        }
        if (!a3)
        {
          if ((std::vector<std::string> *)v9 != a2)
          {
            int64_t v104 = (v11 - 2) >> 1;
            int64_t v105 = v104;
            uint64_t v106 = v9;
            do
            {
              int64_t v107 = v105;
              if (v104 >= v105)
              {
                uint64_t v108 = (2 * v105) | 1;
                uint64_t v109 = v106 + 160 * v108;
                if (2 * v107 + 2 < (uint64_t)v11 && *(float *)(v106 + 160 * v108 + 24) > *(float *)(v109 + 184))
                {
                  v109 += 160;
                  uint64_t v108 = 2 * v107 + 2;
                }
                uint64_t v110 = v106 + 160 * v107;
                float v112 = *(float *)(v110 + 24);
                CFTypeRef v111 = (long long *)(v110 + 24);
                if (*(float *)(v109 + 24) <= v112)
                {
                  uint64_t v113 = v106 + 160 * v107;
                  v236 = *(void **)v113;
                  *(void *)&long long v257 = *(void *)v113;
                  uint64_t v234 = *(void *)(v113 + 8);
                  *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v234;
                  uint64_t v258 = *(void *)(v113 + 16);
                  *(void *)uint64_t v113 = 0;
                  *(void *)(v113 + 8) = 0;
                  *(void *)(v113 + 16) = 0;
                  long long v114 = *v111;
                  int v260 = *((_DWORD *)v111 + 4);
                  long long v259 = v114;
                  long long v115 = *(_OWORD *)(v113 + 48);
                  uint64_t v262 = *(void *)(v113 + 64);
                  long long v261 = v115;
                  *(void *)(v113 + 56) = 0;
                  *(void *)(v113 + 64) = 0;
                  *(void *)(v113 + 48) = 0;
                  long long v116 = *(_OWORD *)(v113 + 72);
                  uint64_t v264 = *(void *)(v113 + 88);
                  long long __p = v116;
                  *(void *)(v113 + 80) = 0;
                  *(void *)(v113 + 88) = 0;
                  *(void *)(v113 + 72) = 0;
                  long long v265 = *(_OWORD *)(v113 + 96);
                  uint64_t v266 = *(void *)(v113 + 112);
                  *(void *)(v113 + 96) = 0;
                  *(void *)(v113 + 104) = 0;
                  *(void *)(v113 + 112) = 0;
                  long long v267 = *(_OWORD *)(v113 + 120);
                  uint64_t v268 = *(void *)(v113 + 136);
                  *(void *)(v113 + 128) = 0;
                  *(void *)(v113 + 136) = 0;
                  *(void *)(v113 + 120) = 0;
                  long long v269 = *(_OWORD *)(v113 + 144);
                  float v117 = *(float *)&v259;
                  do
                  {
                    uint64_t v118 = v109;
                    uint64_t v119 = *(void **)v113;
                    if (*(void *)v113)
                    {
                      *(void *)(v113 + 8) = v119;
                      operator delete(v119);
                      *(void *)uint64_t v113 = 0;
                      *(void *)(v113 + 8) = 0;
                      *(void *)(v113 + 16) = 0;
                    }
                    *(_OWORD *)uint64_t v113 = *(_OWORD *)v118;
                    *(void *)(v113 + 16) = *(void *)(v118 + 16);
                    *(void *)(v118 + 8) = 0;
                    *(void *)(v118 + 16) = 0;
                    *(void *)uint64_t v118 = 0;
                    long long v120 = *(_OWORD *)(v118 + 24);
                    *(_DWORD *)(v113 + 40) = *(_DWORD *)(v118 + 40);
                    *(_OWORD *)(v113 + 24) = v120;
                    CFTypeRef v121 = (void **)(v113 + 48);
                    if (*(char *)(v113 + 71) < 0) {
                      operator delete(*v121);
                    }
                    CFTypeRef v122 = (void **)(v118 + 48);
                    long long v123 = *(_OWORD *)(v118 + 48);
                    *(void *)(v113 + 64) = *(void *)(v118 + 64);
                    *(_OWORD *)CFTypeRef v121 = v123;
                    *(unsigned char *)(v118 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                    *(unsigned char *)(v118 + 48) = 0;
                    CFTypeRef v124 = (void **)(v113 + 72);
                    if (*(char *)(v113 + 95) < 0) {
                      operator delete(*v124);
                    }
                    long long v125 = *(_OWORD *)(v118 + 72);
                    *(void *)(v113 + 88) = *(void *)(v118 + 88);
                    *(_OWORD *)CFTypeRef v124 = v125;
                    *(unsigned char *)(v118 + 95) = 0;
                    *(unsigned char *)(v118 + 72) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v113 + 96));
                    *(_OWORD *)(v113 + 96) = *(_OWORD *)(v118 + 96);
                    *(void *)(v113 + 112) = *(void *)(v118 + 112);
                    *(void *)(v118 + 96) = 0;
                    *(void *)(v118 + 104) = 0;
                    *(void *)(v118 + 112) = 0;
                    std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v113 + 120));
                    *(_OWORD *)(v113 + 120) = *(_OWORD *)(v118 + 120);
                    *(void *)(v113 + 136) = *(void *)(v118 + 136);
                    *(void *)(v118 + 120) = 0;
                    *(void *)(v118 + 128) = 0;
                    *(void *)(v118 + 136) = 0;
                    *(_OWORD *)(v113 + 144) = *(_OWORD *)(v118 + 144);
                    if (v104 < v108) {
                      break;
                    }
                    uint64_t v126 = (2 * v108) | 1;
                    uint64_t v109 = a1 + 160 * v126;
                    if (2 * v108 + 2 < (uint64_t)v11 && *(float *)(a1 + 160 * v126 + 24) > *(float *)(v109 + 184))
                    {
                      v109 += 160;
                      uint64_t v126 = 2 * v108 + 2;
                    }
                    uint64_t v113 = v118;
                    uint64_t v108 = v126;
                  }
                  while (*(float *)(v109 + 24) <= v117);
                  CFTypeID v127 = *(void **)v118;
                  uint64_t v128 = v234;
                  if (*(void *)v118)
                  {
                    *(void *)(v118 + 8) = v127;
                    operator delete(v127);
                    *(void *)uint64_t v118 = 0;
                    *(void *)(v118 + 8) = 0;
                    *(void *)(v118 + 16) = 0;
                    uint64_t v128 = *((void *)&v257 + 1);
                  }
                  *(void *)uint64_t v118 = v236;
                  *(void *)(v118 + 8) = v128;
                  *(void *)(v118 + 16) = v258;
                  long long v257 = 0uLL;
                  uint64_t v258 = 0;
                  int v129 = v260;
                  *(_OWORD *)(v118 + 24) = v259;
                  *(_DWORD *)(v118 + 40) = v129;
                  if (*(char *)(v118 + 71) < 0) {
                    operator delete(*v122);
                  }
                  v130 = (void **)(v118 + 72);
                  long long v131 = v261;
                  *(void *)(v118 + 64) = v262;
                  *(_OWORD *)CFTypeRef v122 = v131;
                  HIBYTE(v262) = 0;
                  LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                  if (*(char *)(v118 + 95) < 0) {
                    operator delete(*v130);
                  }
                  long long v132 = __p;
                  *(void *)(v118 + 88) = v264;
                  *(_OWORD *)v130 = v132;
                  HIBYTE(v264) = 0;
                  LOBYTE(__p) = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v118 + 96));
                  *(_OWORD *)(v118 + 96) = v265;
                  *(void *)(v118 + 112) = v266;
                  long long v265 = 0uLL;
                  uint64_t v266 = 0;
                  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v118 + 120));
                  *(_OWORD *)(v118 + 120) = v267;
                  *(void *)(v118 + 136) = v268;
                  long long v267 = 0uLL;
                  uint64_t v268 = 0;
                  *(_OWORD *)(v118 + 144) = v269;
                  v242 = &v267;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                  v242 = &v265;
                  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
                  uint64_t v106 = a1;
                  if (SHIBYTE(v264) < 0) {
                    operator delete((void *)__p);
                  }
                  if (SHIBYTE(v262) < 0) {
                    operator delete((void *)v261);
                  }
                  if ((void)v257)
                  {
                    *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
                    operator delete((void *)v257);
                  }
                }
              }
              int64_t v105 = v107 - 1;
            }
            while (v107);
            int64_t v133 = v10 / 0xA0uLL;
            uint64_t v224 = v106 + 48;
            uint64_t v225 = v106 + 24;
            CFTypeRef v222 = (void *)(v106 + 96);
            uint64_t v223 = v106 + 72;
            CFTypeRef v220 = (long long *)(v106 + 144);
            CFTypeRef v221 = (void *)(v106 + 120);
            do
            {
              uint64_t v134 = 0;
              id v135 = a2;
              uint64_t v136 = a1;
              v237 = *(std::string **)(a1 + 8);
              v238 = *(std::string **)a1;
              v242 = *(void **)a1;
              v243 = v237;
              v230 = *(std::string **)(a1 + 16);
              v244 = v230;
              *(void *)(a1 + 8) = 0;
              *(void *)(a1 + 16) = 0;
              *(void *)a1 = 0;
              long long v137 = *(_OWORD *)v225;
              int v246 = *(_DWORD *)(v225 + 16);
              long long v245 = v137;
              long long v138 = *(_OWORD *)v224;
              v248 = *(std::string **)(v224 + 16);
              long long v247 = v138;
              *(void *)uint64_t v224 = 0;
              *(void *)(v224 + 8) = 0;
              *(void *)(v224 + 16) = 0;
              long long v139 = *(_OWORD *)v223;
              v250 = *(std::string **)(v223 + 16);
              long long v249 = v139;
              *(void *)uint64_t v223 = 0;
              *(void *)(v223 + 8) = 0;
              *(void *)(v223 + 16) = 0;
              long long v251 = *(_OWORD *)(a1 + 96);
              v252 = *(std::string **)(a1 + 112);
              *CFTypeRef v222 = 0;
              v222[1] = 0;
              v222[2] = 0;
              long long v253 = *(_OWORD *)(a1 + 120);
              v254 = *(std::string **)(a1 + 136);
              *CFTypeRef v221 = 0;
              v221[1] = 0;
              v221[2] = 0;
              long long v255 = *v220;
              do
              {
                uint64_t v140 = v134 + 1;
                uint64_t v141 = v136 + 160 * (v134 + 1);
                uint64_t v142 = 2 * v134;
                uint64_t v134 = (2 * v134) | 1;
                int64_t v143 = v142 + 2;
                if (v143 < v133 && *(float *)(v136 + 160 * v140 + 24) > *(float *)(v141 + 184))
                {
                  v141 += 160;
                  uint64_t v134 = v143;
                }
                CFTypeID v144 = *(void **)v136;
                if (*(void *)v136)
                {
                  *(void *)(v136 + 8) = v144;
                  operator delete(v144);
                  *(void *)uint64_t v136 = 0;
                  *(void *)(v136 + 8) = 0;
                  *(void *)(v136 + 16) = 0;
                }
                *(_OWORD *)uint64_t v136 = *(_OWORD *)v141;
                *(void *)(v136 + 16) = *(void *)(v141 + 16);
                *(void *)(v141 + 8) = 0;
                *(void *)(v141 + 16) = 0;
                *(void *)uint64_t v141 = 0;
                long long v145 = *(_OWORD *)(v141 + 24);
                *(_DWORD *)(v136 + 40) = *(_DWORD *)(v141 + 40);
                *(_OWORD *)(v136 + 24) = v145;
                id v146 = (void **)(v136 + 48);
                if (*(char *)(v136 + 71) < 0) {
                  operator delete(*v146);
                }
                v147 = (void **)(v141 + 48);
                long long v148 = *(_OWORD *)(v141 + 48);
                *(void *)(v136 + 64) = *(void *)(v141 + 64);
                *(_OWORD *)id v146 = v148;
                *(unsigned char *)(v141 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                *(unsigned char *)(v141 + 48) = 0;
                v149 = (void **)(v136 + 72);
                if (*(char *)(v136 + 95) < 0) {
                  operator delete(*v149);
                }
                long long v150 = *(_OWORD *)(v141 + 72);
                *(void *)(v136 + 88) = *(void *)(v141 + 88);
                *(_OWORD *)v149 = v150;
                *(unsigned char *)(v141 + 95) = 0;
                *(unsigned char *)(v141 + 72) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v136 + 96));
                *(_OWORD *)(v136 + 96) = *(_OWORD *)(v141 + 96);
                *(void *)(v136 + 112) = *(void *)(v141 + 112);
                *(void *)(v141 + 96) = 0;
                *(void *)(v141 + 104) = 0;
                *(void *)(v141 + 112) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v136 + 120));
                *(_OWORD *)(v136 + 120) = *(_OWORD *)(v141 + 120);
                *(void *)(v136 + 136) = *(void *)(v141 + 136);
                *(void *)(v141 + 120) = 0;
                *(void *)(v141 + 128) = 0;
                *(void *)(v141 + 136) = 0;
                *(_OWORD *)(v136 + 144) = *(_OWORD *)(v141 + 144);
                uint64_t v136 = v141;
              }
              while (v134 <= (uint64_t)((unint64_t)(v133 - 2) >> 1));
              id v151 = (_OWORD *)(v141 + 24);
              CFTypeID v152 = (void **)(v141 + 72);
              CFTypeID v153 = *(void **)v141;
              a2 = (std::vector<std::string> *)((char *)a2 - 160);
              if ((std::vector<std::string>::pointer *)v141 == &v135[-7].__end_)
              {
                CFTypeRef v192 = v237;
                if (v153)
                {
                  *(void *)(v141 + 8) = v153;
                  operator delete(v153);
                  *(void *)uint64_t v141 = 0;
                  *(void *)(v141 + 8) = 0;
                  *(void *)(v141 + 16) = 0;
                  CFTypeRef v192 = v243;
                }
                *(void *)uint64_t v141 = v238;
                *(void *)(v141 + 8) = v192;
                *(void *)(v141 + 16) = v244;
                v242 = 0;
                v243 = 0;
                v244 = 0;
                long long v193 = v245;
                *(_DWORD *)(v141 + 40) = v246;
                _OWORD *v151 = v193;
                if (*(char *)(v141 + 71) < 0) {
                  operator delete(*v147);
                }
                long long v194 = v247;
                *(void *)(v141 + 64) = v248;
                *(_OWORD *)v147 = v194;
                HIBYTE(v248) = 0;
                LOBYTE(v247) = 0;
                if (*(char *)(v141 + 95) < 0) {
                  operator delete(*v152);
                }
                long long v195 = v249;
                *(void *)(v141 + 88) = v250;
                *(_OWORD *)CFTypeID v152 = v195;
                HIBYTE(v250) = 0;
                LOBYTE(v249) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 96));
                *(_OWORD *)(v141 + 96) = v251;
                *(void *)(v141 + 112) = v252;
                long long v251 = 0uLL;
                v252 = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 120));
                *(_OWORD *)(v141 + 120) = v253;
                *(void *)(v141 + 136) = v254;
                long long v253 = 0uLL;
                v254 = 0;
                *(_OWORD *)(v141 + 144) = v255;
              }
              else
              {
                if (v153)
                {
                  *(void *)(v141 + 8) = v153;
                  operator delete(v153);
                  *(void *)uint64_t v141 = 0;
                  *(void *)(v141 + 8) = 0;
                  *(void *)(v141 + 16) = 0;
                }
                v228 = (long long *)(v141 + 144);
                *(_OWORD *)uint64_t v141 = *(_OWORD *)&v135[-7].__end_;
                *(void *)(v141 + 16) = v135[-6].__begin_;
                a2->__end_ = 0;
                a2->__end_cap_.__value_ = 0;
                a2->__begin_ = 0;
                long long v154 = *(_OWORD *)&v135[-6].__end_;
                *(_DWORD *)(v141 + 40) = v135[-5].__begin_;
                _OWORD *v151 = v154;
                if (*(char *)(v141 + 71) < 0) {
                  operator delete(*v147);
                }
                v226 = (float *)(v141 + 24);
                unsigned int v155 = (void **)&v135[-5].__end_;
                long long v156 = *(_OWORD *)&v135[-5].__end_;
                *(void *)(v141 + 64) = v135[-4].__begin_;
                *(_OWORD *)v147 = v156;
                HIBYTE(v135[-4].__begin_) = 0;
                LOBYTE(v135[-5].__end_) = 0;
                if (*(char *)(v141 + 95) < 0) {
                  operator delete(*v152);
                }
                long long v157 = *(_OWORD *)&v135[-4].__end_;
                *(void *)(v141 + 88) = v135[-3].__begin_;
                CFTypeRef v218 = (long long *)(v141 + 72);
                *(_OWORD *)CFTypeID v152 = v157;
                HIBYTE(v135[-3].__begin_) = 0;
                LOBYTE(v135[-4].__end_) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 96));
                *(_OWORD *)(v141 + 96) = *(_OWORD *)&v135[-3].__end_;
                *(void *)(v141 + 112) = v135[-2].__begin_;
                v135[-3].__end_ = 0;
                v135[-3].__end_cap_.__value_ = 0;
                v135[-2].__begin_ = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 120));
                CFTypeRef v158 = &v135[-2].__end_;
                *(_OWORD *)(v141 + 120) = *(_OWORD *)&v135[-2].__end_;
                *(void *)(v141 + 136) = v135[-1].__begin_;
                *CFTypeRef v158 = 0;
                v158[1] = 0;
                void v158[2] = 0;
                long long *v228 = *(_OWORD *)&v135[-1].__end_;
                std::__split_buffer<std::string>::pointer end = v135[-7].__end_;
                if (end)
                {
                  v135[-7].__end_cap_.__value_ = end;
                  operator delete(end);
                }
                int64_t v229 = v133;
                CFTypeRef v160 = &v135[-6].__end_;
                v135[-7].__end_ = v238;
                v135[-7].__end_cap_.__value_ = v237;
                v135[-6].__begin_ = v230;
                v243 = 0;
                v244 = 0;
                v242 = 0;
                long long v161 = v245;
                *((_DWORD *)v160 + 4) = v246;
                *(_OWORD *)CFTypeRef v160 = v161;
                if (SHIBYTE(v135[-4].__begin_) < 0) {
                  operator delete(*v155);
                }
                CFTypeRef v162 = (void **)&v135[-4].__end_;
                long long v163 = v247;
                v135[-4].__begin_ = v248;
                *(_OWORD *)unsigned int v155 = v163;
                HIBYTE(v248) = 0;
                LOBYTE(v247) = 0;
                if (SHIBYTE(v135[-3].__begin_) < 0) {
                  operator delete(*v162);
                }
                long long v164 = v249;
                v135[-3].__begin_ = v250;
                *(_OWORD *)CFTypeRef v162 = v164;
                HIBYTE(v250) = 0;
                LOBYTE(v249) = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)v135 - 64));
                *(_OWORD *)&v135[-3].__end_ = v251;
                v135[-2].__begin_ = v252;
                long long v251 = 0uLL;
                v252 = 0;
                std::vector<std::string>::__vdeallocate((std::vector<std::string> *)((char *)v135 - 40));
                *(_OWORD *)&v135[-2].__end_ = v253;
                v135[-1].__begin_ = v254;
                long long v253 = 0uLL;
                v254 = 0;
                *(_OWORD *)&v135[-1].__end_ = v255;
                uint64_t v165 = v141 + 160 - a1;
                int64_t v133 = v229;
                if (v165 >= 161)
                {
                  unint64_t v166 = (v165 / 0xA0uLL - 2) >> 1;
                  if (*(float *)(a1 + 160 * v166 + 24) > *v226)
                  {
                    uint64_t v214 = *(void *)v141;
                    *(void *)&long long v257 = *(void *)v141;
                    uint64_t v213 = *(void *)(v141 + 8);
                    *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v213;
                    uint64_t v212 = *(void *)(v141 + 16);
                    uint64_t v258 = v212;
                    *(void *)uint64_t v141 = 0;
                    *(void *)(v141 + 8) = 0;
                    *(void *)(v141 + 16) = 0;
                    long long v167 = *(_OWORD *)v226;
                    int v260 = *(_DWORD *)(v141 + 40);
                    long long v259 = v167;
                    long long v168 = *(_OWORD *)v147;
                    uint64_t v262 = *(void *)(v141 + 64);
                    long long v261 = v168;
                    *(void *)(v141 + 56) = 0;
                    *(void *)(v141 + 64) = 0;
                    void *v147 = 0;
                    long long v169 = *v218;
                    uint64_t v264 = *(void *)(v141 + 88);
                    long long __p = v169;
                    *(void *)(v141 + 80) = 0;
                    *(void *)(v141 + 88) = 0;
                    *(void *)CFTypeRef v218 = 0;
                    v231 = *(std::string **)(v141 + 96);
                    *(void *)&long long v265 = v231;
                    uint64_t v219 = *(void *)(v141 + 104);
                    *((void *)&v265 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v219;
                    uint64_t v216 = *(void *)(v141 + 112);
                    uint64_t v266 = v216;
                    *(void *)(v141 + 104) = 0;
                    *(void *)(v141 + 112) = 0;
                    *(void *)(v141 + 96) = 0;
                    v227 = *(std::string **)(v141 + 120);
                    *(void *)&long long v267 = v227;
                    uint64_t v217 = *(void *)(v141 + 128);
                    *((void *)&v267 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v217;
                    uint64_t v215 = *(void *)(v141 + 136);
                    uint64_t v268 = v215;
                    *(void *)(v141 + 128) = 0;
                    *(void *)(v141 + 136) = 0;
                    *(void *)(v141 + 120) = 0;
                    long long v269 = *v228;
                    float v170 = *(float *)&v259;
                    do
                    {
                      unint64_t v171 = v166;
                      CFTypeRef v172 = *(void **)v141;
                      if (*(void *)v141)
                      {
                        *(void *)(v141 + 8) = v172;
                        operator delete(v172);
                        *(void *)uint64_t v141 = 0;
                        *(void *)(v141 + 8) = 0;
                        *(void *)(v141 + 16) = 0;
                      }
                      uint64_t v173 = a1 + 160 * v171;
                      *(_OWORD *)uint64_t v141 = *(_OWORD *)v173;
                      *(void *)(v141 + 16) = *(void *)(v173 + 16);
                      *(void *)(v173 + 8) = 0;
                      *(void *)(v173 + 16) = 0;
                      *(void *)uint64_t v173 = 0;
                      long long v174 = *(_OWORD *)(v173 + 24);
                      *(_DWORD *)(v141 + 40) = *(_DWORD *)(v173 + 40);
                      *(_OWORD *)(v141 + 24) = v174;
                      CFTypeRef v175 = (void **)(v141 + 48);
                      if (*(char *)(v141 + 71) < 0) {
                        operator delete(*v175);
                      }
                      long long v176 = *(_OWORD *)(v173 + 48);
                      *(void *)(v141 + 64) = *(void *)(v173 + 64);
                      *(_OWORD *)CFTypeRef v175 = v176;
                      *(unsigned char *)(v173 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                      v239 = (void **)(v173 + 48);
                      *(unsigned char *)(v173 + 48) = 0;
                      CFTypeRef v177 = (void **)(v141 + 72);
                      if (*(char *)(v141 + 95) < 0) {
                        operator delete(*v177);
                      }
                      uint64_t v178 = a1 + 160 * v171;
                      long long v179 = *(_OWORD *)(v178 + 72);
                      *(void *)(v141 + 88) = *(void *)(v178 + 88);
                      *(_OWORD *)CFTypeRef v177 = v179;
                      *(unsigned char *)(v173 + 95) = 0;
                      *(unsigned char *)(v178 + 72) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 96));
                      CFTypeRef v180 = (std::vector<std::string> *)(v178 + 96);
                      *(_OWORD *)(v141 + 96) = *(_OWORD *)(v178 + 96);
                      CFTypeRef v181 = (void *)(v178 + 112);
                      *(void *)(v141 + 112) = *(void *)(v178 + 112);
                      *(void *)(v178 + 104) = 0;
                      *(void *)(v178 + 96) = 0;
                      *(void *)(v178 + 112) = 0;
                      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v141 + 120));
                      CFTypeRef v182 = (std::vector<std::string> *)(v178 + 120);
                      *(_OWORD *)(v141 + 120) = *(_OWORD *)(v178 + 120);
                      uint64_t v183 = v178 + 136;
                      *(void *)(v141 + 136) = *(void *)(v178 + 136);
                      *(void *)(v178 + 128) = 0;
                      *(void *)(v178 + 136) = 0;
                      *(void *)(v178 + 120) = 0;
                      *(_OWORD *)(v141 + 144) = *(_OWORD *)(v178 + 144);
                      if (!v171) {
                        break;
                      }
                      unint64_t v166 = (v171 - 1) >> 1;
                      uint64_t v141 = a1 + 160 * v171;
                    }
                    while (*(float *)(a1 + 160 * v166 + 24) > v170);
                    v184 = *(void **)v173;
                    if (*(void *)v173)
                    {
                      *(void *)(v173 + 8) = v184;
                      operator delete(v184);
                    }
                    *(void *)uint64_t v173 = v214;
                    *(void *)(v173 + 8) = v213;
                    *(void *)(v173 + 16) = v212;
                    uint64_t v258 = 0;
                    long long v257 = 0uLL;
                    long long v185 = v259;
                    *(_DWORD *)(v173 + 40) = v260;
                    *(_OWORD *)(v173 + 24) = v185;
                    if (*(char *)(v173 + 71) < 0) {
                      operator delete(*v239);
                    }
                    uint64_t v186 = v178 + 72;
                    long long v187 = v261;
                    *(void *)(v173 + 64) = v262;
                    *(_OWORD *)v239 = v187;
                    HIBYTE(v262) = 0;
                    LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
                    if (*(char *)(v173 + 95) < 0) {
                      operator delete(*(void **)v186);
                    }
                    long long v188 = __p;
                    uint64_t v189 = a1 + 160 * v171;
                    CFTypeRef v190 = (void *)(v189 + 104);
                    CFTypeRef v191 = (void *)(v189 + 128);
                    *(void *)(v186 + 16) = v264;
                    *(_OWORD *)uint64_t v186 = v188;
                    HIBYTE(v264) = 0;
                    LOBYTE(__p) = 0;
                    std::vector<std::string>::__vdeallocate(v180);
                    v180->__begin_ = v231;
                    *CFTypeRef v190 = v219;
                    *CFTypeRef v181 = v216;
                    long long v265 = 0uLL;
                    uint64_t v266 = 0;
                    std::vector<std::string>::__vdeallocate(v182);
                    v182->__begin_ = v227;
                    *CFTypeRef v191 = v217;
                    *(void *)uint64_t v183 = v215;
                    long long v267 = 0uLL;
                    uint64_t v268 = 0;
                    *(_OWORD *)(v183 + 8) = v269;
                    v256 = (void **)&v267;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v256);
                    v256 = (void **)&v265;
                    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v256);
                    if (SHIBYTE(v264) < 0) {
                      operator delete((void *)__p);
                    }
                    int64_t v133 = v229;
                    if (SHIBYTE(v262) < 0) {
                      operator delete((void *)v261);
                    }
                    if ((void)v257)
                    {
                      *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
                      operator delete((void *)v257);
                    }
                  }
                }
              }
              *(void *)&long long v257 = &v253;
              std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v257);
              *(void *)&long long v257 = &v251;
              std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v257);
              if (SHIBYTE(v250) < 0) {
                operator delete((void *)v249);
              }
              if (SHIBYTE(v248) < 0) {
                operator delete((void *)v247);
              }
              if (v242)
              {
                v243 = (std::string *)v242;
                operator delete(v242);
              }
            }
            while (v133-- > 2);
          }
          return;
        }
        long long v12 = (std::vector<std::string> *)(v9 + 160 * (v11 >> 1));
        if ((unint64_t)v10 > 0x5000)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v9, (std::vector<std::string> *)(v9 + 160 * (v11 >> 1)), p_end);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v9 + 160), (std::vector<std::string> *)(v9 + 160 * (v11 >> 1) - 160), (uint64_t)&a2[-14].__end_cap_);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v9 + 320), (std::vector<std::string> *)(v9 + 160 + 160 * (v11 >> 1)), (uint64_t)&a2[-20]);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v9 + 160 * (v11 >> 1) - 160), v12, v9 + 160 + 160 * (v11 >> 1));
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v9, (uint64_t)v12);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)(v9 + 160 * (v11 >> 1)), (std::vector<std::string> *)v9, p_end);
        }
        --a3;
        if ((a4 & 1) != 0 || *(float *)(v9 - 136) > *(float *)(v9 + 24)) {
          break;
        }
        long long v257 = *(_OWORD *)v9;
        uint64_t v258 = *(void *)(v9 + 16);
        *(void *)(v9 + 8) = 0;
        *(void *)(v9 + 16) = 0;
        *(void *)uint64_t v9 = 0;
        long long v47 = *(_OWORD *)(v9 + 24);
        *((_DWORD *)v7 + 4) = *(_DWORD *)(v9 + 40);
        *float v7 = v47;
        long long v48 = *(_OWORD *)(v9 + 48);
        uint64_t v262 = *(void *)(v9 + 64);
        long long v261 = v48;
        *(void *)(v9 + 48) = 0;
        *(void *)(v9 + 56) = 0;
        *(void *)(v9 + 64) = 0;
        long long v49 = *(_OWORD *)(v9 + 72);
        uint64_t v264 = *(void *)(v9 + 88);
        long long __p = v49;
        *(void *)(v9 + 72) = 0;
        *(void *)(v9 + 80) = 0;
        *(void *)(v9 + 88) = 0;
        long long v265 = *(_OWORD *)(v9 + 96);
        uint64_t v266 = *(void *)(v9 + 112);
        *(void *)(v9 + 96) = 0;
        long long v50 = *(_OWORD *)(v9 + 120);
        *(void *)(v9 + 104) = 0;
        *(void *)(v9 + 112) = 0;
        long long v267 = v50;
        uint64_t v268 = *(void *)(v9 + 136);
        *(void *)(v9 + 120) = 0;
        *(void *)(v9 + 128) = 0;
        *(void *)(v9 + 136) = 0;
        long long v269 = *(_OWORD *)(v9 + 144);
        float v51 = *(float *)&v259;
        if (*(float *)&v259 > *(float *)&a2[-6].__end_)
        {
          uint64_t v52 = v9;
          do
          {
            unint64_t v8 = v52 + 160;
            float v53 = *(float *)(v52 + 184);
            v52 += 160;
          }
          while (*(float *)&v259 <= v53);
        }
        else
        {
          unint64_t v54 = v9 + 160;
          do
          {
            unint64_t v8 = v54;
            if (v54 >= (unint64_t)a2) {
              break;
            }
            v54 += 160;
          }
          while (*(float *)&v259 <= *(float *)(v8 + 24));
        }
        unint64_t v55 = (unint64_t)a2;
        if (v8 < (unint64_t)a2)
        {
          uint64_t v56 = a2;
          do
          {
            unint64_t v55 = (unint64_t)&v56[-7].__end_;
            float v57 = *(float *)&v56[-6].__end_;
            uint64_t v56 = (std::vector<std::string> *)((char *)v56 - 160);
          }
          while (*(float *)&v259 > v57);
        }
        while (v8 < v55)
        {
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v8, v55);
          do
          {
            float v58 = *(float *)(v8 + 184);
            v8 += 160;
          }
          while (v51 <= v58);
          do
          {
            float v59 = *(float *)(v55 - 136);
            v55 -= 160;
          }
          while (v51 > v59);
        }
        id v60 = (void **)(v8 - 160);
        if (v8 - 160 != v9)
        {
          long long v61 = *(void **)v9;
          if (*(void *)v9)
          {
            *(void *)(v9 + 8) = v61;
            operator delete(v61);
            *(void *)uint64_t v9 = 0;
            *(void *)(v9 + 8) = 0;
            *(void *)(v9 + 16) = 0;
          }
          int v62 = v7;
          std::string::size_type v63 = (void **)(v9 + 48);
          *(_OWORD *)uint64_t v9 = *(_OWORD *)(v8 - 160);
          *(void *)(v9 + 16) = *(void *)(v8 - 144);
          *(void *)(v8 - 152) = 0;
          *(void *)(v8 - 144) = 0;
          *id v60 = 0;
          long long v64 = *(_OWORD *)(v8 - 136);
          *(_DWORD *)(v9 + 40) = *(_DWORD *)(v8 - 120);
          *(_OWORD *)(v9 + 24) = v64;
          if (*(char *)(v9 + 71) < 0) {
            operator delete(*v63);
          }
          long long v65 = (void **)(v9 + 72);
          long long v66 = *(_OWORD *)(v8 - 112);
          *(void *)(v9 + 64) = *(void *)(v8 - 96);
          *(_OWORD *)std::string::size_type v63 = v66;
          *(unsigned char *)(v8 - 89) = 0;
          *(unsigned char *)(v8 - 112) = 0;
          if (*(char *)(v9 + 95) < 0) {
            operator delete(*v65);
          }
          long long v67 = *(_OWORD *)(v8 - 88);
          *(void *)(v9 + 88) = *(void *)(v8 - 72);
          *(_OWORD *)long long v65 = v67;
          *(unsigned char *)(v8 - 65) = 0;
          *(unsigned char *)(v8 - 88) = 0;
          std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v9 + 96));
          *(_OWORD *)(v9 + 96) = *(_OWORD *)(v8 - 64);
          *(void *)(v9 + 112) = *(void *)(v8 - 48);
          *(void *)(v8 - 64) = 0;
          *(void *)(v8 - 56) = 0;
          *(void *)(v8 - 48) = 0;
          std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v9 + 120));
          *(_OWORD *)(v9 + 120) = *(_OWORD *)(v8 - 40);
          *(void *)(v9 + 136) = *(void *)(v8 - 24);
          *(void *)(v8 - 40) = 0;
          *(void *)(v8 - 32) = 0;
          *(void *)(v8 - 24) = 0;
          *(_OWORD *)(v9 + 144) = *(_OWORD *)(v8 - 16);
          float v7 = v62;
        }
        std::string::size_type v68 = *v60;
        if (*v60)
        {
          *(void *)(v8 - 152) = v68;
          operator delete(v68);
          *id v60 = 0;
          *(void *)(v8 - 152) = 0;
          *(void *)(v8 - 144) = 0;
        }
        *(_OWORD *)(v8 - 160) = v257;
        *(void *)(v8 - 144) = v258;
        uint64_t v258 = 0;
        long long v257 = 0uLL;
        long long v69 = *v7;
        *(_DWORD *)(v8 - 120) = *((_DWORD *)v7 + 4);
        *(_OWORD *)(v8 - 136) = v69;
        long long v70 = (void **)(v8 - 112);
        if (*(char *)(v8 - 89) < 0) {
          operator delete(*v70);
        }
        long long v71 = v261;
        *(void *)(v8 - 96) = v262;
        *(_OWORD *)long long v70 = v71;
        HIBYTE(v262) = 0;
        LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
        id v72 = (void **)(v8 - 88);
        if (*(char *)(v8 - 65) < 0) {
          operator delete(*v72);
        }
        long long v73 = __p;
        *(void *)(v8 - 72) = v264;
        *(_OWORD *)id v72 = v73;
        HIBYTE(v264) = 0;
        LOBYTE(__p) = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 - 64));
        *(_OWORD *)(v8 - 64) = v265;
        *(void *)(v8 - 48) = v266;
        long long v265 = 0uLL;
        uint64_t v266 = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 - 40));
        *(_OWORD *)(v8 - 40) = v267;
        *(void *)(v8 - 24) = v268;
        long long v267 = 0uLL;
        uint64_t v268 = 0;
        *(_OWORD *)(v8 - 16) = v269;
        v242 = &v267;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
        v242 = &v265;
        std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
        if (SHIBYTE(v264) < 0) {
          operator delete((void *)__p);
        }
        if (SHIBYTE(v262) < 0) {
          operator delete((void *)v261);
        }
        if ((void)v257)
        {
          *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
          operator delete((void *)v257);
        }
LABEL_51:
        a4 = 0;
      }
      long long v257 = *(_OWORD *)v9;
      uint64_t v258 = *(void *)(v9 + 16);
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      *(void *)uint64_t v9 = 0;
      uint64_t v13 = v9 + 24;
      long long v14 = *(_OWORD *)(v9 + 24);
      *((_DWORD *)v7 + 4) = *(_DWORD *)(v9 + 40);
      *float v7 = v14;
      uint64_t v15 = v9 + 48;
      long long v16 = *(_OWORD *)(v9 + 48);
      uint64_t v262 = *(void *)(v9 + 64);
      long long v261 = v16;
      *(void *)(v9 + 48) = 0;
      *(void *)(v9 + 56) = 0;
      *(void *)(v9 + 64) = 0;
      uint64_t v17 = v9 + 72;
      long long v18 = *(_OWORD *)(v9 + 72);
      uint64_t v264 = *(void *)(v9 + 88);
      long long __p = v18;
      *(void *)(v9 + 72) = 0;
      *(void *)(v9 + 80) = 0;
      *(void *)(v9 + 88) = 0;
      unint64_t v19 = (std::vector<std::string> *)(v9 + 96);
      long long v265 = *(_OWORD *)(v9 + 96);
      uint64_t v266 = *(void *)(v9 + 112);
      *(void *)(v9 + 96) = 0;
      unint64_t v20 = (std::vector<std::string> *)(v9 + 120);
      long long v21 = *(_OWORD *)(v9 + 120);
      *(void *)(v9 + 104) = 0;
      *(void *)(v9 + 112) = 0;
      long long v267 = v21;
      uint64_t v268 = *(void *)(v9 + 136);
      *(void *)(v9 + 120) = 0;
      *(void *)(v9 + 128) = 0;
      *(void *)(v9 + 136) = 0;
      uint64_t v22 = (_OWORD *)(v9 + 144);
      long long v269 = *(_OWORD *)(v9 + 144);
      unint64_t v23 = v9;
      float v24 = *(float *)&v259;
      do
      {
        unint64_t v25 = v23;
        v23 += 160;
      }
      while (*(float *)(v25 + 184) > *(float *)&v259);
      unint64_t v26 = a2;
      if (v25 == v9)
      {
        unint64_t v29 = a2;
        while (v23 < (unint64_t)v29)
        {
          unint64_t v27 = (unint64_t)&v29[-7].__end_;
          float v30 = *(float *)&v29[-6].__end_;
          unint64_t v29 = (std::vector<std::string> *)((char *)v29 - 160);
          if (v30 > *(float *)&v259) {
            goto LABEL_21;
          }
        }
        unint64_t v27 = (unint64_t)v29;
      }
      else
      {
        do
        {
          unint64_t v27 = (unint64_t)&v26[-7].__end_;
          float v28 = *(float *)&v26[-6].__end_;
          unint64_t v26 = (std::vector<std::string> *)((char *)v26 - 160);
        }
        while (v28 <= *(float *)&v259);
      }
LABEL_21:
      v235 = v22;
      uint64_t v31 = v15;
      unint64_t v8 = v23;
      if (v23 < v27)
      {
        unint64_t v32 = v27;
        do
        {
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)v8, v32);
          do
          {
            float v33 = *(float *)(v8 + 184);
            v8 += 160;
          }
          while (v33 > v24);
          do
          {
            float v34 = *(float *)(v32 - 136);
            v32 -= 160;
          }
          while (v34 <= v24);
        }
        while (v8 < v32);
      }
      unint64_t v35 = (void **)(v8 - 160);
      if (v8 - 160 != a1)
      {
        unint64_t v36 = *(std::string **)a1;
        if (*(void *)a1)
        {
          *(void *)(a1 + 8) = v36;
          operator delete(v36);
          *(void *)a1 = 0;
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
        }
        *(_OWORD *)a1 = *(_OWORD *)(v8 - 160);
        *(void *)(a1 + 16) = *(void *)(v8 - 144);
        *(void *)(v8 - 152) = 0;
        *(void *)(v8 - 144) = 0;
        *unint64_t v35 = 0;
        long long v37 = *(_OWORD *)(v8 - 136);
        *(_DWORD *)(v13 + 16) = *(_DWORD *)(v8 - 120);
        *(_OWORD *)uint64_t v13 = v37;
        if (*(char *)(a1 + 71) < 0) {
          operator delete(*(void **)v31);
        }
        long long v38 = *(_OWORD *)(v8 - 112);
        *(void *)(v31 + 16) = *(void *)(v8 - 96);
        *(_OWORD *)uint64_t v31 = v38;
        *(unsigned char *)(v8 - 89) = 0;
        *(unsigned char *)(v8 - 112) = 0;
        if (*(char *)(a1 + 95) < 0) {
          operator delete(*(void **)v17);
        }
        long long v39 = *(_OWORD *)(v8 - 88);
        *(void *)(v17 + 16) = *(void *)(v8 - 72);
        *(_OWORD *)uint64_t v17 = v39;
        *(unsigned char *)(v8 - 65) = 0;
        *(unsigned char *)(v8 - 88) = 0;
        std::vector<std::string>::__vdeallocate(v19);
        *(_OWORD *)(a1 + 96) = *(_OWORD *)(v8 - 64);
        *(void *)(a1 + 112) = *(void *)(v8 - 48);
        *(void *)(v8 - 64) = 0;
        *(void *)(v8 - 56) = 0;
        *(void *)(v8 - 48) = 0;
        std::vector<std::string>::__vdeallocate(v20);
        *(_OWORD *)(a1 + 120) = *(_OWORD *)(v8 - 40);
        *(void *)(a1 + 136) = *(void *)(v8 - 24);
        *(void *)(v8 - 40) = 0;
        *(void *)(v8 - 32) = 0;
        *(void *)(v8 - 24) = 0;
        _OWORD *v235 = *(_OWORD *)(v8 - 16);
      }
      unint64_t v40 = *v35;
      if (*v35)
      {
        *(void *)(v8 - 152) = v40;
        operator delete(v40);
        *unint64_t v35 = 0;
        *(void *)(v8 - 152) = 0;
        *(void *)(v8 - 144) = 0;
      }
      *(_OWORD *)(v8 - 160) = v257;
      *(void *)(v8 - 144) = v258;
      uint64_t v258 = 0;
      long long v257 = 0uLL;
      float v7 = &v259;
      long long v41 = v259;
      *(_DWORD *)(v8 - 120) = v260;
      *(_OWORD *)(v8 - 136) = v41;
      long long v42 = (void **)(v8 - 112);
      if (*(char *)(v8 - 89) < 0) {
        operator delete(*v42);
      }
      long long v43 = v261;
      *(void *)(v8 - 96) = v262;
      *(_OWORD *)long long v42 = v43;
      HIBYTE(v262) = 0;
      LOBYTE(v26TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
      uint64_t v44 = (void **)(v8 - 88);
      if (*(char *)(v8 - 65) < 0) {
        operator delete(*v44);
      }
      long long v45 = __p;
      *(void *)(v8 - 72) = v264;
      *(_OWORD *)uint64_t v44 = v45;
      HIBYTE(v264) = 0;
      LOBYTE(__p) = 0;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 - 64));
      *(_OWORD *)(v8 - 64) = v265;
      *(void *)(v8 - 48) = v266;
      long long v265 = 0uLL;
      uint64_t v266 = 0;
      std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(v8 - 40));
      *(_OWORD *)(v8 - 40) = v267;
      *(void *)(v8 - 24) = v268;
      long long v267 = 0uLL;
      uint64_t v268 = 0;
      *(_OWORD *)(v8 - 16) = v269;
      v242 = &v267;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
      v242 = &v265;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v242);
      if (SHIBYTE(v264) < 0) {
        operator delete((void *)__p);
      }
      if (SHIBYTE(v262) < 0) {
        operator delete((void *)v261);
      }
      if ((void)v257)
      {
        *((void *)&v257 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v257;
        operator delete((void *)v257);
      }
      if (v23 < v27)
      {
LABEL_50:
        std::__introsort<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*,false>(a1, v8 - 160, a3, a4 & 1);
        goto LABEL_51;
      }
      BOOL v46 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)a1, (std::vector<std::string> *)(v8 - 160));
      if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)v8, a2))
      {
        break;
      }
      if (!v46) {
        goto LABEL_50;
      }
    }
    a2 = (std::vector<std::string> *)(v8 - 160);
    if (!v46) {
      continue;
    }
    break;
  }
}

float std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::operator()(void *a1, uint64_t a2)
{
  char v5 = (uint64_t *)a1[1];
  uint64_t v4 = a1[2];
  unint64_t v6 = v5[1];
  unint64_t v7 = v5[2];
  if (v6 >= v7)
  {
    unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v6 - *v5) >> 5);
    if (v9 + 1 > 0x199999999999999) {
      abort();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - *v5) >> 5);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= v9 + 1) {
      uint64_t v11 = v9 + 1;
    }
    if (v10 >= 0xCCCCCCCCCCCCCCLL) {
      unint64_t v12 = 0x199999999999999;
    }
    else {
      unint64_t v12 = v11;
    }
    long long v21 = v5 + 2;
    if (v12) {
      unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModel::PredictionInfo>>(v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v17 = v12;
    uint64_t v18 = v12 + 160 * v9;
    unint64_t v20 = v12 + 160 * v13;
    std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v18, a2);
    uint64_t v19 = v18 + 160;
    std::vector<KB::LanguageModel::PredictionInfo>::__swap_out_circular_buffer(v5, &v17);
    uint64_t v8 = v5[1];
    std::__split_buffer<KB::LanguageModel::PredictionInfo>::~__split_buffer((uint64_t)&v17);
  }
  else
  {
    uint64_t v8 = std::construct_at[abi:nn180100]<KB::LanguageModel::PredictionInfo,KB::LanguageModel::PredictionInfo const&,KB::LanguageModel::PredictionInfo*>(v6, a2)+ 160;
  }
  v5[1] = v8;
  float v14 = (*(float (**)(uint64_t, void, void))(*(void *)v4 + 456))(v4, *(unsigned int *)(a2 + 144), a1[3]);
  uint64_t v15 = *(void *)(a1[1] + 8);
  float result = v14 * *(float *)(v15 - 136);
  *(float *)(v15 - 136) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73938;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F73938;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0,std::allocator<KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_0>,void ()(KB::LanguageModel::PredictionInfo const&)>::~__func()
{
}

void std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(std::vector<std::string> *this, uint64_t a2)
{
  std::vector<std::string>::pointer end = this->__end_;
  std::vector<std::string>::pointer begin = this->__begin_;
  value = this->__end_cap_.__value_;
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  long long v28 = *(_OWORD *)&this[1].__begin_;
  int v29 = (int)this[1].__end_cap_.__value_;
  uint64_t v4 = this + 2;
  std::vector<std::string> v30 = this[2];
  this[2].__begin_ = 0;
  this[2].__end_ = 0;
  char v5 = this[3].__end_cap_.__value_;
  *(_OWORD *)long long __p = *(_OWORD *)&this[3].__begin_;
  this[2].__end_cap_.__value_ = 0;
  this[3].__begin_ = 0;
  unint64_t v7 = this + 4;
  std::vector<std::string>::pointer v6 = this[4].__begin_;
  this[3].__end_ = 0;
  this[3].__end_cap_.__value_ = 0;
  unint64_t v32 = v5;
  std::vector<std::string>::pointer v33 = v6;
  std::vector<std::string>::pointer v26 = v6;
  uint64_t v22 = this[4].__end_cap_.__value_;
  std::vector<std::string>::pointer v23 = this[4].__end_;
  std::vector<std::string>::pointer v34 = v23;
  unint64_t v35 = v22;
  this[4].__begin_ = 0;
  unint64_t v9 = this + 5;
  std::vector<std::string>::pointer v8 = this[5].__begin_;
  this[4].__end_ = 0;
  this[4].__end_cap_.__value_ = 0;
  std::vector<std::string>::pointer v10 = this[5].__end_;
  uint64_t v11 = this[5].__end_cap_.__value_;
  std::vector<std::string>::pointer v27 = v8;
  std::vector<std::string>::pointer v36 = v8;
  std::vector<std::string>::pointer v37 = v10;
  float v24 = v11;
  std::vector<std::string>::pointer v25 = v10;
  long long v38 = v11;
  this[5].__begin_ = 0;
  this[5].__end_ = 0;
  this[5].__end_cap_.__value_ = 0;
  long long v39 = *(_OWORD *)&this[6].__begin_;
  *this = *(std::vector<std::string> *)a2;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  long long v12 = *(_OWORD *)(a2 + 24);
  LODWORD(this[1].__end_cap_.__value_) = *(_DWORD *)(a2 + 40);
  *(_OWORD *)&this[1].__begin_ = v12;
  uint64_t v13 = (long long *)(a2 + 48);
  if (SHIBYTE(this[2].__end_cap_.__value_) < 0) {
    operator delete(v4->__begin_);
  }
  float v14 = this + 3;
  long long v15 = *v13;
  v4->__end_cap_.__value_ = (std::string *)*((void *)v13 + 2);
  *(_OWORD *)&v4->__begin_ = v15;
  *(unsigned char *)(a2 + 7TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *(unsigned char *)(a2 + 48) = 0;
  if (SHIBYTE(this[3].__end_cap_.__value_) < 0) {
    operator delete(v14->__begin_);
  }
  long long v16 = *(_OWORD *)(a2 + 72);
  this[3].__end_cap_.__value_ = *(std::string **)(a2 + 88);
  *(_OWORD *)&v14->__begin_ = v16;
  *(unsigned char *)(a2 + 95) = 0;
  *(unsigned char *)(a2 + 72) = 0;
  std::vector<std::string>::__vdeallocate(v7);
  *(_OWORD *)&this[4].__begin_ = *(_OWORD *)(a2 + 96);
  this[4].__end_cap_.__value_ = *(std::string **)(a2 + 112);
  *(void *)(a2 + 96) = 0;
  *(void *)(a2 + 104) = 0;
  *(void *)(a2 + 112) = 0;
  std::vector<std::string>::__vdeallocate(v9);
  *(_OWORD *)&this[5].__begin_ = *(_OWORD *)(a2 + 120);
  this[5].__end_cap_.__value_ = *(std::string **)(a2 + 136);
  *(void *)(a2 + 120) = 0;
  *(void *)(a2 + 128) = 0;
  *(void *)(a2 + 136) = 0;
  *(_OWORD *)&this[6].__begin_ = *(_OWORD *)(a2 + 144);
  unint64_t v17 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v17;
    operator delete(v17);
  }
  *(void *)a2 = begin;
  *(void *)(a2 + 8) = end;
  *(void *)(a2 + 16) = value;
  *(_OWORD *)(a2 + 24) = v28;
  *(_DWORD *)(a2 + 40) = v29;
  if (*(char *)(a2 + 71) < 0) {
    operator delete(*(void **)v13);
  }
  uint64_t v18 = (void **)(a2 + 72);
  *(std::vector<std::string> *)uint64_t v13 = v30;
  if (*(char *)(a2 + 95) < 0) {
    operator delete(*v18);
  }
  *(_OWORD *)uint64_t v18 = *(_OWORD *)__p;
  *(void *)(a2 + 88) = v32;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a2 + 96));
  *(void *)(a2 + 96) = v26;
  *(void *)(a2 + 104) = v23;
  *(void *)(a2 + 112) = v22;
  std::vector<std::string>::pointer v34 = 0;
  unint64_t v35 = 0;
  std::vector<std::string>::pointer v33 = 0;
  std::vector<std::string>::__vdeallocate((std::vector<std::string> *)(a2 + 120));
  *(void *)(a2 + 120) = v27;
  *(void *)(a2 + 128) = v25;
  *(void *)(a2 + 136) = v24;
  std::vector<std::string>::pointer v37 = 0;
  long long v38 = 0;
  std::vector<std::string>::pointer v36 = 0;
  *(_OWORD *)(a2 + 144) = v39;
  v40[0] = (void **)&v36;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v40);
  v40[0] = (void **)&v33;
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v40);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(std::vector<std::string> *this, std::vector<std::string> *a2, uint64_t a3)
{
  char v5 = this;
  float v6 = *(float *)&a2[1].__begin_;
  float v7 = *(float *)(a3 + 24);
  if (v6 <= *(float *)&this[1].__begin_)
  {
    if (v7 <= v6) {
      return;
    }
    std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(a2, a3);
    if (*(float *)&a2[1].__begin_ <= *(float *)&v5[1].__begin_) {
      return;
    }
    this = v5;
    std::vector<std::string>::pointer v8 = a2;
  }
  else
  {
    if (v7 <= v6)
    {
      std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this, (uint64_t)a2);
      if (*(float *)(a3 + 24) <= *(float *)&a2[1].__begin_) {
        return;
      }
      this = a2;
    }
    std::vector<std::string>::pointer v8 = (std::vector<std::string> *)a3;
  }

  std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this, (uint64_t)v8);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((std::vector<std::string> *)a1, (std::vector<std::string> *)a2, a3);
  if (*(float *)(a4 + 24) > *(float *)(a3 + 24))
  {
    std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a3, a4);
    if (*(float *)(a3 + 24) > *(float *)(a2 + 24))
    {
      std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a2, a3);
      if (*(float *)(a2 + 24) > *(float *)(a1 + 24))
      {
        std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)a1, a2);
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(std::vector<std::string> *this, std::vector<std::string> *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = ((char *)a2 - (char *)this) >> 5;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(float *)&a2[-6].__end_ > *(float *)&this[1].__begin_)
      {
        p_std::vector<std::string>::pointer end = (std::__compressed_pair<std::string *> *)&a2[-7].__end_;
        float v7 = this;
        goto LABEL_4;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(this, (std::vector<std::string> *)((char *)this + 160), (uint64_t)&a2[-7].__end_);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((uint64_t)this, (uint64_t)&this[6].__end_cap_, (uint64_t)&this[13].__end_, (uint64_t)&a2[-7].__end_);
      return 1;
    case 5uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>((uint64_t)this, (uint64_t)&this[6].__end_cap_, (uint64_t)&this[13].__end_, (uint64_t)&this[20]);
      if (*(float *)&v2[-6].__end_ > *(float *)&this[21].__begin_)
      {
        std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(this + 20, (uint64_t)&v2[-7].__end_);
        if (*(float *)&this[21].__begin_ > *(float *)&this[14].__end_)
        {
          std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)((char *)this + 320), (uint64_t)&this[20]);
          if (*(float *)&this[14].__end_ > *(float *)&this[7].__end_cap_.__value_)
          {
            std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>((std::vector<std::string> *)((char *)this + 160), (uint64_t)&this[13].__end_);
            if (*(float *)&this[7].__end_cap_.__value_ > *(float *)&this[1].__begin_)
            {
              float v7 = this;
              p_std::vector<std::string>::pointer end = &this[6].__end_cap_;
LABEL_4:
              std::swap[abi:nn180100]<KB::LanguageModel::PredictionInfo>(v7, (uint64_t)p_end);
            }
          }
        }
      }
      return 1;
    default:
      std::vector<std::string>::pointer v8 = (std::vector<std::string> *)((char *)this + 320);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,KB::LanguageModelContainer::predictions(KB::LanguageModelContext const&,unsigned long,std::function<void ()(KB::LanguageModel::PredictionInfo const&)>)::$_1 &,KB::LanguageModel::PredictionInfo*>(this, (std::vector<std::string> *)((char *)this + 160), (uint64_t)&this[13].__end_);
      unint64_t v9 = this + 20;
      if (&this[20] == v2) {
        return 1;
      }
      uint64_t v10 = 0;
      int v11 = 0;
      unint64_t v32 = v2;
      break;
  }
  while (1)
  {
    if (*(float *)&v9[1].__begin_ > *(float *)&v8[1].__begin_)
    {
      *(_OWORD *)std::vector<std::string>::pointer v34 = *(_OWORD *)&v9->__begin_;
      value = v9->__end_cap_.__value_;
      v9->__end_ = 0;
      v9->__end_cap_.__value_ = 0;
      v9->__begin_ = 0;
      long long v36 = *(_OWORD *)&v9[1].__begin_;
      int v37 = (int)v9[1].__end_cap_.__value_;
      long long v38 = *(_OWORD *)&v9[2].__begin_;
      long long v39 = v9[2].__end_cap_.__value_;
      v9[2].__begin_ = 0;
      v9[2].__end_ = 0;
      long long v41 = v9[3].__end_cap_.__value_;
      long long __p = *(_OWORD *)&v9[3].__begin_;
      v9[2].__end_cap_.__value_ = 0;
      v9[3].__begin_ = 0;
      v9[3].__end_ = 0;
      v9[3].__end_cap_.__value_ = 0;
      long long v42 = *(_OWORD *)&v9[4].__begin_;
      long long v43 = v9[4].__end_cap_.__value_;
      v9[4].__begin_ = 0;
      v9[4].__end_ = 0;
      long long v44 = *(_OWORD *)&v9[5].__begin_;
      long long v45 = v9[5].__end_cap_.__value_;
      v9[4].__end_cap_.__value_ = 0;
      v9[5].__begin_ = 0;
      v9[5].__end_ = 0;
      v9[5].__end_cap_.__value_ = 0;
      uint64_t v12 = v10;
      long long v46 = *(_OWORD *)&v9[6].__begin_;
      while (1)
      {
        uint64_t v13 = (char *)this + v12;
        float v14 = *(std::vector<std::string>::pointer *)((char *)&this[20].__begin_ + v12);
        if (v14)
        {
          *((void *)v13 + 6TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v14;
          operator delete(v14);
          *((void *)v13 + 62) = 0;
        }
        *((_OWORD *)v13 + 30) = *((_OWORD *)v13 + 20);
        *((void *)v13 + 62) = *((void *)v13 + 42);
        *((void *)v13 + 40) = 0;
        *((void *)v13 + 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
        *((void *)v13 + 42) = 0;
        *((_DWORD *)v13 + 130) = *((_DWORD *)v13 + 90);
        *(_OWORD *)(v13 + 504) = *(_OWORD *)(v13 + 344);
        long long v15 = v13 + 528;
        if (v13[551] < 0) {
          operator delete(*(void **)v15);
        }
        long long v16 = v13 + 368;
        unint64_t v17 = (char *)this + v12;
        *(_OWORD *)long long v15 = *(_OWORD *)v16;
        *((void *)v15 + 2) = *((void *)v16 + 2);
        *((unsigned char *)&this[16].__begin_ + v12 + 7) = 0;
        *long long v16 = 0;
        uint64_t v18 = (void **)((char *)&this[23].__begin_ + v12);
        if (*((char *)&this[23].__end_cap_.__value_ + v12 + 7) < 0) {
          operator delete(*v18);
        }
        *(std::string **)((char *)&this[23].__end_cap_.__value_ + v12) = (std::string *)*((void *)v17 + 51);
        *(_OWORD *)uint64_t v18 = *(_OWORD *)(v17 + 392);
        v17[415] = 0;
        v17[392] = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)v17 + 24);
        *((_OWORD *)v17 + 36) = *((_OWORD *)v17 + 26);
        *((void *)v17 + 74) = *((void *)v17 + 54);
        *((void *)v17 + 53) = 0;
        *((void *)v17 + 54) = 0;
        *((void *)v17 + 52) = 0;
        std::vector<std::string>::__vdeallocate((std::vector<std::string> *)v17 + 25);
        *(_OWORD *)(v17 + 600) = *(_OWORD *)(v17 + 440);
        *((void *)v17 + 77) = *((void *)v17 + 57);
        *((void *)v17 + 56) = 0;
        *((void *)v17 + 57) = 0;
        *((void *)v17 + 55) = 0;
        *((_OWORD *)v17 + 39) = *((_OWORD *)v17 + 29);
        if (v12 == -320) {
          break;
        }
        uint64_t v19 = (char *)this + v12;
        float v20 = *(float *)((char *)&this[7].__end_cap_.__value_ + v12);
        v12 -= 160;
        if (*(float *)&v36 <= v20)
        {
          long long v21 = (std::vector<std::string> *)(v19 + 344);
          uint64_t v22 = (std::vector<std::string> *)(v19 + 368);
          std::vector<std::string>::pointer v23 = (std::vector<std::string> *)((char *)this + v12 + 480);
          std::vector<std::string>::pointer v33 = (std::vector<std::string> *)(v19 + 464);
          float v24 = (std::vector<std::string> *)(v19 + 392);
          std::vector<std::string>::pointer v25 = (std::vector<std::string> *)(v19 + 440);
          std::vector<std::string>::pointer v26 = (std::vector<std::string> *)(v19 + 416);
          goto LABEL_20;
        }
      }
      long long v21 = this + 1;
      uint64_t v22 = this + 2;
      std::vector<std::string>::pointer v33 = this + 6;
      float v24 = this + 3;
      std::vector<std::string>::pointer v25 = this + 5;
      std::vector<std::string>::pointer v26 = this + 4;
      std::vector<std::string>::pointer v23 = this;
LABEL_20:
      std::vector<std::string>::pointer begin = v23->__begin_;
      if (v23->__begin_)
      {
        v23->__end_ = begin;
        operator delete(begin);
        v23->__begin_ = 0;
        v23->__end_ = 0;
        v23->__end_cap_.__value_ = 0;
      }
      *(_OWORD *)&v23->__begin_ = *(_OWORD *)v34;
      v23->__end_cap_.__value_ = value;
      *(_OWORD *)&v21->__begin_ = v36;
      LODWORD(v21->__end_cap_.__value_) = v37;
      if (SHIBYTE(v23[2].__end_cap_.__value_) < 0) {
        operator delete(v22->__begin_);
      }
      v22->__end_cap_.__value_ = v39;
      *(_OWORD *)&v22->__begin_ = v38;
      if (SHIBYTE(v23[3].__end_cap_.__value_) < 0) {
        operator delete(v24->__begin_);
      }
      *(_OWORD *)&v24->__begin_ = __p;
      v24->__end_cap_.__value_ = v41;
      std::vector<std::string>::__vdeallocate(v26);
      long long v28 = (std::string *)*((void *)&v42 + 1);
      v26->__begin_ = (std::vector<std::string>::pointer)v42;
      int v29 = v43;
      v23[4].__end_ = v28;
      v23[4].__end_cap_.__value_ = v29;
      long long v42 = 0uLL;
      long long v43 = 0;
      std::vector<std::string>::__vdeallocate(v25);
      std::vector<std::string> v30 = (std::string *)*((void *)&v44 + 1);
      v25->__begin_ = (std::vector<std::string>::pointer)v44;
      uint64_t v31 = v45;
      v23[5].__end_ = v30;
      v23[5].__end_cap_.__value_ = v31;
      long long v45 = 0;
      long long v44 = 0uLL;
      *(_OWORD *)&v33->__begin_ = v46;
      v47[0] = (void **)&v44;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v47);
      v47[0] = (void **)&v42;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v47);
      uint64_t v2 = v32;
      if (++v11 == 8) {
        return &v9[6].__end_cap_ == (std::__compressed_pair<std::string *> *)v32;
      }
    }
    std::vector<std::string>::pointer v8 = v9;
    v10 += 160;
    unint64_t v9 = (std::vector<std::string> *)((char *)v9 + 160);
    if (v9 == v2) {
      return 1;
    }
  }
}

float KB::LanguageModelContainer::probability_of_lexicon_given_context(KB::LanguageModelContainer *this, unsigned int a2, const KB::LanguageModelContext *a3)
{
  uint64_t v6 = *((void *)this + 3);
  if (*((void *)this + 4) - v6 != 56 || (float v7 = 1.0, *(_DWORD *)(v6 + 40) != 1))
  {
    uint64_t v8 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
    if (v8 == -1)
    {
      if (a2) {
        return 0.0;
      }
      else {
        return 0.04;
      }
    }
    else
    {
      uint64_t v9 = v8;
      uint64_t v33 = 0;
      std::vector<std::string>::pointer v34 = (float *)&v33;
      uint64_t v35 = 0x2020000000;
      int v36 = 0;
      uint64_t v29 = 0;
      std::vector<std::string> v30 = (float *)&v29;
      uint64_t v31 = 0x2020000000;
      int v32 = 0;
      uint64_t v25 = 0;
      std::vector<std::string>::pointer v26 = &v25;
      uint64_t v27 = 0x2020000000;
      uint64_t v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      _OWORD v22[2] = ___ZNK2KB22LanguageModelContainer36probability_of_lexicon_given_contextEjRKNS_20LanguageModelContextE_block_invoke;
      void v22[3] = &unk_1E6E2A810;
      v22[4] = &v25;
      v22[5] = &v33;
      int v23 = 1059648963;
      unsigned int v24 = a2;
      v22[6] = &v29;
      v22[7] = this;
      v22[8] = v8;
      v22[9] = 4;
      uint64_t v10 = v22;
      if (!enumerate_context_backwards((uint64_t)a3, (uint64_t)v10))
      {
        int v11 = *(uint64_t **)a3;
        uint64_t v12 = (std::__shared_weak_count *)*((void *)a3 + 1);
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v11)
        {
          uint64_t v13 = *v11;
          uint64_t v14 = v11[1];
          while (v13 != v14 && !enumerate_context_backwards(v13, (uint64_t)v10))
            v13 += 104;
        }
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:nn180100](v12);
        }
      }

      long long v15 = v26 + 3;
      if (v26[3])
      {
        float v16 = v30[6];
      }
      else
      {
        do
        {
          *long long v15 = 1;
          unsigned char v34[6] = v34[6] + 1.0;
          float v17 = KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * v9), a2);
          float v16 = v17 + v30[6];
          unsigned char v30[6] = v16;
          long long v15 = v26 + 3;
        }
        while (!v26[3]);
      }
      float v18 = v34[6];
      if (v18 <= 0.0) {
        float v18 = 1.0;
      }
      float v19 = v16 / v18;
      float v20 = (float)(KB::LanguageModelContainer::lexicon_stationary_probability(this, a2) * (float)(v16 / v18)) + 0.0;
      float v7 = v20
         + (float)((float)(KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * v9), a2)* 0.04)* (float)(1.0 - v19));
      _Block_object_dispose(&v25, 8);
      _Block_object_dispose(&v29, 8);
      _Block_object_dispose(&v33, 8);
    }
  }
  return v7;
}

void ___ZNK2KB22LanguageModelContainer36probability_of_lexicon_given_contextEjRKNS_20LanguageModelContextE_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if ((HIDWORD(a2) - 500) <= 0xFFFFFE0C)
  {
    uint64_t v6 = *(void **)(a1 + 56);
    float v7 = *(float *)(a1 + 80);
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
    unint64_t v9 = *(void *)(v8 + 24);
    *(void *)(v8 + 24) = v9 + 1;
    float v10 = powf(v7, (float)v9);
    *(float *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v10
                                                               + *(float *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                          + 24);
    uint64_t v11 = v6[3];
    BOOL v12 = (unint64_t)(0x6DB6DB6DB6DB6DB7 * ((v6[4] - v11) >> 3)) <= 1 && *(_DWORD *)(v11 + 40) < 2;
    int v13 = *(_DWORD *)(a1 + 84);
    char v14 = (*(uint64_t (**)(void *, uint64_t))(*v6 + 328))(v6, a2) ^ 1 | v12;
    if (v13 == a2)
    {
      uint64_t v15 = *(void *)(*(void *)(a1 + 48) + 8);
      float v16 = *(float *)(v15 + 24);
      if (v14) {
        float v17 = v10 + v16;
      }
      else {
        float v17 = v16 + (float)(v10 * 0.6);
      }
      *(float *)(v15 + 24) = v17;
    }
    else if ((v14 & 1) == 0)
    {
      KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(v6[3] + 56 * *(void *)(a1 + 64)), *(_DWORD *)(a1 + 84));
    }
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(void *)(a1 + 72)) {
    *a3 = 1;
  }
}

BOOL enumerate_context_backwards(uint64_t a1, uint64_t a2)
{
  char v10 = 0;
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24) - v2;
  if (!v3) {
    return 0;
  }
  uint64_t v6 = 0;
  unint64_t v7 = v3 >> 3;
  for (uint64_t i = -8; ; i -= 8)
  {
    (*(void (**)(uint64_t, void, char *))(a2 + 16))(a2, *(void *)(v2 + 8 * v7 + i), &v10);
    BOOL result = v10 != 0;
    if (v10) {
      break;
    }
    uint64_t v2 = *(void *)(a1 + 16);
    unint64_t v7 = (*(void *)(a1 + 24) - v2) >> 3;
    if (v7 <= ++v6) {
      return 0;
    }
  }
  return result;
}

float KB::LanguageModelLexiconGroup::lexicon_weight(KB::LanguageModelLexiconGroup *this, unsigned int a2)
{
  uint64_t v2 = std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::find<unsigned int>((void *)this + 2, a2);
  if (!v2) {
    abort();
  }
  return *((float *)v2 + 5);
}

float KB::LanguageModelContainer::lexicon_stationary_probability(KB::LanguageModelContainer *this, int a2)
{
  uint64_t v2 = *((void *)this + 3);
  if (*((void *)this + 4) == v2) {
    return 1.0;
  }
  unint64_t v5 = 0;
  float v6 = 1.0;
  do
  {
    uint64_t v7 = *(void *)(v2 + 56 * v5);
    if (v7)
    {
      (*(void (**)(unsigned int **__return_ptr))(*(void *)v7 + 48))(&v11);
      uint64_t v8 = v11;
      unint64_t v9 = v12;
      if (v11 != v12)
      {
        do
        {
          if (*v8 != a2) {
            float v6 = v6
          }
               + (float)(KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * v5), *v8)* -0.04);
          ++v8;
        }
        while (v8 != v9);
        uint64_t v8 = v11;
      }
      if (v8)
      {
        BOOL v12 = v8;
        operator delete(v8);
      }
    }
    ++v5;
    uint64_t v2 = *((void *)this + 3);
  }
  while (v5 < 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 4) - v2) >> 3));
  return v6;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::find<unsigned int>(void *a1, unsigned int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (BOOL result = *v5; result; BOOL result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context(KB::LanguageModelContainer *this, const KB::LanguageModelContext *a2, float *a3)
{
  uint64_t v4 = *((void *)this + 3);
  if (*((void *)this + 4) == v4)
  {
    uint64_t v8 = 0;
    float v9 = 0.0;
  }
  else
  {
    unint64_t v7 = 0;
    uint64_t v8 = 0;
    float v9 = -3.4028e38;
    do
    {
      uint64_t v10 = *(void *)(v4 + 56 * v7);
      if (v10)
      {
        (*(void (**)(unsigned int **__return_ptr))(*(void *)v10 + 48))(&v15);
        uint64_t v11 = v15;
        BOOL v12 = v16;
        if (v15 != v16)
        {
          do
          {
            float v13 = (*(float (**)(KB::LanguageModelContainer *, void, const KB::LanguageModelContext *))(*(void *)this + 456))(this, *v11, a2);
            if (v13 > v9)
            {
              uint64_t v8 = *v11;
              float v9 = v13;
            }
            ++v11;
          }
          while (v11 != v12);
          uint64_t v11 = v15;
        }
        if (v11)
        {
          float v16 = v11;
          operator delete(v11);
        }
      }
      ++v7;
      uint64_t v4 = *((void *)this + 3);
    }
    while (v7 < 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 4) - v4) >> 3));
  }
  *a3 = v9;
  return v8;
}

uint64_t KB::LanguageModelContainer::most_probable_lexicon_for_context(KB::LanguageModelContainer *this, const KB::LanguageModelContext *a2)
{
  int v3 = 0;
  return (*(uint64_t (**)(KB::LanguageModelContainer *, const KB::LanguageModelContext *, int *))(*(void *)this + 448))(this, a2, &v3);
}

void KB::LanguageModelContainer::conditional_likelihood_batched(void *a1@<X0>, unsigned int **a2@<X1>, uint64_t *a3@<X2>, uint64_t *a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  int v7 = a6;
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v94 = a5;
  char v93 = a6;
  float v9 = (uint64_t *)a1[3];
  uint64_t v10 = (uint64_t *)a1[4];
  if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (v10 - v9)) <= 1)
  {
    if (v9 == v10)
    {
      BOOL v12 = 0;
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = *v9;
      BOOL v12 = (std::__shared_weak_count *)v9[1];
      if (v12) {
        atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    (*(void (**)(uint64_t, unsigned int **, uint64_t *, uint64_t *, uint64_t, uint64_t))(*(void *)v11 + 432))(v11, a2, a3, a4, a5, a6);
    if (v12)
    {
      std::__shared_weak_count::__release_shared[abi:nn180100](v12);
    }
    return;
  }
  *a7 = 0;
  a7[1] = 0;
  a7[2] = 0;
  float v13 = *a2;
  char v14 = a2[1];
  if (*a2 != v14)
  {
    do
    {
      std::vector<KB::LikelihoodInfo>::vector(&v91, *v13, (uint64_t)&KB::k_invalid_likelihood_value);
      uint64_t v15 = (void *)a7[1];
      unint64_t v16 = a7[2];
      if ((unint64_t)v15 >= v16)
      {
        unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v15 - *a7) >> 3);
        unint64_t v19 = v18 + 1;
        if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
          goto LABEL_93;
        }
        unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - *a7) >> 3);
        if (2 * v20 > v19) {
          unint64_t v19 = 2 * v20;
        }
        if (v20 >= 0x555555555555555) {
          unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v21 = v19;
        }
        *(void *)&v96.__m_.__opaque[24] = a7 + 2;
        uint64_t v22 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v21);
        int v23 = &v22[24 * v18];
        v96.__m_.__sig = (uint64_t)v22;
        *(void *)v96.__m_.__opaque = v23;
        *(void *)&v96.__m_.__opaque[16] = &v22[24 * v24];
        *((void *)v23 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
        *((void *)v23 + 2) = 0;
        *(void *)int v23 = 0;
        *(_OWORD *)int v23 = v91;
        *((void *)v23 + 2) = v92;
        long long v91 = 0uLL;
        unint64_t v92 = 0;
        *(void *)&v96.__m_.__opaque[8] = v23 + 24;
        std::vector<std::vector<KB::LikelihoodInfo>>::__swap_out_circular_buffer(a7, &v96);
        float v17 = (void *)a7[1];
        std::__split_buffer<std::vector<KB::LikelihoodInfo>>::~__split_buffer((uint64_t)&v96);
      }
      else
      {
        *uint64_t v15 = 0;
        v15[1] = 0;
        v15[2] = 0;
        *(_OWORD *)uint64_t v15 = v91;
        v15[2] = v92;
        long long v91 = 0uLL;
        unint64_t v92 = 0;
        float v17 = v15 + 3;
      }
      a7[1] = v17;
      v96.__m_.__sig = (uint64_t)&v91;
      std::vector<KB::LikelihoodInfo>::__destroy_vector::operator()[abi:nn180100]((void ***)&v96);
      v13 += 250;
    }
    while (v13 != v14);
  }
  int v80 = (*(uint64_t (**)(void *, uint64_t *))(*a1 + 440))(a1, a4);
  int v90 = v80;
  long long v91 = 0uLL;
  unint64_t v92 = 0;
  uint64_t v25 = (KB::LanguageModelLexiconGroup *)a1[3];
  uint64_t v75 = (KB::LanguageModelLexiconGroup *)a1[4];
  double v76 = a7;
  if (v25 == v75)
  {
    id v60 = 0;
    id v87 = 0;
    id v88 = 0;
    uint64_t v89 = 0;
    uint64_t v27 = a2;
    unint64_t v54 = a1;
    goto LABEL_76;
  }
  std::vector<std::string>::pointer v26 = 0;
  uint64_t v27 = a2;
  do
  {
    id v78 = v26;
    memset(&v96, 0, 24);
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(&v96, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
    uint64_t v29 = *v27;
    uint64_t v28 = v27[1];
    if (v28 == *v27) {
      goto LABEL_39;
    }
    unint64_t v30 = 0;
    do
    {
      uint64_t v31 = &v29[250 * v30];
      if (!*(void *)v31) {
        goto LABEL_38;
      }
      uint64_t v32 = 0;
      uint64_t v33 = 0;
      unint64_t v34 = 0;
      do
      {
        uint64_t v35 = *(void *)(v96.__m_.__sig + 24 * v30);
        uint64_t v36 = *((void *)v31 + 1);
        if (v7 && (*(unsigned char *)(v36 + v33 + 106) & 2) != 0)
        {
          long long v38 = v25;
          int v39 = v80;
          goto LABEL_31;
        }
        int v37 = *(_DWORD *)(v36 + v33 + 136);
        if (KB::LanguageModelContainer::index_for_lexicon_id((KB::LanguageModelContainer *)a1, v37) != -1)
        {
          long long v38 = v25;
          int v39 = v37;
LABEL_31:
          *(unsigned char *)(v35 + v32) = KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v38, v39);
          goto LABEL_32;
        }
        if (*(_DWORD *)(*((void *)v31 + 1) + v33 + 140) > 0x1F3u)
        {
          *(unsigned char *)(v35 + v32) = 0;
        }
        else
        {
          unint64_t v40 = (uint64_t *)a1[3];
          if (v40 == (uint64_t *)a1[4])
          {
            uint64_t v41 = 0;
            long long v42 = 0;
          }
          else
          {
            uint64_t v41 = *v40;
            long long v42 = (std::__shared_weak_count *)v40[1];
            if (v42) {
              atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
            }
          }
          int v43 = (*(uint64_t (**)(uint64_t))(*(void *)v41 + 40))(v41);
          *(unsigned char *)(v35 + v32) = KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v25, v43);
          if (v42) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v42);
          }
        }
LABEL_32:
        ++v34;
        v33 += 240;
        v32 += 2;
      }
      while (v34 < *(void *)v31);
      uint64_t v27 = a2;
      uint64_t v29 = *a2;
      uint64_t v28 = a2[1];
LABEL_38:
      ++v30;
    }
    while (v30 < 0x1CAC083126E978D5 * (((char *)v28 - (char *)v29) >> 3));
LABEL_39:
    if ((unint64_t)v78 < v92)
    {
      *id v78 = 0;
      v78[1] = 0;
      v78[2] = 0;
      std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v78, v96.__m_.__sig, *(uint64_t *)v96.__m_.__opaque, 0xAAAAAAAAAAAAAAABLL * ((*(void *)v96.__m_.__opaque - v96.__m_.__sig) >> 3));
      std::vector<std::string>::pointer v26 = v78 + 3;
      goto LABEL_57;
    }
    unint64_t v44 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)v78 - v91) >> 3);
    unint64_t v45 = v44 + 1;
    if (v44 + 1 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_93;
    }
    if (0x5555555555555556 * ((uint64_t)(v92 - v91) >> 3) > v45) {
      unint64_t v45 = 0x5555555555555556 * ((uint64_t)(v92 - v91) >> 3);
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v92 - v91) >> 3) >= 0x555555555555555) {
      unint64_t v46 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v46 = v45;
    }
    if (v46) {
      unint64_t v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v46);
    }
    else {
      uint64_t v47 = 0;
    }
    long long v48 = (void *)(v46 + 24 * v44);
    unint64_t v49 = v46 + 24 * v47;
    void *v48 = 0;
    v48[1] = 0;
    v48[2] = 0;
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v48, v96.__m_.__sig, *(uint64_t *)v96.__m_.__opaque, 0xAAAAAAAAAAAAAAABLL * ((*(void *)v96.__m_.__opaque - v96.__m_.__sig) >> 3));
    std::vector<std::string>::pointer v26 = v48 + 3;
    uint64_t v51 = *((void *)&v91 + 1);
    uint64_t v50 = v91;
    if (*((void *)&v91 + 1) == (void)v91)
    {
      *(void *)&long long v91 = v48;
      *((void *)&v91 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v48 + 3;
      unint64_t v92 = v49;
      if (v51) {
        goto LABEL_56;
      }
    }
    else
    {
      do
      {
        *(v48 - 3) = 0;
        *(v48 - 2) = 0;
        v48 -= 3;
        v48[2] = 0;
        long long v52 = *(_OWORD *)(v51 - 24);
        v51 -= 24;
        *(_OWORD *)long long v48 = v52;
        v48[2] = *(void *)(v51 + 16);
        *(void *)uint64_t v51 = 0;
        *(void *)(v51 + 8) = 0;
        *(void *)(v51 + 16) = 0;
      }
      while (v51 != v50);
      uint64_t v51 = *((void *)&v91 + 1);
      uint64_t v53 = v91;
      *(void *)&long long v91 = v48;
      *((void *)&v91 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v26;
      unint64_t v92 = v49;
      if (v51 != v53)
      {
        do
        {
          v51 -= 24;
          id v87 = (void **)v51;
          std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v87);
        }
        while (v51 != v53);
        uint64_t v51 = v53;
      }
      if (v51) {
LABEL_56:
      }
        operator delete((void *)v51);
    }
LABEL_57:
    *((void *)&v91 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v26;
    id v87 = (void **)&v96;
    std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v87);
    uint64_t v25 = (KB::LanguageModelLexiconGroup *)((char *)v25 + 56);
  }
  while (v25 != v75);
  unint64_t v54 = a1;
  uint64_t v56 = a1[3];
  uint64_t v55 = a1[4];
  id v87 = 0;
  id v88 = 0;
  uint64_t v89 = 0;
  uint64_t v57 = v55 - v56;
  if (!v57)
  {
    id v60 = 0;
    goto LABEL_76;
  }
  unint64_t v58 = 0x6DB6DB6DB6DB6DB7 * (v57 >> 3);
  if (v58 >= 0x276276276276277) {
LABEL_93:
  }
    abort();
  id v87 = (void **)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(v58);
  id v88 = v87;
  uint64_t v89 = &v87[13 * v59];
  id v60 = (const KB::LanguageModelContext *)&v87[13 * v58];
  long long v61 = v87 + 8;
  do
  {
    uint8_t v61[4] = 0;
    *(_OWORD *)long long v61 = 0u;
    *((_OWORD *)v61 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)v61 - 2) = 0u;
    *((_OWORD *)v61 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)v61 - 4) = 0u;
    *((_OWORD *)v61 - 3) = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)v61);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)(v61 + 1));
    v61[2] = 0;
    v61[3] = 0;
    uint8_t v61[4] = 0;
    int v62 = (const KB::LanguageModelContext *)(v61 + 5);
    v61 += 13;
  }
  while (v62 != v60);
  id v88 = (void **)v60;
  if (a1[4] != a1[3])
  {
    unint64_t v63 = 0;
    long long v64 = v87;
    do
    {
      ++v63;
      long long v64 = (void **)(KB::LanguageModelContext::operator=((uint64_t)v64, a4) + 104);
    }
    while (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[4] - a1[3]) >> 3) > v63);
  }
LABEL_76:
  memset(v96.__m_.__opaque, 0, sizeof(v96.__m_.__opaque));
  v96.__m_.__sig = 850045863;
  long long v65 = dispatch_group_create();
  long long v66 = (std::__shared_weak_count *)v54[2];
  if (v66)
  {
    long long v67 = std::__shared_weak_count::lock(v66);
    std::string::size_type v68 = v67;
    if (v67)
    {
      atomic_fetch_add_explicit(&v67->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      std::__shared_weak_count::__release_shared[abi:nn180100](v67);
    }
  }
  else
  {
    std::string::size_type v68 = 0;
  }
  if (v54[4] != v54[3])
  {
    uint64_t v69 = (uint64_t)v54;
    uint64_t v70 = 0;
    unint64_t v71 = 0;
    do
    {
      dispatch_group_enter(v65);
      KB::LanguageModelLexiconGroup::lexicon_group_identifier((KB::LanguageModelLexiconGroup *)(*(void *)(v69 + 24) + v70), (uint64_t)__p);
      id v72 = KB::LanguageModelContainer::get_autocorrection_queue(v69, (uint64_t)__p);
      if (v68) {
        atomic_fetch_add_explicit(&v68->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      memset(v83, 0, sizeof(v83));
      std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>((KB::LanguageModelContext *)v83, (const KB::LanguageModelContext *)v87, v60, 0x4EC4EC4EC4EC4EC5 * ((v60 - (const KB::LanguageModelContext *)v87) >> 3));
      memset(v84, 0, 24);
      std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(v84, (uint64_t *)v91, *((uint64_t **)&v91 + 1), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v91 + 1) - v91) >> 3));
      v84[3] = v27;
      v84[4] = &v93;
      v84[5] = v76;
      v84[6] = &v96;
      v84[7] = a1;
      uint64_t v82 = v65;
      TIDispatchAsync();

      if (v86 < 0) {
        operator delete(__p[0]);
      }

      uint64_t v95 = v84;
      std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](&v95);
      uint64_t v95 = (void **)v83;
      std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](&v95);
      if (v68) {
        std::__shared_weak_count::__release_weak(v68);
      }
      ++v71;
      uint64_t v69 = (uint64_t)a1;
      v70 += 56;
    }
    while (v71 < 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[4] - a1[3]) >> 3));
  }
  dispatch_group_wait(v65, 0xFFFFFFFFFFFFFFFFLL);
  if (v68) {
    std::__shared_weak_count::__release_weak(v68);
  }

  std::mutex::~mutex(&v96);
  v96.__m_.__sig = (uint64_t)&v87;
  std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](v73);
  v96.__m_.__sig = (uint64_t)&v91;
  std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100]((void ***)&v96);
}

void *std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    float v6 = result;
    BOOL result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a4);
    int v7 = result;
    *float v6 = result;
    v6[1] = result;
    v6[2] = &result[3 * v8];
    while (a2 != a3)
    {
      *int v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
      uint64_t v10 = *(const void **)a2;
      uint64_t v9 = *(void *)(a2 + 8);
      int64_t v11 = v9 - *(void *)a2;
      if (v9 != *(void *)a2)
      {
        std::vector<language_modeling::v1::TokenMetadata>::__vallocate[abi:nn180100](v7, v11 >> 1);
        BOOL v12 = (char *)v7[1];
        BOOL result = memmove(v12, v10, v11);
        v7[1] = &v12[v11];
      }
      v7 += 3;
      a2 += 24;
    }
    v6[1] = v7;
  }
  return result;
}

void std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    unint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 104;
        std::__destroy_at[abi:nn180100]<KB::LanguageModelContext,0>(v4);
      }
      while ((void *)v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        float v6 = v4;
        std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__destroy_vector::operator()[abi:nn180100](&v6);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void KB::LanguageModelLexiconGroup::lexicon_group_identifier(KB::LanguageModelLexiconGroup *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)this;
  if (v3)
  {
    (*(void (**)(unsigned int **__return_ptr))(*(void *)v3 + 48))(&v10);
    uint64_t v4 = v10;
    unint64_t v5 = v11;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    *(void *)a2 = 0;
    if (v4 != v5)
    {
      do
      {
        uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
        if ((v6 & 0x80u) != 0) {
          uint64_t v6 = *(void *)(a2 + 8);
        }
        if (v6) {
          std::string::append((std::string *)a2, "+", 1uLL);
        }
        std::to_string(&__p, *v4);
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::__split_buffer<std::string>::pointer p_p = &__p;
        }
        else {
          std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
        }
        if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type size = __p.__r_.__value_.__l.__size_;
        }
        std::string::append((std::string *)a2, (const std::string::value_type *)p_p, size);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        ++v4;
      }
      while (v4 != v5);
      uint64_t v4 = v10;
    }
    if (v4)
    {
      int64_t v11 = v4;
      operator delete(v4);
    }
  }
  else
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
  }
}

id KB::LanguageModelContainer::get_autocorrection_queue(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t *)(a1 + 48);
  int v5 = *(char *)(a2 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (uint64_t *)a2;
  }
  else {
    uint64_t v6 = *(uint64_t **)a2;
  }
  if (v5 >= 0) {
    unint64_t v7 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v7 = *(void *)(a2 + 8);
  }
  unint64_t v8 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v6, v7);
  int8x8_t v9 = *(int8x8_t *)(a1 + 56);
  if (v9)
  {
    unint64_t v10 = v8;
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(v9);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v13 = v8;
      if (v8 >= *(void *)&v9) {
        unint64_t v13 = v8 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v13 = (*(void *)&v9 - 1) & v8;
    }
    char v14 = *(unsigned __int8 ***)(*v4 + 8 * v13);
    if (v14)
    {
      for (uint64_t i = *v14; i; uint64_t i = *(unsigned __int8 **)i)
      {
        unint64_t v16 = *((void *)i + 1);
        if (v16 == v10)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a2))
          {
            id v23 = *((id *)i + 5);
            goto LABEL_28;
          }
        }
        else
        {
          if (v12 > 1)
          {
            if (v16 >= *(void *)&v9) {
              v16 %= *(void *)&v9;
            }
          }
          else
          {
            v16 &= *(void *)&v9 - 1;
          }
          if (v16 != v13) {
            break;
          }
        }
      }
    }
  }
  std::operator+<char>();
  float v17 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  if (v25 >= 0) {
    std::__split_buffer<std::string>::pointer p_p = (const char *)&__p;
  }
  else {
    std::__split_buffer<std::string>::pointer p_p = (const char *)__p;
  }
  dispatch_queue_t v19 = dispatch_queue_create(p_p, v17);
  unint64_t v20 = std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, a2, a2);
  unint64_t v21 = (void *)*((void *)v20 + 5);
  *((void *)v20 + 5) = v19;

  id v23 = *((id *)std::__hash_table<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,applesauce::CF::DictionaryRef>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, a2, a2)+ 5);
  if (v25 < 0) {
    operator delete(__p);
  }
LABEL_28:

  return v23;
}

void ___ZNK2KB22LanguageModelContainer30conditional_likelihood_batchedERKNSt3__16vectorINS_9CandidateENS1_9allocatorIS3_EEEERKNS2_INS2_IN17language_modeling2v113TokenMetadataENS4_ISB_EEEENS4_ISD_EEEERKNS_20LanguageModelContextEP10__CFStringb_block_invoke(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && (uint64_t v3 = *(void *)(a1 + 40), (v4 = std::__shared_weak_count::lock(v2)) != 0))
  {
    int v5 = v4;
    if (*(void *)(a1 + 48))
    {
      uint64_t v6 = (KB::LanguageModelLexiconGroup *)(*(void *)(v3 + 24) + 56 * *(void *)(a1 + 96));
      unint64_t v30 = v4;
      if (**(unsigned char **)(a1 + 72)) {
        KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v6, **(_DWORD **)(a1 + 64));
      }
      (*(void (**)(uint64_t *__return_ptr))(**(void **)v6 + 432))(&v34);
      uint64_t v8 = *(void *)(v3 + 24);
      uint64_t v9 = *(void *)(a1 + 96);
      uint64_t v10 = *(void *)(a1 + 104);
      uint64_t v11 = *(void *)(a1 + 128);
      uint64_t v12 = *(void *)(a1 + 184);
      uint64_t v29 = *(std::mutex **)(a1 + 176);
      std::mutex::lock(v29);
      if (v35 != v34)
      {
        unint64_t v13 = 0;
        uint64_t v31 = (KB::LanguageModelContext *)(v10 + 104 * v9);
        uint64_t v32 = (KB::LanguageModelLexiconGroup *)(v8 + 56 * v9);
        char v14 = (void *)(v11 + 24 * v9);
        do
        {
          KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)&v39, v31);
          if (*(void *)(v34 + 24 * v13 + 8) != *(void *)(v34 + 24 * v13))
          {
            uint64_t v15 = 0;
            uint64_t v16 = 0;
            unint64_t v17 = 0;
            uint64_t v33 = (void *)(**(void **)(a1 + 152) + 1000 * v13 + 8);
            uint64_t v18 = 39;
            do
            {
              uint64_t v19 = *(void *)(*v14 + 24 * v13);
              if (*(unsigned char *)(v19 + v15))
              {
                uint64_t v20 = *v33 + v16;
                uint64_t v21 = *(unsigned int *)(v20 + 136);
                if (!KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v32, *(_DWORD *)(v20 + 136))
                  && (!**(unsigned char **)(a1 + 160) || (*(unsigned char *)(*v33 + v16 + 106) & 2) == 0))
                {
                  uint64_t v21 = 0;
                }
                float v22 = (*(float (**)(uint64_t, uint64_t, void ***))(*(void *)v12 + 456))(v12, v21, &v39);
                id v23 = (char *)(*(void *)(v34 + 24 * v13) + v18);
                uint64_t v36 = (void **)vmul_n_f32(*(float32x2_t *)(v23 - 39), v22);
                int v37 = *(_DWORD *)(v23 - 31);
                uint64_t v24 = (const std::string::value_type **)(v23 - 23);
                if (*v23 < 0)
                {
                  std::string::__init_copy_ctor_external(&v38, *v24, *(void *)(v23 - 15));
                }
                else
                {
                  *(_OWORD *)&v38.__r_.__value_.__l.__data_ = *(_OWORD *)v24;
                  v38.__r_.__value_.__r.__words[2] = *(void *)(v23 - 7);
                }
                char v25 = (char *)(*(void *)(**(void **)(a1 + 168) + 24 * v13) + v18);
                *(void *)(v25 - 39) = v36;
                *(_DWORD *)(v25 - 3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v37;
                std::vector<std::string>::pointer v26 = (void **)(v25 - 23);
                if (*v25 < 0) {
                  operator delete(*v26);
                }
                *(std::string *)std::vector<std::string>::pointer v26 = v38;
                uint64_t v19 = *(void *)(*v14 + 24 * v13);
              }
              if (!*(unsigned char *)(v19 + v15 + 1))
              {
                uint64_t v27 = (TITokenID *)(*v33 + v16);
                TITokenID v28 = v27[17];
                KB::LanguageModelContext::append((KB::LanguageModelContext *)&v39, v28, (const KB::String *)v27, 0);
              }
              ++v17;
              v16 += 240;
              v15 += 2;
              v18 += 40;
            }
            while (v17 < 0xCCCCCCCCCCCCCCCDLL
                        * ((uint64_t)(*(void *)(v34 + 24 * v13 + 8) - *(void *)(v34 + 24 * v13)) >> 3));
          }
          uint64_t v36 = (void **)&v45;
          std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v36);
          language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v44);
          language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v43);
          if (__p)
          {
            long long v42 = __p;
            operator delete(__p);
          }
          if (v40) {
            std::__shared_weak_count::__release_shared[abi:nn180100](v40);
          }
          ++v13;
        }
        while (v13 < 0xAAAAAAAAAAAAAAABLL * ((v35 - v34) >> 3));
      }
      std::mutex::unlock(v29);
      int v39 = (void **)&v34;
      std::vector<std::vector<KB::LikelihoodInfo>>::__destroy_vector::operator()[abi:nn180100](&v39);
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
      int v5 = v30;
    }
    else
    {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
    }
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  else
  {
    unint64_t v7 = *(NSObject **)(a1 + 32);
    dispatch_group_leave(v7);
  }
}

KB::LanguageModelContext *std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>(KB::LanguageModelContext *result, const KB::LanguageModelContext *a2, const KB::LanguageModelContext *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    std::vector<KB::LanguageModelContext>::__vallocate[abi:nn180100](result, a4);
    BOOL result = (KB::LanguageModelContext *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      unint64_t v7 = KB::LanguageModelContext::LanguageModelContext(result, a2);
      a2 = (const KB::LanguageModelContext *)((char *)a2 + 104);
      BOOL result = (KB::LanguageModelContext *)((char *)v7 + 104);
    }
    *((void *)v6 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = result;
  }
  return result;
}

void *std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(void *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v6 = result;
    BOOL result = std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(a4);
    unint64_t v7 = result;
    *uint64_t v6 = result;
    v6[1] = result;
    for (v6[2] = &result[3 * v8]; a2 != a3; v7 += 3)
    {
      *unint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
      uint64_t v9 = *a2;
      uint64_t v10 = a2[1];
      a2 += 3;
      BOOL result = std::vector<std::vector<language_modeling::v1::TokenMetadata>>::__init_with_size[abi:nn180100]<std::vector<language_modeling::v1::TokenMetadata>*,std::vector<language_modeling::v1::TokenMetadata>*>(v7, v9, v10, 0xAAAAAAAAAAAAAAABLL * ((v10 - v9) >> 3));
    }
    v6[1] = v7;
  }
  return result;
}

char *std::vector<KB::LanguageModelContext>::__vallocate[abi:nn180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x276276276276277) {
    abort();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[104 * v4];
  return result;
}

void *std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelContext>>(unint64_t a1)
{
  if (a1 >= 0x276276276276277) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  return operator new(104 * a1);
}

void __destroy_helper_block_a8_48c53_ZTSNSt3__18weak_ptrIKN2KB22LanguageModelContainerEEE104c67_ZTSNSt3__16vectorIN2KB20LanguageModelContextENS_9allocatorIS2_EEEE128c113_ZTSNSt3__16vectorINS0_INS0_IN17language_modeling2v113TokenMetadataENS_9allocatorIS3_EEEENS4_IS6_EEEENS4_IS8_EEEE(uint64_t a1)
{
  unint64_t v2 = (void **)(a1 + 104);
  uint64_t v4 = (void **)(a1 + 128);
  std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v4 = v2;
  std::vector<KB::LanguageModelContext>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 56);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *__copy_helper_block_a8_48c53_ZTSNSt3__18weak_ptrIKN2KB22LanguageModelContainerEEE104c67_ZTSNSt3__16vectorIN2KB20LanguageModelContextENS_9allocatorIS2_EEEE128c113_ZTSNSt3__16vectorINS0_INS0_IN17language_modeling2v113TokenMetadataENS_9allocatorIS3_EEEENS4_IS6_EEEENS4_IS8_EEEE(void *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 56);
  a1[6] = *(void *)(a2 + 48);
  a1[7] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  a1[14] = 0;
  a1[15] = 0;
  a1[13] = 0;
  std::vector<KB::LanguageModelContext>::__init_with_size[abi:nn180100]<KB::LanguageModelContext*,KB::LanguageModelContext*>((KB::LanguageModelContext *)(a1 + 13), *(const KB::LanguageModelContext **)(a2 + 104), *(const KB::LanguageModelContext **)(a2 + 112), 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a2 + 112) - *(void *)(a2 + 104)) >> 3));
  a1[16] = 0;
  a1[17] = 0;
  int v5 = a1 + 16;
  v5[2] = 0;
  uint64_t v6 = *(uint64_t **)(a2 + 128);
  unint64_t v7 = *(uint64_t **)(a2 + 136);

  return std::vector<std::vector<std::vector<language_modeling::v1::TokenMetadata>>>::__init_with_size[abi:nn180100]<std::vector<std::vector<language_modeling::v1::TokenMetadata>>*,std::vector<std::vector<language_modeling::v1::TokenMetadata>>*>(v5, v6, v7, 0xAAAAAAAAAAAAAAABLL * (v7 - v6));
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,0>(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v2 = *(void **)a1;
    operator delete(v2);
  }
}

void KB::LanguageModelContainer::conditional_likelihood(KB::LanguageModelContainer *this@<X0>, const TITokenID *a2@<X2>, const KB::LanguageModelContext *a3@<X3>, float a4@<S0>, float32x2_t *a5@<X8>)
{
  uint64_t v26 = KB::k_invalid_likelihood_value;
  int v27 = dword_1EAE3EB58;
  if (byte_1EAE3EB60[23] < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)byte_1EAE3EB60, *(std::string::size_type *)&byte_1EAE3EB60[8]);
  }
  else {
    std::string __p = *(std::string *)byte_1EAE3EB60;
  }
  uint64_t lexicon_id = a2->lexicon_id;
  uint64_t v13 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2->lexicon_id);
  if (v13 == -1)
  {
    float v15 = 0.0;
    if (a2->word_id > 0x1F3 || *((void *)this + 3) == *((void *)this + 4)) {
      goto LABEL_14;
    }
    double v16 = (*(double (**)(KB::LanguageModelContainer *, void, const KB::LanguageModelContext *))(*(void *)this + 456))(this, 0, a3);
    unint64_t v17 = (uint64_t *)*((void *)this + 3);
    float v22 = *(float *)&v16;
    if (v17 == *((uint64_t **)this + 4))
    {
      uint64_t v18 = 0;
      uint64_t v19 = 0;
    }
    else
    {
      uint64_t v18 = *v17;
      uint64_t v19 = (std::__shared_weak_count *)v17[1];
      if (v19) {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    (*(void (**)(float32x2_t *__return_ptr, float))(*(void *)v18 + 424))(&v23, a4);
    uint64_t v26 = (uint64_t)v23;
    int v27 = v24;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v25;
    *((unsigned char *)&v25.__r_.__value_.__s + 23) = 0;
    v25.__r_.__value_.__s.__data_[0] = 0;
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v19);
    }
  }
  else
  {
    uint64_t v14 = v13;
    LODWORD(v22) = COERCE_UNSIGNED_INT64((*(double (**)(KB::LanguageModelContainer *, uint64_t, const KB::LanguageModelContext *))(*(void *)this + 456))(this, lexicon_id, a3));
    (*(void (**)(float32x2_t *__return_ptr, float))(**(void **)(*((void *)this + 3) + 56 * v14) + 424))(&v23, a4);
    uint64_t v26 = (uint64_t)v23;
    int v27 = v24;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v25;
  }
  float v15 = v22;
LABEL_14:
  *a5 = vmul_n_f32((float32x2_t)v26, v15);
  a5[1].i32[0] = v27;
  uint64_t v20 = (std::string *)&a5[2];
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v21 = (void *)__p.__r_.__value_.__r.__words[0];
    std::string::__init_copy_ctor_external(v20, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    operator delete(v21);
  }
  else
  {
    *(_OWORD *)&v20->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    a5[4] = (float32x2_t)__p.__r_.__value_.__r.__words[2];
  }
}

void KB::LanguageModelContainer::marginal_likelihood(KB::LanguageModelContainer *this, const KB::String *a2, const TITokenID *a3)
{
  unsigned int lexicon_id = a3->lexicon_id;
  uint64_t v7 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3->lexicon_id);
  if (v7 != -1)
  {
    uint64_t v8 = 56 * v7;
    KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * v7), lexicon_id);
    uint64_t v9 = (void *)(*((void *)this + 3) + v8);
LABEL_3:
    (*(float (**)(void, const KB::String *, const TITokenID *))(*(void *)*v9 + 416))(*v9, a2, a3);
    return;
  }
  if (a3->word_id <= 0x1F3)
  {
    uint64_t v9 = (void *)*((void *)this + 3);
    if (v9 != *((void **)this + 4)) {
      goto LABEL_3;
    }
  }
}

uint64_t KB::LanguageModelContainer::can_reason_about(KB::LanguageModelContainer *this, const String *a2, const TITokenID *a3)
{
  if (!(*(unsigned int (**)(KB::LanguageModelContainer *))(*(void *)this + 16))(this)) {
    return 0;
  }
  uint64_t v5 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3->lexicon_id);
  if (v5 != -1)
  {
    uint64_t v6 = *((void *)this + 3) + 56 * v5;
    goto LABEL_4;
  }
  if (a3->word_id > 0x1F3) {
    return 0;
  }
  uint64_t v6 = *((void *)this + 3);
  if (v6 == *((void *)this + 4)) {
    return 0;
  }
LABEL_4:
  uint64_t v7 = *(uint64_t (**)(void))(**(void **)v6 + 408);

  return v7();
}

uint64_t KB::LanguageModelContainer::is_swear_word_policy_enabled(KB::LanguageModelContainer *this, int a2)
{
  uint64_t v3 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (v3 == -1) {
    return 1;
  }
  uint64_t v4 = *(uint64_t (**)(void))(**(void **)(*((void *)this + 3) + 56 * v3) + 400);

  return v4();
}

void KB::LanguageModelContainer::adapt_to_paragraph(uint64_t a1, KB *this, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  KB::cf_string_no_copy(this, (CFStringRef *)&cf);
  uint64_t v12 = *(void **)(a1 + 24);
  uint64_t v13 = *(void **)(a1 + 32);
  CFTypeRef v14 = cf;
  while (v12 != v13)
  {
    if (a5 == 2 || (*(unsigned int (**)(void, CFTypeRef))(*(void *)*v12 + 384))(*v12, v14)) {
      (*(void (**)(void, KB *, uint64_t, uint64_t, uint64_t, double))(*(void *)*v12 + 392))(*v12, this, a3, a4, a5, a6);
    }
    v12 += 7;
  }
  if (v14)
  {
    CFRelease(v14);
  }
}

uint64_t KB::LanguageModelContainer::should_adapt_to_paragraph(KB::LanguageModelContainer *this, const __CFString *a2)
{
  if (!(*(unsigned int (**)(KB::LanguageModelContainer *))(*(void *)this + 16))(this)) {
    return 0;
  }
  uint64_t v4 = (void *)*((void *)this + 3);
  uint64_t v5 = (void *)*((void *)this + 4);
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  uint64_t v10 = ___ZNK2KB22LanguageModelContainer25should_adapt_to_paragraphEPK10__CFString_block_invoke;
  uint64_t v11 = &__block_descriptor_40_e10_B16__0r_v8l;
  CFStringRef v12 = a2;
  uint64_t v6 = v9;
  if (v4 == v5)
  {
    uint64_t v7 = 0;
  }
  else
  {
    do
    {
      uint64_t v7 = v10((uint64_t)v6, v4);
      if (v7) {
        break;
      }
      v4 += 7;
    }
    while (v4 != v5);
  }

  return v7;
}

uint64_t ___ZNK2KB22LanguageModelContainer25should_adapt_to_paragraphEPK10__CFString_block_invoke(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a2 + 384))(*a2, *(void *)(a1 + 32));
}

double KB::LanguageModelContainer::last_offline_adaptation_time(KB::LanguageModelContainer *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  unint64_t v2 = (uint64_t *)*((void *)this + 4);
  double v3 = 0.0;
  while (v1 != v2)
  {
    uint64_t v4 = *v1;
    v1 += 7;
    double v5 = (*(double (**)(uint64_t))(*(void *)v4 + 376))(v4);
    if (v5 < v3) {
      double v3 = v5;
    }
  }
  return v3;
}

unint64_t KB::LanguageModelContainer::record_usage_with_differential_privacy(KB::LanguageModelContainer *a1, int a2, int a3)
{
  unint64_t result = KB::LanguageModelContainer::index_for_lexicon_id(a1, a3);
  uint64_t v6 = *((void *)a1 + 3);
  if (result < 0x6DB6DB6DB6DB6DB7 * ((*((void *)a1 + 4) - v6) >> 3))
  {
    uint64_t v7 = (KB::LanguageModelLexiconGroup *)(v6 + 56 * result);
    KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v7, a3);
    uint64_t v8 = *(uint64_t (**)(void))(**(void **)v7 + 368);
    return v8();
  }
  return result;
}

uint64_t KB::LanguageModelContainer::register_negative_evidence(KB::LanguageModelContainer *a1, uint64_t a2, TITokenID *a3, const KB::LanguageModelContext *a4)
{
  uint64_t result = (*(uint64_t (**)(KB::LanguageModelContainer *))(*(void *)a1 + 24))(a1);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(KB::LanguageModelContainer *, uint64_t, TITokenID *))(*(void *)a1 + 408))(a1, a2, a3);
    if (!result) {
      return result;
    }
    TITokenID v9 = *a3;
  }
  else
  {
    TITokenID v9 = *a3;
    unint64_t v10 = HIDWORD(*(unint64_t *)a3);
    if (!v10 || v10 < 0x1F4) {
      return result;
    }
  }
  int v11 = KB::LanguageModelContainer::lexicon_id_for_token(a1, v9, a4);
  uint64_t result = KB::LanguageModelContainer::index_for_lexicon_id(a1, v11);
  if (result != -1)
  {
    CFStringRef v12 = *(uint64_t (**)(void))(**(void **)(*((void *)a1 + 3) + 56 * result) + 360);
    return v12();
  }
  return result;
}

uint64_t KB::LanguageModelContainer::lexicon_id_for_token(KB::LanguageModelContainer *this, TITokenID a2, const KB::LanguageModelContext *a3)
{
  TITokenID v3 = a2;
  if (a2.lexicon_id && a2.lexicon_id != -2) {
    return (uint64_t)v3;
  }
  uint64_t v4 = (_DWORD *)*((void *)this + 3);
  if (*((void *)this + 4) - (void)v4 == 56 && v4[10] == 1)
  {
    (*(void (**)(void **__return_ptr))(**(void **)v4 + 48))(__p);
    TITokenID v3 = (TITokenID)*(unsigned int *)__p[0];
    __p[1] = __p[0];
    operator delete(__p[0]);
    return (uint64_t)v3;
  }
  uint64_t v6 = *(uint64_t (**)(void))(*(void *)this + 440);

  return v6();
}

void KB::LanguageModelContainer::decrement_usage_count(KB::LanguageModelContainer *this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (HIDWORD(*(unint64_t *)a3) != 1)
  {
    TITokenID v5 = *a3;
    int v9 = KB::LanguageModelContainer::lexicon_id_for_token(this, v5, a4);
    uint64_t v10 = KB::LanguageModelContainer::index_for_lexicon_id(this, v9);
    if (v10 != -1)
    {
      int v11 = (void *)(*((void *)this + 3) + 56 * v10);
      (*(void (**)(void, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(void *)*v11 + 352))(*v11, a2, a3, a4);
      uint64_t v12 = language_modeling::v1::LinguisticContext::tokenSpan((const KB::LanguageModelContext *)((char *)a4 + 64));
      if (v13)
      {
        if (*(_DWORD *)(v12 + 32 * v13 - 8) == 1)
        {
          uint64_t v14 = *v11;
          int v15 = 0x100000;
          __int16 v16 = 0;
          char v17 = 0;
          uint64_t v18 = 0;
          char v19 = 0;
          (*(void (**)(uint64_t, int *, void *, const KB::LanguageModelContext *))(*(void *)v14 + 352))(v14, &v15, &kTITokenIDBeginningOfSentence, a4);
          if (v18)
          {
            if (v17 == 1) {
              free(v18);
            }
          }
        }
      }
    }
  }
}

uint64_t KB::LanguageModelContainer::increment_usage_count(uint64_t this, const KB::String *a2, const TITokenID *a3, const KB::LanguageModelContext *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (HIDWORD(*(unint64_t *)a3) != 1)
  {
    uint64_t v8 = (KB::LanguageModelContainer *)this;
    TITokenID v5 = *a3;
    int v9 = KB::LanguageModelContainer::lexicon_id_for_token((KB::LanguageModelContainer *)this, v5, a4);
    this = KB::LanguageModelContainer::index_for_lexicon_id(v8, v9);
    if (this != -1)
    {
      uint64_t v10 = (void *)(*((void *)v8 + 3) + 56 * this);
      uint64_t v11 = language_modeling::v1::LinguisticContext::tokenSpan((const KB::LanguageModelContext *)((char *)a4 + 64));
      if (v12)
      {
        if (*(_DWORD *)(v11 + 32 * v12 - 8) == 1)
        {
          uint64_t v13 = *v10;
          int v14 = 0x100000;
          __int16 v15 = 0;
          char v16 = 0;
          char v17 = 0;
          char v18 = 0;
          (*(void (**)(uint64_t, int *, void *, const KB::LanguageModelContext *))(*(void *)v13 + 344))(v13, &v14, &kTITokenIDBeginningOfSentence, a4);
          if (v17)
          {
            if (v16 == 1) {
              free(v17);
            }
          }
        }
      }
      return (*(uint64_t (**)(void, const KB::String *, const TITokenID *, const KB::LanguageModelContext *))(*(void *)*v10 + 344))(*v10, a2, a3, a4);
    }
  }
  return this;
}

unint64_t KB::LanguageModelContainer::add_dynamic_word(KB::LanguageModelContainer *this, const __CFString *a2, uint64_t a3)
{
  unint64_t v6 = KB::LanguageModelContainer::index_for_lexicon_id(this, a3);
  uint64_t v7 = *((void *)this + 3);
  if (v6 >= 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 4) - v7) >> 3)) {
    return 0;
  }
  uint64_t v8 = (KB::LanguageModelLexiconGroup *)(v7 + 56 * v6);
  KB::LanguageModelLexiconGroup::model_contains_lexicon_id(v8, a3);
  unint64_t result = (*(uint64_t (**)(void, const __CFString *, uint64_t))(**(void **)v8 + 336))(*(void *)v8, a2, a3);
  if (!HIDWORD(result)) {
    return 0;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::is_dynamic_word_id(KB::LanguageModelContainer *this, TITokenID a2)
{
  unint64_t v2 = (void *)*((void *)this + 3);
  TITokenID v3 = (void *)*((void *)this + 4);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  uint64_t v8 = ___ZNK2KB22LanguageModelContainer18is_dynamic_word_idE9TITokenID_block_invoke;
  int v9 = &__block_descriptor_40_e10_B16__0r_v8l;
  TITokenID v10 = a2;
  uint64_t v4 = v7;
  if (v2 == v3)
  {
    uint64_t v5 = 0;
  }
  else
  {
    do
    {
      uint64_t v5 = v8((uint64_t)v4, v2);
      if (v5) {
        break;
      }
      v2 += 7;
    }
    while (v2 != v3);
  }

  return v5;
}

uint64_t ___ZNK2KB22LanguageModelContainer18is_dynamic_word_idE9TITokenID_block_invoke(uint64_t a1, void *a2)
{
  return (*(uint64_t (**)(void, void))(*(void *)*a2 + 328))(*a2, *(void *)(a1 + 32));
}

void KB::LanguageModelContainer::static_words_for_string(uint64_t a1@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) != v3)
  {
    unint64_t v5 = 0;
    do
    {
      (*(void (**)(size_t **__return_ptr))(**(void **)(v3 + 56 * v5) + 312))(&v9);
      uint64_t v7 = v9;
      unint64_t v6 = v10;
      uint64_t v8 = v9;
      if (v9 != v10)
      {
        do
        {
          *((float *)v7 + 12) = KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*(void *)(a1 + 24) + 56 * v5), *((_DWORD *)v7 + 34))* *((float *)v7 + 12);
          v7 += 30;
        }
        while (v7 != v6);
        uint64_t v8 = v9;
        uint64_t v7 = v10;
      }
      std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>((KB::Word *)a2, a2[1], v8, v7, 0xEEEEEEEEEEEEEEEFLL * (((char *)v7 - (char *)v8) >> 4));
      uint64_t v11 = &v9;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v11);
      ++v5;
      uint64_t v3 = *(void *)(a1 + 24);
    }
    while (v5 < 0x6DB6DB6DB6DB6DB7 * ((*(void *)(a1 + 32) - v3) >> 3));
  }
}

KB::Word *std::vector<KB::Word>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Word*>,std::__wrap_iter<KB::Word*>>(KB::Word *result, uint64_t a2, size_t *a3, size_t *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  unint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v8 = (uint64_t *)result;
  int v9 = (char *)result + 16;
  uint64_t v10 = *((void *)result + 2);
  unint64_t v11 = *((void *)result + 1);
  if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v10 - v11) >> 4)) >= a5)
  {
    uint64_t v21 = v11 - a2;
    if ((uint64_t)(0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v11 - a2) >> 4)) >= a5)
    {
      uint64_t v23 = (uint64_t)&a3[30 * a5];
      std::string v25 = (KB::Word *)*((void *)result + 1);
    }
    else
    {
      uint64_t v23 = (uint64_t)&a3[2 * ((uint64_t)(v11 - a2) >> 4)];
      if ((size_t *)v23 == a4)
      {
        std::string v25 = (KB::Word *)*((void *)result + 1);
      }
      else
      {
        int v24 = &a3[2 * ((uint64_t)(v11 - a2) >> 4)];
        std::string v25 = (KB::Word *)*((void *)result + 1);
        do
        {
          unint64_t result = KB::Word::Word(v25, v24);
          v24 += 30;
          std::string v25 = (KB::Word *)((char *)v25 + 240);
        }
        while (v24 != a4);
      }
      v8[1] = (uint64_t)v25;
      if (v21 < 1) {
        return result;
      }
    }
    uint64_t v35 = (KB::Word *)(v7 + 240 * a5);
    uint64_t v36 = (char *)v25 - 240 * a5;
    uint64_t v37 = (uint64_t)v25;
    if ((unint64_t)v36 < v11)
    {
      unint64_t v38 = (unint64_t)v25 - 240 * a5;
      uint64_t v37 = (uint64_t)v25;
      do
      {
        uint64_t v39 = KB::Word::Word(v37, v38);
        v38 += 240;
        uint64_t v37 = v39 + 240;
      }
      while (v38 < v11);
    }
    v8[1] = v37;
    if (v25 != v35)
    {
      uint64_t v40 = 0;
      do
      {
        uint64_t v41 = (char *)v25 + v40;
        KB::String::operator=((uint64_t)v25 + v40 - 240, (KB::String *)&v36[v40 - 240]);
        KB::ByteString::operator=((unsigned __int16 *)((char *)v25 + v40 - 208), (unsigned __int16 *)&v36[v40 - 208]);
        uint64_t v42 = *(void *)&v36[v40 - 192];
        *((_DWORD *)v41 - 46) = *(_DWORD *)&v36[v40 - 184];
        *((void *)v41 - 24) = v42;
        KB::String::operator=((uint64_t)v25 + v40 - 176, (KB::String *)&v36[v40 - 176]);
        long long v43 = *(_OWORD *)&v36[v40 - 144];
        long long v44 = *(_OWORD *)&v36[v40 - 128];
        long long v45 = *(_OWORD *)&v36[v40 - 96];
        *((_OWORD *)v41 - 7) = *(_OWORD *)&v36[v40 - 112];
        *((_OWORD *)v41 - 6) = v45;
        *((_OWORD *)v41 - 9) = v43;
        *((_OWORD *)v41 - 8) = v44;
        KB::String::operator=((uint64_t)v25 + v40 - 80, (KB::String *)&v36[v40 - 80]);
        *(v41 - 48) = v36[v40 - 48];
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign((uint64_t)v25 + v40 - 40, (uint64_t *)&v36[v40 - 40]);
        v40 -= 240;
      }
      while (-16 * ((v25 - v35) >> 4) != v40);
    }
    return (KB::Word *)std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:nn180100]<KB::Word *,KB::Word *,KB::Word *>((uint64_t)v6, v23, v7);
  }
  else
  {
    uint64_t v12 = *(void *)result;
    unint64_t v13 = a5 - 0x1111111111111111 * ((uint64_t)(v11 - *(void *)result) >> 4);
    if (v13 > 0x111111111111111) {
      abort();
    }
    unint64_t v14 = 0xEEEEEEEEEEEEEEEFLL * ((a2 - v12) >> 4);
    unint64_t v15 = 0xEEEEEEEEEEEEEEEFLL * ((v10 - v12) >> 4);
    uint64_t v16 = 2 * v15;
    if (2 * v15 <= v13) {
      uint64_t v16 = a5 - 0x1111111111111111 * ((uint64_t)(v11 - *(void *)result) >> 4);
    }
    if (v15 >= 0x88888888888888) {
      unint64_t v17 = 0x111111111111111;
    }
    else {
      unint64_t v17 = v16;
    }
    v46[4] = v9;
    if (v17)
    {
      char v18 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v17);
      uint64_t v20 = v19;
    }
    else
    {
      char v18 = 0;
      uint64_t v20 = 0;
    }
    uint64_t v26 = (uint64_t)&v18[240 * v14];
    uint64_t v27 = 240 * a5;
    uint64_t v28 = v26 + v27;
    uint64_t v29 = (KB::Word *)v26;
    do
    {
      uint64_t v29 = (KB::Word *)((char *)KB::Word::Word(v29, v6) + 240);
      v6 += 30;
      v27 -= 240;
    }
    while (v27);
    uint64_t v30 = *v8;
    if (*v8 != v7)
    {
      uint64_t v31 = v7;
      do
      {
        v26 -= 240;
        v31 -= 240;
        KB::Word::Word(v26, v31);
      }
      while (v31 != v30);
    }
    uint64_t v32 = v8[1];
    if (v32 != v7)
    {
      do
      {
        KB::Word::Word(v28, v7);
        v7 += 240;
        v28 += 240;
      }
      while (v7 != v32);
      uint64_t v7 = v8[1];
    }
    uint64_t v33 = *v8;
    uint64_t *v8 = v26;
    v8[1] = v28;
    uint64_t v34 = v8[2];
    void v8[2] = (uint64_t)&v18[240 * v20];
    v46[2] = v7;
    void v46[3] = v34;
    v46[0] = v33;
    v46[1] = v33;
    return (KB::Word *)std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)v46);
  }
}

uint64_t KB::LanguageModelContainer::id_for_separator(KB::LanguageModelContainer *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  if (v1 == *((uint64_t **)this + 4)) {
    return 0;
  }
  uint64_t v2 = *v1;
  uint64_t v3 = (std::__shared_weak_count *)v1[1];
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v2)
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 304))(v2);
    if (!v3) {
      return v4;
    }
    goto LABEL_9;
  }
  uint64_t v4 = 0;
  if (v3) {
LABEL_9:
  }
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  return v4;
}

uint64_t KB::LanguageModelContainer::start_session(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 24);
  for (uint64_t i = *(uint64_t **)(result + 32);
        v2 != i;
        unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 288))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::set_recipient_context(uint64_t this, const __CFDictionary *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFDictionary *))(*(void *)v5 + 280))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_app_context(uint64_t this, const __CFString *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFString *))(*(void *)v5 + 272))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_inline_completion_personalization(uint64_t this, const String *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const String *))(*(void *)v5 + 264))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_inline_completion_analytics_metadata(uint64_t this, const TIInlineCompletionAnalyticsMetadata *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const TIInlineCompletionAnalyticsMetadata *))(*(void *)v5 + 256))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

unsigned int *KB::LanguageModelContainer::set_dictionaries(unsigned int *result, unsigned int **a2)
{
  uint64_t v2 = (uint64_t *)*((void *)result + 3);
  for (uint64_t i = (uint64_t *)*((void *)result + 4); v2 != i; v2 += 7)
  {
    uint64_t v5 = *v2;
    unint64_t v6 = *a2;
    uint64_t v7 = v6;
    if (v6) {
      atomic_fetch_add((atomic_uint *volatile)v6, 1u);
    }
    (*(void (**)(uint64_t, unsigned int **))(*(void *)v5 + 248))(v5, &v7);
    unint64_t result = v7;
    if (v7) {
      unint64_t result = WTF::RefCounted<KB::DictionaryContainer>::deref(v7);
    }
  }
  return result;
}

void KB::LanguageModelContainer::set_current_recipient_names(uint64_t a1, const KB::String **a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 24);
  uint64_t v3 = *(uint64_t **)(a1 + 32);
  while (v2 != v3)
  {
    uint64_t v5 = *v2;
    v2 += 7;
    memset(v6, 0, sizeof(v6));
    std::vector<KB::String>::__init_with_size[abi:nn180100]<KB::String*,KB::String*>((KB::String *)v6, *a2, a2[1], (a2[1] - *a2) >> 5);
    (*(void (**)(uint64_t, void *))(*(void *)v5 + 240))(v5, v6);
    uint64_t v7 = (void **)v6;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100](&v7);
  }
}

void KB::LanguageModelContainer::copyLinguisticDataFiles(KB::LanguageModelContainer *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  if (v1 == *((uint64_t **)this + 4))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = *v1;
    uint64_t v3 = (std::__shared_weak_count *)v1[1];
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 232))(v2);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

void KB::LanguageModelContainer::get_num_candidates(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 24);
  if (v1 == *(uint64_t **)(a1 + 32))
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v2 = *v1;
    uint64_t v3 = (std::__shared_weak_count *)v1[1];
    if (v3) {
      atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  (*(void (**)(uint64_t))(*(void *)v2 + 224))(v2);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:nn180100](v3);
  }
}

uint64_t KB::LanguageModelContainer::unwire_memory(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24);
  uint64_t v2 = *(void *)(this + 32);
  while (v1 != v2)
  {
    this = (*(uint64_t (**)(void))(**(void **)v1 + 16))();
    if (this) {
      this = (*(uint64_t (**)(void))(**(void **)v1 + 216))();
    }
    v1 += 56;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::wire_memory(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 24);
  uint64_t v2 = *(void *)(this + 32);
  while (v1 != v2)
  {
    this = (*(uint64_t (**)(void))(**(void **)v1 + 16))();
    if (this) {
      this = (*(uint64_t (**)(void))(**(void **)v1 + 208))();
    }
    v1 += 56;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::should_score_completion_candidate(KB::LanguageModelContainer *this, const Candidate *a2)
{
  uint64_t v3 = KB::LanguageModelContainer::index_for_lexicon_id(this, *(_DWORD *)(*((void *)a2 + 1) + 240 * *(void *)a2 - 104));
  if (v3 == -1) {
    return 1;
  }
  uint64_t v4 = *(void *)(*((void *)this + 3) + 56 * v3);
  return (*(unsigned int (**)(uint64_t))(*(void *)v4 + 144))(v4) ^ 1;
}

uint64_t KB::LanguageModelContainer::supports_fragment_based_conditional_prob(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 1;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 192))(*(void *)(v3 - 56));
    if (result) {
      BOOL v5 = v3 == v2;
    }
    else {
      BOOL v5 = 1;
    }
    v3 += 56;
  }
  while (!v5);
  return result;
}

BOOL KB::LanguageModelContainer::supports_multilingual(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4) - v1;
  return (unint64_t)(0x6DB6DB6DB6DB6DB7 * (v2 >> 3)) > 1 || v2 == 56 && *(int *)(v1 + 40) > 1;
}

void KB::LanguageModelContainer::model_locales(KB::LanguageModelContainer *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  if (v2 != v3)
  {
    BOOL v5 = 0;
    unint64_t v6 = 0;
    do
    {
      (*(void (**)(void **__return_ptr))(**(void **)v2 + 176))(&__p);
      uint64_t v7 = (char *)__p;
      if (v31 - (unsigned char *)__p >= 1)
      {
        uint64_t v8 = (v31 - (unsigned char *)__p) >> 3;
        int v9 = a2[2];
        if (v8 <= (v9 - v6) >> 3)
        {
          if (v8 <= 0)
          {
            uint64_t v16 = (char *)__p + 8 * v8;
            unint64_t v17 = &v6[-8 * v8];
            char v18 = v6;
            while (v17 < v6)
            {
              uint64_t v19 = *(void *)v17;
              v17 += 8;
              *(void *)char v18 = v19;
              v18 += 8;
            }
            a2[1] = v18;
            if (v6 != &v6[8 * v8]) {
              memmove(&v6[-8 * ((-8 * v8) >> 3)], v6, -8 * v8);
            }
            if (v16 != v7) {
              memmove(v6, v7, v16 - v7);
            }
            unint64_t v6 = v18;
          }
          else
          {
            int64_t v15 = v31 - (unsigned char *)__p;
            if (v31 != __p) {
              memmove(v6, __p, v31 - (unsigned char *)__p);
            }
            a2[1] = &v6[v15];
            v6 += v15;
          }
        }
        else
        {
          uint64_t v10 = (v6 - v5) >> 3;
          unint64_t v11 = v10 + v8;
          if ((unint64_t)(v10 + v8) >> 61) {
            abort();
          }
          uint64_t v12 = v9 - v5;
          if (v12 >> 2 > v11) {
            unint64_t v11 = v12 >> 2;
          }
          if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v11;
          }
          if (v13)
          {
            if (v13 >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unint64_t v14 = (char *)operator new(8 * v13);
          }
          else
          {
            unint64_t v14 = 0;
          }
          BOOL v5 = &v14[8 * v10];
          uint64_t v20 = &v5[8 * v8];
          uint64_t v21 = 8 * v8;
          float v22 = v5;
          do
          {
            uint64_t v23 = *(void *)v7;
            v7 += 8;
            *(void *)float v22 = v23;
            v22 += 8;
            v21 -= 8;
          }
          while (v21);
          int v24 = (char *)*a2;
          if (*a2 == v6)
          {
            uint64_t v27 = v6;
          }
          else
          {
            std::string v25 = v6;
            do
            {
              uint64_t v26 = *((void *)v25 - 1);
              v25 -= 8;
              *((void *)v5 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v26;
              v5 -= 8;
            }
            while (v25 != v24);
            uint64_t v27 = (char *)a2[1];
          }
          uint64_t v28 = v27 - v6;
          if (v27 != v6) {
            memmove(v20, v6, v27 - v6);
          }
          uint64_t v29 = *a2;
          unint64_t v6 = &v20[v28];
          *a2 = v5;
          a2[1] = &v20[v28];
          a2[2] = &v14[8 * v13];
          if (v29) {
            operator delete(v29);
          }
        }
      }
      if (__p)
      {
        uint64_t v31 = __p;
        operator delete(__p);
      }
      v2 += 56;
    }
    while (v2 != v3);
  }
}

uint64_t KB::LanguageModelContainer::does_provide_inline_completions_for_locale(KB::LanguageModelContainer *this, const String *a2)
{
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  if (v2 == v3) {
    return 0;
  }
  uint64_t v5 = v2 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, const String *))(**(void **)(v5 - 56) + 168))(*(void *)(v5 - 56), a2);
    if (result) {
      break;
    }
    BOOL v7 = v5 == v3;
    v5 += 56;
  }
  while (!v7);
  return result;
}

uint64_t KB::LanguageModelContainer::does_provide_inline_completions(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 160))(*(void *)(v3 - 56));
    if (result) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::advanced_models_loaded(KB::LanguageModelContainer *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 3);
  uint64_t v2 = (uint64_t *)*((void *)this + 4);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v3 = 0;
  do
  {
    uint64_t v4 = *v1;
    v1 += 7;
    v3 += (*(unsigned int (**)(uint64_t))(*(void *)v4 + 160))(v4);
  }
  while (v1 != v2);
  return v3;
}

uint64_t KB::LanguageModelContainer::does_provide_completions(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 1;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 144))(*(void *)(v3 - 56));
    if (result) {
      BOOL v5 = v3 == v2;
    }
    else {
      BOOL v5 = 1;
    }
    v3 += 56;
  }
  while (!v5);
  return result;
}

void KB::LanguageModelContainer::reset_state_cache(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a2 || a2 == 2)
  {
    int64_t v15 = *(uint64_t **)(a1 + 24);
    unint64_t v14 = *(uint64_t **)(a1 + 32);
    while (v15 != v14)
    {
      uint64_t v16 = *v15;
      v15 += 7;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v16 + 136))(v16, a2);
    }
  }
  else if (a2 == 1)
  {
    uint64_t v4 = *(KB::LanguageModelLexiconGroup **)(a1 + 24);
    BOOL v5 = *(KB::LanguageModelLexiconGroup **)(a1 + 32);
    if (v4 != v5)
    {
      unint64_t v6 = MEMORY[0x1E4F14500];
      while (1)
      {
        KB::LanguageModelLexiconGroup::lexicon_group_identifier(v4, (uint64_t)__p);
        BOOL v7 = v18 >= 0 ? __p : (void **)__p[0];
        uint64_t v8 = *(uint64_t **)(a1 + 24);
        if (v8 == *(uint64_t **)(a1 + 32)) {
          break;
        }
        uint64_t v10 = *v8;
        int v9 = (std::__shared_weak_count *)v8[1];
        if (!v9) {
          goto LABEL_13;
        }
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v11 = *(void *)v4 == v10;
        std::__shared_weak_count::__release_shared[abi:nn180100](v9);
LABEL_14:
        if (v11) {
          uint64_t v12 = 1;
        }
        else {
          uint64_t v12 = 2;
        }
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          unint64_t v13 = off_1E6E2D378[v12];
          *(_DWORD *)std::string buf = 136315650;
          uint64_t v20 = "reset_state_cache";
          __int16 v21 = 2080;
          float v22 = v7;
          __int16 v23 = 2080;
          int v24 = v13;
          _os_log_impl(&dword_1E3F0E000, v6, OS_LOG_TYPE_DEFAULT, "%s  Resetting state cache for %s model with %s", buf, 0x20u);
        }
        (*(void (**)(void, uint64_t))(**(void **)v4 + 136))(*(void *)v4, v12);
        if (v18 < 0) {
          operator delete(__p[0]);
        }
        uint64_t v4 = (KB::LanguageModelLexiconGroup *)((char *)v4 + 56);
        if (v4 == v5) {
          return;
        }
      }
      uint64_t v10 = 0;
LABEL_13:
      BOOL v11 = *(void *)v4 == v10;
      goto LABEL_14;
    }
  }
}

uint64_t KB::LanguageModelContainer::clear_recent_text_cache(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 128))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::clear_dynamic_learning_cache(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 120))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::set_dynamic_resource_directory(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(result + 24);
  for (uint64_t i = *(uint64_t **)(result + 32);
        v2 != i;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 112))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::remove_dynamic_resource_directory(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 104))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::synchronized_load(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 24);
  uint64_t v2 = *(uint64_t **)(this + 32);
  while (v1 != v2)
  {
    uint64_t v3 = *v1;
    v1 += 7;
    this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 96))(v3);
  }
  return this;
}

uint64_t KB::LanguageModelContainer::reload_with_locales(uint64_t this, const __CFArray *a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, const __CFArray *))(*(void *)v5 + 80))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::load(uint64_t this, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  for (uint64_t i = *(uint64_t **)(this + 32);
        v2 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v5 + 72))(v5, a2))
  {
    uint64_t v5 = *v2;
    v2 += 7;
  }
  return this;
}

uint64_t KB::LanguageModelContainer::does_support_english(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 64))(*(void *)(v3 - 56));
    if (result) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

void KB::LanguageModelContainer::active_locale_identifiers_vector(KB::LanguageModelContainer *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  if (v2 != v3)
  {
    BOOL v5 = 0;
    do
    {
      (*(void (**)(void **__return_ptr))(**(void **)v2 + 56))(&v18);
      unint64_t v6 = v18;
      BOOL v7 = v19;
      if (v18 != v19)
      {
        do
        {
          unint64_t v8 = a2[2];
          if ((unint64_t)v5 >= v8)
          {
            int v9 = (void *)*a2;
            uint64_t v10 = ((uint64_t)v5 - *a2) >> 3;
            unint64_t v11 = v10 + 1;
            if ((unint64_t)(v10 + 1) >> 61) {
              abort();
            }
            uint64_t v12 = v8 - (void)v9;
            if (v12 >> 2 > v11) {
              unint64_t v11 = v12 >> 2;
            }
            if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v13 = v11;
            }
            if (v13) {
              unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v13);
            }
            else {
              uint64_t v14 = 0;
            }
            int64_t v15 = (void *)(v13 + 8 * v10);
            *int64_t v15 = *v6;
            uint64_t v16 = v15 + 1;
            if (v5 != v9)
            {
              do
              {
                uint64_t v17 = *--v5;
                *--int64_t v15 = v17;
              }
              while (v5 != v9);
              BOOL v5 = (void *)*a2;
            }
            *a2 = v15;
            a2[1] = v16;
            a2[2] = v13 + 8 * v14;
            if (v5) {
              operator delete(v5);
            }
            BOOL v5 = v16;
          }
          else
          {
            *v5++ = *v6;
          }
          a2[1] = v5;
          ++v6;
        }
        while (v6 != v7);
        unint64_t v6 = v18;
      }
      if (v6)
      {
        uint64_t v19 = v6;
        operator delete(v6);
      }
      v2 += 56;
    }
    while (v2 != v3);
  }
}

void KB::LanguageModelContainer::lexicon_id_vector(KB::LanguageModelContainer *this@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v3 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v3 != v2)
  {
    BOOL v5 = 0;
    uint64_t v17 = *((void *)this + 4);
    do
    {
      if (*(void *)v3)
      {
        (*(void (**)(_DWORD **__return_ptr))(**(void **)v3 + 48))(&v18);
        unint64_t v6 = v18;
        BOOL v7 = v19;
        if (v18 != v19)
        {
          unint64_t v8 = (unint64_t)a2[2];
          int v9 = *a2;
          do
          {
            if ((unint64_t)v5 >= v8)
            {
              uint64_t v10 = (v5 - v9) >> 2;
              unint64_t v11 = v10 + 1;
              if ((unint64_t)(v10 + 1) >> 62) {
                abort();
              }
              if ((uint64_t)(v8 - (void)v9) >> 1 > v11) {
                unint64_t v11 = (uint64_t)(v8 - (void)v9) >> 1;
              }
              if (v8 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v12 = v11;
              }
              if (v12) {
                unint64_t v12 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v12);
              }
              else {
                uint64_t v13 = 0;
              }
              uint64_t v14 = (char *)(v12 + 4 * v10);
              *(_DWORD *)uint64_t v14 = *v6;
              int64_t v15 = v14 + 4;
              while (v5 != v9)
              {
                int v16 = *((_DWORD *)v5 - 1);
                v5 -= 4;
                *((_DWORD *)v14 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v16;
                v14 -= 4;
              }
              unint64_t v8 = v12 + 4 * v13;
              *a2 = v14;
              a2[1] = v15;
              a2[2] = (char *)v8;
              if (v9) {
                operator delete(v9);
              }
              int v9 = v14;
              BOOL v5 = v15;
            }
            else
            {
              *(_DWORD *)BOOL v5 = *v6;
              v5 += 4;
            }
            a2[1] = v5;
            ++v6;
          }
          while (v6 != v7);
          uint64_t v2 = v17;
          unint64_t v6 = v18;
        }
        if (v6)
        {
          uint64_t v19 = v6;
          operator delete(v6);
        }
      }
      v3 += 56;
    }
    while (v3 != v2);
  }
}

uint64_t KB::LanguageModelContainer::lexicon_id(KB::LanguageModelContainer *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t KB::LanguageModelContainer::is_string_based_lm_model(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 24))(*(void *)(v3 - 56));
    if (result) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 56;
  }
  while (!v5);
  return result;
}

uint64_t KB::LanguageModelContainer::is_valid(KB::LanguageModelContainer *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 4);
  if (v1 == v2) {
    return 1;
  }
  uint64_t v3 = v1 + 56;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 56) + 16))(*(void *)(v3 - 56));
    if (result) {
      BOOL v5 = v3 == v2;
    }
    else {
      BOOL v5 = 1;
    }
    v3 += 56;
  }
  while (!v5);
  return result;
}

void KB::LanguageModelContainer::~LanguageModelContainer(KB::LanguageModelContainer *this)
{
  KB::LanguageModelContainer::~LanguageModelContainer(this);

  JUMPOUT(0x1E4E7BC20);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  void **v6;

  *(void *)this = &unk_1F3F73630;
  uint64_t v2 = (void *)*((void *)this + 8);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,NSObject  {objcproto17OS_dispatch_queue}* {__strong}>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v4) {
    operator delete(v4);
  }
  unint64_t v6 = (void **)((char *)this + 24);
  std::vector<KB::LanguageModelLexiconGroup>::__destroy_vector::operator()[abi:nn180100](&v6);
  BOOL v5 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v5) {
    std::__shared_weak_count::__release_weak(v5);
  }
}

uint64_t KB::LanguageModelLexiconGroup::LanguageModelLexiconGroup(uint64_t a1, uint64_t *a2)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 48) = 1065353216;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    BOOL v5 = *(std::__shared_weak_count **)(a1 + 8);
    *(void *)a1 = v3;
    *(void *)(a1 + 8) = v4;
    if (v5) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v5);
    }
  }
  else
  {
    *(void *)a1 = v3;
    *(void *)(a1 + 8) = 0;
  }
  return a1;
}

float *KB::LanguageModelLexiconGroup::set_lexicon_weight(KB::LanguageModelLexiconGroup *this, unsigned int a2, float a3)
{
  unsigned int v5 = a2;
  uint64_t result = (float *)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>((uint64_t)this + 16, a2, &v5);
  result[5] = a3;
  return result;
}

uint64_t KB::LanguageModelLexiconGroup::lexicon_id_vector@<X0>(KB::LanguageModelLexiconGroup *this@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)this;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return result;
}

double KB::LanguageModelLexiconGroup::any_lexicon_weight(KB::LanguageModelLexiconGroup *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 0.0;
  }
  LODWORD(result) = *(_DWORD *)(v1 + 20);
  return result;
}

uint64_t KB::LanguageModelContainer::LanguageModelContainer(uint64_t a1, uint64_t *a2)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1F3F73630;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (v4 != *a2)
  {
    unint64_t v5 = 0x6DB6DB6DB6DB6DB7 * ((v4 - *a2) >> 3);
    if (v5 >= 0x492492492492493) {
      abort();
    }
    unint64_t v6 = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LanguageModelLexiconGroup>>(v5);
    *(void *)(a1 + 24) = v6;
    *(void *)(a1 + 32) = v6;
    *(void *)(a1 + 40) = &v6[7 * v7];
    uint64_t v8 = v3 + 16;
    do
    {
      uint64_t v9 = *(void *)(v8 - 8);
      uint64_t v10 = v8 - 16;
      *unint64_t v6 = *(void *)(v8 - 16);
      v6[1] = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      std::unordered_map<unsigned int,float>::unordered_map((uint64_t)(v6 + 2), v8);
      v6 += 7;
      v8 += 56;
    }
    while (v10 + 56 != v4);
    *(void *)(a1 + 32) = v6;
  }
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_DWORD *)(a1 + 80) = 1065353216;
  return a1;
}

double KB::LanguageModelContainer::lexicon_prior_probability(KB::LanguageModelContainer *this, unsigned int a2)
{
  uint64_t v4 = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (v4 == -1) {
    return 0.0;
  }
  unint64_t v5 = (KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * v4);

  *(float *)&double result = KB::LanguageModelLexiconGroup::lexicon_weight(v5, a2);
  return result;
}

uint64_t KB::LanguageModelContainer::set_lexicon_prior_probability(KB::LanguageModelContainer *this, unsigned int a2, float a3)
{
  uint64_t result = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (result != -1)
  {
    uint64_t v7 = *((void *)this + 3);
    unsigned int v8 = a2;
    uint64_t result = (uint64_t)std::__hash_table<std::__hash_value_type<unsigned int,float>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,float>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,float>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,float>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v7 + 56 * result + 16, a2, &v8);
    *(float *)(result + 20) = a3;
  }
  return result;
}

uint64_t KB::LanguageModelContainer::language_model@<X0>(KB::LanguageModelContainer *this@<X0>, int a2@<W1>, void *a3@<X8>)
{
  uint64_t result = KB::LanguageModelContainer::index_for_lexicon_id(this, a2);
  if (result == -1)
  {
    *a3 = 0;
    a3[1] = 0;
  }
  else
  {
    unint64_t v6 = (uint64_t *)(*((void *)this + 3) + 56 * result);
    uint64_t v8 = *v6;
    uint64_t v7 = v6[1];
    *a3 = v8;
    a3[1] = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
  }
  return result;
}

uint64_t KB::LanguageModelContainer::language_models@<X0>(uint64_t this@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = *(long long **)(this + 24);
  uint64_t v3 = *(long long **)(this + 32);
  if (v2 != v3)
  {
    unint64_t v5 = 0;
    unint64_t v6 = a2 + 2;
    do
    {
      if ((unint64_t)v5 >= *v6)
      {
        uint64_t v8 = (v5 - *a2) >> 4;
        if ((unint64_t)(v8 + 1) >> 60) {
          abort();
        }
        uint64_t v9 = *v6 - (void)*a2;
        uint64_t v10 = v9 >> 3;
        if (v9 >> 3 <= (unint64_t)(v8 + 1)) {
          uint64_t v10 = v8 + 1;
        }
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        uint64_t v25 = v6;
        unint64_t v12 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::shared_ptr<KB::LanguageModel>>>(v11);
        uint64_t v14 = &v12[16 * v8];
        long long v15 = *v2;
        *(_OWORD *)uint64_t v14 = *v2;
        if (*((void *)&v15 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v17 = *a2;
        int v16 = a2[1];
        if (v16 == *a2)
        {
          int64x2_t v20 = vdupq_n_s64((unint64_t)v16);
          char v18 = &v12[16 * v8];
        }
        else
        {
          char v18 = &v12[16 * v8];
          do
          {
            long long v19 = *((_OWORD *)v16 - 1);
            v16 -= 16;
            *((_OWORD *)v18 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v19;
            v18 -= 16;
            *(void *)int v16 = 0;
            *((void *)v16 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
          }
          while (v16 != v17);
          int64x2_t v20 = *(int64x2_t *)a2;
        }
        unint64_t v5 = v14 + 16;
        *a2 = v18;
        a2[1] = v14 + 16;
        int64x2_t v23 = v20;
        __int16 v21 = a2[2];
        a2[2] = &v12[16 * v13];
        int v24 = v21;
        uint64_t v22 = v20.i64[0];
        this = std::__split_buffer<std::shared_ptr<KB::LanguageModel>>::~__split_buffer((uint64_t)&v22);
      }
      else
      {
        *(void *)unint64_t v5 = *(void *)v2;
        uint64_t v7 = *((void *)v2 + 1);
        *((void *)v5 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v7;
        if (v7) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
        }
        v5 += 16;
      }
      a2[1] = v5;
      uint64_t v2 = (long long *)((char *)v2 + 56);
    }
    while (v2 != v3);
  }
  return this;
}

void KB::LanguageModelContainer::prior_lexicon_probabilities(KB::LanguageModelContainer *this@<X0>, float **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (KB::LanguageModelLexiconGroup *)*((void *)this + 3);
  uint64_t v3 = (KB::LanguageModelLexiconGroup *)*((void *)this + 4);
  if (v2 != v3)
  {
    unint64_t v5 = 0;
    long long v19 = (KB::LanguageModelLexiconGroup *)*((void *)this + 4);
    do
    {
      if (*(void *)v2)
      {
        (*(void (**)(unsigned int **__return_ptr))(**(void **)v2 + 48))(&v20);
        unint64_t v6 = v20;
        uint64_t v7 = v21;
        if (v20 != v21)
        {
          unint64_t v8 = (unint64_t)a2[2];
          uint64_t v9 = *a2;
          do
          {
            float v10 = KB::LanguageModelLexiconGroup::lexicon_weight(v2, *v6);
            float v11 = v10;
            if ((unint64_t)v5 >= v8)
            {
              uint64_t v12 = v5 - v9;
              unint64_t v13 = v12 + 1;
              if ((unint64_t)(v12 + 1) >> 62) {
                abort();
              }
              if ((uint64_t)(v8 - (void)v9) >> 1 > v13) {
                unint64_t v13 = (uint64_t)(v8 - (void)v9) >> 1;
              }
              if (v8 - (unint64_t)v9 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v14 = v13;
              }
              if (v14) {
                unint64_t v14 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v14);
              }
              else {
                uint64_t v15 = 0;
              }
              int v16 = (float *)(v14 + 4 * v12);
              *int v16 = v11;
              uint64_t v17 = v16 + 1;
              while (v5 != v9)
              {
                int v18 = *((_DWORD *)v5-- - 1);
                *((_DWORD *)v16-- - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v18;
              }
              unint64_t v8 = v14 + 4 * v15;
              *a2 = v16;
              a2[1] = v17;
              a2[2] = (float *)v8;
              if (v9) {
                operator delete(v9);
              }
              uint64_t v9 = v16;
              unint64_t v5 = v17;
            }
            else
            {
              *v5++ = v10;
            }
            a2[1] = v5;
            ++v6;
          }
          while (v6 != v7);
          uint64_t v3 = v19;
          unint64_t v6 = v20;
        }
        if (v6)
        {
          __int16 v21 = v6;
          operator delete(v6);
        }
      }
      uint64_t v2 = (KB::LanguageModelLexiconGroup *)((char *)v2 + 56);
    }
    while (v2 != v3);
  }
}

uint64_t KB::LanguageModelContainer::primary_language_model@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(uint64_t **)(this + 24);
  if (v2 == *(uint64_t **)(this + 32))
  {
    *a2 = 0;
    a2[1] = 0;
  }
  else
  {
    uint64_t v4 = *v2;
    uint64_t v3 = v2[1];
    *a2 = v4;
    a2[1] = v3;
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
  }
  return this;
}

float KB::LanguageModelContainer::lexicon_transition_probability(KB::LanguageModelContainer *this, uint64_t a2, unsigned int a3)
{
  return KB::LanguageModelLexiconGroup::lexicon_weight((KB::LanguageModelLexiconGroup *)(*((void *)this + 3) + 56 * a2), a3)* 0.04;
}

BOOL KB::LanguageModelContainer::PredictionEnumeratorContainer::has_more_predictions(KB::LanguageModelContainer::PredictionEnumeratorContainer *this)
{
  uint64_t v1 = *((void *)this + 9);
  return v1 != -1 && *(float *)(*((void *)this + 4) + 160 * v1 + 24) > 0.0;
}

void TI::IndicUtils::convertLetterToSign(uint64_t *a1@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!*((_WORD *)a1 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a1);
    if (!*((_WORD *)a1 + 2))
    {
      *(_DWORD *)a3 = 0x100000;
      *(_WORD *)(a3 + 4) = 0;
      *(unsigned char *)(a3 + 6) = 0;
      *(void *)(a3 + 8) = 0;
      KB::String::operator=(a3, (KB::String *)a1);
      return;
    }
  }
  KB::String::String((KB::String *)a3, (const KB::String *)a1);
  KB::String::String((KB::String *)&v44, "ॲ");
  if (&v44 == a1)
  {
    int v16 = (void *)a1[1];
    if (v16 && *((unsigned char *)a1 + 6) == 1) {
      free(v16);
    }
  }
  else
  {
    BOOL v6 = KB::String::equal((KB::String *)a1, (const KB::String *)&v44, 1);
    if (v45 && BYTE6(v44) == 1) {
      free(v45);
    }
    if (!v6)
    {
      KB::String::String((KB::String *)&v44, "ഔ");
      if (&v44 == a1)
      {
        int v18 = (void *)a1[1];
        if (v18 && *((unsigned char *)a1 + 6) == 1) {
          free(v18);
        }
      }
      else
      {
        BOOL v7 = KB::String::equal((KB::String *)a1, (const KB::String *)&v44, 1);
        if (v45 && BYTE6(v44) == 1) {
          free(v45);
        }
        if (!v7)
        {
          uint64_t v8 = 0;
          unsigned int v9 = *((unsigned __int16 *)a1 + 2);
          int64x2_t v23 = (KB::String *)a3;
          while (1)
          {
            unsigned int v10 = TI::IndicUtils::kVowelLettersA[v8];
            if (!v9)
            {
              KB::String::compute_length((unsigned __int16 *)a1);
              unsigned int v9 = *((unsigned __int16 *)a1 + 2);
            }
            uint64_t v11 = a1[1];
            int v12 = *(unsigned __int16 *)a1;
            if (v9 > 1)
            {
              unint64_t v13 = a2;
              if (v11) {
                uint64_t v14 = a1[1];
              }
              else {
                uint64_t v14 = (uint64_t)(a1 + 2);
              }
              uint64_t v44 = v14;
              LODWORD(v45) = 0;
              HIDWORD(v45) = v12;
              unsigned int v46 = 0;
              KB::String::iterator::initialize(&v44);
              if (v46 == v10)
              {
                *(void *)&long long v28 = v14;
                DWORD2(v28) = 0;
                HIDWORD(v28) = v12;
                LODWORD(v29) = 0;
                KB::String::iterator::initialize((uint64_t *)&v28);
                long long v42 = v28;
                uint64_t v43 = v29;
                KB::String::iterator::operator++((uint64_t *)&v42);
                uint64_t v24 = v14;
                int v25 = v12;
                int v26 = v12;
                int v27 = 0;
                KB::String::iterator::initialize(&v24);
                KB::String::String((KB::String *)&v44, (const KB::String::iterator *)&v42, (const KB::String::iterator *)&v24);
                if (v10 == 2437 || v10 == 2821)
                {
                  KB::String::String((KB::String *)v36, (const KB::String *)&v44);
                  a2 = v13;
                  KB::String::String((KB::String *)v34, v13);
                  BOOL v22 = !shouldConvertToSign_beng_orya((KB::String *)v36, (KB::String *)v34);
                }
                else
                {
                  BOOL v22 = 0;
                  a2 = v13;
                  if (v10 == 2565)
                  {
                    KB::String::String((KB::String *)v40, (const KB::String *)&v44);
                    KB::String::String((KB::String *)v38, v13);
                    convertTippiToBindiIfNeeded((uint64_t)&v42, (const KB::String *)v40, (KB::String *)v38);
                    KB::String::operator=((uint64_t)&v44, (KB::String *)&v42);
                    a3 = (uint64_t)v23;
                    if (*((void *)&v42 + 1) && BYTE6(v42) == 1) {
                      free(*((void **)&v42 + 1));
                    }
                    if (v39 && v38[6] == 1) {
                      free(v39);
                    }
                    if (v41 && v40[6] == 1) {
                      free(v41);
                    }
                    goto LABEL_80;
                  }
                }
                a3 = (uint64_t)v23;
                if (v10 == 2821 || v10 == 2437)
                {
                  if (v35 && v34[6] == 1) {
                    free(v35);
                  }
                  if (v37 && v36[6] == 1) {
                    free(v37);
                  }
                  if (!v22) {
                    goto LABEL_80;
                  }
LABEL_79:
                  KB::String::operator=((KB::String *)&v44, (KB::String *)a1);
                }
                else if (v22)
                {
                  goto LABEL_79;
                }
LABEL_80:
                KB::String::operator=((KB::String *)a3, (KB::String *)&v44);
LABEL_81:
                long long v19 = v45;
                if (v45)
                {
                  int v20 = BYTE6(v44);
                  goto LABEL_43;
                }
                goto LABEL_45;
              }
              a2 = v13;
              a3 = (uint64_t)v23;
            }
            if (!v11) {
              uint64_t v11 = (uint64_t)(a1 + 2);
            }
            uint64_t v44 = v11;
            LODWORD(v45) = 0;
            HIDWORD(v45) = v12;
            unsigned int v46 = 0;
            KB::String::iterator::initialize(&v44);
            if (v46 > v10 && v10 + 16 > v46)
            {
              uint64_t v44 = v11;
              LODWORD(v45) = 0;
              HIDWORD(v45) = v12;
              unsigned int v46 = 0;
              KB::String::iterator::initialize(&v44);
              KB::String::String((uint64_t)&v44, v46 + 56);
              KB::String::operator=(a3, (KB::String *)&v44);
              goto LABEL_81;
            }
            if (++v8 == 9) {
              goto LABEL_45;
            }
          }
        }
      }
      uint64_t v17 = "ൗ";
      goto LABEL_41;
    }
  }
  uint64_t v17 = "ॅ";
LABEL_41:
  KB::String::String((KB::String *)&v42, v17);
  KB::String::operator=(a3, (KB::String *)&v42);
  long long v19 = (void *)*((void *)&v42 + 1);
  if (*((void *)&v42 + 1))
  {
    int v20 = BYTE6(v42);
LABEL_43:
    if (v20 == 1) {
      free(v19);
    }
  }
LABEL_45:
  KB::String::String((KB::String *)v32, (const KB::String *)a3);
  KB::String::String((KB::String *)v30, a2);
  char v21 = shouldAddSignToContext((uint64_t)v32, (KB::String *)v30);
  if (v31 && v30[6] == 1) {
    free(v31);
  }
  if (v33 && v32[6] == 1) {
    free(v33);
  }
  if ((v21 & 1) == 0) {
    KB::String::operator=((KB::String *)a3, (KB::String *)a1);
  }
}

uint64_t convertTippiToBindiIfNeeded(uint64_t a1, const KB::String *a2, KB::String *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (KB::String::last(a2) == 2672)
  {
    if ((int v6 = KB::String::last(a3), (v6 - 2566) <= 0x3A)
      && ((1 << (v6 - 6)) & 0x50000000000661DLL) != 0
      || (v6 - 2631) <= 5 && ((1 << (v6 - 71)) & 0x33) != 0)
    {
      KB::String::String((KB::String *)v8, a2);
      convertTippiToBindi((uint64_t)v10, (KB::String *)v8);
      KB::String::operator=((uint64_t)a2, (KB::String *)v10);
      if (v11 && v10[6] == 1) {
        free(v11);
      }
      if (v9 && v8[6] == 1) {
        free(v9);
      }
    }
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + 8) = 0;
  return KB::String::operator=(a1, a2);
}

BOOL shouldConvertToSign_beng_orya(KB::String *a1, KB::String *a2)
{
  return (a1 != (KB::String *)&kVowelSignYAPHALAA_beng
       && !KB::String::equal(a1, (const KB::String *)&kVowelSignYAPHALAA_beng, 1)
       || KB::String::last(a2) - 2494 >= 0xF)
      && (a1 != (KB::String *)&kVowelSignYAPHALAA_orya
       && !KB::String::equal(a1, (const KB::String *)&kVowelSignYAPHALAA_orya, 1)
       || KB::String::last(a2) - 2878 >= 0xF);
}

unint64_t shouldAddSignToContext(uint64_t a1, KB::String *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  KB::String::String((KB::String *)v20, "ँ");
  if (v20 == (unsigned char *)a1)
  {
    unsigned int v9 = *(void **)(a1 + 8);
    if (v9 && *(unsigned char *)(a1 + 6) == 1) {
      free(v9);
    }
  }
  else
  {
    BOOL v4 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
    if (v22) {
      BOOL v5 = v21 == 1;
    }
    else {
      BOOL v5 = 0;
    }
    if (v5) {
      free(v22);
    }
    if (!v4)
    {
      KB::String::String((KB::String *)v20, "ં");
      if (v20 == (unsigned char *)a1)
      {
        unint64_t v13 = *(void **)(a1 + 8);
        if (v13 && *(unsigned char *)(a1 + 6) == 1) {
          free(v13);
        }
      }
      else
      {
        BOOL v6 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
        if (v22 && v21 == 1) {
          free(v22);
        }
        if (!v6)
        {
          KB::String::String((KB::String *)v20, "ઁ");
          if (v20 == (unsigned char *)a1)
          {
            uint64_t v15 = *(void **)(a1 + 8);
            if (v15 && *(unsigned char *)(a1 + 6) == 1) {
              free(v15);
            }
          }
          else
          {
            BOOL v7 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
            if (v22 && v21 == 1) {
              free(v22);
            }
            if (!v7)
            {
              KB::String::String((KB::String *)v20, "ੱ");
              if (v20 == (unsigned char *)a1)
              {
                uint64_t v17 = *(void **)(a1 + 8);
                if (v17 && *(unsigned char *)(a1 + 6) == 1) {
                  free(v17);
                }
LABEL_50:
                int v18 = KB::String::last(a2);
                if ((v18 - 2566) > 0x3C
                  || ((1 << (v18 - 6)) & 0x1500000000006615) == 0)
                {
                  unint64_t result = 1;
                  unsigned int v19 = v18 - 2631;
                  if (v19 > 5 || ((1 << v19) & 0x33) == 0) {
                    return result;
                  }
                }
                return 0;
              }
              BOOL v8 = KB::String::equal((KB::String *)a1, (const KB::String *)v20, 1);
              if (v22 && v21 == 1) {
                free(v22);
              }
              if (v8) {
                goto LABEL_50;
              }
              return 1;
            }
          }
          int v16 = KB::String::last(a2);
          return ((v16 - 2701) > 0x3F
               || ((1 << (v16 + 115)) & 0xDD0C0000000000DDLL) == 0)
              && (v16 - 2695) >= 4;
        }
      }
      int v14 = KB::String::last(a2);
      if ((v14 - 2701) >= 0x3D) {
        return 1;
      }
      else {
        return (0xEFFFFFFFFFFFFEEuLL >> (v14 + 115)) & 1;
      }
    }
  }
  int v10 = KB::String::last(a2);
  if ((v10 - 2312) <= 0x3D && ((1 << (v10 - 8)) & 0x2180000000001B01) != 0) {
    return 0;
  }
  unint64_t result = 1;
  unsigned int v12 = v10 - 2375;
  if (v12 <= 0x2B && ((1 << v12) & 0x80000000037) != 0) {
    return 0;
  }
  return result;
}

uint64_t KB::String::last(KB::String *this)
{
  int v1 = *(unsigned __int16 *)this;
  if (!*(_WORD *)this) {
    return 0;
  }
  uint64_t v2 = (char *)*((void *)this + 1);
  if (!v2) {
    uint64_t v2 = (char *)this + 16;
  }
  *(void *)&long long v4 = v2;
  DWORD2(v4) = v1;
  HIDWORD(v4) = v1;
  LODWORD(v5) = 0;
  KB::String::iterator::initialize((uint64_t *)&v4);
  long long v6 = v4;
  uint64_t v7 = v5;
  KB::String::iterator::operator--((KB::String::iterator *)&v6);
  return v7;
}

uint64_t convertTippiToBindi(uint64_t a1, KB::String *a2)
{
  if (KB::String::last(a2) == 2672)
  {
    KB::String::pop_last(a2);
    KB::String::append(a2, 0xA02u);
  }
  *(_DWORD *)a1 = 0x100000;
  *(_WORD *)(a1 + 4) = 0;
  *(unsigned char *)(a1 + 6) = 0;
  *(void *)(a1 + 8) = 0;

  return KB::String::operator=(a1, a2);
}

void TI::IndicUtils::convertModifierLetterToSign(unsigned __int16 *a1@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unsigned int v6 = a1[2];
  if (!a1[2])
  {
    KB::String::compute_length(a1);
    unsigned int v6 = a1[2];
  }
  if (v6 <= 1)
  {
    *(_DWORD *)a3 = 0x100000;
    *(_WORD *)(a3 + 4) = 0;
    *(unsigned char *)(a3 + 6) = 0;
    *(void *)(a3 + 8) = 0;
    KB::String::operator=(a3, (KB::String *)a1);
    return;
  }
  KB::String::String((KB::String *)a3, (const KB::String *)a1);
  uint64_t v7 = 0;
  if (*((void *)a1 + 1)) {
    uint64_t v8 = *((void *)a1 + 1);
  }
  else {
    uint64_t v8 = (uint64_t)(a1 + 8);
  }
  int v9 = *a1;
  while (1)
  {
    int v10 = TI::IndicUtils::kVowelLettersA[v7];
    uint64_t v33 = v8;
    LODWORD(v34) = 0;
    HIDWORD(v34) = v9;
    int v35 = 0;
    KB::String::iterator::initialize(&v33);
    if (v35 == v10) {
      break;
    }
    if (++v7 == 9) {
      goto LABEL_42;
    }
  }
  *(void *)&long long v17 = v8;
  DWORD2(v17) = 0;
  HIDWORD(v17) = v9;
  LODWORD(v18) = 0;
  KB::String::iterator::initialize((uint64_t *)&v17);
  long long v31 = v17;
  uint64_t v32 = v18;
  KB::String::iterator::operator++((uint64_t *)&v31);
  uint64_t v13 = v8;
  int v14 = v9;
  int v15 = v9;
  int v16 = 0;
  KB::String::iterator::initialize(&v13);
  KB::String::String((KB::String *)&v33, (const KB::String::iterator *)&v31, (const KB::String::iterator *)&v13);
  if (v10 == 2437 || v10 == 2821)
  {
    KB::String::String((KB::String *)v25, (const KB::String *)&v33);
    KB::String::String((KB::String *)v23, a2);
    BOOL v11 = !shouldConvertToSign_beng_orya((KB::String *)v25, (KB::String *)v23);
  }
  else
  {
    BOOL v11 = 0;
    if (v10 == 2565)
    {
      KB::String::String((KB::String *)v29, (const KB::String *)&v33);
      KB::String::String((KB::String *)v27, a2);
      convertTippiToBindiIfNeeded((uint64_t)&v31, (const KB::String *)v29, (KB::String *)v27);
      KB::String::operator=((uint64_t)&v33, (KB::String *)&v31);
      if (*((void *)&v31 + 1) && BYTE6(v31) == 1) {
        free(*((void **)&v31 + 1));
      }
      if (v28 && v27[6] == 1) {
        free(v28);
      }
      if (v30 && v29[6] == 1) {
        free(v30);
      }
      goto LABEL_39;
    }
  }
  if (v10 != 2821 && v10 != 2437)
  {
    if (!v11) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  if (v24 && v23[6] == 1) {
    free(v24);
  }
  if (v26 && v25[6] == 1) {
    free(v26);
  }
  if (v11) {
LABEL_38:
  }
    KB::String::operator=((KB::String *)&v33, (KB::String *)a1);
LABEL_39:
  KB::String::operator=((KB::String *)a3, (KB::String *)&v33);
  if (v34 && BYTE6(v33) == 1) {
    free(v34);
  }
LABEL_42:
  KB::String::String((KB::String *)v21, (const KB::String *)a3);
  KB::String::String((KB::String *)v19, a2);
  char v12 = shouldAddSignToContext((uint64_t)v21, (KB::String *)v19);
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  if (v22 && v21[6] == 1) {
    free(v22);
  }
  if ((v12 & 1) == 0) {
    KB::String::operator=((KB::String *)a3, (KB::String *)a1);
  }
}

void TI::IndicUtils::convertVowel(const KB::String *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  KB::String::String((KB::String *)&v38, a1);
  int v33 = 0x100000;
  __int16 v34 = 0;
  char v35 = 0;
  uint64_t v36 = 0;
  char v37 = 0;
  TI::IndicUtils::convertLetterToSign(&v38, (const KB::String *)&v33, (uint64_t)v40);
  if (v36) {
    BOOL v4 = v35 == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v36);
  }
  if (v39 && BYTE6(v38) == 1) {
    free(v39);
  }
  if (v40 == (unsigned char *)a1 || KB::String::equal((KB::String *)v40, a1, 1))
  {
    KB::String::String((KB::String *)v25, a1);
    if (v26 || (KB::String::compute_length(v25), v26))
    {
      KB::String::String((KB::String *)&v42, "ॅ");
      BOOL v5 = KB::String::equal((KB::String *)v25, (const KB::String *)&v42, 1);
      if (v43 && BYTE6(v42) == 1) {
        free(v43);
      }
      if (v5)
      {
        unsigned int v6 = "ॲ";
LABEL_19:
        KB::String::String((KB::String *)&v30, v6);
        goto LABEL_43;
      }
      if (KB::String::equal((KB::String *)v25, (const KB::String *)&kVowelSignYAPHALAA_beng, 1))
      {
        uint64_t v7 = (const KB::String *)&kVowelLetterYAPHALAA_beng;
      }
      else
      {
        if (!KB::String::equal((KB::String *)v25, (const KB::String *)&kVowelSignYAPHALAA_orya, 1))
        {
          KB::String::String((KB::String *)&v42, "ൗ");
          BOOL v8 = KB::String::equal((KB::String *)v25, (const KB::String *)&v42, 1);
          if (v43 && BYTE6(v42) == 1) {
            free(v43);
          }
          if (!v8)
          {
            uint64_t v9 = 0;
            if (v28) {
              int v10 = (uint64_t *)v28;
            }
            else {
              int v10 = &v29;
            }
            int v11 = v25[0];
            while (1)
            {
              unsigned int v12 = TI::IndicUtils::kVowelLettersA[v9];
              long long v42 = v10;
              LODWORD(v43) = 0;
              HIDWORD(v43) = v11;
              unsigned int v44 = 0;
              KB::String::iterator::initialize((uint64_t *)&v42);
              if (v12 - 4 <= v44 && v12 - 1 > v44) {
                break;
              }
              if ((v44 & 0xFFFFFFFE) == 0xA70) {
                break;
              }
              long long v42 = v10;
              LODWORD(v43) = 0;
              HIDWORD(v43) = v11;
              unsigned int v44 = 0;
              KB::String::iterator::initialize((uint64_t *)&v42);
              unsigned int v13 = v44 - 56;
              if (v44 - 56 > v12 && v12 + 16 > v13)
              {
                KB::String::String((uint64_t)&v30, v13);
                goto LABEL_43;
              }
              if (++v9 == 9) {
                goto LABEL_42;
              }
            }
            KB::String::String((uint64_t)&v42, v12);
            uint64_t v30 = v10;
            LODWORD(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            HIDWORD(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v11;
            unsigned int v32 = 0;
            KB::String::iterator::initialize((uint64_t *)&v30);
            unsigned int v20 = v32;
            KB::String::String((KB::String *)&v30, (const KB::String *)&v42);
            KB::String::append((KB::String *)&v30, v20);
            if (v43 && BYTE6(v42) == 1) {
              free(v43);
            }
            goto LABEL_43;
          }
          unsigned int v6 = "ഔ";
          goto LABEL_19;
        }
        uint64_t v7 = (const KB::String *)&kVowelLetterYAPHALAA_orya;
      }
      KB::String::String((KB::String *)&v30, v7);
    }
    else
    {
LABEL_42:
      LODWORD(v30) = 0x100000;
      WORD2(v30) = 0;
      BYTE6(v30) = 0;
      long long v31 = 0;
      KB::String::operator=((uint64_t)&v30, (KB::String *)v25);
    }
LABEL_43:
    KB::String::operator=((uint64_t)v40, (KB::String *)&v30);
    if (v31 && BYTE6(v30) == 1) {
      free(v31);
    }
    if (v28 && v27 == 1) {
      free(v28);
    }
  }
  int v15 = KB::String::last((KB::String *)v40);
  if (v15 > 2673)
  {
    if (v15 == 2674)
    {
      KB::String::String((KB::String *)a2, "ਇ");
      KB::String::String((KB::String *)(a2 + 32), "ਈ");
      uint64_t v18 = (KB::String *)(a2 + 64);
      unsigned int v19 = "ਏ";
    }
    else
    {
      if (v15 != 2675) {
        goto LABEL_65;
      }
      KB::String::String((KB::String *)a2, "ਉ");
      KB::String::String((KB::String *)(a2 + 32), "ਊ");
      uint64_t v18 = (KB::String *)(a2 + 64);
      unsigned int v19 = "ਓ";
    }
    KB::String::String(v18, v19);
    goto LABEL_66;
  }
  if (v15 != 2562)
  {
    if (v15 == 2672)
    {
      KB::String::String((KB::String *)a2, (const KB::String *)v40);
      KB::String::String((KB::String *)v23, (const KB::String *)v40);
      convertTippiToBindi(a2 + 32, (KB::String *)v23);
      *(_DWORD *)(a2 + 64) = 0x100000;
      *(_WORD *)(a2 + 68) = 0;
      *(unsigned char *)(a2 + 70) = 0;
      *(void *)(a2 + 72) = 0;
      *(unsigned char *)(a2 + 80) = 0;
      int v16 = v24;
      if (!v24) {
        goto LABEL_66;
      }
      int v17 = v23[6];
      goto LABEL_61;
    }
LABEL_65:
    KB::String::String((KB::String *)a2, (const KB::String *)v40);
    *(_DWORD *)(a2 + 32) = 0x100000;
    *(_WORD *)(a2 + 36) = 0;
    *(unsigned char *)(a2 + 38) = 0;
    *(void *)(a2 + 40) = 0;
    *(unsigned char *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 64) = 0x100000;
    *(_WORD *)(a2 + 68) = 0;
    *(unsigned char *)(a2 + 70) = 0;
    *(void *)(a2 + 72) = 0;
    *(unsigned char *)(a2 + 80) = 0;
    goto LABEL_66;
  }
  KB::String::String((KB::String *)a2, (const KB::String *)v40);
  KB::String::String((KB::String *)v21, (const KB::String *)v40);
  if (KB::String::last((KB::String *)v21) == 2562)
  {
    KB::String::pop_last((KB::String *)v21);
    KB::String::append((KB::String *)v21, 0xA70u);
  }
  *(_DWORD *)(a2 + 32) = 0x100000;
  *(_WORD *)(a2 + 36) = 0;
  *(unsigned char *)(a2 + 38) = 0;
  *(void *)(a2 + 40) = 0;
  KB::String::operator=(a2 + 32, (KB::String *)v21);
  *(_DWORD *)(a2 + 64) = 0x100000;
  *(_WORD *)(a2 + 68) = 0;
  *(unsigned char *)(a2 + 70) = 0;
  *(void *)(a2 + 72) = 0;
  *(unsigned char *)(a2 + 80) = 0;
  int v16 = v22;
  if (v22)
  {
    int v17 = v21[6];
LABEL_61:
    if (v17 == 1) {
      free(v16);
    }
  }
LABEL_66:
  if (v41)
  {
    if (v40[6] == 1) {
      free(v41);
    }
  }
}

uint64_t TI::IndicUtils::initialVowelLetterForScript(int a1)
{
  if (a1 <= 20)
  {
    if (a1 > 14)
    {
      if (a1 == 15) {
        return 2693;
      }
      if (a1 == 16) {
        return 2565;
      }
    }
    else
    {
      if (a1 == 4) {
        return 2437;
      }
      if (a1 == 10) {
        return 2309;
      }
    }
  }
  else if (a1 <= 30)
  {
    if (a1 == 21) {
      return 3205;
    }
    if (a1 == 26) {
      return 3333;
    }
  }
  else
  {
    switch(a1)
    {
      case 31:
        return 2821;
      case 35:
        return 2949;
      case 36:
        return 3077;
    }
  }
  return 0;
}

uint64_t TI::IndicUtils::viramaSignForScript(int a1)
{
  return TI::IndicUtils::initialVowelLetterForScript(a1) + 72;
}

uint64_t TI::IndicUtils::consonantLetterRAForScript(int a1)
{
  return TI::IndicUtils::initialVowelLetterForScript(a1) + 43;
}

BOOL TI::IndicUtils::isAlphabeticLayout(KB::String *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  KB::String::String((KB::String *)v23, "Bengali-Alphabetic");
  BOOL v2 = 1;
  if (!KB::String::equal(a1, (const KB::String *)v23, 1))
  {
    KB::String::String((KB::String *)v21, "Gujarati-Alphabetic");
    if (!KB::String::equal(a1, (const KB::String *)v21, 1))
    {
      KB::String::String((KB::String *)v19, "Hindi-Alphabetic");
      if (!KB::String::equal(a1, (const KB::String *)v19, 1))
      {
        KB::String::String((KB::String *)v17, "Kannada-Alphabetic");
        if (!KB::String::equal(a1, (const KB::String *)v17, 1))
        {
          KB::String::String((KB::String *)v15, "Malayalam-Alphabetic");
          if (!KB::String::equal(a1, (const KB::String *)v15, 1))
          {
            KB::String::String((KB::String *)v13, "Marathi-Alphabetic");
            if (!KB::String::equal(a1, (const KB::String *)v13, 1))
            {
              KB::String::String((KB::String *)v11, "Oriya-Alphabetic");
              if (!KB::String::equal(a1, (const KB::String *)v11, 1))
              {
                KB::String::String((KB::String *)v9, "Punjabi-Alphabetic");
                if (!KB::String::equal(a1, (const KB::String *)v9, 1))
                {
                  KB::String::String((KB::String *)v7, "Tamil-Alphabetic");
                  if (!KB::String::equal(a1, (const KB::String *)v7, 1))
                  {
                    KB::String::String((KB::String *)v5, "Telugu-Alphabetic");
                    BOOL v2 = KB::String::equal(a1, (const KB::String *)v5, 1);
                    if (v6)
                    {
                      if (v5[6] == 1) {
                        free(v6);
                      }
                    }
                  }
                  if (v8 && v7[6] == 1) {
                    free(v8);
                  }
                }
                if (v10 && v9[6] == 1) {
                  free(v10);
                }
              }
              if (v12 && v11[6] == 1) {
                free(v12);
              }
            }
            if (v14 && v13[6] == 1) {
              free(v14);
            }
          }
          if (v16 && v15[6] == 1) {
            free(v16);
          }
        }
        if (v18 && v17[6] == 1) {
          free(v18);
        }
      }
      if (v20 && v19[6] == 1) {
        free(v20);
      }
    }
    if (v22 && v21[6] == 1) {
      free(v22);
    }
  }
  if (v24) {
    BOOL v3 = v23[6] == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    free(v24);
  }
  return v2;
}

unsigned char *KB::SetOnlySearchSupplementalLexiconForScope::SetOnlySearchSupplementalLexiconForScope(unsigned char *this, int a2)
{
  *this = a2;
  int v2 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  this[1] = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  if (v2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (!v3) {
    KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 1;
  }
  return this;
}

{
  int v2;
  BOOL v3;

  *this = a2;
  int v2 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  this[1] = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
  if (v2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (!v3) {
    KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 1;
  }
  return this;
}

void KB::SetOnlySearchSupplementalLexiconForScope::~SetOnlySearchSupplementalLexiconForScope(KB::SetOnlySearchSupplementalLexiconForScope *this)
{
  if (*(unsigned char *)this)
  {
    if (!*((unsigned char *)this + 1)) {
      KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 0;
    }
  }
}

{
  if (*(unsigned char *)this)
  {
    if (!*((unsigned char *)this + 1)) {
      KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon = 0;
    }
  }
}

unsigned char *KB::SetInputHasSupplementalPrefixForScope::SetInputHasSupplementalPrefixForScope(unsigned char *this, int a2)
{
  *this = a2;
  int v2 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  this[1] = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  if (v2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (!v3) {
    KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefiCGFloat x = 1;
  }
  return this;
}

{
  int v2;
  BOOL v3;

  *this = a2;
  int v2 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  this[1] = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
  if (v2) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a2 == 0;
  }
  if (!v3) {
    KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefiCGFloat x = 1;
  }
  return this;
}

void KB::SetInputHasSupplementalPrefixForScope::~SetInputHasSupplementalPrefixForScope(KB::SetInputHasSupplementalPrefixForScope *this)
{
  if (*(unsigned char *)this)
  {
    if (!*((unsigned char *)this + 1)) {
      KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefiCGFloat x = 0;
    }
  }
}

{
  if (*(unsigned char *)this)
  {
    if (!*((unsigned char *)this + 1)) {
      KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefiCGFloat x = 0;
    }
  }
}

void KB::InputManagerSpecialization::do_create_custom_candidate_filter(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t KB::InputManagerSpecialization::do_capitalize_first_letter(KB::InputManagerSpecialization *this, KB::Word *a2, int a3)
{
  return KB::Word::capitalize_first_letter(a2, a3);
}

uint64_t KB::InputManagerSpecialization::get_should_promote_case_variants_of_top_candidate(KB::InputManagerSpecialization *this)
{
  return 0;
}

uint64_t KB::InputManagerSpecialization::get_should_correct_explicitly_shifted_word(KB::InputManagerSpecialization *this)
{
  return 1;
}

uint64_t KB::InputManagerSpecialization::get_period_ends_sentence_after_word(KB::InputManagerSpecialization *this, const String *a2)
{
  return 1;
}

uint64_t KB::InputManagerSpecialization::get_does_need_spell_check(KB::InputManagerSpecialization *this, const String *a2)
{
  return 0;
}

void KB::InputManagerSpecialization::create_input_segment_filter(void *a1@<X8>)
{
  {
    __cxa_atexit((void (*)(void *))WTF::RefPtr<KB::InputSegmentFilter>::~RefPtr, &KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter, &dword_1E3F0E000);
  }
  if (KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::once != -1) {
    dispatch_once(&KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::once, &__block_literal_global_4981);
  }
  uint64_t v2 = KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter;
  *a1 = KB::InputManagerSpecialization::create_input_segment_filter(WTF::PassRefPtr<TI::Favonius::KeyboardLayout>)const::filter;
  if (v2) {
    atomic_fetch_add((atomic_uint *volatile)(v2 + 8), 1u);
  }
}

void ___ZNK2KB26InputManagerSpecialization27create_input_segment_filterEN3WTF10PassRefPtrIN2TI8Favonius14KeyboardLayoutEEE_block_invoke()
{
}

void KB::DefaultInputSegmentFilter::~DefaultInputSegmentFilter(KB::DefaultInputSegmentFilter *this)
{
}

unsigned int **WTF::RefPtr<KB::InputSegmentFilter>::~RefPtr(unsigned int **a1)
{
  uint64_t v2 = *a1;
  if (v2)
  {
    unsigned int v3 = atomic_load(v2 + 2);
    if (v3 == 1) {
      (*(void (**)(unsigned int *))(*(void *)v2 + 8))(v2);
    }
    else {
      atomic_fetch_add((atomic_uint *volatile)v2 + 2, 0xFFFFFFFF);
    }
  }
  return a1;
}

void KB::InputManagerSpecialization::~InputManagerSpecialization(KB::InputManagerSpecialization *this)
{
  *(void *)this = &unk_1F3F73A58;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;

  JUMPOUT(0x1E4E7BC20);
}

{
  const void *v2;

  *(void *)this = &unk_1F3F73A58;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
}

{
  const void *v2;

  *(void *)this = &unk_1F3F73A58;
  uint64_t v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
}

KB::InputManagerSpecialization *KB::InputManagerSpecialization::InputManagerSpecialization(KB::InputManagerSpecialization *this, CFTypeRef cf)
{
  *(void *)this = &unk_1F3F73A58;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = cf;
  if (cf)
  {
    CFRetain(cf);
    *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = cf;
  }
  return this;
}

{
  *(void *)this = &unk_1F3F73A58;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = cf;
  if (cf)
  {
    CFRetain(cf);
    *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = cf;
  }
  return this;
}

uint64_t TIInputManager::should_exclude_filter_corrections_if_any_candidate_matches_input(TIInputManager *this)
{
  return 0;
}

void TIInputManager::external_string_to_internal(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[32] = 0;
}

void TIInputManager::internal_string_to_external(unsigned char *a1@<X8>)
{
  *a1 = 0;
  a1[32] = 0;
}

KB::String *TIInputManager::filter_pre_lookup_input@<X0>(const KB::String *a1@<X1>, KB::String *a2@<X8>)
{
  return KB::String::String(a2, a1);
}

void *TIInputManager_translit::create_custom_candidate_filter@<X0>(void *a1@<X8>)
{
  unint64_t result = operator new(0x20uLL);
  result[1] = 0;
  result[2] = 0;
  *unint64_t result = &unk_1F3F73AE0;
  result[3] = &unk_1F3F759E0;
  *a1 = result + 3;
  a1[1] = result;
  return result;
}

uint64_t std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73AE0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x1E4E7BC20);
}

void std::__shared_ptr_emplace<KB::CandidateFilter_Indic>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1F3F73AE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void TIInputManager_translit::~TIInputManager_translit(TIInputManager_translit *this)
{
  TIInputManager::~TIInputManager(this);

  JUMPOUT(0x1E4E7BC20);
}

uint64_t _getRandomNForMaxN(int a1)
{
  LODWORD(result) = arc4random_uniform(a1 + 1);
  if (result <= 2) {
    return 2;
  }
  else {
    return result;
  }
}

uint64_t TIInputManager::create_custom_candidate_filter@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = *(void *)(a1 + 544);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 80))();
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void TIInputManager::create_quality_filter(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, CFTypeRef **a4@<X8>)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  a4[1] = 0;
  if (*(unsigned char *)(a1 + 699))
  {
    KB::CandidateFilterFactory::create_empty_filter(&v47);
    *(_OWORD *)a4 = v47;
  }
  else
  {
    int v8 = KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon;
    std::vector<KB::FilterFlag>::vector(&__p, a3);
    TIInputManager::candidate_filter_cache_key(&__p, a2, v8, (uint64_t)v62);
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    TIInputManager::candidate_filter_for_key(a1, (const KB::String *)v62, &v47);
    long long v9 = v47;
    *(_OWORD *)a4 = v47;
    if (!(void)v9)
    {
      int v10 = (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 16))(*(void *)(a1 + 184));
      KB::String::String((KB::String *)v45, (const KB::String *)(a1 + 104));
      KB::CandidateFilterParameters::CandidateFilterParameters((uint64_t)v42, *(void *)(a1 + 136), v11, v10, v12, *(_DWORD *)(a1 + 584) != 0);
      int v13 = *(_DWORD *)(a1 + 584);
      std::vector<KB::FilterFlag>::vector(&v40, a3);
      *(void *)&long long v47 = __PAIR64__(v10, a2);
      DWORD2(v47) = 0x100000;
      WORD6(v47) = 0;
      BYTE14(v47) = 0;
      long long v48 = 0;
      KB::String::operator=((uint64_t)&v47 + 8, (KB::String *)v45);
      long long v51 = v42[2];
      long long v52 = v42[3];
      long long v53 = v42[4];
      long long v54 = v42[5];
      long long v49 = v42[0];
      long long v50 = v42[1];
      int v55 = v13;
      long long v56 = v40;
      uint64_t v14 = v41;
      long long v40 = 0uLL;
      uint64_t v41 = 0;
      uint64_t v58 = 0;
      uint64_t v59 = 0;
      uint64_t v57 = v14;
      int v60 = 0x10000;
      char v61 = 0;
      if (v46 && v45[6] == 1) {
        free(v46);
      }
      LOBYTE(v60) = *(unsigned char *)(a1 + 692);
      BYTE2(v60) = *(unsigned char *)(a1 + 697);
      BYTE1(v60) = v8;
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 56))(&v38, a1, a2);
      uint64_t v16 = v38;
      int v15 = v39;
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      int v17 = v59;
      uint64_t v58 = v16;
      uint64_t v59 = v15;
      uint64_t v18 = (std::__shared_weak_count *)*((void *)&v9 + 1);
      if (v17) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v17);
      }
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v39);
      }
      char v61 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
      if ((a2 - 3) < 4 || a2 == 1)
      {
        uint64_t v19 = *(void *)(a1 + 544);
        if (v19)
        {
          if ((*(unsigned int (**)(uint64_t))(*(void *)v19 + 40))(v19)) {
            HIBYTE(v60) = 1;
          }
        }
      }
      unsigned int v20 = *(const void **)(a1 + 704);
      if (v20)
      {
        CFRetain(*(CFTypeRef *)(a1 + 704));
        CFTypeID v21 = CFGetTypeID(v20);
        if (v21 == CFDictionaryGetTypeID())
        {
          CFDictionaryRef v35 = (CFDictionaryRef)v20;
          KB::CandidateFilterFactory::select_filter_specification_for_configuration(&v35, (unsigned int *)&v47, (uint64_t)&v36);
          CFRelease(v20);
        }
        else
        {
          CFRelease(v20);
          CFDictionaryRef v35 = 0;
          KB::CandidateFilterFactory::select_filter_specification_for_configuration(&v35, (unsigned int *)&v47, (uint64_t)&v36);
        }
        unsigned int v32 = 0;
        int v33 = 0;
        long long v31 = 0;
        BOOL v22 = v36;
        uint64_t v23 = (CFTypeRef *)v37;
        uint64_t v24 = (char *)v37 - (char *)v36;
        if (v37 != (void **)v36)
        {
          if (v24 < 0) {
            abort();
          }
          uint64_t v25 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24 >> 3);
          long long v31 = v25;
          int v33 = &v25[v26];
          do
          {
            CFTypeRef v27 = *v22;
            if (*v22) {
              CFRetain(*v22);
            }
            *v25++ = v27;
            ++v22;
          }
          while (v22 != v23);
          unsigned int v32 = v25;
        }
        KB::CandidateFilterFactory::create_filter_stack_from_specification((uint64_t *)&v31, (const KB::CandidateFilterConfiguration *)&v47, v34);
        uint64_t v29 = v34[0];
        long long v28 = v34[1];
        *a4 = (CFTypeRef *)v34[0];
        a4[1] = (CFTypeRef *)v28;
        if (*((void *)&v9 + 1)) {
          std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v9 + 1));
        }
        unsigned int v44 = (void **)&v31;
        std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](&v44);
        v34[0] = (void **)&v36;
        std::vector<applesauce::CF::DictionaryRef>::__destroy_vector::operator()[abi:nn180100](v34);
        uint64_t v18 = (std::__shared_weak_count *)v28;
        if (v29) {
          goto LABEL_37;
        }
      }
      KB::CandidateFilterFactory::create_standard_filter((KB::CandidateFilterFactory *)&v47, &v36);
      uint64_t v30 = v36;
      long long v28 = v37;
      *a4 = v36;
      a4[1] = (CFTypeRef *)v28;
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v18);
      }
      if (v30)
      {
LABEL_37:
        if (v28) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v28 + 1, 1uLL, memory_order_relaxed);
        }
        TIInputManager::set_candidate_filter_for_key();
      }
      if (v59) {
        std::__shared_weak_count::__release_shared[abi:nn180100](v59);
      }
      if ((void)v56)
      {
        *((void *)&v56 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v56;
        operator delete((void *)v56);
      }
      if (v48 && BYTE14(v47) == 1) {
        free(v48);
      }
    }
    if (v63 && v62[6] == 1) {
      free(v63);
    }
  }
}

void TIInputManager::candidate_filter_cache_key(std::string *this@<X2>, int a2@<W0>, int a3@<W1>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 0x100000;
  *(_WORD *)(a4 + 4) = 0;
  *(unsigned char *)(a4 + 6) = 0;
  *(void *)(a4 + 8) = 0;
  *(unsigned char *)(a4 + 16) = 0;
  KB::CandidateFilterFlags::serialize_flag_val(this, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::__split_buffer<std::string>::pointer p_p = &__p;
  }
  else {
    std::__split_buffer<std::string>::pointer p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  KB::String::append_format((KB::String *)a4, "lut:%d osl:%d cff:%s", a2, a3, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

uint64_t TIInputManager::candidate_filter_for_key@<X0>(uint64_t this@<X0>, const KB::String *a2@<X1>, void *a3@<X8>)
{
  uint64_t v4 = *(void *)(this + 672);
  if (v4)
  {
    uint64_t v5 = this + 672;
    if (*((void *)a2 + 1)) {
      unsigned int v6 = (const char *)*((void *)a2 + 1);
    }
    else {
      unsigned int v6 = (char *)a2 + 16;
    }
    uint64_t v7 = this + 672;
    do
    {
      if (*(void *)(v4 + 40)) {
        int v8 = *(const char **)(v4 + 40);
      }
      else {
        int v8 = (const char *)(v4 + 48);
      }
      this = strcmp(v8, v6);
      long long v9 = (uint64_t *)(v4 + 8);
      if ((int)this >= 0)
      {
        long long v9 = (uint64_t *)v4;
        uint64_t v7 = v4;
      }
      uint64_t v4 = *v9;
    }
    while (*v9);
    if (v5 != v7)
    {
      if (*(void *)(v7 + 40)) {
        int v10 = *(const char **)(v7 + 40);
      }
      else {
        int v10 = (const char *)(v7 + 48);
      }
      this = strcmp(v6, v10);
      if ((this & 0x80000000) == 0) {
        KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[]();
      }
    }
  }
  *a3 = 0;
  a3[1] = 0;
  return this;
}

void TIInputManager::set_candidate_filter_for_key()
{
}

void KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::operator[]()
{
}

void std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2)
  {
    unsigned int v3 = *(std::__shared_weak_count **)(v2 + 40);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v3);
    }
    uint64_t v4 = *(void **)(v2 + 8);
    if (v4 && *(unsigned char *)(v2 + 6) == 1) {
      free(v4);
    }
    MEMORY[0x1E4E7BC20](v2, 0x1030C4086F4D270);
  }
  uint64_t v5 = *(void **)(a1 + 8);
  if (v5 && *(unsigned char *)(a1 + 6) == 1)
  {
    free(v5);
  }
}

BOOL TIInputManager::should_accept_candidate_for_mixed_case_input(uint64_t a1, void *a2, _LXLexicon *a3, const char *a4, void *a5, char a6)
{
  v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a5[1];
  uint64_t v12 = v11 - *a5;
  if (v11 == *a5)
  {
    unsigned int v14 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    unint64_t v15 = v12 >> 2;
    do
    {
      v14 += *(_DWORD *)(*a5 + 4 * v13) & ~(*(_DWORD *)(*a5 + 4 * v13) >> 1) & 1;
      ++v13;
    }
    while (v15 > v13);
  }
  if (*((void *)a4 + 1)) {
    uint64_t v16 = *((void *)a4 + 1);
  }
  else {
    uint64_t v16 = (uint64_t)(a4 + 16);
  }
  uint64_t v36 = v16;
  int v17 = *(unsigned __int16 *)a4;
  int v37 = 0;
  int v38 = v17;
  int v39 = 0;
  KB::String::iterator::initialize(&v36);
  uint64_t v32 = v16;
  int v33 = v17;
  int v34 = v17;
  int v35 = 0;
  KB::String::iterator::initialize(&v32);
  int v19 = v33;
  if (v37 != v33)
  {
    uint64_t v20 = MEMORY[0x1E4F14390];
    do
    {
      if ((v39 & 0x80) != 0)
      {
        if (!__maskrune((char)v39, 0x100uLL)) {
          goto LABEL_19;
        }
      }
      else if ((*(_DWORD *)(v20 + 4 * (char)v39 + 60) & 0x100) == 0)
      {
        goto LABEL_19;
      }
      KB::String::iterator::operator++(&v36);
    }
    while (v37 != v19);
  }
  if (v14 <= 1 && (a6 & 1) != 0) {
    return 1;
  }
LABEL_19:
  if (*a2)
  {
    uint64_t v22 = 240 * *a2 - 240;
    uint64_t v23 = (uint64_t *)(a2[1] + 224);
    do
    {
      uint64_t v25 = *v23;
      v23 += 30;
      uint64_t v24 = v25;
      if (v25) {
        BOOL v26 = 1;
      }
      else {
        BOOL v26 = v22 == 0;
      }
      v22 -= 240;
    }
    while (!v26);
    if (v24) {
      return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(void *)(*(void *)(a1 + 224) + 8) + 72), a3, (const KB::String *)a4, v18) == 0;
    }
  }
  KB::Word::capitalized_string((KB::Word *)a3, (uint64_t)v40);
  size_t v27 = *(unsigned __int16 *)a4;
  long long v28 = v42;
  if (v27 > v40[0])
  {
    BOOL v21 = 0;
    if (!v42) {
      return v21;
    }
    goto LABEL_38;
  }
  if (v42) {
    uint64_t v29 = (const char *)v42;
  }
  else {
    uint64_t v29 = (const char *)v43;
  }
  if (*((void *)a4 + 1)) {
    uint64_t v30 = (const char *)*((void *)a4 + 1);
  }
  else {
    uint64_t v30 = a4 + 16;
  }
  BOOL v21 = strncmp(v29, v30, v27) == 0;
  if (v28)
  {
LABEL_38:
    if (v41 == 1) {
      free(v28);
    }
  }
  return v21;
}

void TIInputManager::inline_completion_candidates(void *aBlock@<X4>, uint64_t a2@<X0>, uint64_t a3@<X1>, const KB::String *a4@<X2>, uint64_t a5@<X3>, uint64_t a6@<X8>)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v11 = _Block_copy(aBlock);
  v28[0] = v11;
  v28[1] = a2;
  if (*(unsigned char *)(a2 + 688))
  {
    int v19 = 0;
    memset(v17, 0, sizeof(v17));
    memset(v18, 0, sizeof(v18));
    bzero(&v31, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)&v31);
    uint64_t v27 = 0;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    *(_OWORD *)std::string __p = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v25);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v25 + 8));
    long long v26 = 0uLL;
    uint64_t v27 = 0;
    TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))const::$_0::operator()((uint64_t)v28, (uint64_t)v17, &v31, (const KB::LanguageModelContext *)&v21, 0);
    uint64_t v29 = (void **)&v26;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v29);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)((char *)&v25 + 8));
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v25);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (*((void *)&v21 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v21 + 1));
    }
    KB::Candidate::~Candidate((KB::Candidate *)&v31);
    *(unsigned char *)a6 = 0;
    *(unsigned char *)(a6 + 136) = 0;
LABEL_7:
    *(void *)&long long v31 = (char *)&v18[1] + 8;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
    *(void *)&long long v31 = v18;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
    *(void *)&long long v31 = (char *)&v17[1] + 8;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
    *(void *)&long long v31 = v17;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
    return;
  }
  uint64_t v12 = *(void *)(a2 + 184);
  v30[0] = &unk_1F3F73BB8;
  v30[1] = v11;
  v30[2] = a2;
  void v30[3] = v30;
  (*(void (**)(_OWORD *__return_ptr, uint64_t, const KB::String *, uint64_t, uint64_t, void *))(*(void *)v12 + 80))(v17, v12, a4, a3, a5, v30);
  std::__function::__value_func<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::~__value_func[abi:nn180100](v30);
  if (v20)
  {
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)&v31, (const KB::Candidate **)v17);
    KB::String::String((KB::String *)v40, a4);
    *(_OWORD *)a6 = v31;
    uint64_t v13 = v34;
    *(void *)(a6 + 16) = v32;
    long long v31 = 0uLL;
    *(_OWORD *)(a6 + 24) = v33;
    *(void *)(a6 + 40) = v13;
    uint64_t v32 = 0;
    long long v33 = 0uLL;
    uint64_t v34 = 0;
    *(_OWORD *)(a6 + 48) = v35;
    uint64_t v14 = v38;
    *(void *)(a6 + 64) = v36;
    long long v35 = 0uLL;
    *(_OWORD *)(a6 + 72) = v37;
    *(void *)(a6 + 88) = v14;
    uint64_t v36 = 0;
    long long v37 = 0uLL;
    uint64_t v38 = 0;
    uint64_t v15 = v39;
    *(_DWORD *)(a6 + 104) = 0x100000;
    uint64_t v16 = a6 + 104;
    *(void *)(v16 - 8) = v15;
    *(_WORD *)(v16 + 4) = 0;
    *(unsigned char *)(v16 + 6) = 0;
    *(void *)(v16 + 8) = 0;
    KB::String::operator=(v16, (KB::String *)v40);
    *(unsigned char *)(v16 + 32) = 1;
    if (v41 && v40[6] == 1) {
      free(v41);
    }
    *(void *)&long long v21 = &v37;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
    *(void *)&long long v21 = &v35;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
    *(void *)&long long v21 = &v33;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
    *(void *)&long long v21 = &v31;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v21);
    if (v20) {
      goto LABEL_7;
    }
  }
  else
  {
    *(unsigned char *)a6 = 0;
    *(unsigned char *)(a6 + 136) = 0;
  }
}

void TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))const::$_0::operator()(uint64_t a1, uint64_t a2, _WORD *a3, const KB::LanguageModelContext *a4, int a5)
{
  LODWORD(v5) = a5;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v10 = *(TIInputManager **)(a1 + 8);
  if (*((void *)v10 + 71)) {
    Mutable = CFStringCreateMutable(0, 0);
  }
  else {
    Mutable = 0;
  }
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v21, (const KB::Candidate **)a2);
  uint64_t v12 = a3 + 444;
  if (!a3[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a3);
  }
  TIInputManager::apply_policy_decisions_inline_completions(v10, (KB::CandidateCollection *)a2, (const KB::String *)(a3 + 444), a4, Mutable);
  memset(v19, 0, sizeof(v19));
  KB::CandidateFilterFlags::CandidateFilterFlags(__p, v19);
  uint64_t v13 = *((void *)v10 + 71);
  if (v13)
  {
    if (!*v12) {
      KB::Candidate::compute_string((KB::Candidate *)a3);
    }
    int v14 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)__p);
    uint64_t v15 = (const KB::String *)&kGenericFlagDesc;
    if (v14 == 1) {
      uint64_t v15 = (const KB::String *)&kPostLMFlagDesc;
    }
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = (const KB::String *)&kPreLMFlagDesc;
    }
    KB::String::String((KB::String *)&v25, v16);
    CFTypeRef cf = 0;
    (*(void (**)(uint64_t, _WORD *, uint64_t, void ***, unsigned char *, __CFString *, uint64_t, CFTypeRef *))(*(void *)v13 + 24))(v13, a3 + 444, 2, &v25, v21, Mutable, a2, &cf);
    if (cf) {
      CFRelease(cf);
    }
    CFTypeRef cf = 0;
    if (v26 && BYTE6(v25) == 1) {
      free(v26);
    }
  }
  if (*(void *)(a2 + 8) == *(void *)a2) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = v5;
  }
  int v17 = *(void (***)(const void *, uint64_t, _WORD *, uint64_t))a1;
  if (!*v12) {
    KB::Candidate::compute_string((KB::Candidate *)a3);
  }
  v17[2](v17, a2, a3 + 444, v5);
  _Block_release(*(const void **)a1);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  long long v25 = (void **)&v24;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  long long v25 = (void **)&v23;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  long long v25 = (void **)&v22;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  long long v25 = (void **)v21;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v25);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void *std::__function::__value_func<void ()(KB::CandidateCollection &,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

KB::CandidateCollection *KB::CandidateCollection::CandidateCollection(KB::CandidateCollection *this, const KB::Candidate **a2)
{
  *(void *)this = 0;
  *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  *((void *)this + 2) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(this, *a2, a2[1], 0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3));
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 24), a2[3], a2[4], 0x1CAC083126E978D5 * ((a2[4] - a2[3]) >> 3));
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 48), a2[6], a2[7], 0x1CAC083126E978D5 * ((a2[7] - a2[6]) >> 3));
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
  std::vector<KB::Candidate>::__init_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::CandidateCollection *)((char *)this + 72), a2[9], a2[10], 0x1CAC083126E978D5 * ((a2[10] - a2[9]) >> 3));
  *((void *)this + 12) = a2[12];
  return this;
}

void std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::operator()(uint64_t a1, uint64_t a2, _WORD *a3, const KB::LanguageModelContext *a4, unsigned __int8 *a5)
{
}

__n128 std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73BB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F73BB8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0,std::allocator<TIInputManager::inline_completion_candidates(KB::LanguageModelContext const&,KB::String const&,BOOL,void({block_pointer})(KB::CandidateCollection const&,KB::String const&,BOOL))::$_0>,void ()(KB::CandidateCollection&,KB::Candidate const&,KB::LanguageModelContext const&,BOOL)>::~__func()
{
}

void TIInputManager::apply_policy_decisions_inline_completions(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, const KB::LanguageModelContext *a4, __CFString *a5)
{
  uint64_t v5 = MEMORY[0x1F4188790](this, a2, a3, a4, a5);
  uint64_t v7 = v6;
  long long v9 = v8;
  uint64_t v11 = v10;
  uint64_t v13 = v12;
  uint64_t v14 = v5;
  v43[125] = *MEMORY[0x1E4F143B8];
  memset(v31, 0, sizeof(v31));
  KB::CandidateFilterFlags::CandidateFilterFlags(__p, v31);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v14 + 48))(&v33, v14, 2, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v33)
  {
    KB::Candidate::Candidate((KB::Candidate *)v43, v11, *(_DWORD *)(v14 + 248));
    KB::Candidate::Candidate((KB::Candidate *)v41, (const KB::Candidate *)v43);
    memset(&v30, 0, sizeof(v30));
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v23, v9);
    int v36 = 0x100000;
    __int16 v37 = 0;
    char v38 = 0;
    uint64_t v39 = 0;
    char v40 = 0;
    bzero(v35, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v35);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v42, (const KB::Candidate *)v41, &v30, (const KB::LanguageModelContext *)v23, (const KB::String *)&v36, (const KB::Candidate *)v35, 2);
    KB::Candidate::~Candidate((KB::Candidate *)v35);
    if (v39 && v38 == 1) {
      free(v39);
    }
    v22[0] = (void **)&v29;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v22);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v28);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v27);
    if (v25)
    {
      long long v26 = v25;
      operator delete(v25);
    }
    if (v24) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v24);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v41);
    uint64_t v15 = *(const void **)(v14 + 136);
    int v16 = *(_DWORD *)(v14 + 248);
    int v17 = *(unsigned int **)(v14 + 224);
    long long v21 = v17;
    if (v17) {
      atomic_fetch_add((atomic_uint *volatile)v17, 1u);
    }
    uint64_t v18 = *(std::__shared_weak_count **)(v14 + 240);
    uint64_t v19 = *(void *)(v14 + 232);
    char v20 = v18;
    if (v18) {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v22, v15, v16, (uint64_t *)&v21, (uint64_t)&v19, *(const void **)(v14 + 560), 0, v7);
    if (v20) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v20);
    }
    if (v21) {
      WTF::RefCounted<KB::DictionaryContainer>::deref(v21);
    }
    (*(void (**)(uint64_t, uint64_t, unsigned char *, void ***))(*(void *)v33 + 24))(v33, v13, v42, v22);
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v22);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v42);
    KB::Candidate::~Candidate((KB::Candidate *)v43);
  }
  if (v34) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v34);
  }
}

void KB::CandidateFilterLookupContext::~CandidateFilterLookupContext(KB::CandidateFilterLookupContext *this)
{
  KB::Candidate::~Candidate((KB::CandidateFilterLookupContext *)((char *)this + 2168));
  uint64_t v2 = (void *)*((void *)this + 268);
  if (v2 && *((unsigned char *)this + 2142) == 1) {
    free(v2);
  }
  unsigned int v6 = (void **)((char *)this + 2112);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v6);
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::CandidateFilterLookupContext *)((char *)this + 2104));
  language_modeling::v1::LinguisticContext::~LinguisticContext((KB::CandidateFilterLookupContext *)((char *)this + 2096));
  unsigned int v3 = (void *)*((void *)this + 256);
  if (v3)
  {
    *((void *)this + 257) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 255);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  uint64_t v5 = (void *)*((void *)this + 251);
  if (v5)
  {
    *((void *)this + 252) = v5;
    operator delete(v5);
  }
  if (*((unsigned char *)this + 2000)) {
    KB::Candidate::~Candidate((KB::CandidateFilterLookupContext *)((char *)this + 1000));
  }

  KB::Candidate::~Candidate(this);
}

void TIInputManager::completion_candidates(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
}

void TIInputManager::lookup(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  v21[2] = *MEMORY[0x1E4F143B8];
  if (a2 != 5)
  {
    int v10 = (unsigned __int16 *)(a1 + 64);
    if (*(_WORD *)(a1 + 68) || (KB::String::compute_length((unsigned __int16 *)(a1 + 64)), *(_WORD *)(a1 + 68)))
    {
      TIInputManager::legacy_input_stem((TIInputManager *)a1, (uint64_t)v17);
      if (v18 || (KB::String::compute_length(v17), v18))
      {
        if (v17[0] <= *v10)
        {
          uint64_t v11 = *(void *)(a1 + 72) ? *(const char **)(a1 + 72) : (const char *)(a1 + 80);
          uint64_t v12 = (const char *)(v20 ? v20 : v21);
          if (!strncasecmp(v11, v12, v17[0]))
          {
            unsigned int v13 = *(_DWORD *)(a1 + 96);
            if (*(_DWORD *)(a1 + 172) > v13) {
              unsigned int v13 = *(_DWORD *)(a1 + 172);
            }
            *(_DWORD *)(a1 + 172) = v13;
          }
        }
      }
      if (v20 && v19 == 1) {
        free(v20);
      }
    }
  }
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  void v14[2] = ___ZN14TIInputManager6lookupEN2KB10LookupTypeEj14TIShiftContext_block_invoke;
  void v14[3] = &__block_descriptor_tmp_7_5033;
  void v14[4] = a1;
  int v15 = a2;
  int v16 = a4;
  TIInputManager::perform_lookup(a1, a2, a3, (uint64_t)v14, a5);
}

unsigned __int16 *TIInputManager::legacy_input_stem@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *((unsigned int *)this + 24);
  unsigned int v3 = (unsigned __int16 *)((char *)this + 8);
  uint64_t v4 = v2 + 1;
  uint64_t v5 = 40 * v2 - 8;
  do
  {
    if (!--v4) {
      break;
    }
    char v6 = *(unsigned char *)(*(void *)v3 + v5);
    v5 -= 40;
  }
  while ((v6 & 0x40) == 0);
  return TIInputManager::input_substring(v3, v4, (int)v2 - (int)v4, a2);
}

void ___ZN14TIInputManager6lookupEN2KB10LookupTypeEj14TIShiftContext_block_invoke(uint64_t a1, unint64_t *a2, __CFString *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *a2;
  uint64_t v7 = (uint64_t *)a2[1];
  unint64_t v8 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((uint64_t)((uint64_t)v7 - v6) >> 3));
  size_t v9 = *(void *)(a1 + 32);
  if (v7 == (uint64_t *)v6) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v8;
  }
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(v6, v7, v10, 1);
  if (TIInputManager::inject_supplemental_candidate(v9, *(_DWORD *)(a1 + 40), (uint64_t *)a2))
  {
    uint64_t v11 = (uint64_t *)a2[1];
    unint64_t v12 = 126 - 2 * __clz(0x1CAC083126E978D5 * ((uint64_t)((uint64_t)v11 - *a2) >> 3));
    if (v11 == (uint64_t *)*a2) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = v12;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(*a2, v11, v13, 1);
  }
  TIInputManager::apply_case_insensitive_constraints(v9, (uint64_t)a2, *(_DWORD *)(a1 + 40), (uint64_t)a3);
  TIInputManager::apply_case_changes((unsigned __int8 *)v9, (uint64_t)a2, (unsigned __int16 *)(v9 + 8), *(unsigned int *)(v9 + 96), *(unsigned int *)(a1 + 44), a3);
  uint64_t v14 = TIInputManager::input_substring((unsigned __int16 *)(v9 + 8), 0, *(_DWORD *)(v9 + 96), (uint64_t)v17);
  TIInputManager::apply_apostrophe_changes((TIInputManager *)v14, (KB::CandidateCollection *)a2, (const KB::String *)v17, a3);
  if (v19 && v18 == 1) {
    free(v19);
  }
  TIInputManager::input_substring((unsigned __int16 *)(v9 + 8), 0, *(_DWORD *)(v9 + 96), (uint64_t)v17);
  TIInputManager::apply_shortcut_conversions((TIInputManager *)v9, (KB::CandidateCollection *)a2, v15, a3);
  if (v19 && v18 == 1) {
    free(v19);
  }
  int v16 = *(TIInputManager **)(v9 + 544);
  if (v16) {
    int v16 = (TIInputManager *)(*(uint64_t (**)(TIInputManager *, unint64_t *))(*(void *)v16 + 64))(v16, a2);
  }
  if (*(_DWORD *)(a1 + 40) == 5) {
    TIInputManager::remove_text_replacement_from_top(v16, (const KB::Candidate **)a2);
  }
}

void TIInputManager::perform_lookup(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  HIDWORD(v20) = 0;
  long long v16 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v18 = 0u;
  memset(v19, 0, sizeof(v19));
  uint64_t v10 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)&v35);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void ***))(*(void *)a1 + 64))(&v33, a1, &v35);
  int v28 = 0x100000;
  __int16 v29 = 0;
  char v30 = 0;
  long long v31 = 0;
  char v32 = 0;
  int v23 = 0x100000;
  __int16 v24 = 0;
  char v25 = 0;
  long long v26 = 0;
  char v27 = 0;
  if (a2 != 3
    && a2 != 5
    && !TIInputManager::should_generate_candidates(a1, (const KB::String *)(a1 + 400), (KB::String *)&v33, a2 | 0x100000000))
  {
    goto LABEL_23;
  }
  if (!KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon)
  {
    KB::String::operator=((KB::String *)&v23, (KB::String *)&v33);
    KB::String::operator=((KB::String *)&v28, (KB::String *)&v35);
    if (!*(unsigned char *)(a1 + 694)
      || !TIInputManager::lookup_spellcheck_candidates(a1, (uint64_t)&v16, a2, (const KB::String *)&v33, a4))
    {
      if (!a2 || a2 == 5) {
        goto LABEL_22;
      }
      if (*(unsigned char *)(a1 + 688))
      {
        if (!(_WORD)v23) {
          goto LABEL_22;
        }
      }
      else
      {
        if (!*(_WORD *)(a1 + 32)) {
          goto LABEL_22;
        }
        TIInputManager::input_substring(v10, 0, -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3), (uint64_t)&v21);
        if ((uint64_t *)(a1 + 32) != &v21 && !KB::String::equal((KB::String *)(a1 + 32), (const KB::String *)&v21, 1))
        {
          if (v22 && BYTE6(v21) == 1) {
            free(v22);
          }
          goto LABEL_22;
        }
        int v15 = (unsigned __int16)v23;
        if (v22 && BYTE6(v21) == 1) {
          free(v22);
        }
        if (!v15)
        {
LABEL_22:
          (*(void (**)(void, uint64_t, int *, void, void))(**(void **)(a1 + 184) + 144))(*(void *)(a1 + 184), a1 + 432, &v23, *(unsigned int *)(a1 + 96), -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
          TIInputManager::lookup_static_dynamic_candidates(a1, (uint64_t)&v16, a2, (uint64_t)&v23, a4, a3);
          goto LABEL_23;
        }
      }
      TIInputManager::lookup_revision_candidates((TIInputManager *)a1, (uint64_t *)&v16, a2, a4, a3, (const KB::String *)&v23);
    }
LABEL_23:
    if (a2 == 5) {
      TI::ConfidenceModel::update_confidence_for_candidates((TI::ConfidenceModel *)(a1 + 144), (KB::CandidateCollection *)&v16);
    }
    goto LABEL_25;
  }
  TIInputManager::input_substring(v10, 0, -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3), (uint64_t)&v21);
  KB::String::operator=((uint64_t)&v28, (KB::String *)&v21);
  if (v22 && BYTE6(v21) == 1) {
    free(v22);
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, int *))(*(void *)a1 + 64))(&v21, a1, &v28);
  KB::String::operator=((uint64_t)&v23, (KB::String *)&v21);
  if (v22 && BYTE6(v21) == 1) {
    free(v22);
  }
  if (!a2 && !*(unsigned char *)(a1 + 688) && !*(_WORD *)(a1 + 32) && (_WORD)v33) {
    TIInputManager::lookup_revision_candidates((TIInputManager *)a1, (uint64_t *)&v16, 0, a4, a3, (const KB::String *)&v33);
  }
  (*(void (**)(void, uint64_t, int *, void, void))(**(void **)(a1 + 184) + 144))(*(void *)(a1 + 184), a1 + 432, &v23, *(unsigned int *)(a1 + 96), -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
  BOOL v11 = TIInputManager::lookup_static_dynamic_candidates(a1, (uint64_t)&v16, a2, (uint64_t)&v23, a4, a3);
  if (a2 == 5 || v11) {
    goto LABEL_23;
  }
  if (*(unsigned char *)(a1 + 688) || !*(_WORD *)(a1 + 32))
  {
    if (!(_WORD)v23) {
      goto LABEL_25;
    }
    goto LABEL_17;
  }
  TIInputManager::input_substring(v10, 0, -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3), (uint64_t)&v21);
  if ((uint64_t *)(a1 + 32) == &v21 || KB::String::equal((KB::String *)(a1 + 32), (const KB::String *)&v21, 1))
  {
    int v14 = (unsigned __int16)v23;
    if (v22 && BYTE6(v21) == 1) {
      free(v22);
    }
    if (!v14) {
      goto LABEL_25;
    }
LABEL_17:
    TIInputManager::lookup_revision_candidates((TIInputManager *)a1, (uint64_t *)&v16, a2, a4, a3, (const KB::String *)&v23);
  }
  if (v22 && BYTE6(v21) == 1) {
    free(v22);
  }
LABEL_25:
  *(_OWORD *)a5 = v16;
  *(void *)(a5 + 16) = *(void *)&v17[0];
  long long v16 = 0uLL;
  *(_OWORD *)(a5 + 24) = *(_OWORD *)((char *)v17 + 8);
  *(void *)(a5 + 40) = *((void *)&v17[1] + 1);
  memset(v17, 0, sizeof(v17));
  *(_OWORD *)(a5 + 48) = v18;
  *(void *)(a5 + 64) = *(void *)&v19[0];
  long long v18 = 0uLL;
  *(_OWORD *)(a5 + 72) = *(_OWORD *)((char *)v19 + 8);
  uint64_t v12 = v20;
  *(void *)(a5 + 88) = *((void *)&v19[1] + 1);
  memset(v19, 0, sizeof(v19));
  *(_DWORD *)(a5 + 104) = 0x100000;
  uint64_t v13 = a5 + 104;
  *(void *)(v13 - 8) = v12;
  *(_WORD *)(v13 + 4) = 0;
  *(unsigned char *)(v13 + 6) = 0;
  *(void *)(v13 + 8) = 0;
  KB::String::operator=(v13, (KB::String *)&v28);
  if (v26 && v25 == 1) {
    free(v26);
  }
  if (v31 && v30 == 1) {
    free(v31);
  }
  if (v34 && BYTE6(v33) == 1) {
    free(v34);
  }
  if (v36 && BYTE6(v35) == 1) {
    free(v36);
  }
  long long v35 = (void **)v19 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  long long v35 = (void **)&v18;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  long long v35 = (void **)v17 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
  long long v35 = (void **)&v16;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v35);
}

unsigned __int16 *TIInputManager::input_substring@<X0>(unsigned __int16 *result@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  *(_DWORD *)a4 = 0x100000;
  *(_WORD *)(a4 + 4) = 0;
  *(unsigned char *)(a4 + 6) = 0;
  *(void *)(a4 + 8) = 0;
  *(unsigned char *)(a4 + 16) = 0;
  if (a3 + a2 > a2)
  {
    int v5 = a3;
    unint64_t v6 = result;
    uint64_t v7 = 40 * a2;
    do
    {
      __n128 result = KB::String::append((unsigned __int16 *)a4, (const KB::String *)(*(void *)v6 + v7));
      v7 += 40;
      --v5;
    }
    while (v5);
  }
  return result;
}

BOOL TIInputManager::should_generate_candidates(uint64_t a1, const KB::String *a2, KB::String *this, uint64_t a4)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (**(void **)(*(void *)(a1 + 224) + 8) == *(void *)(*(void *)(*(void *)(a1 + 224) + 8) + 8)
    && !TITransientLexiconManagerGetActiveSupplementalLexiconWords())
  {
    return 0;
  }
  if (!*(_DWORD *)(a1 + 536))
  {
    uint64_t v13 = (unsigned __int16 *)KB::String::String((KB::String *)&v46, a2);
    KB::String::append(v13, this);
    __int16 v42 = 0;
    char v43 = 0;
    unsigned int v44 = "!@#$%^*_[]/\\|.?+=<>";
    int v41 = 1048595;
    v45[1] = 0;
    KB::String::find_last_of((KB::String *)&v39, (const KB::String *)&v46, (const KB::String *)&v41);
    int v14 = (unsigned __int16)v46;
    int v15 = v49;
    long long v16 = v50;
    if (v49) {
      int v17 = v49;
    }
    else {
      int v17 = v50;
    }
    long long v35 = v17;
    int v36 = (unsigned __int16)v46;
    int v37 = (unsigned __int16)v46;
    int v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (DWORD2(v39) == v36) {
      goto LABEL_22;
    }
    long long v33 = v39;
    *(void *)c = v40;
    KB::String::iterator::operator++((uint64_t *)&v33);
    __int16 v29 = v17;
    int v30 = v14;
    int v31 = v14;
    int v32 = 0;
    KB::String::iterator::initialize((uint64_t *)&v29);
    int v22 = DWORD2(v33);
    int v23 = v30;
    if (DWORD2(v33) != v30)
    {
      while (!u_isspace(c[0]))
      {
        KB::String::iterator::operator++((uint64_t *)&v33);
        if (DWORD2(v33) == v23)
        {
          int v22 = v23;
          goto LABEL_51;
        }
      }
      int v22 = DWORD2(v33);
    }
LABEL_51:
    int v24 = (unsigned __int16)v46;
    int v15 = v49;
    if (v49) {
      long long v16 = v49;
    }
    long long v35 = v16;
    int v36 = (unsigned __int16)v46;
    int v37 = (unsigned __int16)v46;
    int v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (v22 == v36)
    {
      int v25 = DWORD2(v39);
    }
    else
    {
      int v25 = DWORD2(v39);
      if (v22 >= SDWORD2(v39))
      {
LABEL_22:
        if (v44 && v43 == 1)
        {
          free(v44);
          int v15 = v49;
        }
        if (v15 && v48 == 1) {
          free(v15);
        }
        goto LABEL_4;
      }
    }
    long long v35 = v16;
    int v36 = 0;
    int v37 = v24;
    int v38 = 0;
    KB::String::iterator::initialize((uint64_t *)&v35);
    if (v25 == v36
      || v40 != 46
      && (long long v27 = v39, v28 = v40, KB::String::iterator::operator--((KB::String::iterator *)&v27), v28 != 46))
    {
      if (v44 && v43 == 1)
      {
        free(v44);
        int v15 = v49;
      }
      if (!v15 || v48 != 1) {
        return 0;
      }
      uint64_t v12 = v15;
LABEL_63:
      free(v12);
      return 0;
    }
    goto LABEL_22;
  }
LABEL_4:
  if (*(_WORD *)this)
  {
    __int16 v47 = 0;
    char v48 = 0;
    long long v49 = ".,ªº-";
    int v46 = 1048583;
    v50[1] = 0;
    unsigned int v8 = KB::String::last(this);
    KB::String::String((uint64_t)&v41, v8);
    if ((a4 & 0xFF00000000) == 0
      || a4 != 1
      || ((size_t v9 = v44) != 0 ? (v10 = (const char *)v44) : (v10 = v45), strcmp(v10, "-")))
    {
      BOOL v11 = KB::String::contains((KB::String *)&v46, (const KB::String *)&v41);
      size_t v9 = v44;
      if (v11)
      {
        if (v44 && v43 == 1) {
          free(v44);
        }
        uint64_t v12 = v49;
        if (!v49 || v48 != 1) {
          return 0;
        }
        goto LABEL_63;
      }
    }
    if (v9 && v43 == 1) {
      free(v9);
    }
    if (v49 && v48 == 1) {
      free(v49);
    }
  }
  if (*(_WORD *)(a1 + 104))
  {
    if (*(void *)(a1 + 112)) {
      long long v18 = *(const KB::String **)(a1 + 112);
    }
    else {
      long long v18 = (const KB::String *)(a1 + 120);
    }
  }
  else
  {
    long long v18 = (const KB::String *)"";
  }
  KB::string_to_lowercase(this, v18, (KB::String *)&v46);
  char v19 = (const KB::String *)repeating_character_threshold(*(const __CFLocale **)(a1 + 136));
  BOOL v21 = (KB::string_contains_run((KB *)&v46, v19) & 1) == 0
     && (uint64_t v20 = (const KB::String *)repeating_character_threshold(*(const __CFLocale **)(a1 + 136)),
         (KB::string_contains_pair_run((KB *)&v46, v20) & 1) == 0)
     && !KB::string_contains_terminal_run((KB *)&v46, (const KB::String *)3);
  if (v49 && v48 == 1) {
    free(v49);
  }
  return v21;
}

void TIInputManager::lookup_revision_candidates(TIInputManager *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, const KB::String *a6)
{
  uint64_t v10 = *a2;
  for (uint64_t i = a2[1]; i != v10; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
    ;
  a2[1] = v10;
  TIInputManager::create_autocorrection_engine_with_synthetic_typing(a1, a6);
}

BOOL TIInputManager::lookup_static_dynamic_candidates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  LODWORD(v6) = a6;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int v38 = a3;
  uint64_t v37 = a5;
  int v44 = 0x100000;
  __int16 v45 = 0;
  char v46 = 0;
  __int16 v47 = 0;
  char v48 = 0;
  unsigned int v11 = 6;
  if (a3 == 5) {
    unsigned int v11 = *(_DWORD *)(a1 + 712);
  }
  int v36 = 0;
  memset(v32, 0, sizeof(v32));
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  uint64_t v12 = *(void *)(a1 + 232);
  if (v12 && (*(unsigned int (**)(uint64_t))(*(void *)v12 + 16))(v12))
  {
    (*(void (**)(void ***__return_ptr))(**(void **)(a1 + 232) + 176))(&v27);
    uint64_t v13 = v27;
    int v14 = v28;
    if (v27 == v28)
    {
      char v15 = 0;
      if (!v27) {
        goto LABEL_26;
      }
    }
    else
    {
      char v15 = 0;
      do
      {
        CFStringRef v16 = (const __CFString *)MEMORY[0x1E4E79AD0](*v13);
        KB::std_string(v16, &v41);
        unint64_t v17 = v43;
        if ((v43 & 0x80u) != 0) {
          unint64_t v17 = (unint64_t)v42;
        }
        if (v17 == 6)
        {
          long long v18 = (v43 & 0x80u) == 0 ? (void **)&v41 : v41;
          unsigned int v19 = bswap32(*(_DWORD *)v18);
          unsigned int v20 = 1836411999;
          if (v19 == 1836411999 && (unsigned int v19 = bswap32(*((unsigned __int16 *)v18 + 2)) >> 16, v20 = 18766, v19 == 18766)) {
            int v21 = 0;
          }
          else {
            int v21 = v19 < v20 ? -1 : 1;
          }
          if (!v21) {
            char v15 = 1;
          }
        }
        if ((char)v43 < 0) {
          operator delete(v41);
        }
        ++v13;
      }
      while (v13 != v14);
      uint64_t v13 = v27;
      if (!v27) {
        goto LABEL_26;
      }
    }
    uint64_t v28 = v13;
    operator delete(v13);
LABEL_26:
    uint64_t v22 = v15 & 1;
    goto LABEL_28;
  }
  uint64_t v22 = 0;
LABEL_28:
  if (v11 <= v6) {
    uint64_t v6 = v6;
  }
  else {
    uint64_t v6 = v11;
  }
  uint64_t v23 = *(void *)(a1 + 184);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)&v41);
  int v24 = operator new(0x30uLL);
  void *v24 = &unk_1F3F73C00;
  v24[1] = a1;
  void v24[2] = a4;
  void v24[3] = &v44;
  v24[4] = &v38;
  void v24[5] = &v37;
  _WORD v40[3] = v24;
  (*(void (**)(void ***__return_ptr, uint64_t, void ***, uint64_t, uint64_t, int *, uint64_t, void *, uint64_t))(*(void *)v23 + 72))(&v27, v23, &v41, a1 + 432, v6, &v44, a3, v40, v22);
  KB::CandidateCollection::operator=((uint64_t)v32, (uint64_t)&v27);
  long long v39 = (void ***)&v31;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
  long long v39 = (void ***)&v30;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
  long long v39 = (void ***)&v29;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
  long long v39 = &v27;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
  std::__function::__value_func<void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__value_func[abi:nn180100](v40);
  if (v42 && BYTE6(v41) == 1) {
    free(v42);
  }
  KB::CandidateCollection::operator=(a2, (uint64_t)v32);
  BOOL v25 = *(void *)&v32[0] != *((void *)&v32[0] + 1)
     || (void)v33 != *((void *)&v33 + 1)
     || *((void *)&v34 + 1) != v35;
  long long v27 = (void **)&v34 + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v27);
  long long v27 = (void **)&v33;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v27);
  long long v27 = (void **)&v32[1] + 1;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v27);
  long long v27 = (void **)v32;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v27);
  if (v47 && v46 == 1) {
    free(v47);
  }
  return v25;
}

BOOL TIInputManager::lookup_spellcheck_candidates(uint64_t a1, uint64_t a2, uint64_t a3, const KB::String *a4, uint64_t a5)
{
  uint64_t v39[125] = *MEMORY[0x1E4F143B8];
  if (a3 != 1)
  {
    KB::Candidate::Candidate((KB::Candidate *)v39, a4, 0);
    if (!v39[0])
    {
      BOOL v5 = 0;
LABEL_10:
      KB::Candidate::~Candidate((KB::Candidate *)v39);
      return v5;
    }
    KB::String::String((KB::String *)v37, (const KB::String *)(v39[1] + 240 * v39[0] - 240));
    if (*(unsigned char *)(a1 + 693)
      || *(unsigned char *)(a1 + 689)
      && (*(int (**)(void, unsigned char *, uint64_t))(**(void **)(*(void *)(a1 + 224) + 24) + 64))(*(void *)(*(void *)(a1 + 224) + 24), v37, 0xFFFFFFFFLL) > 2|| !TIInputManager::does_need_spell_check((TIInputManager *)a1, (const KB::String *)v37))
    {
      BOOL v5 = 0;
LABEL_6:
      if (v38 && v37[6] == 1) {
        free(v38);
      }
      goto LABEL_10;
    }
    if (!TIInputManager::is_autoshift((TIInputManager *)a1)) {
      goto LABEL_23;
    }
    TIInputManager::input_flags_vector((TIInputManager *)a1, &v31);
    if (v31.__end_ == v31.__begin_)
    {
      if (v31.__end_) {
        operator delete(v31.__end_);
      }
    }
    else
    {
      unint64_t v12 = 0;
      unsigned int v13 = 1;
      do
      {
        unsigned int v14 = v31.__begin_[v12] & 0x13;
        unint64_t v12 = v13++;
      }
      while (v14 != 1 && v31.__end_ - v31.__begin_ > v12);
      operator delete(v31.__begin_);
      if (v14 == 1)
      {
LABEL_23:
        KB::spellcheck_candidates(a4, (const KB::String *)(a1 + 104), (uint64_t)&v31);
        KB::CandidateCollection::operator=(a2, (uint64_t)&v31);
        long long v35 = (std::vector<unsigned int> *)v34;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = (std::vector<unsigned int> *)v33;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = (std::vector<unsigned int> *)v32;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = &v31;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
LABEL_29:
        KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)&v31, (const KB::Candidate **)a2);
        if (*(void *)(a1 + 568))
        {
          Mutable = CFStringCreateMutable(0, 0);
          CFStringAppend(Mutable, @"Skipped candidate quality filters for spellchecking candidates.\n");
        }
        else
        {
          Mutable = 0;
        }
        TIInputManager::filter_spellcheck_candidates((TIInputManager *)a1, (uint64_t **)a2, a4);
        (*(void (**)(uint64_t, uint64_t, __CFString *))(a5 + 16))(a5, a2, Mutable);
        if (*(void *)(a1 + 568))
        {
          (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(a1 + 184) + 488))(&cf);
          memset(v28, 0, sizeof(v28));
          KB::CandidateFilterFlags::CandidateFilterFlags(__p, v28);
          uint64_t v17 = *(void *)(a1 + 568);
          int v18 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)__p);
          unsigned int v19 = (const KB::String *)&kGenericFlagDesc;
          if (v18 == 1) {
            unsigned int v19 = (const KB::String *)&kPostLMFlagDesc;
          }
          if (v18) {
            unsigned int v20 = v19;
          }
          else {
            unsigned int v20 = (const KB::String *)&kPreLMFlagDesc;
          }
          KB::String::String((KB::String *)&v35, v20);
          CFTypeRef v21 = cf;
          CFTypeRef v27 = cf;
          if (cf)
          {
            CFRetain(cf);
            CFTypeRef v27 = v21;
          }
          (*(void (**)(uint64_t, const KB::String *, uint64_t, std::vector<unsigned int> **, std::vector<unsigned int> *, __CFString *, uint64_t, CFTypeRef *))(*(void *)v17 + 24))(v17, a4, a3, &v35, &v31, Mutable, a2, &v27);
          if (v27) {
            CFRelease(v27);
          }
          CFTypeRef v27 = 0;
          if (v36 && BYTE6(v35) == 1) {
            free(v36);
          }
          if (__p[0])
          {
            __p[1] = __p[0];
            operator delete(__p[0]);
          }
          if (cf) {
            CFRelease(cf);
          }
        }
        uint64_t v22 = *(const KB::Candidate **)a2;
        uint64_t v23 = *(void *)(a2 + 8);
        BOOL v5 = *(void *)a2 != v23;
        if (!a3 && *(void *)a2 != v23)
        {
          int v24 = (const KB::Candidate *)((char *)v22 + 888);
          if (!*((_WORD *)v22 + 444)) {
            KB::Candidate::compute_string(v22);
          }
          if (v24 == a4 || KB::String::equal(v24, a4, 1))
          {
            long long v26 = *(const KB::Candidate **)a2;
            for (uint64_t i = *(const KB::Candidate **)(a2 + 8);
                  i != v26;
            *(void *)(a2 + 8) = v26;
          }
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        long long v35 = (std::vector<unsigned int> *)v34;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = (std::vector<unsigned int> *)v33;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = (std::vector<unsigned int> *)v32;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        long long v35 = &v31;
        std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v35);
        goto LABEL_6;
      }
    }
    KB::lower_string(a4, *(const KB::String **)(a1 + 136), (KB::String *)&v35);
    KB::spellcheck_candidates((KB *)&v35, (const KB::String *)(a1 + 104), (uint64_t)&v31);
    KB::CandidateCollection::operator=(a2, (uint64_t)&v31);
    __p[0] = v34;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = v33;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = v32;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    __p[0] = &v31;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
    if (v36 && BYTE6(v35) == 1) {
      free(v36);
    }
    goto LABEL_29;
  }
  return 0;
}

uint64_t TIInputManager::does_need_spell_check(TIInputManager *this, const KB::String *a2)
{
  unsigned int v4 = *((unsigned __int16 *)a2 + 2);
  if (!*((_WORD *)a2 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a2);
    unsigned int v4 = *((unsigned __int16 *)a2 + 2);
  }
  if (v4 < 3) {
    return 0;
  }
  KB::DictionaryContainer::lookup(*((void *)this + 28), &v9);
  uint64_t v6 = *((void *)this + 68);
  if (v6) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = v9 == v10;
  }
  uint64_t v5 = v7;
  if (v6 && v9 == v10) {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const KB::String *))(*(void *)v6 + 24))(v6, a2);
  }
  unsigned int v11 = (void **)&v9;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v11);
  return v5;
}

BOOL TIInputManager::is_autoshift(TIInputManager *this)
{
  uint64_t v1 = *((unsigned int *)this + 24);
  uint64_t v2 = v1 + 1;
  uint64_t v3 = 40 * v1 - 8;
  while (--v2)
  {
    uint64_t v4 = *((void *)this + 1);
    char v5 = *(unsigned char *)(v4 + v3);
    v3 -= 40;
    if ((v5 & 0x40) != 0) {
      return v2 != -858993459 * ((unint64_t)(*((void *)this + 2) - v4) >> 3)
    }
          && (*(_DWORD *)(v4 + 40 * v2 + 32) & 0x42) == 2;
  }
  uint64_t v4 = *((void *)this + 1);
  return v2 != -858993459 * ((unint64_t)(*((void *)this + 2) - v4) >> 3)
      && (*(_DWORD *)(v4 + 40 * v2 + 32) & 0x42) == 2;
}

void TIInputManager::input_flags_vector(TIInputManager *this@<X0>, std::vector<unsigned int> *a2@<X8>)
{
  a2->__begin_ = 0;
  a2->__end_ = 0;
  a2->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a2, -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3));
  uint64_t v4 = *((void *)this + 1);
  if (-858993459 * ((unint64_t)(*((void *)this + 2) - v4) >> 3))
  {
    unint64_t v5 = 0;
    std::vector<std::string>::pointer end = (char *)a2->__end_;
    value = a2->__end_cap_.__value_;
    std::vector<unsigned int>::pointer begin = a2->__begin_;
    do
    {
      unsigned int v9 = *(_DWORD *)(v4 + 40 * v5 + 32);
      if (end >= (char *)value)
      {
        uint64_t v11 = (end - (char *)begin) >> 2;
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 62) {
          abort();
        }
        if (((char *)value - (char *)begin) >> 1 > v12) {
          unint64_t v12 = ((char *)value - (char *)begin) >> 1;
        }
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13) {
          unint64_t v13 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v13);
        }
        else {
          uint64_t v14 = 0;
        }
        char v15 = (unsigned int *)(v13 + 4 * v11);
        *char v15 = v9;
        uint64_t v10 = v15 + 1;
        while (end != (char *)begin)
        {
          unsigned int v16 = *((_DWORD *)end - 1);
          end -= 4;
          *--char v15 = v16;
        }
        value = (unsigned int *)(v13 + 4 * v14);
        a2->__begin_ = v15;
        a2->__end_ = v10;
        a2->__end_cap_.__value_ = value;
        if (begin) {
          operator delete(begin);
        }
        std::vector<unsigned int>::pointer begin = v15;
      }
      else
      {
        *(_DWORD *)std::vector<std::string>::pointer end = v9;
        uint64_t v10 = (unsigned int *)(end + 4);
      }
      a2->__end_ = v10;
      ++v5;
      uint64_t v4 = *((void *)this + 1);
      std::vector<std::string>::pointer end = (char *)v10;
    }
    while (v5 < -858993459 * ((unint64_t)(*((void *)this + 2) - v4) >> 3));
  }
}

uint64_t KB::CandidateCollection::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 16) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 24));
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 48));
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a2 + 48);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 64) = 0;
  std::vector<KB::Candidate>::__vdeallocate((void **)(a1 + 72));
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 80) = 0;
  *(void *)(a2 + 88) = 0;
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  return a1;
}

{
  if (a1 != a2)
  {
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)a1, *(const KB::Candidate **)a2, *(const KB::Candidate **)(a2 + 8), 0x1CAC083126E978D5 * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 24), *(const KB::Candidate **)(a2 + 24), *(const KB::Candidate **)(a2 + 32), 0x1CAC083126E978D5 * ((uint64_t)(*(void *)(a2 + 32) - *(void *)(a2 + 24)) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 48), *(const KB::Candidate **)(a2 + 48), *(const KB::Candidate **)(a2 + 56), 0x1CAC083126E978D5 * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
    std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>((KB::Candidate **)(a1 + 72), *(const KB::Candidate **)(a2 + 72), *(const KB::Candidate **)(a2 + 80), 0x1CAC083126E978D5 * ((uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 3));
  }
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  return a1;
}

void TIInputManager::filter_spellcheck_candidates(TIInputManager *this, uint64_t **a2, const KB::String *a3)
{
  uint64_t v4 = *((void *)this + 68);
  if (v4)
  {
    unint64_t v5 = *(void (**)(uint64_t, uint64_t **, const KB::String *))(*(void *)v4 + 56);
    uint64_t v6 = *((void *)this + 68);
    v5(v6, a2, a3);
  }
  else
  {
    unsigned int v8 = *a2;
    BOOL v7 = a2[1];
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    void v10[2] = ___ZNK14TIInputManager28filter_spellcheck_candidatesERN2KB19CandidateCollectionERKNS0_6StringE_block_invoke;
    void v10[3] = &__block_descriptor_tmp_26;
    v10[4] = this;
    void v10[5] = a3;
    unsigned int v9 = std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(v8, v7, (uint64_t)v10);
    std::vector<KB::Candidate>::erase((uint64_t)a2, v9, (KB::Candidate *)a2[1]);
  }
}

BOOL ___ZNK14TIInputManager28filter_spellcheck_candidatesERN2KB19CandidateCollectionERKNS0_6StringE_block_invoke(uint64_t a1, _WORD *a2, uint64_t a3, const KB::String *a4)
{
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 224) + 8);
  uint64_t v6 = (_LXLexicon *)(a2 + 444);
  if (!a2[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(v5 + 72), v6, *(const KB::String **)(a1 + 40), a4) != 0;
}

uint64_t *std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  if (a1 == a2) {
    return a2;
  }
  uint64_t v5 = a1;
  while (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, v5) & 1) == 0)
  {
    v5 += 125;
    if (v5 == a2) {
      return a2;
    }
  }
  if (v5 == a2) {
    return a2;
  }
  for (uint64_t i = v5 + 125; i != a2; i += 125)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t *))(a3 + 16))(a3, i) & 1) == 0)
    {
      KB::Candidate::operator=(v5, i);
      v5 += 125;
    }
  }
  return v5;
}

void std::vector<unsigned int>::reserve(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  if (__n > this->__end_cap_.__value_ - this->__begin_)
  {
    if (__n >> 62) {
      abort();
    }
    int64_t v3 = (char *)this->__end_ - (char *)this->__begin_;
    uint64_t v4 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(__n);
    uint64_t v5 = (unsigned int *)&v4[v3 & 0xFFFFFFFFFFFFFFFCLL];
    BOOL v7 = (unsigned int *)&v4[4 * v6];
    std::vector<unsigned int>::pointer begin = this->__begin_;
    std::vector<std::string>::pointer end = this->__end_;
    uint64_t v10 = v5;
    if (end != this->__begin_)
    {
      uint64_t v10 = v5;
      do
      {
        unsigned int v11 = *--end;
        *--uint64_t v10 = v11;
      }
      while (end != begin);
    }
    this->__begin_ = v10;
    this->__end_ = v5;
    this->__end_cap_.__value_ = v7;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void *std::__function::__value_func<void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::vector<KB::Candidate>::__assign_with_size[abi:nn180100]<KB::Candidate*,KB::Candidate*>(KB::Candidate **a1, const KB::Candidate *a2, const KB::Candidate *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  unsigned int v8 = *a1;
  if (0x1CAC083126E978D5 * ((a1[2] - *a1) >> 3) >= a4)
  {
    unint64_t v13 = a1[1];
    if (0x1CAC083126E978D5 * ((v13 - v8) >> 3) >= a4)
    {
      if (a2 != a3)
      {
        do
        {
          KB::Candidate::operator=((uint64_t)v8, (uint64_t)v6);
          uint64_t v6 = (const KB::Candidate *)((char *)v6 + 1000);
          unsigned int v8 = (KB::Candidate *)((char *)v8 + 1000);
        }
        while (v6 != a3);
        unint64_t v13 = a1[1];
      }
      while (v13 != v8)
        KB::Candidate::~Candidate((KB::Candidate *)((char *)v13 - 1000));
      a1[1] = v8;
    }
    else
    {
      uint64_t v14 = (const KB::Candidate *)((char *)a2 + 8 * ((v13 - v8) >> 3));
      if (v13 != v8)
      {
        uint64_t v15 = 8 * ((v13 - v8) >> 3);
        do
        {
          KB::Candidate::operator=((uint64_t)v8, (uint64_t)v6);
          uint64_t v6 = (const KB::Candidate *)((char *)v6 + 1000);
          unsigned int v8 = (KB::Candidate *)((char *)v8 + 1000);
          v15 -= 1000;
        }
        while (v15);
        unsigned int v8 = a1[1];
      }
      unsigned int v16 = v8;
      if (v14 != a3)
      {
        unsigned int v16 = v8;
        do
        {
          uint64_t v17 = KB::Candidate::Candidate(v16, v14);
          uint64_t v14 = (const KB::Candidate *)((char *)v14 + 1000);
          unsigned int v16 = (KB::Candidate *)((char *)v17 + 1000);
        }
        while (v14 != a3);
      }
      a1[1] = v16;
    }
  }
  else
  {
    std::vector<KB::Candidate>::__vdeallocate((void **)a1);
    if (a4 > 0x4189374BC6A7EFLL) {
      abort();
    }
    unint64_t v9 = 0x395810624DD2F1AALL * ((a1[2] - *a1) >> 3);
    if (v9 <= a4) {
      unint64_t v9 = a4;
    }
    if ((unint64_t)(0x1CAC083126E978D5 * ((a1[2] - *a1) >> 3)) >= 0x20C49BA5E353F7) {
      unint64_t v10 = 0x4189374BC6A7EFLL;
    }
    else {
      unint64_t v10 = v9;
    }
    std::vector<KB::Candidate>::__vallocate[abi:nn180100](a1, v10);
    unsigned int v11 = a1[1];
    while (v6 != a3)
    {
      unint64_t v12 = KB::Candidate::Candidate(v11, v6);
      uint64_t v6 = (const KB::Candidate *)((char *)v6 + 1000);
      unsigned int v11 = (KB::Candidate *)((char *)v12 + 1000);
    }
    a1[1] = v11;
  }
}

void std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, const KB::Candidate **a2, uint64_t a3, unsigned __int8 *a4)
{
  v44[5] = *MEMORY[0x1E4F143B8];
  std::string __p = *(unsigned int **)a3;
  uint64_t v29 = *(unsigned int **)a3;
  long long v26 = *(_OWORD *)(a3 + 8);
  long long v30 = v26;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  int v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(v7 + 568)) {
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  }
  else {
    CFMutableStringRef Mutable = 0;
  }
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v35, a2);
  kdebug_trace();
  log = kac_get_log();
  os_signpost_id_t v9 = os_signpost_id_make_with_pointer(log, (const void *)(v7 ^ 0x15));
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v10 = v9;
    if (os_signpost_enabled(log))
    {
      *(_WORD *)std::string buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1E3F0E000, log, OS_SIGNPOST_INTERVAL_BEGIN, v10, "kbdManager.filterCandidates", (const char *)&unk_1E41704BE, buf, 2u);
    }
  }
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v12 = *(void *)(a1 + 24);
  uint64_t v13 = **(unsigned int **)(a1 + 32);
  __dst = 0;
  uint64_t v34 = 0;
  int64_t v32 = 0;
  int64_t v14 = v26 - (void)__p;
  if ((unsigned int *)v26 != __p)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&v32, v14 >> 3);
    uint64_t v15 = (char *)__dst;
    memmove(__dst, __p, v14);
    __dst = &v15[v14];
    int64_t v14 = v32;
  }
  TIInputManager::filter_raw_candidates(v7, (uint64_t)a2, v11, v12, v13);
  KB::CandidateCollection::operator=((uint64_t)a2, (uint64_t)buf);
  CFTypeRef cf = v44;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = &v43;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = &v42;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = buf;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  if (v14) {
    operator delete((void *)v14);
  }
  kdebug_trace();
  unsigned int v16 = kac_get_log();
  os_signpost_id_t v17 = os_signpost_id_make_with_pointer(v16, (const void *)(v7 ^ 0x15));
  if (v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v18 = v17;
    if (os_signpost_enabled(v16))
    {
      *(_WORD *)std::string buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1E3F0E000, v16, OS_SIGNPOST_INTERVAL_END, v18, "kbdManager.filterCandidates", (const char *)&unk_1E41704BE, buf, 2u);
    }
  }
  if (v6) {
    (*(void (**)(void))(**(void **)(a1 + 40) + 16))();
  }
  if (*(void *)(v7 + 568))
  {
    (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v7 + 184) + 488))(&cf);
    int v19 = KB::CandidateFilterFlags::candidate_filter_flag_type(&v29);
    unsigned int v20 = (const KB::String *)&kGenericFlagDesc;
    if (v19 == 1) {
      unsigned int v20 = (const KB::String *)&kPostLMFlagDesc;
    }
    if (v19) {
      CFTypeRef v21 = v20;
    }
    else {
      CFTypeRef v21 = (const KB::String *)&kPreLMFlagDesc;
    }
    KB::String::String((KB::String *)buf, v21);
    uint64_t v22 = *(void *)(v7 + 568);
    uint64_t v23 = *(void *)(a1 + 16);
    uint64_t v24 = **(unsigned int **)(a1 + 32);
    CFTypeRef v25 = cf;
    CFTypeRef v31 = cf;
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v31 = v25;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint8_t *, unsigned char *, CFMutableStringRef, const KB::Candidate **, CFTypeRef *))(*(void *)v22 + 24))(v22, v23, v24, buf, v35, Mutable, a2, &v31);
    if (v31) {
      CFRelease(v31);
    }
    CFTypeRef v31 = 0;
    if (v41 && buf[6] == 1) {
      free(v41);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  *(void *)std::string buf = &v38;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(void *)std::string buf = &v37;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(void *)std::string buf = &v36;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(void *)std::string buf = v35;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (__p) {
    operator delete(__p);
  }
}

void TIInputManager::filter_raw_candidates(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5);
  uint64_t v7 = v6;
  int v9 = v8;
  uint64_t v11 = v10;
  uint64_t v13 = v12;
  uint64_t v15 = v14;
  os_signpost_id_t v17 = v16;
  uint64_t v18 = v5;
  unsigned int v20 = v19;
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  KB::CandidateCollection::CandidateCollection(v19, v21);
  std::vector<KB::FilterFlag>::vector(__p, v11);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v18 + 48))(&v50, v18, v13, __p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v50)
  {
    (*(void (**)(uint64_t *__return_ptr, uint64_t, const KB::String *))(*(void *)v18 + 72))(&v74, v18, v17);
    KB::Candidate::Candidate((KB::Candidate *)v73, v17, *(_DWORD *)(v18 + 248));
    char v22 = v76;
    if (v76)
    {
      KB::Candidate::Candidate((KB::Candidate *)v71, (const KB::String *)&v74, *(_DWORD *)(v18 + 248));
      char v22 = 1;
    }
    else
    {
      v71[0] = 0;
    }
    char v72 = v22;
    KB::Candidate::Candidate((KB::Candidate *)v70, (const KB::String *)(v18 + 192), 0);
    int v23 = KB::String::last((KB::String *)(v18 + 400));
    int v24 = KB::String::last((KB::String *)(v18 + 400));
    {
      KB::String::String((KB::String *)&TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, ",~:;!@#$%^&'.(){}[]_/\\<>|");
      __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, &dword_1E3F0E000);
    }
    unsigned int v25 = *(unsigned __int16 *)(v18 + 400);
    long long v26 = v7;
    if (v25 >= 2)
    {
      uint64_t v28 = *(void *)(v18 + 408);
      if (!v28) {
        uint64_t v28 = v18 + 416;
      }
      *(void *)&long long v39 = v28;
      DWORD2(v39) = v25;
      HIDWORD(v39) = v25;
      LODWORD(v40) = 0;
      KB::String::iterator::initialize((uint64_t *)&v39);
      long long v63 = v39;
      *(void *)uint64_t v64 = v40;
      uint64_t v29 = 2;
      do
      {
        KB::String::iterator::operator--((KB::String::iterator *)&v63);
        --v29;
      }
      while (v29);
      BOOL v27 = !KB::String::contains((KB::String *)&TIInputManager::filter_raw_candidates(KB::CandidateCollection const&,KB::String const&,KB::String const&,KB::LookupType,KB::CandidateFilterFlags,BOOL,__CFString *)const::disallowed_domain_characters, v64[0]);
    }
    else
    {
      BOOL v27 = 1;
    }
    KB::Candidate::Candidate((KB::Candidate *)v62, (const KB::Candidate *)v73);
    v60[0] = 0;
    char v61 = 0;
    if (v72)
    {
      KB::Candidate::Candidate((KB::Candidate *)v60, (const KB::Candidate *)v71);
      char v61 = 1;
    }
    TIInputManager::input_flags_vector((TIInputManager *)v18, &v48);
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v41, (const KB::LanguageModelContext *)(v18 + 432));
    KB::String::String((KB::String *)v58, v15);
    KB::Candidate::Candidate((KB::Candidate *)v57, (const KB::Candidate *)v70);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)&v63, (uint64_t)v62, (const KB::Candidate *)v60, (uint64_t)&v48, (uint64_t)v41, (KB::String *)v58, (uint64_t)v57, v13);
    KB::Candidate::~Candidate((KB::Candidate *)v57);
    if (v59 && v58[6] == 1) {
      free(v59);
    }
    *(void *)&long long v39 = &v47;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v39);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v46);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v45);
    if (v43)
    {
      int v44 = v43;
      operator delete(v43);
    }
    if (v42) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v42);
    }
    if (v48.__begin_)
    {
      v48.__end_ = v48.__begin_;
      operator delete(v48.__begin_);
    }
    if (v61) {
      KB::Candidate::~Candidate((KB::Candidate *)v60);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v62);
    uint64_t v30 = *(void *)(v18 + 8);
    if (-858993459 * ((unint64_t)(*(void *)(v18 + 16) - v30) >> 3)) {
      BOOL v31 = (*(_DWORD *)(v30 + 32) & 3) == 1;
    }
    else {
      BOOL v31 = 0;
    }
    BOOL v65 = v31;
    BOOL v66 = v23 == 45;
    BOOL v67 = v24 == 46;
    BOOL v69 = v27;
    char v68 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    int64_t v32 = *(const void **)(v18 + 136);
    int v33 = *(_DWORD *)(v18 + 248);
    uint64_t v34 = *(unsigned int **)(v18 + 224);
    uint64_t v38 = v34;
    if (v34) {
      atomic_fetch_add((atomic_uint *volatile)v34, 1u);
    }
    long long v35 = *(std::__shared_weak_count **)(v18 + 240);
    uint64_t v36 = *(void *)(v18 + 232);
    uint64_t v37 = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)&v39, v32, v33, (uint64_t *)&v38, (uint64_t)&v36, *(const void **)(v18 + 560), v18 + 592, v26);
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v37);
    }
    if (v38) {
      WTF::RefCounted<KB::DictionaryContainer>::deref(v38);
    }
    (*(void (**)(uint64_t, KB::CandidateCollection *, long long *, long long *))(*(void *)v50 + 24))(v50, v20, &v63, &v39);
    if (!v13 && v9)
    {
      if (*(void *)v20 == *((void *)v20 + 1))
      {
        int v52 = 0x100000;
        __int16 v53 = 0;
        char v54 = 0;
        int v55 = 0;
        char v56 = 0;
      }
      else
      {
        KB::Candidate::capitalized_string(*(KB::Candidate **)v20, (uint64_t)&v52);
      }
      KB::String::operator=(v18 + 192, (KB::String *)&v52);
      if (v55)
      {
        if (v54 == 1) {
          free(v55);
        }
      }
    }
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)&v39);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)&v63);
    KB::Candidate::~Candidate((KB::Candidate *)v70);
    if (v72) {
      KB::Candidate::~Candidate((KB::Candidate *)v71);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v73);
    if (v76 && v75 && BYTE6(v74) == 1) {
      free(v75);
    }
  }
  if (v51) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v51);
  }
}

__n128 std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73C00;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F3F73C00;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0,std::allocator<TIInputManager::lookup_static_dynamic_candidates(KB::CandidateCollection &,KB::LookupType,KB::String const&,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
}

void TIInputManager::create_autocorrection_engine_with_synthetic_typing(TIInputManager *this, const KB::String *a2)
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  KB::system_uptime(this);
  TIInputManager::create_autocorrection_engine(this);
}

char *TIInputManager::favonius_layout(TIInputManager *this)
{
  uint64_t v2 = (char *)this + 320;
  uint64_t v3 = *((void *)this + 40);
  if (!v3) {
    operator new();
  }
  int v5 = *(unsigned __int16 *)(v3 + 208);
  uint64_t v4 = (KB::String *)(v3 + 208);
  if (!v5) {
    KB::String::operator=(v4, (TIInputManager *)((char *)this + 288));
  }
  return v2;
}

void std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, const KB::Candidate **a2, uint64_t a3, unsigned __int8 *a4)
{
  void v41[4] = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned int **)a3;
  long long v26 = *(unsigned int **)a3;
  long long v23 = *(_OWORD *)(a3 + 8);
  long long v27 = v23;
  *(void *)(a3 + 8) = 0;
  *(void *)(a3 + 16) = 0;
  *(void *)a3 = 0;
  int v25 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  if (*(void *)(v7 + 568)) {
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  }
  else {
    CFMutableStringRef Mutable = 0;
  }
  uint64_t v8 = (uint64_t)a2;
  KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v32, a2);
  uint64_t v9 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = **(unsigned int **)(a1 + 32);
  __dst = 0;
  uint64_t v31 = 0;
  int64_t v29 = 0;
  int64_t v12 = v23 - (void)v6;
  if ((unsigned int *)v23 == v6)
  {
    int64_t v14 = v6;
  }
  else
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&v29, v12 >> 3);
    uint64_t v13 = (char *)__dst;
    int64_t v14 = v6;
    memmove(__dst, v6, v12);
    __dst = &v13[v12];
    int64_t v12 = v29;
  }
  TIInputManager::filter_raw_candidates(v7, v8, v9, v10, v11);
  KB::CandidateCollection::operator=(v8, (uint64_t)&v37);
  CFTypeRef cf = v41;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = &v40;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = &v39;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  CFTypeRef cf = &v37;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
  if (v12) {
    operator delete((void *)v12);
  }
  if (v25) {
    (*(void (**)(void))(**(void **)(a1 + 40) + 16))();
  }
  uint64_t v15 = *(void *)(v7 + 568);
  if (v15)
  {
    (*(void (**)(uint64_t, void, BOOL))(*(void *)v15 + 16))(v15, **(void **)(a1 + 48), *(void *)(v7 + 224) != 0);
    (*(void (**)(CFTypeRef *__return_ptr))(***(void ***)(a1 + 48) + 488))(&cf);
    int v16 = KB::CandidateFilterFlags::candidate_filter_flag_type(&v26);
    os_signpost_id_t v17 = (const KB::String *)&kGenericFlagDesc;
    if (v16 == 1) {
      os_signpost_id_t v17 = (const KB::String *)&kPostLMFlagDesc;
    }
    if (v16) {
      uint64_t v18 = v17;
    }
    else {
      uint64_t v18 = (const KB::String *)&kPreLMFlagDesc;
    }
    KB::String::String((KB::String *)&v37, v18);
    uint64_t v19 = *(void *)(v7 + 568);
    uint64_t v20 = *(void *)(a1 + 16);
    uint64_t v21 = **(unsigned int **)(a1 + 32);
    CFTypeRef v22 = cf;
    CFTypeRef v28 = cf;
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v28 = v22;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, void ***, unsigned char *, CFMutableStringRef, uint64_t, CFTypeRef *))(*(void *)v19 + 24))(v19, v20, v21, &v37, v32, Mutable, v8, &v28);
    if (v28) {
      CFRelease(v28);
    }
    CFTypeRef v28 = 0;
    if (v38 && BYTE6(v37) == 1) {
      free(v38);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  uint64_t v37 = (void **)&v35;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  uint64_t v37 = (void **)&v34;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  uint64_t v37 = (void **)&v33;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  uint64_t v37 = (void **)v32;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](&v37);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v14) {
    operator delete(v14);
  }
}

__n128 std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73C48;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1F3F73C48;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0,std::allocator<TIInputManager::lookup_revision_candidates(KB::CandidateCollection &,KB::LookupType,void({block_pointer})(KB::CandidateCollection &,__CFString *),unsigned int,KB::String const&)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
}

void TIInputManager::create_autocorrection_engine(TIInputManager *this)
{
}

void *std::__function::__value_func<void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t WTF::RefCounted<TI::Favonius::Touch>::deref(uint64_t result)
{
  unsigned int v1 = atomic_load((unsigned int *)result);
  if (v1 == 1)
  {
    uint64_t v2 = *(void *)(result + 56);
    if (v2) {
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
    }
    JUMPOUT(0x1E4E7BC20);
  }
  atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF);
  return result;
}

uint64_t std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::operator()(uint64_t result, atomic_uint **a2)
{
  uint64_t v2 = *(uint64_t **)(result + 8);
  if (!*v2)
  {
    long long v3 = *a2;
    if (*a2)
    {
      atomic_fetch_add(v3, 1u);
      __n128 result = *v2;
      uint64_t *v2 = (uint64_t)v3;
      if (result) {
        return WTF::RefCounted<TI::Favonius::Key>::deref(result);
      }
    }
    else
    {
      uint64_t *v2 = 0;
    }
  }
  return result;
}

uint64_t std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F73C90;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3F73C90;
  result[1] = v3;
  return result;
}

void std::__function::__func<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0,std::allocator<TIInputManager::create_autocorrection_engine_with_synthetic_typing(KB::String const&)::$_0>,void ()(WTF::RefPtr<TI::Favonius::LayoutKey> const&)>::~__func()
{
}

uint64_t *KB::String::find_last_of(KB::String *this, const KB::String *a2, const KB::String *a3)
{
  int v6 = *(unsigned __int16 *)a2;
  uint64_t v7 = (char *)*((void *)a2 + 1);
  if (!v7) {
    uint64_t v7 = (char *)a2 + 16;
  }
  uint64_t v9 = v7;
  int v10 = v6;
  int v11 = v6;
  int v12 = 0;
  KB::String::iterator::initialize((uint64_t *)&v9);
  return KB::String::find_last_of(a2, a3, (const KB::String::iterator *)&v9, (uint64_t)this);
}

uint64_t repeating_character_threshold(const __CFLocale *a1)
{
  if (a1
    && (CFStringRef Value = (const __CFString *)CFLocaleGetValue(a1, (CFLocaleKey)*MEMORY[0x1E4F1D218]),
        CFEqual(Value, @"de")))
  {
    return 4;
  }
  else
  {
    return 3;
  }
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(unint64_t a1, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
LABEL_2:
  uint64_t v10 = a1;
  uint64_t v58 = a1 + 1000;
  uint64_t v11 = a1 + 2000;
  while (1)
  {
    uint64_t v12 = (uint64_t)a2 - v10;
    unint64_t v13 = 0x1CAC083126E978D5 * (((uint64_t)a2 - v10) >> 3);
    if (!(!v5 & v4))
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return;
        case 2uLL:
          float v43 = expf(*((float *)a2 - 64));
          if (v43 > expf(*(float *)(v10 + 744))) {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v10, a2 - 125);
          }
          break;
        case 3uLL:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10, v10 + 1000, (uint64_t)(a2 - 125));
          break;
        case 4uLL:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10, v10 + 1000, v10 + 2000, (uint64_t)(a2 - 125));
          break;
        case 5uLL:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10, v10 + 1000, v10 + 2000, v10 + 3000, (uint64_t)(a2 - 125));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v12 <= 23999) {
      break;
    }
    if (!a3)
    {
      if ((uint64_t *)v10 != a2) {
        std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,KB::Candidate *>(v10, a2, a2);
      }
      return;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = (uint64_t *)(v10 + 1000 * (v13 >> 1));
    uint64_t v16 = (uint64_t)(a2 - 125);
    if ((unint64_t)v12 >= 0x1F401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10, v10 + 1000 * (v13 >> 1), v16);
      uint64_t v17 = v10 + 1000 * v14;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v58, v17 - 1000, (uint64_t)(a2 - 250));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v11, v17 + 1000, (uint64_t)(a2 - 375));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v17 - 1000, (uint64_t)v15, v17 + 1000);
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)v10, v15);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10 + 1000 * (v13 >> 1), v10, v16);
    }
    --a3;
    if ((a4 & 1) == 0)
    {
      float v18 = expf(*(float *)(v10 - 256));
      if (v18 <= expf(*(float *)(v10 + 744)))
      {
        KB::Candidate::Candidate((uint64_t)v59, v10);
        float v32 = expf(v60);
        if (v32 <= expf(*((float *)a2 - 64)))
        {
          unint64_t v35 = v10 + 1000;
          do
          {
            a1 = v35;
            if (v35 >= (unint64_t)a2) {
              break;
            }
            float v36 = expf(*(float *)(v35 + 744));
            unint64_t v35 = a1 + 1000;
          }
          while (v32 <= v36);
        }
        else
        {
          uint64_t v33 = v10;
          do
          {
            a1 = v33 + 1000;
            float v34 = expf(*(float *)(v33 + 1744));
            uint64_t v33 = a1;
          }
          while (v32 <= v34);
        }
        uint64_t v37 = a2;
        if (a1 < (unint64_t)a2)
        {
          uint64_t v38 = a2;
          do
          {
            uint64_t v37 = v38 - 125;
            float v39 = expf(*((float *)v38 - 64));
            uint64_t v38 = v37;
          }
          while (v32 > v39);
        }
        while (a1 < (unint64_t)v37)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, v37);
          float v40 = expf(v60);
          do
          {
            float v41 = *(float *)(a1 + 1744);
            a1 += 1000;
          }
          while (v40 <= expf(v41));
          do
          {
            float v42 = *((float *)v37 - 64);
            v37 -= 125;
          }
          while (v40 > expf(v42));
        }
        if (a1 - 1000 != v10) {
          KB::Candidate::operator=((uint64_t *)v10, (uint64_t *)(a1 - 1000));
        }
        KB::Candidate::operator=((uint64_t *)(a1 - 1000), v59);
        KB::Candidate::~Candidate((KB::Candidate *)v59);
        a4 = 0;
        goto LABEL_2;
      }
    }
    KB::Candidate::Candidate((uint64_t)v59, v10);
    float v19 = expf(v60);
    uint64_t v20 = (uint64_t *)v10;
    do
    {
      uint64_t v21 = (uint64_t)v20;
      v20 += 125;
    }
    while (expf(*(float *)(v21 + 1744)) > v19);
    CFTypeRef v22 = a2;
    if (v21 == v10)
    {
      int v25 = a2;
      while (v20 < v25)
      {
        long long v23 = v25 - 125;
        float v26 = expf(*((float *)v25 - 64));
        int v25 = v23;
        if (v26 > v19) {
          goto LABEL_22;
        }
      }
      long long v23 = v25;
    }
    else
    {
      do
      {
        long long v23 = v22 - 125;
        float v24 = expf(*((float *)v22 - 64));
        CFTypeRef v22 = v23;
      }
      while (v24 <= v19);
    }
LABEL_22:
    if (v20 < v23)
    {
      long long v27 = v20;
      CFTypeRef v28 = v23;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v27, v28);
        float v29 = expf(v60);
        do
        {
          uint64_t v21 = (uint64_t)v27;
          v27 += 125;
        }
        while (expf(*(float *)(v21 + 1744)) > v29);
        do
        {
          float v30 = *((float *)v28 - 64);
          v28 -= 125;
        }
        while (expf(v30) <= v29);
      }
      while (v27 < v28);
    }
    if (v21 != v10) {
      KB::Candidate::operator=((uint64_t *)v10, (uint64_t *)v21);
    }
    KB::Candidate::operator=((uint64_t *)v21, v59);
    KB::Candidate::~Candidate((KB::Candidate *)v59);
    if (v20 < v23) {
      goto LABEL_35;
    }
    char v31 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v10, v21);
    a1 = v21 + 1000;
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(v21 + 1000, (uint64_t)a2))
    {
      if (v31) {
        goto LABEL_2;
      }
LABEL_35:
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,false>(v10, v21, a3, a4 & 1);
      a4 = 0;
      a1 = v21 + 1000;
      goto LABEL_2;
    }
    a2 = (uint64_t *)v21;
    if (v31) {
      return;
    }
  }
  if (a4)
  {
    if ((uint64_t *)v10 != a2)
    {
      uint64_t v44 = v10 + 1000;
      if ((uint64_t *)(v10 + 1000) != a2)
      {
        uint64_t v45 = 0;
        uint64_t v46 = v10;
        do
        {
          uint64_t v47 = v46;
          uint64_t v46 = v44;
          float v48 = expf(*(float *)(v47 + 1744));
          if (v48 > expf(*(float *)(v47 + 744)))
          {
            KB::Candidate::Candidate((uint64_t)v59, v46);
            uint64_t v49 = v45;
            while (1)
            {
              KB::Candidate::operator=((uint64_t *)(v10 + v49 + 1000), (uint64_t *)(v10 + v49));
              if (!v49) {
                break;
              }
              float v50 = expf(v60);
              float v51 = expf(*(float *)(v10 + v49 - 256));
              v49 -= 1000;
              if (v50 <= v51)
              {
                int v52 = (uint64_t *)(v10 + v49 + 1000);
                goto LABEL_70;
              }
            }
            int v52 = (uint64_t *)v10;
LABEL_70:
            KB::Candidate::operator=(v52, v59);
            KB::Candidate::~Candidate((KB::Candidate *)v59);
          }
          uint64_t v44 = v46 + 1000;
          v45 += 1000;
        }
        while ((uint64_t *)(v46 + 1000) != a2);
      }
    }
  }
  else if ((uint64_t *)v10 != a2)
  {
    __int16 v53 = (uint64_t *)(v10 + 1000);
    while (v53 != a2)
    {
      uint64_t v54 = (uint64_t)v53;
      float v55 = expf(*(float *)(v10 + 1744));
      if (v55 > expf(*(float *)(v10 + 744)))
      {
        KB::Candidate::Candidate((uint64_t)v59, v54);
        do
        {
          char v56 = (uint64_t *)v10;
          KB::Candidate::operator=((uint64_t *)(v10 + 1000), (uint64_t *)v10);
          v10 -= 1000;
          float v57 = expf(v60);
        }
        while (v57 > expf(*((float *)v56 - 64)));
        KB::Candidate::operator=(v56, v59);
        KB::Candidate::~Candidate((KB::Candidate *)v59);
      }
      __int16 v53 = (uint64_t *)(v54 + 1000);
      uint64_t v10 = v54;
    }
  }
}

uint64_t TIInputManager::inject_supplemental_candidate(size_t a1, int a2, uint64_t *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!TITransientLexiconManagerGetActiveSupplementalLexiconWords()
    || a2 != 1
    && (a2
     || !*(_DWORD *)(a1 + 536)
     || (uint64_t v6 = *(void *)(a1 + 224)) != 0 && **(void **)(v6 + 8) != *(void *)(*(void *)(v6 + 8) + 8)))
  {
    char v7 = 0;
    return v7 & 1;
  }
  TIInputManager::legacy_input_stem((TIInputManager *)a1, (uint64_t)v40);
  v31[0] = MEMORY[0x1E4F143A8];
  v31[1] = 0x40000000;
  float v32 = ___ZN14TIInputManager29inject_supplemental_candidateEN2KB10LookupTypeERNS0_19CandidateCollectionE_block_invoke;
  uint64_t v33 = &__block_descriptor_tmp_5_5064;
  size_t v34 = a1;
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 0x40000000;
  v35[2] = (size_t)___ZN14TIInputManager30word_from_supplemental_lexiconERN2KB6StringE_block_invoke;
  void v35[3] = (size_t)&__block_descriptor_tmp_5065;
  void v35[4] = a1;
  KB::DynamicDictionary::word_from_supplemental_lexicon(*(void *)(*(void *)(a1 + 224) + 24), v38);
  uint64_t v10 = *a3;
  uint64_t v9 = a3[1];
  if (!v39)
  {
    if (v9 == *a3)
    {
      char v7 = 0;
      goto LABEL_61;
    }
    uint64_t v18 = 0;
    char v7 = 0;
    while (1)
    {
      float v19 = (void *)(v10 + 1000 * v18);
      if (*v19)
      {
        uint64_t v20 = 240 * *v19 - 240;
        uint64_t v21 = (uint64_t *)(v19[1] + 224);
        do
        {
          uint64_t v23 = *v21;
          v21 += 30;
          uint64_t v22 = v23;
          if (v23) {
            BOOL v24 = 1;
          }
          else {
            BOOL v24 = v20 == 0;
          }
          v20 -= 240;
        }
        while (!v24);
        if (!v22)
        {
          KB::DynamicDictionary::word_from_supplemental_lexicon(*(void *)(*(void *)(a1 + 224) + 24), v35);
          if (v36)
          {
            KB::Candidate::pop_last_word((KB::Candidate *)(v10 + 1000 * v18));
            if (!v36) {
              goto LABEL_66;
            }
            KB::Candidate::append((unsigned __int16 *)(v10 + 1000 * v18), v35);
            if (v36) {
              KB::Word::~Word((KB::Word *)v35);
            }
            char v7 = 1;
          }
          uint64_t v10 = *a3;
          uint64_t v9 = a3[1];
        }
      }
      if (++v18 >= (unint64_t)(0x1CAC083126E978D5 * ((v9 - v10) >> 3))) {
        goto LABEL_61;
      }
    }
  }
  if (v9 == *a3)
  {
LABEL_22:
    TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)&v42);
    KB::Candidate::Candidate((KB::Candidate *)v35, (const KB::String *)&v42, 0);
    if (v43 && BYTE6(v42) == 1) {
      free(v43);
    }
    if (v35[0]) {
      KB::Candidate::pop_last_word((KB::Candidate *)v35);
    }
    if (v39)
    {
      KB::Candidate::append((unsigned __int16 *)v35, v38);
      int v37 = 1065353216;
      unint64_t v15 = a3[2];
      uint64_t v16 = (KB::Candidate *)a3[1];
      if ((unint64_t)v16 < v15)
      {
        uint64_t v17 = (char *)KB::Candidate::Candidate(v16, (const KB::Candidate *)v35) + 1000;
LABEL_59:
        a3[1] = (uint64_t)v17;
        KB::Candidate::~Candidate((KB::Candidate *)v35);
        char v11 = 1;
        goto LABEL_60;
      }
      uint64_t v25 = 0x1CAC083126E978D5 * (((uint64_t)v16 - *a3) >> 3);
      if ((unint64_t)(v25 + 1) <= 0x4189374BC6A7EFLL)
      {
        unint64_t v26 = 0x1CAC083126E978D5 * ((uint64_t)(v15 - *a3) >> 3);
        uint64_t v27 = 2 * v26;
        if (2 * v26 <= v25 + 1) {
          uint64_t v27 = v25 + 1;
        }
        if (v26 >= 0x20C49BA5E353F7) {
          unint64_t v28 = 0x4189374BC6A7EFLL;
        }
        else {
          unint64_t v28 = v27;
        }
        uint64_t v46 = a3 + 2;
        if (v28) {
          unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v28);
        }
        else {
          uint64_t v29 = 0;
        }
        float v30 = (char *)(v28 + 1000 * v25);
        unint64_t v42 = v28;
        float v43 = v30;
        unint64_t v45 = v28 + 1000 * v29;
        KB::Candidate::Candidate((KB::Candidate *)v30, (const KB::Candidate *)v35);
        uint64_t v44 = v30 + 1000;
        std::vector<KB::Candidate>::__swap_out_circular_buffer(a3, &v42);
        uint64_t v17 = (char *)a3[1];
        std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v42);
        goto LABEL_59;
      }
    }
    else
    {
LABEL_66:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    abort();
  }
  char v11 = 0;
  unint64_t v12 = 0;
LABEL_12:
  uint64_t v13 = 1000 * v12;
  do
  {
    uint64_t v14 = *(void *)(v10 + v13);
    if (v14)
    {
      if (((uint64_t (*)(void *, unsigned char *, uint64_t))v32)(v31, v40, *(void *)(v10 + v13 + 8) + 240 * v14 - 240))
      {
        KB::Candidate::pop_last_word((KB::Candidate *)(v10 + v13));
        if (!v39) {
          goto LABEL_66;
        }
        KB::Candidate::append((unsigned __int16 *)(v10 + v13), v38);
        *(_DWORD *)(v10 + 1000 * v12++ + 744) = 1065353216;
        uint64_t v10 = *a3;
        uint64_t v9 = a3[1];
        char v11 = 1;
        if (v12 >= 0x1CAC083126E978D5 * ((v9 - *a3) >> 3)) {
          goto LABEL_60;
        }
        goto LABEL_12;
      }
      uint64_t v10 = *a3;
      uint64_t v9 = a3[1];
    }
    ++v12;
    v13 += 1000;
  }
  while (v12 < 0x1CAC083126E978D5 * ((v9 - v10) >> 3));
  if ((v11 & 1) == 0) {
    goto LABEL_22;
  }
LABEL_60:
  char v7 = v11;
LABEL_61:
  if (v39) {
    KB::Word::~Word((KB::Word *)v38);
  }
  if (v41 && v40[6] == 1) {
    free(v41);
  }
  return v7 & 1;
}

void TIInputManager::apply_case_insensitive_constraints(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 172) <= *(_DWORD *)(a1 + 176)) {
    int v6 = *(_DWORD *)(a1 + 176);
  }
  else {
    int v6 = *(_DWORD *)(a1 + 172);
  }
  char v7 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, v6, (uint64_t)v30);
  TIInputManager::input_substring(v7, 0, *(_DWORD *)(a1 + 172), (uint64_t)v28);
  TIInputManager::input_substring(v7, 0, *(_DWORD *)(a1 + 96), (uint64_t)v26);
  uint64_t v8 = 0;
  v16[0] = a2;
  v16[1] = a2 + 24;
  void v16[2] = a2 + 48;
  void v16[3] = a2 + 72;
  uint64_t v9 = MEMORY[0x1E4F143A8];
  do
  {
    uint64_t v10 = v16[v8];
    unint64_t v12 = *(uint64_t **)v10;
    char v11 = *(uint64_t **)(v10 + 8);
    v17[0] = v9;
    v17[1] = 1174405120;
    _OWORD v17[2] = ___ZN14TIInputManager34apply_case_insensitive_constraintsERN2KB19CandidateCollectionENS0_10LookupTypeEP10__CFString_block_invoke;
    _OWORD v17[3] = &__block_descriptor_tmp_18;
    void v17[4] = a1;
    KB::String::String((KB::String *)v18, (const KB::String *)v30);
    KB::String::String((KB::String *)v20, (const KB::String *)v28);
    KB::String::String((KB::String *)v22, (const KB::String *)v26);
    int v25 = a3;
    uint64_t v24 = a4;
    uint64_t v13 = std::remove_if[abi:nn180100]<std::__wrap_iter<KB::Candidate *>,BOOL({block_pointer})(KB::Candidate const&)>(v12, v11, (uint64_t)v17);
    std::vector<KB::Candidate>::erase(v10, v13, *(KB::Candidate **)(v10 + 8));
    if (v23 && v22[6] == 1) {
      free(v23);
    }
    if (v21 && v20[6] == 1) {
      free(v21);
    }
    if (v19 && v18[6] == 1) {
      free(v19);
    }
    ++v8;
  }
  while (v8 != 4);
  if (v27 && v26[6] == 1) {
    free(v27);
  }
  if (v29 && v28[6] == 1) {
    free(v29);
  }
  if (v31)
  {
    if (v30[6] == 1) {
      free(v31);
    }
  }
}

void TIInputManager::apply_case_changes(unsigned __int8 *a1, uint64_t a2, unsigned __int16 *a3, std::vector<unsigned int>::size_type a4, uint64_t a5, __CFString *a6)
{
  std::vector<unsigned int>::size_type v8 = a4;
  uint64_t v11 = 0;
  v39[2] = *MEMORY[0x1E4F143B8];
  v31[0] = a2;
  v31[1] = a2 + 24;
  unint64_t v12 = (uint64_t *)(a1 + 224);
  void v31[2] = a2 + 48;
  void v31[3] = a2 + 72;
  float v30 = (uint64_t *)(a1 + 224);
  unsigned int v29 = a4;
  do
  {
    uint64_t v28 = v11;
    uint64_t v13 = (uint64_t *)v31[v11];
    uint64_t v14 = *v13;
    if (v13[1] != *v13)
    {
      uint64_t v15 = 0;
      unsigned int v16 = 0;
      do
      {
        if (TIInputManager::apply_case_changes((TIInputManager *)a1, v14 + 1000 * v15, a3, v8, a5, a1[691], v12, a6))
        {
          ++v16;
          uint64_t v17 = (uint64_t *)v13[1];
        }
        else
        {
          uint64_t v18 = a5;
          if (a6)
          {
            float v19 = (KB::Candidate *)(*v13 + 1000 * v15);
            KB::Candidate::capitalized_string(v19, (uint64_t)v36);
            uint64_t v20 = (const char *)v38;
            if (!v38) {
              uint64_t v20 = (const char *)v39;
            }
            if (v36[0]) {
              uint64_t v21 = v20;
            }
            else {
              uint64_t v21 = "";
            }
            KB::Candidate::token_ids_as_string(v19, (uint64_t)v32);
            uint64_t v23 = (const char *)v34;
            if (!v34) {
              uint64_t v23 = (const char *)&v35;
            }
            if (v32[0]) {
              uint64_t v24 = v23;
            }
            else {
              uint64_t v24 = "";
            }
            KB::append_format(a6, (__CFString *)"[%s] {%s} removed by %s\n", v22, v21, v24, "apply_case_changes");
            if (v34 && v33 == 1) {
              free(v34);
            }
            if (v38 && v37 == 1) {
              free(v38);
            }
          }
          int v25 = (uint64_t *)v13[1];
          uint64_t v17 = (uint64_t *)(*v13 + 1000 * v15);
          unint64_t v26 = v17 + 125;
          if (v17 + 125 != v25)
          {
            do
            {
              uint64_t v27 = v17;
              v17 += 125;
            }
            while (KB::Candidate::operator=(v27, v17) + 250 != v25);
            unint64_t v26 = (uint64_t *)v13[1];
          }
          a5 = v18;
          while (v26 != v17)
            KB::Candidate::~Candidate((KB::Candidate *)(v26 - 125));
          v13[1] = (uint64_t)v17;
          std::vector<unsigned int>::size_type v8 = v29;
          unint64_t v12 = v30;
        }
        uint64_t v15 = v16;
        uint64_t v14 = *v13;
      }
      while (0x1CAC083126E978D5 * (((uint64_t)v17 - *v13) >> 3) > (unint64_t)v16);
    }
    uint64_t v11 = v28 + 1;
  }
  while (v28 != 3);
}

void TIInputManager::apply_apostrophe_changes(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, __CFString *a4)
{
  v38[2] = *MEMORY[0x1E4F143B8];
  if (KB::String::contains(a3, 0x2019u))
  {
    uint64_t v6 = 0;
    v25[0] = a2;
    v25[1] = (char *)a2 + 24;
    unsigned __int16 v25[2] = (char *)a2 + 48;
    void v25[3] = (char *)a2 + 72;
    do
    {
      uint64_t v24 = v6;
      char v7 = (KB::Candidate **)v25[v6];
      std::vector<unsigned int>::size_type v8 = *v7;
      uint64_t v9 = v7[1];
      while (v8 != v9)
      {
        if (*(void *)v8)
        {
          char v10 = 0;
          uint64_t v11 = (KB::Word *)*((void *)v8 + 1);
          unint64_t v12 = (KB::Word *)((char *)v11 + 240 * *(void *)v8);
          do
          {
            while (1)
            {
              uint64_t v13 = (unsigned char *)*((void *)v11 + 1);
              if (!v13) {
                uint64_t v13 = (char *)v11 + 16;
              }
              uint64_t v14 = (unsigned char *)*(unsigned __int16 *)v11;
              if (*(_WORD *)v11)
              {
                uint64_t v15 = *(unsigned __int16 *)v11;
                unsigned int v16 = v13;
                while (*v16 != 39)
                {
                  ++v16;
                  if (!--v15)
                  {
                    unsigned int v16 = &v14[(void)v13];
                    break;
                  }
                }
              }
              else
              {
                unsigned int v16 = v13;
              }
              if ((unsigned char *)(v16 - v13) == v14) {
                break;
              }
              KB::Word::capitalized_string(v11, (uint64_t)v31);
              __int16 v27 = 0;
              char v28 = 0;
              unsigned int v29 = "’";
              int v26 = 1048579;
              v30[1] = 0;
              KB::String::replace_char((KB::String *)v31, (const KB::String *)&v26, 39, (uint64_t)v35);
              if (v29 && v28 == 1) {
                free(v29);
              }
              if (v33 && v32 == 1) {
                free(v33);
              }
              if (a4)
              {
                KB::Candidate::capitalized_string(v8, (uint64_t)v31);
                uint64_t v17 = (const char *)v33;
                if (!v33) {
                  uint64_t v17 = (const char *)&v34;
                }
                if (v31[0]) {
                  uint64_t v18 = v17;
                }
                else {
                  uint64_t v18 = "";
                }
                KB::Word::capitalized_string(v11, (uint64_t)&v26);
                uint64_t v20 = (const char *)v29;
                if (!v29) {
                  uint64_t v20 = v30;
                }
                if ((_WORD)v26) {
                  uint64_t v21 = v20;
                }
                else {
                  uint64_t v21 = "";
                }
                uint64_t v22 = v37;
                if (!v37) {
                  uint64_t v22 = (const char *)v38;
                }
                if (v35[0]) {
                  uint64_t v23 = v22;
                }
                else {
                  uint64_t v23 = "";
                }
                KB::append_format(a4, (__CFString *)"[%s] converted [%s] to [%s] by %s\n", v19, v18, v21, v23, "apply_apostrophe_changes");
                if (v29 && v28 == 1) {
                  free(v29);
                }
                if (v33 && v32 == 1) {
                  free(v33);
                }
              }
              KB::String::operator=(v11, (KB::String *)v35);
              if (v37)
              {
                if (v36 == 1) {
                  free(v37);
                }
              }
              uint64_t v11 = (KB::Word *)((char *)v11 + 240);
              char v10 = 1;
              if (v11 == v12) {
                goto LABEL_52;
              }
            }
            uint64_t v11 = (KB::Word *)((char *)v11 + 240);
          }
          while (v11 != v12);
          if ((v10 & 1) == 0) {
            goto LABEL_53;
          }
LABEL_52:
          KB::Candidate::compute_string(v8);
        }
LABEL_53:
        std::vector<unsigned int>::size_type v8 = (KB::Candidate *)((char *)v8 + 1000);
      }
      uint64_t v6 = v24 + 1;
    }
    while (v24 != 3);
  }
}

void TIInputManager::apply_shortcut_conversions(TIInputManager *this, KB::CandidateCollection *a2, const KB::String *a3, __CFString *a4)
{
  uint64_t v6 = 0;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  v21[0] = a2;
  v21[1] = (char *)a2 + 24;
  v21[2] = (char *)a2 + 48;
  void v21[3] = (char *)a2 + 72;
  do
  {
    char v7 = (KB::Candidate **)v21[v6];
    uint64_t v9 = *v7;
    std::vector<unsigned int>::size_type v8 = v7[1];
    uint64_t v19 = v6;
    uint64_t v20 = v8;
    while (v9 != v8)
    {
      if (*(void *)v9)
      {
        char v10 = (const KB::String *)*((void *)v9 + 1);
        uint64_t v11 = 240 * *(void *)v9;
        do
        {
          if (*((unsigned char *)v10 + 106))
          {
            TIInputManager::conversion_for_shortcut(this, v10, (KB::Word *)v34);
            if (v34[0])
            {
              if (a4)
              {
                KB::Candidate::capitalized_string(v9, (uint64_t)v30);
                unint64_t v12 = (const char *)v32;
                if (!v32) {
                  unint64_t v12 = (const char *)&v33;
                }
                if (v30[0]) {
                  uint64_t v13 = v12;
                }
                else {
                  uint64_t v13 = "";
                }
                KB::Word::capitalized_string(v10, (uint64_t)v26);
                uint64_t v14 = (const char *)v28;
                if (!v28) {
                  uint64_t v14 = (const char *)&v29;
                }
                if (v26[0]) {
                  uint64_t v15 = v14;
                }
                else {
                  uint64_t v15 = "";
                }
                KB::Word::capitalized_string((KB::Word *)v34, (uint64_t)v22);
                uint64_t v17 = (const char *)v24;
                if (!v24) {
                  uint64_t v17 = (const char *)&v25;
                }
                if (v22[0]) {
                  uint64_t v18 = v17;
                }
                else {
                  uint64_t v18 = "";
                }
                KB::append_format(a4, (__CFString *)"[%s] converted [%s] to [%s] by %s\n", v16, v13, v15, v18, "apply_shortcut_conversions");
                if (v24 && v23 == 1) {
                  free(v24);
                }
                if (v28 && v27 == 1) {
                  free(v28);
                }
                if (v32)
                {
                  if (v31 == 1) {
                    free(v32);
                  }
                }
              }
              KB::String::operator=(v10, (KB::String *)v34);
              KB::Candidate::compute_string(v9);
            }
            KB::Word::~Word((KB::Word *)v34);
          }
          char v10 = (const KB::String *)((char *)v10 + 240);
          v11 -= 240;
        }
        while (v11);
      }
      uint64_t v9 = (KB::Candidate *)((char *)v9 + 1000);
      std::vector<unsigned int>::size_type v8 = v20;
    }
    uint64_t v6 = v19 + 1;
  }
  while (v19 != 3);
}

void TIInputManager::remove_text_replacement_from_top(TIInputManager *this, const KB::Candidate **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  if ((unint64_t)(0x1CAC083126E978D5 * ((a2[1] - v3) >> 3)) >= 2)
  {
    KB::Candidate::Candidate((KB::Candidate *)&v7, v3);
    if (v7)
    {
      uint64_t v5 = 240 * v7;
      uint64_t v6 = v8;
      while ((*(unsigned char *)(v6 + 106) & 1) == 0)
      {
        v6 += 240;
        v5 -= 240;
        if (!v5) {
          goto LABEL_10;
        }
      }
    }
    else
    {
      uint64_t v6 = v8;
    }
    if (v6 != v8 + 240 * v7)
    {
      KB::Candidate::operator=((uint64_t)*a2, (uint64_t)*a2 + 1000);
      KB::Candidate::operator=((uint64_t)*a2 + 1000, (uint64_t)&v7);
    }
LABEL_10:
    KB::Candidate::~Candidate((KB::Candidate *)&v7);
  }
}

void TIInputManager::conversion_for_shortcut(TIInputManager *this@<X0>, const KB::String *a2@<X1>, KB::Word *a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  char v4 = *(uint64_t **)(*(void *)(*((void *)this + 28) + 24) + 24);
  if (v4 && (uint64_t v5 = *v4) != 0 && *(unsigned __int16 *)a2 < 0x41u)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    KB::UserDictionary::conversions_for_shortcut(v5, a2, (uint64_t)&v7);
    if (v8 == v7)
    {
      *((_OWORD *)a3 + 13) = 0u;
      *((_OWORD *)a3 + 14) = 0u;
      *((_OWORD *)a3 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
      *((_OWORD *)a3 + 12) = 0u;
      *((_OWORD *)a3 + 9) = 0u;
      *((_OWORD *)a3 + 10) = 0u;
      *((_OWORD *)a3 + 7) = 0u;
      *((_OWORD *)a3 + 8) = 0u;
      *((_OWORD *)a3 + 5) = 0u;
      *((_OWORD *)a3 + 6) = 0u;
      *((_OWORD *)a3 + 3) = 0u;
      *((_OWORD *)a3 + 4) = 0u;
      *((_OWORD *)a3 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
      *((_OWORD *)a3 + 2) = 0u;
      *(_OWORD *)a3 = 0u;
      KB::Word::Word(a3);
    }
    else
    {
      KB::match_shortcut_conversion_case_with_input(a2, v7, (KB::String *)&v10);
      KB::Word::Word(a3, (const KB::String *)&v10, &kTITokenIDUNK, 0);
      if (v11 && BYTE6(v10) == 1) {
        free(v11);
      }
    }
    char v10 = &v7;
    std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)&v10);
  }
  else
  {
    *((_OWORD *)a3 + 13) = 0u;
    *((_OWORD *)a3 + 14) = 0u;
    *((_OWORD *)a3 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)a3 + 12) = 0u;
    *((_OWORD *)a3 + 9) = 0u;
    *((_OWORD *)a3 + 10) = 0u;
    *((_OWORD *)a3 + 7) = 0u;
    *((_OWORD *)a3 + 8) = 0u;
    *((_OWORD *)a3 + 5) = 0u;
    *((_OWORD *)a3 + 6) = 0u;
    *((_OWORD *)a3 + 3) = 0u;
    *((_OWORD *)a3 + 4) = 0u;
    *((_OWORD *)a3 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
    *((_OWORD *)a3 + 2) = 0u;
    *(_OWORD *)a3 = 0u;
    KB::Word::Word(a3);
  }
}

uint64_t TIInputManager::apply_case_changes(TIInputManager *a1, uint64_t a2, unsigned __int16 *a3, std::vector<unsigned int>::size_type a4, int a5, unsigned int a6, uint64_t *a7, __CFString *a8)
{
  void v198[2] = *MEMORY[0x1E4F143B8];
  TIInputManager::input_substring(a3, 0, a4, (uint64_t)v194);
  TIInputManager::input_flags_subvector(a4, a3, 0, &v185);
  std::vector<unsigned int>::pointer begin = v185.__begin_;
  uint64_t v183 = 0;
  v184 = 0;
  uint64_t v14 = a4;
  CFTypeRef v182 = 0;
  if (a4)
  {
    uint64_t v15 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(a4);
    CFTypeRef v182 = v15;
    v184 = &v15[4 * v16];
    memmove(v15, begin, 4 * a4);
    uint64_t v183 = &v15[4 * a4];
    if (4 * a4)
    {
      uint64_t v17 = 0;
      unsigned int v18 = *(_DWORD *)(a2 + 780);
      do
      {
        int v19 = *(_DWORD *)&v15[4 * v17];
        if (v19)
        {
          if (*(_DWORD *)&v15[4 * v17] & 0x10 | v18 & 1) {
            *(_DWORD *)&v15[4 * v17] = v19 & 0xFFFFFFFE;
          }
          v18 >>= 1;
        }
        ++v17;
      }
      while (a4 > (unint64_t)v17);
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  unsigned int v20 = v195;
  if (!v195)
  {
    KB::String::compute_length(v194);
    unsigned int v20 = v195;
  }
  unint64_t v171 = a1;
  int v163 = a5;
  if (v20 <= a4) {
    goto LABEL_28;
  }
  if (v20 || (KB::String::compute_length(v194), (unsigned int v20 = v195) != 0))
  {
    uint64_t v21 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v20);
    bzero(v21, 4 * v20);
    uint64_t v169 = (uint64_t)v21 + 4 * v20;
    if (a4) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v169 = 0;
    if (a4)
    {
LABEL_17:
      uint64_t v22 = 0;
      int v23 = 0;
      do
      {
        unint64_t v24 = 0;
        uint64_t v25 = (unsigned __int16 *)(*(void *)a3 + 40 * v22);
        unsigned int v26 = v25[2];
        int v27 = v23;
        if (v25[2]) {
          goto LABEL_22;
        }
LABEL_21:
        KB::String::compute_length(v25);
        unsigned int v26 = v25[2];
LABEL_22:
        while (v24 < v26)
        {
          *((_DWORD *)v21 + (v27 + v24++)) = *(_DWORD *)&v15[4 * v22];
          if (!v26) {
            goto LABEL_21;
          }
        }
        if (!v26)
        {
          KB::String::compute_length(v25);
          unsigned int v26 = v25[2];
        }
        int v23 = v27 + v26;
        ++v22;
      }
      while (v22 != v14);
    }
  }
  std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>((char *)&v182, (char *)v21, v169, (v169 - (uint64_t)v21) >> 2);
  if (v21) {
    operator delete(v21);
  }
LABEL_28:
  KB::word_ranges((KB *)v194, 0, (unint64_t **)&v180);
  unint64_t v28 = *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v29 = 0;
    float v30 = 0;
    unint64_t v31 = 0;
    uint64_t v32 = 0;
    unsigned int v33 = 0;
    do
    {
      if ((*(unsigned char *)(*(void *)(a2 + 8) + 240 * v32 + 135) & 4) == 0)
      {
        if ((unint64_t)v30 >= v31)
        {
          uint64_t v35 = v30 - v29;
          unint64_t v36 = v35 + 1;
          if ((unint64_t)(v35 + 1) >> 62) {
LABEL_307:
          }
            abort();
          if ((uint64_t)(v31 - (void)v29) >> 1 > v36) {
            unint64_t v36 = (uint64_t)(v31 - (void)v29) >> 1;
          }
          if (v31 - (unint64_t)v29 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v37 = v36;
          }
          if (v37) {
            unint64_t v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v37);
          }
          else {
            uint64_t v38 = 0;
          }
          char v39 = (unsigned int *)(v37 + 4 * v35);
          *char v39 = v33;
          uint64_t v34 = v39 + 1;
          while (v30 != v29)
          {
            unsigned int v40 = *--v30;
            *--char v39 = v40;
          }
          unint64_t v31 = v37 + 4 * v38;
          if (v29) {
            operator delete(v29);
          }
          uint64_t v29 = v39;
        }
        else
        {
          *float v30 = v33;
          uint64_t v34 = v30 + 1;
        }
        unint64_t v28 = *(void *)a2;
        float v30 = v34;
      }
      uint64_t v32 = ++v33;
    }
    while (v28 > v33);
    if ((a6 & 1) == 0 && v28)
    {
      float v41 = *(KB **)(a2 + 8);
      unint64_t v42 = (TIInputManager *)((char *)a1 + 120);
      uint64_t v43 = 240 * v28;
      do
      {
        if (*((_WORD *)v171 + 52))
        {
          if (*((void *)v171 + 14)) {
            uint64_t v44 = (const KB::String *)*((void *)v171 + 14);
          }
          else {
            uint64_t v44 = v42;
          }
        }
        else
        {
          uint64_t v44 = (const KB::String *)"";
        }
        KB::string_to_lowercase(v41, v44, (KB::String *)v189);
        KB::String::operator=(v41, (KB::String *)v189);
        if (v192) {
          BOOL v45 = v191 == 1;
        }
        else {
          BOOL v45 = 0;
        }
        if (v45) {
          free(v192);
        }
        float v41 = (KB *)((char *)v41 + 240);
        v43 -= 240;
      }
      while (v43);
      if (*(void *)a2)
      {
        uint64_t v46 = 240 * *(void *)a2;
        uint64_t v47 = (_DWORD *)(*(void *)(a2 + 8) + 104);
        do
        {
          void v47[4] = 0;
          *v47 &= ~1u;
          v47 += 60;
          v46 -= 240;
        }
        while (v46);
      }
    }
  }
  else
  {
    uint64_t v29 = 0;
    float v30 = 0;
  }
  float v48 = (char *)v180;
  if (v181 == v180) {
    goto LABEL_242;
  }
  uint64_t v49 = 0;
  unsigned int v50 = 0;
  uint64_t v158 = (v181 - (unsigned char *)v180) >> 3;
  uint64_t v159 = v30 - v29;
  __src = v29 + 1;
  int64x2_t v164 = vdupq_n_s64(2uLL);
  while (2)
  {
    float v170 = v30;
    float v51 = &v48[8 * v49];
    uint64_t v52 = *(unsigned int *)v51;
    unsigned int v53 = *((_DWORD *)v51 + 1);
    unsigned int v54 = v53 + v52;
    if (v197) {
      float v55 = v197;
    }
    else {
      float v55 = v198;
    }
    *(void *)uint64_t v186 = v55;
    int v56 = v194[0];
    *(_DWORD *)&v186[8] = 0;
    *(void *)&v186[12] = v194[0];
    KB::String::iterator::initialize((uint64_t *)v186);
    long long v187 = *(_OWORD *)v186;
    v188[0] = *(void *)&v186[16];
    std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)&v187, (int)v52);
    *(void *)&v176.var0.var0.var0 = v55;
    *(_DWORD *)&v176.var0.var1.var1[6] = 0;
    *(_DWORD *)&v176.var0.var1.var1[10] = v56;
    LODWORD(v177) = 0;
    KB::String::iterator::initialize((uint64_t *)&v176);
    *(ByteString *)std::string __p = v176;
    long long v179 = v177;
    std::__advance[abi:nn180100]<KB::String::iterator>((KB::String::iterator *)__p, (int)v54);
    KB::String::String((KB::String *)v189, (const KB::String::iterator *)&v187, (const KB::String::iterator *)__p);
    __p[1] = 0;
    long long v179 = 0;
    __p[0] = 0;
    if (!v53) {
      goto LABEL_126;
    }
    unsigned int v167 = v50;
    float v57 = (char *)v182 + 4 * v52;
    int64_t v58 = (unsigned char *)v182 + 4 * v54 - v57;
    if (v58 < 0) {
      goto LABEL_307;
    }
    uint64_t v59 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v58 >> 2);
    __p[0] = v59;
    __p[1] = v59;
    long long v179 = &v59[4 * v60];
    memmove(v59, v57, v58);
    __p[1] = &v59[4 * (v58 >> 2)];
    if (__p[0] == __p[1])
    {
LABEL_126:
      float v30 = v29;
      if (v29 != v170)
      {
        uint64_t v84 = v29 + 1;
        size_t v85 = (char *)v170 - (char *)__src;
        if (v170 == __src) {
          goto LABEL_129;
        }
        goto LABEL_128;
      }
      goto LABEL_130;
    }
    BOOL has_lowercase_characters = KB::string_has_lowercase_characters((KB *)v189, v61);
    unsigned int v64 = KB::count_uppercase_letters((KB *)v189, v63);
    int64_t v66 = (char *)__p[1] - (char *)__p[0];
    if (__p[1] == __p[0])
    {
      int v68 = 0;
    }
    else
    {
      uint64_t v67 = 0;
      int v68 = 0;
      do
      {
        v68 |= (v67 != 0) & *((_DWORD *)__p[0] + v67);
        ++v67;
      }
      while (v66 >> 2 > (unint64_t)v67);
    }
    int v69 = has_lowercase_characters & (v68 | (v64 > 1));
    if ((v69 & 1) == 0)
    {
      if (has_lowercase_characters)
      {
        int v70 = 4;
        int v166 = 1;
        if (v64 > 1 || (((unint64_t)v66 > 4) & v68) != 0) {
          goto LABEL_85;
        }
        int v83 = *(_DWORD *)__p[0];
      }
      else
      {
        int v83 = *(_DWORD *)__p[0];
        if (((v163 == 4) & ((*(_DWORD *)__p[0] & 2u) >> 1)) != 0) {
          int v70 = 2;
        }
        else {
          int v70 = 4;
        }
        if (((v163 == 4) & ((*(_DWORD *)__p[0] & 2u) >> 1)) != 0 || v64 > 1) {
          goto LABEL_125;
        }
        if ((((unint64_t)v66 > 4) & v68) != 0) {
          goto LABEL_147;
        }
      }
      if ((v83 & 1) == 0)
      {
        int v70 = 0;
        goto LABEL_124;
      }
      int v70 = 3;
      if (v163 != 5 || v66 != 4)
      {
LABEL_124:
        if ((v83 & 2) != 0)
        {
LABEL_140:
          if (v29 != v170)
          {
            uint64_t v89 = *(void *)(a2 + 8);
            if ((*(unsigned char *)(v89 + 240 * *v29 + 104) & 0x20) == 0) {
              TIInputManager::capitalize_first_letter(v171, (KB::Word *)(v89 + 240 * *v29), 0);
            }
            uint64_t v84 = v29 + 1;
            size_t v85 = (char *)v170 - (char *)__src;
            if (v170 != __src) {
              goto LABEL_128;
            }
            goto LABEL_129;
          }
          if (!a8) {
            goto LABEL_274;
          }
          long long v148 = (const char *)v197;
          if (!v197) {
            long long v148 = (const char *)v198;
          }
          if (v194[0]) {
            v149 = v148;
          }
          else {
            v149 = "";
          }
          KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v187);
          id v151 = (const char *)*((void *)&v187 + 1);
          if (!*((void *)&v187 + 1)) {
            id v151 = (const char *)v188;
          }
          if ((_WORD)v187) {
            CFTypeID v152 = v151;
          }
          else {
            CFTypeID v152 = "";
          }
          KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAutoshift and candidate [%s] was not accepted; will be filtered out\n",
            v150,
            v149,
            v152);
LABEL_271:
          if (*((void *)&v187 + 1) && BYTE6(v187) == 1) {
            free(*((void **)&v187 + 1));
          }
          goto LABEL_274;
        }
LABEL_125:
        int v166 = 1;
        switch(v70)
        {
          case 0:
            goto LABEL_126;
          case 1:
            goto LABEL_140;
          case 2:
            if (v29 != v170)
            {
              unsigned int v90 = *v29;
              uint64_t v91 = *(void *)(a2 + 8);
              uint64_t v92 = v91 + 240 * *v29;
              unsigned int v93 = *(unsigned __int16 *)(v92 + 4);
              if (!*(_WORD *)(v92 + 4))
              {
                KB::String::compute_length((unsigned __int16 *)(v91 + 240 * v90));
                unsigned int v93 = *(unsigned __int16 *)(v92 + 4);
              }
              v186[0] = 1;
              std::vector<BOOL>::vector(&v187, v93, v186);
              if (*((void *)&v187 + 1) >= 0x20uLL) {
                uint64_t v94 = 32;
              }
              else {
                uint64_t v94 = *((void *)&v187 + 1);
              }
              if (v94)
              {
                unint64_t v95 = 0;
                uint64_t v96 = ((_BYTE)v94 + 1) & 0x7E;
                int64x2_t v97 = 0uLL;
                uint64x2_t v98 = (uint64x2_t)vdupq_n_s64(v94 - 1);
                int64x2_t v99 = (int64x2_t)xmmword_1E4154BE0;
                int32x2_t v100 = (int32x2_t)0x100000000;
                do
                {
                  int8x8_t v101 = *(int8x8_t *)v97.i8;
                  int8x8_t v102 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v98, (uint64x2_t)v99));
                  unint64_t v103 = v95 >> 6;
                  if (v102.i8[0]) {
                    v97.i64[0] = *(void *)(v187 + 8 * v103);
                  }
                  if (v102.i8[4]) {
                    v97.i64[1] = *(void *)(v187 + 8 * v103);
                  }
                  int64x2_t v97 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v97, (int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(1uLL), (uint64x2_t)v99)));
                  *(int8x8_t *)v97.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v100), (int8x8_t)vmovn_s64(v97)), v101);
                  v95 += 2;
                  int64x2_t v99 = vaddq_s64(v99, vdupq_n_s64(2uLL));
                  int32x2_t v100 = vadd_s32(v100, (int32x2_t)0x200000002);
                }
                while (v96 != v95);
                int8x8_t v104 = vbsl_s8(v102, *(int8x8_t *)v97.i8, v101);
                __int32 v105 = v104.i32[0] | v104.i32[1];
              }
              else
              {
                __int32 v105 = 0;
              }
              uint64_t v126 = v91 + 240 * v90;
              *(_DWORD *)(v126 + 120) = v105;
              *(_DWORD *)(v126 + 104) = *(_DWORD *)(v126 + 104) & 0xFFFFFFFE | (v105 == 1);
              size_t v85 = (char *)v170 - (char *)__src;
              if (v170 != __src) {
                memmove(v29, __src, (char *)v170 - (char *)__src);
              }
              if ((void)v187) {
                operator delete((void *)v187);
              }
LABEL_129:
              float v30 = (unsigned int *)((char *)v29 + v85);
              goto LABEL_130;
            }
            if (!a8) {
              goto LABEL_274;
            }
            CFTypeID v153 = (const char *)v197;
            if (!v197) {
              CFTypeID v153 = (const char *)v198;
            }
            if (v194[0]) {
              long long v154 = v153;
            }
            else {
              long long v154 = "";
            }
            KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v187);
            long long v156 = (const char *)*((void *)&v187 + 1);
            if (!*((void *)&v187 + 1)) {
              long long v156 = (const char *)v188;
            }
            if ((_WORD)v187) {
              long long v157 = v156;
            }
            else {
              long long v157 = "";
            }
            KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAutoshiftAllCharacters and candidate [%s] was not accepted; will be filtered out\n",
              v155,
              v154,
              v157);
            break;
          case 3:
            uint64_t v106 = *((void *)v171 + 68);
            if (v106) {
              int v107 = (*(uint64_t (**)(uint64_t))(*(void *)v106 + 40))(v106);
            }
            else {
              int v107 = 1;
            }
            float v30 = v170;
            if (!v107 || v159 != v158 || v159 - v49 != v170 - v29) {
              goto LABEL_227;
            }
            uint64_t v123 = *(void *)(a2 + 8) + 240 * *v29;
            if (*(unsigned char *)(v123 + 104)) {
              goto LABEL_205;
            }
            if (!*a7) {
              goto LABEL_201;
            }
            KB::DictionaryContainer::lookup(*a7, &v187);
            uint64_t v125 = *((void *)&v187 + 1);
            uint64_t v124 = v187;
            v172[0] = MEMORY[0x1E4F143A8];
            v172[1] = 0x40000000;
            uint64_t v173 = ___ZNK14TIInputManager18apply_case_changesERN2KB9CandidateERKNSt3__16vectorINS0_5InputENS3_9allocatorIS5_EEEEj14TIShiftContextbRKN3WTF6RefPtrINS0_19DictionaryContainerEEEP10__CFString_block_invoke;
            long long v174 = &__block_descriptor_tmp_10;
            uint64_t v175 = v123;
            while (2)
            {
              if (v124 == v125)
              {
                *(void *)uint64_t v186 = &v187;
                std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v186);
LABEL_201:
                CFTypeID v127 = v192;
                if (!v192) {
                  CFTypeID v127 = v193;
                }
                *(void *)uint64_t v186 = v127;
                *(_DWORD *)&v186[8] = 0;
                *(void *)&v186[12] = v189[0];
                KB::String::iterator::initialize((uint64_t *)v186);
                KB::String::String((uint64_t)&v187, *(unsigned int *)&v186[16]);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)v123, v186);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)&v187, &v176);
              }
              else
              {
                if ((((uint64_t (*)(void *, uint64_t))v173)(v172, v124) & 1) == 0)
                {
                  v124 += 240;
                  continue;
                }
                *(void *)uint64_t v186 = &v187;
                std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)v186);
LABEL_205:
                int v128 = *(unsigned __int16 *)(v123 + 4);
                if (!*(_WORD *)(v123 + 4))
                {
                  KB::String::compute_length((unsigned __int16 *)v123);
                  int v128 = *(unsigned __int16 *)(v123 + 4);
                }
                int v129 = v190;
                if (!v190)
                {
                  KB::String::compute_length(v189);
                  int v129 = v190;
                }
                int v130 = v129 - 1;
                long long v131 = v192;
                if (!v192) {
                  long long v131 = v193;
                }
                *(void *)uint64_t v186 = v131;
                *(_DWORD *)&v186[8] = 0;
                *(void *)&v186[12] = v189[0];
                KB::String::iterator::initialize((uint64_t *)v186);
                KB::String::String((uint64_t)&v187, *(unsigned int *)&v186[16]);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)v123, v186);
                KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)&v187, &v176);
                if (v130 <= v128 && KB::ByteString::starts_with((KB::ByteString *)v186, &v176))
                {
                  TIInputManager::capitalize_first_letter(v171, (KB::Word *)v123, 1);
                  if (v170 != __src) {
                    memmove(v29, __src, (char *)v170 - (char *)__src);
                  }
                  int v132 = 0;
                  float v30 = v170 - 1;
LABEL_217:
                  unsigned int v50 = v167;
                  if (v176.var0.var0.var0 >= 0xFu && v176.var0.var0.var1) {
                    MEMORY[0x1E4E7BC00](v176.var0.var0.var1, 0x1000C8077774924);
                  }
                  if (*(unsigned __int16 *)v186 >= 0xFu && *(void *)&v186[8]) {
                    MEMORY[0x1E4E7BC00](*(void *)&v186[8], 0x1000C8077774924);
                  }
                  if (*((void *)&v187 + 1) && BYTE6(v187) == 1) {
                    free(*((void **)&v187 + 1));
                  }
                  if (!v132) {
                    goto LABEL_130;
                  }
LABEL_227:
                  if (a8)
                  {
                    int64_t v133 = (const char *)v197;
                    if (!v197) {
                      int64_t v133 = (const char *)v198;
                    }
                    if (v194[0]) {
                      uint64_t v134 = v133;
                    }
                    else {
                      uint64_t v134 = "";
                    }
                    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v187);
                    uint64_t v136 = (const char *)*((void *)&v187 + 1);
                    if (!*((void *)&v187 + 1)) {
                      uint64_t v136 = (const char *)v188;
                    }
                    if ((_WORD)v187) {
                      long long v137 = v136;
                    }
                    else {
                      long long v137 = "";
                    }
                    KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeExplicitShift and candidate [%s] was not accepted; falling through to WordCapitalizationType"
                                    "AllCaps/WordCapitalizationTypeMixedCase\n",
                      v135,
                      v134,
                      v137);
                    if (*((void *)&v187 + 1) && BYTE6(v187) == 1) {
                      free(*((void **)&v187 + 1));
                    }
                  }
                  int v166 = 0;
                  int v70 = 3;
                  float v170 = v30;
                  goto LABEL_85;
                }
              }
              break;
            }
            int v132 = 1;
            goto LABEL_217;
          case 4:
            goto LABEL_85;
          default:
            float v30 = v170;
            goto LABEL_130;
        }
        goto LABEL_271;
      }
LABEL_147:
      int v70 = 4;
      int v166 = 1;
      goto LABEL_85;
    }
    int v166 = 0;
    int v70 = 5;
LABEL_85:
    unint64_t v71 = v170 - v29;
    if (v170 == v29)
    {
      unint64_t v72 = 0;
      goto LABEL_111;
    }
    int v162 = v70;
    unint64_t v72 = 0;
    unsigned int v73 = 1;
    while (1)
    {
      uint64_t v74 = v29[v72];
      uint64_t v75 = *(void *)(a2 + 8);
      uint64_t v76 = v75 + 240 * v74;
      if (!v69) {
        break;
      }
      if ((*(uint64_t (**)(TIInputManager *, uint64_t, uint64_t, unsigned __int16 *, void **, void))(*(void *)v171 + 40))(v171, a2, v75 + 240 * v74, v189, __p, a6))
      {
        if ((*(unsigned char *)__p[0] & 1) == 0 || (*(unsigned char *)(v75 + 240 * v74 + 104) & 0x20) != 0) {
          goto LABEL_111;
        }
        char v86 = v171;
        id v87 = (KB::Word *)(v75 + 240 * v74);
        int v88 = 0;
LABEL_199:
        TIInputManager::capitalize_first_letter(v86, v87, v88);
        goto LABEL_111;
      }
LABEL_104:
      unint64_t v72 = v73;
      if (v71 <= v73++) {
        goto LABEL_111;
      }
    }
    if (*(void *)a2 - 1 == v74)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)(v75 + 240 * v74), &v187);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)v189, v186);
      BOOL v77 = KB::ByteString::starts_with((KB::ByteString *)&v187, (const ByteString *)v186);
      if (*(unsigned __int16 *)v186 >= 0xFu && *(void *)&v186[8]) {
        MEMORY[0x1E4E7BC00](*(void *)&v186[8], 0x1000C8077774924);
      }
      if ((unsigned __int16)v187 >= 0xFu && *((void *)&v187 + 1)) {
        MEMORY[0x1E4E7BC00](*((void *)&v187 + 1), 0x1000C8077774924);
      }
      if (!v77) {
        goto LABEL_104;
      }
    }
    else if (KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(void *)(*((void *)v171 + 28) + 8) + 72), (_LXLexicon *)(v75 + 240 * v74), (const KB::String *)v189, v65))
    {
      goto LABEL_104;
    }
    *((void *)&v187 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 1;
    *(void *)&long long v187 = &unk_1F3F77D18;
    int v78 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v187, (const KB::String *)(v75 + 240 * v74), (const KB::String *)v189, 0, 0);
    if ((v166 & v78) == 1)
    {
      unsigned int v80 = KB::count_word_medial_punctuation((KB *)(v75 + 240 * v74), v79);
      if (v80 <= KB::count_word_medial_punctuation((KB *)v189, v81)) {
        goto LABEL_167;
      }
      goto LABEL_104;
    }
    if ((v78 & 1) == 0) {
      goto LABEL_104;
    }
    if (v162 == 3)
    {
      char v86 = v171;
      id v87 = (KB::Word *)(v75 + 240 * v74);
      int v88 = 1;
      goto LABEL_199;
    }
    if (v162 != 4) {
      goto LABEL_111;
    }
LABEL_167:
    unsigned int v108 = *(unsigned __int16 *)(v76 + 4);
    if (!*(_WORD *)(v76 + 4))
    {
      KB::String::compute_length((unsigned __int16 *)(v75 + 240 * v74));
      unsigned int v108 = *(unsigned __int16 *)(v76 + 4);
    }
    v186[0] = 1;
    std::vector<BOOL>::vector(&v187, v108, v186);
    uint64_t v109 = (void *)v187;
    if (*((void *)&v187 + 1) >= 0x20uLL) {
      uint64_t v110 = 32;
    }
    else {
      uint64_t v110 = *((void *)&v187 + 1);
    }
    if (v110)
    {
      unint64_t v111 = 0;
      uint64_t v112 = ((_BYTE)v110 + 1) & 0x7E;
      int64x2_t v113 = 0uLL;
      uint64x2_t v114 = (uint64x2_t)vdupq_n_s64(v110 - 1);
      int64x2_t v115 = (int64x2_t)xmmword_1E4154BE0;
      int32x2_t v116 = (int32x2_t)0x100000000;
      do
      {
        int8x8_t v117 = *(int8x8_t *)v113.i8;
        int8x8_t v118 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v114, (uint64x2_t)v115));
        unint64_t v119 = v111 >> 6;
        if (v118.i8[0]) {
          v113.i64[0] = *(void *)(v187 + 8 * v119);
        }
        if (v118.i8[4]) {
          v113.i64[1] = *(void *)(v187 + 8 * v119);
        }
        int64x2_t v113 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v113, (int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(1uLL), (uint64x2_t)v115)));
        *(int8x8_t *)v113.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v116), (int8x8_t)vmovn_s64(v113)), v117);
        v111 += 2;
        int64x2_t v115 = vaddq_s64(v115, v164);
        int32x2_t v116 = vadd_s32(v116, (int32x2_t)0x200000002);
      }
      while (v112 != v111);
      int8x8_t v120 = vbsl_s8(v118, *(int8x8_t *)v113.i8, v117);
      __int32 v121 = v120.i32[0] | v120.i32[1];
    }
    else
    {
      __int32 v121 = 0;
    }
    uint64_t v122 = v75 + 240 * v74;
    *(_DWORD *)(v122 + 120) = v121;
    *(_DWORD *)(v122 + 104) = *(_DWORD *)(v122 + 104) & 0xFFFFFFFE | (v121 == 1);
    if (v109) {
      operator delete(v109);
    }
LABEL_111:
    if (v71 > v72)
    {
      uint64_t v84 = &__src[v72];
      if (v29 != v84)
      {
        size_t v85 = (char *)v170 - (char *)v84;
        unsigned int v50 = v167;
        if (v170 == v84) {
          goto LABEL_129;
        }
LABEL_128:
        memmove(v29, v84, v85);
        goto LABEL_129;
      }
      float v30 = v170;
      unsigned int v50 = v167;
LABEL_130:
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v192 && v191 == 1) {
        free(v192);
      }
      float v48 = (char *)v180;
      uint64_t v49 = ++v50;
      if (v50 >= (unint64_t)((v181 - (unsigned char *)v180) >> 3))
      {
LABEL_242:
        int v138 = v163;
        if (v29 != v30)
        {
          long long v139 = v29;
          do
          {
            unsigned int v140 = *v139++;
            TIInputManager::apply_shift_context_to_prediction(v171, v138, (KB::Word *)(*(void *)(a2 + 8) + 240 * v140));
            if (v138 == 2) {
              int v138 = 0;
            }
          }
          while (v139 != v30);
        }
        KB::Candidate::commit_custom_capitalization((KB::Candidate *)a2);
        uint64_t v141 = 1;
        if (v29) {
          goto LABEL_248;
        }
        goto LABEL_249;
      }
      continue;
    }
    break;
  }
  if (a8)
  {
    int64_t v143 = (const char *)v197;
    if (!v197) {
      int64_t v143 = (const char *)v198;
    }
    if (v194[0]) {
      CFTypeID v144 = v143;
    }
    else {
      CFTypeID v144 = "";
    }
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)&v187);
    id v146 = (const char *)*((void *)&v187 + 1);
    if (!*((void *)&v187 + 1)) {
      id v146 = (const char *)v188;
    }
    if ((_WORD)v187) {
      v147 = v146;
    }
    else {
      v147 = "";
    }
    KB::append_format(a8, (__CFString *)"input [%s] was considered to have capitalization type WordCapitalizationTypeAllCaps/WordCapitalizationTypeMixedCase and candidate [%s] was not accepted; will be filtered out\n",
      v145,
      v144,
      v147);
    goto LABEL_271;
  }
LABEL_274:
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v192 && v191 == 1) {
    free(v192);
  }
  uint64_t v141 = 0;
  if (v29) {
LABEL_248:
  }
    operator delete(v29);
LABEL_249:
  if (v180) {
    operator delete(v180);
  }
  if (v182) {
    operator delete(v182);
  }
  if (v185.__begin_) {
    operator delete(v185.__begin_);
  }
  if (v197 && v196 == 1) {
    free(v197);
  }
  return v141;
}

void TIInputManager::input_flags_subvector(std::vector<unsigned int>::size_type __n@<X2>, void *a2@<X0>, unsigned int a3@<W1>, std::vector<unsigned int> *a4@<X8>)
{
  int v4 = __n;
  a4->__begin_ = 0;
  a4->__end_ = 0;
  a4->__end_cap_.__value_ = 0;
  std::vector<unsigned int>::reserve(a4, __n);
  uint64_t v8 = v4 + a3;
  if (v8 > a3)
  {
    std::vector<std::string>::pointer end = (char *)a4->__end_;
    value = a4->__end_cap_.__value_;
    uint64_t v11 = a3;
    std::vector<unsigned int>::pointer begin = a4->__begin_;
    do
    {
      unsigned int v13 = *(_DWORD *)(*a2 + 40 * v11 + 32);
      if (end >= (char *)value)
      {
        uint64_t v15 = (end - (char *)begin) >> 2;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 62) {
          abort();
        }
        if (((char *)value - (char *)begin) >> 1 > v16) {
          unint64_t v16 = ((char *)value - (char *)begin) >> 1;
        }
        if ((unint64_t)((char *)value - (char *)begin) >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v17 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v17) {
          unint64_t v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v17);
        }
        else {
          uint64_t v18 = 0;
        }
        int v19 = (unsigned int *)(v17 + 4 * v15);
        *int v19 = v13;
        uint64_t v14 = v19 + 1;
        while (end != (char *)begin)
        {
          unsigned int v20 = *((_DWORD *)end - 1);
          end -= 4;
          *--int v19 = v20;
        }
        value = (unsigned int *)(v17 + 4 * v18);
        a4->__begin_ = v19;
        a4->__end_ = v14;
        a4->__end_cap_.__value_ = value;
        if (begin) {
          operator delete(begin);
        }
        std::vector<unsigned int>::pointer begin = v19;
      }
      else
      {
        *(_DWORD *)std::vector<std::string>::pointer end = v13;
        uint64_t v14 = (unsigned int *)(end + 4);
      }
      a4->__end_ = v14;
      ++v11;
      std::vector<std::string>::pointer end = (char *)v14;
    }
    while (v11 != v8);
  }
}

char *std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 2)
  {
    if (v9)
    {
      *((void *)result + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 62) {
      abort();
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    __n128 result = std::vector<unsigned int>::__vallocate[abi:nn180100](v7, v11);
    unsigned int v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      int v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 2;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  unint64_t v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    __n128 result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    int v19 = v16;
LABEL_18:
    __n128 result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

BOOL ___ZNK14TIInputManager18apply_case_changesERN2KB9CandidateERKNSt3__16vectorINS0_5InputENS3_9allocatorIS5_EEEEj14TIShiftContextbRKN3WTF6RefPtrINS0_19DictionaryContainerEEEP10__CFString_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(float *)(a2 + 48) > 0.0
      && (*(unsigned char *)(a2 + 104) & 1) != 0
      && KB::String::equal((KB::String *)a2, *(const KB::String **)(a1 + 32), 0);
}

uint64_t TIInputManager::capitalize_first_letter(TIInputManager *this, KB::Word *a2, int a3)
{
  uint64_t v3 = *((void *)this + 68);
  if (v3) {
    return (*(uint64_t (**)(uint64_t, KB::Word *))(*(void *)v3 + 72))(v3, a2);
  }
  else {
    return KB::Word::capitalize_first_letter(a2, a3);
  }
}

void *std::vector<BOOL>::vector(void *a1, unint64_t a2, unsigned __int8 *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v6 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(((a2 - 1) >> 6) + 1);
    *a1 = v6;
    a1[2] = v7;
    int v8 = *a3;
    a1[1] = a2;
    if (a2 >= 0x41) {
      unint64_t v9 = (a2 - 1) >> 6;
    }
    else {
      unint64_t v9 = 0;
    }
    v6[v9] = 0;
    unint64_t v11 = v6;
    int v12 = 0;
    if (v8) {
      std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(&v11, a2);
    }
    else {
      std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>((uint64_t)&v11, a2);
    }
  }
  return a1;
}

void TIInputManager::apply_shift_context_to_prediction(TIInputManager *a1, int a2, KB::Word *a3)
{
  if ((a2 - 2) < 2)
  {
    if ((*((unsigned char *)a3 + 104) & 0x20) != 0) {
      return;
    }
  }
  else
  {
    if ((a2 - 4) < 2)
    {
      unsigned int v4 = *((unsigned __int16 *)a3 + 2);
      if (!*((_WORD *)a3 + 2))
      {
        KB::String::compute_length((unsigned __int16 *)a3);
        unsigned int v4 = *((unsigned __int16 *)a3 + 2);
      }
      unsigned __int8 v20 = 1;
      std::vector<BOOL>::vector(&v21, v4, &v20);
      uint64_t v5 = v21;
      if (v22 >= 0x20) {
        uint64_t v6 = 32;
      }
      else {
        uint64_t v6 = v22;
      }
      if (v6)
      {
        unint64_t v7 = 0;
        int32x2_t v8 = (int32x2_t)0x100000000;
        uint64_t v9 = ((_BYTE)v6 + 1) & 0x7E;
        int64x2_t v10 = 0uLL;
        uint64x2_t v11 = (uint64x2_t)vdupq_n_s64(v6 - 1);
        uint64x2_t v12 = (uint64x2_t)vdupq_n_s64(1uLL);
        int64x2_t v13 = (int64x2_t)xmmword_1E4154BE0;
        int64x2_t v14 = vdupq_n_s64(2uLL);
        do
        {
          int8x8_t v15 = *(int8x8_t *)v10.i8;
          int8x8_t v16 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v11, (uint64x2_t)v13));
          unint64_t v17 = v7 >> 6;
          if (v16.i8[0]) {
            v10.i64[0] = *((void *)v21 + v17);
          }
          if (v16.i8[4]) {
            v10.i64[1] = *((void *)v21 + v17);
          }
          int64x2_t v10 = vceqzq_s64((int64x2_t)vandq_s8((int8x16_t)v10, (int8x16_t)vshlq_u64(v12, (uint64x2_t)v13)));
          *(int8x8_t *)v10.i8 = vorr_s8(vbic_s8((int8x8_t)vshl_u32((uint32x2_t)0x100000001, (uint32x2_t)v8), (int8x8_t)vmovn_s64(v10)), v15);
          v7 += 2;
          int64x2_t v13 = vaddq_s64(v13, v14);
          int32x2_t v8 = vadd_s32(v8, (int32x2_t)0x200000002);
        }
        while (v9 != v7);
        int8x8_t v18 = vbsl_s8(v16, *(int8x8_t *)v10.i8, v15);
        __int32 v19 = v18.i32[0] | v18.i32[1];
      }
      else
      {
        __int32 v19 = 0;
      }
      *((_DWORD *)a3 + 30) = v19;
      *((_DWORD *)a3 + 26) = *((_DWORD *)a3 + 26) & 0xFFFFFFFE | (v19 == 1);
      if (v5) {
        operator delete(v5);
      }
      return;
    }
    if (a2 != 1) {
      return;
    }
  }

  TIInputManager::capitalize_first_letter(a1, a3, 0);
}

void *std::__fill_n[abi:nn180100]<true,std::vector<BOOL>>(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  uint64_t v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *__n128 result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    __n128 result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int32x2_t v8 = &v5[v7];
    *uint64_t v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:nn180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int32x2_t v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

BOOL ___ZN14TIInputManager34apply_case_insensitive_constraintsERN2KB19CandidateCollectionENS0_10LookupTypeEP10__CFString_block_invoke(uint64_t a1, KB::Candidate *a2)
{
  _OWORD v19[2] = *MEMORY[0x1E4F143B8];
  BOOL v4 = TIInputManager::matches_case_insensitive_constraints(*(void *)(a1 + 32), (uint64_t)a2, (_LXLexicon *)(a1 + 40), (_LXLexicon *)(a1 + 72), (unsigned __int16 *)(a1 + 104), *(_DWORD *)(a1 + 144));
  if (!v4)
  {
    uint64_t v5 = *(__CFString **)(a1 + 136);
    if (v5)
    {
      KB::Candidate::capitalized_string(a2, (uint64_t)v16);
      unint64_t v6 = (const char *)v18;
      if (!v18) {
        unint64_t v6 = (const char *)v19;
      }
      if (v16[0]) {
        unint64_t v7 = v6;
      }
      else {
        unint64_t v7 = "";
      }
      KB::Candidate::token_ids_as_string(a2, (uint64_t)v12);
      uint64_t v9 = (const char *)v14;
      if (!v14) {
        uint64_t v9 = (const char *)&v15;
      }
      if (v12[0]) {
        int64x2_t v10 = v9;
      }
      else {
        int64x2_t v10 = "";
      }
      KB::append_format(v5, (__CFString *)"[%s] {%s} removed by %s\n", v8, v7, v10, "apply_case_insensitive_constraints");
      if (v14 && v13 == 1) {
        free(v14);
      }
      if (v18 && v17 == 1) {
        free(v18);
      }
    }
  }
  return !v4;
}

void __destroy_helper_block_8_40c17_ZTSKN2KB6StringE72c17_ZTSKN2KB6StringE104c17_ZTSKN2KB6StringE(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 112);
  if (v2 && *(unsigned char *)(a1 + 110) == 1) {
    free(v2);
  }
  uint64_t v3 = *(void **)(a1 + 80);
  if (v3 && *(unsigned char *)(a1 + 78) == 1) {
    free(v3);
  }
  BOOL v4 = *(void **)(a1 + 48);
  if (v4 && *(unsigned char *)(a1 + 46) == 1)
  {
    free(v4);
  }
}

KB::String *__copy_helper_block_8_40c17_ZTSKN2KB6StringE72c17_ZTSKN2KB6StringE104c17_ZTSKN2KB6StringE(uint64_t a1, uint64_t a2)
{
  KB::String::String((KB::String *)(a1 + 40), (const KB::String *)(a2 + 40));
  KB::String::String((KB::String *)(a1 + 72), (const KB::String *)(a2 + 72));

  return KB::String::String((KB::String *)(a1 + 104), (const KB::String *)(a2 + 104));
}

BOOL TIInputManager::matches_case_insensitive_constraints(uint64_t a1, uint64_t a2, _LXLexicon *a3, _LXLexicon *a4, unsigned __int16 *a5, int a6)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)(a2 + 888)) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  uint64x2_t v12 = (KB::String *)(a2 + 888);
  if (!a6)
  {
    if (!*(_WORD *)v12) {
      KB::Candidate::compute_string((KB::Candidate *)a2);
    }
    if (*(unsigned char *)(a2 + 962) && *(_WORD *)a3)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*(void *)(a1 + 224) + 8) + 72), (_LXLexicon *)(a2 + 888), v34);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*(void *)(a1 + 224) + 8) + 72), a3, &v33);
      BOOL v24 = KB::ByteString::starts_with((KB::ByteString *)v34, &v33);
      if (v33.var0.var0.var0 >= 0xFu && v33.var0.var0.var1) {
        MEMORY[0x1E4E7BC00](v33.var0.var0.var1, 0x1000C8077774924);
      }
      if (v34[0] >= 0xFu && v36) {
        MEMORY[0x1E4E7BC00](v36, 0x1000C8077774924);
      }
      if (!v24) {
        return 0;
      }
    }
    else if (*(_WORD *)a4)
    {
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*(void *)(a1 + 224) + 8) + 72), (_LXLexicon *)(a2 + 888), v34);
      KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*(void *)(a1 + 224) + 8) + 72), a4, &v33);
      BOOL v25 = KB::ByteString::starts_with((KB::ByteString *)v34, &v33);
      if (v33.var0.var0.var0 >= 0xFu && v33.var0.var0.var1) {
        MEMORY[0x1E4E7BC00](v33.var0.var0.var1, 0x1000C8077774924);
      }
      if (v34[0] >= 0xFu && v36) {
        MEMORY[0x1E4E7BC00](v36, 0x1000C8077774924);
      }
      if (!v25) {
        return 0;
      }
    }
    if (*(unsigned char *)(a1 + 688))
    {
      unsigned int v26 = *(unsigned __int16 *)(a2 + 892);
      if (!*(_WORD *)(a2 + 892))
      {
        KB::String::compute_length((unsigned __int16 *)(a2 + 888));
        unsigned int v26 = *(unsigned __int16 *)(a2 + 892);
      }
      unsigned int v27 = a5[2];
      if (!a5[2])
      {
        KB::String::compute_length(a5);
        unsigned int v27 = a5[2];
      }
      if (v26 > v27) {
        return 0;
      }
    }
  }
  if (*(void *)a2)
  {
    uint64_t v13 = 240 * *(void *)a2 - 240;
    int64x2_t v14 = (uint64_t *)(*(void *)(a2 + 8) + 224);
    do
    {
      uint64_t v16 = *v14;
      v14 += 30;
      uint64_t v15 = v16;
      if (v16) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = v13 == 0;
      }
      v13 -= 240;
    }
    while (!v17);
    if (v15) {
      return 1;
    }
  }
  if (*(_WORD *)(a1 + 32))
  {
    KB::String::String((KB::String *)v34, (const KB::String *)(a1 + 32));
    if (KB::String::contains((KB::String *)v34, 0x2019u))
    {
      __int16 v29 = 0;
      char v30 = 0;
      unint64_t v31 = "'";
      int v28 = 1048577;
      char v32 = 0;
      KB::String::replace_char((KB::String *)v34, (const KB::String *)&v28, 8217, (uint64_t)&v33);
      KB::String::operator=((uint64_t)v34, (KB::String *)&v33);
      if (v33.var0.var0.var1 && v33.var0.var1.var1[4] == 1) {
        free(v33.var0.var0.var1);
      }
      if (v31 && v30 == 1) {
        free(v31);
      }
    }
    BOOL v18 = KB::String::equal((KB::String *)(a2 + 888), (const KB::String *)v34, 0);
    if (v36 && v35 == 1) {
      free(v36);
    }
    if (v18) {
      return 0;
    }
  }
  uint64_t v19 = *(void *)(*(void *)(a1 + 224) + 24);
  if (!KB::String::equal(v12, (const KB::String *)(v19 + 56), 0)) {
    return 1;
  }
  size_t v20 = *a5;
  if (v20 > *(unsigned __int16 *)(v19 + 56)) {
    return 0;
  }
  if (*(void *)(v19 + 64)) {
    uint64_t v21 = *(const char **)(v19 + 64);
  }
  else {
    uint64_t v21 = (const char *)(v19 + 72);
  }
  if (*((void *)a5 + 1)) {
    unint64_t v22 = (const char *)*((void *)a5 + 1);
  }
  else {
    unint64_t v22 = (const char *)(a5 + 8);
  }
  return strncasecmp(v21, v22, v20) == 0;
}

uint64_t ___ZN14TIInputManager29inject_supplemental_candidateEN2KB10LookupTypeERNS0_19CandidateCollectionE_block_invoke(uint64_t a1, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 32);
  if (!KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(void *)(*(void *)(v6 + 224) + 8) + 72), a2, a3, a4))return 1; {
  if (!(*(unsigned int (**)(void))(**(void **)(v6 + 232) + 16))(*(void *)(v6 + 232))
  }
    || !(*(unsigned int (**)(void))(**(void **)(v6 + 232) + 64))(*(void *)(v6 + 232)))
  {
    return 0;
  }
  KB::String::String((KB::String *)v17, "'s");
  unint64_t v7 = (KB::CollatorWrapper **)(*(void *)(*(void *)(v6 + 224) + 8) + 72);
  KB::String::String((KB::String *)v14, (const KB::String *)a2);
  KB::String::append(v14, (const KB::String *)v17);
  int v9 = KB::CollatorWrapper::sortkey_compare_strings(v7, (_LXLexicon *)v14, a3, v8);
  if (v16 && v15 == 1) {
    free(v16);
  }
  if (v9)
  {
    int64x2_t v10 = (KB::CollatorWrapper **)(*(void *)(*(void *)(v6 + 224) + 8) + 72);
    KB::String::String((KB::String *)v14, a3);
    KB::String::append(v14, (const KB::String *)v17);
    BOOL v12 = KB::CollatorWrapper::sortkey_compare_strings(v10, a2, (const KB::String *)v14, v11) == 0;
    if (v16 && v15 == 1) {
      free(v16);
    }
  }
  else
  {
    BOOL v12 = 1;
  }
  if (v18 && v17[6] == 1) {
    free(v18);
  }
  return v12;
}

BOOL ___ZN14TIInputManager30word_from_supplemental_lexiconERN2KB6StringE_block_invoke(uint64_t a1, _LXLexicon *a2, const KB::String *a3, const KB::String *a4)
{
  return KB::CollatorWrapper::sortkey_compare_strings((KB::CollatorWrapper **)(*(void *)(*(void *)(*(void *)(a1 + 32) + 224) + 8) + 72), a2, a3, a4) == 0;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v6 = expf(*(float *)(a2 + 744));
  float v7 = expf(*(float *)(a1 + 744));
  float v8 = expf(*(float *)(a3 + 744));
  if (v6 <= v7)
  {
    if (v8 <= v6) {
      return;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
    float v12 = expf(*(float *)(a2 + 744));
    if (v12 <= expf(*(float *)(a1 + 744))) {
      return;
    }
    int v9 = (uint64_t *)a1;
    uint64x2_t v11 = (uint64_t *)a2;
  }
  else
  {
    int v9 = (uint64_t *)a1;
    if (v8 <= v6)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      float v10 = expf(*(float *)(a3 + 744));
      if (v10 <= expf(*(float *)(a2 + 744))) {
        return;
      }
      int v9 = (uint64_t *)a2;
    }
    uint64x2_t v11 = (uint64_t *)a3;
  }

  std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v9, v11);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a2, a3);
  float v8 = expf(*(float *)(a4 + 744));
  if (v8 > expf(*(float *)(a3 + 744)))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
    float v9 = expf(*(float *)(a3 + 744));
    if (v9 > expf(*(float *)(a2 + 744)))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
      float v10 = expf(*(float *)(a2 + 744));
      if (v10 > expf(*(float *)(a1 + 744)))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
      }
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a2, a3, a4);
  float v10 = expf(*(float *)(a5 + 744));
  if (v10 > expf(*(float *)(a4 + 744)))
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a4, (uint64_t *)a5);
    float v11 = expf(*(float *)(a4 + 744));
    if (v11 > expf(*(float *)(a3 + 744)))
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a3, (uint64_t *)a4);
      float v12 = expf(*(float *)(a3 + 744));
      if (v12 > expf(*(float *)(a2 + 744)))
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a2, (uint64_t *)a3);
        float v13 = expf(*(float *)(a2 + 744));
        if (v13 > expf(*(float *)(a1 + 744)))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)a2);
        }
      }
    }
  }
}

void std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *,KB::Candidate *>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((uint64_t *)a1 != a2)
  {
    BOOL v4 = a2;
    uint64_t v6 = (uint64_t)a2 - a1;
    uint64_t v7 = ((uint64_t)a2 - a1) / 1000;
    if ((uint64_t)a2 - a1 >= 1001)
    {
      unint64_t v8 = (unint64_t)(v7 - 2) >> 1;
      unint64_t v9 = v8 + 1;
      uint64_t v10 = a1 + 1000 * v8;
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, v7, v10);
        v10 -= 1000;
        --v9;
      }
      while (v9);
    }
    if (v4 != a3)
    {
      float v11 = v4;
      do
      {
        float v12 = expf(*((float *)v11 + 186));
        if (v12 > expf(*(float *)(a1 + 744)))
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>(v11, (uint64_t *)a1);
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, v7, a1);
        }
        v11 += 125;
      }
      while (v11 != a3);
    }
    if (v6 >= 1001)
    {
      int64_t v13 = v6 / 0x3E8uLL;
      do
      {
        KB::Candidate::Candidate((uint64_t)v29, a1);
        uint64_t v14 = 0;
        uint64_t v15 = v13 - 2;
        if (v13 < 2) {
          uint64_t v15 = v13 - 1;
        }
        uint64_t v16 = v15 >> 1;
        uint64_t v17 = a1;
        do
        {
          BOOL v18 = (uint64_t *)v17;
          uint64_t v19 = v14 + 1;
          v17 += 1000 * (v14 + 1);
          uint64_t v20 = 2 * v14;
          uint64_t v14 = (2 * v14) | 1;
          uint64_t v21 = v20 + 2;
          if (v20 + 2 < v13)
          {
            float v22 = expf(*(float *)&v18[125 * v19 + 93]);
            if (v22 > expf(*(float *)(v17 + 1744)))
            {
              v17 += 1000;
              uint64_t v14 = v21;
            }
          }
          KB::Candidate::operator=(v18, (uint64_t *)v17);
        }
        while (v14 <= v16);
        v4 -= 125;
        if ((uint64_t *)v17 == v4)
        {
          KB::Candidate::operator=((uint64_t *)v17, v29);
        }
        else
        {
          KB::Candidate::operator=((uint64_t *)v17, v4);
          KB::Candidate::operator=(v4, v29);
          uint64_t v23 = v17 - a1 + 1000;
          if (v23 >= 1001)
          {
            unint64_t v24 = (unint64_t)(0x1CAC083126E978D5 * (v23 >> 3) - 2) >> 1;
            float v25 = expf(*(float *)(a1 + 1000 * v24 + 744));
            if (v25 > expf(*(float *)(v17 + 744)))
            {
              KB::Candidate::Candidate((uint64_t)v30, v17);
              do
              {
                unsigned int v26 = (uint64_t *)v17;
                uint64_t v17 = a1 + 1000 * v24;
                KB::Candidate::operator=(v26, (uint64_t *)v17);
                if (!v24) {
                  break;
                }
                unint64_t v24 = (v24 - 1) >> 1;
                float v27 = expf(*(float *)(a1 + 1000 * v24 + 744));
              }
              while (v27 > expf(v31));
              KB::Candidate::operator=((uint64_t *)v17, v30);
              KB::Candidate::~Candidate((KB::Candidate *)v30);
            }
          }
        }
        KB::Candidate::~Candidate((KB::Candidate *)v29);
      }
      while (v13-- > 2);
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  BOOL v4 = 1;
  switch(0x1CAC083126E978D5 * ((a2 - a1) >> 3))
  {
    case 0:
    case 1:
      return v4;
    case 2:
      float v5 = expf(*(float *)(a2 - 256));
      if (v5 > expf(*(float *)(a1 + 744))) {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<KB::Candidate *&,KB::Candidate *&>((uint64_t *)a1, (uint64_t *)(a2 - 1000));
      }
      return v4;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a2 - 1000);
      return v4;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a2 - 1000);
      return v4;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000, a1 + 3000, a2 - 1000);
      return v4;
    default:
      uint64_t v6 = a1 + 2000;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(a1, a1 + 1000, a1 + 2000);
      uint64_t v7 = a1 + 3000;
      if (a1 + 3000 == a2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      break;
  }
  while (1)
  {
    float v10 = expf(*(float *)(v7 + 744));
    if (v10 > expf(*(float *)(v6 + 744))) {
      break;
    }
LABEL_14:
    uint64_t v6 = v7;
    v8 += 1000;
    v7 += 1000;
    if (v7 == a2) {
      return 1;
    }
  }
  KB::Candidate::Candidate((uint64_t)v16, v7);
  uint64_t v11 = v8;
  while (1)
  {
    KB::Candidate::operator=((uint64_t *)(a1 + v11 + 3000), (uint64_t *)(a1 + v11 + 2000));
    if (v11 == -2000) {
      break;
    }
    float v12 = expf(v17);
    float v13 = expf(*(float *)(a1 + v11 + 1744));
    v11 -= 1000;
    if (v12 <= v13)
    {
      uint64_t v14 = (uint64_t *)(a1 + v11 + 3000);
      goto LABEL_12;
    }
  }
  uint64_t v14 = (uint64_t *)a1;
LABEL_12:
  KB::Candidate::operator=(v14, v16);
  if (++v9 != 8)
  {
    KB::Candidate::~Candidate((KB::Candidate *)v16);
    goto LABEL_14;
  }
  BOOL v4 = v7 + 1000 == a2;
  KB::Candidate::~Candidate((KB::Candidate *)v16);
  return v4;
}

void std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,KB::Candidate *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a2 - 2;
  if (a2 >= 2)
  {
    uint64_t v4 = a3;
    uint64_t v6 = v3 >> 1;
    if ((uint64_t)(v3 >> 1) >= 0x1CAC083126E978D5 * ((a3 - a1) >> 3))
    {
      uint64_t v8 = (0x395810624DD2F1AALL * ((a3 - a1) >> 3)) | 1;
      uint64_t v9 = a1 + 1000 * v8;
      uint64_t v10 = 0x395810624DD2F1AALL * ((a3 - a1) >> 3) + 2;
      if (v10 < a2)
      {
        float v11 = expf(*(float *)(a1 + 1000 * v8 + 744));
        if (v11 > expf(*(float *)(v9 + 1744)))
        {
          v9 += 1000;
          uint64_t v8 = v10;
        }
      }
      float v12 = expf(*(float *)(v9 + 744));
      if (v12 <= expf(*(float *)(v4 + 744)))
      {
        KB::Candidate::Candidate((uint64_t)v17, v4);
        do
        {
          float v13 = (uint64_t *)v9;
          KB::Candidate::operator=((uint64_t *)v4, (uint64_t *)v9);
          if (v6 < v8) {
            break;
          }
          uint64_t v14 = (2 * v8) | 1;
          uint64_t v9 = a1 + 1000 * v14;
          if (2 * v8 + 2 < a2)
          {
            float v15 = expf(*(float *)(a1 + 1000 * v14 + 744));
            if (v15 > expf(*(float *)(v9 + 1744)))
            {
              v9 += 1000;
              uint64_t v14 = 2 * v8 + 2;
            }
          }
          float v16 = expf(*(float *)(v9 + 744));
          uint64_t v4 = (uint64_t)v13;
          uint64_t v8 = v14;
        }
        while (v16 <= expf(v18));
        KB::Candidate::operator=(v13, v17);
        KB::Candidate::~Candidate((KB::Candidate *)v17);
      }
    }
  }
}

void TIInputManager::autocorrections(TIInputManager *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (!*((_DWORD *)this + 134))
  {
    if (!*((unsigned char *)this + 688))
    {
      uint64_t v6 = (char *)this + 32;
      if (!*((_WORD *)this + 16)) {
        goto LABEL_13;
      }
      TIInputManager::legacy_input_stem(this, (uint64_t)v8);
      if (v6 == v8)
      {
        if (v10 && v9 == 1) {
          free(v10);
        }
        goto LABEL_6;
      }
      BOOL v7 = KB::String::equal((TIInputManager *)((char *)this + 32), (const KB::String *)v8, 1);
      if (v10 && v9 == 1) {
        free(v10);
      }
      if (!v7)
      {
LABEL_13:
        TIInputManager::lookup((uint64_t)this, 0, 1, a2, a3);
        return;
      }
    }
LABEL_6:
    *(void *)(a3 + 100) = 0x10000000000000;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_WORD *)(a3 + 108) = 0;
    *(unsigned char *)(a3 + 110) = 0;
    *(void *)(a3 + 112) = 0;
    *(unsigned char *)(a3 + 120) = 0;
    return;
  }

  TIInputManager::lookup((uint64_t)this, 0, 1, a2, a3);
}

void TIInputManager::~TIInputManager(TIInputManager *this)
{
  TIInputManager::~TIInputManager(this);

  JUMPOUT(0x1E4E7BC20);
}

{
  const void *v2;
  const void *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  void *v6;
  std::__shared_weak_count *v7;
  void *v8;
  uint64_t v9;
  void *v10;
  std::__shared_weak_count *v11;
  unsigned int *v12;
  void *v13;
  uint64_t v14;
  const void *v15;
  void *v16;
  void *v17;
  void *v18;
  void **v19;

  *(void *)this = &unk_1F3F73B18;
  unint64_t v2 = (const void *)*((void *)this + 70);
  if (v2) {
    _Block_release(v2);
  }
  unint64_t v3 = (const void *)*((void *)this + 88);
  if (v3) {
    CFRelease(v3);
  }
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*((void **)this + 84));
  TI::VulgarWordUsageDatabaseWrapper::~VulgarWordUsageDatabaseWrapper((TIInputManager *)((char *)this + 592));
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 72);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  float v5 = (std::__shared_weak_count *)*((void *)this + 69);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
  uint64_t v19 = (void **)((char *)this + 512);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v19);
  language_modeling::v1::LinguisticContext::~LinguisticContext((TIInputManager *)((char *)this + 504));
  language_modeling::v1::LinguisticContext::~LinguisticContext((TIInputManager *)((char *)this + 496));
  uint64_t v6 = (void *)*((void *)this + 56);
  if (v6)
  {
    *((void *)this + 57) = v6;
    operator delete(v6);
  }
  BOOL v7 = (std::__shared_weak_count *)*((void *)this + 55);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v7);
  }
  uint64_t v8 = (void *)*((void *)this + 51);
  if (v8 && *((unsigned char *)this + 406) == 1) {
    free(v8);
  }
  std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*((void **)this + 42));
  char v9 = *((void *)this + 40);
  if (v9) {
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v9);
  }
  uint64_t v10 = (void *)*((void *)this + 37);
  if (v10 && *((unsigned char *)this + 294) == 1) {
    free(v10);
  }
  WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::~Vector((void *)this + 32);
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v11) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v11);
  }
  float v12 = (unsigned int *)*((void *)this + 28);
  if (v12) {
    WTF::RefCounted<KB::DictionaryContainer>::deref(v12);
  }
  float v13 = (void *)*((void *)this + 25);
  if (v13 && *((unsigned char *)this + 198) == 1) {
    free(v13);
  }
  uint64_t v14 = *((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  float v15 = (const void *)*((void *)this + 17);
  if (v15) {
    CFRelease(v15);
  }
  *((void *)this + 17) = 0;
  float v16 = (void *)*((void *)this + 14);
  if (v16 && *((unsigned char *)this + 110) == 1) {
    free(v16);
  }
  float v17 = (void *)*((void *)this + 9);
  if (v17 && *((unsigned char *)this + 70) == 1) {
    free(v17);
  }
  float v18 = (void *)*((void *)this + 5);
  if (v18 && *((unsigned char *)this + 38) == 1) {
    free(v18);
  }
  uint64_t v19 = (void **)((char *)this + 8);
  std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100](&v19);
}

void std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*a1);
    std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,0>((uint64_t)(a1 + 4));
    operator delete(a1);
  }
}

void std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*a1);
    std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(a1[1]);
    std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(a1 + 4);
    operator delete(a1);
  }
}

void std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  unsigned int v1 = *a1;
  unint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    float v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = (void *)*((void *)v4 - 4);
        if (v6 && *(v4 - 34) == 1) {
          free(v6);
        }
        v4 -= 40;
      }
      while (v4 != v2);
      float v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<int const,KB::ContinuousPathDetector::AnnotatedPath>,0>(void *a1)
{
  uint64_t v2 = a1[7];
  if (v2) {
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3)
  {
    a1[5] = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
}

uint64_t TIInputManager::LockedInput::locked_length(TIInputManager::LockedInput *this)
{
  unsigned int v1 = *((_DWORD *)this + 1);
  if (*(_DWORD *)this <= v1) {
    return v1;
  }
  else {
    return *(unsigned int *)this;
  }
}

uint64_t TIInputManager::LockedInput::locked_length_without_deletion(TIInputManager::LockedInput *this)
{
  return *(unsigned int *)this;
}

unsigned int *TIInputManager::LockedInput::set_shadow_locked_length(unsigned int *this, unsigned int a2)
{
  unsigned int v2 = *this;
  if (*this <= a2) {
    unsigned int v2 = a2;
  }
  *this = v2;
  return this;
}

unsigned int *TIInputManager::LockedInput::set_accepted_locked_length(unsigned int *this, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = *this;
  unsigned int v4 = this[1];
  if (*this <= a2) {
    unsigned int v3 = a2;
  }
  if (v4 >= a3) {
    unsigned int v4 = a3;
  }
  *this = v3;
  this[1] = v4;
  return this;
}

unsigned int *TIInputManager::LockedInput::set_deletion_locked_length(unsigned int *this, unsigned int a2)
{
  this[1] = a2;
  if (*this > a2) {
    *this = a2;
  }
  return this;
}

uint32x2_t TIInputManager::LockedInput::drop_input_prefix_of_length(uint32x2_t *this, unsigned int a2)
{
  uint32x2_t result = vqsub_u32(*this, (uint32x2_t)vdup_n_s32(a2));
  *this = result;
  return result;
}

void *TIInputManager::LockedInput::clear(void *this)
{
  *this = 0;
  return this;
}

void TIInputManager::TIInputManager(uint64_t a1)
{
  *(void *)a1 = &unk_1F3F73B18;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_WORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 34) = 16;
  *(unsigned char *)(a1 + 38) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 64) = 0x100000;
  *(_WORD *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 70) = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0x100000;
  *(_WORD *)(a1 + 108) = 0;
  *(unsigned char *)(a1 + 110) = 0;
  *(void *)(a1 + 112) = 0;
  *(unsigned char *)(a1 + 120) = 0;
  *(void *)(a1 + 136) = 0;
  *(_OWORD *)(a1 + 144) = xmmword_1E4154BF0;
  *(_DWORD *)(a1 + 160) = 1028443341;
  *(_OWORD *)(a1 + 164) = xmmword_1E4154C00;
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 192) = 0x100000;
  *(_WORD *)(a1 + 196) = 0;
  *(unsigned char *)(a1 + 198) = 0;
  *(void *)(a1 + 200) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  std::string __p = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  operator new();
}

void TIInputManager::load_dictionaries(uint64_t a1, const __CFString *a2)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 224) + 24);
  unsigned int v4 = *(std::__shared_weak_count **)(v3 + 32);
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v4);
  }
  if (!*(unsigned char *)(a1 + 698))
  {
    if (TI_IS_INTERNAL_INSTALL::once_token != -1) {
      dispatch_once(&TI_IS_INTERNAL_INSTALL::once_token, &__block_literal_global_3708);
    }
    if (TI_IS_INTERNAL_INSTALL::is_internal_install)
    {
      KB::ContinuousPathDetector::Parameters::user_parameters(a2, (uint64_t)&v11);
      char v9 = 0;
      uint64_t v10 = 0;
      *((void *)&v12 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = CFAbsoluteTimeGetCurrent();
      uint64_t v13 = 0;
      uint64_t v5 = a1 + 336;
      std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(*(void **)(a1 + 336));
      uint64_t v6 = v9;
      *(void *)(a1 + 328) = &v9;
      *(void *)(a1 + 336) = v6;
      uint64_t v7 = v10;
      *(void *)(a1 + 344) = v10;
      if (v7)
      {
        v6[2] = v5;
        char v9 = 0;
        uint64_t v10 = 0;
        uint64_t v6 = 0;
      }
      else
      {
        *(void *)(a1 + 328) = v5;
      }
      long long v8 = v12;
      *(_OWORD *)(a1 + 352) = v11;
      *(_OWORD *)(a1 + 368) = v8;
      *(void *)(a1 + 384) = v13;
      std::__tree<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::__map_value_compare<int,std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>,std::less<int>,true>,std::allocator<std::__value_type<int,KB::ContinuousPathDetector::AnnotatedPath>>>::destroy(v6);
    }
  }
  operator new();
}

KB::String *TIInputManager::dynamic_set_transient_string(TIInputManager *this, const KB::String *a2)
{
  return KB::String::operator=((KB::String *)(*(void *)(*((void *)this + 28) + 24) + 56), a2);
}

void TIInputManager::set_locale_identifier(TIInputManager *this, const KB::String *a2)
{
  KB::String::operator=((TIInputManager *)((char *)this + 104), a2);
  KB::cf_string_impl<KB::String>(localeIdentifier, (unsigned __int16 *)a2);
  CFLocaleIdentifier v4 = localeIdentifier[0];
  CFLocaleRef v5 = CFLocaleCreate(0, localeIdentifier[0]);
  uint64_t v6 = (const void *)*((void *)this + 17);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)this + 17) = v5;
  if (v4) {
    CFRelease(v4);
  }
  if (*((void *)this + 23))
  {
    uint64_t v7 = (char *)*((void *)a2 + 1);
    if (!v7) {
      uint64_t v7 = (char *)a2 + 16;
    }
    if (*(_WORD *)a2) {
      long long v8 = v7;
    }
    else {
      long long v8 = "";
    }
    std::string::basic_string[abi:nn180100]<0>(localeIdentifier, v8);
    (*(void (**)(void))(**((void **)this + 23) + 448))();
    if (v10 < 0) {
      operator delete((void *)localeIdentifier[0]);
    }
  }
}

void TIInputManager::set_filter_specification_overrides(TIInputManager *this, CFTypeRef cf)
{
  if (cf) {
    CFRetain(cf);
  }
  CFLocaleIdentifier v4 = (const void *)*((void *)this + 88);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 88) = cf;
  std::__tree<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::__map_value_compare<KB::String const,std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>,std::less<KB::String const>,true>,std::allocator<std::__value_type<KB::String const,std::unique_ptr<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node,std::default_delete<KB::LRUCache<KB::String,std::shared_ptr<KB::CandidateFilter>>::Node>>>>>::destroy(*((void **)this + 84));
  *((void *)this + 83) = (char *)this + 672;
  *((void *)this + 85) = 0;
  *((void *)this + 84) = 0;
  *((void *)this + 82) = 0;
  *((void *)this + 8TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
}

unsigned __int16 *TIInputManager::input_string@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3), a2);
}

unsigned __int16 *TIInputManager::input_substring@<X0>(TIInputManager *this@<X0>, unsigned int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, a2, a3, a4);
}

unsigned __int16 *TIInputManager::input_stem@<X0>(TIInputManager *this@<X0>, uint64_t a2@<X8>)
{
  return TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), a2);
}

uint64_t TIInputManager::legacy_input_start_index(TIInputManager *this)
{
  uint64_t v2 = *((unsigned int *)this + 24);
  uint64_t result = v2 + 1;
  uint64_t v4 = 40 * v2 - 8;
  do
  {
    if (!--result) {
      break;
    }
    char v5 = *(unsigned char *)(*((void *)this + 1) + v4);
    v4 -= 40;
  }
  while ((v5 & 0x40) == 0);
  return result;
}

uint64_t TIInputManager::legacy_input_end_index(TIInputManager *this)
{
  uint64_t result = *((unsigned int *)this + 24);
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = -858993459 * ((unint64_t)(*((void *)this + 2) - v3) >> 3);
  int v5 = v4 - result;
  if (v4 > result)
  {
    uint64_t v6 = (char *)(v3 + 40 * result + 32);
    while (1)
    {
      char v7 = *v6;
      v6 += 40;
      if ((v7 & 0x40) != 0) {
        break;
      }
      ++result;
      if (!--v5) {
        return v4;
      }
    }
  }
  return result;
}

void TIInputManager::add_input(TIInputManager *this, const KB::String *a2, unsigned int a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = TIInputManager::favonius_layout(this);
  unint64_t v7 = *(unsigned int *)(*(void *)v6 + 200);
  if ((unint64_t)((uint64_t)(*(void *)(*(void *)v6 + 16) - *(void *)(*(void *)v6 + 8)) >> 3) >> 1 < v7
    || v7 > 0xB)
  {
    unsigned int v9 = a3 | 0x20;
  }
  else
  {
    unsigned int v9 = a3;
  }
  KB::String::String((KB::String *)v33, a2);
  unint64_t v10 = *((void *)this + 3);
  uint64_t v11 = *((void *)this + 1);
  unsigned int v35 = v9;
  uint64_t v12 = *((unsigned int *)this + 24);
  uint64_t v13 = (const KB::String *)(v11 + 40 * v12);
  unint64_t v14 = *((void *)this + 2);
  if (v14 >= v10)
  {
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - v11) >> 3) + 1;
    if (v16 > 0x666666666666666) {
      abort();
    }
    unint64_t v17 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v10 - v11) >> 3);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0x333333333333333) {
      unint64_t v18 = 0x666666666666666;
    }
    else {
      unint64_t v18 = v16;
    }
    uint64_t v32 = (char *)this + 24;
    if (v18)
    {
      uint64_t v20 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v18);
    }
    else
    {
      uint64_t v20 = 0;
      uint64_t v19 = 0;
    }
    uint64_t v21 = (KB::String *)((char *)v20 + 40 * v12);
    int v28 = v20;
    __int16 v29 = v21;
    float v22 = (char *)v20 + 40 * v19;
    char v30 = v21;
    float v31 = v22;
    if (v19 == v12)
    {
      if (v12)
      {
        uint64_t v23 = (KB::String *)((char *)v21 - 40 * ((unint64_t)(v12 + 1) >> 1));
        uint64_t v21 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(v21, v21, v23);
        __int16 v29 = v23;
        char v30 = v21;
      }
      else
      {
        unsigned int v40 = (char *)this + 24;
        int v28 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(1uLL);
        __int16 v29 = v28;
        unint64_t v36 = v20;
        uint64_t v37 = v20;
        char v30 = v28;
        float v31 = (char *)v28 + 40 * v24;
        uint64_t v38 = v20;
        char v39 = v22;
        std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v36);
        uint64_t v21 = v28;
      }
    }
    KB::String::String(v21, (const KB::String *)v33);
    *((_DWORD *)v21 + 8) = v35;
    char v30 = (KB::String *)((char *)v30 + 40);
    std::vector<KB::Input>::__swap_out_circular_buffer((KB::String **)this + 1, &v28, v13);
    std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v28);
  }
  else if (v13 == (const KB::String *)v14)
  {
    KB::String::String((KB::String *)(v11 + 40 * v12), (const KB::String *)v33);
    *(_DWORD *)(v11 + 40 * v12 + 32) = v35;
    *((void *)this + 2) = (char *)v13 + 40;
  }
  else
  {
    std::vector<KB::Input>::__move_range((uint64_t)this + 8, v11 + 40 * v12, v14, (uint64_t)v13 + 40);
    float v15 = (KB::String *)v33;
    if (v13 <= (const KB::String *)v33) {
      float v15 = (KB::String *)&v33[40 * (*((void *)this + 2) > (unint64_t)v33)];
    }
    if (v13 != v15)
    {
      KB::String::operator=((KB::String *)(v11 + 40 * v12), v15);
      *(_DWORD *)(v11 + 40 * v12 + 32) = *((_DWORD *)v15 + 8);
    }
  }
  ++*((_DWORD *)this + 24);
  *((unsigned char *)this + 688) = 0;
  if (*((void *)a2 + 1)) {
    float v25 = (const char *)*((void *)a2 + 1);
  }
  else {
    float v25 = (char *)a2 + 16;
  }
  BOOL v26 = strcmp(v25, " ") == 0;
  (*(void (**)(void, uint64_t, void))(**((void **)this + 23) + 48))(*((void *)this + 23), 1, v26 & (v9 >> 7));
  if ((v9 & 4) != 0)
  {
    (*(void (**)(void))(**((void **)this + 23) + 136))(*((void *)this + 23));
    uint64_t v27 = *((void *)this + 23);
    TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)&v36);
    (*(void (**)(uint64_t, char *, KB::String **, void, void))(*(void *)v27 + 144))(v27, (char *)this + 432, &v36, *((unsigned int *)this + 24), -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3));
    if (v37)
    {
      if (BYTE6(v36) == 1) {
        free(v37);
      }
    }
  }
  if (v34)
  {
    if (v33[6] == 1) {
      free(v34);
    }
  }
}

KB::String *std::vector<KB::Input>::__move_range(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = v6 - a4;
  unint64_t v8 = a2 + v6 - a4;
  if (v8 >= a3)
  {
    uint64_t result = *(KB::String **)(a1 + 8);
  }
  else
  {
    unint64_t v10 = (const KB::String *)(a2 + v6 - a4);
    uint64_t result = *(KB::String **)(a1 + 8);
    do
    {
      uint64_t v12 = KB::String::String(result, v10);
      *((_DWORD *)v12 + 8) = *((_DWORD *)v10 + 8);
      unint64_t v10 = (const KB::String *)((char *)v10 + 40);
      uint64_t result = (KB::String *)((char *)v12 + 40);
    }
    while ((unint64_t)v10 < a3);
  }
  *(void *)(a1 + 8) = result;
  if (v6 != a4)
  {
    uint64_t v13 = 0;
    do
    {
      if (v8 != v6)
      {
        uint64_t result = KB::String::operator=((KB::String *)(v6 + v13 - 40), (KB::String *)(v8 + v13 - 40));
        *(_DWORD *)(v6 + v13 - 8) = *(_DWORD *)(v8 + v13 - 8);
      }
      v13 -= 40;
    }
    while (-8 * (v7 >> 3) != v13);
  }
  return result;
}

KB::String *std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(KB::String *a1, KB::String *a2, KB::String *a3)
{
  if (a1 != a2)
  {
    int v5 = a1;
    do
    {
      if (v5 != a3)
      {
        KB::String::operator=(a3, v5);
        *((_DWORD *)a3 + 8) = *((_DWORD *)v5 + 8);
      }
      int v5 = (KB::String *)((char *)v5 + 40);
      a3 = (KB::String *)((char *)a3 + 40);
    }
    while (v5 != a2);
  }
  return a3;
}

uint64_t std::__split_buffer<KB::Input>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      int v5 = *(void **)(v2 - 32);
      if (v5 && *(unsigned char *)(v2 - 34) == 1)
      {
        free(v5);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

KB::String *std::vector<KB::Input>::__swap_out_circular_buffer(KB::String **a1, void *a2, const KB::String *a3)
{
  uint64_t v3 = a3;
  uint64_t v6 = (KB::String *)a2[1];
  uint64_t v7 = *a1;
  unint64_t v8 = v6;
  if (v7 != a3)
  {
    unsigned int v9 = a3;
    unint64_t v10 = (KB::String *)a2[1];
    do
    {
      unint64_t v8 = KB::String::String((KB::String *)((char *)v10 - 40), (const KB::String *)((char *)v9 - 40));
      *((_DWORD *)v10 - 2) = *((_DWORD *)v9 - 2);
      unsigned int v9 = (const KB::String *)((char *)v9 - 40);
      unint64_t v10 = v8;
    }
    while (v9 != v7);
  }
  a2[1] = v8;
  uint64_t v11 = a1[1];
  uint64_t v12 = (KB::String *)a2[2];
  if (v11 != v3)
  {
    do
    {
      KB::String::String(v12, v3);
      *((_DWORD *)v12 + 8) = *((_DWORD *)v3 + 8);
      uint64_t v3 = (const KB::String *)((char *)v3 + 40);
      uint64_t v12 = (KB::String *)((char *)v12 + 40);
    }
    while (v3 != v11);
    unint64_t v8 = (KB::String *)a2[1];
  }
  a2[2] = v12;
  uint64_t v13 = *a1;
  *a1 = v8;
  a2[1] = v13;
  unint64_t v14 = a1[1];
  a1[1] = (KB::String *)a2[2];
  a2[2] = v14;
  float v15 = a1[2];
  a1[2] = (KB::String *)a2[3];
  a2[3] = v15;
  *a2 = a2[1];
  return v6;
}

void TIInputManager::set_input(TIInputManager *this, const KB::String *a2)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (KB::String **)((char *)this + 8);
  TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)v82);
  if (KB::String::contains((KB::String *)v82, 0x2019u))
  {
    __int16 v77 = 0;
    char v78 = 0;
    uint64_t v79 = "'";
    int v76 = 1048577;
    char v80 = 0;
    KB::String::replace_char((KB::String *)v82, (const KB::String *)&v76, 8217, (uint64_t)v86);
    KB::String::operator=((uint64_t)v82, (KB::String *)v86);
    if (*(void *)&v86[8] && v86[6] == 1) {
      free(*(void **)&v86[8]);
    }
    if (v79 && v78 == 1) {
      free(v79);
    }
  }
  int64x2_t v69 = 0uLL;
  unint64_t v70 = 0;
  size_t v5 = *(unsigned __int16 *)a2;
  int v6 = v82[0];
  if (v5 <= v82[0])
  {
    uint64_t v7 = (const char *)(v84 ? v84 : &v85);
    unint64_t v8 = *((void *)a2 + 1) ? (const char *)*((void *)a2 + 1) : (char *)a2 + 16;
    if (!strncmp(&v7[v82[0] - v5], v8, v5))
    {
      *(void *)&long long v67 = v7;
      DWORD2(v67) = 0;
      HIDWORD(v67) = v6;
      LODWORD(v68) = 0;
      KB::String::iterator::initialize((uint64_t *)&v67);
      KB::String::find((KB::String *)v82, a2, (uint64_t)v65);
      *(_OWORD *)char v86 = v67;
      *(void *)&v86[16] = v68;
      int v41 = v66;
      if (DWORD2(v67) == v66)
      {
        uint64_t v42 = 0;
      }
      else
      {
        uint64_t v42 = 0;
        do
        {
          ++v42;
          KB::String::iterator::operator++((uint64_t *)v86);
        }
        while (*(_DWORD *)&v86[8] != v41);
      }
      BOOL v45 = 0;
      for (unint64_t i = 0; ; ++i)
      {
        unsigned int v47 = *((unsigned __int16 *)a2 + 2);
        if (!*((_WORD *)a2 + 2))
        {
          KB::String::compute_length((unsigned __int16 *)a2);
          unsigned int v47 = *((unsigned __int16 *)a2 + 2);
        }
        if (i >= v47) {
          break;
        }
        uint64_t v48 = v42 + i;
        uint64_t v49 = *v4;
        unsigned int v50 = (KB::String *)((char *)*v4 + 40 * v42 + 40 * i);
        if ((unint64_t)v45 >= v70)
        {
          unint64_t v51 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v45 - v69.i64[0]) >> 3);
          unint64_t v52 = v51 + 1;
          if (v51 + 1 > 0x666666666666666) {
            goto LABEL_110;
          }
          if (0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3) > v52) {
            unint64_t v52 = 0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v70 - v69.i64[0]) >> 3) >= 0x333333333333333) {
            unint64_t v53 = 0x666666666666666;
          }
          else {
            unint64_t v53 = v52;
          }
          int v88 = &v70;
          if (v53) {
            unint64_t v53 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v53);
          }
          else {
            uint64_t v54 = 0;
          }
          float v55 = (_DWORD *)(v53 + 40 * v51);
          *(void *)char v86 = v53;
          *(void *)&v86[8] = v55;
          unint64_t v87 = v53 + 40 * v54;
          KB::String::String((KB::String *)v55, v50);
          unsigned char v55[8] = *((_DWORD *)v49 + 10 * v48 + 8);
          BOOL v45 = (KB::String *)(v55 + 10);
          *(void *)&v86[16] = v45;
          uint64_t v56 = v69.i64[1];
          uint64_t v57 = v69.i64[0];
          int64_t v58 = *(KB::String **)&v86[8];
          if (v69.i64[1] == v69.i64[0])
          {
            int64x2_t v60 = vdupq_n_s64(v69.u64[1]);
          }
          else
          {
            do
            {
              uint64_t v59 = v58;
              int64_t v58 = KB::String::String((KB::String *)((char *)v58 - 40), (const KB::String *)(v56 - 40));
              *((_DWORD *)v59 - 2) = *(_DWORD *)(v56 - 8);
              v56 -= 40;
            }
            while (v56 != v57);
            int64x2_t v60 = v69;
            BOOL v45 = *(KB::String **)&v86[16];
          }
          v69.i64[0] = (uint64_t)v58;
          v69.i64[1] = (uint64_t)v45;
          *(int64x2_t *)&v86[8] = v60;
          unint64_t v61 = v70;
          unint64_t v70 = v87;
          unint64_t v87 = v61;
          *(void *)char v86 = v60.i64[0];
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v86);
        }
        else
        {
          KB::String::String(v45, (KB::String *)((char *)*v4 + 40 * v42 + 40 * i));
          *((_DWORD *)v45 + 8) = *((_DWORD *)v49 + 10 * v48 + 8);
          BOOL v45 = (KB::String *)((char *)v45 + 40);
        }
        v69.i64[1] = (uint64_t)v45;
      }
    }
  }
  uint64_t v9 = *((void *)this + 1);
  for (uint64_t j = *((void *)this + 2); j != v9; j -= 40)
  {
    uint64_t v11 = *(void **)(j - 32);
    if (v11)
    {
      if (*(unsigned char *)(j - 34) == 1) {
        free(v11);
      }
    }
  }
  *((void *)this + 2) = v9;
  KB::String::operator=((TIInputManager *)((char *)this + 32), a2);
  unsigned int v12 = *((unsigned __int16 *)a2 + 2);
  if (!*((_WORD *)a2 + 2))
  {
    KB::String::compute_length((unsigned __int16 *)a2);
    unsigned int v12 = *((unsigned __int16 *)a2 + 2);
  }
  std::vector<KB::Input>::reserve(v4, v12);
  uint64_t v13 = (const KB::String *)v69.i64[1];
  unint64_t v14 = (const KB::String *)v69.i64[0];
  unint64_t v15 = 0xCCCCCCCCCCCCCCCDLL * ((v69.i64[1] - v69.i64[0]) >> 3);
  if (v15 == *(unsigned __int16 *)a2)
  {
    if (v4 != (KB::String **)&v69)
    {
      uint64_t v16 = *((void *)this + 3);
      uint64_t v17 = *((void *)this + 1);
      if (0xCCCCCCCCCCCCCCCDLL * ((v16 - v17) >> 3) < v15)
      {
        if (v17)
        {
          uint64_t v18 = *((void *)this + 2);
          uint64_t v19 = (KB::String *)*((void *)this + 1);
          if (v18 != v17)
          {
            do
            {
              uint64_t v20 = *(void **)(v18 - 32);
              if (v20 && *(unsigned char *)(v18 - 34) == 1) {
                free(v20);
              }
              v18 -= 40;
            }
            while (v18 != v17);
            uint64_t v19 = *v4;
          }
          *((void *)this + 2) = v17;
          operator delete(v19);
          uint64_t v16 = 0;
          *uint64_t v4 = 0;
          v4[1] = 0;
          v4[2] = 0;
        }
        unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v16 >> 3);
        uint64_t v22 = 2 * v21;
        if (2 * v21 <= v15) {
          uint64_t v22 = v15;
        }
        if (v21 >= 0x333333333333333) {
          unint64_t v23 = 0x666666666666666;
        }
        else {
          unint64_t v23 = v22;
        }
        if (v23 > 0x666666666666666) {
LABEL_110:
        }
          abort();
        uint64_t v24 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v23);
        *((void *)this + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v24;
        *((void *)this + 2) = v24;
        *((void *)this + 3) = (char *)v24 + 40 * v25;
        while (v14 != v13)
        {
          BOOL v26 = KB::String::String(v24, v14);
          *((_DWORD *)v26 + 8) = *((_DWORD *)v14 + 8);
          unint64_t v14 = (const KB::String *)((char *)v14 + 40);
          uint64_t v24 = (KB::String *)((char *)v26 + 40);
        }
        goto LABEL_76;
      }
      if (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 2) - v17) >> 3) < v15)
      {
        uint64_t v43 = (KB::String *)(v69.i64[0] + 8 * ((*((void *)this + 2) - v17) >> 3));
        std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)v69.i64[0], v43, *((KB::String **)this + 1));
        uint64_t v24 = (KB::String *)*((void *)this + 2);
        while (v43 != v13)
        {
          uint64_t v44 = KB::String::String(v24, v43);
          *((_DWORD *)v44 + 8) = *((_DWORD *)v43 + 8);
          uint64_t v43 = (KB::String *)((char *)v43 + 40);
          uint64_t v24 = (KB::String *)((char *)v44 + 40);
        }
LABEL_76:
        *((void *)this + 2) = v24;
        goto LABEL_106;
      }
      int v62 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)v69.i64[0], (KB::String *)v69.i64[1], *((KB::String **)this + 1));
      for (uint64_t k = (KB::String *)*((void *)this + 2); k != v62; uint64_t k = (KB::String *)((char *)k - 40))
      {
        unsigned int v64 = (void *)*((void *)k - 4);
        if (v64 && *((unsigned char *)k - 34) == 1) {
          free(v64);
        }
      }
      *((void *)this + 2) = v62;
    }
  }
  else
  {
    KB::String::String((KB::String *)&v76, a2);
    int v81 = 0;
    while (1)
    {
      UChar32 v27 = KB::UTF8Iterator::next((KB::UTF8Iterator *)&v76);
      if (!v27) {
        break;
      }
      unsigned int v28 = v27;
      BOOL v29 = u_isupper(v27) != 0;
      KB::String::String((uint64_t)v74, v28);
      KB::String::String((KB::String *)v71, (const KB::String *)v74);
      BOOL v73 = v29;
      char v30 = (KB::String *)*((void *)this + 2);
      unint64_t v31 = *((void *)this + 3);
      if ((unint64_t)v30 >= v31)
      {
        unint64_t v34 = 0xCCCCCCCCCCCCCCCDLL * ((v30 - *v4) >> 3);
        unint64_t v35 = v34 + 1;
        if (v34 + 1 > 0x666666666666666) {
          goto LABEL_110;
        }
        unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v31 - (void)*v4) >> 3);
        if (2 * v36 > v35) {
          unint64_t v35 = 2 * v36;
        }
        if (v36 >= 0x333333333333333) {
          unint64_t v37 = 0x666666666666666;
        }
        else {
          unint64_t v37 = v35;
        }
        int v88 = (unint64_t *)((char *)this + 24);
        if (v37) {
          unint64_t v37 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v37);
        }
        else {
          uint64_t v38 = 0;
        }
        char v39 = (KB::String *)(v37 + 40 * v34);
        *(void *)char v86 = v37;
        *(void *)&v86[8] = v39;
        unint64_t v87 = v37 + 40 * v38;
        KB::String::String(v39, (const KB::String *)v71);
        *((_DWORD *)v39 + 8) = v73;
        *(void *)&v86[16] = (char *)v39 + 40;
        std::vector<KB::Input>::__swap_out_circular_buffer(v4, v86);
        ByteString v33 = (char *)*((void *)this + 2);
        std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v86);
      }
      else
      {
        uint64_t v32 = KB::String::String(v30, (const KB::String *)v71);
        *((_DWORD *)v32 + 8) = v73;
        ByteString v33 = (char *)v32 + 40;
      }
      *((void *)this + 2) = v33;
      if (v72 && v71[6] == 1) {
        free(v72);
      }
      if (v75 && v74[6] == 1) {
        free(v75);
      }
    }
    if (v79) {
      BOOL v40 = v78 == 1;
    }
    else {
      BOOL v40 = 0;
    }
    if (v40) {
      free(v79);
    }
  }
LABEL_106:
  *((_DWORD *)this + 24) = -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3);
  KB::String::clear((TIInputManager *)((char *)this + 64));
  *((unsigned char *)this + 688) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  (*(void (**)(void))(**((void **)this + 23) + 136))(*((void *)this + 23));
  *(void *)char v86 = &v69;
  std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)v86);
  if (v84 && v83 == 1) {
    free(v84);
  }
}

KB::String **std::vector<KB::Input>::reserve(KB::String **result, unint64_t a2)
{
  if (0xCCCCCCCCCCCCCCCDLL * ((result[2] - *result) >> 3) < a2)
  {
    uint64_t v2 = result;
    int64_t v3 = result[1] - *result;
    void v5[4] = result + 2;
    v5[0] = std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(a2);
    v5[1] = v5[0] + v3;
    v5[2] = v5[0] + v3;
    v5[3] = v5[0] + 40 * v4;
    std::vector<KB::Input>::__swap_out_circular_buffer(v2, v5);
    return (KB::String **)std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)v5);
  }
  return result;
}

KB::String *std::vector<KB::Input>::__swap_out_circular_buffer(KB::String **a1, void *a2)
{
  uint64_t v4 = *a1;
  size_t v5 = a1[1];
  int v6 = (KB::String *)a2[1];
  if (v5 == *a1)
  {
    uint64_t result = (KB::String *)a2[1];
  }
  else
  {
    do
    {
      uint64_t result = KB::String::String((KB::String *)((char *)v6 - 40), (KB::String *)((char *)v5 - 40));
      *((_DWORD *)v6 - 2) = *((_DWORD *)v5 - 2);
      size_t v5 = (KB::String *)((char *)v5 - 40);
      int v6 = result;
    }
    while (v5 != v4);
  }
  a2[1] = result;
  unint64_t v8 = *a1;
  *a1 = result;
  a2[1] = v8;
  uint64_t v9 = a1[1];
  a1[1] = (KB::String *)a2[2];
  a2[2] = v9;
  unint64_t v10 = a1[2];
  a1[2] = (KB::String *)a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

KB::String *TIInputManager::set_original_input(TIInputManager *this, const KB::String *a2)
{
  return KB::String::operator=((TIInputManager *)((char *)this + 32), a2);
}

void TIInputManager::or_input_flags_from_input(TIInputManager *this, const KB::String *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  KB::String::String((KB::String *)v8, a2);
  int v12 = 0;
  int v3 = v9;
  if (!v9)
  {
    KB::String::compute_length(v8);
    int v3 = v9;
  }
  uint64_t v4 = *((void *)this + 1);
  if (0xCCCCCCCCCCCCCCCDLL * ((*((void *)this + 2) - v4) >> 3) == v3)
  {
    for (unint64_t i = (_DWORD *)(v4 + 32); ; i += 10)
    {
      UChar32 v6 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v8);
      if (!v6) {
        break;
      }
      *i |= u_isupper(v6) != 0;
    }
  }
  if (v11) {
    BOOL v7 = v10 == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v11);
  }
}

void TIInputManager::delete_suffix_from_input(TIInputManager *this, const KB::String *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v14 = 0x100000;
  __int16 v15 = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  char v18 = 0;
  unsigned int v3 = *((_DWORD *)this + 24);
  if (v3)
  {
    unsigned int v5 = 0;
    int v6 = -1;
    do
    {
      TIInputManager::input_substring((unsigned __int16 *)this + 4, v3 + v6, ++v5, (uint64_t)v12);
      KB::String::operator=((uint64_t)&v14, (KB::String *)v12);
      if (v13) {
        BOOL v7 = v12[6] == 1;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7) {
        free(v13);
      }
      BOOL v8 = KB::String::equal(a2, (const KB::String *)&v14, 1);
      unsigned int v3 = *((_DWORD *)this + 24);
      --v6;
    }
    while (v5 < v3 && !v8);
    if (v8) {
      int v10 = v5;
    }
    else {
      int v10 = 1;
    }
  }
  else
  {
    int v10 = 1;
  }
  do
  {
    TIInputManager::delete_from_input(this);
    --v10;
  }
  while (v10);
  if (v17) {
    BOOL v11 = v16 == 1;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11) {
    free(v17);
  }
}

void TIInputManager::delete_from_input(TIInputManager *this)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  int v1 = *((_DWORD *)this + 24);
  if (v1)
  {
    uint64_t v3 = *((void *)this + 23);
    uint64_t v4 = (char *)this + 432;
    TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, v1, (uint64_t)v11);
    (*(void (**)(uint64_t, char *, unsigned char *, void, void))(*(void *)v3 + 144))(v3, v4, v11, *((unsigned int *)this + 24), -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3));
    if (v12 && v11[6] == 1) {
      free(v12);
    }
    if (*((_DWORD *)this + 24) && -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3))
    {
      KB::String::clear((TIInputManager *)((char *)this + 32));
      unsigned int v5 = *((_DWORD *)this + 24) - 1;
      *((_DWORD *)this + 24) = v5;
      uint64_t v6 = *((void *)this + 1) + 40 * v5;
      BOOL v7 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>((KB::String *)(v6 + 40), *((KB::String **)this + 2), (KB::String *)v6);
      for (unint64_t i = (KB::String *)*((void *)this + 2); i != v7; unint64_t i = (KB::String *)((char *)i - 40))
      {
        unsigned __int16 v9 = (void *)*((void *)i - 4);
        if (v9 && *((unsigned char *)i - 34) == 1) {
          free(v9);
        }
      }
      *((void *)this + 2) = v7;
      unsigned int v10 = *((_DWORD *)this + 24);
      *((_DWORD *)this + 44) = v10;
      if (*((_DWORD *)this + 43) > v10) {
        *((_DWORD *)this + 43) = v10;
      }
      *((unsigned char *)this + 688) = 1;
      (*(void (**)(void))(**((void **)this + 23) + 56))(*((void *)this + 23));
    }
  }
}

_DWORD *TIInputManager::lock_input(_DWORD *this)
{
  unsigned int v1 = this[24];
  unsigned int v2 = this[43];
  if (v2 <= v1) {
    unsigned int v2 = this[24];
  }
  if (this[44] < v1) {
    unsigned int v1 = this[44];
  }
  this[43] = v2;
  this[44] = v1;
  return this;
}

uint64_t TIInputManager::clear_input(TIInputManager *this)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v7 = 0x100000;
  __int16 v8 = 0;
  char v9 = 0;
  unsigned int v10 = 0;
  char v11 = 0;
  KB::String::operator=((TIInputManager *)((char *)this + 32), (KB::String *)&v7);
  if (v10) {
    BOOL v2 = v9 == 1;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2) {
    free(v10);
  }
  uint64_t v3 = *((void *)this + 1);
  for (uint64_t i = *((void *)this + 2); i != v3; i -= 40)
  {
    unsigned int v5 = *(void **)(i - 32);
    if (v5)
    {
      if (*(unsigned char *)(i - 34) == 1) {
        free(v5);
      }
    }
  }
  *((void *)this + 2) = v3;
  *((_DWORD *)this + 24) = 0;
  *((_DWORD *)this + 134) = 0;
  *((_DWORD *)this + 43) = 0;
  *((_DWORD *)this + 44) = 0;
  KB::String::clear((TIInputManager *)((char *)this + 64));
  *((unsigned char *)this + 688) = 0;
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 136))(*((void *)this + 23));
}

void TIInputManager::drop_input_prefix(KB::String **this, unsigned int a2)
{
  uint64_t v3 = (char *)(this + 1);
  std::vector<KB::Input>::erase((uint64_t)(this + 1), this[1], (KB::String *)((char *)this[1] + 40 * a2));
  *((_DWORD *)v3 + 22) -= a2;
  *(uint32x2_t *)(v3 + 164) = vqsub_u32(*(uint32x2_t *)(v3 + 164), (uint32x2_t)vdup_n_s32(a2));

  KB::String::clear((KB::String *)(v3 + 56));
}

void std::vector<KB::Input>::erase(uint64_t a1, KB::String *a2, KB::String *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(a3, *(KB::String **)(a1 + 8), a2);
    for (uint64_t i = *(KB::String **)(a1 + 8); i != v4; uint64_t i = (KB::String *)((char *)i - 40))
    {
      uint64_t v6 = (void *)*((void *)i - 4);
      if (v6)
      {
        if (*((unsigned char *)i - 34) == 1) {
          free(v6);
        }
      }
    }
    *(void *)(a1 + 8) = v4;
  }
}

void TIInputManager::clear_shadow_typing(TIInputManager *this)
{
}

void TIInputManager::accept_input(TIInputManager *this)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = *((_DWORD *)this + 24);
  unsigned int v3 = *((_DWORD *)this + 43);
  if (v3 <= v2) {
    unsigned int v3 = *((_DWORD *)this + 24);
  }
  if (*((_DWORD *)this + 44) < v2) {
    unsigned int v2 = *((_DWORD *)this + 44);
  }
  *((_DWORD *)this + 43) = v3;
  *((_DWORD *)this + 44) = v2;
  TIInputManager::legacy_input_stem(this, (uint64_t)v5);
  KB::String::operator=((uint64_t)this + 64, (KB::String *)v5);
  if (v6) {
    BOOL v4 = v5[6] == 1;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4) {
    free(v6);
  }
}

uint64_t TIInputManager::set_input_index(TIInputManager *this, unsigned int a2)
{
  unsigned int v2 = -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3);
  if (v2 >= a2) {
    unsigned int v2 = a2;
  }
  *((_DWORD *)this + 24) = v2;
  uint64_t v3 = **((void **)this + 23);
  if (*((unsigned char *)this + 696)) {
    return (*(uint64_t (**)(void))(v3 + 64))();
  }
  else {
    return (*(uint64_t (**)(void))(v3 + 136))();
  }
}

void TIInputManager::text_accepted(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = (KB::String **)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v88);
  if (a2 != a3 && !KB::String::equal((KB::String *)a2, (const KB::String *)a3, 1))
  {
    KB::String::operator=((KB::String *)(a1 + 64), (KB::String *)v88);
    TIInputManager::input_flags_vector((TIInputManager *)a1, &__p);
    unsigned int v14 = a3[2];
    if (!a3[2])
    {
      KB::String::compute_length(a3);
      unsigned int v14 = a3[2];
    }
    uint64_t v68 = (KB::String *)a3;
    unsigned int v15 = *(_DWORD *)(a1 + 96);
    if (v15 >= v14)
    {
      unsigned int v17 = *(_DWORD *)(a1 + 96);
      if (!v14)
      {
        KB::String::compute_length(a3);
        unsigned int v14 = a3[2];
        unsigned int v17 = *(_DWORD *)(a1 + 96);
      }
      unsigned int v16 = v15 - v14;
      unsigned int v15 = v17;
    }
    else
    {
      unsigned int v16 = 0;
    }
    std::vector<KB::Input>::erase((uint64_t)v12, (KB::String *)(*(void *)(a1 + 8) + 40 * v16), (KB::String *)(*(void *)(a1 + 8) + 40 * v15));
    *(_DWORD *)(a1 + 96) = v16;
    if (*((void *)a2 + 1)) {
      uint64_t v18 = *((void *)a2 + 1);
    }
    else {
      uint64_t v18 = (uint64_t)(a2 + 8);
    }
    uint64_t v73 = v18;
    int v19 = *a2;
    int v74 = 0;
    int v75 = v19;
    unsigned int v76 = 0;
    KB::String::iterator::initialize(&v73);
    uint64_t v69 = v18;
    int v70 = v19;
    int v71 = v19;
    int v72 = 0;
    KB::String::iterator::initialize(&v69);
    unsigned int v67 = v16;
    int v20 = v16;
    if (v74 != v70)
    {
      int v64 = a5;
      unsigned int v66 = a6;
      do
      {
        KB::String::String((uint64_t)v86, v76);
        unint64_t v21 = (const KB::String *)(*(void *)(a1 + 8) + 40 * *(unsigned int *)(a1 + 96));
        KB::String::String((KB::String *)v83, (const KB::String *)v86);
        int v85 = 0;
        unint64_t v23 = *(const KB::String **)(a1 + 8);
        unint64_t v22 = *(void *)(a1 + 16);
        int64_t v24 = 0xCCCCCCCCCCCCCCCDLL * ((v21 - v23) >> 3);
        unint64_t v25 = *(void *)(a1 + 24);
        if (v22 >= v25)
        {
          unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v22 - (void)v23) >> 3) + 1;
          if (v26 > 0x666666666666666) {
            abort();
          }
          unint64_t v27 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v25 - (void)v23) >> 3);
          if (2 * v27 > v26) {
            unint64_t v26 = 2 * v27;
          }
          if (v27 >= 0x333333333333333) {
            unint64_t v28 = 0x666666666666666;
          }
          else {
            unint64_t v28 = v26;
          }
          uint64_t v82 = a1 + 24;
          if (v28)
          {
            char v30 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v28);
          }
          else
          {
            char v30 = 0;
            uint64_t v29 = 0;
          }
          unint64_t v31 = (KB::String *)((char *)v30 + 8 * ((v21 - v23) >> 3));
          uint64_t v79 = v30;
          v80[0] = v31;
          v80[1] = v31;
          int v81 = (char *)v30 + 40 * v29;
          if (v24 == v29)
          {
            if (v21 - v23 < 1)
            {
              if (v21 == v23) {
                unint64_t v34 = 1;
              }
              else {
                unint64_t v34 = 0x999999999999999ALL * ((v21 - v23) >> 3);
              }
              unint64_t v35 = v34 >> 2;
              uint64_t v93 = v82;
              unint64_t v36 = (KB::String *)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v34);
              uint64_t v38 = v36;
              char v39 = (KB::String *)((char *)v36 + 40 * v35);
              BOOL v40 = v80[0];
              if (v80[1] == v80[0])
              {
                int64x2_t v46 = vdupq_n_s64((unint64_t)v80[0]);
                uint64_t v42 = (KB::String *)((char *)v36 + 40 * v35);
              }
              else
              {
                uint64_t v65 = v37;
                int64_t v41 = (v80[1] - v80[0]) / 40;
                uint64_t v42 = (KB::String *)((char *)v39 + 40 * v41);
                uint64_t v43 = 40 * v41;
                uint64_t v44 = v39;
                do
                {
                  BOOL v45 = KB::String::String(v44, v40);
                  *((_DWORD *)v45 + 8) = *((_DWORD *)v40 + 8);
                  uint64_t v44 = (KB::String *)((char *)v45 + 40);
                  BOOL v40 = (KB::String *)((char *)v40 + 40);
                  v43 -= 40;
                }
                while (v43);
                int64x2_t v46 = *(int64x2_t *)v80;
                uint64_t v37 = v65;
              }
              unsigned int v47 = v81;
              unsigned int v90 = v79;
              uint64_t v79 = v38;
              v80[0] = v39;
              int64x2_t v91 = v46;
              v80[1] = v42;
              int v81 = (char *)v38 + 40 * v37;
              uint64_t v92 = v47;
              std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v90);
              unint64_t v31 = v80[1];
              a6 = v66;
            }
            else
            {
              uint64_t v32 = v24 + 2;
              if (v24 >= -1) {
                uint64_t v32 = v24 + 1;
              }
              uint64_t v33 = -5 * (v32 >> 1);
              unint64_t v31 = std::__unwrap_and_dispatch[abi:nn180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,KB::Input *,KB::Input *,KB::Input *,0>(v31, v31, (KB::String *)((char *)v31 - 40 * (v32 >> 1)));
              v80[0] = (KB::String *)((char *)v80[0] + 8 * v33);
              v80[1] = v31;
            }
          }
          uint64_t v48 = KB::String::String(v31, (const KB::String *)v83);
          *((_DWORD *)v48 + 8) = v85;
          v80[1] = (KB::String *)((char *)v80[1] + 40);
          std::vector<KB::Input>::__swap_out_circular_buffer(v12, &v79, v21);
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v79);
        }
        else if (v21 == (const KB::String *)v22)
        {
          KB::String::String(v21, (const KB::String *)v83);
          *((_DWORD *)v23 + 2 * ((v21 - v23) >> 3) + 8) = v85;
          *(void *)(a1 + 16) = (char *)v21 + 40;
        }
        else
        {
          std::vector<KB::Input>::__move_range((uint64_t)v12, (uint64_t)v21, v22, (uint64_t)v21 + 40);
          if (v21 != (const KB::String *)v83)
          {
            KB::String::operator=(v21, (KB::String *)v83);
            *((_DWORD *)v23 + 2 * ((v21 - v23) >> 3) + 8) = v85;
          }
        }
        if (v84 && v83[6] == 1) {
          free(v84);
        }
        ++*(_DWORD *)(a1 + 96);
        if (v87 && v86[6] == 1) {
          free(v87);
        }
        KB::String::iterator::operator++(&v73);
      }
      while (v74 != v70);
      int v20 = *(_DWORD *)(a1 + 96);
      a5 = v64;
      a4 = a4;
    }
    uint64_t v49 = *(void *)(a1 + 184);
    TIInputManager::input_substring((unsigned __int16 *)v12, 0, v20, (uint64_t)&v90);
    (*(void (**)(KB::String **__return_ptr, uint64_t, KB::String **, KB::String *, unsigned char *, uint64_t, unsigned __int16 *, uint64_t))(*(void *)v49 + 104))(&v79, v49, &v90, v68, v88, a4, a2, a6);
    if (v91.i64[0] && BYTE6(v90) == 1) {
      free((void *)v91.i64[0]);
    }
    if ((a6 & 1) == 0
      && (KB::String *)(v80[0] - v79) >= (KB::String *)5
      && *((_DWORD *)v80[0] - 1) == -1
      && *((_DWORD *)v80[0] - 2) == -1)
    {
      (*(void (**)(void))(**(void **)(a1 + 184) + 136))(*(void *)(a1 + 184));
    }
    if (v67 >= *(_DWORD *)(a1 + 96))
    {
      uint64_t v59 = v79;
      if (v79)
      {
LABEL_80:
        v80[0] = v59;
        operator delete(v59);
      }
    }
    else
    {
      unint64_t v51 = v67;
      unsigned int v52 = a5 & 0xFFFFFFFE;
      unint64_t v53 = *v12;
      uint64_t v54 = 40 * v67;
      do
      {
        BOOL has_uppercase_characters = KB::string_has_uppercase_characters((KB::String *)((char *)v53 + v54), v50);
        BOOL v56 = has_uppercase_characters;
        if (v54) {
          BOOL v57 = 0;
        }
        else {
          BOOL v57 = has_uppercase_characters;
        }
        if (((v52 == 2) & a6 & v57) != 0) {
          int v58 = has_uppercase_characters | 2;
        }
        else {
          int v58 = has_uppercase_characters;
        }
        uint64_t v59 = v79;
        if (v51 < (v80[0] - v79) >> 2)
        {
          uint64_t v60 = *((unsigned int *)v79 + v51);
          if (v60 != -1)
          {
            unsigned int v61 = __p.__begin_[v60];
            if (v56) {
              int v62 = v61 & 0x12;
            }
            else {
              int v62 = 0;
            }
            int v63 = v61 & 0x2C | v58 | v62;
            if ((v58 & ((v61 & 1) == 0)) != 0) {
              int v58 = v63 | 0x10;
            }
            else {
              int v58 = v63;
            }
          }
        }
        unint64_t v53 = *(KB::String **)(a1 + 8);
        *(_DWORD *)((char *)v53 + v54 + 32) = v58;
        ++v51;
        v54 += 40;
      }
      while (v51 < *(unsigned int *)(a1 + 96));
      if (v59) {
        goto LABEL_80;
      }
    }
    std::vector<unsigned int>::pointer begin = __p.__begin_;
    if (__p.__begin_) {
      goto LABEL_82;
    }
    goto LABEL_83;
  }
  (*(void (**)(void *__return_ptr))(**(void **)(a1 + 184) + 104))(v78);
  std::vector<unsigned int>::pointer begin = (std::vector<unsigned int>::pointer)v78[0];
  if (v78[0])
  {
    v78[1] = v78[0];
LABEL_82:
    operator delete(begin);
  }
LABEL_83:
  LODWORD(v90) = 0x100000;
  WORD2(v90) = 0;
  BYTE6(v90) = 0;
  v91.i64[0] = 0;
  v91.i8[8] = 0;
  KB::String::operator=((KB::String *)(*(void *)(*(void *)(a1 + 224) + 24) + 56), (KB::String *)&v90);
  if (v91.i64[0] && BYTE6(v90) == 1) {
    free((void *)v91.i64[0]);
  }
  LODWORD(v90) = 0x100000;
  WORD2(v90) = 0;
  BYTE6(v90) = 0;
  v91.i64[0] = 0;
  v91.i8[8] = 0;
  KB::String::operator=((KB::String *)(a1 + 32), (KB::String *)&v90);
  if (v91.i64[0] && BYTE6(v90) == 1) {
    free((void *)v91.i64[0]);
  }
  if (v89)
  {
    if (v88[6] == 1) {
      free(v89);
    }
  }
}

uint64_t TIInputManager::user_frequency(TIInputManager *this, const String *a2)
{
  return (*(uint64_t (**)(void, const String *))(**(void **)(*((void *)this + 28) + 24) + 64))(*(void *)(*((void *)this + 28) + 24), a2);
}

uint64_t TIInputManager::set_autoshift(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 8);
  if (-858993459 * ((unint64_t)(*(void *)(this + 16) - v2) >> 3))
  {
    int v3 = *(_DWORD *)(v2 + 32);
    unsigned int v4 = v3 & 0xFFFFFFFD;
    if ((v3 & a2) != 0) {
      int v5 = 2;
    }
    else {
      int v5 = 0;
    }
    *(_DWORD *)(v2 + 32) = v5 | v4;
  }
  return this;
}

uint64_t TIInputManager::is_uppercase(TIInputManager *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (-858993459 * ((unint64_t)(*((void *)this + 2) - v2) >> 3) <= a2) {
    return 0;
  }
  else {
    return *(unsigned char *)(v2 + 40 * a2 + 32) & 1;
  }
}

BOOL TIInputManager::is_first_character_explicitly_shifted(TIInputManager *this)
{
  uint64_t v1 = *((void *)this + 1);
  return -858993459 * ((unint64_t)(*((void *)this + 2) - v1) >> 3)
      && (*(_DWORD *)(v1 + 32) & 3) == 1;
}

void TIInputManager::autocorrection(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  (*(void (**)(const KB::Candidate **__return_ptr))(*(void *)a1 + 16))(v5);
  if (v5[1] == v5[0])
  {
    bzero(a2, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)a2);
  }
  else
  {
    KB::Candidate::Candidate((KB::Candidate *)a2, v5[0]);
  }
  if (v9) {
    BOOL v3 = v8[38] == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    free(v9);
  }
  unsigned int v4 = (const KB::Candidate **)v8;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v4);
  unsigned int v4 = (const KB::Candidate **)&v7;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v4);
  unsigned int v4 = (const KB::Candidate **)&v6;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v4);
  unsigned int v4 = v5;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v4);
}

uint64_t TIInputManager::register_inline_completion_acceptance_rejection(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 184) + 88))();
}

uint64_t TIInputManager::user_dictionary(TIInputManager *this)
{
  uint64_t v1 = *(void *)(*(void *)(*((void *)this + 28) + 24) + 24);
  if (v1) {
    return *(void *)v1;
  }
  else {
    return 0;
  }
}

KB::UserDictionary *TIInputManager::single_character_completions_for_shortcut_prefix@<X0>(KB::UserDictionary *this@<X0>, const KB::String *a2@<X1>, uint64_t a3@<X8>)
{
  BOOL v3 = *(KB::UserDictionary ***)(*(void *)(*((void *)this + 28) + 24) + 24);
  if (v3)
  {
    this = *v3;
    if (*v3) {
      return (KB::UserDictionary *)KB::UserDictionary::single_character_completions_for_shortcut_prefix(this, a2, a3);
    }
  }
  *(_DWORD *)a3 = 0x100000;
  *(_WORD *)(a3 + 4) = 0;
  *(unsigned char *)(a3 + 6) = 0;
  *(void *)(a3 + 8) = 0;
  *(unsigned char *)(a3 + 16) = 0;
  return this;
}

uint64_t TIInputManager::maximum_shortcut_length(TIInputManager *this)
{
  uint64_t v1 = *(uint64_t **)(*(void *)(*((void *)this + 28) + 24) + 24);
  if (v1 && (uint64_t v2 = *v1) != 0) {
    return *(unsigned int *)(v2 + 88);
  }
  else {
    return 0;
  }
}

BOOL TIInputManager::has_user_explicit_shift(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1] - *a1;
  if (!v2) {
    return 0;
  }
  unint64_t v3 = 0;
  unint64_t v4 = v2 >> 2;
  unsigned int v5 = 1;
  do
  {
    BOOL v6 = (*(_DWORD *)(v1 + 4 * v3) & 0x13) == 1;
    BOOL result = v6;
    unint64_t v3 = v5++;
  }
  while (!v6 && v4 > v3);
  return result;
}

void TIInputManager::word_from_supplemental_lexicon(TIInputManager *this@<X0>, unsigned char *a2@<X8>)
{
}

uint64_t TIInputManager::apply_custom_conversions(TIInputManager *this, CandidateCollection *a2)
{
  uint64_t result = *((void *)this + 68);
  if (result) {
    return (*(uint64_t (**)(uint64_t, CandidateCollection *))(*(void *)result + 64))(result, a2);
  }
  return result;
}

uint64_t TIInputManager::should_correct_explicitly_shifted_word(TIInputManager *this)
{
  uint64_t v1 = *((void *)this + 68);
  if (v1) {
    return (*(uint64_t (**)(void))(*(void *)v1 + 40))();
  }
  else {
    return 1;
  }
}

uint64_t TIInputManager::should_promote_case_variants_of_top_candidate(TIInputManager *this)
{
  uint64_t result = *((void *)this + 68);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void TIInputManager::drop_input_prefix_and_update_autocorrection_engine(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 184);
  uint64_t v7 = a1 + 432;
  __int16 v8 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v9);
  (*(void (**)(uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v6 + 144))(v6, v7, v9, *(unsigned int *)(a1 + 96), -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
  if (v11 && v10 == 1) {
    free(v11);
  }
  TIInputManager::input_substring(v8, 0, a2, (uint64_t)v9);
  std::vector<KB::Input>::erase((uint64_t)v8, *(KB::String **)(a1 + 8), (KB::String *)(*(void *)(a1 + 8) + 40 * a2));
  *(_DWORD *)(a1 + 96) -= a2;
  *(uint32x2_t *)(a1 + 172) = vqsub_u32(*(uint32x2_t *)(a1 + 172), (uint32x2_t)vdup_n_s32(a2));
  KB::String::clear((KB::String *)(a1 + 64));
  (*(void (**)(uint64_t))(a3 + 16))(a3);
  (*(void (**)(void, uint64_t, uint64_t, unsigned char *))(**(void **)(a1 + 184) + 128))(*(void *)(a1 + 184), v7, a2, v9);
  if (v11)
  {
    if (v10 == 1) {
      free(v11);
    }
  }
}

uint64_t TIInputManager::input_context(TIInputManager *this)
{
  return (uint64_t)this + 400;
}

uint64_t TIInputManager::set_input_context(TIInputManager *this, const KB::String *a2, const KB::LanguageModelContext *a3)
{
  KB::String::operator=((TIInputManager *)((char *)this + 400), a2);

  return KB::LanguageModelContext::operator=((uint64_t)this + 432, (uint64_t *)a3);
}

void TIInputManager::sync_with_input_from_UI(TIInputManager *this)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 23);
  unint64_t v3 = (char *)this + 432;
  TIInputManager::input_substring((unsigned __int16 *)this + 4, 0, *((_DWORD *)this + 24), (uint64_t)v4);
  (*(void (**)(uint64_t, char *, unsigned char *, void, void))(*(void *)v2 + 144))(v2, v3, v4, *((unsigned int *)this + 24), -858993459 * ((*((void *)this + 2) - *((void *)this + 1)) >> 3));
  if (v5)
  {
    if (v4[6] == 1) {
      free(v5);
    }
  }
}

void TIInputManager::tokenize_input_context(const KB::String *a1@<X1>, void *a2@<X8>)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  __int16 v5 = 0;
  char v6 = 0;
  uint64_t v7 = " \n\t";
  int v4 = 1048579;
  char v8 = 0;
  KB::string_split_after((unsigned __int16 *)a1, (const KB::String *)&v4, a2);
  if (v7) {
    BOOL v3 = v6 == 1;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3) {
    free(v7);
  }
}

unsigned int *TIInputManager::set_typing_model(TIInputManager *this, unsigned int **a2)
{
  BOOL v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *((void *)this + 68);
  if (v4)
  {
    __int16 v5 = *(atomic_uint **)TIInputManager::favonius_layout(this);
    char v11 = v5;
    if (v5) {
      atomic_fetch_add(v5, 1u);
    }
    (*(void (**)(unsigned int **__return_ptr, uint64_t, atomic_uint **))(*(void *)v4 + 16))(&v12, v4, &v11);
    (*(void (**)(unsigned int *, unsigned int **))(*(void *)v3 + 24))(v3, &v12);
    if (v12)
    {
      unsigned int v6 = atomic_load(v12 + 2);
      if (v6 == 1) {
        (*(void (**)(void))(*(void *)v12 + 8))();
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v12 + 2, 0xFFFFFFFF);
      }
    }
    if (v11) {
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref((uint64_t)v11);
    }
  }
  uint64_t v7 = *((void *)this + 23);
  char v10 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(void *)v7 + 176))(v7, &v10);
  uint64_t result = v10;
  if (v10)
  {
    unsigned int v9 = atomic_load(v10 + 2);
    if (v9 == 1) {
      return (unsigned int *)(*(uint64_t (**)(void))(*(void *)v10 + 40))();
    }
    else {
      atomic_fetch_add((atomic_uint *volatile)v10 + 2, 0xFFFFFFFF);
    }
  }
  return result;
}

uint64_t TIInputManager::set_candidate_generator(uint64_t a1, unsigned int **a2)
{
  uint64_t v2 = *(void *)(a1 + 184);
  BOOL v3 = *a2;
  *a2 = 0;
  unsigned int v6 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(void *)v2 + 192))(v2, &v6);
  uint64_t result = (uint64_t)v6;
  if (v6)
  {
    unsigned int v5 = atomic_load(v6 + 2);
    if (v5 == 1) {
      return (*(uint64_t (**)(void))(*(void *)v6 + 8))();
    }
    else {
      atomic_fetch_add((atomic_uint *volatile)v6 + 2, 0xFFFFFFFF);
    }
  }
  return result;
}

void TIInputManager::set_candidate_refinery(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *(void *)(a1 + 184);
  BOOL v3 = (std::__shared_weak_count *)a2[1];
  uint64_t v4 = *a2;
  unsigned int v5 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v2 + 208))(v2, &v4);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v5);
  }
}

uint64_t TIInputManager::set_search_algorithm(uint64_t a1, unsigned int **a2)
{
  uint64_t v2 = *(void *)(a1 + 184);
  BOOL v3 = *a2;
  *a2 = 0;
  unsigned int v6 = v3;
  (*(void (**)(uint64_t, unsigned int **))(*(void *)v2 + 224))(v2, &v6);
  uint64_t result = (uint64_t)v6;
  if (v6)
  {
    unsigned int v5 = atomic_load(v6 + 2);
    if (v5 == 1) {
      return (*(uint64_t (**)(void))(*(void *)v6 + 16))();
    }
    else {
      atomic_fetch_add((atomic_uint *volatile)v6 + 2, 0xFFFFFFFF);
    }
  }
  return result;
}

void TIInputManager::set_word_medial_punctuation_predicate(uint64_t a1, void *aBlock)
{
  uint64_t v4 = *(const void **)(a1 + 560);
  if (aBlock) {
    _Block_copy(aBlock);
  }
  *(void *)(a1 + 560) = aBlock;
  if (v4)
  {
    _Block_release(v4);
  }
}

BOOL TIInputManager::candidate_contains_space(TIInputManager *this, const KB::Candidate *a2)
{
  uint64_t v3 = *((unsigned __int16 *)this + 444);
  if (*((_WORD *)this + 444))
  {
    uint64_t v4 = (char *)*((void *)this + 112);
    if (!v4) {
      uint64_t v4 = (char *)this + 904;
    }
  }
  else
  {
    KB::Candidate::compute_string(this);
    uint64_t v3 = *((unsigned __int16 *)this + 444);
    uint64_t v4 = (char *)*((void *)this + 112);
    if (!v4) {
      uint64_t v4 = (char *)this + 904;
    }
    if (!*((_WORD *)this + 444))
    {
      unsigned int v5 = v4;
      return v5 - v4 != v3;
    }
  }
  unsigned int v5 = v4;
  while (*v5 != 32)
  {
    if (++v5 == &v4[v3])
    {
      unsigned int v5 = &v4[v3];
      return v5 - v4 != v3;
    }
  }
  return v5 - v4 != v3;
}

uint64_t TIInputManager::period_ends_sentence_after_word(TIInputManager *this, const KB::String *a2, uint64_t a3)
{
  KB::DictionaryContainer::lookup(*((void *)this + 28), &v28);
  uint64_t v6 = (uint64_t)v28;
  uint64_t v7 = v29;
  if (v28 != v29)
  {
    while (1)
    {
      char v30 = (KB::Word **)&unk_1F3F77D18;
      uint64_t v31 = 1;
      if (!KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v30, (const KB::String *)v6, a2, 0, 0))break; {
      v6 += 240;
      }
      if ((KB::Word *)v6 == v7)
      {
        uint64_t v6 = (uint64_t)v7;
        goto LABEL_10;
      }
    }
    if ((KB::Word *)v6 != v7)
    {
      for (uint64_t i = v6 + 240; (KB::Word *)i != v7; i += 240)
      {
        char v30 = (KB::Word **)&unk_1F3F77D18;
        uint64_t v31 = 1;
        if (KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)&v30, (const KB::String *)i, a2, 0, 0))
        {
          KB::String::operator=(v6, (KB::String *)i);
          KB::ByteString::operator=((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)(i + 32));
          uint64_t v9 = *(void *)(i + 48);
          *(_DWORD *)(v6 + 56) = *(_DWORD *)(i + 56);
          *(void *)(v6 + 48) = v9;
          KB::String::operator=(v6 + 64, (KB::String *)(i + 64));
          long long v10 = *(_OWORD *)(i + 96);
          long long v11 = *(_OWORD *)(i + 112);
          long long v12 = *(_OWORD *)(i + 144);
          *(_OWORD *)(v6 + 128) = *(_OWORD *)(i + 128);
          *(_OWORD *)(v6 + 144) = v12;
          *(_OWORD *)(v6 + 96) = v10;
          *(_OWORD *)(v6 + 112) = v11;
          KB::String::operator=(v6 + 160, (KB::String *)(i + 160));
          *(unsigned char *)(v6 + 192) = *(unsigned char *)(i + 192);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v6 + 200, (uint64_t *)(i + 200));
          v6 += 240;
        }
      }
    }
  }
LABEL_10:
  std::vector<KB::Word>::erase((uint64_t)&v28, v6, v29);
  if (v28 == v29)
  {
    char v24 = 1;
  }
  else
  {
    int v14 = KB::string_capitalization(a2, v13);
    unsigned int v15 = v28;
    unsigned int v16 = v29;
    if (v28 == v29)
    {
      uint64_t v26 = 0;
      goto LABEL_30;
    }
    int v17 = v14;
    char v18 = 0;
    char v19 = 0;
    char v20 = 0;
    do
    {
      BOOL v21 = (a3 & 1) != 0 || *((_DWORD *)v15 + 30) == v17;
      if ((*((unsigned char *)v15 + 104) & 0x40) == 0)
      {
        int v22 = KB::String::last(v15);
        BOOL v23 = v22 != 46 && v21;
        v19 |= v23;
        v18 |= v22 != 46;
      }
      v20 |= v21;
      unsigned int v15 = (KB::Word *)((char *)v15 + 240);
    }
    while (v15 != v16);
    if (v20) {
      char v24 = v19;
    }
    else {
      char v24 = v18;
    }
  }
  uint64_t v25 = *((void *)this + 68);
  uint64_t v26 = (v25 == 0) & v24;
  if (v25 && (v24 & 1) != 0) {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, const KB::String *, uint64_t))(*(void *)v25 + 32))(v25, a2, a3);
  }
LABEL_30:
  char v30 = &v28;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v30);
  return v26;
}

unsigned char *TIInputManager::set_uses_text_checker(unsigned char *this, int a2)
{
  this[694] = a2;
  if (a2) {
    return _text_checker(1);
  }
  return this;
}

BOOL TIInputManager::has_continuous_path(TIInputManager *this)
{
  return *((_DWORD *)this + 98) >= 0;
}

uint64_t TIInputManager::has_unfinished_continuous_path(TIInputManager *this)
{
  return *((unsigned __int8 *)this + 396);
}

void TIInputManager::clear_continuous_path(TIInputManager *this)
{
  (*(void (**)(void))(**((void **)this + 23) + 352))(*((void *)this + 23));
  *((_DWORD *)this + 98) = -1;

  KB::ContinuousPathDetector::clear_completed_paths((uint64_t **)this + 41);
}

uint64_t TIInputManager::add_touch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 256)
    || (uint64_t v7 = *(void *)(a1 + 320)) == 0
    || ((*(void *)(v7 + 16) - *(void *)(v7 + 8)) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v6 = *(void *)(a1 + 184);
    TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)v9);
    (*(void (**)(uint64_t, uint64_t, unsigned char *, void, void))(*(void *)v6 + 144))(v6, a1 + 432, v9, *(unsigned int *)(a1 + 96), -858993459 * ((*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3));
    if (v10)
    {
      if (v9[6] == 1) {
        free(v10);
      }
    }
    TIInputManager::favonius_layout((TIInputManager *)a1);
    operator new();
  }
  return a5;
}

uint64_t TIInputManager::delete_from_favonius_stroke_history(TIInputManager *this)
{
  uint64_t v1 = *((void *)this + 23);
  uint64_t v2 = TIInputManager::favonius_layout(this);
  uint64_t v3 = *(uint64_t (**)(uint64_t, char *))(*(void *)v1 + 96);

  return v3(v1, v2);
}

void TIInputManager::clear_key_areas(TIInputManager *this)
{
  uint64_t v2 = *((void *)this + 40);
  *((void *)this + 40) = 0;
  if (v2) {
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v2);
  }
  if (*((void *)this + 34))
  {
    uint64_t v3 = *((void *)this + 32);
    if (v3)
    {
      uint64_t v4 = (uint64_t *)*((void *)this + 33);
      uint64_t v5 = 8 * v3;
      do
      {
        if (*v4) {
          WTF::RefCounted<TI::Favonius::Key>::deref(*v4);
        }
        ++v4;
        v5 -= 8;
      }
      while (v5);
      *((void *)this + 32) = 0;
    }
    uint64_t v6 = (void *)*((void *)this + 33);
    *((void *)this + 33) = 0;
    *((void *)this + 34) = 0;
    free(v6);
  }
}

uint64_t TIInputManager::register_key_area(uint64_t this, _LXLexicon *a2, CGRect a3)
{
  if (*(_WORD *)a2)
  {
    uint64_t v4 = this;
    uint64_t v5 = *(void *)(this + 320);
    *(void *)(v4 + 320) = 0;
    if (v5) {
      WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v5);
    }
    KB::CollatorWrapper::sortkey_for_string((KB::CollatorWrapper *)(*(void *)(*(void *)(v4 + 224) + 8) + 72), a2, &v6);
    operator new();
  }
  return this;
}

uint64_t TIInputManager::set_key_layout(uint64_t a1, atomic_uint **a2)
{
  uint64_t v4 = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = 0;
  if (v4) {
    WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(v4);
  }
  uint64_t v5 = *a2;
  if (*a2) {
    atomic_fetch_add(v5, 1u);
  }
  uint64_t result = *(void *)(a1 + 320);
  *(void *)(a1 + 320) = v5;
  if (result)
  {
    return WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref(result);
  }
  return result;
}

uint64_t TIInputManager::set_layout_uses_two_hands(uint64_t this, char a2)
{
  *(unsigned char *)(this + 280) = a2;
  uint64_t v2 = *(void *)(this + 320);
  if (v2) {
    *(unsigned char *)(v2 + 112) = a2;
  }
  return this;
}

KB::String *TIInputManager::set_layout_name(TIInputManager *this, const KB::String *a2)
{
  uint64_t result = KB::String::operator=((TIInputManager *)((char *)this + 288), a2);
  uint64_t v5 = *((void *)this + 40);
  if (v5)
  {
    return KB::String::operator=((KB::String *)(v5 + 208), a2);
  }
  return result;
}

atomic_uint *TIInputManager::commit_key_layout(TIInputManager *this)
{
  uint64_t result = (atomic_uint *)*((void *)this + 23);
  if (result)
  {
    uint64_t result = (atomic_uint *)(*(void *(**)(unsigned int **__return_ptr))(*(void *)result + 168))(&v10);
    uint64_t v3 = v10;
    if (v10)
    {
      unsigned int v4 = atomic_load(v10 + 2);
      if (v4 == 1) {
        uint64_t result = (atomic_uint *)(*(uint64_t (**)(unsigned int *))(*(void *)v10 + 40))(v10);
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v10 + 2, 0xFFFFFFFF);
      }
      uint64_t v5 = *((void *)this + 68);
      if (v5)
      {
        __int16 v6 = *(atomic_uint **)TIInputManager::favonius_layout(this);
        char v8 = v6;
        if (v6) {
          atomic_fetch_add(v6, 1u);
        }
        (*(void (**)(unsigned int **__return_ptr, uint64_t, atomic_uint **))(*(void *)v5 + 16))(&v9, v5, &v8);
        (*(void (**)(unsigned int *, unsigned int **))(*(void *)v3 + 24))(v3, &v9);
        if (v9)
        {
          unsigned int v7 = atomic_load(v9 + 2);
          if (v7 == 1) {
            (*(void (**)(void))(*(void *)v9 + 8))();
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v9 + 2, 0xFFFFFFFF);
          }
        }
        uint64_t result = v8;
        if (v8) {
          return (atomic_uint *)WTF::RefCounted<TI::Favonius::KeyboardLayout>::deref((uint64_t)v8);
        }
      }
    }
  }
  return result;
}

void TIInputManager::candidates_for_string(TIInputManager *a1, const KB::String *a2, int a3)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v3 = a3;
  TIInputManager::create_autocorrection_engine_with_synthetic_typing(a1, a2);
}

void std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5);
  unsigned int v7 = v6;
  uint64_t v8 = v5;
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = *(void **)v10;
  uint64_t v9 = v33;
  long long v34 = *(_OWORD *)(v10 + 8);
  uint64_t v11 = (unsigned char *)v34;
  *(void *)(v10 + 8) = 0;
  *(void *)(v10 + 16) = 0;
  *(void *)uint64_t v10 = 0;
  uint64_t v12 = *(void *)(v5 + 8);
  __dst = 0;
  uint64_t v62 = 0;
  std::vector<unsigned int> __p = 0;
  int64_t v13 = v11 - v9;
  if (v11 != v9)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&__p, v13 >> 3);
    int v14 = (char *)__dst;
    memmove(__dst, v9, v13);
    __dst = &v14[v13];
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v12 + 48))(&v63, v12, 4, &__p);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if (v63)
  {
    if (*(void *)(v12 + 568)) {
      CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    }
    else {
      CFMutableStringRef Mutable = 0;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v12 + 72))(&v81, v12, *(void *)(v8 + 16));
    KB::Candidate::Candidate((KB::Candidate *)v80, *(const KB::String **)(v8 + 16), *(_DWORD *)(v12 + 248));
    char v16 = v83;
    if (v83)
    {
      KB::Candidate::Candidate((KB::Candidate *)v78, (const KB::String *)&v81, *(_DWORD *)(v12 + 248));
      char v16 = 1;
    }
    else
    {
      v78[0] = 0;
    }
    char v79 = v16;
    uint64_t v17 = *(void *)(v8 + 16);
    unsigned int v18 = *(unsigned __int16 *)(v17 + 4);
    if (*(_WORD *)(v17 + 4)
      || (KB::String::compute_length(*(unsigned __int16 **)(v8 + 16)),
          unsigned int v18 = *(unsigned __int16 *)(v17 + 4),
          *(_WORD *)(v17 + 4)))
    {
      char v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
      bzero(v19, 4 * v18);
      char v20 = &v19[4 * v18];
    }
    else
    {
      char v20 = 0;
      char v19 = 0;
    }
    long long v55 = 0u;
    long long v56 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v57);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v58);
    memset(v59, 0, 24);
    bzero(v77, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v77);
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v49, v7);
    KB::Candidate::Candidate((KB::Candidate *)v74, (const KB::Candidate *)v80);
    v72[0] = 0;
    char v73 = 0;
    if (v79)
    {
      KB::Candidate::Candidate((KB::Candidate *)v72, (const KB::Candidate *)v78);
      char v73 = 1;
    }
    int64x2_t v46 = 0;
    unsigned int v47 = 0;
    uint64_t v48 = 0;
    int64_t v21 = v20 - v19;
    if (v21)
    {
      if (v21 < 0) {
        abort();
      }
      int64x2_t v46 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v21 >> 2);
      uint64_t v48 = (char *)v46 + 4 * v22;
      memmove(v46, v19, v21);
      unsigned int v47 = (char *)v46 + v21;
    }
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v39, (const KB::LanguageModelContext *)&v53);
    KB::String::String((KB::String *)v70, *(const KB::String **)(v8 + 24));
    KB::Candidate::Candidate((KB::Candidate *)v69, (const KB::Candidate *)v77);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v75, (uint64_t)v74, (const KB::Candidate *)v72, (uint64_t)&v46, (uint64_t)v39, (KB::String *)v70, (uint64_t)v69, 4);
    KB::Candidate::~Candidate((KB::Candidate *)v69);
    if (v71 && v70[6] == 1) {
      free(v71);
    }
    v38[0] = (void **)&v45;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v38);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v44);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v43);
    if (v41)
    {
      uint64_t v42 = v41;
      operator delete(v41);
    }
    if (v40) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v40);
    }
    if (v46)
    {
      unsigned int v47 = (char *)v46;
      operator delete(v46);
    }
    if (v73) {
      KB::Candidate::~Candidate((KB::Candidate *)v72);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v74);
    char v76 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    BOOL v23 = *(const void **)(v12 + 136);
    int v24 = *(_DWORD *)(v12 + 248);
    uint64_t v25 = *(unsigned int **)(v12 + 224);
    uint64_t v37 = v25;
    if (v25) {
      atomic_fetch_add((atomic_uint *volatile)v25, 1u);
    }
    uint64_t v26 = *(std::__shared_weak_count **)(v12 + 240);
    uint64_t v35 = *(void *)(v12 + 232);
    unint64_t v36 = v26;
    if (v26) {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v38, v23, v24, (uint64_t *)&v37, (uint64_t)&v35, *(const void **)(v12 + 560), v12 + 592, Mutable);
    if (v36) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v36);
    }
    if (v37) {
      WTF::RefCounted<KB::DictionaryContainer>::deref(v37);
    }
    (*(void (**)(uint64_t, const KB::Candidate **, void ***, void ***))(*(void *)v63 + 24))(v63, v7, v75, v38);
    unsigned int v67 = 0;
    uint64_t v66 = 0;
    uint64_t v68 = 0;
    TIInputManager::apply_case_changes((unsigned __int8 *)v12, (uint64_t)v7, (unsigned __int16 *)&v66, 0, **(unsigned int **)(v8 + 32), 0);
    CFTypeRef cf = &v66;
    std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)&cf);
    TIInputManager::apply_shortcut_conversions((TIInputManager *)v12, (KB::CandidateCollection *)v7, v27, 0);
    if (*(void *)(v12 + 568))
    {
      int v28 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)&v33);
      uint64_t v29 = (const KB::String *)&kGenericFlagDesc;
      if (v28 == 1) {
        uint64_t v29 = (const KB::String *)&kPostLMFlagDesc;
      }
      if (v28) {
        char v30 = v29;
      }
      else {
        char v30 = (const KB::String *)&kPreLMFlagDesc;
      }
      KB::String::String((KB::String *)&v66, v30);
      uint64_t v31 = *(void *)(v12 + 568);
      uint64_t v32 = *(void *)(v8 + 16);
      CFTypeRef cf = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t *, unsigned char *, CFMutableStringRef, const KB::Candidate **, CFTypeRef *))(*(void *)v31 + 24))(v31, v32, 4, &v66, v49, Mutable, v7, &cf);
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef cf = 0;
      if (v67 && BYTE6(v66) == 1) {
        free(v67);
      }
    }
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v38);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v75);
    v75[0] = (void **)&v52;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v75);
    v75[0] = (void **)&v51;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v75);
    v75[0] = (void **)&v50;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v75);
    v75[0] = (void **)v49;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v75);
    KB::Candidate::~Candidate((KB::Candidate *)v77);
    v75[0] = v59;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v75);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v58);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v57);
    if ((void)v54)
    {
      *((void *)&v54 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v54;
      operator delete((void *)v54);
    }
    if (*((void *)&v53 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v53 + 1));
    }
    if (v19) {
      operator delete(v19);
    }
    if (v79) {
      KB::Candidate::~Candidate((KB::Candidate *)v78);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v80);
    if (v83 && v82 && BYTE6(v81) == 1) {
      free(v82);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  if (v64) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v64);
  }
  if (v33) {
    operator delete(v33);
  }
}

__n128 std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73CD8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F3F73CD8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0,std::allocator<TIInputManager::candidates_for_string(KB::String const&,TIShiftContext)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
}

void TIInputManager::predictions_for_string(TIInputManager *a1, uint64_t a2, int a3)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  int v3 = a3;
  TIInputManager::create_autocorrection_engine(a1);
}

void std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = MEMORY[0x1F4188790](a1, a2, a3, a4, a5);
  uint64_t v58 = v6;
  uint64_t v7 = v5;
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  uint64_t v59 = *(void **)v9;
  uint64_t v8 = v59;
  long long v60 = *(_OWORD *)(v9 + 8);
  uint64_t v10 = (unsigned char *)v60;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = 0;
  uint64_t v11 = *(void *)(v5 + 8);
  uint64_t v12 = **(unsigned int **)(v5 + 16);
  uint64_t v98 = 0;
  std::vector<unsigned int> __p = 0;
  __dst = 0;
  int64_t v13 = v10 - v8;
  if (v10 != v8)
  {
    std::vector<KB::FilterFlag>::__vallocate[abi:nn180100](&__p, v13 >> 3);
    int v14 = (char *)__dst;
    memmove(__dst, v8, v13);
    __dst = &v14[v13];
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void **))(*(void *)v11 + 48))(&v99, v11, v12, &__p);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if (v99)
  {
    if (*(void *)(v11 + 568)) {
      CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    }
    else {
      CFMutableStringRef Mutable = 0;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v11 + 72))(&v116, v11, *(void *)(v7 + 24));
    KB::Candidate::Candidate((KB::Candidate *)v115, *(const KB::String **)(v7 + 24), *(_DWORD *)(v11 + 248));
    char v16 = v118;
    if (v118)
    {
      KB::Candidate::Candidate((KB::Candidate *)v113, (const KB::String *)&v116, *(_DWORD *)(v11 + 248));
      char v16 = 1;
    }
    else
    {
      v113[0] = 0;
    }
    char v114 = v16;
    uint64_t v17 = *(void *)(v7 + 24);
    unsigned int v18 = *(unsigned __int16 *)(v17 + 4);
    if (*(_WORD *)(v17 + 4)
      || (KB::String::compute_length(*(unsigned __int16 **)(v7 + 24)),
          unsigned int v18 = *(unsigned __int16 *)(v17 + 4),
          *(_WORD *)(v17 + 4)))
    {
      char v19 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v18);
      bzero(v19, 4 * v18);
      char v20 = &v19[4 * v18];
    }
    else
    {
      char v20 = 0;
      char v19 = 0;
    }
    int64_t v21 = *(const void **)(v11 + 136);
    int v22 = *(_DWORD *)(v11 + 248);
    BOOL v23 = *(unsigned int **)(v11 + 224);
    uint64_t v94 = v23;
    if (v23) {
      atomic_fetch_add((atomic_uint *volatile)v23, 1u);
    }
    int v24 = *(std::__shared_weak_count **)(v11 + 240);
    uint64_t v92 = *(void *)(v11 + 232);
    uint64_t v93 = v24;
    if (v24) {
      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    KB::CandidateFilterResources::CandidateFilterResources((uint64_t)v95, v21, v22, (uint64_t *)&v94, (uint64_t)&v92, *(const void **)(v11 + 560), v11 + 592, Mutable);
    if (v93) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v93);
    }
    if (v94) {
      WTF::RefCounted<KB::DictionaryContainer>::deref(v94);
    }
    KB::CandidateCollection::CandidateCollection((KB::CandidateCollection *)v88, v58);
    long long v83 = 0u;
    long long v84 = 0u;
    long long v81 = 0u;
    long long v82 = 0u;
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v85);
    language_modeling::v1::LinguisticContext::LinguisticContext((language_modeling::v1::LinguisticContext *)&v86);
    memset(v87, 0, 24);
    bzero(v112, 0x3E8uLL);
    KB::Candidate::Candidate((KB::Candidate *)v112);
    int v25 = KB::String::last((KB::String *)(v11 + 400));
    KB::Candidate::Candidate((KB::Candidate *)v108, (const KB::Candidate *)v115);
    v106[0] = 0;
    char v107 = 0;
    if (v114)
    {
      KB::Candidate::Candidate((KB::Candidate *)v106, (const KB::Candidate *)v113);
      char v107 = 1;
    }
    char v78 = 0;
    char v79 = 0;
    char v80 = 0;
    int64_t v26 = v20 - v19;
    if (v20 != v19)
    {
      if (v20 - v19 < 0) {
LABEL_108:
      }
        abort();
      char v78 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned int>>(v26 >> 2);
      char v80 = (char *)v78 + 4 * v27;
      memmove(v78, v19, v26);
      char v79 = (char *)v78 + v26;
    }
    KB::LanguageModelContext::LanguageModelContext((KB::LanguageModelContext *)v71, (const KB::LanguageModelContext *)&v81);
    KB::String::String((KB::String *)v104, *(const KB::String **)(v7 + 32));
    KB::Candidate::Candidate((KB::Candidate *)v103, (const KB::Candidate *)v112);
    KB::CandidateFilterLookupContext::CandidateFilterLookupContext((uint64_t)v109, (uint64_t)v108, (const KB::Candidate *)v106, (uint64_t)&v78, (uint64_t)v71, (KB::String *)v104, (uint64_t)v103, **(_DWORD **)(v7 + 16));
    KB::Candidate::~Candidate((KB::Candidate *)v103);
    if (v105 && v104[6] == 1) {
      free(v105);
    }
    unint64_t v119 = (int64x2_t *)&v77;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v119);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v76);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v75);
    if (v73)
    {
      int v74 = v73;
      operator delete(v73);
    }
    if (v72) {
      std::__shared_weak_count::__release_shared[abi:nn180100](v72);
    }
    if (v78)
    {
      char v79 = (char *)v78;
      operator delete(v78);
    }
    if (v107) {
      KB::Candidate::~Candidate((KB::Candidate *)v106);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v108);
    char v111 = KB::SetInputHasSupplementalPrefixForScope::s_inputHasSupplementalPrefix;
    BOOL v110 = v25 == 46;
    (*(void (**)(uint64_t, const KB::Candidate **, void ***, unsigned char *))(*(void *)v99 + 24))(v99, v58, v109, v95);
    int64x2_t v69 = 0uLL;
    unint64_t v70 = 0;
    uint64_t v28 = *(void *)(v7 + 24);
    unsigned int v29 = *(unsigned __int16 *)(v28 + 4);
    if (!*(_WORD *)(v28 + 4))
    {
      KB::String::compute_length(*(unsigned __int16 **)(v7 + 24));
      unsigned int v29 = *(unsigned __int16 *)(v28 + 4);
    }
    std::vector<KB::Input>::reserve((KB::String **)&v69, v29);
    char v30 = *(unsigned __int16 **)(v7 + 24);
    uint64_t v31 = (const void *)*((void *)v30 + 1);
    if (!v31) {
      uint64_t v31 = v30 + 8;
    }
    CFTypeRef v65 = v31;
    int v66 = 0;
    int v67 = *v30;
    unsigned int v68 = 0;
    KB::String::iterator::initialize((uint64_t *)&v65);
    int v32 = *v30;
    uint64_t v33 = *((void *)v30 + 1);
    if (!v33) {
      uint64_t v33 = (uint64_t)(v30 + 8);
    }
    uint64_t v61 = v33;
    int v62 = v32;
    int v63 = v32;
    int v64 = 0;
    KB::String::iterator::initialize(&v61);
    if (v66 != v62)
    {
      do
      {
        KB::String::String((uint64_t)&cf, v68);
        if (v69.i64[1] >= v70)
        {
          unint64_t v36 = 0xCCCCCCCCCCCCCCCDLL * ((v69.i64[1] - v69.i64[0]) >> 3);
          unint64_t v37 = v36 + 1;
          if (v36 + 1 > 0x666666666666666) {
            goto LABEL_108;
          }
          if (0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3) > v37) {
            unint64_t v37 = 0x999999999999999ALL * ((uint64_t)(v70 - v69.i64[0]) >> 3);
          }
          if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v70 - v69.i64[0]) >> 3) >= 0x333333333333333) {
            unint64_t v38 = 0x666666666666666;
          }
          else {
            unint64_t v38 = v37;
          }
          uint64_t v122 = &v70;
          if (v38) {
            unint64_t v38 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::LikelihoodInfo>>(v38);
          }
          else {
            uint64_t v39 = 0;
          }
          BOOL v40 = (KB::String *)(v38 + 40 * v36);
          unint64_t v119 = (int64x2_t *)v38;
          v120.i64[0] = (uint64_t)v40;
          unint64_t v121 = v38 + 40 * v39;
          KB::String::String(v40, (const KB::String *)&cf);
          *((_DWORD *)v40 + 8) = 0;
          uint64_t v35 = (_DWORD *)((char *)v40 + 40);
          v120.i64[1] = (uint64_t)v35;
          uint64_t v41 = v69.i64[1];
          uint64_t v42 = v69.i64[0];
          uint64_t v43 = (KB::String *)v120.i64[0];
          if (v69.i64[1] == v69.i64[0])
          {
            int64x2_t v45 = vdupq_n_s64(v69.u64[1]);
          }
          else
          {
            do
            {
              uint64_t v44 = v43;
              uint64_t v43 = KB::String::String((KB::String *)((char *)v43 - 40), (const KB::String *)(v41 - 40));
              *((_DWORD *)v44 - 2) = *(_DWORD *)(v41 - 8);
              v41 -= 40;
            }
            while (v41 != v42);
            int64x2_t v45 = v69;
            uint64_t v35 = (_DWORD *)v120.i64[1];
          }
          v69.i64[0] = (uint64_t)v43;
          v69.i64[1] = (uint64_t)v35;
          int64x2_t v120 = v45;
          unint64_t v46 = v70;
          unint64_t v70 = v121;
          unint64_t v121 = v46;
          unint64_t v119 = (int64x2_t *)v45.i64[0];
          std::__split_buffer<KB::Input>::~__split_buffer((uint64_t)&v119);
        }
        else
        {
          long long v34 = KB::String::String((KB::String *)v69.i64[1], (const KB::String *)&cf);
          *((_DWORD *)v34 + 8) = 0;
          uint64_t v35 = (_DWORD *)((char *)v34 + 40);
        }
        v69.i64[1] = (uint64_t)v35;
        if (v102 && BYTE6(cf) == 1) {
          free(v102);
        }
        KB::String::iterator::operator++((uint64_t *)&v65);
      }
      while (v66 != v62);
      char v30 = *(unsigned __int16 **)(v7 + 24);
    }
    unsigned int v47 = *v30;
    if (*v30)
    {
      uint64_t v48 = (void **)*((void *)v30 + 1);
      if (!v48) {
        uint64_t v48 = (void **)(v30 + 8);
      }
      unint64_t v119 = (int64x2_t *)v48;
      v120.i32[0] = 0;
      *(uint64_t *)((char *)v120.i64 + 4) = v47;
      KB::String::iterator::initialize((uint64_t *)&v119);
      int v49 = u_isupper(v120.i32[2]);
      uint64_t v50 = v69.i64[0];
      if (v49) {
        *(_DWORD *)(v69.i64[0] + 32) = 3;
      }
    }
    else
    {
      uint64_t v50 = v69.i64[0];
    }
    TIInputManager::apply_case_changes((unsigned __int8 *)v11, (uint64_t)v58, (unsigned __int16 *)&v69, -858993459 * ((unint64_t)(v69.i64[1] - v50) >> 3), 0, 0);
    TIInputManager::apply_shortcut_conversions((TIInputManager *)v11, (KB::CandidateCollection *)v58, v51, 0);
    if (*(void *)(v11 + 568))
    {
      int v52 = KB::CandidateFilterFlags::candidate_filter_flag_type((unsigned int **)&v59);
      long long v53 = (const KB::String *)&kGenericFlagDesc;
      if (v52 == 1) {
        long long v53 = (const KB::String *)&kPostLMFlagDesc;
      }
      if (v52) {
        long long v54 = v53;
      }
      else {
        long long v54 = (const KB::String *)&kPreLMFlagDesc;
      }
      KB::String::String((KB::String *)&v119, v54);
      (*(void (**)(CFTypeRef *__return_ptr))(**(void **)(v11 + 184) + 488))(&cf);
      uint64_t v55 = *(void *)(v11 + 568);
      uint64_t v56 = *(void *)(v7 + 24);
      CFTypeRef v57 = cf;
      CFTypeRef v65 = cf;
      if (cf)
      {
        CFRetain(cf);
        CFTypeRef v65 = v57;
      }
      (*(void (**)(uint64_t, uint64_t, void, int64x2_t **, unsigned char *, CFMutableStringRef, const KB::Candidate **, CFTypeRef *))(*(void *)v55 + 24))(v55, v56, 0, &v119, v88, Mutable, v58, &v65);
      if (v65) {
        CFRelease(v65);
      }
      CFTypeRef v65 = 0;
      if (cf) {
        CFRelease(cf);
      }
      if (v120.i64[0] && BYTE6(v119) == 1) {
        free((void *)v120.i64[0]);
      }
    }
    unint64_t v119 = &v69;
    std::vector<KB::Input>::__destroy_vector::operator()[abi:nn180100]((void ***)&v119);
    KB::CandidateFilterLookupContext::~CandidateFilterLookupContext((KB::CandidateFilterLookupContext *)v109);
    KB::Candidate::~Candidate((KB::Candidate *)v112);
    v109[0] = (void **)v87;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](v109);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v86);
    language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&v85);
    if ((void)v82)
    {
      *((void *)&v82 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v82;
      operator delete((void *)v82);
    }
    if (*((void *)&v81 + 1)) {
      std::__shared_weak_count::__release_shared[abi:nn180100](*((std::__shared_weak_count **)&v81 + 1));
    }
    v109[0] = (void **)&v91;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v109);
    v109[0] = (void **)&v90;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v109);
    v109[0] = (void **)&v89;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v109);
    v109[0] = (void **)v88;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100](v109);
    KB::CandidateFilterResources::~CandidateFilterResources((KB::CandidateFilterResources *)v95);
    if (v19) {
      operator delete(v19);
    }
    if (v114) {
      KB::Candidate::~Candidate((KB::Candidate *)v113);
    }
    KB::Candidate::~Candidate((KB::Candidate *)v115);
    if (v118 && v117 && BYTE6(v116) == 1) {
      free(v117);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  if (v100) {
    std::__shared_weak_count::__release_shared[abi:nn180100](v100);
  }
  if (v59) {
    operator delete(v59);
  }
}

__n128 std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F73D20;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)uint64_t v2 = &unk_1F3F73D20;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0,std::allocator<TIInputManager::predictions_for_string(KB::String const&,KB::LookupType)::$_0>,void ()(KB::CandidateCollection &,KB::CandidateFilterFlags,BOOL)>::~__func()
{
}

void TIInputManager::phrase_candidates_for_string(TIInputManager *this@<X0>, const KB::String *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  KB::StaticDictionary::candidates_for_string(*(KB::StaticDictionary **)(*((void *)this + 28) + 16), a2, 0, (void *)a4);
  if (!a3
    || KB::SetOnlySearchSupplementalLexiconForScope::s_shouldOnlySearchSupplementalLexicon && *((_DWORD *)this + 134))
  {
    uint64_t v8 = *(void *)(a4 + 8) - *(void *)a4;
    KB::DynamicDictionary::retrieve_phrase_candidates(*(KB::DynamicDictionary **)(*((void *)this + 28) + 24), (unsigned __int16 *)a2);
    uint64_t v9 = *(KB::String **)(a4 + 8);
    uint64_t v10 = (KB::String *)(*(void *)a4 + v8);
    if (v10 != v9)
    {
      uint64_t v11 = *((void *)this + 28);
      uint64_t v12 = *(void *)(a4 + 8);
LABEL_6:
      KB::DictionaryContainer::lookup(v11, &v29);
      for (uint64_t i = v29; ; i += 120)
      {
        if (i == v30)
        {
          uint64_t v31 = &v29;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
          uint64_t v10 = (KB::String *)((char *)v10 + 240);
          if (v10 != v9) {
            goto LABEL_6;
          }
          goto LABEL_46;
        }
        if (!*((void *)i + 28)) {
          goto LABEL_49;
        }
        int v14 = (unsigned __int16 *)*((void *)i + 1);
        if (!v14) {
          int v14 = i + 8;
        }
        unsigned int v15 = (unsigned char *)*i;
        if (*i)
        {
          uint64_t v16 = *i;
          uint64_t v17 = v14;
          while (*v17 != 45)
          {
            ++v17;
            if (!--v16)
            {
              uint64_t v17 = &v15[(void)v14];
              break;
            }
          }
        }
        else
        {
          uint64_t v17 = v14;
        }
        if ((unsigned char *)(v17 - (unsigned char *)v14) == v15)
        {
LABEL_49:
          if ((i[53] & 4) != 0 || *((_DWORD *)i + 31)) {
            break;
          }
        }
      }
      uint64_t v31 = &v29;
      std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
      if (v10 == v9) {
        goto LABEL_46;
      }
      unsigned int v18 = (KB::String *)((char *)v10 + 240);
      if ((KB::String *)((char *)v10 + 240) != v9)
      {
        uint64_t v12 = (uint64_t)v10;
        do
        {
          char v19 = v18;
          KB::DictionaryContainer::lookup(v11, &v29);
          for (uint64_t j = v29; ; j += 120)
          {
            if (j == v30)
            {
              uint64_t v31 = &v29;
              std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
              KB::String::operator=(v12, v19);
              KB::ByteString::operator=((unsigned __int16 *)(v12 + 32), (unsigned __int16 *)v10 + 136);
              uint64_t v25 = *((void *)v10 + 36);
              *(_DWORD *)(v12 + 56) = *((_DWORD *)v10 + 74);
              *(void *)(v12 + 48) = v25;
              KB::String::operator=(v12 + 64, (KB::String *)((char *)v10 + 304));
              long long v26 = *((_OWORD *)v10 + 21);
              long long v27 = *((_OWORD *)v10 + 22);
              long long v28 = *((_OWORD *)v10 + 24);
              *(_OWORD *)(v12 + 128) = *((_OWORD *)v10 + 23);
              *(_OWORD *)(v12 + 144) = v28;
              *(_OWORD *)(v12 + 96) = v26;
              *(_OWORD *)(v12 + 112) = v27;
              KB::String::operator=(v12 + 160, (KB::String *)((char *)v10 + 400));
              *(unsigned char *)(v12 + 192) = *((unsigned char *)v10 + 432);
              std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__move_assign(v12 + 200, (uint64_t *)v10 + 55);
              v12 += 240;
              goto LABEL_43;
            }
            if (!*((void *)j + 28)) {
              goto LABEL_50;
            }
            int64_t v21 = (unsigned __int16 *)*((void *)j + 1);
            if (!v21) {
              int64_t v21 = j + 8;
            }
            int v22 = (unsigned char *)*j;
            if (*j)
            {
              uint64_t v23 = *j;
              int v24 = v21;
              while (*v24 != 45)
              {
                ++v24;
                if (!--v23)
                {
                  int v24 = &v22[(void)v21];
                  break;
                }
              }
            }
            else
            {
              int v24 = v21;
            }
            if ((unsigned char *)(v24 - (unsigned char *)v21) == v22)
            {
LABEL_50:
              if ((j[53] & 4) != 0 || *((_DWORD *)j + 31)) {
                break;
              }
            }
          }
          uint64_t v31 = &v29;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v31);
LABEL_43:
          unsigned int v18 = (KB::String *)((char *)v19 + 240);
          uint64_t v10 = v19;
        }
        while ((KB::String *)((char *)v19 + 240) != v9);
        goto LABEL_46;
      }
    }
    uint64_t v12 = (uint64_t)v10;
LABEL_46:
    std::vector<KB::Word>::erase(a4, v12, *(KB::Word **)(a4 + 8));
  }
}

void TIInputManager::phrase_completed_by_word(uint64_t a1@<X0>, KB::String *a2@<X1>, KB::String *a3@<X2>, int a4@<W3>, int a5@<W4>, int a6@<W5>, KB::Candidate *a7@<X8>)
{
  uint64_t j = a7;
  void v124[2] = *MEMORY[0x1E4F143B8];
  if (!*(_WORD *)a2)
  {
    bzero(a7, 0x3E8uLL);
    KB::Candidate::Candidate(j);
    return;
  }
  uint64_t v77 = (unsigned __int16 *)(a1 + 8);
  TIInputManager::input_substring((unsigned __int16 *)(a1 + 8), 0, *(_DWORD *)(a1 + 96), (uint64_t)buf);
  BOOL v82 = buf == (unsigned char *)a2 || KB::String::equal(a2, (const KB::String *)buf, 1);
  if (*(void *)&buf[8] && buf[6] == 1) {
    free(*(void **)&buf[8]);
  }
  TIInputManager::tokenize_input_context(a2, &v92);
  float v91 = 0.0;
  int v85 = 0;
  if ((KB::LanguageModelContext::is_linguistically_void((KB::LanguageModelContext *)(a1 + 432)) & 1) == 0)
  {
    uint64_t v13 = *(void *)(a1 + 232);
    if (v13 && (*(unsigned int (**)(uint64_t))(*(void *)v13 + 16))(v13)) {
      int v85 = (*(uint64_t (**)(void, uint64_t, float *))(**(void **)(a1 + 232) + 448))(*(void *)(a1 + 232), a1 + 432, &v91);
    }
    else {
      int v85 = 0;
    }
  }
  TIInputManager::tokenize_input_context((const KB::String *)(a1 + 400), &v88);
  unsigned int v14 = *(_DWORD *)(a1 + 536);
  unsigned int v15 = v88;
  char v79 = a3;
  long long v84 = (TIInputManager *)a1;
  int v76 = a6;
  int v78 = a5;
  if (v14)
  {
    uint64_t v16 = (unsigned __int16 *)v89;
    KB::String::String((uint64_t)buf, v14);
    if (v15 != (KB::String *)v16 && v15 != (KB::String *)buf)
    {
      do
      {
        if (KB::String::equal(v15, (const KB::String *)buf, 1)) {
          break;
        }
        unsigned int v15 = (KB::String *)((char *)v15 + 32);
        if (v15 == (KB::String *)v16) {
          break;
        }
      }
      while (v15 != (KB::String *)buf);
    }
    if (v15 != (KB::String *)v16)
    {
      for (uint64_t i = (KB::String *)((char *)v15 + 32); i != (KB::String *)v16; uint64_t i = (KB::String *)((char *)i + 32))
      {
        if (i != (KB::String *)buf && !KB::String::equal(i, (const KB::String *)buf, 1))
        {
          KB::String::operator=((uint64_t)v15, i);
          unsigned int v15 = (KB::String *)((char *)v15 + 32);
        }
      }
    }
    unsigned int v18 = (unsigned __int16 *)v89;
    if (v15 != v89)
    {
      while (v18 != (unsigned __int16 *)v15)
      {
        char v19 = (void *)*((void *)v18 - 3);
        if (v19 && *((unsigned char *)v18 - 26) == 1) {
          free(v19);
        }
        v18 -= 16;
      }
      uint64_t v89 = v15;
    }
    if (*(void *)&buf[8]) {
      BOOL v20 = buf[6] == 1;
    }
    else {
      BOOL v20 = 0;
    }
    if (v20) {
      free(*(void **)&buf[8]);
    }
    unsigned int v15 = v88;
  }
  int64_t v21 = v92;
  int v22 = v93;
  if (v93 - v92 < 1) {
    goto LABEL_80;
  }
  uint64_t v23 = (v93 - v92) >> 5;
  int v24 = (unsigned __int16 *)v89;
  uint64_t v25 = (v89 - v15) >> 5;
  long long v26 = (KB::String *)((char *)v15 + ((v89 - v15) & 0xFFFFFFFFFFFFFFE0));
  if (v23 > (v90 - (uint64_t)v89) >> 5)
  {
    unint64_t v27 = v25 + v23;
    if ((unint64_t)(v25 + v23) >> 59) {
      abort();
    }
    uint64_t v28 = v90 - (void)v15;
    if ((v90 - (uint64_t)v15) >> 4 > v27) {
      unint64_t v27 = v28 >> 4;
    }
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v29 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v29 = v27;
    }
    *(void *)&v103[8] = &v90;
    if (v29)
    {
      uint64_t v31 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<language_modeling::v1::Token>>(v29);
    }
    else
    {
      uint64_t v31 = 0;
      uint64_t v30 = 0;
    }
    unint64_t v37 = (KB::String *)&v31[32 * v25];
    *(void *)std::string buf = v31;
    *(void *)&uint8_t buf[8] = v37;
    *(void *)unint64_t v103 = &v31[32 * v30];
    uint64_t v38 = 32 * v23;
    uint64_t v39 = (uint64_t)v37 + 32 * v23;
    do
    {
      unint64_t v37 = (KB::String *)((char *)KB::String::String(v37, v21) + 32);
      int64_t v21 = (const KB::String *)((char *)v21 + 32);
      v38 -= 32;
    }
    while (v38);
    *(void *)&uint8_t buf[16] = v39;
    uint64_t v40 = *(void *)&buf[8];
    uint64_t v41 = v88;
    if (v88 != v26)
    {
      uint64_t v42 = *(void *)&buf[8] - 32;
      uint64_t v43 = v26;
      do
      {
        *(_DWORD *)uint64_t v42 = 0x100000;
        uint64_t v43 = (KB::String *)((char *)v43 - 32);
        *(_WORD *)(v42 + 4) = 0;
        *(unsigned char *)(v42 + 6) = 0;
        *(void *)(v42 + 8) = 0;
        uint64_t v40 = KB::String::operator=(v42, v43);
        uint64_t v42 = v40 - 32;
      }
      while (v43 != v41);
      uint64_t v39 = *(void *)&buf[16];
    }
    *(void *)&uint8_t buf[8] = v40;
    uint64_t v44 = (unsigned __int16 *)v89;
    if (v89 != v26)
    {
      do
      {
        *(_DWORD *)uint64_t v39 = 0x100000;
        *(_WORD *)(v39 + 4) = 0;
        *(unsigned char *)(v39 + 6) = 0;
        *(void *)(v39 + 8) = 0;
        KB::String::operator=(v39, v26);
        long long v26 = (KB::String *)((char *)v26 + 32);
        v39 += 32;
      }
      while (v26 != (KB::String *)v44);
      uint64_t v40 = *(void *)&buf[8];
      long long v26 = v89;
    }
    int64x2_t v45 = v88;
    uint64_t v46 = v90;
    int v88 = (KB::String *)v40;
    uint64_t v89 = (KB::String *)v39;
    uint64_t v90 = *(void *)v103;
    *(void *)&uint8_t buf[16] = v26;
    *(void *)unint64_t v103 = v46;
    *(void *)std::string buf = v45;
    *(void *)&uint8_t buf[8] = v45;
    std::__split_buffer<KB::String>::~__split_buffer((uint64_t)buf);
    goto LABEL_80;
  }
  char v80 = j;
  uint64_t v32 = v89 - v26;
  uint64_t v33 = (v89 - v26) >> 5;
  uint64_t v75 = (v89 - v15) >> 5;
  if (v33 >= v23)
  {
    long long v34 = (const KB::String *)((char *)v92 + 32 * v23);
    unint64_t v36 = v89;
LABEL_72:
    uint64_t v48 = (KB::String *)((char *)v26 + 32 * v23);
    int v49 = (KB::String *)((char *)v36 - 32 * v23);
    uint64_t v50 = (uint64_t)v36;
    if (v49 < (KB::String *)v24)
    {
      uint64_t v50 = (uint64_t)v36;
      do
      {
        *(_DWORD *)uint64_t v50 = 0x100000;
        *(_WORD *)(v50 + 4) = 0;
        *(unsigned char *)(v50 + 6) = 0;
        *(void *)(v50 + 8) = 0;
        uint64_t v51 = KB::String::operator=(v50, v49);
        int v49 = (KB::String *)((char *)v49 + 32);
        uint64_t v50 = v51 + 32;
      }
      while (v49 < (KB::String *)v24);
    }
    uint64_t v89 = (KB::String *)v50;
    if (v36 != v48)
    {
      uint64_t v52 = (uint64_t)v36 - 32;
      uint64_t v53 = 32 * ((v36 - v48) >> 5);
      do
      {
        uint64_t v52 = KB::String::operator=(v52, (KB::String *)((char *)v15 + 32 * v75 + v53 - 32)) - 32;
        v53 -= 32;
      }
      while (v53);
    }
    for (j = v80; v21 != v34; long long v26 = (KB::String *)((char *)v26 + 32))
    {
      KB::String::operator=(v26, v21);
      int64_t v21 = (const KB::String *)((char *)v21 + 32);
    }
    goto LABEL_80;
  }
  long long v34 = (const KB::String *)((char *)v92 + 32 * v33);
  if (v34 == v93)
  {
    unint64_t v36 = v89;
  }
  else
  {
    uint64_t v35 = (const KB::String *)((char *)v92 + 32 * v33);
    unint64_t v36 = v89;
    do
    {
      KB::String::String(v36, v35);
      uint64_t v35 = (const KB::String *)((char *)v35 + 32);
      unint64_t v36 = (KB::String *)((char *)v36 + 32);
    }
    while (v35 != v22);
  }
  uint64_t v89 = v36;
  BOOL v47 = v32 < 1;
  uint64_t j = v80;
  if (!v47) {
    goto LABEL_72;
  }
LABEL_80:
  if (v82) {
    unint64_t v54 = 1;
  }
  else {
    unint64_t v54 = (v93 - v92) >> 5;
  }
  if (v54 > 4)
  {
LABEL_154:
    bzero(j, 0x3E8uLL);
    KB::Candidate::Candidate(j);
    goto LABEL_155;
  }
  unint64_t v55 = 4;
  long long v81 = j;
  while (v55 > (v89 - v88) >> 5 || v55 == 1 && !v78)
  {
LABEL_153:
    if (v54 > --v55) {
      goto LABEL_154;
    }
  }
  *(_DWORD *)std::string buf = 0x100000;
  *(_WORD *)&uint8_t buf[4] = 0;
  buf[6] = 0;
  *(void *)&uint8_t buf[8] = 0;
  uint8_t buf[16] = 0;
  KB::string_join((unsigned __int16 *)v89 - 16 * v55, (unsigned __int16 *)v89, (const KB::String *)buf, (uint64_t)v121);
  if (*(void *)&buf[8] && buf[6] == 1) {
    free(*(void **)&buf[8]);
  }
  if (v123) {
    uint64_t v56 = v123;
  }
  else {
    uint64_t v56 = v124;
  }
  if (v121[0])
  {
    uint64_t v57 = v121[0];
    uint64_t v58 = v56;
    while (*v58 != 10)
    {
      ++v58;
      if (!--v57)
      {
        uint64_t v58 = (char *)v56 + v121[0];
        break;
      }
    }
  }
  else
  {
    uint64_t v58 = v56;
  }
  if (v58 - (unsigned char *)v56 != v121[0])
  {
    if (v123 && v122 == 1) {
      free(v123);
    }
    goto LABEL_153;
  }
  TIInputManager::phrase_candidates_for_string(v84, (const KB::String *)v121, v78, (uint64_t)&v86);
  if (v86 == v87) {
    goto LABEL_149;
  }
  if (v82)
  {
    KB::String::operator=(v79, (KB::String *)v121);
  }
  else
  {
    v115.unsigned int lexicon_id = 0x100000;
    LOWORD(v115.word_id) = 0;
    BYTE2(v115.word_id) = 0;
    uint64_t v116 = 0;
    char v117 = 0;
    KB::string_join((unsigned __int16 *)v89 - 16 * v55, (unsigned __int16 *)((char *)v89 + v92 - v93), (const KB::String *)&v115, (uint64_t)v118);
    TIInputManager::input_substring(v77, 0, *((_DWORD *)v84 + 24), (uint64_t)v112);
    KB::String::String((KB::String *)buf, (const KB::String *)v118);
    KB::String::append((unsigned __int16 *)buf, (const KB::String *)v112);
    KB::String::operator=((uint64_t)v79, (KB::String *)buf);
    if (*(void *)&buf[8] && buf[6] == 1) {
      free(*(void **)&buf[8]);
    }
    if (v114 && v113 == 1) {
      free(v114);
    }
    if (v120 && v119 == 1) {
      free(v120);
    }
    if (v116 && BYTE2(v115.word_id) == 1) {
      free(v116);
    }
  }
  uint64_t v59 = v86;
  uint64_t v60 = v87;
  if (v86 == v87)
  {
LABEL_149:
    *(void *)std::string buf = &v86;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
    if (v123)
    {
      if (v122 == 1) {
        free(v123);
      }
    }
    uint64_t j = v81;
    goto LABEL_153;
  }
  while (1)
  {
    *(void *)std::string buf = &unk_1F3F77D18;
    *(void *)&uint8_t buf[8] = 1;
    if (!KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)buf, (const KB::String *)v59, (const KB::String *)v121, 0, 0))goto LABEL_143; {
    uint64_t v62 = *(void *)(v59 + 136);
    }
    if (v85 != v62 && *(void *)(v59 + 136) != 0 && v85 != 0)
    {
      if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
      {
        int64x2_t v69 = "";
        if (*(_WORD *)v59)
        {
          int64x2_t v69 = *(const char **)(v59 + 8);
          if (!v69) {
            int64x2_t v69 = (const char *)(v59 + 16);
          }
        }
        *(_DWORD *)std::string buf = 136316162;
        *(void *)&uint8_t buf[4] = "phrase_completed_by_word";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = v69;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)unint64_t v103 = v62;
        *(_WORD *)&v103[4] = 1024;
        *(_DWORD *)&v103[6] = v85;
        *(_WORD *)&v103[10] = 2048;
        *(double *)&v103[12] = v91;
        _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Phrase candidate  %s was found but is not from the most probable lexicon (word.unsigned int lexicon_id = %d, current_unsigned int lexicon_id = %d; language confidence = %f)",
          buf,
          0x2Cu);
      }
      goto LABEL_143;
    }
    int v65 = *(_DWORD *)(v59 + 104);
    if ((v65 & 0x800012) != 0 || (*(_DWORD *)(v59 + 104) & 0x2080) == 0x80 || (v65 & 0x2042000) == 0x2000000)
    {
      if (a4)
      {
        KB::String::String((KB::String *)v94, v79);
        char v96 = 1;
        create_candidate_from_word(v81, v59, (const KB::String *)v94);
        if (!v96) {
          goto LABEL_178;
        }
        int v72 = v95;
        if (!v95) {
          goto LABEL_178;
        }
        int v73 = v94[6];
        goto LABEL_176;
      }
      goto LABEL_143;
    }
    if (!*((unsigned char *)v84 + 691))
    {
      unint64_t v70 = (const KB::String *)TILocaleIdentifierForLexiconID(*(void *)(v59 + 136));
      KB::string_to_lowercase((KB *)v59, v70, (KB::String *)v118);
      TITokenID v115 = *(TITokenID *)(v59 + 136);
      KB::Word::Word((KB::Word *)buf, (const KB::String *)v118, &v115, 0);
      if (v120 && v119 == 1) {
        free(v120);
      }
      int v105 = KB::string_capitalization(v79, v71);
      unsigned int v104 = v104 & 0xFFFFFFFE | (v105 == 1);
      KB::Word::capitalized_string((KB::Word *)buf, (uint64_t)v118);
      int v97 = 0x100000;
      __int16 v98 = 0;
      char v99 = 0;
      int32x2_t v100 = 0;
      KB::String::operator=((uint64_t)&v97, (KB::String *)v118);
      char v101 = 1;
      create_candidate_from_word(v81, v59, (const KB::String *)&v97);
      if (v101 && v100 && v99 == 1) {
        free(v100);
      }
      if (v120 && v119 == 1) {
        free(v120);
      }
      KB::Word::~Word((KB::Word *)buf);
      goto LABEL_178;
    }
    if (*(void *)(v59 + 224)
      && KB::CollatorWrapper::sortkey_starts_with((KB::CollatorWrapper *)(*(void *)(*((void *)v84 + 28) + 8) + 72), (_LXLexicon *)v59, (_LXLexicon *)v79))
    {
      break;
    }
    if (v55 == 1 && !*(_WORD *)v79)
    {
      TIInputManager::apply_shift_context_to_prediction(v84, v76, (KB::Word *)v59);
      goto LABEL_173;
    }
    int v66 = KB::string_capitalization(v79, v61);
    unsigned int v67 = *(_DWORD *)(v59 + 120);
    if ((v66 & ~v67) == 0) {
      goto LABEL_173;
    }
    if ((v66 & ~v67) == 1)
    {
      int v74 = *(_DWORD *)(v59 + 104);
      if ((v74 & 0x20) == 0)
      {
        *(_DWORD *)(v59 + 120) = v67 | 1;
        *(_DWORD *)(v59 + 104) = v74 & 0xFFFFFFFE | (v67 < 2);
      }
LABEL_173:
      v106[0] = 0;
      char v108 = 0;
      create_candidate_from_word(v81, v59, (const KB::String *)v106);
      if (!v108) {
        goto LABEL_178;
      }
      int v72 = v107;
      if (!v107) {
        goto LABEL_178;
      }
      int v73 = v106[6];
LABEL_176:
      if (v73 == 1) {
        free(v72);
      }
      goto LABEL_178;
    }
LABEL_143:
    v59 += 240;
    if (v59 == v60) {
      goto LABEL_149;
    }
  }
  if (!v82)
  {
    v115.unsigned int lexicon_id = 0x100000;
    LOWORD(v115.word_id) = 0;
    BYTE2(v115.word_id) = 0;
    uint64_t v116 = 0;
    char v117 = 0;
    KB::string_join((unsigned __int16 *)v89 - 16 * v55, (unsigned __int16 *)((char *)v89 + v92 - v93), (const KB::String *)&v115, (uint64_t)v118);
    TIInputManager::input_substring(v77, 0, -858993459 * ((*((void *)v84 + 2) - *((void *)v84 + 1)) >> 3), (uint64_t)v112);
    KB::String::String((KB::String *)buf, (const KB::String *)v118);
    KB::String::append((unsigned __int16 *)buf, (const KB::String *)v112);
    KB::String::operator=((uint64_t)v79, (KB::String *)buf);
    if (*(void *)&buf[8] && buf[6] == 1) {
      free(*(void **)&buf[8]);
    }
    if (v114 && v113 == 1) {
      free(v114);
    }
    if (v120 && v119 == 1) {
      free(v120);
    }
    if (v116 && BYTE2(v115.word_id) == 1) {
      free(v116);
    }
  }
  v109[0] = 0;
  char v111 = 0;
  create_candidate_from_word(v81, v59, (const KB::String *)v109);
  if (v111)
  {
    int v72 = v110;
    if (v110)
    {
      int v73 = v109[6];
      goto LABEL_176;
    }
  }
LABEL_178:
  *(void *)std::string buf = &v86;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  if (v123 && v122 == 1) {
    free(v123);
  }
LABEL_155:
  *(void *)std::string buf = &v88;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
  *(void *)std::string buf = &v92;
  std::vector<KB::String>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
}

void create_candidate_from_word(KB::Candidate *a1, uint64_t a2, const KB::String *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a3 + 32)) {
    KB::String::String((KB::String *)v10, a3);
  }
  else {
    KB::Word::capitalized_string((KB::Word *)a2, (uint64_t)v10);
  }
  KB::Candidate::Candidate(a1, (const KB::String *)v10, 0);
  if (v11 && v10[6] == 1) {
    free(v11);
  }
  if ((*(unsigned char *)(a2 + 105) & 1) != 0 && *(void *)a1)
  {
    uint64_t v5 = 240 * *(void *)a1;
    __int16 v6 = (_DWORD *)(*((void *)a1 + 1) + 104);
    do
    {
      *v6 |= 0x100u;
      v6 += 60;
      v5 -= 240;
    }
    while (v5);
  }
  if (*(void *)(a2 + 224))
  {
    uint64_t v7 = *(void *)a1;
    if (*(void *)a1)
    {
      uint64_t v8 = *((void *)a1 + 1) + 200;
      uint64_t v9 = 240 * v7;
      do
      {
        if (v8 - 200 != a2)
        {
          *(_DWORD *)(v8 + 32) = *(_DWORD *)(a2 + 232);
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)v8, *(void **)(a2 + 216));
        }
        v8 += 240;
        v9 -= 240;
      }
      while (v9);
    }
  }
}

uint64_t std::__split_buffer<KB::String>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = v2 - 32;
      *(void *)(a1 + 16) = v2 - 32;
      uint64_t v5 = *(void **)(v2 - 24);
      if (v5 && *(unsigned char *)(v2 - 26) == 1)
      {
        free(v5);
        uint64_t v4 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL TIInputManager::word_has_surface_form(TIInputManager *this, const KB::Word *a2)
{
  v29[2] = *MEMORY[0x1E4F143B8];
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::ko, "ko");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::ko, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::ta, "ta");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::ta, &dword_1E3F0E000);
  }
  {
    KB::String::String((KB::String *)&TIInputManager::word_has_surface_form(KB::Word const&)const::chr, "chr");
    __cxa_atexit((void (*)(void *))KB::String::~String, &TIInputManager::word_has_surface_form(KB::Word const&)const::chr, &dword_1E3F0E000);
  }
  unsigned int v4 = *((unsigned __int16 *)this + 52);
  if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ko <= v4)
  {
    uint64_t v5 = *((void *)this + 14) ? (const char *)*((void *)this + 14) : (char *)this + 120;
    __int16 v6 = qword_1EBFF0390 ? (const char *)qword_1EBFF0390 : (const char *)&unk_1EBFF0398;
    if (!strncmp(v5, v6, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ko)) {
      return 0;
    }
  }
  if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ta <= v4
    && (*((void *)this + 14) ? (uint64_t v7 = (const char *)*((void *)this + 14)) : (uint64_t v7 = (char *)this + 120),
        qword_1EBFF03B0 ? (uint64_t v8 = (const char *)qword_1EBFF03B0) : (uint64_t v8 = (const char *)&unk_1EBFF03B8),
        !strncmp(v7, v8, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::ta)))
  {
    KB::Word::capitalized_string(a2, (uint64_t)v26);
    uint64_t v12 = v28;
    if (v28) {
      uint64_t v13 = v28;
    }
    else {
      uint64_t v13 = v29;
    }
    int v22 = v13;
    int v14 = v26[0];
    int v23 = 0;
    int v24 = v26[0];
    int v25 = 0;
    KB::String::iterator::initialize((uint64_t *)&v22);
    unsigned int v18 = v13;
    int v19 = v14;
    int v20 = v14;
    int v21 = 0;
    KB::String::iterator::initialize((uint64_t *)&v18);
    int v15 = v19;
    if (v23 == v19)
    {
      uint64_t is_tamil_script = 0;
    }
    else
    {
      do
      {
        uint64_t is_tamil_script = character_is_tamil_script();
        if (is_tamil_script) {
          break;
        }
        KB::String::iterator::operator++((uint64_t *)&v22);
      }
      while (v23 != v15);
      uint64_t v12 = v28;
    }
    if (v12) {
      BOOL v16 = v27 == 1;
    }
    else {
      BOOL v16 = 0;
    }
    if (v16) {
      free(v12);
    }
  }
  else if ((unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::chr <= v4)
  {
    if (*((void *)this + 14)) {
      uint64_t v10 = (const char *)*((void *)this + 14);
    }
    else {
      uint64_t v10 = (char *)this + 120;
    }
    if (qword_1EBFF03D0) {
      uint64_t v11 = (const char *)qword_1EBFF03D0;
    }
    else {
      uint64_t v11 = (const char *)&unk_1EBFF03D8;
    }
    return strncmp(v10, v11, (unsigned __int16)TIInputManager::word_has_surface_form(KB::Word const&)const::chr) != 0;
  }
  else
  {
    return 1;
  }
  return is_tamil_script;
}

uint64_t TIInputManager::dictionary_contains_word(TIInputManager *this, const KB::String *a2, const KB::String *a3, char a4)
{
  uint64_t v5 = *((void *)this + 28);
  if (!v5) {
    return 0;
  }
  KB::DictionaryContainer::lookup(v5, &v20);
  uint64_t v9 = v20;
  uint64_t v10 = v21;
  if (v20 == v21)
  {
    uint64_t v11 = 0;
  }
  else
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    int v14 = ___ZNK14TIInputManager24dictionary_contains_wordERKN2KB6StringES3_b_block_invoke;
    int v15 = &__block_descriptor_tmp_34;
    BOOL v16 = this;
    uint64_t v17 = a3;
    unsigned int v18 = a2;
    char v19 = a4;
    do
    {
      uint64_t v11 = v14((uint64_t)v13, v9);
      if (v11) {
        break;
      }
      uint64_t v9 = (const KB::Word *)((char *)v9 + 240);
    }
    while (v9 != v10);
  }
  int v22 = &v20;
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v22);
  return v11;
}

uint64_t ___ZNK14TIInputManager24dictionary_contains_wordERKN2KB6StringES3_b_block_invoke(uint64_t a1, const KB::Word *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(TIInputManager **)(a1 + 32);
  BOOL has_surface_form = TIInputManager::word_has_surface_form(v4, a2);
  uint64_t v6 = 48;
  if (has_surface_form) {
    uint64_t v6 = 40;
  }
  uint64_t v7 = *(const KB::String **)(a1 + v6);
  uint64_t v8 = (KB::CollatorWrapper **)(*(void *)(*((void *)v4 + 28) + 8) + 72);
  KB::Word::capitalized_string(a2, (uint64_t)v18);
  int v10 = KB::CollatorWrapper::sortkey_compare_strings(v8, (_LXLexicon *)v18, v7, v9);
  if (v20) {
    BOOL v11 = v19 == 1;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11) {
    free(v20);
  }
  BOOL v12 = 0;
  BOOL v16 = 0;
  if (!v10)
  {
    KB::Word::capitalized_string(a2, (uint64_t)v18);
    v17[1] = 1;
    v17[0] = &unk_1F3F77D18;
    int v13 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v17, (const KB::String *)v18, v7, &v16, 0);
    if (v20 && v19 == 1) {
      free(v20);
    }
    if (v16) {
      int v14 = 0;
    }
    else {
      int v14 = v13;
    }
    if (v14 == 1)
    {
      if (*(unsigned char *)(a1 + 56))
      {
        KB::Word::capitalized_string(a2, (uint64_t)v18);
        BOOL v12 = v18 == (unsigned char *)v7 || KB::String::equal((KB::String *)v18, v7, 1);
        if (v20 && v19 == 1) {
          free(v20);
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v12;
}

void TIInputManager::matching_words_from_dictionary(TIInputManager *this@<X0>, const KB::String *a2@<X1>, const KB::String *a3@<X2>, char a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  uint64_t v7 = *((void *)this + 28);
  if (v7)
  {
    KB::DictionaryContainer::lookup(v7, &v31);
    BOOL v11 = v31;
    BOOL v12 = v32;
    if (v31 != v32)
    {
      uint64_t v35 = this;
      KB::String::String((KB::String *)v36, a3);
      KB::String::String((KB::String *)v38, a2);
      char v40 = a4;
      do
      {
        int v13 = v35;
        if (TIInputManager::word_has_surface_form(v35, v11)) {
          int v14 = (const KB::String *)v36;
        }
        else {
          int v14 = (const KB::String *)v38;
        }
        int v15 = (KB::CollatorWrapper **)(*(void *)(*((void *)v13 + 28) + 8) + 72);
        KB::Word::capitalized_string(v11, (uint64_t)&v41);
        int v17 = KB::CollatorWrapper::sortkey_compare_strings(v15, (_LXLexicon *)&v41, v14, v16);
        if (v42) {
          BOOL v18 = BYTE6(v41) == 1;
        }
        else {
          BOOL v18 = 0;
        }
        if (v18) {
          free(v42);
        }
        BOOL v33 = 0;
        if (!v17)
        {
          KB::Word::capitalized_string(v11, (uint64_t)&v41);
          v34[0] = &unk_1F3F77D18;
          v34[1] = 1;
          int v19 = KB::InputSegmentFilter::string_preserves_surface_form_features((KB::InputSegmentFilter *)v34, (const KB::String *)&v41, v14, &v33, 0);
          if (v42 && BYTE6(v41) == 1) {
            free(v42);
          }
          if (v33) {
            int v20 = 0;
          }
          else {
            int v20 = v19;
          }
          if (v20 == 1)
          {
            if (!v40) {
              goto LABEL_26;
            }
            KB::Word::capitalized_string(v11, (uint64_t)&v41);
            BOOL v21 = KB::String::equal((KB::String *)&v41, v14, 1);
            if (v42 && BYTE6(v41) == 1) {
              free(v42);
            }
            if (v21)
            {
LABEL_26:
              int v22 = (KB::Word *)a5[1];
              unint64_t v23 = a5[2];
              if ((unint64_t)v22 >= v23)
              {
                unint64_t v25 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v22 - *a5) >> 4);
                unint64_t v26 = v25 + 1;
                if (v25 + 1 > 0x111111111111111) {
                  abort();
                }
                unint64_t v27 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v23 - *a5) >> 4);
                if (2 * v27 > v26) {
                  unint64_t v26 = 2 * v27;
                }
                if (v27 >= 0x88888888888888) {
                  unint64_t v28 = 0x111111111111111;
                }
                else {
                  unint64_t v28 = v26;
                }
                int64x2_t v45 = a5 + 2;
                if (v28) {
                  unint64_t v28 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v28);
                }
                else {
                  uint64_t v29 = 0;
                }
                uint64_t v30 = (char *)(v28 + 240 * v25);
                uint64_t v41 = (void **)v28;
                uint64_t v42 = v30;
                unint64_t v44 = v28 + 240 * v29;
                KB::Word::Word((KB::Word *)v30, (size_t *)v11);
                uint64_t v43 = v30 + 240;
                std::vector<KB::Word>::__swap_out_circular_buffer(a5, &v41);
                int v24 = (char *)a5[1];
                std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v41);
              }
              else
              {
                int v24 = (char *)KB::Word::Word(v22, (size_t *)v11) + 240;
              }
              a5[1] = (uint64_t)v24;
            }
          }
        }
        BOOL v11 = (const KB::Word *)((char *)v11 + 240);
      }
      while (v11 != v12);
      if (v39 && v38[6] == 1) {
        free(v39);
      }
      if (v37)
      {
        if (v36[6] == 1) {
          free(v37);
        }
      }
    }
    uint64_t v41 = (void **)&v31;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v41);
  }
}

uint64_t TIInputManager::keys_for_input(TIInputManager *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 240))();
}

uint64_t TIInputManager::initialize_search_if_necessary_from_last_touch(TIInputManager *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 23) + 248))();
}

BOOL TIInputManager::is_input_hit_test_corrected(TIInputManager *this, unsigned int a2, unsigned int a3)
{
  if (*((_DWORD *)this + 24) >= a3) {
    unsigned int v3 = a3;
  }
  else {
    unsigned int v3 = *((_DWORD *)this + 24);
  }
  if (v3 <= a2) {
    return 0;
  }
  LODWORD(v4) = a2;
  if ((*(uint64_t (**)(void))(**((void **)this + 23) + 280))(*((void *)this + 23))) {
    return 1;
  }
  while (v3 - 1 != v4)
  {
    uint64_t v4 = (v4 + 1);
    if ((*(unsigned int (**)(void, uint64_t))(**((void **)this + 23) + 280))(*((void *)this + 23), v4))
    {
      return v4 < v3;
    }
  }
  LODWORD(v4) = v3;
  return v4 < v3;
}

void debug_print_candidates(uint64_t *a1, const char *a2, uint64_t a3)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 136315138;
    int v19 = "debug_print_candidates";
    _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  ===================", buf, 0xCu);
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = 0x1CAC083126E978D5 * ((a1[1] - *a1) >> 3);
    if (*(_WORD *)a3)
    {
      uint64_t v7 = *(const char **)(a3 + 8);
      if (!v7) {
        uint64_t v7 = (const char *)(a3 + 16);
      }
    }
    else
    {
      uint64_t v7 = "";
    }
    *(_DWORD *)std::string buf = 136315906;
    int v19 = "debug_print_candidates";
    __int16 v20 = 2082;
    BOOL v21 = a2;
    __int16 v22 = 2048;
    double v23 = *(double *)&v6;
    __int16 v24 = 2082;
    unint64_t v25 = v7;
    _os_log_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEFAULT, "%s  %{public}s: %lu (%{public}s)", buf, 0x2Au);
  }
  uint64_t v9 = *a1;
  uint64_t v8 = a1[1];
  if (v8 != *a1)
  {
    unint64_t v10 = 0;
    BOOL v11 = MEMORY[0x1E4F14500];
    uint64_t v12 = 904;
    do
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = v9 + v12;
        int v14 = *(unsigned __int16 *)(v9 + v12 - 16);
        if (!*(_WORD *)(v9 + v12 - 16))
        {
          KB::Candidate::compute_string((KB::Candidate *)(v13 - 904));
          int v14 = *(unsigned __int16 *)(v13 - 16);
        }
        int v15 = *(const char **)(v13 - 8);
        if (!v15) {
          int v15 = (const char *)(v9 + v12);
        }
        if (v14) {
          BOOL v16 = v15;
        }
        else {
          BOOL v16 = "";
        }
        float v17 = expf(*(float *)(v13 - 160));
        *(_DWORD *)std::string buf = 136315650;
        int v19 = "debug_print_candidates";
        __int16 v20 = 2082;
        BOOL v21 = v16;
        __int16 v22 = 2048;
        double v23 = v17;
        _os_log_impl(&dword_1E3F0E000, v11, OS_LOG_TYPE_DEFAULT, "%s     %{public}s, omega: %f", buf, 0x20u);
        uint64_t v9 = *a1;
        uint64_t v8 = a1[1];
      }
      ++v10;
      v12 += 1000;
    }
    while (0x1CAC083126E978D5 * ((v8 - v9) >> 3) > v10);
  }
}

void *KB::FilterZeroProbability::filter_candidates(KB::FilterZeroProbability *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v7[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a4 + 7);
  v7[0] = &unk_1F3F741A8;
  _WORD v7[3] = v7;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterZeroProbability", (uint64_t)v7);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v7);
}

BOOL std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  unsigned int v3 = *a3;
  float v4 = expf(*(float *)(a2 + 744));
  float v5 = v4;
  if (v3 && v4 == 0.0) {
    KB::String::append(v3, "omega=0", 0xFFFFuLL);
  }
  return v5 == 0.0;
}

void std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F741A8;
}

void *std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F741A8;
  return result;
}

void std::__function::__func<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterZeroProbability::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterZeroProbability::filter_description(KB::FilterZeroProbability *this)
{
  return "FilterZeroProbability";
}

void KB::FilterZeroProbability::~FilterZeroProbability(KB::FilterZeroProbability *this)
{
}

void *KB::FilterIncomplete::filter_candidates(KB::FilterIncomplete *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v7[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a4 + 7);
  v7[0] = &unk_1F3F741F0;
  _WORD v7[3] = v7;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterIncomplete", (uint64_t)v7);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v7);
}

uint64_t std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, void *a2, KB::String **a3)
{
  if (*a2) {
    return 0;
  }
  uint64_t v4 = a2[1];
  int v5 = *(_DWORD *)(v4 + 132);
  int v6 = *(_DWORD *)(v4 - 108);
  BOOL v3 = (v5 & 0x10000000 | v6 & 0x20000000) != 0;
  if (*a3) {
    BOOL v7 = (v5 & 0x10000000 | v6 & 0x20000000) == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v8 = "no";
    if ((v5 & 0x10000000) != 0) {
      uint64_t v9 = "yes";
    }
    else {
      uint64_t v9 = "no";
    }
    if ((v6 & 0x20000000) != 0) {
      uint64_t v8 = "yes";
    }
    KB::String::append_format(*a3, "needs_prefix=%s, needs_suffix=%s", v9, v8);
    return 1;
  }
  return v3;
}

void std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F741F0;
}

void *std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F741F0;
  return result;
}

void std::__function::__func<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterIncomplete::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterIncomplete::filter_description(KB::FilterIncomplete *this)
{
  return "FilterIncomplete";
}

void KB::FilterIncomplete::~FilterIncomplete(KB::FilterIncomplete *this)
{
}

void *KB::FilterControlCharacters::filter_candidates(KB::FilterControlCharacters *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v7[4] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a4 + 7);
  v7[0] = &unk_1F3F74238;
  _WORD v7[3] = v7;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v5, (uint64_t)"FilterControlCharacters", (uint64_t)v7);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v7);
}

BOOL std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  BOOL v3 = *a3;
  uint64_t v4 = (KB *)(a2 + 444);
  if (!a2[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  BOOL has_control_characters = KB::string_has_control_characters(v4, (const KB::String *)a2);
  BOOL v6 = has_control_characters;
  if (v3) {
    BOOL v7 = !has_control_characters;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7) {
    KB::String::append_format(v3, "candidate word contains control characters");
  }
  return v6;
}

void std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F74238;
}

void *std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F74238;
  return result;
}

void std::__function::__func<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterControlCharacters::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterControlCharacters::filter_description(KB::FilterControlCharacters *this)
{
  return "FilterControlCharacters";
}

void KB::FilterControlCharacters::~FilterControlCharacters(KB::FilterControlCharacters *this)
{
}

void KB::FilterNotSuggestibleForInput::filter_candidates(KB::FilterNotSuggestibleForInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 9) != 1) {
    goto LABEL_5;
  }
  uint64_t v8 = *((void *)a4 + 2);
  if (v8) {
    atomic_fetch_add((atomic_uint *volatile)v8, 1u);
  }
  uint64_t v9 = *(void *)(v8 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  if (KB::FilterNotSuggestibleForInput::does_candidate_list_contain_input_match((uint64_t)a2, (uint64_t)a3, v9))
  {
LABEL_5:
    KB::Candidate::Candidate((KB::Candidate *)v28, a3);
    uint64_t v10 = *((void *)a4 + 2);
    if (v10) {
      atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    }
    uint64_t v11 = *(void *)(v10 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v10);
    std::__function::__value_func<int ()(KB::String const&,KB::String const&)>::__value_func[abi:nn180100]((uint64_t)v27, v11);
    int v12 = *((_DWORD *)this + 8);
    long long v21 = *(_OWORD *)((char *)this + 8);
    uint64_t v22 = *((void *)this + 3);
    double v23 = 0;
    __int16 v24 = 0;
    uint64_t v25 = 0;
    uint64_t v13 = *((void *)a4 + 7);
    int v14 = operator new(0x48uLL);
    *(void *)int v14 = &unk_1F3F74160;
    void v14[2] = v12;
    *((void *)v14 + 2) = this;
    *((void *)v14 + 3) = a4;
    *((void *)v14 + 4) = v28;
    *((void *)v14 + 5) = &v21;
    *((void *)v14 + 6) = v27;
    *((void *)v14 + 7) = a3;
    *((void *)v14 + 8) = &v23;
    uint64_t v30 = v14;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v13, (uint64_t)"FilterNotSuggestibleForInput", (uint64_t)v29);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v29);
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2, *((void *)a2 + 1), v23, v24, 0x1CAC083126E978D5 * ((v24 - v23) >> 3));
    uint64_t v26 = &v23;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    double v23 = 0;
    __int16 v24 = 0;
    uint64_t v25 = 0;
    uint64_t v15 = *((void *)a4 + 7);
    BOOL v16 = operator new(0x48uLL);
    *(void *)BOOL v16 = &unk_1F3F74160;
    void v16[2] = v12;
    *((void *)v16 + 2) = this;
    *((void *)v16 + 3) = a4;
    *((void *)v16 + 4) = v28;
    *((void *)v16 + 5) = &v21;
    *((void *)v16 + 6) = v27;
    *((void *)v16 + 7) = a3;
    *((void *)v16 + 8) = &v23;
    uint64_t v30 = v16;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 24, v15, (uint64_t)"FilterNotSuggestibleForInput", (uint64_t)v29);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v29);
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 3, *((void *)a2 + 4), v23, v24, 0x1CAC083126E978D5 * ((v24 - v23) >> 3));
    uint64_t v26 = &v23;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    double v23 = 0;
    __int16 v24 = 0;
    uint64_t v25 = 0;
    uint64_t v17 = *((void *)a4 + 7);
    BOOL v18 = operator new(0x48uLL);
    *(void *)BOOL v18 = &unk_1F3F74160;
    v18[2] = v12;
    *((void *)v18 + 2) = this;
    *((void *)v18 + 3) = a4;
    *((void *)v18 + 4) = v28;
    *((void *)v18 + 5) = &v21;
    *((void *)v18 + 6) = v27;
    *((void *)v18 + 7) = a3;
    *((void *)v18 + 8) = &v23;
    uint64_t v30 = v18;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 48, v17, (uint64_t)"FilterNotSuggestibleForInput", (uint64_t)v29);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v29);
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 6, *((void *)a2 + 7), v23, v24, 0x1CAC083126E978D5 * ((v24 - v23) >> 3));
    uint64_t v26 = &v23;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    double v23 = 0;
    __int16 v24 = 0;
    uint64_t v25 = 0;
    uint64_t v19 = *((void *)a4 + 7);
    __int16 v20 = operator new(0x48uLL);
    *(void *)__int16 v20 = &unk_1F3F74160;
    _OWORD v20[2] = v12;
    *((void *)v20 + 2) = this;
    *((void *)v20 + 3) = a4;
    *((void *)v20 + 4) = v28;
    *((void *)v20 + 5) = &v21;
    *((void *)v20 + 6) = v27;
    *((void *)v20 + 7) = a3;
    *((void *)v20 + 8) = &v23;
    uint64_t v30 = v20;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 72, v19, (uint64_t)"FilterNotSuggestibleForInput", (uint64_t)v29);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v29);
    std::vector<KB::Candidate>::__insert_with_size[abi:nn180100]<std::__wrap_iter<KB::Candidate const*>,std::__wrap_iter<KB::Candidate const*>>((uint64_t *)a2 + 9, *((void *)a2 + 10), v23, v24, 0x1CAC083126E978D5 * ((v24 - v23) >> 3));
    uint64_t v26 = &v23;
    std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)&v26);
    std::__function::__value_func<int ()(KB::String const&,KB::String const&)>::~__value_func[abi:nn180100](v27);
    KB::Candidate::~Candidate((KB::Candidate *)v28);
  }
}

uint64_t KB::FilterNotSuggestibleForInput::does_candidate_list_contain_input_match(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3 = *(void **)a1;
  uint64_t v4 = *(void **)(a1 + 8);
  if (*(void **)a1 == v4) {
    return 0;
  }
  while ((*(unsigned char *)(v3[1] + 240 * *v3 - 134) & 0x80) != 0
       || (KB::CandidateFilter::candidate_matches_input((uint64_t)v3, a2, a3) & 1) == 0)
  {
    v3 += 125;
    if (v3 == v4) {
      return 0;
    }
  }
  return 1;
}

uint64_t std::__function::__value_func<int ()(KB::String const&,KB::String const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<int ()(KB::String const&,KB::String const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, const KB::Candidate *a2, KB::String **a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a1 + 16);
  KB::FilterNotSuggestibleForInput::ovs_words_across_languages(a2, *(atomic_uint ***)(a1 + 24), (uint64_t)v35);
  uint64_t v7 = v36;
  uint64_t v8 = v37[3];
  if (KB::CandidateFilter::is_suggestible_for_input((uint64_t *)a2, *(void **)(a1 + 32), *(_DWORD *)(a1 + 8), *(KB::WordSuggestionPolicy **)(a1 + 40), *(void *)(a1 + 48), v5))BOOL v9 = v7 == 0; {
  else
  }
    BOOL v9 = 0;
  if (v9) {
    goto LABEL_27;
  }
  uint64_t v10 = *((void *)a2 + 1);
  uint64_t v11 = v10 + 240 * *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v12 = 240 * *(void *)a2;
    while ((*(unsigned char *)(v10 + 107) & 8) == 0)
    {
      v10 += 240;
      v12 -= 240;
      if (!v12)
      {
        uint64_t v10 = v11;
        break;
      }
    }
  }
  BOOL v13 = !v8 && v10 == v11;
  BOOL v14 = !v13;
  int v15 = simular_swear_word_policy_v1_setting
      ? [(id)simular_swear_word_policy_v1_setting BOOLValue]
      : _os_feature_enabled_impl();
  if ((v15 & v14) == 1 && *(_DWORD *)(v6 + 40) == 2) {
    goto LABEL_27;
  }
  if (simular_swear_word_policy_v2_setting) {
    int v16 = [(id)simular_swear_word_policy_v2_setting BOOLValue];
  }
  else {
    int v16 = _os_feature_enabled_impl();
  }
  if ((v16 & v14) == 1)
  {
    uint64_t v17 = *(void *)(*(void *)(a1 + 24) + 48);
    std::unordered_map<KB::String,KB::Word>::unordered_map((uint64_t)v34, (uint64_t)v37);
    if (KB::Candidate::every_vulgar_word_is_allowlisted(a2, v17, v34, 0))
    {
      int v18 = *(_DWORD *)(v6 + 40);
      std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v34);
      if (v18 == 1)
      {
LABEL_27:
        uint64_t v19 = 0;
        goto LABEL_56;
      }
    }
    else
    {
      std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v34);
    }
  }
  BOOL v20 = *(_DWORD *)(*(void *)(a1 + 56) + 3168) == 4 && v14;
  if (!v20
    || (long long v21 = *(TI::VulgarWordUsageDatabaseWrapper **)(*(void *)(a1 + 24) + 48),
        std::unordered_map<KB::String,KB::Word>::unordered_map((uint64_t)v33, (uint64_t)v37),
        BOOL is_allowlisted_somewhere = KB::Candidate::every_vulgar_word_is_allowlisted_somewhere(a2, v21, v33, 0),
        std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v33),
        uint64_t v19 = 0,
        !is_allowlisted_somewhere))
  {
    if (simular_swear_word_policy_v2_setting)
    {
      if (([(id)simular_swear_word_policy_v2_setting BOOLValue] & 1) == 0) {
        goto LABEL_55;
      }
    }
    else if (!_os_feature_enabled_impl())
    {
      goto LABEL_55;
    }
    double v23 = *(void **)(a1 + 56);
    if (*(void *)a2 == *v23)
    {
      uint64_t v24 = *((void *)a2 + 1);
      if ((*(unsigned char *)(v24 + 107) & 8) != 0)
      {
        uint64_t v25 = *(void *)a2 - 1;
        uint64_t v26 = (KB::String *)(v24 + 240 * v25);
        if ((*((unsigned char *)v26 + 107) & 8) == 0)
        {
          uint64_t v27 = v23[1];
          if (v24 != v27)
          {
            uint64_t v19 = 1;
            if (KB::String::equal(v26, (const KB::String *)(v27 + 240 * v25), 1)) {
              goto LABEL_56;
            }
            KB::Candidate::Candidate((KB::Candidate *)v41, a2);
            KB::Candidate::clear((KB::Candidate *)v41);
            if (*(void *)a2)
            {
              uint64_t v28 = 0;
              unint64_t v29 = 0;
              do
              {
                KB::Word::Word((KB::Word *)v40, (size_t *)(*((void *)a2 + 1) + v28));
                if ((v40[107] & 8) != 0) {
                  goto LABEL_50;
                }
                KB::Word::lowercased_string((KB::Word *)v40, (KB::String *)&v38);
                uint64_t v30 = std::__hash_table<std::__hash_value_type<KB::String,unsigned long>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,unsigned long>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,unsigned long>>>::find<KB::String>(v37, &v38);
                if (v39 && BYTE6(v38) == 1) {
                  free(v39);
                }
                if (v30) {
LABEL_50:
                }
                  uint64_t v31 = (size_t *)(*(void *)(*(void *)(a1 + 56) + 8) + v28);
                else {
                  uint64_t v31 = (size_t *)v40;
                }
                KB::Candidate::append(v41, v31);
                KB::Word::~Word((KB::Word *)v40);
                ++v29;
                v28 += 240;
              }
              while (v29 < *(void *)a2);
            }
            std::vector<KB::Candidate>::push_back[abi:nn180100](*(uint64_t **)(a1 + 64), (const KB::Candidate *)v41);
            KB::Candidate::~Candidate((KB::Candidate *)v41);
          }
        }
      }
    }
LABEL_55:
    uint64_t v19 = 1;
  }
LABEL_56:
  std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v37);
  std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v35);
  return v19;
}

void KB::FilterNotSuggestibleForInput::ovs_words_across_languages(const KB::Candidate *a1@<X1>, atomic_uint **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v50 = *(void *)a1;
  uint64_t v5 = *((void *)a1 + 2);
  if (v5 && (uint64_t v7 = (char *)malloc_type_malloc(240 * v5, 0x10B2040DF775671uLL)) != 0)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)a1;
    uint64_t v51 = v7;
    if (*(void *)a1)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *((void *)a1 + 1);
      uint64_t v12 = 240 * v9;
      do
      {
        KB::Word::Word((KB::Word *)&v8[v10], (size_t *)(v11 + v10));
        v10 += 240;
      }
      while (v12 != v10);
    }
  }
  else
  {
    uint64_t v51 = 0;
  }
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_DWORD *)(a3 + 32) = 1065353216;
  *(_OWORD *)(a3 + 40) = 0u;
  uint64_t v53 = a3 + 40;
  *(_OWORD *)(a3 + 56) = 0u;
  *(_DWORD *)(a3 + 72) = 1065353216;
  uint64_t v52 = (const KB::CandidateFilterResources *)a2;
  BOOL v13 = a2[2];
  if (!v13) {
    goto LABEL_82;
  }
  atomic_fetch_add(v13, 1u);
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v13);
  BOOL v14 = a2[2];
  if (v14) {
    atomic_fetch_add(v14, 1u);
  }
  int v15 = *((unsigned __int8 *)v14 + 66);
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v14);
  int v16 = a2[2];
  if (v16) {
    atomic_fetch_add(v16, 1u);
  }
  uint64_t v17 = *((void *)v16 + 5);
  uint64_t v18 = *((void *)v16 + 6);
  if (v17 == v18)
  {
    BOOL v21 = 0;
LABEL_42:
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v16);
    goto LABEL_43;
  }
  do
  {
    KB::String::String((KB::String *)&v73, (const KB::String *)v17);
    KB::String::String((KB::String *)v75, (const KB::String *)(v17 + 32));
    KB::String::String((KB::String *)v80, (const KB::String *)(v17 + 64));
    KB::String::String((KB::String *)&v82, (const KB::String *)(v17 + 96));
    KB::String::String((KB::String *)&v84, (const KB::String *)(v17 + 128));
    uint64_t v19 = *(void *)(v17 + 160);
    int v87 = *(_DWORD *)(v17 + 168);
    uint64_t v86 = v19;
    BOOL v21 = v19 != -2 && BYTE4(v19) != 0;
    if (*((void *)&v84 + 1) && BYTE6(v84) == 1) {
      free(*((void **)&v84 + 1));
    }
    if (*((void *)&v82 + 1) && BYTE6(v82) == 1) {
      free(*((void **)&v82 + 1));
    }
    if (v81 && v80[6] == 1) {
      free(v81);
    }
    if (v77 && v76 == 1) {
      free(v77);
    }
    if (v74 && BYTE6(v73) == 1) {
      free(v74);
    }
    v17 += 176;
    int v22 = v17 == v18 || v21;
  }
  while (v22 != 1);
  if (v16) {
    goto LABEL_42;
  }
LABEL_43:
  if (v15 && v21)
  {
    double v23 = v51;
    if (!v50) {
      goto LABEL_85;
    }
    uint64_t v24 = (size_t *)&v51[240 * v50];
    uint64_t v25 = (size_t *)v51;
    do
    {
      KB::Word::Word((KB::Word *)&v73, v25);
      if ((BYTE11(v82) & 0x38) != 0)
      {
        v60[0] = (void **)&v73;
        uint64_t v26 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(a3, &v73, (const KB::String **)v60);
        KB::String::operator=((KB::String *)(v26 + 24), (KB::String *)&v73);
        KB::ByteString::operator=(v26 + 40, v75);
        *((void *)v26 + 12) = v78;
        *((_DWORD *)v26 + 26) = v79;
        KB::String::operator=((KB::String *)(v26 + 56), (KB::String *)v80);
        long long v27 = v83;
        long long v29 = v84;
        long long v28 = v85;
        *((_OWORD *)v26 + 9) = v82;
        *((_OWORD *)v26 + 10) = v27;
        *((_OWORD *)v26 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v29;
        *((_OWORD *)v26 + 12) = v28;
        KB::String::operator=((KB::String *)(v26 + 104), (KB::String *)&v86);
        *((unsigned char *)v26 + 240) = v88;
        if (v26 + 24 != (unsigned __int16 *)&v73)
        {
          *((_DWORD *)v26 + 70) = v90;
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)v26 + 31, v89);
        }
        if ((BYTE11(v82) & 8) != 0)
        {
          v60[0] = (void **)&v73;
          uint64_t v30 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(v53, &v73, (const KB::String **)v60);
          KB::String::operator=((KB::String *)(v30 + 24), (KB::String *)&v73);
          KB::ByteString::operator=(v30 + 40, v75);
          *((void *)v30 + 12) = v78;
          *((_DWORD *)v30 + 26) = v79;
          KB::String::operator=((KB::String *)(v30 + 56), (KB::String *)v80);
          long long v31 = v83;
          long long v33 = v84;
          long long v32 = v85;
          *((_OWORD *)v30 + 9) = v82;
          *((_OWORD *)v30 + 10) = v31;
          *((_OWORD *)v30 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v33;
          *((_OWORD *)v30 + 12) = v32;
          KB::String::operator=((KB::String *)(v30 + 104), (KB::String *)&v86);
          *((unsigned char *)v30 + 240) = v88;
          if (v30 + 24 != (unsigned __int16 *)&v73)
          {
            *((_DWORD *)v30 + 70) = v90;
            std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)v30 + 31, v89);
          }
        }
      }
      else
      {
        long long v34 = (atomic_uint *)*((void *)v52 + 2);
        if (v34)
        {
          atomic_fetch_add(v34, 1u);
          WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v34);
          uint64_t v35 = (atomic_uint *)*((void *)v52 + 2);
          if (v35)
          {
            atomic_fetch_add(v35, 1u);
            KB::DictionaryContainer::lookup((uint64_t)v35, v55);
            WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v35);
          }
          else
          {
            KB::DictionaryContainer::lookup(0, v55);
          }
          uint64_t v36 = (size_t *)v55[0];
          unint64_t v37 = (size_t *)v55[1];
          while (v36 != v37)
          {
            KB::Word::Word((KB::Word *)v60, v36);
            if ((BYTE11(v65) & 0x38) != 0)
            {
              KB::Word::lowercased_string((KB::Word *)v60, (KB::String *)&v58);
              KB::Word::lowercased_string((KB::Word *)&v73, (KB::String *)&v56);
              BOOL v38 = KB::String::equal((KB::String *)&v58, (const KB::String *)&v56, 1);
              if (v57 && BYTE6(v56) == 1) {
                free(v57);
              }
              if (v59 && BYTE6(v58) == 1) {
                free(v59);
              }
              if (v38)
              {
                KB::Word::lowercased_string((KB::Word *)v60, (KB::String *)&v58);
                uint64_t v56 = (KB::String *)&v58;
                uint64_t v39 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(a3, &v58, &v56);
                KB::String::operator=((KB::String *)(v39 + 24), (KB::String *)v60);
                KB::ByteString::operator=(v39 + 40, v61);
                *((void *)v39 + 12) = v62;
                *((_DWORD *)v39 + 26) = v63;
                KB::String::operator=((KB::String *)(v39 + 56), (KB::String *)v64);
                long long v40 = v66;
                long long v42 = v67;
                long long v41 = v68;
                *((_OWORD *)v39 + 9) = v65;
                *((_OWORD *)v39 + 10) = v40;
                *((_OWORD *)v39 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v42;
                *((_OWORD *)v39 + 12) = v41;
                KB::String::operator=((KB::String *)(v39 + 104), (KB::String *)v69);
                *((unsigned char *)v39 + 240) = v70;
                if (v39 + 24 != (unsigned __int16 *)v60)
                {
                  *((_DWORD *)v39 + 70) = v72;
                  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)v39 + 31, v71);
                }
                if (v59 && BYTE6(v58) == 1) {
                  free(v59);
                }
                if ((BYTE11(v65) & 8) != 0)
                {
                  KB::Word::lowercased_string((KB::Word *)v60, (KB::String *)&v58);
                  uint64_t v56 = (KB::String *)&v58;
                  uint64_t v43 = (unsigned __int16 *)std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(v53, &v58, &v56);
                  KB::String::operator=((KB::String *)(v43 + 24), (KB::String *)v60);
                  KB::ByteString::operator=(v43 + 40, v61);
                  *((void *)v43 + 12) = v62;
                  *((_DWORD *)v43 + 26) = v63;
                  KB::String::operator=((KB::String *)(v43 + 56), (KB::String *)v64);
                  long long v44 = v66;
                  long long v46 = v67;
                  long long v45 = v68;
                  *((_OWORD *)v43 + 9) = v65;
                  *((_OWORD *)v43 + 10) = v44;
                  *((_OWORD *)v43 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v46;
                  *((_OWORD *)v43 + 12) = v45;
                  KB::String::operator=((KB::String *)(v43 + 104), (KB::String *)v69);
                  *((unsigned char *)v43 + 240) = v70;
                  if (v43 + 24 != (unsigned __int16 *)v60)
                  {
                    *((_DWORD *)v43 + 70) = v72;
                    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)v43 + 31, v71);
                  }
                  if (v59 && BYTE6(v58) == 1) {
                    free(v59);
                  }
                }
              }
            }
            KB::Word::~Word((KB::Word *)v60);
            v36 += 30;
          }
          v60[0] = (void **)v55;
          std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](v60);
          uint64_t v24 = (size_t *)&v51[240 * v50];
        }
      }
      KB::Word::~Word((KB::Word *)&v73);
      v25 += 30;
    }
    while (v25 != v24);
  }
LABEL_82:
  double v23 = v51;
  if (v50)
  {
    uint64_t v47 = 240 * v50;
    uint64_t v48 = (KB::Word *)v51;
    do
    {
      KB::Word::~Word(v48);
      uint64_t v48 = (KB::Word *)(v49 + 240);
      v47 -= 240;
    }
    while (v47);
  }
LABEL_85:
  free(v23);
}

uint64_t std::unordered_map<KB::String,KB::Word>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, *(void *)(a2 + 8));
  uint64_t v5 = *(void **)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = (void *)(a1 + 16);
    do
    {
      if (v5[3]) {
        uint64_t v7 = (KB::String *)v5[3];
      }
      else {
        uint64_t v7 = (KB::String *)(v5 + 4);
      }
      unsigned int v8 = KB::String::hash(v7, (const char *)*((unsigned __int16 *)v5 + 8));
      unint64_t v9 = v8;
      unint64_t v10 = *(void *)(a1 + 8);
      if (v10)
      {
        uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
        v11.i16[0] = vaddlv_u8(v11);
        unint64_t v12 = v11.u32[0];
        if (v11.u32[0] > 1uLL)
        {
          unint64_t v2 = v8;
          if (v10 <= v8) {
            unint64_t v2 = v8 % v10;
          }
        }
        else
        {
          unint64_t v2 = (v10 - 1) & v8;
        }
        BOOL v13 = *(void **)(*(void *)a1 + 8 * v2);
        if (v13)
        {
          BOOL v14 = (void *)*v13;
          if (*v13)
          {
            do
            {
              unint64_t v15 = v14[1];
              if (v15 == v9)
              {
                if (v14 == v5 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)(v5 + 2), 1)) {
                  goto LABEL_45;
                }
              }
              else
              {
                if (v12 > 1)
                {
                  if (v15 >= v10) {
                    v15 %= v10;
                  }
                }
                else
                {
                  v15 &= v10 - 1;
                }
                if (v15 != v2) {
                  break;
                }
              }
              BOOL v14 = (void *)*v14;
            }
            while (v14);
          }
        }
      }
      int v16 = operator new(0x120uLL);
      *int v16 = 0;
      v16[1] = v9;
      KB::String::String((KB::String *)(v16 + 2), (const KB::String *)(v5 + 2));
      KB::Word::Word((KB::Word *)(v16 + 6), v5 + 6);
      float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v18 = *(float *)(a1 + 32);
      if (!v10 || (float)(v18 * (float)v10) < v17)
      {
        BOOL v19 = (v10 & (v10 - 1)) != 0;
        if (v10 < 3) {
          BOOL v19 = 1;
        }
        unint64_t v20 = v19 | (2 * v10);
        unint64_t v21 = vcvtps_u32_f32(v17 / v18);
        if (v20 <= v21) {
          size_t v22 = v21;
        }
        else {
          size_t v22 = v20;
        }
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
        unint64_t v10 = *(void *)(a1 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v10 <= v9) {
            unint64_t v2 = v9 % v10;
          }
          else {
            unint64_t v2 = v9;
          }
        }
        else
        {
          unint64_t v2 = (v10 - 1) & v9;
        }
      }
      uint64_t v23 = *(void *)a1;
      uint64_t v24 = *(void **)(*(void *)a1 + 8 * v2);
      if (v24)
      {
        *int v16 = *v24;
      }
      else
      {
        *int v16 = *v6;
        *uint64_t v6 = v16;
        *(void *)(v23 + 8 * v2) = v6;
        if (!*v16) {
          goto LABEL_44;
        }
        unint64_t v25 = *(void *)(*v16 + 8);
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v25 >= v10) {
            v25 %= v10;
          }
        }
        else
        {
          v25 &= v10 - 1;
        }
        uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
      }
      void *v24 = v16;
LABEL_44:
      ++*(void *)(a1 + 24);
LABEL_45:
      uint64_t v5 = (void *)*v5;
    }
    while (v5);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    uint64_t v3 = v2;
    unint64_t v2 = (void *)*v2;
    KB::Word::~Word((KB::Word *)(v3 + 6));
    uint64_t v4 = (void *)v3[3];
    if (v4 && *((unsigned char *)v3 + 22) == 1) {
      free(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String const&>,std::tuple<>>(uint64_t a1, void *a2, const KB::String **a3)
{
  if (a2[1]) {
    uint64_t v7 = (KB::String *)a2[1];
  }
  else {
    uint64_t v7 = (KB::String *)(a2 + 2);
  }
  unsigned int v8 = KB::String::hash(v7, (const char *)*(unsigned __int16 *)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v10 <= v8) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    BOOL v13 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      BOOL v14 = *v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v9)
          {
            if (v14 + 2 == a2 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)a2, 1)) {
              return v14;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3) {
              break;
            }
          }
          BOOL v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
  BOOL v14 = operator new(0x120uLL);
  void *v14 = 0;
  v14[1] = v9;
  KB::String::String((KB::String *)(v14 + 2), *a3);
  *((_OWORD *)v14 + 16) = 0u;
  *((_OWORD *)v14 + 17) = 0u;
  *((_OWORD *)v14 + 14) = 0u;
  *((_OWORD *)v14 + 15) = 0u;
  *((_OWORD *)v14 + 12) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  KB::Word::Word((KB::Word *)(v14 + 6));
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    BOOL v18 = 1;
    if (v10 >= 3) {
      BOOL v18 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v10);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      size_t v21 = v20;
    }
    else {
      size_t v21 = v19;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v21);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    void *v14 = *v23;
LABEL_42:
    *uint64_t v23 = v14;
    goto LABEL_43;
  }
  void *v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    unint64_t v24 = *(void *)(*v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10) {
        v24 %= v10;
      }
    }
    else
    {
      v24 &= v10 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_42;
  }
LABEL_43:
  ++*(void *)(a1 + 24);
  return v14;
}

void *std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(uint64_t a1, void *a2, KB::String **a3)
{
  if (a2[1]) {
    uint64_t v7 = (KB::String *)a2[1];
  }
  else {
    uint64_t v7 = (KB::String *)(a2 + 2);
  }
  unsigned int v8 = KB::String::hash(v7, (const char *)*(unsigned __int16 *)a2);
  unint64_t v9 = v8;
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v10 <= v8) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    BOOL v13 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      BOOL v14 = *v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v9)
          {
            if (v14 + 2 == a2 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)a2, 1)) {
              return v14;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3) {
              break;
            }
          }
          BOOL v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
  BOOL v14 = operator new(0x120uLL);
  void *v14 = 0;
  v14[1] = v9;
  float v16 = *a3;
  *((_DWORD *)v14 + 4) = 0x100000;
  *((_WORD *)v14 + 10) = 0;
  *((unsigned char *)v14 + 22) = 0;
  unsigned __int16 v14[3] = 0;
  KB::String::operator=((uint64_t)(v14 + 2), v16);
  *((_OWORD *)v14 + 16) = 0u;
  *((_OWORD *)v14 + 17) = 0u;
  *((_OWORD *)v14 + 14) = 0u;
  *((_OWORD *)v14 + 15) = 0u;
  *((_OWORD *)v14 + 12) = 0u;
  *((_OWORD *)v14 + 13) = 0u;
  *((_OWORD *)v14 + 10) = 0u;
  *((_OWORD *)v14 + 1TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0u;
  *((_OWORD *)v14 + 8) = 0u;
  *((_OWORD *)v14 + 9) = 0u;
  *((_OWORD *)v14 + 6) = 0u;
  *((_OWORD *)v14 + 7) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_OWORD *)v14 + 5) = 0u;
  *((_OWORD *)v14 + 3) = 0u;
  KB::Word::Word((KB::Word *)(v14 + 6));
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v10 || (float)(v18 * (float)v10) < v17)
  {
    BOOL v19 = 1;
    if (v10 >= 3) {
      BOOL v19 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v10);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t v22 = v21;
    }
    else {
      size_t v22 = v20;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a1, v22);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v23 = *(void *)a1;
  unint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    void *v14 = *v24;
LABEL_42:
    void *v24 = v14;
    goto LABEL_43;
  }
  void *v14 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  *(void *)(v23 + 8 * v3) = a1 + 16;
  if (*v14)
  {
    unint64_t v25 = *(void *)(*v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v25 >= v10) {
        v25 %= v10;
      }
    }
    else
    {
      v25 &= v10 - 1;
    }
    unint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(void *)(a1 + 24);
  return v14;
}

__n128 std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74160;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x48uLL);
  *(void *)unint64_t v2 = &unk_1F3F74160;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(v2 + 40) = *(_OWORD *)(a1 + 40);
  __n128 result = *(__n128 *)(a1 + 56);
  *(__n128 *)(v2 + 56) = result;
  return result;
}

void std::__function::__func<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1},std::allocator<KB::FilterNotSuggestibleForInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0::operator() const(std::vector<KB::Candidate> &)::{lambda(KB::Candidate const&,KB::String *)#1}>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterNotSuggestibleForInput::filter_description(KB::FilterNotSuggestibleForInput *this)
{
  return "FilterNotSuggestibleForInput";
}

void KB::FilterNotSuggestibleForInput::~FilterNotSuggestibleForInput(KB::FilterNotSuggestibleForInput *this)
{
}

void KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::FilterNonVulgarIfTopCandidateVulgar *this, const KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (simular_swear_word_policy_v1_setting)
  {
    if (objc_msgSend((id)simular_swear_word_policy_v1_setting, "BOOLValue", a3)) {
      goto LABEL_3;
    }
  }
  else if (_os_feature_enabled_impl())
  {
LABEL_3:
    uint64_t v6 = *a2;
    if (*a2 == a2[1]) {
      return;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136315138;
      *(void *)((char *)buf + 4) = "filter_candidates";
      _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Swear Word Policy V1 Enabled", (uint8_t *)buf, 0xCu);
      uint64_t v6 = *a2;
    }
    KB::Candidate::Candidate((KB::Candidate *)buf, v6);
    if (*(void *)&buf[0])
    {
      uint64_t v7 = 240 * *(void *)&buf[0];
      uint64_t v8 = *((void *)&buf[0] + 1);
      while ((*(unsigned char *)(v8 + 107) & 8) == 0)
      {
        v8 += 240;
        v7 -= 240;
        if (!v7) {
          goto LABEL_23;
        }
      }
    }
    else
    {
      uint64_t v8 = *((void *)&buf[0] + 1);
    }
    if (v8 == *((void *)&buf[0] + 1) + 240 * *(void *)&buf[0]) {
      goto LABEL_23;
    }
    if (simular_swear_word_policy_v2_setting)
    {
      if (([(id)simular_swear_word_policy_v2_setting BOOLValue] & 1) == 0) {
        goto LABEL_21;
      }
    }
    else if (!_os_feature_enabled_impl())
    {
      goto LABEL_21;
    }
    uint64_t v9 = *((void *)a4 + 6);
    memset(v12, 0, sizeof(v12));
    int v13 = 1065353216;
    BOOL is_allowlisted = KB::Candidate::every_vulgar_word_is_allowlisted(buf, v9, v12, 0);
    std::__hash_table<std::__hash_value_type<KB::String,KB::Word>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,KB::Word>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,KB::Word>>>::~__hash_table((uint64_t)v12);
    if (is_allowlisted)
    {
LABEL_23:
      KB::Candidate::~Candidate((KB::Candidate *)buf);
      return;
    }
LABEL_21:
    *((_DWORD *)a2 + 25) |= 1u;
    if ((unint64_t)(0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3)) >= 2)
    {
      uint64_t v11 = *((void *)a4 + 7);
      v14[0] = &unk_1F3F74280;
      v14[1] = buf;
      unsigned __int16 v14[3] = v14;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v11, (uint64_t)"FilterNonVulgarIfTopCandidateVulgar", (uint64_t)v14);
      std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v14);
    }
    goto LABEL_23;
  }
  if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
  {
    LODWORD(buf[0]) = 136315138;
    *(void *)((char *)buf + 4) = "filter_candidates";
    _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Swear Word Policy V1 Disabled", (uint8_t *)buf, 0xCu);
  }
}

BOOL std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = v6 + 240 * *(void *)a2;
  if (*(void *)a2)
  {
    uint64_t v8 = 240 * *(void *)a2;
    while ((*(unsigned char *)(v6 + 107) & 8) == 0)
    {
      v6 += 240;
      v8 -= 240;
      if (!v8)
      {
        uint64_t v6 = v7;
        break;
      }
    }
  }
  if (v5) {
    BOOL v9 = v6 == v7;
  }
  else {
    BOOL v9 = 0;
  }
  if (v9)
  {
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG))
    {
      int v11 = *(unsigned __int16 *)(a2 + 888);
      if (!*(_WORD *)(a2 + 888))
      {
        KB::Candidate::compute_string((KB::Candidate *)a2);
        int v11 = *(unsigned __int16 *)(a2 + 888);
      }
      unint64_t v12 = *(const char **)(a2 + 896);
      if (!v12) {
        unint64_t v12 = (const char *)(a2 + 904);
      }
      if (v11) {
        int v13 = v12;
      }
      else {
        int v13 = "";
      }
      uint64_t v14 = *(void *)(a1 + 8);
      int v15 = *(unsigned __int16 *)(v14 + 888);
      if (!*(_WORD *)(v14 + 888))
      {
        KB::Candidate::compute_string((KB::Candidate *)v14);
        int v15 = *(unsigned __int16 *)(v14 + 888);
      }
      uint64_t v16 = *(const char **)(v14 + 896);
      if (!v16) {
        uint64_t v16 = (const char *)(v14 + 904);
      }
      *(_DWORD *)float v18 = 136315650;
      *(void *)&void v18[4] = "operator()";
      if (v15) {
        float v17 = v16;
      }
      else {
        float v17 = "";
      }
      *(_WORD *)&v18[12] = 2080;
      *(void *)&v18[14] = v13;
      __int16 v19 = 2080;
      unint64_t v20 = v17;
      _os_log_debug_impl(&dword_1E3F0E000, MEMORY[0x1E4F14500], OS_LOG_TYPE_DEBUG, "%s  Word %s is non-vulgar. Top candidate %s is a vulgar word leading to non-vulgar words to be removed.", v18, 0x20u);
    }
    KB::String::append_format(v5, "Word is non-vulgar. Top candidate is a vulgar word leading to non-vulgar words to be removed.", *(_OWORD *)v18);
  }
  return v6 == v7;
}

uint64_t std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F74280;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3F74280;
  result[1] = v3;
  return result;
}

void std::__function::__func<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNonVulgarIfTopCandidateVulgar::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterNonVulgarIfTopCandidateVulgar::filter_description(KB::FilterNonVulgarIfTopCandidateVulgar *this)
{
  return "FilterNonVulgarIfTopCandidateVulgar";
}

void KB::FilterNonVulgarIfTopCandidateVulgar::~FilterNonVulgarIfTopCandidateVulgar(KB::FilterNonVulgarIfTopCandidateVulgar *this)
{
}

void KB::FilterNumberMismatch::filter_candidates(KB::FilterNumberMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v13[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444)) {
    KB::Candidate::compute_string(a3);
  }
  if (KB::string_has_numbers(v7, a2))
  {
    BOOL has_nonnumbers = KB::string_has_nonnumbers((KB *)(*((void *)a3 + 1) + 240 * *(void *)a3 - 240), v8);
    unint64_t v10 = (__CFString *)*((void *)a4 + 7);
    if (has_nonnumbers)
    {
      v13[0] = &unk_1F3F742C8;
      v13[1] = a3;
      void v13[2] = a4;
      _OWORD v13[3] = v13;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, (uint64_t)v10, (uint64_t)"FilterNumberMismatch", (uint64_t)v13);
      std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v13);
    }
    else
    {
      if (v10) {
        CFStringAppendFormat(v10, 0, @"All candidates removed (last input word is purely numeric) by %s\n", "filter_candidates");
      }
      uint64_t v12 = *(void *)a2;
      for (uint64_t i = *((void *)a2 + 1); i != v12; KB::Candidate::~Candidate((KB::Candidate *)(i - 1000)))
        ;
      *((void *)a2 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v12;
    }
  }
}

BOOL std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  _OWORD v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  uint64_t v6 = (_LXLexicon *)(a2 + 444);
  if (!a2[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  KB::CandidateFilter::_sortkey_for_string(v6, *(const KB::String **)(a1 + 16), &v15);
  uint64_t v7 = *(_WORD **)(a1 + 8);
  uint64_t v8 = (_LXLexicon *)(v7 + 444);
  if (!v7[444]) {
    KB::Candidate::compute_string((KB::Candidate *)v7);
  }
  KB::CandidateFilter::_sortkey_for_string(v8, *(const KB::String **)(a1 + 16), &v14);
  BOOL v9 = KB::ByteString::starts_with((KB::ByteString *)&v15, &v14);
  BOOL v10 = v9;
  if (v5 && !v9)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)a2, (uint64_t)v17);
    int v11 = (const char *)v19;
    if (!v19) {
      int v11 = (const char *)v20;
    }
    if (v17[0]) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = "";
    }
    KB::String::append_format(v5, "'%s' does not preserve numbers typed in the input manager string", v12);
    if (v19 && v18 == 1) {
      free(v19);
    }
  }
  if (v14.var0.var0.var0 >= 0xFu && v14.var0.var0.var1) {
    MEMORY[0x1E4E7BC00](v14.var0.var0.var1, 0x1000C8077774924);
  }
  if (v15 >= 0xFu && v16) {
    MEMORY[0x1E4E7BC00](v16, 0x1000C8077774924);
  }
  return !v10;
}

__n128 std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F742C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F742C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterNumberMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterNumberMismatch::filter_description(KB::FilterNumberMismatch *this)
{
  return "FilterNumberMismatch";
}

void KB::FilterNumberMismatch::~FilterNumberMismatch(KB::FilterNumberMismatch *this)
{
}

uint64_t KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::FilterNumberlikeTokenMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444)) {
    KB::Candidate::compute_string(a3);
  }
  uint64_t result = KB::string_has_numbers(v7, a2);
  if (result)
  {
    uint64_t v30 = a2;
    if (*(void *)a3)
    {
      unint64_t v10 = 0;
      uint64_t v11 = 0;
      do
      {
        uint64_t v12 = (uint64_t *)(*((void *)a3 + 1) + 240 * v10);
        unsigned int v13 = KB::count_numbers((KB *)v12, v9);
        if (!v13) {
          goto LABEL_37;
        }
        if (v13 >= KB::count_letters((KB *)v12, v9)) {
          goto LABEL_36;
        }
        unsigned int v14 = *((unsigned __int16 *)v12 + 2);
        if (!*((_WORD *)v12 + 2))
        {
          KB::String::compute_length((unsigned __int16 *)v12);
          unsigned int v14 = *((unsigned __int16 *)v12 + 2);
        }
        if (v14 < 3) {
          goto LABEL_37;
        }
        uint64_t v15 = v12[1];
        if (!v15) {
          uint64_t v15 = (uint64_t)(v12 + 2);
        }
        uint64_t v38 = v15;
        LODWORD(v39) = 0;
        HIDWORD(v39) = *(unsigned __int16 *)v12;
        UChar32 c = 0;
        KB::String::iterator::initialize(&v38);
        TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::KeyClassification *)&v38, c);
        if ((v38 & 4) != 0)
        {
          uint64_t v16 = (atomic_uint *)*((void *)a4 + 2);
          if (v16)
          {
            atomic_fetch_add(v16, 1u);
            WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v16);
            float v17 = (unsigned __int16 *)v12[1];
            if (!v17) {
              float v17 = (unsigned __int16 *)(v12 + 2);
            }
            *(void *)&long long v33 = v17;
            DWORD2(v33) = 0;
            HIDWORD(v33) = *(unsigned __int16 *)v12;
            LODWORD(v34) = 0;
            KB::String::iterator::initialize((uint64_t *)&v33);
            long long v35 = v33;
            uint64_t v36 = v34;
            KB::String::iterator::operator++((uint64_t *)&v35);
            int v18 = *(unsigned __int16 *)v12;
            __int16 v19 = (unsigned __int16 *)v12[1];
            if (!v19) {
              __int16 v19 = (unsigned __int16 *)(v12 + 2);
            }
            *(void *)&long long v31 = v19;
            DWORD2(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v18;
            HIDWORD(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v18;
            LODWORD(v32) = 0;
            KB::String::iterator::initialize((uint64_t *)&v31);
            KB::String::String((KB::String *)&v38, (const KB::String::iterator *)&v35, (const KB::String::iterator *)&v31);
            unint64_t v20 = (atomic_uint *)*((void *)a4 + 2);
            if (v20)
            {
              atomic_fetch_add(v20, 1u);
              KB::DictionaryContainer::lookup((uint64_t)v20, &v35);
              WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v20);
            }
            else
            {
              KB::DictionaryContainer::lookup(0, &v35);
            }
            long long v21 = v35;
            *(void *)&long long v33 = &v35;
            std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v33);
            if (v39 && BYTE6(v38) == 1) {
              free(v39);
            }
            if ((void)v21 != *((void *)&v21 + 1)) {
              goto LABEL_36;
            }
          }
        }
        UChar32 v22 = KB::String::last((KB::String *)v12);
        TI::Favonius::KeyClassification::KeyClassification((TI::Favonius::KeyClassification *)&v38, v22);
        if ((v38 & 4) == 0) {
          goto LABEL_37;
        }
        uint64_t v23 = (atomic_uint *)*((void *)a4 + 2);
        if (!v23) {
          goto LABEL_37;
        }
        atomic_fetch_add(v23, 1u);
        WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v23);
        unint64_t v24 = v12[1] ? (unsigned __int16 *)v12[1] : (unsigned __int16 *)(v12 + 2);
        *(void *)&long long v35 = v24;
        DWORD2(v35) = 0;
        int v25 = *(unsigned __int16 *)v12;
        HIDWORD(v35) = v25;
        LODWORD(v36) = 0;
        KB::String::iterator::initialize((uint64_t *)&v35);
        *(void *)&long long v31 = v24;
        DWORD2(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v25;
        HIDWORD(v3TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v25;
        LODWORD(v32) = 0;
        KB::String::iterator::initialize((uint64_t *)&v31);
        long long v33 = v31;
        uint64_t v34 = v32;
        KB::String::iterator::operator--((KB::String::iterator *)&v33);
        KB::String::String((KB::String *)&v38, (const KB::String::iterator *)&v35, (const KB::String::iterator *)&v33);
        uint64_t v26 = (atomic_uint *)*((void *)a4 + 2);
        if (v26)
        {
          atomic_fetch_add(v26, 1u);
          KB::DictionaryContainer::lookup((uint64_t)v26, &v35);
          WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v26);
        }
        else
        {
          KB::DictionaryContainer::lookup(0, &v35);
        }
        long long v27 = v35;
        *(void *)&long long v33 = &v35;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)&v33);
        if (v39)
        {
          if (BYTE6(v38) == 1) {
            free(v39);
          }
        }
        if ((void)v27 != *((void *)&v27 + 1)) {
LABEL_36:
        }
          uint64_t v11 = ++v10;
        else {
LABEL_37:
        }
          ++v10;
      }
      while (v10 < *(void *)a3);
    }
    else
    {
      uint64_t v11 = 0;
    }
    uint64_t v28 = *((void *)a4 + 7);
    long long v29 = operator new(0x20uLL);
    *long long v29 = &unk_1F3F74310;
    v29[1] = a3;
    v29[2] = a4;
    void v29[3] = v11;
    void v37[3] = v29;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)v30, v28, (uint64_t)"FilterNumberlikeTokenMismatch", (uint64_t)v37);
    return (uint64_t)std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v37);
  }
  return result;
}

BOOL std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(void *a1, unint64_t *a2, KB::String **a3)
{
  uint64_t v5 = 0;
  unint64_t v6 = 0;
  uint64_t v23[2] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a3;
  do
  {
    unint64_t v8 = v6;
    unint64_t v9 = a1[3];
    if (v6 >= v9) {
      break;
    }
    if (v6 < *a2)
    {
      unint64_t v10 = a2[1];
      uint64_t v11 = *(void *)(a1[1] + 8);
      uint64_t v12 = *(void *)(a1[2] + 16);
      if (v12) {
        atomic_fetch_add((atomic_uint *volatile)v12, 1u);
      }
      unsigned int v13 = (KB::String *)(v10 + v5);
      unsigned int v14 = (KB::String *)(v11 + v5);
      uint64_t v15 = *(void *)(v12 + 8) + 144;
      WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v12);
      int v16 = KB::Word::preserves_input(v13, v14, v15) ^ 1;
      if (!v7) {
        goto LABEL_17;
      }
LABEL_9:
      if (v16)
      {
        KB::Word::capitalized_string((KB::Word *)(*(void *)(a1[1] + 8) + v5), (uint64_t)v20);
        float v17 = (const char *)v22;
        if (!v22) {
          float v17 = (const char *)v23;
        }
        int v18 = "";
        if (v20[0]) {
          int v18 = v17;
        }
        KB::String::append_format(v7, "Candidate does not preserve input word '%s', which contains numbers", v18);
        if (v22 && v21 == 1) {
          free(v22);
        }
      }
      goto LABEL_17;
    }
    int v16 = 1;
    if (v7) {
      goto LABEL_9;
    }
LABEL_17:
    unint64_t v6 = v8 + 1;
    v5 += 240;
  }
  while (!v16);
  return v8 < v9;
}

__n128 std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74310;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F74310;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterNumberlikeTokenMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterNumberlikeTokenMismatch::filter_description(KB::FilterNumberlikeTokenMismatch *this)
{
  return "FilterNumberlikeTokenMismatch";
}

void KB::FilterNumberlikeTokenMismatch::~FilterNumberlikeTokenMismatch(KB::FilterNumberlikeTokenMismatch *this)
{
}

void *KB::FilterCharacterCount::filter_candidates(KB::FilterCharacterCount *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = *((_DWORD *)this + 2);
  unint64_t v8 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444)) {
    KB::Candidate::compute_string(a3);
  }
  int v9 = KB::String::count(v8, v7);
  switch(*((_DWORD *)this + 3))
  {
    case 0:
      unint64_t v10 = std::cmp_less[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 1;
      uint64_t v12 = 60;
      break;
    case 1:
      unint64_t v10 = std::cmp_less_equal[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 2;
      uint64_t v12 = 15676;
      break;
    case 2:
      unint64_t v10 = std::cmp_equal[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 2;
      uint64_t v12 = 15677;
      break;
    case 3:
      unint64_t v10 = std::cmp_not_equal[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 2;
      uint64_t v12 = 15649;
      break;
    case 4:
      unint64_t v10 = std::cmp_greater_equal[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 2;
      uint64_t v12 = 15678;
      break;
    case 5:
      unint64_t v10 = std::cmp_greater[abi:nn180100]<unsigned int,unsigned int>;
      char v11 = 1;
      uint64_t v12 = 62;
      break;
    default:
      uint64_t v12 = 0;
      char v11 = 0;
      unint64_t v10 = 0;
      break;
  }
  unsigned int v13 = (char *)operator new(0x30uLL);
  *(void *)unsigned int v13 = &unk_1F3F74358;
  *((_DWORD *)v13 + 2) = v7;
  *((_DWORD *)v13 + 3) = v9;
  *((void *)v13 + 2) = v10;
  *((void *)v13 + 3) = v12;
  *((void *)v13 + 4) = 0;
  *(void *)(v13 + 39) = 0;
  v13[47] = v11;
  __int16 v17[3] = v13;
  uint64_t v14 = *((void *)a4 + 7);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::__value_func[abi:nn180100]((uint64_t)v16, (uint64_t)v17);
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v14, (uint64_t)"FilterCharacterCount", (uint64_t)v16);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v16);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v17);
}

uint64_t std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  _OWORD v19[2] = *MEMORY[0x1E4F143B8];
  long long v4 = *a3;
  uint64_t v5 = *(uint64_t (**)(uint64_t, void))(a1 + 16);
  unint64_t v6 = (KB::String *)(a2 + 444);
  if (!a2[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  uint64_t v7 = KB::String::count(v6, *(_DWORD *)(a1 + 8));
  int v8 = v5(v7, *(unsigned int *)(a1 + 12));
  int v9 = v8;
  if (v4 && (v8 & 1) == 0)
  {
    KB::String::String((uint64_t)v16, *(_DWORD *)(a1 + 8));
    unint64_t v10 = (const char *)v18;
    if (!v18) {
      unint64_t v10 = (const char *)v19;
    }
    if (v16[0]) {
      char v11 = v10;
    }
    else {
      char v11 = "";
    }
    uint64_t v14 = *(const char **)(a1 + 24);
    uint64_t v13 = a1 + 24;
    uint64_t v12 = v14;
    if (*(char *)(v13 + 23) >= 0) {
      uint64_t v12 = (const char *)v13;
    }
    KB::String::append_format(v4, "candidate count of '%s' is not %s input count", v11, v12);
    if (v18 && v17 == 1) {
      free(v18);
    }
  }
  return v9 ^ 1u;
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy_deallocate(void **__p)
{
  if (*((char *)__p + 47) < 0) {
    operator delete(__p[3]);
  }

  operator delete(__p);
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74358;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = (std::string *)(a2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v2, *(const std::string::value_type **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    long long v3 = *(_OWORD *)(a1 + 24);
    *(void *)(a2 + 40) = *(void *)(a1 + 40);
    *(_OWORD *)&v2->__r_.__value_.__l.__data_ = v3;
  }
}

char *std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_1F3F74358;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  long long v3 = (std::string *)(v2 + 24);
  if (*(char *)(a1 + 47) < 0)
  {
    std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a1 + 24), *(void *)(a1 + 32));
  }
  else
  {
    *(_OWORD *)&v3->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 24);
    *((void *)v2 + 5) = *(void *)(a1 + 40);
  }
  return v2;
}

void std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1F3F74358;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }

  JUMPOUT(0x1E4E7BC20);
}

uint64_t std::__function::__func<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCharacterCount::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1F3F74358;
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

BOOL std::cmp_greater[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a2 < a1;
}

BOOL std::cmp_greater_equal[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a1 >= a2;
}

BOOL std::cmp_not_equal[abi:nn180100]<unsigned int,unsigned int>(int a1, int a2)
{
  return a1 != a2;
}

BOOL std::cmp_equal[abi:nn180100]<unsigned int,unsigned int>(int a1, int a2)
{
  return a1 == a2;
}

BOOL std::cmp_less_equal[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a2 >= a1;
}

BOOL std::cmp_less[abi:nn180100]<unsigned int,unsigned int>(unsigned int a1, unsigned int a2)
{
  return a1 < a2;
}

const char *KB::FilterCharacterCount::filter_description(KB::FilterCharacterCount *this)
{
  return "FilterCharacterCount";
}

void KB::FilterCharacterCount::~FilterCharacterCount(KB::FilterCharacterCount *this)
{
}

void KB::FilterAlteredURLFragments::filter_candidates(KB::FilterAlteredURLFragments *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v14[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((unsigned __int16 *)a3 + 444);
  if (*((_WORD *)a3 + 444))
  {
    int v8 = (char *)*((void *)a3 + 112);
    if (!v8) {
      int v8 = (char *)a3 + 904;
    }
  }
  else
  {
    KB::Candidate::compute_string(a3);
    uint64_t v7 = *((unsigned __int16 *)a3 + 444);
    int v8 = (char *)*((void *)a3 + 112);
    if (!v8) {
      int v8 = (char *)a3 + 904;
    }
    if (!*((_WORD *)a3 + 444))
    {
      int v9 = v8;
      goto LABEL_13;
    }
  }
  int v9 = v8;
  while (*v9 != 46)
  {
    if (++v9 == &v8[v7])
    {
      int v9 = &v8[v7];
      break;
    }
  }
LABEL_13:
  if (v9 - v8 != v7 || *((unsigned char *)a3 + 3174))
  {
    uint64_t v10 = *((void *)a4 + 2);
    if (v10) {
      atomic_fetch_add((atomic_uint *volatile)v10, 1u);
    }
    uint64_t v11 = *(void *)(v10 + 8) + 144;
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v10);
    uint64_t v12 = *((void *)a4 + 7);
    uint64_t v13 = operator new(0x20uLL);
    *uint64_t v13 = &unk_1F3F743A0;
    v13[1] = a3;
    void v13[2] = v11;
    _OWORD v13[3] = a3;
    unsigned __int16 v14[3] = v13;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v12, (uint64_t)"FilterAlteredURLFragments", (uint64_t)v14);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v14);
  }
}

BOOL std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a3;
  unsigned int v6 = KB::Candidate::num_words_preserving_input(a2, *(void **)(a1 + 8), *(void *)(a1 + 16));
  uint64_t v7 = *(void *)(a1 + 8);
  int v8 = (unsigned char *)*(unsigned __int16 *)(v7 + 888);
  if (*(_WORD *)(v7 + 888))
  {
    int v9 = *(unsigned char **)(v7 + 896);
    if (!v9) {
      int v9 = (unsigned char *)(v7 + 904);
    }
  }
  else
  {
    KB::Candidate::compute_string(*(KB::Candidate **)(a1 + 8));
    int v8 = (unsigned char *)*(unsigned __int16 *)(v7 + 888);
    int v9 = *(unsigned char **)(v7 + 896);
    if (!v9) {
      int v9 = (unsigned char *)(v7 + 904);
    }
    if (!*(_WORD *)(v7 + 888))
    {
      uint64_t v10 = v9;
      goto LABEL_13;
    }
  }
  uint64_t v10 = v9;
  while (*v10 != 46)
  {
    if (++v10 == &v8[(void)v9])
    {
      uint64_t v10 = &v8[(void)v9];
      break;
    }
  }
LABEL_13:
  if ((unsigned char *)(v10 - v9) == v8)
  {
    if (*(unsigned char *)(*(void *)(a1 + 24) + 3176)) {
      BOOL v11 = v6 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    if (!v11) {
      return 0;
    }
    if (!v5) {
      return 1;
    }
    KB::Candidate::capitalized_string(a2, (uint64_t)v26);
    KB::String::append_format(v5, "candidate %s proceeds '.' in context and does not preserve input word url format");
LABEL_21:
    if (v28)
    {
      if (v27 == 1) {
        free(v28);
      }
    }
    return 1;
  }
  if (!v6) {
    return 0;
  }
  if (*(void *)a2 == v6) {
    return 0;
  }
  uint64_t v13 = *(void **)(a1 + 8);
  if (*v13 == v6) {
    return 0;
  }
  uint64_t v14 = v13[1];
  uint64_t v15 = v14 + 240 * (v6 - 1);
  int v16 = *(const char **)(v15 + 8);
  char v17 = (const char *)(v15 + 16);
  if (v16) {
    int v18 = v16;
  }
  else {
    int v18 = v17;
  }
  int v19 = strcmp(v18, ".");
  if (v19) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = v6 >= 2;
  }
  if (v20)
  {
    uint64_t v22 = v14 + 240 * (v6 - 2);
    uint64_t v23 = *(const char **)(v22 + 8);
    unint64_t v24 = (const char *)(v22 + 16);
    if (v23) {
      int v25 = v23;
    }
    else {
      int v25 = v24;
    }
    BOOL v21 = strcmp(v25, ".") == 0;
  }
  else
  {
    BOOL v21 = 0;
  }
  BOOL result = 0;
  if (!v19 && !v21)
  {
    BOOL result = (*(_DWORD *)(v14 + 240 * v6 + 132) & 0x4000000) == 0;
    if (v5)
    {
      if ((*(_DWORD *)(v14 + 240 * v6 + 132) & 0x4000000) == 0)
      {
        KB::Candidate::capitalized_string(a2, (uint64_t)v26);
        KB::String::append_format(v5, "candidate %s contains '.' and does not preserve input word url format");
        goto LABEL_21;
      }
    }
  }
  return result;
}

__n128 std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F743A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F743A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAlteredURLFragments::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterAlteredURLFragments::filter_description(KB::FilterAlteredURLFragments *this)
{
  return "FilterAlteredURLFragments";
}

void KB::FilterAlteredURLFragments::~FilterAlteredURLFragments(KB::FilterAlteredURLFragments *this)
{
}

void KB::FilterDoubleApostrophe::filter_candidates(KB::FilterDoubleApostrophe *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((unsigned __int16 *)a3 + 444);
  if (*((_WORD *)a3 + 444))
  {
    int v8 = (char *)*((void *)a3 + 112);
    if (!v8) {
      int v8 = (char *)a3 + 904;
    }
  }
  else
  {
    KB::Candidate::compute_string(a3);
    uint64_t v7 = *((unsigned __int16 *)a3 + 444);
    int v8 = (char *)*((void *)a3 + 112);
    if (!v8) {
      int v8 = (char *)a3 + 904;
    }
    if (!*((_WORD *)a3 + 444))
    {
      int v9 = v8;
      goto LABEL_13;
    }
  }
  int v9 = v8;
  while (*v9 != 39)
  {
    if (++v9 == &v8[v7])
    {
      int v9 = &v8[v7];
      break;
    }
  }
LABEL_13:
  if (v9 - v8 != v7)
  {
    uint64_t v10 = *((void *)a4 + 7);
    v11[0] = &unk_1F3F743E8;
    _WORD v11[3] = v11;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v10, (uint64_t)"FilterDoubleApostrophe", (uint64_t)v11);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v11);
  }
}

uint64_t std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, unint64_t *a2, KB::String **a3)
{
  unint64_t v3 = *a2;
  if (!*a2) {
    return 0;
  }
  unint64_t v4 = 0;
  uint64_t v5 = *a3;
  unint64_t v6 = a2[1];
  for (unsigned int i = 1; ; ++i)
  {
    if ((*(unsigned char *)(v6 + 240 * v4 + 135) & 4) != 0)
    {
      unint64_t v8 = v6 + 240 * v4;
      unint64_t v9 = *(void *)(v8 + 8);
      unint64_t v10 = v8 + 16;
      BOOL v11 = (const char *)(v9 ? v9 : v10);
      if (!strcmp(v11, "'"))
      {
        BOOL v12 = i != 1
           && (*(unsigned char *)(v6 + 240 * (i - 2) + 135) & 4) == 0
           && KB::String::last((KB::String *)(v6 + 240 * (i - 2))) == 39;
        if (v3 - 1 <= v4 || (*(unsigned char *)(v6 + 240 * i + 135) & 4) != 0)
        {
          BOOL v16 = 0;
        }
        else
        {
          uint64_t v13 = (unsigned __int16 *)(v6 + 240 * i);
          uint64_t v14 = *((void *)v13 + 1);
          if (!v14) {
            uint64_t v14 = (uint64_t)(v13 + 8);
          }
          uint64_t v19 = v14;
          int v15 = *v13;
          int v20 = 0;
          int v21 = v15;
          int v22 = 0;
          KB::String::iterator::initialize(&v19);
          BOOL v16 = v22 == 39;
        }
        if (v12 || v16) {
          break;
        }
      }
    }
    unint64_t v4 = i;
    if (v3 <= i) {
      return 0;
    }
  }
  if (v5) {
    KB::String::append_format(v5, "candidate contains word that has multiple adjacent apostrophes");
  }
  return 1;
}

void std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1F3F743E8;
}

void *std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1F3F743E8;
  return result;
}

void std::__function::__func<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDoubleApostrophe::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterDoubleApostrophe::filter_description(KB::FilterDoubleApostrophe *this)
{
  return "FilterDoubleApostrophe";
}

void KB::FilterDoubleApostrophe::~FilterDoubleApostrophe(KB::FilterDoubleApostrophe *this)
{
}

void *KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::FilterWordEndingApostropheBetweenNonseparators *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)a4 + 2);
  if (v7) {
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  }
  uint64_t v8 = *(void *)(v7 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  uint64_t v9 = *((void *)a4 + 7);
  v11[0] = &unk_1F3F74430;
  v11[1] = a3;
  void v11[2] = v8;
  _WORD v11[3] = v11;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v9, (uint64_t)"FilterWordEndingApostropheBetweenNonseparators", (uint64_t)v11);
  return std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v11);
}

void std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t a2, KB::String **a3)
{
  if (*(void *)a2 >= 3uLL)
  {
    uint64_t v5 = *a3;
    uint64_t v6 = *(void *)(a1 + 16);
    if (!*(_WORD *)(a2 + 888)) {
      KB::Candidate::compute_string((KB::Candidate *)a2);
    }
    uint64_t v7 = *(KB::Candidate **)(a1 + 8);
    if (!*((_WORD *)v7 + 444)) {
      KB::Candidate::compute_string(v7);
    }
    uint64_t v8 = *(void *)(v6 + 24);
    if (v8)
    {
      if (!(*(unsigned int (**)(uint64_t, uint64_t, _WORD *))(*(void *)v8 + 48))(v8, a2 + 888, (_WORD *)v7 + 444)&& (unint64_t)(*(void *)a2 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
      {
        uint64_t v9 = 1;
        for (uint64_t i = 612; ; i += 240)
        {
          uint64_t v11 = *(void *)(a2 + 8);
          BOOL v12 = (unsigned __int16 *)(v11 + i - 372);
          uint64_t v13 = (_WORD *)(v11 + i - 368);
          int v14 = (unsigned __int16)*v13;
          if (!*v13)
          {
            KB::String::compute_length((unsigned __int16 *)(v11 + i - 372));
            int v14 = (unsigned __int16)*v13;
          }
          if (v14 == 1)
          {
            uint64_t v15 = *(void *)(v11 + i - 364) ? *(void *)(v11 + i - 364) : v11 + i - 356;
            uint64_t v18 = v15;
            int v16 = *v12;
            int v19 = 0;
            int v20 = v16;
            int v21 = 0;
            KB::String::iterator::initialize(&v18);
            if (v21 == 39
              || (uint64_t v18 = v15, v19 = 0, v20 = v16, v21 = 0, KB::String::iterator::initialize(&v18), v21 == 8217))
            {
              if (((*(_DWORD *)(*(void *)(a2 + 8) + i - 480) | *(_DWORD *)(*(void *)(a2 + 8) + i)) & 0x4000000) == 0) {
                break;
              }
            }
          }
          if (++v9 >= (unint64_t)(*(void *)a2 - 1)) {
            return;
          }
        }
        if (v5) {
          KB::String::append_format(v5, "candidate is a word ending with an apostrophe between nonseparators");
        }
      }
    }
    else
    {
      char v17 = (char *)std::__throw_bad_function_call[abi:nn180100]();
      std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy_deallocate(v17);
    }
  }
}

__n128 std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74430;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F74430;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterWordEndingApostropheBetweenNonseparators::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterWordEndingApostropheBetweenNonseparators::filter_description(KB::FilterWordEndingApostropheBetweenNonseparators *this)
{
  return "FilterWordEndingApostropheBetweenNonseparators";
}

void KB::FilterWordEndingApostropheBetweenNonseparators::~FilterWordEndingApostropheBetweenNonseparators(KB::FilterWordEndingApostropheBetweenNonseparators *this)
{
}

void KB::FilterPopupVariantMismatch::filter_candidates(KB::FilterPopupVariantMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v11[4] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (unsigned char *)*((void *)a3 + 251);
  uint64_t v7 = (unsigned char *)*((void *)a3 + 252);
  if (v6 != v7)
  {
    while ((*v6 & 4) == 0)
    {
      v6 += 4;
      if (v6 == v7) {
        return;
      }
    }
  }
  if (v6 != v7)
  {
    uint64_t v8 = *(void *)a4;
    uint64_t v9 = *((void *)a4 + 7);
    unint64_t v10 = operator new(0x20uLL);
    void *v10 = &unk_1F3F74478;
    v10[1] = a3;
    void v10[2] = (char *)a3 + 2008;
    void v10[3] = v8;
    _WORD v11[3] = v10;
    KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v9, (uint64_t)"FilterPopupVariantMismatch", (uint64_t)v11);
    std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v11);
  }
}

BOOL std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, _WORD *a2, KB::String **a3)
{
  unint64_t v4 = *a3;
  uint64_t v5 = (KB *)(a2 + 444);
  if (!a2[444]) {
    KB::Candidate::compute_string((KB::Candidate *)a2);
  }
  uint64_t v6 = *(_WORD **)(a1 + 8);
  uint64_t v7 = (KB::String *)(v6 + 444);
  if (!v6[444]) {
    KB::Candidate::compute_string((KB::Candidate *)v6);
  }
  BOOL v8 = KB::FilterPopupVariantMismatch::candidate_matches_popup_variants(v5, v7, *(void **)(a1 + 16), *(const KB::String **)(a1 + 24));
  BOOL v9 = v8;
  if (v4 && !v8) {
    KB::String::append_format(v4, "candidate does not match popup variants");
  }
  return !v9;
}

BOOL KB::FilterPopupVariantMismatch::candidate_matches_popup_variants(KB *a1, KB::String *this, void *a3, const KB::String *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    unsigned int v8 = *((unsigned __int16 *)this + 2);
  }
  KB::lower_string(this, a4, (KB::String *)v27);
  KB::lower_string(a1, a4, (KB::String *)v25);
  KB::String::String((KB::String *)v22, (const KB::String *)v27);
  int v24 = 0;
  KB::String::String((KB::String *)v19, (const KB::String *)v25);
  int v21 = 0;
  if (v8)
  {
    unint64_t v9 = 0;
    BOOL v10 = 0;
    unint64_t v11 = v8;
    while (1)
    {
      if (v9 >= (uint64_t)(a3[1] - *a3) >> 2) {
        LOBYTE(v12) = 0;
      }
      else {
        int v12 = *(_DWORD *)(*a3 + 4 * v9);
      }
      uint64_t v13 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v22);
      int v14 = (KB *)KB::UTF8Iterator::next((KB::UTF8Iterator *)v19);
      UChar32 v15 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v22);
      UChar32 v16 = KB::UTF8Iterator::next((KB::UTF8Iterator *)v19);
      if ((v12 & 4) != 0) {
        break;
      }
LABEL_20:
      if (((0x4000050u >> u_charType(v15)) & 1) == 0) {
        KB::UTF8Iterator::prev((KB::UTF8Iterator *)v22);
      }
      if (((0x4000050u >> u_charType(v16)) & 1) == 0) {
        KB::UTF8Iterator::prev((KB::UTF8Iterator *)v19);
      }
      BOOL v10 = ++v9 >= v11;
      if (v11 == v9) {
        goto LABEL_29;
      }
    }
    if (v15 > 729)
    {
      if (v15 == 730 || v15 == 732 || v15 == 901) {
        goto LABEL_17;
      }
    }
    else if ((v15 - 168) <= 0xC && ((1 << (v15 + 88)) & 0x1081) != 0)
    {
      goto LABEL_17;
    }
    if (u_charType(v15) != 4)
    {
      if (!KB::substitution_allowed(v14, v13, 0, v17)) {
        goto LABEL_29;
      }
LABEL_18:
      if (u_charType(v13) == 6 && u_charType((UChar32)v14) != 6) {
        goto LABEL_29;
      }
      goto LABEL_20;
    }
LABEL_17:
    if (!KB::character_has_diacritic(v14, v15)) {
      goto LABEL_29;
    }
    goto LABEL_18;
  }
  BOOL v10 = 1;
LABEL_29:
  if (v20 && v19[6] == 1) {
    free(v20);
  }
  if (v23 && v22[6] == 1) {
    free(v23);
  }
  if (v26 && v25[6] == 1) {
    free(v26);
  }
  if (v28 && v27[6] == 1) {
    free(v28);
  }
  return v10;
}

__n128 std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1F3F74478;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterPopupVariantMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterPopupVariantMismatch::filter_description(KB::FilterPopupVariantMismatch *this)
{
  return "FilterPopupVariantMismatch";
}

void KB::FilterPopupVariantMismatch::~FilterPopupVariantMismatch(KB::FilterPopupVariantMismatch *this)
{
}

void KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::FilterAllCapsNoSuggestWordsOfLength *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4, uint64_t a5)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  unsigned int v8 = (const KB::CandidateFilterLookupContext *)((char *)a3 + 888);
  if (!*((_WORD *)a3 + 444))
  {
    KB::Candidate::compute_string(a3);
    if (!*((_WORD *)a3 + 444)) {
      KB::Candidate::compute_string(a3);
    }
  }
  KB::upper_string(v8, 0, a3, (uint64_t)a4, a5, (KB::String *)v16);
  if (v8 == (KB *)v16)
  {
    if (v18 && v17 == 1) {
      free(v18);
    }
  }
  else
  {
    BOOL v10 = KB::String::equal(v8, (const KB::String *)v16, 1);
    if (v18 && v17 == 1) {
      free(v18);
    }
    if (!v10)
    {
      int v11 = *((_DWORD *)this + 2);
      uint64_t v12 = *((void *)a4 + 7);
      uint64_t v13 = &unk_1F3F744C0;
      int v14 = v11;
      UChar32 v15 = &v13;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v12, (uint64_t)"FilterAllCapsNoSuggestWordsOfLength", (uint64_t)&v13);
      std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](&v13);
    }
  }
}

BOOL std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, uint64_t *a2, KB::String **a3)
{
  unint64_t v4 = *a3;
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  int v14 = ___ZZNK2KB35FilterAllCapsNoSuggestWordsOfLength17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesEENK3__0clERKNS_9CandidateEPNS_6StringE_block_invoke;
  UChar32 v15 = &__block_descriptor_tmp_68;
  int v16 = *(_DWORD *)(a1 + 8);
  if (v5)
  {
    uint64_t v8 = v6 + 240 * v5;
    uint64_t v9 = 240 * v5;
    while ((((uint64_t (*)(void *, uint64_t))v14)(v13, v6) & 1) == 0)
    {
      v6 += 240;
      v9 -= 240;
      if (!v9)
      {
        uint64_t v6 = v8;
        break;
      }
    }
    uint64_t v10 = v6;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
  }
  else
  {
    uint64_t v10 = v6;
  }
  uint64_t v11 = v6 + 240 * v5;
  if (v4 && v10 != v11) {
    KB::String::append_format(v4, "candidate word of length=%u is all-caps and not suggestible", *(_DWORD *)(a1 + 8));
  }
  return v10 != v11;
}

BOOL ___ZZNK2KB35FilterAllCapsNoSuggestWordsOfLength17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesEENK3__0clERKNS_9CandidateEPNS_6StringE_block_invoke(uint64_t a1, KB::String *this)
{
  int v4 = *((unsigned __int16 *)this + 2);
  if (!*((_WORD *)this + 2))
  {
    KB::String::compute_length((unsigned __int16 *)this);
    int v4 = *((unsigned __int16 *)this + 2);
  }
  if (*(_DWORD *)(a1 + 32) != v4) {
    return 0;
  }
  int v5 = *((_DWORD *)this + 26);
  if ((v5 & 0x800012) == 0)
  {
    int v6 = v5 & 0x2042000;
    if ((*((_DWORD *)this + 26) & 0x2080) != 0x80 && v6 != 0x2000000) {
      return 0;
    }
  }
  if (!v4)
  {
    KB::String::compute_length((unsigned __int16 *)this);
    LOWORD(v4) = *((_WORD *)this + 2);
  }
  return ((-1 << v4) | *((_DWORD *)this + 30)) == -1;
}

uint64_t std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F744C0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

_DWORD *std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_1F3F744C0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

void std::__function::__func<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterAllCapsNoSuggestWordsOfLength::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterAllCapsNoSuggestWordsOfLength::filter_description(KB::FilterAllCapsNoSuggestWordsOfLength *this)
{
  return "FilterAllCapsNoSuggestWordsOfLength";
}

void KB::FilterAllCapsNoSuggestWordsOfLength::~FilterAllCapsNoSuggestWordsOfLength(KB::FilterAllCapsNoSuggestWordsOfLength *this)
{
}

uint64_t KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::FilterMissingOneLetterWordFromInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  void v16[4] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *((void *)a4 + 2);
  if (v7) {
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  }
  uint64_t v8 = *(void *)(v7 + 8);
  uint64_t result = (uint64_t)WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  if (*(void *)a3)
  {
    uint64_t v10 = *((void *)a3 + 1);
    uint64_t v11 = v8 + 144;
    uint64_t v12 = 240 * *(void *)a3;
    uint64_t v13 = v10;
    do
    {
      if ((*(unsigned char *)(v13 + 135) & 4) == 0)
      {
        unsigned int v14 = *(unsigned __int16 *)(v13 + 4);
        if (!*(_WORD *)(v13 + 4))
        {
          uint64_t result = (uint64_t)KB::String::compute_length((unsigned __int16 *)v13);
          unsigned int v14 = *(unsigned __int16 *)(v13 + 4);
        }
        if (v14 <= 1)
        {
          uint64_t result = KB::FilterMissingOneLetterWordFromInput::word_is_static_and_suggestible_and_in_candidates((const KB::String *)v13, (uint64_t)a2);
          if (result)
          {
            uint64_t v15 = *((void *)a4 + 7);
            v16[0] = &unk_1F3F74508;
            v16[1] = v10;
            void v16[2] = v11;
            _WORD v16[3] = v16;
            KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v15, (uint64_t)"FilterMissingOneLetterWordFromInput", (uint64_t)v16);
            uint64_t result = (uint64_t)std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v16);
          }
        }
      }
      v13 += 240;
      v10 += 240;
      v12 -= 240;
    }
    while (v12);
  }
  return result;
}

uint64_t KB::FilterMissingOneLetterWordFromInput::word_is_static_and_suggestible_and_in_candidates(const KB::String *a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  unint64_t v3 = *(void **)(a2 + 8);
  if (*(void **)a2 == v3) {
    return 0;
  }
  while (!*v2)
  {
LABEL_14:
    v2 += 125;
    if (v2 == v3) {
      return 0;
    }
  }
  uint64_t v5 = v2[1];
  uint64_t v6 = 240 * *v2;
  while (1)
  {
    if ((*(unsigned char *)(v5 + 135) & 4) == 0 && ((const KB::String *)v5 == a1 || KB::String::equal((KB::String *)v5, a1, 1)))
    {
      int v7 = *(_DWORD *)(v5 + 104);
      if ((v7 & 0x800012) == 0)
      {
        int v8 = v7 & 0x40000;
        if ((*(_DWORD *)(v5 + 104) & 0x2080) != 0x80 && v8 != 0) {
          return 1;
        }
      }
    }
    v5 += 240;
    v6 -= 240;
    if (!v6) {
      goto LABEL_14;
    }
  }
}

void std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, void *a2, KB::String **a3)
{
  if (*a2)
  {
    unsigned __int8 v4 = 0;
    unsigned __int8 v5 = 0;
    uint64_t v6 = *a3;
    uint64_t v7 = a2[1];
    uint64_t v8 = 240 * *a2;
    do
    {
      if ((*(unsigned char *)(v7 + 135) & 4) == 0)
      {
        int v9 = *(unsigned __int16 *)(v7 + 4);
        if (!*(_WORD *)(v7 + 4))
        {
          KB::String::compute_length((unsigned __int16 *)v7);
          int v9 = *(unsigned __int16 *)(v7 + 4);
        }
        if (v9 == 1)
        {
          uint64_t v10 = *(void *)(*(void *)(a1 + 16) + 24);
          if (!v10)
          {
            uint64_t v12 = (char *)std::__throw_bad_function_call[abi:nn180100]();
            std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::destroy_deallocate(v12);
            return;
          }
          int v11 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v10 + 48))(v10, v7, *(void *)(a1 + 8));
          v5 |= v11 != 0;
          v4 |= v11 == 0;
        }
      }
      v7 += 240;
      v8 -= 240;
    }
    while (v8);
    if (v6)
    {
      if (v4 & (v5 ^ 1)) {
        KB::String::append_format(v6, "candidate does not preserve original 1 letter word");
      }
    }
  }
}

__n128 std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1F3F74508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterMissingOneLetterWordFromInput::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterMissingOneLetterWordFromInput::filter_description(KB::FilterMissingOneLetterWordFromInput *this)
{
  return "FilterMissingOneLetterWordFromInput";
}

void KB::FilterMissingOneLetterWordFromInput::~FilterMissingOneLetterWordFromInput(KB::FilterMissingOneLetterWordFromInput *this)
{
}

uint64_t KB::FilterCorrectionsIfAnyCandidateMatchesInput::filter_candidates(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v8 = *((void *)a4 + 2);
  if (v8) {
    atomic_fetch_add((atomic_uint *volatile)v8, 1u);
  }
  uint64_t v9 = *(void *)(v8 + 8);
  uint64_t result = (uint64_t)WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v8);
  int v11 = *(void **)a2;
  uint64_t v12 = (void *)*((void *)a2 + 1);
  if (*(void **)a2 != v12)
  {
    uint64_t v13 = v9 + 144;
    while (1)
    {
      if ((*(unsigned char *)(v11[1] + 240 * *v11 - 134) & 0x80) == 0)
      {
        uint64_t result = KB::CandidateFilter::candidate_matches_input((uint64_t)v11, (uint64_t)a3, v13);
        if (result) {
          break;
        }
        if (*((unsigned char *)a3 + 2000))
        {
          uint64_t result = KB::CandidateFilter::candidate_matches_input((uint64_t)v11, (uint64_t)a3 + 1000, v13);
          if (result) {
            break;
          }
        }
      }
      v11 += 125;
      if (v11 == v12)
      {
        int v11 = v12;
        break;
      }
    }
    if (v11 != *((void **)a2 + 1)
      && 0x1CAC083126E978D5 * (((uint64_t)v11 - *(void *)a2) >> 3) <= *((unsigned int *)this + 2))
    {
      int v14 = *(_DWORD *)a3;
      return (uint64_t)KB::CandidateFilter::remove_candidates_with_input_mismatch((uint64_t)this, (uint64_t)a2, v14, (uint64_t)a3, (uint64_t)a4, (uint64_t)"match length is equal to the number of input words");
    }
  }
  return result;
}

const char *KB::FilterCorrectionsIfAnyCandidateMatchesInput::filter_description(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this)
{
  return "FilterCorrectionsIfAnyCandidateMatchesInput";
}

void KB::FilterCorrectionsIfAnyCandidateMatchesInput::~FilterCorrectionsIfAnyCandidateMatchesInput(KB::FilterCorrectionsIfAnyCandidateMatchesInput *this)
{
}

void *KB::FilterNondominantCorrectionOfMoreWords::filter_candidates(KB::FilterNondominantCorrectionOfMoreWords *this, KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  int matched = KB::FilterNondominantCorrectionOfMoreWords::required_candidate_input_word_match_count((uint64_t)this, a2, a3, (uint64_t)a4);

  return KB::CandidateFilter::remove_candidates_with_input_mismatch((uint64_t)this, (uint64_t)a2, matched, (uint64_t)a3, (uint64_t)a4, (uint64_t)"match length is equal to the max input length which has a boosted omega > top candidate");
}

uint64_t KB::FilterNondominantCorrectionOfMoreWords::required_candidate_input_word_match_count(uint64_t a1, KB::Candidate **a2, void *a3, uint64_t a4)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  if (*a2 == a2[1]) {
    return 0;
  }
  uint64_t v7 = *(void *)(a4 + 16);
  if (v7) {
    atomic_fetch_add((atomic_uint *volatile)v7, 1u);
  }
  uint64_t v8 = *(void *)(v7 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v7);
  uint64_t v9 = *a2;
  float v10 = expf(*((float *)*a2 + 186));
  uint64_t v22 = v8;
  unsigned int v21 = KB::Candidate::num_words_matching_input(v9, a3, v8);
  uint64_t v11 = 8;
  if (*a3 - (unint64_t)v21 > 1) {
    uint64_t v11 = 12;
  }
  float v12 = *(float *)(a1 + v11);
  KB::Candidate::capitalized_string(*a2, (uint64_t)v31);
  KB::String::String((KB::String *)v28, "");
  KB::String::replace_char((KB::String *)v31, (const KB::String *)v28, 39, (uint64_t)v34);
  KB::String::String((KB::String *)v25, "");
  KB::String::replace_char((KB::String *)v34, (const KB::String *)v25, 8217, (uint64_t)v37);
  if (v27 && v26 == 1) {
    free(v27);
  }
  if (v36 && v35 == 1) {
    free(v36);
  }
  if (v30 && v29 == 1) {
    free(v30);
  }
  if (v33 && v32 == 1) {
    free(v33);
  }
  uint64_t v13 = *a2;
  if ((unint64_t)(0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3)) < 2)
  {
    uint64_t v14 = 0;
    goto LABEL_47;
  }
  uint64_t v14 = 0;
  unsigned int v15 = 2;
  uint64_t v16 = 1;
  while (1)
  {
    KB::Candidate::capitalized_string((KB::Candidate *)((char *)v13 + 1000 * v16), (uint64_t)v28);
    KB::String::String((KB::String *)v25, "");
    KB::String::replace_char((KB::String *)v28, (const KB::String *)v25, 39, (uint64_t)v31);
    KB::String::String((KB::String *)v23, "");
    KB::String::replace_char((KB::String *)v31, (const KB::String *)v23, 8217, (uint64_t)v34);
    if (v24 && v23[6] == 1) {
      free(v24);
    }
    if (v33 && v32 == 1) {
      free(v33);
    }
    if (v27 && v26 == 1) {
      free(v27);
    }
    if (v30 && v29 == 1) {
      free(v30);
    }
    if (KB::String::equal((KB::String *)v37, (const KB::String *)v34, 1)) {
      goto LABEL_40;
    }
    if ((float)(v12 * expf(*((float *)v13 + 250 * v16 + 186))) < v10) {
      break;
    }
    unsigned int v17 = KB::Candidate::num_words_matching_input((void *)v13 + 125 * v16, a3, v22);
    if (v14 <= v17) {
      unsigned int v18 = v17;
    }
    else {
      unsigned int v18 = v14;
    }
    if (v17 <= v21) {
      uint64_t v14 = v14;
    }
    else {
      uint64_t v14 = v18;
    }
LABEL_40:
    if (v36 && v35 == 1) {
      free(v36);
    }
    uint64_t v16 = v15;
    uint64_t v13 = *a2;
    if (0x1CAC083126E978D5 * ((a2[1] - *a2) >> 3) <= (unint64_t)v15++) {
      goto LABEL_47;
    }
  }
  if (v36 && v35 == 1) {
    free(v36);
  }
LABEL_47:
  if (v38 && v37[6] == 1) {
    free(v38);
  }
  return v14;
}

const char *KB::FilterNondominantCorrectionOfMoreWords::filter_description(KB::FilterNondominantCorrectionOfMoreWords *this)
{
  return "FilterNondominantCorrectionOfMoreWords";
}

void KB::FilterNondominantCorrectionOfMoreWords::~FilterNondominantCorrectionOfMoreWords(KB::FilterNondominantCorrectionOfMoreWords *this)
{
}

void KB::FilterInputPrefixMismatch::filter_candidates(KB::FilterInputPrefixMismatch *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v34[125] = *MEMORY[0x1E4F143B8];
  KB::Candidate::Candidate((KB::Candidate *)v34, a3);
  if (!v34[0]) {
    goto LABEL_58;
  }
  uint64_t v7 = v34[1] + 240 * v34[0];
  if ((*(unsigned char *)(v7 - 105) & 4) == 0)
  {
    uint64_t v8 = (KB::Word *)(v7 - 240);
    uint64_t v9 = (atomic_uint *)*((void *)a4 + 2);
    if (!v9)
    {
LABEL_11:
      KB::Candidate::capitalized_string((KB::Candidate *)v34, (uint64_t)&v32);
      int v12 = WORD2(v32);
      if (!WORD2(v32))
      {
        KB::String::compute_length((unsigned __int16 *)&v32);
        int v12 = WORD2(v32);
      }
      KB::Word::capitalized_string(v8, (uint64_t)&v30);
      int v13 = WORD2(v30);
      if (!WORD2(v30))
      {
        KB::String::compute_length((unsigned __int16 *)&v30);
        int v13 = WORD2(v30);
      }
      int v14 = v12 - ((v13 - *((_DWORD *)this + 2)) & ~((v13 - *((_DWORD *)this + 2)) >> 31));
      if (v31 && BYTE6(v30) == 1) {
        free(v31);
      }
      goto LABEL_21;
    }
    atomic_fetch_add(v9, 1u);
    WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v9);
    float v10 = (atomic_uint *)*((void *)a4 + 2);
    if (v10)
    {
      atomic_fetch_add(v10, 1u);
      KB::DictionaryContainer::lookup((uint64_t)v10, &v32);
      WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v10);
    }
    else
    {
      KB::DictionaryContainer::lookup(0, &v32);
    }
    for (uint64_t i = v32; ; i += 240)
    {
      if (i == v33)
      {
        uint64_t v30 = (void **)&v32;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v30);
        goto LABEL_11;
      }
      if ((i[107] & 0x10) != 0) {
        break;
      }
    }
    uint64_t v30 = (void **)&v32;
    std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v30);
  }
  KB::Candidate::capitalized_string((KB::Candidate *)v34, (uint64_t)&v32);
  int v14 = WORD2(v32);
  if (!WORD2(v32))
  {
    KB::String::compute_length((unsigned __int16 *)&v32);
    int v14 = WORD2(v32);
  }
LABEL_21:
  if (*((void *)this + 2) >= (unint64_t)(0x1CAC083126E978D5
                                                 * ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3)))
    unint64_t v15 = 0x1CAC083126E978D5 * ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3);
  else {
    unint64_t v15 = *((void *)this + 2);
  }
  KB::String::String((KB::String *)&v30, (const KB::String *)&v32);
  if ((_WORD)v30)
  {
    while (1)
    {
      uint64_t v16 = *((void *)a4 + 2);
      if (v16) {
        atomic_fetch_add((atomic_uint *volatile)v16, 1u);
      }
      uint64_t v17 = *(void *)(v16 + 8) + 112;
      WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v16);
      std::__function::__value_func<KB::ByteString ()(KB::String const&)>::__value_func[abi:nn180100]((uint64_t)v29, v17);
      KB::CandidateFilter::_sortkey_for_string((_LXLexicon *)&v30, a4, &v25);
      v24[0] = &v25;
      v24[1] = v29;
      unsigned int v18 = *(KB::Candidate **)a2;
      uint64_t v19 = (KB::Candidate *)*((void *)a2 + 1);
      if (*(KB::Candidate **)a2 == v19)
      {
        unint64_t v20 = 0;
      }
      else
      {
        unint64_t v20 = 0;
        do
        {
          BOOL v21 = KB::Candidate::sort_key(v18, (uint64_t)v29);
          v20 += KB::ByteString::starts_with((KB::ByteString *)v21, &v25);
          unsigned int v18 = (KB::Candidate *)((char *)v18 + 1000);
        }
        while (v18 != v19);
      }
      if (v20 >= v15) {
        break;
      }
      int v22 = WORD2(v30);
      if (!WORD2(v30))
      {
        KB::String::compute_length((unsigned __int16 *)&v30);
        int v22 = WORD2(v30);
      }
      if (v14 >= v22) {
        break;
      }
      if (!v22)
      {
        KB::String::compute_length((unsigned __int16 *)&v30);
        LOWORD(v22) = WORD2(v30);
      }
      KB::String::shorten((KB::String *)&v30, (unsigned __int16)(v22 - 1), (uint64_t)v26);
      KB::String::operator=((uint64_t)&v30, (KB::String *)v26);
      if (v27 && v26[6] == 1) {
        free(v27);
      }
      if (v25.var0.var0.var0 >= 0xFu && v25.var0.var0.var1) {
        MEMORY[0x1E4E7BC00](v25.var0.var0.var1, 0x1000C8077774924);
      }
      std::__function::__value_func<KB::ByteString ()(KB::String const&)>::~__value_func[abi:nn180100](v29);
      if (!(_WORD)v30) {
        goto LABEL_52;
      }
    }
    if (v20 < 0x1CAC083126E978D5 * ((uint64_t)(*((void *)a2 + 1) - *(void *)a2) >> 3))
    {
      uint64_t v23 = *((void *)a4 + 7);
      v28[0] = &unk_1F3F74550;
      v28[1] = v24;
      void v28[3] = v28;
      KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v23, (uint64_t)"FilterInputPrefixMismatch", (uint64_t)v28);
      std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v28);
    }
    if (v25.var0.var0.var0 >= 0xFu && v25.var0.var0.var1) {
      MEMORY[0x1E4E7BC00](v25.var0.var0.var1, 0x1000C8077774924);
    }
    std::__function::__value_func<KB::ByteString ()(KB::String const&)>::~__value_func[abi:nn180100](v29);
  }
LABEL_52:
  if (v31 && BYTE6(v30) == 1) {
    free(v31);
  }
  if (v33 && BYTE6(v32) == 1) {
    free(v33);
  }
LABEL_58:
  KB::Candidate::~Candidate((KB::Candidate *)v34);
}

uint64_t std::__function::__value_func<KB::ByteString ()(KB::String const&)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<KB::ByteString ()(KB::String const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL std::__function::__func<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2,std::allocator<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  uint64_t v3 = *a3;
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL v5 = KB::Candidate::sort_key(a2, *(void *)(v4 + 8));
  BOOL v6 = KB::ByteString::starts_with((KB::ByteString *)v5, *(const ByteString **)v4);
  BOOL v7 = v6;
  if (v3 && !v6) {
    KB::String::append_format(v3, "candidate does not contain the original input as a prefix");
  }
  return !v7;
}

uint64_t std::__function::__func<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2,std::allocator<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F74550;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2,std::allocator<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1F3F74550;
  result[1] = v3;
  return result;
}

void std::__function::__func<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2,std::allocator<KB::FilterInputPrefixMismatch::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_2>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterInputPrefixMismatch::filter_description(KB::FilterInputPrefixMismatch *this)
{
  return "FilterInputPrefixMismatch";
}

void KB::FilterInputPrefixMismatch::~FilterInputPrefixMismatch(KB::FilterInputPrefixMismatch *this)
{
}

void KB::AddAlternativesForRetrocorrection::filter_candidates(KB::AddAlternativesForRetrocorrection *this, size_t ***a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  if (HIBYTE(add_alternatives_for_retrocorrection_override))
  {
    if (!(_BYTE)add_alternatives_for_retrocorrection_override) {
      return;
    }
  }
  else if (!_os_feature_enabled_impl())
  {
    return;
  }
  std::string::basic_string[abi:nn180100]<0>(__p, "were");
  std::string::basic_string[abi:nn180100]<0>(v62, "we're");
  std::string::basic_string[abi:nn180100]<0>(v63, "well");
  std::string::basic_string[abi:nn180100]<0>(v64, "we'll");
  uint64_t v5 = 0;
  memset(v56, 0, sizeof(v56));
  int v57 = 1065353216;
  do
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v56, (uint64_t)&__p[v5], (uint64_t)&__p[v5]);
    v5 += 3;
  }
  while (v5 != 12);
  for (uint64_t i = 0; i != -12; i -= 3)
  {
    if (SHIBYTE(v64[i + 2]) < 0) {
      operator delete((void *)v64[i]);
    }
  }
  int64x2_t v54 = 0uLL;
  unint64_t v55 = 0;
  BOOL v7 = *a2;
  uint64_t v8 = a2[1];
  if (*a2 != v8)
  {
    uint64_t v47 = a2[1];
    do
    {
      uint64_t v9 = v7[1];
      if (*(_WORD *)v9)
      {
        if (v9[1]) {
          float v10 = (char *)v9[1];
        }
        else {
          float v10 = (char *)(v9 + 2);
        }
      }
      else
      {
        float v10 = "";
      }
      unsigned int v11 = *((_DWORD *)v9 + 26);
      std::string::basic_string[abi:nn180100]<0>(__p, v10);
      int v12 = std::__hash_table<std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::unordered_set<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::unordered_set<std::string>>>>::find<std::string>(v56, (uint64_t)__p);
      if (SHIBYTE(v61) < 0) {
        operator delete(__p[0]);
      }
      int v13 = (v11 >> 17) & 1;
      if (v12) {
        int v13 = 1;
      }
      if ((unint64_t)*v7 >= 2 && v13 != 0)
      {
        KB::Word::Word((KB::Word *)v66, v7[1]);
        uint64_t v48 = 0;
        uint64_t v49 = &v48;
        uint64_t v50 = 0x4002000000;
        uint64_t v51 = __Block_byref_object_copy__5246;
        uint64_t v52 = __Block_byref_object_dispose__5247;
        memset(v53, 0, sizeof(v53));
        if ((v11 & 0x20000) != 0)
        {
          unint64_t v15 = (atomic_uint *)*((void *)a4 + 2);
          if (v15) {
            atomic_fetch_add(v15, 1u);
          }
          KB::cf_string_impl<KB::String>((CFStringRef *)__p, (unsigned __int16 *)v66);
          uint64_t v16 = __p[0];
          v64[116] = MEMORY[0x1E4F143A8];
          v64[117] = 1174405120;
          v64[118] = ___ZNK2KB33AddAlternativesForRetrocorrection17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesE_block_invoke;
          v64[119] = &unk_1F3F73D60;
          KB::Word::Word((KB::Word *)v65, v66);
          v64[120] = &v48;
          LXLexiconEnumerateEntriesForString();
          if (v16) {
            CFRelease(v16);
          }
          WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v15);
          KB::Word::~Word((KB::Word *)v65);
        }
        else if (v12)
        {
          uint64_t v17 = (atomic_uint *)*((void *)a4 + 2);
          if (v17)
          {
            atomic_fetch_add(v17, 1u);
            KB::DictionaryContainer::derive_static_words((KB::DictionaryContainer *)v17, v49 + 5, (unsigned __int16 *)v66);
            WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v17);
          }
          else
          {
            KB::DictionaryContainer::derive_static_words(0, v53, (unsigned __int16 *)v66);
          }
        }
        unsigned int v18 = (size_t *)v49[5];
        uint64_t v19 = (size_t *)v49[6];
        while (v18 != v19)
        {
          if (!KB::String::equal((KB::String *)v18, (const KB::String *)v66, 0))
          {
            KB::Candidate::Candidate((KB::Candidate *)__p, (const KB::Candidate *)v7);
            KB::Candidate::clear((KB::Candidate *)__p);
            KB::Candidate::append((unsigned __int16 *)__p, v18);
            if ((unint64_t)*v7 >= 2)
            {
              uint64_t v20 = 30;
              unint64_t v21 = 1;
              do
              {
                KB::Candidate::append((unsigned __int16 *)__p, &v7[1][v20]);
                ++v21;
                v20 += 30;
              }
              while ((unint64_t)*v7 > v21);
            }
            if (a2[1] == *a2)
            {
LABEL_54:
              if (v54.i64[1] >= v55)
              {
                uint64_t v27 = 0x1CAC083126E978D5 * ((v54.i64[1] - v54.i64[0]) >> 3);
                unint64_t v28 = v27 + 1;
                if ((unint64_t)(v27 + 1) > 0x4189374BC6A7EFLL) {
LABEL_94:
                }
                  abort();
                if (0x395810624DD2F1AALL * ((uint64_t)(v55 - v54.i64[0]) >> 3) > v28) {
                  unint64_t v28 = 0x395810624DD2F1AALL * ((uint64_t)(v55 - v54.i64[0]) >> 3);
                }
                if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(v55 - v54.i64[0]) >> 3)) >= 0x20C49BA5E353F7) {
                  unint64_t v29 = 0x4189374BC6A7EFLL;
                }
                else {
                  unint64_t v29 = v28;
                }
                char v70 = &v55;
                if (v29) {
                  unint64_t v29 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v29);
                }
                else {
                  uint64_t v30 = 0;
                }
                long long v31 = (KB::Candidate *)(v29 + 1000 * v27);
                unint64_t v67 = v29;
                v68.i64[0] = (uint64_t)v31;
                unint64_t v69 = v29 + 1000 * v30;
                KB::Candidate::Candidate(v31, (const KB::Candidate *)__p);
                char v26 = (char *)v31 + 1000;
                v68.i64[1] = (uint64_t)v31 + 1000;
                uint64_t v32 = v54.i64[1];
                uint64_t v33 = v54.i64[0];
                uint64_t v34 = v68.i64[0];
                if (v54.i64[1] == v54.i64[0])
                {
                  int64x2_t v35 = vdupq_n_s64(v54.u64[1]);
                }
                else
                {
                  do
                  {
                    v32 -= 1000;
                    uint64_t v34 = KB::Candidate::Candidate(v34 - 1000, v32);
                  }
                  while (v32 != v33);
                  int64x2_t v35 = v54;
                  char v26 = (char *)v68.i64[1];
                }
                v54.i64[0] = v34;
                v54.i64[1] = (uint64_t)v26;
                int64x2_t v68 = v35;
                unint64_t v36 = v55;
                unint64_t v55 = v69;
                unint64_t v69 = v36;
                unint64_t v67 = v35.i64[0];
                std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)&v67);
              }
              else
              {
                char v26 = (char *)KB::Candidate::Candidate((KB::Candidate *)v54.i64[1], (const KB::Candidate *)__p) + 1000;
              }
              v54.i64[1] = (uint64_t)v26;
            }
            else
            {
              uint64_t v22 = 0;
              unint64_t v23 = 0;
              while (1)
              {
                KB::Candidate::capitalized_string((KB::Candidate *)__p, (uint64_t)&v67);
                KB::Candidate::capitalized_string((KB::Candidate *)&(*a2)[v22], (uint64_t)v58);
                BOOL v24 = KB::String::equal((KB::String *)&v67, (const KB::String *)v58, 1);
                if (v59) {
                  BOOL v25 = v58[6] == 1;
                }
                else {
                  BOOL v25 = 0;
                }
                if (v25) {
                  free(v59);
                }
                if (v68.i64[0] && BYTE6(v67) == 1) {
                  free((void *)v68.i64[0]);
                }
                if (v24) {
                  break;
                }
                ++v23;
                v22 += 125;
                if (0x1CAC083126E978D5 * (a2[1] - *a2) <= v23) {
                  goto LABEL_54;
                }
              }
            }
            KB::Candidate::~Candidate((KB::Candidate *)__p);
          }
          v18 += 30;
        }
        _Block_object_dispose(&v48, 8);
        __p[0] = v53;
        std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
        KB::Word::~Word((KB::Word *)v66);
        uint64_t v8 = v47;
      }
      v7 += 125;
    }
    while (v7 != v8);
    uint64_t v38 = (const KB::Candidate *)v54.i64[1];
    unint64_t v37 = (const KB::Candidate *)v54.i64[0];
    if (v54.i64[0] != v54.i64[1])
    {
      uint64_t v39 = a2 + 2;
      long long v40 = (KB::Candidate *)a2[1];
      do
      {
        if ((unint64_t)v40 >= *v39)
        {
          uint64_t v41 = 0x1CAC083126E978D5 * ((v40 - (KB::Candidate *)*a2) >> 3);
          unint64_t v42 = v41 + 1;
          if ((unint64_t)(v41 + 1) > 0x4189374BC6A7EFLL) {
            goto LABEL_94;
          }
          if (0x395810624DD2F1AALL * ((uint64_t)(*v39 - (void)*a2) >> 3) > v42) {
            unint64_t v42 = 0x395810624DD2F1AALL * ((uint64_t)(*v39 - (void)*a2) >> 3);
          }
          if ((unint64_t)(0x1CAC083126E978D5 * ((uint64_t)(*v39 - (void)*a2) >> 3)) >= 0x20C49BA5E353F7) {
            unint64_t v43 = 0x4189374BC6A7EFLL;
          }
          else {
            unint64_t v43 = v42;
          }
          v62[1] = a2 + 2;
          if (v43) {
            unint64_t v43 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Candidate>>(v43);
          }
          else {
            uint64_t v44 = 0;
          }
          long long v45 = (char *)(v43 + 1000 * v41);
          __p[0] = (void *)v43;
          __p[1] = v45;
          v62[0] = v43 + 1000 * v44;
          KB::Candidate::Candidate((KB::Candidate *)v45, v37);
          uint64_t v61 = v45 + 1000;
          std::vector<KB::Candidate>::__swap_out_circular_buffer((uint64_t *)a2, __p);
          long long v40 = (KB::Candidate *)a2[1];
          std::__split_buffer<KB::Candidate>::~__split_buffer((uint64_t)__p);
        }
        else
        {
          KB::Candidate::Candidate(v40, v37);
          long long v40 = (KB::Candidate *)((char *)v40 + 1000);
        }
        a2[1] = (size_t **)v40;
        unint64_t v37 = (const KB::Candidate *)((char *)v37 + 1000);
      }
      while (v37 != v38);
    }
  }
  __p[0] = &v54;
  std::vector<KB::Candidate>::__destroy_vector::operator()[abi:nn180100]((void ***)__p);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v56);
}

__n128 __Block_byref_object_copy__5246(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__5247(uint64_t a1)
{
  uint64_t v1 = (void **)(a1 + 40);
  std::vector<KB::Word>::__destroy_vector::operator()[abi:nn180100](&v1);
}

void ___ZNK2KB33AddAlternativesForRetrocorrection17filter_candidatesERNS_19CandidateCollectionERKNS_28CandidateFilterLookupContextERKNS_24CandidateFilterResourcesE_block_invoke(uint64_t a1, uint64_t a2)
{
  v18[30] = *MEMORY[0x1E4F143B8];
  KB::Word::Word((uint64_t)v18, a2, *(_DWORD *)(a1 + 176));
  uint64_t v3 = *(uint64_t **)(*(void *)(a1 + 32) + 8);
  uint64_t v4 = (KB::Word *)v3[6];
  unint64_t v5 = v3[7];
  if ((unint64_t)v4 >= v5)
  {
    uint64_t v7 = v3[5];
    unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * (((uint64_t)v4 - v7) >> 4);
    if (v8 + 1 > 0x111111111111111) {
      abort();
    }
    unint64_t v9 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v5 - v7) >> 4);
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= v8 + 1) {
      uint64_t v10 = v8 + 1;
    }
    if (v9 >= 0x88888888888888) {
      unint64_t v11 = 0x111111111111111;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t v17 = v3 + 7;
    if (v11) {
      unint64_t v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<KB::Word>>(v11);
    }
    else {
      uint64_t v12 = 0;
    }
    unint64_t v13 = v11;
    int v14 = (KB::Word *)(v11 + 240 * v8);
    unint64_t v16 = v11 + 240 * v12;
    KB::Word::Word(v14, v18);
    unint64_t v15 = (char *)v14 + 240;
    std::vector<KB::Word>::__swap_out_circular_buffer(v3 + 5, &v13);
    BOOL v6 = (char *)v3[6];
    std::__split_buffer<KB::Word>::~__split_buffer((uint64_t)&v13);
  }
  else
  {
    BOOL v6 = (char *)KB::Word::Word(v4, v18) + 240;
  }
  void v3[6] = (uint64_t)v6;
  KB::Word::~Word((KB::Word *)v18);
}

void __destroy_helper_block_8_40c14_ZTSN2KB4WordE(uint64_t a1)
{
}

KB::Word *__copy_helper_block_8_40c14_ZTSN2KB4WordE(uint64_t a1, uint64_t a2)
{
  return KB::Word::Word((KB::Word *)(a1 + 40), (size_t *)(a2 + 40));
}

const char *KB::AddAlternativesForRetrocorrection::filter_description(KB::AddAlternativesForRetrocorrection *this)
{
  return "AddAlternativesForRetrocorrection";
}

void KB::AddAlternativesForRetrocorrection::~AddAlternativesForRetrocorrection(KB::AddAlternativesForRetrocorrection *this)
{
}

uint64_t KB::FilterDuplicates::filter_candidates(KB::FilterDuplicates *this, KB::CandidateCollection *a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  v12[4] = *MEMORY[0x1E4F143B8];
  memset(v9, 0, sizeof(v9));
  int v10 = 1065353216;
  uint64_t v6 = *((void *)a4 + 7);
  v12[0] = &unk_1F3F74598;
  v12[1] = v9;
  _WORD v12[3] = v12;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v6, (uint64_t)"FilterDuplicates", (uint64_t)v12);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v12);
  uint64_t v7 = *((void *)a4 + 7);
  v11[0] = &unk_1F3F745E0;
  v11[1] = v9;
  _WORD v11[3] = v11;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2 + 24, v7, (uint64_t)"FilterDuplicates", (uint64_t)v11);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v11);
  return std::__hash_table<std::__hash_value_type<KB::String,_LXLexicon const*>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,_LXLexicon const*>>>::~__hash_table((uint64_t)v9);
}

uint64_t std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, unsigned __int16 **a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a3;
  KB::Candidate::capitalized_string(a2, (uint64_t)v11);
  uint64_t v6 = (const char *)v13;
  if (!v13) {
    uint64_t v6 = (const char *)&v14;
  }
  if (v11[0]) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = "";
  }
  KB::String::format((KB::String *)"Removing duplicate candidate with string %s from linguistic_alternate candidate list.", (uint64_t)v15, v7);
  if (v13 && v12 == 1) {
    free(v13);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  KB::String::String((KB::String *)v11, (const KB::String *)v15);
  uint64_t is_duplicate_candidate = KB::FilterDuplicates::is_duplicate_candidate(a2, v8, v5, (KB::String *)v11);
  if (v13 && v12 == 1) {
    free(v13);
  }
  if (v16 && v15[6] == 1) {
    free(v16);
  }
  return is_duplicate_candidate;
}

uint64_t KB::FilterDuplicates::is_duplicate_candidate(KB::Candidate *a1, uint64_t a2, unsigned __int16 *a3, KB::String *a4)
{
  v47[2] = *MEMORY[0x1E4F143B8];
  KB::Candidate::capitalized_string(a1, (uint64_t)v44);
  uint64_t v7 = (KB::String *)v46;
  if (v46) {
    uint64_t v8 = (KB::String *)v46;
  }
  else {
    uint64_t v8 = (KB::String *)v47;
  }
  unint64_t v9 = v44[0];
  unsigned int v10 = KB::String::hash(v8, (const char *)v44[0]);
  unint64_t v11 = *(void *)(a2 + 8);
  if (v11)
  {
    uint64_t v41 = a4;
    uint64_t v12 = v10;
    uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v13.i16[0] = vaddlv_u8(v13);
    unint64_t v14 = v13.u32[0];
    if (v13.u32[0] > 1uLL)
    {
      unint64_t v15 = v10;
      if (v11 <= v10) {
        unint64_t v15 = v10 % v11;
      }
    }
    else
    {
      unint64_t v15 = (v11 - 1) & v10;
    }
    unint64_t v16 = *(uint64_t ***)(*(void *)a2 + 8 * v15);
    if (v16)
    {
      uint64_t v17 = (uint64_t **)*v16;
      if (*v16)
      {
        while (1)
        {
          unint64_t v18 = (unint64_t)v17[1];
          if (v18 == v12)
          {
            if (v17 + 2 == (uint64_t **)v44 || KB::String::equal((KB::String *)(v17 + 2), (const KB::String *)v44, 1))
            {
              if (a3) {
                KB::String::append(a3, v41);
              }
              uint64_t v38 = 1;
              goto LABEL_69;
            }
          }
          else
          {
            if (v14 > 1)
            {
              if (v18 >= v11) {
                v18 %= v11;
              }
            }
            else
            {
              v18 &= v11 - 1;
            }
            if (v18 != v15)
            {
LABEL_21:
              uint64_t v7 = (KB::String *)v46;
              unint64_t v9 = v44[0];
              unint64_t v11 = *(void *)(a2 + 8);
              break;
            }
          }
          uint64_t v17 = (uint64_t **)*v17;
          if (!v17) {
            goto LABEL_21;
          }
        }
      }
    }
  }
  if (v7) {
    uint64_t v19 = v7;
  }
  else {
    uint64_t v19 = (KB::String *)v47;
  }
  unsigned int v20 = KB::String::hash(v19, (const char *)v9);
  unint64_t v21 = v20;
  if (v11)
  {
    uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v22.i16[0] = vaddlv_u8(v22);
    unint64_t v23 = v22.u32[0];
    if (v22.u32[0] > 1uLL)
    {
      unint64_t v9 = v20;
      if (v11 <= v20) {
        unint64_t v9 = v20 % v11;
      }
    }
    else
    {
      unint64_t v9 = (v11 - 1) & v20;
    }
    BOOL v24 = *(uint64_t ***)(*(void *)a2 + 8 * v9);
    if (v24)
    {
      BOOL v25 = (uint64_t **)*v24;
      if (*v24)
      {
        do
        {
          unint64_t v26 = (unint64_t)v25[1];
          if (v26 == v21)
          {
            if (v25 + 2 == (uint64_t **)v44 || KB::String::equal((KB::String *)(v25 + 2), (const KB::String *)v44, 1)) {
              goto LABEL_68;
            }
          }
          else
          {
            if (v23 > 1)
            {
              if (v26 >= v11) {
                v26 %= v11;
              }
            }
            else
            {
              v26 &= v11 - 1;
            }
            if (v26 != v9) {
              break;
            }
          }
          BOOL v25 = (uint64_t **)*v25;
        }
        while (v25);
      }
    }
  }
  uint64_t v27 = (void *)(a2 + 16);
  unint64_t v28 = operator new(0x30uLL);
  v42[1] = a2 + 16;
  void *v28 = 0;
  v28[1] = v21;
  KB::String::String((KB::String *)(v28 + 2), (const KB::String *)v44);
  char v43 = 1;
  float v29 = (float)(unint64_t)(*(void *)(a2 + 24) + 1);
  float v30 = *(float *)(a2 + 32);
  if (!v11 || (float)(v30 * (float)v11) < v29)
  {
    BOOL v31 = 1;
    if (v11 >= 3) {
      BOOL v31 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v11);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t v34 = v33;
    }
    else {
      size_t v34 = v32;
    }
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>(a2, v34);
    unint64_t v11 = *(void *)(a2 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v11 <= v21) {
        unint64_t v9 = v21 % v11;
      }
      else {
        unint64_t v9 = v21;
      }
    }
    else
    {
      unint64_t v9 = (v11 - 1) & v21;
    }
  }
  uint64_t v35 = *(void *)a2;
  unint64_t v36 = *(void **)(*(void *)a2 + 8 * v9);
  if (v36)
  {
    void *v28 = *v36;
  }
  else
  {
    void *v28 = *v27;
    *uint64_t v27 = v28;
    *(void *)(v35 + 8 * v9) = v27;
    if (!*v28) {
      goto LABEL_67;
    }
    unint64_t v37 = *(void *)(*v28 + 8);
    if ((v11 & (v11 - 1)) != 0)
    {
      if (v37 >= v11) {
        v37 %= v11;
      }
    }
    else
    {
      v37 &= v11 - 1;
    }
    unint64_t v36 = (void *)(*(void *)a2 + 8 * v37);
  }
  *unint64_t v36 = v28;
LABEL_67:
  v42[0] = 0;
  ++*(void *)(a2 + 24);
  std::unique_ptr<std::__hash_node<KB::String,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<KB::String,void *>>>>::reset[abi:nn180100](v42);
LABEL_68:
  uint64_t v38 = 0;
LABEL_69:
  if (v46) {
    BOOL v39 = v45 == 1;
  }
  else {
    BOOL v39 = 0;
  }
  if (v39) {
    free(v46);
  }
  return v38;
}

void std::unique_ptr<std::__hash_node<KB::String,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<KB::String,void *>>>>::reset[abi:nn180100](uint64_t *a1)
{
  uint64_t v1 = *a1;
  *a1 = 0;
  if (v1)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v2 = *(void **)(v1 + 24);
      if (v2)
      {
        if (*(unsigned char *)(v1 + 22) == 1) {
          free(v2);
        }
      }
    }
    operator delete((void *)v1);
  }
}

uint64_t std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F745E0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3F745E0;
  result[1] = v3;
  return result;
}

void std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_1>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

uint64_t std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, unsigned __int16 **a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a3;
  KB::Candidate::capitalized_string(a2, (uint64_t)v11);
  uint64_t v6 = (const char *)v13;
  if (!v13) {
    uint64_t v6 = (const char *)&v14;
  }
  if (v11[0]) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = "";
  }
  KB::String::format((KB::String *)"Removing duplicate candidate with string %s from linguistic candidate list.", (uint64_t)v15, v7);
  if (v13 && v12 == 1) {
    free(v13);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  KB::String::String((KB::String *)v11, (const KB::String *)v15);
  uint64_t is_duplicate_candidate = KB::FilterDuplicates::is_duplicate_candidate(a2, v8, v5, (KB::String *)v11);
  if (v13 && v12 == 1) {
    free(v13);
  }
  if (v16 && v15[6] == 1) {
    free(v16);
  }
  return is_duplicate_candidate;
}

uint64_t std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1F3F74598;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1F3F74598;
  result[1] = v3;
  return result;
}

void std::__function::__func<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterDuplicates::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterDuplicates::filter_description(KB::FilterDuplicates *this)
{
  return "FilterDuplicates";
}

void KB::FilterDuplicates::~FilterDuplicates(KB::FilterDuplicates *this)
{
}

void KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::FilterCaseVariantsOfStaticWords *this, const KB::Candidate **a2, const KB::CandidateFilterLookupContext *a3, const KB::CandidateFilterResources *a4)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)std::vector<unsigned int> __p = 0u;
  long long v49 = 0u;
  int v50 = 1065353216;
  unint64_t v5 = *a2;
  char v45 = a2[1];
  if (*a2 != v45)
  {
    while (1)
    {
      long long v46 = v5;
      KB::Candidate::Candidate((KB::Candidate *)&v59, v5);
      int v47 = 0;
      unint64_t v6 = v59;
      if (v59) {
        break;
      }
LABEL_67:
      KB::Candidate::~Candidate((KB::Candidate *)&v59);
      unint64_t v5 = (const KB::Candidate *)((char *)v46 + 1000);
      if ((const KB::Candidate *)((char *)v46 + 1000) == v45) {
        goto LABEL_68;
      }
    }
    int v7 = 0;
    uint64_t v8 = 0;
    while ((*(unsigned char *)(v60 + 240 * v8 + 106) & 4) == 0)
    {
LABEL_66:
      int v47 = ++v7;
      uint64_t v8 = v7;
      if (v6 <= v7) {
        goto LABEL_67;
      }
    }
    if (!std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::find<int>(__p, v7))
    {
      unint64_t v9 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)__p, v7, &v47);
      unsigned int v10 = v9;
      if (*((void *)v9 + 6))
      {
        std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__deallocate_node(*((void **)v9 + 5));
        *((void *)v10 + 5) = 0;
        uint64_t v11 = *((void *)v10 + 4);
        if (v11)
        {
          for (uint64_t i = 0; i != v11; ++i)
            *(void *)(*((void *)v10 + 3) + 8 * i) = 0;
        }
        *((void *)v10 + 6) = 0;
      }
      uint8x8_t v13 = (void *)*((void *)v10 + 3);
      *((void *)v10 + 3) = 0;
      if (v13) {
        operator delete(v13);
      }
      *((void *)v10 + 4) = 0;
      *((void *)v10 + 5) = 0;
      *((void *)v10 + 6) = 0;
      *((_DWORD *)v10 + 14) = 1065353216;
      std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__deallocate_node(0);
    }
    uint64_t v14 = (uint64_t *)(std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t *)__p, v7, &v47)+ 24);
    KB::lower_string((KB *)(v60 + 240 * v7), 0, (KB::String *)&v57);
    int64x2_t v54 = (char *)&v57;
    unint64_t v15 = std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(v14, &v57, (KB::String **)&v54);
    unint64_t v16 = v15 + 6;
    KB::Word::capitalized_string((KB::Word *)(v60 + 240 * v7), (uint64_t)&v54);
    if (v55) {
      uint64_t v17 = (KB::String *)v55;
    }
    else {
      uint64_t v17 = (KB::String *)&v56;
    }
    unsigned int v18 = KB::String::hash(v17, (const char *)(unsigned __int16)v54);
    unint64_t v19 = v18;
    unint64_t v20 = v15[7];
    if (v20)
    {
      uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
      v21.i16[0] = vaddlv_u8(v21);
      unint64_t v22 = v21.u32[0];
      if (v21.u32[0] > 1uLL)
      {
        unint64_t v4 = v18;
        if (v20 <= v18) {
          unint64_t v4 = v18 % v20;
        }
      }
      else
      {
        unint64_t v4 = (v20 - 1) & v18;
      }
      unint64_t v23 = *(uint64_t ***)(*v16 + 8 * v4);
      if (v23)
      {
        BOOL v24 = (uint64_t **)*v23;
        if (*v23)
        {
          do
          {
            unint64_t v25 = (unint64_t)v24[1];
            if (v25 == v19)
            {
              if (v24 + 2 == (uint64_t **)&v54
                || KB::String::equal((KB::String *)(v24 + 2), (const KB::String *)&v54, 1))
              {
                goto LABEL_56;
              }
            }
            else
            {
              if (v22 > 1)
              {
                if (v25 >= v20) {
                  v25 %= v20;
                }
              }
              else
              {
                v25 &= v20 - 1;
              }
              if (v25 != v4) {
                break;
              }
            }
            BOOL v24 = (uint64_t **)*v24;
          }
          while (v24);
        }
      }
    }
    unint64_t v26 = v15 + 8;
    uint64_t v27 = operator new(0x30uLL);
    v51[1] = (uint64_t)(v15 + 8);
    *uint64_t v27 = 0;
    v27[1] = v19;
    *((_DWORD *)v27 + 4) = 0x100000;
    *((_WORD *)v27 + 10) = 0;
    *((unsigned char *)v27 + 22) = 0;
    void v27[3] = 0;
    KB::String::operator=((uint64_t)(v27 + 2), (KB::String *)&v54);
    char v52 = 1;
    float v28 = (float)(unint64_t)(v15[9] + 1);
    float v29 = *((float *)v15 + 20);
    if (!v20 || (float)(v29 * (float)v20) < v28)
    {
      BOOL v30 = (v20 & (v20 - 1)) != 0;
      if (v20 < 3) {
        BOOL v30 = 1;
      }
      unint64_t v31 = v30 | (2 * v20);
      unint64_t v32 = vcvtps_u32_f32(v28 / v29);
      if (v31 <= v32) {
        size_t v33 = v32;
      }
      else {
        size_t v33 = v31;
      }
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__rehash<true>((uint64_t)v16, v33);
      unint64_t v20 = v15[7];
      if ((v20 & (v20 - 1)) != 0)
      {
        if (v20 <= v19) {
          unint64_t v4 = v19 % v20;
        }
        else {
          unint64_t v4 = v19;
        }
      }
      else
      {
        unint64_t v4 = (v20 - 1) & v19;
      }
    }
    uint64_t v34 = *v16;
    uint64_t v35 = *(void **)(*v16 + 8 * v4);
    if (v35)
    {
      *uint64_t v27 = *v35;
    }
    else
    {
      *uint64_t v27 = *v26;
      *unint64_t v26 = v27;
      *(void *)(v34 + 8 * v4) = v26;
      if (!*v27) {
        goto LABEL_55;
      }
      unint64_t v36 = *(void *)(*v27 + 8);
      if ((v20 & (v20 - 1)) != 0)
      {
        if (v36 >= v20) {
          v36 %= v20;
        }
      }
      else
      {
        v36 &= v20 - 1;
      }
      uint64_t v35 = (void *)(*v16 + 8 * v36);
    }
    *uint64_t v35 = v27;
LABEL_55:
    v51[0] = 0;
    ++v15[9];
    std::unique_ptr<std::__hash_node<KB::String,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<KB::String,void *>>>>::reset[abi:nn180100](v51);
LABEL_56:
    if (v55) {
      BOOL v37 = BYTE6(v54) == 1;
    }
    else {
      BOOL v37 = 0;
    }
    if (v37) {
      free(v55);
    }
    if (v58 && BYTE6(v57) == 1) {
      free(v58);
    }
    int v7 = v47;
    unint64_t v6 = v59;
    goto LABEL_66;
  }
LABEL_68:
  uint64_t v38 = *((void *)a4 + 7);
  v53[0] = &unk_1F3F74628;
  v53[1] = a3;
  v53[2] = __p;
  uint64_t v53[3] = v53;
  KB::CandidateFilter::remove_candidates_satisfying_predicate((uint64_t)a2, v38, (uint64_t)"FilterCaseVariantsOfStaticWords", (uint64_t)v53);
  std::__function::__value_func<BOOL ()(KB::Candidate const&,KB::String *)>::~__value_func[abi:nn180100](v53);
  BOOL v39 = (void *)v49;
  if ((void)v49)
  {
    do
    {
      long long v40 = (void *)*v39;
      std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::~__hash_table((uint64_t)(v39 + 3));
      operator delete(v39);
      BOOL v39 = v40;
    }
    while (v40);
  }
  uint64_t v41 = __p[0];
  __p[0] = 0;
  if (v41) {
    operator delete(v41);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::find<int>(void *a1, int a2)
{
  unint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a2;
    if (v2 <= a2) {
      unint64_t v4 = a2 % v2;
    }
  }
  else
  {
    unint64_t v4 = (v2 - 1) & a2;
  }
  unint64_t v5 = *(uint64_t ***)(*a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (__n128 result = *v5; result; __n128 result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a2)
    {
      if (*((_DWORD *)result + 4) == a2) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2) {
          v7 %= v2;
        }
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t *a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      unsigned int v10 = (char *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3) {
              break;
            }
          }
          unsigned int v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
  char v12 = a1 + 2;
  unsigned int v10 = (char *)operator new(0x40uLL);
  *(void *)unsigned int v10 = 0;
  *((void *)v10 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v13 = (float)(unint64_t)(a1[3] + 1);
  float v14 = *((float *)a1 + 8);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = a1[1];
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unint64_t v19 = operator new(8 * *(void *)&prime);
          unint64_t v20 = (void *)*a1;
          *a1 = (uint64_t)v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          unint64_t v22 = (void *)*v12;
          if (*v12)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v23) = v12;
            float v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*a1 + 8 * v29))
                  {
                    *(void *)(*a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *unint64_t v22 = *v28;
                  void *v28 = **(void **)(*a1 + 8 * v29);
                  **(void **)(*a1 + 8 * v29) = v28;
                  float v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                unint64_t v22 = v28;
                float v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        uint64_t v34 = (void *)*a1;
        *a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *a1;
  unint64_t v31 = *(void **)(*a1 + 8 * v3);
  if (v31)
  {
    *(void *)unsigned int v10 = *v31;
LABEL_72:
    *unint64_t v31 = v10;
    goto LABEL_73;
  }
  *(void *)unsigned int v10 = *v12;
  *char v12 = v10;
  *(void *)(v30 + 8 * v3) = v12;
  if (*(void *)v10)
  {
    unint64_t v32 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++a1[3];
  return v10;
}

uint64_t std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__deallocate_node(*(void **)(a1 + 16));
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void *std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(uint64_t *a1, void *a2, KB::String **a3)
{
  if (a2[1]) {
    unint64_t v7 = (KB::String *)a2[1];
  }
  else {
    unint64_t v7 = (KB::String *)(a2 + 2);
  }
  unsigned int v8 = KB::String::hash(v7, (const char *)*(unsigned __int16 *)a2);
  unint64_t v9 = v8;
  unint64_t v10 = a1[1];
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    unint64_t v12 = v11.u32[0];
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v10 <= v8) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    float v13 = *(void ***)(*a1 + 8 * v3);
    if (v13)
    {
      float v14 = *v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v9)
          {
            if (v14 + 2 == a2 || KB::String::equal((KB::String *)(v14 + 2), (const KB::String *)a2, 1)) {
              return v14;
            }
          }
          else
          {
            if (v12 > 1)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v3) {
              break;
            }
          }
          float v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
  unint64_t v16 = a1 + 2;
  float v14 = operator new(0x58uLL);
  void *v14 = 0;
  v14[1] = v9;
  unint64_t v17 = *a3;
  *((_DWORD *)v14 + 4) = 0x100000;
  *((_WORD *)v14 + 10) = 0;
  *((unsigned char *)v14 + 22) = 0;
  unsigned __int16 v14[3] = 0;
  KB::String::operator=((uint64_t)(v14 + 2), v17);
  *((_OWORD *)v14 + 3) = 0u;
  *((_OWORD *)v14 + 4) = 0u;
  *((_DWORD *)v14 + 20) = 1065353216;
  float v18 = (float)(unint64_t)(a1[3] + 1);
  float v19 = *((float *)a1 + 8);
  if (!v10 || (float)(v19 * (float)v10) < v18)
  {
    BOOL v20 = 1;
    if (v10 >= 3) {
      BOOL v20 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v10);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      int8x8_t prime = (int8x8_t)v22;
    }
    else {
      int8x8_t prime = (int8x8_t)v21;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    }
    unint64_t v10 = a1[1];
    if (*(void *)&prime > v10) {
      goto LABEL_34;
    }
    if (*(void *)&prime < v10)
    {
      unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v10 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (*(void *)&prime <= v30) {
        int8x8_t prime = (int8x8_t)v30;
      }
      if (*(void *)&prime >= v10)
      {
        unint64_t v10 = a1[1];
      }
      else
      {
        if (prime)
        {
LABEL_34:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint8x8_t v24 = operator new(8 * *(void *)&prime);
          unint64_t v25 = (void *)*a1;
          *a1 = (uint64_t)v24;
          if (v25) {
            operator delete(v25);
          }
          uint64_t v26 = 0;
          a1[1] = (uint64_t)prime;
          do
            *(void *)(*a1 + 8 * v26++) = 0;
          while (*(void *)&prime != v26);
          uint64_t v27 = (void *)*v16;
          if (*v16)
          {
            unint64_t v28 = v27[1];
            uint8x8_t v29 = (uint8x8_t)vcnt_s8(prime);
            v29.i16[0] = vaddlv_u8(v29);
            if (v29.u32[0] > 1uLL)
            {
              if (v28 >= *(void *)&prime) {
                v28 %= *(void *)&prime;
              }
            }
            else
            {
              v28 &= *(void *)&prime - 1;
            }
            *(void *)(*a1 + 8 * v28) = v16;
            size_t v33 = (void *)*v27;
            if (*v27)
            {
              do
              {
                unint64_t v34 = v33[1];
                if (v29.u32[0] > 1uLL)
                {
                  if (v34 >= *(void *)&prime) {
                    v34 %= *(void *)&prime;
                  }
                }
                else
                {
                  v34 &= *(void *)&prime - 1;
                }
                if (v34 != v28)
                {
                  if (!*(void *)(*a1 + 8 * v34))
                  {
                    *(void *)(*a1 + 8 * v34) = v27;
                    goto LABEL_59;
                  }
                  *uint64_t v27 = *v33;
                  *size_t v33 = **(void **)(*a1 + 8 * v34);
                  **(void **)(*a1 + 8 * v34) = v33;
                  size_t v33 = v27;
                }
                unint64_t v34 = v28;
LABEL_59:
                uint64_t v27 = v33;
                size_t v33 = (void *)*v33;
                unint64_t v28 = v34;
              }
              while (v33);
            }
          }
          unint64_t v10 = (unint64_t)prime;
          goto LABEL_63;
        }
        BOOL v39 = (void *)*a1;
        *a1 = 0;
        if (v39) {
          operator delete(v39);
        }
        unint64_t v10 = 0;
        a1[1] = 0;
      }
    }
LABEL_63:
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v10 <= v9) {
        unint64_t v3 = v9 % v10;
      }
      else {
        unint64_t v3 = v9;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v9;
    }
  }
  uint64_t v35 = *a1;
  unint64_t v36 = *(void **)(*a1 + 8 * v3);
  if (v36)
  {
    void *v14 = *v36;
LABEL_76:
    *unint64_t v36 = v14;
    goto LABEL_77;
  }
  void *v14 = *v16;
  *unint64_t v16 = v14;
  *(void *)(v35 + 8 * v3) = v16;
  if (*v14)
  {
    unint64_t v37 = *(void *)(*v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v37 >= v10) {
        v37 %= v10;
      }
    }
    else
    {
      v37 &= v10 - 1;
    }
    unint64_t v36 = (void *)(*a1 + 8 * v37);
    goto LABEL_76;
  }
LABEL_77:
  ++a1[3];
  return v14;
}

void std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__deallocate_node(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    do
    {
      unint64_t v2 = v1;
      uint64_t v1 = (void *)*v1;
      std::__hash_table<std::__hash_value_type<KB::String,_LXLexicon const*>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,_LXLexicon const*>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,_LXLexicon const*>>>::~__hash_table((uint64_t)(v2 + 6));
      unint64_t v3 = (void *)v2[3];
      if (v3)
      {
        if (*((unsigned char *)v2 + 22) == 1) {
          free(v3);
        }
      }
      operator delete(v2);
    }
    while (v1);
  }
}

uint64_t std::__function::__func<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::operator()(uint64_t a1, KB::Candidate *a2, KB::String **a3)
{
  v48[2] = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a3;
  KB::Candidate::capitalized_string(a2, (uint64_t)v45);
  KB::Candidate::capitalized_string(*(KB::Candidate **)(a1 + 8), (uint64_t)&v43);
  BOOL v6 = KB::String::equal((KB::String *)v45, (const KB::String *)&v43, 1);
  if (v44) {
    BOOL v7 = BYTE6(v43) == 1;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7) {
    free(v44);
  }
  if (v47 && v46 == 1) {
    free(v47);
  }
  if (v6) {
    return 0;
  }
  uint64_t v38 = v5;
  int v39 = 0;
  if (!*(void *)a2) {
    return 0;
  }
  LODWORD(v8) = 0;
  unint64_t v9 = 0;
  while (2)
  {
    if ((*(unsigned char *)(*((void *)a2 + 1) + 240 * v9 + 106) & 4) != 0) {
      goto LABEL_39;
    }
    unint64_t v10 = *(uint64_t **)(a1 + 16);
    if (!std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::find<int>(v10, v8))goto LABEL_39; {
    uint8x8_t v11 = std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v10, v8, &v39);
    }
    KB::lower_string((KB *)(*((void *)a2 + 1) + 240 * (int)v8), 0, (KB::String *)v45);
    unint64_t v12 = v47;
    if (v47) {
      float v13 = (KB::String *)v47;
    }
    else {
      float v13 = (KB::String *)v48;
    }
    unsigned int v14 = KB::String::hash(v13, (const char *)v45[0]);
    unint64_t v15 = *((void *)v11 + 4);
    if (!v15) {
      goto LABEL_36;
    }
    uint64_t v16 = v14;
    uint8x8_t v17 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
    v17.i16[0] = vaddlv_u8(v17);
    unint64_t v18 = v17.u32[0];
    if (v17.u32[0] > 1uLL)
    {
      unint64_t v19 = v14;
      if (v15 <= v14) {
        unint64_t v19 = v14 % v15;
      }
    }
    else
    {
      unint64_t v19 = (v15 - 1) & v14;
    }
    BOOL v20 = *(uint64_t ***)(*((void *)v11 + 3) + 8 * v19);
    if (!v20 || (unint64_t v21 = (uint64_t **)*v20) == 0)
    {
LABEL_36:
      if (v12 && v46 == 1) {
        free(v12);
      }
      goto LABEL_39;
    }
    while (1)
    {
      unint64_t v22 = (unint64_t)v21[1];
      if (v22 == v16) {
        break;
      }
      if (v18 > 1)
      {
        if (v22 >= v15) {
          v22 %= v15;
        }
      }
      else
      {
        v22 &= v15 - 1;
      }
      if (v22 != v19)
      {
LABEL_35:
        unint64_t v12 = v47;
        goto LABEL_36;
      }
LABEL_34:
      unint64_t v21 = (uint64_t **)*v21;
      if (!v21) {
        goto LABEL_35;
      }
    }
    if (v21 + 2 != (uint64_t **)v45 && !KB::String::equal((KB::String *)(v21 + 2), (const KB::String *)v45, 1)) {
      goto LABEL_34;
    }
    uint64_t v23 = v39;
    uint8x8_t v24 = (uint64_t *)(std::__hash_table<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::unordered_map<KB::String,std::unordered_set<KB::String>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(*(uint64_t **)(a1 + 16), v39, &v39)+ 24);
    KB::lower_string((KB *)(*((void *)a2 + 1) + 240 * v23), 0, (KB::String *)&v43);
    long long v40 = (char *)&v43;
    unint64_t v25 = std::__hash_table<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::__unordered_map_hasher<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::hash<KB::String>,std::equal_to<KB::String>,true>,std::__unordered_map_equal<KB::String,std::__hash_value_type<KB::String,std::unordered_set<KB::String>>,std::equal_to<KB::String>,std::hash<KB::String>,true>,std::allocator<std::__hash_value_type<KB::String,std::unordered_set<KB::String>>>>::__emplace_unique_key_args<KB::String,std::piecewise_construct_t const&,std::tuple<KB::String&&>,std::tuple<>>(v24, &v43, (KB::String **)&v40);
    KB::Word::capitalized_string((KB::Word *)(*((void *)a2 + 1) + 240 * v23), (uint64_t)&v40);
    uint64_t v26 = v41;
    if (v41) {
      uint64_t v27 = (KB::String *)v41;
    }
    else {
      uint64_t v27 = (KB::String *)&v42;
    }
    unsigned int v28 = KB::String::hash(v27, (const char *)(unsigned __int16)v40);
    unint64_t v29 = v25[7];
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v30 = v28;
    uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v29);
    v31.i16[0] = vaddlv_u8(v31);
    unint64_t v32 = v31.u32[0];
    if (v31.u32[0] > 1uLL)
    {
      unint64_t v33 = v28;
      if (v29 <= v28) {
        unint64_t v33 = v28 % v29;
      }
    }
    else
    {
      unint64_t v33 = (v29 - 1) & v28;
    }
    unint64_t v34 = *(uint64_t ***)(v25[6] + 8 * v33);
    if (!v34)
    {
LABEL_62:
      uint64_t v35 = 0;
LABEL_63:
      if (!v26) {
        goto LABEL_66;
      }
LABEL_64:
      if (BYTE6(v40) == 1) {
        free(v26);
      }
      goto LABEL_66;
    }
    uint64_t v35 = (uint64_t **)*v34;
    if (!*v34) {
      goto LABEL_63;
    }
    while (2)
    {
      unint64_t v36 = (unint64_t)v35[1];
      if (v36 == v30)
      {
        if (v35 + 2 == (uint64_t **)&v40 || KB::String::equal((KB::String *)(v35 + 2), (const KB::String *)&v40, 1)) {
          goto LABEL_75;
        }
        goto LABEL_60;
      }
      if (v32 > 1)
      {
        if (v36 >= v29) {
          v36 %= v29;
        }
      }
      else
      {
        v36 &= v29 - 1;
      }
      if (v36 == v33)
      {
LABEL_60:
        uint64_t v35 = (uint64_t **)*v35;
        if (!v35) {
          goto LABEL_75;
        }
        continue;
      }
      break;
    }
    uint64_t v35 = 0;
LABEL_75:
    uint64_t v26 = v41;
    if (v41) {
      goto LABEL_64;
    }
LABEL_66:
    if (v44 && BYTE6(v43) == 1) {
      free(v44);
    }
    if (v47 && v46 == 1) {
      free(v47);
    }
    if (v35)
    {
LABEL_39:
      unint64_t v8 = ++v39;
      unint64_t v9 = v8;
      if (*(void *)a2 <= v8) {
        return 0;
      }
      continue;
    }
    break;
  }
  if (v38) {
    KB::String::append_format(v38, "candidate contains case variant of static word");
  }
  return 1;
}

__n128 std::__function::__func<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1F3F74628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)unint64_t v2 = &unk_1F3F74628;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0,std::allocator<KB::FilterCaseVariantsOfStaticWords::filter_candidates(KB::CandidateCollection &,KB::CandidateFilterLookupContext const&,KB::CandidateFilterResources const&)::$_0>,BOOL ()(KB::Candidate const&,KB::String *)>::~__func()
{
}

const char *KB::FilterCaseVariantsOfStaticWords::filter_description(KB::FilterCaseVariantsOfStaticWords *this)
{
  return "FilterCaseVariantsOfStaticWords";
}

void KB::FilterCaseVariantsOfStaticWords::~FilterCaseVariantsOfStaticWords(KB::FilterCaseVariantsOfStaticWords *this)
{
}

uint64_t KB::enum_value_from_string<KB::FilterNotSuggestibleForInput::ApplyFilterCondition>(uint64_t *a1)
{
  uint64_t v1 = *((unsigned __int8 *)a1 + 23);
  int v2 = (char)v1;
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = a1[1];
  }
  if (v1 == 34)
  {
    if (v2 < 0) {
      a1 = (uint64_t *)*a1;
    }
    if (!memcmp(a1, "ApplyIfCandidatesContainInputMatch", 0x22uLL))
    {
      uint64_t v8 = 0x100000000;
      uint64_t v7 = 1;
      return v7 | v8;
    }
    goto LABEL_17;
  }
  if (v1 != 11
    || (v2 >= 0 ? (unint64_t v3 = a1) : (unint64_t v3 = (uint64_t *)*a1),
        (v4 = *v3, uint64_t v5 = *(uint64_t *)((char *)v3 + 3), v4 == 0x776C41796C707041)
      ? (BOOL v6 = v5 == 0x737961776C41796CLL)
      : (BOOL v6 = 0),
        !v6))
  {
LABEL_17:
    uint64_t v8 = 0;
    uint64_t v7 = 0;
    return v7 | v8;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0x100000000;
  return v7 | v8;
}

uint64_t KB::FilterNotSuggestibleForInput::should_apply_filter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 36) != 1) {
    return 1;
  }
  uint64_t v6 = *(void *)(a4 + 16);
  if (v6) {
    atomic_fetch_add((atomic_uint *volatile)v6, 1u);
  }
  uint64_t v7 = *(void *)(v6 + 8) + 144;
  WTF::RefCounted<KB::DictionaryContainer>::deref((unsigned int *)v6);

  return KB::FilterNotSuggestibleForInput::does_candidate_list_contain_input_match(a2, a3, v7);
}

uint64_t KB::enum_value_from_string<KB::FilterCharacterCount::CharacterCountRelation>(uint64_t *a1)
{
  uint64_t v1 = *((unsigned __int8 *)a1 + 23);
  int v2 = (char)v1;
  if ((v1 & 0x80u) != 0) {
    uint64_t v1 = a1[1];
  }
  switch(v1)
  {
    case 17:
      if (v2 >= 0) {
        unint64_t v3 = a1;
      }
      else {
        unint64_t v3 = (uint64_t *)*a1;
      }
      uint64_t v4 = *v3;
      uint64_t v5 = v3[1];
      int v6 = *((unsigned __int8 *)v3 + 16);
      if (v4 != 0x496F546C61757145 || v5 != 0x6E756F437475706ELL || v6 != 116) {
        goto LABEL_80;
      }
      uint64_t v9 = 0x100000000;
      uint64_t v10 = 2;
      break;
    case 18:
      if (v2 >= 0) {
        uint8x8_t v11 = a1;
      }
      else {
        uint8x8_t v11 = (uint64_t *)*a1;
      }
      uint64_t v12 = *v11;
      uint64_t v13 = v11[1];
      int v14 = *((unsigned __int16 *)v11 + 8);
      if (v12 != 0x6E6168547373654CLL || v13 != 0x756F437475706E49 || v14 != 29806) {
        goto LABEL_80;
      }
      uint64_t v10 = 0;
      uint64_t v9 = 0x100000000;
      break;
    case 20:
      if (v2 >= 0) {
        uint8x8_t v17 = a1;
      }
      else {
        uint8x8_t v17 = (uint64_t *)*a1;
      }
      uint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      int v20 = *((_DWORD *)v17 + 4);
      if (v18 != 0x6C61757145746F4ELL || v19 != 0x437475706E496F54 || v20 != 1953396079) {
        goto LABEL_80;
      }
      uint64_t v9 = 0x100000000;
      uint64_t v10 = 3;
      break;
    case 21:
      if (v2 >= 0) {
        uint64_t v23 = a1;
      }
      else {
        uint64_t v23 = (uint64_t *)*a1;
      }
      uint64_t v24 = *v23;
      uint64_t v25 = v23[1];
      uint64_t v26 = *(uint64_t *)((char *)v23 + 13);
      if (v24 != 0x5472657461657247 || v25 != 0x7475706E496E6168 || v26 != 0x746E756F43747570) {
        goto LABEL_80;
      }
      uint64_t v9 = 0x100000000;
      uint64_t v10 = 5;
      break;
    case 27:
      if (v2 >= 0) {
        unint64_t v29 = a1;
      }
      else {
        unint64_t v29 = (uint64_t *)*a1;
      }
      uint64_t v30 = *v29;
      uint64_t v31 = v29[1];
      uint64_t v32 = v29[2];
      uint64_t v33 = *(uint64_t *)((char *)v29 + 19);
      if (v30 != 0x6E6168547373654CLL
        || v31 != 0x546C61757145724FLL
        || v32 != 0x6F437475706E496FLL
        || v33 != 0x746E756F43747570)
      {
        goto LABEL_80;
      }
      uint64_t v9 = 0x100000000;
      uint64_t v10 = 1;
      break;
    case 30:
      if (v2 >= 0) {
        unint64_t v37 = a1;
      }
      else {
        unint64_t v37 = (uint64_t *)*a1;
      }
      uint64_t v38 = *v37;
      uint64_t v39 = v37[1];
      uint64_t v40 = v37[2];
      uint64_t v41 = *(uint64_t *)((char *)v37 + 22);
      if (v38 != 0x5472657461657247
        || v39 != 0x757145724F6E6168
        || v40 != 0x75706E496F546C61
        || v41 != 0x746E756F43747570)
      {
        goto LABEL_80;
      }
      uint64_t v9 = 0x100000000;
      uint64_t v10 = 4;
      break;
    default:
LABEL_80:
      uint64_t v9 = 0;
      uint64_t v10 = 0;
      break;
  }
  return v10 | v9;
}

double TI::CP::SearchNodeLanguageExtensions::bound_on_score(TI::CP::SearchNodeLanguageExtensions *this)
{
  return *((double *)this + 12);
}

void TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(TI::CP::SearchNodeLanguageExtensions *this)
{
  if (!*((unsigned char *)this + 80))
  {
    uint64_t v2 = *((void *)this + 4);
    if (!*(unsigned char *)(v2 + 82))
    {
      (*(void (**)(void, uint64_t))(**(void **)(v2 + 64) + 48))(*(void *)(v2 + 64), v2 + 88);
      *(unsigned char *)(v2 + 82) = 1;
    }
    WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::operator=((unint64_t *)this + 7, (unint64_t *)(v2 + 88));
    unint64_t v3 = *((void *)this + 7);
    unint64_t v4 = 126 - 2 * __clz(v3);
    if (v3) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = 0;
    }
    std::__introsort<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(*((uint64_t **)this + 8), (uint64_t *)(*((void *)this + 8) + 8 * v3), v5, 1);
    *((unsigned char *)this + 80) = 1;
    TI::CP::SearchNodeLanguageExtensions::compute_bound_on_score(this);
  }
}

unint64_t *WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::operator=(unint64_t *a1, unint64_t *a2)
{
  if (a2 != a1)
  {
    unint64_t v4 = *a1;
    unint64_t v5 = *a2;
    if (*a1 <= *a2)
    {
      if (v5 > a1[2])
      {
        WTF::Vector<WTF::RefPtr<TI::Favonius::TypingHypothesis>,0ul>::shrinkCapacity((uint64_t)a1);
        WTF::Vector<WTF::RefPtr<TI::Favonius::LayoutKey>,0ul>::reserveCapacity(a1, *a2);
        if (!a1[1]) {
          return a1;
        }
        unint64_t v4 = *a1;
      }
    }
    else
    {
      WTF::VectorDestructor<true,WTF::RefPtr<TI::Favonius::TypingHypothesis>>::destruct((unsigned int *)(a1[1] + 8 * v5), (unsigned int **)(a1[1] + 8 * v4));
      *a1 = v5;
      unint64_t v4 = v5;
    }
    int v6 = (uint64_t *)a2[1];
    if (v4)
    {
      uint64_t v7 = (unsigned int **)a1[1];
      uint64_t v8 = 8 * v4;
      do
      {
        uint64_t v9 = *v6;
        if (*v6) {
          atomic_fetch_add((atomic_uint *volatile)(v9 + 8), 1u);
        }
        uint64_t v10 = *v7;
        *uint64_t v7 = (unsigned int *)v9;
        if (v10)
        {
          unsigned int v11 = atomic_load(v10 + 2);
          if (v11 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v10 + 248))(v10);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v10 + 2, 0xFFFFFFFF);
          }
        }
        ++v6;
        ++v7;
        v8 -= 8;
      }
      while (v8);
      int v6 = (uint64_t *)a2[1];
      unint64_t v12 = *a1;
    }
    else
    {
      unint64_t v12 = 0;
    }
    if (v12 != *a2)
    {
      uint64_t v13 = (uint64_t *)(a1[1] + 8 * v12);
      int v14 = &v6[v12];
      uint64_t v15 = 8 * *a2 - 8 * v12;
      do
      {
        uint64_t v16 = *v14;
        *uint64_t v13 = *v14;
        if (v16) {
          atomic_fetch_add((atomic_uint *volatile)(v16 + 8), 1u);
        }
        ++v13;
        ++v14;
        v15 -= 8;
      }
      while (v15);
      unint64_t v12 = *a2;
    }
    *a1 = v12;
  }
  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
LABEL_1:
  uint64_t v141 = a2 - 2;
  int64_t v143 = a2 - 1;
  unsigned int v140 = a2 - 3;
  uint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    uint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          float v60 = (*(float (**)(void))(*(void *)*v143 + 24))();
          if (v60 < (*(float (**)(void))(*(void *)*a1 + 24))())
          {
            uint64_t v61 = *a1;
            *a1 = *v143;
            *int64_t v143 = v61;
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, v143);
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, v143);
          break;
        case 5:
          std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, v143);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      int64_t v80 = (unint64_t)(v12 - 2) >> 1;
      uint64_t v142 = a2;
      int64_t v144 = v80;
      do
      {
        int64_t v81 = v80;
        if (v144 >= v80)
        {
          uint64_t v82 = (2 * v80) | 1;
          long long v83 = (unsigned int **)&a1[v82];
          if (2 * v80 + 2 < v12)
          {
            float v84 = (*(float (**)(void))(*(void *)*v83 + 24))();
            if (v84 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
            {
              ++v83;
              uint64_t v82 = 2 * v81 + 2;
            }
          }
          long long v85 = (unsigned int **)&a1[v81];
          float v86 = (*(float (**)(void))(*(void *)*v83 + 24))();
          if (v86 >= (*(float (**)(void))(*(void *)*v85 + 24))())
          {
            int v87 = *v85;
            *long long v85 = 0;
            do
            {
              char v88 = v83;
              uint64_t v89 = *v83;
              *long long v83 = 0;
              int v90 = *v85;
              *long long v85 = v89;
              if (v90)
              {
                unsigned int v91 = atomic_load(v90 + 2);
                if (v91 == 1) {
                  (*(void (**)(unsigned int *))(*(void *)v90 + 248))(v90);
                }
                else {
                  atomic_fetch_add((atomic_uint *volatile)v90 + 2, 0xFFFFFFFF);
                }
              }
              if (v144 < v82) {
                break;
              }
              uint64_t v92 = 2 * v82;
              uint64_t v82 = (2 * v82) | 1;
              long long v83 = (unsigned int **)&a1[v82];
              uint64_t v93 = v92 + 2;
              if (v92 + 2 < v12)
              {
                float v94 = (*(float (**)(void))(*(void *)*v83 + 24))();
                if (v94 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
                {
                  ++v83;
                  uint64_t v82 = v93;
                }
              }
              float v95 = (*(float (**)(void))(*(void *)*v83 + 24))();
              long long v85 = v88;
            }
            while (v95 >= (*(float (**)(unsigned int *))(*(void *)v87 + 24))(v87));
            char v96 = *v88;
            *char v88 = v87;
            if (v96)
            {
              unsigned int v97 = atomic_load(v96 + 2);
              if (v97 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v96 + 248))(v96);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v96 + 2, 0xFFFFFFFF);
              }
            }
          }
        }
        int64_t v80 = v81 - 1;
      }
      while (v81);
      uint64_t v98 = (unint64_t)v11 >> 3;
      char v99 = (unsigned int **)v142;
      while (1)
      {
        uint64_t v100 = 0;
        uint64_t v145 = *a1;
        *a1 = 0;
        char v101 = (unsigned int **)a1;
        do
        {
          int8x8_t v102 = v101;
          v101 += v100 + 1;
          uint64_t v103 = 2 * v100;
          uint64_t v100 = (2 * v100) | 1;
          uint64_t v104 = v103 + 2;
          if (v103 + 2 < v98)
          {
            float v105 = (*(float (**)(void))(*(void *)*v101 + 24))();
            if (v105 < (*(float (**)(unsigned int *))(*(void *)v101[1] + 24))(v101[1]))
            {
              ++v101;
              uint64_t v100 = v104;
            }
          }
          uint64_t v106 = *v101;
          *char v101 = 0;
          char v107 = *v102;
          void *v102 = v106;
          if (v107)
          {
            unsigned int v108 = atomic_load(v107 + 2);
            if (v108 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v107 + 248))(v107);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v107 + 2, 0xFFFFFFFF);
            }
          }
        }
        while (v100 <= (uint64_t)((unint64_t)(v98 - 2) >> 1));
        uint64_t v109 = v99 - 1;
        if (v101 != v109) {
          break;
        }
        char v113 = v109;
        char v114 = *v101;
        *char v101 = (unsigned int *)v145;
        if (v114)
        {
LABEL_156:
          unsigned int v127 = atomic_load(v114 + 2);
          if (v127 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v114 + 248))(v114);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v114 + 2, 0xFFFFFFFF);
          }
        }
LABEL_159:
        BOOL v128 = v98-- <= 2;
        char v99 = v113;
        if (v128) {
          return;
        }
      }
      BOOL v110 = *v109;
      void *v109 = 0;
      char v111 = *v101;
      *char v101 = v110;
      if (v111)
      {
        unsigned int v112 = atomic_load(v111 + 2);
        if (v112 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v111 + 248))(v111);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v111 + 2, 0xFFFFFFFF);
        }
      }
      TITokenID v115 = *v109;
      void *v109 = (unsigned int *)v145;
      if (v115)
      {
        unsigned int v116 = atomic_load(v115 + 2);
        if (v116 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v115 + 248))(v115);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v115 + 2, 0xFFFFFFFF);
        }
      }
      char v113 = v109;
      uint64_t v117 = (char *)(v101 + 1) - (char *)a1;
      if (v117 < 9) {
        goto LABEL_159;
      }
      unint64_t v118 = (((unint64_t)v117 >> 3) - 2) >> 1;
      char v119 = (unsigned int **)&a1[v118];
      float v120 = (*(float (**)(void))(*(void *)*v119 + 24))();
      if (v120 >= (*(float (**)(void))(*(void *)*v101 + 24))()) {
        goto LABEL_159;
      }
      unint64_t v121 = *v101;
      *char v101 = 0;
      while (1)
      {
        char v122 = v119;
        uint64_t v123 = *v119;
        *char v119 = 0;
        uint64_t v124 = *v101;
        *char v101 = v123;
        if (v124)
        {
          unsigned int v125 = atomic_load(v124 + 2);
          if (v125 != 1)
          {
            atomic_fetch_add((atomic_uint *volatile)v124 + 2, 0xFFFFFFFF);
            if (!v118) {
              goto LABEL_155;
            }
            goto LABEL_154;
          }
          (*(void (**)(unsigned int *))(*(void *)v124 + 248))(v124);
        }
        if (!v118) {
          goto LABEL_155;
        }
LABEL_154:
        unint64_t v118 = (v118 - 1) >> 1;
        char v119 = (unsigned int **)&a1[v118];
        float v126 = (*(float (**)(void))(*(void *)*v119 + 24))();
        char v101 = v122;
        if (v126 >= (*(float (**)(unsigned int *))(*(void *)v121 + 24))(v121))
        {
LABEL_155:
          char v114 = *v122;
          *char v122 = v121;
          if (v114) {
            goto LABEL_156;
          }
          goto LABEL_159;
        }
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    int v14 = &a1[(unint64_t)v12 >> 1];
    if ((unint64_t)v11 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v14, a1, v143);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v14, v143);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 1, v14 - 1, v141);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 2, &a1[v13 + 1], v140);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v14 - 1, v14, &a1[v13 + 1]);
      uint64_t v15 = *a1;
      *a1 = *v14;
      uint64_t *v14 = v15;
    }
    --a3;
    if ((a4 & 1) != 0
      || (float v16 = (*(float (**)(void))(*(void *)*(a1 - 1) + 24))(*(a1 - 1)),
          v16 < (*(float (**)(void))(*(void *)*a1 + 24))()))
    {
      uint64_t v17 = *a1;
      *a1 = 0;
      uint64_t v18 = a1;
      do
      {
        uint64_t v19 = v18;
        uint64_t v20 = v18[1];
        ++v18;
        float v21 = (*(float (**)(uint64_t))(*(void *)v20 + 24))(v20);
      }
      while (v21 < (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      unint64_t v22 = a2;
      if (v19 == a1)
      {
        do
        {
          if (v18 >= a2) {
            break;
          }
          uint64_t v25 = *--a2;
          float v26 = (*(float (**)(uint64_t))(*(void *)v25 + 24))(v25);
        }
        while (v26 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      }
      else
      {
        do
        {
          uint64_t v23 = *--a2;
          float v24 = (*(float (**)(uint64_t))(*(void *)v23 + 24))(v23);
        }
        while (v24 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      }
      if (v18 < a2)
      {
        uint64_t v27 = v18;
        unsigned int v28 = a2;
        do
        {
          uint64_t v29 = *v27;
          *uint64_t v27 = *v28;
          uint64_t *v28 = v29;
          do
          {
            uint64_t v19 = v27;
            uint64_t v30 = v27[1];
            ++v27;
            float v31 = (*(float (**)(uint64_t))(*(void *)v30 + 24))(v30);
          }
          while (v31 < (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
          do
          {
            uint64_t v32 = *--v28;
            float v33 = (*(float (**)(uint64_t))(*(void *)v32 + 24))(v32);
          }
          while (v33 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
        }
        while (v27 < v28);
      }
      if (v19 != a1)
      {
        uint64_t v34 = *v19;
        *uint64_t v19 = 0;
        uint64_t v35 = (unsigned int *)*a1;
        *a1 = v34;
        if (v35)
        {
          unsigned int v36 = atomic_load(v35 + 2);
          if (v36 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v35 + 248))(v35);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v35 + 2, 0xFFFFFFFF);
          }
        }
      }
      unint64_t v37 = (unsigned int *)*v19;
      *uint64_t v19 = v17;
      if (v37)
      {
        unsigned int v38 = atomic_load(v37 + 2);
        if (v38 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v37 + 248))(v37);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v37 + 2, 0xFFFFFFFF);
        }
      }
      BOOL v4 = v18 >= a2;
      a2 = v22;
      if (v4)
      {
        BOOL v39 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v19);
        uint64_t v10 = v19 + 1;
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v19 + 1, v22))
        {
          a2 = v19;
          if (v39) {
            return;
          }
          goto LABEL_1;
        }
        if (!v39) {
          goto LABEL_37;
        }
      }
      else
      {
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(a1, v19, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v19 + 1;
      }
    }
    else
    {
      uint64_t v40 = *a1;
      *a1 = 0;
      float v41 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
      if (v41 >= (*(float (**)(void))(*(void *)*v143 + 24))())
      {
        uint64_t v44 = a1 + 1;
        do
        {
          uint64_t v10 = v44;
          if (v44 >= a2) {
            break;
          }
          float v45 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          ++v44;
        }
        while (v45 >= (*(float (**)(void))(*(void *)*v10 + 24))());
      }
      else
      {
        uint64_t v10 = a1;
        do
        {
          float v42 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v43 = v10[1];
          ++v10;
        }
        while (v42 >= (*(float (**)(uint64_t))(*(void *)v43 + 24))(v43));
      }
      char v46 = a2;
      if (v10 < a2)
      {
        char v46 = a2;
        do
        {
          float v47 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v48 = *--v46;
        }
        while (v47 < (*(float (**)(uint64_t))(*(void *)v48 + 24))(v48));
      }
      while (v10 < v46)
      {
        uint64_t v49 = *v10;
        uint64_t *v10 = *v46;
        *char v46 = v49;
        do
        {
          float v50 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v51 = v10[1];
          ++v10;
        }
        while (v50 >= (*(float (**)(uint64_t))(*(void *)v51 + 24))(v51));
        do
        {
          float v52 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v53 = *--v46;
        }
        while (v52 < (*(float (**)(uint64_t))(*(void *)v53 + 24))(v53));
      }
      int64x2_t v54 = (unsigned int **)(v10 - 1);
      BOOL v4 = v10 - 1 >= a1;
      BOOL v5 = v10 - 1 == a1;
      if (v10 - 1 != a1)
      {
        unint64_t v55 = *v54;
        char *v54 = 0;
        uint64_t v56 = (unsigned int *)*a1;
        *a1 = (uint64_t)v55;
        if (v56)
        {
          unsigned int v57 = atomic_load(v56 + 2);
          BOOL v4 = v57 != 0;
          BOOL v5 = v57 == 1;
          if (v57 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v56 + 248))(v56);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v56 + 2, 0xFFFFFFFF);
          }
        }
      }
      a4 = 0;
      uint64_t v58 = *v54;
      char *v54 = (unsigned int *)v40;
      if (v58)
      {
        unsigned int v59 = atomic_load(v58 + 2);
        BOOL v4 = v59 != 0;
        BOOL v5 = v59 == 1;
        if (v59 == 1)
        {
          (*(void (**)(unsigned int *))(*(void *)v58 + 248))(v58);
          a4 = 0;
        }
        else
        {
          a4 = 0;
          atomic_fetch_add((atomic_uint *volatile)v58 + 2, 0xFFFFFFFF);
        }
      }
    }
  }
  uint64_t v62 = a1 + 1;
  BOOL v64 = a1 == a2 || v62 == a2;
  if ((a4 & 1) == 0)
  {
    if (!v64)
    {
      do
      {
        int v129 = a1;
        a1 = v62;
        float v130 = (*(float (**)(uint64_t))(*(void *)v129[1] + 24))(v129[1]);
        if (v130 < (*(float (**)(void))(*(void *)*v129 + 24))())
        {
          long long v131 = 0;
          uint64_t v132 = *a1;
          *a1 = 0;
          int64_t v133 = a1;
          do
          {
            uint64_t v134 = *(v133 - 1);
            *(v133 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            *int64_t v133 = v134;
            if (v131)
            {
              unsigned int v135 = atomic_load(v131 + 2);
              if (v135 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v131 + 248))(v131);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v131 + 2, 0xFFFFFFFF);
              }
            }
            float v136 = (*(float (**)(uint64_t))(*(void *)v132 + 24))(v132);
            float v137 = (*(float (**)(void))(*(void *)*(v133 - 2) + 24))(*(v133 - 2));
            int v138 = (unsigned int *)*--v133;
            long long v131 = v138;
          }
          while (v136 < v137);
          *int64_t v133 = v132;
          if (v131)
          {
            unsigned int v139 = atomic_load(v131 + 2);
            if (v139 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v131 + 248))(v131);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v131 + 2, 0xFFFFFFFF);
            }
          }
        }
        uint64_t v62 = a1 + 1;
      }
      while (a1 + 1 != a2);
    }
    return;
  }
  if (v64) {
    return;
  }
  uint64_t v65 = 0;
  long long v66 = a1;
  while (2)
  {
    unint64_t v67 = v66;
    long long v66 = v62;
    float v68 = (*(float (**)(uint64_t))(*(void *)v67[1] + 24))(v67[1]);
    if (v68 >= (*(float (**)(void))(*(void *)*v67 + 24))()) {
      goto LABEL_100;
    }
    unint64_t v69 = a2;
    char v70 = 0;
    uint64_t v71 = (unsigned int *)*v66;
    uint64_t *v66 = 0;
    uint64_t v72 = v65;
    while (2)
    {
      uint64_t v73 = (unsigned int **)((char *)a1 + v72);
      int v74 = *(unsigned int **)((char *)a1 + v72);
      *uint64_t v73 = 0;
      v73[1] = v74;
      if (!v70)
      {
LABEL_90:
        if (!v72) {
          break;
        }
        goto LABEL_93;
      }
      unsigned int v75 = atomic_load(v70 + 2);
      if (v75 == 1)
      {
        (*(void (**)(unsigned int *))(*(void *)v70 + 248))(v70);
        goto LABEL_90;
      }
      atomic_fetch_add((atomic_uint *volatile)v70 + 2, 0xFFFFFFFF);
      if (v72)
      {
LABEL_93:
        char v76 = (unsigned int **)((char *)a1 + v72);
        float v77 = (*(float (**)(unsigned int *))(*(void *)v71 + 24))(v71);
        if (v77 >= (*(float (**)(void))(*(void *)*(v76 - 1) + 24))(*(v76 - 1))) {
          goto LABEL_96;
        }
        char v70 = *v73;
        v72 -= 8;
        continue;
      }
      break;
    }
    char v76 = (unsigned int **)a1;
LABEL_96:
    uint64_t v78 = *v76;
    void *v76 = v71;
    a2 = v69;
    if (v78)
    {
      unsigned int v79 = atomic_load(v78 + 2);
      if (v79 == 1) {
        (*(void (**)(unsigned int *))(*(void *)v78 + 248))(v78);
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v78 + 2, 0xFFFFFFFF);
      }
    }
LABEL_100:
    uint64_t v62 = v66 + 1;
    v65 += 8;
    if (v66 + 1 != a2) {
      continue;
    }
    break;
  }
}

  uint64_t v141 = a2 - 2;
  int64_t v143 = a2 - 1;
  unsigned int v140 = a2 - 3;
  uint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    uint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          float v60 = (*(float (**)(void))(*(void *)*v143 + 24))();
          if (v60 < (*(float (**)(void))(*(void *)*a1 + 24))())
          {
            uint64_t v61 = *a1;
            *a1 = *v143;
            *int64_t v143 = v61;
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, v143);
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, v143);
          break;
        case 5:
          std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, v143);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      int64_t v80 = (unint64_t)(v12 - 2) >> 1;
      uint64_t v142 = a2;
      int64_t v144 = v80;
      do
      {
        int64_t v81 = v80;
        if (v144 >= v80)
        {
          uint64_t v82 = (2 * v80) | 1;
          long long v83 = (unsigned int **)&a1[v82];
          if (2 * v80 + 2 < v12)
          {
            float v84 = (*(float (**)(void))(*(void *)*v83 + 24))();
            if (v84 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
            {
              ++v83;
              uint64_t v82 = 2 * v81 + 2;
            }
          }
          long long v85 = (unsigned int **)&a1[v81];
          float v86 = (*(float (**)(void))(*(void *)*v83 + 24))();
          if (v86 >= (*(float (**)(void))(*(void *)*v85 + 24))())
          {
            int v87 = *v85;
            *long long v85 = 0;
            do
            {
              char v88 = v83;
              uint64_t v89 = *v83;
              *long long v83 = 0;
              int v90 = *v85;
              *long long v85 = v89;
              if (v90)
              {
                unsigned int v91 = atomic_load(v90 + 2);
                if (v91 == 1) {
                  (*(void (**)(unsigned int *))(*(void *)v90 + 248))(v90);
                }
                else {
                  atomic_fetch_add((atomic_uint *volatile)v90 + 2, 0xFFFFFFFF);
                }
              }
              if (v144 < v82) {
                break;
              }
              uint64_t v92 = 2 * v82;
              uint64_t v82 = (2 * v82) | 1;
              long long v83 = (unsigned int **)&a1[v82];
              uint64_t v93 = v92 + 2;
              if (v92 + 2 < v12)
              {
                float v94 = (*(float (**)(void))(*(void *)*v83 + 24))();
                if (v94 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
                {
                  ++v83;
                  uint64_t v82 = v93;
                }
              }
              float v95 = (*(float (**)(void))(*(void *)*v83 + 24))();
              long long v85 = v88;
            }
            while (v95 >= (*(float (**)(unsigned int *))(*(void *)v87 + 24))(v87));
            char v96 = *v88;
            *char v88 = v87;
            if (v96)
            {
              unsigned int v97 = atomic_load(v96 + 2);
              if (v97 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v96 + 248))(v96);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v96 + 2, 0xFFFFFFFF);
              }
            }
          }
        }
        int64_t v80 = v81 - 1;
      }
      while (v81);
      uint64_t v98 = (unint64_t)v11 >> 3;
      char v99 = (unsigned int **)v142;
      while (1)
      {
        uint64_t v100 = 0;
        uint64_t v145 = *a1;
        *a1 = 0;
        char v101 = (unsigned int **)a1;
        do
        {
          int8x8_t v102 = v101;
          v101 += v100 + 1;
          uint64_t v103 = 2 * v100;
          uint64_t v100 = (2 * v100) | 1;
          uint64_t v104 = v103 + 2;
          if (v103 + 2 < v98)
          {
            float v105 = (*(float (**)(void))(*(void *)*v101 + 24))();
            if (v105 < (*(float (**)(unsigned int *))(*(void *)v101[1] + 24))(v101[1]))
            {
              ++v101;
              uint64_t v100 = v104;
            }
          }
          uint64_t v106 = *v101;
          *char v101 = 0;
          char v107 = *v102;
          void *v102 = v106;
          if (v107)
          {
            unsigned int v108 = atomic_load(v107 + 2);
            if (v108 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v107 + 248))(v107);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v107 + 2, 0xFFFFFFFF);
            }
          }
        }
        while (v100 <= (uint64_t)((unint64_t)(v98 - 2) >> 1));
        uint64_t v109 = v99 - 1;
        if (v101 != v109) {
          break;
        }
        char v113 = v109;
        char v114 = *v101;
        *char v101 = (unsigned int *)v145;
        if (v114)
        {
LABEL_156:
          unsigned int v127 = atomic_load(v114 + 2);
          if (v127 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v114 + 248))(v114);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v114 + 2, 0xFFFFFFFF);
          }
        }
LABEL_159:
        BOOL v128 = v98-- <= 2;
        char v99 = v113;
        if (v128) {
          return;
        }
      }
      BOOL v110 = *v109;
      void *v109 = 0;
      char v111 = *v101;
      *char v101 = v110;
      if (v111)
      {
        unsigned int v112 = atomic_load(v111 + 2);
        if (v112 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v111 + 248))(v111);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v111 + 2, 0xFFFFFFFF);
        }
      }
      TITokenID v115 = *v109;
      void *v109 = (unsigned int *)v145;
      if (v115)
      {
        unsigned int v116 = atomic_load(v115 + 2);
        if (v116 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v115 + 248))(v115);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v115 + 2, 0xFFFFFFFF);
        }
      }
      char v113 = v109;
      uint64_t v117 = (char *)(v101 + 1) - (char *)a1;
      if (v117 < 9) {
        goto LABEL_159;
      }
      unint64_t v118 = (((unint64_t)v117 >> 3) - 2) >> 1;
      char v119 = (unsigned int **)&a1[v118];
      float v120 = (*(float (**)(void))(*(void *)*v119 + 24))();
      if (v120 >= (*(float (**)(void))(*(void *)*v101 + 24))()) {
        goto LABEL_159;
      }
      unint64_t v121 = *v101;
      *char v101 = 0;
      while (1)
      {
        char v122 = v119;
        uint64_t v123 = *v119;
        *char v119 = 0;
        uint64_t v124 = *v101;
        *char v101 = v123;
        if (v124)
        {
          unsigned int v125 = atomic_load(v124 + 2);
          if (v125 != 1)
          {
            atomic_fetch_add((atomic_uint *volatile)v124 + 2, 0xFFFFFFFF);
            if (!v118) {
              goto LABEL_155;
            }
            goto LABEL_154;
          }
          (*(void (**)(unsigned int *))(*(void *)v124 + 248))(v124);
        }
        if (!v118) {
          goto LABEL_155;
        }
LABEL_154:
        unint64_t v118 = (v118 - 1) >> 1;
        char v119 = (unsigned int **)&a1[v118];
        float v126 = (*(float (**)(void))(*(void *)*v119 + 24))();
        char v101 = v122;
        if (v126 >= (*(float (**)(unsigned int *))(*(void *)v121 + 24))(v121))
        {
LABEL_155:
          char v114 = *v122;
          *char v122 = v121;
          if (v114) {
            goto LABEL_156;
          }
          goto LABEL_159;
        }
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    int v14 = &a1[(unint64_t)v12 >> 1];
    if ((unint64_t)v11 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v14, a1, v143);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v14, v143);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 1, v14 - 1, v141);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 2, &a1[v13 + 1], v140);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v14 - 1, v14, &a1[v13 + 1]);
      uint64_t v15 = *a1;
      *a1 = *v14;
      uint64_t *v14 = v15;
    }
    --a3;
    if ((a4 & 1) != 0
      || (float v16 = (*(float (**)(void))(*(void *)*(a1 - 1) + 24))(*(a1 - 1)),
          v16 < (*(float (**)(void))(*(void *)*a1 + 24))()))
    {
      uint64_t v17 = *a1;
      *a1 = 0;
      uint64_t v18 = a1;
      do
      {
        uint64_t v19 = v18;
        uint64_t v20 = v18[1];
        ++v18;
        float v21 = (*(float (**)(uint64_t))(*(void *)v20 + 24))(v20);
      }
      while (v21 < (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      unint64_t v22 = a2;
      if (v19 == a1)
      {
        do
        {
          if (v18 >= a2) {
            break;
          }
          uint64_t v25 = *--a2;
          float v26 = (*(float (**)(uint64_t))(*(void *)v25 + 24))(v25);
        }
        while (v26 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      }
      else
      {
        do
        {
          uint64_t v23 = *--a2;
          float v24 = (*(float (**)(uint64_t))(*(void *)v23 + 24))(v23);
        }
        while (v24 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
      }
      if (v18 < a2)
      {
        uint64_t v27 = v18;
        unsigned int v28 = a2;
        do
        {
          uint64_t v29 = *v27;
          *uint64_t v27 = *v28;
          uint64_t *v28 = v29;
          do
          {
            uint64_t v19 = v27;
            uint64_t v30 = v27[1];
            ++v27;
            float v31 = (*(float (**)(uint64_t))(*(void *)v30 + 24))(v30);
          }
          while (v31 < (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
          do
          {
            uint64_t v32 = *--v28;
            float v33 = (*(float (**)(uint64_t))(*(void *)v32 + 24))(v32);
          }
          while (v33 >= (*(float (**)(uint64_t))(*(void *)v17 + 24))(v17));
        }
        while (v27 < v28);
      }
      if (v19 != a1)
      {
        uint64_t v34 = *v19;
        *uint64_t v19 = 0;
        uint64_t v35 = (unsigned int *)*a1;
        *a1 = v34;
        if (v35)
        {
          unsigned int v36 = atomic_load(v35 + 2);
          if (v36 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v35 + 248))(v35);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v35 + 2, 0xFFFFFFFF);
          }
        }
      }
      unint64_t v37 = (unsigned int *)*v19;
      *uint64_t v19 = v17;
      if (v37)
      {
        unsigned int v38 = atomic_load(v37 + 2);
        if (v38 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v37 + 248))(v37);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v37 + 2, 0xFFFFFFFF);
        }
      }
      BOOL v4 = v18 >= a2;
      a2 = v22;
      if (v4)
      {
        BOOL v39 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeKeyPredictionExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v19);
        uint64_t v10 = v19 + 1;
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeKeyPredictionExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v19 + 1, v22))
        {
          a2 = v19;
          if (v39) {
            return;
          }
          goto LABEL_1;
        }
        if (!v39) {
          goto LABEL_37;
        }
      }
      else
      {
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,TI::CP::SearchNodeKeyPredictionExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(a1, v19, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v19 + 1;
      }
    }
    else
    {
      uint64_t v40 = *a1;
      *a1 = 0;
      float v41 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
      if (v41 >= (*(float (**)(void))(*(void *)*v143 + 24))())
      {
        uint64_t v44 = a1 + 1;
        do
        {
          uint64_t v10 = v44;
          if (v44 >= a2) {
            break;
          }
          float v45 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          ++v44;
        }
        while (v45 >= (*(float (**)(void))(*(void *)*v10 + 24))());
      }
      else
      {
        uint64_t v10 = a1;
        do
        {
          float v42 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v43 = v10[1];
          ++v10;
        }
        while (v42 >= (*(float (**)(uint64_t))(*(void *)v43 + 24))(v43));
      }
      char v46 = a2;
      if (v10 < a2)
      {
        char v46 = a2;
        do
        {
          float v47 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v48 = *--v46;
        }
        while (v47 < (*(float (**)(uint64_t))(*(void *)v48 + 24))(v48));
      }
      while (v10 < v46)
      {
        uint64_t v49 = *v10;
        uint64_t *v10 = *v46;
        *char v46 = v49;
        do
        {
          float v50 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v51 = v10[1];
          ++v10;
        }
        while (v50 >= (*(float (**)(uint64_t))(*(void *)v51 + 24))(v51));
        do
        {
          float v52 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v53 = *--v46;
        }
        while (v52 < (*(float (**)(uint64_t))(*(void *)v53 + 24))(v53));
      }
      int64x2_t v54 = (unsigned int **)(v10 - 1);
      BOOL v4 = v10 - 1 >= a1;
      BOOL v5 = v10 - 1 == a1;
      if (v10 - 1 != a1)
      {
        unint64_t v55 = *v54;
        char *v54 = 0;
        uint64_t v56 = (unsigned int *)*a1;
        *a1 = (uint64_t)v55;
        if (v56)
        {
          unsigned int v57 = atomic_load(v56 + 2);
          BOOL v4 = v57 != 0;
          BOOL v5 = v57 == 1;
          if (v57 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v56 + 248))(v56);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v56 + 2, 0xFFFFFFFF);
          }
        }
      }
      a4 = 0;
      uint64_t v58 = *v54;
      char *v54 = (unsigned int *)v40;
      if (v58)
      {
        unsigned int v59 = atomic_load(v58 + 2);
        BOOL v4 = v59 != 0;
        BOOL v5 = v59 == 1;
        if (v59 == 1)
        {
          (*(void (**)(unsigned int *))(*(void *)v58 + 248))(v58);
          a4 = 0;
        }
        else
        {
          a4 = 0;
          atomic_fetch_add((atomic_uint *volatile)v58 + 2, 0xFFFFFFFF);
        }
      }
    }
  }
  uint64_t v62 = a1 + 1;
  BOOL v64 = a1 == a2 || v62 == a2;
  if ((a4 & 1) == 0)
  {
    if (!v64)
    {
      do
      {
        int v129 = a1;
        a1 = v62;
        float v130 = (*(float (**)(uint64_t))(*(void *)v129[1] + 24))(v129[1]);
        if (v130 < (*(float (**)(void))(*(void *)*v129 + 24))())
        {
          long long v131 = 0;
          uint64_t v132 = *a1;
          *a1 = 0;
          int64_t v133 = a1;
          do
          {
            uint64_t v134 = *(v133 - 1);
            *(v133 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            *int64_t v133 = v134;
            if (v131)
            {
              unsigned int v135 = atomic_load(v131 + 2);
              if (v135 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v131 + 248))(v131);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v131 + 2, 0xFFFFFFFF);
              }
            }
            float v136 = (*(float (**)(uint64_t))(*(void *)v132 + 24))(v132);
            float v137 = (*(float (**)(void))(*(void *)*(v133 - 2) + 24))(*(v133 - 2));
            int v138 = (unsigned int *)*--v133;
            long long v131 = v138;
          }
          while (v136 < v137);
          *int64_t v133 = v132;
          if (v131)
          {
            unsigned int v139 = atomic_load(v131 + 2);
            if (v139 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v131 + 248))(v131);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v131 + 2, 0xFFFFFFFF);
            }
          }
        }
        uint64_t v62 = a1 + 1;
      }
      while (a1 + 1 != a2);
    }
    return;
  }
  if (v64) {
    return;
  }
  uint64_t v65 = 0;
  long long v66 = a1;
  while (2)
  {
    unint64_t v67 = v66;
    long long v66 = v62;
    float v68 = (*(float (**)(uint64_t))(*(void *)v67[1] + 24))(v67[1]);
    if (v68 >= (*(float (**)(void))(*(void *)*v67 + 24))()) {
      goto LABEL_100;
    }
    unint64_t v69 = a2;
    char v70 = 0;
    uint64_t v71 = (unsigned int *)*v66;
    uint64_t *v66 = 0;
    uint64_t v72 = v65;
    while (2)
    {
      uint64_t v73 = (unsigned int **)((char *)a1 + v72);
      int v74 = *(unsigned int **)((char *)a1 + v72);
      *uint64_t v73 = 0;
      v73[1] = v74;
      if (!v70)
      {
LABEL_90:
        if (!v72) {
          break;
        }
        goto LABEL_93;
      }
      unsigned int v75 = atomic_load(v70 + 2);
      if (v75 == 1)
      {
        (*(void (**)(unsigned int *))(*(void *)v70 + 248))(v70);
        goto LABEL_90;
      }
      atomic_fetch_add((atomic_uint *volatile)v70 + 2, 0xFFFFFFFF);
      if (v72)
      {
LABEL_93:
        char v76 = (unsigned int **)((char *)a1 + v72);
        float v77 = (*(float (**)(unsigned int *))(*(void *)v71 + 24))(v71);
        if (v77 >= (*(float (**)(void))(*(void *)*(v76 - 1) + 24))(*(v76 - 1))) {
          goto LABEL_96;
        }
        char v70 = *v73;
        v72 -= 8;
        continue;
      }
      break;
    }
    char v76 = (unsigned int **)a1;
LABEL_96:
    uint64_t v78 = *v76;
    void *v76 = v71;
    a2 = v69;
    if (v78)
    {
      unsigned int v79 = atomic_load(v78 + 2);
      if (v79 == 1) {
        (*(void (**)(unsigned int *))(*(void *)v78 + 248))(v78);
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v78 + 2, 0xFFFFFFFF);
      }
    }
LABEL_100:
    uint64_t v62 = v66 + 1;
    v65 += 8;
    if (v66 + 1 != a2) {
      continue;
    }
    break;
  }
}

  uint64_t v9 = a1;
  v149 = a1 + 128;
  long long v150 = a1 + 64;
  uint64_t v10 = a1 + 24;
  CFTypeID v153 = (void *)(a1 + 32);
  unsigned int v155 = (void *)(a1 + 8);
  CFTypeID v152 = a1 + 48;
  while (1)
  {
    uint64_t v11 = (uint64_t)a2 - v9;
    uint64_t v12 = (uint64_t)((uint64_t)a2 - v9) >> 6;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          if (*((double *)a2 - 2) > *(double *)(v9 + 48))
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TI::ShortMemory::WordRecord *&,TI::ShortMemory::WordRecord *&>((uint64_t *)v9, a2 - 4);
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v9, v9 + 64, (uint64_t)(a2 - 4));
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v9, v9 + 64, v9 + 128, (uint64_t)(a2 - 4));
          break;
        case 5:
          std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v9, v9 + 64, v9 + 128, v9 + 192, (uint64_t)(a2 - 4));
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    uint64_t v165 = (uint64_t)a2;
    if (v11 <= 1535) {
      break;
    }
    if (!a3)
    {
      if ((long long *)v9 != a2)
      {
        long long v83 = (unint64_t)(v12 - 2) >> 1;
        float v84 = v83;
        do
        {
          long long v85 = v84;
          if (v83 >= v84)
          {
            float v86 = (2 * v84) | 1;
            int v87 = v9 + (v86 << 6);
            if (2 * v85 + 2 < v12 && *(double *)(v87 + 48) > *(double *)(v87 + 112))
            {
              v87 += 64;
              float v86 = 2 * v85 + 2;
            }
            char v88 = v9 + (v85 << 6);
            uint64_t v89 = *(double *)(v88 + 48);
            if (*(double *)(v87 + 48) <= v89)
            {
              int v90 = v9 + (v85 << 6);
              long long v154 = *(void **)v90;
              *(void *)&v184[7] = *(void *)(v90 + 15);
              *(void *)v184 = *(void *)(v90 + 8);
              unsigned int v91 = *(unsigned char *)(v90 + 23);
              *(void *)int v90 = 0;
              *(void *)(v90 + 8) = 0;
              *(void *)(v90 + 16) = 0;
              uint64_t v158 = *(void *)(v88 + 24);
              *(void *)CFTypeRef v177 = *(void *)(v88 + 32);
              *(void *)&v177[7] = *(void *)(v88 + 39);
              int v162 = *(unsigned char *)(v90 + 47);
              *(void *)(v88 + 24) = 0;
              *(void *)(v88 + 32) = 0;
              *(void *)(v88 + 40) = 0;
              long long v156 = *(_DWORD *)(v88 + 56);
              do
              {
                uint64_t v92 = v90;
                int v90 = v87;
                if (*(char *)(v92 + 23) < 0) {
                  operator delete(*(void **)v92);
                }
                uint64_t v93 = *(_OWORD *)v90;
                *(void *)(v92 + 16) = *(void *)(v90 + 16);
                *(_OWORD *)uint64_t v92 = v93;
                *(unsigned char *)(v90 + 23) = 0;
                *(unsigned char *)int v90 = 0;
                float v94 = (void **)(v92 + 24);
                if (*(char *)(v92 + 47) < 0) {
                  operator delete(*v94);
                }
                float v95 = *(_OWORD *)(v90 + 24);
                *(void *)(v92 + 40) = *(void *)(v90 + 40);
                *(_OWORD *)float v94 = v95;
                *(unsigned char *)(v90 + 47) = 0;
                *(unsigned char *)(v90 + 24) = 0;
                char v96 = *(void *)(v90 + 48);
                *(_DWORD *)(v92 + 56) = *(_DWORD *)(v90 + 56);
                *(void *)(v92 + 48) = v96;
                if (v83 < v86) {
                  break;
                }
                unsigned int v97 = 2 * v86;
                float v86 = (2 * v86) | 1;
                int v87 = v9 + (v86 << 6);
                uint64_t v98 = v97 + 2;
                if (v98 < v12 && *(double *)(v87 + 48) > *(double *)(v87 + 112))
                {
                  v87 += 64;
                  float v86 = v98;
                }
              }
              while (*(double *)(v87 + 48) <= v89);
              if (*(char *)(v90 + 23) < 0) {
                operator delete(*(void **)v90);
              }
              *(void *)int v90 = v154;
              *(void *)(v90 + 8) = *(void *)v184;
              *(void *)(v90 + 15) = *(void *)&v184[7];
              *(unsigned char *)(v90 + 23) = v91;
              if (*(char *)(v90 + 47) < 0) {
                operator delete(*(void **)(v90 + 24));
              }
              *(void *)(v90 + 24) = v158;
              *(void *)(v90 + 32) = *(void *)v177;
              *(void *)(v90 + 39) = *(void *)&v177[7];
              *(unsigned char *)(v90 + 47) = v162;
              *(double *)(v90 + 48) = v89;
              *(_DWORD *)(v90 + 56) = v156;
            }
          }
          float v84 = v85 - 1;
        }
        while (v85);
        char v99 = (unint64_t)v11 >> 6;
        uint64_t v100 = v165;
        do
        {
          if (v99 >= 2)
          {
            char v101 = 0;
            int v163 = *(void *)v9;
            int v166 = v100;
            *(void *)unint64_t v171 = *(void *)(v9 + 8);
            *(void *)&v171[7] = *(void *)(v9 + 15);
            int8x8_t v102 = *(unsigned char *)(v9 + 23);
            *(void *)uint64_t v9 = 0;
            *(void *)(v9 + 8) = 0;
            *(void *)(v9 + 16) = 0;
            uint64_t v103 = *(void *)(v9 + 24);
            *(void *)uint64_t v169 = *(void *)(v9 + 32);
            *(void *)&v169[7] = *(void *)(v9 + 39);
            uint64_t v104 = *(unsigned char *)(v9 + 47);
            *(void *)(v9 + 32) = 0;
            *(void *)(v9 + 40) = 0;
            long long v168 = *(_DWORD *)(v9 + 56);
            unsigned int v167 = *(void *)(v9 + 48);
            float v105 = v9;
            *(void *)(v9 + 24) = 0;
            do
            {
              uint64_t v106 = v105 + ((v101 + 1) << 6);
              char v107 = 2 * v101;
              char v101 = (2 * v101) | 1;
              unsigned int v108 = v107 + 2;
              if (v108 < v99 && *(double *)(v106 + 48) > *(double *)(v106 + 112))
              {
                v106 += 64;
                char v101 = v108;
              }
              if (*(char *)(v105 + 23) < 0) {
                operator delete(*(void **)v105);
              }
              uint64_t v109 = *(_OWORD *)v106;
              *(void *)(v105 + 16) = *(void *)(v106 + 16);
              *(_OWORD *)float v105 = v109;
              *(unsigned char *)(v106 + 23) = 0;
              *(unsigned char *)uint64_t v106 = 0;
              BOOL v110 = (void **)(v105 + 24);
              if (*(char *)(v105 + 47) < 0) {
                operator delete(*v110);
              }
              char v111 = *(_OWORD *)(v106 + 24);
              *(void *)(v105 + 40) = *(void *)(v106 + 40);
              *(_OWORD *)BOOL v110 = v111;
              char v113 = (double *)(v106 + 48);
              unsigned int v112 = *(void *)(v106 + 48);
              *(unsigned char *)(v106 + 47) = 0;
              *(unsigned char *)(v106 + 24) = 0;
              *(_DWORD *)(v105 + 56) = *(_DWORD *)(v106 + 56);
              *(void *)(v105 + 48) = v112;
              float v105 = v106;
            }
            while (v101 <= (uint64_t)((unint64_t)(v99 - 2) >> 1));
            char v114 = (void **)(v106 + 24);
            TITokenID v115 = (void **)(v166 - 64);
            unsigned int v116 = *(char *)(v106 + 23);
            if (v106 == v166 - 64)
            {
              if (v116 < 0) {
                operator delete(*(void **)v106);
              }
              *(void *)uint64_t v106 = v163;
              *(void *)(v106 + 8) = *(void *)v171;
              *(void *)(v106 + 15) = *(void *)&v171[7];
              *(unsigned char *)(v106 + 23) = v102;
              if (*(char *)(v106 + 47) < 0) {
                operator delete(*v114);
              }
              *(void *)(v106 + 24) = v103;
              *(void *)(v106 + 32) = *(void *)v169;
              *(void *)(v106 + 39) = *(void *)&v169[7];
              *(unsigned char *)(v106 + 47) = v104;
              *(_DWORD *)(v106 + 56) = v168;
              *(void *)char v113 = v167;
            }
            else
            {
              if (v116 < 0) {
                operator delete(*(void **)v106);
              }
              uint64_t v117 = *(_OWORD *)v115;
              *(void *)(v106 + 16) = *(void *)(v166 - 48);
              *(_OWORD *)uint64_t v106 = v117;
              *(unsigned char *)(v166 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
              *(unsigned char *)(v166 - 64) = 0;
              if (*(char *)(v106 + 47) < 0) {
                operator delete(*v114);
              }
              unint64_t v118 = *(_OWORD *)(v166 - 40);
              *(void *)(v106 + 40) = *(void *)(v166 - 24);
              *(_OWORD *)char v114 = v118;
              char v119 = *(void *)(v166 - 16);
              *(unsigned char *)(v166 - 17) = 0;
              *(unsigned char *)(v166 - 40) = 0;
              *(_DWORD *)(v106 + 56) = *(_DWORD *)(v166 - 8);
              *(void *)char v113 = v119;
              if (*(char *)(v166 - 41) < 0) {
                operator delete(*v115);
              }
              *(void *)(v166 - 64) = v163;
              *(void *)(v166 - 49) = *(void *)&v171[7];
              *(void *)(v166 - 56) = *(void *)v171;
              *(unsigned char *)(v166 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v102;
              if (*(char *)(v166 - 17) < 0) {
                operator delete(*(void **)(v166 - 40));
              }
              *(void *)(v166 - 40) = v103;
              *(void *)(v166 - 25) = *(void *)&v169[7];
              *(void *)(v166 - 32) = *(void *)v169;
              *(unsigned char *)(v166 - 17) = v104;
              *(_DWORD *)(v166 - 8) = v168;
              *(void *)(v166 - 16) = v167;
              float v120 = v106 + 64 - v9;
              if (v120 >= 65)
              {
                unint64_t v121 = (unint64_t)((v120 >> 6) - 2) >> 1;
                char v122 = *v113;
                if (*(double *)(v9 + (v121 << 6) + 48) > *v113)
                {
                  uint64_t v123 = *(void **)v106;
                  *(void *)std::vector<unsigned int> v185 = *(void *)(v106 + 8);
                  *(void *)&v185[7] = *(void *)(v106 + 15);
                  uint64_t v124 = *(unsigned char *)(v106 + 23);
                  *(void *)uint64_t v106 = 0;
                  *(void *)(v106 + 8) = 0;
                  *(void *)(v106 + 16) = 0;
                  unsigned int v125 = *(void *)(v106 + 24);
                  *(void *)&v178[7] = *(void *)(v106 + 39);
                  *(void *)uint64_t v178 = *(void *)(v106 + 32);
                  int64x2_t v164 = *(unsigned char *)(v106 + 47);
                  *char v114 = 0;
                  *(void *)(v106 + 32) = 0;
                  *(void *)(v106 + 40) = 0;
                  uint64_t v159 = *(_DWORD *)(v106 + 56);
                  do
                  {
                    if (*(char *)(v106 + 23) < 0) {
                      operator delete(*(void **)v106);
                    }
                    float v126 = v9 + (v121 << 6);
                    unsigned int v127 = *(_OWORD *)v126;
                    *(void *)(v106 + 16) = *(void *)(v126 + 16);
                    *(_OWORD *)uint64_t v106 = v127;
                    *(unsigned char *)(v126 + 23) = 0;
                    *(unsigned char *)float v126 = 0;
                    BOOL v128 = (void **)(v106 + 24);
                    if (*(char *)(v106 + 47) < 0) {
                      operator delete(*v128);
                    }
                    int v129 = v9 + (v121 << 6);
                    float v130 = *(_OWORD *)(v129 + 24);
                    *(void *)(v106 + 40) = *(void *)(v129 + 40);
                    *(_OWORD *)BOOL v128 = v130;
                    *(unsigned char *)(v126 + 47) = 0;
                    *(unsigned char *)(v129 + 24) = 0;
                    uint64_t v132 = *(void *)(v129 + 48);
                    long long v131 = v129 + 48;
                    *(_DWORD *)(v106 + 56) = *(_DWORD *)(v129 + 56);
                    *(void *)(v106 + 48) = v132;
                    if (!v121) {
                      break;
                    }
                    unint64_t v121 = (v121 - 1) >> 1;
                    uint64_t v106 = v126;
                  }
                  while (*(double *)(v9 + (v121 << 6) + 48) > v122);
                  if (*(char *)(v126 + 23) < 0) {
                    operator delete(*(void **)v126);
                  }
                  int64_t v133 = v129 + 24;
                  *(void *)float v126 = v123;
                  *(void *)(v126 + 15) = *(void *)&v185[7];
                  *(void *)(v126 + 8) = *(void *)v185;
                  *(unsigned char *)(v126 + 23) = v124;
                  if (*(char *)(v126 + 47) < 0) {
                    operator delete(*(void **)v133);
                  }
                  *(void *)int64_t v133 = v125;
                  *(void *)(v133 + 15) = *(void *)&v178[7];
                  *(void *)(v133 + 8) = *(void *)v178;
                  *(unsigned char *)(v133 + 23) = v164;
                  *(double *)long long v131 = v122;
                  *(_DWORD *)(v131 + 8) = v159;
                }
              }
            }
            uint64_t v100 = v166;
          }
          v100 -= 64;
        }
        while ((unint64_t)v99-- > 2);
      }
      return;
    }
    unint64_t v13 = v9 + ((unint64_t)v12 >> 1 << 6);
    int v14 = (uint64_t)(a2 - 4);
    if ((unint64_t)v11 <= 0x2000)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v13, v9, v14);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v9, v13, v14);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v150, v13 - 64, (uint64_t)(a2 - 8));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v149, v13 + 64, (uint64_t)(a2 - 12));
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v13 - 64, v13, v13 + 64);
      uint64_t v15 = *(void *)v9;
      *(void *)&CFTypeRef v180 = *v155;
      *(void *)((char *)&v180 + 7) = *(void *)((char *)v155 + 7);
      float v16 = *(unsigned char *)(v9 + 23);
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(void *)(v9 + 16) = 0;
      uint64_t v17 = *(void *)(v9 + 24);
      *(void *)&uint64_t v173 = *v153;
      *(void *)((char *)&v173 + 7) = *(void *)((char *)v153 + 7);
      uint64_t v18 = *(unsigned char *)(v9 + 47);
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 16) = 0;
      *(void *)uint64_t v10 = 0;
      CFTypeRef v172 = *(_DWORD *)(v152 + 8);
      float v170 = *(void *)v152;
      uint64_t v19 = *(_OWORD *)v13;
      *(void *)(v9 + 16) = *(void *)(v13 + 16);
      *(_OWORD *)uint64_t v9 = v19;
      *(unsigned char *)(v13 + 23) = 0;
      *(unsigned char *)unint64_t v13 = 0;
      uint64_t v20 = *(_OWORD *)(v13 + 24);
      float v21 = *(void *)(v13 + 48);
      *(void *)(v10 + 16) = *(void *)(v13 + 40);
      *(_OWORD *)uint64_t v10 = v20;
      *(unsigned char *)(v13 + 47) = 0;
      *(unsigned char *)(v13 + 24) = 0;
      *(_DWORD *)(v152 + 8) = *(_DWORD *)(v13 + 56);
      *(void *)CFTypeID v152 = v21;
      *(void *)unint64_t v13 = v15;
      *(void *)(v13 + 15) = *(void *)((char *)&v180 + 7);
      *(void *)(v13 + 8) = v180;
      *(unsigned char *)(v13 + 23) = v16;
      *(void *)(v13 + 24) = v17;
      *(void *)(v13 + 39) = *(void *)((char *)&v173 + 7);
      *(void *)(v13 + 32) = v173;
      *(unsigned char *)(v13 + 47) = v18;
      *(_DWORD *)(v13 + 56) = v172;
      *(void *)(v13 + 48) = v170;
    }
    CFTypeRef v160 = --a3;
    if (a4)
    {
      unint64_t v22 = *(double *)(v9 + 48);
    }
    else
    {
      unint64_t v22 = *(double *)(v9 + 48);
      if (*(double *)(v9 - 16) <= v22)
      {
        float v42 = *(void *)v9;
        *(void *)CFTypeRef v182 = *(void *)(v9 + 8);
        *(void *)&v182[7] = *(void *)(v9 + 15);
        uint64_t v43 = *(unsigned char *)(v9 + 23);
        *(void *)uint64_t v9 = 0;
        *(void *)(v9 + 8) = 0;
        *(void *)(v9 + 16) = 0;
        uint64_t v44 = (void **)(v9 + 24);
        float v45 = *(void *)(v9 + 24);
        *(void *)&v175[7] = *(void *)(v9 + 39);
        *(void *)uint64_t v175 = *(void *)(v9 + 32);
        char v46 = *(unsigned char *)(v9 + 47);
        *(void *)(v9 + 24) = 0;
        *(void *)(v9 + 32) = 0;
        *(void *)(v9 + 40) = 0;
        if (v22 <= *((double *)a2 - 2))
        {
          uint64_t v49 = v9 + 64;
          do
          {
            a1 = v49;
            if (v49 >= (unint64_t)a2) {
              break;
            }
            float v50 = *(double *)(v49 + 48);
            v49 += 64;
          }
          while (v22 <= v50);
        }
        else
        {
          float v47 = v9;
          do
          {
            a1 = v47 + 64;
            uint64_t v48 = *(double *)(v47 + 112);
            v47 += 64;
          }
          while (v22 <= v48);
        }
        if (a1 < (unint64_t)a2)
        {
          uint64_t v51 = a2;
          do
          {
            a2 = v51 - 4;
            float v52 = *((double *)v51 - 2);
            v51 -= 4;
          }
          while (v22 > v52);
        }
        uint64_t v53 = *(_DWORD *)(v9 + 56);
        while (a1 < (unint64_t)a2)
        {
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TI::ShortMemory::WordRecord *&,TI::ShortMemory::WordRecord *&>((uint64_t *)a1, a2);
          do
          {
            int64x2_t v54 = *(double *)(a1 + 112);
            a1 += 64;
          }
          while (v22 <= v54);
          do
          {
            unint64_t v55 = *((double *)a2 - 2);
            a2 -= 4;
          }
          while (v22 > v55);
        }
        uint64_t v56 = (void **)(a1 - 64);
        BOOL v4 = a1 - 64 >= v9;
        BOOL v5 = a1 - 64 == v9;
        if (a1 - 64 != v9)
        {
          if (*(char *)(v9 + 23) < 0) {
            operator delete(*(void **)v9);
          }
          unsigned int v57 = *(_OWORD *)v56;
          *(void *)(v9 + 16) = *(void *)(a1 - 48);
          *(_OWORD *)uint64_t v9 = v57;
          *(unsigned char *)(a1 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
          *(unsigned char *)(a1 - 64) = 0;
          if (*(char *)(v9 + 47) < 0) {
            operator delete(*v44);
          }
          uint64_t v58 = *(_OWORD *)(a1 - 40);
          *(void *)(v9 + 40) = *(void *)(a1 - 24);
          *(_OWORD *)uint64_t v44 = v58;
          *(unsigned char *)(a1 - 17) = 0;
          *(unsigned char *)(a1 - 40) = 0;
          unsigned int v59 = *(void *)(a1 - 16);
          *(_DWORD *)(v9 + 56) = *(_DWORD *)(a1 - 8);
          *(void *)(v9 + 48) = v59;
        }
        if (*(char *)(a1 - 41) < 0) {
          operator delete(*v56);
        }
        *(void *)(a1 - 64) = v42;
        *(void *)(a1 - 49) = *(void *)&v182[7];
        *(void *)(a1 - 56) = *(void *)v182;
        *(unsigned char *)(a1 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v43;
        if (*(char *)(a1 - 17) < 0) {
          operator delete(*(void **)(a1 - 40));
        }
        a4 = 0;
        *(void *)(a1 - 40) = v45;
        *(void *)(a1 - 25) = *(void *)&v175[7];
        *(void *)(a1 - 32) = *(void *)v175;
        *(unsigned char *)(a1 - 17) = v46;
        *(double *)(a1 - 16) = v22;
        *(_DWORD *)(a1 - 8) = v53;
        a2 = (long long *)v165;
        goto LABEL_1;
      }
    }
    uint64_t v23 = *(void *)v9;
    *(void *)CFTypeRef v181 = *v155;
    *(void *)&v181[7] = *(void *)((char *)v155 + 7);
    float v24 = *(unsigned char *)(v9 + 23);
    *(void *)uint64_t v9 = 0;
    *(void *)(v9 + 8) = 0;
    *(void *)(v9 + 16) = 0;
    long long v157 = *(void *)(v9 + 24);
    *(void *)&v174[7] = *(void *)((char *)v153 + 7);
    *(void *)long long v174 = *v153;
    uint64_t v25 = *(unsigned char *)(v9 + 47);
    *(void *)(v10 + 8) = 0;
    *(void *)(v10 + 16) = 0;
    *(void *)uint64_t v10 = 0;
    float v26 = v9;
    uint64_t v27 = *(_DWORD *)(v9 + 56);
    do
    {
      unsigned int v28 = v26;
      v26 += 64;
    }
    while (*(double *)(v28 + 112) > v22);
    uint64_t v29 = v165;
    if (v28 == v9)
    {
      uint64_t v32 = v165;
      while (v26 < v32)
      {
        uint64_t v30 = (long long *)(v32 - 64);
        float v33 = *(double *)(v32 - 16);
        v32 -= 64;
        if (v33 > v22) {
          goto LABEL_22;
        }
      }
      uint64_t v30 = (long long *)v32;
    }
    else
    {
      do
      {
        uint64_t v30 = (long long *)(v29 - 64);
        float v31 = *(double *)(v29 - 16);
        v29 -= 64;
      }
      while (v31 <= v22);
    }
LABEL_22:
    a1 = v26;
    if (v26 < (unint64_t)v30)
    {
      uint64_t v34 = v30;
      do
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<TI::ShortMemory::WordRecord *&,TI::ShortMemory::WordRecord *&>((uint64_t *)a1, v34);
        do
        {
          uint64_t v35 = *(double *)(a1 + 112);
          a1 += 64;
        }
        while (v35 > v22);
        do
        {
          unsigned int v36 = *((double *)v34 - 2);
          v34 -= 4;
        }
        while (v36 <= v22);
      }
      while (a1 < (unint64_t)v34);
    }
    unint64_t v37 = (void **)(a1 - 64);
    if (a1 - 64 != v9)
    {
      if (*(char *)(v9 + 23) < 0) {
        operator delete(*(void **)v9);
      }
      unsigned int v38 = *(_OWORD *)v37;
      *(void *)(v9 + 16) = *(void *)(a1 - 48);
      *(_OWORD *)uint64_t v9 = v38;
      *(unsigned char *)(a1 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
      *(unsigned char *)(a1 - 64) = 0;
      if (*(char *)(v9 + 47) < 0) {
        operator delete(*(void **)v10);
      }
      BOOL v39 = *(_OWORD *)(a1 - 40);
      *(void *)(v10 + 16) = *(void *)(a1 - 24);
      *(_OWORD *)uint64_t v10 = v39;
      *(unsigned char *)(a1 - 17) = 0;
      *(unsigned char *)(a1 - 40) = 0;
      uint64_t v40 = *(void *)(a1 - 16);
      *(_DWORD *)(v152 + 8) = *(_DWORD *)(a1 - 8);
      *(void *)CFTypeID v152 = v40;
    }
    if (*(char *)(a1 - 41) < 0) {
      operator delete(*v37);
    }
    *(void *)(a1 - 64) = v23;
    *(void *)(a1 - 49) = *(void *)&v181[7];
    *(void *)(a1 - 56) = *(void *)v181;
    *(unsigned char *)(a1 - 4TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v24;
    if (*(char *)(a1 - 17) < 0) {
      operator delete(*(void **)(a1 - 40));
    }
    a3 = v160;
    *(void *)(a1 - 40) = v157;
    *(void *)(a1 - 25) = *(void *)&v174[7];
    *(void *)(a1 - 32) = *(void *)v174;
    *(unsigned char *)(a1 - 17) = v25;
    *(double *)(a1 - 16) = v22;
    *(_DWORD *)(a1 - 8) = v27;
    a2 = (long long *)v165;
    if (v26 < (unint64_t)v30) {
      goto LABEL_43;
    }
    float v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(v9, a1 - 64);
    if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *>(a1, v165))
    {
      if (v41) {
        goto LABEL_1;
      }
LABEL_43:
      std::__introsort<std::_ClassicAlgPolicy,std::greater<void> &,TI::ShortMemory::WordRecord *,false>(v9, a1 - 64, v160, a4 & 1);
      a4 = 0;
      goto LABEL_1;
    }
    a2 = (long long *)(a1 - 64);
    if (v41) {
      return;
    }
  }
  float v60 = (long long *)(v9 + 64);
  uint64_t v62 = (long long *)v9 == a2 || v60 == a2;
  if (a4)
  {
    if (!v62)
    {
      int v63 = 0;
      BOOL v64 = v9;
      do
      {
        uint64_t v65 = v60;
        long long v66 = *(double *)(v64 + 112);
        if (v66 > *(double *)(v64 + 48))
        {
          unint64_t v67 = *(void *)v60;
          *(void *)&v183[7] = *(void *)(v64 + 79);
          *(void *)uint64_t v183 = *(void *)(v64 + 72);
          float v68 = *(unsigned char *)(v64 + 87);
          *((void *)v60 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
          *((void *)v60 + 2) = 0;
          *(void *)float v60 = 0;
          *(void *)&v176[7] = *(void *)(v64 + 103);
          unint64_t v69 = *(void **)(v64 + 88);
          *(void *)ByteString v176 = *(void *)(v64 + 96);
          long long v161 = *(unsigned char *)(v64 + 111);
          *(void *)(v64 + 88) = 0;
          *(void *)(v64 + 96) = 0;
          *(void *)(v64 + 104) = 0;
          char v70 = *(_DWORD *)(v64 + 120);
          uint64_t v71 = v63;
          while (1)
          {
            uint64_t v72 = v71;
            uint64_t v73 = v9 + v71;
            int v74 = v9 + v71 + 64;
            if (*(char *)(v9 + v71 + 87) < 0) {
              operator delete(*(void **)v74);
            }
            *(_OWORD *)int v74 = *(_OWORD *)v73;
            *(void *)(v74 + 16) = *(void *)(v73 + 16);
            *(unsigned char *)(v73 + 23) = 0;
            *(unsigned char *)uint64_t v73 = 0;
            unsigned int v75 = (void **)(v73 + 88);
            if (*(char *)(v73 + 111) < 0) {
              operator delete(*v75);
            }
            char v76 = v9 + v72;
            *(_OWORD *)unsigned int v75 = *(_OWORD *)(v9 + v72 + 24);
            float v77 = *(void *)(v9 + v72 + 48);
            *(void *)(v73 + 104) = *(void *)(v9 + v72 + 40);
            *(unsigned char *)(v76 + 47) = 0;
            *(unsigned char *)(v76 + 24) = 0;
            *(void *)(v76 + 112) = v77;
            *(_DWORD *)(v76 + 120) = *(_DWORD *)(v9 + v72 + 56);
            if (!v72) {
              break;
            }
            uint64_t v78 = *(double *)(v76 - 16);
            uint64_t v71 = v72 - 64;
            if (v66 <= v78)
            {
              unsigned int v79 = v9 + v72;
              int64_t v80 = v9 + v72;
              int64_t v81 = (double *)(v9 + v72 + 48);
              uint64_t v82 = (void **)(v80 + 24);
              goto LABEL_104;
            }
          }
          int64_t v81 = (double *)(v76 + 48);
          uint64_t v82 = (void **)(v76 + 24);
          unsigned int v79 = v9;
LABEL_104:
          if (*(char *)(v79 + 23) < 0) {
            operator delete(*(void **)v79);
          }
          *(void *)unsigned int v79 = v67;
          *(void *)(v79 + 8) = *(void *)v183;
          *(void *)(v79 + 15) = *(void *)&v183[7];
          *(unsigned char *)(v79 + 23) = v68;
          if (*(char *)(v79 + 47) < 0) {
            operator delete(*v82);
          }
          *uint64_t v82 = v69;
          *(void *)(v79 + 32) = *(void *)v176;
          *(void *)(v79 + 39) = *(void *)&v176[7];
          *(unsigned char *)(v79 + 47) = v161;
          void *v81 = v66;
          *(_DWORD *)(v79 + 56) = v70;
          a2 = (long long *)v165;
        }
        float v60 = v65 + 4;
        v63 += 64;
        BOOL v64 = (unint64_t)v65;
      }
      while (v65 + 4 != a2);
    }
  }
  else if (!v62)
  {
    unsigned int v135 = v9 + 112;
    do
    {
      float v136 = v60;
      float v137 = *(double *)(v9 + 112);
      if (v137 > *(double *)(v9 + 48))
      {
        int v138 = *(void *)v60;
        *(void *)&v186[7] = *(void *)(v9 + 79);
        *(void *)uint64_t v186 = *(void *)(v9 + 72);
        unsigned int v139 = *(unsigned char *)(v9 + 87);
        *((void *)v60 + TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
        *((void *)v60 + 2) = 0;
        *(void *)float v60 = 0;
        *(void *)&v179[7] = *(void *)(v9 + 103);
        unsigned int v140 = *(void *)(v9 + 88);
        *(void *)long long v179 = *(void *)(v9 + 96);
        uint64_t v141 = *(unsigned char *)(v9 + 111);
        *(void *)(v9 + 88) = 0;
        *(void *)(v9 + 96) = 0;
        *(void *)(v9 + 104) = 0;
        uint64_t v142 = *(_DWORD *)(v9 + 120);
        int64_t v143 = v135;
        do
        {
          int64_t v144 = (void **)(v143 - 48);
          if (*(char *)(v143 - 25) < 0) {
            operator delete(*v144);
          }
          uint64_t v145 = v143 - 112;
          *(_OWORD *)int64_t v144 = *(_OWORD *)(v143 - 112);
          *(void *)(v143 - 32) = *(void *)(v143 - 96);
          *(unsigned char *)(v143 - 89) = 0;
          *(unsigned char *)(v143 - 112) = 0;
          id v146 = (void **)(v143 - 24);
          if (*(char *)(v143 - 1) < 0) {
            operator delete(*v146);
          }
          *(_OWORD *)id v146 = *(_OWORD *)(v143 - 88);
          *(void *)(v143 - 8) = *(void *)(v143 - 72);
          *(unsigned char *)(v143 - 65) = 0;
          *(unsigned char *)(v143 - 88) = 0;
          v147 = v143 - 64;
          *(void *)int64_t v143 = *(void *)(v143 - 64);
          *(_DWORD *)(v143 + 8) = *(_DWORD *)(v143 - 56);
          long long v148 = *(double *)(v143 - 128);
          v143 -= 64;
        }
        while (v137 > v148);
        if (*(char *)(v145 + 23) < 0) {
          operator delete(*(void **)v145);
        }
        *(void *)uint64_t v145 = v138;
        *(void *)(v145 + 15) = *(void *)&v186[7];
        *(void *)(v145 + 8) = *(void *)v186;
        *(unsigned char *)(v145 + 23) = v139;
        if (*(char *)(v145 + 47) < 0) {
          operator delete(*(void **)(v147 - 24));
        }
        *(void *)(v147 - 24) = v140;
        *(void *)(v145 + 39) = *(void *)&v179[7];
        *(void *)(v145 + 32) = *(void *)v179;
        *(unsigned char *)(v147 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = v141;
        *(double *)v147 = v137;
        *(_DWORD *)(v147 + 8) = v142;
        a2 = (long long *)v165;
      }
      float v60 = v136 + 4;
      v135 += 64;
      uint64_t v9 = (unint64_t)v136;
    }
    while (v136 + 4 != a2);
  }
}

  uint64_t v9 = a2 - 1;
  uint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    uint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          float v60 = (*(float (**)(void))(*(void *)*v9 + 24))();
          if (v60 < (*(float (**)(void))(*(void *)*a1 + 24))())
          {
            uint64_t v61 = *a1;
            *a1 = *v9;
            *uint64_t v9 = v61;
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a2 - 1);
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, a2 - 1);
          break;
        case 5:
          std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      int64_t v143 = a2;
      unsigned int v79 = (unint64_t)(v12 - 2) >> 1;
      int64_t v80 = v79;
      do
      {
        int64_t v81 = v79;
        if (v80 >= v79)
        {
          uint64_t v82 = (2 * v79) | 1;
          long long v83 = (unsigned int **)&a1[v82];
          if (2 * v79 + 2 < v12)
          {
            float v84 = (*(float (**)(void))(*(void *)*v83 + 24))();
            if (v84 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
            {
              ++v83;
              uint64_t v82 = 2 * v81 + 2;
            }
          }
          long long v85 = (unsigned int **)&a1[v81];
          float v86 = (*(float (**)(void))(*(void *)*v83 + 24))();
          if (v86 >= (*(float (**)(void))(*(void *)*v85 + 24))())
          {
            int v87 = *v85;
            *long long v85 = 0;
            do
            {
              char v88 = v83;
              uint64_t v89 = *v83;
              *long long v83 = 0;
              int v90 = *v85;
              *long long v85 = v89;
              if (v90)
              {
                unsigned int v91 = atomic_load(v90 + 2);
                if (v91 == 1) {
                  (*(void (**)(unsigned int *))(*(void *)v90 + 248))(v90);
                }
                else {
                  atomic_fetch_add((atomic_uint *volatile)v90 + 2, 0xFFFFFFFF);
                }
              }
              if (v80 < v82) {
                break;
              }
              uint64_t v92 = 2 * v82;
              uint64_t v82 = (2 * v82) | 1;
              long long v83 = (unsigned int **)&a1[v82];
              uint64_t v93 = v92 + 2;
              if (v92 + 2 < v12)
              {
                float v94 = (*(float (**)(void))(*(void *)*v83 + 24))();
                if (v94 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
                {
                  ++v83;
                  uint64_t v82 = v93;
                }
              }
              float v95 = (*(float (**)(void))(*(void *)*v83 + 24))();
              long long v85 = v88;
            }
            while (v95 >= (*(float (**)(unsigned int *))(*(void *)v87 + 24))(v87));
            char v96 = *v88;
            *char v88 = v87;
            if (v96)
            {
              unsigned int v97 = atomic_load(v96 + 2);
              if (v97 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v96 + 248))(v96);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v96 + 2, 0xFFFFFFFF);
              }
            }
          }
        }
        unsigned int v79 = v81 - 1;
      }
      while (v81);
      uint64_t v98 = (unint64_t)v11 >> 3;
      char v99 = (unsigned int **)v143;
      while (1)
      {
        uint64_t v100 = 0;
        char v101 = (unsigned int **)a1;
        int64_t v144 = *a1;
        *a1 = 0;
        int8x8_t v102 = v98 - 2;
        if (v98 < 2) {
          int8x8_t v102 = v98 - 1;
        }
        uint64_t v103 = v102 >> 1;
        do
        {
          uint64_t v104 = v101;
          v101 += v100 + 1;
          float v105 = 2 * v100;
          uint64_t v100 = (2 * v100) | 1;
          uint64_t v106 = v105 + 2;
          if (v105 + 2 < v98)
          {
            char v107 = (*(float (**)(void))(*(void *)*v101 + 24))();
            if (v107 < (*(float (**)(unsigned int *))(*(void *)v101[1] + 24))(v101[1]))
            {
              ++v101;
              uint64_t v100 = v106;
            }
          }
          unsigned int v108 = *v101;
          *char v101 = 0;
          uint64_t v109 = *v104;
          *uint64_t v104 = v108;
          if (v109)
          {
            BOOL v110 = atomic_load(v109 + 2);
            if (v110 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v109 + 248))(v109);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v109 + 2, 0xFFFFFFFF);
            }
          }
        }
        while (v100 <= v103);
        char v111 = v99 - 1;
        if (v101 != v111) {
          break;
        }
        char v113 = v111;
        uint64_t v117 = *v101;
        *char v101 = (unsigned int *)v144;
        TITokenID v115 = v98 - 1;
        if (v117)
        {
LABEL_158:
          float v130 = atomic_load(v117 + 2);
          if (v130 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v117 + 248))(v117);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v117 + 2, 0xFFFFFFFF);
          }
        }
LABEL_161:
        long long v131 = v98 <= 2;
        uint64_t v98 = v115;
        char v99 = v113;
        if (v131) {
          return;
        }
      }
      unsigned int v112 = *v111;
      char v113 = v111;
      *char v111 = 0;
      char v114 = *v101;
      *char v101 = v112;
      TITokenID v115 = v98 - 1;
      if (v114)
      {
        unsigned int v116 = atomic_load(v114 + 2);
        if (v116 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v114 + 248))(v114);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v114 + 2, 0xFFFFFFFF);
        }
      }
      unint64_t v118 = *v113;
      const void *v113 = (unsigned int *)v144;
      if (v118)
      {
        char v119 = atomic_load(v118 + 2);
        if (v119 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v118 + 248))(v118);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v118 + 2, 0xFFFFFFFF);
        }
      }
      float v120 = (char *)(v101 + 1) - (char *)a1;
      if (v120 < 9) {
        goto LABEL_161;
      }
      unint64_t v121 = (unint64_t)((v120 >> 3) - 2) >> 1;
      char v122 = (unsigned int **)&a1[v121];
      uint64_t v123 = (*(float (**)(void))(*(void *)*v122 + 24))();
      if (v123 >= (*(float (**)(void))(*(void *)*v101 + 24))()) {
        goto LABEL_161;
      }
      uint64_t v124 = *v101;
      *char v101 = 0;
      while (1)
      {
        unsigned int v125 = v122;
        float v126 = *v122;
        *char v122 = 0;
        unsigned int v127 = *v101;
        *char v101 = v126;
        if (v127)
        {
          BOOL v128 = atomic_load(v127 + 2);
          if (v128 != 1)
          {
            atomic_fetch_add((atomic_uint *volatile)v127 + 2, 0xFFFFFFFF);
            if (!v121) {
              goto LABEL_157;
            }
            goto LABEL_156;
          }
          (*(void (**)(unsigned int *))(*(void *)v127 + 248))(v127);
        }
        if (!v121) {
          goto LABEL_157;
        }
LABEL_156:
        unint64_t v121 = (v121 - 1) >> 1;
        char v122 = (unsigned int **)&a1[v121];
        int v129 = (*(float (**)(void))(*(void *)*v122 + 24))();
        char v101 = v125;
        if (v129 >= (*(float (**)(unsigned int *))(*(void *)v124 + 24))(v124))
        {
LABEL_157:
          uint64_t v117 = *v125;
          *unsigned int v125 = v124;
          if (v117) {
            goto LABEL_158;
          }
          goto LABEL_161;
        }
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    int v14 = a1;
    uint64_t v15 = &a1[(unint64_t)v12 >> 1];
    if ((unint64_t)v11 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v15, a1, a2 - 1);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v15, a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 1, v15 - 1, a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 2, &a1[v13 + 1], a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v15 - 1, v15, &a1[v13 + 1]);
      float v16 = *a1;
      *a1 = *v15;
      *uint64_t v15 = v16;
    }
    --a3;
    if ((a4 & 1) != 0
      || (uint64_t v17 = (*(float (**)(void))(*(void *)*(a1 - 1) + 24))(*(a1 - 1)),
          v17 < (*(float (**)(void))(*(void *)*a1 + 24))()))
    {
      uint64_t v18 = *a1;
      *a1 = 0;
      do
      {
        uint64_t v19 = v14;
        uint64_t v20 = v14[1];
        ++v14;
        float v21 = (*(float (**)(uint64_t))(*(void *)v20 + 24))(v20);
      }
      while (v21 < (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      unint64_t v22 = a2;
      if (v19 == a1)
      {
        unint64_t v22 = a2;
        do
        {
          if (v14 >= v22) {
            break;
          }
          uint64_t v25 = *--v22;
          float v26 = (*(float (**)(uint64_t))(*(void *)v25 + 24))(v25);
        }
        while (v26 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      }
      else
      {
        do
        {
          uint64_t v23 = *--v22;
          float v24 = (*(float (**)(uint64_t))(*(void *)v23 + 24))(v23);
        }
        while (v24 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      }
      if (v14 < v22)
      {
        uint64_t v27 = v14;
        unsigned int v28 = v22;
        do
        {
          uint64_t v29 = *v27;
          *uint64_t v27 = *v28;
          uint64_t *v28 = v29;
          do
          {
            uint64_t v19 = v27;
            uint64_t v30 = v27[1];
            ++v27;
            float v31 = (*(float (**)(uint64_t))(*(void *)v30 + 24))(v30);
          }
          while (v31 < (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
          do
          {
            uint64_t v32 = *--v28;
            float v33 = (*(float (**)(uint64_t))(*(void *)v32 + 24))(v32);
          }
          while (v33 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
        }
        while (v27 < v28);
      }
      if (v19 != a1)
      {
        uint64_t v34 = *v19;
        *uint64_t v19 = 0;
        uint64_t v35 = (unsigned int *)*a1;
        *a1 = v34;
        if (v35)
        {
          unsigned int v36 = atomic_load(v35 + 2);
          if (v36 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v35 + 248))(v35);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v35 + 2, 0xFFFFFFFF);
          }
        }
      }
      unint64_t v37 = (unsigned int *)*v19;
      *uint64_t v19 = v18;
      if (v37)
      {
        unsigned int v38 = atomic_load(v37 + 2);
        if (v38 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v37 + 248))(v37);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v37 + 2, 0xFFFFFFFF);
        }
      }
      if (v14 < v22)
      {
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(a1, v19, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v19 + 1;
      }
      else
      {
        BOOL v39 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v19);
        uint64_t v10 = v19 + 1;
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v19 + 1, a2))
        {
          a2 = v19;
          if (v39) {
            return;
          }
          goto LABEL_1;
        }
        if (!v39) {
          goto LABEL_37;
        }
      }
    }
    else
    {
      uint64_t v40 = *a1;
      *a1 = 0;
      float v41 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
      if (v41 >= (*(float (**)(void))(*(void *)*v9 + 24))())
      {
        uint64_t v44 = a1 + 1;
        do
        {
          uint64_t v10 = v44;
          if (v44 >= a2) {
            break;
          }
          float v45 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          ++v44;
        }
        while (v45 >= (*(float (**)(void))(*(void *)*v10 + 24))());
      }
      else
      {
        uint64_t v10 = a1;
        do
        {
          float v42 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v43 = v10[1];
          ++v10;
        }
        while (v42 >= (*(float (**)(uint64_t))(*(void *)v43 + 24))(v43));
      }
      char v46 = a2;
      if (v10 < a2)
      {
        char v46 = a2;
        do
        {
          float v47 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v48 = *--v46;
        }
        while (v47 < (*(float (**)(uint64_t))(*(void *)v48 + 24))(v48));
      }
      while (v10 < v46)
      {
        uint64_t v49 = *v10;
        uint64_t *v10 = *v46;
        *char v46 = v49;
        do
        {
          float v50 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v51 = v10[1];
          ++v10;
        }
        while (v50 >= (*(float (**)(uint64_t))(*(void *)v51 + 24))(v51));
        do
        {
          float v52 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v53 = *--v46;
        }
        while (v52 < (*(float (**)(uint64_t))(*(void *)v53 + 24))(v53));
      }
      int64x2_t v54 = (unsigned int **)(v10 - 1);
      BOOL v4 = v10 - 1 >= a1;
      BOOL v5 = v10 - 1 == a1;
      if (v10 - 1 != a1)
      {
        unint64_t v55 = *v54;
        char *v54 = 0;
        uint64_t v56 = (unsigned int *)*a1;
        *a1 = (uint64_t)v55;
        if (v56)
        {
          unsigned int v57 = atomic_load(v56 + 2);
          BOOL v4 = v57 != 0;
          BOOL v5 = v57 == 1;
          if (v57 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v56 + 248))(v56);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v56 + 2, 0xFFFFFFFF);
          }
        }
      }
      a4 = 0;
      uint64_t v58 = *v54;
      char *v54 = (unsigned int *)v40;
      if (v58)
      {
        unsigned int v59 = atomic_load(v58 + 2);
        BOOL v4 = v59 != 0;
        BOOL v5 = v59 == 1;
        if (v59 == 1)
        {
          (*(void (**)(unsigned int *))(*(void *)v58 + 248))(v58);
          a4 = 0;
        }
        else
        {
          a4 = 0;
          atomic_fetch_add((atomic_uint *volatile)v58 + 2, 0xFFFFFFFF);
        }
      }
    }
  }
  uint64_t v62 = a1 + 1;
  BOOL v64 = a1 == a2 || v62 == a2;
  if ((a4 & 1) == 0)
  {
    if (!v64)
    {
      do
      {
        uint64_t v132 = v62;
        int64_t v133 = (*(float (**)(uint64_t))(*(void *)a1[1] + 24))(a1[1]);
        if (v133 < (*(float (**)(void))(*(void *)*a1 + 24))())
        {
          uint64_t v134 = 0;
          unsigned int v135 = *v132;
          *uint64_t v132 = 0;
          float v136 = v132;
          do
          {
            float v137 = *(v136 - 1);
            *(v136 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            const char *v136 = v137;
            if (v134)
            {
              int v138 = atomic_load(v134 + 2);
              if (v138 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v134 + 248))(v134);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v134 + 2, 0xFFFFFFFF);
              }
            }
            unsigned int v139 = (*(float (**)(uint64_t))(*(void *)v135 + 24))(v135);
            unsigned int v140 = (*(float (**)(void))(*(void *)*(v136 - 2) + 24))(*(v136 - 2));
            uint64_t v141 = (unsigned int *)*--v136;
            uint64_t v134 = v141;
          }
          while (v139 < v140);
          const char *v136 = v135;
          if (v134)
          {
            uint64_t v142 = atomic_load(v134 + 2);
            if (v142 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v134 + 248))(v134);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v134 + 2, 0xFFFFFFFF);
            }
          }
        }
        a1 = v132;
        uint64_t v62 = v132 + 1;
      }
      while (v132 + 1 != a2);
    }
    return;
  }
  if (v64) {
    return;
  }
  uint64_t v65 = 0;
  long long v66 = a1;
  while (2)
  {
    unint64_t v67 = v66;
    long long v66 = v62;
    float v68 = (*(float (**)(uint64_t))(*(void *)v67[1] + 24))(v67[1]);
    if (v68 >= (*(float (**)(void))(*(void *)*v67 + 24))()) {
      goto LABEL_100;
    }
    unint64_t v69 = 0;
    char v70 = (unsigned int *)*v66;
    uint64_t *v66 = 0;
    uint64_t v71 = v65;
    while (2)
    {
      uint64_t v72 = (unsigned int **)((char *)a1 + v71);
      uint64_t v73 = *(unsigned int **)((char *)a1 + v71);
      void *v72 = 0;
      v72[1] = v73;
      if (!v69)
      {
LABEL_90:
        if (!v71) {
          break;
        }
        goto LABEL_93;
      }
      int v74 = atomic_load(v69 + 2);
      if (v74 == 1)
      {
        (*(void (**)(unsigned int *))(*(void *)v69 + 248))(v69);
        goto LABEL_90;
      }
      atomic_fetch_add((atomic_uint *volatile)v69 + 2, 0xFFFFFFFF);
      if (v71)
      {
LABEL_93:
        unsigned int v75 = (unsigned int **)((char *)a1 + v71);
        char v76 = (*(float (**)(unsigned int *))(*(void *)v70 + 24))(v70);
        if (v76 >= (*(float (**)(void))(*(void *)*(v75 - 1) + 24))(*(v75 - 1))) {
          goto LABEL_96;
        }
        unint64_t v69 = *v72;
        v71 -= 8;
        continue;
      }
      break;
    }
    unsigned int v75 = (unsigned int **)a1;
LABEL_96:
    float v77 = *v75;
    *unsigned int v75 = v70;
    if (v77)
    {
      uint64_t v78 = atomic_load(v77 + 2);
      if (v78 == 1) {
        (*(void (**)(unsigned int *))(*(void *)v77 + 248))(v77);
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v77 + 2, 0xFFFFFFFF);
      }
    }
LABEL_100:
    uint64_t v62 = v66 + 1;
    v65 += 8;
    if (v66 + 1 != a2) {
      continue;
    }
    break;
  }
}

  uint64_t v9 = a2 - 1;
  uint64_t v10 = a1;
  while (1)
  {
    a1 = v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    uint64_t v12 = a2 - v10;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return;
        case 2:
          float v60 = (*(float (**)(void))(*(void *)*v9 + 24))();
          if (v60 < (*(float (**)(void))(*(void *)*a1 + 24))())
          {
            uint64_t v61 = *a1;
            *a1 = *v9;
            *uint64_t v9 = v61;
          }
          break;
        case 3:
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a2 - 1);
          break;
        case 4:
          std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, a1 + 1, a1 + 2, a2 - 1);
          break;
        case 5:
          std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
          break;
        default:
          JUMPOUT(0);
      }
      return;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (a1 == a2) {
        return;
      }
      int64_t v143 = a2;
      unsigned int v79 = (unint64_t)(v12 - 2) >> 1;
      int64_t v80 = v79;
      do
      {
        int64_t v81 = v79;
        if (v80 >= v79)
        {
          uint64_t v82 = (2 * v79) | 1;
          long long v83 = (unsigned int **)&a1[v82];
          if (2 * v79 + 2 < v12)
          {
            float v84 = (*(float (**)(void))(*(void *)*v83 + 24))();
            if (v84 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
            {
              ++v83;
              uint64_t v82 = 2 * v81 + 2;
            }
          }
          long long v85 = (unsigned int **)&a1[v81];
          float v86 = (*(float (**)(void))(*(void *)*v83 + 24))();
          if (v86 >= (*(float (**)(void))(*(void *)*v85 + 24))())
          {
            int v87 = *v85;
            *long long v85 = 0;
            do
            {
              char v88 = v83;
              uint64_t v89 = *v83;
              *long long v83 = 0;
              int v90 = *v85;
              *long long v85 = v89;
              if (v90)
              {
                unsigned int v91 = atomic_load(v90 + 2);
                if (v91 == 1) {
                  (*(void (**)(unsigned int *))(*(void *)v90 + 248))(v90);
                }
                else {
                  atomic_fetch_add((atomic_uint *volatile)v90 + 2, 0xFFFFFFFF);
                }
              }
              if (v80 < v82) {
                break;
              }
              uint64_t v92 = 2 * v82;
              uint64_t v82 = (2 * v82) | 1;
              long long v83 = (unsigned int **)&a1[v82];
              uint64_t v93 = v92 + 2;
              if (v92 + 2 < v12)
              {
                float v94 = (*(float (**)(void))(*(void *)*v83 + 24))();
                if (v94 < (*(float (**)(unsigned int *))(*(void *)v83[1] + 24))(v83[1]))
                {
                  ++v83;
                  uint64_t v82 = v93;
                }
              }
              float v95 = (*(float (**)(void))(*(void *)*v83 + 24))();
              long long v85 = v88;
            }
            while (v95 >= (*(float (**)(unsigned int *))(*(void *)v87 + 24))(v87));
            char v96 = *v88;
            *char v88 = v87;
            if (v96)
            {
              unsigned int v97 = atomic_load(v96 + 2);
              if (v97 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v96 + 248))(v96);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v96 + 2, 0xFFFFFFFF);
              }
            }
          }
        }
        unsigned int v79 = v81 - 1;
      }
      while (v81);
      uint64_t v98 = (unint64_t)v11 >> 3;
      char v99 = (unsigned int **)v143;
      while (1)
      {
        uint64_t v100 = 0;
        char v101 = (unsigned int **)a1;
        int64_t v144 = *a1;
        *a1 = 0;
        int8x8_t v102 = v98 - 2;
        if (v98 < 2) {
          int8x8_t v102 = v98 - 1;
        }
        uint64_t v103 = v102 >> 1;
        do
        {
          uint64_t v104 = v101;
          v101 += v100 + 1;
          float v105 = 2 * v100;
          uint64_t v100 = (2 * v100) | 1;
          uint64_t v106 = v105 + 2;
          if (v105 + 2 < v98)
          {
            char v107 = (*(float (**)(void))(*(void *)*v101 + 24))();
            if (v107 < (*(float (**)(unsigned int *))(*(void *)v101[1] + 24))(v101[1]))
            {
              ++v101;
              uint64_t v100 = v106;
            }
          }
          unsigned int v108 = *v101;
          *char v101 = 0;
          uint64_t v109 = *v104;
          *uint64_t v104 = v108;
          if (v109)
          {
            BOOL v110 = atomic_load(v109 + 2);
            if (v110 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v109 + 248))(v109);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v109 + 2, 0xFFFFFFFF);
            }
          }
        }
        while (v100 <= v103);
        char v111 = v99 - 1;
        if (v101 != v111) {
          break;
        }
        char v113 = v111;
        uint64_t v117 = *v101;
        *char v101 = (unsigned int *)v144;
        TITokenID v115 = v98 - 1;
        if (v117)
        {
LABEL_158:
          float v130 = atomic_load(v117 + 2);
          if (v130 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v117 + 248))(v117);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v117 + 2, 0xFFFFFFFF);
          }
        }
LABEL_161:
        long long v131 = v98 <= 2;
        uint64_t v98 = v115;
        char v99 = v113;
        if (v131) {
          return;
        }
      }
      unsigned int v112 = *v111;
      char v113 = v111;
      *char v111 = 0;
      char v114 = *v101;
      *char v101 = v112;
      TITokenID v115 = v98 - 1;
      if (v114)
      {
        unsigned int v116 = atomic_load(v114 + 2);
        if (v116 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v114 + 248))(v114);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v114 + 2, 0xFFFFFFFF);
        }
      }
      unint64_t v118 = *v113;
      const void *v113 = (unsigned int *)v144;
      if (v118)
      {
        char v119 = atomic_load(v118 + 2);
        if (v119 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v118 + 248))(v118);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v118 + 2, 0xFFFFFFFF);
        }
      }
      float v120 = (char *)(v101 + 1) - (char *)a1;
      if (v120 < 9) {
        goto LABEL_161;
      }
      unint64_t v121 = (unint64_t)((v120 >> 3) - 2) >> 1;
      char v122 = (unsigned int **)&a1[v121];
      uint64_t v123 = (*(float (**)(void))(*(void *)*v122 + 24))();
      if (v123 >= (*(float (**)(void))(*(void *)*v101 + 24))()) {
        goto LABEL_161;
      }
      uint64_t v124 = *v101;
      *char v101 = 0;
      while (1)
      {
        unsigned int v125 = v122;
        float v126 = *v122;
        *char v122 = 0;
        unsigned int v127 = *v101;
        *char v101 = v126;
        if (v127)
        {
          BOOL v128 = atomic_load(v127 + 2);
          if (v128 != 1)
          {
            atomic_fetch_add((atomic_uint *volatile)v127 + 2, 0xFFFFFFFF);
            if (!v121) {
              goto LABEL_157;
            }
            goto LABEL_156;
          }
          (*(void (**)(unsigned int *))(*(void *)v127 + 248))(v127);
        }
        if (!v121) {
          goto LABEL_157;
        }
LABEL_156:
        unint64_t v121 = (v121 - 1) >> 1;
        char v122 = (unsigned int **)&a1[v121];
        int v129 = (*(float (**)(void))(*(void *)*v122 + 24))();
        char v101 = v125;
        if (v129 >= (*(float (**)(unsigned int *))(*(void *)v124 + 24))(v124))
        {
LABEL_157:
          uint64_t v117 = *v125;
          *unsigned int v125 = v124;
          if (v117) {
            goto LABEL_158;
          }
          goto LABEL_161;
        }
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    int v14 = a1;
    uint64_t v15 = &a1[(unint64_t)v12 >> 1];
    if ((unint64_t)v11 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v15, a1, a2 - 1);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v15, a2 - 1);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 1, v15 - 1, a2 - 2);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1 + 2, &a1[v13 + 1], a2 - 3);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,TI::CP::SearchNodeLanguageExtensions::decrease_bound_on_score(void)::$_0 &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v15 - 1, v15, &a1[v13 + 1]);
      float v16 = *a1;
      *a1 = *v15;
      *uint64_t v15 = v16;
    }
    --a3;
    if ((a4 & 1) != 0
      || (uint64_t v17 = (*(float (**)(void))(*(void *)*(a1 - 1) + 24))(*(a1 - 1)),
          v17 < (*(float (**)(void))(*(void *)*a1 + 24))()))
    {
      uint64_t v18 = *a1;
      *a1 = 0;
      do
      {
        uint64_t v19 = v14;
        uint64_t v20 = v14[1];
        ++v14;
        float v21 = (*(float (**)(uint64_t))(*(void *)v20 + 24))(v20);
      }
      while (v21 < (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      unint64_t v22 = a2;
      if (v19 == a1)
      {
        unint64_t v22 = a2;
        do
        {
          if (v14 >= v22) {
            break;
          }
          uint64_t v25 = *--v22;
          float v26 = (*(float (**)(uint64_t))(*(void *)v25 + 24))(v25);
        }
        while (v26 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      }
      else
      {
        do
        {
          uint64_t v23 = *--v22;
          float v24 = (*(float (**)(uint64_t))(*(void *)v23 + 24))(v23);
        }
        while (v24 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
      }
      if (v14 < v22)
      {
        uint64_t v27 = v14;
        unsigned int v28 = v22;
        do
        {
          uint64_t v29 = *v27;
          *uint64_t v27 = *v28;
          uint64_t *v28 = v29;
          do
          {
            uint64_t v19 = v27;
            uint64_t v30 = v27[1];
            ++v27;
            float v31 = (*(float (**)(uint64_t))(*(void *)v30 + 24))(v30);
          }
          while (v31 < (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
          do
          {
            uint64_t v32 = *--v28;
            float v33 = (*(float (**)(uint64_t))(*(void *)v32 + 24))(v32);
          }
          while (v33 >= (*(float (**)(uint64_t))(*(void *)v18 + 24))(v18));
        }
        while (v27 < v28);
      }
      if (v19 != a1)
      {
        uint64_t v34 = *v19;
        *uint64_t v19 = 0;
        uint64_t v35 = (unsigned int *)*a1;
        *a1 = v34;
        if (v35)
        {
          unsigned int v36 = atomic_load(v35 + 2);
          if (v36 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v35 + 248))(v35);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v35 + 2, 0xFFFFFFFF);
          }
        }
      }
      unint64_t v37 = (unsigned int *)*v19;
      *uint64_t v19 = v18;
      if (v37)
      {
        unsigned int v38 = atomic_load(v37 + 2);
        if (v38 == 1) {
          (*(void (**)(unsigned int *))(*(void *)v37 + 248))(v37);
        }
        else {
          atomic_fetch_add((atomic_uint *volatile)v37 + 2, 0xFFFFFFFF);
        }
      }
      if (v14 < v22)
      {
LABEL_37:
        std::__introsort<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *,false>(a1, v19, a3, a4 & 1);
        a4 = 0;
        uint64_t v10 = v19 + 1;
      }
      else
      {
        BOOL v39 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(a1, v19);
        uint64_t v10 = v19 + 1;
        if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,TI::Favonius::SearchNodeLanguageThenGeometryExtensions::LetterExtensionComparator &,WTF::RefPtr<TI::Favonius::TypingHypothesis> *>(v19 + 1, a2))
        {
          a2 = v19;
          if (v39) {
            return;
          }
          goto LABEL_1;
        }
        if (!v39) {
          goto LABEL_37;
        }
      }
    }
    else
    {
      uint64_t v40 = *a1;
      *a1 = 0;
      float v41 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
      if (v41 >= (*(float (**)(void))(*(void *)*v9 + 24))())
      {
        uint64_t v44 = a1 + 1;
        do
        {
          uint64_t v10 = v44;
          if (v44 >= a2) {
            break;
          }
          float v45 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          ++v44;
        }
        while (v45 >= (*(float (**)(void))(*(void *)*v10 + 24))());
      }
      else
      {
        uint64_t v10 = a1;
        do
        {
          float v42 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v43 = v10[1];
          ++v10;
        }
        while (v42 >= (*(float (**)(uint64_t))(*(void *)v43 + 24))(v43));
      }
      char v46 = a2;
      if (v10 < a2)
      {
        char v46 = a2;
        do
        {
          float v47 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v48 = *--v46;
        }
        while (v47 < (*(float (**)(uint64_t))(*(void *)v48 + 24))(v48));
      }
      while (v10 < v46)
      {
        uint64_t v49 = *v10;
        uint64_t *v10 = *v46;
        *char v46 = v49;
        do
        {
          float v50 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v51 = v10[1];
          ++v10;
        }
        while (v50 >= (*(float (**)(uint64_t))(*(void *)v51 + 24))(v51));
        do
        {
          float v52 = (*(float (**)(uint64_t))(*(void *)v40 + 24))(v40);
          uint64_t v53 = *--v46;
        }
        while (v52 < (*(float (**)(uint64_t))(*(void *)v53 + 24))(v53));
      }
      int64x2_t v54 = (unsigned int **)(v10 - 1);
      BOOL v4 = v10 - 1 >= a1;
      BOOL v5 = v10 - 1 == a1;
      if (v10 - 1 != a1)
      {
        unint64_t v55 = *v54;
        char *v54 = 0;
        uint64_t v56 = (unsigned int *)*a1;
        *a1 = (uint64_t)v55;
        if (v56)
        {
          unsigned int v57 = atomic_load(v56 + 2);
          BOOL v4 = v57 != 0;
          BOOL v5 = v57 == 1;
          if (v57 == 1) {
            (*(void (**)(unsigned int *))(*(void *)v56 + 248))(v56);
          }
          else {
            atomic_fetch_add((atomic_uint *volatile)v56 + 2, 0xFFFFFFFF);
          }
        }
      }
      a4 = 0;
      uint64_t v58 = *v54;
      char *v54 = (unsigned int *)v40;
      if (v58)
      {
        unsigned int v59 = atomic_load(v58 + 2);
        BOOL v4 = v59 != 0;
        BOOL v5 = v59 == 1;
        if (v59 == 1)
        {
          (*(void (**)(unsigned int *))(*(void *)v58 + 248))(v58);
          a4 = 0;
        }
        else
        {
          a4 = 0;
          atomic_fetch_add((atomic_uint *volatile)v58 + 2, 0xFFFFFFFF);
        }
      }
    }
  }
  uint64_t v62 = a1 + 1;
  BOOL v64 = a1 == a2 || v62 == a2;
  if ((a4 & 1) == 0)
  {
    if (!v64)
    {
      do
      {
        uint64_t v132 = v62;
        int64_t v133 = (*(float (**)(uint64_t))(*(void *)a1[1] + 24))(a1[1]);
        if (v133 < (*(float (**)(void))(*(void *)*a1 + 24))())
        {
          uint64_t v134 = 0;
          unsigned int v135 = *v132;
          *uint64_t v132 = 0;
          float v136 = v132;
          do
          {
            float v137 = *(v136 - 1);
            *(v136 - TI::CP::Path::set_sample_is_inflection_point(this, -1431655765 * ((*((void *)this + 1) - *(void *)this) >> 4) - 1) = 0;
            const char *v136 = v137;
            if (v134)
            {
              int v138 = atomic_load(v134 + 2);
              if (v138 == 1) {
                (*(void (**)(unsigned int *))(*(void *)v134 + 248))(v134);
              }
              else {
                atomic_fetch_add((atomic_uint *volatile)v134 + 2, 0xFFFFFFFF);
              }
            }
            unsigned int v139 = (*(float (**)(uint64_t))(*(void *)v135 + 24))(v135);
            unsigned int v140 = (*(float (**)(void))(*(void *)*(v136 - 2) + 24))(*(v136 - 2));
            uint64_t v141 = (unsigned int *)*--v136;
            uint64_t v134 = v141;
          }
          while (v139 < v140);
          const char *v136 = v135;
          if (v134)
          {
            uint64_t v142 = atomic_load(v134 + 2);
            if (v142 == 1) {
              (*(void (**)(unsigned int *))(*(void *)v134 + 248))(v134);
            }
            else {
              atomic_fetch_add((atomic_uint *volatile)v134 + 2, 0xFFFFFFFF);
            }
          }
        }
        a1 = v132;
        uint64_t v62 = v132 + 1;
      }
      while (v132 + 1 != a2);
    }
    return;
  }
  if (v64) {
    return;
  }
  uint64_t v65 = 0;
  long long v66 = a1;
  while (2)
  {
    unint64_t v67 = v66;
    long long v66 = v62;
    float v68 = (*(float (**)(uint64_t))(*(void *)v67[1] + 24))(v67[1]);
    if (v68 >= (*(float (**)(void))(*(void *)*v67 + 24))()) {
      goto LABEL_100;
    }
    unint64_t v69 = 0;
    char v70 = (unsigned int *)*v66;
    uint64_t *v66 = 0;
    uint64_t v71 = v65;
    while (2)
    {
      uint64_t v72 = (unsigned int **)((char *)a1 + v71);
      uint64_t v73 = *(unsigned int **)((char *)a1 + v71);
      void *v72 = 0;
      v72[1] = v73;
      if (!v69)
      {
LABEL_90:
        if (!v71) {
          break;
        }
        goto LABEL_93;
      }
      int v74 = atomic_load(v69 + 2);
      if (v74 == 1)
      {
        (*(void (**)(unsigned int *))(*(void *)v69 + 248))(v69);
        goto LABEL_90;
      }
      atomic_fetch_add((atomic_uint *volatile)v69 + 2, 0xFFFFFFFF);
      if (v71)
      {
LABEL_93:
        unsigned int v75 = (unsigned int **)((char *)a1 + v71);
        char v76 = (*(float (**)(unsigned int *))(*(void *)v70 + 24))(v70);
        if (v76 >= (*(float (**)(void))(*(void *)*(v75 - 1) + 24))(*(v75 - 1))) {
          goto LABEL_96;
        }
        unint64_t v69 = *v72;
        v71 -= 8;
        continue;
      }
      break;
    }
    unsigned int v75 = (unsigned int **)a1;
LABEL_96:
    float v77 = *v75;
    *unsigned int v75 = v70;
    if (v77)
    {
      uint64_t v78 = atomic_load(v77 + 2);
      if (v78 == 1) {
        (*(void (**)(unsigned int *))(*(void *)v77 + 248))(v77);
      }
      else {
        atomic_fetch_add((atomic_uint *volatile)v77 + 2, 0xFFFFFFFF);
      }
    }
LABEL_100:
    uint64_t v62 = v66 + 1;
    v65 += 8;
    if (v66 + 1 != a2) {
      continue;
    }
    break;
  }
}

void TI::CP::SearchNodeLanguageExtensions::compute_bound_on_score(TI::CP::SearchNodeLanguageExtensions *this)
{
  if (*((unsigned char *)this + 80))
  {
    uint64_t v2 = *((void *)this + 7);
    if (!v2)
    {
      double v7 = -INFINITY;
      goto LABEL_7;
    }
    double v3 = *((double *)this + 11);
    uint64_t v4 = *((void *)this + 3);
    uint64_t v5 = *(void *)(*((void *)this + 8) + 8 * v2 - 8);
    (*(void (**)(uint64_t))(*(void *)v5 + 24))(v5);
  }
  else
  {
    double v3 = *((double *)this + 11);
    uint64_t v4 = *((void *)this + 3);
    float v6 = 1.0
       - (*(float (**)(void))(**(void **)(*((void *)this + 4) + 64) + 80))(*(void *)(*((void *)this + 4) + 64));
  }
  double v7 = v3 + *(double *)(v4 + 440) * logf(v6);
LABEL_7:
  *((double *)this + 12) = v7;
}