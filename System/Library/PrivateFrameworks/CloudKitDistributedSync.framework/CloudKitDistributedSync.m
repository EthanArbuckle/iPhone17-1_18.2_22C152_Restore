uint64_t sub_1DD238A00()
{
  uint64_t vars8;

  dword_1EB215150 = 0;
  qword_1EB215160 = 0;
  unk_1EB215168 = 0;
  qword_1EB215158 = 0;
  __cxa_atexit((void (*)(void *))sub_1DD2FB7D8, &dword_1EB215150, &dword_1DD237000);
  sub_1DD238AC8((uint64_t)&unk_1EB215190, 1, "", 0);
  __cxa_atexit((void (*)(void *))sub_1DD2FB7D8, &unk_1EB215190, &dword_1DD237000);
  sub_1DD238AC8((uint64_t)&unk_1EB215170, 2, "", 0);
  return __cxa_atexit((void (*)(void *))sub_1DD2FB7D8, &unk_1EB215170, &dword_1DD237000);
}

uint64_t sub_1DD238AC8(uint64_t a1, int a2, void *__src, size_t __len)
{
  *(_DWORD *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  uint64_t v5 = a1 + 8;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (a2)
  {
    if (__src)
    {
      sub_1DD251BA8(&__dst, __src, __len);
      if (*(char *)(a1 + 31) < 0) {
        operator delete(*(void **)v5);
      }
    }
    else
    {
      long long __dst = 0uLL;
      uint64_t v8 = 0;
    }
    *(_OWORD *)uint64_t v5 = __dst;
    *(void *)(v5 + 16) = v8;
  }
  return a1;
}

void sub_1DD238B50(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD238B6C()
{
  __cxa_atexit(MEMORY[0x1E4FBA268], &unk_1EAB1EBB8, &dword_1DD237000);
  qword_1EB215148 = 0;
  qword_1EB215140 = 0;
  qword_1EB215138 = (uint64_t)&qword_1EB215140;
  return __cxa_atexit((void (*)(void *))sub_1DD287094, &qword_1EB215138, &dword_1DD237000);
}

uint64_t sub_1DD238BEC(unsigned __int8 *a1, char *__dst, int a3, int a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (!a1 || a4 < 0) {
    return v4;
  }
  if (!a4)
  {
    if (a3 == 1)
    {
      if (*a1) {
        return 0xFFFFFFFFLL;
      }
      else {
        return 0;
      }
    }
    return v4;
  }
  if (!a3) {
    return v4;
  }
  v6 = (unsigned __int16 *)&a1[a3];
  v7 = &__dst[a4];
  unint64_t v8 = (unint64_t)v6 - 15;
  v9 = v7 - 12;
  v10 = v7 - 7;
  v11 = a1;
  v12 = __dst;
  while (1)
  {
    while (1)
    {
      v14 = v11 + 1;
      unint64_t v13 = *v11;
      size_t v15 = v13 >> 4;
      if ((v13 >> 4) == 15) {
        break;
      }
      if (v14 >= (_OWORD *)v6 - 1 || v12 > v7 - 32)
      {
        ++v11;
        goto LABEL_13;
      }
      *(_OWORD *)v12 = *v14;
      v20 = &v12[v15];
      unint64_t v28 = v13 & 0xF;
      v11 = (unsigned __int8 *)v14 + v15 + 2;
      unint64_t v25 = *(unsigned __int16 *)((char *)v14 + v15);
      unint64_t v27 = (unint64_t)&v20[-v25];
      if (v28 == 15 || v25 < 8 || v27 < (unint64_t)__dst)
      {
        v24 = v11;
        goto LABEL_29;
      }
      *(void *)v20 = *(void *)v27;
      *((void *)v20 + 1) = *(void *)(v27 + 8);
      *((_WORD *)v20 + 8) = *(_WORD *)(v27 + 16);
      v12 = &v20[v28 + 4];
    }
    if ((unint64_t)v14 >= v8)
    {
      LODWORD(v11) = v11 + 1;
      return (~v11 + a1);
    }
    LODWORD(v16) = 0;
    uint64_t v17 = (uint64_t)(v11 + 2);
    ++v11;
    do
    {
      int v19 = *v11++;
      int v18 = v19;
      uint64_t v16 = (v16 + v19);
      ++v17;
    }
    while ((unint64_t)v11 < v8 && v18 == 255);
    size_t v15 = v16 + 15;
    if (__CFADD__(v12, v15) || v15 > -v17) {
      return (~v11 + a1);
    }
LABEL_13:
    v20 = &v12[v15];
    v21 = (unsigned __int16 *)&v11[v15];
    if (&v12[v15] > v9 || v21 > v6 - 4) {
      break;
    }
    do
    {
      uint64_t v23 = *(void *)v11;
      v11 += 8;
      *(void *)v12 = v23;
      v12 += 8;
    }
    while (v12 < v20);
    unsigned int v26 = *v21;
    v24 = (unsigned __int8 *)(v21 + 1);
    unint64_t v25 = v26;
    unint64_t v27 = (unint64_t)&v20[-v26];
    unint64_t v28 = v13 & 0xF;
LABEL_29:
    if (v28 == 15)
    {
      LODWORD(v31) = 0;
      while (1)
      {
        v11 = v24 + 1;
        if (v24 + 1 >= (unsigned __int8 *)v6 - 4) {
          return (~v11 + a1);
        }
        int v32 = *v24;
        uint64_t v31 = (v31 + v32);
        ++v24;
        if (v32 != 255)
        {
          unint64_t v28 = v31 + 15;
          if (__CFADD__(v20, v28)) {
            return (~v11 + a1);
          }
          goto LABEL_37;
        }
      }
    }
    v11 = v24;
LABEL_37:
    if (v27 < (unint64_t)__dst) {
      return (~v11 + a1);
    }
    if (v25 <= 7)
    {
      *(_DWORD *)v20 = 0;
      char *v20 = *(unsigned char *)v27;
      v20[1] = *(unsigned char *)(v27 + 1);
      v20[2] = *(unsigned char *)(v27 + 2);
      v20[3] = *(unsigned char *)(v27 + 3);
      v39 = (_DWORD *)(v27 + dword_1DD31F154[v25]);
      *((_DWORD *)v20 + 1) = *v39;
      v33 = (char *)v39 - dword_1DD31F174[v25];
    }
    else
    {
      uint64_t v34 = *(void *)v27;
      v33 = (char *)(v27 + 8);
      *(void *)v20 = v34;
    }
    v12 = &v20[v28 + 4];
    v35 = v20 + 8;
    if (v12 > v9)
    {
      if (v12 > v7 - 5) {
        return (~v11 + a1);
      }
      if (v35 < v10)
      {
        v40 = v20 + 8;
        v41 = (uint64_t *)v33;
        do
        {
          uint64_t v42 = *v41++;
          *(void *)v40 = v42;
          v40 += 8;
        }
        while (v40 < v10);
        v33 += v10 - v35;
        v35 = v7 - 7;
      }
      while (v35 < v12)
      {
        char v43 = *v33++;
        *v35++ = v43;
      }
    }
    else
    {
      *(void *)v35 = *(void *)v33;
      if (v28 >= 0xD)
      {
        v36 = v20 + 16;
        v37 = (uint64_t *)(v33 + 8);
        do
        {
          uint64_t v38 = *v37++;
          *(void *)v36 = v38;
          v36 += 8;
        }
        while (v36 < v12);
      }
    }
  }
  if (v21 == v6 && v20 <= v7)
  {
    memmove(v12, v11, v15);
    return (v20 - __dst);
  }
  return (~v11 + a1);
}

void *sub_1DD238ED0(void *a1, char *a2)
{
  v3 = (char *)a1 + *(void *)(*a1 - 24);
  int v4 = *a2;
  if (*((_DWORD *)v3 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    uint64_t v5 = std::locale::use_facet(&v8, MEMORY[0x1E4FBA258]);
    int v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 32);
    std::locale::~locale(&v8);
    *((_DWORD *)v3 + 36) = v6;
  }
  *((_DWORD *)v3 + 36) = v4;
  return a1;
}

void sub_1DD238F84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
}

void *sub_1DD238F98(void *result, uint64_t a2)
{
  *result = *(void *)(a2 + 8);
  return result;
}

uint64_t sub_1DD238FA4(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)a1 + 16);
  *(void *)a1 = *(void *)(*(void *)a1 + 8);
  return v1;
}

void *sub_1DD238FC4(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *result = &unk_1F387B0C0;
  result[1] = a2;
  result[2] = a3;
  result[3] = 0;
  if (a4) {
    uint64_t v4 = a4;
  }
  else {
    uint64_t v4 = a3;
  }
  result[4] = v4;
  return result;
}

BOOL sub_1DD238FF4(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v3 = a1[3];
  unint64_t v4 = a1[2] - v3;
  if (a1[4] < v4) {
    unint64_t v4 = a1[4];
  }
  if (v4)
  {
    *a2 = a1[1] + v3;
    a1[3] = v4 + v3;
    int v5 = v4;
  }
  else
  {
    int v5 = 0;
  }
  BOOL result = v4 != 0;
  *a3 = v5;
  return result;
}

uint64_t sub_1DD23903C(uint64_t result, unsigned int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    if (*(void *)(result + 32) < (unint64_t)a2 || (unint64_t v2 = *(void *)(result + 24), v2 < a2))
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Can't backup that much!");
      __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
    }
    *(void *)(result + 24) = v2 - a2;
  }
  return result;
}

void sub_1DD2390B4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1DD2390C8(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v2 = *(void *)(a1 + 16);
  unint64_t v3 = *(void *)(a1 + 24) + a2;
  BOOL v4 = v3 >= v2;
  BOOL v5 = v3 == v2;
  if (v3 >= v2) {
    unint64_t v3 = *(void *)(a1 + 16);
  }
  *(void *)(a1 + 24) = v3;
  return v5 || !v4;
}

uint64_t sub_1DD2390F4(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_1DD2390FC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)a2 + 16);
  *(void *)a2 = *(void *)(*(void *)a2 + 8);
  *(void *)(result + 24) = v2;
  return result;
}

uint64_t sub_1DD239110()
{
  sub_1DD239280((uint64_t)v2);
  sub_1DD239B24(v2, (uint64_t)"SeekableArrayInputStream ", 25);
  v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  std::ostream::operator<<();
  std::stringbuf::str();
  v2[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v2 + *(void *)(v2[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v2[1] = MEMORY[0x1E4FBA470] + 16;
  if (v3 < 0) {
    operator delete((void *)v2[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v4);
}

void sub_1DD23926C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD239280(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  BOOL v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1DD2393F0(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x1E01B1EC0](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD239418(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1E01B1EC0](a1 + 112);
  return a1;
}

void *sub_1DD23951C(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  *a1 = &unk_1F387AE28;
  a1[1] = a5;
  a1[2] = a2;
  a1[3] = a3;
  unint64_t v8 = 0x40000;
  if (a6) {
    unint64_t v8 = a6;
  }
  if (v8 >= a4) {
    unint64_t v8 = a4;
  }
  a1[4] = a4;
  a1[5] = v8;
  a1[6] = 0;
  v9 = a1 + 6;
  a1[7] = 0;
  v10 = operator new(0x28uLL);
  sub_1DD26FA14(v10, a5);
  uint64_t v11 = *v9;
  uint64_t *v9 = (uint64_t)v10;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  a1[8] = 0;
  return a1;
}

void sub_1DD2395DC(_Unwind_Exception *a1)
{
  operator delete(v1);
  uint64_t v4 = *v2;
  *uint64_t v2 = 0;
  if (v4) {
    sub_1DD31CA20(v4);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD239610(void *a1)
{
  *a1 = &unk_1F387AE28;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD239680(void *__p)
{
  *__p = &unk_1F387AE28;
  uint64_t v2 = __p[6];
  __p[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

BOOL sub_1DD239700(uint64_t a1, unint64_t *a2, _DWORD *a3)
{
  unint64_t v6 = *(void *)(a1 + 64);
  if (v6)
  {
    unint64_t v7 = *(void *)(*(void *)(a1 + 48) + 16) + *(void *)(*(void *)(a1 + 48) + 24) - v6;
LABEL_8:
    *a2 = v7;
    goto LABEL_9;
  }
  unint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 56);
  if (v8 >= *(void *)(a1 + 32) - v10) {
    unint64_t v6 = *(void *)(a1 + 32) - v10;
  }
  else {
    unint64_t v6 = *(void *)(a1 + 40);
  }
  sub_1DD26F9D0(v9, v6);
  if (v6)
  {
    (*(void (**)(void, void, unint64_t, void))(**(void **)(a1 + 16) + 32))(*(void *)(a1 + 16), *(void *)(*(void *)(a1 + 48) + 16), v6, *(void *)(a1 + 56) + *(void *)(a1 + 24));
    unint64_t v7 = *(void *)(*(void *)(a1 + 48) + 16);
    goto LABEL_8;
  }
LABEL_9:
  *(void *)(a1 + 56) += v6;
  *(void *)(a1 + 64) = 0;
  *a3 = v6;
  return v6 != 0;
}

void *sub_1DD2397C8(void *result, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "can't backup negative distances");
    goto LABEL_10;
  }
  if (result[8])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "can't backup unless we just called Next");
LABEL_10:
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  if (result[5] < (unint64_t)a2 || (v2 = result[7], v3 = v2 >= a2, unint64_t v4 = v2 - a2, !v3))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "can't backup that far");
    goto LABEL_10;
  }
  result[7] = v4;
  result[8] = a2;
  return result;
}

void sub_1DD239880(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1DD23989C(void *a1, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  unint64_t v2 = a1[7] + a2;
  unint64_t v3 = a1[4];
  BOOL v4 = v3 >= v2;
  BOOL v5 = v3 == v2;
  if (v3 < v2) {
    unint64_t v2 = a1[4];
  }
  a1[7] = v2;
  a1[8] = 0;
  return !v5 && v4;
}

uint64_t sub_1DD2398C8(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void *sub_1DD2398D0(void *result, uint64_t a2)
{
  unint64_t v2 = *(void *)(*(void *)a2 + 16);
  *(void *)a2 = *(void *)(*(void *)a2 + 8);
  result[7] = v2;
  unint64_t v3 = result[4];
  if (v2 > v3)
  {
    result[7] = v3;
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "seek too far");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  result[8] = 0;
  return result;
}

void sub_1DD239948(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23995C(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 40))(*(void *)(a1 + 16));
  int v3 = *(char *)(v2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = v2;
  }
  else {
    uint64_t v4 = *(void *)v2;
  }
  if (v3 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(v2 + 23);
  }
  else {
    uint64_t v5 = *(void *)(v2 + 8);
  }
  unint64_t v6 = sub_1DD239B24(v9, v4, v5);
  sub_1DD239B24(v6, (uint64_t)" from ", 6);
  unint64_t v7 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v7, (uint64_t)" for ", 5);
  std::ostream::operator<<();
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD239AFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD239B10(void *a1)
{
}

void *sub_1DD239B24(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1E01B1D50](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      char v10 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!sub_1DD239CC8(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x1E01B1D60](v13);
  return a1;
}

void sub_1DD239C60(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x1E01B1D60](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1DD239C40);
}

void sub_1DD239CB4(_Unwind_Exception *a1)
{
}

uint64_t sub_1DD239CC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      sub_1DD239E50(__p, v12, __c);
      unint64_t v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_1DD239E34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD239E50(void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DD239EFC();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

void sub_1DD239EFC()
{
}

void sub_1DD239F14(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1DD239F70(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6CBA920, MEMORY[0x1E4FBA1C8]);
}

void sub_1DD239F5C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1DD239F70(std::logic_error *a1, const char *a2)
{
  BOOL result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void *sub_1DD239FA4(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  *a1 = &unk_1F387A5B0;
  a1[1] = a3;
  a1[2] = 0;
  a1[3] = a5;
  size_t v8 = operator new(0x28uLL);
  sub_1DD26FA14(v8, a2);
  uint64_t v9 = a1[2];
  a1[2] = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    size_t v8 = (void *)a1[2];
  }
  sub_1DD26FA18((uint64_t)v8, a4);
  return a1;
}

void sub_1DD23A050(_Unwind_Exception *a1)
{
  operator delete(v2);
  uint64_t v4 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD23A0A0(void *a1)
{
  *a1 = &unk_1F387A5B0;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void *sub_1DD23A110(void *a1)
{
  *a1 = &unk_1F387A5B0;
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD23A180(void *__p)
{
  *__p = &unk_1F387A5B0;
  uint64_t v2 = __p[2];
  __p[2] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

uint64_t sub_1DD23A200(uint64_t a1, void *a2, _DWORD *a3)
{
  unint64_t v5 = 0;
  uint64_t v8 = a1 + 16;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v8 + 8);
  *a3 = v7;
  uint64_t v9 = *(void *)(v6 + 24);
  unint64_t v10 = v9 + v7;
  do
    v5 += *(void *)(v6 + 32);
  while (v5 < v10);
  sub_1DD26FA18(v6, v5);
  sub_1DD26F9D0(*(void *)(a1 + 16), v10);
  *a2 = *(void *)(*(void *)(a1 + 16) + 16) + v9;
  return 1;
}

void sub_1DD23A270(uint64_t a1, unsigned int a2)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    unint64_t v3 = *(void *)(v2 + 24);
    if (v3 < a2)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Can't backup that much!");
      __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
    }
    unint64_t v4 = v3 - a2;
    sub_1DD26F9D0(v2, v4);
  }
}

void sub_1DD23A2FC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23A310(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24);
}

void sub_1DD23A31C()
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1DD26D80C(exception, "WriteAliasedRaw is not supported.");
  __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
}

void sub_1DD23A364(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23A378()
{
  return 0;
}

uint64_t sub_1DD23A380()
{
  sub_1DD239280((uint64_t)v2);
  sub_1DD239B24(v2, (uint64_t)"BufferedOutputStream ", 21);
  v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  std::ostream::operator<<();
  std::stringbuf::str();
  v2[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v2 + *(void *)(v2[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v2[1] = MEMORY[0x1E4FBA470] + 16;
  if (v3 < 0) {
    operator delete((void *)v2[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v4);
}

void sub_1DD23A4E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23A4F8(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24);
}

uint64_t sub_1DD23A504(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(v2 + 24);
  (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), *(void *)(v2 + 16), v3);
  sub_1DD26F9D0(*(void *)(a1 + 16), 0);
  return v3;
}

char *sub_1DD23A564(char *result, uint64_t a2, unint64_t a3)
{
  if (a3)
  {
    unint64_t v3 = a3;
    unint64_t v5 = result;
    uint64_t v6 = 0;
    uint64_t v7 = (int *)(result + 20);
    uint64_t v8 = result + 8;
    int v9 = *((_DWORD *)result + 4);
    do
    {
      int v10 = *v7;
      if (v9 == *v7)
      {
        if (((*(uint64_t (**)(void, char *, int *))(*(void *)*v5 + 16))(*v5, v8, v7) & 1) == 0)
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "Failed to allocate buffer.");
          __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
        }
        int v9 = 0;
        *((_DWORD *)v5 + 4) = 0;
        int v10 = *((_DWORD *)v5 + 5);
      }
      int v11 = v10 - v9;
      if (v3 >= v11) {
        size_t v12 = v11;
      }
      else {
        size_t v12 = v3;
      }
      BOOL result = (char *)memcpy((void *)(v5[1] + v9), (const void *)(a2 + v6), v12);
      int v9 = *((_DWORD *)v5 + 4) + v12;
      *((_DWORD *)v5 + 4) = v9;
      v6 += v12;
      v3 -= v12;
    }
    while (v3);
  }
  return result;
}

void sub_1DD23A678(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23A68C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)a1 + 64))();
}

uint64_t sub_1DD23A6B4(void *a1)
{
  (*(void (**)(void, void))(*(void *)*a1 + 24))(*a1, (*((_DWORD *)a1 + 5) - *((_DWORD *)a1 + 4)));
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)*a1 + 72);
  return v2();
}

uint64_t sub_1DD23A73C(int *a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)a1 + 64))(*(void *)a1);
  uint64_t v5 = a1[4];
  if ((*(unsigned int (**)(void))(**(void **)a1 + 80))()) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v4);
  }
  else {
    uint64_t v5 = v4 + v5 - a1[5];
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16);
  return v6(a2, v5);
}

uint64_t sub_1DD23A840()
{
  return 0;
}

void sub_1DD23A848()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23B5D0(qword_1EAB1F588);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F588);
}

void sub_1DD23A8B4()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23BC50(qword_1EAB1F448);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F448);
}

void sub_1DD23A920()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23C25C(qword_1EAB1F478);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F478);
}

void sub_1DD23A98C()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23CDA0((uint64_t)&unk_1EAB1F3A0);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F3A0);
}

void sub_1DD23A9F8()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23D6F8(qword_1EAB1F510);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F510);
}

void sub_1DD23AA64()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23E00C(qword_1EAB1F360);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F360);
}

void sub_1DD23AAD0()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23E5C4((uint64_t)&unk_1EAB1F618);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F618);
}

void sub_1DD23AB3C()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23EEAC(qword_1EAB1F380);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F380);
}

void sub_1DD23ABA8()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD23F370(qword_1EAB1F658);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F658);
}

void sub_1DD23AC14()
{
  qword_1EAB1F3E8 = (uint64_t)qword_1EAB1F588;
  unk_1EAB1F3F0 = qword_1EAB1F448;
  qword_1EAB1F3F8 = (uint64_t)qword_1EAB1F478;
  unk_1EAB1F400 = &unk_1EAB1F3A0;
  qword_1EAB1F408 = (uint64_t)qword_1EAB1F510;
  unk_1EAB1F410 = qword_1EAB1F360;
  qword_1EAB1F418 = (uint64_t)qword_1EAB1F380;
  unk_1EAB1F420 = &unk_1EAB1F618;
  qword_1EAB1F428 = (uint64_t)qword_1EAB1F658;
}

void sub_1DD23ACD0()
{
  qword_1EAB1F700 = (uint64_t)&unk_1EAB1F3D0;
}

void sub_1DD23AD3C()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2418D8((uint64_t)&unk_1EAB1F708);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F708);
}

void sub_1DD23ADA8()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD241F1C((uint64_t)&unk_1EAB1F738);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F738);
}

void sub_1DD23AE14()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD242920((uint64_t)&unk_1EAB1F770);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F770);
}

void sub_1DD23AE80()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD242F18(qword_1EAB1F110);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F110);
}

void sub_1DD23AEEC()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD243758((uint64_t)&unk_1EAB1F338);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F338);
}

void sub_1DD23AF58()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD243FAC((uint64_t)&unk_1EAB1F688);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F688);
}

void sub_1DD23AFC4()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2447D0((uint64_t)&unk_1EAB1F2A8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F2A8);
}

void sub_1DD23B030()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD24556C(qword_1EAB1F280);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F280);
}

void sub_1DD23B09C()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD245C2C((uint64_t)&unk_1EAB1EFF8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1EFF8);
}

void sub_1DD23B108()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD246D44((uint64_t)&unk_1EAB1F5B8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F5B8);
}

void sub_1DD23B174()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2478E4(qword_1EAB1F4E8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F4E8);
}

void sub_1DD23B1E0()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD247E04((uint64_t)&unk_1EAB1F4B8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F4B8);
}

void sub_1DD23B24C()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2483F8((uint64_t)&unk_1EAB1F188);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F188);
}

void sub_1DD23B2B8()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2489F0((uint64_t)&unk_1EAB1F138);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F138);
}

void sub_1DD23B324()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD2494DC(qword_1EAB1F310);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)qword_1EAB1F310);
}

void sub_1DD23B390()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD249C74((uint64_t)&unk_1EAB1F540);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F540);
}

void sub_1DD23B3FC()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD24A720((uint64_t)&unk_1EAB1F1B8);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F1B8);
}

void sub_1DD23B468()
{
  qword_1EAB1F0E0 = (uint64_t)&unk_1EAB1F1B8;
}

void sub_1DD23B4D4()
{
  sub_1DD2FABDC(3006001, 3006001, "/Library/Caches/com.apple.xbs/Binaries/CloudKit/install/TempContent/Objects/CloudKit.build/ORC.build/DerivedSources/cmake/c++/src/orc_proto.pb.cc");
  sub_1DD24CBA0((uint64_t)&unk_1EAB1F220);
  sub_1DD2FB4E0((uint64_t)sub_1DD2F56E0, (uint64_t)&unk_1EAB1F220);
}

void sub_1DD23B540()
{
  qword_1EAB1F7B8 = (uint64_t)&unk_1EAB1F220;
  unk_1EAB1F7C0 = &unk_1EAB1F068;
}

BOOL sub_1DD23B5B4(unsigned int a1)
{
  return a1 < 0xB || a1 - 100 < 2;
}

void *sub_1DD23B5D0(void *a1)
{
  *a1 = &unk_1F387C438;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC208, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC208);
  }
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

void sub_1DD23B644(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23B658(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C438;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void sub_1DD23B6D8(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23B6EC(void *a1)
{
  *a1 = &unk_1F387C438;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23B730(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C438;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23B784(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 7) != 0)
  {
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23B7AC(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v23 = (uint64_t *)(a1 + 8);
  long long v24 = 0uLL;
  uint64_t v25 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v25 = *(void *)(v5 + 16);
    long long v24 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v22, (uint64_t)&v24);
  sub_1DD2F9178((uint64_t)v21, (uint64_t)v22, 0);
  do
  {
    while (1)
    {
      uint64_t v7 = *a2;
      if (*a2 >= a2[1])
      {
        uint64_t v8 = 0;
LABEL_9:
        unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
        unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_30;
        }
        goto LABEL_10;
      }
      uint64_t v8 = *v7;
      if (*v7 < 1) {
        goto LABEL_9;
      }
      *a2 = v7 + 1;
      unint64_t v9 = v8 | 0x100000000;
      if ((v9 & 0x100000000) == 0) {
        goto LABEL_30;
      }
LABEL_10:
      unsigned int v11 = v9 >> 3;
      if (v9 >> 3 != 3) {
        break;
      }
      if (v9 != 24) {
        goto LABEL_30;
      }
      *(_DWORD *)(a1 + 16) |= 4u;
      unint64_t v13 = *a2;
      if (*a2 < a2[1] && (*v13 & 0x80000000) == 0)
      {
        unint64_t v14 = *v13;
        uint64_t v15 = (unint64_t *)(a1 + 40);
        goto LABEL_28;
      }
      unint64_t v14 = sub_1DD2F8A78((uint64_t)a2);
      if ((v17 & 1) == 0) {
        goto LABEL_41;
      }
      uint64_t v15 = (unint64_t *)(a1 + 40);
LABEL_29:
      *uint64_t v15 = -(uint64_t)(v14 & 1) ^ (v14 >> 1);
    }
    if (v11 == 2)
    {
      if (v9 != 16) {
        goto LABEL_30;
      }
      *(_DWORD *)(a1 + 16) |= 2u;
      unint64_t v13 = *a2;
      if (*a2 < a2[1] && (*v13 & 0x80000000) == 0)
      {
        unint64_t v14 = *v13;
        uint64_t v15 = (unint64_t *)(a1 + 32);
        goto LABEL_28;
      }
      unint64_t v14 = sub_1DD2F8A78((uint64_t)a2);
      if ((v18 & 1) == 0) {
        break;
      }
      uint64_t v15 = (unint64_t *)(a1 + 32);
      goto LABEL_29;
    }
    if (v11 == 1 && v9 == 8)
    {
      *(_DWORD *)(a1 + 16) |= 1u;
      unint64_t v13 = *a2;
      if (*a2 < a2[1] && (*v13 & 0x80000000) == 0)
      {
        unint64_t v14 = *v13;
        uint64_t v15 = (unint64_t *)(a1 + 24);
LABEL_28:
        *a2 = v13 + 1;
        goto LABEL_29;
      }
      unint64_t v14 = sub_1DD2F8A78((uint64_t)a2);
      if ((v16 & 1) == 0) {
        break;
      }
      uint64_t v15 = (unint64_t *)(a1 + 24);
      goto LABEL_29;
    }
LABEL_30:
    if (!v9)
    {
      uint64_t v19 = 1;
      goto LABEL_40;
    }
  }
  while (sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v21));
LABEL_41:
  uint64_t v19 = 0;
LABEL_40:
  sub_1DD2F92B4(v21);
  sub_1DD24F874(&v23);
  return v19;
}

void sub_1DD23B9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23BA0C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC328(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC328(2, *(void *)(a1 + 32), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC328(3, *(void *)(a1 + 40), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23BAE0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_12;
  }
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    v3 += ((9 * (__clz((2 * *(void *)(a1 + 32)) ^ (*(uint64_t *)(a1 + 32) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v4 & 4) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  v3 += ((9 * (__clz((2 * *(void *)(a1 + 24)) ^ (*(uint64_t *)(a1 + 24) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v4 & 2) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if ((v4 & 4) != 0) {
LABEL_11:
  }
    v3 += ((9 * (__clz((2 * *(void *)(a1 + 40)) ^ (*(uint64_t *)(a1 + 40) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_12:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23BBB8(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      v3[1].__r_.__value_.__r.__words[0] = *(void *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0)
        {
LABEL_8:
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
          return result;
        }
LABEL_7:
        v3[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
        goto LABEL_8;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    v3[1].__r_.__value_.__l.__size_ = *(void *)(a2 + 32);
    if ((v5 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_1DD23BC38()
{
  return 1;
}

void *sub_1DD23BC40@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.IntegerStatistics");
}

void *sub_1DD23BC50(void *a1)
{
  *a1 = &unk_1F387C078;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC178, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC178);
  }
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

void sub_1DD23BCC4(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23BCD8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C078;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void sub_1DD23BD58(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23BD6C(void *a1)
{
  *a1 = &unk_1F387C078;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23BDB0(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C078;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23BE04(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 7) != 0)
  {
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

BOOL sub_1DD23BE2C(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v23 = (uint64_t *)(a1 + 8);
  long long v24 = 0uLL;
  uint64_t v25 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v25 = *(void *)(v5 + 16);
    long long v24 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v22, (uint64_t)&v24);
  sub_1DD2F9178((uint64_t)v21, (uint64_t)v22, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v7 = *a2;
          if (*a2 >= a2[1]) {
            break;
          }
          uint64_t v8 = *v7;
          if (*v7 < 1) {
            goto LABEL_9;
          }
          *a2 = v7 + 1;
          unint64_t v9 = v8 | 0x100000000;
          if ((v9 & 0x100000000) != 0) {
            goto LABEL_10;
          }
LABEL_28:
          BOOL v19 = v9 == 0;
          if (!v9 || !sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v21)) {
            goto LABEL_38;
          }
        }
        uint64_t v8 = 0;
LABEL_9:
        unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
        unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_28;
        }
LABEL_10:
        unsigned int v11 = v9 >> 3;
        if (v9 >> 3 != 3) {
          break;
        }
        if (v9 != 25) {
          goto LABEL_28;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v26 = 0;
        uint64_t v15 = *a2;
        if ((int)(*((_DWORD *)a2 + 2) - *a2) < 8)
        {
          if (!sub_1DD2F89E4((uint64_t)a2, &v26)) {
            goto LABEL_37;
          }
          uint64_t v16 = v26;
        }
        else
        {
          uint64_t v16 = *(void *)v15;
          *a2 = v15 + 8;
        }
        *(void *)(a1 + 40) = v16;
      }
      if (v11 == 2) {
        break;
      }
      if (v11 != 1 || v9 != 9) {
        goto LABEL_28;
      }
      *(_DWORD *)(a1 + 16) |= 1u;
      uint64_t v26 = 0;
      unint64_t v13 = *a2;
      if ((int)(*((_DWORD *)a2 + 2) - *a2) < 8)
      {
        if (!sub_1DD2F89E4((uint64_t)a2, &v26)) {
          goto LABEL_37;
        }
        uint64_t v14 = v26;
      }
      else
      {
        uint64_t v14 = *(void *)v13;
        *a2 = v13 + 8;
      }
      *(void *)(a1 + 24) = v14;
    }
    if (v9 != 17) {
      goto LABEL_28;
    }
    *(_DWORD *)(a1 + 16) |= 2u;
    uint64_t v26 = 0;
    char v17 = *a2;
    if ((int)(*((_DWORD *)a2 + 2) - *a2) >= 8)
    {
      uint64_t v18 = *(void *)v17;
      *a2 = v17 + 8;
      goto LABEL_27;
    }
    if (!sub_1DD2F89E4((uint64_t)a2, &v26)) {
      break;
    }
    uint64_t v18 = v26;
LABEL_27:
    *(void *)(a1 + 32) = v18;
  }
LABEL_37:
  BOOL v19 = 0;
LABEL_38:
  sub_1DD2F92B4(v21);
  sub_1DD24F874(&v23);
  return v19;
}

void sub_1DD23C05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23C084(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC500(1, a2, *(double *)(a1 + 24));
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC500(2, a2, *(double *)(a1 + 32));
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC500(3, a2, *(double *)(a1 + 40));
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23C158(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  uint64_t v5 = v3 + 9;
  if ((v4 & 1) == 0) {
    uint64_t v5 = v3;
  }
  if ((v4 & 2) != 0) {
    v5 += 9;
  }
  if ((v4 & 4) != 0) {
    v5 += 9;
  }
  if ((v4 & 7) != 0) {
    uint64_t v3 = v5;
  }
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23C1C4(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      v3[1].__r_.__value_.__r.__words[0] = *(void *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0)
        {
LABEL_8:
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
          return result;
        }
LABEL_7:
        v3[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
        goto LABEL_8;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    v3[1].__r_.__value_.__l.__size_ = *(void *)(a2 + 32);
    if ((v5 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_1DD23C244()
{
  return 1;
}

void *sub_1DD23C24C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.DoubleStatistics");
}

void *sub_1DD23C25C(void *a1)
{
  *a1 = &unk_1F387C118;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC190, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC190);
  }
  a1[3] = &qword_1EAB1F7D8;
  a1[4] = &qword_1EAB1F7D8;
  a1[5] = &qword_1EAB1F7D8;
  a1[6] = &qword_1EAB1F7D8;
  a1[7] = 0;
  return a1;
}

void sub_1DD23C2DC(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23C2F0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C118;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(void *)(a1 + 24) = &qword_1EAB1F7D8;
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5)
  {
    long long v6 = *(uint64_t **)(a2 + 24);
    if (v6 != &qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 24), (uint64_t)v6);
      int v5 = *(_DWORD *)(a2 + 16);
    }
  }
  *(void *)(a1 + 32) = &qword_1EAB1F7D8;
  if ((v5 & 2) != 0)
  {
    uint64_t v7 = *(uint64_t **)(a2 + 32);
    if (v7 != &qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 32), (uint64_t)v7);
      int v5 = *(_DWORD *)(a2 + 16);
    }
  }
  *(void *)(a1 + 40) = &qword_1EAB1F7D8;
  if ((v5 & 4) != 0)
  {
    uint64_t v8 = *(uint64_t **)(a2 + 40);
    if (v8 != &qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 40), (uint64_t)v8);
      int v5 = *(_DWORD *)(a2 + 16);
    }
  }
  *(void *)(a1 + 48) = &qword_1EAB1F7D8;
  if ((v5 & 8) != 0)
  {
    unint64_t v9 = *(uint64_t **)(a2 + 48);
    if (v9 != &qword_1EAB1F7D8) {
      sub_1DD24F908((void *)(a1 + 48), (uint64_t)v9);
    }
  }
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  return a1;
}

void sub_1DD23C3F0(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void sub_1DD23C404(void *a1)
{
  uint64_t v2 = a1[3];
  if ((uint64_t *)v2 != &qword_1EAB1F7D8 && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete((void *)v2);
  }
  uint64_t v4 = a1[4];
  if ((uint64_t *)v4 != &qword_1EAB1F7D8 && v4 != 0)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete((void *)v4);
  }
  uint64_t v6 = a1[5];
  if ((uint64_t *)v6 != &qword_1EAB1F7D8 && v6 != 0)
  {
    if (*(char *)(v6 + 23) < 0) {
      operator delete(*(void **)v6);
    }
    operator delete((void *)v6);
  }
  uint64_t v8 = a1[6];
  if ((uint64_t *)v8 != &qword_1EAB1F7D8 && v8 != 0)
  {
    if (*(char *)(v8 + 23) < 0) {
      operator delete(*(void **)v8);
    }
    operator delete((void *)v8);
  }
}

void *sub_1DD23C4F0(void *a1)
{
  *a1 = &unk_1F387C118;
  uint64_t v2 = a1 + 1;
  sub_1DD23C404(a1);
  sub_1DD24F770(v2);
  return a1;
}

void sub_1DD23C540(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C118;
  uint64_t v2 = a1 + 1;
  sub_1DD23C404(a1);
  sub_1DD24F770(v2);
  operator delete(a1);
}

void sub_1DD23C5A0(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 0xF) == 0) {
    goto LABEL_22;
  }
  if ((v1 & 1) == 0)
  {
    if ((v1 & 2) == 0) {
      goto LABEL_4;
    }
LABEL_11:
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(char *)(v3 + 23) < 0)
    {
      **(unsigned char **)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
      if ((v1 & 4) != 0) {
        goto LABEL_15;
      }
    }
    else
    {
      *(unsigned char *)uint64_t v3 = 0;
      *(unsigned char *)(v3 + 23) = 0;
      if ((v1 & 4) != 0) {
        goto LABEL_15;
      }
    }
LABEL_5:
    if ((v1 & 8) == 0) {
      goto LABEL_22;
    }
LABEL_19:
    uint64_t v5 = *(void *)(a1 + 48);
    if (*(char *)(v5 + 23) < 0)
    {
      **(unsigned char **)uint64_t v5 = 0;
      *(void *)(v5 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v5 = 0;
      *(unsigned char *)(v5 + 23) = 0;
    }
    goto LABEL_22;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (*(char *)(v2 + 23) < 0)
  {
    **(unsigned char **)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
    if ((v1 & 2) != 0) {
      goto LABEL_11;
    }
  }
  else
  {
    *(unsigned char *)uint64_t v2 = 0;
    *(unsigned char *)(v2 + 23) = 0;
    if ((v1 & 2) != 0) {
      goto LABEL_11;
    }
  }
LABEL_4:
  if ((v1 & 4) == 0) {
    goto LABEL_5;
  }
LABEL_15:
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(char *)(v4 + 23) < 0)
  {
    **(unsigned char **)uint64_t v4 = 0;
    *(void *)(v4 + 8) = 0;
    if ((v1 & 8) == 0) {
      goto LABEL_22;
    }
    goto LABEL_19;
  }
  *(unsigned char *)uint64_t v4 = 0;
  *(unsigned char *)(v4 + 23) = 0;
  if ((v1 & 8) != 0) {
    goto LABEL_19;
  }
LABEL_22:
  char v7 = *(unsigned char *)(a1 + 8);
  uint64_t v6 = a1 + 8;
  *(void *)(v6 + 48) = 0;
  *(_DWORD *)(v6 + 8) = 0;
  if (v7) {
    sub_1DD24FC0C((unint64_t *)v6);
  }
}

uint64_t sub_1DD23C680(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  v20 = (uint64_t *)(a1 + 8);
  long long v21 = 0uLL;
  uint64_t v22 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v22 = *(void *)(v5 + 16);
    long long v21 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v19, (uint64_t)&v21);
  sub_1DD2F9178((uint64_t)v18, (uint64_t)v19, 0);
  do
  {
    while (1)
    {
      char v7 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1]) {
        break;
      }
      uint64_t v8 = 0;
LABEL_9:
      unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
      unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
      if ((v9 & 0x100000000) == 0) {
        goto LABEL_31;
      }
LABEL_10:
      switch(v9 >> 3)
      {
        case 1u:
          if (v9 != 10) {
            goto LABEL_31;
          }
          *(_DWORD *)(a1 + 16) |= 1u;
          unsigned int v11 = *(std::string **)(a1 + 24);
          if (v11 == (std::string *)&qword_1EAB1F7D8)
          {
            sub_1DD24F908((void *)(a1 + 24), (uint64_t)&qword_1EAB1F7D8);
            unsigned int v11 = *(std::string **)(a1 + 24);
          }
          goto LABEL_30;
        case 2u:
          if (v9 != 18) {
            goto LABEL_31;
          }
          *(_DWORD *)(a1 + 16) |= 2u;
          unsigned int v11 = *(std::string **)(a1 + 32);
          if (v11 == (std::string *)&qword_1EAB1F7D8)
          {
            sub_1DD24F908((void *)(a1 + 32), (uint64_t)&qword_1EAB1F7D8);
            unsigned int v11 = *(std::string **)(a1 + 32);
          }
          goto LABEL_30;
        case 3u:
          if (v9 != 24) {
            goto LABEL_31;
          }
          *(_DWORD *)(a1 + 16) |= 0x10u;
          size_t v12 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v12 < 0)
          {
            unint64_t v13 = sub_1DD2F8A78((uint64_t)a2);
            if ((v15 & 1) == 0) {
              goto LABEL_39;
            }
          }
          else
          {
            unint64_t v13 = *v12;
            *a2 = (uint64_t)(v12 + 1);
          }
          *(void *)(a1 + 56) = -(uint64_t)(v13 & 1) ^ (v13 >> 1);
          break;
        case 4u:
          if (v9 != 34) {
            goto LABEL_31;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          unsigned int v11 = *(std::string **)(a1 + 40);
          if (v11 == (std::string *)&qword_1EAB1F7D8)
          {
            sub_1DD24F908((void *)(a1 + 40), (uint64_t)&qword_1EAB1F7D8);
            unsigned int v11 = *(std::string **)(a1 + 40);
          }
          goto LABEL_30;
        case 5u:
          if (v9 != 42) {
            goto LABEL_31;
          }
          *(_DWORD *)(a1 + 16) |= 8u;
          unsigned int v11 = *(std::string **)(a1 + 48);
          if (v11 == (std::string *)&qword_1EAB1F7D8)
          {
            sub_1DD24F908((void *)(a1 + 48), (uint64_t)&qword_1EAB1F7D8);
            unsigned int v11 = *(std::string **)(a1 + 48);
          }
LABEL_30:
          BOOL v14 = sub_1DD2FCF1C(a2, v11);
          goto LABEL_33;
        default:
          goto LABEL_31;
      }
    }
    uint64_t v8 = *v7;
    if (*v7 < 1) {
      goto LABEL_9;
    }
    *a2 = (uint64_t)(v7 + 1);
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) != 0) {
      goto LABEL_10;
    }
LABEL_31:
    if (!v9)
    {
      uint64_t v16 = 1;
      goto LABEL_38;
    }
    BOOL v14 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v18);
LABEL_33:
    ;
  }
  while (v14);
LABEL_39:
  uint64_t v16 = 0;
LABEL_38:
  sub_1DD2F92B4(v18);
  sub_1DD24F874(&v20);
  return v16;
}

void sub_1DD23C944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23C980(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC85C(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 0x10) == 0) {
        goto LABEL_4;
      }
      goto LABEL_19;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC85C(2, *(void *)(a1 + 32), a2);
  if ((v4 & 0x10) == 0)
  {
LABEL_4:
    if ((v4 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_20;
  }
LABEL_19:
  sub_1DD2FC328(3, *(void *)(a1 + 56), a2);
  if ((v4 & 4) == 0)
  {
LABEL_5:
    if ((v4 & 8) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_20:
  sub_1DD2FC85C(4, *(void *)(a1 + 40), a2);
  if ((v4 & 8) != 0) {
LABEL_6:
  }
    sub_1DD2FC85C(5, *(void *)(a1 + 48), a2);
LABEL_7:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    char v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23CA84(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 0x1F) == 0) {
    goto LABEL_14;
  }
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(unsigned __int8 *)(v6 + 23);
    uint64_t v8 = *(void *)(v6 + 8);
    if ((v7 & 0x80u) == 0) {
      uint64_t v8 = v7;
    }
    v3 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 2) == 0)
    {
LABEL_10:
      if ((v4 & 4) == 0) {
        goto LABEL_11;
      }
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_10;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(unsigned __int8 *)(v9 + 23);
  uint64_t v11 = *(void *)(v9 + 8);
  if ((v10 & 0x80u) == 0) {
    uint64_t v11 = v10;
  }
  v3 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v4 & 4) == 0)
  {
LABEL_11:
    if ((v4 & 8) == 0) {
      goto LABEL_12;
    }
LABEL_24:
    uint64_t v15 = *(void *)(a1 + 48);
    uint64_t v16 = *(unsigned __int8 *)(v15 + 23);
    uint64_t v17 = *(void *)(v15 + 8);
    if ((v16 & 0x80u) == 0) {
      uint64_t v17 = v16;
    }
    v3 += v17 + ((9 * (__clz(v17 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 0x10) != 0) {
      goto LABEL_13;
    }
    goto LABEL_14;
  }
LABEL_21:
  uint64_t v12 = *(void *)(a1 + 40);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 23);
  uint64_t v14 = *(void *)(v12 + 8);
  if ((v13 & 0x80u) == 0) {
    uint64_t v14 = v13;
  }
  v3 += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v4 & 8) != 0) {
    goto LABEL_24;
  }
LABEL_12:
  if ((v4 & 0x10) != 0) {
LABEL_13:
  }
    v3 += ((9 * (__clz((2 * *(void *)(a1 + 56)) ^ (*(uint64_t *)(a1 + 56) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_14:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23CC0C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x1F) != 0)
  {
    if (v5)
    {
      BOOL result = v3 + 1;
      data = (std::string *)v3[1].__r_.__value_.__l.__data_;
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      uint64_t v7 = *(const std::string **)(a2 + 24);
      if (data != v7)
      {
        if (data == (std::string *)&qword_1EAB1F7D8)
        {
          BOOL result = (std::string *)sub_1DD24F908(result, (uint64_t)v7);
          if ((v5 & 2) == 0) {
            goto LABEL_15;
          }
LABEL_9:
          BOOL result = (std::string *)((char *)v3 + 32);
          size = (std::string *)v3[1].__r_.__value_.__l.__size_;
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= 2u;
          uint64_t v9 = *(const std::string **)(a2 + 32);
          if (size != v9)
          {
            if (size == (std::string *)&qword_1EAB1F7D8) {
              BOOL result = (std::string *)sub_1DD24F908(result, (uint64_t)v9);
            }
            else {
              BOOL result = std::string::operator=(size, v9);
            }
          }
LABEL_15:
          if ((v5 & 4) != 0)
          {
            BOOL result = (std::string *)((char *)v3 + 40);
            uint64_t v10 = (std::string *)v3[1].__r_.__value_.__r.__words[2];
            LODWORD(v3->__r_.__value_.__r.__words[2]) |= 4u;
            uint64_t v11 = *(const std::string **)(a2 + 40);
            if (v10 != v11)
            {
              if (v10 == (std::string *)&qword_1EAB1F7D8)
              {
                BOOL result = (std::string *)sub_1DD24F908(result, (uint64_t)v11);
                if ((v5 & 8) != 0)
                {
LABEL_20:
                  BOOL result = v3 + 2;
                  uint64_t v12 = (std::string *)v3[2].__r_.__value_.__l.__data_;
                  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 8u;
                  uint64_t v13 = *(const std::string **)(a2 + 48);
                  if (v12 != v13)
                  {
                    if (v12 == (std::string *)&qword_1EAB1F7D8) {
                      BOOL result = (std::string *)sub_1DD24F908(result, (uint64_t)v13);
                    }
                    else {
                      BOOL result = std::string::operator=(v12, v13);
                    }
                  }
                }
LABEL_26:
                if ((v5 & 0x10) != 0) {
                  v3[2].__r_.__value_.__l.__size_ = *(void *)(a2 + 56);
                }
                LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
                return result;
              }
              BOOL result = std::string::operator=(v10, v11);
            }
          }
          if ((v5 & 8) != 0) {
            goto LABEL_20;
          }
          goto LABEL_26;
        }
        BOOL result = std::string::operator=(data, v7);
      }
    }
    if ((v5 & 2) == 0) {
      goto LABEL_15;
    }
    goto LABEL_9;
  }
  return result;
}

uint64_t sub_1DD23CD88()
{
  return 1;
}

void *sub_1DD23CD90@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StringStatistics");
}

uint64_t sub_1DD23CDA0(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BF38;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  if (atomic_load_explicit(dword_1EC8AC108, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC108);
  }
  return a1;
}

void sub_1DD23CE18(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v1 + 24);
  sub_1DD24F770(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23CE34(uint64_t a1)
{
  if (*(int *)(a1 + 4) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 8);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  return a1;
}

uint64_t sub_1DD23CE78(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387BF38;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (unint64_t *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 20) = 0;
  *(void *)(a1 + 28) = 0;
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_1DD24FA20((unsigned int *)(a1 + 24), v5);
    uint64_t v6 = *(void *)(a1 + 32);
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
    memcpy((void *)(v6 + 8), (const void *)(*(void *)(a2 + 32) + 8), 8 * *(int *)(a2 + 24));
  }
  uint64_t v7 = *(void *)(a2 + 8);
  if (v7) {
    sub_1DD24FBB0(v4, v7 & 0xFFFFFFFFFFFFFFFELL);
  }
  return a1;
}

void sub_1DD23CF34(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23CF58(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BF38;
  if (*(int *)(a1 + 28) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD23CFC4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD23CF58(a1);
  operator delete(v1);
}

void sub_1DD23CFEC(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23D004(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v25 = (uint64_t *)(a1 + 8);
  long long v26 = 0uLL;
  uint64_t v27 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v27 = *(void *)(v5 + 16);
    long long v26 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v24, (uint64_t)&v26);
  sub_1DD2F9178((uint64_t)v23, (uint64_t)v24, 0);
  while (1)
  {
    while (1)
    {
      uint64_t v7 = *(char **)a2;
      if (*(void *)a2 >= *(void *)(a2 + 8))
      {
        uint64_t v8 = 0;
      }
      else
      {
        uint64_t v8 = *v7;
        if (*v7 >= 1)
        {
          *(void *)a2 = v7 + 1;
          unint64_t v9 = v8 | 0x100000000;
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_16;
          }
          goto LABEL_10;
        }
      }
      unsigned int v10 = sub_1DD2F8F70(a2, v8);
      unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
      if ((v9 & 0x100000000) == 0) {
        goto LABEL_16;
      }
LABEL_10:
      if ((v9 & 0xFFFFFFF8) != 8)
      {
LABEL_16:
        if (!v9)
        {
          uint64_t v21 = 1;
          goto LABEL_34;
        }
        goto LABEL_17;
      }
      if (v9 == 8)
      {
        char v13 = sub_1DD23D24C(1, 0xAu, (char **)a2, a1 + 24);
        goto LABEL_19;
      }
      if (v9 == 10) {
        break;
      }
LABEL_17:
      char v13 = sub_1DD2FB80C(a2, v9, (uint64_t)v23);
LABEL_19:
      if ((v13 & 1) == 0) {
        goto LABEL_35;
      }
    }
    uint64_t v11 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || *v11 < 0) {
      break;
    }
    int v12 = *v11;
    *(void *)a2 = v11 + 1;
LABEL_22:
    int v14 = sub_1DD2F81D8(a2, v12);
    while ((int)sub_1DD2F8334((_DWORD *)a2) >= 1)
    {
      uint64_t v15 = *(char **)a2;
      if (*(void *)a2 >= *(void *)(a2 + 8) || *v15 < 0)
      {
        unint64_t v17 = sub_1DD2F8A78(a2);
        if ((v18 & 1) == 0) {
          goto LABEL_35;
        }
        unint64_t v16 = v17;
      }
      else
      {
        unint64_t v16 = *v15;
        *(void *)a2 = v15 + 1;
      }
      int v19 = *(_DWORD *)(a1 + 24);
      if (v19 == *(_DWORD *)(a1 + 28))
      {
        sub_1DD24FA20((unsigned int *)(a1 + 24), v19 + 1);
        int v19 = *(_DWORD *)(a1 + 24);
      }
      uint64_t v20 = *(void *)(a1 + 32);
      *(_DWORD *)(a1 + 24) = v19 + 1;
      *(void *)(v20 + 8 * v19 + 8) = v16;
    }
    sub_1DD2F8250(a2, v14);
  }
  int v12 = sub_1DD2F8D1C((unsigned __int8 **)a2);
  if ((v12 & 0x80000000) == 0) {
    goto LABEL_22;
  }
LABEL_35:
  uint64_t v21 = 0;
LABEL_34:
  sub_1DD2F92B4(v23);
  sub_1DD24F874(&v25);
  return v21;
}

void sub_1DD23D220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23D24C(uint64_t a1, unsigned int a2, char **a3, uint64_t a4)
{
  uint64_t v7 = *a3;
  if (*a3 >= a3[1] || *v7 < 0)
  {
    unint64_t v9 = sub_1DD2F8A78((uint64_t)a3);
    if ((v10 & 1) == 0) {
      return 0;
    }
    unint64_t v8 = v9;
  }
  else
  {
    unint64_t v8 = *v7;
    *a3 = v7 + 1;
  }
  signed int v12 = *(_DWORD *)a4;
  int v13 = *(_DWORD *)(a4 + 4);
  if (*(_DWORD *)a4 == v13)
  {
    sub_1DD24FA20((unsigned int *)a4, v12 + 1);
    signed int v12 = *(_DWORD *)a4;
    int v13 = *(_DWORD *)(a4 + 4);
  }
  uint64_t v14 = *(void *)(a4 + 8);
  signed int v15 = v12 + 1;
  *(_DWORD *)a4 = v12 + 1;
  *(void *)(v14 + 8 * v12 + 8) = v8;
  if (v13 - (v12 + 1) >= 1)
  {
    int v16 = v13 - v12;
    do
    {
      if (a2 > 0x7F)
      {
        if (a2 >> 14) {
          return 1;
        }
        uint64_t v20 = *a3;
        unint64_t v17 = (unint64_t)a3[1];
        if ((int)(v17 - *a3) < 2
          || (a2 & 0x7F | 0x80) != *v20
          || v20[1] != (a2 >> 7))
        {
          return 1;
        }
        int v19 = v20 + 2;
      }
      else
      {
        char v18 = *a3;
        unint64_t v17 = (unint64_t)a3[1];
        if ((unint64_t)*a3 >= v17 || *v18 != a2) {
          return 1;
        }
        int v19 = v18 + 1;
      }
      *a3 = v19;
      if ((unint64_t)v19 >= v17 || *v19 < 0)
      {
        unint64_t v21 = sub_1DD2F8A78((uint64_t)a3);
        if ((v22 & 1) == 0) {
          return 0;
        }
        signed int v15 = *(_DWORD *)a4;
      }
      else
      {
        unint64_t v21 = *v19;
        *a3 = v19 + 1;
      }
      uint64_t v23 = *(void *)(a4 + 8) + 8 * v15++;
      *(_DWORD *)a4 = v15;
      *(void *)(v23 + 8) = v21;
      --v16;
    }
    while (v16 > 1);
  }
  return 1;
}

uint64_t sub_1DD23D3C0(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a1 + 24) >= 1)
  {
    if (*(int *)(a2 + 16) < 5)
    {
      sub_1DD2F9508(a2, 0xAu);
      int v4 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      *(unsigned char *)(*(void *)(a2 + 8))++ = 10;
      int v4 = *(_DWORD *)(a2 + 16) - 1;
      *(_DWORD *)(a2 + 16) = v4;
    }
    unsigned int v5 = *(_DWORD *)(a1 + 40);
    if (v4 < 5)
    {
      sub_1DD2F9508(a2, v5);
    }
    else
    {
      uint64_t v6 = *(void *)(a2 + 8);
      if (v5 < 0x80)
      {
        unsigned int v8 = *(_DWORD *)(a1 + 40);
        uint64_t v7 = *(unsigned char **)(a2 + 8);
      }
      else
      {
        uint64_t v7 = *(unsigned char **)(a2 + 8);
        do
        {
          *v7++ = v5 | 0x80;
          unsigned int v8 = v5 >> 7;
          unsigned int v9 = v5 >> 14;
          v5 >>= 7;
        }
        while (v9);
      }
      unsigned char *v7 = v8;
      int v10 = v7 - v6 + 1;
      *(void *)(a2 + 8) += v10;
      *(_DWORD *)(a2 + 16) -= v10;
    }
    uint64_t v11 = *(unsigned int *)(a1 + 24);
    if ((int)v11 >= 1)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        unint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8 * i + 8);
        if (*(int *)(a2 + 16) < 10)
        {
          sub_1DD2F9564(a2, v13);
        }
        else
        {
          uint64_t v14 = *(void *)(a2 + 8);
          if (v13 < 0x80)
          {
            unint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8 * i + 8);
            signed int v15 = *(unsigned char **)(a2 + 8);
          }
          else
          {
            signed int v15 = *(unsigned char **)(a2 + 8);
            do
            {
              *v15++ = v13 | 0x80;
              unint64_t v16 = v13 >> 7;
              unint64_t v17 = v13 >> 14;
              v13 >>= 7;
            }
            while (v17);
          }
          *signed int v15 = v16;
          int v18 = v15 - v14 + 1;
          *(void *)(a2 + 8) += v18;
          *(_DWORD *)(a2 + 16) -= v18;
        }
      }
    }
  }
  uint64_t v19 = *(void *)(a1 + 8);
  if (v19) {
    uint64_t v20 = (char *)(v19 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v20 = (char *)&qword_1EAB1F7D8;
  }
  if (v20[23] < 0) {
    uint64_t v20 = *(char **)v20;
  }
  if (v19) {
    unint64_t v21 = (uint64_t *)(v19 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v21 = &qword_1EAB1F7D8;
  }
  if (*((char *)v21 + 23) < 0) {
    uint64_t v22 = v21[1];
  }
  else {
    LODWORD(v22) = *((unsigned __int8 *)v21 + 23);
  }
  return sub_1DD2F92E0(a2, v20, v22);
}

uint64_t sub_1DD23D5A0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = sub_1DD2FD058((unsigned int *)(a1 + 24));
  uint64_t v6 = 11;
  uint64_t v7 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((int)v5 >= 0) {
    uint64_t v6 = v7;
  }
  uint64_t v8 = v6 + v4;
  if (v5) {
    int v9 = v5;
  }
  else {
    int v9 = 0;
  }
  if (!v5) {
    uint64_t v8 = v4;
  }
  *(_DWORD *)(a1 + 40) = v9;
  uint64_t result = v8 + v5;
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

std::string *sub_1DD23D63C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t data_low = SLODWORD(v3[1].__r_.__value_.__l.__data_);
    uint64_t v6 = v3 + 1;
    sub_1DD24FA20((unsigned int *)v6, data_low + v5);
    std::string::size_type size = v6->__r_.__value_.__l.__size_;
    LODWORD(v6->__r_.__value_.__l.__data_) += *(_DWORD *)(a2 + 24);
    int v9 = (void *)(size + 8 * data_low + 8);
    int v10 = (const void *)(*(void *)(a2 + 32) + 8);
    size_t v11 = 8 * *(int *)(a2 + 24);
    return (std::string *)memcpy(v9, v10, v11);
  }
  return result;
}

uint64_t sub_1DD23D6E0()
{
  return 1;
}

void *sub_1DD23D6E8@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.BucketStatistics");
}

void *sub_1DD23D6F8(void *a1)
{
  *a1 = &unk_1F387C2F8;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC1D8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC1D8);
  }
  a1[3] = &qword_1EAB1F7D8;
  a1[4] = &qword_1EAB1F7D8;
  a1[5] = &qword_1EAB1F7D8;
  return a1;
}

void sub_1DD23D774(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23D788(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C2F8;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(void *)(a1 + 24) = &qword_1EAB1F7D8;
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5)
  {
    uint64_t v6 = *(uint64_t **)(a2 + 24);
    if (v6 != &qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 24), (uint64_t)v6);
      int v5 = *(_DWORD *)(a2 + 16);
    }
  }
  *(void *)(a1 + 32) = &qword_1EAB1F7D8;
  if ((v5 & 2) != 0)
  {
    uint64_t v7 = *(uint64_t **)(a2 + 32);
    if (v7 != &qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 32), (uint64_t)v7);
      int v5 = *(_DWORD *)(a2 + 16);
    }
  }
  *(void *)(a1 + 40) = &qword_1EAB1F7D8;
  if ((v5 & 4) != 0)
  {
    uint64_t v8 = *(uint64_t **)(a2 + 40);
    if (v8 != &qword_1EAB1F7D8) {
      sub_1DD24F908((void *)(a1 + 40), (uint64_t)v8);
    }
  }
  return a1;
}

void sub_1DD23D860(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void sub_1DD23D874(void *a1)
{
  uint64_t v2 = a1[3];
  if ((uint64_t *)v2 != &qword_1EAB1F7D8 && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete((void *)v2);
  }
  uint64_t v4 = a1[4];
  if ((uint64_t *)v4 != &qword_1EAB1F7D8 && v4 != 0)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete((void *)v4);
  }
  uint64_t v6 = a1[5];
  if ((uint64_t *)v6 != &qword_1EAB1F7D8 && v6 != 0)
  {
    if (*(char *)(v6 + 23) < 0) {
      operator delete(*(void **)v6);
    }
    operator delete((void *)v6);
  }
}

void *sub_1DD23D938(void *a1)
{
  *a1 = &unk_1F387C2F8;
  uint64_t v2 = a1 + 1;
  sub_1DD23D874(a1);
  sub_1DD24F770(v2);
  return a1;
}

void sub_1DD23D988(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C2F8;
  uint64_t v2 = a1 + 1;
  sub_1DD23D874(a1);
  sub_1DD24F770(v2);
  operator delete(a1);
}

void sub_1DD23D9E8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 7) == 0) {
    goto LABEL_17;
  }
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (*(char *)(v2 + 23) < 0)
    {
      **(unsigned char **)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
      if ((v1 & 2) != 0) {
        goto LABEL_10;
      }
    }
    else
    {
      *(unsigned char *)uint64_t v2 = 0;
      *(unsigned char *)(v2 + 23) = 0;
      if ((v1 & 2) != 0) {
        goto LABEL_10;
      }
    }
LABEL_4:
    if ((v1 & 4) == 0) {
      goto LABEL_17;
    }
LABEL_14:
    uint64_t v4 = *(void *)(a1 + 40);
    if (*(char *)(v4 + 23) < 0)
    {
      **(unsigned char **)uint64_t v4 = 0;
      *(void *)(v4 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v4 = 0;
      *(unsigned char *)(v4 + 23) = 0;
    }
    goto LABEL_17;
  }
  if ((v1 & 2) == 0) {
    goto LABEL_4;
  }
LABEL_10:
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(char *)(v3 + 23) < 0)
  {
    **(unsigned char **)uint64_t v3 = 0;
    *(void *)(v3 + 8) = 0;
    if ((v1 & 4) == 0) {
      goto LABEL_17;
    }
    goto LABEL_14;
  }
  *(unsigned char *)uint64_t v3 = 0;
  *(unsigned char *)(v3 + 23) = 0;
  if ((v1 & 4) != 0) {
    goto LABEL_14;
  }
LABEL_17:
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6) {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD23DA94(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v19 = (uint64_t *)(a1 + 8);
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v21 = *(void *)(v5 + 16);
    long long v20 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v18, (uint64_t)&v20);
  sub_1DD2F9178((uint64_t)v17, (uint64_t)v18, 0);
  while (1)
  {
    uint64_t v7 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if (*v7 >= 1)
      {
        *a2 = (uint64_t)(v7 + 1);
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_28;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_28;
    }
LABEL_10:
    unsigned int v11 = v9 >> 3;
    if (v9 >> 3 == 3)
    {
      if (v9 != 26) {
        goto LABEL_28;
      }
      *(_DWORD *)(a1 + 16) |= 4u;
      unint64_t v13 = *(std::string **)(a1 + 40);
      if (v13 == (std::string *)&qword_1EAB1F7D8)
      {
        sub_1DD24F908((void *)(a1 + 40), (uint64_t)&qword_1EAB1F7D8);
        unint64_t v13 = *(std::string **)(a1 + 40);
      }
      goto LABEL_27;
    }
    if (v11 != 2) {
      break;
    }
    if (v9 != 18) {
      goto LABEL_28;
    }
    *(_DWORD *)(a1 + 16) |= 2u;
    unint64_t v13 = *(std::string **)(a1 + 32);
    if (v13 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 32), (uint64_t)&qword_1EAB1F7D8);
      unint64_t v13 = *(std::string **)(a1 + 32);
    }
LABEL_27:
    BOOL v14 = sub_1DD2FCF1C(a2, v13);
LABEL_30:
    if (!v14)
    {
      uint64_t v15 = 0;
      goto LABEL_33;
    }
  }
  if (v11 == 1 && v9 == 10)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    unint64_t v13 = *(std::string **)(a1 + 24);
    if (v13 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 24), (uint64_t)&qword_1EAB1F7D8);
      unint64_t v13 = *(std::string **)(a1 + 24);
    }
    goto LABEL_27;
  }
LABEL_28:
  if (v9)
  {
    BOOL v14 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v17);
    goto LABEL_30;
  }
  uint64_t v15 = 1;
LABEL_33:
  sub_1DD2F92B4(v17);
  sub_1DD24F874(&v19);
  return v15;
}

void sub_1DD23DC94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23DCBC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC85C(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC85C(2, *(void *)(a1 + 32), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC85C(3, *(void *)(a1 + 40), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23DD90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_14;
  }
  if (v4)
  {
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(unsigned __int8 *)(v9 + 23);
    uint64_t v11 = *(void *)(v9 + 8);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = v10;
    }
    v3 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 2) == 0)
    {
LABEL_10:
      if ((v4 & 4) == 0) {
        goto LABEL_14;
      }
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_10;
  }
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = *(unsigned __int8 *)(v12 + 23);
  uint64_t v14 = *(void *)(v12 + 8);
  if ((v13 & 0x80u) == 0) {
    uint64_t v14 = v13;
  }
  v3 += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v4 & 4) != 0)
  {
LABEL_11:
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(unsigned __int8 *)(v5 + 23);
    uint64_t v7 = *(void *)(v5 + 8);
    if ((v6 & 0x80u) == 0) {
      uint64_t v7 = v6;
    }
    v3 += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }
LABEL_14:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23DEA4(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      uint64_t result = v3 + 1;
      data = (std::string *)v3[1].__r_.__value_.__l.__data_;
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      uint64_t v7 = *(const std::string **)(a2 + 24);
      if (data != v7)
      {
        if (data == (std::string *)&qword_1EAB1F7D8)
        {
          uint64_t result = (std::string *)sub_1DD24F908(result, (uint64_t)v7);
          if ((v5 & 2) == 0) {
            goto LABEL_14;
          }
          goto LABEL_9;
        }
        uint64_t result = std::string::operator=(data, v7);
      }
    }
    if ((v5 & 2) == 0) {
      goto LABEL_14;
    }
LABEL_9:
    uint64_t result = (std::string *)((char *)v3 + 32);
    std::string::size_type size = (std::string *)v3[1].__r_.__value_.__l.__size_;
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 2u;
    uint64_t v9 = *(const std::string **)(a2 + 32);
    if (size != v9)
    {
      if (size == (std::string *)&qword_1EAB1F7D8)
      {
        uint64_t result = (std::string *)sub_1DD24F908(result, (uint64_t)v9);
        if ((v5 & 4) == 0) {
          return result;
        }
      }
      else
      {
        uint64_t result = std::string::operator=(size, v9);
        if ((v5 & 4) == 0) {
          return result;
        }
      }
      goto LABEL_15;
    }
LABEL_14:
    if ((v5 & 4) == 0) {
      return result;
    }
LABEL_15:
    uint64_t v11 = (std::string *)v3[1].__r_.__value_.__r.__words[2];
    uint64_t v10 = &v3[1].__r_.__value_.__r.__words[2];
    uint64_t result = v11;
    *((_DWORD *)v10 - 6) |= 4u;
    uint64_t v12 = *(const std::string **)(a2 + 40);
    if (v11 != v12)
    {
      if (result == (std::string *)&qword_1EAB1F7D8)
      {
        return (std::string *)sub_1DD24F908(v10, (uint64_t)v12);
      }
      else
      {
        return std::string::operator=(result, v12);
      }
    }
  }
  return result;
}

uint64_t sub_1DD23DFF4()
{
  return 1;
}

void *sub_1DD23DFFC@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.DecimalStatistics");
}

void *sub_1DD23E00C(void *a1)
{
  *a1 = &unk_1F387BD58;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC0D8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC0D8);
  }
  a1[3] = 0;
  return a1;
}

void sub_1DD23E07C(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23E090(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387BD58;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return a1;
}

void sub_1DD23E108(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23E11C(void *a1)
{
  *a1 = &unk_1F387BD58;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23E160(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387BD58;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23E1B4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 3) != 0) {
    *(void *)(a1 + 24) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23E1D8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v21 = (uint64_t *)(a1 + 8);
  long long v22 = 0uLL;
  uint64_t v23 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v23 = *(void *)(v5 + 16);
    long long v22 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v20, (uint64_t)&v22);
  sub_1DD2F9178((uint64_t)v19, (uint64_t)v20, 0);
  do
  {
    while (1)
    {
      uint64_t v7 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        uint64_t v8 = 0;
LABEL_9:
        unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
        unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_24;
        }
        goto LABEL_10;
      }
      uint64_t v8 = *v7;
      if (*v7 < 1) {
        goto LABEL_9;
      }
      *a2 = (uint64_t)(v7 + 1);
      unint64_t v9 = v8 | 0x100000000;
      if ((v9 & 0x100000000) == 0) {
        goto LABEL_24;
      }
LABEL_10:
      if (v9 >> 3 != 2) {
        break;
      }
      if (v9 != 16) {
        goto LABEL_24;
      }
      *(_DWORD *)(a1 + 16) |= 2u;
      uint64_t v12 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        unsigned int v13 = 0;
      }
      else
      {
        unsigned int v13 = *v12;
        uint64_t v14 = (unsigned int *)(a1 + 28);
        if ((*v12 & 0x80000000) == 0)
        {
LABEL_23:
          *a2 = (uint64_t)(v12 + 1);
          goto LABEL_30;
        }
      }
      uint64_t v16 = sub_1DD2F8C30(a2, v13);
      unsigned int v13 = v16;
      uint64_t v14 = (unsigned int *)(a1 + 28);
      if (v16 < 0) {
        goto LABEL_33;
      }
LABEL_30:
      unsigned int *v14 = -(v13 & 1) ^ (v13 >> 1);
    }
    if (v9 >> 3 == 1 && v9 == 8)
    {
      *(_DWORD *)(a1 + 16) |= 1u;
      uint64_t v12 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        unsigned int v13 = 0;
      }
      else
      {
        unsigned int v13 = *v12;
        uint64_t v14 = (unsigned int *)(a1 + 24);
        if ((*v12 & 0x80000000) == 0) {
          goto LABEL_23;
        }
      }
      uint64_t v15 = sub_1DD2F8C30(a2, v13);
      unsigned int v13 = v15;
      uint64_t v14 = (unsigned int *)(a1 + 24);
      if (v15 < 0) {
        break;
      }
      goto LABEL_30;
    }
LABEL_24:
    if (!v9)
    {
      uint64_t v17 = 1;
      goto LABEL_32;
    }
  }
  while (sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v19));
LABEL_33:
  uint64_t v17 = 0;
LABEL_32:
  sub_1DD2F92B4(v19);
  sub_1DD24F874(&v21);
  return v17;
}

void sub_1DD23E3C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23E3E8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4) {
    sub_1DD2FC204(1, *(_DWORD *)(a1 + 24), a2);
  }
  if ((v4 & 2) != 0) {
    sub_1DD2FC204(2, *(_DWORD *)(a1 + 28), a2);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23E49C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 3) != 0)
  {
    if (v4) {
      v3 += ((9 * (__clz((2 * *(_DWORD *)(a1 + 24)) ^ (*(int *)(a1 + 24) >> 31) | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
    if ((v4 & 2) != 0) {
      v3 += ((9 * (__clz((2 * *(_DWORD *)(a1 + 28)) ^ (*(int *)(a1 + 28) >> 31) | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
  }
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23E544(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 3) != 0)
  {
    if (v5) {
      LODWORD(v3[1].__r_.__value_.__l.__data_) = *(_DWORD *)(a2 + 24);
    }
    if ((v5 & 2) != 0) {
      HIDWORD(v3[1].__r_.__value_.__r.__words[0]) = *(_DWORD *)(a2 + 28);
    }
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
  }
  return result;
}

uint64_t sub_1DD23E5AC()
{
  return 1;
}

void *sub_1DD23E5B4@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.DateStatistics");
}

uint64_t sub_1DD23E5C4(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C578;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (atomic_load_explicit(dword_1EC8AC238, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC238);
  }
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return a1;
}

void sub_1DD23E640(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23E654(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C578;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  long long v6 = *(_OWORD *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(_OWORD *)(a1 + 40) = v6;
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void sub_1DD23E6DC(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23E6F0(void *a1)
{
  *a1 = &unk_1F387C578;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23E734(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C578;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23E788(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 0x3F) != 0)
  {
    *(void *)(a1 + 56) = 0;
    *(_OWORD *)(a1 + 40) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23E7B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  v33 = (uint64_t *)(a1 + 8);
  long long v34 = 0uLL;
  uint64_t v35 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v35 = *(void *)(v5 + 16);
    long long v34 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v32, (uint64_t)&v34);
  sub_1DD2F9178((uint64_t)v31, (uint64_t)v32, 0);
  while (1)
  {
    while (1)
    {
      uint64_t v7 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1]) {
        break;
      }
      uint64_t v8 = 0;
LABEL_9:
      unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
      unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
      if ((v9 & 0x100000000) == 0) {
        goto LABEL_35;
      }
LABEL_10:
      switch(v9 >> 3)
      {
        case 1u:
          if (v9 != 8) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 1u;
          uint64_t v11 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v11 < 0)
          {
            unint64_t v12 = sub_1DD2F8A78((uint64_t)a2);
            if ((v23 & 1) == 0) {
              goto LABEL_54;
            }
          }
          else
          {
            unint64_t v12 = *v11;
            *a2 = (uint64_t)(v11 + 1);
          }
          *(void *)(a1 + 24) = -(uint64_t)(v12 & 1) ^ (v12 >> 1);
          continue;
        case 2u:
          if (v9 != 16) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 2u;
          unsigned int v13 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v13 < 0)
          {
            unint64_t v14 = sub_1DD2F8A78((uint64_t)a2);
            if ((v24 & 1) == 0) {
              goto LABEL_54;
            }
          }
          else
          {
            unint64_t v14 = *v13;
            *a2 = (uint64_t)(v13 + 1);
          }
          *(void *)(a1 + 32) = -(uint64_t)(v14 & 1) ^ (v14 >> 1);
          continue;
        case 3u:
          if (v9 != 24) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          uint64_t v15 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v15 < 0)
          {
            unint64_t v16 = sub_1DD2F8A78((uint64_t)a2);
            if ((v25 & 1) == 0) {
              goto LABEL_54;
            }
          }
          else
          {
            unint64_t v16 = *v15;
            *a2 = (uint64_t)(v15 + 1);
          }
          *(void *)(a1 + 40) = -(uint64_t)(v16 & 1) ^ (v16 >> 1);
          continue;
        case 4u:
          if (v9 != 32) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 8u;
          uint64_t v17 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v17 < 0)
          {
            unint64_t v18 = sub_1DD2F8A78((uint64_t)a2);
            if ((v26 & 1) == 0) {
              goto LABEL_54;
            }
          }
          else
          {
            unint64_t v18 = *v17;
            *a2 = (uint64_t)(v17 + 1);
          }
          *(void *)(a1 + 48) = -(uint64_t)(v18 & 1) ^ (v18 >> 1);
          continue;
        case 5u:
          if (v9 != 40) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 0x10u;
          uint64_t v19 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1])
          {
            int v20 = 0;
          }
          else
          {
            int v20 = *v19;
            if ((*v19 & 0x80000000) == 0)
            {
              *a2 = (uint64_t)(v19 + 1);
              goto LABEL_48;
            }
          }
          uint64_t v27 = sub_1DD2F8C30(a2, v20);
          int v20 = v27;
          if (v27 < 0) {
            goto LABEL_54;
          }
LABEL_48:
          *(_DWORD *)(a1 + 56) = v20;
          continue;
        case 6u:
          if (v9 != 48) {
            goto LABEL_35;
          }
          *(_DWORD *)(a1 + 16) |= 0x20u;
          uint64_t v21 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1])
          {
            int v22 = 0;
          }
          else
          {
            int v22 = *v21;
            if ((*v21 & 0x80000000) == 0)
            {
              *a2 = (uint64_t)(v21 + 1);
              goto LABEL_51;
            }
          }
          uint64_t v28 = sub_1DD2F8C30(a2, v22);
          int v22 = v28;
          if (v28 < 0)
          {
LABEL_54:
            uint64_t v29 = 0;
            goto LABEL_53;
          }
LABEL_51:
          *(_DWORD *)(a1 + 60) = v22;
          break;
        default:
          goto LABEL_35;
      }
    }
    uint64_t v8 = *v7;
    if (*v7 < 1) {
      goto LABEL_9;
    }
    *a2 = (uint64_t)(v7 + 1);
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) != 0) {
      goto LABEL_10;
    }
LABEL_35:
    if (!v9) {
      break;
    }
    if (!sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v31)) {
      goto LABEL_54;
    }
  }
  uint64_t v29 = 1;
LABEL_53:
  sub_1DD2F92B4(v31);
  sub_1DD24F874(&v33);
  return v29;
}

void sub_1DD23EB10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23EB50(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC328(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_20;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC328(2, *(void *)(a1 + 32), a2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_21;
  }
LABEL_20:
  sub_1DD2FC328(3, *(void *)(a1 + 40), a2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_22;
  }
LABEL_21:
  sub_1DD2FC328(4, *(void *)(a1 + 48), a2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_22:
  sub_1DD2FBEA4(5, *(_DWORD *)(a1 + 56), a2);
  if ((v4 & 0x20) != 0) {
LABEL_7:
  }
    sub_1DD2FBEA4(6, *(_DWORD *)(a1 + 60), a2);
LABEL_8:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23EC6C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 0x3F) == 0) {
    goto LABEL_18;
  }
  if (v4)
  {
    v3 += ((9 * (__clz((2 * *(void *)(a1 + 24)) ^ (*(uint64_t *)(a1 + 24) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v4 & 2) == 0)
    {
LABEL_10:
      if ((v4 & 4) == 0) {
        goto LABEL_11;
      }
      goto LABEL_21;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_10;
  }
  v3 += ((9 * (__clz((2 * *(void *)(a1 + 32)) ^ (*(uint64_t *)(a1 + 32) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v4 & 4) == 0)
  {
LABEL_11:
    if ((v4 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_22;
  }
LABEL_21:
  v3 += ((9 * (__clz((2 * *(void *)(a1 + 40)) ^ (*(uint64_t *)(a1 + 40) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v4 & 8) == 0)
  {
LABEL_12:
    if ((v4 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_23;
  }
LABEL_22:
  v3 += ((9 * (__clz((2 * *(void *)(a1 + 48)) ^ (*(uint64_t *)(a1 + 48) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v4 & 0x10) == 0)
  {
LABEL_13:
    if ((v4 & 0x20) == 0) {
      goto LABEL_18;
    }
    goto LABEL_14;
  }
LABEL_23:
  int v9 = *(_DWORD *)(a1 + 56);
  uint64_t v10 = ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v9 >= 0) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = 11;
  }
  v3 += v11;
  if ((v4 & 0x20) != 0)
  {
LABEL_14:
    int v5 = *(_DWORD *)(a1 + 60);
    uint64_t v6 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v5 >= 0) {
      uint64_t v7 = v6;
    }
    else {
      uint64_t v7 = 11;
    }
    v3 += v7;
  }
LABEL_18:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23EDE4(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x3F) != 0)
  {
    if (v5)
    {
      v3[1].__r_.__value_.__r.__words[0] = *(void *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_15;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    v3[1].__r_.__value_.__l.__size_ = *(void *)(a2 + 32);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0) {
        goto LABEL_8;
      }
      goto LABEL_16;
    }
LABEL_15:
    v3[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
    if ((v5 & 8) == 0)
    {
LABEL_8:
      if ((v5 & 0x10) == 0) {
        goto LABEL_9;
      }
      goto LABEL_17;
    }
LABEL_16:
    v3[2].__r_.__value_.__r.__words[0] = *(void *)(a2 + 48);
    if ((v5 & 0x10) == 0)
    {
LABEL_9:
      if ((v5 & 0x20) == 0)
      {
LABEL_11:
        LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
        return result;
      }
LABEL_10:
      HIDWORD(v3[2].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 60);
      goto LABEL_11;
    }
LABEL_17:
    LODWORD(v3[2].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 56);
    if ((v5 & 0x20) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_1DD23EE94()
{
  return 1;
}

void *sub_1DD23EE9C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.TimestampStatistics");
}

void *sub_1DD23EEAC(void *a1)
{
  *a1 = &unk_1F387BDF8;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC0F0, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC0F0);
  }
  a1[3] = 0;
  return a1;
}

void sub_1DD23EF1C(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23EF30(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387BDF8;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  return a1;
}

void sub_1DD23EFA8(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23EFBC(void *a1)
{
  *a1 = &unk_1F387BDF8;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23F000(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387BDF8;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23F054(uint64_t a1)
{
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(void *)(v1 + 16) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23F06C(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v19 = (uint64_t *)(a1 + 8);
  long long v20 = 0uLL;
  uint64_t v21 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v21 = *(void *)(v5 + 16);
    long long v20 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v18, (uint64_t)&v20);
  sub_1DD2F9178((uint64_t)v17, (uint64_t)v18, 0);
  do
  {
    while (1)
    {
      uint64_t v7 = *a2;
      if (*a2 >= a2[1])
      {
        uint64_t v8 = 0;
LABEL_9:
        unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
        unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
        if ((v9 & 0x100000000) == 0) {
          break;
        }
        goto LABEL_10;
      }
      uint64_t v8 = *v7;
      if (*v7 < 1) {
        goto LABEL_9;
      }
      *a2 = v7 + 1;
      unint64_t v9 = v8 | 0x100000000;
      if ((v9 & 0x100000000) == 0) {
        break;
      }
LABEL_10:
      if (v9 != 8 || (v9 & 0xFFFFFFF8) != 8) {
        break;
      }
      *(_DWORD *)(a1 + 16) |= 1u;
      unint64_t v12 = *a2;
      if (*a2 >= a2[1] || *v12 < 0)
      {
        unint64_t v13 = sub_1DD2F8A78((uint64_t)a2);
        if ((v14 & 1) == 0) {
          goto LABEL_24;
        }
      }
      else
      {
        unint64_t v13 = *v12;
        *a2 = v12 + 1;
      }
      *(void *)(a1 + 24) = -(uint64_t)(v13 & 1) ^ (v13 >> 1);
    }
    if (!v9)
    {
      uint64_t v15 = 1;
      goto LABEL_23;
    }
  }
  while (sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v17));
LABEL_24:
  uint64_t v15 = 0;
LABEL_23:
  sub_1DD2F92B4(v17);
  sub_1DD24F874(&v19);
  return v15;
}

void sub_1DD23F1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23F200(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD2FC328(1, *(void *)(a1 + 24), a2);
  }
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4) {
    unint64_t v5 = (char *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v5 = (char *)&qword_1EAB1F7D8;
  }
  if (v5[23] < 0) {
    unint64_t v5 = *(char **)v5;
  }
  if (v4) {
    long long v6 = (uint64_t *)(v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = &qword_1EAB1F7D8;
  }
  if (*((char *)v6 + 23) < 0) {
    uint64_t v7 = v6[1];
  }
  else {
    LODWORD(v7) = *((unsigned __int8 *)v6 + 23);
  }
  return sub_1DD2F92E0(a2, v5, v7);
}

uint64_t sub_1DD23F298(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  if (*(unsigned char *)(a1 + 16)) {
    v3 += ((9 * (__clz((2 * *(void *)(a1 + 24)) ^ (*(uint64_t *)(a1 + 24) >> 63) | 1) ^ 0x3F) + 73) >> 6) + 1;
  }
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD23F304(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    std::string::size_type v5 = *(void *)(a2 + 24);
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
    v3[1].__r_.__value_.__r.__words[0] = v5;
  }
  return result;
}

uint64_t sub_1DD23F358()
{
  return 1;
}

void *sub_1DD23F360@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.BinaryStatistics");
}

void *sub_1DD23F370(void *a1)
{
  *a1 = &unk_1F387C618;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC250, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC250);
  }
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  return a1;
}

void sub_1DD23F3E4(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23F3F8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C618;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  long long v5 = *(_OWORD *)(a2 + 24);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(_OWORD *)(a1 + 24) = v5;
  return a1;
}

void sub_1DD23F478(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23F48C(void *a1)
{
  *a1 = &unk_1F387C618;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD23F4D0(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C618;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD23F524(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 7) != 0)
  {
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD23F54C(uint64_t a1, char **a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  char v23 = (uint64_t *)(a1 + 8);
  long long v24 = 0uLL;
  uint64_t v25 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v25 = *(void *)(v5 + 16);
    long long v24 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v22, (uint64_t)&v24);
  sub_1DD2F9178((uint64_t)v21, (uint64_t)v22, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v7 = *a2;
          if (*a2 >= a2[1])
          {
            uint64_t v8 = 0;
LABEL_9:
            unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
            unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
            if ((v9 & 0x100000000) == 0) {
              goto LABEL_29;
            }
            goto LABEL_10;
          }
          uint64_t v8 = *v7;
          if (*v7 < 1) {
            goto LABEL_9;
          }
          *a2 = v7 + 1;
          unint64_t v9 = v8 | 0x100000000;
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_29;
          }
LABEL_10:
          unsigned int v11 = v9 >> 3;
          if (v9 >> 3 != 3) {
            break;
          }
          if (v9 != 24) {
            goto LABEL_29;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          unint64_t v13 = *a2;
          if (*a2 < a2[1] && (*v13 & 0x80000000) == 0)
          {
            uint64_t v14 = *v13;
            uint64_t v15 = (void *)(a1 + 40);
            goto LABEL_28;
          }
          *(void *)(a1 + 40) = sub_1DD2F8A78((uint64_t)a2);
          if ((v17 & 1) == 0) {
            goto LABEL_37;
          }
        }
        if (v11 != 2) {
          break;
        }
        if (v9 != 16) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        unint64_t v13 = *a2;
        if (*a2 >= a2[1] || *v13 < 0)
        {
          *(void *)(a1 + 32) = sub_1DD2F8A78((uint64_t)a2);
          if ((v18 & 1) == 0)
          {
LABEL_37:
            uint64_t v19 = 0;
            goto LABEL_39;
          }
        }
        else
        {
          uint64_t v14 = *v13;
          uint64_t v15 = (void *)(a1 + 32);
LABEL_28:
          *uint64_t v15 = v14;
          *a2 = v13 + 1;
        }
      }
      if (v11 != 1 || v9 != 8) {
        break;
      }
      *(_DWORD *)(a1 + 16) |= 1u;
      unint64_t v13 = *a2;
      if (*a2 < a2[1] && (*v13 & 0x80000000) == 0)
      {
        uint64_t v14 = *v13;
        uint64_t v15 = (void *)(a1 + 24);
        goto LABEL_28;
      }
      *(void *)(a1 + 24) = sub_1DD2F8A78((uint64_t)a2);
      if ((v16 & 1) == 0) {
        goto LABEL_37;
      }
    }
LABEL_29:
    if (!v9) {
      break;
    }
    if (!sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v21)) {
      goto LABEL_37;
    }
  }
  uint64_t v19 = 1;
LABEL_39:
  sub_1DD2F92B4(v21);
  sub_1DD24F874(&v23);
  return v19;
}

void sub_1DD23F774(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23F79C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC0E4(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC0E4(2, *(void *)(a1 + 32), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC0E4(3, *(void *)(a1 + 40), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD23F870(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_12;
  }
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    v3 += ((9 * (__clz(*(void *)(a1 + 32) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v4 & 4) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  v3 += ((9 * (__clz(*(void *)(a1 + 24) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v4 & 2) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if ((v4 & 4) != 0) {
LABEL_11:
  }
    v3 += ((9 * (__clz(*(void *)(a1 + 40) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_12:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

uint64_t sub_1DD23F930()
{
  return 1;
}

void *sub_1DD23F938@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.CollectionStatistics");
}

uint64_t sub_1DD23F948(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BFD8;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (atomic_load_explicit(dword_1EC8AC120, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC120);
  }
  *(_OWORD *)(a1 + 97) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return a1;
}

void sub_1DD23F9D0(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD23F9E8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387BFD8;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5)
  {
    uint64_t v7 = operator new(0x30uLL);
    sub_1DD23B658((uint64_t)v7, *(void *)(a2 + 24));
    *(void *)(a1 + 24) = v7;
    int v5 = *(_DWORD *)(a2 + 16);
    if ((v5 & 2) == 0)
    {
LABEL_5:
      *(void *)(a1 + 32) = 0;
      if ((v5 & 4) == 0) {
        goto LABEL_6;
      }
      goto LABEL_15;
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
    if ((v5 & 2) == 0) {
      goto LABEL_5;
    }
  }
  uint64_t v8 = operator new(0x30uLL);
  sub_1DD23BCD8((uint64_t)v8, *(void *)(a2 + 32));
  *(void *)(a1 + 32) = v8;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 4) == 0)
  {
LABEL_6:
    *(void *)(a1 + 40) = 0;
    if ((v5 & 8) == 0) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  unint64_t v9 = operator new(0x40uLL);
  sub_1DD23C2F0((uint64_t)v9, *(void *)(a2 + 40));
  *(void *)(a1 + 40) = v9;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 8) == 0)
  {
LABEL_7:
    *(void *)(a1 + 48) = 0;
    if ((v5 & 0x10) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  unsigned int v10 = operator new(0x30uLL);
  sub_1DD23CE78((uint64_t)v10, *(void *)(a2 + 48));
  *(void *)(a1 + 48) = v10;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x10) == 0)
  {
LABEL_8:
    *(void *)(a1 + 56) = 0;
    if ((v5 & 0x20) == 0) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }
LABEL_17:
  unsigned int v11 = operator new(0x30uLL);
  sub_1DD23D788((uint64_t)v11, *(void *)(a2 + 56));
  *(void *)(a1 + 56) = v11;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x20) == 0)
  {
LABEL_9:
    *(void *)(a1 + 64) = 0;
    if ((v5 & 0x40) == 0) {
      goto LABEL_10;
    }
    goto LABEL_19;
  }
LABEL_18:
  unint64_t v12 = operator new(0x20uLL);
  sub_1DD23E090((uint64_t)v12, *(void *)(a2 + 64));
  *(void *)(a1 + 64) = v12;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x40) == 0)
  {
LABEL_10:
    *(void *)(a1 + 72) = 0;
    if ((v5 & 0x80) == 0) {
      goto LABEL_11;
    }
LABEL_20:
    uint64_t v14 = operator new(0x40uLL);
    sub_1DD23E654((uint64_t)v14, *(void *)(a2 + 80));
    *(void *)(a1 + 80) = v14;
    if ((*(_DWORD *)(a2 + 16) & 0x100) == 0) {
      goto LABEL_12;
    }
LABEL_21:
    long long v6 = operator new(0x30uLL);
    sub_1DD23F3F8((uint64_t)v6, *(void *)(a2 + 88));
    goto LABEL_22;
  }
LABEL_19:
  unint64_t v13 = operator new(0x20uLL);
  sub_1DD23EF30((uint64_t)v13, *(void *)(a2 + 72));
  *(void *)(a1 + 72) = v13;
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0x80) != 0) {
    goto LABEL_20;
  }
LABEL_11:
  *(void *)(a1 + 80) = 0;
  if ((v5 & 0x100) != 0) {
    goto LABEL_21;
  }
LABEL_12:
  long long v6 = 0;
LABEL_22:
  *(void *)(a1 + 88) = v6;
  long long v15 = *(_OWORD *)(a2 + 96);
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v15;
  return a1;
}

void sub_1DD23FBD0(_Unwind_Exception *a1)
{
  operator delete(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD23FC18(void *a1)
{
  *a1 = &unk_1F387BFD8;
  sub_1DD23FC68(a1);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void *sub_1DD23FC68(void *result)
{
  if (result != (void *)&unk_1EAB1F3D0)
  {
    uint64_t v1 = result;
    uint64_t v2 = result[3];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t v3 = v1[4];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = v1[5];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = v1[6];
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = v1[7];
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    uint64_t v7 = v1[8];
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    uint64_t v8 = v1[9];
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    uint64_t v9 = v1[10];
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t result = (void *)v1[11];
    if (result)
    {
      unsigned int v10 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v10();
    }
  }
  return result;
}

void sub_1DD23FE40(void *a1)
{
  uint64_t v1 = sub_1DD23FC18(a1);
  operator delete(v1);
}

void sub_1DD23FE68(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (!(_BYTE)v2) {
    goto LABEL_22;
  }
  if (v2)
  {
    sub_1DD23B784(*(void *)(a1 + 24));
    if ((v2 & 2) == 0)
    {
LABEL_4:
      if ((v2 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_9;
    }
  }
  else if ((v2 & 2) == 0)
  {
    goto LABEL_4;
  }
  sub_1DD23BE04(*(void *)(a1 + 32));
  if ((v2 & 4) == 0)
  {
LABEL_5:
    if ((v2 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_10;
  }
LABEL_9:
  sub_1DD23C5A0(*(void *)(a1 + 40));
  if ((v2 & 8) == 0) {
    goto LABEL_12;
  }
LABEL_10:
  uint64_t v3 = *(void *)(a1 + 48);
  char v5 = *(unsigned char *)(v3 + 8);
  uint64_t v4 = v3 + 8;
  *(_DWORD *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  if (v5) {
    sub_1DD24FC0C((unint64_t *)v4);
  }
LABEL_12:
  if ((v2 & 0x10) == 0)
  {
    if ((v2 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_17:
    sub_1DD23E1B4(*(void *)(a1 + 64));
    if ((v2 & 0x40) == 0) {
      goto LABEL_20;
    }
LABEL_18:
    uint64_t v6 = *(void *)(a1 + 72);
    char v8 = *(unsigned char *)(v6 + 8);
    uint64_t v7 = v6 + 8;
    *(void *)(v7 + 16) = 0;
    *(_DWORD *)(v7 + 8) = 0;
    if (v8) {
      sub_1DD24FC0C((unint64_t *)v7);
    }
    goto LABEL_20;
  }
  sub_1DD23D9E8(*(void *)(a1 + 56));
  if ((v2 & 0x20) != 0) {
    goto LABEL_17;
  }
LABEL_14:
  if ((v2 & 0x40) != 0) {
    goto LABEL_18;
  }
LABEL_20:
  if ((v2 & 0x80) != 0) {
    sub_1DD23E788(*(void *)(a1 + 80));
  }
LABEL_22:
  if ((v2 & 0x100) != 0) {
    sub_1DD23F524(*(void *)(a1 + 88));
  }
  if ((v2 & 0xE00) != 0)
  {
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
    *(unsigned char *)(a1 + 112) = 0;
  }
  char v10 = *(unsigned char *)(a1 + 8);
  uint64_t v9 = a1 + 8;
  *(_DWORD *)(v9 + 8) = 0;
  if (v10)
  {
    sub_1DD24FC0C((unint64_t *)v9);
  }
}

uint64_t sub_1DD23FF78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  v59 = (uint64_t *)(a1 + 8);
  long long v60 = 0uLL;
  uint64_t v61 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v61 = *(void *)(v5 + 16);
    long long v60 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v58, (uint64_t)&v60);
  sub_1DD2F9178((uint64_t)v57, (uint64_t)v58, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *v7;
    if ((char)*v7 < 1) {
      goto LABEL_9;
    }
    *(void *)a2 = v7 + 1;
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 8) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x200u;
        unint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 < *(void *)(a2 + 8) && ((char)*v12 & 0x80000000) == 0)
        {
          *(void *)(a1 + 96) = *v12;
          goto LABEL_75;
        }
        *(void *)(a1 + 96) = sub_1DD2F8A78(a2);
        if ((v42 & 1) == 0) {
          goto LABEL_126;
        }
        continue;
      case 2u:
        if (v9 != 18) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        unint64_t v13 = *(void **)(a1 + 24);
        if (!v13)
        {
          unint64_t v13 = sub_1DD24E360(0);
          *(void *)(a1 + 24) = v13;
        }
        uint64_t v14 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v14 < 0)
        {
          int v15 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v15 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v15 = *v14;
          *(void *)a2 = v14 + 1;
        }
        unint64_t v45 = sub_1DD2F8298(a2, v15);
        int v46 = v45;
        if ((v45 & 0x8000000000000000) == 0 && sub_1DD23B7AC((uint64_t)v13, (char **)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 3u:
        if (v9 != 26) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        char v16 = *(void **)(a1 + 32);
        if (!v16)
        {
          char v16 = sub_1DD24E3F4(0);
          *(void *)(a1 + 32) = v16;
        }
        char v17 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v17 < 0)
        {
          int v18 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v18 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v18 = *v17;
          *(void *)a2 = v17 + 1;
        }
        unint64_t v47 = sub_1DD2F8298(a2, v18);
        int v46 = v47;
        if ((v47 & 0x8000000000000000) == 0 && sub_1DD23BE2C((uint64_t)v16, (char **)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 4u:
        if (v9 != 34) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v19 = *(void **)(a1 + 40);
        if (!v19)
        {
          uint64_t v19 = sub_1DD24E488(0);
          *(void *)(a1 + 40) = v19;
        }
        long long v20 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v20 < 0)
        {
          int v21 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v21 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v21 = *v20;
          *(void *)a2 = v20 + 1;
        }
        unint64_t v48 = sub_1DD2F8298(a2, v21);
        int v46 = v48;
        if ((v48 & 0x8000000000000000) == 0 && sub_1DD23C680((uint64_t)v19, (uint64_t *)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 5u:
        if (v9 != 42) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 8u;
        int v22 = *(void **)(a1 + 48);
        if (!v22)
        {
          int v22 = sub_1DD24E51C(0);
          *(void *)(a1 + 48) = v22;
        }
        char v23 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v23 < 0)
        {
          int v24 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v24 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v24 = *v23;
          *(void *)a2 = v23 + 1;
        }
        unint64_t v49 = sub_1DD2F8298(a2, v24);
        int v46 = v49;
        if ((v49 & 0x8000000000000000) == 0 && sub_1DD23D004((uint64_t)v22, a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 6u:
        if (v9 != 50) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x10u;
        uint64_t v25 = *(void **)(a1 + 56);
        if (!v25)
        {
          uint64_t v25 = sub_1DD24E5B0(0);
          *(void *)(a1 + 56) = v25;
        }
        char v26 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v26 < 0)
        {
          int v27 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v27 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v27 = *v26;
          *(void *)a2 = v26 + 1;
        }
        unint64_t v50 = sub_1DD2F8298(a2, v27);
        int v46 = v50;
        if ((v50 & 0x8000000000000000) == 0 && sub_1DD23DA94((uint64_t)v25, (uint64_t *)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 7u:
        if (v9 != 58) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x20u;
        uint64_t v28 = *(void **)(a1 + 64);
        if (!v28)
        {
          uint64_t v28 = sub_1DD24E644(0);
          *(void *)(a1 + 64) = v28;
        }
        uint64_t v29 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v29 < 0)
        {
          int v30 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v30 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v30 = *v29;
          *(void *)a2 = v29 + 1;
        }
        unint64_t v51 = sub_1DD2F8298(a2, v30);
        int v46 = v51;
        if ((v51 & 0x8000000000000000) == 0 && sub_1DD23E1D8((uint64_t)v28, (uint64_t *)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 8u:
        if (v9 != 66) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x40u;
        uint64_t v31 = *(void **)(a1 + 72);
        if (!v31)
        {
          uint64_t v31 = sub_1DD24E76C(0);
          *(void *)(a1 + 72) = v31;
        }
        int v32 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v32 < 0)
        {
          int v33 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v33 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v33 = *v32;
          *(void *)a2 = v32 + 1;
        }
        unint64_t v52 = sub_1DD2F8298(a2, v33);
        int v46 = v52;
        if ((v52 & 0x8000000000000000) == 0 && sub_1DD23F06C((uint64_t)v31, (char **)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 9u:
        if (v9 != 74) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x80u;
        long long v34 = *(void **)(a1 + 80);
        if (!v34)
        {
          long long v34 = sub_1DD24E6D8(0);
          *(void *)(a1 + 80) = v34;
        }
        uint64_t v35 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v35 < 0)
        {
          int v36 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v36 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v36 = *v35;
          *(void *)a2 = v35 + 1;
        }
        unint64_t v53 = sub_1DD2F8298(a2, v36);
        int v46 = v53;
        if ((v53 & 0x8000000000000000) == 0 && sub_1DD23E7B8((uint64_t)v34, (uint64_t *)a2)) {
          goto LABEL_123;
        }
        goto LABEL_126;
      case 0xAu:
        if (v9 != 80) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x800u;
        v37 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v37 < 0)
        {
          unint64_t v38 = sub_1DD2F8A78(a2);
          if ((v43 & 1) == 0) {
            goto LABEL_126;
          }
        }
        else
        {
          unint64_t v38 = *v37;
          *(void *)a2 = v37 + 1;
        }
        *(unsigned char *)(a1 + 112) = v38 != 0;
        continue;
      case 0xBu:
        if (v9 != 88) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x400u;
        unint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v12 < 0)
        {
          *(void *)(a1 + 104) = sub_1DD2F8A78(a2);
          if ((v44 & 1) == 0) {
            goto LABEL_126;
          }
        }
        else
        {
          *(void *)(a1 + 104) = *v12;
LABEL_75:
          *(void *)a2 = v12 + 1;
        }
        continue;
      case 0xCu:
        if (v9 != 98) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x100u;
        v39 = *(void **)(a1 + 88);
        if (!v39)
        {
          v39 = sub_1DD24E800(0);
          *(void *)(a1 + 88) = v39;
        }
        v40 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v40 < 0)
        {
          int v41 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v41 < 0) {
            goto LABEL_126;
          }
        }
        else
        {
          int v41 = *v40;
          *(void *)a2 = v40 + 1;
        }
        unint64_t v54 = sub_1DD2F8298(a2, v41);
        int v46 = v54;
        if ((v54 & 0x8000000000000000) != 0 || !sub_1DD23F54C((uint64_t)v39, (char **)a2))
        {
LABEL_126:
          uint64_t v55 = 0;
          goto LABEL_125;
        }
LABEL_123:
        BOOL v11 = sub_1DD2F82D0(a2, v46);
        break;
      default:
        goto LABEL_10;
    }
LABEL_12:
    if (!v11) {
      goto LABEL_126;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  unsigned int v10 = sub_1DD2F8F70(a2, v8);
  unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
  if ((v9 & 0x100000000) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if (v9)
  {
    BOOL v11 = sub_1DD2FB80C(a2, v9, (uint64_t)v57);
    goto LABEL_12;
  }
  uint64_t v55 = 1;
LABEL_125:
  sub_1DD2F92B4(v57);
  sub_1DD24F874(&v59);
  return v55;
}

void sub_1DD2406E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24073C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 0x200) != 0)
  {
    sub_1DD2FC0E4(1, *(void *)(a1 + 96), a2);
    if ((v4 & 1) == 0)
    {
LABEL_3:
      if ((v4 & 2) == 0) {
        goto LABEL_4;
      }
      goto LABEL_26;
    }
  }
  else if ((v4 & 1) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FCDAC(2, *(void *)(a1 + 24), a2);
  if ((v4 & 2) == 0)
  {
LABEL_4:
    if ((v4 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_27;
  }
LABEL_26:
  sub_1DD2FCDAC(3, *(void *)(a1 + 32), a2);
  if ((v4 & 4) == 0)
  {
LABEL_5:
    if ((v4 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_28;
  }
LABEL_27:
  sub_1DD2FCDAC(4, *(void *)(a1 + 40), a2);
  if ((v4 & 8) == 0)
  {
LABEL_6:
    if ((v4 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_29;
  }
LABEL_28:
  sub_1DD2FCDAC(5, *(void *)(a1 + 48), a2);
  if ((v4 & 0x10) == 0)
  {
LABEL_7:
    if ((v4 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_30;
  }
LABEL_29:
  sub_1DD2FCDAC(6, *(void *)(a1 + 56), a2);
  if ((v4 & 0x20) == 0)
  {
LABEL_8:
    if ((v4 & 0x40) == 0) {
      goto LABEL_9;
    }
    goto LABEL_31;
  }
LABEL_30:
  sub_1DD2FCDAC(7, *(void *)(a1 + 64), a2);
  if ((v4 & 0x40) == 0)
  {
LABEL_9:
    if ((v4 & 0x80) == 0) {
      goto LABEL_10;
    }
    goto LABEL_32;
  }
LABEL_31:
  sub_1DD2FCDAC(8, *(void *)(a1 + 72), a2);
  if ((v4 & 0x80) == 0)
  {
LABEL_10:
    if ((v4 & 0x800) == 0) {
      goto LABEL_11;
    }
    goto LABEL_33;
  }
LABEL_32:
  sub_1DD2FCDAC(9, *(void *)(a1 + 80), a2);
  if ((v4 & 0x800) == 0)
  {
LABEL_11:
    if ((v4 & 0x400) == 0) {
      goto LABEL_12;
    }
    goto LABEL_34;
  }
LABEL_33:
  sub_1DD2FC5BC(10, *(unsigned __int8 *)(a1 + 112), a2);
  if ((v4 & 0x400) == 0)
  {
LABEL_12:
    if ((v4 & 0x100) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_34:
  sub_1DD2FC0E4(11, *(void *)(a1 + 104), a2);
  if ((v4 & 0x100) != 0) {
LABEL_13:
  }
    sub_1DD2FCDAC(12, *(void *)(a1 + 88), a2);
LABEL_14:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD2408E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  int v5 = *(_DWORD *)(a1 + 16);
  if (!(_BYTE)v5) {
    goto LABEL_17;
  }
  if (v5)
  {
    uint64_t v8 = sub_1DD23BAE0(*(void *)(a1 + 24));
    v4 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6) + 1;
    int v5 = *(_DWORD *)(a1 + 16);
    if ((v5 & 2) == 0)
    {
LABEL_10:
      if ((v5 & 4) == 0) {
        goto LABEL_11;
      }
      goto LABEL_27;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_10;
  }
  uint64_t v9 = sub_1DD23C158(*(void *)(a1 + 32));
  v4 += v9 + ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 4) == 0)
  {
LABEL_11:
    if ((v5 & 8) == 0) {
      goto LABEL_12;
    }
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v10 = sub_1DD23CA84(*(void *)(a1 + 40));
  v4 += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 8) == 0)
  {
LABEL_12:
    if ((v5 & 0x10) == 0) {
      goto LABEL_13;
    }
    goto LABEL_29;
  }
LABEL_28:
  uint64_t v11 = sub_1DD23D5A0(*(void *)(a1 + 48));
  v4 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x10) == 0)
  {
LABEL_13:
    if ((v5 & 0x20) == 0) {
      goto LABEL_14;
    }
LABEL_30:
    uint64_t v13 = sub_1DD23E49C(*(void *)(a1 + 64));
    v4 += v13 + ((9 * (__clz(v13 | 1) ^ 0x1F) + 73) >> 6) + 1;
    int v5 = *(_DWORD *)(a1 + 16);
    if ((v5 & 0x40) == 0)
    {
LABEL_15:
      if ((v5 & 0x80) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
    goto LABEL_31;
  }
LABEL_29:
  uint64_t v12 = sub_1DD23DD90(*(void *)(a1 + 56));
  v4 += v12 + ((9 * (__clz(v12 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x20) != 0) {
    goto LABEL_30;
  }
LABEL_14:
  if ((v5 & 0x40) == 0) {
    goto LABEL_15;
  }
LABEL_31:
  uint64_t v14 = sub_1DD23F298(*(void *)(a1 + 72));
  v4 += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80) != 0)
  {
LABEL_16:
    uint64_t v6 = sub_1DD23EC6C(*(void *)(a1 + 80));
    v4 += v6 + ((9 * (__clz(v6 | 1) ^ 0x1F) + 73) >> 6) + 1;
    int v5 = *(_DWORD *)(a1 + 16);
  }
LABEL_17:
  if ((v5 & 0xF00) == 0) {
    goto LABEL_24;
  }
  if ((v5 & 0x100) != 0)
  {
    uint64_t v15 = sub_1DD23F870(*(void *)(a1 + 88));
    v4 += v15 + ((9 * (__clz(v15 | 1) ^ 0x1F) + 73) >> 6) + 1;
    int v5 = *(_DWORD *)(a1 + 16);
    if ((v5 & 0x200) == 0)
    {
LABEL_20:
      if ((v5 & 0x400) == 0) {
        goto LABEL_22;
      }
      goto LABEL_21;
    }
  }
  else if ((v5 & 0x200) == 0)
  {
    goto LABEL_20;
  }
  v4 += ((9 * (__clz(*(void *)(a1 + 96) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v5 & 0x400) != 0) {
LABEL_21:
  }
    v4 += ((9 * (__clz(*(void *)(a1 + 104) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_22:
  if ((v5 & 0x800) != 0) {
    v4 += 2;
  }
LABEL_24:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

std::string *sub_1DD240BA8(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if (!(_BYTE)v5) {
    goto LABEL_61;
  }
  if (v5)
  {
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
    data = (std::string *)v3[1].__r_.__value_.__l.__data_;
    if (!data)
    {
      data = (std::string *)sub_1DD24E360(0);
      v3[1].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
    }
    if (*(void *)(a2 + 24)) {
      uint64_t v7 = *(void **)(a2 + 24);
    }
    else {
      uint64_t v7 = qword_1EAB1F588;
    }
    uint64_t result = sub_1DD23BBB8(data, (uint64_t)v7);
    if ((v5 & 2) == 0)
    {
LABEL_6:
      if ((v5 & 4) == 0) {
        goto LABEL_7;
      }
      goto LABEL_25;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_6;
  }
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 2u;
  std::string::size_type size = (std::string *)v3[1].__r_.__value_.__l.__size_;
  if (!size)
  {
    std::string::size_type size = (std::string *)sub_1DD24E3F4(0);
    v3[1].__r_.__value_.__l.__size_ = (std::string::size_type)size;
  }
  if (*(void *)(a2 + 32)) {
    uint64_t v9 = *(void **)(a2 + 32);
  }
  else {
    uint64_t v9 = qword_1EAB1F448;
  }
  uint64_t result = sub_1DD23C1C4(size, (uint64_t)v9);
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0) {
      goto LABEL_8;
    }
    goto LABEL_31;
  }
LABEL_25:
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 4u;
  uint64_t v10 = (std::string *)v3[1].__r_.__value_.__r.__words[2];
  if (!v10)
  {
    uint64_t v10 = (std::string *)sub_1DD24E488(0);
    v3[1].__r_.__value_.__r.__words[2] = (std::string::size_type)v10;
  }
  if (*(void *)(a2 + 40)) {
    uint64_t v11 = *(void **)(a2 + 40);
  }
  else {
    uint64_t v11 = qword_1EAB1F478;
  }
  uint64_t result = sub_1DD23CC0C(v10, (uint64_t)v11);
  if ((v5 & 8) == 0)
  {
LABEL_8:
    if ((v5 & 0x10) == 0) {
      goto LABEL_9;
    }
    goto LABEL_37;
  }
LABEL_31:
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 8u;
  uint64_t v12 = (std::string *)v3[2].__r_.__value_.__l.__data_;
  if (!v12)
  {
    uint64_t v12 = (std::string *)sub_1DD24E51C(0);
    v3[2].__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
  }
  if (*(void *)(a2 + 48)) {
    uint64_t v13 = *(void **)(a2 + 48);
  }
  else {
    uint64_t v13 = &unk_1EAB1F3A0;
  }
  uint64_t result = sub_1DD23D63C(v12, (uint64_t)v13);
  if ((v5 & 0x10) == 0)
  {
LABEL_9:
    if ((v5 & 0x20) == 0) {
      goto LABEL_10;
    }
LABEL_43:
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 0x20u;
    char v16 = (std::string *)v3[2].__r_.__value_.__r.__words[2];
    if (!v16)
    {
      char v16 = (std::string *)sub_1DD24E644(0);
      v3[2].__r_.__value_.__r.__words[2] = (std::string::size_type)v16;
    }
    if (*(void *)(a2 + 64)) {
      char v17 = *(void **)(a2 + 64);
    }
    else {
      char v17 = qword_1EAB1F360;
    }
    uint64_t result = sub_1DD23E544(v16, (uint64_t)v17);
    if ((v5 & 0x40) == 0)
    {
LABEL_11:
      if ((v5 & 0x80) == 0) {
        goto LABEL_61;
      }
      goto LABEL_55;
    }
    goto LABEL_49;
  }
LABEL_37:
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 0x10u;
  uint64_t v14 = (std::string *)v3[2].__r_.__value_.__l.__size_;
  if (!v14)
  {
    uint64_t v14 = (std::string *)sub_1DD24E5B0(0);
    v3[2].__r_.__value_.__l.__size_ = (std::string::size_type)v14;
  }
  if (*(void *)(a2 + 56)) {
    uint64_t v15 = *(void **)(a2 + 56);
  }
  else {
    uint64_t v15 = qword_1EAB1F510;
  }
  uint64_t result = sub_1DD23DEA4(v14, (uint64_t)v15);
  if ((v5 & 0x20) != 0) {
    goto LABEL_43;
  }
LABEL_10:
  if ((v5 & 0x40) == 0) {
    goto LABEL_11;
  }
LABEL_49:
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= 0x40u;
  int v18 = (std::string *)v3[3].__r_.__value_.__l.__data_;
  if (!v18)
  {
    int v18 = (std::string *)sub_1DD24E76C(0);
    v3[3].__r_.__value_.__r.__words[0] = (std::string::size_type)v18;
  }
  if (*(void *)(a2 + 72)) {
    uint64_t v19 = *(void **)(a2 + 72);
  }
  else {
    uint64_t v19 = qword_1EAB1F380;
  }
  uint64_t result = sub_1DD23F304(v18, (uint64_t)v19);
  if ((v5 & 0x80) != 0)
  {
LABEL_55:
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 0x80u;
    long long v20 = (std::string *)v3[3].__r_.__value_.__l.__size_;
    if (!v20)
    {
      long long v20 = (std::string *)sub_1DD24E6D8(0);
      v3[3].__r_.__value_.__l.__size_ = (std::string::size_type)v20;
    }
    if (*(void *)(a2 + 80)) {
      int v21 = *(void **)(a2 + 80);
    }
    else {
      int v21 = &unk_1EAB1F618;
    }
    uint64_t result = sub_1DD23EDE4(v20, (uint64_t)v21);
  }
LABEL_61:
  if ((v5 & 0xF00) == 0) {
    return result;
  }
  if ((v5 & 0x100) != 0)
  {
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 0x100u;
    int v22 = (std::string *)v3[3].__r_.__value_.__r.__words[2];
    if (!v22)
    {
      int v22 = (std::string *)sub_1DD24E800(0);
      v3[3].__r_.__value_.__r.__words[2] = (std::string::size_type)v22;
    }
    if (*(void *)(a2 + 88)) {
      char v23 = *(void **)(a2 + 88);
    }
    else {
      char v23 = qword_1EAB1F658;
    }
    uint64_t result = sub_1DD23BBB8(v22, (uint64_t)v23);
    if ((v5 & 0x200) == 0)
    {
LABEL_64:
      if ((v5 & 0x400) == 0) {
        goto LABEL_65;
      }
LABEL_76:
      v3[4].__r_.__value_.__l.__size_ = *(void *)(a2 + 104);
      if ((v5 & 0x800) == 0) {
        goto LABEL_67;
      }
      goto LABEL_66;
    }
  }
  else if ((v5 & 0x200) == 0)
  {
    goto LABEL_64;
  }
  v3[4].__r_.__value_.__r.__words[0] = *(void *)(a2 + 96);
  if ((v5 & 0x400) != 0) {
    goto LABEL_76;
  }
LABEL_65:
  if ((v5 & 0x800) != 0) {
LABEL_66:
  }
    v3[4].__r_.__value_.__s.__data_[16] = *(unsigned char *)(a2 + 112);
LABEL_67:
  LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
  return result;
}

std::string *sub_1DD240E54(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD23FE68((uint64_t)result);
    return sub_1DD240BA8(v4, a2);
  }
  return result;
}

uint64_t sub_1DD240EA0()
{
  return 1;
}

__n128 sub_1DD240EA8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = v2;
  uint64_t v3 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v3;
  uint64_t v4 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v4;
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(void *)(a2 + 48) = v5;
  uint64_t v6 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v6;
  uint64_t v7 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = v7;
  uint64_t v8 = *(void *)(a1 + 72);
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v8;
  uint64_t v9 = *(void *)(a1 + 80);
  *(void *)(a1 + 80) = *(void *)(a2 + 80);
  *(void *)(a2 + 80) = v9;
  uint64_t v10 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(void *)(a2 + 88) = v10;
  uint64_t v11 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = *(void *)(a2 + 96);
  *(void *)(a2 + 96) = v11;
  uint64_t v12 = *(void *)(a1 + 104);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = v12;
  LOBYTE(v12) = *(unsigned char *)(a1 + 112);
  *(unsigned char *)(a1 + 112) = *(unsigned char *)(a2 + 112);
  *(unsigned char *)(a2 + 112) = v12;
  LODWORD(v12) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v12;
  uint64_t v14 = (unint64_t *)(a1 + 8);
  unint64_t v13 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(a2 + 8);
  uint64_t v15 = (unint64_t *)(a2 + 8);
  uint64_t v16 = v17;
  if (v13)
  {
    if ((v16 & 1) == 0)
    {
      sub_1DD24F7CC(v15);
      unint64_t v18 = v23;
      unint64_t v13 = *v14;
      if (*v14) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
LABEL_5:
    unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFFELL;
    if (v13)
    {
LABEL_6:
      uint64_t v19 = (__n128 *)(v13 & 0xFFFFFFFFFFFFFFFELL);
LABEL_7:
      unint64_t v20 = v19[1].n128_u64[0];
      __n128 result = *v19;
      unint64_t v22 = *(void *)(v18 + 16);
      *uint64_t v19 = *(__n128 *)v18;
      v19[1].n128_u64[0] = v22;
      *(__n128 *)unint64_t v18 = result;
      *(void *)(v18 + 16) = v20;
      return result;
    }
LABEL_9:
    sub_1DD24F7CC(v14);
    goto LABEL_7;
  }
  if (v16) {
    goto LABEL_5;
  }
  return result;
}

void *sub_1DD241004@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.ColumnStatistics");
}

uint64_t sub_1DD241014(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BC18;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  if (atomic_load_explicit(dword_1EC8ABF50, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF50);
  }
  *(void *)(a1 + 48) = 0;
  return a1;
}

void sub_1DD241090(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v1 + 24);
  sub_1DD24F770(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2410B0(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BC18;
  if ((_UNKNOWN *)a1 != &unk_1EAB1F6D0)
  {
    uint64_t v2 = *(void *)(a1 + 48);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  if (*(int *)(a1 + 28) >= 1)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    if (v3)
    {
      if (!*v3) {
        operator delete(v3);
      }
    }
  }
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD241158(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD2410B0(a1);
  operator delete(v1);
}

void sub_1DD241180(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD23FE68(*(void *)(a1 + 48));
  }
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  *(_DWORD *)(v2 + 8) = 0;
  if (v3)
  {
    sub_1DD24FC0C((unint64_t *)v2);
  }
}

uint64_t sub_1DD2411E0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v30 = (uint64_t *)(a1 + 8);
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v32 = *(void *)(v5 + 16);
    long long v31 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v29, (uint64_t)&v31);
  sub_1DD2F9178((uint64_t)v28, (uint64_t)v29, 0);
  while (1)
  {
    uint64_t v7 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if (*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_23;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_23;
    }
LABEL_10:
    if (v9 >> 3 == 2) {
      break;
    }
    if (v9 >> 3 != 1) {
      goto LABEL_23;
    }
    if (v9 == 8)
    {
      char v16 = sub_1DD23D24C(1, 0xAu, (char **)a2, a1 + 24);
LABEL_25:
      if ((v16 & 1) == 0) {
        goto LABEL_46;
      }
    }
    else
    {
      if (v9 != 10) {
        goto LABEL_23;
      }
      uint64_t v11 = *(char **)a2;
      if (*(void *)a2 >= *(void *)(a2 + 8) || *v11 < 0)
      {
        int v12 = sub_1DD2F8D1C((unsigned __int8 **)a2);
        if (v12 < 0) {
          goto LABEL_46;
        }
      }
      else
      {
        int v12 = *v11;
        *(void *)a2 = v11 + 1;
      }
      int v19 = sub_1DD2F81D8(a2, v12);
      while ((int)sub_1DD2F8334((_DWORD *)a2) >= 1)
      {
        unint64_t v20 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v20 < 0)
        {
          unint64_t v22 = sub_1DD2F8A78(a2);
          if ((v23 & 1) == 0) {
            goto LABEL_46;
          }
          unint64_t v21 = v22;
        }
        else
        {
          unint64_t v21 = *v20;
          *(void *)a2 = v20 + 1;
        }
        int v24 = *(_DWORD *)(a1 + 24);
        if (v24 == *(_DWORD *)(a1 + 28))
        {
          sub_1DD24FA20((unsigned int *)(a1 + 24), v24 + 1);
          int v24 = *(_DWORD *)(a1 + 24);
        }
        uint64_t v25 = *(void *)(a1 + 32);
        *(_DWORD *)(a1 + 24) = v24 + 1;
        *(void *)(v25 + 8 * v24 + 8) = v21;
      }
      sub_1DD2F8250(a2, v19);
    }
  }
  if (v9 != 18)
  {
LABEL_23:
    if (!v9)
    {
      uint64_t v26 = 1;
      goto LABEL_45;
    }
    char v16 = sub_1DD2FB80C(a2, v9, (uint64_t)v28);
    goto LABEL_25;
  }
  *(_DWORD *)(a1 + 16) |= 1u;
  unint64_t v13 = *(void **)(a1 + 48);
  if (!v13)
  {
    unint64_t v13 = sub_1DD24E894(0);
    *(void *)(a1 + 48) = v13;
  }
  uint64_t v14 = *(char **)a2;
  if (*(void *)a2 >= *(void *)(a2 + 8) || *v14 < 0)
  {
    int v15 = sub_1DD2F8D1C((unsigned __int8 **)a2);
    if (v15 < 0) {
      goto LABEL_46;
    }
  }
  else
  {
    int v15 = *v14;
    *(void *)a2 = v14 + 1;
  }
  unint64_t v17 = sub_1DD2F8298(a2, v15);
  int v18 = v17;
  if ((v17 & 0x8000000000000000) == 0 && sub_1DD23FF78((uint64_t)v13, a2))
  {
    char v16 = sub_1DD2F82D0(a2, v18);
    goto LABEL_25;
  }
LABEL_46:
  uint64_t v26 = 0;
LABEL_45:
  sub_1DD2F92B4(v28);
  sub_1DD24F874(&v30);
  return v26;
}

void sub_1DD241498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2414C4(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a1 + 24) >= 1)
  {
    if (*(int *)(a2 + 16) < 5)
    {
      sub_1DD2F9508(a2, 0xAu);
      int v4 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      *(unsigned char *)(*(void *)(a2 + 8))++ = 10;
      int v4 = *(_DWORD *)(a2 + 16) - 1;
      *(_DWORD *)(a2 + 16) = v4;
    }
    unsigned int v5 = *(_DWORD *)(a1 + 40);
    if (v4 < 5)
    {
      sub_1DD2F9508(a2, v5);
    }
    else
    {
      uint64_t v6 = *(void *)(a2 + 8);
      if (v5 < 0x80)
      {
        unsigned int v8 = *(_DWORD *)(a1 + 40);
        uint64_t v7 = *(unsigned char **)(a2 + 8);
      }
      else
      {
        uint64_t v7 = *(unsigned char **)(a2 + 8);
        do
        {
          *v7++ = v5 | 0x80;
          unsigned int v8 = v5 >> 7;
          unsigned int v9 = v5 >> 14;
          v5 >>= 7;
        }
        while (v9);
      }
      unsigned char *v7 = v8;
      int v10 = v7 - v6 + 1;
      *(void *)(a2 + 8) += v10;
      *(_DWORD *)(a2 + 16) -= v10;
    }
    uint64_t v11 = *(unsigned int *)(a1 + 24);
    if ((int)v11 >= 1)
    {
      for (uint64_t i = 0; i != v11; ++i)
      {
        unint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8 * i + 8);
        if (*(int *)(a2 + 16) < 10)
        {
          sub_1DD2F9564(a2, v13);
        }
        else
        {
          uint64_t v14 = *(void *)(a2 + 8);
          if (v13 < 0x80)
          {
            unint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8 * i + 8);
            int v15 = *(unsigned char **)(a2 + 8);
          }
          else
          {
            int v15 = *(unsigned char **)(a2 + 8);
            do
            {
              *v15++ = v13 | 0x80;
              unint64_t v16 = v13 >> 7;
              unint64_t v17 = v13 >> 14;
              v13 >>= 7;
            }
            while (v17);
          }
          *int v15 = v16;
          int v18 = v15 - v14 + 1;
          *(void *)(a2 + 8) += v18;
          *(_DWORD *)(a2 + 16) -= v18;
        }
      }
    }
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD2FCDAC(2, *(void *)(a1 + 48), a2);
  }
  uint64_t v19 = *(void *)(a1 + 8);
  if (v19) {
    unint64_t v20 = (char *)(v19 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v20 = (char *)&qword_1EAB1F7D8;
  }
  if (v20[23] < 0) {
    unint64_t v20 = *(char **)v20;
  }
  if (v19) {
    unint64_t v21 = (uint64_t *)(v19 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v21 = &qword_1EAB1F7D8;
  }
  if (*((char *)v21 + 23) < 0) {
    uint64_t v22 = v21[1];
  }
  else {
    LODWORD(v22) = *((unsigned __int8 *)v21 + 23);
  }
  return sub_1DD2F92E0(a2, v20, v22);
}

uint64_t sub_1DD2416BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    char v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = sub_1DD2FD058((unsigned int *)(a1 + 24));
  uint64_t v6 = 11;
  uint64_t v7 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((int)v5 >= 0) {
    uint64_t v6 = v7;
  }
  uint64_t v8 = v6 + v4;
  if (v5) {
    int v9 = v5;
  }
  else {
    int v9 = 0;
  }
  if (!v5) {
    uint64_t v8 = v4;
  }
  *(_DWORD *)(a1 + 40) = v9;
  uint64_t v10 = v8 + v5;
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v11 = sub_1DD2408E8(*(void *)(a1 + 48));
    v10 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }
  *(_DWORD *)(a1 + 20) = v10;
  return v10;
}

std::string *sub_1DD241790(std::string *result, uint64_t a2)
{
  char v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t data_low = SLODWORD(v3[1].__r_.__value_.__l.__data_);
    sub_1DD24FA20((unsigned int *)&v3[1], data_low + v5);
    std::string::size_type size = v3[1].__r_.__value_.__l.__size_;
    LODWORD(v3[1].__r_.__value_.__l.__data_) += *(_DWORD *)(a2 + 24);
    __n128 result = (std::string *)memcpy((void *)(size + 8 * data_low + 8), (const void *)(*(void *)(a2 + 32) + 8), 8 * *(int *)(a2 + 24));
  }
  if (*(unsigned char *)(a2 + 16))
  {
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
    data = (std::string *)v3[2].__r_.__value_.__l.__data_;
    if (!data)
    {
      data = (std::string *)sub_1DD24E894(0);
      v3[2].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
    }
    if (*(void *)(a2 + 48)) {
      int v9 = *(void **)(a2 + 48);
    }
    else {
      int v9 = &unk_1EAB1F3D0;
    }
    return sub_1DD240BA8(data, (uint64_t)v9);
  }
  return result;
}

std::string *sub_1DD241874(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD241180((uint64_t)result);
    return sub_1DD241790(v4, a2);
  }
  return result;
}

uint64_t sub_1DD2418C0()
{
  return 1;
}

void *sub_1DD2418C8@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.RowIndexEntry");
}

uint64_t sub_1DD2418D8(uint64_t a1)
{
  *(void *)a1 = &unk_1F387CB18;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8ABF20, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF20);
  }
  return a1;
}

void sub_1DD241958(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24197C(void *a1)
{
  *a1 = &unk_1F387CB18;
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD2419D0(void *a1)
{
  uint64_t v1 = sub_1DD24197C(a1);
  operator delete(v1);
}

void sub_1DD2419F8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    char v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD241180(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6)
  {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD241A78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v27 = (uint64_t *)(a1 + 8);
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v29 = *(void *)(v5 + 16);
    long long v28 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v26, (uint64_t)&v28);
  sub_1DD2F9178((uint64_t)v25, (uint64_t)v26, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if ((char)*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          break;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      break;
    }
LABEL_10:
    if (v9 != 10 || (v9 & 0xFFFFFFF8) != 8) {
      break;
    }
    unint64_t v13 = *(int **)(a1 + 40);
    if (!v13)
    {
      int v15 = *(_DWORD *)(a1 + 36);
LABEL_21:
      sub_1DD2FABC8(a1 + 24, v15 + 1);
      unint64_t v13 = *(int **)(a1 + 40);
      int v15 = *v13;
      goto LABEL_22;
    }
    uint64_t v14 = *(int *)(a1 + 32);
    int v15 = *v13;
    if ((int)v14 < *v13)
    {
      *(_DWORD *)(a1 + 32) = v14 + 1;
      unint64_t v16 = *(void **)&v13[2 * v14 + 2];
      goto LABEL_23;
    }
    if (v15 == *(_DWORD *)(a1 + 36)) {
      goto LABEL_21;
    }
LABEL_22:
    *unint64_t v13 = v15 + 1;
    unint64_t v16 = sub_1DD24E928(*(void *)(a1 + 24));
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(int *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(void *)(v17 + 8 * v18 + 8) = v16;
LABEL_23:
    uint64_t v19 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || *v19 < 0)
    {
      int v20 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v20 < 0) {
        goto LABEL_31;
      }
    }
    else
    {
      int v20 = *v19;
      *(void *)a2 = v19 + 1;
    }
    unint64_t v21 = sub_1DD2F8298(a2, v20);
    int v22 = v21;
    if ((v21 & 0x8000000000000000) != 0 || !sub_1DD2411E0((uint64_t)v16, a2))
    {
LABEL_31:
      uint64_t v23 = 0;
      goto LABEL_33;
    }
    BOOL v12 = sub_1DD2F82D0(a2, v22);
LABEL_30:
    if (!v12) {
      goto LABEL_31;
    }
  }
  if (v9)
  {
    BOOL v12 = sub_1DD2FB80C(a2, v9, (uint64_t)v25);
    goto LABEL_30;
  }
  uint64_t v23 = 1;
LABEL_33:
  sub_1DD2F92B4(v25);
  sub_1DD24F874(&v27);
  return v23;
}

void sub_1DD241C88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD241CB0(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6) {
    uint64_t v7 = (char *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = (char *)&qword_1EAB1F7D8;
  }
  if (v7[23] < 0) {
    uint64_t v7 = *(char **)v7;
  }
  if (v6) {
    uint64_t v8 = (uint64_t *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v8 = &qword_1EAB1F7D8;
  }
  if (*((char *)v8 + 23) < 0) {
    uint64_t v9 = v8[1];
  }
  else {
    LODWORD(v9) = *((unsigned __int8 *)v8 + 23);
  }
  return sub_1DD2F92E0(a2, v7, v9);
}

uint64_t sub_1DD241D68(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    char v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2416BC(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  *(_DWORD *)(a1 + 20) = v6;
  return v6;
}

std::string *sub_1DD241E14(std::string *result, uint64_t a2)
{
  char v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], v5);
    __n128 result = sub_1DD24FCE0(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  return result;
}

std::string *sub_1DD241EB8(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD2419F8((uint64_t)result);
    return sub_1DD241E14(v4, a2);
  }
  return result;
}

uint64_t sub_1DD241F04()
{
  return 1;
}

void *sub_1DD241F0C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.RowIndex");
}

uint64_t sub_1DD241F1C(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BA38;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  if (atomic_load_explicit(dword_1EC8ABF38, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF38);
  }
  *(void *)(a1 + 40) = &qword_1EAB1F7D8;
  *(_DWORD *)(a1 + 48) = 0;
  return a1;
}

void sub_1DD241FA4(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v1 + 24);
  sub_1DD24F770(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD241FC0(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BA38;
  sub_1DD24202C(a1);
  if (*(int *)(a1 + 28) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD24202C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if ((uint64_t *)v1 != &qword_1EAB1F7D8 && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete((void *)v1);
  }
}

void sub_1DD242094(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD241FC0(a1);
  operator delete(v1);
}

void sub_1DD2420BC(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v1 = *(void *)(a1 + 40);
    if (*(char *)(v1 + 23) < 0)
    {
      **(unsigned char **)uint64_t v1 = 0;
      *(void *)(v1 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v1 = 0;
      *(unsigned char *)(v1 + 23) = 0;
    }
  }
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  *(_DWORD *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  if (v3) {
    sub_1DD24FC0C((unint64_t *)v2);
  }
}

uint64_t sub_1DD242104(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v38 = (uint64_t *)(a1 + 8);
  long long v39 = 0uLL;
  uint64_t v40 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v40 = *(void *)(v5 + 16);
    long long v39 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v37, (uint64_t)&v39);
  sub_1DD2F9178((uint64_t)v36, (uint64_t)v37, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
LABEL_4:
        int v7 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          uint64_t v8 = 0;
LABEL_9:
          unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
          unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_40;
          }
          goto LABEL_10;
        }
        uint64_t v8 = *v7;
        if (*v7 < 1) {
          goto LABEL_9;
        }
        *a2 = (uint64_t)(v7 + 1);
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_40;
        }
LABEL_10:
        unsigned int v11 = v9 >> 3;
        if (v9 >> 3 == 3)
        {
          if (v9 == 26)
          {
            *(_DWORD *)(a1 + 16) |= 1u;
            int v15 = *(std::string **)(a1 + 40);
            if (v15 == (std::string *)&qword_1EAB1F7D8)
            {
              sub_1DD24F908((void *)(a1 + 40), (uint64_t)&qword_1EAB1F7D8);
              int v15 = *(std::string **)(a1 + 40);
            }
            BOOL v16 = sub_1DD2FCF1C(a2, v15);
            goto LABEL_42;
          }
          goto LABEL_40;
        }
        if (v11 == 2) {
          break;
        }
        if (v11 != 1 || v9 != 8) {
          goto LABEL_40;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        unint64_t v13 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v14 = 0;
          goto LABEL_50;
        }
        int v14 = *v13;
        if (*v13 < 0)
        {
LABEL_50:
          uint64_t v33 = sub_1DD2F8C30(a2, v14);
          *(_DWORD *)(a1 + 48) = v33;
          if (v33 < 0) {
            goto LABEL_53;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 48) = v14;
          *a2 = (uint64_t)(v13 + 1);
        }
      }
      if (v9 == 18)
      {
        BOOL v16 = sub_1DD242474((uint64_t)a2, (signed int *)(a1 + 24));
        goto LABEL_42;
      }
      if (v9 != 17) {
        break;
      }
      uint64_t v41 = 0;
      uint64_t v17 = (uint64_t *)*a2;
      if ((int)(*((_DWORD *)a2 + 2) - *a2) < 8)
      {
        if (!sub_1DD2F89E4((uint64_t)a2, &v41))
        {
LABEL_53:
          uint64_t v34 = 0;
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v41 = *v17;
        *a2 = (uint64_t)(v17 + 1);
      }
      int v18 = *(_DWORD *)(a1 + 24);
      if (v18 == *(_DWORD *)(a1 + 28))
      {
        sub_1DD24FA20((unsigned int *)(a1 + 24), v18 + 1);
        int v18 = *(_DWORD *)(a1 + 24);
      }
      uint64_t v19 = v41;
      uint64_t v20 = *(void *)(a1 + 32);
      int v21 = v18 + 1;
      *(_DWORD *)(a1 + 24) = v18 + 1;
      *(void *)(v20 + 8 * v18 + 8) = v19;
      uint64_t v22 = *a2;
      LODWORD(v20) = *((_DWORD *)a2 + 2);
      unint64_t v23 = v20 - *a2;
      if ((int)(v20 - *a2) > 0)
      {
        LODWORD(v24) = *(_DWORD *)(a1 + 28) - v21;
        signed int v25 = v23 / 9;
        if ((int)(v23 / 9) >= (int)v24) {
          signed int v25 = *(_DWORD *)(a1 + 28) - v21;
        }
        if (v25 >= 1)
        {
          uint64_t v26 = 0;
          int v27 = v18 + 2;
          uint64_t v28 = 8 * v21 + 8;
          if ((uint64_t)((v23 * (unsigned __int128)0x1C71C71C71C71C72uLL) >> 64) < (int)v24) {
            uint64_t v24 = (v23 * (unsigned __int128)0x1C71C71C71C71C72uLL) >> 64;
          }
          uint64_t v29 = *a2;
          while (*(unsigned char *)v29 == 17)
          {
            uint64_t v41 = *(void *)(v29 + 1);
            uint64_t v30 = v41;
            uint64_t v31 = *(void *)(a1 + 32);
            *(_DWORD *)(a1 + 24) = v27 + v26;
            *(void *)(v31 + v28 + 8 * v26++) = v30;
            v29 += 9;
            if (v24 == v26) {
              goto LABEL_46;
            }
          }
          signed int v25 = v26;
          if (!v26) {
            goto LABEL_4;
          }
LABEL_46:
          unsigned int v32 = 9 * v25;
          if (9 * v25 <= (int)v23) {
            *a2 = v22 + v32;
          }
          else {
            sub_1DD2F843C((uint64_t)a2, v32, v23);
          }
        }
      }
    }
LABEL_40:
    if (!v9) {
      break;
    }
    BOOL v16 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v36);
LABEL_42:
    if (!v16) {
      goto LABEL_53;
    }
  }
  uint64_t v34 = 1;
LABEL_55:
  sub_1DD2F92B4(v36);
  sub_1DD24F874(&v38);
  return v34;
}

void sub_1DD24244C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

BOOL sub_1DD242474(uint64_t a1, signed int *a2)
{
  uint64_t v4 = *(unsigned __int8 **)a1;
  if (*(void *)a1 >= *(void *)(a1 + 8) || (char)*v4 < 0)
  {
    unsigned int v5 = sub_1DD2F8D1C((unsigned __int8 **)a1);
    if ((v5 & 0x80000000) != 0) {
      return 0;
    }
  }
  else
  {
    unsigned int v5 = *v4;
    *(void *)a1 = v4 + 1;
  }
  if ((v5 & 7) != 0) {
    return 0;
  }
  signed int v7 = *a2;
  unsigned int v8 = v5 >> 3;
  int v9 = sub_1DD2F8370((_DWORD *)a1);
  int v10 = sub_1DD2F8334((_DWORD *)a1);
  if (v10 >= v9) {
    int v11 = v9;
  }
  else {
    int v11 = v10;
  }
  if (v9 == -1) {
    int v11 = v10;
  }
  if (v11 < (uint64_t)v5)
  {
    uint64_t v21 = 0;
    if (v5 >= 8)
    {
      if (v8 <= 1) {
        int v12 = 1;
      }
      else {
        int v12 = v5 >> 3;
      }
      do
      {
        unint64_t v13 = *(unsigned __int8 **)a1;
        if ((int)(*(_DWORD *)(a1 + 8) - *(void *)a1) < 8)
        {
          BOOL result = sub_1DD2F89E4(a1, &v21);
          if (!result) {
            return result;
          }
        }
        else
        {
          uint64_t v21 = *(void *)v13;
          *(void *)a1 = v13 + 8;
        }
        signed int v14 = *a2;
        if (*a2 == a2[1])
        {
          sub_1DD24FA20((unsigned int *)a2, v14 + 1);
          signed int v14 = *a2;
        }
        uint64_t v15 = v21;
        uint64_t v16 = *((void *)a2 + 1);
        *a2 = v14 + 1;
        *(void *)(v16 + 8 * v14 + 8) = v15;
        --v12;
      }
      while (v12);
    }
    return 1;
  }
  signed int v17 = v7 + v8;
  if (*a2 < (int)(v7 + v8))
  {
    sub_1DD24FA20((unsigned int *)a2, v7 + v8);
    uint64_t v18 = *a2;
    uint64_t v19 = 8 * v17 - 8 * v18;
    if (v19 >= 1) {
      bzero((void *)(*((void *)a2 + 1) + 8 + 8 * v18), 8 * (((unint64_t)v19 >> 3) - ((unint64_t)v19 > 7)) + 8);
    }
  }
  *a2 = v17;
  if (a2[1] < 1) {
    uint64_t v20 = 0;
  }
  else {
    uint64_t v20 = *((void *)a2 + 1) + 8;
  }
  if (sub_1DD2F8710((const void **)a1, (char *)(v20 + 8 * v7), v5)) {
    return 1;
  }
  if (*a2 < 1) {
    return 0;
  }
  BOOL result = 0;
  *a2 = v7;
  return result;
}

uint64_t sub_1DD242660(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 2) != 0) {
    sub_1DD2FBFC4(1, *(_DWORD *)(a1 + 48), a2);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 24);
  if ((int)v5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 8 * v5;
    do
    {
      sub_1DD2FC44C(2, *(void *)(*(void *)(a1 + 32) + v6 + 8), a2);
      v6 += 8;
    }
    while (v7 != v6);
  }
  if (v4) {
    sub_1DD2FCBE0(3, *(void *)(a1 + 40), a2);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8) {
    int v9 = (char *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v9 = (char *)&qword_1EAB1F7D8;
  }
  if (v9[23] < 0) {
    int v9 = *(char **)v9;
  }
  if (v8) {
    int v10 = (uint64_t *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v10 = &qword_1EAB1F7D8;
  }
  if (*((char *)v10 + 23) < 0) {
    uint64_t v11 = v10[1];
  }
  else {
    LODWORD(v11) = *((unsigned __int8 *)v10 + 23);
  }
  return sub_1DD2F92E0(a2, v9, v11);
}

uint64_t sub_1DD242754(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  uint64_t v4 = v3 + *(unsigned int *)(a1 + 24) + 8 * *(unsigned int *)(a1 + 24);
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 3) != 0)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      uint64_t v7 = *(unsigned __int8 *)(v6 + 23);
      uint64_t v8 = *(void *)(v6 + 8);
      if ((v7 & 0x80u) == 0) {
        uint64_t v8 = v7;
      }
      v4 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
    if ((v5 & 2) != 0) {
      v4 += ((9 * (__clz(*(_DWORD *)(a1 + 48) | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
  }
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

void *sub_1DD242810(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(result + 1, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((int *)v3 + 6);
    sub_1DD24FA20((unsigned int *)v3 + 6, v6 + v5);
    uint64_t v7 = v3[4];
    *((_DWORD *)v3 + 6) += *(_DWORD *)(a2 + 24);
    BOOL result = memcpy((void *)(v7 + 8 * v6 + 8), (const void *)(*(void *)(a2 + 32) + 8), 8 * *(int *)(a2 + 24));
  }
  int v8 = *(_DWORD *)(a2 + 16);
  if ((v8 & 3) != 0)
  {
    if (v8)
    {
      BOOL result = v3 + 5;
      int v9 = (std::string *)v3[5];
      *((_DWORD *)v3 + 4) |= 1u;
      int v10 = *(const std::string **)(a2 + 40);
      if (v9 != v10)
      {
        if (v9 == (std::string *)&qword_1EAB1F7D8)
        {
          BOOL result = sub_1DD24F908(result, (uint64_t)v10);
          if ((v8 & 2) == 0) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }
        BOOL result = std::string::operator=(v9, v10);
      }
    }
    if ((v8 & 2) == 0)
    {
LABEL_12:
      *((_DWORD *)v3 + 4) |= v8;
      return result;
    }
LABEL_11:
    *((_DWORD *)v3 + 12) = *(_DWORD *)(a2 + 48);
    goto LABEL_12;
  }
  return result;
}

uint64_t sub_1DD242908()
{
  return 1;
}

void *sub_1DD242910@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.BloomFilter");
}

uint64_t sub_1DD242920(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BE98;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8ABF68, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF68);
  }
  return a1;
}

void sub_1DD2429A0(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD2429C4(void *a1)
{
  *a1 = &unk_1F387BE98;
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD242A18(void *a1)
{
  uint64_t v1 = sub_1DD2429C4(a1);
  operator delete(v1);
}

void sub_1DD242A40(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD2420BC(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6)
  {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD242AC0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v27 = (uint64_t *)(a1 + 8);
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v29 = *(void *)(v5 + 16);
    long long v28 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v26, (uint64_t)&v28);
  sub_1DD2F9178((uint64_t)v25, (uint64_t)v26, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if ((char)*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          break;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      break;
    }
LABEL_10:
    if (v9 != 10 || (v9 & 0xFFFFFFF8) != 8) {
      break;
    }
    unint64_t v13 = *(int **)(a1 + 40);
    if (!v13)
    {
      int v15 = *(_DWORD *)(a1 + 36);
LABEL_21:
      sub_1DD2FABC8(a1 + 24, v15 + 1);
      unint64_t v13 = *(int **)(a1 + 40);
      int v15 = *v13;
      goto LABEL_22;
    }
    uint64_t v14 = *(int *)(a1 + 32);
    int v15 = *v13;
    if ((int)v14 < *v13)
    {
      *(_DWORD *)(a1 + 32) = v14 + 1;
      uint64_t v16 = *(void **)&v13[2 * v14 + 2];
      goto LABEL_23;
    }
    if (v15 == *(_DWORD *)(a1 + 36)) {
      goto LABEL_21;
    }
LABEL_22:
    *unint64_t v13 = v15 + 1;
    uint64_t v16 = sub_1DD24EA50(*(void *)(a1 + 24));
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(int *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(void *)(v17 + 8 * v18 + 8) = v16;
LABEL_23:
    uint64_t v19 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || *v19 < 0)
    {
      int v20 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v20 < 0) {
        goto LABEL_31;
      }
    }
    else
    {
      int v20 = *v19;
      *(void *)a2 = v19 + 1;
    }
    unint64_t v21 = sub_1DD2F8298(a2, v20);
    int v22 = v21;
    if ((v21 & 0x8000000000000000) != 0 || !sub_1DD242104((uint64_t)v16, (uint64_t *)a2))
    {
LABEL_31:
      uint64_t v23 = 0;
      goto LABEL_33;
    }
    BOOL v12 = sub_1DD2F82D0(a2, v22);
LABEL_30:
    if (!v12) {
      goto LABEL_31;
    }
  }
  if (v9)
  {
    BOOL v12 = sub_1DD2FB80C(a2, v9, (uint64_t)v25);
    goto LABEL_30;
  }
  uint64_t v23 = 1;
LABEL_33:
  sub_1DD2F92B4(v25);
  sub_1DD24F874(&v27);
  return v23;
}

void sub_1DD242CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD242CF8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6) {
    uint64_t v7 = (char *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = (char *)&qword_1EAB1F7D8;
  }
  if (v7[23] < 0) {
    uint64_t v7 = *(char **)v7;
  }
  if (v6) {
    uint64_t v8 = (uint64_t *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v8 = &qword_1EAB1F7D8;
  }
  if (*((char *)v8 + 23) < 0) {
    uint64_t v9 = v8[1];
  }
  else {
    LODWORD(v9) = *((unsigned __int8 *)v8 + 23);
  }
  return sub_1DD2F92E0(a2, v7, v9);
}

uint64_t sub_1DD242DB0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD242754(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  *(_DWORD *)(a1 + 20) = v6;
  return v6;
}

std::string *sub_1DD242E5C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (void **)sub_1DD2FAAC0((uint64_t)&v3[1], v5);
    BOOL result = (std::string *)sub_1DD24FDA0((uint64_t *)&v3[1], v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2]- LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  return result;
}

uint64_t sub_1DD242F00()
{
  return 1;
}

void *sub_1DD242F08@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.BloomFilterIndex");
}

void *sub_1DD242F18(void *a1)
{
  *a1 = &unk_1F387C898;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8ABFE0, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABFE0);
  }
  a1[3] = 0;
  a1[4] = 0;
  return a1;
}

void sub_1DD242F88(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD242FA0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C898;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(_OWORD *)(a1 + 24) = *(_OWORD *)(a2 + 24);
  return a1;
}

void sub_1DD243018(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD243030(void *a1)
{
  *a1 = &unk_1F387C898;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD243074(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C898;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD2430C8(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 7) != 0)
  {
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD2430EC(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v31 = (uint64_t *)(a1 + 8);
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v33 = *(void *)(v5 + 16);
    long long v32 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v30, (uint64_t)&v32);
  sub_1DD2F9178((uint64_t)&v27, (uint64_t)v30, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          int v7 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1])
          {
            uint64_t v8 = 0;
LABEL_9:
            unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
            unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
            if ((v9 & 0x100000000) == 0) {
              goto LABEL_29;
            }
            goto LABEL_10;
          }
          uint64_t v8 = *v7;
          if (*v7 < 1) {
            goto LABEL_9;
          }
          *a2 = (uint64_t)(v7 + 1);
          unint64_t v9 = v8 | 0x100000000;
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_29;
          }
LABEL_10:
          unsigned int v11 = v9 >> 3;
          if (v9 >> 3 != 3) {
            break;
          }
          if (v9 != 24) {
            goto LABEL_29;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          int v15 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v15 & 0x80000000) == 0)
          {
            *(void *)(a1 + 32) = *v15;
            goto LABEL_28;
          }
          *(void *)(a1 + 32) = sub_1DD2F8A78((uint64_t)a2);
          if ((v17 & 1) == 0) {
            goto LABEL_51;
          }
        }
        if (v11 != 2) {
          break;
        }
        if (v9 != 16) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        int v15 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v16 = 0;
          goto LABEL_50;
        }
        int v16 = *v15;
        if (*v15 < 0)
        {
LABEL_50:
          uint64_t v24 = sub_1DD2F8C30(a2, v16);
          *(_DWORD *)(a1 + 28) = v24;
          if (v24 < 0)
          {
LABEL_51:
            uint64_t v25 = 0;
            goto LABEL_53;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 28) = v16;
LABEL_28:
          *a2 = (uint64_t)(v15 + 1);
        }
      }
      if (v11 != 1 || v9 != 8) {
        break;
      }
      unint64_t v13 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        LODWORD(v14) = 0;
      }
      else
      {
        LODWORD(v14) = *v13;
        if ((*v13 & 0x80000000) == 0)
        {
          *a2 = (uint64_t)(v13 + 1);
          goto LABEL_36;
        }
      }
      uint64_t v14 = sub_1DD2F8C30(a2, v14);
      if (v14 < 0) {
        goto LABEL_51;
      }
LABEL_36:
      if (sub_1DD23B5B4(v14))
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 24) = v14;
      }
      else
      {
        if (v29 < 5)
        {
          sub_1DD2F9508((uint64_t)&v27, 8u);
          int v18 = v29;
        }
        else
        {
          *v28++ = 8;
          int v18 = --v29;
        }
        if (v18 < 5)
        {
          sub_1DD2F9508((uint64_t)&v27, v14);
        }
        else
        {
          int v19 = (int)v28;
          if (v14 < 0x80)
          {
            LOBYTE(v21) = v14;
            int v20 = v28;
          }
          else
          {
            int v20 = v28;
            do
            {
              *v20++ = v14 | 0x80;
              unsigned int v21 = v14 >> 7;
              unsigned int v22 = v14 >> 14;
              LODWORD(v14) = v14 >> 7;
            }
            while (v22);
          }
          unsigned char *v20 = v21;
          int v23 = v20 - v19 + 1;
          v28 += v23;
          v29 -= v23;
        }
      }
    }
LABEL_29:
    if (!v9) {
      break;
    }
    if (!sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)&v27)) {
      goto LABEL_51;
    }
  }
  uint64_t v25 = 1;
LABEL_53:
  sub_1DD2F92B4(&v27);
  sub_1DD24F874(&v31);
  return v25;
}

void sub_1DD2433D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD243400(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FBEA4(1, *(_DWORD *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FBFC4(2, *(_DWORD *)(a1 + 28), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC0E4(3, *(void *)(a1 + 32), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    int v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD2434D4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_12;
  }
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_17:
    v3 += ((9 * (__clz(*(_DWORD *)(a1 + 28) | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 4) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  int v6 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = ((9 * (__clz(v6 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 11;
  }
  v3 += v8;
  if ((v4 & 2) != 0) {
    goto LABEL_17;
  }
LABEL_10:
  if ((v4 & 4) != 0) {
LABEL_11:
  }
    v3 += ((9 * (__clz(*(void *)(a1 + 32) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_12:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD2435A8(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    BOOL result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      LODWORD(v3[1].__r_.__value_.__l.__data_) = *(_DWORD *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0)
        {
LABEL_8:
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
          return result;
        }
LABEL_7:
        v3[1].__r_.__value_.__l.__size_ = *(void *)(a2 + 32);
        goto LABEL_8;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    HIDWORD(v3[1].__r_.__value_.__r.__words[0]) = *(_DWORD *)(a2 + 28);
    if ((v5 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

std::string *sub_1DD243628(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD2430C8((uint64_t)result);
    return sub_1DD2435A8(v4, a2);
  }
  return result;
}

uint64_t sub_1DD243674()
{
  return 1;
}

__n128 sub_1DD24367C(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v2;
  int v3 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 28) = v3;
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a2 + 32) = v4;
  LODWORD(v4) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v4;
  int v6 = (unint64_t *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 8);
  uint64_t v9 = *(void *)(a2 + 8);
  uint64_t v7 = (unint64_t *)(a2 + 8);
  uint64_t v8 = v9;
  if (v5)
  {
    if ((v8 & 1) == 0)
    {
      sub_1DD24F7CC(v7);
      unint64_t v10 = v15;
      unint64_t v5 = *v6;
      if (*v6) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
LABEL_5:
    unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFFELL;
    if (v5)
    {
LABEL_6:
      unsigned int v11 = (__n128 *)(v5 & 0xFFFFFFFFFFFFFFFELL);
LABEL_7:
      unint64_t v12 = v11[1].n128_u64[0];
      __n128 result = *v11;
      unint64_t v14 = *(void *)(v10 + 16);
      __n128 *v11 = *(__n128 *)v10;
      v11[1].n128_u64[0] = v14;
      *(__n128 *)unint64_t v10 = result;
      *(void *)(v10 + 16) = v12;
      return result;
    }
LABEL_9:
    sub_1DD24F7CC(v6);
    goto LABEL_7;
  }
  if (v8) {
    goto LABEL_5;
  }
  return result;
}

void *sub_1DD243748@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.Stream");
}

uint64_t sub_1DD243758(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BCB8;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (atomic_load_explicit(dword_1EC8AC0C0, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC0C0);
  }
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  return a1;
}

void sub_1DD2437CC(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2437E4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387BCB8;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    sub_1DD24FBB0((unint64_t *)(a1 + 8), v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  uint64_t v5 = *(void *)(a2 + 24);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(void *)(a1 + 24) = v5;
  return a1;
}

void sub_1DD243864(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24387C(void *a1)
{
  *a1 = &unk_1F387BCB8;
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD2438C0(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387BCB8;
  sub_1DD24F770(a1 + 1);
  operator delete(a1);
}

void sub_1DD243914(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 7) != 0)
  {
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)(a1 + 24) = 0;
  }
  char v2 = *(unsigned char *)(a1 + 8);
  uint64_t v1 = a1 + 8;
  *(_DWORD *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD24FC0C((unint64_t *)v1);
  }
}

uint64_t sub_1DD24393C(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  long long v32 = (uint64_t *)(a1 + 8);
  long long v33 = 0uLL;
  uint64_t v34 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v34 = *(void *)(v5 + 16);
    long long v33 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v31, (uint64_t)&v33);
  sub_1DD2F9178((uint64_t)&v28, (uint64_t)v31, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v7 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1])
          {
            uint64_t v8 = 0;
LABEL_9:
            unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
            unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
            if ((v9 & 0x100000000) == 0) {
              goto LABEL_29;
            }
            goto LABEL_10;
          }
          uint64_t v8 = *v7;
          if (*v7 < 1) {
            goto LABEL_9;
          }
          *a2 = (uint64_t)(v7 + 1);
          unint64_t v9 = v8 | 0x100000000;
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_29;
          }
LABEL_10:
          unsigned int v11 = v9 >> 3;
          if (v9 >> 3 != 3) {
            break;
          }
          if (v9 != 24) {
            goto LABEL_29;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          unint64_t v15 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1])
          {
            int v16 = 0;
          }
          else
          {
            int v16 = *v15;
            if ((*v15 & 0x80000000) == 0)
            {
              *(_DWORD *)(a1 + 32) = v16;
              goto LABEL_28;
            }
          }
          uint64_t v24 = sub_1DD2F8C30(a2, v16);
          *(_DWORD *)(a1 + 32) = v24;
          if (v24 < 0) {
            goto LABEL_52;
          }
        }
        if (v11 != 2) {
          break;
        }
        if (v9 != 16) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        unint64_t v15 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v17 = 0;
          goto LABEL_51;
        }
        int v17 = *v15;
        if (*v15 < 0)
        {
LABEL_51:
          uint64_t v25 = sub_1DD2F8C30(a2, v17);
          *(_DWORD *)(a1 + 28) = v25;
          if (v25 < 0)
          {
LABEL_52:
            uint64_t v26 = 0;
            goto LABEL_54;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 28) = v17;
LABEL_28:
          *a2 = (uint64_t)(v15 + 1);
        }
      }
      if (v11 != 1 || v9 != 8) {
        break;
      }
      unint64_t v13 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        LODWORD(v14) = 0;
      }
      else
      {
        LODWORD(v14) = *v13;
        if ((*v13 & 0x80000000) == 0)
        {
          *a2 = (uint64_t)(v13 + 1);
          goto LABEL_34;
        }
      }
      uint64_t v14 = sub_1DD2F8C30(a2, v14);
      if (v14 < 0) {
        goto LABEL_52;
      }
LABEL_34:
      if (v14 > 3)
      {
        if (v30 < 5)
        {
          sub_1DD2F9508((uint64_t)&v28, 8u);
          int v18 = v30;
        }
        else
        {
          *v29++ = 8;
          int v18 = --v30;
        }
        if (v18 < 5)
        {
          sub_1DD2F9508((uint64_t)&v28, v14);
        }
        else
        {
          int v19 = (int)v29;
          if (v14 < 0x80)
          {
            LOBYTE(v21) = v14;
            int v20 = v29;
          }
          else
          {
            int v20 = v29;
            do
            {
              *v20++ = v14 | 0x80;
              unsigned int v21 = v14 >> 7;
              unsigned int v22 = v14 >> 14;
              LODWORD(v14) = v14 >> 7;
            }
            while (v22);
          }
          unsigned char *v20 = v21;
          int v23 = v20 - v19 + 1;
          v29 += v23;
          v30 -= v23;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 16) |= 1u;
        *(_DWORD *)(a1 + 24) = v14;
      }
    }
LABEL_29:
    if (!v9) {
      break;
    }
    if (!sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)&v28)) {
      goto LABEL_52;
    }
  }
  uint64_t v26 = 1;
LABEL_54:
  sub_1DD2F92B4(&v28);
  sub_1DD24F874(&v32);
  return v26;
}

void sub_1DD243C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD243C50(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FBEA4(1, *(_DWORD *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FBFC4(2, *(_DWORD *)(a1 + 28), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FBFC4(3, *(_DWORD *)(a1 + 32), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD243D24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    char v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_12;
  }
  if ((v4 & 1) == 0)
  {
    if ((v4 & 2) == 0) {
      goto LABEL_10;
    }
LABEL_17:
    v3 += ((9 * (__clz(*(_DWORD *)(a1 + 28) | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 4) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  int v6 = *(_DWORD *)(a1 + 24);
  uint64_t v7 = ((9 * (__clz(v6 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v6 >= 0) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 11;
  }
  v3 += v8;
  if ((v4 & 2) != 0) {
    goto LABEL_17;
  }
LABEL_10:
  if ((v4 & 4) != 0) {
LABEL_11:
  }
    v3 += ((9 * (__clz(*(_DWORD *)(a1 + 32) | 1) ^ 0x1F) + 73) >> 6) + 1;
LABEL_12:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD243DFC(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      LODWORD(v3[1].__r_.__value_.__l.__data_) = *(_DWORD *)(a2 + 24);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0)
        {
LABEL_8:
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
          return result;
        }
LABEL_7:
        LODWORD(v3[1].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 32);
        goto LABEL_8;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    HIDWORD(v3[1].__r_.__value_.__r.__words[0]) = *(_DWORD *)(a2 + 28);
    if ((v5 & 4) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

std::string *sub_1DD243E7C(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD243914((uint64_t)result);
    return sub_1DD243DFC(v4, a2);
  }
  return result;
}

uint64_t sub_1DD243EC8()
{
  return 1;
}

__n128 sub_1DD243ED0(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v2;
  int v3 = *(_DWORD *)(a1 + 28);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a2 + 28) = v3;
  int v4 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a2 + 32) = v4;
  int v5 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 16) = v5;
  uint64_t v7 = (unint64_t *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 8);
  uint64_t v10 = *(void *)(a2 + 8);
  uint64_t v8 = (unint64_t *)(a2 + 8);
  uint64_t v9 = v10;
  if (v6)
  {
    if ((v9 & 1) == 0)
    {
      sub_1DD24F7CC(v8);
      unint64_t v11 = v16;
      unint64_t v6 = *v7;
      if (*v7) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
LABEL_5:
    unint64_t v11 = v9 & 0xFFFFFFFFFFFFFFFELL;
    if (v6)
    {
LABEL_6:
      unint64_t v12 = (__n128 *)(v6 & 0xFFFFFFFFFFFFFFFELL);
LABEL_7:
      unint64_t v13 = v12[1].n128_u64[0];
      __n128 result = *v12;
      unint64_t v15 = *(void *)(v11 + 16);
      __n128 *v12 = *(__n128 *)v11;
      v12[1].n128_u64[0] = v15;
      *(__n128 *)unint64_t v11 = result;
      *(void *)(v11 + 16) = v13;
      return result;
    }
LABEL_9:
    sub_1DD24F7CC(v7);
    goto LABEL_7;
  }
  if (v9) {
    goto LABEL_5;
  }
  return result;
}

void *sub_1DD243F9C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.ColumnEncoding");
}

uint64_t sub_1DD243FAC(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)a1 = &unk_1F387C6B8;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  if (atomic_load_explicit(dword_1EC8AC268, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC268);
  }
  return a1;
}

void sub_1DD244034(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD244060(void *a1)
{
  *a1 = &unk_1F387C6B8;
  sub_1DD24FC54(a1 + 6);
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD2440C0(void *a1)
{
  uint64_t v1 = sub_1DD244060(a1);
  operator delete(v1);
}

void sub_1DD2440E8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    int v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD2430C8(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 56);
  if ((int)v5 >= 1)
  {
    unint64_t v6 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v7 = *v6++;
      sub_1DD243914(v7);
      --v5;
    }
    while (v5);
    *(_DWORD *)(a1 + 56) = 0;
  }
  char v9 = *(unsigned char *)(a1 + 8);
  uint64_t v8 = a1 + 8;
  *(_DWORD *)(v8 + 8) = 0;
  if (v9)
  {
    sub_1DD24FC0C((unint64_t *)v8);
  }
}

uint64_t sub_1DD244190(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v36 = (uint64_t *)(a1 + 8);
  long long v37 = 0uLL;
  uint64_t v38 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v38 = *(void *)(v5 + 16);
    long long v37 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v35, (uint64_t)&v37);
  sub_1DD2F9178((uint64_t)v34, (uint64_t)v35, 0);
  do
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if ((char)*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_23;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_23;
    }
LABEL_10:
    if (v9 >> 3 != 2)
    {
      if (v9 >> 3 != 1 || v9 != 10)
      {
LABEL_23:
        if (!v9)
        {
          uint64_t v32 = 1;
          goto LABEL_50;
        }
        BOOL v20 = sub_1DD2FB80C(a2, v9, (uint64_t)v34);
        continue;
      }
      unint64_t v12 = *(int **)(a1 + 40);
      if (v12)
      {
        uint64_t v13 = *(int *)(a1 + 32);
        int v14 = *v12;
        if ((int)v13 < *v12)
        {
          *(_DWORD *)(a1 + 32) = v13 + 1;
          unint64_t v15 = *(void **)&v12[2 * v13 + 2];
LABEL_32:
          int v23 = *(char **)a2;
          if (*(void *)a2 >= *(void *)(a2 + 8) || *v23 < 0)
          {
            int v24 = sub_1DD2F8D1C((unsigned __int8 **)a2);
            if (v24 < 0) {
              break;
            }
          }
          else
          {
            int v24 = *v23;
            *(void *)a2 = v23 + 1;
          }
          unint64_t v25 = sub_1DD2F8298(a2, v24);
          int v26 = v25;
          if ((v25 & 0x8000000000000000) != 0 || !sub_1DD2430EC((uint64_t)v15, (uint64_t *)a2)) {
            break;
          }
          goto LABEL_38;
        }
        if (v14 != *(_DWORD *)(a1 + 36))
        {
LABEL_31:
          int *v12 = v14 + 1;
          unint64_t v15 = sub_1DD24EB78(*(void *)(a1 + 24));
          uint64_t v21 = *(void *)(a1 + 40);
          uint64_t v22 = *(int *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v22 + 1;
          *(void *)(v21 + 8 * v22 + 8) = v15;
          goto LABEL_32;
        }
      }
      else
      {
        int v14 = *(_DWORD *)(a1 + 36);
      }
      sub_1DD2FABC8(a1 + 24, v14 + 1);
      unint64_t v12 = *(int **)(a1 + 40);
      int v14 = *v12;
      goto LABEL_31;
    }
    if (v9 != 18) {
      goto LABEL_23;
    }
    unint64_t v16 = *(int **)(a1 + 64);
    if (!v16)
    {
      int v18 = *(_DWORD *)(a1 + 60);
      goto LABEL_40;
    }
    uint64_t v17 = *(int *)(a1 + 56);
    int v18 = *v16;
    if ((int)v17 >= *v16)
    {
      if (v18 != *(_DWORD *)(a1 + 60))
      {
LABEL_41:
        *unint64_t v16 = v18 + 1;
        int v19 = sub_1DD24EC0C(*(void *)(a1 + 48));
        uint64_t v27 = *(void *)(a1 + 64);
        uint64_t v28 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v28 + 1;
        *(void *)(v27 + 8 * v28 + 8) = v19;
        goto LABEL_42;
      }
LABEL_40:
      sub_1DD2FABC8(a1 + 48, v18 + 1);
      unint64_t v16 = *(int **)(a1 + 64);
      int v18 = *v16;
      goto LABEL_41;
    }
    *(_DWORD *)(a1 + 56) = v17 + 1;
    int v19 = *(void **)&v16[2 * v17 + 2];
LABEL_42:
    int v29 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v29 < 0)
    {
      int v30 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v30 < 0) {
        break;
      }
    }
    else
    {
      int v30 = *v29;
      *(void *)a2 = v29 + 1;
    }
    unint64_t v31 = sub_1DD2F8298(a2, v30);
    int v26 = v31;
    if ((v31 & 0x8000000000000000) != 0 || !sub_1DD24393C((uint64_t)v19, (uint64_t *)a2)) {
      break;
    }
LABEL_38:
    BOOL v20 = sub_1DD2F82D0(a2, v26);
  }
  while (v20);
  uint64_t v32 = 0;
LABEL_50:
  sub_1DD2F92B4(v34);
  sub_1DD24F874(&v36);
  return v32;
}

void sub_1DD2444A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2444C8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  int v6 = *(_DWORD *)(a1 + 56);
  if (v6)
  {
    for (int j = 0; j != v6; ++j)
      sub_1DD2FCDAC(2, *(void *)(*(void *)(a1 + 64) + 8 * j + 8), a2);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8) {
    unint64_t v9 = (char *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v9 = (char *)&qword_1EAB1F7D8;
  }
  if (v9[23] < 0) {
    unint64_t v9 = *(char **)v9;
  }
  if (v8) {
    unsigned int v10 = (uint64_t *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unsigned int v10 = &qword_1EAB1F7D8;
  }
  if (*((char *)v10 + 23) < 0) {
    uint64_t v11 = v10[1];
  }
  else {
    LODWORD(v11) = *((unsigned __int8 *)v10 + 23);
  }
  return sub_1DD2F92E0(a2, v9, v11);
}

uint64_t sub_1DD2445B0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    int v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2434D4(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 56);
  uint64_t v10 = v6 + v9;
  if (v9)
  {
    int v11 = 0;
    do
    {
      uint64_t v12 = sub_1DD243D24(*(void *)(*(void *)(a1 + 64) + 8 * v11 + 8));
      v10 += v12 + ((9 * (__clz(v12 | 1) ^ 0x1F) + 73) >> 6);
      ++v11;
    }
    while (v9 != v11);
  }
  *(_DWORD *)(a1 + 20) = v10;
  return v10;
}

std::string *sub_1DD2446A8(std::string *result, uint64_t a2)
{
  int v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    __n128 result = sub_1DD24FE60(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  unsigned int v10 = *(_DWORD *)(a2 + 56);
  if (v10)
  {
    int v11 = (uint64_t *)(*(void *)(a2 + 64) + 8);
    uint64_t v12 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[2], v10);
    __n128 result = sub_1DD24FF20(v3 + 2, v12, v11, v10, *(_DWORD *)v3[2].__r_.__value_.__r.__words[2] - LODWORD(v3[2].__r_.__value_.__r.__words[1]));
    signed int v13 = LODWORD(v3[2].__r_.__value_.__r.__words[1]) + v10;
    LODWORD(v3[2].__r_.__value_.__r.__words[1]) = v13;
    int v14 = (signed int *)v3[2].__r_.__value_.__r.__words[2];
    if (*v14 < v13) {
      signed int *v14 = v13;
    }
  }
  return result;
}

uint64_t sub_1DD2447B8()
{
  return 1;
}

void *sub_1DD2447C0@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StripeEncryptionVariant");
}

uint64_t sub_1DD2447D0(uint64_t a1)
{
  *(void *)a1 = &unk_1F387BAD8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 88) = 0;
  if (atomic_load_explicit(dword_1EC8AC080, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC080);
  }
  *(void *)(a1 + 96) = &qword_1EAB1F7D8;
  return a1;
}

void sub_1DD244878(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v4);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD2448B4(void *a1)
{
  *a1 = &unk_1F387BAD8;
  uint64_t v2 = a1 + 9;
  sub_1DD244928((uint64_t)a1);
  sub_1DD24FC54(v2);
  sub_1DD24FC54(a1 + 6);
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD244928(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 96);
  if ((uint64_t *)v1 != &qword_1EAB1F7D8 && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete((void *)v1);
  }
}

void sub_1DD244990(void *a1)
{
  uint64_t v1 = sub_1DD2448B4(a1);
  operator delete(v1);
}

void sub_1DD2449B8(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    int v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD2430C8(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 56);
  if ((int)v5 >= 1)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v7 = *v6++;
      sub_1DD243914(v7);
      --v5;
    }
    while (v5);
    *(_DWORD *)(a1 + 56) = 0;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 80);
  if ((int)v8 >= 1)
  {
    uint64_t v9 = (uint64_t *)(*(void *)(a1 + 88) + 8);
    do
    {
      uint64_t v10 = *v9++;
      sub_1DD2440E8(v10);
      --v8;
    }
    while (v8);
    *(_DWORD *)(a1 + 80) = 0;
  }
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v11 = *(void *)(a1 + 96);
    if (*(char *)(v11 + 23) < 0)
    {
      **(unsigned char **)uint64_t v11 = 0;
      *(void *)(v11 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v11 = 0;
      *(unsigned char *)(v11 + 23) = 0;
    }
  }
  char v13 = *(unsigned char *)(a1 + 8);
  uint64_t v12 = a1 + 8;
  *(_DWORD *)(v12 + 8) = 0;
  if (v13)
  {
    sub_1DD24FC0C((unint64_t *)v12);
  }
}

uint64_t sub_1DD244AB4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v45 = (uint64_t *)(a1 + 8);
  long long v46 = 0uLL;
  uint64_t v47 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v47 = *(void *)(v5 + 16);
    long long v46 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v44, (uint64_t)&v46);
  sub_1DD2F9178((uint64_t)v43, (uint64_t)v44, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *v7;
    if ((char)*v7 < 1) {
      goto LABEL_9;
    }
    *(void *)a2 = v7 + 1;
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_27;
    }
LABEL_10:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 10) {
          goto LABEL_27;
        }
        uint64_t v11 = *(int **)(a1 + 40);
        if (!v11)
        {
          int v13 = *(_DWORD *)(a1 + 36);
LABEL_35:
          sub_1DD2FABC8(a1 + 24, v13 + 1);
          uint64_t v11 = *(int **)(a1 + 40);
          int v13 = *v11;
          goto LABEL_36;
        }
        uint64_t v12 = *(int *)(a1 + 32);
        int v13 = *v11;
        if ((int)v12 < *v11)
        {
          *(_DWORD *)(a1 + 32) = v12 + 1;
          int v14 = *(void **)&v11[2 * v12 + 2];
          goto LABEL_37;
        }
        if (v13 == *(_DWORD *)(a1 + 36)) {
          goto LABEL_35;
        }
LABEL_36:
        int *v11 = v13 + 1;
        int v14 = sub_1DD24EB78(*(void *)(a1 + 24));
        uint64_t v25 = *(void *)(a1 + 40);
        uint64_t v26 = *(int *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v26 + 1;
        *(void *)(v25 + 8 * v26 + 8) = v14;
LABEL_37:
        uint64_t v27 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v27 < 0)
        {
          int v28 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v28 < 0) {
            goto LABEL_66;
          }
        }
        else
        {
          int v28 = *v27;
          *(void *)a2 = v27 + 1;
        }
        unint64_t v29 = sub_1DD2F8298(a2, v28);
        int v30 = v29;
        if ((v29 & 0x8000000000000000) == 0 && sub_1DD2430EC((uint64_t)v14, (uint64_t *)a2)) {
          goto LABEL_63;
        }
        goto LABEL_66;
      case 2u:
        if (v9 != 18) {
          goto LABEL_27;
        }
        unint64_t v15 = *(int **)(a1 + 64);
        if (!v15)
        {
          int v17 = *(_DWORD *)(a1 + 60);
LABEL_45:
          sub_1DD2FABC8(a1 + 48, v17 + 1);
          unint64_t v15 = *(int **)(a1 + 64);
          int v17 = *v15;
          goto LABEL_46;
        }
        uint64_t v16 = *(int *)(a1 + 56);
        int v17 = *v15;
        if ((int)v16 < *v15)
        {
          *(_DWORD *)(a1 + 56) = v16 + 1;
          int v18 = *(void **)&v15[2 * v16 + 2];
          goto LABEL_47;
        }
        if (v17 == *(_DWORD *)(a1 + 60)) {
          goto LABEL_45;
        }
LABEL_46:
        *unint64_t v15 = v17 + 1;
        int v18 = sub_1DD24EC0C(*(void *)(a1 + 48));
        uint64_t v31 = *(void *)(a1 + 64);
        uint64_t v32 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v32 + 1;
        *(void *)(v31 + 8 * v32 + 8) = v18;
LABEL_47:
        long long v33 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v33 < 0)
        {
          int v34 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v34 < 0) {
            goto LABEL_66;
          }
        }
        else
        {
          int v34 = *v33;
          *(void *)a2 = v33 + 1;
        }
        unint64_t v35 = sub_1DD2F8298(a2, v34);
        int v30 = v35;
        if ((v35 & 0x8000000000000000) == 0 && sub_1DD24393C((uint64_t)v18, (uint64_t *)a2)) {
          goto LABEL_63;
        }
        goto LABEL_66;
      case 3u:
        if (v9 != 26) {
          goto LABEL_27;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        int v19 = *(std::string **)(a1 + 96);
        if (v19 == (std::string *)&qword_1EAB1F7D8)
        {
          sub_1DD24F908((void *)(a1 + 96), (uint64_t)&qword_1EAB1F7D8);
          int v19 = *(std::string **)(a1 + 96);
        }
        BOOL v20 = sub_1DD2FCF1C((uint64_t *)a2, v19);
        break;
      case 4u:
        if (v9 != 34) {
          goto LABEL_27;
        }
        uint64_t v21 = *(int **)(a1 + 88);
        if (!v21)
        {
          int v23 = *(_DWORD *)(a1 + 84);
LABEL_55:
          sub_1DD2FABC8(a1 + 72, v23 + 1);
          uint64_t v21 = *(int **)(a1 + 88);
          int v23 = *v21;
          goto LABEL_56;
        }
        uint64_t v22 = *(int *)(a1 + 80);
        int v23 = *v21;
        if ((int)v22 < *v21)
        {
          *(_DWORD *)(a1 + 80) = v22 + 1;
          int v24 = *(void **)&v21[2 * v22 + 2];
          goto LABEL_57;
        }
        if (v23 == *(_DWORD *)(a1 + 84)) {
          goto LABEL_55;
        }
LABEL_56:
        int *v21 = v23 + 1;
        int v24 = sub_1DD24ECA0(*(void *)(a1 + 72));
        uint64_t v36 = *(void *)(a1 + 88);
        uint64_t v37 = *(int *)(a1 + 80);
        *(_DWORD *)(a1 + 80) = v37 + 1;
        *(void *)(v36 + 8 * v37 + 8) = v24;
LABEL_57:
        uint64_t v38 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v38 < 0)
        {
          int v39 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v39 < 0) {
            goto LABEL_66;
          }
        }
        else
        {
          int v39 = *v38;
          *(void *)a2 = v38 + 1;
        }
        unint64_t v40 = sub_1DD2F8298(a2, v39);
        int v30 = v40;
        if ((v40 & 0x8000000000000000) != 0 || !sub_1DD244190((uint64_t)v24, a2))
        {
LABEL_66:
          uint64_t v41 = 0;
          goto LABEL_65;
        }
LABEL_63:
        BOOL v20 = sub_1DD2F82D0(a2, v30);
        break;
      default:
        goto LABEL_27;
    }
LABEL_29:
    if (!v20) {
      goto LABEL_66;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  unsigned int v10 = sub_1DD2F8F70(a2, v8);
  unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
  if ((v9 & 0x100000000) != 0) {
    goto LABEL_10;
  }
LABEL_27:
  if (v9)
  {
    BOOL v20 = sub_1DD2FB80C(a2, v9, (uint64_t)v43);
    goto LABEL_29;
  }
  uint64_t v41 = 1;
LABEL_65:
  sub_1DD2F92B4(v43);
  sub_1DD24F874(&v45);
  return v41;
}

void sub_1DD244F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD244F6C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  int v6 = *(_DWORD *)(a1 + 56);
  if (v6)
  {
    for (int j = 0; j != v6; ++j)
      sub_1DD2FCDAC(2, *(void *)(*(void *)(a1 + 64) + 8 * j + 8), a2);
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD2FC85C(3, *(void *)(a1 + 96), a2);
  }
  int v8 = *(_DWORD *)(a1 + 80);
  if (v8)
  {
    for (int k = 0; k != v8; ++k)
      sub_1DD2FCDAC(4, *(void *)(*(void *)(a1 + 88) + 8 * k + 8), a2);
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10) {
    uint64_t v11 = (char *)(v10 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v11 = (char *)&qword_1EAB1F7D8;
  }
  if (v11[23] < 0) {
    uint64_t v11 = *(char **)v11;
  }
  if (v10) {
    uint64_t v12 = (uint64_t *)(v10 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v12 = &qword_1EAB1F7D8;
  }
  if (*((char *)v12 + 23) < 0) {
    uint64_t v13 = v12[1];
  }
  else {
    LODWORD(v13) = *((unsigned __int8 *)v12 + 23);
  }
  return sub_1DD2F92E0(a2, v11, v13);
}

uint64_t sub_1DD24509C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    int v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2434D4(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 56);
  uint64_t v10 = v6 + v9;
  if (v9)
  {
    int v11 = 0;
    do
    {
      uint64_t v12 = sub_1DD243D24(*(void *)(*(void *)(a1 + 64) + 8 * v11 + 8));
      v10 += v12 + ((9 * (__clz(v12 | 1) ^ 0x1F) + 73) >> 6);
      ++v11;
    }
    while (v9 != v11);
  }
  uint64_t v13 = *(unsigned int *)(a1 + 80);
  uint64_t v14 = v10 + v13;
  if (v13)
  {
    int v15 = 0;
    do
    {
      uint64_t v16 = sub_1DD2445B0(*(void *)(*(void *)(a1 + 88) + 8 * v15 + 8));
      v14 += v16 + ((9 * (__clz(v16 | 1) ^ 0x1F) + 73) >> 6);
      ++v15;
    }
    while (v13 != v15);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v17 = *(void *)(a1 + 96);
    uint64_t v18 = *(unsigned __int8 *)(v17 + 23);
    uint64_t v19 = *(void *)(v17 + 8);
    if ((v18 & 0x80u) == 0) {
      uint64_t v19 = v18;
    }
    v14 += v19 + ((9 * (__clz(v19 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }
  *(_DWORD *)(a1 + 20) = v14;
  return v14;
}

std::string *sub_1DD245224(std::string *result, uint64_t a2)
{
  int v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    __n128 result = sub_1DD24FE60(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  unsigned int v10 = *(_DWORD *)(a2 + 56);
  if (v10)
  {
    int v11 = (uint64_t *)(*(void *)(a2 + 64) + 8);
    uint64_t v12 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[2], *(_DWORD *)(a2 + 56));
    __n128 result = sub_1DD24FF20(v3 + 2, v12, v11, v10, *(_DWORD *)v3[2].__r_.__value_.__r.__words[2] - LODWORD(v3[2].__r_.__value_.__r.__words[1]));
    signed int v13 = LODWORD(v3[2].__r_.__value_.__r.__words[1]) + v10;
    LODWORD(v3[2].__r_.__value_.__r.__words[1]) = v13;
    uint64_t v14 = (signed int *)v3[2].__r_.__value_.__r.__words[2];
    if (*v14 < v13) {
      signed int *v14 = v13;
    }
  }
  unsigned int v15 = *(_DWORD *)(a2 + 80);
  if (v15)
  {
    uint64_t v16 = (uint64_t *)(*(void *)(a2 + 88) + 8);
    uint64_t v17 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[3], *(_DWORD *)(a2 + 80));
    __n128 result = sub_1DD24FFE0(v3 + 3, v17, v16, v15, *(_DWORD *)v3[3].__r_.__value_.__r.__words[2] - LODWORD(v3[3].__r_.__value_.__r.__words[1]));
    signed int v18 = LODWORD(v3[3].__r_.__value_.__r.__words[1]) + v15;
    LODWORD(v3[3].__r_.__value_.__r.__words[1]) = v18;
    uint64_t v19 = (signed int *)v3[3].__r_.__value_.__r.__words[2];
    if (*v19 < v18) {
      *uint64_t v19 = v18;
    }
  }
  if (*(unsigned char *)(a2 + 16))
  {
    data = (std::string *)v3[4].__r_.__value_.__l.__data_;
    BOOL v20 = (std::string::__raw *)&v3[4];
    __n128 result = data;
    LODWORD(v20[-4].__words[2]) |= 1u;
    uint64_t v22 = *(const std::string **)(a2 + 96);
    if (data != v22)
    {
      if (result == (std::string *)&qword_1EAB1F7D8)
      {
        return (std::string *)sub_1DD24F908(v20, (uint64_t)v22);
      }
      else
      {
        return std::string::operator=(result, v22);
      }
    }
  }
  return result;
}

uint64_t sub_1DD245418()
{
  return 1;
}

__n128 sub_1DD245420(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = a2[5];
  a2[5] = v2;
  uint64_t v3 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = a2[8];
  a2[8] = v3;
  uint64_t v4 = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = a2[11];
  a2[11] = v4;
  uint64_t v5 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = a2[12];
  a2[12] = v5;
  int v7 = (unint64_t *)(a1 + 8);
  unint64_t v6 = *(void *)(a1 + 8);
  int v8 = *(_DWORD *)(a1 + 32);
  uint64_t v11 = a2[1];
  uint64_t v9 = a2 + 1;
  uint64_t v10 = v11;
  *(_DWORD *)(a1 + 32) = *((_DWORD *)v9 + 6);
  *((_DWORD *)v9 + 6) = v8;
  int v12 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 36) = *((_DWORD *)v9 + 7);
  *((_DWORD *)v9 + 7) = v12;
  int v13 = *(_DWORD *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = *((_DWORD *)v9 + 12);
  *((_DWORD *)v9 + 12) = v13;
  int v14 = *(_DWORD *)(a1 + 60);
  *(_DWORD *)(a1 + 60) = *((_DWORD *)v9 + 13);
  *((_DWORD *)v9 + 13) = v14;
  int v15 = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(a1 + 80) = *((_DWORD *)v9 + 18);
  *((_DWORD *)v9 + 18) = v15;
  int v16 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(a1 + 84) = *((_DWORD *)v9 + 19);
  *((_DWORD *)v9 + 19) = v16;
  int v17 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = *((_DWORD *)v9 + 2);
  *((_DWORD *)v9 + 2) = v17;
  if (v6)
  {
    if ((v10 & 1) == 0)
    {
      sub_1DD24F7CC(v9);
      unint64_t v18 = v23;
      unint64_t v6 = *v7;
      if (*v7) {
        goto LABEL_6;
      }
      goto LABEL_9;
    }
LABEL_5:
    unint64_t v18 = v10 & 0xFFFFFFFFFFFFFFFELL;
    if (v6)
    {
LABEL_6:
      uint64_t v19 = (__n128 *)(v6 & 0xFFFFFFFFFFFFFFFELL);
LABEL_7:
      unint64_t v20 = v19[1].n128_u64[0];
      __n128 result = *v19;
      unint64_t v22 = *(void *)(v18 + 16);
      *uint64_t v19 = *(__n128 *)v18;
      v19[1].n128_u64[0] = v22;
      *(__n128 *)unint64_t v18 = result;
      *(void *)(v18 + 16) = v20;
      return result;
    }
LABEL_9:
    sub_1DD24F7CC(v7);
    goto LABEL_7;
  }
  if (v10) {
    goto LABEL_5;
  }
  return result;
}

void *sub_1DD24555C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StripeFooter");
}

void *sub_1DD24556C(void *a1)
{
  *a1 = &unk_1F387B998;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC068, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC068);
  }
  a1[3] = &qword_1EAB1F7D8;
  a1[4] = &qword_1EAB1F7D8;
  return a1;
}

void sub_1DD2455E4(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void sub_1DD2455F8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if ((uint64_t *)v2 != &qword_1EAB1F7D8 && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete((void *)v2);
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if ((uint64_t *)v4 != &qword_1EAB1F7D8 && v4 != 0)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete((void *)v4);
  }
}

void *sub_1DD245694(void *a1)
{
  *a1 = &unk_1F387B998;
  uint64_t v2 = a1 + 1;
  sub_1DD2455F8((uint64_t)a1);
  sub_1DD24F770(v2);
  return a1;
}

void sub_1DD2456E4(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387B998;
  uint64_t v2 = a1 + 1;
  sub_1DD2455F8((uint64_t)a1);
  sub_1DD24F770(v2);
  operator delete(a1);
}

void sub_1DD245744(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 3) == 0) {
    goto LABEL_11;
  }
  if ((v1 & 1) == 0)
  {
LABEL_5:
    if ((v1 & 2) != 0) {
      goto LABEL_6;
    }
    goto LABEL_11;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if ((*(char *)(v2 + 23) & 0x80000000) == 0)
  {
    *(unsigned char *)uint64_t v2 = 0;
    *(unsigned char *)(v2 + 23) = 0;
    goto LABEL_5;
  }
  **(unsigned char **)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  if ((v1 & 2) != 0)
  {
LABEL_6:
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(char *)(v3 + 23) < 0)
    {
      **(unsigned char **)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v3 = 0;
      *(unsigned char *)(v3 + 23) = 0;
    }
  }
LABEL_11:
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = a1 + 8;
  *(_DWORD *)(v4 + 8) = 0;
  if (v5) {
    sub_1DD24FC0C((unint64_t *)v4);
  }
}

uint64_t sub_1DD2457B8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v18 = (uint64_t *)(a1 + 8);
  long long v19 = 0uLL;
  uint64_t v20 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v20 = *(void *)(v5 + 16);
    long long v19 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v17, (uint64_t)&v19);
  sub_1DD2F9178((uint64_t)v16, (uint64_t)v17, 0);
  while (1)
  {
    int v7 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if (*v7 >= 1)
      {
        *a2 = (uint64_t)(v7 + 1);
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_23;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_23;
    }
LABEL_10:
    if (v9 >> 3 != 2) {
      break;
    }
    if (v9 != 18) {
      goto LABEL_23;
    }
    *(_DWORD *)(a1 + 16) |= 2u;
    int v12 = *(std::string **)(a1 + 32);
    if (v12 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 32), (uint64_t)&qword_1EAB1F7D8);
      int v12 = *(std::string **)(a1 + 32);
    }
LABEL_18:
    BOOL v13 = sub_1DD2FCF1C(a2, v12);
LABEL_25:
    if (!v13)
    {
      uint64_t v14 = 0;
      goto LABEL_28;
    }
  }
  if (v9 >> 3 == 1 && v9 == 10)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    int v12 = *(std::string **)(a1 + 24);
    if (v12 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 24), (uint64_t)&qword_1EAB1F7D8);
      int v12 = *(std::string **)(a1 + 24);
    }
    goto LABEL_18;
  }
LABEL_23:
  if (v9)
  {
    BOOL v13 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v16);
    goto LABEL_25;
  }
  uint64_t v14 = 1;
LABEL_28:
  sub_1DD2F92B4(v16);
  sub_1DD24F874(&v18);
  return v14;
}

void sub_1DD24596C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD245994(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4) {
    sub_1DD2FC85C(1, *(void *)(a1 + 24), a2);
  }
  if ((v4 & 2) != 0) {
    sub_1DD2FC85C(2, *(void *)(a1 + 32), a2);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    int v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD245A48(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 3) != 0)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v7 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        uint64_t v7 = v6;
      }
      v3 += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(unsigned __int8 *)(v8 + 23);
      uint64_t v10 = *(void *)(v8 + 8);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = v9;
      }
      v3 += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
  }
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD245B10(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 3) != 0)
  {
    if (v5)
    {
      __n128 result = v3 + 1;
      data = (std::string *)v3[1].__r_.__value_.__l.__data_;
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      uint64_t v7 = *(const std::string **)(a2 + 24);
      if (data != v7)
      {
        if (data == (std::string *)&qword_1EAB1F7D8)
        {
          __n128 result = (std::string *)sub_1DD24F908(result, (uint64_t)v7);
          if ((v5 & 2) == 0) {
            return result;
          }
          goto LABEL_9;
        }
        __n128 result = std::string::operator=(data, v7);
      }
    }
    if ((v5 & 2) == 0) {
      return result;
    }
LABEL_9:
    std::string::size_type size = (std::string *)v3[1].__r_.__value_.__l.__size_;
    p_std::string::size_type size = &v3[1].__r_.__value_.__l.__size_;
    __n128 result = size;
    *((_DWORD *)p_size - 4) |= 2u;
    uint64_t v10 = *(const std::string **)(a2 + 32);
    if (size != v10)
    {
      if (result == (std::string *)&qword_1EAB1F7D8)
      {
        return (std::string *)sub_1DD24F908(p_size, (uint64_t)v10);
      }
      else
      {
        return std::string::operator=(result, v10);
      }
    }
  }
  return result;
}

uint64_t sub_1DD245C14()
{
  return 1;
}

void *sub_1DD245C1C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StringPair");
}

uint64_t sub_1DD245C2C(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C758;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  if (atomic_load_explicit(dword_1EC8ABF90, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF90);
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  return a1;
}

void sub_1DD245CB8(_Unwind_Exception *a1)
{
  int v5 = v4;
  sub_1DD24FC54(v5);
  sub_1DD2500A0(v3);
  sub_1DD23CE34(v1 + 24);
  sub_1DD24F770(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD245CF4(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C758;
  sub_1DD24FC54((void *)(a1 + 72));
  sub_1DD2500A0((void *)(a1 + 48));
  if (*(int *)(a1 + 28) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD245D74(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD245CF4(a1);
  operator delete(v1);
}

void sub_1DD245D9C(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  sub_1DD24FB64(a1 + 48);
  uint64_t v2 = *(unsigned int *)(a1 + 80);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 88) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD245744(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 80) = 0;
  }
  if ((*(unsigned char *)(a1 + 16) & 0xF) != 0)
  {
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 104) = 0;
  }
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6)
  {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD245E38(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  v59 = (uint64_t *)(a1 + 8);
  long long v60 = 0uLL;
  uint64_t v61 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v61 = *(void *)(v5 + 16);
    long long v60 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v58, (uint64_t)&v60);
  sub_1DD2F9178((uint64_t)&v55, (uint64_t)v58, 0);
  uint64_t v7 = (uint64_t *)(a1 + 48);
LABEL_4:
  while (2)
  {
    uint64_t v8 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      uint64_t v9 = 0;
LABEL_9:
      unsigned int v11 = sub_1DD2F8F70((uint64_t)a2, v9);
      unint64_t v10 = v11 | ((unint64_t)(v11 - 1 < 0x7F) << 32);
      if ((v10 & 0x100000000) == 0) {
        goto LABEL_41;
      }
      goto LABEL_10;
    }
    uint64_t v9 = *v8;
    if (*v8 < 1) {
      goto LABEL_9;
    }
    *a2 = (uint64_t)(v8 + 1);
    unint64_t v10 = v9 | 0x100000000;
    if ((v10 & 0x100000000) == 0) {
      goto LABEL_41;
    }
LABEL_10:
    switch(v10 >> 3)
    {
      case 1u:
        if (v10 != 8) {
          goto LABEL_41;
        }
        int v12 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          LODWORD(v13) = 0;
        }
        else
        {
          LODWORD(v13) = *v12;
          if ((*v12 & 0x80000000) == 0)
          {
            *a2 = (uint64_t)(v12 + 1);
            goto LABEL_81;
          }
        }
        uint64_t v13 = sub_1DD2F8C30(a2, v13);
        if (v13 < 0) {
          goto LABEL_105;
        }
LABEL_81:
        if (v13 > 0x12)
        {
          if (v57 < 5)
          {
            sub_1DD2F9508((uint64_t)&v55, 8u);
            int v44 = v57;
          }
          else
          {
            *v56++ = 8;
            int v44 = --v57;
          }
          if (v44 < 5)
          {
            sub_1DD2F9508((uint64_t)&v55, v13);
          }
          else
          {
            int v45 = (int)v56;
            if (v13 < 0x80)
            {
              LOBYTE(v47) = v13;
              long long v46 = v56;
            }
            else
            {
              long long v46 = v56;
              do
              {
                *v46++ = v13 | 0x80;
                unsigned int v47 = v13 >> 7;
                unsigned int v48 = v13 >> 14;
                LODWORD(v13) = v13 >> 7;
              }
              while (v48);
            }
            *long long v46 = v47;
            int v49 = v46 - v45 + 1;
            v56 += v49;
            v57 -= v49;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) |= 1u;
          *(_DWORD *)(a1 + 96) = v13;
        }
        continue;
      case 2u:
        if (v10 == 16)
        {
          char v28 = sub_1DD2464D8(1, 0x12u, a2, (signed int *)(a1 + 24));
          goto LABEL_43;
        }
        if (v10 == 18)
        {
          uint64_t v14 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v14 & 0x80000000) == 0)
          {
            int v15 = *v14;
            *a2 = (uint64_t)(v14 + 1);
LABEL_68:
            int v38 = sub_1DD2F81D8((uint64_t)a2, v15);
            while (1)
            {
              if ((int)sub_1DD2F8334(a2) < 1)
              {
                sub_1DD2F8250((uint64_t)a2, v38);
                goto LABEL_4;
              }
              int v39 = (char *)*a2;
              if (*a2 >= (unint64_t)a2[1])
              {
                int v40 = 0;
              }
              else
              {
                int v40 = *v39;
                if ((*v39 & 0x80000000) == 0)
                {
                  *a2 = (uint64_t)(v39 + 1);
                  goto LABEL_75;
                }
              }
              uint64_t v41 = sub_1DD2F8C30(a2, v40);
              int v40 = v41;
              if (v41 < 0) {
                goto LABEL_105;
              }
LABEL_75:
              int v42 = *(_DWORD *)(a1 + 24);
              if (v42 == *(_DWORD *)(a1 + 28))
              {
                sub_1DD250120((unsigned int *)(a1 + 24), v42 + 1);
                int v42 = *(_DWORD *)(a1 + 24);
              }
              uint64_t v43 = *(void *)(a1 + 32);
              *(_DWORD *)(a1 + 24) = v42 + 1;
              *(_DWORD *)(v43 + 4 * v42 + 8) = v40;
            }
          }
          int v15 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if ((v15 & 0x80000000) == 0) {
            goto LABEL_68;
          }
          goto LABEL_105;
        }
LABEL_41:
        if (v10)
        {
          char v28 = sub_1DD2FB80C((uint64_t)a2, v10, (uint64_t)&v55);
          goto LABEL_43;
        }
        uint64_t v53 = 1;
        goto LABEL_104;
      case 3u:
        if (v10 != 26) {
          goto LABEL_41;
        }
        int v16 = *(int **)(a1 + 64);
        if (!v16)
        {
          int v18 = *(_DWORD *)(a1 + 60);
LABEL_49:
          sub_1DD2FABC8(a1 + 48, v18 + 1);
          int v16 = *(int **)(a1 + 64);
          int v18 = *v16;
          goto LABEL_50;
        }
        uint64_t v17 = *(int *)(a1 + 56);
        int v18 = *v16;
        if ((int)v17 < *v16)
        {
          *(_DWORD *)(a1 + 56) = v17 + 1;
          long long v19 = *(std::string **)&v16[2 * v17 + 2];
          goto LABEL_66;
        }
        if (v18 == *(_DWORD *)(a1 + 60)) {
          goto LABEL_49;
        }
LABEL_50:
        *int v16 = v18 + 1;
        uint64_t v29 = *v7;
        if (*v7)
        {
          if (*(void *)(v29 + 112)) {
            sub_1DD2F5330(*v7, (uint64_t)&unk_1F3878F18, 24);
          }
          long long v19 = (std::string *)sub_1DD2F4FD8(v29, 0x18uLL, (uint64_t)sub_1DD24FB50);
        }
        else
        {
          long long v19 = (std::string *)operator new(0x18uLL);
        }
        v19->__r_.__value_.__r.__words[0] = 0;
        v19->__r_.__value_.__l.__size_ = 0;
        v19->__r_.__value_.__r.__words[2] = 0;
        uint64_t v36 = *(void *)(a1 + 64);
        uint64_t v37 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v37 + 1;
        *(void *)(v36 + 8 * v37 + 8) = v19;
LABEL_66:
        char v28 = sub_1DD2FCF1C(a2, v19);
        goto LABEL_43;
      case 4u:
        if (v10 != 32) {
          goto LABEL_41;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        uint64_t v20 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v21 = 0;
        }
        else
        {
          int v21 = *v20;
          if ((*v20 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 100) = v21;
LABEL_36:
            *a2 = (uint64_t)(v20 + 1);
            continue;
          }
        }
        uint64_t v50 = sub_1DD2F8C30(a2, v21);
        *(_DWORD *)(a1 + 100) = v50;
        if (v50 < 0) {
          goto LABEL_105;
        }
        continue;
      case 5u:
        if (v10 != 40) {
          goto LABEL_41;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v20 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v22 = 0;
        }
        else
        {
          int v22 = *v20;
          if ((*v20 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 104) = v22;
            goto LABEL_36;
          }
        }
        uint64_t v51 = sub_1DD2F8C30(a2, v22);
        *(_DWORD *)(a1 + 104) = v51;
        if (v51 < 0) {
          goto LABEL_105;
        }
        continue;
      case 6u:
        if (v10 != 48) {
          goto LABEL_41;
        }
        *(_DWORD *)(a1 + 16) |= 8u;
        uint64_t v20 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v23 = 0;
        }
        else
        {
          int v23 = *v20;
          if ((*v20 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 108) = v23;
            goto LABEL_36;
          }
        }
        uint64_t v52 = sub_1DD2F8C30(a2, v23);
        *(_DWORD *)(a1 + 108) = v52;
        if (v52 < 0) {
          goto LABEL_105;
        }
        continue;
      case 7u:
        if (v10 != 58) {
          goto LABEL_41;
        }
        int v24 = *(int **)(a1 + 88);
        if (!v24)
        {
          int v26 = *(_DWORD *)(a1 + 84);
LABEL_55:
          sub_1DD2FABC8(a1 + 72, v26 + 1);
          int v24 = *(int **)(a1 + 88);
          int v26 = *v24;
          goto LABEL_56;
        }
        uint64_t v25 = *(int *)(a1 + 80);
        int v26 = *v24;
        if ((int)v25 < *v24)
        {
          *(_DWORD *)(a1 + 80) = v25 + 1;
          uint64_t v27 = *(void **)&v24[2 * v25 + 2];
          goto LABEL_57;
        }
        if (v26 == *(_DWORD *)(a1 + 84)) {
          goto LABEL_55;
        }
LABEL_56:
        int *v24 = v26 + 1;
        uint64_t v27 = sub_1DD24EDC8(*(void *)(a1 + 72));
        uint64_t v30 = *(void *)(a1 + 88);
        uint64_t v31 = *(int *)(a1 + 80);
        *(_DWORD *)(a1 + 80) = v31 + 1;
        *(void *)(v30 + 8 * v31 + 8) = v27;
LABEL_57:
        uint64_t v32 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1] || *v32 < 0)
        {
          int v33 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v33 < 0) {
            goto LABEL_105;
          }
        }
        else
        {
          int v33 = *v32;
          *a2 = (uint64_t)(v32 + 1);
        }
        unint64_t v34 = sub_1DD2F8298((uint64_t)a2, v33);
        int v35 = v34;
        if ((v34 & 0x8000000000000000) == 0 && sub_1DD2457B8((uint64_t)v27, a2))
        {
          char v28 = sub_1DD2F82D0((uint64_t)a2, v35);
LABEL_43:
          if (v28) {
            continue;
          }
        }
LABEL_105:
        uint64_t v53 = 0;
LABEL_104:
        sub_1DD2F92B4(&v55);
        sub_1DD24F874(&v59);
        return v53;
      default:
        goto LABEL_41;
    }
  }
}

void sub_1DD24648C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t *a15)
{
}

uint64_t sub_1DD2464D8(uint64_t a1, unsigned int a2, uint64_t *a3, signed int *a4)
{
  uint64_t v7 = (char *)*a3;
  if (*a3 >= (unint64_t)a3[1])
  {
    int v8 = 0;
  }
  else
  {
    int v8 = *v7;
    if ((*v7 & 0x80000000) == 0)
    {
      *a3 = (uint64_t)(v7 + 1);
      goto LABEL_6;
    }
  }
  uint64_t v9 = sub_1DD2F8C30(a3, v8);
  int v8 = v9;
  if (v9 < 0) {
    return 0;
  }
LABEL_6:
  signed int v10 = *a4;
  if (*a4 == a4[1])
  {
    sub_1DD250120((unsigned int *)a4, v10 + 1);
    signed int v10 = *a4;
  }
  uint64_t v11 = *((void *)a4 + 1);
  *a4 = v10 + 1;
  *(_DWORD *)(v11 + 4 * v10 + 8) = v8;
  int v12 = a4[1] - *a4;
  if (v12 >= 1)
  {
    int v13 = v12 + 1;
    while (1)
    {
      if (a2 > 0x7F)
      {
        if (a2 >> 14) {
          return 1;
        }
        uint64_t v17 = (unsigned __int8 *)*a3;
        unint64_t v14 = a3[1];
        if ((int)(v14 - *a3) < 2 || (a2 & 0x7F | 0x80) != *v17 || v17[1] != (a2 >> 7)) {
          return 1;
        }
        int v16 = (char *)(v17 + 2);
      }
      else
      {
        int v15 = (unsigned __int8 *)*a3;
        unint64_t v14 = a3[1];
        if (*a3 >= v14 || *v15 != a2) {
          return 1;
        }
        int v16 = (char *)(v15 + 1);
      }
      *a3 = (uint64_t)v16;
      if ((unint64_t)v16 >= v14) {
        break;
      }
      int v18 = *v16;
      if (*v16 < 0) {
        goto LABEL_23;
      }
      *a3 = (uint64_t)(v16 + 1);
LABEL_24:
      uint64_t v20 = *((void *)a4 + 1);
      uint64_t v21 = *a4;
      *a4 = v21 + 1;
      *(_DWORD *)(v20 + 4 * v21 + 8) = v18;
      if (--v13 <= 1) {
        return 1;
      }
    }
    int v18 = 0;
LABEL_23:
    uint64_t v19 = sub_1DD2F8C30(a3, v18);
    int v18 = v19;
    if (v19 < 0) {
      return 0;
    }
    goto LABEL_24;
  }
  return 1;
}

uint64_t sub_1DD246668(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4) {
    sub_1DD2FBEA4(1, *(_DWORD *)(a1 + 96), a2);
  }
  if (*(int *)(a1 + 24) >= 1)
  {
    if (*(int *)(a2 + 16) < 5)
    {
      sub_1DD2F9508(a2, 0x12u);
      int v5 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      *(unsigned char *)(*(void *)(a2 + 8))++ = 18;
      int v5 = *(_DWORD *)(a2 + 16) - 1;
      *(_DWORD *)(a2 + 16) = v5;
    }
    unsigned int v6 = *(_DWORD *)(a1 + 40);
    if (v5 < 5)
    {
      sub_1DD2F9508(a2, v6);
    }
    else
    {
      uint64_t v7 = *(void *)(a2 + 8);
      if (v6 < 0x80)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 40);
        int v8 = *(unsigned char **)(a2 + 8);
      }
      else
      {
        int v8 = *(unsigned char **)(a2 + 8);
        do
        {
          *v8++ = v6 | 0x80;
          unsigned int v9 = v6 >> 7;
          unsigned int v10 = v6 >> 14;
          v6 >>= 7;
        }
        while (v10);
      }
      *int v8 = v9;
      int v11 = v8 - v7 + 1;
      *(void *)(a2 + 8) += v11;
      *(_DWORD *)(a2 + 16) -= v11;
    }
    uint64_t v12 = *(unsigned int *)(a1 + 24);
    if ((int)v12 >= 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i + 8);
        if (*(int *)(a2 + 16) < 5)
        {
          sub_1DD2F9508(a2, v14);
        }
        else
        {
          uint64_t v15 = *(void *)(a2 + 8);
          if (v14 < 0x80)
          {
            unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i + 8);
            int v16 = *(unsigned char **)(a2 + 8);
          }
          else
          {
            int v16 = *(unsigned char **)(a2 + 8);
            do
            {
              *v16++ = v14 | 0x80;
              unsigned int v17 = v14 >> 7;
              unsigned int v18 = v14 >> 14;
              v14 >>= 7;
            }
            while (v18);
          }
          *int v16 = v17;
          int v19 = v16 - v15 + 1;
          *(void *)(a2 + 8) += v19;
          *(_DWORD *)(a2 + 16) -= v19;
        }
      }
    }
  }
  uint64_t v20 = *(unsigned int *)(a1 + 56);
  if ((int)v20 >= 1)
  {
    uint64_t v21 = 0;
    uint64_t v22 = 8 * v20;
    do
    {
      sub_1DD2FC6A4(3, *(void *)(*(void *)(a1 + 64) + v21 + 8), a2);
      v21 += 8;
    }
    while (v22 != v21);
  }
  if ((v4 & 2) != 0)
  {
    sub_1DD2FBFC4(4, *(_DWORD *)(a1 + 100), a2);
    if ((v4 & 4) == 0)
    {
LABEL_31:
      if ((v4 & 8) == 0) {
        goto LABEL_33;
      }
      goto LABEL_32;
    }
  }
  else if ((v4 & 4) == 0)
  {
    goto LABEL_31;
  }
  sub_1DD2FBFC4(5, *(_DWORD *)(a1 + 104), a2);
  if ((v4 & 8) != 0) {
LABEL_32:
  }
    sub_1DD2FBFC4(6, *(_DWORD *)(a1 + 108), a2);
LABEL_33:
  int v23 = *(_DWORD *)(a1 + 80);
  if (v23)
  {
    for (int j = 0; j != v23; ++j)
      sub_1DD2FCDAC(7, *(void *)(*(void *)(a1 + 88) + 8 * j + 8), a2);
  }
  uint64_t v25 = *(void *)(a1 + 8);
  if (v25) {
    int v26 = (char *)(v25 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v26 = (char *)&qword_1EAB1F7D8;
  }
  if (v26[23] < 0) {
    int v26 = *(char **)v26;
  }
  if (v25) {
    uint64_t v27 = (uint64_t *)(v25 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v27 = &qword_1EAB1F7D8;
  }
  if (*((char *)v27 + 23) < 0) {
    uint64_t v28 = v27[1];
  }
  else {
    LODWORD(v28) = *((unsigned __int8 *)v27 + 23);
  }
  return sub_1DD2F92E0(a2, v26, v28);
}

uint64_t sub_1DD246918(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = sub_1DD2FD008((unsigned int *)(a1 + 24));
  uint64_t v6 = 11;
  uint64_t v7 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((int)v5 >= 0) {
    uint64_t v6 = v7;
  }
  uint64_t v8 = v6 + v4;
  if (v5) {
    int v9 = v5;
  }
  else {
    int v9 = 0;
  }
  if (!v5) {
    uint64_t v8 = v4;
  }
  *(_DWORD *)(a1 + 40) = v9;
  uint64_t v10 = *(unsigned int *)(a1 + 56);
  uint64_t v11 = v8 + v5 + v10;
  if ((int)v10 >= 1)
  {
    uint64_t v12 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v13 = *v12++;
      uint64_t v14 = *(unsigned __int8 *)(v13 + 23);
      uint64_t v15 = *(void *)(v13 + 8);
      if ((v14 & 0x80u) == 0) {
        uint64_t v15 = v14;
      }
      v11 += v15 + ((9 * (__clz(v15 | 1) ^ 0x1F) + 73) >> 6);
      --v10;
    }
    while (v10);
  }
  uint64_t v16 = *(unsigned int *)(a1 + 80);
  uint64_t v17 = v11 + v16;
  if (v16)
  {
    int v18 = 0;
    do
    {
      uint64_t v19 = sub_1DD245A48(*(void *)(*(void *)(a1 + 88) + 8 * v18 + 8));
      v17 += v19 + ((9 * (__clz(v19 | 1) ^ 0x1F) + 73) >> 6);
      ++v18;
    }
    while (v16 != v18);
  }
  int v20 = *(_DWORD *)(a1 + 16);
  if ((v20 & 0xF) == 0) {
    goto LABEL_28;
  }
  if (v20)
  {
    int v22 = *(_DWORD *)(a1 + 96);
    uint64_t v23 = ((9 * (__clz(v22 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v22 >= 0) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 11;
    }
    v17 += v24;
    if ((v20 & 2) == 0)
    {
LABEL_25:
      if ((v20 & 4) == 0) {
        goto LABEL_26;
      }
LABEL_34:
      v17 += ((9 * (__clz(*(_DWORD *)(a1 + 104) | 1) ^ 0x1F) + 73) >> 6) + 1;
      if ((v20 & 8) == 0) {
        goto LABEL_28;
      }
      goto LABEL_27;
    }
  }
  else if ((v20 & 2) == 0)
  {
    goto LABEL_25;
  }
  v17 += ((9 * (__clz(*(_DWORD *)(a1 + 100) | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v20 & 4) != 0) {
    goto LABEL_34;
  }
LABEL_26:
  if ((v20 & 8) != 0) {
LABEL_27:
  }
    v17 += ((9 * (__clz(*(_DWORD *)(a1 + 108) | 1) ^ 0x1F) + 73) >> 6) + 1;
LABEL_28:
  *(_DWORD *)(a1 + 20) = v17;
  return v17;
}

unint64_t *sub_1DD246B2C(unint64_t *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = (unint64_t *)sub_1DD24FBB0(result + 1, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((int *)v3 + 6);
    sub_1DD250120((unsigned int *)v3 + 6, v6 + v5);
    unint64_t v7 = v3[4];
    *((_DWORD *)v3 + 6) += *(_DWORD *)(a2 + 24);
    __n128 result = (unint64_t *)memcpy((void *)(v7 + 4 * v6 + 8), (const void *)(*(void *)(a2 + 32) + 8), 4 * *(int *)(a2 + 24));
  }
  unsigned int v8 = *(_DWORD *)(a2 + 56);
  if (v8)
  {
    int v9 = (const std::string **)(*(void *)(a2 + 64) + 8);
    uint64_t v10 = (std::string **)sub_1DD2FAAC0((uint64_t)(v3 + 6), *(_DWORD *)(a2 + 56));
    __n128 result = (unint64_t *)sub_1DD250250((std::string *)v3 + 2, v10, v9, v8, *(_DWORD *)v3[8] - *((_DWORD *)v3 + 14));
    signed int v11 = *((_DWORD *)v3 + 14) + v8;
    *((_DWORD *)v3 + 14) = v11;
    uint64_t v12 = (signed int *)v3[8];
    if (*v12 < v11) {
      signed int *v12 = v11;
    }
  }
  unsigned int v13 = *(_DWORD *)(a2 + 80);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)(*(void *)(a2 + 88) + 8);
    uint64_t v15 = (std::string **)sub_1DD2FAAC0((uint64_t)(v3 + 9), *(_DWORD *)(a2 + 80));
    __n128 result = (unint64_t *)sub_1DD250354((std::string *)v3 + 3, v15, v14, v13, *(_DWORD *)v3[11] - *((_DWORD *)v3 + 20));
    signed int v16 = *((_DWORD *)v3 + 20) + v13;
    *((_DWORD *)v3 + 20) = v16;
    uint64_t v17 = (signed int *)v3[11];
    if (*v17 < v16) {
      *uint64_t v17 = v16;
    }
  }
  int v18 = *(_DWORD *)(a2 + 16);
  if ((v18 & 0xF) != 0)
  {
    if (v18)
    {
      *((_DWORD *)v3 + 24) = *(_DWORD *)(a2 + 96);
      if ((v18 & 2) == 0)
      {
LABEL_14:
        if ((v18 & 4) == 0) {
          goto LABEL_15;
        }
        goto LABEL_21;
      }
    }
    else if ((v18 & 2) == 0)
    {
      goto LABEL_14;
    }
    *((_DWORD *)v3 + 25) = *(_DWORD *)(a2 + 100);
    if ((v18 & 4) == 0)
    {
LABEL_15:
      if ((v18 & 8) == 0)
      {
LABEL_17:
        *((_DWORD *)v3 + 4) |= v18;
        return result;
      }
LABEL_16:
      *((_DWORD *)v3 + 27) = *(_DWORD *)(a2 + 108);
      goto LABEL_17;
    }
LABEL_21:
    *((_DWORD *)v3 + 26) = *(_DWORD *)(a2 + 104);
    if ((v18 & 8) == 0) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  return result;
}

unint64_t *sub_1DD246CE0(unint64_t *result, uint64_t a2)
{
  if ((unint64_t *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD245D9C((uint64_t)result);
    return sub_1DD246B2C(v4, a2);
  }
  return result;
}

uint64_t sub_1DD246D2C()
{
  return 1;
}

void *sub_1DD246D34@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.Type");
}

uint64_t sub_1DD246D44(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C4D8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8AC220, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC220);
  }
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  return a1;
}

void sub_1DD246DD0(_Unwind_Exception *a1)
{
  sub_1DD2500A0(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD246DF4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C4D8;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (unint64_t *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  int v5 = (std::string *)(a1 + 24);
  *(_DWORD *)(a1 + 44) = 0;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 20) = 0;
  unsigned int v6 = *(_DWORD *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = *(void *)(a2 + 40);
    unsigned int v8 = (std::string **)sub_1DD2FAAC0(a1 + 24, *(_DWORD *)(a2 + 32));
    sub_1DD250250(v5, v8, (const std::string **)(v7 + 8), v6, **(_DWORD **)(a1 + 40) - *(_DWORD *)(a1 + 32));
    signed int v9 = *(_DWORD *)(a1 + 32) + v6;
    *(_DWORD *)(a1 + 32) = v9;
    uint64_t v10 = *(signed int **)(a1 + 40);
    if (*v10 < v9) {
      signed int *v10 = v9;
    }
  }
  uint64_t v11 = *(void *)(a2 + 8);
  if (v11) {
    sub_1DD24FBB0(v4, v11 & 0xFFFFFFFFFFFFFFFELL);
  }
  long long v12 = *(_OWORD *)(a2 + 48);
  long long v13 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v13;
  *(_OWORD *)(a1 + 48) = v12;
  return a1;
}

void sub_1DD246EEC(_Unwind_Exception *a1)
{
  sub_1DD2500A0(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD246F18(void *a1)
{
  *a1 = &unk_1F387C4D8;
  sub_1DD2500A0(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD246F6C(void *a1)
{
  uint64_t v1 = sub_1DD246F18(a1);
  operator delete(v1);
}

void sub_1DD246F94(uint64_t a1)
{
  sub_1DD24FB64(a1 + 24);
  if ((*(unsigned char *)(a1 + 16) & 0x3F) != 0)
  {
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
  }
  char v3 = *(unsigned char *)(a1 + 8);
  uint64_t v2 = a1 + 8;
  *(_DWORD *)(v2 + 8) = 0;
  if (v3)
  {
    sub_1DD24FC0C((unint64_t *)v2);
  }
}

uint64_t sub_1DD247000(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v33 = (uint64_t *)(a1 + 8);
  long long v34 = 0uLL;
  uint64_t v35 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v35 = *(void *)(v5 + 16);
    long long v34 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v32, (uint64_t)&v34);
  sub_1DD2F9178((uint64_t)v31, (uint64_t)v32, 0);
  uint64_t v7 = (uint64_t *)(a1 + 24);
  while (1)
  {
    while (1)
    {
      unsigned int v8 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1]) {
        break;
      }
      uint64_t v9 = 0;
LABEL_9:
      unsigned int v11 = sub_1DD2F8F70((uint64_t)a2, v9);
      unint64_t v10 = v11 | ((unint64_t)(v11 - 1 < 0x7F) << 32);
      if ((v10 & 0x100000000) == 0) {
        goto LABEL_40;
      }
LABEL_10:
      switch(v10 >> 3)
      {
        case 1u:
          if (v10 != 8) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 1u;
          long long v12 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 48);
            goto LABEL_35;
          }
          *(void *)(a1 + 48) = sub_1DD2F8A78((uint64_t)a2);
          if ((v20 & 1) == 0) {
            goto LABEL_68;
          }
          continue;
        case 2u:
          if (v10 != 16) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 2u;
          long long v12 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 56);
            goto LABEL_35;
          }
          *(void *)(a1 + 56) = sub_1DD2F8A78((uint64_t)a2);
          if ((v21 & 1) == 0) {
            goto LABEL_68;
          }
          continue;
        case 3u:
          if (v10 != 24) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 4u;
          long long v12 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 64);
            goto LABEL_35;
          }
          *(void *)(a1 + 64) = sub_1DD2F8A78((uint64_t)a2);
          if ((v22 & 1) == 0) {
            goto LABEL_68;
          }
          continue;
        case 4u:
          if (v10 != 32) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 8u;
          long long v12 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 72);
            goto LABEL_35;
          }
          *(void *)(a1 + 72) = sub_1DD2F8A78((uint64_t)a2);
          if ((v23 & 1) == 0) {
            goto LABEL_68;
          }
          continue;
        case 5u:
          if (v10 != 40) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 0x10u;
          long long v12 = (char *)*a2;
          if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 80);
            goto LABEL_35;
          }
          *(void *)(a1 + 80) = sub_1DD2F8A78((uint64_t)a2);
          if ((v24 & 1) == 0) {
            goto LABEL_68;
          }
          continue;
        case 6u:
          if (v10 != 48) {
            goto LABEL_40;
          }
          *(_DWORD *)(a1 + 16) |= 0x20u;
          long long v12 = (char *)*a2;
          if (*a2 >= (unint64_t)a2[1] || *v12 < 0)
          {
            *(void *)(a1 + 88) = sub_1DD2F8A78((uint64_t)a2);
            if ((v25 & 1) == 0)
            {
LABEL_68:
              uint64_t v29 = 0;
              goto LABEL_67;
            }
          }
          else
          {
            uint64_t v13 = *v12;
            uint64_t v14 = (void *)(a1 + 88);
LABEL_35:
            void *v14 = v13;
            *a2 = (uint64_t)(v12 + 1);
          }
          break;
        case 7u:
          if (v10 != 58) {
            goto LABEL_40;
          }
          uint64_t v15 = *(int **)(a1 + 40);
          if (!v15)
          {
            int v17 = *(_DWORD *)(a1 + 36);
LABEL_58:
            sub_1DD2FABC8(a1 + 24, v17 + 1);
            uint64_t v15 = *(int **)(a1 + 40);
            int v17 = *v15;
            goto LABEL_59;
          }
          uint64_t v16 = *(int *)(a1 + 32);
          int v17 = *v15;
          if ((int)v16 < *v15)
          {
            *(_DWORD *)(a1 + 32) = v16 + 1;
            int v18 = *(std::string **)&v15[2 * v16 + 2];
            goto LABEL_65;
          }
          if (v17 == *(_DWORD *)(a1 + 36)) {
            goto LABEL_58;
          }
LABEL_59:
          *uint64_t v15 = v17 + 1;
          uint64_t v26 = *v7;
          if (*v7)
          {
            if (*(void *)(v26 + 112)) {
              sub_1DD2F5330(*v7, (uint64_t)&unk_1F3878F18, 24);
            }
            int v18 = (std::string *)sub_1DD2F4FD8(v26, 0x18uLL, (uint64_t)sub_1DD24FB50);
          }
          else
          {
            int v18 = (std::string *)operator new(0x18uLL);
          }
          v18->__r_.__value_.__r.__words[0] = 0;
          v18->__r_.__value_.__l.__size_ = 0;
          v18->__r_.__value_.__r.__words[2] = 0;
          uint64_t v27 = *(void *)(a1 + 40);
          uint64_t v28 = *(int *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v28 + 1;
          *(void *)(v27 + 8 * v28 + 8) = v18;
LABEL_65:
          BOOL v19 = sub_1DD2FCF1C(a2, v18);
          goto LABEL_42;
        default:
          goto LABEL_40;
      }
    }
    uint64_t v9 = *v8;
    if (*v8 < 1) {
      goto LABEL_9;
    }
    *a2 = (uint64_t)(v8 + 1);
    unint64_t v10 = v9 | 0x100000000;
    if ((v10 & 0x100000000) != 0) {
      goto LABEL_10;
    }
LABEL_40:
    if (!v10) {
      break;
    }
    BOOL v19 = sub_1DD2FB80C((uint64_t)a2, v10, (uint64_t)v31);
LABEL_42:
    if (!v19) {
      goto LABEL_68;
    }
  }
  uint64_t v29 = 1;
LABEL_67:
  sub_1DD2F92B4(v31);
  sub_1DD24F874(&v33);
  return v29;
}

void sub_1DD247434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD247478(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC0E4(1, *(void *)(a1 + 48), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_23;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FC0E4(2, *(void *)(a1 + 56), a2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_24;
  }
LABEL_23:
  sub_1DD2FC0E4(3, *(void *)(a1 + 64), a2);
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_25;
  }
LABEL_24:
  sub_1DD2FC0E4(4, *(void *)(a1 + 72), a2);
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x20) == 0) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_25:
  sub_1DD2FC0E4(5, *(void *)(a1 + 80), a2);
  if ((v4 & 0x20) != 0) {
LABEL_7:
  }
    sub_1DD2FC0E4(6, *(void *)(a1 + 88), a2);
LABEL_8:
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if ((int)v5 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 8 * v5;
    do
    {
      sub_1DD2FCA28(7, *(void *)(*(void *)(a1 + 40) + v6 + 8), a2);
      v6 += 8;
    }
    while (v7 != v6);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  if (v8) {
    uint64_t v9 = (char *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v9 = (char *)&qword_1EAB1F7D8;
  }
  if (v9[23] < 0) {
    uint64_t v9 = *(char **)v9;
  }
  if (v8) {
    unint64_t v10 = (uint64_t *)(v8 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v10 = &qword_1EAB1F7D8;
  }
  if (*((char *)v10 + 23) < 0) {
    uint64_t v11 = v10[1];
  }
  else {
    LODWORD(v11) = *((unsigned __int8 *)v10 + 23);
  }
  return sub_1DD2F92E0(a2, v9, v11);
}

uint64_t sub_1DD2475CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  uint64_t v5 = v3 + v4;
  if ((int)v4 >= 1)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v7 = *v6++;
      uint64_t v8 = *(unsigned __int8 *)(v7 + 23);
      uint64_t v9 = *(void *)(v7 + 8);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = v8;
      }
      v5 += v9 + ((9 * (__clz(v9 | 1) ^ 0x1F) + 73) >> 6);
      --v4;
    }
    while (v4);
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x3F) == 0) {
    goto LABEL_20;
  }
  if (v10)
  {
    v5 += ((9 * (__clz(*(void *)(a1 + 48) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v10 & 2) == 0)
    {
LABEL_15:
      if ((v10 & 4) == 0) {
        goto LABEL_16;
      }
      goto LABEL_23;
    }
  }
  else if ((v10 & 2) == 0)
  {
    goto LABEL_15;
  }
  v5 += ((9 * (__clz(*(void *)(a1 + 56) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v10 & 4) == 0)
  {
LABEL_16:
    if ((v10 & 8) == 0) {
      goto LABEL_17;
    }
    goto LABEL_24;
  }
LABEL_23:
  v5 += ((9 * (__clz(*(void *)(a1 + 64) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v10 & 8) == 0)
  {
LABEL_17:
    if ((v10 & 0x10) == 0) {
      goto LABEL_18;
    }
LABEL_25:
    v5 += ((9 * (__clz(*(void *)(a1 + 80) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v10 & 0x20) == 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
LABEL_24:
  v5 += ((9 * (__clz(*(void *)(a1 + 72) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v10 & 0x10) != 0) {
    goto LABEL_25;
  }
LABEL_18:
  if ((v10 & 0x20) != 0) {
LABEL_19:
  }
    v5 += ((9 * (__clz(*(void *)(a1 + 88) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_20:
  *(_DWORD *)(a1 + 20) = v5;
  return v5;
}

std::string *sub_1DD24775C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (const std::string **)(*(void *)(a2 + 40) + 8);
    uint64_t v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    __n128 result = sub_1DD250250(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  int v10 = *(_DWORD *)(a2 + 16);
  if ((v10 & 0x3F) != 0)
  {
    if (v10)
    {
      v3[2].__r_.__value_.__r.__words[0] = *(void *)(a2 + 48);
      if ((v10 & 2) == 0)
      {
LABEL_9:
        if ((v10 & 4) == 0) {
          goto LABEL_10;
        }
        goto LABEL_18;
      }
    }
    else if ((v10 & 2) == 0)
    {
      goto LABEL_9;
    }
    v3[2].__r_.__value_.__l.__size_ = *(void *)(a2 + 56);
    if ((v10 & 4) == 0)
    {
LABEL_10:
      if ((v10 & 8) == 0) {
        goto LABEL_11;
      }
      goto LABEL_19;
    }
LABEL_18:
    v3[2].__r_.__value_.__r.__words[2] = *(void *)(a2 + 64);
    if ((v10 & 8) == 0)
    {
LABEL_11:
      if ((v10 & 0x10) == 0) {
        goto LABEL_12;
      }
      goto LABEL_20;
    }
LABEL_19:
    v3[3].__r_.__value_.__r.__words[0] = *(void *)(a2 + 72);
    if ((v10 & 0x10) == 0)
    {
LABEL_12:
      if ((v10 & 0x20) == 0)
      {
LABEL_14:
        LODWORD(v3->__r_.__value_.__r.__words[2]) |= v10;
        return result;
      }
LABEL_13:
      v3[3].__r_.__value_.__r.__words[2] = *(void *)(a2 + 88);
      goto LABEL_14;
    }
LABEL_20:
    v3[3].__r_.__value_.__l.__size_ = *(void *)(a2 + 80);
    if ((v10 & 0x20) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  return result;
}

std::string *sub_1DD247880(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD246F94((uint64_t)result);
    return sub_1DD24775C(v4, a2);
  }
  return result;
}

uint64_t sub_1DD2478CC()
{
  return 1;
}

void *sub_1DD2478D4@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StripeInformation");
}

void *sub_1DD2478E4(void *a1)
{
  *a1 = &unk_1F387C258;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC1C0, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC1C0);
  }
  a1[3] = &qword_1EAB1F7D8;
  a1[4] = &qword_1EAB1F7D8;
  return a1;
}

void sub_1DD24795C(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD247970(void *a1)
{
  *a1 = &unk_1F387C258;
  uint64_t v2 = a1 + 1;
  sub_1DD2455F8((uint64_t)a1);
  sub_1DD24F770(v2);
  return a1;
}

void sub_1DD2479C0(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387C258;
  uint64_t v2 = a1 + 1;
  sub_1DD2455F8((uint64_t)a1);
  sub_1DD24F770(v2);
  operator delete(a1);
}

void sub_1DD247A20(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if ((v1 & 3) == 0) {
    goto LABEL_11;
  }
  if ((v1 & 1) == 0)
  {
LABEL_5:
    if ((v1 & 2) != 0) {
      goto LABEL_6;
    }
    goto LABEL_11;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if ((*(char *)(v2 + 23) & 0x80000000) == 0)
  {
    *(unsigned char *)uint64_t v2 = 0;
    *(unsigned char *)(v2 + 23) = 0;
    goto LABEL_5;
  }
  **(unsigned char **)uint64_t v2 = 0;
  *(void *)(v2 + 8) = 0;
  if ((v1 & 2) != 0)
  {
LABEL_6:
    uint64_t v3 = *(void *)(a1 + 32);
    if (*(char *)(v3 + 23) < 0)
    {
      **(unsigned char **)uint64_t v3 = 0;
      *(void *)(v3 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v3 = 0;
      *(unsigned char *)(v3 + 23) = 0;
    }
  }
LABEL_11:
  char v5 = *(unsigned char *)(a1 + 8);
  uint64_t v4 = a1 + 8;
  *(_DWORD *)(v4 + 8) = 0;
  if (v5) {
    sub_1DD24FC0C((unint64_t *)v4);
  }
}

uint64_t sub_1DD247A94(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v18 = (uint64_t *)(a1 + 8);
  long long v19 = 0uLL;
  uint64_t v20 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v20 = *(void *)(v5 + 16);
    long long v19 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v17, (uint64_t)&v19);
  sub_1DD2F9178((uint64_t)v16, (uint64_t)v17, 0);
  while (1)
  {
    uint64_t v7 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if (*v7 >= 1)
      {
        *a2 = (uint64_t)(v7 + 1);
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_23;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_23;
    }
LABEL_10:
    if (v9 >> 3 != 2) {
      break;
    }
    if (v9 != 18) {
      goto LABEL_23;
    }
    *(_DWORD *)(a1 + 16) |= 2u;
    long long v12 = *(std::string **)(a1 + 32);
    if (v12 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 32), (uint64_t)&qword_1EAB1F7D8);
      long long v12 = *(std::string **)(a1 + 32);
    }
LABEL_18:
    BOOL v13 = sub_1DD2FCF1C(a2, v12);
LABEL_25:
    if (!v13)
    {
      uint64_t v14 = 0;
      goto LABEL_28;
    }
  }
  if (v9 >> 3 == 1 && v9 == 10)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    long long v12 = *(std::string **)(a1 + 24);
    if (v12 == (std::string *)&qword_1EAB1F7D8)
    {
      sub_1DD24F908((void *)(a1 + 24), (uint64_t)&qword_1EAB1F7D8);
      long long v12 = *(std::string **)(a1 + 24);
    }
    goto LABEL_18;
  }
LABEL_23:
  if (v9)
  {
    BOOL v13 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v16);
    goto LABEL_25;
  }
  uint64_t v14 = 1;
LABEL_28:
  sub_1DD2F92B4(v16);
  sub_1DD24F874(&v18);
  return v14;
}

void sub_1DD247C48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD247C70(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4) {
    sub_1DD2FC85C(1, *(void *)(a1 + 24), a2);
  }
  if ((v4 & 2) != 0) {
    sub_1DD2FCBE0(2, *(void *)(a1 + 32), a2);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD247D24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 3) != 0)
  {
    if (v4)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      uint64_t v6 = *(unsigned __int8 *)(v5 + 23);
      uint64_t v7 = *(void *)(v5 + 8);
      if ((v6 & 0x80u) == 0) {
        uint64_t v7 = v6;
      }
      v3 += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
    if ((v4 & 2) != 0)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(unsigned __int8 *)(v8 + 23);
      uint64_t v10 = *(void *)(v8 + 8);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = v9;
      }
      v3 += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6) + 1;
    }
  }
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

uint64_t sub_1DD247DEC()
{
  return 1;
}

void *sub_1DD247DF4@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.UserMetadataItem");
}

uint64_t sub_1DD247E04(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C1B8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8AC1A8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC1A8);
  }
  return a1;
}

void sub_1DD247E84(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD247EA4(void *a1)
{
  *a1 = &unk_1F387C1B8;
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD247EF8(void *a1)
{
  uint64_t v1 = sub_1DD247EA4(a1);
  operator delete(v1);
}

void sub_1DD247F20(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD23FE68(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6)
  {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD247FA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v27 = (uint64_t *)(a1 + 8);
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v29 = *(void *)(v5 + 16);
    long long v28 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v26, (uint64_t)&v28);
  sub_1DD2F9178((uint64_t)v25, (uint64_t)v26, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if ((char)*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          break;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      break;
    }
LABEL_10:
    if (v9 != 10 || (v9 & 0xFFFFFFF8) != 8) {
      break;
    }
    BOOL v13 = *(int **)(a1 + 40);
    if (!v13)
    {
      int v15 = *(_DWORD *)(a1 + 36);
LABEL_21:
      sub_1DD2FABC8(a1 + 24, v15 + 1);
      BOOL v13 = *(int **)(a1 + 40);
      int v15 = *v13;
      goto LABEL_22;
    }
    uint64_t v14 = *(int *)(a1 + 32);
    int v15 = *v13;
    if ((int)v14 < *v13)
    {
      *(_DWORD *)(a1 + 32) = v14 + 1;
      uint64_t v16 = *(void **)&v13[2 * v14 + 2];
      goto LABEL_23;
    }
    if (v15 == *(_DWORD *)(a1 + 36)) {
      goto LABEL_21;
    }
LABEL_22:
    *BOOL v13 = v15 + 1;
    uint64_t v16 = sub_1DD24E894(*(void *)(a1 + 24));
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(int *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(void *)(v17 + 8 * v18 + 8) = v16;
LABEL_23:
    long long v19 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || *v19 < 0)
    {
      int v20 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v20 < 0) {
        goto LABEL_31;
      }
    }
    else
    {
      int v20 = *v19;
      *(void *)a2 = v19 + 1;
    }
    unint64_t v21 = sub_1DD2F8298(a2, v20);
    int v22 = v21;
    if ((v21 & 0x8000000000000000) != 0 || !sub_1DD23FF78((uint64_t)v16, a2))
    {
LABEL_31:
      uint64_t v23 = 0;
      goto LABEL_33;
    }
    BOOL v12 = sub_1DD2F82D0(a2, v22);
LABEL_30:
    if (!v12) {
      goto LABEL_31;
    }
  }
  if (v9)
  {
    BOOL v12 = sub_1DD2FB80C(a2, v9, (uint64_t)v25);
    goto LABEL_30;
  }
  uint64_t v23 = 1;
LABEL_33:
  sub_1DD2F92B4(v25);
  sub_1DD24F874(&v27);
  return v23;
}

void sub_1DD2481B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2481D8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6) {
    uint64_t v7 = (char *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = (char *)&qword_1EAB1F7D8;
  }
  if (v7[23] < 0) {
    uint64_t v7 = *(char **)v7;
  }
  if (v6) {
    uint64_t v8 = (uint64_t *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v8 = &qword_1EAB1F7D8;
  }
  if (*((char *)v8 + 23) < 0) {
    uint64_t v9 = v8[1];
  }
  else {
    LODWORD(v9) = *((unsigned __int8 *)v8 + 23);
  }
  return sub_1DD2F92E0(a2, v7, v9);
}

uint64_t sub_1DD248290(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2408E8(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  *(_DWORD *)(a1 + 20) = v6;
  return v6;
}

std::string *sub_1DD24833C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], v5);
    __n128 result = sub_1DD250414(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  return result;
}

uint64_t sub_1DD2483E0()
{
  return 1;
}

void *sub_1DD2483E8@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.StripeStatistics");
}

uint64_t sub_1DD2483F8(uint64_t a1)
{
  *(void *)a1 = &unk_1F387CA78;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8AC010, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC010);
  }
  return a1;
}

void sub_1DD248478(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24849C(void *a1)
{
  *a1 = &unk_1F387CA78;
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD2484F0(void *a1)
{
  uint64_t v1 = sub_1DD24849C(a1);
  operator delete(v1);
}

void sub_1DD248518(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD247F20(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  char v6 = *(unsigned char *)(a1 + 8);
  uint64_t v5 = a1 + 8;
  *(_DWORD *)(v5 + 8) = 0;
  if (v6)
  {
    sub_1DD24FC0C((unint64_t *)v5);
  }
}

uint64_t sub_1DD248598(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v27 = (uint64_t *)(a1 + 8);
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v29 = *(void *)(v5 + 16);
    long long v28 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v26, (uint64_t)&v28);
  sub_1DD2F9178((uint64_t)v25, (uint64_t)v26, 0);
  while (1)
  {
    int v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8))
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v8 = *v7;
      if ((char)*v7 >= 1)
      {
        *(void *)a2 = v7 + 1;
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          break;
        }
        goto LABEL_10;
      }
    }
    unsigned int v10 = sub_1DD2F8F70(a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      break;
    }
LABEL_10:
    if (v9 != 10 || (v9 & 0xFFFFFFF8) != 8) {
      break;
    }
    BOOL v13 = *(int **)(a1 + 40);
    if (!v13)
    {
      int v15 = *(_DWORD *)(a1 + 36);
LABEL_21:
      sub_1DD2FABC8(a1 + 24, v15 + 1);
      BOOL v13 = *(int **)(a1 + 40);
      int v15 = *v13;
      goto LABEL_22;
    }
    uint64_t v14 = *(int *)(a1 + 32);
    int v15 = *v13;
    if ((int)v14 < *v13)
    {
      *(_DWORD *)(a1 + 32) = v14 + 1;
      uint64_t v16 = *(void **)&v13[2 * v14 + 2];
      goto LABEL_23;
    }
    if (v15 == *(_DWORD *)(a1 + 36)) {
      goto LABEL_21;
    }
LABEL_22:
    *BOOL v13 = v15 + 1;
    uint64_t v16 = sub_1DD24F018(*(void *)(a1 + 24));
    uint64_t v17 = *(void *)(a1 + 40);
    uint64_t v18 = *(int *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = v18 + 1;
    *(void *)(v17 + 8 * v18 + 8) = v16;
LABEL_23:
    long long v19 = *(char **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8) || *v19 < 0)
    {
      int v20 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v20 < 0) {
        goto LABEL_31;
      }
    }
    else
    {
      int v20 = *v19;
      *(void *)a2 = v19 + 1;
    }
    unint64_t v21 = sub_1DD2F8298(a2, v20);
    int v22 = v21;
    if ((v21 & 0x8000000000000000) != 0 || !sub_1DD247FA0((uint64_t)v16, a2))
    {
LABEL_31:
      uint64_t v23 = 0;
      goto LABEL_33;
    }
    BOOL v12 = sub_1DD2F82D0(a2, v22);
LABEL_30:
    if (!v12) {
      goto LABEL_31;
    }
  }
  if (v9)
  {
    BOOL v12 = sub_1DD2FB80C(a2, v9, (uint64_t)v25);
    goto LABEL_30;
  }
  uint64_t v23 = 1;
LABEL_33:
  sub_1DD2F92B4(v25);
  sub_1DD24F874(&v27);
  return v23;
}

void sub_1DD2487A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2487D0(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6) {
    int v7 = (char *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v7 = (char *)&qword_1EAB1F7D8;
  }
  if (v7[23] < 0) {
    int v7 = *(char **)v7;
  }
  if (v6) {
    uint64_t v8 = (uint64_t *)(v6 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v8 = &qword_1EAB1F7D8;
  }
  if (*((char *)v8 + 23) < 0) {
    uint64_t v9 = v8[1];
  }
  else {
    LODWORD(v9) = *((unsigned __int8 *)v8 + 23);
  }
  return sub_1DD2F92E0(a2, v7, v9);
}

uint64_t sub_1DD248888(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD248290(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  *(_DWORD *)(a1 + 20) = v6;
  return v6;
}

std::string *sub_1DD248934(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    __n128 result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], v5);
    __n128 result = sub_1DD2504D4(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  return result;
}

uint64_t sub_1DD2489D8()
{
  return 1;
}

void *sub_1DD2489E0@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.Metadata");
}

uint64_t sub_1DD2489F0(uint64_t a1)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)a1 = &unk_1F387C938;
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = 0;
  if (atomic_load_explicit(dword_1EC8ABFF8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABFF8);
  }
  *(void *)(a1 + 72) = &qword_1EAB1F7D8;
  return a1;
}

void sub_1DD248A84(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v3);
  sub_1DD2500A0(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD248AAC(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C938;
  sub_1DD248B24(a1);
  if (*(int *)(a1 + 52) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 56);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  sub_1DD2500A0((void *)(a1 + 24));
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD248B24(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if ((uint64_t *)v1 != &qword_1EAB1F7D8 && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete((void *)v1);
  }
}

void sub_1DD248B8C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD248AAC(a1);
  operator delete(v1);
}

void sub_1DD248BB4(uint64_t a1)
{
  sub_1DD24FB64(a1 + 24);
  *(_DWORD *)(a1 + 48) = 0;
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v2 = *(void *)(a1 + 72);
    if (*(char *)(v2 + 23) < 0)
    {
      **(unsigned char **)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v2 = 0;
      *(unsigned char *)(v2 + 23) = 0;
    }
  }
  char v4 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  *(_DWORD *)(v3 + 8) = 0;
  if (v4)
  {
    sub_1DD24FC0C((unint64_t *)v3);
  }
}

uint64_t sub_1DD248C38(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  long long v34 = (uint64_t *)(a1 + 8);
  long long v35 = 0uLL;
  uint64_t v36 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v36 = *(void *)(v5 + 16);
    long long v35 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v33, (uint64_t)&v35);
  sub_1DD2F9178((uint64_t)v32, (uint64_t)v33, 0);
  int v7 = (uint64_t *)(a1 + 24);
LABEL_4:
  while (2)
  {
    signed int v8 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      uint64_t v9 = 0;
LABEL_9:
      unsigned int v11 = sub_1DD2F8F70((uint64_t)a2, v9);
      unint64_t v10 = v11 | ((unint64_t)(v11 - 1 < 0x7F) << 32);
      if ((v10 & 0x100000000) == 0) {
        goto LABEL_29;
      }
      goto LABEL_10;
    }
    uint64_t v9 = *v8;
    if (*v8 < 1) {
      goto LABEL_9;
    }
    *a2 = (uint64_t)(v8 + 1);
    unint64_t v10 = v9 | 0x100000000;
    if ((v10 & 0x100000000) == 0) {
      goto LABEL_29;
    }
LABEL_10:
    unsigned int v12 = v10 >> 3;
    if (v10 >> 3 != 3)
    {
      if (v12 != 2)
      {
        if (v12 != 1 || v10 != 10) {
          goto LABEL_29;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        uint64_t v14 = *(std::string **)(a1 + 72);
        if (v14 == (std::string *)&qword_1EAB1F7D8)
        {
          sub_1DD24F908((void *)(a1 + 72), (uint64_t)&qword_1EAB1F7D8);
          uint64_t v14 = *(std::string **)(a1 + 72);
        }
LABEL_19:
        char v15 = sub_1DD2FCF1C(a2, v14);
        goto LABEL_31;
      }
      if (v10 != 18) {
        goto LABEL_29;
      }
      uint64_t v18 = *(int **)(a1 + 40);
      if (v18)
      {
        uint64_t v19 = *(int *)(a1 + 32);
        int v20 = *v18;
        if ((int)v19 < *v18)
        {
          *(_DWORD *)(a1 + 32) = v19 + 1;
          uint64_t v14 = *(std::string **)&v18[2 * v19 + 2];
          goto LABEL_19;
        }
        if (v20 != *(_DWORD *)(a1 + 36))
        {
LABEL_37:
          *uint64_t v18 = v20 + 1;
          uint64_t v21 = *v7;
          if (*v7)
          {
            if (*(void *)(v21 + 112)) {
              sub_1DD2F5330(*v7, (uint64_t)&unk_1F3878F18, 24);
            }
            uint64_t v14 = (std::string *)sub_1DD2F4FD8(v21, 0x18uLL, (uint64_t)sub_1DD24FB50);
          }
          else
          {
            uint64_t v14 = (std::string *)operator new(0x18uLL);
          }
          v14->__r_.__value_.__r.__words[0] = 0;
          v14->__r_.__value_.__l.__size_ = 0;
          v14->__r_.__value_.__r.__words[2] = 0;
          uint64_t v22 = *(void *)(a1 + 40);
          uint64_t v23 = *(int *)(a1 + 32);
          *(_DWORD *)(a1 + 32) = v23 + 1;
          *(void *)(v22 + 8 * v23 + 8) = v14;
          goto LABEL_19;
        }
      }
      else
      {
        int v20 = *(_DWORD *)(a1 + 36);
      }
      sub_1DD2FABC8(a1 + 24, v20 + 1);
      uint64_t v18 = *(int **)(a1 + 40);
      int v20 = *v18;
      goto LABEL_37;
    }
    if (v10 == 24)
    {
      char v15 = sub_1DD2464D8(1, 0x1Au, a2, (signed int *)(a1 + 48));
LABEL_31:
      if (v15) {
        continue;
      }
      goto LABEL_57;
    }
    break;
  }
  if (v10 == 26)
  {
    uint64_t v16 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1] || *v16 < 0)
    {
      int v17 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v17 < 0)
      {
LABEL_57:
        uint64_t v30 = 0;
        goto LABEL_56;
      }
    }
    else
    {
      int v17 = *v16;
      *a2 = (uint64_t)(v16 + 1);
    }
    int v24 = sub_1DD2F81D8((uint64_t)a2, v17);
    while (1)
    {
      if ((int)sub_1DD2F8334(a2) < 1)
      {
        sub_1DD2F8250((uint64_t)a2, v24);
        goto LABEL_4;
      }
      char v25 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        int v26 = 0;
      }
      else
      {
        int v26 = *v25;
        if ((*v25 & 0x80000000) == 0)
        {
          *a2 = (uint64_t)(v25 + 1);
          goto LABEL_51;
        }
      }
      uint64_t v27 = sub_1DD2F8C30(a2, v26);
      int v26 = v27;
      if (v27 < 0) {
        goto LABEL_57;
      }
LABEL_51:
      int v28 = *(_DWORD *)(a1 + 48);
      if (v28 == *(_DWORD *)(a1 + 52))
      {
        sub_1DD250120((unsigned int *)(a1 + 48), v28 + 1);
        int v28 = *(_DWORD *)(a1 + 48);
      }
      uint64_t v29 = *(void *)(a1 + 56);
      *(_DWORD *)(a1 + 48) = v28 + 1;
      *(_DWORD *)(v29 + 4 * v28 + 8) = v26;
    }
  }
LABEL_29:
  if (v10)
  {
    char v15 = sub_1DD2FB80C((uint64_t)a2, v10, (uint64_t)v32);
    goto LABEL_31;
  }
  uint64_t v30 = 1;
LABEL_56:
  sub_1DD2F92B4(v32);
  sub_1DD24F874(&v34);
  return v30;
}

void sub_1DD248FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD248FE4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD2FC85C(1, *(void *)(a1 + 72), a2);
  }
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  if ((int)v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 8 * v4;
    do
    {
      sub_1DD2FC6A4(2, *(void *)(*(void *)(a1 + 40) + v5 + 8), a2);
      v5 += 8;
    }
    while (v6 != v5);
  }
  if (*(int *)(a1 + 48) > 0)
  {
    if (*(int *)(a2 + 16) < 5)
    {
      sub_1DD2F9508(a2, 0x1Au);
      int v7 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      *(unsigned char *)(*(void *)(a2 + 8))++ = 26;
      int v7 = *(_DWORD *)(a2 + 16) - 1;
      *(_DWORD *)(a2 + 16) = v7;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 64);
    if (v7 < 5)
    {
      sub_1DD2F9508(a2, v8);
    }
    else
    {
      uint64_t v9 = *(void *)(a2 + 8);
      if (v8 < 0x80)
      {
        unsigned int v11 = *(_DWORD *)(a1 + 64);
        unint64_t v10 = *(unsigned char **)(a2 + 8);
      }
      else
      {
        unint64_t v10 = *(unsigned char **)(a2 + 8);
        do
        {
          *v10++ = v8 | 0x80;
          unsigned int v11 = v8 >> 7;
          unsigned int v12 = v8 >> 14;
          v8 >>= 7;
        }
        while (v12);
      }
      unsigned char *v10 = v11;
      int v13 = v10 - v9 + 1;
      *(void *)(a2 + 8) += v13;
      *(_DWORD *)(a2 + 16) -= v13;
    }
    uint64_t v14 = *(unsigned int *)(a1 + 48);
    if ((int)v14 >= 1)
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        unsigned int v16 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * i + 8);
        if (*(int *)(a2 + 16) < 5)
        {
          sub_1DD2F9508(a2, v16);
        }
        else
        {
          uint64_t v17 = *(void *)(a2 + 8);
          if (v16 < 0x80)
          {
            unsigned int v19 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * i + 8);
            uint64_t v18 = *(unsigned char **)(a2 + 8);
          }
          else
          {
            uint64_t v18 = *(unsigned char **)(a2 + 8);
            do
            {
              *v18++ = v16 | 0x80;
              unsigned int v19 = v16 >> 7;
              unsigned int v20 = v16 >> 14;
              v16 >>= 7;
            }
            while (v20);
          }
          *uint64_t v18 = v19;
          int v21 = v18 - v17 + 1;
          *(void *)(a2 + 8) += v21;
          *(_DWORD *)(a2 + 16) -= v21;
        }
      }
    }
  }
  uint64_t v22 = *(void *)(a1 + 8);
  if (v22) {
    uint64_t v23 = (char *)(v22 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v23 = (char *)&qword_1EAB1F7D8;
  }
  if (v23[23] < 0) {
    uint64_t v23 = *(char **)v23;
  }
  if (v22) {
    int v24 = (uint64_t *)(v22 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v24 = &qword_1EAB1F7D8;
  }
  if (*((char *)v24 + 23) < 0) {
    uint64_t v25 = v24[1];
  }
  else {
    LODWORD(v25) = *((unsigned __int8 *)v24 + 23);
  }
  return sub_1DD2F92E0(a2, v23, v25);
}

uint64_t sub_1DD249214(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if ((int)v5 >= 1)
  {
    int v7 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v8 = *v7++;
      uint64_t v9 = *(unsigned __int8 *)(v8 + 23);
      uint64_t v10 = *(void *)(v8 + 8);
      if ((v9 & 0x80u) == 0) {
        uint64_t v10 = v9;
      }
      v6 += v10 + ((9 * (__clz(v10 | 1) ^ 0x1F) + 73) >> 6);
      --v5;
    }
    while (v5);
  }
  uint64_t v11 = sub_1DD2FD008((unsigned int *)(a1 + 48));
  uint64_t v12 = 11;
  uint64_t v13 = ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((int)v11 >= 0) {
    uint64_t v12 = v13;
  }
  uint64_t v14 = v12 + v6;
  if (v11) {
    int v15 = v11;
  }
  else {
    int v15 = 0;
  }
  if (!v11) {
    uint64_t v14 = v6;
  }
  *(_DWORD *)(a1 + 64) = v15;
  uint64_t result = v14 + v11;
  if (*(unsigned char *)(a1 + 16))
  {
    uint64_t v17 = *(void *)(a1 + 72);
    uint64_t v18 = *(unsigned __int8 *)(v17 + 23);
    uint64_t v19 = *(void *)(v17 + 8);
    if ((v18 & 0x80u) == 0) {
      uint64_t v19 = v18;
    }
    result += v19 + ((9 * (__clz(v19 | 1) ^ 0x1F) + 73) >> 6) + 1;
  }
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

std::string *sub_1DD24934C(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (const std::string **)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    uint64_t result = sub_1DD250250(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  int v10 = *(_DWORD *)(a2 + 48);
  if (v10)
  {
    uint64_t data_low = SLODWORD(v3[2].__r_.__value_.__l.__data_);
    sub_1DD250120((unsigned int *)&v3[2], data_low + v10);
    std::string::size_type size = v3[2].__r_.__value_.__l.__size_;
    LODWORD(v3[2].__r_.__value_.__l.__data_) += *(_DWORD *)(a2 + 48);
    uint64_t result = (std::string *)memcpy((void *)(size + 4 * data_low + 8), (const void *)(*(void *)(a2 + 56) + 8), 4 * *(int *)(a2 + 48));
  }
  if (*(unsigned char *)(a2 + 16))
  {
    data = (std::string *)v3[3].__r_.__value_.__l.__data_;
    uint64_t v13 = (std::string::__raw *)&v3[3];
    uint64_t result = data;
    LODWORD(v13[-3].__words[2]) |= 1u;
    int v15 = *(const std::string **)(a2 + 72);
    if (data != v15)
    {
      if (result == (std::string *)&qword_1EAB1F7D8)
      {
        return (std::string *)sub_1DD24F908(v13, (uint64_t)v15);
      }
      else
      {
        return std::string::operator=(result, v15);
      }
    }
  }
  return result;
}

uint64_t sub_1DD2494C4()
{
  return 1;
}

void *sub_1DD2494CC@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.DataMask");
}

void *sub_1DD2494DC(void *a1)
{
  *a1 = &unk_1F387BB78;
  a1[1] = 0;
  a1[2] = 0;
  if (atomic_load_explicit(dword_1EC8AC0A8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC0A8);
  }
  a1[3] = &qword_1EAB1F7D8;
  a1[4] = 0;
  return a1;
}

void sub_1DD249554(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void sub_1DD249568(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if ((uint64_t *)v1 != &qword_1EAB1F7D8 && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete((void *)v1);
  }
}

void *sub_1DD2495CC(void *a1)
{
  *a1 = &unk_1F387BB78;
  uint64_t v2 = a1 + 1;
  sub_1DD249568((uint64_t)a1);
  sub_1DD24F770(v2);
  return a1;
}

void sub_1DD24961C(uint64_t *a1)
{
  *a1 = (uint64_t)&unk_1F387BB78;
  uint64_t v2 = a1 + 1;
  sub_1DD249568((uint64_t)a1);
  sub_1DD24F770(v2);
  operator delete(a1);
}

void sub_1DD24967C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (*(char *)(v2 + 23) < 0)
    {
      **(unsigned char **)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v2 = 0;
      *(unsigned char *)(v2 + 23) = 0;
    }
  }
  if ((v1 & 6) != 0) {
    *(void *)(a1 + 32) = 0;
  }
  char v4 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  *(_DWORD *)(v3 + 8) = 0;
  if (v4) {
    sub_1DD24FC0C((unint64_t *)v3);
  }
}

uint64_t sub_1DD2496C8(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v32 = (uint64_t *)(a1 + 8);
  long long v33 = 0uLL;
  uint64_t v34 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v34 = *(void *)(v5 + 16);
    long long v33 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v31, (uint64_t)&v33);
  sub_1DD2F9178((uint64_t)&v28, (uint64_t)v31, 0);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        int v7 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          uint64_t v8 = 0;
LABEL_9:
          unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
          unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
          if ((v9 & 0x100000000) == 0) {
            goto LABEL_28;
          }
          goto LABEL_10;
        }
        uint64_t v8 = *v7;
        if (*v7 < 1) {
          goto LABEL_9;
        }
        *a2 = (uint64_t)(v7 + 1);
        unint64_t v9 = v8 | 0x100000000;
        if ((v9 & 0x100000000) == 0) {
          goto LABEL_28;
        }
LABEL_10:
        unsigned int v11 = v9 >> 3;
        if (v9 >> 3 != 3) {
          break;
        }
        if (v9 != 24) {
          goto LABEL_28;
        }
        int v15 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          LODWORD(v16) = 0;
        }
        else
        {
          LODWORD(v16) = *v15;
          if ((*v15 & 0x80000000) == 0)
          {
            *a2 = (uint64_t)(v15 + 1);
            goto LABEL_34;
          }
        }
        uint64_t v16 = sub_1DD2F8C30(a2, v16);
        if (v16 < 0) {
          goto LABEL_49;
        }
LABEL_34:
        if (v16 > 2)
        {
          if (v30 < 5)
          {
            sub_1DD2F9508((uint64_t)&v28, 0x18u);
            int v19 = v30;
          }
          else
          {
            *v29++ = 24;
            int v19 = --v30;
          }
          if (v19 < 5)
          {
            sub_1DD2F9508((uint64_t)&v28, v16);
          }
          else
          {
            int v20 = (int)v29;
            if (v16 < 0x80)
            {
              LOBYTE(v22) = v16;
              int v21 = v29;
            }
            else
            {
              int v21 = v29;
              do
              {
                *v21++ = v16 | 0x80;
                unsigned int v22 = v16 >> 7;
                unsigned int v23 = v16 >> 14;
                LODWORD(v16) = v16 >> 7;
              }
              while (v23);
            }
            unsigned char *v21 = v22;
            int v24 = v21 - v20 + 1;
            v29 += v24;
            v30 -= v24;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) |= 4u;
          *(_DWORD *)(a1 + 36) = v16;
        }
      }
      if (v11 != 2) {
        break;
      }
      if (v9 != 16) {
        goto LABEL_28;
      }
      *(_DWORD *)(a1 + 16) |= 2u;
      uint64_t v17 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        int v18 = 0;
        goto LABEL_48;
      }
      int v18 = *v17;
      if (*v17 < 0)
      {
LABEL_48:
        uint64_t v25 = sub_1DD2F8C30(a2, v18);
        *(_DWORD *)(a1 + 32) = v25;
        if (v25 < 0)
        {
LABEL_49:
          uint64_t v26 = 0;
          goto LABEL_51;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 32) = v18;
        *a2 = (uint64_t)(v17 + 1);
      }
    }
    if (v11 == 1 && v9 == 10)
    {
      *(_DWORD *)(a1 + 16) |= 1u;
      uint64_t v13 = *(std::string **)(a1 + 24);
      if (v13 == (std::string *)&qword_1EAB1F7D8)
      {
        sub_1DD24F908((void *)(a1 + 24), (uint64_t)&qword_1EAB1F7D8);
        uint64_t v13 = *(std::string **)(a1 + 24);
      }
      BOOL v14 = sub_1DD2FCF1C(a2, v13);
      goto LABEL_30;
    }
LABEL_28:
    if (!v9) {
      break;
    }
    BOOL v14 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)&v28);
LABEL_30:
    if (!v14) {
      goto LABEL_49;
    }
  }
  uint64_t v26 = 1;
LABEL_51:
  sub_1DD2F92B4(&v28);
  sub_1DD24F874(&v32);
  return v26;
}

void sub_1DD2499B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2499E0(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FC85C(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FBFC4(2, *(_DWORD *)(a1 + 32), a2);
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FBEA4(3, *(_DWORD *)(a1 + 36), a2);
LABEL_5:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    int v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD249AB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    uint64_t v2 = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v2 = &qword_1EAB1F7D8;
  }
  if (*((char *)v2 + 23) < 0) {
    uint64_t v3 = v2[1];
  }
  else {
    uint64_t v3 = *((unsigned __int8 *)v2 + 23);
  }
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 7) == 0) {
    goto LABEL_15;
  }
  if (v4)
  {
    uint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(unsigned __int8 *)(v9 + 23);
    uint64_t v11 = *(void *)(v9 + 8);
    if ((v10 & 0x80u) == 0) {
      uint64_t v11 = v10;
    }
    v3 += v11 + ((9 * (__clz(v11 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v4 & 2) == 0)
    {
LABEL_10:
      if ((v4 & 4) == 0) {
        goto LABEL_15;
      }
      goto LABEL_11;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_10;
  }
  v3 += ((9 * (__clz(*(_DWORD *)(a1 + 32) | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v4 & 4) == 0) {
    goto LABEL_15;
  }
LABEL_11:
  int v5 = *(_DWORD *)(a1 + 36);
  uint64_t v6 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v5 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    uint64_t v7 = 11;
  }
  v3 += v7;
LABEL_15:
  *(_DWORD *)(a1 + 20) = v3;
  return v3;
}

std::string *sub_1DD249BA4(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 7) != 0)
  {
    if (v5)
    {
      uint64_t result = v3 + 1;
      data = (std::string *)v3[1].__r_.__value_.__l.__data_;
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      uint64_t v7 = *(const std::string **)(a2 + 24);
      if (data != v7)
      {
        if (data == (std::string *)&qword_1EAB1F7D8)
        {
          uint64_t result = (std::string *)sub_1DD24F908(result, (uint64_t)v7);
          if ((v5 & 2) == 0) {
            goto LABEL_10;
          }
          goto LABEL_9;
        }
        uint64_t result = std::string::operator=(data, v7);
      }
    }
    if ((v5 & 2) == 0)
    {
LABEL_10:
      if ((v5 & 4) != 0) {
        HIDWORD(v3[1].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 36);
      }
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
      return result;
    }
LABEL_9:
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 32);
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_1DD249C5C()
{
  return 1;
}

void *sub_1DD249C64@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.EncryptionKey");
}

uint64_t sub_1DD249C74(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C398;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = 0;
  if (atomic_load_explicit(dword_1EC8AC1F0, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC1F0);
  }
  *(void *)(a1 + 48) = &qword_1EAB1F7D8;
  *(void *)(a1 + 56) = &qword_1EAB1F7D8;
  *(void *)(a1 + 64) = 0;
  return a1;
}

void sub_1DD249D04(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD249D24(void *a1)
{
  *a1 = &unk_1F387C398;
  uint64_t v2 = a1 + 3;
  sub_1DD249D80((uint64_t)a1);
  sub_1DD24FC54(v2);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD249D80(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if ((uint64_t *)v2 != &qword_1EAB1F7D8 && v2 != 0)
  {
    if (*(char *)(v2 + 23) < 0) {
      operator delete(*(void **)v2);
    }
    operator delete((void *)v2);
  }
  uint64_t v4 = *(void *)(a1 + 56);
  if ((uint64_t *)v4 != &qword_1EAB1F7D8 && v4 != 0)
  {
    if (*(char *)(v4 + 23) < 0) {
      operator delete(*(void **)v4);
    }
    operator delete((void *)v4);
  }
}

void sub_1DD249E20(void *a1)
{
  uint64_t v1 = sub_1DD249D24(a1);
  operator delete(v1);
}

void sub_1DD249E48(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD2430C8(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 3) != 0)
  {
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 48);
      if (*(char *)(v6 + 23) < 0)
      {
        **(unsigned char **)uint64_t v6 = 0;
        *(void *)(v6 + 8) = 0;
        if ((v5 & 2) == 0) {
          goto LABEL_15;
        }
        goto LABEL_10;
      }
      *(unsigned char *)uint64_t v6 = 0;
      *(unsigned char *)(v6 + 23) = 0;
    }
    if ((v5 & 2) == 0) {
      goto LABEL_15;
    }
LABEL_10:
    uint64_t v7 = *(void *)(a1 + 56);
    if (*(char *)(v7 + 23) < 0)
    {
      **(unsigned char **)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v7 = 0;
      *(unsigned char *)(v7 + 23) = 0;
    }
  }
LABEL_15:
  if ((v5 & 0xC) != 0) {
    *(void *)(a1 + 64) = 0;
  }
  char v9 = *(unsigned char *)(a1 + 8);
  uint64_t v8 = a1 + 8;
  *(_DWORD *)(v8 + 8) = 0;
  if (v9)
  {
    sub_1DD24FC0C((unint64_t *)v8);
  }
}

uint64_t sub_1DD249F34(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v32 = (uint64_t *)(a1 + 8);
  long long v33 = 0uLL;
  uint64_t v34 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v34 = *(void *)(v5 + 16);
    long long v33 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v31, (uint64_t)&v33);
  sub_1DD2F9178((uint64_t)v30, (uint64_t)v31, 0);
  while (2)
  {
    while (1)
    {
      uint64_t v7 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1]) {
        break;
      }
      uint64_t v8 = *v7;
      if (*v7 < 1) {
        goto LABEL_9;
      }
      *a2 = (uint64_t)(v7 + 1);
      unint64_t v9 = v8 | 0x100000000;
      if ((v9 & 0x100000000) != 0) {
        goto LABEL_10;
      }
LABEL_32:
      if (!v9)
      {
        uint64_t v28 = 1;
        goto LABEL_54;
      }
      BOOL v15 = sub_1DD2FB80C((uint64_t)a2, v9, (uint64_t)v30);
LABEL_34:
      if (!v15) {
        goto LABEL_52;
      }
    }
    uint64_t v8 = 0;
LABEL_9:
    unsigned int v10 = sub_1DD2F8F70((uint64_t)a2, v8);
    unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_32;
    }
LABEL_10:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 8) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v11 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v12 = 0;
        }
        else
        {
          int v12 = *v11;
          if ((*v11 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 64) = v12;
            goto LABEL_19;
          }
        }
        uint64_t v26 = sub_1DD2F8C30(a2, v12);
        *(_DWORD *)(a1 + 64) = v26;
        if (v26 < 0) {
          goto LABEL_52;
        }
        continue;
      case 2u:
        if (v9 != 16) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 8u;
        uint64_t v11 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1])
        {
          int v13 = 0;
        }
        else
        {
          int v13 = *v11;
          if ((*v11 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 68) = v13;
LABEL_19:
            *a2 = (uint64_t)(v11 + 1);
            continue;
          }
        }
        uint64_t v27 = sub_1DD2F8C30(a2, v13);
        *(_DWORD *)(a1 + 68) = v27;
        if (v27 < 0) {
          goto LABEL_52;
        }
        continue;
      case 3u:
        if (v9 != 26) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        BOOL v14 = *(std::string **)(a1 + 48);
        if (v14 == (std::string *)&qword_1EAB1F7D8)
        {
          sub_1DD24F908((void *)(a1 + 48), (uint64_t)&qword_1EAB1F7D8);
          BOOL v14 = *(std::string **)(a1 + 48);
        }
        goto LABEL_23;
      case 4u:
        if (v9 != 34) {
          goto LABEL_32;
        }
        uint64_t v16 = *(int **)(a1 + 40);
        if (!v16)
        {
          int v18 = *(_DWORD *)(a1 + 36);
LABEL_38:
          sub_1DD2FABC8(a1 + 24, v18 + 1);
          uint64_t v16 = *(int **)(a1 + 40);
          int v18 = *v16;
          goto LABEL_39;
        }
        uint64_t v17 = *(int *)(a1 + 32);
        int v18 = *v16;
        if ((int)v17 < *v16)
        {
          *(_DWORD *)(a1 + 32) = v17 + 1;
          int v19 = *(void **)&v16[2 * v17 + 2];
          goto LABEL_40;
        }
        if (v18 == *(_DWORD *)(a1 + 36)) {
          goto LABEL_38;
        }
LABEL_39:
        *uint64_t v16 = v18 + 1;
        int v19 = sub_1DD24EB78(*(void *)(a1 + 24));
        uint64_t v20 = *(void *)(a1 + 40);
        uint64_t v21 = *(int *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v21 + 1;
        *(void *)(v20 + 8 * v21 + 8) = v19;
LABEL_40:
        unsigned int v22 = (char *)*a2;
        if (*a2 >= (unint64_t)a2[1] || *v22 < 0)
        {
          int v23 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v23 < 0) {
            goto LABEL_52;
          }
        }
        else
        {
          int v23 = *v22;
          *a2 = (uint64_t)(v22 + 1);
        }
        unint64_t v24 = sub_1DD2F8298((uint64_t)a2, v23);
        int v25 = v24;
        if ((v24 & 0x8000000000000000) == 0 && sub_1DD2430EC((uint64_t)v19, a2))
        {
          BOOL v15 = sub_1DD2F82D0((uint64_t)a2, v25);
          goto LABEL_34;
        }
LABEL_52:
        uint64_t v28 = 0;
LABEL_54:
        sub_1DD2F92B4(v30);
        sub_1DD24F874(&v32);
        return v28;
      case 5u:
        if (v9 != 42) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        BOOL v14 = *(std::string **)(a1 + 56);
        if (v14 == (std::string *)&qword_1EAB1F7D8)
        {
          sub_1DD24F908((void *)(a1 + 56), (uint64_t)&qword_1EAB1F7D8);
          BOOL v14 = *(std::string **)(a1 + 56);
        }
LABEL_23:
        BOOL v15 = sub_1DD2FCF1C(a2, v14);
        goto LABEL_34;
      default:
        goto LABEL_32;
    }
  }
}

void sub_1DD24A2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24A2E8(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 4) != 0)
  {
    sub_1DD2FBFC4(1, *(_DWORD *)(a1 + 64), a2);
    if ((v4 & 8) == 0)
    {
LABEL_3:
      if ((v4 & 1) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else if ((v4 & 8) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FBFC4(2, *(_DWORD *)(a1 + 68), a2);
  if (v4) {
LABEL_4:
  }
    sub_1DD2FCBE0(3, *(void *)(a1 + 48), a2);
LABEL_5:
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5)
  {
    for (int i = 0; i != v5; ++i)
      sub_1DD2FCDAC(4, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  if ((v4 & 2) != 0) {
    sub_1DD2FCBE0(5, *(void *)(a1 + 56), a2);
  }
  uint64_t v7 = *(void *)(a1 + 8);
  if (v7) {
    uint64_t v8 = (char *)(v7 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v8 = (char *)&qword_1EAB1F7D8;
  }
  if (v8[23] < 0) {
    uint64_t v8 = *(char **)v8;
  }
  if (v7) {
    unint64_t v9 = (uint64_t *)(v7 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    unint64_t v9 = &qword_1EAB1F7D8;
  }
  if (*((char *)v9 + 23) < 0) {
    uint64_t v10 = v9[1];
  }
  else {
    LODWORD(v10) = *((unsigned __int8 *)v9 + 23);
  }
  return sub_1DD2F92E0(a2, v8, v10);
}

uint64_t sub_1DD24A408(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2434D4(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & 0xF) == 0) {
    goto LABEL_16;
  }
  if (v9)
  {
    uint64_t v11 = *(void *)(a1 + 48);
    uint64_t v12 = *(unsigned __int8 *)(v11 + 23);
    uint64_t v13 = *(void *)(v11 + 8);
    if ((v12 & 0x80u) == 0) {
      uint64_t v13 = v12;
    }
    v6 += v13 + ((9 * (__clz(v13 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v9 & 2) == 0)
    {
LABEL_13:
      if ((v9 & 4) == 0) {
        goto LABEL_14;
      }
LABEL_23:
      v6 += ((9 * (__clz(*(_DWORD *)(a1 + 64) | 1) ^ 0x1F) + 73) >> 6) + 1;
      if ((v9 & 8) == 0) {
        goto LABEL_16;
      }
      goto LABEL_15;
    }
  }
  else if ((v9 & 2) == 0)
  {
    goto LABEL_13;
  }
  uint64_t v14 = *(void *)(a1 + 56);
  uint64_t v15 = *(unsigned __int8 *)(v14 + 23);
  uint64_t v16 = *(void *)(v14 + 8);
  if ((v15 & 0x80u) == 0) {
    uint64_t v16 = v15;
  }
  v6 += v16 + ((9 * (__clz(v16 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v9 & 4) != 0) {
    goto LABEL_23;
  }
LABEL_14:
  if ((v9 & 8) != 0) {
LABEL_15:
  }
    v6 += ((9 * (__clz(*(_DWORD *)(a1 + 68) | 1) ^ 0x1F) + 73) >> 6) + 1;
LABEL_16:
  *(_DWORD *)(a1 + 20) = v6;
  return v6;
}

std::string *sub_1DD24A5A0(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    uint64_t result = sub_1DD24FE60(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    int v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  int v10 = *(_DWORD *)(a2 + 16);
  if ((v10 & 0xF) != 0)
  {
    if (v10)
    {
      uint64_t result = v3 + 2;
      data = (std::string *)v3[2].__r_.__value_.__l.__data_;
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      uint64_t v12 = *(const std::string **)(a2 + 48);
      if (data != v12)
      {
        if (data == (std::string *)&qword_1EAB1F7D8)
        {
          uint64_t result = (std::string *)sub_1DD24F908(result, (uint64_t)v12);
          if ((v10 & 2) != 0)
          {
LABEL_12:
            uint64_t result = (std::string *)((char *)v3 + 56);
            std::string::size_type size = (std::string *)v3[2].__r_.__value_.__l.__size_;
            LODWORD(v3->__r_.__value_.__r.__words[2]) |= 2u;
            uint64_t v14 = *(const std::string **)(a2 + 56);
            if (size != v14)
            {
              if (size == (std::string *)&qword_1EAB1F7D8) {
                uint64_t result = (std::string *)sub_1DD24F908(result, (uint64_t)v14);
              }
              else {
                uint64_t result = std::string::operator=(size, v14);
              }
            }
          }
LABEL_18:
          if ((v10 & 4) != 0) {
            LODWORD(v3[2].__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 64);
          }
          if ((v10 & 8) != 0) {
            HIDWORD(v3[2].__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 68);
          }
          LODWORD(v3->__r_.__value_.__r.__words[2]) |= v10;
          return result;
        }
        uint64_t result = std::string::operator=(data, v12);
      }
    }
    if ((v10 & 2) != 0) {
      goto LABEL_12;
    }
    goto LABEL_18;
  }
  return result;
}

uint64_t sub_1DD24A708()
{
  return 1;
}

void *sub_1DD24A710@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.EncryptionVariant");
}

uint64_t sub_1DD24A720(uint64_t a1)
{
  *(void *)a1 = &unk_1F387B858;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(void *)(a1 + 88) = 0;
  if (atomic_load_explicit(dword_1EC8AC028, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC028);
  }
  *(_DWORD *)(a1 + 96) = 0;
  return a1;
}

void sub_1DD24A7C0(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v4);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24A7F8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387B858;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (unint64_t *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  unsigned int v5 = (std::string *)(a1 + 24);
  *(_DWORD *)(a1 + 44) = 0;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 20) = 0;
  unsigned int v6 = *(_DWORD *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = *(void *)(a2 + 40);
    signed int v8 = (std::string **)sub_1DD2FAAC0(a1 + 24, *(_DWORD *)(a2 + 32));
    sub_1DD250594(v5, v8, (uint64_t *)(v7 + 8), v6, **(_DWORD **)(a1 + 40) - *(_DWORD *)(a1 + 32));
    signed int v9 = *(_DWORD *)(a1 + 32) + v6;
    *(_DWORD *)(a1 + 32) = v9;
    int v10 = *(signed int **)(a1 + 40);
    if (*v10 < v9) {
      signed int *v10 = v9;
    }
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  unsigned int v11 = *(_DWORD *)(a2 + 56);
  if (v11)
  {
    uint64_t v12 = *(void *)(a2 + 64);
    uint64_t v13 = (std::string **)sub_1DD2FAAC0(a1 + 48, *(_DWORD *)(a2 + 56));
    sub_1DD250654((std::string *)(a1 + 48), v13, (uint64_t *)(v12 + 8), v11, **(_DWORD **)(a1 + 64) - *(_DWORD *)(a1 + 56));
    signed int v14 = *(_DWORD *)(a1 + 56) + v11;
    *(_DWORD *)(a1 + 56) = v14;
    uint64_t v15 = *(signed int **)(a1 + 64);
    if (*v15 < v14) {
      *uint64_t v15 = v14;
    }
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  unsigned int v16 = *(_DWORD *)(a2 + 80);
  if (v16)
  {
    uint64_t v17 = *(void *)(a2 + 88);
    int v18 = (std::string **)sub_1DD2FAAC0(a1 + 72, *(_DWORD *)(a2 + 80));
    sub_1DD250714((std::string *)(a1 + 72), v18, (uint64_t *)(v17 + 8), v16, **(_DWORD **)(a1 + 88) - *(_DWORD *)(a1 + 80));
    signed int v19 = *(_DWORD *)(a1 + 80) + v16;
    *(_DWORD *)(a1 + 80) = v19;
    uint64_t v20 = *(signed int **)(a1 + 88);
    if (*v20 < v19) {
      signed int *v20 = v19;
    }
  }
  uint64_t v21 = *(void *)(a2 + 8);
  if (v21) {
    sub_1DD24FBB0(v4, v21 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  return a1;
}

void sub_1DD24A9C0(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v4);
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24AA10(void *a1)
{
  *a1 = &unk_1F387B858;
  sub_1DD24FC54(a1 + 9);
  sub_1DD24FC54(a1 + 6);
  sub_1DD24FC54(a1 + 3);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void sub_1DD24AA7C(void *a1)
{
  uint64_t v1 = sub_1DD24AA10(a1);
  operator delete(v1);
}

void sub_1DD24AAA4(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD248BB4(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 56);
  if ((int)v5 >= 1)
  {
    unsigned int v6 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v7 = *v6++;
      sub_1DD24967C(v7);
      --v5;
    }
    while (v5);
    *(_DWORD *)(a1 + 56) = 0;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 80);
  if ((int)v8 >= 1)
  {
    signed int v9 = (uint64_t *)(*(void *)(a1 + 88) + 8);
    do
    {
      uint64_t v10 = *v9++;
      sub_1DD249E48(v10);
      --v8;
    }
    while (v8);
    *(_DWORD *)(a1 + 80) = 0;
  }
  char v12 = *(unsigned char *)(a1 + 8);
  uint64_t v11 = a1 + 8;
  *(_DWORD *)(v11 + 88) = 0;
  *(_DWORD *)(v11 + 8) = 0;
  if (v12)
  {
    sub_1DD24FC0C((unint64_t *)v11);
  }
}

uint64_t sub_1DD24AB78(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v54 = (uint64_t *)(a1 + 8);
  long long v55 = 0uLL;
  uint64_t v56 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v56 = *(void *)(v5 + 16);
    long long v55 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v53, (uint64_t)&v55);
  sub_1DD2F9178((uint64_t)&v50, (uint64_t)v53, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *v7;
    if ((char)*v7 < 1) {
      goto LABEL_9;
    }
    *(void *)a2 = v7 + 1;
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_27;
    }
LABEL_10:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 10) {
          goto LABEL_27;
        }
        uint64_t v11 = *(int **)(a1 + 40);
        if (!v11)
        {
          int v13 = *(_DWORD *)(a1 + 36);
LABEL_35:
          sub_1DD2FABC8(a1 + 24, v13 + 1);
          uint64_t v11 = *(int **)(a1 + 40);
          int v13 = *v11;
          goto LABEL_36;
        }
        uint64_t v12 = *(int *)(a1 + 32);
        int v13 = *v11;
        if ((int)v12 < *v11)
        {
          *(_DWORD *)(a1 + 32) = v12 + 1;
          signed int v14 = *(void **)&v11[2 * v12 + 2];
          goto LABEL_37;
        }
        if (v13 == *(_DWORD *)(a1 + 36)) {
          goto LABEL_35;
        }
LABEL_36:
        int *v11 = v13 + 1;
        signed int v14 = sub_1DD24F140(*(void *)(a1 + 24));
        uint64_t v26 = *(void *)(a1 + 40);
        uint64_t v27 = *(int *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v27 + 1;
        *(void *)(v26 + 8 * v27 + 8) = v14;
LABEL_37:
        uint64_t v28 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v28 < 0)
        {
          int v29 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v29 < 0) {
            goto LABEL_81;
          }
        }
        else
        {
          int v29 = *v28;
          *(void *)a2 = v28 + 1;
        }
        unint64_t v30 = sub_1DD2F8298(a2, v29);
        int v31 = v30;
        if ((v30 & 0x8000000000000000) == 0 && sub_1DD248C38((uint64_t)v14, (uint64_t *)a2)) {
          goto LABEL_63;
        }
        goto LABEL_81;
      case 2u:
        if (v9 != 18) {
          goto LABEL_27;
        }
        uint64_t v15 = *(int **)(a1 + 64);
        if (!v15)
        {
          int v17 = *(_DWORD *)(a1 + 60);
LABEL_45:
          sub_1DD2FABC8(a1 + 48, v17 + 1);
          uint64_t v15 = *(int **)(a1 + 64);
          int v17 = *v15;
          goto LABEL_46;
        }
        uint64_t v16 = *(int *)(a1 + 56);
        int v17 = *v15;
        if ((int)v16 < *v15)
        {
          *(_DWORD *)(a1 + 56) = v16 + 1;
          int v18 = *(void **)&v15[2 * v16 + 2];
          goto LABEL_47;
        }
        if (v17 == *(_DWORD *)(a1 + 60)) {
          goto LABEL_45;
        }
LABEL_46:
        *uint64_t v15 = v17 + 1;
        int v18 = sub_1DD24F1D4(*(void *)(a1 + 48));
        uint64_t v32 = *(void *)(a1 + 64);
        uint64_t v33 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v33 + 1;
        *(void *)(v32 + 8 * v33 + 8) = v18;
LABEL_47:
        uint64_t v34 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v34 < 0)
        {
          int v35 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v35 < 0) {
            goto LABEL_81;
          }
        }
        else
        {
          int v35 = *v34;
          *(void *)a2 = v34 + 1;
        }
        unint64_t v36 = sub_1DD2F8298(a2, v35);
        int v31 = v36;
        if ((v36 & 0x8000000000000000) == 0 && sub_1DD2496C8((uint64_t)v18, (uint64_t *)a2)) {
          goto LABEL_63;
        }
        goto LABEL_81;
      case 3u:
        if (v9 != 26) {
          goto LABEL_27;
        }
        signed int v19 = *(int **)(a1 + 88);
        if (!v19)
        {
          int v21 = *(_DWORD *)(a1 + 84);
LABEL_55:
          sub_1DD2FABC8(a1 + 72, v21 + 1);
          signed int v19 = *(int **)(a1 + 88);
          int v21 = *v19;
          goto LABEL_56;
        }
        uint64_t v20 = *(int *)(a1 + 80);
        int v21 = *v19;
        if ((int)v20 < *v19)
        {
          *(_DWORD *)(a1 + 80) = v20 + 1;
          unsigned int v22 = *(void **)&v19[2 * v20 + 2];
          goto LABEL_57;
        }
        if (v21 == *(_DWORD *)(a1 + 84)) {
          goto LABEL_55;
        }
LABEL_56:
        *signed int v19 = v21 + 1;
        unsigned int v22 = sub_1DD24F268(*(void *)(a1 + 72));
        uint64_t v37 = *(void *)(a1 + 88);
        uint64_t v38 = *(int *)(a1 + 80);
        *(_DWORD *)(a1 + 80) = v38 + 1;
        *(void *)(v37 + 8 * v38 + 8) = v22;
LABEL_57:
        int v39 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v39 < 0)
        {
          int v40 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v40 < 0) {
            goto LABEL_81;
          }
        }
        else
        {
          int v40 = *v39;
          *(void *)a2 = v39 + 1;
        }
        unint64_t v41 = sub_1DD2F8298(a2, v40);
        int v31 = v41;
        if ((v41 & 0x8000000000000000) != 0 || !sub_1DD249F34((uint64_t)v22, (uint64_t *)a2))
        {
LABEL_81:
          uint64_t v48 = 0;
          goto LABEL_80;
        }
LABEL_63:
        BOOL v25 = sub_1DD2F82D0(a2, v31);
        break;
      case 4u:
        if (v9 != 32) {
          goto LABEL_27;
        }
        int v23 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8))
        {
          LODWORD(v24) = 0;
        }
        else
        {
          LODWORD(v24) = *v23;
          if (((char)*v23 & 0x80000000) == 0)
          {
            *(void *)a2 = v23 + 1;
            goto LABEL_66;
          }
        }
        uint64_t v24 = sub_1DD2F8C30((uint64_t *)a2, v24);
        if (v24 < 0) {
          goto LABEL_81;
        }
LABEL_66:
        if (v24 > 4)
        {
          if (v52 < 5)
          {
            sub_1DD2F9508((uint64_t)&v50, 0x20u);
            int v42 = v52;
          }
          else
          {
            *v51++ = 32;
            int v42 = --v52;
          }
          if (v42 < 5)
          {
            sub_1DD2F9508((uint64_t)&v50, v24);
          }
          else
          {
            int v43 = (int)v51;
            if (v24 < 0x80)
            {
              LOBYTE(v45) = v24;
              int v44 = v51;
            }
            else
            {
              int v44 = v51;
              do
              {
                *v44++ = v24 | 0x80;
                unsigned int v45 = v24 >> 7;
                unsigned int v46 = v24 >> 14;
                LODWORD(v24) = v24 >> 7;
              }
              while (v46);
            }
            *int v44 = v45;
            int v47 = v44 - v43 + 1;
            v51 += v47;
            v52 -= v47;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) |= 1u;
          *(_DWORD *)(a1 + 96) = v24;
        }
        continue;
      default:
        goto LABEL_27;
    }
LABEL_29:
    if (!v25) {
      goto LABEL_81;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  unsigned int v10 = sub_1DD2F8F70(a2, v8);
  unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
  if ((v9 & 0x100000000) != 0) {
    goto LABEL_10;
  }
LABEL_27:
  if (v9)
  {
    BOOL v25 = sub_1DD2FB80C(a2, v9, (uint64_t)&v50);
    goto LABEL_29;
  }
  uint64_t v48 = 1;
LABEL_80:
  sub_1DD2F92B4(&v50);
  sub_1DD24F874(&v54);
  return v48;
}

void sub_1DD24B0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24B0FC(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    for (int i = 0; i != v4; ++i)
      sub_1DD2FCDAC(1, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  int v6 = *(_DWORD *)(a1 + 56);
  if (v6)
  {
    for (int j = 0; j != v6; ++j)
      sub_1DD2FCDAC(2, *(void *)(*(void *)(a1 + 64) + 8 * j + 8), a2);
  }
  int v8 = *(_DWORD *)(a1 + 80);
  if (v8)
  {
    for (int k = 0; k != v8; ++k)
      sub_1DD2FCDAC(3, *(void *)(*(void *)(a1 + 88) + 8 * k + 8), a2);
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_1DD2FBEA4(4, *(_DWORD *)(a1 + 96), a2);
  }
  uint64_t v10 = *(void *)(a1 + 8);
  if (v10) {
    uint64_t v11 = (char *)(v10 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v11 = (char *)&qword_1EAB1F7D8;
  }
  if (v11[23] < 0) {
    uint64_t v11 = *(char **)v11;
  }
  if (v10) {
    uint64_t v12 = (uint64_t *)(v10 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v12 = &qword_1EAB1F7D8;
  }
  if (*((char *)v12 + 23) < 0) {
    uint64_t v13 = v12[1];
  }
  else {
    LODWORD(v13) = *((unsigned __int8 *)v12 + 23);
  }
  return sub_1DD2F92E0(a2, v11, v13);
}

uint64_t sub_1DD24B22C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD249214(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 56);
  uint64_t v10 = v6 + v9;
  if (v9)
  {
    int v11 = 0;
    do
    {
      uint64_t v12 = sub_1DD249AB4(*(void *)(*(void *)(a1 + 64) + 8 * v11 + 8));
      v10 += v12 + ((9 * (__clz(v12 | 1) ^ 0x1F) + 73) >> 6);
      ++v11;
    }
    while (v9 != v11);
  }
  uint64_t v13 = *(unsigned int *)(a1 + 80);
  uint64_t v14 = v10 + v13;
  if (v13)
  {
    int v15 = 0;
    do
    {
      uint64_t v16 = sub_1DD24A408(*(void *)(*(void *)(a1 + 88) + 8 * v15 + 8));
      v14 += v16 + ((9 * (__clz(v16 | 1) ^ 0x1F) + 73) >> 6);
      ++v15;
    }
    while (v13 != v15);
  }
  if (*(unsigned char *)(a1 + 16))
  {
    int v17 = *(_DWORD *)(a1 + 96);
    uint64_t v18 = ((9 * (__clz(v17 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v17 >= 0) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = 11;
    }
    v14 += v19;
  }
  *(_DWORD *)(a1 + 20) = v14;
  return v14;
}

std::string *sub_1DD24B3A8(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    uint64_t result = sub_1DD250594(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  unsigned int v10 = *(_DWORD *)(a2 + 56);
  if (v10)
  {
    int v11 = (uint64_t *)(*(void *)(a2 + 64) + 8);
    uint64_t v12 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[2], *(_DWORD *)(a2 + 56));
    uint64_t result = sub_1DD250654(v3 + 2, v12, v11, v10, *(_DWORD *)v3[2].__r_.__value_.__r.__words[2] - LODWORD(v3[2].__r_.__value_.__r.__words[1]));
    signed int v13 = LODWORD(v3[2].__r_.__value_.__r.__words[1]) + v10;
    LODWORD(v3[2].__r_.__value_.__r.__words[1]) = v13;
    uint64_t v14 = (signed int *)v3[2].__r_.__value_.__r.__words[2];
    if (*v14 < v13) {
      signed int *v14 = v13;
    }
  }
  unsigned int v15 = *(_DWORD *)(a2 + 80);
  if (v15)
  {
    uint64_t v16 = (uint64_t *)(*(void *)(a2 + 88) + 8);
    int v17 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[3], *(_DWORD *)(a2 + 80));
    uint64_t result = sub_1DD250714(v3 + 3, v17, v16, v15, *(_DWORD *)v3[3].__r_.__value_.__r.__words[2] - LODWORD(v3[3].__r_.__value_.__r.__words[1]));
    signed int v18 = LODWORD(v3[3].__r_.__value_.__r.__words[1]) + v15;
    LODWORD(v3[3].__r_.__value_.__r.__words[1]) = v18;
    uint64_t v19 = (signed int *)v3[3].__r_.__value_.__r.__words[2];
    if (*v19 < v18) {
      *uint64_t v19 = v18;
    }
  }
  if (*(unsigned char *)(a2 + 16))
  {
    int v20 = *(_DWORD *)(a2 + 96);
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
    LODWORD(v3[4].__r_.__value_.__l.__data_) = v20;
  }
  return result;
}

uint64_t sub_1DD24B538()
{
  return 1;
}

void *sub_1DD24B540@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.Encryption");
}

uint64_t sub_1DD24B550(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C7F8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  if (atomic_load_explicit(dword_1EC8ABFA8, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABFA8);
  }
  *(_OWORD *)(a1 + 148) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  return a1;
}

void sub_1DD24B604(_Unwind_Exception *a1)
{
  sub_1DD24FC54(v5);
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v4);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24B64C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387C7F8;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (unint64_t *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  unsigned int v5 = (std::string *)(a1 + 24);
  *(_DWORD *)(a1 + 44) = 0;
  *(void *)(a1 + 28) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 20) = 0;
  unsigned int v6 = *(_DWORD *)(a2 + 32);
  if (v6)
  {
    uint64_t v7 = *(void *)(a2 + 40);
    signed int v8 = (std::string **)sub_1DD2FAAC0(a1 + 24, *(_DWORD *)(a2 + 32));
    sub_1DD2507D4(v5, v8, (uint64_t *)(v7 + 8), v6, **(_DWORD **)(a1 + 40) - *(_DWORD *)(a1 + 32));
    signed int v9 = *(_DWORD *)(a1 + 32) + v6;
    *(_DWORD *)(a1 + 32) = v9;
    unsigned int v10 = *(signed int **)(a1 + 40);
    if (*v10 < v9) {
      signed int *v10 = v9;
    }
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  unsigned int v11 = *(_DWORD *)(a2 + 56);
  if (v11)
  {
    uint64_t v12 = *(void *)(a2 + 64);
    signed int v13 = (unint64_t **)sub_1DD2FAAC0(a1 + 48, *(_DWORD *)(a2 + 56));
    sub_1DD250894((unint64_t *)(a1 + 48), v13, (uint64_t *)(v12 + 8), v11, **(_DWORD **)(a1 + 64) - *(_DWORD *)(a1 + 56));
    signed int v14 = *(_DWORD *)(a1 + 56) + v11;
    *(_DWORD *)(a1 + 56) = v14;
    unsigned int v15 = *(signed int **)(a1 + 64);
    if (*v15 < v14) {
      *unsigned int v15 = v14;
    }
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  unsigned int v16 = *(_DWORD *)(a2 + 80);
  if (v16)
  {
    uint64_t v17 = *(void *)(a2 + 88);
    signed int v18 = (std::string **)sub_1DD2FAAC0(a1 + 72, *(_DWORD *)(a2 + 80));
    sub_1DD250954((std::string *)(a1 + 72), v18, (uint64_t *)(v17 + 8), v16, **(_DWORD **)(a1 + 88) - *(_DWORD *)(a1 + 80));
    signed int v19 = *(_DWORD *)(a1 + 80) + v16;
    *(_DWORD *)(a1 + 80) = v19;
    int v20 = *(signed int **)(a1 + 88);
    if (*v20 < v19) {
      signed int *v20 = v19;
    }
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  unsigned int v21 = *(_DWORD *)(a2 + 104);
  if (v21)
  {
    uint64_t v22 = *(void *)(a2 + 112);
    int v23 = (std::string **)sub_1DD2FAAC0(a1 + 96, *(_DWORD *)(a2 + 104));
    sub_1DD250414((std::string *)(a1 + 96), v23, (uint64_t *)(v22 + 8), v21, **(_DWORD **)(a1 + 112) - *(_DWORD *)(a1 + 104));
    signed int v24 = *(_DWORD *)(a1 + 104) + v21;
    *(_DWORD *)(a1 + 104) = v24;
    BOOL v25 = *(signed int **)(a1 + 112);
    if (*v25 < v24) {
      *BOOL v25 = v24;
    }
  }
  uint64_t v26 = *(void *)(a2 + 8);
  if (v26) {
    sub_1DD24FBB0(v4, v26 & 0xFFFFFFFFFFFFFFFELL);
  }
  if (*(unsigned char *)(a2 + 16))
  {
    uint64_t v27 = operator new(0x68uLL);
    sub_1DD24A7F8((uint64_t)v27, *(void *)(a2 + 120));
  }
  else
  {
    uint64_t v27 = 0;
  }
  *(void *)(a1 + 120) = v27;
  long long v28 = *(_OWORD *)(a2 + 128);
  long long v29 = *(_OWORD *)(a2 + 144);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 128) = v28;
  *(_OWORD *)(a1 + 144) = v29;
  return a1;
}

void sub_1DD24B8B4(_Unwind_Exception *a1)
{
  operator delete(v6);
  sub_1DD24FC54(v5);
  sub_1DD24FC54(v4);
  sub_1DD24FC54(v3);
  sub_1DD24FC54(v2);
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24B92C(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C7F8;
  if ((_UNKNOWN *)a1 != &unk_1EAB1F068)
  {
    uint64_t v2 = *(void *)(a1 + 120);
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
  }
  sub_1DD24FC54((void *)(a1 + 96));
  sub_1DD24FC54((void *)(a1 + 72));
  sub_1DD24FC54((void *)(a1 + 48));
  sub_1DD24FC54((void *)(a1 + 24));
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD24B9E4(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD24B92C(a1);
  operator delete(v1);
}

void sub_1DD24BA0C(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if ((int)v2 >= 1)
  {
    uint64_t v3 = (uint64_t *)(*(void *)(a1 + 40) + 8);
    do
    {
      uint64_t v4 = *v3++;
      sub_1DD246F94(v4);
      --v2;
    }
    while (v2);
    *(_DWORD *)(a1 + 32) = 0;
  }
  uint64_t v5 = *(unsigned int *)(a1 + 56);
  if ((int)v5 >= 1)
  {
    unsigned int v6 = (uint64_t *)(*(void *)(a1 + 64) + 8);
    do
    {
      uint64_t v7 = *v6++;
      sub_1DD245D9C(v7);
      --v5;
    }
    while (v5);
    *(_DWORD *)(a1 + 56) = 0;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 80);
  if ((int)v8 >= 1)
  {
    signed int v9 = (uint64_t *)(*(void *)(a1 + 88) + 8);
    do
    {
      uint64_t v10 = *v9++;
      sub_1DD247A20(v10);
      --v8;
    }
    while (v8);
    *(_DWORD *)(a1 + 80) = 0;
  }
  uint64_t v11 = *(unsigned int *)(a1 + 104);
  if ((int)v11 >= 1)
  {
    uint64_t v12 = (uint64_t *)(*(void *)(a1 + 112) + 8);
    do
    {
      uint64_t v13 = *v12++;
      sub_1DD23FE68(v13);
      --v11;
    }
    while (v11);
    *(_DWORD *)(a1 + 104) = 0;
  }
  int v14 = *(_DWORD *)(a1 + 16);
  if (v14) {
    sub_1DD24AAA4(*(void *)(a1 + 120));
  }
  if ((v14 & 0x7E) != 0)
  {
    *(_DWORD *)(a1 + 160) = 0;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
  }
  char v16 = *(unsigned char *)(a1 + 8);
  uint64_t v15 = a1 + 8;
  *(_DWORD *)(v15 + 8) = 0;
  if (v16)
  {
    sub_1DD24FC0C((unint64_t *)v15);
  }
}

uint64_t sub_1DD24BB28(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  v75 = (uint64_t *)(a1 + 8);
  long long v76 = 0uLL;
  uint64_t v77 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v77 = *(void *)(v5 + 16);
    long long v76 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v74, (uint64_t)&v76);
  sub_1DD2F9178((uint64_t)&v71, (uint64_t)v74, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *v7;
    if ((char)*v7 < 1) {
      goto LABEL_9;
    }
    *(void *)a2 = v7 + 1;
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_10;
    }
LABEL_14:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 8) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        uint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 < *(void *)(a2 + 8) && ((char)*v12 & 0x80000000) == 0)
        {
          *(void *)(a1 + 128) = *v12;
          goto LABEL_57;
        }
        *(void *)(a1 + 128) = sub_1DD2F8A78(a2);
        if ((v36 & 1) == 0) {
          goto LABEL_139;
        }
        continue;
      case 2u:
        if (v9 != 16) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 < *(void *)(a2 + 8) && ((char)*v12 & 0x80000000) == 0)
        {
          *(void *)(a1 + 136) = *v12;
          goto LABEL_57;
        }
        *(void *)(a1 + 136) = sub_1DD2F8A78(a2);
        if ((v37 & 1) == 0) {
          goto LABEL_139;
        }
        continue;
      case 3u:
        if (v9 != 26) {
          goto LABEL_10;
        }
        uint64_t v13 = *(int **)(a1 + 40);
        if (!v13)
        {
          int v15 = *(_DWORD *)(a1 + 36);
LABEL_77:
          sub_1DD2FABC8(a1 + 24, v15 + 1);
          uint64_t v13 = *(int **)(a1 + 40);
          int v15 = *v13;
          goto LABEL_78;
        }
        uint64_t v14 = *(int *)(a1 + 32);
        int v15 = *v13;
        if ((int)v14 < *v13)
        {
          *(_DWORD *)(a1 + 32) = v14 + 1;
          char v16 = *(void **)&v13[2 * v14 + 2];
          goto LABEL_79;
        }
        if (v15 == *(_DWORD *)(a1 + 36)) {
          goto LABEL_77;
        }
LABEL_78:
        *uint64_t v13 = v15 + 1;
        char v16 = sub_1DD24EEF0(*(void *)(a1 + 24));
        uint64_t v41 = *(void *)(a1 + 40);
        uint64_t v42 = *(int *)(a1 + 32);
        *(_DWORD *)(a1 + 32) = v42 + 1;
        *(void *)(v41 + 8 * v42 + 8) = v16;
LABEL_79:
        int v43 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v43 < 0)
        {
          int v44 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v44 < 0) {
            goto LABEL_139;
          }
        }
        else
        {
          int v44 = *v43;
          *(void *)a2 = v43 + 1;
        }
        unint64_t v45 = sub_1DD2F8298(a2, v44);
        int v40 = v45;
        if ((v45 & 0x8000000000000000) == 0 && sub_1DD247000((uint64_t)v16, (uint64_t *)a2)) {
          goto LABEL_115;
        }
        goto LABEL_139;
      case 4u:
        if (v9 != 34) {
          goto LABEL_10;
        }
        uint64_t v17 = *(int **)(a1 + 64);
        if (!v17)
        {
          int v19 = *(_DWORD *)(a1 + 60);
LABEL_87:
          sub_1DD2FABC8(a1 + 48, v19 + 1);
          uint64_t v17 = *(int **)(a1 + 64);
          int v19 = *v17;
          goto LABEL_88;
        }
        uint64_t v18 = *(int *)(a1 + 56);
        int v19 = *v17;
        if ((int)v18 < *v17)
        {
          *(_DWORD *)(a1 + 56) = v18 + 1;
          int v20 = *(void **)&v17[2 * v18 + 2];
          goto LABEL_89;
        }
        if (v19 == *(_DWORD *)(a1 + 60)) {
          goto LABEL_87;
        }
LABEL_88:
        *uint64_t v17 = v19 + 1;
        int v20 = sub_1DD24EE5C(*(void *)(a1 + 48));
        uint64_t v46 = *(void *)(a1 + 64);
        uint64_t v47 = *(int *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = v47 + 1;
        *(void *)(v46 + 8 * v47 + 8) = v20;
LABEL_89:
        uint64_t v48 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v48 < 0)
        {
          int v49 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v49 < 0) {
            goto LABEL_139;
          }
        }
        else
        {
          int v49 = *v48;
          *(void *)a2 = v48 + 1;
        }
        unint64_t v50 = sub_1DD2F8298(a2, v49);
        int v40 = v50;
        if ((v50 & 0x8000000000000000) == 0 && sub_1DD245E38((uint64_t)v20, (uint64_t *)a2)) {
          goto LABEL_115;
        }
        goto LABEL_139;
      case 5u:
        if (v9 != 42) {
          goto LABEL_10;
        }
        unsigned int v21 = *(int **)(a1 + 88);
        if (!v21)
        {
          int v23 = *(_DWORD *)(a1 + 84);
LABEL_97:
          sub_1DD2FABC8(a1 + 72, v23 + 1);
          unsigned int v21 = *(int **)(a1 + 88);
          int v23 = *v21;
          goto LABEL_98;
        }
        uint64_t v22 = *(int *)(a1 + 80);
        int v23 = *v21;
        if ((int)v22 < *v21)
        {
          *(_DWORD *)(a1 + 80) = v22 + 1;
          signed int v24 = *(void **)&v21[2 * v22 + 2];
          goto LABEL_99;
        }
        if (v23 == *(_DWORD *)(a1 + 84)) {
          goto LABEL_97;
        }
LABEL_98:
        int *v21 = v23 + 1;
        signed int v24 = sub_1DD24EF84(*(void *)(a1 + 72));
        uint64_t v51 = *(void *)(a1 + 88);
        uint64_t v52 = *(int *)(a1 + 80);
        *(_DWORD *)(a1 + 80) = v52 + 1;
        *(void *)(v51 + 8 * v52 + 8) = v24;
LABEL_99:
        uint64_t v53 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v53 < 0)
        {
          int v54 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v54 < 0) {
            goto LABEL_139;
          }
        }
        else
        {
          int v54 = *v53;
          *(void *)a2 = v53 + 1;
        }
        unint64_t v55 = sub_1DD2F8298(a2, v54);
        int v40 = v55;
        if ((v55 & 0x8000000000000000) == 0 && sub_1DD247A94((uint64_t)v24, (uint64_t *)a2)) {
          goto LABEL_115;
        }
        goto LABEL_139;
      case 6u:
        if (v9 != 48) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 8u;
        uint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 < *(void *)(a2 + 8) && ((char)*v12 & 0x80000000) == 0)
        {
          *(void *)(a1 + 144) = *v12;
          goto LABEL_57;
        }
        *(void *)(a1 + 144) = sub_1DD2F8A78(a2);
        if ((v38 & 1) == 0) {
          goto LABEL_139;
        }
        continue;
      case 7u:
        if (v9 != 58) {
          goto LABEL_10;
        }
        long long v29 = *(int **)(a1 + 112);
        if (!v29)
        {
          int v31 = *(_DWORD *)(a1 + 108);
LABEL_107:
          sub_1DD2FABC8(a1 + 96, v31 + 1);
          long long v29 = *(int **)(a1 + 112);
          int v31 = *v29;
          goto LABEL_108;
        }
        uint64_t v30 = *(int *)(a1 + 104);
        int v31 = *v29;
        if ((int)v30 < *v29)
        {
          *(_DWORD *)(a1 + 104) = v30 + 1;
          uint64_t v32 = *(void **)&v29[2 * v30 + 2];
          goto LABEL_109;
        }
        if (v31 == *(_DWORD *)(a1 + 108)) {
          goto LABEL_107;
        }
LABEL_108:
        *long long v29 = v31 + 1;
        uint64_t v32 = sub_1DD24E894(*(void *)(a1 + 96));
        uint64_t v56 = *(void *)(a1 + 112);
        uint64_t v57 = *(int *)(a1 + 104);
        *(_DWORD *)(a1 + 104) = v57 + 1;
        *(void *)(v56 + 8 * v57 + 8) = v32;
LABEL_109:
        v58 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v58 < 0)
        {
          int v59 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v59 < 0) {
            goto LABEL_139;
          }
        }
        else
        {
          int v59 = *v58;
          *(void *)a2 = v58 + 1;
        }
        unint64_t v60 = sub_1DD2F8298(a2, v59);
        int v40 = v60;
        if ((v60 & 0x8000000000000000) != 0 || !sub_1DD23FF78((uint64_t)v32, a2))
        {
LABEL_139:
          uint64_t v69 = 0;
          goto LABEL_138;
        }
LABEL_115:
        BOOL v11 = sub_1DD2F82D0(a2, v40);
        break;
      case 8u:
        if (v9 != 64) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x10u;
        uint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8))
        {
          int v25 = 0;
        }
        else
        {
          int v25 = *v12;
          if (((char)*v12 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 152) = v25;
            goto LABEL_57;
          }
        }
        uint64_t v61 = sub_1DD2F8C30((uint64_t *)a2, v25);
        *(_DWORD *)(a1 + 152) = v61;
        if (v61 < 0) {
          goto LABEL_139;
        }
        continue;
      case 9u:
        if (v9 != 72) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 0x20u;
        uint64_t v12 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8))
        {
          int v33 = 0;
        }
        else
        {
          int v33 = *v12;
          if (((char)*v12 & 0x80000000) == 0)
          {
            *(_DWORD *)(a1 + 156) = v33;
LABEL_57:
            *(void *)a2 = v12 + 1;
            continue;
          }
        }
        uint64_t v62 = sub_1DD2F8C30((uint64_t *)a2, v33);
        *(_DWORD *)(a1 + 156) = v62;
        if (v62 < 0) {
          goto LABEL_139;
        }
        continue;
      case 0xAu:
        if (v9 != 82) {
          goto LABEL_10;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        uint64_t v26 = *(void **)(a1 + 120);
        if (!v26)
        {
          uint64_t v26 = sub_1DD24F2FC(0);
          *(void *)(a1 + 120) = v26;
        }
        uint64_t v27 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v27 < 0)
        {
          int v28 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v28 < 0) {
            goto LABEL_139;
          }
        }
        else
        {
          int v28 = *v27;
          *(void *)a2 = v27 + 1;
        }
        unint64_t v39 = sub_1DD2F8298(a2, v28);
        int v40 = v39;
        if ((v39 & 0x8000000000000000) == 0 && sub_1DD24AB78((uint64_t)v26, a2)) {
          goto LABEL_115;
        }
        goto LABEL_139;
      case 0xBu:
        if (v9 != 88) {
          goto LABEL_10;
        }
        uint64_t v34 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8))
        {
          LODWORD(v35) = 0;
        }
        else
        {
          LODWORD(v35) = *v34;
          if (((char)*v34 & 0x80000000) == 0)
          {
            *(void *)a2 = v34 + 1;
            goto LABEL_124;
          }
        }
        uint64_t v35 = sub_1DD2F8C30((uint64_t *)a2, v35);
        if (v35 < 0) {
          goto LABEL_139;
        }
LABEL_124:
        if (v35 > 2)
        {
          if (v73 < 5)
          {
            sub_1DD2F9508((uint64_t)&v71, 0x58u);
            int v63 = v73;
          }
          else
          {
            *v72++ = 88;
            int v63 = --v73;
          }
          if (v63 < 5)
          {
            sub_1DD2F9508((uint64_t)&v71, v35);
          }
          else
          {
            int v64 = (int)v72;
            if (v35 < 0x80)
            {
              LOBYTE(v66) = v35;
              v65 = v72;
            }
            else
            {
              v65 = v72;
              do
              {
                *v65++ = v35 | 0x80;
                unsigned int v66 = v35 >> 7;
                unsigned int v67 = v35 >> 14;
                LODWORD(v35) = v35 >> 7;
              }
              while (v67);
            }
            unsigned char *v65 = v66;
            int v68 = v65 - v64 + 1;
            v72 += v68;
            v73 -= v68;
          }
        }
        else
        {
          *(_DWORD *)(a1 + 16) |= 0x40u;
          *(_DWORD *)(a1 + 160) = v35;
        }
        continue;
      default:
        goto LABEL_10;
    }
LABEL_12:
    if (!v11) {
      goto LABEL_139;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  unsigned int v10 = sub_1DD2F8F70(a2, v8);
  unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
  if ((v9 & 0x100000000) != 0) {
    goto LABEL_14;
  }
LABEL_10:
  if (v9)
  {
    BOOL v11 = sub_1DD2FB80C(a2, v9, (uint64_t)&v71);
    goto LABEL_12;
  }
  uint64_t v69 = 1;
LABEL_138:
  sub_1DD2F92B4(&v71);
  sub_1DD24F874(&v75);
  return v69;
}

void sub_1DD24C38C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t *a15)
{
}

uint64_t sub_1DD24C3E4(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 2) != 0) {
    sub_1DD2FC0E4(1, *(void *)(a1 + 128), a2);
  }
  if ((v4 & 4) != 0) {
    sub_1DD2FC0E4(2, *(void *)(a1 + 136), a2);
  }
  int v5 = *(_DWORD *)(a1 + 32);
  if (v5)
  {
    for (int i = 0; i != v5; ++i)
      sub_1DD2FCDAC(3, *(void *)(*(void *)(a1 + 40) + 8 * i + 8), a2);
  }
  int v7 = *(_DWORD *)(a1 + 56);
  if (v7)
  {
    for (int j = 0; j != v7; ++j)
      sub_1DD2FCDAC(4, *(void *)(*(void *)(a1 + 64) + 8 * j + 8), a2);
  }
  int v9 = *(_DWORD *)(a1 + 80);
  if (v9)
  {
    for (int k = 0; k != v9; ++k)
      sub_1DD2FCDAC(5, *(void *)(*(void *)(a1 + 88) + 8 * k + 8), a2);
  }
  if ((v4 & 8) != 0) {
    sub_1DD2FC0E4(6, *(void *)(a1 + 144), a2);
  }
  int v11 = *(_DWORD *)(a1 + 104);
  if (v11)
  {
    for (int m = 0; m != v11; ++m)
      sub_1DD2FCDAC(7, *(void *)(*(void *)(a1 + 112) + 8 * m + 8), a2);
  }
  if ((v4 & 0x10) != 0)
  {
    sub_1DD2FBFC4(8, *(_DWORD *)(a1 + 152), a2);
    if ((v4 & 0x20) == 0)
    {
LABEL_21:
      if ((v4 & 1) == 0) {
        goto LABEL_22;
      }
      goto LABEL_36;
    }
  }
  else if ((v4 & 0x20) == 0)
  {
    goto LABEL_21;
  }
  sub_1DD2FBFC4(9, *(_DWORD *)(a1 + 156), a2);
  if ((v4 & 1) == 0)
  {
LABEL_22:
    if ((v4 & 0x40) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
LABEL_36:
  sub_1DD2FCDAC(10, *(void *)(a1 + 120), a2);
  if ((v4 & 0x40) != 0) {
LABEL_23:
  }
    sub_1DD2FBEA4(11, *(_DWORD *)(a1 + 160), a2);
LABEL_24:
  uint64_t v13 = *(void *)(a1 + 8);
  if (v13) {
    uint64_t v14 = (char *)(v13 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v14 = (char *)&qword_1EAB1F7D8;
  }
  if (v14[23] < 0) {
    uint64_t v14 = *(char **)v14;
  }
  if (v13) {
    int v15 = (uint64_t *)(v13 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    int v15 = &qword_1EAB1F7D8;
  }
  if (*((char *)v15 + 23) < 0) {
    uint64_t v16 = v15[1];
  }
  else {
    LODWORD(v16) = *((unsigned __int8 *)v15 + 23);
  }
  return sub_1DD2F92E0(a2, v14, v16);
}

uint64_t sub_1DD24C5D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  uint64_t v6 = v4 + v5;
  if (v5)
  {
    int v7 = 0;
    do
    {
      uint64_t v8 = sub_1DD2475CC(*(void *)(*(void *)(a1 + 40) + 8 * v7 + 8));
      v6 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6);
      ++v7;
    }
    while (v5 != v7);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 56);
  uint64_t v10 = v6 + v9;
  if (v9)
  {
    int v11 = 0;
    do
    {
      uint64_t v12 = sub_1DD246918(*(void *)(*(void *)(a1 + 64) + 8 * v11 + 8));
      v10 += v12 + ((9 * (__clz(v12 | 1) ^ 0x1F) + 73) >> 6);
      ++v11;
    }
    while (v9 != v11);
  }
  uint64_t v13 = *(unsigned int *)(a1 + 80);
  uint64_t v14 = v10 + v13;
  if (v13)
  {
    int v15 = 0;
    do
    {
      uint64_t v16 = sub_1DD247D24(*(void *)(*(void *)(a1 + 88) + 8 * v15 + 8));
      v14 += v16 + ((9 * (__clz(v16 | 1) ^ 0x1F) + 73) >> 6);
      ++v15;
    }
    while (v13 != v15);
  }
  uint64_t v17 = *(unsigned int *)(a1 + 104);
  uint64_t v18 = v14 + v17;
  if (v17)
  {
    int v19 = 0;
    do
    {
      uint64_t v20 = sub_1DD2408E8(*(void *)(*(void *)(a1 + 112) + 8 * v19 + 8));
      v18 += v20 + ((9 * (__clz(v20 | 1) ^ 0x1F) + 73) >> 6);
      ++v19;
    }
    while (v17 != v19);
  }
  int v21 = *(_DWORD *)(a1 + 16);
  if ((v21 & 0x7F) != 0)
  {
    if (v21)
    {
      uint64_t v26 = sub_1DD24B22C(*(void *)(a1 + 120));
      v18 += v26 + ((9 * (__clz(v26 | 1) ^ 0x1F) + 73) >> 6) + 1;
      int v21 = *(_DWORD *)(a1 + 16);
      if ((v21 & 2) == 0)
      {
LABEL_22:
        if ((v21 & 4) == 0) {
          goto LABEL_23;
        }
        goto LABEL_34;
      }
    }
    else if ((v21 & 2) == 0)
    {
      goto LABEL_22;
    }
    v18 += ((9 * (__clz(*(void *)(a1 + 128) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v21 & 4) == 0)
    {
LABEL_23:
      if ((v21 & 8) == 0) {
        goto LABEL_24;
      }
      goto LABEL_35;
    }
LABEL_34:
    v18 += ((9 * (__clz(*(void *)(a1 + 136) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v21 & 8) == 0)
    {
LABEL_24:
      if ((v21 & 0x10) == 0) {
        goto LABEL_25;
      }
      goto LABEL_36;
    }
LABEL_35:
    v18 += ((9 * (__clz(*(void *)(a1 + 144) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v21 & 0x10) == 0)
    {
LABEL_25:
      if ((v21 & 0x20) == 0) {
        goto LABEL_26;
      }
      goto LABEL_37;
    }
LABEL_36:
    v18 += ((9 * (__clz(*(_DWORD *)(a1 + 152) | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v21 & 0x20) == 0)
    {
LABEL_26:
      if ((v21 & 0x40) == 0) {
        goto LABEL_31;
      }
      goto LABEL_27;
    }
LABEL_37:
    v18 += ((9 * (__clz(*(_DWORD *)(a1 + 156) | 1) ^ 0x1F) + 73) >> 6) + 1;
    if ((v21 & 0x40) == 0) {
      goto LABEL_31;
    }
LABEL_27:
    int v22 = *(_DWORD *)(a1 + 160);
    uint64_t v23 = ((9 * (__clz(v22 | 1) ^ 0x1F) + 73) >> 6) + 1;
    if (v22 >= 0) {
      uint64_t v24 = v23;
    }
    else {
      uint64_t v24 = 11;
    }
    v18 += v24;
  }
LABEL_31:
  *(_DWORD *)(a1 + 20) = v18;
  return v18;
}

std::string *sub_1DD24C8B0(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  unsigned int v5 = *(_DWORD *)(a2 + 32);
  if (v5)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a2 + 40) + 8);
    int v7 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[1], *(_DWORD *)(a2 + 32));
    uint64_t result = sub_1DD2507D4(v3 + 1, v7, v6, v5, *(_DWORD *)v3[1].__r_.__value_.__r.__words[2] - LODWORD(v3[1].__r_.__value_.__r.__words[1]));
    signed int v8 = LODWORD(v3[1].__r_.__value_.__r.__words[1]) + v5;
    LODWORD(v3[1].__r_.__value_.__r.__words[1]) = v8;
    uint64_t v9 = (signed int *)v3[1].__r_.__value_.__r.__words[2];
    if (*v9 < v8) {
      signed int *v9 = v8;
    }
  }
  unsigned int v10 = *(_DWORD *)(a2 + 56);
  if (v10)
  {
    int v11 = (uint64_t *)(*(void *)(a2 + 64) + 8);
    uint64_t v12 = (unint64_t **)sub_1DD2FAAC0((uint64_t)&v3[2], *(_DWORD *)(a2 + 56));
    uint64_t result = (std::string *)sub_1DD250894((unint64_t *)&v3[2], v12, v11, v10, *(_DWORD *)v3[2].__r_.__value_.__r.__words[2]- LODWORD(v3[2].__r_.__value_.__r.__words[1]));
    signed int v13 = LODWORD(v3[2].__r_.__value_.__r.__words[1]) + v10;
    LODWORD(v3[2].__r_.__value_.__r.__words[1]) = v13;
    uint64_t v14 = (signed int *)v3[2].__r_.__value_.__r.__words[2];
    if (*v14 < v13) {
      signed int *v14 = v13;
    }
  }
  unsigned int v15 = *(_DWORD *)(a2 + 80);
  if (v15)
  {
    uint64_t v16 = (uint64_t *)(*(void *)(a2 + 88) + 8);
    uint64_t v17 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[3], *(_DWORD *)(a2 + 80));
    uint64_t result = sub_1DD250954(v3 + 3, v17, v16, v15, *(_DWORD *)v3[3].__r_.__value_.__r.__words[2] - LODWORD(v3[3].__r_.__value_.__r.__words[1]));
    signed int v18 = LODWORD(v3[3].__r_.__value_.__r.__words[1]) + v15;
    LODWORD(v3[3].__r_.__value_.__r.__words[1]) = v18;
    int v19 = (signed int *)v3[3].__r_.__value_.__r.__words[2];
    if (*v19 < v18) {
      *int v19 = v18;
    }
  }
  unsigned int v20 = *(_DWORD *)(a2 + 104);
  if (v20)
  {
    int v21 = (uint64_t *)(*(void *)(a2 + 112) + 8);
    int v22 = (std::string **)sub_1DD2FAAC0((uint64_t)&v3[4], *(_DWORD *)(a2 + 104));
    uint64_t result = sub_1DD250414(v3 + 4, v22, v21, v20, *(_DWORD *)v3[4].__r_.__value_.__r.__words[2] - LODWORD(v3[4].__r_.__value_.__r.__words[1]));
    signed int v23 = LODWORD(v3[4].__r_.__value_.__r.__words[1]) + v20;
    LODWORD(v3[4].__r_.__value_.__r.__words[1]) = v23;
    uint64_t v24 = (signed int *)v3[4].__r_.__value_.__r.__words[2];
    if (*v24 < v23) {
      signed int *v24 = v23;
    }
  }
  int v25 = *(_DWORD *)(a2 + 16);
  if ((v25 & 0x7F) != 0)
  {
    if (v25)
    {
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      data = (std::string *)v3[5].__r_.__value_.__l.__data_;
      if (!data)
      {
        data = (std::string *)sub_1DD24F2FC(0);
        v3[5].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
      }
      if (*(void *)(a2 + 120)) {
        uint64_t v27 = *(void **)(a2 + 120);
      }
      else {
        uint64_t v27 = &unk_1EAB1F1B8;
      }
      uint64_t result = sub_1DD24B3A8(data, (uint64_t)v27);
      if ((v25 & 2) == 0)
      {
LABEL_18:
        if ((v25 & 4) == 0) {
          goto LABEL_19;
        }
        goto LABEL_33;
      }
    }
    else if ((v25 & 2) == 0)
    {
      goto LABEL_18;
    }
    v3[5].__r_.__value_.__l.__size_ = *(void *)(a2 + 128);
    if ((v25 & 4) == 0)
    {
LABEL_19:
      if ((v25 & 8) == 0) {
        goto LABEL_20;
      }
      goto LABEL_34;
    }
LABEL_33:
    v3[5].__r_.__value_.__r.__words[2] = *(void *)(a2 + 136);
    if ((v25 & 8) == 0)
    {
LABEL_20:
      if ((v25 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_35;
    }
LABEL_34:
    v3[6].__r_.__value_.__r.__words[0] = *(void *)(a2 + 144);
    if ((v25 & 0x10) == 0)
    {
LABEL_21:
      if ((v25 & 0x20) == 0) {
        goto LABEL_22;
      }
      goto LABEL_36;
    }
LABEL_35:
    LODWORD(v3[6].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 152);
    if ((v25 & 0x20) == 0)
    {
LABEL_22:
      if ((v25 & 0x40) == 0)
      {
LABEL_24:
        LODWORD(v3->__r_.__value_.__r.__words[2]) |= v25;
        return result;
      }
LABEL_23:
      LODWORD(v3[6].__r_.__value_.__r.__words[2]) = *(_DWORD *)(a2 + 160);
      goto LABEL_24;
    }
LABEL_36:
    HIDWORD(v3[6].__r_.__value_.__r.__words[1]) = *(_DWORD *)(a2 + 156);
    if ((v25 & 0x40) == 0) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  return result;
}

std::string *sub_1DD24CB3C(std::string *result, uint64_t a2)
{
  if ((std::string *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD24BA0C((uint64_t)result);
    return sub_1DD24C8B0(v4, a2);
  }
  return result;
}

uint64_t sub_1DD24CB88()
{
  return 1;
}

void *sub_1DD24CB90@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.Footer");
}

uint64_t sub_1DD24CBA0(uint64_t a1)
{
  *(void *)a1 = &unk_1F387B8F8;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  if (atomic_load_explicit(dword_1EC8AC050, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8AC050);
  }
  *(void *)(a1 + 48) = &qword_1EAB1F7D8;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  return a1;
}

void sub_1DD24CC34(_Unwind_Exception *a1)
{
  sub_1DD23CE34(v1 + 24);
  sub_1DD24F770(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24CC54(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F387B8F8;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = (unint64_t *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 36) = 0;
  *(void *)(a1 + 20) = 0;
  *(void *)(a1 + 28) = 0;
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    sub_1DD250120((unsigned int *)(a1 + 24), v5);
    uint64_t v6 = *(void *)(a1 + 32);
    *(_DWORD *)(a1 + 24) += *(_DWORD *)(a2 + 24);
    memcpy((void *)(v6 + 8), (const void *)(*(void *)(a2 + 32) + 8), 4 * *(int *)(a2 + 24));
  }
  uint64_t v7 = *(void *)(a2 + 8);
  if (v7) {
    sub_1DD24FBB0(v4, v7 & 0xFFFFFFFFFFFFFFFELL);
  }
  *(void *)(a1 + 48) = &qword_1EAB1F7D8;
  if (*(unsigned char *)(a2 + 16))
  {
    signed int v8 = *(uint64_t **)(a2 + 48);
    if (v8 != &qword_1EAB1F7D8) {
      sub_1DD24F908((void *)(a1 + 48), (uint64_t)v8);
    }
  }
  long long v9 = *(_OWORD *)(a2 + 56);
  long long v10 = *(_OWORD *)(a2 + 72);
  *(void *)(a1 + 88) = *(void *)(a2 + 88);
  *(_OWORD *)(a1 + 72) = v10;
  *(_OWORD *)(a1 + 56) = v9;
  return a1;
}

void sub_1DD24CD50(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24CD78(uint64_t a1)
{
  *(void *)a1 = &unk_1F387B8F8;
  sub_1DD24CDE4(a1);
  if (*(int *)(a1 + 28) >= 1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      if (!*v2) {
        operator delete(v2);
      }
    }
  }
  sub_1DD24F770((uint64_t *)(a1 + 8));
  return a1;
}

void sub_1DD24CDE4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  if ((uint64_t *)v1 != &qword_1EAB1F7D8 && v1 != 0)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    operator delete((void *)v1);
  }
}

void sub_1DD24CE4C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD24CD78(a1);
  operator delete(v1);
}

void sub_1DD24CE74(uint64_t a1)
{
  *(_DWORD *)(a1 + 24) = 0;
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(void *)(a1 + 48);
    if (*(char *)(v2 + 23) < 0)
    {
      **(unsigned char **)uint64_t v2 = 0;
      *(void *)(v2 + 8) = 0;
    }
    else
    {
      *(unsigned char *)uint64_t v2 = 0;
      *(unsigned char *)(v2 + 23) = 0;
    }
  }
  if ((v1 & 0x7E) != 0)
  {
    *(void *)(a1 + 88) = 0;
    *(_OWORD *)(a1 + 72) = 0u;
    *(_OWORD *)(a1 + 56) = 0u;
  }
  char v4 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  *(_DWORD *)(v3 + 8) = 0;
  if (v4) {
    sub_1DD24FC0C((unint64_t *)v3);
  }
}

uint64_t sub_1DD24CED0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v45 = (uint64_t *)(a1 + 8);
  long long v46 = 0uLL;
  uint64_t v47 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v47 = *(void *)(v5 + 16);
    long long v46 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v44, (uint64_t)&v46);
  sub_1DD2F9178((uint64_t)&v41, (uint64_t)v44, 0);
  while (1)
  {
LABEL_4:
    uint64_t v7 = (unsigned __int8 *)*a2;
    unint64_t v8 = a2[1];
    if (*a2 >= v8)
    {
      unint64_t v10 = 0;
      goto LABEL_72;
    }
    long long v9 = v7 + 1;
    unint64_t v10 = *v7;
    if ((char)*v7 >= 1)
    {
      *a2 = (uint64_t)v9;
      v10 |= 0x100000000uLL;
      if ((v10 & 0x100000000) != 0) {
        goto LABEL_11;
      }
      goto LABEL_73;
    }
    if ((unint64_t)v9 < v8)
    {
      int v11 = *v9;
      if ((v10 & ~v11) >= 0x80) {
        break;
      }
    }
LABEL_72:
    unsigned int v31 = sub_1DD2F8F70((uint64_t)a2, v10);
    unint64_t v10 = v31 | ((unint64_t)(v31 - 1 < 0xFA05) << 32);
    if ((v10 & 0x100000000) != 0) {
      goto LABEL_11;
    }
LABEL_73:
    if (!v10)
    {
      uint64_t v39 = 1;
      goto LABEL_96;
    }
    char v15 = sub_1DD2FB80C((uint64_t)a2, v10, (uint64_t)&v41);
LABEL_75:
    if ((v15 & 1) == 0) {
      goto LABEL_94;
    }
  }
  *a2 = (uint64_t)(v7 + 2);
  LODWORD(v10) = v10 + (v11 << 7) - 128;
LABEL_11:
  switch(v10 >> 3)
  {
    case 1u:
      if (v10 != 8) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 2u;
      uint64_t v12 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
      {
        *(void *)(a1 + 56) = *v12;
LABEL_49:
        *a2 = (uint64_t)(v12 + 1);
        goto LABEL_4;
      }
      *(void *)(a1 + 56) = sub_1DD2F8A78((uint64_t)a2);
      if (v21) {
        goto LABEL_4;
      }
      goto LABEL_94;
    case 2u:
      if (v10 != 16) {
        goto LABEL_73;
      }
      uint64_t v16 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        LODWORD(v17) = 0;
      }
      else
      {
        LODWORD(v17) = *v16;
        if ((*v16 & 0x80000000) == 0)
        {
          *a2 = (uint64_t)(v16 + 1);
          goto LABEL_79;
        }
      }
      uint64_t v17 = sub_1DD2F8C30(a2, v17);
      if (v17 < 0) {
        goto LABEL_94;
      }
LABEL_79:
      if (v17 > 5)
      {
        if (v43 < 5)
        {
          sub_1DD2F9508((uint64_t)&v41, 0x10u);
          int v32 = v43;
        }
        else
        {
          *v42++ = 16;
          int v32 = --v43;
        }
        if (v32 < 5)
        {
          sub_1DD2F9508((uint64_t)&v41, v17);
        }
        else
        {
          int v33 = (int)v42;
          if (v17 < 0x80)
          {
            LOBYTE(v35) = v17;
            uint64_t v34 = v42;
          }
          else
          {
            uint64_t v34 = v42;
            do
            {
              *v34++ = v17 | 0x80;
              unsigned int v35 = v17 >> 7;
              unsigned int v36 = v17 >> 14;
              LODWORD(v17) = v17 >> 7;
            }
            while (v36);
          }
          *uint64_t v34 = v35;
          int v37 = v34 - v33 + 1;
          v42 += v37;
          v43 -= v37;
        }
      }
      else
      {
        *(_DWORD *)(a1 + 16) |= 8u;
        *(_DWORD *)(a1 + 72) = v17;
      }
      goto LABEL_4;
    case 3u:
      if (v10 != 24) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 4u;
      uint64_t v12 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
      {
        *(void *)(a1 + 64) = *v12;
        goto LABEL_49;
      }
      *(void *)(a1 + 64) = sub_1DD2F8A78((uint64_t)a2);
      if (v22) {
        goto LABEL_4;
      }
LABEL_94:
      uint64_t v39 = 0;
LABEL_96:
      sub_1DD2F92B4(&v41);
      sub_1DD24F874(&v45);
      return v39;
    case 4u:
      if (v10 == 32)
      {
        char v15 = sub_1DD2464D8(1, 0x22u, a2, (signed int *)(a1 + 24));
        goto LABEL_75;
      }
      if (v10 != 34) {
        goto LABEL_73;
      }
      signed int v18 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1] && (*v18 & 0x80000000) == 0)
      {
        int v19 = *v18;
        *a2 = (uint64_t)(v18 + 1);
        goto LABEL_60;
      }
      int v19 = sub_1DD2F8D1C((unsigned __int8 **)a2);
      if (v19 < 0) {
        goto LABEL_94;
      }
LABEL_60:
      int v25 = sub_1DD2F81D8((uint64_t)a2, v19);
      break;
    case 5u:
      if (v10 != 40) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 0x20u;
      uint64_t v12 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
      {
        *(void *)(a1 + 80) = *v12;
        goto LABEL_49;
      }
      *(void *)(a1 + 80) = sub_1DD2F8A78((uint64_t)a2);
      if (v23) {
        goto LABEL_4;
      }
      goto LABEL_94;
    case 6u:
      if (v10 != 48) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 0x10u;
      uint64_t v12 = (char *)*a2;
      if (*a2 >= (unint64_t)a2[1])
      {
        int v20 = 0;
      }
      else
      {
        int v20 = *v12;
        if ((*v12 & 0x80000000) == 0)
        {
          *(_DWORD *)(a1 + 76) = v20;
          goto LABEL_49;
        }
      }
      uint64_t v38 = sub_1DD2F8C30(a2, v20);
      *(_DWORD *)(a1 + 76) = v38;
      if (v38 < 0) {
        goto LABEL_94;
      }
      goto LABEL_4;
    case 7u:
      if (v10 != 56) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 0x40u;
      uint64_t v12 = (char *)*a2;
      if (*a2 < (unint64_t)a2[1] && (*v12 & 0x80000000) == 0)
      {
        *(void *)(a1 + 88) = *v12;
        goto LABEL_49;
      }
      *(void *)(a1 + 88) = sub_1DD2F8A78((uint64_t)a2);
      if (v24) {
        goto LABEL_4;
      }
      goto LABEL_94;
    default:
      if (v10 >> 3 != 8000 || v10 != 2) {
        goto LABEL_73;
      }
      *(_DWORD *)(a1 + 16) |= 1u;
      uint64_t v14 = *(std::string **)(a1 + 48);
      if (v14 == (std::string *)&qword_1EAB1F7D8)
      {
        sub_1DD24F908((void *)(a1 + 48), (uint64_t)&qword_1EAB1F7D8);
        uint64_t v14 = *(std::string **)(a1 + 48);
      }
      char v15 = sub_1DD2FCF1C(a2, v14);
      goto LABEL_75;
  }
  while (2)
  {
    if ((int)sub_1DD2F8334(a2) < 1)
    {
      sub_1DD2F8250((uint64_t)a2, v25);
      goto LABEL_4;
    }
    uint64_t v26 = (char *)*a2;
    if (*a2 >= (unint64_t)a2[1])
    {
      int v27 = 0;
    }
    else
    {
      int v27 = *v26;
      if ((*v26 & 0x80000000) == 0)
      {
        *a2 = (uint64_t)(v26 + 1);
LABEL_67:
        int v29 = *(_DWORD *)(a1 + 24);
        if (v29 == *(_DWORD *)(a1 + 28))
        {
          sub_1DD250120((unsigned int *)(a1 + 24), v29 + 1);
          int v29 = *(_DWORD *)(a1 + 24);
        }
        uint64_t v30 = *(void *)(a1 + 32);
        *(_DWORD *)(a1 + 24) = v29 + 1;
        *(_DWORD *)(v30 + 4 * v29 + 8) = v27;
        continue;
      }
    }
    break;
  }
  uint64_t v28 = sub_1DD2F8C30(a2, v27);
  int v27 = v28;
  if (v28 < 0) {
    goto LABEL_94;
  }
  goto LABEL_67;
}

void sub_1DD24D450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t *a15)
{
}

uint64_t sub_1DD24D49C(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if ((v4 & 2) == 0)
  {
    if ((v4 & 8) == 0) {
      goto LABEL_3;
    }
LABEL_9:
    sub_1DD2FBEA4(2, *(_DWORD *)(a1 + 72), a2);
    if ((v4 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  sub_1DD2FC0E4(1, *(void *)(a1 + 56), a2);
  if ((v4 & 8) != 0) {
    goto LABEL_9;
  }
LABEL_3:
  if ((v4 & 4) != 0) {
LABEL_4:
  }
    sub_1DD2FC0E4(3, *(void *)(a1 + 64), a2);
LABEL_5:
  if (*(int *)(a1 + 24) >= 1)
  {
    if (*(int *)(a2 + 16) < 5)
    {
      sub_1DD2F9508(a2, 0x22u);
      int v5 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      *(unsigned char *)(*(void *)(a2 + 8))++ = 34;
      int v5 = *(_DWORD *)(a2 + 16) - 1;
      *(_DWORD *)(a2 + 16) = v5;
    }
    unsigned int v6 = *(_DWORD *)(a1 + 40);
    if (v5 < 5)
    {
      sub_1DD2F9508(a2, v6);
    }
    else
    {
      uint64_t v7 = *(void *)(a2 + 8);
      if (v6 < 0x80)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 40);
        unint64_t v8 = *(unsigned char **)(a2 + 8);
      }
      else
      {
        unint64_t v8 = *(unsigned char **)(a2 + 8);
        do
        {
          *v8++ = v6 | 0x80;
          unsigned int v9 = v6 >> 7;
          unsigned int v10 = v6 >> 14;
          v6 >>= 7;
        }
        while (v10);
      }
      *unint64_t v8 = v9;
      int v11 = v8 - v7 + 1;
      *(void *)(a2 + 8) += v11;
      *(_DWORD *)(a2 + 16) -= v11;
    }
    uint64_t v12 = *(unsigned int *)(a1 + 24);
    if ((int)v12 >= 1)
    {
      for (uint64_t i = 0; i != v12; ++i)
      {
        unsigned int v14 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i + 8);
        if (*(int *)(a2 + 16) < 5)
        {
          sub_1DD2F9508(a2, v14);
        }
        else
        {
          uint64_t v15 = *(void *)(a2 + 8);
          if (v14 < 0x80)
          {
            unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 32) + 4 * i + 8);
            uint64_t v16 = *(unsigned char **)(a2 + 8);
          }
          else
          {
            uint64_t v16 = *(unsigned char **)(a2 + 8);
            do
            {
              *v16++ = v14 | 0x80;
              unsigned int v17 = v14 >> 7;
              unsigned int v18 = v14 >> 14;
              v14 >>= 7;
            }
            while (v18);
          }
          *uint64_t v16 = v17;
          int v19 = v16 - v15 + 1;
          *(void *)(a2 + 8) += v19;
          *(_DWORD *)(a2 + 16) -= v19;
        }
      }
    }
  }
  if ((v4 & 0x20) != 0)
  {
    sub_1DD2FC0E4(5, *(void *)(a1 + 80), a2);
    if ((v4 & 0x10) == 0)
    {
LABEL_33:
      if ((v4 & 0x40) == 0) {
        goto LABEL_34;
      }
      goto LABEL_48;
    }
  }
  else if ((v4 & 0x10) == 0)
  {
    goto LABEL_33;
  }
  sub_1DD2FBFC4(6, *(_DWORD *)(a1 + 76), a2);
  if ((v4 & 0x40) == 0)
  {
LABEL_34:
    if ((v4 & 1) == 0) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
LABEL_48:
  sub_1DD2FC0E4(7, *(void *)(a1 + 88), a2);
  if (v4) {
LABEL_35:
  }
    sub_1DD2FC85C(8000, *(void *)(a1 + 48), a2);
LABEL_36:
  uint64_t v20 = *(void *)(a1 + 8);
  if (v20) {
    char v21 = (char *)(v20 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v21 = (char *)&qword_1EAB1F7D8;
  }
  if (v21[23] < 0) {
    char v21 = *(char **)v21;
  }
  if (v20) {
    char v22 = (uint64_t *)(v20 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    char v22 = &qword_1EAB1F7D8;
  }
  if (*((char *)v22 + 23) < 0) {
    uint64_t v23 = v22[1];
  }
  else {
    LODWORD(v23) = *((unsigned __int8 *)v22 + 23);
  }
  return sub_1DD2F92E0(a2, v21, v23);
}

uint64_t sub_1DD24D730(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  uint64_t v5 = sub_1DD2FD008((unsigned int *)(a1 + 24));
  uint64_t v6 = 11;
  uint64_t v7 = ((9 * (__clz(v5 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((int)v5 >= 0) {
    uint64_t v6 = v7;
  }
  uint64_t v8 = v6 + v4;
  if (v5) {
    int v9 = v5;
  }
  else {
    int v9 = 0;
  }
  if (!v5) {
    uint64_t v8 = v4;
  }
  *(_DWORD *)(a1 + 40) = v9;
  uint64_t result = v8 + v5;
  int v11 = *(_DWORD *)(a1 + 16);
  if ((v11 & 0x7F) == 0) {
    goto LABEL_23;
  }
  if (v11)
  {
    uint64_t v12 = *(void *)(a1 + 48);
    uint64_t v13 = *(unsigned __int8 *)(v12 + 23);
    uint64_t v14 = *(void *)(v12 + 8);
    if ((v13 & 0x80u) == 0) {
      uint64_t v14 = v13;
    }
    result += v14 + ((9 * (__clz(v14 | 1) ^ 0x1F) + 73) >> 6) + 3;
    if ((v11 & 2) == 0)
    {
LABEL_17:
      if ((v11 & 4) == 0) {
        goto LABEL_18;
      }
      goto LABEL_28;
    }
  }
  else if ((v11 & 2) == 0)
  {
    goto LABEL_17;
  }
  result += ((9 * (__clz(*(void *)(a1 + 56) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v11 & 4) == 0)
  {
LABEL_18:
    if ((v11 & 8) == 0) {
      goto LABEL_19;
    }
    goto LABEL_29;
  }
LABEL_28:
  result += ((9 * (__clz(*(void *)(a1 + 64) | 1) ^ 0x3F) + 73) >> 6) + 1;
  if ((v11 & 8) == 0)
  {
LABEL_19:
    if ((v11 & 0x10) == 0) {
      goto LABEL_20;
    }
    goto LABEL_33;
  }
LABEL_29:
  int v15 = *(_DWORD *)(a1 + 72);
  uint64_t v16 = ((9 * (__clz(v15 | 1) ^ 0x1F) + 73) >> 6) + 1;
  if (v15 >= 0) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = 11;
  }
  result += v17;
  if ((v11 & 0x10) == 0)
  {
LABEL_20:
    if ((v11 & 0x20) == 0) {
      goto LABEL_21;
    }
LABEL_34:
    result += ((9 * (__clz(*(void *)(a1 + 80) | 1) ^ 0x3F) + 73) >> 6) + 1;
    if ((v11 & 0x40) == 0) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_33:
  result += ((9 * (__clz(*(_DWORD *)(a1 + 76) | 1) ^ 0x1F) + 73) >> 6) + 1;
  if ((v11 & 0x20) != 0) {
    goto LABEL_34;
  }
LABEL_21:
  if ((v11 & 0x40) != 0) {
LABEL_22:
  }
    result += ((9 * (__clz(*(void *)(a1 + 88) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_23:
  *(_DWORD *)(a1 + 20) = result;
  return result;
}

void *sub_1DD24D920(void *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(result + 1, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    uint64_t v6 = *((int *)v3 + 6);
    sub_1DD250120((unsigned int *)v3 + 6, v6 + v5);
    uint64_t v7 = v3[4];
    *((_DWORD *)v3 + 6) += *(_DWORD *)(a2 + 24);
    uint64_t result = memcpy((void *)(v7 + 4 * v6 + 8), (const void *)(*(void *)(a2 + 32) + 8), 4 * *(int *)(a2 + 24));
  }
  int v8 = *(_DWORD *)(a2 + 16);
  if ((v8 & 0x7F) != 0)
  {
    if (v8)
    {
      uint64_t result = v3 + 6;
      int v9 = (std::string *)v3[6];
      *((_DWORD *)v3 + 4) |= 1u;
      unsigned int v10 = *(const std::string **)(a2 + 48);
      if (v9 != v10)
      {
        if (v9 == (std::string *)&qword_1EAB1F7D8)
        {
          uint64_t result = sub_1DD24F908(result, (uint64_t)v10);
          if ((v8 & 2) == 0)
          {
LABEL_11:
            if ((v8 & 4) == 0) {
              goto LABEL_12;
            }
            goto LABEL_21;
          }
LABEL_20:
          v3[7] = *(void *)(a2 + 56);
          if ((v8 & 4) == 0)
          {
LABEL_12:
            if ((v8 & 8) == 0) {
              goto LABEL_13;
            }
            goto LABEL_22;
          }
LABEL_21:
          v3[8] = *(void *)(a2 + 64);
          if ((v8 & 8) == 0)
          {
LABEL_13:
            if ((v8 & 0x10) == 0) {
              goto LABEL_14;
            }
            goto LABEL_23;
          }
LABEL_22:
          *((_DWORD *)v3 + 18) = *(_DWORD *)(a2 + 72);
          if ((v8 & 0x10) == 0)
          {
LABEL_14:
            if ((v8 & 0x20) == 0) {
              goto LABEL_15;
            }
            goto LABEL_24;
          }
LABEL_23:
          *((_DWORD *)v3 + 19) = *(_DWORD *)(a2 + 76);
          if ((v8 & 0x20) == 0)
          {
LABEL_15:
            if ((v8 & 0x40) == 0)
            {
LABEL_17:
              *((_DWORD *)v3 + 4) |= v8;
              return result;
            }
LABEL_16:
            v3[11] = *(void *)(a2 + 88);
            goto LABEL_17;
          }
LABEL_24:
          v3[10] = *(void *)(a2 + 80);
          if ((v8 & 0x40) == 0) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }
        uint64_t result = std::string::operator=(v9, v10);
      }
    }
    if ((v8 & 2) == 0) {
      goto LABEL_11;
    }
    goto LABEL_20;
  }
  return result;
}

void *sub_1DD24DA68(void *result, uint64_t a2)
{
  if ((void *)a2 != result)
  {
    uint64_t v4 = result;
    sub_1DD24CE74((uint64_t)result);
    return sub_1DD24D920(v4, a2);
  }
  return result;
}

uint64_t sub_1DD24DAB4()
{
  return 1;
}

void *sub_1DD24DABC@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.PostScript");
}

uint64_t sub_1DD24DACC(uint64_t a1)
{
  *(void *)a1 = &unk_1F387C9D8;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (atomic_load_explicit(dword_1EC8ABF00, memory_order_acquire)) {
    sub_1DD2F7DA0(dword_1EC8ABF00);
  }
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  return a1;
}

void sub_1DD24DB44(_Unwind_Exception *a1)
{
  sub_1DD24F770(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24DB5C(void *a1)
{
  *a1 = &unk_1F387C9D8;
  sub_1DD24DBAC(a1);
  sub_1DD24F770(a1 + 1);
  return a1;
}

void *sub_1DD24DBAC(void *result)
{
  if (result != (void *)&unk_1EAB1F7A0)
  {
    int v1 = result;
    uint64_t v2 = result[3];
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    uint64_t result = (void *)v1[4];
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v3();
    }
  }
  return result;
}

void sub_1DD24DC50(void *a1)
{
  int v1 = sub_1DD24DB5C(a1);
  operator delete(v1);
}

void sub_1DD24DC78(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if ((v2 & 3) != 0)
  {
    if (v2) {
      sub_1DD24CE74(*(void *)(a1 + 24));
    }
    if ((v2 & 2) != 0) {
      sub_1DD24BA0C(*(void *)(a1 + 32));
    }
  }
  if ((v2 & 0xC) != 0)
  {
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
  char v4 = *(unsigned char *)(a1 + 8);
  uint64_t v3 = a1 + 8;
  *(_DWORD *)(v3 + 8) = 0;
  if (v4)
  {
    sub_1DD24FC0C((unint64_t *)v3);
  }
}

uint64_t sub_1DD24DCF4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v30 = (uint64_t *)(a1 + 8);
  long long v31 = 0uLL;
  uint64_t v32 = 0;
  if (v4)
  {
    unint64_t v5 = v4 & 0xFFFFFFFFFFFFFFFELL;
    long long v6 = *(_OWORD *)v5;
    uint64_t v32 = *(void *)(v5 + 16);
    long long v31 = v6;
    *(void *)(v5 + 8) = 0;
    *(void *)(v5 + 16) = 0;
    *(void *)unint64_t v5 = 0;
  }
  sub_1DD2F98B8(v29, (uint64_t)&v31);
  sub_1DD2F9178((uint64_t)v28, (uint64_t)v29, 0);
  while (1)
  {
    uint64_t v7 = *(unsigned __int8 **)a2;
    if (*(void *)a2 >= *(void *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *v7;
    if ((char)*v7 < 1) {
      goto LABEL_9;
    }
    *(void *)a2 = v7 + 1;
    unint64_t v9 = v8 | 0x100000000;
    if ((v9 & 0x100000000) == 0) {
      goto LABEL_32;
    }
LABEL_10:
    switch(v9 >> 3)
    {
      case 1u:
        if (v9 != 10) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 1u;
        int v11 = *(void **)(a1 + 24);
        if (!v11)
        {
          int v11 = sub_1DD24F424(0);
          *(void *)(a1 + 24) = v11;
        }
        uint64_t v12 = *(char **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || *v12 < 0)
        {
          int v13 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v13 < 0) {
            goto LABEL_50;
          }
        }
        else
        {
          int v13 = *v12;
          *(void *)a2 = v12 + 1;
        }
        unint64_t v23 = sub_1DD2F8298(a2, v13);
        int v24 = v23;
        if ((v23 & 0x8000000000000000) == 0 && sub_1DD24CED0((uint64_t)v11, (uint64_t *)a2)) {
          goto LABEL_43;
        }
        goto LABEL_50;
      case 2u:
        if (v9 != 18) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 2u;
        uint64_t v14 = *(void **)(a1 + 32);
        if (!v14)
        {
          uint64_t v14 = sub_1DD24F390(0);
          *(void *)(a1 + 32) = v14;
        }
        int v15 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v15 < 0)
        {
          int v16 = sub_1DD2F8D1C((unsigned __int8 **)a2);
          if (v16 < 0) {
            goto LABEL_50;
          }
        }
        else
        {
          int v16 = *v15;
          *(void *)a2 = v15 + 1;
        }
        unint64_t v25 = sub_1DD2F8298(a2, v16);
        int v24 = v25;
        if ((v25 & 0x8000000000000000) != 0 || !sub_1DD24BB28((uint64_t)v14, a2))
        {
LABEL_50:
          uint64_t v26 = 0;
          goto LABEL_49;
        }
LABEL_43:
        BOOL v20 = sub_1DD2F82D0(a2, v24);
        break;
      case 3u:
        if (v9 != 24) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 4u;
        uint64_t v17 = *(unsigned __int8 **)a2;
        if (*(void *)a2 < *(void *)(a2 + 8) && ((char)*v17 & 0x80000000) == 0)
        {
          uint64_t v18 = *v17;
          int v19 = (void *)(a1 + 40);
          goto LABEL_31;
        }
        *(void *)(a1 + 40) = sub_1DD2F8A78(a2);
        if ((v21 & 1) == 0) {
          goto LABEL_50;
        }
        continue;
      case 4u:
        if (v9 != 32) {
          goto LABEL_32;
        }
        *(_DWORD *)(a1 + 16) |= 8u;
        uint64_t v17 = *(unsigned __int8 **)a2;
        if (*(void *)a2 >= *(void *)(a2 + 8) || (char)*v17 < 0)
        {
          *(void *)(a1 + 48) = sub_1DD2F8A78(a2);
          if ((v22 & 1) == 0) {
            goto LABEL_50;
          }
        }
        else
        {
          uint64_t v18 = *v17;
          int v19 = (void *)(a1 + 48);
LABEL_31:
          *int v19 = v18;
          *(void *)a2 = v17 + 1;
        }
        continue;
      default:
        goto LABEL_32;
    }
LABEL_34:
    if (!v20) {
      goto LABEL_50;
    }
  }
  uint64_t v8 = 0;
LABEL_9:
  unsigned int v10 = sub_1DD2F8F70(a2, v8);
  unint64_t v9 = v10 | ((unint64_t)(v10 - 1 < 0x7F) << 32);
  if ((v9 & 0x100000000) != 0) {
    goto LABEL_10;
  }
LABEL_32:
  if (v9)
  {
    BOOL v20 = sub_1DD2FB80C(a2, v9, (uint64_t)v28);
    goto LABEL_34;
  }
  uint64_t v26 = 1;
LABEL_49:
  sub_1DD2F92B4(v28);
  sub_1DD24F874(&v30);
  return v26;
}

void sub_1DD24E010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_1DD24F874((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD24E048(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 16);
  if (v4)
  {
    sub_1DD2FCDAC(1, *(void *)(a1 + 24), a2);
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_18;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  sub_1DD2FCDAC(2, *(void *)(a1 + 32), a2);
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
LABEL_18:
  sub_1DD2FC0E4(3, *(void *)(a1 + 40), a2);
  if ((v4 & 8) != 0) {
LABEL_5:
  }
    sub_1DD2FC0E4(4, *(void *)(a1 + 48), a2);
LABEL_6:
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5) {
    long long v6 = (char *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    long long v6 = (char *)&qword_1EAB1F7D8;
  }
  if (v6[23] < 0) {
    long long v6 = *(char **)v6;
  }
  if (v5) {
    uint64_t v7 = (uint64_t *)(v5 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v7 = &qword_1EAB1F7D8;
  }
  if (*((char *)v7 + 23) < 0) {
    uint64_t v8 = v7[1];
  }
  else {
    LODWORD(v8) = *((unsigned __int8 *)v7 + 23);
  }
  return sub_1DD2F92E0(a2, v6, v8);
}

uint64_t sub_1DD24E134(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2) {
    uint64_t v3 = (uint64_t *)(v2 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    uint64_t v3 = &qword_1EAB1F7D8;
  }
  if (*((char *)v3 + 23) < 0) {
    uint64_t v4 = v3[1];
  }
  else {
    uint64_t v4 = *((unsigned __int8 *)v3 + 23);
  }
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0xF) == 0) {
    goto LABEL_13;
  }
  if (v5)
  {
    uint64_t v7 = sub_1DD24D730(*(void *)(a1 + 24));
    v4 += v7 + ((9 * (__clz(v7 | 1) ^ 0x1F) + 73) >> 6) + 1;
    int v5 = *(_DWORD *)(a1 + 16);
    if ((v5 & 2) == 0)
    {
LABEL_10:
      if ((v5 & 4) == 0) {
        goto LABEL_11;
      }
LABEL_16:
      v4 += ((9 * (__clz(*(void *)(a1 + 40) | 1) ^ 0x3F) + 73) >> 6) + 1;
      if ((v5 & 8) == 0) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_10;
  }
  uint64_t v8 = sub_1DD24C5D4(*(void *)(a1 + 32));
  v4 += v8 + ((9 * (__clz(v8 | 1) ^ 0x1F) + 73) >> 6) + 1;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 4) != 0) {
    goto LABEL_16;
  }
LABEL_11:
  if ((v5 & 8) != 0) {
LABEL_12:
  }
    v4 += ((9 * (__clz(*(void *)(a1 + 48) | 1) ^ 0x3F) + 73) >> 6) + 1;
LABEL_13:
  *(_DWORD *)(a1 + 20) = v4;
  return v4;
}

std::string *sub_1DD24E258(std::string *result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    uint64_t result = sub_1DD24FBB0(&result->__r_.__value_.__l.__size_, v4 & 0xFFFFFFFFFFFFFFFELL);
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if ((v5 & 0xF) != 0)
  {
    if (v5)
    {
      LODWORD(v3->__r_.__value_.__r.__words[2]) |= 1u;
      data = v3[1].__r_.__value_.__l.__data_;
      if (!data)
      {
        data = sub_1DD24F424(0);
        v3[1].__r_.__value_.__r.__words[0] = (std::string::size_type)data;
      }
      if (*(void *)(a2 + 24)) {
        uint64_t v7 = *(void **)(a2 + 24);
      }
      else {
        uint64_t v7 = &unk_1EAB1F220;
      }
      uint64_t result = (std::string *)sub_1DD24D920(data, (uint64_t)v7);
      if ((v5 & 2) == 0)
      {
LABEL_6:
        if ((v5 & 4) == 0) {
          goto LABEL_7;
        }
        goto LABEL_23;
      }
    }
    else if ((v5 & 2) == 0)
    {
      goto LABEL_6;
    }
    LODWORD(v3->__r_.__value_.__r.__words[2]) |= 2u;
    std::string::size_type size = (std::string *)v3[1].__r_.__value_.__l.__size_;
    if (!size)
    {
      std::string::size_type size = (std::string *)sub_1DD24F390(0);
      v3[1].__r_.__value_.__l.__size_ = (std::string::size_type)size;
    }
    if (*(void *)(a2 + 32)) {
      unint64_t v9 = *(void **)(a2 + 32);
    }
    else {
      unint64_t v9 = &unk_1EAB1F068;
    }
    uint64_t result = sub_1DD24C8B0(size, (uint64_t)v9);
    if ((v5 & 4) == 0)
    {
LABEL_7:
      if ((v5 & 8) == 0)
      {
LABEL_9:
        LODWORD(v3->__r_.__value_.__r.__words[2]) |= v5;
        return result;
      }
LABEL_8:
      v3[2].__r_.__value_.__r.__words[0] = *(void *)(a2 + 48);
      goto LABEL_9;
    }
LABEL_23:
    v3[1].__r_.__value_.__r.__words[2] = *(void *)(a2 + 40);
    if ((v5 & 8) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  return result;
}

uint64_t sub_1DD24E348()
{
  return 1;
}

void *sub_1DD24E350@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "orc.proto.FileTail");
}

void *sub_1DD24E360(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C78, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250A04);
    sub_1DD23B5D0(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD23B5D0(v2);
  }
  return v2;
}

void sub_1DD24E3E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E3F4(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878BE8, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250A28);
    sub_1DD23BC50(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD23BC50(v2);
  }
  return v2;
}

void sub_1DD24E474(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E488(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C00, 64);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x40uLL, (uint64_t)sub_1DD250A4C);
    sub_1DD23C25C(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x40uLL);
    sub_1DD23C25C(v2);
  }
  return v2;
}

void sub_1DD24E508(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E51C(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878BB8, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250A70);
    sub_1DD23CDA0((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD23CDA0((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24E59C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E5B0(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C48, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250A94);
    sub_1DD23D6F8(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD23D6F8(v2);
  }
  return v2;
}

void sub_1DD24E630(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E644(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B70, 32);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x20uLL, (uint64_t)sub_1DD250AB8);
    sub_1DD23E00C(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x20uLL);
    sub_1DD23E00C(v2);
  }
  return v2;
}

void sub_1DD24E6C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E6D8(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878CA8, 64);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x40uLL, (uint64_t)sub_1DD250ADC);
    sub_1DD23E5C4((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x40uLL);
    sub_1DD23E5C4((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24E758(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E76C(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B88, 32);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x20uLL, (uint64_t)sub_1DD250B00);
    sub_1DD23EEAC(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x20uLL);
    sub_1DD23EEAC(v2);
  }
  return v2;
}

void sub_1DD24E7EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E800(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878CC0, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250B24);
    sub_1DD23F370(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD23F370(v2);
  }
  return v2;
}

void sub_1DD24E880(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E894(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878BD0, 120);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x78uLL, (uint64_t)sub_1DD250B48);
    sub_1DD23F948((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x78uLL);
    sub_1DD23F948((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24E914(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E928(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B40, 56);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x38uLL, (uint64_t)sub_1DD250B6C);
    sub_1DD241014((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x38uLL);
    sub_1DD241014((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24E9A8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24E9BC(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D80, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250B90);
    sub_1DD2418D8((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD2418D8((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EA3C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EA50(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878AF8, 56);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x38uLL, (uint64_t)sub_1DD250BB4);
    sub_1DD241F1C((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x38uLL);
    sub_1DD241F1C((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EAD0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EAE4(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878BA0, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250BD8);
    sub_1DD242920((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD242920((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EB64(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EB78(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D20, 40);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x28uLL, (uint64_t)sub_1DD250BFC);
    sub_1DD242F18(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x28uLL);
    sub_1DD242F18(v2);
  }
  return v2;
}

void sub_1DD24EBF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EC0C(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B58, 40);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x28uLL, (uint64_t)sub_1DD250C20);
    sub_1DD243758((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x28uLL);
    sub_1DD243758((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EC8C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24ECA0(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878CD8, 72);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x48uLL, (uint64_t)sub_1DD250C44);
    sub_1DD243FAC((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x48uLL);
    sub_1DD243FAC((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24ED20(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24ED34(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B10, 104);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x68uLL, (uint64_t)sub_1DD250C68);
    sub_1DD2447D0((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x68uLL);
    sub_1DD2447D0((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EDB4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EDC8(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878AE0, 40);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x28uLL, (uint64_t)sub_1DD250C8C);
    sub_1DD24556C(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x28uLL);
    sub_1DD24556C(v2);
  }
  return v2;
}

void sub_1DD24EE48(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EE5C(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878CF0, 112);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x70uLL, (uint64_t)sub_1DD250CB0);
    sub_1DD245C2C((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x70uLL);
    sub_1DD245C2C((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EEDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EEF0(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C90, 96);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x60uLL, (uint64_t)sub_1DD250CD4);
    sub_1DD246D44((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x60uLL);
    sub_1DD246D44((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24EF70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24EF84(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C30, 40);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x28uLL, (uint64_t)sub_1DD250CF8);
    sub_1DD2478E4(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x28uLL);
    sub_1DD2478E4(v2);
  }
  return v2;
}

void sub_1DD24F004(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F018(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C18, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250D1C);
    sub_1DD247E04((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD247E04((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F098(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F0AC(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D68, 48);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x30uLL, (uint64_t)sub_1DD250D40);
    sub_1DD2483F8((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x30uLL);
    sub_1DD2483F8((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F12C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F140(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D38, 80);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x50uLL, (uint64_t)sub_1DD250D64);
    sub_1DD2489F0((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x50uLL);
    sub_1DD2489F0((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F1C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F1D4(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878B28, 40);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x28uLL, (uint64_t)sub_1DD250D88);
    sub_1DD2494DC(v2);
  }
  else
  {
    uint64_t v2 = operator new(0x28uLL);
    sub_1DD2494DC(v2);
  }
  return v2;
}

void sub_1DD24F254(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F268(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878C60, 72);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x48uLL, (uint64_t)sub_1DD250DAC);
    sub_1DD249C74((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x48uLL);
    sub_1DD249C74((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F2E8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F2FC(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878AB0, 104);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x68uLL, (uint64_t)sub_1DD250DD0);
    sub_1DD24A720((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x68uLL);
    sub_1DD24A720((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F37C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F390(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D08, 168);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0xA8uLL, (uint64_t)sub_1DD250DF4);
    sub_1DD24B550((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0xA8uLL);
    sub_1DD24B550((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F410(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F424(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878AC8, 96);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x60uLL, (uint64_t)sub_1DD250E18);
    sub_1DD24CBA0((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x60uLL);
    sub_1DD24CBA0((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F4A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F4B8(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 112)) {
      sub_1DD2F5330(a1, (uint64_t)&unk_1F3878D50, 56);
    }
    uint64_t v2 = sub_1DD2F4FD8(a1, 0x38uLL, (uint64_t)sub_1DD250E3C);
    sub_1DD24DACC((uint64_t)v2);
  }
  else
  {
    uint64_t v2 = operator new(0x38uLL);
    sub_1DD24DACC((uint64_t)v2);
  }
  return v2;
}

void sub_1DD24F538(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F54C()
{
  return sub_1DD24E360(0);
}

void *sub_1DD24F554(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E360(a2);
}

uint64_t sub_1DD24F55C()
{
  return 0;
}

uint64_t sub_1DD24F564(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 40))();
}

uint64_t sub_1DD24F588(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

void *sub_1DD24F590()
{
  return sub_1DD24E3F4(0);
}

void *sub_1DD24F598(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E3F4(a2);
}

void *sub_1DD24F5A0()
{
  return sub_1DD24E488(0);
}

void *sub_1DD24F5A8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E488(a2);
}

void *sub_1DD24F5B0()
{
  return sub_1DD24E51C(0);
}

void *sub_1DD24F5B8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E51C(a2);
}

void *sub_1DD24F5C0()
{
  return sub_1DD24E5B0(0);
}

void *sub_1DD24F5C8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E5B0(a2);
}

void *sub_1DD24F5D0()
{
  return sub_1DD24E644(0);
}

void *sub_1DD24F5D8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E644(a2);
}

void *sub_1DD24F5E0()
{
  return sub_1DD24E6D8(0);
}

void *sub_1DD24F5E8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E6D8(a2);
}

void *sub_1DD24F5F0()
{
  return sub_1DD24E76C(0);
}

void *sub_1DD24F5F8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E76C(a2);
}

void *sub_1DD24F600()
{
  return sub_1DD24E800(0);
}

void *sub_1DD24F608(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E800(a2);
}

void *sub_1DD24F610()
{
  return sub_1DD24E894(0);
}

void *sub_1DD24F618(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E894(a2);
}

void *sub_1DD24F620()
{
  return sub_1DD24E928(0);
}

void *sub_1DD24F628(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E928(a2);
}

void *sub_1DD24F630()
{
  return sub_1DD24E9BC(0);
}

void *sub_1DD24F638(uint64_t a1, uint64_t a2)
{
  return sub_1DD24E9BC(a2);
}

void *sub_1DD24F640()
{
  return sub_1DD24EA50(0);
}

void *sub_1DD24F648(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EA50(a2);
}

void *sub_1DD24F650()
{
  return sub_1DD24EAE4(0);
}

void *sub_1DD24F658(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EAE4(a2);
}

void *sub_1DD24F660()
{
  return sub_1DD24EB78(0);
}

void *sub_1DD24F668(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EB78(a2);
}

void *sub_1DD24F670()
{
  return sub_1DD24EC0C(0);
}

void *sub_1DD24F678(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EC0C(a2);
}

void *sub_1DD24F680()
{
  return sub_1DD24ECA0(0);
}

void *sub_1DD24F688(uint64_t a1, uint64_t a2)
{
  return sub_1DD24ECA0(a2);
}

void *sub_1DD24F690()
{
  return sub_1DD24ED34(0);
}

void *sub_1DD24F698(uint64_t a1, uint64_t a2)
{
  return sub_1DD24ED34(a2);
}

void *sub_1DD24F6A0()
{
  return sub_1DD24EDC8(0);
}

void *sub_1DD24F6A8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EDC8(a2);
}

void *sub_1DD24F6B0()
{
  return sub_1DD24EE5C(0);
}

void *sub_1DD24F6B8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EE5C(a2);
}

void *sub_1DD24F6C0()
{
  return sub_1DD24EEF0(0);
}

void *sub_1DD24F6C8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EEF0(a2);
}

void *sub_1DD24F6D0()
{
  return sub_1DD24EF84(0);
}

void *sub_1DD24F6D8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24EF84(a2);
}

void *sub_1DD24F6E0()
{
  return sub_1DD24F018(0);
}

void *sub_1DD24F6E8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F018(a2);
}

void *sub_1DD24F6F0()
{
  return sub_1DD24F0AC(0);
}

void *sub_1DD24F6F8(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F0AC(a2);
}

void *sub_1DD24F700()
{
  return sub_1DD24F140(0);
}

void *sub_1DD24F708(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F140(a2);
}

void *sub_1DD24F710()
{
  return sub_1DD24F1D4(0);
}

void *sub_1DD24F718(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F1D4(a2);
}

void *sub_1DD24F720()
{
  return sub_1DD24F268(0);
}

void *sub_1DD24F728(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F268(a2);
}

void *sub_1DD24F730()
{
  return sub_1DD24F2FC(0);
}

void *sub_1DD24F738(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F2FC(a2);
}

void *sub_1DD24F740()
{
  return sub_1DD24F390(0);
}

void *sub_1DD24F748(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F390(a2);
}

void *sub_1DD24F750()
{
  return sub_1DD24F424(0);
}

void *sub_1DD24F758(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F424(a2);
}

void *sub_1DD24F760()
{
  return sub_1DD24F4B8(0);
}

void *sub_1DD24F768(uint64_t a1, uint64_t a2)
{
  return sub_1DD24F4B8(a2);
}

uint64_t *sub_1DD24F770(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    unint64_t v3 = v2 & 0xFFFFFFFFFFFFFFFELL;
    if (!*(void *)((v2 & 0xFFFFFFFFFFFFFFFELL) + 24) && v3 != 0)
    {
      if (*(char *)(v3 + 23) < 0) {
        operator delete(*(void **)v3);
      }
      operator delete((void *)v3);
    }
  }
  *a1 = 0;
  return a1;
}

double sub_1DD24F7CC(unint64_t *a1)
{
  unint64_t v2 = *a1 & 0xFFFFFFFFFFFFFFFELL;
  if (*a1)
  {
    unint64_t v2 = *(void *)(v2 + 24);
    if (v2) {
      goto LABEL_3;
    }
LABEL_7:
    unint64_t v3 = (unint64_t)operator new(0x20uLL);
    goto LABEL_8;
  }
  if (!v2) {
    goto LABEL_7;
  }
LABEL_3:
  if (*(void *)(v2 + 112)) {
    sub_1DD2F5330(v2, (uint64_t)&unk_1F3878E68, 32);
  }
  unint64_t v3 = (unint64_t)sub_1DD2F4FD8(v2, 0x20uLL, (uint64_t)sub_1DD24F860);
LABEL_8:
  double result = 0.0;
  *(_OWORD *)unint64_t v3 = 0u;
  *(_OWORD *)(v3 + 16) = 0u;
  *a1 = v3 | 1;
  *(void *)(v3 + 24) = v2;
  return result;
}

void sub_1DD24F860(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t **sub_1DD24F874(uint64_t **a1)
{
  LODWORD(v2) = *((char *)a1 + 31);
  if ((v2 & 0x80000000) != 0) {
    unint64_t v3 = a1[2];
  }
  else {
    unint64_t v3 = (uint64_t *)*((unsigned __int8 *)a1 + 31);
  }
  uint64_t v4 = (void **)(a1 + 1);
  if (v3)
  {
    int v5 = (unint64_t *)*a1;
    uint64_t v6 = **a1;
    if (v6) {
      unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFFELL;
    }
    else {
      sub_1DD24F7CC(v5);
    }
    unint64_t v2 = *(uint64_t **)(v7 + 16);
    long long v8 = *(_OWORD *)v7;
    unint64_t v9 = a1[3];
    *(_OWORD *)unint64_t v7 = *(_OWORD *)v4;
    *(void *)(v7 + 16) = v9;
    *(_OWORD *)uint64_t v4 = v8;
    a1[3] = v2;
    LOBYTE(v2) = *((unsigned char *)a1 + 31);
  }
  if ((v2 & 0x80) != 0) {
    operator delete(*v4);
  }
  return a1;
}

void *sub_1DD24F908(void *a1, uint64_t a2)
{
  double result = operator new(0x18uLL);
  int v5 = result;
  if (*(char *)(a2 + 23) < 0)
  {
    double result = sub_1DD24F980(result, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)double result = *(_OWORD *)a2;
    result[2] = *(void *)(a2 + 16);
  }
  *a1 = v5;
  return result;
}

void sub_1DD24F96C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD24F980(unsigned char *__dst, void *__src, unint64_t a3)
{
  int v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_1DD239EFC();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    long long v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *int v5 = v8;
    int v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

void sub_1DD24FA20(unsigned int *a1, int a2)
{
  int v2 = a1[1];
  if (v2 < a2)
  {
    if (v2 < 1)
    {
      int v5 = (uint64_t **)(a1 + 2);
      uint64_t v4 = 0;
      if (v2) {
        uint64_t v6 = *v5;
      }
      else {
        uint64_t v6 = (uint64_t *)(a1 + 2);
      }
    }
    else
    {
      int v5 = (uint64_t **)(a1 + 2);
      uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
      uint64_t v6 = v4;
    }
    uint64_t v7 = *v6;
    int v8 = 2 * v2;
    if (v8 <= a2) {
      int v8 = a2;
    }
    if (v8 <= 4) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = v8;
    }
    uint64_t v10 = 8 * v9;
    if (v7)
    {
      uint64_t v11 = (v10 + 15) & 0x7FFFFFFF8;
      if (*(void *)(v7 + 112)) {
        sub_1DD2F5330(v7, MEMORY[0x1E4FBA380], v11);
      }
      uint64_t v12 = sub_1DD2F4EC0(v7, v11);
    }
    else
    {
      uint64_t v12 = operator new(v10 + 8);
    }
    *((void *)a1 + 1) = v12;
    void *v12 = v7;
    a1[1] = v9;
    uint64_t v13 = *a1;
    if ((int)v13 >= 1) {
      memcpy(*v5 + 1, v4 + 1, 8 * v13);
    }
    if (v4 && !*v4)
    {
      operator delete(v4);
    }
  }
}

void sub_1DD24FB50(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
}

uint64_t sub_1DD24FB64(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 8);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = *(void *)(result + 16) + 8;
    do
    {
      uint64_t v3 = *(void *)v2;
      if (*(char *)(*(void *)v2 + 23) < 0)
      {
        **(unsigned char **)uint64_t v3 = 0;
        *(void *)(v3 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v3 = 0;
        *(unsigned char *)(v3 + 23) = 0;
      }
      v2 += 8;
      --v1;
    }
    while (v1);
    *(_DWORD *)(result + 8) = 0;
  }
  return result;
}

std::string *sub_1DD24FBB0(unint64_t *a1, uint64_t a2)
{
  if (*a1) {
    uint64_t v3 = (std::string *)(*a1 & 0xFFFFFFFFFFFFFFFELL);
  }
  else {
    sub_1DD24F7CC(a1);
  }
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    int v5 = (const std::string::value_type *)a2;
  }
  else {
    int v5 = *(const std::string::value_type **)a2;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a2 + 8);
  }
  return std::string::append(v3, v5, v6);
}

void sub_1DD24FC0C(unint64_t *a1)
{
  if (*a1) {
    unint64_t v1 = *a1 & 0xFFFFFFFFFFFFFFFELL;
  }
  else {
    sub_1DD24F7CC(a1);
  }
  if (*(char *)(v1 + 23) < 0)
  {
    **(unsigned char **)unint64_t v1 = 0;
    *(void *)(v1 + 8) = 0;
  }
  else
  {
    *(unsigned char *)unint64_t v1 = 0;
    *(unsigned char *)(v1 + 23) = 0;
  }
}

void sub_1DD24FC54(void *a1)
{
  uint64_t v2 = (unsigned int *)a1[2];
  if (v2 && !*a1)
  {
    uint64_t v3 = v2 + 2;
    uint64_t v4 = *v2;
    if ((int)v4 >= 1)
    {
      do
      {
        if (*v3) {
          (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
        }
        ++v3;
        --v4;
      }
      while (v4);
      uint64_t v2 = (unsigned int *)a1[2];
    }
    operator delete(v2);
  }
  a1[2] = 0;
}

std::string *sub_1DD24FCE0(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD24FD90(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24E928(v18);
      double result = sub_1DD24FD90(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD24FD90(uint64_t a1, std::string *a2)
{
  return sub_1DD241790(a2, a1);
}

uint64_t *sub_1DD24FDA0(uint64_t *result, void **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD24FE50(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = sub_1DD24EA50(v18);
      double result = sub_1DD24FE50(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

void *sub_1DD24FE50(uint64_t a1, void *a2)
{
  return sub_1DD242810(a2, a1);
}

std::string *sub_1DD24FE60(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD24FF10(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24EB78(v18);
      double result = sub_1DD24FF10(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD24FF10(uint64_t a1, std::string *a2)
{
  return sub_1DD2435A8(a2, a1);
}

std::string *sub_1DD24FF20(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD24FFD0(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24EC0C(v18);
      double result = sub_1DD24FFD0(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD24FFD0(uint64_t a1, std::string *a2)
{
  return sub_1DD243DFC(a2, a1);
}

std::string *sub_1DD24FFE0(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250090(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24ECA0(v18);
      double result = sub_1DD250090(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250090(uint64_t a1, std::string *a2)
{
  return sub_1DD2446A8(a2, a1);
}

void sub_1DD2500A0(void *a1)
{
  uint64_t v2 = (unsigned int *)a1[2];
  if (v2 && !*a1)
  {
    uint64_t v3 = (uint64_t *)(v2 + 2);
    uint64_t v4 = *v2;
    if ((int)v4 >= 1)
    {
      do
      {
        uint64_t v5 = *v3;
        if (*v3)
        {
          if (*(char *)(v5 + 23) < 0) {
            operator delete(*(void **)v5);
          }
          operator delete((void *)v5);
        }
        ++v3;
        --v4;
      }
      while (v4);
      uint64_t v2 = (unsigned int *)a1[2];
    }
    operator delete(v2);
  }
  a1[2] = 0;
}

void sub_1DD250120(unsigned int *a1, int a2)
{
  int v2 = a1[1];
  if (v2 < a2)
  {
    if (v2 < 1)
    {
      uint64_t v5 = (uint64_t **)(a1 + 2);
      uint64_t v4 = 0;
      if (v2) {
        std::string::size_type v6 = *v5;
      }
      else {
        std::string::size_type v6 = (uint64_t *)(a1 + 2);
      }
    }
    else
    {
      uint64_t v5 = (uint64_t **)(a1 + 2);
      uint64_t v4 = (uint64_t *)*((void *)a1 + 1);
      std::string::size_type v6 = v4;
    }
    uint64_t v7 = *v6;
    int v8 = 2 * v2;
    if (v8 <= a2) {
      int v8 = a2;
    }
    if (v8 <= 4) {
      unsigned int v9 = 4;
    }
    else {
      unsigned int v9 = v8;
    }
    uint64_t v10 = 4 * v9;
    if (v7)
    {
      uint64_t v11 = (v10 + 15) & 0x3FFFFFFF8;
      if (*(void *)(v7 + 112)) {
        sub_1DD2F5330(v7, MEMORY[0x1E4FBA380], v11);
      }
      uint64_t v12 = sub_1DD2F4EC0(v7, v11);
    }
    else
    {
      uint64_t v12 = operator new(v10 + 8);
    }
    *((void *)a1 + 1) = v12;
    void *v12 = v7;
    a1[1] = v9;
    uint64_t v13 = *a1;
    if ((int)v13 >= 1) {
      memcpy(*v5 + 1, v4 + 1, 4 * v13);
    }
    if (v4 && !*v4)
    {
      operator delete(v4);
    }
  }
}

std::string *sub_1DD250250(std::string *result, std::string **a2, const std::string **a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = std::string::operator=(v15, v13);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19;
      if (v18)
      {
        if (*(void *)(v18 + 112)) {
          sub_1DD2F5330(v18, (uint64_t)&unk_1F3878F18, 24);
        }
        char v22 = (std::string *)sub_1DD2F4FD8(v18, 0x18uLL, (uint64_t)sub_1DD24FB50);
      }
      else
      {
        char v22 = (std::string *)operator new(0x18uLL);
      }
      unint64_t v23 = v22;
      v22->__r_.__value_.__r.__words[0] = 0;
      v22->__r_.__value_.__l.__size_ = 0;
      v22->__r_.__value_.__r.__words[2] = 0;
      double result = std::string::operator=(v22, v21);
      *v20++ = v23;
      ++v19;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250354(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250404(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24EDC8(v18);
      double result = sub_1DD250404(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250404(uint64_t a1, std::string *a2)
{
  return sub_1DD245B10(a2, a1);
}

std::string *sub_1DD250414(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD2504C4(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24E894(v18);
      double result = sub_1DD2504C4(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD2504C4(uint64_t a1, std::string *a2)
{
  return sub_1DD240BA8(a2, a1);
}

std::string *sub_1DD2504D4(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250584(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24F018(v18);
      double result = sub_1DD250584(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250584(uint64_t a1, std::string *a2)
{
  return sub_1DD24833C(a2, a1);
}

std::string *sub_1DD250594(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250644(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24F140(v18);
      double result = sub_1DD250644(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250644(uint64_t a1, std::string *a2)
{
  return sub_1DD24934C(a2, a1);
}

std::string *sub_1DD250654(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250704(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24F1D4(v18);
      double result = sub_1DD250704(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250704(uint64_t a1, std::string *a2)
{
  return sub_1DD249BA4(a2, a1);
}

std::string *sub_1DD250714(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD2507C4(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24F268(v18);
      double result = sub_1DD2507C4(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD2507C4(uint64_t a1, std::string *a2)
{
  return sub_1DD24A5A0(a2, a1);
}

std::string *sub_1DD2507D4(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250884(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24EEF0(v18);
      double result = sub_1DD250884(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

std::string *sub_1DD250884(uint64_t a1, std::string *a2)
{
  return sub_1DD24775C(a2, a1);
}

unint64_t *sub_1DD250894(unint64_t *result, unint64_t **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250944(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (unint64_t *)sub_1DD24EE5C(v18);
      double result = sub_1DD250944(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

unint64_t *sub_1DD250944(uint64_t a1, unint64_t *a2)
{
  return sub_1DD246B2C(a2, a1);
}

std::string *sub_1DD250954(std::string *result, std::string **a2, uint64_t *a3, unsigned int a4, unsigned int a5)
{
  unsigned int v9 = (uint64_t *)result;
  if ((int)a5 >= (int)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  if ((int)v10 >= 1)
  {
    uint64_t v11 = a3;
    uint64_t v12 = a2;
    do
    {
      uint64_t v14 = *v11++;
      uint64_t v13 = v14;
      int v15 = *v12++;
      double result = sub_1DD250404(v13, v15);
      --v10;
    }
    while (v10);
  }
  BOOL v16 = __OFSUB__(a4, a5);
  int v17 = a4 - a5;
  if (!((v17 < 0) ^ v16 | (v17 == 0)))
  {
    uint64_t v18 = *v9;
    int v19 = &a3[a5];
    BOOL v20 = &a2[a5];
    do
    {
      uint64_t v21 = *v19++;
      char v22 = (std::string *)sub_1DD24EF84(v18);
      double result = sub_1DD250404(v21, v22);
      *v20++ = v22;
      --v17;
    }
    while (v17);
  }
  return result;
}

uint64_t sub_1DD250A04(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250A28(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250A4C(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250A70(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250A94(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250AB8(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250ADC(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250B00(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250B24(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250B48(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250B6C(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250B90(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250BB4(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250BD8(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250BFC(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250C20(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250C44(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250C68(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250C8C(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250CB0(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250CD4(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250CF8(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250D1C(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250D40(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250D64(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250D88(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250DAC(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250DD0(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250DF4(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250E18(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

uint64_t sub_1DD250E3C(uint64_t (***a1)(void))
{
  return (**a1)(a1);
}

void *sub_1DD250E68(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = 0;
  sub_1DD250ED8((uint64_t)a1, vcvtpd_u64_f64((double)a2 * 0.015625), &v4);
  return a1;
}

void sub_1DD250EBC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD250ED8(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_1DD251C88((void **)a1, a2 - v3, a3);
  }
}

uint64_t sub_1DD250F08(uint64_t a1, const void *a2, unint64_t a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v7 = 0;
  sub_1DD250ED8(a1, a3 >> 6, &v7);
  memcpy(*(void **)a1, a2, a3 >> 3);
  return a1;
}

void sub_1DD250F6C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD250F88(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA488] + 104;
  *(void *)(a1 + 128) = MEMORY[0x1E4FBA488] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  *(void *)(a1 + 16) = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  int v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x1E4FBA488] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_1DD251238(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1E01B1EC0](v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD251260(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA408];
  uint64_t v3 = *MEMORY[0x1E4FBA408];
  *(void *)a1 = *MEMORY[0x1E4FBA408];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1E01B1EC0](a1 + 128);
  return a1;
}

uint64_t sub_1DD251398(uint64_t result, const std::string *a2)
{
  if ((result & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, a2);
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  return result;
}

void sub_1DD2513F0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD251404(uint64_t a1, unint64_t a2, long double a3)
{
  *(void *)a1 = &unk_1F3879838;
  *(void *)(a1 + 24) = 0;
  uint64_t v6 = (void ***)(a1 + 24);
  sub_1DD314888(&__p, "expectedEntries should be > 0");
  sub_1DD251398(a2 != 0, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_1DD314888(&__p, "False positive probability should be > 0.0 & < 1.0");
  uint64_t v7 = a3 < 1.0 && a3 > 0.0;
  sub_1DD251398(v7, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  double v8 = (double)a2;
  unint64_t v9 = (int)((int)(log(a3) * (double)a2 / -0.480453014) & 0xFFFFFFC0) + 64;
  *(void *)(a1 + 8) = v9;
  int v10 = llround((double)v9 / v8 * 0.693147181);
  if (v10 <= 1) {
    int v10 = 1;
  }
  *(_DWORD *)(a1 + 16) = v10;
  uint64_t v11 = (void **)operator new(0x18uLL);
  sub_1DD250E68(v11, v9);
  uint64_t v12 = *v6;
  uint64_t *v6 = v11;
  if (v12) {
    sub_1DD251DFC((int)v6, v12);
  }
  return a1;
}

void sub_1DD251554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  operator delete(v16);
  uint64_t v18 = *v15;
  *int v15 = 0;
  if (v18) {
    sub_1DD251DFC((int)v15, v18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2515A8(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  if (a2) {
    unint64_t v4 = sub_1DD270570(a2, a3);
  }
  else {
    unint64_t v4 = 0x27BB2EE687B0B0FDLL;
  }
  return sub_1DD251604(a1, v4);
}

uint64_t sub_1DD251604(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(result + 16);
  if (v2 >= 1)
  {
    uint64_t v3 = **(void **)(result + 24);
    int v4 = a2 + HIDWORD(a2);
    do
    {
      unint64_t v5 = (unint64_t)(v4 ^ (v4 >> 31)) % *(void *)(result + 8);
      *(void *)(v3 + ((v5 >> 3) & 0x1FFFFFF8)) |= 1 << v5;
      v4 += HIDWORD(a2);
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_1DD25165C(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 265 * ((~a2 + (a2 << 21)) ^ ((unint64_t)(~a2 + (a2 << 21)) >> 24));
  return sub_1DD251604(a1, 2147483649u * ((21 * (v2 ^ (v2 >> 14))) ^ ((21 * (v2 ^ (v2 >> 14))) >> 28)));
}

BOOL sub_1DD251688(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  if (a2) {
    unint64_t v4 = sub_1DD270570(a2, a3);
  }
  else {
    unint64_t v4 = 0x27BB2EE687B0B0FDLL;
  }
  return sub_1DD2516E4(a1, v4);
}

BOOL sub_1DD2516E4(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if (v2 < 1) {
    return 1;
  }
  unint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = **(void **)(a1 + 24);
  unint64_t v5 = ((HIDWORD(a2) + a2) ^ ((HIDWORD(a2) + (int)a2) >> 31)) % v3;
  if (((*(void *)(v4 + ((v5 >> 3) & 0x1FFFFFF8)) >> v5) & 1) == 0) {
    return 0;
  }
  int v6 = a2 + 2 * HIDWORD(a2);
  int v7 = 1;
  do
  {
    int v8 = v7;
    if (v2 == v7) {
      break;
    }
    ++v7;
    unint64_t v9 = (v6 ^ (v6 >> 31)) % v3;
    v6 += HIDWORD(a2);
  }
  while (((*(void *)(v4 + ((v9 >> 3) & 0x1FFFFFF8)) >> v9) & 1) != 0);
  return v8 >= v2;
}

BOOL sub_1DD25177C(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = 265 * ((~a2 + (a2 << 21)) ^ ((unint64_t)(~a2 + (a2 << 21)) >> 24));
  return sub_1DD2516E4(a1, 2147483649u * ((21 * (v2 ^ (v2 >> 14))) ^ ((21 * (v2 ^ (v2 >> 14))) >> 28)));
}

uint64_t sub_1DD2517A8(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1F3879838;
  *(void *)(a1 + 24) = 0;
  unint64_t v3 = (void ***)(a1 + 24);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 48);
  uint64_t v4 = *(void **)(a2 + 40);
  if (*((char *)v4 + 23) < 0) {
    uint64_t v5 = v4[1];
  }
  else {
    uint64_t v5 = *((unsigned __int8 *)v4 + 23);
  }
  *(void *)(a1 + 8) = 8 * v5;
  sub_1DD314888(&__p, "numBits should be multiple of 64!");
  sub_1DD251398((v5 & 7) == 0, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (*((char *)v4 + 23) < 0) {
    uint64_t v4 = (void *)*v4;
  }
  int v6 = (void **)operator new(0x18uLL);
  sub_1DD250F08((uint64_t)v6, v4, *(void *)(a1 + 8));
  int v7 = *v3;
  void *v3 = v6;
  if (v7) {
    sub_1DD251DFC((int)v3, v7);
  }
  return a1;
}

void sub_1DD251890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  operator delete(v16);
  uint64_t v18 = *v15;
  *int v15 = 0;
  if (v18) {
    sub_1DD251DFC((int)v15, v18);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2518D8(uint64_t a1, double a2)
{
  unint64_t v2 = 265 * ((~*(void *)&a2 + (*(void *)&a2 << 21)) ^ ((~*(void *)&a2 + (*(void *)&a2 << 21)) >> 24));
  return sub_1DD251604(a1, 2147483649u * ((21 * (v2 ^ (v2 >> 14))) ^ ((21 * (v2 ^ (v2 >> 14))) >> 28)));
}

uint64_t sub_1DD251908(uint64_t a1, double a2)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 24))(a1, *(void *)&a2);
}

void sub_1DD251930(uint64_t a1)
{
}

void sub_1DD251940(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a2 + 48) = *(_DWORD *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void **)v3;
  size_t v5 = (*(void *)(v3 + 8) - *(void *)v3) & 0x1FFFFFFFFFFFFFFFLL;
  *(_DWORD *)(a2 + 16) = v2 | 3;
  int v6 = (__n128 **)(a2 + 40);
  sub_1DD251BA8(&__p, v4, v5);
  sub_1DD251B20(v6, (__n128 *)&qword_1EAB1F7D8, &__p);
  if (v8 < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
}

void sub_1DD2519BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

_DWORD *sub_1DD2519D8@<X0>(_DWORD *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  if (*result == 8 && (*(unsigned char *)(a2 + 16) & 4) != 0 && *(_DWORD *)(a2 + 32) == 1 && (~*(_DWORD *)(a3 + 16) & 3) == 0)
  {
    int v6 = operator new(0x20uLL);
    double result = (_DWORD *)sub_1DD2517A8((uint64_t)v6, a3);
    *a4 = v6;
  }
  return result;
}

void sub_1DD251A50(_Unwind_Exception *a1)
{
  operator delete(v2);
  *uint64_t v1 = 0;
  _Unwind_Resume(a1);
}

void *sub_1DD251A70(void *a1)
{
  *a1 = &unk_1F3879838;
  uint64_t v4 = (void **)a1[3];
  int v2 = a1 + 3;
  uint64_t v3 = v4;
  *int v2 = 0;
  if (v4) {
    sub_1DD251DFC((int)v2, v3);
  }
  return a1;
}

void sub_1DD251AC0(void *__p)
{
  *__n128 __p = &unk_1F3879838;
  uint64_t v4 = (void **)__p[3];
  int v2 = __p + 3;
  uint64_t v3 = v4;
  *int v2 = 0;
  if (v4) {
    sub_1DD251DFC((int)v2, v3);
  }
  operator delete(__p);
}

__n128 sub_1DD251B20(__n128 **a1, __n128 *a2, __n128 *a3)
{
  uint64_t v4 = *a1;
  if (*a1 == a2)
  {
    int v7 = (__n128 *)operator new(0x18uLL);
    __n128 result = *a3;
    __n128 *v7 = *a3;
    v7[1].n128_u64[0] = a3[1].n128_u64[0];
    a3->n128_u64[0] = 0;
    a3->n128_u64[1] = 0;
    a3[1].n128_u64[0] = 0;
    *a1 = v7;
  }
  else
  {
    if (v4[1].n128_i8[7] < 0) {
      operator delete((void *)v4->n128_u64[0]);
    }
    __n128 result = *a3;
    v4[1].n128_u64[0] = a3[1].n128_u64[0];
    *uint64_t v4 = result;
    a3[1].n128_u8[7] = 0;
    a3->n128_u8[0] = 0;
  }
  return result;
}

void *sub_1DD251BA8(void *__dst, void *__src, size_t __len)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DD239EFC();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    int v6 = operator new(v7 + 1);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    *long long __dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    int v6 = __dst;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memmove(v6, __src, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void sub_1DD251C54()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void sub_1DD251C88(void **a1, unint64_t a2, void *a3)
{
  size_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  size_t v7 = v8;
  unint64_t v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      int v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      unint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      sub_1DD251DAC();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      int v15 = (char *)sub_1DD251DC4(v6, v14);
    }
    else {
      int v15 = 0;
    }
    uint64_t v18 = &v15[8 * v12];
    int v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    uint64_t v21 = v18;
    do
    {
      *(void *)uint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    char v22 = &v15[8 * v14];
    unint64_t v23 = (char *)*a1;
    for (uint64_t i = (char *)a1[1]; i != v23; i -= 8)
    {
      uint64_t v25 = *((void *)i - 1);
      *((void *)v18 - 1) = v25;
      v18 -= 8;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

void sub_1DD251DAC()
{
}

void *sub_1DD251DC4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1DD251C54();
  }
  return operator new(8 * a2);
}

void sub_1DD251DFC(int a1, void **__p)
{
  if (__p)
  {
    uint64_t v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

uint64_t sub_1DD251E48(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)a1 = &unk_1F387A0E8;
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = operator new[](0x80uLL);
  *(_DWORD *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 28) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  return a1;
}

void sub_1DD251EB8(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + 8) = 0;
  if (v2) {
    sub_1DD31CA44(v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD251ED4(void *a1)
{
  *a1 = &unk_1F387A0E8;
  uint64_t v2 = (void *)a1[2];
  if (v2) {
    operator delete[](v2);
  }
  uint64_t v3 = a1[1];
  a1[1] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1DD251F54(void *a1)
{
  uint64_t v1 = sub_1DD251ED4(a1);
  operator delete(v1);
}

uint64_t sub_1DD251F7C(uint64_t result, char a2)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 36);
  if (v4 == *(_DWORD *)(result + 40))
  {
    int v8 = 0;
    __n128 result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(result + 8) + 16))(*(void *)(result + 8), result + 48, &v8);
    if ((result & 1) == 0)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      size_t v7 = std::bad_alloc::bad_alloc(exception);
      __cxa_throw(v7, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
    }
    int v4 = 0;
    *(_DWORD *)(v3 + 40) = v8;
  }
  uint64_t v5 = *(void *)(v3 + 48);
  *(_DWORD *)(v3 + 36) = v4 + 1;
  *(unsigned char *)(v5 + v4) = a2;
  return result;
}

uint64_t sub_1DD252030(uint64_t result, unsigned __int8 *a2, uint64_t a3, unsigned char *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    int v8 = a4;
    do
    {
      if (!a4 || *v8) {
        __n128 result = sub_1DD2520A0(v7, *a2);
      }
      ++a2;
      ++v8;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t sub_1DD2520A0(uint64_t result, unsigned __int8 a2)
{
  uint64_t v2 = result;
  uint64_t v4 = *(int *)(result + 24);
  if (!v4)
  {
    uint64_t v7 = *(unsigned __int8 **)(result + 16);
    *(_DWORD *)(result + 24) = 1;
    unsigned __int8 *v7 = a2;
    *(_DWORD *)(result + 32) = 1;
    return result;
  }
  uint64_t v5 = *(unsigned __int8 **)(result + 16);
  if (!*(unsigned char *)(result + 28))
  {
    if (v5[v4 - 1] == a2)
    {
      int v8 = *(_DWORD *)(result + 32) + 1;
      *(_DWORD *)(result + 32) = v8;
      if (v8 == 3)
      {
        if (v4 != 2)
        {
          *(_DWORD *)(result + 24) = v4 - 2;
          __n128 result = sub_1DD2521D0(result);
          **(unsigned char **)(v2 + 16) = a2;
        }
        *(unsigned char *)(v2 + 28) = 1;
        *(_DWORD *)(v2 + 24) = 3;
        return result;
      }
    }
    else
    {
      *(_DWORD *)(result + 32) = 1;
    }
    *(_DWORD *)(result + 24) = v4 + 1;
    v5[v4] = a2;
    if (*(_DWORD *)(result + 24) != 128) {
      return result;
    }
LABEL_15:
    return sub_1DD2521D0(result);
  }
  if (*v5 != a2)
  {
    __n128 result = sub_1DD2521D0(result);
    uint64_t v9 = *(void *)(v2 + 16);
    uint64_t v10 = *(int *)(v2 + 24);
    *(_DWORD *)(v2 + 24) = v10 + 1;
    *(unsigned char *)(v9 + v10) = a2;
    *(_DWORD *)(v2 + 32) = 1;
    return result;
  }
  int v6 = v4 + 1;
  *(_DWORD *)(result + 24) = v6;
  if (v6 == 130) {
    goto LABEL_15;
  }
  return result;
}

uint64_t sub_1DD2521D0(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 24);
  if (v1)
  {
    uint64_t v2 = result;
    if (*(unsigned char *)(result + 28))
    {
      sub_1DD251F7C(result, v1 - 3);
      __n128 result = sub_1DD251F7C(v2, **(unsigned char **)(v2 + 16));
    }
    else
    {
      __n128 result = sub_1DD251F7C(result, -(char)v1);
      if (*(int *)(v2 + 24) >= 1)
      {
        uint64_t v3 = 0;
        do
          __n128 result = sub_1DD251F7C(v2, *(unsigned char *)(*(void *)(v2 + 16) + v3++));
        while (v3 < *(int *)(v2 + 24));
      }
    }
    *(unsigned char *)(v2 + 28) = 0;
    *(_DWORD *)(v2 + 32) = 0;
    *(_DWORD *)(v2 + 24) = 0;
  }
  return result;
}

uint64_t sub_1DD252270(uint64_t a1)
{
  sub_1DD2521D0(a1);
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), (*(_DWORD *)(a1 + 40) - *(_DWORD *)(a1 + 36)));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

uint64_t sub_1DD2522F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))();
}

uint64_t sub_1DD252318(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v5 = *(int *)(a1 + 36);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8))) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v4);
  }
  else {
    uint64_t v5 = v4 + v5 - *(int *)(a1 + 40);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v5);
  uint64_t v6 = *(int *)(a1 + 24);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16);
  return v7(a2, v6);
}

uint64_t sub_1DD252448@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x38uLL);
  uint64_t v5 = *a1;
  *a1 = 0;
  uint64_t v8 = v5;
  sub_1DD251E48((uint64_t)v4, &v8);
  *a2 = v4;
  uint64_t result = v8;
  if (v8)
  {
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)v8 + 8);
    return v7();
  }
  return result;
}

void sub_1DD2524EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CA44(a10);
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25250C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v5 = v3;
  sub_1DD251E48(a1, &v5);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *(void *)a1 = &unk_1F387A7D8;
  *(_DWORD *)(a1 + 56) = 8;
  *(unsigned char *)(a1 + 60) = 0;
  return a1;
}

void sub_1DD2525A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CA44(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD2525BC(void *a1)
{
  int v1 = sub_1DD251ED4(a1);
  operator delete(v1);
}

uint64_t sub_1DD2525E4(uint64_t result, unsigned char *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v4 = result;
  if (a3)
  {
    uint64_t v6 = a3;
    int v8 = *(_DWORD *)(result + 56);
    uint64_t v9 = a4;
    uint64_t v10 = a2;
    while (1)
    {
      if (v8)
      {
        if (!a4) {
          goto LABEL_8;
        }
      }
      else
      {
        uint64_t result = sub_1DD2520A0(v4, *(unsigned char *)(v4 + 60));
        *(unsigned char *)(v4 + 60) = 0;
        int v8 = 8;
        *(_DWORD *)(v4 + 56) = 8;
        if (!a4) {
          goto LABEL_8;
        }
      }
      if (*v9)
      {
LABEL_8:
        if (!a2 || *v10) {
          *(unsigned char *)(v4 + 60) |= 0x80u >> (8 - v8);
        }
        *(_DWORD *)(v4 + 56) = --v8;
      }
      ++v10;
      ++v9;
      if (!--v6)
      {
        if (v8) {
          return result;
        }
LABEL_16:
        uint64_t result = sub_1DD2520A0(v4, *(unsigned char *)(v4 + 60));
        *(unsigned char *)(v4 + 60) = 0;
        *(_DWORD *)(v4 + 56) = 8;
        return result;
      }
    }
  }
  if (!*(_DWORD *)(result + 56)) {
    goto LABEL_16;
  }
  return result;
}

uint64_t sub_1DD2526D0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 56) != 8) {
    sub_1DD2520A0(a1, *(unsigned char *)(a1 + 60));
  }
  *(_DWORD *)(a1 + 56) = 8;
  *(unsigned char *)(a1 + 60) = 0;
  return sub_1DD252270(a1);
}

uint64_t sub_1DD252728(uint64_t a1, uint64_t a2)
{
  sub_1DD252318(a1, a2);
  uint64_t v4 = 8 - *(int *)(a1 + 56);
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16);
  return v5(a2, v4);
}

uint64_t sub_1DD252790@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x40uLL);
  uint64_t v5 = *a1;
  *a1 = 0;
  uint64_t v7 = v5;
  sub_1DD25250C((uint64_t)v4, &v7);
  uint64_t result = v7;
  if (v7) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a2 = v4;
  return result;
}

void sub_1DD252814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CA44(a10);
  }
  operator delete(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD252834(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = &unk_1F387A0B0;
  *(void *)(a1 + 8) = 0;
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v3;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  *(void *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 48) = 0;
  return a1;
}

void *sub_1DD2528BC(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F387A0B0;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD252928(void *__p)
{
  uint64_t v2 = __p[1];
  *__n128 __p = &unk_1F387A0B0;
  __p[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

uint64_t sub_1DD2529A4(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(void *)(a1 + 40) = *(void *)(a1 + 32);
  sub_1DD252A20(a1);
  unint64_t v4 = sub_1DD238FA4(a2);
  return sub_1DD252BA4(a1, v4);
}

uint64_t sub_1DD252A20(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v3 = *(char **)(result + 32);
  uint64_t v2 = *(char **)(result + 40);
  if (v3 == v2)
  {
    int v9 = 0;
    int v8 = 0;
    uint64_t result = (*(uint64_t (**)(void, char **, int *))(**(void **)(result + 8) + 16))(*(void *)(result + 8), &v8, &v9);
    if ((result & 1) == 0) {
      goto LABEL_10;
    }
    uint64_t v3 = v8;
    uint64_t v2 = &v8[v9];
    *(void *)(v1 + 32) = v8;
    *(void *)(v1 + 40) = v2;
  }
  unint64_t v4 = v3 + 1;
  *(void *)(v1 + 32) = v3 + 1;
  uint64_t v5 = *v3;
  if ((v5 & 0x8000000000000000) == 0)
  {
    *(void *)(v1 + 16) = v5 + 3;
    *(unsigned char *)(v1 + 48) = 1;
    if (v4 != v2)
    {
LABEL_8:
      *(void *)(v1 + 32) = v4 + 1;
      *(unsigned char *)(v1 + 24) = *v4;
      return result;
    }
    int v9 = 0;
    int v8 = 0;
    uint64_t result = (*(uint64_t (**)(void, char **, int *))(**(void **)(v1 + 8) + 16))(*(void *)(v1 + 8), &v8, &v9);
    if (result)
    {
      unint64_t v4 = v8;
      uint64_t v6 = &v8[v9];
      *(void *)(v1 + 32) = v8;
      *(void *)(v1 + 40) = v6;
      goto LABEL_8;
    }
LABEL_10:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "bad read in nextBuffer");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  *(void *)(v1 + 16) = -v5;
  *(unsigned char *)(v1 + 48) = 0;
  return result;
}

void sub_1DD252B8C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD252BA4(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      unint64_t v4 = *(void *)(v3 + 16);
      if (!v4)
      {
        uint64_t result = sub_1DD252A20(v3);
        unint64_t v4 = *(void *)(v3 + 16);
      }
      if (v4 >= v2) {
        unint64_t v5 = v2;
      }
      else {
        unint64_t v5 = v4;
      }
      *(void *)(v3 + 16) = v4 - v5;
      if (*(unsigned char *)(v3 + 48)) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = v5 == 0;
      }
      if (!v6)
      {
        uint64_t v7 = *(void *)(v3 + 32);
        uint64_t v8 = *(void *)(v3 + 40);
        unint64_t v9 = v5;
        do
        {
          if (v7 == v8)
          {
            int v13 = 0;
            uint64_t v12 = 0;
            uint64_t result = (*(uint64_t (**)(void, uint64_t *, int *))(**(void **)(v3 + 8) + 16))(*(void *)(v3 + 8), &v12, &v13);
            if ((result & 1) == 0)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              sub_1DD26D8A0(exception, "bad read in nextBuffer");
              __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
            }
            uint64_t v7 = v12;
            uint64_t v8 = v12 + v13;
            *(void *)(v3 + 32) = v12;
            *(void *)(v3 + 40) = v8;
          }
          unint64_t v10 = v8 - v7;
          if (v8 - v7 >= v9) {
            unint64_t v10 = v9;
          }
          v7 += v10;
          *(void *)(v3 + 32) = v7;
          v9 -= v10;
        }
        while (v9);
      }
      v2 -= v5;
    }
    while (v2);
  }
  return result;
}

void sub_1DD252CC8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD252CDC(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = result;
  unint64_t i = 0;
  if (a4 && a3)
  {
    for (unint64_t i = 0; i < a3; ++i)
    {
      if (*(unsigned char *)(a4 + i)) {
        break;
      }
    }
  }
  if (i < a3)
  {
    size_t v9 = *(void *)(result + 16);
    do
    {
      if (!v9)
      {
        uint64_t result = sub_1DD252A20(v7);
        size_t v9 = *(void *)(v7 + 16);
      }
      if (v9 >= a3 - i) {
        size_t v10 = a3 - i;
      }
      else {
        size_t v10 = v9;
      }
      if (*(unsigned char *)(v7 + 48))
      {
        if (a4)
        {
          if (!v10) {
            goto LABEL_33;
          }
          size_t v11 = 0;
          uint64_t v12 = (unsigned char *)(a2 + i);
          int v13 = (unsigned __int8 *)(a4 + i);
          size_t v14 = v10;
          do
          {
            if (*v13++)
            {
              unsigned char *v12 = *(unsigned char *)(v7 + 24);
              ++v11;
            }
            ++v12;
            --v14;
          }
          while (v14);
          goto LABEL_44;
        }
        uint64_t result = (uint64_t)memset((void *)(a2 + i), *(unsigned __int8 *)(v7 + 24), v10);
        size_t v22 = v10;
      }
      else
      {
        if (a4)
        {
          if (v10)
          {
            size_t v11 = 0;
            uint64_t v16 = (unsigned char *)(a2 + i);
            int v17 = (unsigned __int8 *)(a4 + i);
            size_t v18 = v10;
            do
            {
              if (*v17++)
              {
                uint64_t v20 = *(unsigned char **)(v7 + 32);
                if (v20 == *(unsigned char **)(v7 + 40))
                {
                  int v30 = 0;
                  __src = 0;
                  uint64_t result = (*(uint64_t (**)(void, void **, int *))(**(void **)(v7 + 8) + 16))(*(void *)(v7 + 8), &__src, &v30);
                  if ((result & 1) == 0) {
                    goto LABEL_52;
                  }
                  uint64_t v20 = __src;
                  uint64_t v21 = (char *)__src + v30;
                  *(void *)(v7 + 32) = __src;
                  *(void *)(v7 + 40) = v21;
                }
                *(void *)(v7 + 32) = v20 + 1;
                *uint64_t v16 = *v20;
                ++v11;
              }
              ++v16;
              --v18;
            }
            while (v18);
            goto LABEL_44;
          }
LABEL_33:
          size_t v11 = 0;
LABEL_44:
          size_t v9 = *(void *)(v7 + 16) - v11;
          *(void *)(v7 + 16) = v9;
          i += v10;
          if (a4)
          {
            while (i < a3 && !*(unsigned char *)(a4 + i))
              ++i;
          }
          continue;
        }
        if (v10)
        {
          size_t v23 = 0;
          int v24 = *(char **)(v7 + 32);
          do
          {
            uint64_t v25 = *(char **)(v7 + 40);
            if (v24 == v25)
            {
              int v30 = 0;
              __src = 0;
              if (((*(uint64_t (**)(void, void **, int *))(**(void **)(v7 + 8) + 16))(*(void *)(v7 + 8), &__src, &v30) & 1) == 0)
              {
LABEL_52:
                exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                sub_1DD26D8A0(exception, "bad read in nextBuffer");
                __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
              }
              int v24 = (char *)__src;
              uint64_t v25 = (char *)__src + v30;
              *(void *)(v7 + 32) = __src;
              *(void *)(v7 + 40) = v25;
            }
            size_t v26 = v25 - v24;
            if (v26 >= v10 - v23) {
              size_t v27 = v10 - v23;
            }
            else {
              size_t v27 = v26;
            }
            uint64_t result = (uint64_t)memcpy((void *)(a2 + i + v23), v24, v27);
            int v24 = (char *)(*(void *)(v7 + 32) + v27);
            *(void *)(v7 + 32) = v24;
            v23 += v27;
          }
          while (v23 < v10);
          size_t v11 = v10;
          goto LABEL_44;
        }
        size_t v22 = 0;
      }
      size_t v9 = *(void *)(v7 + 16) - v22;
      *(void *)(v7 + 16) = v9;
      i += v10;
    }
    while (i < a3);
  }
  return result;
}

void sub_1DD252FC0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD252FD8@<X0>(uint64_t *a1@<X0>, uint64_t *a2@<X8>)
{
  unint64_t v4 = operator new(0x38uLL);
  uint64_t v5 = *a1;
  *a1 = 0;
  uint64_t v8 = v5;
  *a2 = sub_1DD252834((uint64_t)v4, &v8);
  uint64_t result = v8;
  if (v8)
  {
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)v8 + 8);
    return v7();
  }
  return result;
}

uint64_t sub_1DD25306C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  uint64_t v5 = v3;
  sub_1DD252834(a1, &v5);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  *(void *)a1 = &unk_1F387A7A0;
  *(void *)(a1 + 56) = 0;
  *(unsigned char *)(a1 + 64) = 0;
  return a1;
}

void *sub_1DD2530FC(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F387A0B0;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD253168(void *__p)
{
  uint64_t v2 = __p[1];
  *__n128 __p = &unk_1F387A0B0;
  __p[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

unint64_t sub_1DD2531E4(uint64_t a1, uint64_t a2)
{
  sub_1DD2529A4(a1, a2);
  unint64_t result = sub_1DD238FA4(a2);
  *(void *)(a1 + 56) = 0;
  if (result >= 9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "bad position");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (result)
  {
    *(void *)(a1 + 56) = 8 - result;
    return sub_1DD252CDC(a1, a1 + 64, 1uLL, 0);
  }
  return result;
}

void sub_1DD253294(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2532A8(uint64_t result, unint64_t a2)
{
  uint64_t v2 = result;
  unint64_t v3 = *(void *)(result + 56);
  unint64_t v4 = v3 - a2;
  if (v3 < a2)
  {
    char v5 = a2 - v3;
    unint64_t result = sub_1DD252BA4(result, (a2 - v3) >> 3);
    uint64_t v6 = v5 & 7;
    if (v6)
    {
      unint64_t result = sub_1DD252CDC(v2, v2 + 64, 1uLL, 0);
      unint64_t v4 = 8 - v6;
    }
    else
    {
      unint64_t v4 = 0;
    }
  }
  *(void *)(v2 + 56) = v4;
  return result;
}

void sub_1DD253314(uint64_t a1, uint64_t a2, size_t a3, uint64_t a4)
{
  int64_t v5 = a3;
  uint64_t v8 = *(void *)(a1 + 56);
  BOOL v9 = v8 != 0;
  BOOL v10 = a3 != 0;
  if (!a3) {
    BOOL v9 = 0;
  }
  if (a4)
  {
    size_t v11 = 0;
    if (v9)
    {
      do
      {
        LOBYTE(v12) = *(unsigned char *)(a4 + v11);
        if ((_BYTE)v12)
        {
          *(void *)(a1 + 56) = v8 - 1;
          int v12 = (*(unsigned __int8 *)(a1 + 64) >> (v8 - 1)) & 1;
        }
        *(unsigned char *)(a2 + v11++) = v12;
        uint64_t v8 = *(void *)(a1 + 56);
        if (v8) {
          BOOL v13 = v11 >= a3;
        }
        else {
          BOOL v13 = 1;
        }
      }
      while (!v13);
    }
  }
  else
  {
    if (!v9)
    {
      size_t v11 = 0;
      size_t v17 = a3;
      size_t v20 = a3;
      if (a3) {
        goto LABEL_27;
      }
      goto LABEL_35;
    }
    uint64_t v14 = 0;
    do
    {
      uint64_t v15 = v8 - 1;
      *(void *)(a1 + 56) = v15;
      size_t v11 = v14 + 1;
      *(unsigned char *)(a2 + v14) = (*(unsigned __int8 *)(a1 + 64) >> v15) & 1;
      uint64_t v8 = *(void *)(a1 + 56);
      if (v8) {
        BOOL v16 = v11 >= a3;
      }
      else {
        BOOL v16 = 1;
      }
      ++v14;
    }
    while (!v16);
  }
  size_t v17 = a3 - v11;
  BOOL v10 = a3 > v11;
  if (a4 && a3 > v11)
  {
    uint64_t v18 = a4;
    size_t v19 = a3;
    size_t v20 = a3 - v11;
    do
    {
      v20 -= *(unsigned char *)(v18 + v11) == 0;
      --v19;
      ++v18;
    }
    while (v11 != v19);
  }
  else
  {
    size_t v20 = a3 - v11;
  }
  if (v20)
  {
LABEL_27:
    if (v10)
    {
      sub_1DD252CDC(a1, a2 + v11, (v20 + 7) >> 3, 0);
      *(unsigned char *)(a1 + 64) = *(unsigned char *)(v11 + ((v20 + 7) >> 3) + a2 - 1);
      *(void *)(a1 + 56) = ((v20 + 7) & 0xFFFFFFFFFFFFFFF8) - v20;
      if (a4)
      {
        for (; v5 > (uint64_t)v11; --v5)
        {
          LOBYTE(v21) = *(unsigned char *)(a4 - 1 + v5);
          if ((_BYTE)v21)
          {
            int v22 = -(int)v20--;
            unsigned int v21 = (*(char *)(a2 + v11 + (v20 >> 3)) >> (v22 & 7)) & 1;
          }
          *(unsigned char *)(a2 - 1 + v5) = v21;
        }
      }
      else if ((uint64_t)v11 < v5)
      {
        size_t v23 = v20 - 1;
        int v24 = -(int)v20;
        do
          *(unsigned char *)(a2 - 1 + v5--) = (*(char *)(a2 + v11 + (v23-- >> 3)) >> (v24++ & 7)) & 1;
        while (v5 > (uint64_t)v11);
      }
    }
    return;
  }
LABEL_35:
  if (v10)
  {
    bzero((void *)(a2 + v11), v17);
  }
}

uint64_t sub_1DD253540@<X0>(uint64_t *a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x48uLL);
  uint64_t v5 = *a1;
  *a1 = 0;
  uint64_t v7 = v5;
  sub_1DD25306C((uint64_t)v4, &v7);
  uint64_t result = v7;
  if (v7) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a2 = v4;
  return result;
}

void *sub_1DD2535C4(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  a1[2] = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  a1[3] = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, void, uint64_t))(*(void *)a3 + 32))(&v14, a3, a1[2], 0, 1);
  uint64_t v5 = v14;
  if (v14)
  {
    uint64_t v14 = 0;
    uint64_t v12 = v5;
    sub_1DD253540(&v12, &v13);
    uint64_t v6 = v13;
    uint64_t v13 = 0;
    uint64_t v7 = a1[1];
    a1[1] = v6;
    if (v7)
    {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
      uint64_t v8 = v13;
      uint64_t v13 = 0;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
    }
    uint64_t v9 = v12;
    uint64_t v12 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v10 = v14;
    uint64_t v14 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  return a1;
}

void sub_1DD253784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a10) {
    sub_1DD31CA68();
  }
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = *(void *)(v12 + 8);
  *(void *)(v12 + 8) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD25380C(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD253878(void *__p)
{
  uint64_t v2 = __p[1];
  *__n128 __p = &unk_1F38793E8;
  __p[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

unint64_t sub_1DD2538F4()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  unint64_t v2 = v1;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(v0 + 8);
  if (v3)
  {
    if (!v1) {
      return 0;
    }
    unint64_t v4 = v1;
    unint64_t v5 = v1;
    do
    {
      if (v2 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v2;
      }
      if (v6 >= 0x8000) {
        uint64_t v7 = 0x8000;
      }
      else {
        uint64_t v7 = v6;
      }
      (*(void (**)(uint64_t, unsigned char *, uint64_t, void))(*(void *)v3 + 32))(v3, v12, v7, 0);
      if (v7)
      {
        uint64_t v8 = v12;
        uint64_t v9 = v7;
        do
        {
          int v10 = *v8++;
          v4 -= v10 == 0;
          --v9;
        }
        while (v9);
      }
      v5 -= v7;
    }
    while (v5);
    return v4;
  }
  return v2;
}

void *sub_1DD253A14(uint64_t a1, uint64_t a2, size_t __n, void *__src)
{
  size_t v5 = __n;
  if (*(void *)(a2 + 8) < __n) {
    (*(void (**)(uint64_t, size_t))(*(void *)a2 + 24))(a2, __n);
  }
  *(void *)(a2 + 16) = v5;
  uint64_t result = *(void **)(a1 + 8);
  if (!result)
  {
    if (__src)
    {
      *(unsigned char *)(a2 + 64) = 1;
      size_t v11 = *(void **)(a2 + 40);
      return memcpy(v11, __src, v5);
    }
LABEL_12:
    *(unsigned char *)(a2 + 64) = 0;
    return result;
  }
  uint64_t v9 = *(unsigned __int8 **)(a2 + 40);
  uint64_t result = (void *)(*(uint64_t (**)(void *, unsigned __int8 *, size_t, void *))(*(void *)result + 32))(result, v9, v5, __src);
  if (!v5) {
    goto LABEL_12;
  }
  while (*v9++)
  {
    if (!--v5) {
      goto LABEL_12;
    }
  }
  *(unsigned char *)(a2 + 64) = 1;
  return result;
}

uint64_t sub_1DD253B20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2)
  {
    uint64_t v3 = sub_1DD25B62C(a2, (unint64_t *)(result + 16));
    if (!v3) {
      sub_1DD25B5D0("unordered_map::at: key not found");
    }
    unint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 16);
    return v4(v2, v3 + 3);
  }
  return result;
}

void *sub_1DD253BA8(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = sub_1DD2535C4(a1, a2, a3);
  *size_t v5 = &unk_1F387A380;
  v5[4] = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v16, a3, v5[2], 1, 1);
  uint64_t v6 = v16;
  if (!v16)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "DATA stream not found in Boolean column");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v16 = 0;
  uint64_t v14 = v6;
  sub_1DD253540(&v14, &v15);
  uint64_t v7 = v15;
  uint64_t v15 = 0;
  uint64_t v8 = a1[4];
  a1[4] = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v15;
    uint64_t v15 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  uint64_t v10 = v14;
  uint64_t v14 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = v16;
  uint64_t v16 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

void sub_1DD253D5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[4];
  v12[4] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD253E40(void *a1)
{
  *a1 = &unk_1F387A380;
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1DD253EFC(void *a1)
{
  unint64_t v1 = sub_1DD253E40(a1);
  operator delete(v1);
}

unint64_t sub_1DD253F24(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), v2);
  return v2;
}

uint64_t sub_1DD253F7C(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, a2, a3, a4);
  uint64_t v7 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = v7[12];
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v9 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, size_t, uint64_t))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v8, a3, v9);
  if (a3)
  {
    size_t v11 = a3 - 1;
    do
    {
      *(void *)(v8 + 8 * v11) = *(char *)(v8 + v11);
      --v11;
    }
    while (v11 < a3);
  }
  return result;
}

uint64_t sub_1DD25405C(uint64_t a1, void *a2)
{
  sub_1DD253B20(a1, a2);
  uint64_t v4 = *(void *)(a1 + 32);
  size_t v5 = sub_1DD25B62C(a2, (unint64_t *)(a1 + 16));
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16);
  return v6(v4, v5 + 3);
}

void *sub_1DD2540E4(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = sub_1DD2535C4(a1, a2, a3);
  *size_t v5 = &unk_1F3879A38;
  v5[4] = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v16, a3, v5[2], 1, 1);
  uint64_t v6 = v16;
  if (!v16)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "DATA stream not found in Byte column");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v16 = 0;
  uint64_t v14 = v6;
  sub_1DD252FD8(&v14, &v15);
  uint64_t v7 = v15;
  uint64_t v15 = 0;
  uint64_t v8 = a1[4];
  a1[4] = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v15;
    uint64_t v15 = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
  }
  uint64_t v10 = v14;
  uint64_t v14 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = v16;
  uint64_t v16 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

void sub_1DD254298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[4];
  v12[4] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD25437C(void *a1)
{
  *a1 = &unk_1F3879A38;
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1DD254438(void *a1)
{
  unint64_t v1 = sub_1DD25437C(a1);
  operator delete(v1);
}

unint64_t sub_1DD254460(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), v2);
  return v2;
}

uint64_t sub_1DD2544B8(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, a2, a3, a4);
  uint64_t v7 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = v7[12];
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v9 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, size_t, uint64_t))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v8, a3, v9);
  if (a3)
  {
    size_t v11 = a3 - 1;
    do
    {
      *(void *)(v8 + 8 * v11) = *(char *)(v8 + v11);
      --v11;
    }
    while (v11 < a3);
  }
  return result;
}

uint64_t sub_1DD254598(uint64_t a1, void *a2)
{
  sub_1DD253B20(a1, a2);
  uint64_t v4 = *(void *)(a1 + 32);
  size_t v5 = sub_1DD25B62C(a2, (unint64_t *)(a1 + 16));
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16);
  return v6(v4, v5 + 3);
}

void *sub_1DD254620(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = sub_1DD2535C4(a1, a2, a3);
  *size_t v5 = &unk_1F387A450;
  v5[4] = 0;
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v18, a3, v5[2]);
  if (v19 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v6 = dword_1DD31F7B0[v19];
  sub_1DD24387C(v18);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v18, a3, a1[2], 1, 1);
  uint64_t v7 = v18[0];
  if (!v18[0])
  {
    uint64_t v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v15, "DATA stream not found in Integer column");
    __cxa_throw(v15, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v18[0] = 0;
  uint64_t v16 = v7;
  sub_1DD27D51C(&v16, 1, v6, a1[3], &v17);
  uint64_t v8 = v17;
  uint64_t v17 = 0;
  uint64_t v9 = a1[4];
  a1[4] = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    uint64_t v10 = v17;
    uint64_t v17 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  uint64_t v11 = v16;
  uint64_t v16 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = v18[0];
  v18[0] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  return a1;
}

void sub_1DD25486C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[4];
  v12[4] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD254974(void *a1)
{
  *a1 = &unk_1F387A450;
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1DD254A30(void *a1)
{
  unint64_t v1 = sub_1DD254974(a1);
  operator delete(v1);
}

unint64_t sub_1DD254A58(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), v2);
  return v2;
}

uint64_t sub_1DD254AB0(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, a2, a3, a4);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  uint64_t v9 = v8[12];
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v10 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, size_t, uint64_t))(*(void *)v7 + 32);
  return v11(v7, v9, a3, v10);
}

uint64_t sub_1DD254B80(uint64_t a1, void *a2)
{
  sub_1DD253B20(a1, a2);
  uint64_t v4 = *(void *)(a1 + 32);
  size_t v5 = sub_1DD25B62C(a2, (unint64_t *)(a1 + 16));
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  int v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16);
  return v6(v4, v5 + 3);
}

void *sub_1DD254C08(void *a1, uint64_t a2, uint64_t a3)
{
  size_t v5 = sub_1DD2535C4(a1, a2, a3);
  v5[4] = 0;
  int v6 = v5 + 4;
  *size_t v5 = &unk_1F387AA50;
  v5[5] = 0;
  uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 48))(a3);
  a1[6] = v7;
  a1[7] = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 24))(v7);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v28, a3, a1[2]);
  if (v29 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v8 = dword_1DD31F7B0[v29];
  sub_1DD24387C(v28);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v28, a3, a1[2], 1, 1);
  uint64_t v9 = v28[0];
  if (!v28[0])
  {
    int v24 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v24, "DATA stream not found in Timestamp column");
    goto LABEL_24;
  }
  v28[0] = 0;
  uint64_t v26 = v9;
  sub_1DD27D51C(&v26, 1, v8, a1[3], &v27);
  uint64_t v10 = v27;
  uint64_t v27 = 0;
  uint64_t v11 = *v6;
  uint64_t *v6 = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v27;
    uint64_t v27 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t v13 = v26;
  uint64_t v26 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v27, a3, a1[2], 5, 1);
  uint64_t v15 = v27;
  uint64_t v14 = v28[0];
  uint64_t v27 = 0;
  v28[0] = v15;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    uint64_t v16 = v27;
    uint64_t v27 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
    uint64_t v15 = v28[0];
  }
  if (!v15)
  {
    int v24 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v24, "SECONDARY stream not found in Timestamp column");
LABEL_24:
    __cxa_throw(v24, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v28[0] = 0;
  uint64_t v25 = v15;
  sub_1DD27D51C(&v25, 0, v8, a1[3], &v27);
  uint64_t v17 = v27;
  uint64_t v27 = 0;
  uint64_t v18 = a1[5];
  a1[5] = v17;
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    uint64_t v19 = v27;
    uint64_t v27 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
  uint64_t v20 = v25;
  uint64_t v25 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = v28[0];
  v28[0] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  return a1;
}

void sub_1DD255024(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  __cxa_free_exception(v13);
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v16 = v12[5];
  v12[5] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *v14;
  uint64_t *v14 = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD255180(void *a1)
{
  *a1 = &unk_1F387AA50;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_1DD25526C(void *a1)
{
  unint64_t v1 = sub_1DD255180(a1);
  operator delete(v1);
}

unint64_t sub_1DD255294(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32), v2);
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40), v2);
  return v2;
}

uint64_t sub_1DD255318(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v7 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v7 = 0;
  }
  int v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878558, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  uint64_t v9 = v8;
  uint64_t v10 = v8[12];
  (*(void (**)(void, uint64_t, size_t, uint64_t))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v10, a3, v7);
  uint64_t v11 = v9[17];
  uint64_t result = (*(uint64_t (**)(void, uint64_t, size_t, uint64_t))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), v11, a3, v7);
  if (a3)
  {
    uint64_t v13 = 0;
    do
    {
      if (!v7 || *(unsigned char *)(v7 + v13))
      {
        uint64_t v14 = *(void *)(v11 + 8 * v13);
        uint64_t v15 = v14 >> 3;
        *(void *)(v11 + 8 * v13) = v14 >> 3;
        uint64_t v16 = v14 & 7;
        if (v16)
        {
          uint64_t v17 = v16 + 1;
          do
          {
            v15 *= 10;
            --v17;
          }
          while (v17);
          *(void *)(v11 + 8 * v13) = v15;
        }
        uint64_t result = (*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 48))(*(void *)(a1 + 48), *(void *)(a1 + 56) + *(void *)(v10 + 8 * v13));
        *(void *)(v10 + 8 * v13) = result;
        if (result < 0)
        {
          if (*(void *)(v11 + 8 * v13)) {
            *(void *)(v10 + 8 * v13) = result - 1;
          }
        }
      }
      ++v13;
    }
    while (v13 != a3);
  }
  return result;
}

uint64_t sub_1DD2554B8(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[4];
  size_t v5 = a1 + 2;
  int v6 = sub_1DD25B62C(a2, a1 + 2);
  if (!v6
    || ((*(void (**)(unint64_t, void *))(*(void *)v4 + 16))(v4, v6 + 3),
        unint64_t v7 = a1[5],
        (int v8 = sub_1DD25B62C(a2, v5)) == 0))
  {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v9 = *(uint64_t (**)(unint64_t, void *))(*(void *)v7 + 16);
  return v9(v7, v8 + 3);
}

uint64_t sub_1DD255584(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = sub_1DD2535C4((void *)a1, a2, a3);
  void *v6 = &unk_1F387A128;
  v6[4] = 0;
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  uint64_t v8 = 8;
  if (v7 == 5) {
    uint64_t v8 = 4;
  }
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 48) = v8;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v14, a3, *(void *)(a1 + 16), 1, 1);
  uint64_t v9 = v14;
  uint64_t v14 = 0;
  uint64_t v10 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    uint64_t v11 = v14;
    uint64_t v14 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    uint64_t v9 = *(void *)(a1 + 32);
  }
  if (!v9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "DATA stream not found in Double column");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1;
}

void sub_1DD255734(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  uint64_t v4 = v1[4];
  v1[4] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = v1[1];
  *unint64_t v1 = &unk_1F38793E8;
  v1[1] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD2557CC(void *a1)
{
  *a1 = &unk_1F387A128;
  uint64_t v2 = a1[4];
  a1[4] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void sub_1DD255888(void *a1)
{
  unint64_t v1 = sub_1DD2557CC(a1);
  operator delete(v1);
}

unint64_t sub_1DD2558B0(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  uint64_t v3 = *(void *)(a1 + 56);
  unint64_t v4 = *(void *)(a1 + 64) - v3;
  unint64_t v5 = *(void *)(a1 + 48) * v2;
  unint64_t v6 = v5 - v4;
  if (v5 <= v4)
  {
    uint64_t v8 = v3 + v5;
  }
  else
  {
    do
    {
      if (v6 >= 0x7FFFFFFF) {
        uint64_t v7 = 0x7FFFFFFFLL;
      }
      else {
        uint64_t v7 = v6;
      }
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v7);
      v6 -= v7;
    }
    while (v6);
    uint64_t v8 = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(void *)(a1 + 56) = v8;
  return v2;
}

uint64_t sub_1DD25595C(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v7 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t result = (uint64_t)__dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878290, 0);
  if (!result) {
    __cxa_bad_cast();
  }
  uint64_t v9 = *(void *)(result + 96);
  if (*(_DWORD *)(a1 + 40) == 5)
  {
    if (v7)
    {
      if (a3)
      {
        uint64_t v10 = 0;
        do
        {
          if (*(unsigned char *)(v7 + v10))
          {
            uint64_t v11 = 0;
            float v12 = 0.0;
            do
            {
              uint64_t result = sub_1DD25B4F8(a1);
              LODWORD(v12) |= result << v11;
              v11 += 8;
            }
            while (v11 != 32);
            *(double *)(v9 + 8 * v10) = v12;
          }
          ++v10;
        }
        while (v10 != a3);
      }
    }
    else if (a3)
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = 0;
        float v18 = 0.0;
        do
        {
          uint64_t result = sub_1DD25B4F8(a1);
          LODWORD(v18) |= result << v17;
          v17 += 8;
        }
        while (v17 != 32);
        *(double *)(v9 + 8 * v16++) = v18;
      }
      while (v16 != a3);
    }
  }
  else if (v7)
  {
    if (a3)
    {
      uint64_t v13 = 0;
      do
      {
        if (*(unsigned char *)(v7 + v13))
        {
          uint64_t v14 = 0;
          uint64_t v15 = 0;
          do
          {
            uint64_t result = sub_1DD25B4F8(a1);
            v15 |= (unint64_t)result << v14;
            v14 += 8;
          }
          while (v14 != 64);
          *(void *)(v9 + 8 * v13) = v15;
        }
        ++v13;
      }
      while (v13 != a3);
    }
  }
  else if (a3)
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      do
      {
        uint64_t result = sub_1DD25B4F8(a1);
        v21 |= (unint64_t)result << v20;
        v20 += 8;
      }
      while (v20 != 64);
      *(void *)(v9 + 8 * v19++) = v21;
    }
    while (v19 != a3);
  }
  return result;
}

char *sub_1DD255B38(char *result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1)
  {
    unint64_t v5 = result;
    uint64_t v6 = 0;
    while (1)
    {
      memset(__n, 0, sizeof(__n));
      if (((*(uint64_t (**)(uint64_t, _DWORD *, _DWORD *))(*(void *)a3 + 16))(a3, &__n[1], __n) & 1) == 0) {
        break;
      }
      uint64_t v7 = v6 + __n[0];
      if (v7 > a2)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26D8A0(exception, "Corrupt dictionary blob in StringDictionaryColumn");
LABEL_9:
        __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      uint64_t result = (char *)memcpy(&v5[v6], *(const void **)&__n[1], __n[0]);
      uint64_t v6 = v7;
      if (v7 >= a2) {
        return result;
      }
    }
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "bad read in readFully");
    goto LABEL_9;
  }
  return result;
}

void sub_1DD255C3C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD255C54(uint64_t a1, void *a2)
{
  sub_1DD253B20(a1, a2);
  uint64_t v4 = *(void *)(a1 + 32);
  unint64_t v5 = sub_1DD25B62C(a2, (unint64_t *)(a1 + 16));
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 48);
  return v6(v4, v5 + 3);
}

void *sub_1DD255CDC(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = sub_1DD2535C4(a1, a2, a3);
  *unint64_t v5 = &unk_1F387B720;
  uint64_t v6 = v5 + 4;
  uint64_t v7 = operator new(0x50uLL);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3);
  sub_1DD28E8B0((uint64_t)v7, v8);
  sub_1DD25B714(v6, (uint64_t)v7);
  a1[6] = 0;
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v28, a3, a1[2]);
  if (v29 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v9 = dword_1DD31F7B0[v29];
  sub_1DD24387C(v28);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v28, a3, a1[2]);
  uint64_t v10 = v30;
  sub_1DD24387C(v28);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v27, a3, a1[2], 1, 1);
  sub_1DD27D51C(&v27, 0, v9, a1[3], v28);
  uint64_t v11 = v28[0];
  v28[0] = 0;
  uint64_t v12 = a1[6];
  a1[6] = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = v28[0];
    v28[0] = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  uint64_t v14 = v27;
  uint64_t v27 = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, void))(*(void *)a3 + 32))(&v26, a3, a1[2], 2, 0);
  sub_1DD27D51C(&v26, 0, v9, a1[3], v28);
  uint64_t v15 = v26;
  uint64_t v26 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  unint64_t v16 = (v10 + 1);
  sub_1DD26FB7C(*v6 + 40, v16);
  uint64_t v17 = *(void **)(*v6 + 56);
  (*(void (**)(void, void *, uint64_t, void))(*(void *)v28[0] + 32))(v28[0], v17 + 1, v10, 0);
  *uint64_t v17 = 0;
  if (v16 >= 2)
  {
    uint64_t v18 = 0;
    uint64_t v19 = v17 + 1;
    unint64_t v20 = v16 - 1;
    do
    {
      v18 += *v19;
      *v19++ = v18;
      --v20;
    }
    while (v20);
  }
  sub_1DD26F9D0(*v6, v17[v10]);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, void))(*(void *)a3 + 32))(&v25, a3, a1[2], 3, 0);
  sub_1DD255B38(*(char **)(*v6 + 16), v17[v10], v25);
  uint64_t v21 = v25;
  uint64_t v25 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = v28[0];
  v28[0] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  return a1;
}

void sub_1DD2560F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_1DD24387C((uint64_t *)va);
  uint64_t v6 = v4[6];
  v4[6] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)v4[5];
  if (v7) {
    sub_1DD25B904(v7);
  }
  uint64_t v8 = v4[1];
  *uint64_t v4 = &unk_1F38793E8;
  v4[1] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD256250(void *a1)
{
  *a1 = &unk_1F387B720;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3) {
    sub_1DD25B904(v3);
  }
  uint64_t v4 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_1DD256318(void *a1)
{
  unint64_t v1 = sub_1DD256250(a1);
  operator delete(v1);
}

unint64_t sub_1DD256340(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), v2);
  return v2;
}

uint64_t sub_1DD256398(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v7 = *(unsigned __int8 **)(a2 + 40);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(v9 + 16);
  uint64_t v11 = *(void *)(v9 + 56);
  uint64_t v12 = (void *)v8[12];
  uint64_t v13 = (unint64_t *)v8[17];
  uint64_t result = (*(uint64_t (**)(void, unint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 48)
                                                                                            + 32))(*(void *)(a1 + 48), v13, v4, v7);
  unint64_t v15 = *(void *)(*(void *)(a1 + 32) + 64) - 1;
  if (v7)
  {
    for (; v4; --v4)
    {
      if (*v7++)
      {
        unint64_t v17 = *v13;
        if ((*v13 & 0x8000000000000000) != 0 || v17 >= v15) {
          goto LABEL_18;
        }
        uint64_t v18 = (uint64_t *)(v11 + 8 * v17);
        uint64_t v20 = *v18;
        uint64_t v19 = v18[1];
        void *v12 = v10 + v20;
        *uint64_t v13 = v19 - v20;
      }
      ++v12;
      ++v13;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      unint64_t v21 = *v13;
      if ((*v13 & 0x8000000000000000) != 0 || v21 >= v15)
      {
LABEL_18:
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26D8A0(exception, "Entry index out of range in StringDictionaryColumn");
        __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      uint64_t v22 = (uint64_t *)(v11 + 8 * v21);
      uint64_t v24 = *v22;
      uint64_t v23 = v22[1];
      *v12++ = v10 + v24;
      *v13++ = v23 - v24;
    }
  }
  return result;
}

void sub_1DD256560(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD256578(uint64_t a1, unsigned char *a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  a2[65] = 1;
  uint64_t v6 = (std::__shared_weak_count **)__dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878858, 0);
  if (!v6) {
    __cxa_bad_cast();
  }
  uint64_t v7 = v6;
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 32);
  uint64_t v8 = *(std::__shared_weak_count **)(a1 + 40);
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = v6[26];
  v7[25] = v9;
  v7[26] = v8;
  if (v10) {
    sub_1DD25B904(v10);
  }
  uint64_t v11 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 32);
  return v11();
}

uint64_t sub_1DD25667C(uint64_t a1, void *a2)
{
  sub_1DD253B20(a1, a2);
  uint64_t v4 = *(void *)(a1 + 48);
  unint64_t v5 = sub_1DD25B62C(a2, (unint64_t *)(a1 + 16));
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16);
  return v6(v4, v5 + 3);
}

void *sub_1DD256704(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = sub_1DD2535C4(a1, a2, a3);
  *unint64_t v5 = &unk_1F387B110;
  v5[4] = 0;
  uint64_t v6 = v5 + 4;
  v5[5] = 0;
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v22, a3, v5[2]);
  if (v23 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v7 = dword_1DD31F7B0[v23];
  sub_1DD24387C(v22);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v22, a3, a1[2], 2, 1);
  uint64_t v8 = v22[0];
  if (!v22[0])
  {
    uint64_t v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v19, "LENGTH stream not found in StringDirectColumn");
    goto LABEL_19;
  }
  v22[0] = 0;
  uint64_t v20 = v8;
  sub_1DD27D51C(&v20, 0, v7, a1[3], &v21);
  uint64_t v9 = v21;
  uint64_t v21 = 0;
  uint64_t v10 = *v6;
  uint64_t *v6 = v9;
  if (v10)
  {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    uint64_t v11 = v21;
    uint64_t v21 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
  }
  uint64_t v12 = v20;
  uint64_t v20 = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v21, a3, a1[2], 1, 1);
  uint64_t v13 = v21;
  uint64_t v21 = 0;
  uint64_t v14 = a1[5];
  a1[5] = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    uint64_t v15 = v21;
    uint64_t v21 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
    uint64_t v13 = a1[5];
  }
  if (!v13)
  {
    uint64_t v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v19, "DATA stream not found in StringDirectColumn");
LABEL_19:
    __cxa_throw(v19, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  a1[6] = 0;
  a1[7] = 0;
  uint64_t v16 = v22[0];
  v22[0] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  return a1;
}

void sub_1DD256A20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  __cxa_free_exception(v13);
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v16 = v12[5];
  v12[5] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *v14;
  uint64_t *v14 = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(a1);
}

void *sub_1DD256B60(void *a1)
{
  *a1 = &unk_1F387B110;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_1DD256C4C(void *a1)
{
  unint64_t v1 = sub_1DD256B60(a1);
  operator delete(v1);
}

unint64_t sub_1DD256C74()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = sub_1DD2538F4();
  if (!v1)
  {
    unint64_t v3 = 0;
    unint64_t v9 = *(void *)(v0 + 56);
LABEL_17:
    *(void *)(v0 + 48) += v3;
    *(void *)(v0 + 56) = v9 - v3;
    return v1;
  }
  unint64_t v2 = 0;
  unint64_t v3 = 0;
  do
  {
    if (v1 - v2 >= 0x400) {
      uint64_t v4 = 1024;
    }
    else {
      uint64_t v4 = v1 - v2;
    }
    (*(void (**)(void, unsigned char *, uint64_t, void))(**(void **)(v0 + 32) + 32))(*(void *)(v0 + 32), v13, v4, 0);
    uint64_t v5 = 0;
    if (v4)
    {
      uint64_t v6 = (uint64_t *)v13;
      uint64_t v7 = v4;
      do
      {
        uint64_t v8 = *v6++;
        v5 += v8;
        --v7;
      }
      while (v7);
    }
    v3 += v5;
    v2 += v4;
  }
  while (v2 < v1);
  unint64_t v9 = *(void *)(v0 + 56);
  unint64_t v10 = v3 - v9;
  if (v3 <= v9) {
    goto LABEL_17;
  }
  do
  {
    if (v10 >= 0x7FFFFFFF) {
      uint64_t v11 = 0x7FFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    (*(void (**)(void, uint64_t))(**(void **)(v0 + 40) + 32))(*(void *)(v0 + 40), v11);
    v10 -= v11;
  }
  while (v10);
  *(void *)(v0 + 48) = 0;
  *(void *)(v0 + 56) = 0;
  return v1;
}

void sub_1DD256DF8(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v7 = *(unsigned __int8 **)(a2 + 40);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  unint64_t v9 = v8;
  unint64_t v10 = (void *)v8[12];
  uint64_t v11 = (uint64_t *)v8[17];
  (*(void (**)(void, uint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v11, v4, v7);
  if (!v7)
  {
    if (v4)
    {
      unint64_t v12 = 0;
      uint64_t v17 = v11;
      size_t v18 = v4;
      do
      {
        uint64_t v19 = *v17++;
        v12 += v19;
        --v18;
      }
      while (v18);
      goto LABEL_17;
    }
LABEL_16:
    unint64_t v12 = 0;
    goto LABEL_17;
  }
  if (!v4) {
    goto LABEL_16;
  }
  unint64_t v12 = 0;
  uint64_t v13 = v7;
  uint64_t v14 = v11;
  size_t v15 = v4;
  do
  {
    if (*v13++) {
      v12 += *v14;
    }
    ++v14;
    --v15;
  }
  while (v15);
LABEL_17:
  sub_1DD26F9D0((uint64_t)(v9 + 20), v12);
  uint64_t v20 = v9[22];
  size_t v21 = *(void *)(a1 + 56);
  if (v21 >= v12)
  {
    unint64_t v22 = 0;
  }
  else
  {
    unint64_t v22 = 0;
    unsigned int v23 = *(const void **)(a1 + 48);
    do
    {
      memcpy((void *)(v20 + v22), v23, v21);
      uint64_t v24 = *(void *)(a1 + 56);
      int v33 = 0;
      int v32 = 0;
      if (((*(uint64_t (**)(void, const void **, int *))(**(void **)(a1 + 40) + 16))(*(void *)(a1 + 40), &v33, &v32) & 1) == 0)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26D8A0(exception, "failed to read in StringDirectColumnReader.next");
        __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      v22 += v24;
      unsigned int v23 = v33;
      size_t v21 = v32;
      *(void *)(a1 + 48) = v33;
      *(void *)(a1 + 56) = v21;
    }
    while (v22 + v21 < v12);
  }
  BOOL v25 = v12 > v22;
  size_t v26 = v12 - v22;
  if (v25)
  {
    memcpy((void *)(v20 + v22), *(const void **)(a1 + 48), v26);
    size_t v27 = *(void *)(a1 + 56) - v26;
    *(void *)(a1 + 48) += v26;
    *(void *)(a1 + 56) = v27;
  }
  uint64_t v28 = v9[22];
  if (v7)
  {
    for (; v4; --v4)
    {
      if (*v7++)
      {
        void *v10 = v28;
        v28 += *v11;
      }
      ++v11;
      ++v10;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      *v10++ = v28;
      uint64_t v30 = *v11++;
      v28 += v30;
    }
  }
}

void sub_1DD257084(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD257098(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[5];
  uint64_t v5 = a1 + 2;
  uint64_t v6 = sub_1DD25B62C(a2, a1 + 2);
  if (!v6
    || ((*(void (**)(unint64_t, void *))(*(void *)v4 + 48))(v4, v6 + 3),
        unint64_t v7 = a1[4],
        (uint64_t v8 = sub_1DD25B62C(a2, v5)) == 0))
  {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  unint64_t v9 = *(uint64_t (**)(unint64_t, void *))(*(void *)v7 + 16);
  return v9(v7, v8 + 3);
}

void *sub_1DD257164(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1DD2535C4(a1, a2, a3);
  void *v6 = &unk_1F387A2B0;
  v6[4] = 0;
  unint64_t v7 = (char **)(v6 + 4);
  v6[5] = 0;
  v6[6] = 0;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a3 + 16))(&__p, a3);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v27, a3, a1[2]);
  int v8 = v28;
  sub_1DD24387C(v27);
  if (v8)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding for StructColumnReader");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  for (unsigned int i = 0; (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2) > (unint64_t)i; ++i)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, i);
    unint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 16))(v10);
    if ((*(void *)((char *)__p + ((v11 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v11))
    {
      sub_1DD2574E4(v27, v10, a3);
      uint64_t v12 = v27[0];
      v27[0] = 0;
      uint64_t v14 = (void *)a1[5];
      unint64_t v13 = a1[6];
      if ((unint64_t)v14 >= v13)
      {
        uint64_t v16 = ((char *)v14 - *v7) >> 3;
        if ((unint64_t)(v16 + 1) >> 61) {
          sub_1DD251DAC();
        }
        uint64_t v17 = v13 - (void)*v7;
        uint64_t v18 = v17 >> 2;
        if (v17 >> 2 <= (unint64_t)(v16 + 1)) {
          uint64_t v18 = v16 + 1;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v19 = v18;
        }
        if (v19) {
          uint64_t v20 = (char *)sub_1DD251DC4((uint64_t)(a1 + 6), v19);
        }
        else {
          uint64_t v20 = 0;
        }
        size_t v21 = &v20[8 * v16];
        *(void *)size_t v21 = v12;
        size_t v15 = v21 + 8;
        unsigned int v23 = (char *)a1[4];
        unint64_t v22 = (char *)a1[5];
        if (v22 != v23)
        {
          do
          {
            uint64_t v24 = *((void *)v22 - 1);
            v22 -= 8;
            *((void *)v21 - 1) = v24;
            v21 -= 8;
          }
          while (v22 != v23);
          unint64_t v22 = *v7;
        }
        a1[4] = v21;
        a1[5] = v15;
        a1[6] = &v20[8 * v19];
        if (v22) {
          operator delete(v22);
        }
      }
      else
      {
        void *v14 = v12;
        size_t v15 = v14 + 1;
      }
      a1[5] = v15;
      if (v27[0]) {
        (*(void (**)(void))(*(void *)v27[0] + 8))(v27[0]);
      }
    }
  }
  if (__p) {
    operator delete(__p);
  }
  return a1;
}

void sub_1DD257440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v17 = *v15;
  if (*v15)
  {
    v14[5] = v17;
    operator delete(v17);
  }
  uint64_t v18 = v14[1];
  void *v14 = &unk_1F38793E8;
  v14[1] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD2574E4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  switch((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1))
  {
    case 0u:
      uint64_t v6 = operator new(0x28uLL);
      uint64_t result = (uint64_t)sub_1DD253BA8(v6, a1, a2);
      break;
    case 1u:
      uint64_t v6 = operator new(0x28uLL);
      uint64_t result = (uint64_t)sub_1DD2540E4(v6, a1, a2);
      break;
    case 2u:
    case 3u:
    case 4u:
    case 0xFu:
      uint64_t v6 = operator new(0x28uLL);
      uint64_t result = (uint64_t)sub_1DD254620(v6, a1, a2);
      break;
    case 5u:
    case 6u:
      uint64_t v6 = operator new(0x48uLL);
      uint64_t result = sub_1DD255584((uint64_t)v6, a1, a2);
      break;
    case 7u:
    case 8u:
    case 0x10u:
    case 0x11u:
      uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t))(*(void *)a2 + 24))(v12, a2, v8);
      int v9 = v13;
      sub_1DD24387C(v12);
      switch(v9)
      {
        case 0:
        case 2:
          uint64_t v6 = operator new(0x40uLL);
          uint64_t result = (uint64_t)sub_1DD256704(v6, a1, a2);
          goto LABEL_19;
        case 1:
        case 3:
          uint64_t v6 = operator new(0x38uLL);
          uint64_t result = (uint64_t)sub_1DD255CDC(v6, a1, a2);
          goto LABEL_19;
        default:
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          sub_1DD26D80C(exception, "buildReader unhandled string encoding");
          goto LABEL_22;
      }
    case 9u:
      uint64_t v6 = operator new(0x40uLL);
      uint64_t result = (uint64_t)sub_1DD254C08(v6, a1, a2);
      break;
    case 0xAu:
      uint64_t v6 = operator new(0x30uLL);
      uint64_t result = (uint64_t)sub_1DD257D38(v6, a1, a2);
      break;
    case 0xBu:
      uint64_t v6 = operator new(0x38uLL);
      uint64_t result = (uint64_t)sub_1DD25886C(v6, a1, a2);
      break;
    case 0xCu:
      uint64_t v6 = operator new(0x38uLL);
      uint64_t result = (uint64_t)sub_1DD257164(v6, a1, a2);
      break;
    case 0xDu:
      uint64_t v6 = operator new(0x60uLL);
      uint64_t result = (uint64_t)sub_1DD2595A8(v6, a1, a2);
      break;
    case 0xEu:
      if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1))
      {
        unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
        uint64_t v6 = operator new(0x48uLL);
        uint64_t result = sub_1DD25A110((uint64_t)v6, a1, a2);
        if (v10 > 0x12) {
          void *v6 = &unk_1F387AC80;
        }
      }
      else
      {
        uint64_t v6 = operator new(0x58uLL);
        uint64_t result = sub_1DD25AF64((uint64_t)v6, a1, a2);
      }
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(exception, "buildReader unhandled type");
LABEL_22:
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
LABEL_19:
  *a3 = v6;
  return result;
}

void sub_1DD257858(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25790C(void *a1)
{
  *a1 = &unk_1F387A2B0;
  unint64_t v4 = a1 + 4;
  unint64_t v2 = (void *)a1[4];
  unint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    unint64_t v2 = v3;
    if (v3)
    {
LABEL_7:
      a1[5] = v2;
      operator delete(v2);
    }
  }
  else
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *((void *)v2 + v5);
      if (v6)
      {
        (*(void (**)(void))(*(void *)v6 + 8))(*((void *)v2 + v5));
        unint64_t v2 = (void *)a1[4];
        unint64_t v3 = (void *)a1[5];
      }
      ++v5;
    }
    while (v5 < ((unsigned char *)v3 - (unsigned char *)v2) >> 3);
    if (v2) {
      goto LABEL_7;
    }
  }
  uint64_t v7 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

void sub_1DD257A04(void *a1)
{
  unint64_t v1 = sub_1DD25790C(a1);
  operator delete(v1);
}

unint64_t sub_1DD257A2C(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  for (unsigned int i = *(uint64_t **)(a1 + 32); i != *(uint64_t **)(a1 + 40); ++i)
  {
    uint64_t v4 = *i;
    (*(void (**)(uint64_t, unint64_t))(*(void *)v4 + 16))(v4, v2);
  }
  return v2;
}

void *sub_1DD257AA4(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  uint64_t result = sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v8 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9 != *(void *)(a1 + 40))
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(v9 + v10);
      uint64_t v12 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878310, 0);
      if (!v12) {
        __cxa_bad_cast();
      }
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void, size_t, uint64_t))(*(void *)v11 + 24))(v11, *(void *)(v12[10] + v10), a3, v8);
      v10 += 8;
    }
    while (v9 + v10 != *(void *)(a1 + 40));
  }
  return result;
}

void *sub_1DD257BB8(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  uint64_t result = sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    uint64_t v8 = *(void *)(a2 + 40);
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9 != *(void *)(a1 + 40))
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(v9 + v10);
      uint64_t v12 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878310, 0);
      if (!v12) {
        __cxa_bad_cast();
      }
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void, size_t, uint64_t))(*(void *)v11 + 32))(v11, *(void *)(v12[10] + v10), a3, v8);
      v10 += 8;
    }
    while (v9 + v10 != *(void *)(a1 + 40));
  }
  return result;
}

uint64_t sub_1DD257CC8(uint64_t a1, void *a2)
{
  uint64_t result = sub_1DD253B20(a1, a2);
  for (unsigned int i = *(uint64_t **)(a1 + 32); i != *(uint64_t **)(a1 + 40); ++i)
  {
    uint64_t v6 = *i;
    uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)v6 + 40))(v6, a2);
  }
  return result;
}

void *sub_1DD257D38(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1DD2535C4(a1, a2, a3);
  v6[4] = 0;
  uint64_t v7 = v6 + 4;
  void *v6 = &unk_1F3879C70;
  v6[5] = 0;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a3 + 16))(&__p, a3);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v23, a3, a1[2]);
  if (v24 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v8 = dword_1DD31F7B0[v24];
  sub_1DD24387C(v23);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v23, a3, a1[2], 2, 1);
  uint64_t v9 = v23[0];
  if (!v23[0])
  {
    uint64_t v20 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v20, "LENGTH stream not found in List column");
    __cxa_throw(v20, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v23[0] = 0;
  uint64_t v21 = v9;
  sub_1DD27D51C(&v21, 0, v8, a1[3], &v22);
  uint64_t v10 = v22;
  uint64_t v22 = 0;
  uint64_t v11 = a1[5];
  a1[5] = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v22;
    uint64_t v22 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t v13 = v21;
  uint64_t v21 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, 0);
  unint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
  if ((*(void *)((char *)__p + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15))
  {
    sub_1DD2574E4(&v22, v14, a3);
    uint64_t v16 = *v7;
    uint64_t *v7 = v22;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  uint64_t v17 = v23[0];
  v23[0] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  if (__p) {
    operator delete(__p);
  }
  return a1;
}

void sub_1DD258080(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (__p) {
    operator delete(__p);
  }
  uint64_t v19 = v16[5];
  v16[5] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *v17;
  *uint64_t v17 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = v16[1];
  *uint64_t v16 = &unk_1F38793E8;
  v16[1] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD2581D8(void *a1)
{
  *a1 = &unk_1F3879C70;
  uint64_t v2 = a1[5];
  a1[5] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_1DD2582C4(void *a1)
{
  unint64_t v1 = sub_1DD2581D8(a1);
  operator delete(v1);
}

unint64_t sub_1DD2582EC()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = sub_1DD2538F4();
  unint64_t v2 = v1;
  uint64_t v3 = *(void *)(v0 + 32);
  if (v3)
  {
    if (v1)
    {
      unint64_t v4 = 0;
      uint64_t v5 = 0;
      do
      {
        if (v2 - v4 >= 0x400) {
          uint64_t v6 = 1024;
        }
        else {
          uint64_t v6 = v2 - v4;
        }
        (*(void (**)(void, unsigned char *, uint64_t, void))(**(void **)(v0 + 40) + 32))(*(void *)(v0 + 40), v11, v6, 0);
        if (v6)
        {
          uint64_t v7 = (uint64_t *)v11;
          uint64_t v8 = v6;
          do
          {
            uint64_t v9 = *v7++;
            v5 += v9;
            --v8;
          }
          while (v8);
        }
        v4 += v6;
      }
      while (v4 < v2);
    }
    else
    {
      uint64_t v5 = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 16))(v3, v5);
  }
  else
  {
    (*(void (**)(void, unint64_t))(**(void **)(v0 + 40) + 24))(*(void *)(v0 + 40), v1);
  }
  return v2;
}

uint64_t sub_1DD258468(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878100, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = (uint64_t *)v7[12];
  if (*((unsigned char *)v7 + 64)) {
    uint64_t v9 = (unsigned __int8 *)v7[5];
  }
  else {
    uint64_t v9 = 0;
  }
  (*(void (**)(void, uint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), v8, a3, v9);
  if (v9)
  {
    if (a3)
    {
      uint64_t v10 = 0;
      size_t v11 = a3;
      uint64_t v12 = v8;
      do
      {
        if (*v9++)
        {
          uint64_t v14 = *v12;
          uint64_t *v12 = v10;
          v10 += v14;
        }
        else
        {
          uint64_t *v12 = v10;
        }
        ++v12;
        --v11;
      }
      while (v11);
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!a3)
  {
LABEL_17:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  uint64_t v10 = 0;
  unint64_t v15 = v8;
  size_t v16 = a3;
  do
  {
    uint64_t v17 = *v15;
    *v15++ = v10;
    v10 += v17;
    --v16;
  }
  while (v16);
LABEL_18:
  v8[a3] = v10;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    uint64_t v19 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v19();
  }
  return result;
}

uint64_t sub_1DD258608(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878100, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = (uint64_t *)v7[12];
  if (*((unsigned char *)v7 + 64)) {
    uint64_t v9 = (unsigned __int8 *)v7[5];
  }
  else {
    uint64_t v9 = 0;
  }
  (*(void (**)(void, uint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), v8, a3, v9);
  if (v9)
  {
    if (a3)
    {
      uint64_t v10 = 0;
      size_t v11 = a3;
      uint64_t v12 = v8;
      do
      {
        if (*v9++)
        {
          uint64_t v14 = *v12;
          uint64_t *v12 = v10;
          v10 += v14;
        }
        else
        {
          uint64_t *v12 = v10;
        }
        ++v12;
        --v11;
      }
      while (v11);
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (!a3)
  {
LABEL_17:
    uint64_t v10 = 0;
    goto LABEL_18;
  }
  uint64_t v10 = 0;
  unint64_t v15 = v8;
  size_t v16 = a3;
  do
  {
    uint64_t v17 = *v15;
    *v15++ = v10;
    v10 += v17;
    --v16;
  }
  while (v16);
LABEL_18:
  v8[a3] = v10;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    uint64_t v19 = *(uint64_t (**)(void))(*(void *)result + 32);
    return v19();
  }
  return result;
}

uint64_t sub_1DD2587A4(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[5];
  uint64_t v5 = sub_1DD25B62C(a2, a1 + 2);
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  (*(void (**)(unint64_t, void *))(*(void *)v4 + 16))(v4, v5 + 3);
  uint64_t result = a1[4];
  if (result)
  {
    uint64_t v7 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v7();
  }
  return result;
}

void *sub_1DD25886C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1DD2535C4(a1, a2, a3);
  void *v6 = &unk_1F3879968;
  v6[4] = 0;
  uint64_t v7 = v6 + 4;
  v6[5] = 0;
  v6[6] = 0;
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a3 + 16))(&__p, a3);
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v26, a3, a1[2]);
  if (v27 >= 4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown encoding in convertRleVersion");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v8 = dword_1DD31F7B0[v27];
  sub_1DD24387C(v26);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v26, a3, a1[2], 2, 1);
  uint64_t v9 = v26[0];
  if (!v26[0])
  {
    unsigned int v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v23, "LENGTH stream not found in Map column");
    __cxa_throw(v23, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v26[0] = 0;
  uint64_t v24 = v9;
  sub_1DD27D51C(&v24, 0, v8, a1[3], &v25);
  uint64_t v10 = v25;
  uint64_t v25 = 0;
  uint64_t v11 = a1[6];
  a1[6] = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v25;
    uint64_t v25 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t v13 = v24;
  uint64_t v24 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, 0);
  unint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 16))(v14);
  if ((*(void *)((char *)__p + ((v15 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v15))
  {
    sub_1DD2574E4(&v25, v14, a3);
    uint64_t v16 = *v7;
    uint64_t *v7 = v25;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1);
  unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16))(v17);
  if ((*(void *)((char *)__p + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v18))
  {
    sub_1DD2574E4(&v25, v17, a3);
    uint64_t v19 = a1[5];
    a1[5] = v25;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
  uint64_t v20 = v26[0];
  v26[0] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  if (__p) {
    operator delete(__p);
  }
  return a1;
}

void sub_1DD258C64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  if (__p) {
    operator delete(__p);
  }
  uint64_t v19 = v16[6];
  v16[6] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = v16[5];
  v16[5] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = *v17;
  *uint64_t v17 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = v16[1];
  *uint64_t v16 = &unk_1F38793E8;
  v16[1] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD258DF0()
{
}

void *sub_1DD258DF8(void *a1)
{
  *a1 = &unk_1F3879968;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[5];
  a1[5] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[4];
  a1[4] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void sub_1DD258F14(void *a1)
{
  unint64_t v1 = sub_1DD258DF8(a1);
  operator delete(v1);
}

unint64_t sub_1DD258F3C()
{
  uint64_t v0 = MEMORY[0x1F4188790]();
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v1 = sub_1DD2538F4();
  unint64_t v2 = v1;
  uint64_t v4 = *(void *)(v0 + 32);
  uint64_t v3 = *(void *)(v0 + 40);
  if (*(_OWORD *)(v0 + 32) == 0)
  {
    (*(void (**)(void, unint64_t))(**(void **)(v0 + 48) + 24))(*(void *)(v0 + 48), v1);
    return v2;
  }
  if (v1)
  {
    unint64_t v5 = 0;
    uint64_t v6 = 0;
    do
    {
      if (v2 - v5 >= 0x400) {
        uint64_t v7 = 1024;
      }
      else {
        uint64_t v7 = v2 - v5;
      }
      (*(void (**)(void, unsigned char *, uint64_t, void))(**(void **)(v0 + 48) + 32))(*(void *)(v0 + 48), v12, v7, 0);
      if (v7)
      {
        int v8 = (uint64_t *)v12;
        uint64_t v9 = v7;
        do
        {
          uint64_t v10 = *v8++;
          v6 += v10;
          --v9;
        }
        while (v9);
      }
      v5 += v7;
    }
    while (v5 < v2);
    if (!v4) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v6 = 0;
  if (v4) {
LABEL_12:
  }
    (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 16))(v4, v6);
LABEL_13:
  if (v3) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v3 + 16))(v3, v6);
  }
  return v2;
}

uint64_t sub_1DD2590FC(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878030, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  int v8 = v7;
  uint64_t v9 = (uint64_t *)v7[12];
  if (*((unsigned char *)v7 + 64)) {
    uint64_t v10 = (unsigned __int8 *)v7[5];
  }
  else {
    uint64_t v10 = 0;
  }
  (*(void (**)(void, uint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v9, a3, v10);
  if (!v10)
  {
    if (a3)
    {
      uint64_t v11 = 0;
      uint64_t v16 = v9;
      size_t v17 = a3;
      do
      {
        uint64_t v18 = *v16;
        *v16++ = v11;
        v11 += v18;
        --v17;
      }
      while (v17);
      goto LABEL_18;
    }
LABEL_17:
    uint64_t v11 = 0;
    goto LABEL_18;
  }
  if (!a3) {
    goto LABEL_17;
  }
  uint64_t v11 = 0;
  size_t v12 = a3;
  uint64_t v13 = v9;
  do
  {
    if (*v10++)
    {
      uint64_t v15 = *v13;
      *uint64_t v13 = v11;
      v11 += v15;
    }
    else
    {
      *uint64_t v13 = v11;
    }
    ++v13;
    --v12;
  }
  while (v12);
LABEL_18:
  v9[a3] = v11;
  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v19 + 24))(v19, v8[15], v11, 0);
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v21 = *(uint64_t (**)(void))(*(void *)result + 24);
    return v21();
  }
  return result;
}

uint64_t sub_1DD2592D8(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878030, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  int v8 = v7;
  uint64_t v9 = (uint64_t *)v7[12];
  if (*((unsigned char *)v7 + 64)) {
    uint64_t v10 = (unsigned __int8 *)v7[5];
  }
  else {
    uint64_t v10 = 0;
  }
  (*(void (**)(void, uint64_t *, size_t, unsigned __int8 *))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v9, a3, v10);
  if (!v10)
  {
    if (a3)
    {
      uint64_t v11 = 0;
      uint64_t v16 = v9;
      size_t v17 = a3;
      do
      {
        uint64_t v18 = *v16;
        *v16++ = v11;
        v11 += v18;
        --v17;
      }
      while (v17);
      goto LABEL_18;
    }
LABEL_17:
    uint64_t v11 = 0;
    goto LABEL_18;
  }
  if (!a3) {
    goto LABEL_17;
  }
  uint64_t v11 = 0;
  size_t v12 = a3;
  uint64_t v13 = v9;
  do
  {
    if (*v10++)
    {
      uint64_t v15 = *v13;
      *uint64_t v13 = v11;
      v11 += v15;
    }
    else
    {
      *uint64_t v13 = v11;
    }
    ++v13;
    --v12;
  }
  while (v12);
LABEL_18:
  v9[a3] = v11;
  uint64_t v19 = *(void *)(a1 + 32);
  if (v19) {
    (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v19 + 32))(v19, v8[15], v11, 0);
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result)
  {
    uint64_t v21 = *(uint64_t (**)(void))(*(void *)result + 32);
    return v21();
  }
  return result;
}

uint64_t sub_1DD2594B0(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[6];
  unint64_t v5 = sub_1DD25B62C(a2, a1 + 2);
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  (*(void (**)(unint64_t, void *))(*(void *)v4 + 16))(v4, v5 + 3);
  unint64_t v6 = a1[4];
  if (v6) {
    (*(void (**)(unint64_t, void *))(*(void *)v6 + 40))(v6, a2);
  }
  uint64_t result = a1[5];
  if (result)
  {
    int v8 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v8();
  }
  return result;
}

void *sub_1DD2595A8(void *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = sub_1DD2535C4(a1, a2, a3);
  void *v6 = &unk_1F3879F50;
  *((_OWORD *)v6 + 2) = 0u;
  uint64_t v7 = v6 + 4;
  int v8 = v6 + 5;
  *((_OWORD *)v6 + 4) = 0u;
  uint64_t v9 = (uint64_t)(v6 + 8);
  *((_OWORD *)v6 + 3) = 0u;
  v6[10] = 0;
  unint64_t v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  a1[11] = v10;
  sub_1DD2599E0((uint64_t)v8, v10);
  sub_1DD259A10(v9, a1[11]);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(&v26, a3, a1[2], 1, 1);
  if (!v26)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "LENGTH stream not found in Union column");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v25 = v26;
  uint64_t v26 = 0;
  sub_1DD252FD8(&v25, (uint64_t *)__p);
  uint64_t v11 = __p[0];
  __p[0] = 0;
  uint64_t v12 = *v7;
  uint64_t *v7 = (uint64_t)v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = __p[0];
    __p[0] = 0;
    if (v13) {
      (*(void (**)(void *))(*(void *)v13 + 8))(v13);
    }
  }
  uint64_t v14 = v25;
  uint64_t v25 = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a3 + 16))(__p, a3);
  if (a1[11])
  {
    uint64_t v15 = 0;
    unsigned int v16 = 1;
    do
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, v15);
      unint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16))(v17);
      if ((*(void *)((char *)__p[0] + ((v18 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v18))
      {
        sub_1DD2574E4(&v23, v17, a3);
        *(void *)(*v8 + 8 * v15) = v23;
      }
      uint64_t v15 = v16;
    }
    while (a1[11] > (unint64_t)v16++);
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  uint64_t v20 = v26;
  uint64_t v26 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  return a1;
}

void sub_1DD2598B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a14) {
    (*(void (**)(uint64_t))(*(void *)a14 + 8))(a14);
  }
  uint64_t v19 = *v16;
  if (*v16)
  {
    v14[9] = v19;
    operator delete(v19);
  }
  uint64_t v20 = *v15;
  if (*v15)
  {
    v14[6] = v20;
    operator delete(v20);
  }
  uint64_t v21 = *v17;
  *uint64_t v17 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = v14[1];
  void *v14 = &unk_1F38793E8;
  v14[1] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD2599E0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_1DD25B978((void **)a1, a2 - v2);
  }
}

void sub_1DD259A10(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    sub_1DD25BA8C((char **)a1, a2 - v2);
  }
}

void *sub_1DD259A40(void *a1)
{
  *a1 = &unk_1F3879F50;
  uint64_t v3 = (void *)a1[5];
  unint64_t v2 = (void *)a1[6];
  while (v3 != v2)
  {
    if (*v3)
    {
      (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
      unint64_t v2 = (void *)a1[6];
    }
    ++v3;
  }
  unint64_t v4 = (void *)a1[8];
  if (v4)
  {
    a1[9] = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)a1[5];
  if (v5)
  {
    a1[6] = v5;
    operator delete(v5);
  }
  uint64_t v6 = a1[4];
  a1[4] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

void sub_1DD259B60(void *a1)
{
  unint64_t v1 = sub_1DD259A40(a1);
  operator delete(v1);
}

unint64_t sub_1DD259B88(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = sub_1DD2538F4();
  uint64_t v3 = *(void **)(a1 + 64);
  bzero(v3, 8 * *(void *)(a1 + 88));
  if (v2)
  {
    for (unint64_t i = 0; i < v2; i += v5)
    {
      if (v2 - i >= 0x400) {
        uint64_t v5 = 1024;
      }
      else {
        uint64_t v5 = v2 - i;
      }
      (*(void (**)(void, unsigned char *, uint64_t, void))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v13, v5, 0);
      if (v5)
      {
        uint64_t v6 = v13;
        uint64_t v7 = v5;
        do
        {
          uint64_t v8 = *v6++;
          ++*((void *)v3 + v8);
          --v7;
        }
        while (v7);
      }
    }
  }
  unint64_t v9 = *(void *)(a1 + 88);
  if (v9)
  {
    for (unint64_t j = 0; j < v9; ++j)
    {
      if (*((void *)v3 + j))
      {
        uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8 * j);
        if (v11)
        {
          (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
          unint64_t v9 = *(void *)(a1 + 88);
        }
      }
    }
  }
  return v2;
}

uint64_t sub_1DD259CE8(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878250, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = v7;
  unint64_t v9 = (void *)v7[17];
  unint64_t v10 = *(void **)(a1 + 64);
  bzero(v10, 8 * *(void *)(a1 + 88));
  uint64_t v11 = (unsigned __int8 *)v8[12];
  if (*((unsigned char *)v8 + 64)) {
    uint64_t v12 = (unsigned __int8 *)v8[5];
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void, void, size_t, unsigned __int8 *))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v8[12], v4, v12);
  if (v12)
  {
    for (; v4; --v4)
    {
      if (*v12++)
      {
        uint64_t v15 = *v11;
        uint64_t v16 = *((void *)v10 + v15);
        *((void *)v10 + v15) = v16 + 1;
        void *v9 = v16;
      }
      ++v9;
      ++v11;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      unsigned int v17 = *v11++;
      uint64_t v18 = *((void *)v10 + v17);
      *((void *)v10 + v17) = v18 + 1;
      *v9++ = v18;
    }
  }
  unint64_t v19 = *(void *)(a1 + 88);
  if (v19)
  {
    for (unint64_t i = 0; i < v19; ++i)
    {
      uint64_t result = *(void *)(*(void *)(a1 + 40) + 8 * i);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)result + 24))(result, *(void *)(v8[20] + 8 * i), *((void *)v10 + i), 0);
        unint64_t v19 = *(void *)(a1 + 88);
      }
    }
  }
  return result;
}

uint64_t sub_1DD259E98(uint64_t a1, const void *a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, (uint64_t)a2, a3, a4);
  uint64_t v7 = __dynamic_cast(a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878250, 0);
  if (!v7) {
    __cxa_bad_cast();
  }
  uint64_t v8 = v7;
  unint64_t v9 = (void *)v7[17];
  unint64_t v10 = *(void **)(a1 + 64);
  bzero(v10, 8 * *(void *)(a1 + 88));
  uint64_t v11 = (unsigned __int8 *)v8[12];
  if (*((unsigned char *)v8 + 64)) {
    uint64_t v12 = (unsigned __int8 *)v8[5];
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void, void, size_t, unsigned __int8 *))(**(void **)(a1 + 32) + 32))(*(void *)(a1 + 32), v8[12], v4, v12);
  if (v12)
  {
    for (; v4; --v4)
    {
      if (*v12++)
      {
        uint64_t v15 = *v11;
        uint64_t v16 = *((void *)v10 + v15);
        *((void *)v10 + v15) = v16 + 1;
        void *v9 = v16;
      }
      ++v9;
      ++v11;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      unsigned int v17 = *v11++;
      uint64_t v18 = *((void *)v10 + v17);
      *((void *)v10 + v17) = v18 + 1;
      *v9++ = v18;
    }
  }
  unint64_t v19 = *(void *)(a1 + 88);
  if (v19)
  {
    for (unint64_t i = 0; i < v19; ++i)
    {
      uint64_t result = *(void *)(*(void *)(a1 + 40) + 8 * i);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void, void))(*(void *)result + 32))(result, *(void *)(v8[20] + 8 * i), *((void *)v10 + i), 0);
        unint64_t v19 = *(void *)(a1 + 88);
      }
    }
  }
  return result;
}

uint64_t sub_1DD25A044(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[4];
  uint64_t v5 = sub_1DD25B62C(a2, a1 + 2);
  if (!v5) {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t result = (*(uint64_t (**)(unint64_t, void *))(*(void *)v4 + 16))(v4, v5 + 3);
  unint64_t v7 = a1[11];
  if (v7)
  {
    for (unint64_t i = 0; i < v7; ++i)
    {
      uint64_t result = *(void *)(a1[5] + 8 * i);
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 40))(result, a2);
        unint64_t v7 = a1[11];
      }
    }
  }
  return result;
}

uint64_t sub_1DD25A110(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = sub_1DD2535C4((void *)a1, a2, a3);
  void *v6 = &unk_1F387A8C8;
  v6[4] = 0;
  v6[8] = 0;
  *(_DWORD *)(a1 + 44) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
  *(_DWORD *)(a1 + 40) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 72))(a2);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v23, a3, *(void *)(a1 + 16), 1, 1);
  uint64_t v7 = v23[0];
  v23[0] = 0;
  uint64_t v8 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v7;
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    uint64_t v9 = v23[0];
    v23[0] = 0;
    if (v9) {
      (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    }
    uint64_t v7 = *(void *)(a1 + 32);
  }
  if (!v7)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "DATA stream not found in Decimal64Column");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a3 + 24))(v23, a3, *(void *)(a1 + 16));
  if (v24 >= 4)
  {
    unint64_t v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v19, "Unknown encoding in convertRleVersion");
    __cxa_throw(v19, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v10 = dword_1DD31F7B0[v24];
  sub_1DD24387C(v23);
  (*(void (**)(void *__return_ptr, uint64_t, void, uint64_t, uint64_t))(*(void *)a3 + 32))(v23, a3, *(void *)(a1 + 16), 5, 1);
  uint64_t v11 = v23[0];
  if (!v23[0])
  {
    uint64_t v20 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(v20, "SECONDARY stream not found in Decimal64Column");
    __cxa_throw(v20, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v23[0] = 0;
  uint64_t v21 = v11;
  sub_1DD27D51C(&v21, 1, v10, *(void *)(a1 + 24), &v22);
  uint64_t v12 = v22;
  uint64_t v22 = 0;
  uint64_t v13 = *(void *)(a1 + 64);
  *(void *)(a1 + 64) = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    uint64_t v14 = v22;
    uint64_t v22 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
  uint64_t v15 = v21;
  uint64_t v21 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = v23[0];
  v23[0] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  return a1;
}

void sub_1DD25A4A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[8];
  v12[8] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v12[4];
  v12[4] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = v12[1];
  void *v12 = &unk_1F38793E8;
  v12[1] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD25A5F4(void *a1)
{
  *a1 = &unk_1F387A8C8;
  uint64_t v2 = a1[8];
  a1[8] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  *a1 = &unk_1F38793E8;
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void sub_1DD25A6E0(void *a1)
{
  unint64_t v1 = sub_1DD25A5F4(a1);
  operator delete(v1);
}

unint64_t sub_1DD25A708(uint64_t a1)
{
  unint64_t v2 = sub_1DD2538F4();
  if (v2)
  {
    unint64_t v3 = 0;
    do
    {
      sub_1DD25A79C(a1);
      uint64_t v4 = *(unsigned __int8 **)(a1 + 48);
      *(void *)(a1 + 48) = v4 + 1;
      v3 += (*v4 >> 7) ^ 1u;
    }
    while (v3 < v2);
  }
  (*(void (**)(void, unint64_t))(**(void **)(a1 + 64) + 24))(*(void *)(a1 + 64), v2);
  return v2;
}

uint64_t sub_1DD25A79C(uint64_t result)
{
  uint64_t v1 = result + 48;
  if (*(void *)(result + 48) == *(void *)(result + 56))
  {
    uint64_t v2 = result;
    do
    {
      int v9 = 0;
      uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(v2 + 32) + 16))(*(void *)(v2 + 32), v1, &v9);
      if ((result & 1) == 0)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        (*(void (**)(std::string *__return_ptr))(**(void **)(v2 + 32) + 56))(&v7);
        uint64_t v5 = std::string::insert(&v7, 0, "Read past end of stream in Decimal64ColumnReader ");
        long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
        v8.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v6;
        v5->__r_.__value_.__l.__size_ = 0;
        v5->__r_.__value_.__r.__words[2] = 0;
        v5->__r_.__value_.__r.__words[0] = 0;
        sub_1DD26D86C(exception, &v8);
        __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      int v3 = v9;
      *(void *)(v2 + 56) = *(void *)(v2 + 48) + v9;
    }
    while (!v3);
  }
  return result;
}

void sub_1DD25A8C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1DD25A924(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    std::string v7 = *(unsigned __int8 **)(a2 + 40);
  }
  else {
    std::string v7 = 0;
  }
  std::string v8 = (int **)__dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878528, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  int v9 = v8;
  int v10 = v8[13];
  uint64_t v11 = v8[18];
  uint64_t result = (*(uint64_t (**)(void, int *, size_t, unsigned __int8 *))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), v11, v4, v7);
  v9[10] = *(int **)(a1 + 40);
  if (v7)
  {
    for (; v4; --v4)
    {
      if (*v7++) {
        uint64_t result = sub_1DD25AA58(a1, v10, *v11);
      }
      v11 += 2;
      v10 += 2;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      int v14 = *v11;
      v11 += 2;
      uint64_t result = sub_1DD25AA58(a1, v10, v14);
      v10 += 2;
    }
  }
  return result;
}

uint64_t sub_1DD25AA58(uint64_t a1, void *a2, int a3)
{
  uint64_t v6 = 0;
  *a2 = 0;
  do
  {
    uint64_t result = sub_1DD25A79C(a1);
    std::string v8 = *(char **)(a1 + 48);
    *(void *)(a1 + 48) = v8 + 1;
    char v9 = *v8;
    unint64_t v10 = ((unint64_t)(*v8 & 0x7F) << v6) | *a2;
    *a2 = v10;
    v6 += 7;
  }
  while (v9 < 0);
  int64_t v11 = -(uint64_t)(v10 & 1) ^ (v10 >> 1);
  *a2 = v11;
  int v12 = *(_DWORD *)(a1 + 44);
  unsigned int v13 = v12 - a3;
  if (v12 > a3 && v13 <= 0x12)
  {
    uint64_t v14 = qword_1DD31F7C0[v13] * v11;
LABEL_9:
    *a2 = v14;
    return result;
  }
  if (v12 < a3 && (a3 - v12) <= 0x12)
  {
    uint64_t v14 = v11 / qword_1DD31F7C0[a3 - v12];
    goto LABEL_9;
  }
  if (v12 != a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Decimal scale out of range");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return result;
}

void sub_1DD25AB68(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25AB7C(uint64_t result, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = a3;
  uint64_t v5 = (unint64_t *)result;
  if (a2 <= a3)
  {
    if (a2 < a3)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      do
      {
        if (v3 - a2 >= 0x12) {
          int v8 = 18;
        }
        else {
          int v8 = v3 - a2;
        }
        uint64_t v9 = qword_1DD31F7C0[v8];
        v11[0] = v9 >> 63;
        v11[1] = v9;
        uint64_t result = sub_1DD26DED4(v5, v11, &v12);
        *uint64_t v5 = result;
        v5[1] = v10;
        v3 -= v8;
      }
      while (v3 > a2);
    }
  }
  else
  {
    do
    {
      if (a2 - v3 >= 0x12) {
        int v6 = 18;
      }
      else {
        int v6 = a2 - v3;
      }
      uint64_t v7 = qword_1DD31F7C0[v6];
      uint64_t v12 = v7 >> 63;
      uint64_t v13 = v7;
      uint64_t result = (uint64_t)sub_1DD26DB04(v5, &v12);
      v3 += v6;
    }
    while (v3 < a2);
  }
  return result;
}

uint64_t sub_1DD25AC50(unint64_t *a1, void *a2)
{
  sub_1DD253B20((uint64_t)a1, a2);
  unint64_t v4 = a1[4];
  uint64_t v5 = a1 + 2;
  int v6 = sub_1DD25B62C(a2, a1 + 2);
  if (!v6
    || ((*(void (**)(unint64_t, void *))(*(void *)v4 + 48))(v4, v6 + 3),
        unint64_t v7 = a1[8],
        (int v8 = sub_1DD25B62C(a2, v5)) == 0))
  {
    sub_1DD25B5D0("unordered_map::at: key not found");
  }
  uint64_t v9 = *(uint64_t (**)(unint64_t, void *))(*(void *)v7 + 16);
  return v9(v7, v8 + 3);
}

void sub_1DD25AD20(void *a1)
{
  uint64_t v1 = sub_1DD25A5F4(a1);
  operator delete(v1);
}

uint64_t sub_1DD25AD48(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    unint64_t v7 = *(unsigned __int8 **)(a2 + 40);
  }
  else {
    unint64_t v7 = 0;
  }
  int v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38785B8, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  uint64_t v9 = v8;
  unint64_t v10 = (uint64_t *)*((void *)v8 + 13);
  int64_t v11 = (unsigned int *)*((void *)v8 + 18);
  uint64_t result = (*(uint64_t (**)(void, unsigned int *, size_t, unsigned __int8 *))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), v11, v4, v7);
  v9[10] = *(void *)(a1 + 40);
  if (v7)
  {
    for (; v4; --v4)
    {
      if (*v7++) {
        uint64_t result = sub_1DD25AE7C(a1, v10, *v11);
      }
      v11 += 2;
      v10 += 2;
    }
  }
  else
  {
    for (; v4; --v4)
    {
      unsigned int v14 = *v11;
      v11 += 2;
      uint64_t result = sub_1DD25AE7C(a1, v10, v14);
      v10 += 2;
    }
  }
  return result;
}

uint64_t sub_1DD25AE7C(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  unsigned int v6 = 0;
  *a2 = 0;
  a2[1] = 0;
  char v7 = 64;
  do
  {
    sub_1DD25A79C(a1);
    int v8 = *(unsigned char **)(a1 + 48);
    *(void *)(a1 + 48) = v8 + 1;
    LOBYTE(v8) = *v8;
    int v9 = (char)v8;
    unint64_t v10 = v8 & 0x7F;
    unint64_t v11 = v10 << v6;
    uint64_t v12 = 0;
    if (v6 > 0x7F) {
      unint64_t v11 = 0;
    }
    if (v6 <= 0x3F)
    {
      uint64_t v12 = v10 << v6;
      unint64_t v11 = v10 >> v7;
    }
    if (v6) {
      unint64_t v10 = v12;
    }
    else {
      unint64_t v11 = 0;
    }
    uint64_t v13 = a2[1] | v10;
    unint64_t v14 = *a2 | v11;
    *a2 = v14;
    a2[1] = v13;
    v6 += 7;
    v7 -= 7;
  }
  while (v9 < 0);
  *((void *)&v16 + 1) = v14;
  *(void *)&long long v16 = v13;
  uint64_t v15 = v16 >> 1;
  unint64_t v17 = v14 >> 1;
  *a2 = v17;
  a2[1] = v15;
  if (v13)
  {
    *a2 = ~v17;
    a2[1] = ~v15;
  }
  unsigned int v18 = *(_DWORD *)(a1 + 44);
  return sub_1DD25AB7C((uint64_t)a2, v18, a3);
}

uint64_t sub_1DD25AF64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)sub_1DD25A110(a1, a2, a3) = &unk_1F387B150;
  *(_DWORD *)(a1 + 44) = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 72))(a3);
  *(unsigned char *)(a1 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3);
  *(void *)(a1 + 80) = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 56))(a3);
  return a1;
}

void sub_1DD25B030(_Unwind_Exception *a1)
{
  sub_1DD25A5F4(v1);
  _Unwind_Resume(a1);
}

void sub_1DD25B048(void *a1)
{
  uint64_t v1 = sub_1DD25A5F4(a1);
  operator delete(v1);
}

uint64_t sub_1DD25B070(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  size_t v4 = a3;
  sub_1DD253A14(a1, a2, a3, a4);
  if (*(unsigned char *)(a2 + 64)) {
    char v7 = *(unsigned char **)(a2 + 40);
  }
  else {
    char v7 = 0;
  }
  int v8 = __dynamic_cast((const void *)a2, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38785B8, 0);
  if (!v8) {
    __cxa_bad_cast();
  }
  int v9 = v8;
  unint64_t v10 = (uint64_t *)*((void *)v8 + 13);
  unint64_t v11 = (unsigned int *)*((void *)v8 + 18);
  uint64_t result = (*(uint64_t (**)(void, unsigned int *, size_t, unsigned char *))(**(void **)(a1 + 64) + 32))(*(void *)(a1 + 64), v11, v4, v7);
  v9[10] = *(void *)(a1 + 40);
  if (v7)
  {
    for (; v4; --v4)
    {
      if (*v7)
      {
        uint64_t result = sub_1DD25B2D8(a1, v10, *v11);
        if ((result & 1) == 0)
        {
          if (*(unsigned char *)(a1 + 72)) {
            goto LABEL_20;
          }
          uint64_t v13 = sub_1DD239B24(*(void **)(a1 + 80), (uint64_t)"Warning: ", 9);
          unint64_t v14 = sub_1DD239B24(v13, (uint64_t)"Hive 0.11 decimal with more than 38 digits ", 43);
          uint64_t result = (uint64_t)sub_1DD239B24(v14, (uint64_t)"replaced by NULL.\n", 18);
          unsigned char *v7 = 0;
        }
      }
      v11 += 2;
      v10 += 2;
      ++v7;
    }
  }
  else if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t result = sub_1DD25B2D8(a1, v10, *(void *)&v11[2 * i]);
      if ((result & 1) == 0)
      {
        if (*(unsigned char *)(a1 + 72))
        {
LABEL_20:
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          sub_1DD26D8A0(exception, "Hive 0.11 decimal was more than 38 digits.");
          __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        long long v16 = sub_1DD239B24(*(void **)(a1 + 80), (uint64_t)"Warning: ", 9);
        unint64_t v17 = sub_1DD239B24(v16, (uint64_t)"Hive 0.11 decimal with more than 38 digits ", 43);
        uint64_t result = (uint64_t)sub_1DD239B24(v17, (uint64_t)"replaced by NULL.\n", 18);
        *((unsigned char *)v9 + 64) = 1;
        *(unsigned char *)(v9[5] + i) = 0;
      }
      v10 += 2;
    }
  }
  return result;
}

void sub_1DD25B2C0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1DD25B2D8(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1EC08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1EC08))
  {
    xmmword_1EAB1EBF8 = xmmword_1DD31F790;
    __cxa_guard_release(&qword_1EAB1EC08);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1EC20, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1EC20))
  {
    xmmword_1EAB1EC10 = xmmword_1DD31F7A0;
    __cxa_guard_release(&qword_1EAB1EC20);
  }
  unsigned int v6 = 0;
  *a2 = 0;
  a2[1] = 0;
  char v7 = 1;
  char v8 = 64;
  do
  {
    sub_1DD25A79C(a1);
    int v9 = *(char **)(a1 + 48);
    *(void *)(a1 + 48) = v9 + 1;
    char v10 = *v9;
    if (v6 > 0x80)
    {
      char v7 = 0;
LABEL_6:
      unint64_t v11 = 0;
      unint64_t v12 = 0;
      goto LABEL_15;
    }
    unint64_t v11 = v10 & 0x7F;
    if (!v6)
    {
      unint64_t v12 = 0;
      goto LABEL_15;
    }
    if (v6 == 126)
    {
      v7 &= v11 < 4;
    }
    else
    {
      if (v6 <= 0x3F)
      {
        unint64_t v12 = v11 >> v8;
        v11 <<= v6;
        goto LABEL_15;
      }
      if (v6 > 0x7F) {
        goto LABEL_6;
      }
    }
    unint64_t v12 = v11 << v6;
    unint64_t v11 = 0;
LABEL_15:
    uint64_t v13 = a2[1] | v11;
    unint64_t v14 = *a2 | v12;
    *a2 = v14;
    a2[1] = v13;
    v6 += 7;
    v8 -= 7;
  }
  while (v10 < 0);
  if ((v7 & 1) == 0) {
    return 0;
  }
  *((void *)&v16 + 1) = v14;
  *(void *)&long long v16 = v13;
  uint64_t v15 = v16 >> 1;
  uint64_t v17 = v14 >> 1;
  *a2 = v17;
  a2[1] = v15;
  if (v13)
  {
    *a2 = ~v17;
    a2[1] = ~v15;
  }
  sub_1DD25AB7C((uint64_t)a2, *(_DWORD *)(a1 + 44), a3);
  uint64_t v18 = *a2;
  if (*a2 == (void)xmmword_1EAB1EBF8)
  {
    if ((unint64_t)a2[1] < *((void *)&xmmword_1EAB1EBF8 + 1)) {
      return 0;
    }
LABEL_23:
    if (v18 == (void)xmmword_1EAB1EC10) {
      return (unint64_t)a2[1] <= *((void *)&xmmword_1EAB1EC10 + 1);
    }
    else {
      return v18 <= (uint64_t)xmmword_1EAB1EC10;
    }
  }
  else
  {
    if (*a2 >= (uint64_t)xmmword_1EAB1EBF8) {
      goto LABEL_23;
    }
    return 0;
  }
}

uint64_t sub_1DD25B4D0(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 65) = 0;
  return (*(uint64_t (**)(void))(*(void *)a1 + 24))();
}

uint64_t sub_1DD25B4F8(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 56);
  uint64_t v2 = (void *)(a1 + 56);
  if (v1 == *(unsigned __int8 **)(a1 + 64))
  {
    int v6 = 0;
    if (((*(uint64_t (**)(void, void *, int *))(**(void **)(a1 + 32) + 16))(*(void *)(a1 + 32), v2, &v6) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "bad read in DoubleColumnReader::next()");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v1 = *(unsigned __int8 **)(a1 + 56);
    *(void *)(a1 + 64) = &v1[v6];
  }
  *uint64_t v2 = v1 + 1;
  return *v1;
}

void sub_1DD25B5BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD25B5D0(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1DD25B6E0(exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E6CBA928, MEMORY[0x1E4FBA1D0]);
}

void sub_1DD25B618(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25B62C(void *a1, unint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (v3 >= *(void *)&v2) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & v3;
  }
  int v6 = *(void **)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  uint64_t result = (void *)*v6;
  if (*v6)
  {
    do
    {
      unint64_t v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3) {
          return result;
        }
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(void *)&v2) {
            v8 %= *(void *)&v2;
          }
        }
        else
        {
          v8 &= *(void *)&v2 - 1;
        }
        if (v8 != v5) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

std::logic_error *sub_1DD25B6E0(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
  return result;
}

void *sub_1DD25B714(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint8x8_t v4 = operator new(0x20uLL);
  *uint8x8_t v4 = &unk_1F387CEB8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  uint64_t v6 = 0;
  sub_1DD25B8B0(&v6, 0);
  return a1;
}

void sub_1DD25B788(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD25B8B0((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

void sub_1DD25B7A4(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1DD25B7CC(uint64_t a1)
{
}

uint64_t sub_1DD25B7D4(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878EE8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_1DD25B818(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    sub_1DD270394(a2 + 40);
    unint64_t v3 = (void *)sub_1DD2701B4(a2);
    operator delete(v3);
  }
}

BOOL sub_1DD25B860(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

void sub_1DD25B8B0(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_1DD270394(v2 + 40);
    uint64_t v3 = (void *)sub_1DD2701B4(v2);
    operator delete(v3);
  }
}

void sub_1DD25B904(std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void sub_1DD25B978(void **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  char v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      sub_1DD251DAC();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      uint64_t v13 = (char *)sub_1DD251DC4(v4, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = &v13[8 * v10];
    uint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    long long v16 = &v14[8 * a2];
    uint64_t v18 = (char *)*a1;
    uint64_t v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      uint64_t v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

void sub_1DD25BA8C(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  char v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      sub_1DD251DAC();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      unint64_t v14 = (char *)sub_1DD251DC4(v4, v13);
      uint64_t v8 = *a1;
      char v7 = a1[1];
    }
    else
    {
      unint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v11];
    long long v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t sub_1DD25BBB4@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  int v4 = sub_1DD29155C(*(void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  int v6 = sub_1DD291568(*(void *)(a1 + 8));
  unint64_t v7 = sub_1DD29147C(*(void *)(a1 + 8));
  uint64_t v8 = sub_1DD291464(*(void *)(a1 + 8));
  uint64_t v9 = sub_1DD291588(*(void *)(a1 + 8));
  return sub_1DD26C0A0(v4, v5, v6, v7, v8, v9, a2);
}

void *sub_1DD25BC54@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t result = operator new(0x18uLL);
  *uint64_t result = &unk_1F387A1F8;
  result[1] = a1;
  result[2] = a2;
  *a3 = result;
  return result;
}

void sub_1DD25BCB4(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_1(a1);
  operator delete(v1);
}

uint64_t sub_1DD25BCDC(uint64_t result)
{
  if (result)
  {
    if (result != 1)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D938(exception, "Invalid param");
      __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    return 2;
  }
  return result;
}

void sub_1DD25BD40(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25BD54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_1F3879428;
  *(void *)(a1 + 8) = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  *(void *)(a1 + 24) = 0;
  uint64_t v9 = (uint64_t *)(a1 + 24);
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  char v10 = sub_1DD291594(a4);
  *(void *)(a1 + 56) = 0;
  uint64_t v11 = (uint64_t *)(a1 + 56);
  *(unsigned char *)(a1 + 48) = v10;
  *(void *)(a1 + 88) = 0;
  uint64_t v12 = (uint64_t *)(a1 + 88);
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  *(void *)(a1 + 96) = 0;
  uint64_t v13 = sub_1DD291588(a4);
  *(void *)(a1 + 112) = 0;
  unint64_t v14 = (uint64_t *)(a1 + 112);
  *(void *)(a1 + 104) = v13;
  *(void *)(a1 + 120) = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)a3 + 16))(&v52, a3, 0);
  uint64_t v15 = v52;
  uint64_t v52 = 0;
  uint64_t v50 = v15;
  sub_1DD252790(&v50, &v51);
  uint64_t v16 = v51;
  uint64_t v51 = 0;
  uint64_t v17 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    uint64_t v18 = v51;
    uint64_t v51 = 0;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
  }
  uint64_t v19 = v50;
  uint64_t v50 = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  sub_1DD27F24C(a2, &v51);
  uint64_t v20 = v51;
  uint64_t v51 = 0;
  uint64_t v21 = *v9;
  uint64_t *v9 = v20;
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    uint64_t v22 = v51;
    uint64_t v51 = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
  }
  sub_1DD27F24C(a2, &v51);
  uint64_t v23 = v51;
  uint64_t v51 = 0;
  uint64_t v24 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v23;
  if (v24)
  {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    uint64_t v25 = v51;
    uint64_t v51 = 0;
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
  sub_1DD27F24C(a2, &v51);
  uint64_t v26 = v51;
  uint64_t v51 = 0;
  uint64_t v27 = *(void *)(a1 + 40);
  *(void *)(a1 + 40) = v26;
  if (v27)
  {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    uint64_t v28 = v51;
    uint64_t v51 = 0;
    if (v28) {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
    }
  }
  if (*(unsigned char *)(a1 + 48))
  {
    unsigned int v29 = operator new(0x30uLL);
    sub_1DD241978((uint64_t)v29);
    uint64_t v30 = *v11;
    uint64_t *v11 = (uint64_t)v29;
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
    }
    long long v31 = operator new(0x38uLL);
    sub_1DD2410AC((uint64_t)v31);
    uint64_t v32 = *(void *)(a1 + 64);
    *(void *)(a1 + 64) = v31;
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
    }
    int v33 = operator new(0x10uLL);
    uint64_t v34 = *(void *)(a1 + 64);
    void *v33 = &unk_1F387B098;
    v33[1] = v34;
    uint64_t v35 = *(void *)(a1 + 72);
    *(void *)(a1 + 72) = v33;
    if (v35) {
      (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v51, a3, 6);
    uint64_t v36 = v51;
    uint64_t v51 = 0;
    uint64_t v37 = *v14;
    uint64_t *v14 = v36;
    if (v37)
    {
      (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
      uint64_t v38 = v51;
      uint64_t v51 = 0;
      if (v38) {
        (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
      }
    }
    if (sub_1DD2915B4(a4, *(void *)(a1 + 16)) && sub_1DD291610(a4) == 1)
    {
      *(unsigned char *)(a1 + 80) = 1;
      uint64_t v39 = operator new(0x20uLL);
      unint64_t v40 = sub_1DD2914A0(a4);
      double v41 = sub_1DD291604(a4);
      sub_1DD2515A4((uint64_t)v39, v40, v41);
      uint64_t v42 = *v12;
      uint64_t *v12 = (uint64_t)v39;
      if (v42) {
        (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
      }
      int v43 = operator new(0x30uLL);
      sub_1DD2429C0((uint64_t)v43);
      uint64_t v44 = *(void *)(a1 + 96);
      *(void *)(a1 + 96) = v43;
      if (v44) {
        (*(void (**)(uint64_t))(*(void *)v44 + 8))(v44);
      }
      (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v51, a3, 8);
      uint64_t v45 = v51;
      uint64_t v51 = 0;
      uint64_t v46 = *(void *)(a1 + 120);
      *(void *)(a1 + 120) = v45;
      if (v46)
      {
        (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
        uint64_t v47 = v51;
        uint64_t v51 = 0;
        if (v47) {
          (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
        }
      }
    }
  }
  uint64_t v48 = v52;
  uint64_t v52 = 0;
  if (v48) {
    (*(void (**)(uint64_t))(*(void *)v48 + 8))(v48);
  }
  return a1;
}

void sub_1DD25C384(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v18 = v12[15];
  v12[15] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = *v16;
  *uint64_t v16 = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = v12[12];
  v12[12] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = *v15;
  *uint64_t v15 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = v12[9];
  v12[9] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = v12[8];
  v12[8] = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = *v14;
  uint64_t *v14 = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = v12[5];
  v12[5] = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  uint64_t v26 = v12[4];
  v12[4] = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = *v13;
  *uint64_t v13 = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  uint64_t v28 = v12[1];
  v12[1] = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD25C64C(void *a1)
{
  *a1 = &unk_1F3879428;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[14];
  a1[14] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[12];
  a1[12] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[11];
  a1[11] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = a1[9];
  a1[9] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[8];
  a1[8] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[7];
  a1[7] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[5];
  a1[5] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = a1[4];
  a1[4] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = a1[3];
  a1[3] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = a1[1];
  a1[1] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  return a1;
}

uint64_t sub_1DD25C8A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *(void *)(a2 + 40) + a3, a4, a5);
}

void *sub_1DD25C8DC(uint64_t a1, uint64_t *a2)
{
  sub_1DD242F9C(v10);
  v11 |= 3u;
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  int v12 = 0;
  int v13 = v5;
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
  v11 |= 4u;
  uint64_t v14 = v6;
  unint64_t v7 = a2[1];
  if (v7 >= a2[2])
  {
    uint64_t v8 = sub_1DD268EA4(a2, (uint64_t)v10);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v10);
    uint64_t v8 = v7 + 40;
    a2[1] = v7 + 40;
  }
  a2[1] = v8;
  return sub_1DD243030(v10);
}

void sub_1DD25C99C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25C9BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

void *sub_1DD25C9E4(uint64_t a1, uint64_t *a2)
{
  return sub_1DD25C9EC(a1, a2, *(void *)(a1 + 32));
}

void *sub_1DD25C9EC(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  sub_1DD23F9E4((uint64_t)v8);
  (*(void (**)(uint64_t, void *))(*(void *)a3 + 56))(a3, v8);
  unint64_t v5 = a2[1];
  if (v5 >= a2[2])
  {
    uint64_t v6 = sub_1DD268360(a2, (uint64_t)v8);
  }
  else
  {
    sub_1DD23FC14(a2[1], (uint64_t)v8);
    uint64_t v6 = v5 + 120;
    a2[1] = v5 + 120;
  }
  a2[1] = v6;
  return sub_1DD23FE3C(v8);
}

void sub_1DD25CA90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD23FE3C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25CAB0(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 32) + 48);
  return v2();
}

uint64_t sub_1DD25CB30(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 48);
  return v2();
}

void *sub_1DD25CBB0(uint64_t a1, uint64_t *a2)
{
  return sub_1DD25C9EC(a1, a2, *(void *)(a1 + 40));
}

uint64_t sub_1DD25CBB8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  *(_DWORD *)(v2 + 16) |= 1u;
  uint64_t v3 = *(void **)(v2 + 48);
  if (!v3)
  {
    uint64_t v3 = sub_1DD24E894(0);
    *(void *)(v2 + 48) = v3;
  }
  (*(void (**)(void, void *))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24), v3);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v6 = *(int **)(v5 + 40);
  if (!v6)
  {
    int v8 = *(_DWORD *)(v5 + 36);
LABEL_8:
    sub_1DD2FABC8(v5 + 24, v8 + 1);
    uint64_t v6 = *(int **)(v5 + 40);
    int v8 = *v6;
    goto LABEL_9;
  }
  uint64_t v7 = *(int *)(v5 + 32);
  int v8 = *v6;
  if ((int)v7 < *v6)
  {
    *(_DWORD *)(v5 + 32) = v7 + 1;
    uint64_t v9 = *(std::string **)&v6[2 * v7 + 2];
    goto LABEL_10;
  }
  if (v8 == *(_DWORD *)(v5 + 36)) {
    goto LABEL_8;
  }
LABEL_9:
  int *v6 = v8 + 1;
  uint64_t v9 = (std::string *)sub_1DD24E928(*(void *)(v5 + 24));
  uint64_t v10 = *(void *)(v5 + 40);
  uint64_t v11 = *(int *)(v5 + 32);
  *(_DWORD *)(v5 + 32) = v11 + 1;
  *(void *)(v10 + 8 * v11 + 8) = v9;
LABEL_10:
  sub_1DD241874(v9, v4);
  uint64_t v12 = *(void *)(a1 + 64);
  *(_DWORD *)(v12 + 24) = 0;
  uint64_t v13 = *(void *)(v12 + 48);
  if (v13) {
    sub_1DD23FE68(v13);
  }
  *(_DWORD *)(v12 + 16) &= ~1u;
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  (*(void (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
  uint64_t v14 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 104);
  return v14(a1);
}

void sub_1DD25CD84(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 80)) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 88);
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v4 = *(int **)(v3 + 40);
  if (!v4)
  {
    int v6 = *(_DWORD *)(v3 + 36);
    goto LABEL_8;
  }
  uint64_t v5 = *(int *)(v3 + 32);
  int v6 = *v4;
  if ((int)v5 >= *v4)
  {
    if (v6 != *(_DWORD *)(v3 + 36))
    {
LABEL_9:
      *uint64_t v4 = v6 + 1;
      uint64_t v7 = sub_1DD24EA50(*(void *)(v3 + 24));
      uint64_t v8 = *(void *)(v3 + 40);
      uint64_t v9 = *(int *)(v3 + 32);
      *(_DWORD *)(v3 + 32) = v9 + 1;
      *(void *)(v8 + 8 * v9 + 8) = v7;
      goto LABEL_10;
    }
LABEL_8:
    sub_1DD2FABC8(v3 + 24, v6 + 1);
    uint64_t v4 = *(int **)(v3 + 40);
    int v6 = *v4;
    goto LABEL_9;
  }
  *(_DWORD *)(v3 + 32) = v5 + 1;
  uint64_t v7 = *(void **)&v4[2 * v5 + 2];
LABEL_10:
  sub_1DD251940(v2, (uint64_t)v7);
  uint64_t v10 = *(void *)(a1 + 88);
  sub_1DD251930(v10);
}

void *sub_1DD25CE64(uint64_t a1, uint64_t *a2)
{
  sub_1DD2FA720(*(void *)(a1 + 56), *(void *)(a1 + 112));
  sub_1DD242F9C(v14);
  uint64_t v4 = *(void *)(a1 + 16);
  int v16 = 6;
  int v17 = v4;
  v15 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 72))(*(void *)(a1 + 112));
  v15 |= 4u;
  uint64_t v18 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v14);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v14);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  if (*(unsigned char *)(a1 + 80))
  {
    if ((sub_1DD2FA720(*(void *)(a1 + 96), *(void *)(a1 + 120)) & 1) == 0)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Failed to write bloom filter stream.");
      __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
    }
    uint64_t v8 = *(void *)(a1 + 16);
    int v16 = 8;
    int v17 = v8;
    v15 |= 3u;
    uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 72))(*(void *)(a1 + 120));
    v15 |= 4u;
    uint64_t v18 = v9;
    unint64_t v10 = a2[1];
    if (v10 >= a2[2])
    {
      uint64_t v11 = sub_1DD268EA4(a2, (uint64_t)v14);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v14);
      uint64_t v11 = v10 + 40;
      a2[1] = v10 + 40;
    }
    a2[1] = v11;
  }
  return sub_1DD243030(v14);
}

void sub_1DD25D010(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25D044(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
}

void sub_1DD25D074(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void *)(a1 + 56);
    uint64_t v3 = *(unsigned int *)(v2 + 32);
    if ((int)v3 >= 1)
    {
      uint64_t v4 = (uint64_t *)(*(void *)(v2 + 40) + 8);
      do
      {
        uint64_t v5 = *v4++;
        sub_1DD241180(v5);
        --v3;
      }
      while (v3);
      *(_DWORD *)(v2 + 32) = 0;
    }
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)(v6 + 24) = 0;
    uint64_t v7 = *(void *)(v6 + 48);
    if (v7) {
      sub_1DD23FE68(v7);
    }
    *(_DWORD *)(v6 + 16) &= ~1u;
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  if (*(unsigned char *)(a1 + 80))
  {
    sub_1DD251930(*(void *)(a1 + 88));
    uint64_t v8 = *(void *)(a1 + 96);
    uint64_t v9 = *(unsigned int *)(v8 + 32);
    if ((int)v9 >= 1)
    {
      unint64_t v10 = (uint64_t *)(*(void *)(v8 + 40) + 8);
      do
      {
        uint64_t v11 = *v10++;
        sub_1DD2420BC(v11);
        --v9;
      }
      while (v9);
      *(_DWORD *)(v8 + 32) = 0;
    }
  }
}

uint64_t sub_1DD25D158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  unsigned int v9 = 0;
  *uint64_t v8 = &unk_1F387A2F0;
  v8[16] = 0;
  unint64_t v10 = (char **)(v8 + 16);
  v8[17] = 0;
  v8[18] = 0;
  uint64_t v11 = (uint64_t)(v8 + 18);
  while ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2) > (unint64_t)v9)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, v9);
    sub_1DD25D3B0(&v27, v12, a3, a4);
    uint64_t v13 = v27;
    uint64_t v27 = 0;
    int v15 = *(void **)(a1 + 136);
    unint64_t v14 = *(void *)(a1 + 144);
    if ((unint64_t)v15 >= v14)
    {
      uint64_t v17 = ((char *)v15 - *v10) >> 3;
      if ((unint64_t)(v17 + 1) >> 61) {
        sub_1DD251DAC();
      }
      uint64_t v18 = v14 - (void)*v10;
      uint64_t v19 = v18 >> 2;
      if (v18 >> 2 <= (unint64_t)(v17 + 1)) {
        uint64_t v19 = v17 + 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20) {
        uint64_t v21 = (char *)sub_1DD251DC4(v11, v20);
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v22 = &v21[8 * v17];
      *(void *)uint64_t v22 = v13;
      int v16 = v22 + 8;
      uint64_t v24 = *(char **)(a1 + 128);
      uint64_t v23 = *(char **)(a1 + 136);
      if (v23 != v24)
      {
        do
        {
          uint64_t v25 = *((void *)v23 - 1);
          v23 -= 8;
          *((void *)v22 - 1) = v25;
          v22 -= 8;
        }
        while (v23 != v24);
        uint64_t v23 = *v10;
      }
      *(void *)(a1 + 128) = v22;
      *(void *)(a1 + 136) = v16;
      *(void *)(a1 + 144) = &v21[8 * v20];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *int v15 = v13;
      int v16 = v15 + 1;
    }
    *(void *)(a1 + 136) = v16;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    ++v9;
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  return a1;
}

void sub_1DD25D378(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  sub_1DD25C64C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25D3B0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  switch((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1))
  {
    case 0u:
      uint64_t v8 = operator new(0x88uLL);
      uint64_t result = sub_1DD25F1C4((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 1u:
      uint64_t v8 = operator new(0x88uLL);
      uint64_t result = sub_1DD25EA20((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 2u:
    case 3u:
    case 4u:
      uint64_t v8 = operator new(0x90uLL);
      uint64_t result = sub_1DD25E254((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 5u:
      uint64_t v8 = operator new(0xB8uLL);
      uint64_t result = (uint64_t)sub_1DD25F96C(v8, a1, a2, a3, 1);
      goto LABEL_22;
    case 6u:
      uint64_t v8 = operator new(0xB8uLL);
      uint64_t result = (uint64_t)sub_1DD25F96C(v8, a1, a2, a3, 0);
      goto LABEL_22;
    case 7u:
      uint64_t v8 = operator new(0x138uLL);
      uint64_t result = sub_1DD260528((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 8u:
      uint64_t v8 = operator new(0x138uLL);
      uint64_t result = sub_1DD260528((uint64_t)v8, a1, a2, a3);
      unint64_t v10 = &unk_1F387A020;
      goto LABEL_21;
    case 9u:
      uint64_t v8 = operator new(0xA0uLL);
      uint64_t result = sub_1DD262C60((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0xAu:
      uint64_t v8 = operator new(0x98uLL);
      uint64_t result = sub_1DD264AC8((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0xBu:
      uint64_t v8 = operator new(0xA0uLL);
      uint64_t result = sub_1DD2658F4((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0xCu:
      uint64_t v8 = operator new(0x98uLL);
      uint64_t result = sub_1DD25D158((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0xDu:
      uint64_t v8 = operator new(0xA0uLL);
      uint64_t result = sub_1DD266A9C((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0xEu:
      if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) > 0x12)
      {
        if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1) > 0x26)
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          sub_1DD26D80C(exception, "Decimal precision more than 38 is not supported");
LABEL_25:
          __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
        }
        uint64_t v8 = operator new(0xC8uLL);
        uint64_t result = sub_1DD263BD0((uint64_t)v8, a1, a2, a3);
        unint64_t v10 = &unk_1F387ACC0;
LABEL_21:
        *(void *)uint64_t v8 = v10;
      }
      else
      {
        uint64_t v8 = operator new(0xB8uLL);
        uint64_t result = sub_1DD263BD0((uint64_t)v8, a1, a2, a3);
      }
LABEL_22:
      *a4 = v8;
      return result;
    case 0xFu:
      uint64_t v8 = operator new(0x90uLL);
      uint64_t result = sub_1DD25E254((uint64_t)v8, a1, a2, a3);
      unint64_t v10 = &unk_1F3879B98;
      goto LABEL_21;
    case 0x10u:
      uint64_t v8 = operator new(0x140uLL);
      uint64_t result = sub_1DD268E1C((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    case 0x11u:
      uint64_t v8 = operator new(0x168uLL);
      uint64_t result = sub_1DD268C04((uint64_t)v8, a1, a2, a3);
      goto LABEL_22;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(exception, "Type is not supported yet for creating ColumnWriter.");
      goto LABEL_25;
  }
}

void sub_1DD25D764(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25D814(void *a1)
{
  *a1 = &unk_1F387A2F0;
  uint64_t v4 = a1 + 16;
  uint64_t v2 = (void *)a1[16];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (v3)
    {
LABEL_7:
      a1[17] = v2;
      operator delete(v2);
    }
  }
  else
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = *((void *)v2 + v5);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v2 = (void *)a1[16];
        uint64_t v3 = (void *)a1[17];
      }
      unint64_t v5 = v6++;
    }
    while (v5 < ((unsigned char *)v3 - (unsigned char *)v2) >> 3);
    if (v2) {
      goto LABEL_7;
    }
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD25D8DC(void *a1)
{
  uint64_t v1 = sub_1DD25D814(a1);
  operator delete(v1);
}

uint64_t sub_1DD25D904(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878310, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StructVectorBatch");
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v12 = (unsigned __int8 *)(v11[5] + a3);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v13)
  {
    unint64_t v14 = 0;
    unsigned int v15 = 1;
    do
    {
      (*(void (**)(void, void, uint64_t, unint64_t, unsigned __int8 *))(**(void **)(v13 + 8 * v14)
                                                                                           + 16))(*(void *)(v13 + 8 * v14), *(void *)(v11[10] + 8 * v14), a3, a4, v12);
      unint64_t v14 = v15;
      uint64_t v13 = *(void *)(a1 + 128);
      ++v15;
    }
    while (v14 < (*(void *)(a1 + 136) - v13) >> 3);
  }
  if (!v12)
  {
    unint64_t v20 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);
    return v20();
  }
  unint64_t v16 = 0;
  if (a4)
  {
    unint64_t v17 = a4;
    do
    {
      if (*v12++) {
        ++v16;
      }
      --v17;
    }
    while (v17);
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v16);
  if (v16 < a4)
  {
    unint64_t v20 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 32);
    return v20();
  }
  return result;
}

void sub_1DD25DB70(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25DB84(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25C8DC(a1, a2);
  uint64_t v5 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 24))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = *(void *)(a1 + 128);
      ++v7;
    }
    while (v6 < (*(void *)(a1 + 136) - v5) >> 3);
  }
  return result;
}

void *sub_1DD25DC0C(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25CE64(a1, a2);
  uint64_t v5 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 96))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = *(void *)(a1 + 128);
      ++v7;
    }
    while (v6 < (*(void *)(a1 + 136) - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD25DC94(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      v2 += (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 32))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 128);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 136) - v3) >> 3);
  }
  return v2;
}

void *sub_1DD25DD44(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v10);
  uint64_t v12 = 0;
  v11 |= 3u;
  unint64_t v4 = a2[1];
  if (v4 >= a2[2])
  {
    uint64_t v5 = sub_1DD269130(a2, (uint64_t)v10);
  }
  else
  {
    sub_1DD243878(a2[1], v10);
    uint64_t v5 = v4 + 40;
    a2[1] = v4 + 40;
  }
  a2[1] = v5;
  uint64_t v6 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v6)
  {
    unint64_t v7 = 0;
    unsigned int v8 = 1;
    do
    {
      (*(void (**)(void, uint64_t *))(**(void **)(v6 + 8 * v7) + 40))(*(void *)(v6 + 8 * v7), a2);
      unint64_t v7 = v8;
      uint64_t v6 = *(void *)(a1 + 128);
      ++v8;
    }
    while (v7 < (*(void *)(a1 + 136) - v6) >> 3);
  }
  return sub_1DD24387C(v10);
}

void sub_1DD25DE24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DD25DE48(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25C9EC((uint64_t)a1, a2, a1[4]);
  uint64_t v5 = a1[16];
  if (a1[17] != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 48))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = a1[16];
      ++v7;
    }
    while (v6 < (a1[17] - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD25DED4(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 72))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 128);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 136) - v3) >> 3);
  }
  return result;
}

void *sub_1DD25DF9C(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25C9EC((uint64_t)a1, a2, a1[5]);
  uint64_t v5 = a1[16];
  if (a1[17] != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 56))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = a1[16];
      ++v7;
    }
    while (v6 < (a1[17] - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD25E028(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  uint64_t v3 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 64))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 128);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 136) - v3) >> 3);
  }
  return result;
}

uint64_t sub_1DD25E0F0(uint64_t a1)
{
  uint64_t result = sub_1DD25CBB8(a1);
  uint64_t v3 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 80))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 128);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 136) - v3) >> 3);
  }
  return result;
}

void sub_1DD25E168(uint64_t a1)
{
  sub_1DD25D074(a1);
  uint64_t v2 = *(void *)(a1 + 128);
  if (*(void *)(a1 + 136) != v2)
  {
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      (*(void (**)(void))(**(void **)(v2 + 8 * v3) + 112))(*(void *)(v2 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v2 = *(void *)(a1 + 128);
      ++v4;
    }
    while (v3 < (*(void *)(a1 + 136) - v2) >> 3);
  }
}

uint64_t sub_1DD25E1E0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 128);
  if (*(void *)(result + 136) != v1)
  {
    uint64_t v2 = result;
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 8 * v3) + 120))(*(void *)(v1 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v1 = *(void *)(v2 + 128);
      ++v4;
    }
    while (v3 < (*(void *)(v2 + 136) - v1) >> 3);
  }
  return result;
}

uint64_t sub_1DD25E254(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a3;
  unsigned int v7 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  void *v7 = &unk_1F387A490;
  v7[16] = 0;
  *(_DWORD *)(a1 + 136) = sub_1DD2913FC(a4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)v5 + 16))(&v18, v5, 1);
  uint64_t v8 = v18;
  uint64_t v18 = 0;
  uint64_t v16 = v8;
  LODWORD(v5) = *(_DWORD *)(a1 + 136);
  BOOL v9 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v16, 1, v5, v9, &v17);
  uint64_t v10 = v17;
  uint64_t v17 = 0;
  uint64_t v11 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v17;
    uint64_t v17 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t v13 = v16;
  uint64_t v16 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v14 = v18;
  uint64_t v18 = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  return a1;
}

void sub_1DD25E420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[16];
  v12[16] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25E4B8(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to LongVectorBatch");
LABEL_22:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878A18, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to IntegerColumnStatisticsImpl");
    goto LABEL_22;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  unsigned int v15 = (uint64_t *)(v11[12] + 8 * a3);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v16 = (unsigned char *)(v11[5] + a3);
  }
  else {
    uint64_t v16 = 0;
  }
  (*(void (**)(void, uint64_t *, unint64_t, unsigned char *))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v15, a4, v16);
  unint64_t v17 = 0;
  if (a4)
  {
    unint64_t v18 = a4;
    uint64_t v19 = v16;
    do
    {
      if (!v16 || *v19)
      {
        if (*(unsigned char *)(a1 + 80)) {
          sub_1DD25165C(*(void *)(a1 + 88), *v15);
        }
        ++v17;
        sub_1DD27E75C(v14, *v15, 1);
      }
      ++v19;
      ++v15;
      --v18;
    }
    while (v18);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v17);
  if (v17 < a4)
  {
    uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 104);
    return v21(v14, 1);
  }
  return result;
}

void sub_1DD25E754(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25E76C(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v9);
  uint64_t v4 = *(void *)(a1 + 16);
  int v11 = 1;
  int v12 = v4;
  v10 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128));
  v10 |= 4u;
  uint64_t v13 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD243030(v9);
}

void sub_1DD25E838(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25E858(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 128) + 8) + 64))(*(void *)(*(void *)(a1 + 128) + 8))
       + v2;
}

void *sub_1DD25E8D4(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v9);
  int v4 = sub_1DD25BCDC(*(unsigned int *)(a1 + 136));
  int v5 = v10;
  int v11 = v4;
  int v12 = 0;
  v10 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v10 = v5 | 7;
    int v13 = 1;
  }
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD269130(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD243878(a2[1], v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD24387C(v9);
}

void sub_1DD25E97C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25E99C(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 128) + 32);
  return v2();
}

uint64_t sub_1DD25EA20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v6 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  void *v6 = &unk_1F3879A78;
  v6[16] = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v16, a3, 1);
  uint64_t v7 = v16;
  uint64_t v16 = 0;
  uint64_t v14 = v7;
  sub_1DD252448(&v14, &v15);
  uint64_t v8 = v15;
  uint64_t v15 = 0;
  uint64_t v9 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    uint64_t v10 = v15;
    uint64_t v15 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  uint64_t v11 = v14;
  uint64_t v14 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v12 = v16;
  uint64_t v16 = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  return a1;
}

void sub_1DD25EBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[16];
  v12[16] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25EC48(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to LongVectorBatch");
LABEL_27:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (int v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878A18, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to IntegerColumnStatisticsImpl");
    goto LABEL_27;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v15 = v11[12] + 8 * a3;
  if (*((unsigned char *)v11 + 64))
  {
    uint64_t v16 = v11[5] + a3;
    if (!a4) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v16 = 0;
    if (!a4) {
      goto LABEL_10;
    }
  }
  uint64_t v17 = 0;
  do
  {
    *(unsigned char *)(v15 + v17) = *(void *)(v15 + 8 * v17);
    ++v17;
  }
  while (a4 != v17);
LABEL_10:
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v15, a4, v16);
  if (a4)
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      if (!v16 || *(unsigned char *)(v16 + v18))
      {
        if (*(unsigned char *)(a1 + 80)) {
          sub_1DD25165C(*(void *)(a1 + 88), *(void *)(v15 + 8 * v18));
        }
        ++v19;
        sub_1DD27E75C(v14, *(char *)(v15 + v18), 1);
      }
      ++v18;
    }
    while (a4 != v18);
  }
  else
  {
    unint64_t v19 = 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v19);
  if (v19 < a4)
  {
    uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 104);
    return v21(v14, 1);
  }
  return result;
}

void sub_1DD25EF04(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25EF1C(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v9);
  uint64_t v4 = *(void *)(a1 + 16);
  int v11 = 1;
  int v12 = v4;
  v10 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 32))(*(void *)(a1 + 128));
  v10 |= 4u;
  uint64_t v13 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD243030(v9);
}

void sub_1DD25EFE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25F008(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128)) + v2;
}

void *sub_1DD25F080(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v8);
  int v4 = v9;
  uint64_t v10 = 0;
  v9 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v9 = v4 | 7;
    int v11 = 1;
  }
  unint64_t v5 = a2[1];
  if (v5 >= a2[2])
  {
    uint64_t v6 = sub_1DD269130(a2, (uint64_t)v8);
  }
  else
  {
    sub_1DD243878(a2[1], v8);
    uint64_t v6 = v5 + 40;
    a2[1] = v5 + 40;
  }
  a2[1] = v6;
  return sub_1DD24387C(v8);
}

void sub_1DD25F120(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25F140(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 128) + 40);
  return v2();
}

uint64_t sub_1DD25F1C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  void *v6 = &unk_1F387A3C0;
  v6[16] = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v16, a3, 1);
  uint64_t v7 = v16;
  uint64_t v16 = 0;
  uint64_t v14 = v7;
  sub_1DD252790(&v14, &v15);
  uint64_t v8 = v15;
  uint64_t v15 = 0;
  uint64_t v9 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    uint64_t v10 = v15;
    uint64_t v15 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  uint64_t v11 = v14;
  uint64_t v14 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v12 = v16;
  uint64_t v16 = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  return a1;
}

void sub_1DD25F358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[16];
  v12[16] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25F3EC(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to LongVectorBatch");
LABEL_28:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38789A8, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to BooleanColumnStatisticsImpl");
    goto LABEL_28;
  }
  uint64_t v14 = v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v15 = v11[12] + 8 * a3;
  if (*((unsigned char *)v11 + 64))
  {
    uint64_t v16 = v11[5] + a3;
    if (!a4) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v16 = 0;
    if (!a4) {
      goto LABEL_10;
    }
  }
  uint64_t v17 = 0;
  do
  {
    *(unsigned char *)(v15 + v17) = *(void *)(v15 + 8 * v17);
    ++v17;
  }
  while (a4 != v17);
LABEL_10:
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v15, a4, v16);
  if (a4)
  {
    uint64_t v18 = 0;
    unint64_t v19 = 0;
    do
    {
      if (!v16 || *(unsigned char *)(v16 + v18))
      {
        if (*(unsigned char *)(a1 + 80)) {
          sub_1DD25165C(*(void *)(a1 + 88), *(void *)(v15 + 8 * v18));
        }
        ++v19;
        if (*(unsigned char *)(v15 + v18)) {
          ++v14[7];
        }
      }
      ++v18;
    }
    while (a4 != v18);
  }
  else
  {
    unint64_t v19 = 0;
  }
  uint64_t result = (*(uint64_t (**)(void *, unint64_t))(*v14 + 64))(v14, v19);
  if (v19 < a4)
  {
    uint64_t v21 = *(uint64_t (**)(void *, uint64_t))(*v14 + 80);
    return v21(v14, 1);
  }
  return result;
}

void sub_1DD25F6AC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25F6C4(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v9);
  uint64_t v4 = *(void *)(a1 + 16);
  int v11 = 1;
  int v12 = v4;
  v10 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 32))(*(void *)(a1 + 128));
  v10 |= 4u;
  uint64_t v13 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD243030(v9);
}

void sub_1DD25F790(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25F7B0(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  return (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128)) + v2;
}

void *sub_1DD25F828(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v8);
  int v4 = v9;
  uint64_t v10 = 0;
  v9 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v9 = v4 | 7;
    int v11 = 1;
  }
  unint64_t v5 = a2[1];
  if (v5 >= a2[2])
  {
    uint64_t v6 = sub_1DD269130(a2, (uint64_t)v8);
  }
  else
  {
    sub_1DD243878(a2[1], v8);
    uint64_t v6 = v5 + 40;
    a2[1] = v5 + 40;
  }
  a2[1] = v6;
  return sub_1DD24387C(v8);
}

void sub_1DD25F8C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25F8E8(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 128) + 40);
  return v2();
}

unsigned char *sub_1DD25F96C(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v9 = sub_1DD25BD54((uint64_t)a1, a2, a3, a4);
  *(void *)uint64_t v9 = &unk_1F387A168;
  *(unsigned char *)(v9 + 128) = a5;
  *(void *)(v9 + 136) = 0;
  uint64_t v10 = (uint64_t **)(v9 + 136);
  uint64_t v11 = sub_1DD291588(a4);
  sub_1DD26FA14(a1 + 144, v11);
  int v12 = (uint64_t *)operator new(0x18uLL);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v18, a3, 1);
  uint64_t v13 = v18;
  uint64_t v18 = 0;
  v12[1] = 0;
  v12[2] = 0;
  uint64_t *v12 = v13;
  uint64_t v14 = *v10;
  void *v10 = v12;
  if (v14)
  {
    sub_1DD269308((int)v10, v14);
    uint64_t v15 = v18;
    uint64_t v18 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  if (a1[128]) {
    unint64_t v16 = 4;
  }
  else {
    unint64_t v16 = 8;
  }
  sub_1DD26F9D0((uint64_t)(a1 + 144), v16);
  if (a1[48]) {
    (*(void (**)(unsigned char *))(*(void *)a1 + 104))(a1);
  }
  return a1;
}

void sub_1DD25FAD8(_Unwind_Exception *a1)
{
  operator delete(v4);
  sub_1DD2701B4(v3);
  uint64_t v6 = *v2;
  *uint64_t v2 = 0;
  if (v6) {
    sub_1DD269308((int)v2, v6);
  }
  sub_1DD25C64C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25FB20(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878290, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to DoubleVectorBatch");
LABEL_34:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  int v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = (char *)__dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878938, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to DoubleColumnStatisticsImpl");
    goto LABEL_34;
  }
  uint64_t v14 = v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v15 = (unsigned char *)(v11[5] + a3);
  }
  else {
    uint64_t v15 = 0;
  }
  if (*(unsigned char *)(a1 + 128)) {
    unint64_t v16 = 4;
  }
  else {
    unint64_t v16 = 8;
  }
  unint64_t v29 = a4;
  unint64_t v17 = 0;
  if (a4)
  {
    uint64_t v18 = (const double *)(v11[12] + 8 * a3);
    unint64_t v19 = *(int8x8_t **)(a1 + 160);
    unint64_t v20 = v15;
    do
    {
      if (v15 && !*v20) {
        goto LABEL_26;
      }
      if (*(unsigned char *)(a1 + 128))
      {
        double v21 = *v18;
        *(float *)&double v21 = *v18;
        int16x8_t v22 = (int16x8_t)vshlq_s32(vdupq_lane_s32(*(int32x2_t *)&v21, 0), (int32x4_t)xmmword_1DD31FB30);
        *(int16x4_t *)v22.i8 = vmovn_s32((int32x4_t)v22);
        v19->i32[0] = vmovn_s16(v22).u32[0];
      }
      else
      {
        int64x2_t v23 = (int64x2_t)vld1q_dup_f64(v18);
        *unint64_t v19 = vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_s64(v23, (int64x2_t)xmmword_1DD31FB50), (int32x4_t)vshlq_s64(v23, (int64x2_t)xmmword_1DD31FB40)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_s64(v23, (int64x2_t)xmmword_1DD31FB70), (int32x4_t)vshlq_s64(v23, (int64x2_t)xmmword_1DD31FB60))));
      }
      sub_1DD23A564(*(char **)(a1 + 136), (uint64_t)v19, v16);
      if (*(unsigned char *)(a1 + 80)) {
        sub_1DD2518D8(*(void *)(a1 + 88), *v18);
      }
      double v24 = *v18;
      if (v14[17])
      {
        uint64_t v25 = (double *)(v14 + 40);
        if (*((double *)v14 + 5) <= v24)
        {
          uint64_t v25 = (double *)(v14 + 48);
          if (*((double *)v14 + 6) >= v24) {
            goto LABEL_25;
          }
        }
      }
      else
      {
        *(_WORD *)(v14 + 17) = 257;
        *((double *)v14 + 6) = v24;
        uint64_t v25 = (double *)(v14 + 40);
      }
      *uint64_t v25 = v24;
LABEL_25:
      ++v17;
      *((double *)v14 + 7) = v24 + *((double *)v14 + 7);
LABEL_26:
      ++v18;
      ++v20;
      --a4;
    }
    while (a4);
  }
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(*(void *)v14 + 88))(v14, v17);
  if (v17 < v29)
  {
    uint64_t v27 = *(uint64_t (**)(char *, uint64_t))(*(void *)v14 + 104);
    return v27(v14, 1);
  }
  return result;
}

void sub_1DD25FEB0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD25FEC8(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v9);
  uint64_t v4 = *(void *)(a1 + 16);
  int v11 = 1;
  int v12 = v4;
  v10 |= 3u;
  uint64_t v5 = sub_1DD23A6B4(*(void **)(a1 + 136));
  v10 |= 4u;
  uint64_t v13 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD243030(v9);
}

void sub_1DD25FF74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD25FF94(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  return sub_1DD23A68C(*(void *)(a1 + 136)) + v2;
}

void *sub_1DD25FFEC(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v8);
  int v4 = v9;
  uint64_t v10 = 0;
  v9 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v9 = v4 | 7;
    int v11 = 1;
  }
  unint64_t v5 = a2[1];
  if (v5 >= a2[2])
  {
    uint64_t v6 = sub_1DD269130(a2, (uint64_t)v8);
  }
  else
  {
    sub_1DD243878(a2[1], v8);
    uint64_t v6 = v5 + 40;
    a2[1] = v5 + 40;
  }
  a2[1] = v6;
  return sub_1DD24387C(v8);
}

void sub_1DD26008C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2600AC(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(int **)(a1 + 136);
  uint64_t v3 = *(void *)(a1 + 72);
  return sub_1DD23A73C(v2, v3);
}

uint64_t sub_1DD260110(uint64_t a1, void *a2, size_t a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  __n128 __p = a2;
  size_t v11 = a3;
  uint64_t v12 = v6;
  uint64_t v7 = sub_1DD269374((uint64_t **)a1, (uint64_t)&__p, (uint64_t)&__p);
  if (v8)
  {
    sub_1DD2696CC(&__p, a3);
    sub_1DD2601EC((uint64_t *)(a1 + 24), (uint64_t)&__p);
    if (__p)
    {
      size_t v11 = (size_t)__p;
      operator delete(__p);
    }
    memcpy(*(void **)(*(void *)(a1 + 32) - 24), a2, a3);
    *((void *)v7 + 4) = *(void *)(*(void *)(a1 + 32) - 24);
    *(void *)(a1 + 48) += a3;
  }
  return *((void *)v7 + 6);
}

void sub_1DD2601D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD2601EC(uint64_t *a1, uint64_t a2)
{
  unint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  unint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_1DD251DAC();
    }
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10) {
      unint64_t v10 = 2 * v11;
    }
    if (v11 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v10;
    }
    v16[4] = result;
    uint64_t v13 = (char *)sub_1DD2697FC(result, v12);
    uint64_t v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = 0;
    *(void *)uint64_t v14 = 0;
    *(_OWORD *)uint64_t v14 = *(_OWORD *)a2;
    *((void *)v14 + 2) = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    sub_1DD269784(a1, v16);
    char v8 = (void *)a1[1];
    uint64_t result = sub_1DD269968((uint64_t)v16);
  }
  else
  {
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
    v7[2] = *(void *)(a2 + 16);
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    char v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1DD260318(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD269968((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1DD26032C(void *result, char *a2, uint64_t a3)
{
  uint64_t v3 = result + 1;
  int v4 = (void *)*result;
  if ((void *)*result != result + 1)
  {
    do
    {
      sub_1DD23A564(a2, v4[4], v4[5]);
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 40))(a3, v4[5]);
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          char v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          int v4 = v8;
        }
        while (!v9);
      }
      int v4 = v8;
    }
    while (v8 != v3);
  }
  return result;
}

void sub_1DD2603D8(void *a1, uint64_t a2)
{
  sub_1DD2699FC(__p, a1[2]);
  int v4 = (void *)*a1;
  unint64_t v5 = __p[0];
  if ((void *)*a1 != a1 + 1)
  {
    uint64_t v6 = 0;
    do
    {
      v5[v4[6]] = v6;
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          char v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          char v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          int v4 = v8;
        }
        while (!v9);
      }
      ++v6;
      int v4 = v8;
    }
    while (v8 != a1 + 1);
  }
  unint64_t v10 = *(void **)a2;
  uint64_t v11 = *(void *)(a2 + 8) - *(void *)a2;
  if (v11)
  {
    uint64_t v12 = v11 >> 3;
    do
    {
      void *v10 = v5[*v10];
      ++v10;
      --v12;
    }
    while (v12);
  }
  else if (!v5)
  {
    return;
  }
  __p[1] = v5;
  operator delete(v5);
}

void sub_1DD2604A0(void *a1, void *a2)
{
  sub_1DD2599E0((uint64_t)a2, a1[2]);
  int v4 = (void *)*a1;
  if ((void *)*a1 != a1 + 1)
  {
    do
    {
      *(void *)(*a2 + 8 * v4[6]) = v4 + 4;
      unint64_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          uint64_t v6 = v5;
          unint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          int v4 = v6;
        }
        while (!v7);
      }
      int v4 = v6;
    }
    while (v6 != a1 + 1);
  }
}

uint64_t sub_1DD260528(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_1DD25BD54(a1, a2, a3, a4) = &unk_1F387A220;
  *(_DWORD *)(a1 + 128) = sub_1DD2913FC(a4);
  *(unsigned char *)(a1 + 132) = sub_1DD29155C(a4) != 0;
  *(void *)(a1 + 136) = a3;
  BOOL v8 = sub_1DD291574(a4);
  *(_OWORD *)(a1 + 152) = 0u;
  *(unsigned char *)(a1 + 144) = v8;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 257) = 0u;
  *(unsigned char *)(a1 + 273) = sub_1DD2915A0(a4);
  *(double *)(a1 + 280) = sub_1DD2914B8(a4);
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 288) = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 32))(a2) == 8)
  {
    *(_WORD *)(a1 + 272) = 1;
  }
  else if (*(unsigned char *)(a1 + 273))
  {
    sub_1DD26079C(a1);
    goto LABEL_6;
  }
  *(unsigned char *)(a1 + 272) = 1;
  sub_1DD260B48(a1);
LABEL_6:
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  return a1;
}

void sub_1DD2606A4(_Unwind_Exception *a1)
{
  sub_1DD260D84(v3);
  uint64_t v6 = *v2;
  *uint64_t v2 = 0;
  if (v6) {
    sub_1DD269308((int)v2, v6);
  }
  uint64_t v7 = v1[22];
  v1[22] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  BOOL v8 = (uint64_t **)(v4 + 1);
  uint64_t v9 = v1[21];
  v1[21] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  unint64_t v10 = *v8;
  *BOOL v8 = 0;
  if (v10) {
    sub_1DD269308(v4 + 8, v10);
  }
  uint64_t v11 = *v4;
  *int v4 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  sub_1DD25C64C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26079C(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 136) + 16))(&v25);
  uint64_t v2 = v25;
  uint64_t v25 = 0;
  uint64_t v23 = v2;
  sub_1DD27D3B4(&v23, 0, *(_DWORD *)(a1 + 128), *(unsigned __int8 *)(a1 + 144), &v24);
  uint64_t v3 = v24;
  uint64_t v24 = 0;
  uint64_t v4 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = v3;
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    uint64_t v5 = v24;
    uint64_t v24 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  uint64_t v6 = v23;
  uint64_t v23 = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 136) + 16))(&v24);
  uint64_t v7 = v24;
  uint64_t v24 = 0;
  uint64_t v21 = v7;
  sub_1DD27D3B4(&v21, 0, *(_DWORD *)(a1 + 128), *(unsigned __int8 *)(a1 + 144), &v22);
  uint64_t v8 = v22;
  uint64_t v22 = 0;
  uint64_t v9 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    uint64_t v10 = v22;
    uint64_t v22 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  uint64_t v11 = v21;
  uint64_t v21 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = operator new(0x18uLL);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 136) + 16))(&v20);
  uint64_t v13 = v20;
  uint64_t v20 = 0;
  v12[1] = 0;
  v12[2] = 0;
  void *v12 = v13;
  unint64_t v16 = *(uint64_t **)(a1 + 184);
  uint64_t v15 = (void *)(a1 + 184);
  uint64_t v14 = v16;
  *uint64_t v15 = v12;
  if (v16)
  {
    sub_1DD269308((int)v15, v14);
    uint64_t v17 = v20;
    uint64_t v20 = 0;
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
  }
  uint64_t v18 = v24;
  uint64_t v24 = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t result = v25;
  uint64_t v25 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1DD260A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8))(a13);
  }
  uint64_t v16 = *(void *)(v14 - 24);
  *(void *)(v14 - 24) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD260B48(uint64_t a1)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 136) + 16))(&v17);
  uint64_t v2 = v17;
  uint64_t v17 = 0;
  uint64_t v15 = v2;
  sub_1DD27D3B4(&v15, 0, *(_DWORD *)(a1 + 128), *(unsigned __int8 *)(a1 + 144), &v16);
  uint64_t v3 = v16;
  uint64_t v16 = 0;
  uint64_t v4 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = v3;
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    uint64_t v5 = v16;
    uint64_t v16 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
  }
  uint64_t v6 = v15;
  uint64_t v15 = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = operator new(0x18uLL);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 136) + 16))(&v14);
  uint64_t v8 = v14;
  uint64_t v14 = 0;
  v7[1] = 0;
  v7[2] = 0;
  void *v7 = v8;
  uint64_t v11 = *(uint64_t **)(a1 + 160);
  uint64_t v10 = (void *)(a1 + 160);
  uint64_t v9 = v11;
  void *v10 = v7;
  if (v11)
  {
    sub_1DD269308((int)v10, v9);
    uint64_t v12 = v14;
    uint64_t v14 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t result = v17;
  uint64_t v17 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1DD260D20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  operator delete(v12);
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD260D84(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    *(void *)(a1 + 64) = v2;
    operator delete(v2);
  }
  uint64_t v4 = (void **)(a1 + 24);
  sub_1DD2685EC(&v4);
  sub_1DD268698(a1, *(void **)(a1 + 8));
  return a1;
}

uint64_t sub_1DD260DDC(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringVectorBatch");
LABEL_46:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  uint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878970, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringColumnStatisticsImpl");
    goto LABEL_46;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v38 = v11[17] + 8 * a3;
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v15 = v11[5] + a3;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = v11[12];
  if (*(unsigned char *)(a1 + 273))
  {
    if (a4) {
      goto LABEL_9;
    }
LABEL_37:
    unint64_t v18 = 0;
    goto LABEL_38;
  }
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), v38, a4, v15);
  if (!a4) {
    goto LABEL_37;
  }
LABEL_9:
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v37 = (void **)(a1 + 248);
  uint64_t v19 = v16 + 8 * a3;
  do
  {
    if (!v15 || *(unsigned char *)(v15 + v17))
    {
      size_t v20 = *(void *)(v38 + 8 * v17);
      if (*(unsigned char *)(a1 + 273))
      {
        uint64_t v21 = sub_1DD260110(a1 + 192, *(void **)(v19 + 8 * v17), *(void *)(v38 + 8 * v17));
        uint64_t v22 = v21;
        uint64_t v24 = *(uint64_t **)(a1 + 256);
        unint64_t v23 = *(void *)(a1 + 264);
        if ((unint64_t)v24 >= v23)
        {
          uint64_t v26 = (uint64_t *)*v37;
          uint64_t v27 = ((char *)v24 - (unsigned char *)*v37) >> 3;
          unint64_t v28 = v27 + 1;
          if ((unint64_t)(v27 + 1) >> 61) {
            sub_1DD251DAC();
          }
          uint64_t v29 = v23 - (void)v26;
          if (v29 >> 2 > v28) {
            unint64_t v28 = v29 >> 2;
          }
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v30 = v28;
          }
          if (v30)
          {
            long long v31 = (char *)sub_1DD251DC4(a1 + 264, v30);
            uint64_t v26 = *(uint64_t **)(a1 + 248);
            uint64_t v24 = *(uint64_t **)(a1 + 256);
          }
          else
          {
            long long v31 = 0;
          }
          uint64_t v32 = (uint64_t *)&v31[8 * v27];
          *uint64_t v32 = v22;
          uint64_t v25 = v32 + 1;
          while (v24 != v26)
          {
            uint64_t v33 = *--v24;
            *--uint64_t v32 = v33;
          }
          *(void *)(a1 + 248) = v32;
          *(void *)(a1 + 256) = v25;
          *(void *)(a1 + 264) = &v31[8 * v30];
          if (v26) {
            operator delete(v26);
          }
        }
        else
        {
          uint64_t *v24 = v21;
          uint64_t v25 = v24 + 1;
        }
        *(void *)(a1 + 256) = v25;
      }
      else
      {
        sub_1DD23A564(*(char **)(a1 + 160), *(void *)(v19 + 8 * v17), *(void *)(v38 + 8 * v17));
      }
      if (*(unsigned char *)(a1 + 80)) {
        sub_1DD2515A8(*(void *)(a1 + 88), *(uint64_t **)(v19 + 8 * v17), v20);
      }
      sub_1DD2611C0(v14, *(char **)(v19 + 8 * v17), v20);
      ++v18;
    }
    ++v17;
  }
  while (v17 != a4);
LABEL_38:
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v18);
  if (v18 < a4)
  {
    uint64_t v35 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 104);
    return v35(v14, 1);
  }
  return result;
}

void sub_1DD2611A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD2611C0(uint64_t a1, char *__s2, size_t a3)
{
  unint64_t v3 = a3;
  if (__s2)
  {
    if (*(unsigned char *)(a1 + 17))
    {
      unint64_t v6 = *(unsigned __int8 *)(a1 + 63);
      if (*(char *)(a1 + 63) < 0)
      {
        uint64_t v7 = *(const char **)(a1 + 40);
        size_t v8 = *(void *)(a1 + 48);
      }
      else
      {
        uint64_t v7 = (const char *)(a1 + 40);
        size_t v8 = *(unsigned __int8 *)(a1 + 63);
      }
      if (v8 < a3) {
        a3 = v8;
      }
      int v9 = strncmp(v7, __s2, a3);
      if (v9 > 0) {
        goto LABEL_11;
      }
      if (!v9)
      {
        if ((v6 & 0x80) != 0) {
          unint64_t v6 = *(void *)(a1 + 48);
        }
        if (v6 > v3)
        {
LABEL_11:
          sub_1DD268814(__p, __s2, &__s2[v3], v3);
          sub_1DD2686EC(a1, (uint64_t)__p);
          if (v19 < 0) {
            operator delete(__p[0]);
          }
        }
      }
      unint64_t v10 = *(unsigned __int8 *)(a1 + 87);
      if (*(char *)(a1 + 87) < 0)
      {
        uint64_t v11 = *(const char **)(a1 + 64);
        size_t v12 = *(void *)(a1 + 72);
      }
      else
      {
        uint64_t v11 = (const char *)(a1 + 64);
        size_t v12 = *(unsigned __int8 *)(a1 + 87);
      }
      if (v12 >= v3) {
        size_t v13 = v3;
      }
      else {
        size_t v13 = v12;
      }
      int v14 = strncmp(v11, __s2, v13);
      if (v14 < 0) {
        goto LABEL_45;
      }
      if (!v14)
      {
        if ((v10 & 0x80) != 0) {
          unint64_t v10 = *(void *)(a1 + 72);
        }
        if (v10 < v3)
        {
LABEL_45:
          sub_1DD268814(v16, __s2, &__s2[v3], v3);
          sub_1DD268780(a1, (uint64_t)v16);
          if (v17 < 0)
          {
            uint64_t v15 = (void *)v16[0];
LABEL_41:
            operator delete(v15);
          }
        }
      }
    }
    else
    {
      sub_1DD268814(&v24, __s2, &__s2[a3], a3);
      if (SHIBYTE(v25) < 0)
      {
        sub_1DD24F980(__dst, (void *)v24, *((unint64_t *)&v24 + 1));
      }
      else
      {
        *(_OWORD *)long long __dst = v24;
        uint64_t v23 = v25;
      }
      sub_1DD2686EC(a1, (uint64_t)__dst);
      if (SHIBYTE(v23) < 0) {
        operator delete(__dst[0]);
      }
      if (SHIBYTE(v25) < 0)
      {
        sub_1DD24F980(v20, (void *)v24, *((unint64_t *)&v24 + 1));
      }
      else
      {
        *(_OWORD *)size_t v20 = v24;
        uint64_t v21 = v25;
      }
      sub_1DD268780(a1, (uint64_t)v20);
      if (SHIBYTE(v21) < 0) {
        operator delete(v20[0]);
      }
      if (SHIBYTE(v25) < 0)
      {
        uint64_t v15 = (void *)v24;
        goto LABEL_41;
      }
    }
  }
  *(void *)(a1 + 24) += v3;
}

void sub_1DD2613B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v33 - 33) < 0) {
    operator delete(*(void **)(v33 - 56));
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD261420(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  if (*(unsigned char *)(a1 + 273))
  {
    sub_1DD242F9C(v35);
    uint64_t v4 = *(void *)(a1 + 16);
    int v37 = 1;
    int v38 = v4;
    v36 |= 3u;
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 168) + 24))(*(void *)(a1 + 168));
    v36 |= 4u;
    uint64_t v39 = v5;
    unint64_t v6 = a2[1];
    if (v6 >= a2[2])
    {
      uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v35);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v35);
      uint64_t v7 = v6 + 40;
      a2[1] = v6 + 40;
    }
    a2[1] = v7;
    sub_1DD242F9C(v30);
    uint64_t v12 = *(void *)(a1 + 16);
    int v32 = 3;
    int v33 = v12;
    v31 |= 3u;
    uint64_t v13 = sub_1DD23A6B4(*(void **)(a1 + 184));
    v31 |= 4u;
    uint64_t v34 = v13;
    unint64_t v14 = a2[1];
    if (v14 >= a2[2])
    {
      uint64_t v15 = sub_1DD268EA4(a2, (uint64_t)v30);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v30);
      uint64_t v15 = v14 + 40;
      a2[1] = v14 + 40;
    }
    a2[1] = v15;
    sub_1DD242F9C(v25);
    uint64_t v16 = *(void *)(a1 + 16);
    int v27 = 2;
    int v28 = v16;
    v26 |= 3u;
    uint64_t v17 = (*(uint64_t (**)(void))(**(void **)(a1 + 176) + 24))(*(void *)(a1 + 176));
    v26 |= 4u;
    uint64_t v29 = v17;
    unint64_t v18 = a2[1];
    if (v18 >= a2[2])
    {
      uint64_t v19 = sub_1DD268EA4(a2, (uint64_t)v25);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v25);
      uint64_t v19 = v18 + 40;
      a2[1] = v18 + 40;
    }
    a2[1] = v19;
    sub_1DD243030(v25);
  }
  else
  {
    sub_1DD242F9C(v35);
    uint64_t v8 = *(void *)(a1 + 16);
    int v37 = 2;
    int v38 = v8;
    v36 |= 3u;
    uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
    v36 |= 4u;
    uint64_t v39 = v9;
    unint64_t v10 = a2[1];
    if (v10 >= a2[2])
    {
      uint64_t v11 = sub_1DD268EA4(a2, (uint64_t)v35);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v35);
      uint64_t v11 = v10 + 40;
      a2[1] = v10 + 40;
    }
    a2[1] = v11;
    sub_1DD242F9C(v30);
    uint64_t v20 = *(void *)(a1 + 16);
    int v32 = 1;
    int v33 = v20;
    v31 |= 3u;
    uint64_t v21 = sub_1DD23A6B4(*(void **)(a1 + 160));
    v31 |= 4u;
    uint64_t v34 = v21;
    unint64_t v22 = a2[1];
    if (v22 >= a2[2])
    {
      uint64_t v23 = sub_1DD268EA4(a2, (uint64_t)v30);
    }
    else
    {
      sub_1DD24302C(a2[1], (uint64_t)v30);
      uint64_t v23 = v22 + 40;
      a2[1] = v22 + 40;
    }
    a2[1] = v23;
  }
  sub_1DD243030(v30);
  return sub_1DD243030(v35);
}

void sub_1DD2616F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  *(void *)(v7 + 8) = v8;
  sub_1DD243030((uint64_t *)va);
  sub_1DD243030((void *)(v9 - 72));
  _Unwind_Resume(a1);
}

unint64_t sub_1DD26176C(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = v2;
  if (*(unsigned char *)(a1 + 273))
  {
    if (*(unsigned char *)(a1 + 132)) {
      return (*(void *)(a1 + 240)
    }
            + v2
            + 4 * *(void *)(a1 + 208)
            + ((uint64_t)(*(void *)(a1 + 256) - *(void *)(a1 + 248)) >> 1))
           / 3uLL;
    else {
      return *(void *)(a1 + 240)
    }
           + v2
           + 4 * *(void *)(a1 + 208)
           + ((uint64_t)(*(void *)(a1 + 256) - *(void *)(a1 + 248)) >> 1);
  }
  else
  {
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 152) + 8) + 64))(*(void *)(*(void *)(a1 + 152) + 8));
    return v5 + v3 + sub_1DD23A68C(*(void *)(a1 + 160));
  }
}

void *sub_1DD261844(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v15);
  int v4 = *(_DWORD *)(a1 + 128);
  BOOL v5 = v4 == 0;
  BOOL v6 = v4 != 0;
  int v7 = v16;
  int v8 = 2 * v6;
  if (v5) {
    int v9 = 1;
  }
  else {
    int v9 = 3;
  }
  if (*(unsigned char *)(a1 + 273)) {
    int v10 = v9;
  }
  else {
    int v10 = v8;
  }
  uint64_t v11 = *(void *)(a1 + 208);
  int v17 = v10;
  int v18 = v11;
  v16 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v16 = v7 | 7;
    int v19 = 1;
  }
  unint64_t v12 = a2[1];
  if (v12 >= a2[2])
  {
    uint64_t v13 = sub_1DD269130(a2, (uint64_t)v15);
  }
  else
  {
    sub_1DD243878(a2[1], v15);
    uint64_t v13 = v12 + 40;
    a2[1] = v12 + 40;
  }
  a2[1] = v13;
  return sub_1DD24387C(v15);
}

void sub_1DD26190C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1DD26192C(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  if (*(unsigned char *)(a1 + 273))
  {
    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v2 = (uint64_t)(*(void *)(a1 + 256) - *(void *)(a1 + 248)) >> 3;
      uint64_t v3 = *(uint64_t **)(a1 + 296);
      unint64_t v4 = *(void *)(a1 + 304);
      if ((unint64_t)v3 >= v4)
      {
        int v7 = *(uint64_t **)(a1 + 288);
        uint64_t v8 = v3 - v7;
        if ((unint64_t)(v8 + 1) >> 61) {
          sub_1DD251DAC();
        }
        unint64_t v9 = v4 - (void)v7;
        unint64_t v10 = (uint64_t)(v4 - (void)v7) >> 2;
        if (v10 <= v8 + 1) {
          unint64_t v10 = v8 + 1;
        }
        if (v9 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v11 = v10;
        }
        if (v11)
        {
          unint64_t v12 = (char *)sub_1DD251DC4(a1 + 304, v11);
          int v7 = *(uint64_t **)(a1 + 288);
          uint64_t v3 = *(uint64_t **)(a1 + 296);
        }
        else
        {
          unint64_t v12 = 0;
        }
        uint64_t v13 = (uint64_t *)&v12[8 * v8];
        unint64_t v14 = &v12[8 * v11];
        *uint64_t v13 = v2;
        BOOL v5 = v13 + 1;
        while (v3 != v7)
        {
          uint64_t v15 = *--v3;
          *--uint64_t v13 = v15;
        }
        *(void *)(a1 + 288) = v13;
        *(void *)(a1 + 296) = v5;
        *(void *)(a1 + 304) = v14;
        if (v7) {
          operator delete(v7);
        }
      }
      else
      {
        uint64_t *v3 = v2;
        BOOL v5 = v3 + 1;
      }
      *(void *)(a1 + 296) = v5;
    }
  }
  else
  {
    sub_1DD23A73C(*(int **)(a1 + 160), *(void *)(a1 + 72));
    BOOL v6 = *(void (**)(void))(**(void **)(a1 + 152) + 32);
    v6();
  }
}

BOOL sub_1DD261AA0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 272)) {
    return *(unsigned char *)(a1 + 273) != 0;
  }
  BOOL v1 = *(void *)(a1 + 208) <= (unint64_t)(*(double *)(a1 + 280)
                                                 * (double)(unint64_t)((uint64_t)(*(void *)(a1 + 256)
                                                                                      - *(void *)(a1 + 248)) >> 3));
  *(unsigned char *)(a1 + 273) = v1;
  *(unsigned char *)(a1 + 272) = 1;
  return v1;
}

uint64_t sub_1DD261AF4(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 273) && !*(unsigned char *)(a1 + 272) && !sub_1DD261AA0(a1)) {
    sub_1DD261B4C(a1);
  }
  return sub_1DD25CBB8(a1);
}

void sub_1DD261B4C(uint64_t a1)
{
  sub_1DD260B48(a1);
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(void **)(a1 + 64);
    __n128 __p = &unk_1F387B098;
    int v7 = v2;
    sub_1DD23A73C(*(int **)(a1 + 160), (uint64_t)&__p);
    (*(void (**)(void, void **))(**(void **)(a1 + 152) + 32))(*(void *)(a1 + 152), &__p);
    nullsub_1(&__p);
  }
  __n128 __p = 0;
  int v7 = 0;
  uint64_t v8 = 0;
  sub_1DD2604A0((void *)(a1 + 192), &__p);
  uint64_t v3 = *(void *)(a1 + 248);
  if (*(void *)(a1 + 256) != v3)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *((void *)__p + *(void *)(v3 + 8 * v4));
      sub_1DD23A564(*(char **)(a1 + 160), *(void *)v5, *(void *)(v5 + 8));
      (*(void (**)(void, void))(**(void **)(a1 + 152) + 40))(*(void *)(a1 + 152), *(void *)(v5 + 8));
      ++v4;
      uint64_t v3 = *(void *)(a1 + 248);
    }
    while (v4 != (*(void *)(a1 + 256) - v3) >> 3);
  }
  sub_1DD261D8C((void *)a1);
  if (__p)
  {
    int v7 = __p;
    operator delete(__p);
  }
}

void sub_1DD261C80(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD261CB0(uint64_t a1)
{
  sub_1DD25D074(a1);
  *(void *)(a1 + 240) = 0;
  sub_1DD268640((uint64_t *)(a1 + 216));
  sub_1DD268698(a1 + 192, *(void **)(a1 + 200));
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  sub_1DD259A10(a1 + 248, 0);
  uint64_t v2 = *(void **)(a1 + 288);
  *(void *)(a1 + 296) = v2;
  unint64_t v3 = *(void *)(a1 + 304);
  if ((unint64_t)v2 >= v3)
  {
    uint64_t v5 = v3 - (void)v2;
    uint64_t v6 = v5 >> 2;
    if ((unint64_t)(v5 >> 2) <= 1) {
      uint64_t v6 = 1;
    }
    if ((unint64_t)v5 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v7 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v7 = v6;
    }
    uint64_t v8 = sub_1DD251DC4(a1 + 304, v7);
    unint64_t v9 = *(char **)(a1 + 288);
    unint64_t v10 = *(char **)(a1 + 296);
    unint64_t v12 = &v8[v11];
    *uint64_t v8 = 0;
    uint64_t v4 = v8 + 1;
    while (v10 != v9)
    {
      uint64_t v13 = *((void *)v10 - 1);
      v10 -= 8;
      *--uint64_t v8 = v13;
    }
    *(void *)(a1 + 288) = v8;
    *(void *)(a1 + 296) = v4;
    *(void *)(a1 + 304) = v12;
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *uint64_t v2 = 0;
    uint64_t v4 = v2 + 1;
  }
  *(void *)(a1 + 296) = v4;
}

void sub_1DD261D8C(void *a1)
{
  uint64_t v2 = a1[21];
  a1[21] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[22];
  a1[22] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = (uint64_t *)a1[23];
  a1[23] = 0;
  if (v4) {
    sub_1DD269308(a1 + 184, v4);
  }
  a1[30] = 0;
  sub_1DD268640(a1 + 27);
  uint64_t v6 = (void *)a1[25];
  uint64_t v5 = a1 + 25;
  sub_1DD268698((uint64_t)(v5 - 1), v6);
  *(v5 - 1) = v5;
  *uint64_t v5 = 0;
  v5[1] = 0;
  v5[7] = v5[6];
  v5[12] = v5[11];
}

void sub_1DD261E50(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 273)) {
    return;
  }
  if (*(unsigned char *)(a1 + 272)) {
    goto LABEL_3;
  }
  if (sub_1DD261AA0(a1))
  {
    if (!*(unsigned char *)(a1 + 273)) {
      return;
    }
LABEL_3:
    sub_1DD26032C((void *)(a1 + 192), *(char **)(a1 + 184), *(void *)(a1 + 176));
    sub_1DD2603D8((void *)(a1 + 192), a1 + 248);
    uint64_t v2 = *(void *)(a1 + 248);
    if (*(unsigned char *)(a1 + 48))
    {
      uint64_t v3 = *(void *)(a1 + 288);
      if (*(void *)(a1 + 296) == v3)
      {
        uint64_t v5 = 0;
        uint64_t v11 = *(void *)(a1 + 248);
      }
      else
      {
        uint64_t v4 = 0;
        uint64_t v5 = 0;
        unint64_t v6 = 0;
        do
        {
          uint64_t v7 = v5;
          uint64_t v5 = *(void *)(v3 + 8 * v6);
          (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168), v2 + 8 * v7, v5 - v7, 0);
          uint64_t v8 = *(void *)(a1 + 56);
          unint64_t v9 = (uint64_t *)(a1 + 64);
          if (*(_DWORD *)(v8 + 32) > (int)v6) {
            unint64_t v9 = (uint64_t *)(*(void *)(v8 + 40) + (v4 >> 29) + 8);
          }
          uint64_t v10 = *v9;
          v13[0] = &unk_1F387B098;
          v13[1] = v10;
          (*(void (**)(void, void *))(**(void **)(a1 + 168) + 32))(*(void *)(a1 + 168), v13);
          nullsub_1(v13);
          ++v6;
          uint64_t v3 = *(void *)(a1 + 288);
          v4 += 0x100000000;
        }
        while (v6 < (*(void *)(a1 + 296) - v3) >> 3);
        uint64_t v11 = *(void *)(a1 + 248);
      }
      (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168), v2 + 8 * v5, ((*(void *)(a1 + 256) - v11) >> 3) - v5, 0);
    }
    else
    {
      unint64_t v12 = *(void (**)(void))(**(void **)(a1 + 168) + 16);
      v12();
    }
    return;
  }
  sub_1DD261B4C(a1);
}

void sub_1DD2620C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_1DD2620D8(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  unint64_t v9 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringVectorBatch");
LABEL_63:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v10 = v9;
  uint64_t v11 = *(const void **)(a1 + 24);
  if (!v11
    || (unint64_t v12 = __dynamic_cast(v11, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878970, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringColumnStatisticsImpl");
    goto LABEL_63;
  }
  uint64_t v13 = (uint64_t)v12;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v14 = v10[17] + 8 * a3;
  if (*((unsigned char *)v10 + 64)) {
    uint64_t v15 = v10[5] + a3;
  }
  else {
    uint64_t v15 = 0;
  }
  if (a4)
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    uint64_t v18 = v10[12] + 8 * a3;
    uint64_t v45 = (void **)(a1 + 248);
    do
    {
      if (!v15 || *(unsigned char *)(v15 + v16))
      {
        size_t v19 = *(void *)(v14 + 8 * v16);
        uint64_t v20 = *(unsigned char **)(v18 + 8 * v16);
        size_t v21 = 0;
        if (v19)
        {
          unint64_t v22 = *(char **)(v18 + 8 * v16);
          uint64_t v23 = *(void *)(v14 + 8 * v16);
          do
          {
            char v24 = *v22++;
            if ((v24 & 0xC0) != 0x80) {
              ++v21;
            }
            --v23;
          }
          while (v23);
        }
        size_t v25 = *(void *)(a1 + 312);
        if (v21 >= v25)
        {
          if (v19 > v25)
          {
            size_t v27 = 0;
            size_t v28 = 0;
            while (1)
            {
              if ((v20[v27] & 0xC0) != 0x80) {
                ++v28;
              }
              if (v28 > v25) {
                break;
              }
              if (v19 == ++v27)
              {
                size_t v27 = *(void *)(v14 + 8 * v16);
                break;
              }
            }
            if (v27 < v19) {
              size_t v19 = v27;
            }
          }
          *(void *)(v14 + 8 * v16) = v19;
        }
        else
        {
          int v26 = *(void **)(a1 + 336);
          *(void *)(v14 + 8 * v16) = v19 - v21 + v25;
          memcpy(v26, v20, v19);
          memset((void *)(*(void *)(a1 + 336) + v19), 32, *(void *)(v14 + 8 * v16) - v19);
          uint64_t v20 = v26;
        }
        if (*(unsigned char *)(a1 + 273))
        {
          uint64_t v29 = sub_1DD260110(a1 + 192, v20, *(void *)(v14 + 8 * v16));
          uint64_t v30 = v29;
          int v32 = *(uint64_t **)(a1 + 256);
          unint64_t v31 = *(void *)(a1 + 264);
          if ((unint64_t)v32 >= v31)
          {
            uint64_t v34 = (uint64_t *)*v45;
            uint64_t v35 = ((char *)v32 - (unsigned char *)*v45) >> 3;
            unint64_t v36 = v35 + 1;
            if ((unint64_t)(v35 + 1) >> 61) {
              sub_1DD251DAC();
            }
            uint64_t v37 = v31 - (void)v34;
            if (v37 >> 2 > v36) {
              unint64_t v36 = v37 >> 2;
            }
            if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v38 = v36;
            }
            if (v38)
            {
              uint64_t v39 = (char *)sub_1DD251DC4(a1 + 264, v38);
              uint64_t v34 = *(uint64_t **)(a1 + 248);
              int v32 = *(uint64_t **)(a1 + 256);
            }
            else
            {
              uint64_t v39 = 0;
            }
            unint64_t v40 = (uint64_t *)&v39[8 * v35];
            uint64_t *v40 = v30;
            int v33 = v40 + 1;
            while (v32 != v34)
            {
              uint64_t v41 = *--v32;
              *--unint64_t v40 = v41;
            }
            *(void *)(a1 + 248) = v40;
            *(void *)(a1 + 256) = v33;
            *(void *)(a1 + 264) = &v39[8 * v38];
            if (v34) {
              operator delete(v34);
            }
          }
          else
          {
            *int v32 = v29;
            int v33 = v32 + 1;
          }
          *(void *)(a1 + 256) = v33;
        }
        else
        {
          sub_1DD23A564(*(char **)(a1 + 160), (uint64_t)v20, *(void *)(v14 + 8 * v16));
        }
        if (*(unsigned char *)(a1 + 80)) {
          sub_1DD2515A8(*(void *)(a1 + 88), *(uint64_t **)(v18 + 8 * v16), *(void *)(v14 + 8 * v16));
        }
        sub_1DD2611C0(v13, v20, *(void *)(v14 + 8 * v16));
        ++v17;
      }
      ++v16;
    }
    while (v16 != a4);
  }
  else
  {
    unint64_t v17 = 0;
  }
  if (!*(unsigned char *)(a1 + 273)) {
    (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), v14, a4, v15);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v13 + 88))(v13, v17);
  if (v17 < a4)
  {
    int v43 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 104);
    return v43(v13, 1);
  }
  return result;
}

void sub_1DD262560(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD262578(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringVectorBatch");
LABEL_54:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  unint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878970, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringColumnStatisticsImpl");
    goto LABEL_54;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v15 = v11[17] + 8 * a3;
  if (*((unsigned char *)v11 + 64))
  {
    uint64_t v16 = v11[5] + a3;
    if (a4) {
      goto LABEL_6;
    }
LABEL_43:
    unint64_t v18 = 0;
    goto LABEL_44;
  }
  uint64_t v16 = 0;
  if (!a4) {
    goto LABEL_43;
  }
LABEL_6:
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  uint64_t v19 = v11[12] + 8 * a3;
  uint64_t v41 = (void **)(a1 + 248);
  do
  {
    if (!v16 || *(unsigned char *)(v16 + v17))
    {
      size_t v20 = *(void *)(a1 + 312);
      size_t v21 = *(unsigned char **)(v19 + 8 * v17);
      size_t v22 = *(void *)(v15 + 8 * v17);
      if (v22 > v20)
      {
        size_t v23 = 0;
        size_t v24 = 0;
        while (1)
        {
          if ((v21[v23] & 0xC0) != 0x80) {
            ++v24;
          }
          if (v24 > v20) {
            break;
          }
          if (v22 == ++v23)
          {
            size_t v23 = *(void *)(v15 + 8 * v17);
            break;
          }
        }
        if (v23 < v22) {
          size_t v22 = v23;
        }
      }
      *(void *)(v15 + 8 * v17) = v22;
      if (*(unsigned char *)(a1 + 273))
      {
        uint64_t v25 = sub_1DD260110(a1 + 192, v21, v22);
        uint64_t v26 = v25;
        size_t v28 = *(uint64_t **)(a1 + 256);
        unint64_t v27 = *(void *)(a1 + 264);
        if ((unint64_t)v28 >= v27)
        {
          uint64_t v30 = (uint64_t *)*v41;
          uint64_t v31 = ((char *)v28 - (unsigned char *)*v41) >> 3;
          unint64_t v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61) {
            sub_1DD251DAC();
          }
          uint64_t v33 = v27 - (void)v30;
          if (v33 >> 2 > v32) {
            unint64_t v32 = v33 >> 2;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v32;
          }
          if (v34)
          {
            uint64_t v35 = (char *)sub_1DD251DC4(a1 + 264, v34);
            uint64_t v30 = *(uint64_t **)(a1 + 248);
            size_t v28 = *(uint64_t **)(a1 + 256);
          }
          else
          {
            uint64_t v35 = 0;
          }
          unint64_t v36 = (uint64_t *)&v35[8 * v31];
          uint64_t *v36 = v26;
          uint64_t v29 = v36 + 1;
          while (v28 != v30)
          {
            uint64_t v37 = *--v28;
            *--unint64_t v36 = v37;
          }
          *(void *)(a1 + 248) = v36;
          *(void *)(a1 + 256) = v29;
          *(void *)(a1 + 264) = &v35[8 * v34];
          if (v30) {
            operator delete(v30);
          }
        }
        else
        {
          *size_t v28 = v25;
          uint64_t v29 = v28 + 1;
        }
        *(void *)(a1 + 256) = v29;
      }
      else
      {
        sub_1DD23A564(*(char **)(a1 + 160), (uint64_t)v21, v22);
      }
      if (*(unsigned char *)(a1 + 80)) {
        sub_1DD2515A8(*(void *)(a1 + 88), *(uint64_t **)(v19 + 8 * v17), *(void *)(v15 + 8 * v17));
      }
      sub_1DD2611C0(v14, *(char **)(v19 + 8 * v17), *(void *)(v15 + 8 * v17));
      ++v18;
    }
    ++v17;
  }
  while (v17 != a4);
LABEL_44:
  if (!*(unsigned char *)(a1 + 273)) {
    (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), v15, a4, v16);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v18);
  if (v18 < a4)
  {
    uint64_t v39 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 104);
    return v39(v14, 1);
  }
  return result;
}

void sub_1DD262974(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26298C(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38782D0, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to StringVectorBatch");
LABEL_20:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  unint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878900, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to BinaryColumnStatisticsImpl");
    goto LABEL_20;
  }
  uint64_t v14 = v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v15 = (unint64_t *)(v11[17] + 8 * a3);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v16 = (unsigned char *)(v11[5] + a3);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t v26 = v11[17] + 8 * a3;
  unint64_t v17 = 0;
  if (a4)
  {
    unint64_t v18 = (uint64_t *)(v11[12] + 8 * a3);
    uint64_t v19 = v16;
    unint64_t v20 = a4;
    do
    {
      unint64_t v22 = *v15++;
      unint64_t v21 = v22;
      if (!v16 || *v19)
      {
        sub_1DD23A564(*(char **)(a1 + 160), *v18, v21);
        v14[3] += v21;
        ++v17;
      }
      ++v18;
      ++v19;
      --v20;
    }
    while (v20);
  }
  (*(void (**)(void, uint64_t, unint64_t, unsigned char *))(**(void **)(a1 + 152) + 16))(*(void *)(a1 + 152), v26, a4, v16);
  uint64_t result = (*(uint64_t (**)(void *, unint64_t))(*v14 + 64))(v14, v17);
  if (v17 < a4)
  {
    size_t v24 = *(uint64_t (**)(void *, uint64_t))(*v14 + 72);
    return v24(v14, 1);
  }
  return result;
}

void sub_1DD262C48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD262C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  void *v7 = &unk_1F387AA90;
  v7[16] = 0;
  uint64_t v8 = v7 + 16;
  v7[17] = 0;
  *(_DWORD *)(a1 + 144) = sub_1DD2913FC(a4);
  sub_1DD314888(__p, "GMT");
  uint64_t v9 = sub_1DD287D10((uint64_t)__p);
  if (v32 < 0) {
    operator delete(__p[0]);
  }
  *(void *)(a1 + 152) = v9;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(__p, a3, 1);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v30, a3, 5);
  uint64_t v10 = __p[0];
  __p[0] = 0;
  uint64_t v28 = (uint64_t)v10;
  int v11 = *(_DWORD *)(a1 + 144);
  BOOL v12 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v28, 1, v11, v12, &v29);
  uint64_t v13 = v29;
  uint64_t v29 = 0;
  uint64_t v14 = *v8;
  *uint64_t v8 = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    uint64_t v15 = v29;
    uint64_t v29 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  uint64_t v16 = v28;
  uint64_t v28 = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = v30;
  uint64_t v30 = 0;
  uint64_t v27 = v17;
  int v18 = *(_DWORD *)(a1 + 144);
  BOOL v19 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v27, 0, v18, v19, &v29);
  uint64_t v20 = v29;
  uint64_t v29 = 0;
  uint64_t v21 = *(void *)(a1 + 136);
  *(void *)(a1 + 136) = v20;
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
    uint64_t v22 = v29;
    uint64_t v29 = 0;
    if (v22) {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
    }
  }
  uint64_t v23 = v27;
  uint64_t v27 = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v24 = v30;
  uint64_t v30 = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = __p[0];
  __p[0] = 0;
  if (v25) {
    (*(void (**)(void *))(*(void *)v25 + 8))(v25);
  }
  return a1;
}

void sub_1DD262F9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a13) {
    (*(void (**)(uint64_t))(*(void *)a13 + 8))(a13);
  }
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  uint64_t v22 = v19[17];
  v19[17] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = *v20;
  uint64_t *v20 = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  sub_1DD25C64C(v19);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2630D0(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878558, 0);
  if (!v9)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to TimestampVectorBatch");
LABEL_46:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v10 = v9;
  int v11 = *(const void **)(a1 + 24);
  if (!v11
    || (BOOL v12 = (char *)__dynamic_cast(v11, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878A68, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to TimestampColumnStatisticsImpl");
    goto LABEL_46;
  }
  uint64_t v13 = v12;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v10 + 64)) {
    uint64_t v14 = v10[5] + a3;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = v10[12] + 8 * a3;
  uint64_t v16 = v10[17] + 8 * a3;
  if (a4)
  {
    uint64_t v17 = 0;
    unint64_t v18 = 0;
    while (v14 && !*(unsigned char *)(v14 + v17))
    {
LABEL_36:
      if (++v17 == a4) {
        goto LABEL_39;
      }
    }
    uint64_t v19 = *(void *)(v16 + 8 * v17) / 1000000;
    uint64_t v20 = v19 + 1000 * *(void *)(v15 + 8 * v17);
    if (*(unsigned char *)(a1 + 80)) {
      sub_1DD25165C(*(void *)(a1 + 88), v19 + 1000 * *(void *)(v15 + 8 * v17));
    }
    if (v13[17])
    {
      uint64_t v21 = (uint64_t *)(v13 + 40);
      if (*((void *)v13 + 5) <= v20)
      {
        uint64_t v21 = (uint64_t *)(v13 + 48);
        if (*((void *)v13 + 6) >= v20) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      *(_WORD *)(v13 + 17) = 257;
      *((void *)v13 + 6) = v20;
      uint64_t v21 = (uint64_t *)(v13 + 40);
    }
    uint64_t *v21 = v20;
LABEL_19:
    uint64_t v22 = *(void *)(v15 + 8 * v17);
    if (v22 < 0 && *(void *)(v16 + 8 * v17)) {
      *(void *)(v15 + 8 * v17) = v22 + 1;
    }
    *(void *)(v15 + 8 * v17) -= (*(uint64_t (**)(void))(**(void **)(a1 + 152) + 24))(*(void *)(a1 + 152));
    uint64_t v23 = *(void *)(v16 + 8 * v17);
    if (v23)
    {
      uint64_t v24 = v23 / 100;
      if (v23 % 100)
      {
        uint64_t v25 = 8 * v23;
      }
      else
      {
        if (__ROR8__(0x1999999999999998 - 0x3333333333333333 * v24, 1) <= 0x1999999999999998uLL)
        {
          unint64_t v27 = 1;
          do
          {
            v24 /= 10;
            uint64_t v26 = v27 + 1;
          }
          while (__ROR8__(0x1999999999999998 - 0x3333333333333333 * v24, 1) <= 0x1999999999999998uLL && v27++ < 6);
        }
        else
        {
          uint64_t v26 = 1;
        }
        uint64_t v25 = v26 | (8 * v24);
      }
    }
    else
    {
      uint64_t v25 = 0;
    }
    ++v18;
    *(void *)(v16 + 8 * v17) = v25;
    goto LABEL_36;
  }
  unint64_t v18 = 0;
LABEL_39:
  (*(void (**)(char *, unint64_t))(*(void *)v13 + 112))(v13, v18);
  if (v18 < a4) {
    (*(void (**)(char *, uint64_t))(*(void *)v13 + 120))(v13, 1);
  }
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v15, a4, v14);
  uint64_t v29 = *(uint64_t (**)(void))(**(void **)(a1 + 136) + 16);
  return v29();
}

void sub_1DD26350C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD263524(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v18);
  uint64_t v4 = *(void *)(a1 + 16);
  int v20 = 1;
  int v21 = v4;
  v19 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128));
  v19 |= 4u;
  uint64_t v22 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v18);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v18);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  sub_1DD242F9C(v13);
  uint64_t v8 = *(void *)(a1 + 16);
  int v15 = 5;
  int v16 = v8;
  v14 |= 3u;
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 136) + 24))(*(void *)(a1 + 136));
  v14 |= 4u;
  uint64_t v17 = v9;
  unint64_t v10 = a2[1];
  if (v10 >= a2[2])
  {
    uint64_t v11 = sub_1DD268EA4(a2, (uint64_t)v13);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v13);
    uint64_t v11 = v10 + 40;
    a2[1] = v10 + 40;
  }
  a2[1] = v11;
  sub_1DD243030(v13);
  return sub_1DD243030(v18);
}

void sub_1DD263684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  *(void *)(v14 + 8) = v15;
  sub_1DD243030(&a9);
  sub_1DD243030(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2636C4(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 128) + 8) + 64))(*(void *)(*(void *)(a1 + 128) + 8))
     + v2;
  return v3
       + (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 136) + 8) + 64))(*(void *)(*(void *)(a1 + 136) + 8));
}

void *sub_1DD263770(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v9);
  int v4 = sub_1DD25BCDC(*(unsigned int *)(a1 + 144));
  int v5 = v10;
  int v11 = v4;
  int v12 = 0;
  v10 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v10 = v5 | 7;
    int v13 = 1;
  }
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD269130(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD243878(a2[1], v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD24387C(v9);
}

void sub_1DD263818(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD263838(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  (*(void (**)(void, void))(**(void **)(a1 + 128) + 32))(*(void *)(a1 + 128), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 136) + 32);
  return v2();
}

uint64_t sub_1DD2638E8(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878118, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to LongVectorBatch");
LABEL_27:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v11 = v10;
  int v12 = *(const void **)(a1 + 24);
  if (!v12
    || (int v13 = (char *)__dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878820, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to DateColumnStatisticsImpl");
    goto LABEL_27;
  }
  uint64_t v14 = v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v15 = (uint64_t *)(v11[12] + 8 * a3);
  if (*((unsigned char *)v11 + 64)) {
    int v16 = (unsigned char *)(v11[5] + a3);
  }
  else {
    int v16 = 0;
  }
  (*(void (**)(void, uint64_t *, unint64_t, unsigned char *))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v15, a4, v16);
  unint64_t v17 = 0;
  if (a4)
  {
    unint64_t v18 = v16;
    unint64_t v19 = a4;
    while (v16 && !*v18)
    {
LABEL_19:
      ++v15;
      ++v18;
      if (!--v19) {
        goto LABEL_20;
      }
    }
    uint64_t v20 = *v15;
    if (v14[17])
    {
      if (*((_DWORD *)v14 + 10) <= (int)v20)
      {
        if (*((_DWORD *)v14 + 11) < (int)v20) {
          *((_DWORD *)v14 + 11) = v20;
        }
        goto LABEL_17;
      }
    }
    else
    {
      *(_WORD *)(v14 + 17) = 257;
      *((_DWORD *)v14 + 11) = v20;
    }
    *((_DWORD *)v14 + 10) = v20;
LABEL_17:
    ++v17;
    if (*(unsigned char *)(a1 + 80)) {
      sub_1DD25165C(*(void *)(a1 + 88), v20);
    }
    goto LABEL_19;
  }
LABEL_20:
  uint64_t result = (*(uint64_t (**)(char *, unint64_t))(*(void *)v14 + 72))(v14, v17);
  if (v17 < a4)
  {
    uint64_t v22 = *(uint64_t (**)(char *, uint64_t))(*(void *)v14 + 88);
    return v22(v14, 1);
  }
  return result;
}

void sub_1DD263BB8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD263BD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_1DD25BD54(a1, a2, a3, a4) = &unk_1F387A908;
  *(_DWORD *)(a1 + 128) = sub_1DD2913FC(a4);
  *(void *)(a1 + 136) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 72))(a2);
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 144) = v8;
  *(void *)(a1 + 160) = 0;
  uint64_t v9 = operator new(0x18uLL);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v25, a3, 1);
  uint64_t v10 = v25;
  uint64_t v25 = 0;
  v9[1] = 0;
  void v9[2] = 0;
  void *v9 = v10;
  int v11 = *(uint64_t **)(a1 + 152);
  *(void *)(a1 + 152) = v9;
  if (v11)
  {
    sub_1DD269308(a1 + 152, v11);
    uint64_t v12 = v25;
    uint64_t v25 = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v24, a3, 5);
  uint64_t v13 = v24;
  uint64_t v24 = 0;
  uint64_t v22 = v13;
  int v14 = *(_DWORD *)(a1 + 128);
  BOOL v15 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v22, 1, v14, v15, &v23);
  uint64_t v16 = v23;
  uint64_t v23 = 0;
  uint64_t v17 = *(void *)(a1 + 160);
  *(void *)(a1 + 160) = v16;
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    uint64_t v18 = v23;
    uint64_t v23 = 0;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
  }
  uint64_t v19 = v22;
  uint64_t v22 = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v20 = v24;
  uint64_t v24 = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  return a1;
}

void sub_1DD263E98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a11) {
    (*(void (**)(uint64_t))(*(void *)a11 + 8))(a11);
  }
  uint64_t v14 = v11[20];
  v11[20] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  BOOL v15 = *v12;
  const void *v12 = 0;
  if (v15) {
    sub_1DD269308((int)v12, v15);
  }
  sub_1DD25C64C(v11);
  _Unwind_Resume(a1);
}

void sub_1DD263F64(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878528, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to Decimal64VectorBatch");
LABEL_32:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v11 = v10;
  uint64_t v12 = *(const void **)(a1 + 24);
  if (!v12
    || (uint64_t v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38789E0, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to DecimalColumnStatisticsImpl");
    goto LABEL_32;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v11 + 64))
  {
    uint64_t v15 = v11[5] + a3;
    if (a4) {
      goto LABEL_6;
    }
LABEL_24:
    unint64_t v17 = 0;
    goto LABEL_25;
  }
  uint64_t v15 = 0;
  if (!a4) {
    goto LABEL_24;
  }
LABEL_6:
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  uint64_t v18 = v11[13] + 8 * a3;
  do
  {
    if (!v15 || *(unsigned char *)(v15 + v16))
    {
      unint64_t v19 = (2 * *(void *)(v18 + 8 * v16)) ^ (*(uint64_t *)(v18 + 8 * v16) >> 63);
      uint64_t v20 = (unsigned char *)(a1 + 168);
      if (v19 >= 0x80)
      {
        do
        {
          *v20++ = v19 | 0x80;
          BOOL v21 = v19 >= 0x4000;
          v19 >>= 7;
        }
        while (v21);
      }
      unsigned char *v20 = v19;
      sub_1DD23A564(*(char **)(a1 + 152), a1 + 168, (unint64_t)&v20[-a1 - 167]);
      if (*(unsigned char *)(a1 + 80))
      {
        uint64_t v22 = *(void *)(v18 + 8 * v16);
        v27.n128_u64[0] = v22 >> 63;
        v27.n128_u64[1] = v22;
        sub_1DD290CAC(&v28, &v27, *(_DWORD *)(a1 + 144));
        sub_1DD290E3C((uint64_t)&v28, &__p);
        uint64_t v23 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &__p
            : (std::string *)__p.__r_.__value_.__r.__words[0];
        unsigned int v24 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? HIBYTE(__p.__r_.__value_.__r.__words[2])
            : LODWORD(__p.__r_.__value_.__r.__words[1]);
        sub_1DD2515A8(*(void *)(a1 + 88), (uint64_t *)v23, v24);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
      }
      ++v17;
      uint64_t v25 = *(void *)(v18 + 8 * v16);
      v28.n128_u64[0] = v25 >> 63;
      v28.n128_u64[1] = v25;
      sub_1DD290CAC((__n128 *)&__p, &v28, *(_DWORD *)(a1 + 144));
      sub_1DD26430C(v14, (__n128 *)&__p);
    }
    ++v16;
  }
  while (v16 != a4);
LABEL_25:
  (*(void (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v17);
  if (v17 < a4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 104))(v14, 1);
  }
  v28.n128_u64[0] = *(void *)(a1 + 144);
  sub_1DD269AB8(&__p, a4, &v28);
  (*(void (**)(void, std::string::size_type, unint64_t, uint64_t))(**(void **)(a1 + 160) + 16))(*(void *)(a1 + 160), __p.__r_.__value_.__r.__words[0], a4, v15);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD2642C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  __cxa_free_exception(v19);
  _Unwind_Resume(a1);
}

void sub_1DD26430C(uint64_t a1, __n128 *a2)
{
  __n128 v6 = *a2;
  unint64_t v7 = a2[1].n128_u64[0];
  sub_1DD2688BC(a1 + 16, &v6);
  if (*(unsigned char *)(a1 + 19))
  {
    __n128 v4 = *a2;
    unint64_t v5 = a2[1].n128_u64[0];
    sub_1DD268998(a1, (uint64_t *)&v4);
  }
}

void *sub_1DD264378(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v18);
  uint64_t v4 = *(void *)(a1 + 16);
  int v20 = 1;
  int v21 = v4;
  v19 |= 3u;
  uint64_t v5 = sub_1DD23A6B4(*(void **)(a1 + 152));
  v19 |= 4u;
  uint64_t v22 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v18);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v18);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  sub_1DD242F9C(v13);
  uint64_t v8 = *(void *)(a1 + 16);
  int v15 = 5;
  int v16 = v8;
  v14 |= 3u;
  uint64_t v9 = (*(uint64_t (**)(void))(**(void **)(a1 + 160) + 24))(*(void *)(a1 + 160));
  v14 |= 4u;
  uint64_t v17 = v9;
  unint64_t v10 = a2[1];
  if (v10 >= a2[2])
  {
    uint64_t v11 = sub_1DD268EA4(a2, (uint64_t)v13);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v13);
    uint64_t v11 = v10 + 40;
    a2[1] = v10 + 40;
  }
  a2[1] = v11;
  sub_1DD243030(v13);
  return sub_1DD243030(v18);
}

void sub_1DD2644B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  *(void *)(v14 + 8) = v15;
  sub_1DD243030(&a9);
  sub_1DD243030(&a14);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2644F8(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = sub_1DD23A68C(*(void *)(a1 + 152)) + v2;
  return v3
       + (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 160) + 8) + 64))(*(void *)(*(void *)(a1 + 160) + 8));
}

void *sub_1DD264580(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v9);
  int v4 = sub_1DD25BCDC(*(unsigned int *)(a1 + 128));
  int v5 = v10;
  int v11 = v4;
  int v12 = 0;
  v10 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v10 = v5 | 7;
    int v13 = 1;
  }
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD269130(a2, (uint64_t)v9);
  }
  else
  {
    sub_1DD243878(a2[1], v9);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  return sub_1DD24387C(v9);
}

void sub_1DD264628(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD264648(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  sub_1DD23A73C(*(int **)(a1 + 152), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 160) + 32);
  return v2();
}

unint64_t sub_1DD2646D8(uint64_t *a1)
{
  uint64_t v1 = *a1;
  unint64_t v2 = a1[1];
  *((void *)&v4 + 1) = *a1;
  *(void *)&long long v4 = v2;
  uint64_t v3 = v4 >> 63;
  uint64_t v5 = -*a1;
  if (v2) {
    uint64_t v5 = ~v1;
  }
  *((void *)&v7 + 1) = v5;
  *(void *)&long long v7 = -(uint64_t)v2;
  unint64_t v6 = v7 >> 63;
  if (v1 < 0) {
    uint64_t v3 = (__PAIR128__(v6, -2 * v2) - 1) >> 64;
  }
  unint64_t v8 = v2 >> 63;
  if (v1) {
    return v3;
  }
  else {
    return v8;
  }
}

void sub_1DD264730(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F38785B8, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to Decimal128VectorBatch");
LABEL_33:
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v11 = v10;
  int v12 = *(const void **)(a1 + 24);
  if (!v12
    || (int v13 = __dynamic_cast(v12, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38789E0, 8)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to DecimalColumnStatisticsImpl");
    goto LABEL_33;
  }
  uint64_t v14 = (uint64_t)v13;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v11 + 64))
  {
    uint64_t v15 = v11[5] + a3;
    if (a4)
    {
LABEL_6:
      uint64_t v16 = 0;
      unint64_t v17 = 0;
      uint64_t v18 = v11[13] + 16 * a3;
      while (v15 && !*(unsigned char *)(v15 + v16))
      {
LABEL_22:
        if (++v16 == a4) {
          goto LABEL_26;
        }
      }
      unint64_t v19 = sub_1DD2646D8((uint64_t *)(v18 + 16 * v16));
      int v21 = (unsigned char *)(a1 + 178);
      if (!v19) {
        goto LABEL_11;
      }
      while (1)
      {
        do
        {
          unint64_t v22 = v19;
          *v21++ = v20 | 0x80;
          *((void *)&v23 + 1) = v19;
          *(void *)&long long v23 = v20;
          unint64_t v20 = v23 >> 7;
          v19 >>= 7;
        }
        while (v22 > 0x7F);
LABEL_11:
        if (v20 < 0x80)
        {
          unsigned char *v21 = v20;
          sub_1DD23A564(*(char **)(a1 + 152), a1 + 178, (unint64_t)&v21[-a1 - 177]);
          if (*(unsigned char *)(a1 + 80))
          {
            sub_1DD290CAC(&v27, (__n128 *)(v18 + 16 * v16), *(_DWORD *)(a1 + 144));
            sub_1DD290E3C((uint64_t)&v27, &__p);
            unsigned int v24 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? &__p
                : (std::string *)__p.__r_.__value_.__r.__words[0];
            unsigned int v25 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? HIBYTE(__p.__r_.__value_.__r.__words[2])
                : LODWORD(__p.__r_.__value_.__r.__words[1]);
            sub_1DD2515A8(*(void *)(a1 + 88), (uint64_t *)v24, v25);
            if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__p.__r_.__value_.__l.__data_);
            }
          }
          ++v17;
          sub_1DD290CAC((__n128 *)&__p, (__n128 *)(v18 + 16 * v16), *(_DWORD *)(a1 + 144));
          sub_1DD26430C(v14, (__n128 *)&__p);
          goto LABEL_22;
        }
      }
    }
  }
  else
  {
    uint64_t v15 = 0;
    if (a4) {
      goto LABEL_6;
    }
  }
  unint64_t v17 = 0;
LABEL_26:
  (*(void (**)(uint64_t, unint64_t))(*(void *)v14 + 88))(v14, v17);
  if (v17 < a4) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v14 + 104))(v14, 1);
  }
  v27.n128_u64[0] = *(void *)(a1 + 144);
  sub_1DD269AB8(&__p, a4, &v27);
  (*(void (**)(void, std::string::size_type, unint64_t, uint64_t))(**(void **)(a1 + 160) + 16))(*(void *)(a1 + 160), __p.__r_.__value_.__r.__words[0], a4, v15);
  if (__p.__r_.__value_.__r.__words[0])
  {
    __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD264A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  __cxa_free_exception(v17);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD264AC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  *unint64_t v8 = &unk_1F3879CB0;
  v8[16] = 0;
  *(_DWORD *)(a1 + 136) = sub_1DD2913FC(a4);
  *(void *)(a1 + 144) = 0;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v22, a3, 2);
  uint64_t v9 = v22;
  uint64_t v22 = 0;
  uint64_t v20 = v9;
  int v10 = *(_DWORD *)(a1 + 136);
  BOOL v11 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v20, 0, v10, v11, &v21);
  uint64_t v12 = v21;
  uint64_t v21 = 0;
  uint64_t v13 = *(void *)(a1 + 128);
  *(void *)(a1 + 128) = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    uint64_t v14 = v21;
    uint64_t v21 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
  uint64_t v15 = v20;
  uint64_t v20 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2) == 1)
  {
    uint64_t v16 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, 0);
    sub_1DD25D3B0(&v21, v16, a3, a4);
    uint64_t v17 = *(void *)(a1 + 144);
    *(void *)(a1 + 144) = v21;
    if (v17) {
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    }
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v18 = v22;
  uint64_t v22 = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  return a1;
}

void sub_1DD264D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v14 = v12[18];
  v12[18] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v12[16];
  v12[16] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

void *sub_1DD264E14(void *a1)
{
  *a1 = &unk_1F3879CB0;
  uint64_t v2 = a1[18];
  a1[18] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD264EC8(void *a1)
{
  uint64_t v1 = sub_1DD264E14(a1);
  operator delete(v1);
}

uint64_t sub_1DD264EF0(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878100, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to ListVectorBatch");
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  BOOL v11 = v10;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v12 = v11[12];
  uint64_t v13 = (uint64_t *)(v12 + 8 * a3);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v14 = (unsigned __int8 *)(v11[5] + a3);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *v13;
  uint64_t v16 = v13[a4];
  if (a4)
  {
    uint64_t v17 = (uint64_t *)(v12 + 8 * a3 + 8);
    unint64_t v18 = a4;
    uint64_t v19 = *v13;
    do
    {
      uint64_t v20 = *v17;
      *(v17 - 1) = *v17 - v19;
      ++v17;
      uint64_t v19 = v20;
      --v18;
    }
    while (v18);
  }
  uint64_t v21 = *(void *)(a1 + 144);
  if (v21) {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)v21 + 16))(v21, v11[15], v15, v16 - v15, 0);
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t *, unint64_t, unsigned __int8 *))(**(void **)(a1 + 128)
                                                                                             + 16))(*(void *)(a1 + 128), v13, a4, v14);
  if (*(unsigned char *)(a1 + 48))
  {
    if (!v14)
    {
      uint64_t v26 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);
      return v26();
    }
    unint64_t v23 = 0;
    if (a4)
    {
      unint64_t v24 = a4;
      do
      {
        if (*v14++)
        {
          ++v23;
          if (*(unsigned char *)(a1 + 80)) {
            sub_1DD25165C(*(void *)(a1 + 88), *v13);
          }
        }
        ++v13;
        --v24;
      }
      while (v24);
    }
    uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v23);
    if (v23 < a4)
    {
      uint64_t v26 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 32);
      return v26();
    }
  }
  return result;
}

void sub_1DD2651C0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD2651D4(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v10);
  uint64_t v4 = *(void *)(a1 + 16);
  int v12 = 2;
  int v13 = v4;
  v11 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128));
  v11 |= 4u;
  uint64_t v14 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v10);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v10);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 24))(v8, a2);
  }
  return sub_1DD243030(v10);
}

void sub_1DD2652D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2652F0(uint64_t a1, uint64_t *a2)
{
  sub_1DD25CE64(a1, a2);
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 96);
    return v4();
  }
  return result;
}

uint64_t sub_1DD265360(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  if (*(void *)(a1 + 144))
  {
    uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 128) + 8) + 64))(*(void *)(*(void *)(a1 + 128) + 8));
    v2 += v3 + (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 32))(*(void *)(a1 + 144));
  }
  return v2;
}

void *sub_1DD265420(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v10);
  int v4 = sub_1DD25BCDC(*(unsigned int *)(a1 + 136));
  int v5 = v11;
  int v12 = v4;
  int v13 = 0;
  v11 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v11 = v5 | 7;
    int v14 = 1;
  }
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD269130(a2, (uint64_t)v10);
  }
  else
  {
    sub_1DD243878(a2[1], v10);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  uint64_t v8 = *(void *)(a1 + 144);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 40))(v8, a2);
  }
  return sub_1DD24387C(v10);
}

void sub_1DD2654F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD265518(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C9EC(a1, a2, *(void *)(a1 + 32));
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    int v4 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v4();
  }
  return result;
}

uint64_t sub_1DD26558C(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32));
  (*(void (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 72);
    return v3();
  }
  return result;
}

uint64_t sub_1DD265644(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C9EC(a1, a2, *(void *)(a1 + 40));
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    int v4 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v4();
  }
  return result;
}

uint64_t sub_1DD2656B8(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  (*(void (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 64);
    return v3();
  }
  return result;
}

uint64_t sub_1DD265770(uint64_t a1)
{
  sub_1DD25CBB8(a1);
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 80);
    return v3();
  }
  return result;
}

uint64_t sub_1DD2657D8(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 128) + 32);
  return v2();
}

uint64_t sub_1DD26585C(uint64_t a1)
{
  sub_1DD25D074(a1);
  uint64_t result = *(void *)(a1 + 144);
  if (result)
  {
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)result + 112);
    return v3();
  }
  return result;
}

uint64_t sub_1DD2658C4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 144);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  return result;
}

uint64_t sub_1DD2658F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (void *)sub_1DD25BD54(a1, a2, a3, a4);
  *uint64_t v8 = &unk_1F38799A8;
  v8[16] = 0;
  uint64_t v9 = v8 + 16;
  v8[17] = 0;
  v8[18] = 0;
  *(_DWORD *)(a1 + 152) = sub_1DD2913FC(a4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v25, a3, 2);
  uint64_t v10 = v25;
  uint64_t v25 = 0;
  uint64_t v23 = v10;
  int v11 = *(_DWORD *)(a1 + 152);
  BOOL v12 = sub_1DD291574(a4);
  sub_1DD27D3B4(&v23, 0, v11, v12, &v24);
  uint64_t v13 = v24;
  uint64_t v24 = 0;
  uint64_t v14 = *(void *)(a1 + 144);
  *(void *)(a1 + 144) = v13;
  if (v14)
  {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    uint64_t v15 = v24;
    uint64_t v24 = 0;
    if (v15) {
      (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    }
  }
  uint64_t v16 = v23;
  uint64_t v23 = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2))
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 48))(a2, 0);
    sub_1DD25D3B0(&v24, v17, a3, a4);
    uint64_t v18 = *v9;
    uint64_t *v9 = v24;
    if (v18) {
      (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    }
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2) >= 2)
  {
    uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, 1);
    sub_1DD25D3B0(&v24, v19, a3, a4);
    uint64_t v20 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v24;
    if (v20) {
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    }
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v21 = v25;
  uint64_t v25 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  return a1;
}

void sub_1DD265C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v15 = v12[18];
  v12[18] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = v12[17];
  v12[17] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *v13;
  *uint64_t v13 = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

void *sub_1DD265D18(void *a1)
{
  *a1 = &unk_1F38799A8;
  uint64_t v2 = a1[18];
  a1[18] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[17];
  a1[17] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[16];
  a1[16] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD265DFC(void *a1)
{
  uint64_t v1 = sub_1DD265D18(a1);
  operator delete(v1);
}

uint64_t sub_1DD265E24(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878030, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to MapVectorBatch");
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  int v11 = v10;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  uint64_t v12 = v11[12];
  uint64_t v13 = (uint64_t *)(v12 + 8 * a3);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v14 = (unsigned __int8 *)(v11[5] + a3);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *v13;
  uint64_t v16 = v13[a4] - *v13;
  if (a4)
  {
    uint64_t v17 = (uint64_t *)(v12 + 8 * a3 + 8);
    unint64_t v18 = a4;
    uint64_t v19 = *v13;
    do
    {
      uint64_t v20 = *v17;
      *(v17 - 1) = *v17 - v19;
      ++v17;
      uint64_t v19 = v20;
      --v18;
    }
    while (v18);
  }
  (*(void (**)(void, uint64_t *, unint64_t, unsigned __int8 *))(**(void **)(a1 + 144) + 16))(*(void *)(a1 + 144), v13, a4, v14);
  uint64_t v21 = *(void *)(a1 + 128);
  if (v21) {
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)v21 + 16))(v21, v11[15], v15, v16, 0);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)result + 16))(result, v11[16], v15, v16, 0);
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (!v14)
    {
      uint64_t v26 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 16);
      return v26();
    }
    unint64_t v23 = 0;
    if (a4)
    {
      unint64_t v24 = a4;
      do
      {
        if (*v14++)
        {
          ++v23;
          if (*(unsigned char *)(a1 + 80)) {
            sub_1DD25165C(*(void *)(a1 + 88), *v13);
          }
        }
        ++v13;
        --v24;
      }
      while (v24);
    }
    uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v23);
    if (v23 < a4)
    {
      uint64_t v26 = *(uint64_t (**)(void))(**(void **)(a1 + 24) + 32);
      return v26();
    }
  }
  return result;
}

void sub_1DD266148(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD26615C(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v11);
  uint64_t v4 = *(void *)(a1 + 16);
  int v13 = 2;
  int v14 = v4;
  v12 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 144) + 24))(*(void *)(a1 + 144));
  v12 |= 4u;
  uint64_t v15 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v11);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v11);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 24))(v8, a2);
  }
  uint64_t v9 = *(void *)(a1 + 136);
  if (v9) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 24))(v9, a2);
  }
  return sub_1DD243030(v11);
}

void sub_1DD266288(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2662A8(uint64_t a1, uint64_t *a2)
{
  sub_1DD25CE64(a1, a2);
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 96))(v4, a2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    unint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 96);
    return v6();
  }
  return result;
}

uint64_t sub_1DD266348(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 144) + 8) + 64))(*(void *)(*(void *)(a1 + 144) + 8))
     + v2;
  uint64_t v4 = *(void *)(a1 + 128);
  if (v4) {
    v3 += (*(uint64_t (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 136);
  if (v5) {
    v3 += (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  return v3;
}

void *sub_1DD266428(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v11);
  int v4 = sub_1DD25BCDC(*(unsigned int *)(a1 + 152));
  int v5 = v12;
  int v13 = v4;
  int v14 = 0;
  v12 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v12 = v5 | 7;
    int v15 = 1;
  }
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD269130(a2, (uint64_t)v11);
  }
  else
  {
    sub_1DD243878(a2[1], v11);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v8 + 40))(v8, a2);
  }
  uint64_t v9 = *(void *)(a1 + 136);
  if (v9) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 40))(v9, a2);
  }
  return sub_1DD24387C(v11);
}

void sub_1DD266530(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD266550(uint64_t *a1, uint64_t *a2)
{
  sub_1DD25C9EC((uint64_t)a1, a2, a1[4]);
  uint64_t v4 = a1[16];
  if (v4) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, a2);
  }
  uint64_t result = a1[17];
  if (result)
  {
    unint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 48);
    return v6();
  }
  return result;
}

uint64_t sub_1DD2665F4(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32));
  (*(void (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 72))(v2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 72);
    return v4();
  }
  return result;
}

uint64_t sub_1DD2666D8(uint64_t *a1, uint64_t *a2)
{
  sub_1DD25C9EC((uint64_t)a1, a2, a1[5]);
  uint64_t v4 = a1[16];
  if (v4) {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v4 + 56))(v4, a2);
  }
  uint64_t result = a1[17];
  if (result)
  {
    unint64_t v6 = *(uint64_t (**)(void))(*(void *)result + 56);
    return v6();
  }
  return result;
}

uint64_t sub_1DD26677C(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  (*(void (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 64))(v2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 64);
    return v4();
  }
  return result;
}

uint64_t sub_1DD266860(uint64_t a1)
{
  sub_1DD25CBB8(a1);
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 80))(v2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 80);
    return v4();
  }
  return result;
}

uint64_t sub_1DD2668F4(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 144) + 32);
  return v2();
}

uint64_t sub_1DD266978(uint64_t a1)
{
  sub_1DD25D074(a1);
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 112))(v2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 112);
    return v4();
  }
  return result;
}

uint64_t sub_1DD266A0C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 128);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 120))(v2);
  }
  uint64_t result = *(void *)(a1 + 136);
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 120);
    return v4();
  }
  return result;
}

uint64_t sub_1DD266A9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_1DD25BD54(a1, a2, a3, a4);
  *(void *)uint64_t v8 = &unk_1F3879F90;
  *(_OWORD *)(v8 + 128) = 0u;
  uint64_t v9 = (uint64_t *)(v8 + 128);
  uint64_t v10 = (char **)(v8 + 136);
  *(_OWORD *)(v8 + 144) = 0u;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a3 + 16))(&v35, a3, 1);
  uint64_t v11 = v35;
  uint64_t v35 = 0;
  uint64_t v33 = v11;
  sub_1DD252448(&v33, &v34);
  uint64_t v12 = v34;
  uint64_t v34 = 0;
  uint64_t v13 = *v9;
  uint64_t *v9 = v12;
  if (v13)
  {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    uint64_t v14 = v34;
    uint64_t v34 = 0;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
  }
  uint64_t v15 = v33;
  uint64_t v33 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  for (uint64_t i = 0; i != (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2); ++i)
  {
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 48))(a2, i);
    sub_1DD25D3B0(&v34, v17, a3, a4);
    uint64_t v18 = v34;
    uint64_t v34 = 0;
    uint64_t v20 = *(void **)(a1 + 144);
    unint64_t v19 = *(void *)(a1 + 152);
    if ((unint64_t)v20 >= v19)
    {
      uint64_t v22 = ((char *)v20 - *v10) >> 3;
      if ((unint64_t)(v22 + 1) >> 61) {
        sub_1DD251DAC();
      }
      uint64_t v23 = v19 - (void)*v10;
      uint64_t v24 = v23 >> 2;
      if (v23 >> 2 <= (unint64_t)(v22 + 1)) {
        uint64_t v24 = v22 + 1;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v24;
      }
      if (v25) {
        uint64_t v26 = (char *)sub_1DD251DC4(a1 + 152, v25);
      }
      else {
        uint64_t v26 = 0;
      }
      __n128 v27 = &v26[8 * v22];
      *(void *)__n128 v27 = v18;
      uint64_t v21 = v27 + 8;
      uint64_t v29 = *(char **)(a1 + 136);
      __n128 v28 = *(char **)(a1 + 144);
      if (v28 != v29)
      {
        do
        {
          uint64_t v30 = *((void *)v28 - 1);
          v28 -= 8;
          *((void *)v27 - 1) = v30;
          v27 -= 8;
        }
        while (v28 != v29);
        __n128 v28 = *v10;
      }
      *(void *)(a1 + 136) = v27;
      *(void *)(a1 + 144) = v21;
      *(void *)(a1 + 152) = &v26[8 * v25];
      if (v28) {
        operator delete(v28);
      }
    }
    else
    {
      void *v20 = v18;
      uint64_t v21 = v20 + 1;
    }
    *(void *)(a1 + 144) = v21;
    if (v34) {
      (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
    }
  }
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t))(*(void *)a1 + 104))(a1);
  }
  uint64_t v31 = v35;
  uint64_t v35 = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  return a1;
}

void sub_1DD266DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a12) {
    (*(void (**)(uint64_t))(*(void *)a12 + 8))(a12);
  }
  uint64_t v15 = *v13;
  if (*v13)
  {
    v12[18] = v15;
    operator delete(v15);
  }
  uint64_t v16 = *a9;
  *a9 = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  sub_1DD25C64C(v12);
  _Unwind_Resume(a1);
}

void *sub_1DD266E88(void *a1)
{
  *a1 = &unk_1F3879F90;
  uint64_t v4 = a1 + 17;
  uint64_t v2 = (void *)a1[17];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (v3)
    {
LABEL_7:
      a1[18] = v2;
      operator delete(v2);
    }
  }
  else
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = *((void *)v2 + v5);
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        uint64_t v2 = (void *)a1[17];
        uint64_t v3 = (void *)a1[18];
      }
      unint64_t v5 = v6++;
    }
    while (v5 < ((unsigned char *)v3 - (unsigned char *)v2) >> 3);
    if (v2) {
      goto LABEL_7;
    }
  }
  uint64_t v8 = a1[16];
  a1[16] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD266F80(void *a1)
{
  uint64_t v1 = sub_1DD266E88(a1);
  operator delete(v1);
}

void sub_1DD266FA8(uint64_t a1, void *lpsrc, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = __dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F3878268, (const struct __class_type_info *)&unk_1F3878250, 0);
  if (!v10)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D938(exception, "Failed to cast to UnionVectorBatch");
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v11 = v10;
  (*(void (**)(void, uint64_t, unint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), *((void *)lpsrc + 5) + a3, a4, a5);
  if (*((unsigned char *)v11 + 64)) {
    uint64_t v12 = (unsigned __int8 *)(v11[5] + a3);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = v11[12];
  uint64_t v14 = v11[17];
  unint64_t v15 = (uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 136)) >> 3;
  __p[0] = (void *)-1;
  sub_1DD269AB8(v35, v15, __p);
  unint64_t v16 = (uint64_t)(*(void *)(a1 + 144) - *(void *)(a1 + 136)) >> 3;
  uint64_t v33 = 0;
  sub_1DD269B3C(__p, v16, &v33);
  uint64_t v17 = (unsigned __int8 *)(v13 + a3);
  if (a4)
  {
    uint64_t v18 = (void *)(v14 + 8 * a3);
    unint64_t v19 = v35[0];
    uint64_t v20 = __p[0];
    uint64_t v21 = v17;
    unint64_t v22 = a4;
    do
    {
      uint64_t v23 = *v21;
      if (v19[v23] == -1)
      {
        v19[v23] = *v18;
        uint64_t v23 = *v21;
      }
      ++v20[v23];
      ++v18;
      ++v21;
      --v22;
    }
    while (v22);
  }
  (*(void (**)(void, unsigned __int8 *, unint64_t, unsigned __int8 *))(**(void **)(a1 + 128) + 16))(*(void *)(a1 + 128), v17, a4, v12);
  uint64_t v25 = *(void *)(a1 + 136);
  uint64_t v24 = *(void *)(a1 + 144);
  if (v24 != v25)
  {
    unint64_t v26 = 0;
    unsigned int v27 = 1;
    do
    {
      uint64_t v28 = *((void *)__p[0] + v26);
      if (v28)
      {
        (*(void (**)(void, void, void, uint64_t, void))(**(void **)(v25 + 8 * v26) + 16))(*(void *)(v25 + 8 * v26), *(void *)(v11[20] + 8 * v26), *((void *)v35[0] + v26), v28, 0);
        uint64_t v25 = *(void *)(a1 + 136);
        uint64_t v24 = *(void *)(a1 + 144);
      }
      unint64_t v26 = v27++;
    }
    while (v26 < (v24 - v25) >> 3);
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (v12)
    {
      unint64_t v29 = 0;
      if (a4)
      {
        unint64_t v30 = a4;
        do
        {
          if (*v12++)
          {
            ++v29;
            if (*(unsigned char *)(a1 + 80)) {
              sub_1DD25165C(*(void *)(a1 + 88), *v17);
            }
          }
          ++v17;
          --v30;
        }
        while (v30);
      }
      (*(void (**)(void, unint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), v29);
      if (v29 < a4) {
        (*(void (**)(void, uint64_t))(**(void **)(a1 + 24) + 32))(*(void *)(a1 + 24), 1);
      }
    }
    else
    {
      (*(void (**)(void, unint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), a4);
    }
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v35[0])
  {
    v35[1] = v35[0];
    operator delete(v35[0]);
  }
}

void sub_1DD267300(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  __cxa_free_exception(v15);
  _Unwind_Resume(a1);
}

void *sub_1DD267350(uint64_t a1, uint64_t *a2)
{
  sub_1DD25C8DC(a1, a2);
  sub_1DD242F9C(v12);
  uint64_t v4 = *(void *)(a1 + 16);
  int v14 = 1;
  int v15 = v4;
  v13 |= 3u;
  uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 32))(*(void *)(a1 + 128));
  v13 |= 4u;
  uint64_t v16 = v5;
  unint64_t v6 = a2[1];
  if (v6 >= a2[2])
  {
    uint64_t v7 = sub_1DD268EA4(a2, (uint64_t)v12);
  }
  else
  {
    sub_1DD24302C(a2[1], (uint64_t)v12);
    uint64_t v7 = v6 + 40;
    a2[1] = v6 + 40;
  }
  a2[1] = v7;
  uint64_t v8 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v8)
  {
    unint64_t v9 = 0;
    unsigned int v10 = 1;
    do
    {
      (*(void (**)(void, uint64_t *))(**(void **)(v8 + 8 * v9) + 24))(*(void *)(v8 + 8 * v9), a2);
      unint64_t v9 = v10;
      uint64_t v8 = *(void *)(a1 + 136);
      ++v10;
    }
    while (v9 < (*(void *)(a1 + 144) - v8) >> 3);
  }
  return sub_1DD243030(v12);
}

void sub_1DD267474(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  *(void *)(v2 + 8) = v3;
  sub_1DD243030((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DD267498(uint64_t a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25CE64(a1, a2);
  uint64_t v5 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 96))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = *(void *)(a1 + 136);
      ++v7;
    }
    while (v6 < (*(void *)(a1 + 144) - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD267520(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 24))(*(void *)(a1 + 128)) + v2;
  uint64_t v4 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v4)
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      v3 += (*(uint64_t (**)(void))(**(void **)(v4 + 8 * v5) + 32))(*(void *)(v4 + 8 * v5));
      unint64_t v5 = v6;
      uint64_t v4 = *(void *)(a1 + 136);
      ++v6;
    }
    while (v5 < (*(void *)(a1 + 144) - v4) >> 3);
  }
  return v3;
}

void *sub_1DD2675FC(uint64_t a1, uint64_t *a2)
{
  sub_1DD2437E0((uint64_t)v11);
  int v4 = v12;
  uint64_t v13 = 0;
  v12 |= 3u;
  if (*(unsigned char *)(a1 + 80))
  {
    int v12 = v4 | 7;
    int v14 = 1;
  }
  unint64_t v5 = a2[1];
  if (v5 >= a2[2])
  {
    uint64_t v6 = sub_1DD269130(a2, (uint64_t)v11);
  }
  else
  {
    sub_1DD243878(a2[1], v11);
    uint64_t v6 = v5 + 40;
    a2[1] = v5 + 40;
  }
  a2[1] = v6;
  uint64_t v7 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v7)
  {
    unint64_t v8 = 0;
    unsigned int v9 = 1;
    do
    {
      (*(void (**)(void, uint64_t *))(**(void **)(v7 + 8 * v8) + 40))(*(void *)(v7 + 8 * v8), a2);
      unint64_t v8 = v9;
      uint64_t v7 = *(void *)(a1 + 136);
      ++v9;
    }
    while (v8 < (*(void *)(a1 + 144) - v7) >> 3);
  }
  return sub_1DD24387C(v11);
}

void sub_1DD2676F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD24387C((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_1DD267718(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25C9EC((uint64_t)a1, a2, a1[4]);
  uint64_t v5 = a1[17];
  if (a1[18] != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 48))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = a1[17];
      ++v7;
    }
    while (v6 < (a1[18] - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD2677A4(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 32));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 48))(*(void *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 72))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 136);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 144) - v3) >> 3);
  }
  return result;
}

void *sub_1DD26786C(uint64_t *a1, uint64_t *a2)
{
  uint64_t result = sub_1DD25C9EC((uint64_t)a1, a2, a1[5]);
  uint64_t v5 = a1[17];
  if (a1[18] != v5)
  {
    unint64_t v6 = 0;
    unsigned int v7 = 1;
    do
    {
      uint64_t result = (void *)(*(uint64_t (**)(void, uint64_t *))(**(void **)(v5 + 8 * v6) + 56))(*(void *)(v5 + 8 * v6), a2);
      unint64_t v6 = v7;
      uint64_t v5 = a1[17];
      ++v7;
    }
    while (v6 < (a1[18] - v5) >> 3);
  }
  return result;
}

uint64_t sub_1DD2678F8(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 32) + 40))(*(void *)(a1 + 32), *(void *)(a1 + 24));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  uint64_t v3 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 64))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 136);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 144) - v3) >> 3);
  }
  return result;
}

uint64_t sub_1DD2679C0(uint64_t a1)
{
  uint64_t result = sub_1DD25CBB8(a1);
  uint64_t v3 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v3)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 80))(*(void *)(v3 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v3 = *(void *)(a1 + 136);
      ++v5;
    }
    while (v4 < (*(void *)(a1 + 144) - v3) >> 3);
  }
  return result;
}

uint64_t sub_1DD267A38(uint64_t a1)
{
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *(void *)(a1 + 72));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 128) + 40);
  return v2();
}

void sub_1DD267ABC(uint64_t a1)
{
  sub_1DD25D074(a1);
  uint64_t v2 = *(void *)(a1 + 136);
  if (*(void *)(a1 + 144) != v2)
  {
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      (*(void (**)(void))(**(void **)(v2 + 8 * v3) + 112))(*(void *)(v2 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v2 = *(void *)(a1 + 136);
      ++v4;
    }
    while (v3 < (*(void *)(a1 + 144) - v2) >> 3);
  }
}

uint64_t sub_1DD267B34(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 136);
  if (*(void *)(result + 144) != v1)
  {
    uint64_t v2 = result;
    unint64_t v3 = 0;
    unsigned int v4 = 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 8 * v3) + 120))(*(void *)(v1 + 8 * v3));
      unint64_t v3 = v4;
      uint64_t v1 = *(void *)(v2 + 136);
      ++v4;
    }
    while (v3 < (*(void *)(v2 + 144) - v1) >> 3);
  }
  return result;
}

void sub_1DD267BA8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  unsigned int v5 = (unsigned int *)(v3 + 24);
  signed int v4 = *(_DWORD *)(v3 + 24);
  if (v4 == *(_DWORD *)(v3 + 28))
  {
    sub_1DD24FA20(v5, v4 + 1);
    signed int v4 = *v5;
  }
  uint64_t v6 = *(void *)(v3 + 32);
  *(_DWORD *)(v3 + 24) = v4 + 1;
  *(void *)(v6 + 8 * v4 + 8) = a2;
}

void *sub_1DD267C10(void *a1)
{
  *a1 = &unk_1F387A490;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD267C90(void *a1)
{
  *a1 = &unk_1F387A490;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = sub_1DD25C64C(a1);
  operator delete(v3);
}

void *sub_1DD267D14(void *a1)
{
  *a1 = &unk_1F3879A78;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD267D94(void *a1)
{
  *a1 = &unk_1F3879A78;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = sub_1DD25C64C(a1);
  operator delete(v3);
}

void *sub_1DD267E18(void *a1)
{
  *a1 = &unk_1F387A3C0;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD267E98(void *a1)
{
  *a1 = &unk_1F387A3C0;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = sub_1DD25C64C(a1);
  operator delete(v3);
}

void *sub_1DD267F1C(void *a1)
{
  *a1 = &unk_1F387A168;
  sub_1DD2701B4(a1 + 18);
  uint64_t v2 = (uint64_t *)a1[17];
  a1[17] = 0;
  if (v2) {
    sub_1DD269308(a1 + 136, v2);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD267F84(void *a1)
{
  *a1 = &unk_1F387A168;
  sub_1DD2701B4(a1 + 18);
  uint64_t v2 = (uint64_t *)a1[17];
  a1[17] = 0;
  if (v2) {
    sub_1DD269308(a1 + 136, v2);
  }
  uint64_t v3 = sub_1DD25C64C(a1);
  operator delete(v3);
}

void sub_1DD267FF4(uint64_t a1)
{
  uint64_t v1 = sub_1DD268CD8(a1);
  operator delete(v1);
}

void *sub_1DD26801C(void *a1)
{
  *a1 = &unk_1F3879B08;
  sub_1DD2701B4(a1 + 40);
  return sub_1DD268CD8((uint64_t)a1);
}

void sub_1DD268074(void *a1)
{
  *a1 = &unk_1F3879B08;
  sub_1DD2701B4(a1 + 40);
  uint64_t v2 = sub_1DD268CD8((uint64_t)a1);
  operator delete(v2);
}

void *sub_1DD2680D0(void *a1)
{
  *a1 = &unk_1F387AA90;
  uint64_t v2 = a1[17];
  a1[17] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD268180(void *a1)
{
  *a1 = &unk_1F387AA90;
  uint64_t v2 = a1[17];
  a1[17] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  signed int v4 = sub_1DD25C64C(a1);
  operator delete(v4);
}

void *sub_1DD268234(void *a1)
{
  *a1 = &unk_1F387A908;
  uint64_t v2 = a1[20];
  a1[20] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (uint64_t *)a1[19];
  a1[19] = 0;
  if (v3) {
    sub_1DD269308(a1 + 152, v3);
  }
  return sub_1DD25C64C(a1);
}

void sub_1DD2682C8(void *a1)
{
  *a1 = &unk_1F387A908;
  uint64_t v2 = a1[20];
  a1[20] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (uint64_t *)a1[19];
  a1[19] = 0;
  if (v3) {
    sub_1DD269308(a1 + 152, v3);
  }
  signed int v4 = sub_1DD25C64C(a1);
  operator delete(v4);
}

uint64_t sub_1DD268360(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xEEEEEEEEEEEEEEEFLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x222222222222222) {
    sub_1DD251DAC();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xEEEEEEEEEEEEEEEFLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x111111111111111) {
    unint64_t v9 = 0x222222222222222;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v17 = a1 + 2;
  if (v9) {
    unsigned int v10 = (char *)sub_1DD2684F0(v7, v9);
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v13 = v10;
  int v14 = &v10[120 * v4];
  uint64_t v16 = &v10[120 * v9];
  sub_1DD23FC14((uint64_t)v14, a2);
  int v15 = v14 + 120;
  sub_1DD268468(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1DD268580((uint64_t)&v13);
  return v11;
}

void sub_1DD268454(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD268580((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD268468(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 120;
    uint64_t result = sub_1DD268538(result - 120, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_1DD2684F0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x222222222222223) {
    sub_1DD251C54();
  }
  return operator new(120 * a2);
}

uint64_t sub_1DD268538(uint64_t a1, uint64_t a2)
{
  if (a1 != a2) {
    sub_1DD240EA8(a1, a2);
  }
  return a1;
}

uint64_t sub_1DD268580(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 120);
    *(void *)(a1 + 16) = i - 120;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DD2685EC(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1DD268640((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1DD268640(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (v2 != *a1)
  {
    uint64_t v4 = a1[1];
    do
    {
      uint64_t v6 = *(void **)(v4 - 24);
      v4 -= 24;
      uint64_t v5 = v6;
      if (v6)
      {
        *(void *)(v2 - 16) = v5;
        operator delete(v5);
      }
      uint64_t v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1DD268698(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1DD268698(a1, *a2);
    sub_1DD268698(a1, a2[1]);
    operator delete(a2);
  }
}

void sub_1DD2686EC(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 17) = 1;
  if (*(char *)(a2 + 23) < 0) {
    sub_1DD24F980(&__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::string::operator=((std::string *)(a1 + 40), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD268764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD268780(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 18) = 1;
  if (*(char *)(a2 + 23) < 0) {
    sub_1DD24F980(&__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  std::string::operator=((std::string *)(a1 + 64), &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD2687F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD268814(void *result, char *a2, char *a3, unint64_t a4)
{
  uint64_t v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DD239EFC();
  }
  if (a4 > 0x16)
  {
    uint64_t v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17) {
      uint64_t v8 = a4 | 7;
    }
    uint64_t v9 = v8 + 1;
    uint64_t result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *uint64_t v4 = result;
    uint64_t v4 = result;
  }
  else
  {
    *((unsigned char *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    char v10 = *a2++;
    *(unsigned char *)uint64_t v4 = v10;
    uint64_t v4 = (void *)((char *)v4 + 1);
  }
  *(unsigned char *)uint64_t v4 = 0;
  return result;
}

__n128 sub_1DD2688BC(uint64_t a1, __n128 *a2)
{
  if (!*(unsigned char *)(a1 + 1))
  {
    *(_WORD *)(a1 + 1) = 257;
    __n128 v5 = *a2;
    *(_DWORD *)(a1 + 64) = a2[1].n128_u32[0];
    *(__n128 *)(a1 + 48) = v5;
    __n128 result = *a2;
    *(_DWORD *)(a1 + 40) = a2[1].n128_u32[0];
    *(__n128 *)(a1 + 24) = result;
    return result;
  }
  __n128 v13 = *a2;
  unint64_t v14 = a2[1].n128_u64[0];
  long long v11 = *(_OWORD *)(a1 + 24);
  uint64_t v12 = *(void *)(a1 + 40);
  if (sub_1DD268A80((uint64_t)&v13, (uint64_t)&v11))
  {
    uint64_t v4 = (__n128 *)(a1 + 24);
  }
  else
  {
    long long v9 = *(_OWORD *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 64);
    __n128 v7 = *a2;
    unint64_t v8 = a2[1].n128_u64[0];
    if (!sub_1DD268A80((uint64_t)&v9, (uint64_t)&v7)) {
      return result;
    }
    uint64_t v4 = (__n128 *)(a1 + 48);
  }
  __n128 result = *a2;
  v4[1].n128_u32[0] = a2[1].n128_u32[0];
  *uint64_t v4 = result;
  return result;
}

uint64_t sub_1DD268998(uint64_t result, uint64_t *a2)
{
  if (*(unsigned char *)(result + 19))
  {
    uint64_t v3 = result;
    char v11 = 0;
    uint64_t v4 = *(void *)(result + 88);
    unint64_t v5 = *(void *)(result + 96);
    int v6 = *(_DWORD *)(result + 104);
    int v7 = *((_DWORD *)a2 + 4);
    if (v6 <= v7)
    {
      if (v6 < v7)
      {
        __n128 result = sub_1DD26EA78(*(void *)(result + 88), v5, v7 - v6, &v11);
        uint64_t v4 = result;
        unint64_t v5 = v9;
        int v6 = *((_DWORD *)a2 + 4);
      }
    }
    else
    {
      __n128 result = sub_1DD26EA78(*a2, a2[1], v6 - v7, &v11);
      *a2 = result;
      a2[1] = v8;
    }
    if (v11)
    {
      *(unsigned char *)(v3 + 19) = 0;
      return result;
    }
    unsigned long long v10 = __PAIR128__(*a2, a2[1]) + __PAIR128__(v4, v5);
    if (*a2)
    {
      if (((*a2 ^ v4) & 0x8000000000000000) == 0) {
        goto LABEL_10;
      }
    }
    else if ((v4 & 0x8000000000000000) == 0)
    {
LABEL_10:
      *(unsigned char *)(v3 + 19) = (*((void *)&v10 + 1) ^ v4) >= 0;
      if ((*((void *)&v10 + 1) ^ v4) < 0) {
        return result;
      }
      goto LABEL_11;
    }
    if (!*(unsigned char *)(v3 + 19)) {
      return result;
    }
LABEL_11:
    *(void *)(v3 + 88) = *((void *)&v10 + 1);
    *(void *)(v3 + 96) = v10;
    *(_DWORD *)(v3 + 104) = v6;
  }
  return result;
}

uint64_t sub_1DD268A80(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1DD26EBFC(*(void *)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 16));
  unint64_t v6 = v5;
  uint64_t v7 = sub_1DD26EBFC(*(void *)a2, *(void *)(a2 + 8), *(_DWORD *)(a2 + 16));
  uint64_t v9 = v7;
  unint64_t v10 = v8;
  if (v4 != v7)
  {
    if (v4 >= v7)
    {
      if (v4 > v7) {
        return 0;
      }
      goto LABEL_9;
    }
    return 1;
  }
  if (v6 < v8) {
    return 1;
  }
  if (v6 > v8) {
    return 0;
  }
LABEL_9:
  char v31 = 0;
  uint64_t v11 = *(void *)a1 >> 63;
  uint64_t v13 = sub_1DD26EA78(v4, v6, *(_DWORD *)(a1 + 16), &v31);
  unint64_t v14 = *(void *)(a1 + 8);
  BOOL v16 = v14 >= v15;
  unint64_t v17 = v14 - v15;
  uint64_t v18 = !v16;
  *(void *)a1 = *(void *)a1 - v13 - v18;
  *(void *)(a1 + 8) = v17;
  uint64_t v19 = sub_1DD26EA78(v9, v10, *(_DWORD *)(a2 + 16), &v31);
  unint64_t v20 = *(void *)(a2 + 8);
  uint64_t v21 = *(void *)a2 - v19;
  BOOL v16 = v20 >= v22;
  unint64_t v23 = v20 - v22;
  uint64_t v24 = !v16;
  *(void *)a2 = v21 - v24;
  *(void *)(a2 + 8) = v23;
  int v25 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16);
  if (v25 < 1)
  {
    uint64_t v28 = sub_1DD26EA78(*(void *)a1, *(void *)(a1 + 8), *(_DWORD *)(a2 + 16) - *(_DWORD *)(a1 + 16), &v31);
    *(void *)a1 = v28;
    *(void *)(a1 + 8) = v29;
    if (v31) {
      return v11;
    }
    uint64_t v30 = *(void *)a2;
  }
  else
  {
    uint64_t v26 = sub_1DD26EA78(v21 - v24, v23, v25, &v31);
    *(void *)a2 = v26;
    *(void *)(a2 + 8) = v27;
    if (v31) {
      return v11 ^ 1;
    }
    uint64_t v30 = v26;
    uint64_t v28 = *(void *)a1;
  }
  if (v28 == v30) {
    return *(void *)(a1 + 8) < *(void *)(a2 + 8);
  }
  else {
    return v28 < v30;
  }
}

uint64_t sub_1DD268C04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_1DD260528(a1, a2, a3, a4) = &unk_1F3879B08;
  *(void *)(a1 + 312) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  uint64_t v7 = sub_1DD291588(a4);
  sub_1DD26FA14(a1 + 320, v7);
  sub_1DD26F9D0(a1 + 320, 6 * *(void *)(a1 + 312));
  return a1;
}

void sub_1DD268CB4(_Unwind_Exception *a1)
{
  sub_1DD2701B4(v2);
  sub_1DD268CD8(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD268CD8(uint64_t a1)
{
  *(void *)a1 = &unk_1F387A220;
  uint64_t v2 = *(void **)(a1 + 288);
  if (v2)
  {
    *(void *)(a1 + 296) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 248);
  if (v3)
  {
    *(void *)(a1 + 256) = v3;
    operator delete(v3);
  }
  unint64_t v10 = (void **)(a1 + 216);
  sub_1DD2685EC(&v10);
  sub_1DD268698(a1 + 192, *(void **)(a1 + 200));
  uint64_t v4 = *(uint64_t **)(a1 + 184);
  *(void *)(a1 + 184) = 0;
  if (v4) {
    sub_1DD269308(a1 + 184, v4);
  }
  uint64_t v5 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(a1 + 168);
  *(void *)(a1 + 168) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = *(uint64_t **)(a1 + 160);
  *(void *)(a1 + 160) = 0;
  if (v7) {
    sub_1DD269308(a1 + 160, v7);
  }
  uint64_t v8 = *(void *)(a1 + 152);
  *(void *)(a1 + 152) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  return sub_1DD25C64C((void *)a1);
}

uint64_t sub_1DD268E1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)sub_1DD260528(a1, a2, a3, a4) = &unk_1F387A520;
  *(void *)(a1 + 312) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  return a1;
}

void sub_1DD268E90(_Unwind_Exception *a1)
{
  sub_1DD268CD8(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD268EA4(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    sub_1DD251DAC();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x333333333333333) {
    unint64_t v9 = 0x666666666666666;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1DD269034(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  unint64_t v14 = &v10[40 * v4];
  BOOL v16 = &v10[40 * v9];
  sub_1DD24302C((uint64_t)v14, a2);
  unint64_t v15 = v14 + 40;
  sub_1DD268FAC(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1DD2690C4((uint64_t)&v13);
  return v11;
}

void sub_1DD268F98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD2690C4((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_1DD268FAC(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  __n128 result = (void *)a2[1];
  while (v4 != v5)
  {
    v4 -= 40;
    __n128 result = sub_1DD26907C(result - 5, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *sub_1DD269034(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    sub_1DD251C54();
  }
  return operator new(40 * a2);
}

void *sub_1DD26907C(void *a1, uint64_t a2)
{
  if (a1 != (void *)a2) {
    sub_1DD24367C((uint64_t)a1, a2);
  }
  return a1;
}

uint64_t sub_1DD2690C4(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 40);
    *(void *)(a1 + 16) = i - 40;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_1DD269130(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x666666666666666) {
    sub_1DD251DAC();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x333333333333333) {
    unint64_t v9 = 0x666666666666666;
  }
  else {
    unint64_t v9 = v5;
  }
  unint64_t v17 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1DD269034(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v13 = v10;
  unint64_t v14 = &v10[40 * v4];
  BOOL v16 = &v10[40 * v9];
  sub_1DD243878(v14, a2);
  unint64_t v15 = v14 + 40;
  sub_1DD269238(a1, &v13);
  uint64_t v11 = a1[1];
  sub_1DD2690C4((uint64_t)&v13);
  return v11;
}

void sub_1DD269224(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD2690C4((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD269238(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t result = a2[1];
  while (v4 != v5)
  {
    v4 -= 40;
    uint64_t result = sub_1DD2692C0(result - 40, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD2692C0(uint64_t a1, uint64_t a2)
{
  if (a1 != a2) {
    sub_1DD243ED0(a1, a2);
  }
  return a1;
}

void sub_1DD269308(int a1, uint64_t *__p)
{
  if (__p)
  {
    uint64_t v3 = *__p;
    *std::string __p = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    operator delete(__p);
  }
}

_OWORD *sub_1DD269374(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (void **)sub_1DD269400((uint64_t)a1, &v9, a2);
  uint64_t v6 = *v5;
  if (!*v5)
  {
    uint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = operator new(0x38uLL);
    v6[2] = *(_OWORD *)a3;
    *((void *)v6 + 6) = *(void *)(a3 + 16);
    sub_1DD2694DC(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

void *sub_1DD269400(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v6 = *(const void **)a3;
    size_t v7 = *(void *)(a3 + 8);
    do
    {
      while (1)
      {
        uint64_t v8 = (void *)v4;
        uint64_t v9 = *(const void **)(v4 + 32);
        size_t v10 = *(void *)(v4 + 40);
        if (v10 >= v7) {
          size_t v11 = v7;
        }
        else {
          size_t v11 = *(void *)(v4 + 40);
        }
        int v12 = memcmp(v6, *(const void **)(v4 + 32), v11);
        BOOL v13 = v7 < v10;
        if (v12) {
          BOOL v13 = v12 < 0;
        }
        if (!v13) {
          break;
        }
        uint64_t v4 = *v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_17;
        }
      }
      int v14 = memcmp(v9, v6, v11);
      BOOL v15 = v10 < v7;
      if (v14) {
        BOOL v15 = v14 < 0;
      }
      if (!v15) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_17:
  *a2 = v8;
  return v5;
}

uint64_t *sub_1DD2694DC(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  uint64_t v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  uint64_t result = sub_1DD269534(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1DD269534(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      uint64_t v3 = (uint64_t *)v2[2];
      uint64_t v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            uint64_t v9 = (uint64_t **)a2[2];
          }
          else
          {
            uint64_t v9 = (uint64_t **)v2[1];
            size_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              void v10[2] = (uint64_t)v2;
              uint64_t v3 = (uint64_t *)v2[2];
            }
            void v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            const void *v9 = v2;
            v2[2] = (uint64_t)v9;
            uint64_t v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          uint64_t *v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), uint64_t v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            uint64_t v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          uint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      *uint64_t v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void *sub_1DD2696CC(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD269740(a1, a2);
    uint64_t v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1DD269724(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1DD269740(void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    sub_1DD251DAC();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t sub_1DD269784(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD269844((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1DD2697FC(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1DD251C54();
  }
  return operator new(24 * a2);
}

uint64_t sub_1DD269844(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_1DD2698E8((uint64_t)v11);
  return v9;
}

uint64_t sub_1DD2698E8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD269920(a1);
  }
  return a1;
}

void sub_1DD269920(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(void **)v1;
    if (*(void *)v1)
    {
      *(void *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t sub_1DD269968(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DD2699A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != a2)
  {
    uint64_t v5 = *(void **)(v2 - 24);
    *(void *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(void *)(v2 - 16) = v5;
      operator delete(v5);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void *sub_1DD2699FC(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD269A74(a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1DD269A58(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1DD269A74(void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_1DD251DAC();
  }
  uint64_t result = (char *)sub_1DD251DC4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *sub_1DD269AB8(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD269A74(a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1DD269B20(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD269B3C(void *a1, unint64_t a2, void *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD269A74(a1, a2);
    uint64_t v6 = (void *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1DD269BA4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD269BC0()
{
  sub_1DD250F88((uint64_t)v3);
  uint64_t v0 = (void *)std::ostream::operator<<();
  char v6 = 46;
  sub_1DD239B24(v0, (uint64_t)&v6, 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA408];
  uint64_t v1 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v3[2] = v1;
  v3[3] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[11]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD269D50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t *sub_1DD269D64()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1F828, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1F828))
  {
    qword_1EAB1F858 = 0xB00000000;
    __cxa_guard_release(&qword_1EAB1F828);
  }
  return &qword_1EAB1F858;
}

uint64_t *sub_1DD269DC0()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1F830, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1F830))
  {
    qword_1EAB1F860 = 0xC00000000;
    __cxa_guard_release(&qword_1EAB1F830);
  }
  return &qword_1EAB1F860;
}

uint64_t sub_1DD269E1C(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  size_t v10 = sub_1DD239FA4((void *)a1, a6, a2, a4, a5);
  void *v10 = &unk_1F387A818;
  sub_1DD270124(v10 + 4, a6, a5);
  *(_DWORD *)(a1 + 72) = a3;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  return a1;
}

void sub_1DD269E94(_Unwind_Exception *a1)
{
  sub_1DD23A0A0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD269EA8(uint64_t result, int a2)
{
  int v2 = *(_DWORD *)(result + 88);
  BOOL v3 = __OFSUB__(v2, a2);
  int v4 = v2 - a2;
  if (v4 < 0 != v3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Can't backup that much!");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  *(_DWORD *)(result + 88) = v4;
  return result;
}

void sub_1DD269F0C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD269F20(uint64_t a1)
{
  uint64_t v5 = 0;
  int v4 = 0;
  if (((*(uint64_t (**)(uint64_t, uint64_t *, int *))(*(void *)a1 + 16))(a1, &v5, &v4) & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to flush compression buffer.");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_1DD23A270(a1, *(_DWORD *)(a1 + 96) - *(_DWORD *)(a1 + 92));
  *(_DWORD *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  return sub_1DD23A504(a1);
}

void sub_1DD269FD8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD269FEC(uint64_t a1)
{
  return sub_1DD23A4F8(a1) - *(int *)(a1 + 96) + *(int *)(a1 + 92);
}

uint64_t sub_1DD26A01C(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 96);
  int v3 = *(_DWORD *)(result + 92) + 3;
  int v4 = v3 - v2;
  if (v3 >= v2)
  {
    uint64_t result = sub_1DD23A200(result, (void *)(result + 80), (_DWORD *)(result + 96));
    if ((result & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Failed to get next output buffer from output stream.");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    int v3 = v4;
  }
  *(_DWORD *)(v1 + 92) = v3;
  return result;
}

void sub_1DD26A0A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26A0B8(uint64_t a1, void *a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 88))
  {
    sub_1DD26A01C(a1);
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
    unint64_t v7 = *(int *)(a1 + 88);
    uint64_t v8 = (char *)(*(void *)(a1 + 80) + *(int *)(a1 + 92) - v6);
    if (v6 >= v7)
    {
      *(v8 - 3) = (2 * v7) | 1;
      *(v8 - 2) = v7 >> 7;
      *(v8 - 1) = v7 >> 15;
      memcpy(v8, *(const void **)(a1 + 48), *(int *)(a1 + 88));
      unsigned int v9 = v6 - *(_DWORD *)(a1 + 88);
      sub_1DD23A270(a1, v9);
      *(int32x2_t *)(a1 + 92) = vsub_s32(*(int32x2_t *)(a1 + 92), vdup_n_s32(v9));
    }
    else
    {
      *(_WORD *)(v8 - 3) = __PAIR16__((2 * v6) >> 56, 2 * v6);
      *(v8 - 1) = v6 >> 15;
    }
  }
  *a2 = *(void *)(a1 + 48);
  int v10 = *(_DWORD *)(a1 + 56);
  *a3 = v10;
  *(_DWORD *)(a1 + 88) = v10;
  return 1;
}

uint64_t sub_1DD26A1BC(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v7 = (void *)sub_1DD269E1C(a1, a2, a3, a4, a5, a6);
  void *v7 = &unk_1F387AB98;
  sub_1DD26A218((uint64_t)v7);
  return a1;
}

void sub_1DD26A204(_Unwind_Exception *a1)
{
  sub_1DD26A2B4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26A218(uint64_t a1)
{
  *(void *)(a1 + 104) = 0;
  uint64_t v1 = (void *)(a1 + 104);
  v1[9] = 0;
  v1[10] = 0;
  v1[8] = 0;
  uint64_t result = sub_1DD2EDAAC(v1, *((_DWORD *)v1 - 8), 8, 0xFFFFFFF1, 8, 0, "1.2.13", 112);
  if (result)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Error while calling deflateInit2() for zlib.");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  return result;
}

void sub_1DD26A2A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD26A2B4(void *a1)
{
  *a1 = &unk_1F387A818;
  sub_1DD2704D4((uint64_t)(a1 + 4));
  return sub_1DD23A0A0(a1);
}

uint64_t sub_1DD26A308(uint64_t a1)
{
  uint64_t v2 = a1 + 104;
  if (sub_1DD2EDE10(a1 + 104))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to reset inflate.");
LABEL_13:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  int v3 = *(_DWORD *)(a1 + 96);
  int v4 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 112) = *(_DWORD *)(a1 + 88);
  *(void *)(a1 + 104) = *(void *)(a1 + 48);
  while (1)
  {
    if (v4 < v3) {
      goto LABEL_6;
    }
    if ((sub_1DD23A200(a1, (void *)(a1 + 80), (_DWORD *)(a1 + 96)) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Failed to get next output buffer from output stream.");
      goto LABEL_13;
    }
    int v4 = 0;
    *(_DWORD *)(a1 + 92) = 0;
    int v3 = *(_DWORD *)(a1 + 96);
LABEL_6:
    *(void *)(a1 + 128) = *(void *)(a1 + 80) + v4;
    *(_DWORD *)(a1 + 136) = v3 - v4;
    int v5 = sub_1DD2EE214(v2, 4);
    int v3 = *(_DWORD *)(a1 + 96);
    int v6 = *(_DWORD *)(a1 + 136);
    int v4 = v3 - v6;
    *(_DWORD *)(a1 + 92) = v3 - v6;
    if (v5) {
      break;
    }
    if (v6) {
      return *(void *)(a1 + 144);
    }
  }
  if (v5 != 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Failed to deflate input data.");
    goto LABEL_13;
  }
  return *(void *)(a1 + 144);
}

void sub_1DD26A43C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD26A458@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "ZlibCompressionStream");
}

uint64_t sub_1DD26A468(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_1F387AED0;
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 24) = 0;
  sub_1DD26FA14(a1 + 144, a4);
  uint64_t v6 = *a2;
  *a2 = 0;
  uint64_t v7 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v6;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 56) = *(void *)(a1 + 160);
  *(_DWORD *)(a1 + 64) = *(void *)(a1 + 16);
  int v8 = sub_1DD2F0604((void *)(a1 + 32), 0xFFFFFFF1, "1.2.13", 112);
  if (v8)
  {
    switch(v8)
    {
      case -6:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Version error from inflateInit2");
        break;
      case -4:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Memory error from inflateInit2");
        break;
      case -2:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Stream error from inflateInit2");
        break;
      default:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Unknown error from inflateInit2");
        break;
    }
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  *(_DWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  return a1;
}

void sub_1DD26A5EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v3);
  sub_1DD2701B4(v2);
  uint64_t v5 = *(void *)(v1 + 24);
  *(void *)(v1 + 24) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  nullsub_1(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26A65C(void *a1)
{
  *a1 = &unk_1F387AED0;
  if (sub_1DD2F21EC((uint64_t)(a1 + 4)))
  {
    sub_1DD239B24(MEMORY[0x1E4FBA250], (uint64_t)"Error in ~ZlibDecompressionStream() ", 36);
    uint64_t v2 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v2, (uint64_t)"\n", 1);
  }
  sub_1DD2701B4(a1 + 18);
  uint64_t v3 = a1[3];
  a1[3] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return nullsub_1(a1);
}

void sub_1DD26A728(void *a1)
{
  uint64_t v1 = (void *)sub_1DD26A65C(a1);
  operator delete(v1);
}

uint64_t sub_1DD26A750(uint64_t a1, void *a2, int *a3)
{
  uint64_t v6 = *(void *)(a1 + 200);
  if (!v6)
  {
    int v7 = *(_DWORD *)(a1 + 184);
    if (!v7 || !*(void *)(a1 + 208))
    {
      sub_1DD26AA4C(a1);
      int v7 = *(_DWORD *)(a1 + 184);
    }
    if (v7 == 4) {
      return 0;
    }
    uint64_t v9 = *(void *)(a1 + 216);
    uint64_t v10 = *(void *)(a1 + 224);
    if (v9 == v10)
    {
      sub_1DD26AAD0(a1, 1);
      uint64_t v9 = *(void *)(a1 + 216);
      uint64_t v10 = *(void *)(a1 + 224);
      int v7 = *(_DWORD *)(a1 + 184);
    }
    unint64_t v11 = v10 - v9;
    if (*(void *)(a1 + 208) >= v11) {
      unint64_t v12 = v11;
    }
    else {
      unint64_t v12 = *(void *)(a1 + 208);
    }
    if (v7 == 1)
    {
      *(void *)(a1 + 32) = v9;
      *(_DWORD *)(a1 + 40) = v12;
      uint64_t v15 = *(void *)(a1 + 160);
      *(void *)(a1 + 192) = v15;
      *(void *)(a1 + 56) = v15;
      *(_DWORD *)(a1 + 64) = *(void *)(a1 + 16);
      sub_1DD2F04E4((void *)(a1 + 32));
      if (!v16)
      {
        while (2)
        {
          if (v12 == *(void *)(a1 + 208)) {
            int v17 = 4;
          }
          else {
            int v17 = 2;
          }
          int v18 = sub_1DD2F06F0(a1 + 32, v17);
          switch(v18)
          {
            case -5:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "Buffer error in ZlibDecompressionStream::Next");
              goto LABEL_33;
            case -3:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "Data error in ZlibDecompressionStream::Next");
              goto LABEL_33;
            case -2:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "Stream error in ZlibDecompressionStream::Next");
              goto LABEL_33;
            case 0:
              unint64_t v19 = *(void *)(a1 + 216) + v12;
              *(void *)(a1 + 208) -= v12;
              *(void *)(a1 + 216) = v19;
              sub_1DD26AAD0(a1, 1);
              uint64_t v20 = *(void *)(a1 + 216);
              if (*(void *)(a1 + 208) >= (unint64_t)(*(void *)(a1 + 224) - v20)) {
                unint64_t v12 = *(void *)(a1 + 224) - v20;
              }
              else {
                unint64_t v12 = *(void *)(a1 + 208);
              }
              *(void *)(a1 + 32) = v20;
              *(_DWORD *)(a1 + 40) = v12;
              goto LABEL_25;
            case 1:
LABEL_25:
              if (v18 != 1) {
                continue;
              }
              int v21 = *(_DWORD *)(a1 + 16) - *(_DWORD *)(a1 + 64);
              *a3 = v21;
              *a2 = *(void *)(a1 + 192);
              uint64_t v14 = v21;
              *(void *)(a1 + 192) += v21;
              *(void *)(a1 + 200) = 0;
              uint64_t v13 = *(void *)(a1 + 216);
              break;
            default:
              exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
              std::logic_error::logic_error(exception, "Unknown error in ZlibDecompressionStream::Next");
              goto LABEL_33;
          }
          goto LABEL_27;
        }
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Bad inflateReset in ZlibDecompressionStream::Next");
    }
    else
    {
      if (v7 == 3)
      {
        *a2 = v9;
        *a3 = v12;
        uint64_t v13 = *(void *)(a1 + 216);
        *(void *)(a1 + 192) = v13 + v12;
        *(void *)(a1 + 200) = 0;
        uint64_t v14 = (int)v12;
LABEL_27:
        *(void *)(a1 + 208) -= v12;
        *(void *)(a1 + 216) = v13 + v12;
        *(void *)(a1 + 232) += v14;
        return 1;
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unknown compression state in ZlibDecompressionStream::Next");
    }
LABEL_33:
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  *a2 = *(void *)(a1 + 192);
  *a3 = v6;
  *(void *)(a1 + 192) += v6;
  *(void *)(a1 + 200) = 0;
  return 1;
}

void sub_1DD26AA08(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26AA4C(uint64_t a1)
{
  uint64_t result = sub_1DD26CDA0(a1, 0);
  if (*(_DWORD *)(a1 + 184) == 4)
  {
    uint64_t v3 = 0;
  }
  else
  {
    int v4 = result;
    unsigned int v5 = sub_1DD26CDA0(a1, 1) << 8;
    uint64_t result = sub_1DD26CDA0(a1, 1);
    if (v4) {
      int v6 = 3;
    }
    else {
      int v6 = 1;
    }
    *(_DWORD *)(a1 + 184) = v6;
    uint64_t v3 = (v5 | (result << 16) | v4) >> 1;
  }
  *(void *)(a1 + 208) = v3;
  return result;
}

uint64_t sub_1DD26AAD0(uint64_t a1, int a2)
{
  int v7 = 0;
  int v4 = (void *)(a1 + 216);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), a1 + 216, &v7);
  if (result)
  {
    *(void *)(a1 + 224) = *(void *)(a1 + 216) + v7;
  }
  else
  {
    if (a2)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Read past EOF in ZlibDecompressionStream::readBuffer");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    *(_DWORD *)(a1 + 184) = 4;
    *int v4 = 0;
    *(void *)(a1 + 224) = 0;
  }
  return result;
}

void sub_1DD26AB9C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD26ABB0(void *result, int a2)
{
  uint64_t v2 = result[24];
  if (!v2 || result[25])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Backup without previous Next in ZlibDecompressionStream");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  result[24] = v2 - a2;
  result[25] = a2;
  result[29] -= a2;
  return result;
}

void sub_1DD26AC2C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26AC40(void *a1, int a2)
{
  a1[29] += a2;
  if (a2 >= 1)
  {
    int v2 = a2;
    while (1)
    {
      uint64_t v7 = 0;
      int v6 = 0;
      if (((*(uint64_t (**)(void *, uint64_t *, int *))(*a1 + 16))(a1, &v7, &v6) & 1) == 0) {
        return 0;
      }
      if (v6 > v2) {
        break;
      }
      BOOL v4 = __OFSUB__(v2, v6);
      v2 -= v6;
      if ((v2 < 0) ^ v4 | (v2 == 0)) {
        return 1;
      }
    }
    (*(void (**)(void *, void))(*a1 + 24))(a1, (v6 - v2));
  }
  return 1;
}

uint64_t sub_1DD26AD08(uint64_t a1)
{
  return *(void *)(a1 + 232);
}

uint64_t sub_1DD26AD10(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 224) = 0;
  (*(void (**)(void))(**(void **)(a1 + 24) + 48))(*(void *)(a1 + 24));
  *(void *)(a1 + 232) = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24));
  uint64_t v4 = sub_1DD238FA4(a2);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v4);
  if ((result & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Bad skip in ZlibDecompressionStream::seek");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return result;
}

void sub_1DD26AE08(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26AE1C(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  int v2 = sub_1DD239B24(v9, (uint64_t)"zlib(", 5);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 24) + 56))(__p);
  if ((v8 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)")", 1);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD26AFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1DD26AFFC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_1F387AF20;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a4;
  sub_1DD26FA14(a1 + 24, a4);
  sub_1DD26FA14(a1 + 64, *(void *)(a1 + 16));
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  uint64_t v6 = *a2;
  *a2 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v6;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  return a1;
}

void sub_1DD26B0B8(_Unwind_Exception *a1)
{
  sub_1DD2701B4(v2);
  uint64_t v4 = *(void *)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  nullsub_1(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26B10C(uint64_t a1, char **a2, _DWORD *a3)
{
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6)
  {
    *a2 = *(char **)(a1 + 112);
    *a3 = v6;
    uint64_t v7 = *(void *)(a1 + 112) + v6;
    *(void *)(a1 + 152) += v6;
    *(void *)(a1 + 112) = v7;
    *(void *)(a1 + 120) = 0;
  }
  else
  {
    int v8 = *(_DWORD *)(a1 + 104);
    if (!v8 || !*(void *)(a1 + 128))
    {
      sub_1DD26B30C(a1);
      int v8 = *(_DWORD *)(a1 + 104);
    }
    if (v8 == 4) {
      return 0;
    }
    uint64_t v11 = *(char **)(a1 + 136);
    char v10 = *(char **)(a1 + 144);
    if (v11 == v10)
    {
      sub_1DD26B390(a1, 1);
      uint64_t v11 = *(char **)(a1 + 136);
      char v10 = *(char **)(a1 + 144);
      int v8 = *(_DWORD *)(a1 + 104);
    }
    size_t v12 = v10 - v11;
    size_t v13 = *(void *)(a1 + 128);
    if (v13 >= v12) {
      size_t v14 = v12;
    }
    else {
      size_t v14 = *(void *)(a1 + 128);
    }
    if (v8 == 1)
    {
      if (v13 <= v12)
      {
        *(void *)(a1 + 136) = &v11[v14];
      }
      else
      {
        if (*(void *)(a1 + 56) < v13)
        {
          sub_1DD26F9D0(a1 + 24, *(void *)(a1 + 128));
          uint64_t v11 = *(char **)(a1 + 136);
        }
        memcpy(*(void **)(a1 + 40), v11, v14);
        size_t v17 = *(void *)(a1 + 128);
        *(void *)(a1 + 136) += v14;
        uint64_t v11 = *(char **)(a1 + 40);
        while (v14 < v17)
        {
          sub_1DD26B390(a1, 1);
          int v18 = *(const void **)(a1 + 136);
          if (*(void *)(a1 + 128) - v14 >= *(void *)(a1 + 144) - (void)v18) {
            size_t v19 = *(void *)(a1 + 144) - (void)v18;
          }
          else {
            size_t v19 = *(void *)(a1 + 128) - v14;
          }
          memcpy((void *)(*(void *)(a1 + 40) + v14), v18, v19);
          v14 += v19;
          size_t v17 = *(void *)(a1 + 128);
          *(void *)(a1 + 136) += v19;
        }
      }
      uint64_t v16 = (*(uint64_t (**)(uint64_t, char *))(*(void *)a1 + 64))(a1, v11);
      *(_DWORD *)(a1 + 104) = 0;
      *a2 = *(char **)(a1 + 80);
      *a3 = v16;
      uint64_t v20 = *(void *)(a1 + 80) + v16;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 112) = v20;
    }
    else if (v8 == 3)
    {
      *a2 = v11;
      *a3 = v14;
      size_t v15 = *(void *)(a1 + 136) + v14;
      *(void *)(a1 + 112) = v15;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 128) = v13 - v14;
      *(void *)(a1 + 136) = v15;
      LODWORD(v16) = v14;
    }
    else
    {
      LODWORD(v16) = *a3;
    }
    *(void *)(a1 + 152) += (int)v16;
  }
  return 1;
}

uint64_t sub_1DD26B30C(uint64_t a1)
{
  uint64_t result = sub_1DD26CDF8(a1, 0);
  if (*(_DWORD *)(a1 + 104) == 4)
  {
    uint64_t v3 = 0;
  }
  else
  {
    int v4 = result;
    unsigned int v5 = sub_1DD26CDF8(a1, 1) << 8;
    uint64_t result = sub_1DD26CDF8(a1, 1);
    if (v4) {
      int v6 = 3;
    }
    else {
      int v6 = 1;
    }
    *(_DWORD *)(a1 + 104) = v6;
    uint64_t v3 = (v5 | (result << 16) | v4) >> 1;
  }
  *(void *)(a1 + 128) = v3;
  return result;
}

uint64_t sub_1DD26B390(uint64_t a1, int a2)
{
  int v11 = 0;
  int v4 = (void *)(a1 + 136);
  uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), a1 + 136, &v11);
  if (result)
  {
    *(void *)(a1 + 144) = *(void *)(a1 + 136) + v11;
  }
  else
  {
    if (a2)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 56))(&v9, a1);
      uint64_t v7 = std::string::append(&v9, "read past EOF");
      long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v10.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      sub_1DD26D86C(exception, &v10);
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    *(_DWORD *)(a1 + 104) = 4;
    *int v4 = 0;
    *(void *)(a1 + 144) = 0;
  }
  return result;
}

void sub_1DD26B4BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

void *sub_1DD26B51C(void *result, int a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[14];
  if (!v3 || result[15])
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    (*(void (**)(std::string *__return_ptr, void *))(*v2 + 56))(&v7, v2);
    unsigned int v5 = std::string::insert(&v7, 0, "Backup without previous Next in ");
    long long v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v8.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v8);
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  result[14] = v3 - a2;
  result[15] = a2;
  result[19] -= a2;
  return result;
}

void sub_1DD26B610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1DD26B670(void *a1, int a2)
{
  a1[19] += a2;
  if (a2 >= 1)
  {
    int v2 = a2;
    while (1)
    {
      uint64_t v7 = 0;
      int v6 = 0;
      if (((*(uint64_t (**)(void *, uint64_t *, int *))(*a1 + 16))(a1, &v7, &v6) & 1) == 0) {
        return 0;
      }
      if (v6 > v2) {
        break;
      }
      BOOL v4 = __OFSUB__(v2, v6);
      v2 -= v6;
      if ((v2 < 0) ^ v4 | (v2 == 0)) {
        return 1;
      }
    }
    (*(void (**)(void *, void))(*a1 + 24))(a1, (v6 - v2));
  }
  return 1;
}

uint64_t sub_1DD26B738(uint64_t a1)
{
  return *(void *)(a1 + 152);
}

uint64_t sub_1DD26B740(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 144) = 0;
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  uint64_t v4 = sub_1DD238FA4(a2);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 32))(a1, v4);
  if ((result & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 56))(&v9, a1);
    uint64_t v7 = std::string::insert(&v9, 0, "Bad skip in ");
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v10.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v10.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D86C(exception, &v10);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return result;
}

void sub_1DD26B880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

unint64_t sub_1DD26B8E0(uint64_t a1, unsigned char *a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v13 = 0;
  if ((sub_1DD2F435C(a2, a3, &v13) & 1) == 0) {
    goto LABEL_7;
  }
  if (v13 > a5)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Snappy length exceeds block size");
    int v11 = (struct type_info *)MEMORY[0x1E4FBA328];
    size_t v12 = (void (__cdecl *)(std::runtime_error *__hidden))MEMORY[0x1E4FBA1B0];
    goto LABEL_8;
  }
  if (!sub_1DD2F46F0((uint64_t)a2, a3, a4))
  {
LABEL_7:
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0((std::runtime_error *)exception, "SnappyDecompressionStream choked on corrupt input");
    int v11 = (struct type_info *)&unk_1F3877E48;
    size_t v12 = std::runtime_error::~runtime_error;
LABEL_8:
    __cxa_throw(exception, v11, (void (*)(void *))v12);
  }
  return v13;
}

void sub_1DD26B9DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

char *sub_1DD26B9F8(uint64_t a1, unint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  return sub_1DD26ED2C(a2, a2 + a3, a4, (unint64_t)&a4[a5]);
}

uint64_t sub_1DD26BA10(uint64_t a1, unsigned __int8 *a2, int a3, char *__dst, int a5)
{
  LODWORD(result) = sub_1DD238BEC(a2, __dst, a3, a5);
  if ((result & 0x80000000) != 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 56))(&v10, a1);
    long long v8 = std::string::append(&v10, " - failed to decompress");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v11.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v11.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D86C(exception, &v11);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return result;
}

void sub_1DD26BAF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1DD26BB50(uint64_t a1, void *a2, _DWORD *a3)
{
  if (*(_DWORD *)(a1 + 88))
  {
    sub_1DD26A01C(a1);
    unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1);
    unint64_t v7 = *(int *)(a1 + 88);
    long long v8 = (char *)(*(void *)(a1 + 80) + *(int *)(a1 + 92));
    if (v6 >= v7)
    {
      *(v8 - 3) = (2 * v7) | 1;
      *(v8 - 2) = v7 >> 7;
      *(v8 - 1) = v7 >> 15;
      std::string v10 = (const void **)(a1 + 48);
      int v9 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v9 = v6;
      *(_WORD *)(v8 - 3) = __PAIR16__((2 * v6) >> 56, 2 * v6);
      *(v8 - 1) = v6 >> 15;
      std::string v10 = (const void **)(a1 + 120);
    }
    if (v9 >= 1)
    {
      std::string v11 = (char *)*v10;
      size_t v12 = (int *)(a1 + 96);
      int v13 = *(_DWORD *)(a1 + 92);
      do
      {
        int v14 = *v12;
        if (v13 == *v12)
        {
          if ((sub_1DD23A200(a1, (void *)(a1 + 80), (_DWORD *)(a1 + 96)) & 1) == 0)
          {
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "Failed to get next output buffer from output stream.");
LABEL_20:
            __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
          }
          int v13 = 0;
          *(_DWORD *)(a1 + 92) = 0;
          long long v8 = *(char **)(a1 + 80);
          int v14 = *(_DWORD *)(a1 + 96);
        }
        else if (v13 > v14)
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "Write to an out-of-bound place!");
          goto LABEL_20;
        }
        int v15 = v14 - v13;
        if (v15 >= v9) {
          int v16 = v9;
        }
        else {
          int v16 = v15;
        }
        memcpy(v8, v11, v16);
        int v13 = *(_DWORD *)(a1 + 92) + v16;
        *(_DWORD *)(a1 + 92) = v13;
        v11 += v16;
        v8 += v16;
        BOOL v17 = __OFSUB__(v9, v16);
        v9 -= v16;
      }
      while (!((v9 < 0) ^ v17 | (v9 == 0)));
    }
  }
  *a2 = *(void *)(a1 + 48);
  int v18 = *(_DWORD *)(a1 + 56);
  *a3 = v18;
  *(_DWORD *)(a1 + 88) = v18;
  unint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1);
  sub_1DD26F9D0(a1 + 104, v19);
  return 1;
}

void sub_1DD26BD64(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26BD7C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

unint64_t sub_1DD26BDAC(uint64_t a1)
{
  return sub_1DD29A148(*(void *)(a1 + 144), *(char **)(a1 + 120), *(void *)(a1 + 128), *(char **)(a1 + 48), *(int *)(a1 + 88), *(_DWORD *)(a1 + 72));
}

void sub_1DD26BDC8(uint64_t a1)
{
  sub_1DD26D634();
  int v2 = (uint64_t *)off_1EC8AC288();
  uint64_t v3 = (std::__shared_weak_count *)v2[1];
  if (v3 && (uint64_t v3 = std::__shared_weak_count::lock(v3)) != 0) {
    uint64_t v4 = *v2;
  }
  else {
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(std::__shared_weak_count **)(a1 + 152);
  *(void *)(a1 + 144) = v4;
  *(void *)(a1 + 152) = v3;
  if (v5)
  {
    sub_1DD25B904(v5);
    uint64_t v4 = *(void *)(a1 + 144);
  }
  if (!v4)
  {
    uint64_t v6 = sub_1DD2981D0();
    sub_1DD26D44C(&v12, v6, (uint64_t)sub_1DD2982C0);
    sub_1DD26D634();
    uint64_t v7 = v12;
    long long v8 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    int v9 = (std::__shared_weak_count *)v2[1];
    *int v2 = v7;
    v2[1] = (uint64_t)v8;
    if (v9)
    {
      std::__shared_weak_count::__release_weak(v9);
      uint64_t v7 = v12;
      long long v8 = v13;
    }
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::string v10 = *(std::__shared_weak_count **)(a1 + 152);
    *(void *)(a1 + 144) = v7;
    *(void *)(a1 + 152) = v8;
    if (v10) {
      sub_1DD25B904(v10);
    }
    if (v13) {
      sub_1DD25B904(v13);
    }
    if (!*(void *)(a1 + 144))
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Error while calling ZSTD_createCCtx() for zstd.");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
}

void sub_1DD26BEF8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26BF0C(uint64_t a1)
{
  int v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t sub_1DD26BF3C(uint64_t a1, unint64_t a2, size_t a3, char *a4, uint64_t a5)
{
  return sub_1DD2DD6FC(*(void **)(a1 + 160), a4, a5, a2, a3);
}

void sub_1DD26BF5C(uint64_t a1)
{
  sub_1DD26D634();
  int v2 = (uint64_t *)off_1EC8AC2A0();
  uint64_t v3 = (std::__shared_weak_count *)v2[1];
  if (v3 && (uint64_t v3 = std::__shared_weak_count::lock(v3)) != 0) {
    uint64_t v4 = *v2;
  }
  else {
    uint64_t v4 = 0;
  }
  unsigned int v5 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 160) = v4;
  *(void *)(a1 + 168) = v3;
  if (v5)
  {
    sub_1DD25B904(v5);
    uint64_t v4 = *(void *)(a1 + 160);
  }
  if (!v4)
  {
    uint64_t v6 = sub_1DD2DCC54();
    sub_1DD26D540(&v12, (uint64_t)v6, (uint64_t)sub_1DD2DCC60);
    sub_1DD26D634();
    uint64_t v7 = v12;
    long long v8 = v13;
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    int v9 = (std::__shared_weak_count *)v2[1];
    *int v2 = v7;
    v2[1] = (uint64_t)v8;
    if (v9)
    {
      std::__shared_weak_count::__release_weak(v9);
      uint64_t v7 = v12;
      long long v8 = v13;
    }
    if (v8) {
      atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    std::string v10 = *(std::__shared_weak_count **)(a1 + 168);
    *(void *)(a1 + 160) = v7;
    *(void *)(a1 + 168) = v8;
    if (v10) {
      sub_1DD25B904(v10);
    }
    if (v13) {
      sub_1DD25B904(v13);
    }
    if (!*(void *)(a1 + 160))
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Error while calling ZSTD_createDCtx() for zstd.");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
}

void sub_1DD26C08C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26C0A0@<X0>(int a1@<W0>, uint64_t a2@<X1>, int a3@<W2>, unint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, void *a7@<X8>)
{
  if (a1 == 5)
  {
    if (a3) {
      int v14 = 3;
    }
    else {
      int v14 = 1;
    }
    uint64_t v12 = operator new(0xA0uLL);
    uint64_t result = sub_1DD26CE50((uint64_t)v12, a2, v14, a4, a5, a6);
  }
  else if (a1 == 1)
  {
    if (a3) {
      int v15 = -1;
    }
    else {
      int v15 = 2;
    }
    uint64_t v12 = operator new(0xD8uLL);
    uint64_t result = sub_1DD26A1BC((uint64_t)v12, a2, v15, a4, a5, a6);
  }
  else
  {
    if (a1)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(exception, "compression codec");
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
    }
    uint64_t v12 = operator new(0x20uLL);
    uint64_t result = (uint64_t)sub_1DD23A09C(v12, a6, a2, a4, a5);
  }
  *a7 = v12;
  return result;
}

void sub_1DD26C1C0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26C1EC@<X0>(uint64_t result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  switch((int)result)
  {
    case 0:
      uint64_t v9 = *a2;
      *a2 = 0;
      *a5 = v9;
      return result;
    case 1:
      int v16 = operator new(0xF0uLL);
      uint64_t v17 = *a2;
      *a2 = 0;
      uint64_t v28 = v17;
      sub_1DD26A468((uint64_t)v16, &v28, a3, a4);
      *a5 = (uint64_t)v16;
      uint64_t result = v28;
      if (v28)
      {
        int v18 = *(uint64_t (**)(void))(*(void *)v28 + 8);
        return v18();
      }
      return result;
    case 2:
      uint64_t v12 = operator new(0xA0uLL);
      uint64_t v13 = *a2;
      *a2 = 0;
      uint64_t v27 = v13;
      sub_1DD26CF9C(v12, &v27, a3, a4);
      *a5 = (uint64_t)v12;
      uint64_t result = v27;
      uint64_t v27 = 0;
      if (!result) {
        return result;
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    case 3:
      int v14 = operator new(0xA0uLL);
      uint64_t v15 = *a2;
      *a2 = 0;
      uint64_t v26 = v15;
      sub_1DD26D03C(v14, &v26, a3, a4);
      *a5 = (uint64_t)v14;
      uint64_t result = v26;
      uint64_t v26 = 0;
      if (!result) {
        return result;
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    case 4:
      std::string v10 = operator new(0xA0uLL);
      uint64_t v11 = *a2;
      *a2 = 0;
      uint64_t v25 = v11;
      sub_1DD26D0DC(v10, &v25, a3, a4);
      *a5 = (uint64_t)v10;
      uint64_t result = v25;
      uint64_t v25 = 0;
      if (!result) {
        return result;
      }
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    case 5:
      unint64_t v19 = operator new(0xB0uLL);
      uint64_t v20 = *a2;
      *a2 = 0;
      uint64_t v24 = v20;
      sub_1DD26D17C(v19, &v24, a3, a4);
      *a5 = (uint64_t)v19;
      uint64_t result = v24;
      uint64_t v24 = 0;
      if (result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
      return result;
    default:
      sub_1DD239280((uint64_t)v23);
      sub_1DD239B24(v23, (uint64_t)"Unknown compression codec ", 26);
      std::ostream::operator<<();
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      sub_1DD26D7D8(exception, &v22);
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
}

void sub_1DD26C474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1DD239418((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t sub_1DD26C550()
{
  return 1;
}

void sub_1DD26C55C(void *a1)
{
  uint64_t v1 = sub_1DD26D2D0(a1);
  operator delete(v1);
}

void sub_1DD26C588(void *a1)
{
  uint64_t v1 = (void *)sub_1DD26D244(a1);
  operator delete(v1);
}

uint64_t sub_1DD26C5B0(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  int v2 = sub_1DD239B24(v9, (uint64_t)"snappy(", 7);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 56))(__p);
  if ((v8 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)")", 1);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD26C760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1DD26C790(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  int v2 = sub_1DD239B24(v9, (uint64_t)"lzo(", 4);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 56))(__p);
  if ((v8 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)")", 1);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD26C940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1DD26C970(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  int v2 = sub_1DD239B24(v9, (uint64_t)"lz4(", 4);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 56))(__p);
  if ((v8 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)")", 1);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD26CB20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1DD26CB54(void *a1)
{
  uint64_t v1 = sub_1DD26D34C(a1);
  operator delete(v1);
}

void *sub_1DD26CB7C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "ZstdCompressionStream");
}

uint64_t sub_1DD26CB8C(uint64_t a1)
{
  return sub_1DD298194(*(int *)(a1 + 88));
}

void sub_1DD26CB98(void *a1)
{
  uint64_t v1 = (void *)sub_1DD26D3F0(a1);
  operator delete(v1);
}

uint64_t sub_1DD26CBC0(uint64_t a1)
{
  sub_1DD239280((uint64_t)v9);
  int v2 = sub_1DD239B24(v9, (uint64_t)"zstd(", 5);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 56))(__p);
  if ((v8 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v8 & 0x80u) == 0) {
    uint64_t v4 = v8;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)")", 1);
  if ((char)v8 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v9[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v9 + *(void *)(v9[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD26CD70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

uint64_t sub_1DD26CDA0(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 216);
  if (v3 == *(unsigned __int8 **)(a1 + 224))
  {
    sub_1DD26AAD0(a1, a2);
    if (*(_DWORD *)(a1 + 184) == 4) {
      return 0;
    }
    uint64_t v3 = *(unsigned __int8 **)(a1 + 216);
  }
  *(void *)(a1 + 216) = v3 + 1;
  return *v3;
}

uint64_t sub_1DD26CDF8(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 136);
  if (v3 == *(unsigned __int8 **)(a1 + 144))
  {
    sub_1DD26B390(a1, a2);
    if (*(_DWORD *)(a1 + 104) == 4) {
      return 0;
    }
    uint64_t v3 = *(unsigned __int8 **)(a1 + 136);
  }
  *(void *)(a1 + 136) = v3 + 1;
  return *v3;
}

uint64_t sub_1DD26CE50(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = (void *)sub_1DD26CEBC(a1, a2, a3, a4, a5, a6);
  void *v7 = &unk_1F387AB20;
  v7[18] = 0;
  v7[19] = 0;
  sub_1DD26BDC8((uint64_t)v7);
  return a1;
}

void sub_1DD26CE9C(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[19];
  if (v3) {
    sub_1DD25B904(v3);
  }
  sub_1DD26CF24(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26CEBC(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned __int8 v8 = (void *)sub_1DD269E1C(a1, a2, a3, a4, a5, a6);
  *unsigned __int8 v8 = &unk_1F387AC08;
  sub_1DD270124(v8 + 13, a6, 0);
  return a1;
}

void sub_1DD26CF10(_Unwind_Exception *a1)
{
  sub_1DD26A2B4(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD26CF24(void *a1)
{
  *a1 = &unk_1F387AC08;
  sub_1DD2704D4((uint64_t)(a1 + 13));
  *a1 = &unk_1F387A818;
  sub_1DD2704D4((uint64_t)(a1 + 4));
  return sub_1DD23A0A0(a1);
}

void *sub_1DD26CF9C(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v7 = v5;
  sub_1DD26AFFC((uint64_t)a1, &v7, a3, a4);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a1 = &unk_1F387B190;
  return a1;
}

void sub_1DD26D024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CAD4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD26D03C(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v7 = v5;
  sub_1DD26AFFC((uint64_t)a1, &v7, a3, a4);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a1 = &unk_1F387ADA8;
  return a1;
}

void sub_1DD26D0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CAD4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD26D0DC(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v7 = v5;
  sub_1DD26AFFC((uint64_t)a1, &v7, a3, a4);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a1 = &unk_1F387AD50;
  return a1;
}

void sub_1DD26D164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CAD4(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD26D17C(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  uint64_t v7 = v5;
  sub_1DD26AFFC((uint64_t)a1, &v7, a3, a4);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  *a1 = &unk_1F387AE78;
  a1[20] = 0;
  a1[21] = 0;
  sub_1DD26BF5C((uint64_t)a1);
  return a1;
}

void sub_1DD26D210(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[21];
  if (v3) {
    sub_1DD25B904(v3);
  }
  sub_1DD26D244(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26D244(void *a1)
{
  *a1 = &unk_1F387AF20;
  sub_1DD2701B4(a1 + 8);
  sub_1DD2701B4(a1 + 3);
  uint64_t v2 = a1[1];
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return nullsub_1(a1);
}

void *sub_1DD26D2D0(void *a1)
{
  *a1 = &unk_1F387AB98;
  sub_1DD2EDD60((uint64_t)(a1 + 13));
  *a1 = &unk_1F387A818;
  sub_1DD2704D4((uint64_t)(a1 + 4));
  return sub_1DD23A0A0(a1);
}

void *sub_1DD26D34C(void *a1)
{
  *a1 = &unk_1F387AB20;
  uint64_t v2 = (std::__shared_weak_count *)a1[19];
  if (v2) {
    sub_1DD25B904(v2);
  }
  *a1 = &unk_1F387AC08;
  sub_1DD2704D4((uint64_t)(a1 + 13));
  *a1 = &unk_1F387A818;
  sub_1DD2704D4((uint64_t)(a1 + 4));
  return sub_1DD23A0A0(a1);
}

uint64_t sub_1DD26D3F0(void *a1)
{
  *a1 = &unk_1F387AE78;
  uint64_t v2 = (std::__shared_weak_count *)a1[21];
  if (v2) {
    sub_1DD25B904(v2);
  }
  return sub_1DD26D244(a1);
}

void *sub_1DD26D44C(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  uint64_t v6 = operator new(0x28uLL);
  void *v6 = &unk_1F387CD30;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = a2;
  v6[4] = a3;
  a1[1] = v6;
  return a1;
}

void sub_1DD26D4B4(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1DD26D4C8(_Unwind_Exception *a1)
{
}

uint64_t sub_1DD26D4DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t sub_1DD26D4FC(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3879048)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

void *sub_1DD26D540(void *a1, uint64_t a2, uint64_t a3)
{
  *a1 = a2;
  uint64_t v6 = operator new(0x28uLL);
  void *v6 = &unk_1F387CD68;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = a2;
  v6[4] = a3;
  a1[1] = v6;
  return a1;
}

void sub_1DD26D5A8(void *a1)
{
  __cxa_begin_catch(a1);
  v1(v2);
  __cxa_rethrow();
}

void sub_1DD26D5BC(_Unwind_Exception *a1)
{
}

uint64_t sub_1DD26D5D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 24));
}

uint64_t sub_1DD26D5F0(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3879068)) {
    return a1 + 32;
  }
  else {
    return 0;
  }
}

void sub_1DD26D634()
{
  if (!*(unsigned char *)off_1EC8AC2B8(&off_1EC8AC2B8))
  {
    *(unsigned char *)v0(v1) = 1;
    uint64_t v2 = (void *)off_1EC8AC288();
    _tlv_atexit((void (__cdecl *)(void *))sub_1DD26BD7C, v2);
    uint64_t v3 = (void *)off_1EC8AC2A0();
    _tlv_atexit((void (__cdecl *)(void *))sub_1DD26BF0C, v3);
  }
}

std::logic_error *sub_1DD26D7D8(std::logic_error *a1, const std::string *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)&unk_1F3879E38;
  return result;
}

std::logic_error *sub_1DD26D80C(std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)&unk_1F3879E38;
  return result;
}

void sub_1DD26D844(std::logic_error *a1)
{
  std::logic_error::~logic_error(a1);
  operator delete(v1);
}

std::runtime_error *sub_1DD26D86C(std::runtime_error *a1, const std::string *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F3879200;
  return result;
}

std::runtime_error *sub_1DD26D8A0(std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F3879200;
  return result;
}

void sub_1DD26D8DC(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);
  operator delete(v1);
}

std::runtime_error *sub_1DD26D904(std::runtime_error *a1, const std::string *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F38798B0;
  return result;
}

std::runtime_error *sub_1DD26D938(std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_1F38798B0;
  return result;
}

void sub_1DD26D970(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);
  operator delete(v1);
}

uint64_t *sub_1DD26D998(uint64_t *a1, std::string *__str)
{
  *a1 = 0;
  a1[1] = 0;
  if (SHIBYTE(__str->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = __str->__r_.__value_.__l.__size_;
    if (!size) {
      return a1;
    }
    uint64_t v4 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  else
  {
    uint64_t v4 = __str;
    std::string::size_type size = HIBYTE(__str->__r_.__value_.__r.__words[2]);
    if (!*((unsigned char *)&__str->__r_.__value_.__s + 23)) {
      return a1;
    }
  }
  int v6 = v4->__r_.__value_.__s.__data_[0];
  std::string::size_type v7 = v6 == 45;
  if (size > v7)
  {
    while (1)
    {
      if (size - v7 >= 0x12) {
        std::string::size_type v8 = 18;
      }
      else {
        std::string::size_type v8 = size - v7;
      }
      std::string::basic_string(&__p, __str, v7, v8, (std::allocator<char> *)&v19);
      uint64_t v9 = std::stoll(&__p, 0, 10);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(__p.__r_.__value_.__l.__data_);
        if (v8)
        {
LABEL_12:
          std::string::size_type v10 = v8;
          std::string::size_type v11 = 1;
          do
          {
            v11 *= 10;
            --v10;
          }
          while (v10);
          goto LABEL_17;
        }
      }
      else if (v8)
      {
        goto LABEL_12;
      }
      std::string::size_type v11 = 1;
LABEL_17:
      __p.__r_.__value_.__r.__words[0] = 0;
      __p.__r_.__value_.__l.__size_ = v11;
      sub_1DD26DB04(a1, (uint64_t *)&__p);
      uint64_t v12 = a1[1];
      BOOL v13 = __CFADD__(v12, v9);
      uint64_t v14 = v12 + v9;
      uint64_t v15 = (v9 >> 63) + v13 + *a1;
      *a1 = v15;
      a1[1] = v14;
      v7 += v8;
      if (v7 >= size) {
        goto LABEL_20;
      }
    }
  }
  uint64_t v15 = 0;
  uint64_t v14 = 0;
LABEL_20:
  if (v6 == 45)
  {
    if (v14) {
      uint64_t v16 = ~v15;
    }
    else {
      uint64_t v16 = -v15;
    }
    *a1 = v16;
    a1[1] = -v14;
  }
  return a1;
}

void sub_1DD26DAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD26DB04(void *result, uint64_t *a2)
{
  uint64_t v2 = result[1];
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = HIDWORD(v4) * (unint64_t)v2;
  unint64_t v6 = v4 * (unint64_t)HIDWORD(v2)
     + v5
     + ((v4 * (unint64_t)v2) >> 32);
  *uint64_t result = v3 * (unint64_t)v2
          + HIDWORD(v4) * (unint64_t)HIDWORD(v2)
          + v4 * (unint64_t)*result
          + HIDWORD(v6)
          + ((unint64_t)(HIDWORD(v2) * v3
                                            + v4 * HIDWORD(*result)
                                            + HIDWORD(v3) * v2
                                            + HIDWORD(v4) * *result) << 32)
          + ((unint64_t)(v6 < v5) << 32);
  result[1] = (v4 * v2) | ((unint64_t)v6 << 32);
  return result;
}

uint64_t sub_1DD26DB7C(unint64_t *a1, _DWORD *a2, char *a3)
{
  unint64_t v4 = *a1;
  unint64_t v3 = a1[1];
  if ((*a1 & 0x8000000000000000) != 0)
  {
    char v5 = 1;
    if (!v3)
    {
      unint64_t v4 = -(uint64_t)v4;
      *a3 = 1;
      goto LABEL_11;
    }
    unint64_t v3 = -(uint64_t)v3;
    unint64_t v4 = ~v4;
  }
  else
  {
    char v5 = 0;
  }
  *a3 = v5;
  if (!v4)
  {
    if (v3 < 0xFFFFFFFF)
    {
      if (v3)
      {
        *a2 = v3;
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      *(void *)a2 = __ROR8__(v3, 32);
      return 2;
    }
  }
LABEL_11:
  if (HIDWORD(v4))
  {
    *a2 = HIDWORD(v4);
    a2[1] = v4;
    a2[2] = HIDWORD(v3);
    a2[3] = v3;
    return 4;
  }
  else
  {
    *a2 = v4;
    a2[1] = HIDWORD(v3);
    a2[2] = v3;
    return 3;
  }
}

int *sub_1DD26DC10(int *result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1 && a3)
  {
    if ((unint64_t)a2 >= 2)
    {
      unint64_t v3 = result + 1;
      int v4 = *result;
      uint64_t v5 = a2 - 1;
      do
      {
        int v6 = v4 << a3;
        int v4 = *v3;
        *(v3 - 1) = (*v3 >> (32 - a3)) | v6;
        ++v3;
        --v5;
      }
      while (v5);
    }
    result[a2 - 1] <<= a3;
  }
  return result;
}

_DWORD *sub_1DD26DC68(_DWORD *result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 1 && a3)
  {
    if ((unint64_t)a2 >= 2)
    {
      do
        result[a2 - 1] = (result[a2 - 2] << (32 - a3)) | (result[a2 - 1] >> a3);
      while ((unint64_t)a2-- > 2);
    }
    *result >>= a3;
  }
  return result;
}

unint64_t *sub_1DD26DCBC(unint64_t *result, unsigned int *a2, uint64_t a3)
{
  switch(a3)
  {
    case 0:
      *uint64_t result = 0;
      result[1] = 0;
      return result;
    case 1:
      unint64_t v3 = *a2;
      goto LABEL_5;
    case 2:
      unint64_t v3 = a2[1] | ((unint64_t)*a2 << 32);
LABEL_5:
      *uint64_t result = 0;
      result[1] = v3;
      return result;
    case 3:
      unint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      uint64_t v6 = a2[2];
      goto LABEL_10;
    case 4:
      unint64_t v4 = a2[1] | ((unint64_t)*a2 << 32);
      uint64_t v5 = a2[2];
      uint64_t v6 = a2[3];
      goto LABEL_10;
    case 5:
      if (*a2)
      {
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Can't build Int128 with 5 ints.");
LABEL_14:
        __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
      }
      unint64_t v4 = a2[2] | ((unint64_t)a2[1] << 32);
      uint64_t v5 = a2[3];
      uint64_t v6 = a2[4];
LABEL_10:
      *uint64_t result = v4;
      result[1] = v6 | (v5 << 32);
      return result;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "Unsupported length for building Int128");
      goto LABEL_14;
  }
}

void sub_1DD26DDB0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26DDE0(unsigned int *a1, uint64_t a2, unsigned int a3, uint64_t *a4, int a5, int a6)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2 < 1)
  {
    unint64_t v9 = 0;
  }
  else
  {
    unint64_t v9 = 0;
    std::string::size_type v10 = v19;
    uint64_t v11 = a2;
    do
    {
      unsigned int v12 = *a1++;
      unint64_t v13 = v12 | (v9 << 32);
      *v10++ = v13 / a3;
      unint64_t v9 = v13 % a3;
      --v11;
    }
    while (v11);
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  sub_1DD26DCBC((unint64_t *)&v17, v19, a2);
  *a4 = 0;
  a4[1] = v9;
  if (a5 != a6)
  {
    if (v18) {
      unint64_t v14 = ~v17;
    }
    else {
      unint64_t v14 = -v17;
    }
    uint64_t v17 = v14;
    uint64_t v18 = -v18;
  }
  if (a5)
  {
    if (v9) {
      uint64_t v15 = -1;
    }
    else {
      uint64_t v15 = 0;
    }
    *a4 = v15;
    a4[1] = -(uint64_t)v9;
  }
  return v17;
}

uint64_t sub_1DD26DED4(unint64_t *a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  __int16 v38 = 0;
  int v43 = 0;
  unint64_t v6 = sub_1DD26DB7C(a1, v44, (char *)&v38 + 1);
  unint64_t v7 = sub_1DD26DB7C(a2, v42, (char *)&v38);
  if (v6 >= v7)
  {
    unint64_t v9 = v7;
    uint64_t v10 = v6 + 1;
    if (v7 == 1)
    {
      return sub_1DD26DDE0((unsigned int *)&v43, v6 + 1, v42[0], a3, HIBYTE(v38), v38);
    }
    else
    {
      if (!v7)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26E1F4(exception, "Division by 0 in Int128");
        __cxa_throw(exception, (struct type_info *)off_1E6CBA918, MEMORY[0x1E4FBA1B8]);
      }
      uint64_t v11 = v10 - v7;
      unsigned int v12 = v42[0];
      if (v42[0])
      {
        uint64_t v13 = 32;
        do
        {
          --v13;
          BOOL v14 = v12 > 1;
          v12 >>= 1;
        }
        while (v14);
      }
      else
      {
        uint64_t v13 = 32;
      }
      sub_1DD26DC10(v42, v7, v13);
      sub_1DD26DC10(&v43, v10, v13);
      if (v11 >= 1)
      {
        uint64_t v15 = 0;
        unint64_t v16 = v42[0];
        unsigned int v17 = v42[1];
        uint64_t v18 = &v43;
        do
        {
          uint64_t v19 = v15;
          uint64_t v20 = v44[v15++ - 1];
          uint64_t v21 = v44[v15 - 1];
          if (v20 == v16) {
            LODWORD(v22) = -1;
          }
          else {
            unint64_t v22 = (v21 | (unint64_t)(v20 << 32)) / v16;
          }
          uint64_t v23 = (v21 - v22 * v16);
          do
          {
            if (v17 * (unint64_t)v22 <= (v44[v19 + 1] | (unint64_t)(v23 << 32))) {
              break;
            }
            LODWORD(v22) = v22 - 1;
            uint64_t v23 = (v23 + v16);
          }
          while (v23 >= v16);
          if (v9)
          {
            unint64_t v24 = 0;
            uint64_t v25 = v9;
            do
            {
              unint64_t v26 = v24 + v41[v25 + 3] * (unint64_t)v22;
              unsigned int v27 = v18[v25];
              BOOL v28 = v27 >= v26;
              v18[v25] = v27 - v26;
              unint64_t v24 = HIDWORD(v26);
              if (!v28) {
                ++v24;
              }
              BOOL v14 = v25-- <= 1;
            }
            while (!v14);
            unsigned int v29 = v44[v19 - 1];
            v44[v19 - 1] = v29 - v24;
            if (v29 < v24)
            {
              unint64_t v30 = 0;
              LODWORD(v22) = v22 - 1;
              uint64_t v31 = v9;
              do
              {
                unint64_t v32 = v30 + v41[v31 + 3] + v18[v31];
                v18[v31] = v32;
                unint64_t v30 = HIDWORD(v32);
                BOOL v14 = v31-- <= 1;
              }
              while (!v14);
              v44[v19 - 1] += v30;
            }
          }
          v41[v19] = v22;
          ++v18;
        }
        while (v15 != v11);
      }
      sub_1DD26DC68(&v43, v10, v13);
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      sub_1DD26DCBC((unint64_t *)&v39, v41, v10 - v9);
      sub_1DD26DCBC((unint64_t *)a3, (unsigned int *)&v43, v10);
      if ((HIBYTE(v38) != 0) != ((_BYTE)v38 != 0))
      {
        if (v40) {
          unint64_t v33 = ~v39;
        }
        else {
          unint64_t v33 = -v39;
        }
        uint64_t v39 = v33;
        uint64_t v40 = -v40;
      }
      if (HIBYTE(v38))
      {
        uint64_t v34 = a3[1];
        uint64_t v35 = -v34;
        if (v34) {
          uint64_t v36 = ~*a3;
        }
        else {
          uint64_t v36 = -*a3;
        }
        *a3 = v36;
        a3[1] = v35;
      }
      return v39;
    }
  }
  else
  {
    uint64_t result = 0;
    *(_OWORD *)a3 = *(_OWORD *)a1;
  }
  return result;
}

void sub_1DD26E1D8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *sub_1DD26E1F4(std::runtime_error *a1, const char *a2)
{
  uint64_t result = std::runtime_error::runtime_error(a1, a2);
  result->__vftable = (std::runtime_error_vtbl *)(MEMORY[0x1E4FBA4B8] + 16);
  return result;
}

uint64_t sub_1DD26E228(unint64_t *a1)
{
  long long v21 = xmmword_1DD320040;
  long long v22 = xmmword_1DD320030;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  sub_1DD250F88((uint64_t)v15);
  uint64_t v13 = sub_1DD26DED4(a1, (unint64_t *)&v21, &v19);
  uint64_t v14 = v2;
  BOOL v3 = (v13 | v2) != 0;
  if (v13 | v2)
  {
    sub_1DD26E50C(&v13);
    std::ostream::operator<<();
    if (v19 < 0)
    {
      if (v20) {
        uint64_t v4 = ~v19;
      }
      else {
        uint64_t v4 = -v19;
      }
      uint64_t v19 = v4;
      uint64_t v20 = -v20;
    }
  }
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v5 = sub_1DD26DED4((unint64_t *)&v19, (unint64_t *)&v22, &v11);
  uint64_t v13 = v5;
  uint64_t v14 = v6;
  if (v3)
  {
    *(void *)((char *)&v16[3] + *(void *)(v16[0] - 24)) = 18;
    char v10 = 48;
    sub_1DD238ED0(v16, &v10);
  }
  else
  {
    if (!(v5 | v6)) {
      goto LABEL_16;
    }
    if (v11 < 0)
    {
      if (v12) {
        uint64_t v7 = ~v11;
      }
      else {
        uint64_t v7 = -v11;
      }
      uint64_t v11 = v7;
      uint64_t v12 = -v12;
    }
  }
  sub_1DD26E50C(&v13);
  std::ostream::operator<<();
  *(void *)((char *)&v16[3] + *(void *)(v16[0] - 24)) = 18;
  char v10 = 48;
  sub_1DD238ED0(v16, &v10);
LABEL_16:
  sub_1DD26E50C(&v11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v15[0] = *MEMORY[0x1E4FBA408];
  uint64_t v8 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v15 + *(void *)(v15[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v16[0] = v8;
  v16[1] = MEMORY[0x1E4FBA470] + 16;
  if (v17 < 0) {
    operator delete((void *)v16[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E01B1EC0](&v18);
}

void sub_1DD26E4E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  sub_1DD251260((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD26E50C(void *a1)
{
  if (!*a1)
  {
    uint64_t result = a1[1];
    if ((result & 0x8000000000000000) == 0) {
      return result;
    }
LABEL_6:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26E1F4(exception, "Int128 too large to convert to long");
    __cxa_throw(exception, (struct type_info *)off_1E6CBA918, MEMORY[0x1E4FBA1B8]);
  }
  if (*a1 != -1) {
    goto LABEL_6;
  }
  uint64_t result = a1[1];
  if ((result & 0x8000000000000000) == 0) {
    goto LABEL_6;
  }
  return result;
}

void sub_1DD26E580(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD26E594(unint64_t *a1@<X0>, int a2@<W1>, std::string *a3@<X8>)
{
  sub_1DD26E228(a1);
  if (!a2)
  {
    *a3 = __str;
    memset(&__str, 0, sizeof(__str));
    goto LABEL_50;
  }
  unint64_t v6 = *a1;
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v7 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  }
  else {
    int v7 = __str.__r_.__value_.__r.__words[1];
  }
  if ((v6 & 0x8000000000000000) == 0)
  {
    int v8 = v7 - a2;
    if (v7 > a2)
    {
      std::string::size_type v9 = v8;
      std::string::basic_string(&v28, &__str, 0, v8, (std::allocator<char> *)&__p);
      char v10 = std::string::append(&v28, ".");
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v29.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      std::string::basic_string(&__p, &__str, v9, a2, (std::allocator<char> *)&v31);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        p_p = &__p;
      }
      else {
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      }
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = __p.__r_.__value_.__l.__size_;
      }
      goto LABEL_21;
    }
    if (v7 == a2)
    {
      std::operator+<char>();
      goto LABEL_50;
    }
    sub_1DD314888(&v29, "0.");
    int v21 = a2 - v7;
    if (v21 >= 1)
    {
      do
      {
        std::string::append(&v29, "0");
        --v21;
      }
      while (v21);
    }
    sub_1DD26E9AC((const void **)&v29.__r_.__value_.__l.__data_, (const void **)&__str.__r_.__value_.__l.__data_, (uint64_t)a3);
LABEL_47:
    if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_50;
    }
    uint64_t v18 = (void *)v29.__r_.__value_.__r.__words[0];
    goto LABEL_49;
  }
  if (v7 - 1 <= a2)
  {
    if (v7 - 1 == a2)
    {
      std::string::basic_string(&v29, &__str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v28);
      uint64_t v19 = std::string::insert(&v29, 0, "-0.");
      long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
      a3->__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v20;
      v19->__r_.__value_.__l.__size_ = 0;
      v19->__r_.__value_.__r.__words[2] = 0;
      v19->__r_.__value_.__r.__words[0] = 0;
    }
    else
    {
      sub_1DD314888(&v29, "-0.");
      if (v7 <= a2)
      {
        int v22 = a2 - v7 + 1;
        do
        {
          std::string::append(&v29, "0");
          --v22;
        }
        while (v22);
      }
      std::string::basic_string(&v28, &__str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&__p);
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v23 = &v29;
      }
      else {
        uint64_t v23 = (std::string *)v29.__r_.__value_.__r.__words[0];
      }
      if ((v29.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v24 = HIBYTE(v29.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v24 = v29.__r_.__value_.__l.__size_;
      }
      uint64_t v25 = std::string::insert(&v28, 0, (const std::string::value_type *)v23, v24);
      long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
      a3->__r_.__value_.__r.__words[2] = v25->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v26;
      v25->__r_.__value_.__l.__size_ = 0;
      v25->__r_.__value_.__r.__words[2] = 0;
      v25->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v28.__r_.__value_.__l.__data_);
      }
    }
    goto LABEL_47;
  }
  std::string::basic_string(&v28, &__str, 0, v7 - a2, (std::allocator<char> *)&__p);
  uint64_t v14 = std::string::append(&v28, ".");
  long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v29.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  std::string::basic_string(&__p, &__str, v7 - a2, a2, (std::allocator<char> *)&v31);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
LABEL_21:
  unint64_t v16 = std::string::append(&v29, (const std::string::value_type *)p_p, size);
  long long v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  a3->__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v29.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v18 = (void *)v28.__r_.__value_.__r.__words[0];
LABEL_49:
    operator delete(v18);
  }
LABEL_50:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

void sub_1DD26E8EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (*(char *)(v26 - 41) < 0) {
    operator delete(*(void **)(v26 - 64));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD26E9AC@<X0>(const void **a1@<X0>, const void **a2@<X1>, uint64_t a3@<X8>)
{
  if (*((char *)a1 + 23) >= 0) {
    size_t v5 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v5 = (size_t)a1[1];
  }
  if (*((char *)a2 + 23) >= 0) {
    size_t v6 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v6 = (size_t)a2[1];
  }
  uint64_t result = sub_1DD26EC78(a3, v6 + v5);
  if (*(char *)(result + 23) >= 0) {
    int v8 = (char *)result;
  }
  else {
    int v8 = *(char **)result;
  }
  if (v5)
  {
    if (*((char *)a1 + 23) >= 0) {
      std::string::size_type v9 = a1;
    }
    else {
      std::string::size_type v9 = *a1;
    }
    uint64_t result = (uint64_t)memmove(v8, v9, v5);
  }
  char v10 = &v8[v5];
  if (v6)
  {
    if (*((char *)a2 + 23) >= 0) {
      long long v11 = a2;
    }
    else {
      long long v11 = *a2;
    }
    uint64_t result = (uint64_t)memmove(v10, v11, v6);
  }
  v10[v6] = 0;
  return result;
}

uint64_t sub_1DD26EA78(uint64_t result, unint64_t a2, int a3, unsigned char *a4)
{
  uint64_t v20 = result;
  unint64_t v21 = a2;
  *a4 = 0;
  v19[0] = 0;
  v19[1] = 0;
  if (a3 >= 1)
  {
    int v5 = a3;
    while (1)
    {
      if (v5 >= 0x12) {
        unsigned int v6 = 18;
      }
      else {
        unsigned int v6 = v5;
      }
      uint64_t v7 = v20;
      if (v20)
      {
        if (v20 < 1) {
          goto LABEL_14;
        }
      }
      else if (!v21)
      {
        goto LABEL_14;
      }
      long long v18 = xmmword_1DD320050;
      uint64_t v8 = qword_1DD320070[v6];
      uint64_t v16 = v8 >> 63;
      uint64_t v17 = v8;
      uint64_t v7 = sub_1DD26DED4((unint64_t *)&v18, (unint64_t *)&v16, v19);
      BOOL v10 = v7 < v20;
      if (v7 == v20)
      {
        if (v9 < v21) {
          goto LABEL_25;
        }
      }
      else
      {
        uint64_t v7 = v20;
        if (v10)
        {
LABEL_25:
          *a4 = 1;
          return 0x7FFFFFFFFFFFFFFFLL;
        }
      }
LABEL_14:
      if (v7 && v7 < 0)
      {
        long long v18 = xmmword_1DD320060;
        uint64_t v11 = qword_1DD320070[v6];
        uint64_t v12 = v11 >> 63;
        uint64_t v16 = v11 >> 63;
        uint64_t v17 = v11;
        uint64_t v14 = sub_1DD26DED4((unint64_t *)&v18, (unint64_t *)&v16, v19);
        if (v14 == v20)
        {
          if (v15 > v21) {
            goto LABEL_24;
          }
        }
        else if (v14 > v20)
        {
LABEL_24:
          *a4 = 1;
          return 0x8000000000000000;
        }
      }
      else
      {
        uint64_t v11 = qword_1DD320070[v6];
        uint64_t v12 = v11 >> 63;
      }
      *(void *)&long long v18 = v12;
      *((void *)&v18 + 1) = v11;
      sub_1DD26DB04(&v20, (uint64_t *)&v18);
      BOOL v13 = __OFSUB__(v5, v6);
      v5 -= v6;
      if ((v5 < 0) ^ v13 | (v5 == 0)) {
        return v20;
      }
    }
  }
  return result;
}

uint64_t sub_1DD26EBFC(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v10 = result;
  uint64_t v11 = a2;
  v9[0] = 0;
  v9[1] = 0;
  if (a3 >= 1)
  {
    int v3 = a3;
    do
    {
      if (v3 >= 0x12) {
        int v4 = 18;
      }
      else {
        int v4 = v3;
      }
      uint64_t v5 = qword_1DD320070[v4];
      v8[0] = v5 >> 63;
      v8[1] = v5;
      uint64_t result = sub_1DD26DED4((unint64_t *)&v10, v8, v9);
      uint64_t v10 = result;
      uint64_t v11 = v6;
      BOOL v7 = __OFSUB__(v3, v4);
      v3 -= v4;
    }
    while (!((v3 < 0) ^ v7 | (v3 == 0)));
  }
  return result;
}

uint64_t sub_1DD26EC78(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x7FFFFFFFFFFFFFF8) {
    sub_1DD239EFC();
  }
  if (a2 > 0x16)
  {
    uint64_t v4 = (a2 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a2 | 7) != 0x17) {
      uint64_t v4 = a2 | 7;
    }
    uint64_t v5 = v4 + 1;
    uint64_t v6 = operator new(v4 + 1);
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = v5 | 0x8000000000000000;
    *(void *)a1 = v6;
  }
  else
  {
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = 0;
    *(unsigned char *)(a1 + 23) = a2;
  }
  return a1;
}

void sub_1DD26ED04(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);
  operator delete(v1);
}

char *sub_1DD26ED2C(unint64_t a1, unint64_t a2, char *a3, unint64_t a4)
{
  if (a1 == a2) {
    return 0;
  }
  uint64_t v4 = a3;
  unint64_t v6 = a1;
  BOOL v7 = a3;
  if (v6 < a2)
  {
    unsigned int v8 = 0;
    unint64_t v9 = a4 - 8;
    unint64_t v10 = a2 - 8;
    int v11 = 255 * a2 - 248;
    char v12 = 1;
    BOOL v13 = (int *)&unk_1DD320128;
    unint64_t v66 = v6;
    BOOL v7 = a3;
    while (1)
    {
      uint64_t v14 = 0;
      int v15 = v11 - 255 * v6;
      uint64_t v16 = (unsigned __int16 *)(v6 + 2);
      for (unint64_t i = a2 - 1 - v6; ; i -= 3)
      {
        uint64_t v18 = v6 + v14;
        unsigned int v19 = *(unsigned __int8 *)(v6 + v14);
        if (v19 != 17) {
          break;
        }
        if (v18 + 3 > a2 && *(_WORD *)(v18 + 1)) {
          goto LABEL_91;
        }
        unsigned int v8 = 0;
        v14 += 3;
        v15 -= 765;
        uint64_t v16 = (unsigned __int16 *)((char *)v16 + 3);
        char v12 = 1;
        if (v6 + v14 >= a2) {
          return (char *)(v7 - v4);
        }
      }
      uint64_t v20 = (unsigned __int16 *)(v18 + 1);
      if ((v19 & 0xF0) != 0)
      {
        if (v12)
        {
          unsigned int v8 = v19 - 17;
        }
        else
        {
          if ((v19 & 0xF0) == 0x10)
          {
            int v24 = v19 & 7;
            if ((v19 & 7) == 0)
            {
              if ((unint64_t)v20 >= a2)
              {
                int v27 = 0;
                int v15 = 7;
              }
              else
              {
                uint64_t v25 = 0;
                int v26 = 7;
                while (1)
                {
                  int v27 = *((unsigned __int8 *)v16 - 1);
                  if (*((unsigned char *)v16 - 1)) {
                    break;
                  }
                  uint64_t v16 = (unsigned __int16 *)((char *)v16 + 1);
                  v26 += 255;
                  if (i == ++v25)
                  {
                    int v27 = 0;
                    uint64_t v20 = (unsigned __int16 *)a2;
                    goto LABEL_45;
                  }
                }
                int v15 = v26;
                uint64_t v20 = v16;
              }
LABEL_45:
              int v24 = v27 + v15;
            }
            __int16 v38 = v20 + 1;
            if ((unint64_t)(v20 + 1) > a2) {
              goto LABEL_93;
            }
            unsigned int v39 = *v20;
            if ((v19 & 8) != 0) {
              int v40 = 0x7FFF;
            }
            else {
              int v40 = 0x3FFF;
            }
            unsigned int v22 = v40 + (v39 >> 2);
          }
          else
          {
            if ((v19 & 0xE0) != 0x20)
            {
              if (v19 < 0x40)
              {
                exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
                sub_1DD26F420();
                int v64 = std::string::insert(&v68, 0, "Invalid LZO command ");
                long long v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
                std::string::size_type v70 = v64->__r_.__value_.__r.__words[2];
                long long v69 = v65;
                v64->__r_.__value_.__l.__size_ = 0;
                v64->__r_.__value_.__r.__words[2] = 0;
                v64->__r_.__value_.__r.__words[0] = 0;
                sub_1DD26F7CC(exception);
                __cxa_throw(exception, (struct type_info *)&unk_1F3878798, (void (*)(void *))j_std::runtime_error::~runtime_error);
              }
              if ((unint64_t)v20 >= a2)
              {
LABEL_91:
                unint64_t v60 = __cxa_allocate_exception(0x10uLL);
                sub_1DD26F41C(v60, v6 - v66 + v14 + 1);
                goto LABEL_92;
              }
              int v23 = (v19 >> 5) + 1;
              int v37 = *(unsigned __int8 *)v20;
              uint64_t v20 = (unsigned __int16 *)(v6 + v14 + 2);
              unsigned int v22 = (v19 >> 2) & 7 | (8 * v37);
              unsigned int v8 = v19 & 3;
              goto LABEL_60;
            }
            int v24 = v19 & 0x1F;
            if ((v19 & 0x1F) == 0)
            {
              if ((unint64_t)v20 >= a2)
              {
                int v30 = 0;
                int v28 = 31;
              }
              else
              {
                int v28 = v15 + 24;
                int v29 = 31;
                while (1)
                {
                  int v30 = *((unsigned __int8 *)v16 - 1);
                  if (*((unsigned char *)v16 - 1)) {
                    break;
                  }
                  uint64_t v16 = (unsigned __int16 *)((char *)v16 + 1);
                  v29 += 255;
                  if (!--i)
                  {
                    int v30 = 0;
                    uint64_t v20 = (unsigned __int16 *)a2;
                    goto LABEL_56;
                  }
                }
                int v28 = v29;
                uint64_t v20 = v16;
              }
LABEL_56:
              int v24 = v30 + v28;
            }
            __int16 v38 = v20 + 1;
            if ((unint64_t)(v20 + 1) > a2)
            {
LABEL_93:
              uint64_t v62 = v20;
              unint64_t v60 = __cxa_allocate_exception(0x10uLL);
              sub_1DD26F41C(v60, (char *)v62 - v66);
LABEL_92:
              __cxa_throw(v60, (struct type_info *)&unk_1F3878798, (void (*)(void *))j_std::runtime_error::~runtime_error);
            }
            unsigned int v39 = *v20;
            unsigned int v22 = v39 >> 2;
          }
          uint64_t v20 = v38;
          unsigned int v8 = v39 & 3;
          int v23 = v24 + 2;
          if (v24 != -2) {
            goto LABEL_60;
          }
        }
      }
      else
      {
        if (v8)
        {
          if (v8 > 3)
          {
            if ((unint64_t)v20 >= a2) {
              goto LABEL_91;
            }
            int v36 = *(unsigned __int8 *)v20;
            uint64_t v20 = (unsigned __int16 *)(v6 + v14 + 2);
            unsigned int v22 = (v19 >> 2) & 3 | (4 * v36);
            unsigned int v8 = v19 & 3;
            int v23 = 2;
          }
          else
          {
            if ((unint64_t)v20 >= a2) {
              goto LABEL_91;
            }
            int v21 = (v19 >> 2) & 3 | (4 * *(unsigned __int8 *)v20);
            uint64_t v20 = (unsigned __int16 *)(v6 + v14 + 2);
            unsigned int v22 = v21 | 0x800;
            unsigned int v8 = v19 & 3;
            int v23 = 3;
          }
LABEL_60:
          uint64_t v41 = v22 + 1;
          uint64_t v42 = &v7[-v41];
          int v43 = &v7[v23];
          if (&v7[-v41] < v4 || (unint64_t)v43 > a4) {
            goto LABEL_93;
          }
          if ((unint64_t)v7 <= v9)
          {
            if (v22 > 6)
            {
              uint64_t v49 = *(void *)v42;
              uint64_t v48 = v42 + 8;
              *(void *)BOOL v7 = v49;
            }
            else
            {
              uint64_t v45 = v13[v41];
              uint64_t v46 = dword_1DD320148[v41];
              char *v7 = *v42;
              v7[1] = v42[1];
              v7[2] = v42[2];
              v7[3] = v42[3];
              uint64_t v47 = &v42[v45];
              *((_DWORD *)v7 + 1) = *(_DWORD *)v47;
              uint64_t v48 = &v47[-v46];
            }
            uint64_t v50 = v7 + 8;
            if ((unint64_t)v43 >= v9)
            {
              while ((unint64_t)v50 < v9)
              {
                uint64_t v52 = *(void *)v48;
                v48 += 8;
                *v50++ = v52;
              }
              if (v50 < (void *)v43)
              {
                int64_t v53 = &v7[v23] - (char *)v50;
                do
                {
                  char v54 = *v48++;
                  *(unsigned char *)uint64_t v50 = v54;
                  uint64_t v50 = (void *)((char *)v50 + 1);
                  --v53;
                }
                while (v53);
              }
            }
            else if (v23 >= 9)
            {
              do
              {
                uint64_t v51 = *(void *)v48;
                v48 += 8;
                *v50++ = v51;
              }
              while (v50 < (void *)v43);
            }
          }
          else if (v23 >= 1)
          {
            do
            {
              char *v7 = v7[-v41];
              ++v7;
            }
            while (v7 < v43);
          }
          BOOL v7 = v43;
          goto LABEL_81;
        }
        int v31 = v19 & 0xF;
        if (!v31)
        {
          if ((unint64_t)v20 >= a2)
          {
            int v35 = 0;
            int v33 = 15;
          }
          else
          {
            uint64_t v32 = 0;
            int v33 = v15 + 8;
            int v34 = 15;
            while (1)
            {
              int v35 = *((unsigned __int8 *)v16 - 1);
              if (*((unsigned char *)v16 - 1)) {
                break;
              }
              uint64_t v16 = (unsigned __int16 *)((char *)v16 + 1);
              v34 += 255;
              if (i == ++v32)
              {
                int v35 = 0;
                uint64_t v20 = (unsigned __int16 *)a2;
                goto LABEL_53;
              }
            }
            int v33 = v34;
            uint64_t v20 = v16;
          }
LABEL_53:
          int v31 = v35 + v33;
        }
        unsigned int v8 = v31 + 3;
      }
LABEL_81:
      uint64_t v55 = v8;
      uint64_t v56 = &v7[v8];
      unint64_t v6 = (unint64_t)v20 + v8;
      if ((unint64_t)v56 > v9 || v6 > v10)
      {
        unsigned int v67 = v4;
        if ((unint64_t)v56 > a4) {
          goto LABEL_93;
        }
        v58 = v13;
        unint64_t v59 = a4;
        memcpy(v7, v20, v8);
        a4 = v59;
        BOOL v13 = v58;
        uint64_t v4 = v67;
      }
      else
      {
        do
        {
          uint64_t v57 = *(void *)v20;
          v20 += 4;
          *(void *)BOOL v7 = v57;
          v7 += 8;
          v55 -= 8;
        }
        while (v7 < v56);
        unint64_t v6 = (unint64_t)v20 + v55;
      }
      char v12 = 0;
      BOOL v7 = v56;
      if (v6 >= a2)
      {
        unint64_t v60 = __cxa_allocate_exception(0x10uLL);
        sub_1DD26F41C(v60, v6 - v66);
        goto LABEL_92;
      }
    }
  }
  return (char *)(v7 - v4);
}

void sub_1DD26F398(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a17 < 0)
  {
    operator delete(a12);
    if ((v24 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

uint64_t sub_1DD26F420()
{
  sub_1DD239280((uint64_t)v2);
  uint64_t v0 = sub_1DD239B24(v2, (uint64_t)"0x", 2);
  *(_DWORD *)((char *)v0 + *(void *)(*v0 - 24) + 8) = *(_DWORD *)((unsigned char *)v0 + *(void *)(*v0 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  v2[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v2 + *(void *)(v2[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v2[1] = MEMORY[0x1E4FBA470] + 16;
  if (v3 < 0) {
    operator delete((void *)v2[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v4);
}

void sub_1DD26F590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

std::runtime_error *sub_1DD26F5A4(std::runtime_error *a1)
{
  sub_1DD26F684();
  uint64_t v2 = std::string::insert(&v5, 0, "MalformedInputException at ");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_1DD26D86C(a1, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v5.__r_.__value_.__l.__data_);
  }
  a1->__vftable = (std::runtime_error_vtbl *)&unk_1F387AE00;
  return a1;
}

void sub_1DD26F650(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD26F684()
{
  sub_1DD239280((uint64_t)v1);
  std::ostream::operator<<();
  std::stringbuf::str();
  v1[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v1 + *(void *)(v1[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v1[1] = MEMORY[0x1E4FBA470] + 16;
  if (v2 < 0) {
    operator delete((void *)v1[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v3);
}

void sub_1DD26F7B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

std::runtime_error *sub_1DD26F7CC(std::runtime_error *a1)
{
  std::operator+<char>();
  char v2 = std::string::append(&v11, " at ");
  long long v3 = *(_OWORD *)&v2->__r_.__value_.__l.__data_;
  v12.__r_.__value_.__r.__words[2] = v2->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v12.__r_.__value_.__l.__data_ = v3;
  v2->__r_.__value_.__l.__size_ = 0;
  v2->__r_.__value_.__r.__words[2] = 0;
  v2->__r_.__value_.__r.__words[0] = 0;
  sub_1DD26F684();
  if ((v10 & 0x80u) == 0) {
    uint64_t v4 = __p;
  }
  else {
    uint64_t v4 = (void **)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    std::string::size_type v5 = v10;
  }
  else {
    std::string::size_type v5 = (std::string::size_type)__p[1];
  }
  unint64_t v6 = std::string::append(&v12, (const std::string::value_type *)v4, v5);
  long long v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
  v13.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v7;
  v6->__r_.__value_.__l.__size_ = 0;
  v6->__r_.__value_.__r.__words[2] = 0;
  v6->__r_.__value_.__r.__words[0] = 0;
  sub_1DD26D86C(a1, &v13);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v12.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v12.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
  a1->__vftable = (std::runtime_error_vtbl *)&unk_1F387AE00;
  return a1;
}

void sub_1DD26F8F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (*(char *)(v26 - 41) < 0) {
    operator delete(*(void **)(v26 - 64));
  }
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD26F954(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F3879160;
  a1[1] = a2;
  a1[2] = 0;
  std::string::size_type v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FA18((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + v6), a3 - v6);
  }
  a1[3] = a3;
  return a1;
}

void sub_1DD26F9D0(uint64_t a1, unint64_t a2)
{
  sub_1DD26FA18(a1, a2);
  unint64_t v4 = *(void *)(a1 + 24);
  if (a2 > v4) {
    bzero((void *)(*(void *)(a1 + 16) + v4), a2 - v4);
  }
  *(void *)(a1 + 24) = a2;
}

uint64_t sub_1DD26FA18(uint64_t result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(const void **)(result + 16);
  if (*(void *)(result + 32) >= a2)
  {
    if (v4) {
      return result;
    }
    goto LABEL_5;
  }
  if (!v4)
  {
LABEL_5:
    uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), a2);
    *(void *)(v3 + 16) = result;
    goto LABEL_6;
  }
  std::string::size_type v5 = (void *)(*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), a2);
  *(void *)(v3 + 16) = v5;
  memcpy(v5, v4, *(void *)(v3 + 24));
  uint64_t result = (*(uint64_t (**)(void, const void *))(**(void **)(v3 + 8) + 24))(*(void *)(v3 + 8), v4);
LABEL_6:
  *(void *)(v3 + 32) = a2;
  return result;
}

void *sub_1DD26FAFC(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F3879140;
  a1[1] = a2;
  a1[2] = 0;
  std::string::size_type v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FBC8((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + 8 * v6), 8 * (a3 - v6));
  }
  a1[3] = a3;
  return a1;
}

void sub_1DD26FB7C(uint64_t a1, unint64_t a2)
{
  sub_1DD26FBC8(a1, a2);
  unint64_t v4 = *(void *)(a1 + 24);
  if (a2 > v4) {
    bzero((void *)(*(void *)(a1 + 16) + 8 * v4), 8 * (a2 - v4));
  }
  *(void *)(a1 + 24) = a2;
}

uint64_t sub_1DD26FBC8(uint64_t result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(const void **)(result + 16);
  if (*(void *)(result + 32) >= a2)
  {
    if (v4) {
      return result;
    }
    goto LABEL_5;
  }
  if (!v4)
  {
LABEL_5:
    uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), 8 * a2);
    *(void *)(v3 + 16) = result;
    goto LABEL_6;
  }
  std::string::size_type v5 = (void *)(*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), 8 * a2);
  *(void *)(v3 + 16) = v5;
  memcpy(v5, v4, 8 * *(void *)(v3 + 24));
  uint64_t result = (*(uint64_t (**)(void, const void *))(**(void **)(v3 + 8) + 24))(*(void *)(v3 + 8), v4);
LABEL_6:
  *(void *)(v3 + 32) = a2;
  return result;
}

void *sub_1DD26FCB0(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F3879180;
  a1[1] = a2;
  a1[2] = 0;
  std::string::size_type v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FBC8((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + 8 * v6), 8 * (a3 - v6));
  }
  a1[3] = a3;
  return a1;
}

void *sub_1DD26FD34(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F3879120;
  a1[1] = a2;
  a1[2] = 0;
  std::string::size_type v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FEB8((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  uint64_t v7 = a3 - v6;
  if (a3 > v6)
  {
    uint64_t v8 = 16 * v6;
    do
    {
      unint64_t v9 = (void *)(*v5 + v8);
      void *v9 = 0;
      v9[1] = 0;
      v8 += 16;
      --v7;
    }
    while (v7);
  }
  a1[3] = a3;
  return a1;
}

uint64_t sub_1DD26FDC0(uint64_t a1, unint64_t a2)
{
  uint64_t result = sub_1DD26FEB8(a1, a2);
  unint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = a2 - v5;
  if (a2 > v5)
  {
    uint64_t v7 = 16 * v5;
    do
    {
      uint64_t v8 = (void *)(*(void *)(a1 + 16) + v7);
      *uint64_t v8 = 0;
      v8[1] = 0;
      v7 += 16;
      --v6;
    }
    while (v6);
  }
  *(void *)(a1 + 24) = a2;
  return result;
}

uint64_t sub_1DD26FE18(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879120;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD26FE90(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD26FE18(a1);
  operator delete(v1);
}

uint64_t sub_1DD26FEB8(uint64_t result, unint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(const void **)(result + 16);
  if (*(void *)(result + 32) >= a2)
  {
    if (v4) {
      return result;
    }
    goto LABEL_5;
  }
  if (!v4)
  {
LABEL_5:
    uint64_t result = (*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), 16 * a2);
    *(void *)(v3 + 16) = result;
    goto LABEL_6;
  }
  unint64_t v5 = (void *)(*(uint64_t (**)(void, unint64_t))(**(void **)(result + 8) + 16))(*(void *)(result + 8), 16 * a2);
  *(void *)(v3 + 16) = v5;
  memcpy(v5, v4, 16 * *(void *)(v3 + 24));
  uint64_t result = (*(uint64_t (**)(void, const void *))(**(void **)(v3 + 8) + 24))(*(void *)(v3 + 8), v4);
LABEL_6:
  *(void *)(v3 + 32) = a2;
  return result;
}

void *sub_1DD26FFA0(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F38791C0;
  a1[1] = a2;
  a1[2] = 0;
  unint64_t v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FBC8((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + 8 * v6), 8 * (a3 - v6));
  }
  a1[3] = a3;
  return a1;
}

void *sub_1DD270024(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F38791E0;
  a1[1] = a2;
  a1[2] = 0;
  unint64_t v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FBC8((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + 8 * v6), 8 * (a3 - v6));
  }
  a1[3] = a3;
  return a1;
}

void *sub_1DD2700A8(void *a1, uint64_t a2, unint64_t a3)
{
  *a1 = &unk_1F38791A0;
  a1[1] = a2;
  a1[2] = 0;
  unint64_t v5 = a1 + 2;
  a1[3] = 0;
  a1[4] = 0;
  sub_1DD26FA18((uint64_t)a1, a3);
  unint64_t v6 = a1[3];
  if (a3 > v6) {
    bzero((void *)(*v5 + v6), a3 - v6);
  }
  a1[3] = a3;
  return a1;
}

void *sub_1DD270128(int a1, size_t __size)
{
  return malloc(__size);
}

void sub_1DD270130(int a1, void *a2)
{
}

uint64_t sub_1DD270140(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879160;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD2701B8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD270140(a1);
  operator delete(v1);
}

uint64_t sub_1DD2701E0(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879140;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD270258(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD2701E0(a1);
  operator delete(v1);
}

uint64_t sub_1DD270280(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879180;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD2702F8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD270280(a1);
  operator delete(v1);
}

uint64_t sub_1DD270320(uint64_t a1)
{
  *(void *)a1 = &unk_1F38791C0;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD270398(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD270320(a1);
  operator delete(v1);
}

uint64_t sub_1DD2703C0(uint64_t a1)
{
  *(void *)a1 = &unk_1F38791E0;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD270438(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD2703C0(a1);
  operator delete(v1);
}

uint64_t sub_1DD270460(uint64_t a1)
{
  *(void *)a1 = &unk_1F38791A0;
  if (*(void *)(a1 + 16)) {
    (*(void (**)(void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8));
  }
  return a1;
}

void sub_1DD2704D8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD270460(a1);
  operator delete(v1);
}

uint64_t (***sub_1DD270500())()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1F838, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1F838))
  {
    __cxa_atexit((void (*)(void *))nullsub_4, &off_1EC8ABF88, &dword_1DD237000);
    __cxa_guard_release(&qword_1EAB1F838);
  }
  return &off_1EC8ABF88;
}

unint64_t sub_1DD270570(uint64_t *a1, unsigned int a2)
{
  return sub_1DD27057C(a1, a2, 0x19919u);
}

unint64_t sub_1DD27057C(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a3;
  if (a2 >= 8)
  {
    uint64_t v4 = a2 >> 3;
    unint64_t v5 = a1;
    do
    {
      uint64_t v6 = *v5++;
      unint64_t v3 = 5
         * __ROR8__((0x4CF5AD432745937FLL * ((0x88A129EA80000000 * v6) | ((0x87C37B91114253D5 * v6) >> 33))) ^ v3, 37)+ 1390208809;
      --v4;
    }
    while (v4);
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  uint64_t v13 = a2 & 0xFFFFFFF8;
  switch(a2 & 7)
  {
    case 1u:
      goto LABEL_11;
    case 2u:
      goto LABEL_10;
    case 3u:
      goto LABEL_9;
    case 4u:
      goto LABEL_8;
    case 5u:
      goto LABEL_7;
    case 6u:
      goto LABEL_6;
    case 7u:
      unint64_t v7 = (unint64_t)*((unsigned __int8 *)a1 + (v13 | 6)) << 48;
LABEL_6:
      unint64_t v8 = v7 | ((unint64_t)*((unsigned __int8 *)a1 + (v13 | 5)) << 40);
LABEL_7:
      unint64_t v9 = v8 ^ ((unint64_t)*((unsigned __int8 *)a1 + (v13 | 4)) << 32);
LABEL_8:
      unint64_t v10 = v9 ^ ((unint64_t)*((unsigned __int8 *)a1 + (v13 | 3)) << 24);
LABEL_9:
      unint64_t v11 = v10 ^ ((unint64_t)*((unsigned __int8 *)a1 + (v13 | 2)) << 16);
LABEL_10:
      unint64_t v12 = v11 ^ ((unint64_t)*((unsigned __int8 *)a1 + (v13 | 1)) << 8);
LABEL_11:
      v3 ^= 0x4CF5AD432745937FLL
          * ((0x88A129EA80000000 * (v12 ^ *((unsigned __int8 *)a1 + v13))) | ((0x87C37B91114253D5
                                                                               * (v12 ^ *((unsigned __int8 *)a1 + v13))) >> 33));
      break;
    default:
      break;
  }
  unint64_t v14 = 0xFF51AFD7ED558CCDLL * (a2 ^ (v3 >> 33) ^ v3);
  return (0xC4CEB9FE1A85EC53 * (v14 ^ (v14 >> 33))) ^ ((0xC4CEB9FE1A85EC53 * (v14 ^ (v14 >> 33))) >> 33);
}

uint64_t sub_1DD270718(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879870;
  close(*(_DWORD *)(a1 + 32));
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return nullsub_1(a1);
}

void sub_1DD270788(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD270718(a1);
  operator delete(v1);
}

void sub_1DD2707B0(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(char *)(a1 + 23) < 0)
  {
    sub_1DD24F980(__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a1;
    uint64_t v4 = *(void *)(a1 + 16);
  }
  sub_1DD270838((uint64_t)__p, a2);
  if (SHIBYTE(v4) < 0) {
    operator delete(__p[0]);
  }
}

void sub_1DD27081C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD270838(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x30uLL);
  if (*(char *)(a1 + 23) < 0) {
    sub_1DD24F980(&__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  sub_1DD270D90((uint64_t)v4, &__p);
  *a2 = v4;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD2708C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  operator delete(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2708EC(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879C28;
  if (!*(unsigned char *)(a1 + 48))
  {
    close(*(_DWORD *)(a1 + 32));
    *(unsigned char *)(a1 + 48) = 1;
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1DD27095C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD2708EC(a1);
  operator delete(v1);
}

void sub_1DD270984(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t v4 = operator new(0x38uLL);
  if (*(char *)(a1 + 23) < 0) {
    sub_1DD24F980(&__p, *(void **)a1, *(void *)(a1 + 8));
  }
  else {
    std::string __p = *(std::string *)a1;
  }
  sub_1DD271104((uint64_t)v4, &__p);
  *a2 = v4;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_1DD270A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  operator delete(v14);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD270A38(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1DD270A40()
{
  return 0x20000;
}

ssize_t sub_1DD270A48(uint64_t a1, void *a2, size_t a3, off_t a4)
{
  if (!a2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Buffer is null");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  ssize_t result = pread(*(_DWORD *)(a1 + 32), a2, a3, a4);
  if (result == -1)
  {
    unint64_t v7 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(v7, &v9);
    __cxa_throw(v7, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (result != a3)
  {
    unint64_t v8 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(v8, &v9);
    __cxa_throw(v8, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return result;
}

void sub_1DD270B80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_1DD270BC4(uint64_t a1)
{
  return a1 + 8;
}

ssize_t sub_1DD270BCC(uint64_t a1, const void *a2, size_t a3)
{
  if (*(unsigned char *)(a1 + 48))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Cannot write to closed stream.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  ssize_t result = write(*(_DWORD *)(a1 + 32), a2, a3);
  if (result == -1)
  {
    unint64_t v7 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(v7, &v9);
    __cxa_throw(v7, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (result != a3)
  {
    unint64_t v8 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(v8, &v9);
    __cxa_throw(v8, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  *(void *)(a1 + 40) += a3;
  return result;
}

void sub_1DD270D14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_1DD270D58(uint64_t result)
{
  if (!*(unsigned char *)(result + 48))
  {
    uint64_t v1 = result;
    ssize_t result = close(*(_DWORD *)(result + 32));
    *(unsigned char *)(v1 + 48) = 1;
  }
  return result;
}

uint64_t sub_1DD270D90(uint64_t a1, const std::string *a2)
{
  *(void *)a1 = &unk_1F3879870;
  *(void *)(a1 + 8) = 0;
  unint64_t v3 = (const char **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  std::string::operator=((std::string *)(a1 + 8), a2);
  uint64_t v4 = (const char *)v3;
  if (*(char *)(a1 + 31) < 0) {
    uint64_t v4 = *v3;
  }
  int v5 = open(v4, 0);
  *(_DWORD *)(a1 + 32) = v5;
  if (v5 == -1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    unint64_t v8 = std::string::append(&v26, ": ");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    unint64_t v10 = __error();
    unint64_t v11 = strerror(*v10);
    unint64_t v12 = std::string::append(&v27, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v28, " (");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    int v16 = __error();
    std::to_string(&v25, *v16);
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v17 = &v25;
    }
    else {
      uint64_t v17 = (std::string *)v25.__r_.__value_.__r.__words[0];
    }
    if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v25.__r_.__value_.__l.__size_;
    }
    unsigned int v19 = std::string::append(&v29, (const std::string::value_type *)v17, size);
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v30.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    int v21 = std::string::append(&v30, ")");
    long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    *(void *)&v24.st_uid = *((void *)&v21->__r_.__value_.__l + 2);
    *(_OWORD *)&v24.st_dev = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D86C(exception, (const std::string *)&v24);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (fstat(v5, &v24) == -1)
  {
    int v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(v23, &v30);
    __cxa_throw(v23, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  *(void *)(a1 + 40) = v24.st_size;
  return a1;
}

void sub_1DD270FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,void *a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v45 - 57) < 0) {
    operator delete(*(void **)(v45 - 80));
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (*(char *)(v45 - 89) < 0) {
    operator delete(*(void **)(v45 - 112));
  }
  if (*(char *)(v45 - 121) < 0) {
    operator delete(*(void **)(v45 - 144));
  }
  if (*(char *)(v45 - 153) < 0) {
    operator delete(*(void **)(v45 - 176));
  }
  if (a41 < 0)
  {
    operator delete(a36);
    if ((v44 & 1) == 0)
    {
LABEL_18:
      if (*(char *)(v41 + 31) < 0) {
        operator delete(*v42);
      }
      nullsub_1(v41);
      _Unwind_Resume(a1);
    }
  }
  else if (!v44)
  {
    goto LABEL_18;
  }
  __cxa_free_exception(v43);
  goto LABEL_18;
}

uint64_t sub_1DD271104(uint64_t a1, const std::string *a2)
{
  *(void *)a1 = &unk_1F3879C28;
  *(void *)(a1 + 8) = 0;
  unint64_t v3 = (const char **)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 40) = 0;
  std::string::operator=((std::string *)(a1 + 8), a2);
  *(unsigned char *)(a1 + 48) = 0;
  uint64_t v4 = (const char *)v3;
  if (*(char *)(a1 + 31) < 0) {
    uint64_t v4 = *v3;
  }
  int v5 = open(v4, 1537, 384);
  *(_DWORD *)(a1 + 32) = v5;
  if (v5 == -1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    unint64_t v8 = std::string::append(&v24, ": ");
    long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
    v25.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v9;
    v8->__r_.__value_.__l.__size_ = 0;
    v8->__r_.__value_.__r.__words[2] = 0;
    v8->__r_.__value_.__r.__words[0] = 0;
    unint64_t v10 = __error();
    unint64_t v11 = strerror(*v10);
    unint64_t v12 = std::string::append(&v25, v11);
    long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
    v26.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v26.__r_.__value_.__l.__data_ = v13;
    v12->__r_.__value_.__l.__size_ = 0;
    v12->__r_.__value_.__r.__words[2] = 0;
    v12->__r_.__value_.__r.__words[0] = 0;
    unint64_t v14 = std::string::append(&v26, " (");
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v27.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v27.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    int v16 = __error();
    std::to_string(&v23, *v16);
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v17 = &v23;
    }
    else {
      uint64_t v17 = (std::string *)v23.__r_.__value_.__r.__words[0];
    }
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v23.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v23.__r_.__value_.__l.__size_;
    }
    unsigned int v19 = std::string::append(&v27, (const std::string::value_type *)v17, size);
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v28.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v28.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    int v21 = std::string::append(&v28, ")");
    long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    v29.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D86C(exception, &v29);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1;
}

void sub_1DD2712F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (*(char *)(v46 - 57) < 0) {
    operator delete(*(void **)(v46 - 80));
  }
  if (*(char *)(v46 - 89) < 0) {
    operator delete(*(void **)(v46 - 112));
  }
  if (a16 < 0) {
    operator delete(__p);
  }
  if (a42 < 0) {
    operator delete(a37);
  }
  if (a35 < 0) {
    operator delete(a30);
  }
  if (a28 < 0) {
    operator delete(a23);
  }
  if (a22 < 0)
  {
    operator delete(a17);
    if ((v45 & 1) == 0)
    {
LABEL_18:
      if (*(char *)(v42 + 31) < 0) {
        operator delete(*v43);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v45)
  {
    goto LABEL_18;
  }
  __cxa_free_exception(v44);
  goto LABEL_18;
}

void *sub_1DD2713F4(void *a1)
{
  *a1 = &unk_1F3879620;
  char v2 = operator new(0x30uLL);
  sub_1DD27701C(v2);
  a1[1] = v2;
  return a1;
}

void sub_1DD271448(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD271460(void *a1, uint64_t a2)
{
  *a1 = &unk_1F3879620;
  uint64_t v4 = (char *)operator new(0x30uLL);
  int v5 = *(long long **)(a2 + 8);
  long long v6 = *v5;
  *((void *)v4 + 2) = *((void *)v5 + 2);
  *(_OWORD *)uint64_t v4 = v6;
  unint64_t v7 = v4 + 24;
  if (*((char *)v5 + 47) < 0)
  {
    sub_1DD24F980(v7, *((void **)v5 + 3), *((void *)v5 + 4));
  }
  else
  {
    long long v8 = *(long long *)((char *)v5 + 24);
    *((void *)v4 + 5) = *((void *)v5 + 5);
    *(_OWORD *)unint64_t v7 = v8;
  }
  a1[1] = v4;
  return a1;
}

void sub_1DD2714F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD271508(void *a1)
{
  *a1 = &unk_1F3879620;
  uint64_t v4 = (void **)a1[1];
  char v2 = a1 + 1;
  unint64_t v3 = v4;
  *char v2 = 0;
  if (v4) {
    sub_1DD2776A0((int)v2, v3);
  }
  return a1;
}

void sub_1DD271558(void *__p)
{
  *std::string __p = &unk_1F3879620;
  uint64_t v4 = (void **)__p[1];
  char v2 = __p + 1;
  unint64_t v3 = v4;
  *char v2 = 0;
  if (v4) {
    sub_1DD2776A0((int)v2, v3);
  }
  operator delete(__p);
}

void *sub_1DD2715B8(void *a1)
{
  *a1 = &unk_1F3879D40;
  char v2 = operator new(0x58uLL);
  v2[1] = v2 + 1;
  v2[2] = v2 + 1;
  v2[3] = 0;
  v2[4] = v2 + 4;
  *(_DWORD *)char v2 = 0;
  v2[5] = v2 + 4;
  v2[6] = 0;
  v2[7] = 0;
  v2[8] = -1;
  *((unsigned char *)v2 + 72) = 1;
  *((_DWORD *)v2 + 19) = 6;
  *((unsigned char *)v2 + 80) = 0;
  a1[1] = v2;
  return a1;
}

void sub_1DD27163C(void **a1, void *a2)
{
  char v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_1DD2770EC(v2 + 4);
    sub_1DD277088(v2 + 1);
    operator delete(v2);
  }
}

uint64_t sub_1DD271694(uint64_t a1)
{
  *(void *)a1 = &unk_1F3879D40;
  sub_1DD27163C((void **)(a1 + 8), 0);
  return a1;
}

void sub_1DD2716DC(void **a1)
{
  *a1 = &unk_1F3879D40;
  sub_1DD27163C(a1 + 1, 0);
  operator delete(a1);
}

uint64_t sub_1DD271734(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(_DWORD *)uint64_t v3 = 2;
  sub_1DD2776EC((uint64_t *)(v3 + 8), *(void *)(a2 + 8), a2);
  sub_1DD2770EC((void *)(*(void *)(a1 + 8) + 32));
  return a1;
}

int *sub_1DD27177C()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1F870, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1F870))
  {
    dword_1EAB1F868 = 1;
    __cxa_guard_release(&qword_1EAB1F870);
  }
  return &dword_1EAB1F868;
}

uint64_t sub_1DD2717D4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 16) & 8) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Unknown compression type");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return *(unsigned int *)(a1 + 72);
}

void sub_1DD271834(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD271848@<X0>(uint64_t result@<X0>, std::string *a2@<X8>)
{
  if (*(void *)(result + 56) == *(void *)(result + 64))
  {
    a2->__r_.__value_.__r.__words[0] = 0;
    a2->__r_.__value_.__l.__size_ = 0;
    a2->__r_.__value_.__r.__words[2] = 0;
  }
  else
  {
    uint64_t v3 = result;
    sub_1DD239280((uint64_t)v5);
    sub_1DD277930(*(void *)(v3 + 56), *(void *)(v3 + 64), (uint64_t)v5, (uint64_t)".", (uint64_t *)&__str);
    std::stringbuf::str();
    std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
    if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = __str.__r_.__value_.__l.__size_;
    }
    std::string::basic_string(a2, &__str, 0, size - 1, (std::allocator<char> *)&v9);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    v5[0] = *MEMORY[0x1E4FBA418];
    *(void *)((char *)v5 + *(void *)(v5[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
    v5[1] = MEMORY[0x1E4FBA470] + 16;
    if (v6 < 0) {
      operator delete((void *)v5[9]);
    }
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    return MEMORY[0x1E01B1EC0](&v7);
  }
  return result;
}

void sub_1DD2719DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v2 - 41) < 0) {
    operator delete(*(void **)(v2 - 64));
  }
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD271A0C(uint64_t a1, void *a2, uint64_t a3)
{
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  uint64_t v6 = *(void *)(*a2 + 8 * (result >> 6));
  if (((1 << result) & v6) == 0)
  {
    unint64_t v7 = result;
    *(void *)(*a2 + 8 * (result >> 6)) = v6 | (1 << result);
    for (unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3);
          v7 <= result;
          unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 24))(a3))
    {
      *(void *)(*a2 + ((v7 >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << v7;
      ++v7;
    }
  }
  return result;
}

uint64_t sub_1DD271B0C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  unint64_t v7 = v6 >> 6;
  uint64_t v8 = 1 << v6;
  int v9 = ((1 << v6) & *(void *)(*a2 + 8 * (v6 >> 6))) != 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3))
  {
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a3 + 48))(a3, v10);
      v9 |= sub_1DD271B0C(a1, a2, v11);
      ++v10;
    }
    while (v10 < (*(uint64_t (**)(uint64_t))(*(void *)a3 + 40))(a3));
  }
  uint64_t v12 = *a2;
  if (v9) {
    uint64_t v13 = *(void *)(v12 + 8 * v7) | v8;
  }
  else {
    uint64_t v13 = *(void *)(v12 + 8 * v7) & ~v8;
  }
  *(void *)(v12 + 8 * v7) = v13;
  return v9 & 1;
}

unint64_t sub_1DD271C58(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (uint64_t **)(a1 + 24);
  p_p = (std::string *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&p_p;
  sub_1DD277A0C(v4, (unint64_t *)&p_p, (uint64_t)&unk_1DD32030B, (uint64_t **)&__p)[5] = a2;
  LODWORD(v4) = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  if (v4 == 12)
  {
    if (result)
    {
      for (unint64_t i = 0; i < result; ++i)
      {
        unint64_t v7 = (long long *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 56))(a2, i);
        unint64_t v8 = *(void *)(a1 + 64);
        int v9 = (uint64_t *)(a1 + 56);
        if (v8 >= *(void *)(a1 + 72))
        {
          uint64_t v10 = sub_1DD277B2C(v9, v7);
        }
        else
        {
          sub_1DD277ACC(v9, v7);
          uint64_t v10 = v8 + 24;
        }
        *(void *)(a1 + 64) = v10;
        uint64_t v11 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 48))(a2, i);
        uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
        sub_1DD271848(a1, &__p);
        p_p = &__p;
        *((void *)sub_1DD277E78((uint64_t **)a1, (const void **)&__p.__r_.__value_.__l.__data_, (uint64_t)&unk_1DD32030B, (_OWORD **)&p_p)+ 7) = v12;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        uint64_t v13 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 48))(a2, i);
        sub_1DD271C58(a1, v13);
        uint64_t v14 = *(void *)(a1 + 64);
        long long v15 = (void **)(v14 - 24);
        if (*(char *)(v14 - 1) < 0) {
          operator delete(*v15);
        }
        *(void *)(a1 + 64) = v15;
        unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
      }
    }
  }
  else if (result)
  {
    for (unint64_t j = 0; j < result; ++j)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 48))(a2, j);
      sub_1DD271C58(a1, v17);
      unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
    }
  }
  return result;
}

void sub_1DD271F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD271F68(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v6 = *(int *)(*(void *)(*(void *)(a1 + 48) + 16) + 56);
  LOBYTE(v17) = 0;
  sub_1DD272130((uint64_t)a2, v6, &v17);
  if ((*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 48) + 24) + 32))(*(void *)(*(void *)(a1 + 48) + 24)) == 12
    && (uint64_t v7 = *(void *)(a3 + 8), *(_DWORD *)v7 == 2))
  {
    uint64_t v8 = *(void *)(v7 + 16);
    if (v8 != v7 + 8)
    {
      do
      {
        sub_1DD272244(a1, a2, *(void *)(v8 + 16));
        uint64_t v8 = *(void *)(v8 + 8);
      }
      while (v8 != *(void *)(a3 + 8) + 8);
    }
  }
  else
  {
    int v9 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 48) + 24) + 32))(*(void *)(*(void *)(a1 + 48) + 24));
    uint64_t v10 = *(int **)(a3 + 8);
    int v11 = *v10;
    if (v9 == 12 && v11 == 1)
    {
      uint64_t v14 = *((void *)v10 + 5);
      if ((int *)v14 != v10 + 8)
      {
        do
        {
          sub_1DD272408(a1, a2, (const void **)(v14 + 16));
          uint64_t v14 = *(void *)(v14 + 8);
        }
        while (v14 != *(void *)(a3 + 8) + 32);
      }
    }
    else if (v11 == 3)
    {
      uint64_t v13 = *((void *)v10 + 2);
      if ((int *)v13 != v10 + 2)
      {
        do
        {
          sub_1DD272500(a1, a2, *(void *)(v13 + 16));
          uint64_t v13 = *(void *)(v13 + 8);
        }
        while (v13 != *(void *)(a3 + 8) + 8);
      }
    }
    else
    {
      unint64_t v15 = a2[1];
      if (v15)
      {
        uint64_t v17 = *a2;
        int v18 = 0;
        sub_1DD27832C(&v17, v15);
      }
    }
  }
  uint64_t result = sub_1DD271B0C(a1, a2, *(void *)(*(void *)(a1 + 48) + 24));
  *(void *)*a2 |= 1uLL;
  return result;
}

void sub_1DD272130(uint64_t a1, unint64_t a2, unsigned char *a3)
{
  *(void *)(a1 + 8) = 0;
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = v6 << 6;
    if (v6 << 6 >= a2)
    {
      *(void *)(a1 + 8) = a2;
    }
    else
    {
      uint64_t v14 = 0;
      long long v15 = 0uLL;
      if ((a2 & 0x8000000000000000) != 0) {
        sub_1DD251DAC();
      }
      unint64_t v8 = v6 << 7;
      if (v8 <= ((a2 + 63) & 0xFFFFFFFFFFFFFFC0)) {
        unint64_t v8 = (a2 + 63) & 0xFFFFFFFFFFFFFFC0;
      }
      if (v7 <= 0x3FFFFFFFFFFFFFFELL) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      sub_1DD278020(&v14, v9);
      int v11 = v14;
      uint64_t v12 = *((void *)&v15 + 1);
      uint64_t v14 = *(char **)a1;
      uint64_t v10 = v14;
      long long v13 = *(_OWORD *)(a1 + 8);
      *(void *)a1 = v11;
      *(void *)(a1 + 8) = a2;
      *(void *)(a1 + 16) = v12;
      long long v15 = v13;
      if (v10) {
        operator delete(v10);
      }
    }
    if (*a3)
    {
      uint64_t v14 = *(char **)a1;
      LODWORD(v15) = 0;
      sub_1DD27832C(&v14, a2);
    }
    else
    {
      uint64_t v14 = *(char **)a1;
      LODWORD(v15) = 0;
      sub_1DD2783E0((uint64_t)&v14, a2);
    }
  }
}

void sub_1DD27222C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DD272244(uint64_t a1, void *a2, unint64_t a3)
{
  if ((*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 48) + 24) + 40))(*(void *)(*(void *)(a1 + 48) + 24)) <= a3)
  {
    sub_1DD250F88((uint64_t)v11);
    sub_1DD239B24(v12, (uint64_t)"Invalid column selected ", 24);
    unint64_t v8 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v8, (uint64_t)" out of ", 8);
    (*(void (**)(void))(**(void **)(*(void *)(a1 + 48) + 24) + 40))(*(void *)(*(void *)(a1 + 48) + 24));
    std::ostream::operator<<();
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    sub_1DD26D86C(exception, &v10);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v6 = (*(uint64_t (**)(void, unint64_t))(**(void **)(*(void *)(a1 + 48) + 24) + 48))(*(void *)(*(void *)(a1 + 48) + 24), a3);
  return sub_1DD271A0C(v6, a2, v6);
}

void sub_1DD2723C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

unint64_t sub_1DD272408(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = sub_1DD278490(a1, a3);
  if (a1 + 8 == v5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::operator+<char>();
    sub_1DD26D86C(exception, &v9);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  unint64_t v6 = *(void *)(v5 + 56);
  return sub_1DD272500(a1, a2, v6);
}

void sub_1DD2724C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

unint64_t sub_1DD272500(uint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v11 = a3;
  if (a2[1] <= a3)
  {
    sub_1DD250F88((uint64_t)v9);
    sub_1DD239B24(v10, (uint64_t)"Invalid type id selected ", 25);
    unint64_t v6 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v6, (uint64_t)" out of ", 8);
    std::ostream::operator<<();
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    sub_1DD26D86C(exception, &v8);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  v9[0] = (uint64_t *)&v11;
  uint64_t v4 = sub_1DD277A0C((uint64_t **)(a1 + 24), &v11, (uint64_t)&unk_1DD32030B, v9);
  return sub_1DD271A0C((uint64_t)v4, a2, v4[5]);
}

void sub_1DD272608(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void *sub_1DD272650(void *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  a1[4] = 0;
  *a1 = a1 + 1;
  a1[3] = a1 + 4;
  a1[5] = 0;
  a1[6] = a2;
  a1[7] = 0;
  a1[8] = 0;
  a1[9] = 0;
  sub_1DD271C58((uint64_t)a1, *(void *)(a2 + 24));
  return a1;
}

void sub_1DD2726BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  long long v13 = v12;
  a10 = v13;
  sub_1DD278584(&a10);
  sub_1DD268698(v11, *(void **)(v10 + 32));
  sub_1DD278520(v10, *(char **)(v10 + 8));
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2726F0(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879640;
  *(void *)(a1 + 8) = sub_1DD287CA0();
  uint64_t v6 = *a2;
  *(void *)(a1 + 16) = *a2;
  uint64_t v7 = a2[1];
  *(void *)(a1 + 24) = v7;
  if (v7)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    uint64_t v6 = *(void *)(a1 + 16);
  }
  uint64_t v8 = *(void *)(a3 + 8);
  char v9 = *(unsigned char *)(v8 + 72);
  LODWORD(v8) = *(_DWORD *)(v8 + 76);
  *(void *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 32) = v9;
  *(_DWORD *)(a1 + 36) = v8;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = *(void *)(v6 + 16);
  sub_1DD2700A4((void *)(a1 + 72), *(void *)(v6 + 48), 0);
  *(void *)(a1 + 112) = 0;
  sub_1DD246DF0(a1 + 168);
  sub_1DD2448B0(a1 + 264);
  *(void *)(a1 + 368) = 0;
  char v10 = *(unsigned char *)(*(void *)(a3 + 8) + 80);
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  unint64_t v11 = *(int *)(*(void *)(a1 + 64) + 32);
  *(void *)(a1 + 144) = 0;
  uint64_t v12 = (unint64_t *)(a1 + 144);
  *(unsigned char *)(a1 + 376) = v10;
  *(_DWORD *)(a1 + 416) = 1065353216;
  *(void *)(a1 + 136) = v11;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  sub_1DD26FB7C(a1 + 72, v11);
  if (v11)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 88) + 8 * v14) = v15;
      sub_1DD246F14((uint64_t)v21, *(void *)(*(void *)(*(void *)(a1 + 64) + 40) + (v13 >> 29) + 8));
      uint64_t v16 = *(void *)(a3 + 8);
      unint64_t v17 = *(void *)(v16 + 56);
      if (v23 >= v17 && v23 < *(void *)(v16 + 64) + v17)
      {
        if (v14 < *(void *)(a1 + 136)) {
          *(void *)(a1 + 136) = v14;
        }
        if (v14 >= *v12) {
          unint64_t *v12 = v14 + 1;
        }
      }
      v15 += v24[3];
      sub_1DD246F68(v21);
      ++v14;
      v13 += 0x100000000;
    }
    while (v11 != v14);
  }
  uint64_t v18 = *(void *)(a1 + 136);
  *(void *)(a1 + 128) = v18;
  if (v18)
  {
    if (v18 == v11) {
      uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 144);
    }
    else {
      uint64_t v19 = *(void *)(*(void *)(a1 + 88) + 8 * v18) - 1;
    }
  }
  else
  {
    uint64_t v19 = -1;
  }
  *(void *)(a1 + 120) = v19;
  sub_1DD272650(v21, *(void *)(a1 + 16));
  sub_1DD271F68((uint64_t)v21, (uint64_t *)(a1 + 40), a3);
  std::string v25 = (void **)v24;
  sub_1DD278584(&v25);
  sub_1DD268698((uint64_t)v22, v22[1]);
  sub_1DD278520((uint64_t)v21, (char *)v21[1]);
  return a1;
}

void sub_1DD272948(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, ...)
{
  va_start(va, a4);
  sub_1DD272A1C((uint64_t)va);
  sub_1DD278628((uint64_t)(v4 + 48));
  uint64_t v8 = v4[46];
  v4[46] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  sub_1DD24498C(a3);
  sub_1DD246F68(a4);
  uint64_t v9 = v4[14];
  v4[14] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  sub_1DD270434(v6);
  if (*v5) {
    operator delete(*v5);
  }
  char v10 = (std::__shared_weak_count *)v4[3];
  if (v10) {
    sub_1DD25B904(v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD272A1C(uint64_t a1)
{
  uint64_t v3 = (void **)(a1 + 56);
  sub_1DD278584(&v3);
  sub_1DD268698(a1 + 24, *(void **)(a1 + 32));
  sub_1DD278520(a1, *(char **)(a1 + 8));
  return a1;
}

uint64_t sub_1DD272A70(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 16) + 40);
}

uint64_t sub_1DD272A7C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 32);
}

void *sub_1DD272A88@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  return sub_1DD2786A8(a2, a1 + 40);
}

uint64_t sub_1DD272A94(void *a1)
{
  uint64_t result = a1[14];
  if (!result)
  {
    sub_1DD28B890(*(void *)(a1[2] + 24), a1 + 5, &v6);
    uint64_t v3 = v6;
    uint64_t v6 = 0;
    uint64_t v4 = a1[14];
    a1[14] = v3;
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      uint64_t v5 = v6;
      uint64_t v6 = 0;
      if (v5) {
        (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
      }
    }
    return a1[14];
  }
  return result;
}

uint64_t sub_1DD272B44(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

void *sub_1DD272B4C(void *result, unint64_t a2)
{
  unint64_t v2 = result[18];
  if (!v2) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  uint64_t v4 = result[8];
  unint64_t v5 = *(int *)(v4 + 32);
  if (v2 == v5)
  {
    unint64_t v6 = *(void *)(v4 + 144);
    if (v6 <= a2)
    {
LABEL_20:
      result[17] = v5;
      result[15] = v6;
      return result;
    }
  }
  if (v2 < v5 && *(void *)(result[11] + 8 * v2) <= a2)
  {
    unint64_t v6 = *(void *)(v4 + 144);
    goto LABEL_20;
  }
  unint64_t v7 = v2 - 1;
  uint64_t v8 = 1;
  while (v2 != v8)
  {
    unint64_t v9 = *(void *)(result[11] + 8 * v8++);
    if (v9 > a2)
    {
      unint64_t v7 = v8 - 2;
      break;
    }
  }
  if (v7 >= result[16])
  {
    result[17] = v7;
    result[19] = a2 - *(void *)(result[11] + 8 * v7);
    result[15] = a2;
    sub_1DD272C8C((uint64_t)result);
    unint64_t v10 = *(void *)(v3 + 152);
    unint64_t v11 = *(unsigned int *)(*(void *)(v3 + 64) + 152);
    if (v11 && *(void *)(v3 + 224) && (v10 / v11)) {
      sub_1DD272FC4(v3, v10 / v11);
    }
    uint64_t v12 = *(uint64_t (**)(void))(**(void **)(v3 + 368) + 16);
    return (void *)v12();
  }
  else
  {
    result[17] = v5;
    result[15] = *(void *)(v4 + 144);
  }
  return result;
}

uint64_t sub_1DD272C8C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1DD247880((std::string *)(a1 + 168), *(void *)(*(void *)(*(void *)(a1 + 64) + 40) + ((uint64_t)(*(void *)(a1 + 136) << 32) >> 29) + 8));
  if (vaddvq_s64(vaddq_s64(*(int64x2_t *)(a1 + 216), *(int64x2_t *)(a1 + 232))) >= (unint64_t)(*(uint64_t (**)(void))(***(void ***)(a1 + 16) + 16))(**(void **)(a1 + 16)))
  {
    sub_1DD250F88((uint64_t)v16);
    sub_1DD239B24(v17, (uint64_t)"Malformed StripeInformation at stripe index ", 44);
    uint64_t v8 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v8, (uint64_t)": fileLength=", 13);
    unint64_t v9 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v9, (uint64_t)", StripeInfo=(offset=", 21);
    unint64_t v10 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v10, (uint64_t)", indexLength=", 14);
    unint64_t v11 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v11, (uint64_t)", dataLength=", 13);
    uint64_t v12 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v12, (uint64_t)", footerLength=", 15);
    uint64_t v13 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v13, (uint64_t)")", 1);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    sub_1DD26D86C(exception, &v15);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  sub_1DD273418((void *)(a1 + 168), *(void *)(a1 + 16), (uint64_t)v16);
  if ((void *)(a1 + 264) != v16) {
    sub_1DD245420(a1 + 264, v16);
  }
  sub_1DD24498C(v16);
  *(void *)(a1 + 160) = *(void *)(a1 + 248);
  if (*(unsigned char *)(a1 + 280)) {
    uint64_t v3 = sub_1DD287D10(*(void *)(a1 + 360));
  }
  else {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  sub_1DD285DC8(v16, a1, *(void *)(a1 + 136), a1 + 168, a1 + 264, *(void *)(a1 + 216), **(void **)(a1 + 16), v3);
  sub_1DD2574E4(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v16, &v15);
  std::string::size_type v4 = v15.__r_.__value_.__r.__words[0];
  v15.__r_.__value_.__r.__words[0] = 0;
  uint64_t v5 = *(void *)(a1 + 368);
  *(void *)(a1 + 368) = v4;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    std::string::size_type v6 = v15.__r_.__value_.__r.__words[0];
    v15.__r_.__value_.__r.__words[0] = 0;
    if (v6) {
      (*(void (**)(std::string::size_type))(*(void *)v6 + 8))(v6);
    }
  }
  return j_nullsub_1_0(v16);
}

void sub_1DD272F68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_1DD272FC4(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 384;
  sub_1DD27882C(a1 + 384);
  int v4 = *(_DWORD *)(a1 + 296);
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 216);
    do
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 304) + 8 * v5 + 8);
      *(void *)&long long v31 = *(unsigned int *)(v7 + 28);
      if (((*(void *)(*(void *)(a1 + 40) + (((unint64_t)v31 >> 3) & 0x1FFFFFF8)) >> v31) & 1) != 0
        && (*(unsigned char *)(v7 + 16) & 1) != 0
        && *(_DWORD *)(v7 + 24) == 6)
      {
        uint64_t v8 = *(void *)(a1 + 16);
        uint64_t v9 = *(unsigned int *)(v8 + 40);
        unint64_t v10 = operator new(0x48uLL);
        sub_1DD23960C(v10, *(void *)v8, v6, *(void *)(v7 + 32), *(void *)(v8 + 48), 0);
        __int16 v38 = v10;
        sub_1DD26C1EC(v9, (uint64_t *)&v38, *(void *)(*(void *)(a1 + 16) + 32), *(void *)(*(void *)(a1 + 16) + 48), &v39);
        uint64_t v11 = (uint64_t)v38;
        __int16 v38 = 0;
        if (v11) {
          (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
        }
        sub_1DD241978((uint64_t)v36);
        if ((sub_1DD2F9DB8((uint64_t)v36, v39) & 1) == 0)
        {
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          sub_1DD26D8A0(exception, "Failed to parse the row index");
          __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        int v33 = &v31;
        uint64_t v12 = (std::string *)sub_1DD278884(v3, (uint64_t *)&v31, (uint64_t)&unk_1DD32030B, (void **)&v33);
        sub_1DD241EB8(v12 + 1, (uint64_t)v36);
        sub_1DD2419CC(v36);
        uint64_t v13 = v39;
        uint64_t v39 = 0;
        if (v13) {
          (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
        }
        int v4 = *(_DWORD *)(a1 + 296);
      }
      v6 += *(void *)(v7 + 32);
      ++v5;
    }
    while (v5 < v4);
  }
  int v33 = 0;
  int v34 = 0;
  unint64_t v35 = 0;
  memset(v36, 0, sizeof(v36));
  int v37 = 1065353216;
  for (unint64_t i = *(void **)(a1 + 400); i; unint64_t i = (void *)*i)
  {
    uint64_t v15 = i[2];
    uint64_t v16 = *(void *)(i[8] + 8 * a2 + 8);
    *(void *)&long long v31 = &v31;
    *((void *)&v31 + 1) = &v31;
    uint64_t v32 = 0;
    unint64_t v17 = v34;
    if ((unint64_t)v34 >= v35)
    {
      uint64_t v22 = sub_1DD278EBC((uint64_t *)&v33, &v31);
    }
    else
    {
      *int v34 = (uint64_t)v34;
      v17[1] = (uint64_t)v17;
      void v17[2] = 0;
      uint64_t v18 = v32;
      if (v32)
      {
        long long v19 = v31;
        uint64_t v20 = **((void **)&v31 + 1);
        *(void *)(v20 + 8) = *(void *)(v31 + 8);
        **(void **)(v19 + 8) = v20;
        uint64_t v21 = *v17;
        *(void *)(v21 + 8) = *((void *)&v19 + 1);
        **((void **)&v19 + 1) = v21;
        *unint64_t v17 = v19;
        *(void *)(v19 + 8) = v17;
        void v17[2] = v18;
        uint64_t v32 = 0;
      }
      uint64_t v22 = (uint64_t)(v17 + 3);
    }
    int v34 = (uint64_t *)v22;
    sub_1DD277088(&v31);
    unint64_t v23 = v34;
    uint64_t v24 = (uint64_t)(v34 - 3);
    if (*(_DWORD *)(v16 + 24))
    {
      uint64_t v25 = 0;
      do
      {
        uint64_t v26 = *(void *)(*(void *)(v16 + 32) + 8 * v25 + 8);
        std::string v27 = operator new(0x18uLL);
        v27[1] = v24;
        v27[2] = v26;
        uint64_t v28 = *(v23 - 3);
        *std::string v27 = v28;
        *(void *)(v28 + 8) = v27;
        *(v23 - 3) = (uint64_t)v27;
        ++*(v23 - 1);
        ++v25;
      }
      while (v25 != *(_DWORD *)(v16 + 24));
    }
    sub_1DD238F98(&v39, v24);
    *(void *)&long long v31 = v15;
    *((void *)&v31 + 1) = v39;
    sub_1DD279118((uint64_t)v36, (unint64_t *)&v31, &v31);
  }
  (*(void (**)(void, _OWORD *))(**(void **)(a1 + 368) + 40))(*(void *)(a1 + 368), v36);
  sub_1DD278E70((uint64_t)v36);
  *(void *)&v36[0] = &v33;
  sub_1DD278DEC((void ***)v36);
}

void sub_1DD273340(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17)
{
  a17 = (void **)&a14;
  sub_1DD278DEC(&a17);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD273400(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t sub_1DD273408(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 32);
}

uint64_t sub_1DD273410(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t sub_1DD273418@<X0>(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v5 = a1[9];
  uint64_t v6 = a1[7] + a1[6] + a1[8];
  uint64_t v7 = *(unsigned int *)(a2 + 40);
  uint64_t v8 = operator new(0x48uLL);
  sub_1DD23960C(v8, *(void *)a2, v6, v5, *(void *)(a2 + 48), 0);
  uint64_t v20 = v8;
  sub_1DD26C1EC(v7, (uint64_t *)&v20, *(void *)(a2 + 32), *(void *)(a2 + 48), &v21);
  uint64_t v9 = (uint64_t)v20;
  uint64_t v20 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  sub_1DD2448B0(a3);
  if ((sub_1DD2F9DB8(a3, v21) & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD314888(&v18, "bad StripeFooter from ");
    (*(void (**)(void *__return_ptr))(*(void *)v21 + 56))(v16);
    if ((v17 & 0x80u) == 0) {
      uint64_t v12 = (const std::string::value_type *)v16;
    }
    else {
      uint64_t v12 = (const std::string::value_type *)v16[0];
    }
    if ((v17 & 0x80u) == 0) {
      std::string::size_type v13 = v17;
    }
    else {
      std::string::size_type v13 = v16[1];
    }
    unint64_t v14 = std::string::append(&v18, v12, v13);
    long long v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
    v19.__r_.__value_.__r.__words[2] = v14->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v19.__r_.__value_.__l.__data_ = v15;
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D86C(exception, &v19);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t result = v21;
  uint64_t v21 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1DD2735DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a20 < 0)
  {
    operator delete(a15);
    if ((v28 & 1) == 0)
    {
LABEL_10:
      sub_1DD24498C(v26);
      uint64_t v31 = *(void *)(v29 - 56);
      *(void *)(v29 - 56) = 0;
      if (v31) {
        (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v28)
  {
    goto LABEL_10;
  }
  __cxa_free_exception(v27);
  goto LABEL_10;
}

uint64_t sub_1DD2736C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(void *)a1 = &unk_1F3879228;
  *(_OWORD *)(a1 + 8) = *(_OWORD *)a2;
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  sub_1DD271460((void *)(a1 + 24), a3);
  *(void *)(a1 + 40) = a4;
  *(void *)(a1 + 48) = a5;
  *(void *)(a1 + 56) = *(void *)(*(void *)(a1 + 8) + 16);
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 0;
  sub_1DD273890(a1);
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 64) = *(int *)(v8 + 32);
  sub_1DD28B36C(*(void *)(*(void *)(v8 + 64) + 8), v8, &v17);
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = v17;
  unsigned __int8 v17 = 0;
  uint64_t v11 = *(void *)(v9 + 24);
  *(void *)(v9 + 24) = v10;
  if (v11)
  {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    uint64_t v12 = v17;
    unsigned __int8 v17 = 0;
    if (v12) {
      (*(void (**)(char *))(*(void *)v12 + 8))(v12);
    }
  }
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = *(void *)(v13 + 8);
  uint64_t v15 = 0x40000;
  if ((*(_DWORD *)(v14 + 16) & 4) != 0) {
    uint64_t v15 = *(void *)(v14 + 64);
  }
  *(void *)(v13 + 32) = v15;
  *(_DWORD *)(*(void *)(a1 + 8) + 40) = sub_1DD2717D4(v14);
  return a1;
}

void sub_1DD273810(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v1[9];
  v1[9] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  int v4 = (void **)v1[4];
  v1[3] = &unk_1F3879620;
  v1[4] = 0;
  if (v4) {
    sub_1DD2776A0(v1 + 32, v4);
  }
  unint64_t v5 = (std::__shared_weak_count *)v1[2];
  if (v5) {
    sub_1DD25B904(v5);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD273890(uint64_t a1)
{
  uint64_t v2 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v15 = v2;
  if (v2 || (HIDWORD(v2) - 13) <= 0xFFFFFFFD)
  {
    uint64_t v3 = sub_1DD239B24(*(void **)(*(void *)(a1 + 32) + 8), (uint64_t)"Warning: ORC file ", 18);
    uint64_t v4 = (*(uint64_t (**)(void))(***(void ***)(a1 + 8) + 40))(**(void **)(a1 + 8));
    int v5 = *(char *)(v4 + 23);
    if (v5 >= 0) {
      uint64_t v6 = v4;
    }
    else {
      uint64_t v6 = *(void *)v4;
    }
    if (v5 >= 0) {
      uint64_t v7 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      uint64_t v7 = *(void *)(v4 + 8);
    }
    uint64_t v8 = sub_1DD239B24(v3, v6, v7);
    uint64_t v9 = sub_1DD239B24(v8, (uint64_t)" was written in an unknown format version ", 42);
    sub_1DD269BC0();
    if ((v14 & 0x80u) == 0) {
      unint64_t v10 = __p;
    }
    else {
      unint64_t v10 = (void **)__p[0];
    }
    if ((v14 & 0x80u) == 0) {
      uint64_t v11 = v14;
    }
    else {
      uint64_t v11 = (uint64_t)__p[1];
    }
    uint64_t v12 = sub_1DD239B24(v9, (uint64_t)v10, v11);
    sub_1DD239B24(v12, (uint64_t)"\n", 1);
    if ((char)v14 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_1DD2739C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD2739DC@<X0>(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  sub_1DD24DB58((uint64_t)v8);
  v9 |= 1u;
  uint64_t v4 = v10;
  if (!v10)
  {
    uint64_t v4 = sub_1DD24F424(0);
    unint64_t v10 = v4;
  }
  sub_1DD24DA68(v4, *(void *)(*(void *)(a1 + 8) + 8));
  v9 |= 2u;
  int v5 = v11;
  if (!v11)
  {
    int v5 = (std::string *)sub_1DD24F390(0);
    uint64_t v11 = v5;
  }
  sub_1DD24CB3C(v5, *(void *)(a1 + 56));
  v9 |= 0xCu;
  long long v12 = *(_OWORD *)(a1 + 40);
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  a2->__r_.__value_.__r.__words[0] = 0;
  if (!sub_1DD2FA900((uint64_t)v8, a2))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Failed to serialize file tail");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return sub_1DD24DC4C(v8);
}

void sub_1DD273AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v11);
  if (*(char *)(v10 + 23) < 0) {
    operator delete(*(void **)v10);
  }
  sub_1DD24DC4C(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD273B14(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 40);
}

uint64_t sub_1DD273B20(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 32);
}

uint64_t sub_1DD273B2C(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_1DD273B34(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 80)) {
    sub_1DD273B78((void *)a1);
  }
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2) {
    return *(int *)(v2 + 32);
  }
  else {
    return 0;
  }
}

void *sub_1DD273B78(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  uint64_t v3 = *(void *)(v2 + 8);
  unint64_t v4 = *(void *)(v3 + 80);
  uint64_t v5 = *(void *)(v3 + 56);
  unint64_t v6 = result[5];
  unint64_t v7 = v5 + v4 + result[6];
  if (v6 < v7 + 1)
  {
    sub_1DD250F88((uint64_t)v21);
    sub_1DD239B24(v22, (uint64_t)"Invalid Metadata length: fileLength=", 36);
    unsigned __int8 v14 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v14, (uint64_t)", metadataLength=", 17);
    uint64_t v15 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v15, (uint64_t)", footerLength=", 15);
    uint64_t v16 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v16, (uint64_t)", postscriptLength=", 19);
    std::ostream::operator<<();
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    sub_1DD26D86C(exception, &v20);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (v4)
  {
    uint64_t v8 = v6 + ~v7;
    uint64_t v9 = *(unsigned int *)(v2 + 40);
    uint64_t v10 = operator new(0x48uLL);
    sub_1DD23960C(v10, *(void *)v2, v8, v4, *(void *)(v2 + 48), 0);
    std::string v19 = v10;
    sub_1DD26C1EC(v9, (uint64_t *)&v19, *(void *)(v1[1] + 32), *(void *)(v1[1] + 48), v21);
    uint64_t v11 = (uint64_t)v19;
    std::string v19 = 0;
    if (v11) {
      (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
    }
    long long v12 = operator new(0x30uLL);
    sub_1DD248498((uint64_t)v12);
    uint64_t v13 = v1[9];
    v1[9] = v12;
    if (v13)
    {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
      long long v12 = (void *)v1[9];
    }
    if ((sub_1DD2F9DB8((uint64_t)v12, v21[0]) & 1) == 0)
    {
      std::string v18 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(v18, "Failed to parse the metadata");
      __cxa_throw(v18, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t result = (void *)v21[0];
    v21[0] = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  *((unsigned char *)v1 + 80) = 1;
  return result;
}

void sub_1DD273DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v18 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a17);
      _Unwind_Resume(a1);
    }
  }
  else if (!v18)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v17);
  goto LABEL_6;
}

void *sub_1DD273EBC@<X0>(void *a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  int v3 = a2;
  if ((*(uint64_t (**)(void *))(*a1 + 104))(a1) < a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "stripe index out of range");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  sub_1DD246F14((uint64_t)v16, *(void *)(*(void *)(a1[7] + 40) + 8 * v3 + 8));
  unint64_t v6 = (char *)operator new(0x58uLL);
  uint64_t v7 = v19;
  uint64_t v8 = (uint64_t *)a1[1];
  uint64_t v9 = *v8;
  uint64_t v10 = v8[6];
  int v11 = *((_DWORD *)v8 + 10);
  uint64_t v12 = v8[4];
  long long v13 = v18;
  *(_OWORD *)(v6 + 8) = v17;
  *(void *)unint64_t v6 = &unk_1F387A9D8;
  *(_OWORD *)(v6 + 24) = v13;
  *((void *)v6 + 5) = v7;
  *((void *)v6 + 6) = v9;
  *((void *)v6 + 7) = v10;
  *((_DWORD *)v6 + 16) = v11;
  *((void *)v6 + 9) = v12;
  *((void *)v6 + 10) = 0;
  *a3 = v6;
  return sub_1DD246F68(v16);
}

void sub_1DD273FD8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD273FFC(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 8);
  if (*(_DWORD *)(v1 + 24) == 2)
  {
    uint64_t v2 = *(void *)(v1 + 32);
    unsigned int v3 = *(_DWORD *)(v2 + 8);
    uint64_t v4 = *(unsigned int *)(v2 + 12);
  }
  else
  {
    uint64_t v5 = sub_1DD269D64();
    unsigned int v3 = *(_DWORD *)v5;
    uint64_t v4 = *((unsigned int *)v5 + 1);
  }
  return v3 | (unint64_t)(v4 << 32);
}

uint64_t sub_1DD274040(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 144);
}

uint64_t sub_1DD27404C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if ((*(unsigned char *)(v1 + 16) & 0x20) == 0) {
    return 0;
  }
  unsigned int v3 = *(_DWORD *)(v1 + 156);
  if (v3 <= 2) {
    return v3;
  }
  else {
    return 0x7FFFFFFFLL;
  }
}

uint64_t sub_1DD274074(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if ((*(unsigned char *)(v1 + 16) & 0x20) != 0) {
    return *(unsigned int *)(v1 + 156);
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD274090(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 8) + 8);
  if ((*(unsigned char *)(v1 + 16) & 0x10) != 0) {
    return *(unsigned int *)(v1 + 76);
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD2740B0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 136);
}

uint64_t sub_1DD2740BC(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 80);
}

uint64_t sub_1DD2740CC(uint64_t a1)
{
  return *(void *)(*(void *)(*(void *)(a1 + 8) + 8) + 56);
}

uint64_t sub_1DD2740DC(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_1DD2740E4(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_1DD2740EC(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 56) + 152);
}

uint64_t sub_1DD2740F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(***(void ***)(a1 + 8) + 40))();
}

void *sub_1DD274124@<X0>(void *result@<X0>, uint64_t *a2@<X8>)
{
  *a2 = (uint64_t)a2;
  a2[1] = (uint64_t)a2;
  a2[2] = 0;
  uint64_t v3 = result[7];
  if (*(int *)(v3 + 80) >= 1)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    do
    {
      uint64_t result = sub_1DD2778B4((uint64_t)a2, 0, 0, *(void *)(*(void *)(*(void *)(v3 + 88) + 8 * v5 + 8) + 24));
      uint64_t v6 = *a2;
      *uint64_t result = *a2;
      result[1] = a2;
      *(void *)(v6 + 8) = result;
      *a2 = (uint64_t)result;
      ++a2[2];
      ++v5;
      uint64_t v3 = v4[7];
    }
    while (v5 < *(int *)(v3 + 80));
  }
  return result;
}

void sub_1DD2741BC(_Unwind_Exception *a1)
{
  sub_1DD2770EC(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD2741D0@<X0>(void *result@<X0>, unsigned __int8 **a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = *((void *)result + 7);
  uint64_t v5 = *(unsigned int *)(v4 + 80);
  if ((int)v5 < 1)
  {
LABEL_20:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26E1F4(exception, "key not found");
    __cxa_throw(exception, (struct type_info *)off_1E6CBA918, MEMORY[0x1E4FBA1B8]);
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)(v4 + 88);
  char v8 = *((unsigned char *)a2 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    uint64_t v9 = a2[1];
  }
  if (v8 >= 0) {
    uint64_t v10 = (unsigned __int8 *)a2;
  }
  else {
    uint64_t v10 = *a2;
  }
  while (1)
  {
    uint64_t v11 = *(void *)(v7 + 8 * v6 + 8);
    uint64_t v12 = *(unsigned __int8 **)(v11 + 24);
    uint64_t v13 = v12[23];
    unsigned __int8 v14 = (v13 & 0x80u) == 0 ? (unsigned __int8 *)v12[23] : (unsigned __int8 *)*((void *)v12 + 1);
    if (v14 == v9)
    {
      if ((v13 & 0x80) == 0)
      {
        if (!v12[23]) {
          break;
        }
        uint64_t v15 = v10;
        while (*v12 == *v15)
        {
          ++v12;
          ++v15;
          if (!--v13) {
            goto LABEL_21;
          }
        }
        goto LABEL_19;
      }
      uint64_t result = (void *)memcmp(*(const void **)v12, v10, *((void *)v12 + 1));
      if (!result) {
        break;
      }
    }
LABEL_19:
    if (++v6 == v5) {
      goto LABEL_20;
    }
  }
LABEL_21:
  long long v17 = *(long long **)(v11 + 32);
  if (*((char *)v17 + 23) < 0)
  {
    uint64_t v19 = *(void **)v17;
    unint64_t v20 = *((void *)v17 + 1);
    return sub_1DD24F980((unsigned char *)a3, v19, v20);
  }
  else
  {
    long long v18 = *v17;
    *(void *)(a3 + 16) = *((void *)v17 + 2);
    *(_OWORD *)a3 = v18;
  }
  return result;
}

void sub_1DD274330(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD274344(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = *(unsigned int *)(a4 + 32);
  if ((int)v5 >= 1)
  {
    uint64_t v7 = result;
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)(a2 + 48);
    unint64_t v36 = *(void *)(a2 + 56) + v9;
    uint64_t v34 = *(unsigned int *)(a4 + 32);
    uint64_t v35 = a4;
    do
    {
      uint64_t v10 = *(void *)(*(void *)(a4 + 40) + 8 * v8 + 8);
      uint64_t v11 = *(void *)(v10 + 32);
      unint64_t v12 = v11 + v9;
      if (*(_DWORD *)(v10 + 24) == 6)
      {
        unint64_t v37 = v11 + v9;
        unint64_t v38 = *(void *)(v10 + 32);
        if (v12 > v36)
        {
          sub_1DD250F88((uint64_t)v41);
          sub_1DD239B24(&v42, (uint64_t)"Malformed RowIndex stream meta in stripe ", 41);
          int v28 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v28, (uint64_t)": streamOffset=", 15);
          uint64_t v29 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v29, (uint64_t)", streamLength=", 15);
          std::string v30 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v30, (uint64_t)", stripeOffset=", 15);
          uint64_t v31 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v31, (uint64_t)", stripeIndexLength=", 20);
          std::ostream::operator<<();
          exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          sub_1DD26D86C(exception, &v40);
          __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        uint64_t v13 = v7;
        uint64_t v14 = *(void *)(v7 + 8);
        uint64_t v15 = *(unsigned int *)(v14 + 40);
        uint64_t v16 = operator new(0x48uLL);
        sub_1DD23960C(v16, *(void *)v14, v9, v38, *(void *)(v14 + 48), 0);
        uint64_t v39 = v16;
        sub_1DD26C1EC(v15, (uint64_t *)&v39, *(void *)(*(void *)(v13 + 8) + 32), *(void *)(*(void *)(v13 + 8) + 48), (uint64_t *)&v40);
        uint64_t v7 = v13;
        uint64_t v17 = (uint64_t)v39;
        uint64_t v39 = 0;
        if (v17) {
          (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
        }
        sub_1DD241978((uint64_t)v41);
        if ((sub_1DD2F9DB8((uint64_t)v41, (uint64_t)v40.__r_.__value_.__l.__data_) & 1) == 0)
        {
          int v33 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          sub_1DD26D8A0(v33, "Failed to parse RowIndex from stripe footer");
          __cxa_throw(v33, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        if (v43 >= 1)
        {
          uint64_t v18 = 0;
          unsigned int v19 = *(_DWORD *)(v10 + 28);
          uint64_t v20 = 8 * v43;
          do
          {
            uint64_t v21 = *a5;
            if (*(void *)(*(void *)(v44 + v18 + 8) + 48)) {
              uint64_t v22 = *(void **)(*(void *)(v44 + v18 + 8) + 48);
            }
            else {
              uint64_t v22 = &unk_1EAB1F3D0;
            }
            uint64_t v23 = v21 + 24 * v19;
            unint64_t v25 = *(void *)(v23 + 8);
            unint64_t v24 = *(void *)(v23 + 16);
            uint64_t v26 = (uint64_t *)(v23 + 8);
            if (v25 >= v24)
            {
              uint64_t v27 = sub_1DD268360((uint64_t *)(v21 + 24 * v19), (uint64_t)v22);
            }
            else
            {
              sub_1DD23FC14(v25, (uint64_t)v22);
              uint64_t v27 = v25 + 120;
              *uint64_t v26 = v25 + 120;
            }
            *uint64_t v26 = v27;
            v18 += 8;
          }
          while (v20 != v18);
        }
        sub_1DD2419CC(v41);
        uint64_t result = v40.__r_.__value_.__r.__words[0];
        v40.__r_.__value_.__r.__words[0] = 0;
        if (result) {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
        }
        uint64_t v5 = v34;
        a4 = v35;
        unint64_t v12 = v37;
      }
      ++v8;
      uint64_t v9 = v12;
    }
    while (v8 != v5);
  }
  return result;
}

void sub_1DD274670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  if (a23 < 0)
  {
    operator delete(__p);
    if ((v25 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a24);
      _Unwind_Resume(a1);
    }
  }
  else if (!v25)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v24);
  goto LABEL_6;
}

BOOL sub_1DD27474C(uint64_t a1, unsigned __int8 **a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  unint64_t v3 = *(unsigned int *)(v2 + 80);
  if ((int)v3 < 1)
  {
    return 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(v2 + 88);
    char v6 = *((unsigned char *)a2 + 23);
    if (v6 >= 0) {
      uint64_t v7 = (unsigned __int8 *)*((unsigned __int8 *)a2 + 23);
    }
    else {
      uint64_t v7 = a2[1];
    }
    if (v6 >= 0) {
      uint64_t v8 = (unsigned __int8 *)a2;
    }
    else {
      uint64_t v8 = *a2;
    }
    BOOL v9 = 1;
    do
    {
      uint64_t v10 = *(unsigned __int8 **)(*(void *)(v5 + 8 * v4 + 8) + 24);
      uint64_t v11 = v10[23];
      if ((v11 & 0x80u) == 0) {
        unint64_t v12 = (unsigned __int8 *)v10[23];
      }
      else {
        unint64_t v12 = (unsigned __int8 *)*((void *)v10 + 1);
      }
      if (v12 == v7)
      {
        if ((v11 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v10, v8, *((void *)v10 + 1))) {
            return v9;
          }
        }
        else
        {
          if (!v10[23]) {
            return v9;
          }
          for (unint64_t i = v8; *v10 == *i; ++i)
          {
            ++v10;
            if (!--v11) {
              return v9;
            }
          }
        }
      }
      BOOL v9 = ++v4 < v3;
    }
    while (v4 != v3);
  }
  return v9;
}

uint64_t sub_1DD274830(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 24);
}

void sub_1DD27483C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (!*(unsigned char *)(a1 + 80)) {
    sub_1DD273B78((void *)a1);
  }
  uint64_t v6 = *(void *)(a1 + 72);
  if (!v6)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "No stripe statistics in file");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  sub_1DD279334(v17, *(int *)(*(void *)(*(void *)(v6 + 40) + 8 * (int)a2 + 8) + 32));
  sub_1DD246F14((uint64_t)v16, *(void *)(*(void *)(*(void *)(a1 + 56) + 40) + 8 * (int)a2 + 8));
  sub_1DD273418(v16, *(void *)(a1 + 8), (uint64_t)v13);
  sub_1DD274344(a1, (uint64_t)v16, a2, (uint64_t)v13, v17);
  if (v14) {
    uint64_t v7 = sub_1DD287D10(v15);
  }
  else {
    uint64_t v7 = sub_1DD287CA0();
  }
  uint64_t v8 = v7;
  v11[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 192))(a1);
  uint64_t v12 = v8;
  BOOL v9 = operator new(0x28uLL);
  sub_1DD27E384(v9, *(void *)(*(void *)(*(void *)(a1 + 72) + 40) + 8 * (int)a2 + 8), v17, v11);
  *a3 = v9;
  sub_1DD24498C(v13);
  sub_1DD246F68(v16);
  v13[0] = (void **)v17;
  sub_1DD27942C(v13);
}

void sub_1DD2749C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  __cxa_free_exception(v24);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD274A28@<X0>(void *a1@<X0>, void *a2@<X8>)
{
  v6[0] = (*(uint64_t (**)(void *))(*a1 + 192))(a1);
  uint64_t v7 = 0;
  uint64_t v4 = operator new(0x20uLL);
  uint64_t result = sub_1DD27DE70(v4, a1[7], v6);
  *a2 = v4;
  return result;
}

void sub_1DD274AA4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD274AB8@<X0>(void *a1@<X0>, unsigned int a2@<W1>, void **a3@<X8>)
{
  uint64_t v4 = a1[7];
  if (a2 >= (unint64_t)*(int *)(v4 + 104))
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "column index out of range");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  sub_1DD23FC14((uint64_t)v10, *(void *)(*(void *)(v4 + 112) + 8 * (int)a2 + 8));
  v8[0] = (*(uint64_t (**)(void *))(*a1 + 192))(a1);
  uint64_t v9 = 0;
  *a3 = sub_1DD27D9C8((uint64_t)v10, v8);
  return sub_1DD23FE3C(v10);
}

void sub_1DD274B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
  __cxa_free_exception(v12);
  _Unwind_Resume(a1);
}

BOOL sub_1DD274BB0(uint64_t a1)
{
  return dword_1EAB1F868 <= (*(int (**)(uint64_t))(*(void *)a1 + 88))(a1);
}

void sub_1DD274C0C(uint64_t a1)
{
  sub_1DD2715B8(&v2);
  (*(void (**)(uint64_t, void **))(*(void *)a1 + 224))(a1, &v2);
  uint64_t v2 = &unk_1F3879D40;
  sub_1DD27163C(&v3, 0);
}

void sub_1DD274CA4(_Unwind_Exception *a1)
{
  sub_1DD27163C((void **)(v1 + 8), 0);
  _Unwind_Resume(a1);
}

void sub_1DD274CD8(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x1A8uLL);
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a1 + 8);
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 16);
  v10[0] = v8;
  v10[1] = (uint64_t)v9;
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_1DD2726F0((uint64_t)v6, v10, a2);
  *a3 = v7;
  if (v9)
  {
    sub_1DD25B904(v9);
  }
}

void sub_1DD274D74(_Unwind_Exception *a1)
{
  if (v2) {
    sub_1DD25B904(v2);
  }
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD274D94(uint64_t a1)
{
  uint64_t v1 = *(int *)(a1 + 96);
  if (v1 > 0x11) {
    return 0;
  }
  else {
    return qword_1DD3204A0[v1];
  }
}

unint64_t sub_1DD274DB8(uint64_t a1, int a2)
{
  memset(__p, 0, sizeof(__p));
  unint64_t v4 = *(int *)(*(void *)(*(void *)(a1 + 8) + 16) + 56);
  char v7 = 1;
  sub_1DD272130((uint64_t)__p, v4, &v7);
  unint64_t v5 = sub_1DD274E4C(a1, a2, (uint64_t *)__p);
  if (__p[0]) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_1DD274E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DD274E4C(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v4 = *(void *)(a1 + 56);
  uint64_t v5 = *(unsigned int *)(v4 + 32);
  if (a2 < 0 || (int)v5 <= a2)
  {
    if ((int)v5 < 1)
    {
      unint64_t v6 = 0;
    }
    else
    {
      unint64_t v6 = 0;
      char v7 = (uint64_t *)(*(void *)(v4 + 40) + 8);
      do
      {
        uint64_t v8 = *v7++;
        unint64_t v9 = *(void *)(v8 + 64);
        if (v6 <= v9) {
          unint64_t v6 = v9;
        }
        --v5;
      }
      while (v5);
    }
  }
  else
  {
    unint64_t v6 = *(void *)(*(void *)(*(void *)(v4 + 40) + 8 * a2 + 8) + 64);
  }
  int v10 = *(_DWORD *)(v4 + 56);
  uint64_t v11 = 0;
  if (v10 >= 1)
  {
    unint64_t v12 = 0;
    uint64_t v13 = *a3;
    uint64_t v14 = v10 & ~(v10 >> 31);
    do
    {
      if ((*(void *)(v13 + ((v12 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v12))
      {
        uint64_t v15 = *(void *)(*(void *)(v4 + 64) + 8 * v12 + 8);
        uint64_t v16 = sub_1DD274D94(v15);
        unsigned int v17 = *(_DWORD *)(v15 + 96);
        BOOL v18 = v17 > 0x11;
        int v19 = (1 << v17) & 0x30180;
        if (!v18 && v19 != 0)
        {
          unint64_t v22 = 2 * v6;
          goto LABEL_25;
        }
        v11 += v16;
      }
      ++v12;
    }
    while (v14 != v12);
  }
  uint64_t v21 = (*(uint64_t (**)(void))(***(void ***)(a1 + 8) + 24))(**(void **)(a1 + 8));
  if (v21 * v11 >= v6) {
    unint64_t v22 = v6;
  }
  else {
    unint64_t v22 = v21 * v11;
  }
  uint64_t v4 = *(void *)(a1 + 56);
LABEL_25:
  uint64_t v23 = *(void *)(a1 + 8);
  uint64_t v24 = *(void *)(v23 + 8);
  uint64_t v25 = *(void *)(v24 + 56);
  unint64_t v26 = *(void *)(v24 + 80);
  uint64_t v27 = *(int *)(v4 + 32);
  int v28 = *(_DWORD *)(v23 + 40);
  if (v28)
  {
    uint64_t v29 = *(unsigned int *)(v4 + 56);
    uint64_t v36 = *(int *)(v4 + 32);
    if ((int)v29 < 1)
    {
      uint64_t v31 = 0;
    }
    else
    {
      unint64_t v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = *a3;
      do
      {
        if ((*(void *)(v32 + ((v30 >> 3) & 0x1FFFFFFFFFFFFFF8)) >> v30)) {
          v31 += *(void *)(v23 + 32) * sub_1DD274D94(*(void *)(*(void *)(v4 + 64) + 8 * v30 + 8));
        }
        ++v30;
      }
      while (v29 != v30);
    }
    uint64_t v33 = v31 << (v28 == 2);
    uint64_t v27 = v36;
  }
  else
  {
    uint64_t v33 = 0;
  }
  unint64_t v34 = v25 + 0x4000;
  if (v22 > v25 + 0x4000) {
    unint64_t v34 = v22;
  }
  if (v34 <= v26) {
    unint64_t v34 = v26;
  }
  return v34 + 8 * v27 + v33;
}

unint64_t sub_1DD275060(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  unint64_t v6 = *(int *)(*(void *)(*(void *)(a1 + 8) + 16) + 56);
  LOBYTE(v12[0]) = 0;
  sub_1DD272130((uint64_t)&v15, v6, v12);
  sub_1DD272650(v12, *(void *)(a1 + 8));
  int v7 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 24) + 32))(*(void *)(*(void *)(a1 + 8) + 24));
  uint64_t v8 = *(void *)(a2 + 8);
  if (v7 != 12 || v8 == a2)
  {
    if (v16)
    {
      BOOL v18 = v15;
      int v19 = 0;
      sub_1DD27832C(&v18, v16);
    }
  }
  else
  {
    do
    {
      sub_1DD272244((uint64_t)v12, &v15, *(void *)(v8 + 16));
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != a2);
  }
  sub_1DD271B0C((uint64_t)v12, (uint64_t *)&v15, *(void *)(*(void *)(a1 + 8) + 24));
  *uint64_t v15 = (void *)((unint64_t)*v15 | 1);
  unint64_t v10 = sub_1DD274E4C(a1, a3, (uint64_t *)&v15);
  BOOL v18 = (void **)&v14;
  sub_1DD278584(&v18);
  sub_1DD268698((uint64_t)v13, v13[1]);
  sub_1DD278520((uint64_t)v12, (char *)v12[1]);
  if (v15) {
    operator delete(v15);
  }
  return v10;
}

void sub_1DD2751B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  unint64_t v12 = *(void **)(v10 - 72);
  if (v12) {
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DD2751E4(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  unint64_t v6 = *(int *)(*(void *)(*(void *)(a1 + 8) + 16) + 56);
  LOBYTE(v12[0]) = 0;
  sub_1DD272130((uint64_t)&v15, v6, v12);
  sub_1DD272650(v12, *(void *)(a1 + 8));
  int v7 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 24) + 32))(*(void *)(*(void *)(a1 + 8) + 24));
  uint64_t v8 = *(void *)(a2 + 8);
  if (v7 != 12 || v8 == a2)
  {
    if (v16)
    {
      BOOL v18 = v15;
      int v19 = 0;
      sub_1DD27832C(&v18, v16);
    }
  }
  else
  {
    do
    {
      sub_1DD272408((uint64_t)v12, &v15, (const void **)(v8 + 16));
      uint64_t v8 = *(void *)(v8 + 8);
    }
    while (v8 != a2);
  }
  sub_1DD271B0C((uint64_t)v12, (uint64_t *)&v15, *(void *)(*(void *)(a1 + 8) + 24));
  *uint64_t v15 = (void *)((unint64_t)*v15 | 1);
  unint64_t v10 = sub_1DD274E4C(a1, a3, (uint64_t *)&v15);
  BOOL v18 = (void **)&v14;
  sub_1DD278584(&v18);
  sub_1DD268698((uint64_t)v13, v13[1]);
  sub_1DD278520((uint64_t)v12, (char *)v12[1]);
  if (v15) {
    operator delete(v15);
  }
  return v10;
}

void sub_1DD275338(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  unint64_t v12 = *(void **)(v10 - 72);
  if (v12) {
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

unint64_t sub_1DD275368(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  unint64_t v6 = *(int *)(*(void *)(*(void *)(a1 + 8) + 16) + 56);
  LOBYTE(v10[0]) = 0;
  sub_1DD272130((uint64_t)&v13, v6, v10);
  sub_1DD272650(v10, *(void *)(a1 + 8));
  uint64_t v7 = *(void *)(a2 + 8);
  if (v7 == a2)
  {
    if (v14)
    {
      unint64_t v16 = v13;
      int v17 = 0;
      sub_1DD27832C(&v16, v14);
    }
  }
  else
  {
    do
    {
      sub_1DD272500((uint64_t)v10, &v13, *(void *)(v7 + 16));
      uint64_t v7 = *(void *)(v7 + 8);
    }
    while (v7 != a2);
  }
  sub_1DD271B0C((uint64_t)v10, (uint64_t *)&v13, *(void *)(*(void *)(a1 + 8) + 24));
  *uint64_t v13 = (void *)((unint64_t)*v13 | 1);
  unint64_t v8 = sub_1DD274E4C(a1, a3, (uint64_t *)&v13);
  unint64_t v16 = (void **)&v12;
  sub_1DD278584(&v16);
  sub_1DD268698((uint64_t)v11, v11[1]);
  sub_1DD278520((uint64_t)v10, (char *)v10[1]);
  if (v13) {
    operator delete(v13);
  }
  return v8;
}

void sub_1DD27548C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v12 = *(void **)(v10 - 72);
  if (v12) {
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_1DD2754BC(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(a1 + 144);
  if (*(void *)(a1 + 136) >= v4)
  {
    *(void *)(a2 + 16) = 0;
    BOOL result = 0;
    if (v4) {
      *(void *)(a1 + 120) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 40)
    }
                                                    + ((uint64_t)((v4 << 32) - 0x100000000) >> 29)
                                                    + 8)
                                        + 80)
                            + *(void *)(*(void *)(a1 + 88) + 8 * v4 - 8);
    else {
      *(void *)(a1 + 120) = 0;
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 152);
    if (!v5)
    {
      sub_1DD272C8C(a1);
      uint64_t v5 = *(void *)(a1 + 152);
    }
    unint64_t v6 = *(void *)(a1 + 160) - v5;
    if (v6 >= *(void *)(a2 + 8)) {
      unint64_t v7 = *(void *)(a2 + 8);
    }
    else {
      unint64_t v7 = v6;
    }
    *(void *)(a2 + 16) = v7;
    uint64_t v8 = **(void **)(a1 + 368);
    if (*(unsigned char *)(a1 + 376)) {
      (*(void (**)(void))(v8 + 32))();
    }
    else {
      (*(void (**)(void))(v8 + 24))();
    }
    uint64_t v10 = *(void *)(a1 + 136);
    uint64_t v11 = *(void *)(a1 + 152);
    unint64_t v12 = *(void *)(a1 + 160);
    *(void *)(a1 + 120) = v11 + *(void *)(*(void *)(a1 + 88) + 8 * v10);
    *(void *)(a1 + 152) = v11 + v7;
    if (v11 + v7 >= v12)
    {
      *(void *)(a1 + 136) = v10 + 1;
      *(void *)(a1 + 152) = 0;
    }
    return v7 != 0;
  }
  return result;
}

uint64_t sub_1DD275614(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) + 96);
  return v1();
}

void sub_1DD2756AC(uint64_t a1, uint64_t a2, unint64_t a3)
{
  sub_1DD314888(&__s2, "ORC");
  unsigned __int8 v6 = v20;
  if ((char)v20 < 0)
  {
    size_t v7 = v19;
    size_t v12 = *(void *)(a2 + 24);
    if (v19 > a3 || v12 < v19)
    {
LABEL_23:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Invalid ORC postscript length");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v10 = (const void *)(~v19 + *(void *)(a2 + 16) + v12);
    p_s2 = __s2;
  }
  else
  {
    size_t v7 = v20;
    unint64_t v8 = *(void *)(a2 + 24);
    if (v20 > a3 || v8 < v20) {
      goto LABEL_23;
    }
    uint64_t v10 = (const void *)(~(unint64_t)v20 + *(void *)(a2 + 16) + v8);
    p_s2 = &__s2;
  }
  if (memcmp(v10, p_s2, v7))
  {
    unint64_t v14 = operator new[](v7);
    (*(void (**)(uint64_t, void *, size_t, void))(*(void *)a1 + 32))(a1, v14, v7, 0);
    if ((v20 & 0x80u) == 0) {
      uint64_t v15 = &__s2;
    }
    else {
      uint64_t v15 = __s2;
    }
    if (memcmp(v14, v15, v7))
    {
      int v17 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(v17, "Not an ORC file");
      __cxa_throw(v17, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    operator delete[](v14);
    unsigned __int8 v6 = v20;
  }
  if ((v6 & 0x80) != 0) {
    operator delete(__s2);
  }
}

void sub_1DD275858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  operator delete[](v15);
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1DD2758AC@<W0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v7 = *(void *)(a2 + 16);
  unint64_t v8 = *(void *)(a2 + 24);
  sub_1DD2756AC(a1, a2, a3);
  unint64_t v9 = operator new(0x60uLL);
  sub_1DD24CC50((uint64_t)v9);
  if (v8 < a3 + 1)
  {
    sub_1DD250F88((uint64_t)&v15);
    sub_1DD239B24(&v15.__r_.__value_.__r.__words[2], (uint64_t)"Invalid ORC postscript length: ", 31);
    uint64_t v11 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v11, (uint64_t)", file length = ", 16);
    (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
    std::ostream::operator<<();
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    sub_1DD26D86C(exception, &v14);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  BOOL result = sub_1DD2FA004((uint64_t)v9, ~a3 + v7 + v8, a3);
  if (!result)
  {
    uint64_t v13 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    std::operator+<char>();
    sub_1DD26D86C(v13, &v15);
    __cxa_throw(v13, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  *a4 = v9;
  return result;
}

void sub_1DD275A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v22 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a15);
      (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
      _Unwind_Resume(a1);
    }
  }
  else if (!v22)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v21);
  goto LABEL_6;
}

uint64_t sub_1DD275B3C(uint64_t a1)
{
  sub_1DD250F88((uint64_t)v24);
  uint64_t v2 = *(unsigned int *)(a1 + 56);
  if ((int)v2 < 1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Footer is corrupt: no types found");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)(a1 + 64);
  do
  {
    uint64_t v5 = *(void *)(v4 + 8 * v3 + 8);
    uint64_t v6 = *(unsigned int *)(v5 + 24);
    if ((int)v6 >= 1)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(v5 + 32);
      do
      {
        uint64_t v9 = *(int *)(v8 + 4 * v7 + 8);
        if (v3 >= v9)
        {
          sub_1DD239B24(v25, (uint64_t)"Footer is corrupt: malformed link from type ", 44);
          std::string v14 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v14, (uint64_t)" to ", 4);
          std::ostream::operator<<();
          std::string v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          sub_1DD26D86C(v15, &v23);
          __cxa_throw(v15, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        if ((int)v9 >= (int)v2)
        {
          sub_1DD239B24(v25, (uint64_t)"Footer is corrupt: types(", 25);
          size_t v12 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v12, (uint64_t)") not exists", 12);
          uint64_t v13 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          sub_1DD26D86C(v13, &v23);
          __cxa_throw(v13, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        if (v7 && *(_DWORD *)(v8 + 4 * v7 + 4) >= (int)v9)
        {
          sub_1DD239B24(v25, (uint64_t)"Footer is corrupt: subType(", 27);
          unint64_t v16 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v16, (uint64_t)") >= subType(", 13);
          int v17 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v17, (uint64_t)") in types(", 11);
          BOOL v18 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v18, (uint64_t)"). (", 4);
          size_t v19 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v19, (uint64_t)" >= ", 4);
          uint64_t v20 = (void *)std::ostream::operator<<();
          sub_1DD239B24(v20, (uint64_t)")", 1);
          uint64_t v21 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          sub_1DD26D86C(v21, &v23);
          __cxa_throw(v21, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
        }
        ++v7;
      }
      while (v6 != v7);
    }
    ++v3;
  }
  while (v3 != v2);
  v24[0] = *MEMORY[0x1E4FBA408];
  uint64_t v10 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v24 + *(void *)(v24[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v25[0] = v10;
  v25[1] = MEMORY[0x1E4FBA470] + 16;
  if (v26 < 0) {
    operator delete((void *)v25[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E01B1EC0](&v27);
}

void sub_1DD275F38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

uint64_t sub_1DD275F98@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, void *a6@<X8>)
{
  uint64_t v10 = *(void *)(a2 + 16) + a3;
  uint64_t v11 = sub_1DD2717D4(a4);
  size_t v12 = operator new(0x28uLL);
  sub_1DD238FC4(v12, v10, *(void *)(a4 + 56), 0);
  size_t v19 = v12;
  if ((*(_DWORD *)(a4 + 16) & 4) != 0) {
    uint64_t v13 = *(void *)(a4 + 64);
  }
  else {
    uint64_t v13 = 0x40000;
  }
  sub_1DD26C1EC(v11, (uint64_t *)&v19, v13, a5, &v20);
  uint64_t v14 = (uint64_t)v19;
  size_t v19 = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  std::string v15 = operator new(0xA8uLL);
  sub_1DD24B648((uint64_t)v15);
  if ((sub_1DD2F9DB8((uint64_t)v15, v20) & 1) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    std::operator+<char>();
    sub_1DD26D86C(exception, &v18);
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  sub_1DD275B3C((uint64_t)v15);
  *a6 = v15;
  uint64_t result = v20;
  uint64_t v20 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1DD27614C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v19 & 1) == 0)
    {
LABEL_6:
      (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
      if (a17) {
        (*(void (**)(uint64_t))(*(void *)a17 + 8))(a17);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v19)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v18);
  goto LABEL_6;
}

void sub_1DD276224(uint64_t *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x40uLL);
  _OWORD *v6 = 0u;
  v6[1] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  sub_1DD279560(&v51, (uint64_t)v6);
  uint64_t v7 = v51;
  *(void *)(v51 + 48) = *(void *)(*(void *)(a2 + 8) + 16);
  *(void *)(v7 + 56) = *(void *)(*(void *)(a2 + 8) + 8);
  uint64_t v8 = *(void *)(a2 + 8);
  if (*(char *)(v8 + 47) < 0)
  {
    sub_1DD24F980(&__dst, *(void **)(v8 + 24), *(void *)(v8 + 32));
  }
  else
  {
    long long __dst = *(_OWORD *)(v8 + 24);
    uint64_t v50 = *(void *)(v8 + 40);
  }
  uint64_t v9 = HIBYTE(v50);
  if (v50 < 0) {
    uint64_t v9 = *((void *)&__dst + 1);
  }
  if (v9)
  {
    sub_1DD24DB58((uint64_t)v43);
    if (!sub_1DD2F9E54((uint64_t)v43, (uint64_t *)&__dst))
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Failed to parse the file tail from string");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v10 = v51;
    uint64_t v11 = operator new(0x60uLL);
    size_t v12 = v11;
    if (v45) {
      uint64_t v13 = v45;
    }
    else {
      uint64_t v13 = &unk_1EAB1F220;
    }
    sub_1DD24CD74((uint64_t)v11, (uint64_t)v13);
    uint64_t v14 = *(void *)(v10 + 8);
    *(void *)(v10 + 8) = v12;
    if (v14) {
      (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
    }
    uint64_t v15 = v51;
    int v16 = operator new(0xA8uLL);
    uint64_t v17 = v16;
    if (v46) {
      std::string v18 = v46;
    }
    else {
      std::string v18 = &unk_1EAB1F068;
    }
    sub_1DD24B928((uint64_t)v16, (uint64_t)v18);
    uint64_t v19 = *(void *)(v15 + 16);
    *(void *)(v15 + 16) = v17;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    unint64_t v20 = v47;
    unint64_t v21 = v48;
    sub_1DD24DC4C(v43);
  }
  else
  {
    unint64_t v22 = **(void **)(a2 + 8);
    unint64_t v23 = (*(uint64_t (**)(void))(*(void *)*a1 + 16))();
    if (v23 >= v22) {
      unint64_t v20 = v22;
    }
    else {
      unint64_t v20 = v23;
    }
    if (v20 >= 0x4000) {
      unint64_t v24 = 0x4000;
    }
    else {
      unint64_t v24 = v20;
    }
    if (v24 <= 3)
    {
      unint64_t v38 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(v38, "File size too small");
      __cxa_throw(v38, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v25 = operator new(0x28uLL);
    sub_1DD26FA14(v25, *(void *)(v51 + 48));
    (*(void (**)(uint64_t, void, unint64_t, unint64_t))(*(void *)*a1 + 32))(*a1, v25[2], v24, v20 - v24);
    unint64_t v21 = *(unsigned __int8 *)(v24 + v25[2] - 1);
    sub_1DD2758AC(*a1, (uint64_t)v25, v21, v43);
    uint64_t v26 = v51;
    uint64_t v27 = v43[0];
    uint64_t v28 = *(void *)(v51 + 8);
    *(void *)(v51 + 8) = v43[0];
    if (v28)
    {
      (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
      uint64_t v26 = v51;
      uint64_t v27 = *(void *)(v51 + 8);
    }
    uint64_t v29 = *(void *)(v27 + 56);
    unint64_t v30 = v21 + v29 + 1;
    if (v20 <= v30)
    {
      sub_1DD250F88((uint64_t)v43);
      sub_1DD239B24(&v44, (uint64_t)"Invalid ORC tailSize=", 21);
      uint64_t v39 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v39, (uint64_t)", fileLength=", 13);
      std::ostream::operator<<();
      std::string v40 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      sub_1DD26D86C(v40, &v42);
      __cxa_throw(v40, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v31 = v24 - v30;
    if (v24 < v30)
    {
      sub_1DD26F9D0((uint64_t)v25, *(void *)(v27 + 56));
      (*(void (**)(uint64_t, void, uint64_t, unint64_t))(*(void *)*a1 + 32))(*a1, v25[2], v29, v20 - v30);
      uint64_t v31 = 0;
      uint64_t v26 = v51;
      uint64_t v27 = *(void *)(v51 + 8);
    }
    sub_1DD275F98(*a1, (uint64_t)v25, v31, v27, *(void *)(v26 + 48), v43);
    uint64_t v32 = *(void *)(v51 + 16);
    *(void *)(v51 + 16) = v43[0];
    if (v32) {
      (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
    }
    (*(void (**)(void *))(*v25 + 8))(v25);
  }
  uint64_t v33 = (uint64_t *)v51;
  uint64_t v34 = *a1;
  *a1 = 0;
  uint64_t v35 = *v33;
  uint64_t *v33 = v34;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  uint64_t v36 = operator new(0x58uLL);
  long long v41 = v51;
  long long v51 = 0uLL;
  sub_1DD2736C8((uint64_t)v36, (uint64_t)&v41, a2, v20, v21);
  *a3 = v36;
  if (*((void *)&v41 + 1)) {
    sub_1DD25B904(*((std::__shared_weak_count **)&v41 + 1));
  }
  if (SHIBYTE(v50) < 0) {
    operator delete((void *)__dst);
  }
  if (*((void *)&v51 + 1)) {
    sub_1DD25B904(*((std::__shared_weak_count **)&v51 + 1));
  }
}

void sub_1DD276744(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, char a17)
{
  if (a16 < 0)
  {
    operator delete(__p);
    if ((v18 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a17);
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
      if (*(char *)(v20 - 121) < 0) {
        operator delete(*(void **)(v20 - 144));
      }
      unint64_t v22 = *(std::__shared_weak_count **)(v20 - 104);
      if (v22) {
        sub_1DD25B904(v22);
      }
      _Unwind_Resume(a1);
    }
  }
  else if (!v18)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v17);
  goto LABEL_6;
}

void *sub_1DD276874@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  *(void *)(a4 + 16) = 0;
  *(void *)(a4 + 8) = 0;
  *(void *)a4 = a4 + 8;
  uint64_t v5 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v5 + 32) <= a2)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::to_string(&v64, a2);
    uint64_t v46 = std::string::insert(&v64, 0, "Illegal stripe index: ");
    long long v47 = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v60.__r_.__value_.__r.__words[2] = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v60.__r_.__value_.__l.__data_ = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    std::logic_error::logic_error(exception, &v60);
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t v7 = a1;
  sub_1DD246F14((uint64_t)&v64, *(void *)(*(void *)(v5 + 40) + 8 * (int)a2 + 8));
  sub_1DD273418(&v64, *(void *)(v7 + 8), (uint64_t)&v60);
  int v8 = v61;
  if (v61 >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v65;
    uint64_t v11 = (void *)(a3 + 8);
    unint64_t v48 = (void *)(a3 + 8);
    uint64_t v49 = v7;
    do
    {
      uint64_t v12 = *(void *)(v62 + 8 * v9 + 8);
      int v14 = *(_DWORD *)(v12 + 24);
      unsigned int v13 = *(_DWORD *)(v12 + 28);
      unsigned int v59 = v13;
      unint64_t v15 = *(void *)(v12 + 32);
      if (v14 == 8)
      {
        if (!*(void *)(a3 + 16)) {
          goto LABEL_17;
        }
        uint64_t v16 = *v11;
        if (*v11)
        {
          uint64_t v17 = v11;
          do
          {
            unsigned int v18 = *(_DWORD *)(v16 + 28);
            BOOL v19 = v18 >= v13;
            if (v18 >= v13) {
              uint64_t v20 = (uint64_t *)v16;
            }
            else {
              uint64_t v20 = (uint64_t *)(v16 + 8);
            }
            if (v19) {
              uint64_t v17 = (void *)v16;
            }
            uint64_t v16 = *v20;
          }
          while (*v20);
          if (v17 != v11 && v13 >= *((_DWORD *)v17 + 7))
          {
LABEL_17:
            uint64_t v21 = *(void *)(v7 + 8);
            uint64_t v22 = *(unsigned int *)(v21 + 40);
            unint64_t v23 = operator new(0x48uLL);
            sub_1DD23960C(v23, *(void *)v21, v10, v15, *(void *)(v21 + 48), 0);
            uint64_t v57 = v23;
            sub_1DD26C1EC(v22, (uint64_t *)&v57, *(void *)(*(void *)(v7 + 8) + 32), *(void *)(*(void *)(v7 + 8) + 48), &v58);
            uint64_t v24 = (uint64_t)v57;
            uint64_t v57 = 0;
            if (v24) {
              (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
            }
            sub_1DD2429C0((uint64_t)v54);
            uint64_t v25 = a3;
            if ((sub_1DD2F9DB8((uint64_t)v54, v58) & 1) == 0)
            {
              uint64_t v44 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              sub_1DD26D8A0(v44, "Failed to parse BloomFilterIndex");
              __cxa_throw(v44, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
            }
            long long v51 = 0;
            uint64_t v52 = 0;
            unint64_t v53 = 0;
            if (v55 >= 1)
            {
              for (uint64_t i = 0; i < v55; ++i)
              {
                uint64_t v27 = *(int *)(v12 + 28);
                LODWORD(v66[0]) = *(_DWORD *)(v12 + 24);
                sub_1DD2519D8(v66, *(void *)(v63 + 8 * v27 + 8), *(void *)(v56 + 8 * i + 8), &v67);
                uint64_t v28 = v67;
                uint64_t v29 = operator new(0x20uLL);
                unint64_t v30 = v29;
                *uint64_t v29 = &unk_1F387CDA0;
                v29[1] = 0;
                void v29[2] = 0;
                v29[3] = v28;
                uint64_t v67 = 0;
                uint64_t v31 = v52;
                if ((unint64_t)v52 >= v53)
                {
                  int64_t v33 = (v52 - v51) >> 4;
                  unint64_t v34 = v33 + 1;
                  if ((unint64_t)(v33 + 1) >> 60) {
                    sub_1DD251DAC();
                  }
                  uint64_t v35 = v53 - (void)v51;
                  if ((uint64_t)(v53 - (void)v51) >> 3 > v34) {
                    unint64_t v34 = v35 >> 3;
                  }
                  if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
                    unint64_t v36 = 0xFFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v36 = v34;
                  }
                  v66[4] = &v53;
                  unint64_t v37 = (char *)sub_1DD27753C((uint64_t)&v53, v36);
                  unint64_t v38 = (uint64_t *)&v37[16 * v33];
                  v66[0] = v37;
                  v66[1] = v38;
                  v66[3] = &v37[16 * v39];
                  *unint64_t v38 = v28;
                  v38[1] = (uint64_t)v30;
                  v66[2] = v38 + 2;
                  sub_1DD2797FC((uint64_t *)&v51, v66);
                  uint64_t v32 = (uint64_t *)v52;
                  sub_1DD279984(v66);
                }
                else
                {
                  *(void *)uint64_t v52 = v28;
                  *((void *)v31 + 1) = v29;
                  uint64_t v32 = (uint64_t *)(v31 + 16);
                }
                uint64_t v52 = (char *)v32;
                uint64_t v40 = v67;
                uint64_t v67 = 0;
                if (v40) {
                  (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
                }
              }
            }
            v66[0] = &v59;
            long long v41 = sub_1DD279A0C((uint64_t **)a4, &v59, (uint64_t)&unk_1DD32030B, (_DWORD **)v66) + 5;
            if (v41 != (uint64_t **)&v51) {
              sub_1DD277194((uint64_t)v41, (uint64_t *)v51, (uint64_t *)v52, (v52 - v51) >> 4);
            }
            v66[0] = &v51;
            sub_1DD277574((void ***)v66);
            sub_1DD242A14(v54);
            uint64_t v42 = v58;
            uint64_t v58 = 0;
            a3 = v25;
            if (v42) {
              (*(void (**)(uint64_t))(*(void *)v42 + 8))(v42);
            }
            int v8 = v61;
            uint64_t v11 = v48;
            uint64_t v7 = v49;
          }
        }
      }
      v10 += v15;
      ++v9;
    }
    while (v9 < v8);
  }
  sub_1DD24498C(&v60);
  return sub_1DD246F68(&v64);
}

void sub_1DD276CF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,void *a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  if (a47 < 0)
  {
    operator delete(a42);
    if ((v47 & 1) == 0)
    {
LABEL_8:
      sub_1DD279728(a12, *(char **)(a12 + 8));
      _Unwind_Resume(a1);
    }
  }
  else if (!v47)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v48);
  goto LABEL_8;
}

void sub_1DD276E8C(void *a1)
{
  uint64_t v1 = sub_1DD2775C8(a1);
  operator delete(v1);
}

void *sub_1DD276EB4(void *a1)
{
  *a1 = &unk_1F3879228;
  uint64_t v2 = a1[9];
  a1[9] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void **)a1[4];
  a1[3] = &unk_1F3879620;
  a1[4] = 0;
  if (v3) {
    sub_1DD2776A0(a1 + 32, v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4) {
    sub_1DD25B904(v4);
  }
  return a1;
}

void sub_1DD276F60(void *__p)
{
  *std::string __p = &unk_1F3879228;
  uint64_t v2 = __p[9];
  __p[9] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (void **)__p[4];
  __p[3] = &unk_1F3879620;
  __p[4] = 0;
  if (v3) {
    sub_1DD2776A0(__p + 32, v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)__p[2];
  if (v4) {
    sub_1DD25B904(v4);
  }
  operator delete(__p);
}

void *sub_1DD27701C(void *a1)
{
  a1[3] = 0;
  a1[4] = 0;
  a1[5] = 0;
  uint64_t v2 = MEMORY[0x1E4FBA240];
  *a1 = -1;
  a1[1] = v2;
  a1[2] = sub_1DD270500();
  return a1;
}

void sub_1DD27706C(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 47) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD277088(void *result)
{
  if (result[2])
  {
    uint64_t v1 = result;
    uint64_t result = (void *)result[1];
    uint64_t v2 = *v1;
    uint64_t v3 = *result;
    *(void *)(v3 + 8) = *(void *)(*v1 + 8);
    **(void **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        uint64_t v4 = (void *)result[1];
        operator delete(result);
        uint64_t result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

void sub_1DD2770EC(void *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = a1[1];
    uint64_t v4 = *(void **)v2;
    v4[1] = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    while ((void *)v2 != a1)
    {
      uint64_t v5 = *(void *)(v2 + 8);
      sub_1DD277150((int)a1, (void **)v2);
      uint64_t v2 = v5;
    }
  }
}

void sub_1DD277150(int a1, void **__p)
{
  if (*((char *)__p + 39) < 0) {
    operator delete(__p[2]);
  }
  operator delete(__p);
}

void sub_1DD277194(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(void **)a1;
  if (a4 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4)
  {
    sub_1DD2772E8((uint64_t *)a1);
    if (a4 >> 60) {
      sub_1DD251DAC();
    }
    uint64_t v10 = *(void *)(a1 + 16) - *(void *)a1;
    uint64_t v11 = v10 >> 3;
    if (v10 >> 3 <= a4) {
      uint64_t v11 = a4;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    sub_1DD277324((void *)a1, v12);
    unsigned int v13 = sub_1DD277368(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  unint64_t v14 = (uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 4;
  if (v14 < a4)
  {
    unint64_t v15 = &a2[2 * v14];
    sub_1DD277474((uint64_t)&v20, a2, v15, v9);
    unsigned int v13 = sub_1DD277368(v8, v15, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v13;
    return;
  }
  sub_1DD277474((uint64_t)&v21, a2, a3, v9);
  uint64_t v17 = v16;
  uint64_t v18 = *(void *)(a1 + 8);
  if (v18 != v16)
  {
    do
    {
      BOOL v19 = *(std::__shared_weak_count **)(v18 - 8);
      if (v19) {
        sub_1DD25B904(v19);
      }
      v18 -= 16;
    }
    while (v18 != v17);
  }
  *(void *)(a1 + 8) = v17;
}

void sub_1DD2772D8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1DD2772E0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1DD2772E8(uint64_t *a1)
{
  if (*a1)
  {
    sub_1DD2774F0(a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *sub_1DD277324(void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1DD251DAC();
  }
  uint64_t result = (char *)sub_1DD27753C((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *sub_1DD277368(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v9;
  v7[2] = &v10;
  if (a2 != a3)
  {
    do
    {
      *uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v10 = v4;
  }
  char v8 = 1;
  sub_1DD2773F8((uint64_t)v7);
  return v4;
}

uint64_t sub_1DD2773F8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD277430(a1);
  }
  return a1;
}

void sub_1DD277430(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 - 8);
    if (v3) {
      sub_1DD25B904(v3);
    }
    v1 -= 16;
  }
}

uint64_t *sub_1DD277474(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4)
{
  uint64_t v5 = a2;
  if (a2 == a3) {
    return a2;
  }
  uint64_t v6 = a3;
  do
  {
    uint64_t v8 = *v5;
    uint64_t v7 = v5[1];
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v9 = (std::__shared_weak_count *)a4[1];
    *a4 = v8;
    a4[1] = v7;
    if (v9) {
      sub_1DD25B904(v9);
    }
    a4 += 2;
    v5 += 2;
  }
  while (v5 != v6);
  return v6;
}

void sub_1DD2774F0(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      sub_1DD25B904(v4);
    }
  }
  a1[1] = v2;
}

void *sub_1DD27753C(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    sub_1DD251C54();
  }
  return operator new(16 * a2);
}

void sub_1DD277574(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1DD2774F0((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *sub_1DD2775C8(void *a1)
{
  *a1 = &unk_1F3879640;
  sub_1DD278628((uint64_t)(a1 + 48));
  uint64_t v2 = a1[46];
  a1[46] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1DD24498C(a1 + 33);
  sub_1DD246F68(a1 + 21);
  uint64_t v3 = a1[14];
  a1[14] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1DD270434((uint64_t)(a1 + 9));
  uint64_t v4 = (void *)a1[5];
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[3];
  if (v5) {
    sub_1DD25B904(v5);
  }
  return a1;
}

void sub_1DD2776A0(int a1, void **__p)
{
  if (__p)
  {
    if (*((char *)__p + 47) < 0) {
      operator delete(__p[3]);
    }
    operator delete(__p);
  }
}

uint64_t *sub_1DD2776EC(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = (uint64_t *)a1[1]; a2 != a3 && i != a1; uint64_t i = (uint64_t *)i[1])
  {
    i[2] = *(void *)(a2 + 16);
    a2 = *(void *)(a2 + 8);
  }
  if (i == a1) {
    return sub_1DD27773C((uint64_t)a1, a1, a2, a3);
  }
  else {
    return sub_1DD277840((uint64_t)a1, i, a1);
  }
}

uint64_t *sub_1DD27773C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != a4)
  {
    uint64_t v8 = operator new(0x18uLL);
    uint64_t v9 = v8;
    *uint64_t v8 = 0;
    v8[1] = 0;
    uint64_t v10 = *(void *)(a3 + 8);
    void v8[2] = *(void *)(a3 + 16);
    uint64_t v11 = 1;
    if (v10 != a4)
    {
      unint64_t v12 = v8;
      do
      {
        uint64_t v8 = operator new(0x18uLL);
        *uint64_t v8 = v12;
        v8[1] = 0;
        void v8[2] = *(void *)(v10 + 16);
        v12[1] = v8;
        ++v11;
        uint64_t v10 = *(void *)(v10 + 8);
        unint64_t v12 = v8;
      }
      while (v10 != a4);
    }
    uint64_t v13 = *a2;
    *(void *)(v13 + 8) = v9;
    void *v9 = v13;
    *a2 = (uint64_t)v8;
    v8[1] = a2;
    *(void *)(a1 + 16) += v11;
    return v9;
  }
  return a2;
}

void sub_1DD27780C(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_1DD27782C(_Unwind_Exception *a1)
{
}

uint64_t *sub_1DD277840(uint64_t a1, uint64_t *__p, uint64_t *a3)
{
  if (__p != a3)
  {
    uint64_t v5 = *a3;
    uint64_t v6 = *__p;
    *(void *)(v6 + 8) = *(void *)(*a3 + 8);
    **(void **)(v5 + 8) = v6;
    do
    {
      uint64_t v7 = (uint64_t *)__p[1];
      --*(void *)(a1 + 16);
      operator delete(__p);
      std::string __p = v7;
    }
    while (v7 != a3);
  }
  return a3;
}

void *sub_1DD2778B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = operator new(0x28uLL);
  void *v7 = a2;
  v7[1] = a3;
  uint64_t v8 = v7 + 2;
  if (*(char *)(a4 + 23) < 0)
  {
    sub_1DD24F980(v8, *(void **)a4, *(void *)(a4 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = *(_OWORD *)a4;
    v7[4] = *(void *)(a4 + 16);
  }
  return v7;
}

void sub_1DD27791C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD277930@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  uint64_t v5 = result;
  uint64_t v8 = a3;
  uint64_t v9 = a4;
  if (result != a2)
  {
    do
    {
      uint64_t result = sub_1DD27799C((uint64_t)&v8, v5);
      v5 += 24;
    }
    while (v5 != a2);
    a3 = v8;
    a4 = v9;
    uint64_t v5 = a2;
  }
  *a5 = v5;
  a5[1] = a3;
  a5[2] = a4;
  return result;
}

uint64_t sub_1DD27799C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a1;
  uint64_t v4 = *(void *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(void *)a2;
    uint64_t v5 = v4;
  }
  sub_1DD239B24(v3, a2, v5);
  uint64_t v6 = *(void *)(a1 + 8);
  if (v6)
  {
    size_t v7 = strlen(*(const char **)(a1 + 8));
    sub_1DD239B24(*(void **)a1, v6, v7);
  }
  return a1;
}

uint64_t *sub_1DD277A0C(uint64_t **a1, unint64_t *a2, uint64_t a3, uint64_t **a4)
{
  size_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        size_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        size_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    sub_1DD2694DC(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void *sub_1DD277ACC(void *result, long long *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_1DD24F980((unsigned char *)result[1], *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  v2[1] = v3 + 24;
  return result;
}

void sub_1DD277B24(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1DD277B2C(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1DD251DAC();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    unint64_t v10 = (char *)sub_1DD2697FC(v7, v9);
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v15[0] = v10;
  v15[1] = v11;
  uint64_t v16 = v11;
  uint64_t v17 = &v10[24 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_1DD24F980(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v16;
  }
  else
  {
    long long v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  uint64_t v16 = v11 + 24;
  sub_1DD277C50(a1, v15);
  uint64_t v13 = a1[1];
  sub_1DD277DE8((uint64_t)v15);
  return v13;
}

void sub_1DD277C3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD277DE8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD277C50(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD277CC8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD277CC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  char v13 = 1;
  sub_1DD277D68((uint64_t)v12);
  return a6;
}

uint64_t sub_1DD277D68(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD277DA0(a1);
  }
  return a1;
}

void sub_1DD277DA0(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_1DD277DE8(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DD277E20(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

_OWORD *sub_1DD277E78(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v6 = (void **)sub_1DD277F14((uint64_t)a1, &v12, a2);
  uint64_t v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x40uLL);
    uint64_t v9 = *a4;
    uint64_t v10 = *((void *)*a4 + 2);
    v7[2] = **a4;
    *((void *)v7 + 6) = v10;
    v9[1] = 0;
    uint64_t v9[2] = 0;
    void *v9 = 0;
    *((void *)v7 + 7) = 0;
    sub_1DD2694DC(a1, v12, v8, (uint64_t *)v7);
  }
  return v7;
}

void *sub_1DD277F14(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        uint64_t v8 = (void *)v4;
        uint64_t v9 = (const void **)(v4 + 32);
        if (!sub_1DD277FB4(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_1DD277FB4(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    uint64_t v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

BOOL sub_1DD277FB4(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

void sub_1DD278020(char **a1, unint64_t a2)
{
  if (a2 > (void)a1[2] << 6)
  {
    if ((a2 & 0x8000000000000000) != 0) {
      sub_1DD251DAC();
    }
    int v10 = 0;
    long long v11 = 0uLL;
    sub_1DD2780E0(&v10, a2);
    unint64_t v3 = (unint64_t)a1[1];
    uint64_t v8 = *a1;
    int v9 = 0;
    uint64_t v6 = &v8[8 * (v3 >> 6)];
    int v7 = v3 & 0x3F;
    sub_1DD278128(&v10, (uint64_t)&v8, (uint64_t)&v6, v3);
    int v4 = *a1;
    *a1 = v10;
    int v10 = v4;
    long long v5 = *(_OWORD *)(a1 + 1);
    *(_OWORD *)(a1 + 1) = v11;
    long long v11 = v5;
    if (v4) {
      operator delete(v4);
    }
  }
}

void sub_1DD2780C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD2780E0(void *a1, uint64_t a2)
{
  if (a2 < 0) {
    sub_1DD251DAC();
  }
  uint64_t result = sub_1DD251DC4((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

void sub_1DD278128(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a1[1];
  unint64_t v5 = v4 + a4;
  a1[1] = v4 + a4;
  if (!v4 || ((v5 - 1) ^ (v4 - 1)) >= 0x40)
  {
    if (v5 >= 0x41) {
      unint64_t v6 = (v5 - 1) >> 6;
    }
    else {
      unint64_t v6 = 0;
    }
    *(void *)(*a1 + 8 * v6) = 0;
  }
  int v7 = *(_DWORD *)(a2 + 8);
  uint64_t v8 = *(void *)a3;
  int v9 = *(_DWORD *)(a3 + 8);
  uint64_t v10 = *a1 + 8 * (v4 >> 6);
  uint64_t v16 = *(void *)a2;
  int v17 = v7;
  uint64_t v14 = v8;
  int v15 = v9;
  uint64_t v12 = v10;
  int v13 = v4 & 0x3F;
  sub_1DD2781CC(&v16, &v14, &v12, (uint64_t)&v11);
}

void sub_1DD2781CC(uint64_t *a1@<X0>, uint64_t *a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  int v5 = *((_DWORD *)a1 + 2);
  uint64_t v6 = *a2;
  int v7 = *((_DWORD *)a2 + 2);
  uint64_t v16 = *a1;
  int v17 = v5;
  uint64_t v14 = v6;
  int v15 = v7;
  int v8 = *((_DWORD *)a3 + 2);
  uint64_t v12 = *a3;
  int v13 = v8;
  sub_1DD27825C((uint64_t)&v16, (uint64_t)&v14, (uint64_t)&v12, (uint64_t)&v18);
  int v9 = v19;
  uint64_t v10 = v20;
  int v11 = v21;
  *(void *)a4 = v18;
  *(_DWORD *)(a4 + 8) = v9;
  *(void *)(a4 + 16) = v10;
  *(_DWORD *)(a4 + 24) = v11;
}

void sub_1DD27825C(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  unint64_t v4 = *(void **)a1;
  int v5 = *(_DWORD *)(a1 + 8);
  for (i = *(_DWORD *)(a3 + 8); *(void *)a1 != *(void *)a2 || v5 != *(_DWORD *)(a2 + 8); int v5 = *(_DWORD *)(a1 + 8))
  {
    int v8 = *(uint64_t **)a3;
    uint64_t v9 = 1 << i;
    if ((*v4 >> v5)) {
      uint64_t v10 = *v8 | v9;
    }
    else {
      uint64_t v10 = *v8 & ~v9;
    }
    *int v8 = v10;
    if (v5 == 63)
    {
      int v11 = 0;
      *(void *)a1 = v4 + 1;
    }
    else
    {
      int v11 = v5 + 1;
    }
    *(_DWORD *)(a1 + 8) = v11;
    int v12 = *(_DWORD *)(a3 + 8);
    if (v12 == 63)
    {
      int i = 0;
      *(void *)a3 += 8;
    }
    else
    {
      int i = v12 + 1;
    }
    *(_DWORD *)(a3 + 8) = i;
    unint64_t v4 = *(void **)a1;
  }
  *(void *)a4 = v4;
  *(_DWORD *)(a4 + 8) = v5;
  *(void *)(a4 + 16) = *(void *)a3;
  *(_DWORD *)(a4 + 24) = i;
}

void *sub_1DD27832C(void *result, unint64_t a2)
{
  unint64_t v2 = a2;
  unint64_t v3 = result;
  int v4 = *((_DWORD *)result + 2);
  int v5 = (void *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    unint64_t v2 = a2 - v6;
    *uint64_t result = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    uint64_t result = memset(v5, 255, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int v8 = &v5[v7];
    void *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void sub_1DD2783E0(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  int v4 = *(_DWORD *)(a1 + 8);
  int v5 = *(void **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2) {
      unint64_t v6 = a2;
    }
    else {
      unint64_t v6 = (64 - v4);
    }
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    unint64_t v2 = a2 - v6;
    *(void *)a1 = v5;
  }
  unint64_t v7 = v2 >> 6;
  if (v2 >= 0x40) {
    bzero(v5, 8 * v7);
  }
  if ((v2 & 0x3F) != 0)
  {
    int v8 = &v5[v7];
    *(void *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

uint64_t sub_1DD278490(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_1DD277FB4(v5, (const void **)(v3 + 32), a2);
    int v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      int v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_1DD277FB4(v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

void sub_1DD278520(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1DD278520(a1, *(void *)a2);
    sub_1DD278520(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

void sub_1DD278584(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_1DD2785D8((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1DD2785D8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t sub_1DD278628(uint64_t a1)
{
  sub_1DD278664(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void sub_1DD278664(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      sub_1DD2419CC(v2 + 3);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void *sub_1DD2786A8(void *a1, uint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4)
  {
    sub_1DD2780E0(a1, v4);
    sub_1DD278704(a1, *(void **)a2, 0, (void *)(*(void *)a2 + 8 * (*(void *)(a2 + 8) >> 6)), *(void *)(a2 + 8) & 0x3F, *(void *)(a2 + 8));
  }
  return a1;
}

void sub_1DD278704(void *a1, void *a2, unint64_t a3, void *a4, int a5, uint64_t a6)
{
  unint64_t v6 = a1[1];
  unint64_t v7 = v6 + a6;
  a1[1] = v6 + a6;
  if (!v6 || ((v7 - 1) ^ (v6 - 1)) >= 0x40)
  {
    if (v7 >= 0x41) {
      unint64_t v8 = (v7 - 1) >> 6;
    }
    else {
      unint64_t v8 = 0;
    }
    *(void *)(*a1 + 8 * v8) = 0;
  }
  uint64_t v9 = *a1 + 8 * (v6 >> 6);
  int v10 = v6 & 0x3F;
  sub_1DD278784(a2, a3, a4, a5, (uint64_t)&v9, (uint64_t)v11);
}

void sub_1DD278784(void *a1@<X1>, unint64_t a2@<X2>, void *a3@<X3>, int a4@<W4>, uint64_t a5@<X5>, uint64_t a6@<X8>)
{
  LODWORD(v6) = a2;
  unint64_t v7 = *(uint64_t **)a5;
  int v8 = *(_DWORD *)(a5 + 8);
  if (a1 != a3 || a2 != a4)
  {
    do
    {
      uint64_t v9 = 1 << v8;
      if ((*a1 >> a2)) {
        uint64_t v10 = *v7 | v9;
      }
      else {
        uint64_t v10 = *v7 & ~v9;
      }
      uint64_t *v7 = v10;
      BOOL v11 = v6 == 63;
      BOOL v12 = v6 == 63;
      uint64_t v6 = (a2 + 1);
      if (v11) {
        uint64_t v6 = 0;
      }
      if (v8 == 63)
      {
        int v8 = 0;
        *(void *)a5 = ++v7;
      }
      else
      {
        ++v8;
      }
      a1 += v12;
      a2 = v6 | a2 & 0xFFFFFFFF00000000;
      *(_DWORD *)(a5 + 8) = v8;
    }
    while (a1 != a3 || v6 != a4);
    a1 = a3;
  }
  *(void *)a6 = a1;
  *(void *)(a6 + 8) = a2;
  *(void *)(a6 + 16) = v7;
  *(_DWORD *)(a6 + 24) = v8;
}

void sub_1DD27882C(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    sub_1DD278664(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void *sub_1DD278884(uint64_t a1, uint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v6 >= v7) {
        unint64_t v4 = v6 % v7;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v4);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (*v9)
      {
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == v6) {
              return v10;
            }
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7) {
                v11 %= v7;
              }
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v4) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
  sub_1DD278ACC(a1, *a2, a4, (uint64_t)v21);
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_1DD278B48(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v4 = v6 % v7;
      }
      else {
        unint64_t v4 = v6;
      }
    }
    else
    {
      unint64_t v4 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void **)(*(void *)a1 + 8 * v4);
  if (v18)
  {
    *(void *)v21[0] = *v18;
    *uint64_t v18 = v21[0];
  }
  else
  {
    *(void *)v21[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v21[0];
    *(void *)(*(void *)a1 + 8 * v4) = a1 + 16;
    if (*(void *)v21[0])
    {
      unint64_t v19 = *(void *)(*(void *)v21[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v19 >= v7) {
          v19 %= v7;
        }
      }
      else
      {
        v19 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v19) = v21[0];
    }
  }
  uint64_t v10 = (void *)v21[0];
  v21[0] = 0;
  ++*(void *)(a1 + 24);
  sub_1DD278D94((uint64_t)v21, 0);
  return v10;
}

void sub_1DD278AB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD278D94((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD278ACC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7 = a1 + 16;
  uint8x8_t v8 = operator new(0x48uLL);
  *(void *)a4 = v8;
  *(void *)(a4 + 8) = v7;
  *(unsigned char *)(a4 + 16) = 0;
  *uint8x8_t v8 = 0;
  v8[1] = a2;
  void v8[2] = **a3;
  uint64_t result = sub_1DD241978((uint64_t)(v8 + 3));
  *(unsigned char *)(a4 + 16) = 1;
  return result;
}

void sub_1DD278B30(_Unwind_Exception *a1)
{
  sub_1DD278D94(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1DD278B48(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      sub_1DD278C38(a1, prime);
    }
  }
}

void sub_1DD278C38(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      sub_1DD251C54();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      unint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            void *v7 = *v11;
            void *v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            unint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          unint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    uint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void sub_1DD278D94(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1DD2419CC(v2 + 3);
    }
    operator delete(v2);
  }
}

void sub_1DD278DEC(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    int8x8_t v4 = v1[1];
    unint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        sub_1DD277088(v4);
      }
      while (v4 != v2);
      unint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1DD278E70(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int8x8_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_1DD278EBC(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_1DD251DAC();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  v14[4] = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_1DD2697FC(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = (uint64_t *)&v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v14[3] = &v10[24 * v9];
  uint64_t *v11 = (uint64_t)v11;
  v11[1] = (uint64_t)v11;
  void v11[2] = 0;
  sub_1DD278FCC((uint64_t)v11, v11, a2);
  void v14[2] = v11 + 3;
  sub_1DD279014(a1, v14);
  uint64_t v12 = a1[1];
  sub_1DD2790C8((uint64_t)v14);
  return v12;
}

void sub_1DD278FB8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD2790C8((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD278FCC(uint64_t result, uint64_t *a2, void *a3)
{
  uint64_t v3 = a3[2];
  if (v3)
  {
    uint64_t v5 = *a3;
    unint64_t v4 = (uint64_t *)a3[1];
    uint64_t v6 = *v4;
    *(void *)(v6 + 8) = *(void *)(*a3 + 8);
    **(void **)(v5 + 8) = v6;
    uint64_t v7 = *a2;
    *(void *)(v7 + 8) = v4;
    *unint64_t v4 = v7;
    *a2 = v5;
    *(void *)(v5 + 8) = a2;
    *(void *)(result + 16) += v3;
    a3[2] = 0;
  }
  return result;
}

uint64_t *sub_1DD279014(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = (void *)*result;
  unint64_t v4 = (void *)result[1];
  uint64_t v6 = (void *)a2[1];
  if (v4 != (void *)*result)
  {
    uint64_t v7 = v6 - 3;
    unint64_t v8 = v6 - 3;
    do
    {
      v4 -= 3;
      *unint64_t v8 = v8;
      v8[1] = v8;
      void v8[2] = 0;
      uint64_t result = (uint64_t *)sub_1DD278FCC((uint64_t)v8, v7, v4);
      v8 -= 3;
      v7 -= 3;
    }
    while (v4 != v5);
    uint64_t v6 = v8 + 3;
  }
  a2[1] = v6;
  uint64_t v9 = *v3;
  uint64_t *v3 = (uint64_t)v6;
  a2[1] = v9;
  uint64_t v10 = v3[1];
  v3[1] = a2[2];
  a2[2] = v10;
  uint64_t v11 = v3[2];
  v3[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD2790C8(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 24;
    sub_1DD277088((void *)(i - 24));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *sub_1DD279118(uint64_t a1, unint64_t *a2, _OWORD *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = v6;
  *((_OWORD *)i + 1) = *a3;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    sub_1DD278B48(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v18 = *(void *)a1;
  unint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t i = *v19;
LABEL_38:
    *unint64_t v19 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    unint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_1DD279320(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD279334(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD2793D8(a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1DD2793C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *sub_1DD2793D8(void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_1DD251DAC();
  }
  uint64_t result = (char *)sub_1DD2697FC((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void sub_1DD27942C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    uint64_t v4 = (void **)v1[1];
    size_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        unint64_t v6 = v4;
        sub_1DD2794A0(&v6);
      }
      while (v4 != v2);
      size_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DD2794A0(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    size_t v5 = **a1;
    if (v4 != v2)
    {
      unint64_t v6 = v4 - 120;
      unint64_t v7 = v4 - 120;
      uint8x8_t v8 = v4 - 120;
      do
      {
        uint64_t v9 = *(void (***)(char *))v8;
        v8 -= 120;
        (*v9)(v7);
        v6 -= 120;
        BOOL v10 = v7 == v2;
        unint64_t v7 = v8;
      }
      while (!v10);
      size_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *sub_1DD279560(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &unk_1F387CDD8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1DD2795C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    sub_1DD27962C((int)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD2795E0(uint64_t a1)
{
}

uint64_t sub_1DD2795E8(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878ED0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_1DD27962C(int a1, uint64_t *__p)
{
  if (__p)
  {
    uint64_t v3 = __p[3];
    __p[3] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    uint64_t v4 = __p[2];
    __p[2] = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = __p[1];
    __p[1] = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    uint64_t v6 = *__p;
    *std::string __p = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
    operator delete(__p);
  }
}

void sub_1DD279728(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1DD279728(a1, *(void *)a2);
    sub_1DD279728(a1, *((void *)a2 + 1));
    uint64_t v4 = (void **)(a2 + 40);
    sub_1DD277574(&v4);
    operator delete(a2);
  }
}

uint64_t sub_1DD279788(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1DD2797B8(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878F28)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD2797FC(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD279874((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD279874(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1DD279908((uint64_t)v12);
  return v10;
}

uint64_t sub_1DD279908(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD279940(a1);
  }
  return a1;
}

void sub_1DD279940(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      sub_1DD25B904(v3);
    }
    v1 += 16;
  }
}

void **sub_1DD279984(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1DD2799B8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      sub_1DD25B904(v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

uint64_t **sub_1DD279A0C(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        long long v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    long long v9 = a1 + 1;
LABEL_10:
    unint64_t v11 = operator new(0x40uLL);
    char v11[8] = **a4;
    *((void *)v11 + 6) = 0;
    *((void *)v11 + 7) = 0;
    *((void *)v11 + 5) = 0;
    sub_1DD2694DC(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1DD279AD4(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = a3;
  *(void *)(a1 + 56) = 0;
  *(void *)a1 = &unk_1F3879528;
  *(void *)(a1 + 40) = operator new[](0x400uLL);
  *(void *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  return a1;
}

void sub_1DD279B44(_Unwind_Exception *a1)
{
  sub_1DD27D340(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD279B5C(void *a1)
{
  *a1 = &unk_1F3879528;
  uint64_t v2 = (void *)a1[5];
  if (v2) {
    operator delete[](v2);
  }
  return sub_1DD27D340(a1);
}

void sub_1DD279BBC(void *a1)
{
  uint64_t v1 = sub_1DD279B5C(a1);
  operator delete(v1);
}

uint64_t sub_1DD279BE4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void (**)(uint64_t, void))(*(void *)result + 48);
    if (*(unsigned char *)(result + 72))
    {
      v3(result, (char)(v1 - 3));
      (*(void (**)(uint64_t, void))(*(void *)v2 + 48))(v2, *(char *)(v2 + 64));
      uint64_t v4 = **(void **)(v2 + 40);
      uint64_t v5 = *(void *)v2;
      if (*(unsigned char *)(v2 + 48)) {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 64))(v2, v4);
      }
      else {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 56))(v2, v4);
      }
    }
    else
    {
      uint64_t result = ((uint64_t (*)(uint64_t, void))v3)(result, (char)-*(unsigned char *)(result + 32));
      if (*(void *)(v2 + 32))
      {
        unint64_t v6 = 0;
        do
        {
          uint64_t v7 = *(void *)(*(void *)(v2 + 40) + 8 * v6);
          uint64_t v8 = *(void *)v2;
          if (*(unsigned char *)(v2 + 48)) {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 64))(v2, v7);
          }
          else {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v8 + 56))(v2, v7);
          }
          ++v6;
        }
        while (v6 < *(void *)(v2 + 32));
      }
    }
    *(unsigned char *)(v2 + 72) = 0;
    *(void *)(v2 + 32) = 0;
    *(void *)(v2 + 80) = 0;
  }
  return result;
}

uint64_t sub_1DD279D7C(uint64_t a1)
{
  sub_1DD279BE4(a1);
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 16)));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t sub_1DD279E00(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 32);
  if (!v4)
  {
    unint64_t v6 = *(void **)(result + 40);
    *(void *)(result + 32) = 1;
    void *v6 = a2;
    *(void *)(result + 80) = 1;
    return result;
  }
  if (!*(unsigned char *)(result + 72))
  {
    uint64_t v7 = *(void *)(result + 80);
    uint64_t v8 = *(void *)(result + 40);
    uint64_t v9 = *(void *)(v8 + 8 * v4 - 8);
    if (v7 == 1 || *(void *)(result + 64) + v9 != a2)
    {
      *(void *)(result + 64) = a2 - v9;
      uint64_t v15 = 1;
      if (a2 - v9 == (char)(a2 - v9)) {
        uint64_t v15 = 2;
      }
      *(void *)(result + 80) = v15;
    }
    else
    {
      uint64_t v10 = v7 + 1;
      *(void *)(result + 80) = v10;
      if (v10 == 3)
      {
        uint64_t v11 = v4 - 2;
        if (v11)
        {
          *(void *)(result + 32) = v11;
          uint64_t v12 = *(void *)(v8 + 8 * v11);
          uint64_t result = sub_1DD279BE4(result);
          **(void **)(v3 + 40) = v12;
        }
        *(unsigned char *)(v3 + 72) = 1;
        *(void *)(v3 + 32) = 3;
        return result;
      }
    }
    *(void *)(result + 32) = v4 + 1;
    *(void *)(v8 + 8 * v4) = a2;
    if (v4 != 127) {
      return result;
    }
LABEL_18:
    return sub_1DD279BE4(result);
  }
  if (**(void **)(result + 40) + *(void *)(result + 64) * v4 != a2)
  {
    uint64_t result = sub_1DD279BE4(result);
    uint64_t v14 = *(void *)(v3 + 32);
    uint64_t v13 = *(void *)(v3 + 40);
    *(void *)(v3 + 32) = v14 + 1;
    *(void *)(v13 + 8 * v14) = a2;
    *(void *)(v3 + 80) = 1;
    return result;
  }
  uint64_t v5 = v4 + 1;
  *(void *)(result + 32) = v5;
  if (v5 == 130) {
    goto LABEL_18;
  }
  return result;
}

double sub_1DD279F54(uint64_t a1, uint64_t *a2, char a3)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  *(void *)a1 = &unk_1F38794B8;
  *(void *)(a1 + 8) = v3;
  *(unsigned char *)(a1 + 16) = a3;
  double result = 0.0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 49) = 0u;
  return result;
}

uint64_t sub_1DD279F90(unint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(void *)(a1 + 48) = *(void *)(a1 + 40);
  sub_1DD27A02C(a1);
  uint64_t v4 = sub_1DD238FA4(a2);
  uint64_t v5 = *(uint64_t (**)(unint64_t, uint64_t))(*(void *)a1 + 24);
  return v5(a1, v4);
}

unint64_t sub_1DD27A02C(unint64_t result)
{
  uint64_t v1 = result;
  uint64_t v3 = *(char **)(result + 40);
  uint64_t v2 = *(char **)(result + 48);
  if (v3 == v2)
  {
    int v11 = 0;
    uint64_t v10 = 0;
    double result = (*(uint64_t (**)(void, char **, int *))(**(void **)(result + 8) + 16))(*(void *)(result + 8), &v10, &v11);
    if ((result & 1) == 0) {
      goto LABEL_12;
    }
    uint64_t v3 = v10;
    uint64_t v2 = &v10[v11];
    *(void *)(v1 + 40) = v10;
    *(void *)(v1 + 48) = v2;
  }
  uint64_t v4 = v3 + 1;
  *(void *)(v1 + 40) = v3 + 1;
  uint64_t v5 = *v3;
  if (v5 < 0)
  {
    *(void *)(v1 + 24) = -v5;
    *(unsigned char *)(v1 + 64) = 0;
    return result;
  }
  *(void *)(v1 + 24) = v5 + 3;
  *(unsigned char *)(v1 + 64) = 1;
  if (v4 == v2)
  {
    int v11 = 0;
    uint64_t v10 = 0;
    if ((*(uint64_t (**)(void, char **, int *))(**(void **)(v1 + 8) + 16))(*(void *)(v1 + 8), &v10, &v11))
    {
      uint64_t v4 = v10;
      unint64_t v6 = &v10[v11];
      *(void *)(v1 + 40) = v10;
      *(void *)(v1 + 48) = v6;
      goto LABEL_8;
    }
LABEL_12:
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "bad read in readByte");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
LABEL_8:
  *(void *)(v1 + 40) = v4 + 1;
  *(void *)(v1 + 56) = *v4;
  int v7 = *(unsigned __int8 *)(v1 + 16);
  double result = sub_1DD27A564(v1);
  unint64_t v8 = -(uint64_t)(result & 1) ^ (result >> 1);
  if (!v7) {
    unint64_t v8 = result;
  }
  *(void *)(v1 + 32) = v8;
  return result;
}

void sub_1DD27A1BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD27A1D4(unint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    unint64_t v3 = result;
    do
    {
      unint64_t v4 = *(void *)(v3 + 24);
      if (!v4)
      {
        double result = sub_1DD27A02C(v3);
        unint64_t v4 = *(void *)(v3 + 24);
      }
      if (v4 >= v2) {
        unint64_t v5 = v2;
      }
      else {
        unint64_t v5 = v4;
      }
      *(void *)(v3 + 24) = v4 - v5;
      if (*(unsigned char *)(v3 + 64))
      {
        *(void *)(v3 + 32) += *(void *)(v3 + 56) * v5;
      }
      else if (v5)
      {
        int v7 = *(unsigned __int8 **)(v3 + 40);
        unint64_t v6 = *(unsigned __int8 **)(v3 + 48);
        unint64_t v8 = v5;
        do
        {
          if (v7 == v6)
          {
            int v12 = 0;
            int v11 = 0;
            double result = (*(uint64_t (**)(void, unsigned __int8 **, int *))(**(void **)(v3 + 8) + 16))(*(void *)(v3 + 8), &v11, &v12);
            if ((result & 1) == 0)
            {
              exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
              sub_1DD26D8A0(exception, "bad read in readByte");
              __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
            }
            int v7 = v11;
            unint64_t v6 = &v11[v12];
            *(void *)(v3 + 40) = v11;
            *(void *)(v3 + 48) = v6;
          }
          *(void *)(v3 + 40) = v7 + 1;
          uint64_t v9 = (*v7++ >> 7) ^ 1u;
          v8 -= v9;
        }
        while (v8);
      }
      v2 -= v5;
    }
    while (v2);
  }
  return result;
}

void sub_1DD27A30C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD27A320(unint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v6 = result;
  unint64_t v7 = 0;
  if (a4 && a3)
  {
    unint64_t v7 = 0;
    while (!*(unsigned char *)(a4 + v7))
    {
      if (a3 == ++v7) {
        return result;
      }
    }
  }
  if (v7 < a3)
  {
    unint64_t v8 = *(void *)(result + 24);
    while (1)
    {
      if (!v8)
      {
        double result = sub_1DD27A02C(v6);
        unint64_t v8 = *(void *)(v6 + 24);
      }
      uint64_t v9 = v8 >= a3 - v7 ? a3 - v7 : v8;
      if (*(unsigned char *)(v6 + 64)) {
        break;
      }
      if (a4)
      {
        uint64_t v10 = 0;
        if (v9)
        {
          uint64_t v15 = (unsigned __int8 *)(a4 + v7);
          uint64_t v16 = v9;
          size_t v17 = (unint64_t *)(a2 + 8 * v7);
          do
          {
            if (*v15++)
            {
              int v19 = *(unsigned __int8 *)(v6 + 16);
              double result = sub_1DD27A564(v6);
              unint64_t v20 = -(uint64_t)(result & 1) ^ (result >> 1);
              if (!v19) {
                unint64_t v20 = result;
              }
              *size_t v17 = v20;
              ++v10;
            }
            ++v17;
            --v16;
          }
          while (v16);
        }
        goto LABEL_37;
      }
      if (*(unsigned char *)(v6 + 16))
      {
        if (v9)
        {
          uint64_t v22 = (unint64_t *)(a2 + 8 * v7);
          uint64_t v23 = v9;
          do
          {
            double result = sub_1DD27A564(v6);
            *v22++ = -(uint64_t)(result & 1) ^ (result >> 1);
            --v23;
          }
          while (v23);
          goto LABEL_50;
        }
      }
      else if (v9)
      {
        uint64_t v24 = (unint64_t *)(a2 + 8 * v7);
        uint64_t v25 = v9;
        do
        {
          double result = sub_1DD27A564(v6);
          *v24++ = result;
          --v25;
        }
        while (v25);
LABEL_50:
        uint64_t v10 = v9;
LABEL_37:
        unint64_t v8 = *(void *)(v6 + 24) - v10;
        *(void *)(v6 + 24) = v8;
        v7 += v9;
        if (a4 && v7 < a3)
        {
          while (!*(unsigned char *)(a4 + v7))
          {
            if (++v7 >= a3) {
              return result;
            }
          }
        }
        goto LABEL_52;
      }
      unint64_t v8 = *(void *)(v6 + 24);
      v7 += v9;
LABEL_52:
      if (v7 >= a3) {
        return result;
      }
    }
    if (a4)
    {
      if (v9)
      {
        uint64_t v10 = 0;
        int v11 = (unsigned __int8 *)(a4 + v7);
        uint64_t v12 = v9;
        uint64_t v13 = (void *)(a2 + 8 * v7);
        do
        {
          if (*v11++) {
            *uint64_t v13 = *(void *)(v6 + 32) + *(void *)(v6 + 56) * v10++;
          }
          ++v13;
          --v12;
        }
        while (v12);
        goto LABEL_36;
      }
    }
    else if (v9)
    {
      for (uint64_t i = 0; i != v9; ++i)
        *(void *)(a2 + 8 * v7 + 8 * i) = *(void *)(v6 + 32) + *(void *)(v6 + 56) * i;
      uint64_t v10 = v9;
      goto LABEL_36;
    }
    uint64_t v10 = 0;
LABEL_36:
    *(void *)(v6 + 32) += *(void *)(v6 + 56) * v10;
    goto LABEL_37;
  }
  return result;
}

uint64_t sub_1DD27A564(uint64_t a1)
{
  unint64_t v3 = *(char **)(a1 + 40);
  unint64_t v2 = *(char **)(a1 + 48);
  if (v3 == v2)
  {
    int v14 = 0;
    uint64_t v13 = 0;
    if (((*(uint64_t (**)(void, char **, int *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v13, &v14) & 1) == 0)
    {
LABEL_13:
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "bad read in readByte");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    unint64_t v3 = v13;
    unint64_t v2 = &v13[v14];
    *(void *)(a1 + 40) = v13;
    *(void *)(a1 + 48) = v2;
  }
  unint64_t v4 = (unsigned __int8 *)(v3 + 1);
  *(void *)(a1 + 40) = v3 + 1;
  int v5 = *v3;
  uint64_t result = v5;
  if (v5 < 0)
  {
    uint64_t v7 = v5 & 0x7F;
    for (char i = 7; ; i += 7)
    {
      if (v4 == (unsigned __int8 *)v2)
      {
        int v14 = 0;
        uint64_t v13 = 0;
        if (((*(uint64_t (**)(void, char **, int *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v13, &v14) & 1) == 0)goto LABEL_13; {
        unint64_t v4 = (unsigned __int8 *)v13;
        }
        unint64_t v2 = &v13[v14];
        *(void *)(a1 + 40) = v13;
        *(void *)(a1 + 48) = v2;
      }
      uint64_t v9 = (char *)(v4 + 1);
      *(void *)(a1 + 40) = v4 + 1;
      int v10 = (char)*v4;
      uint64_t v11 = *v4;
      if ((v10 & 0x80000000) == 0) {
        break;
      }
      v7 |= (unint64_t)(v11 & 0x7F) << i;
      unint64_t v4 = (unsigned __int8 *)v9;
    }
    return (v11 << i) | v7;
  }
  return result;
}

void sub_1DD27A6E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27A6FC(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F38794B8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return nullsub_1(a1);
}

void sub_1DD27A778(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F38794B8;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = (void *)nullsub_1(a1);
  operator delete(v3);
}

uint64_t sub_1DD27A7F8(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 **)(a1 + 40);
  if (v2 == *(unsigned __int8 **)(a1 + 48))
  {
    int v7 = 0;
    unint64_t v6 = 0;
    if (((*(uint64_t (**)(void, unsigned __int8 **, int *))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), &v6, &v7) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "bad read in RleDecoderV2::readByte");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v2 = v6;
    unint64_t v3 = &v6[v7];
    *(void *)(a1 + 40) = v6;
    *(void *)(a1 + 48) = v3;
  }
  *(void *)(a1 + 40) = v2 + 1;
  return *v2;
}

void sub_1DD27A8BC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27A8D0(uint64_t a1, uint64_t *a2, char a3, uint64_t a4)
{
  uint64_t v6 = *a2;
  *a2 = 0;
  *(void *)a1 = &unk_1F38794F0;
  *(void *)(a1 + 8) = v6;
  *(unsigned char *)(a1 + 16) = a3;
  *(unsigned char *)(a1 + 17) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(void *)(a1 + 152) = 0;
  sub_1DD270020(a1 + 160, a4, 0);
  sub_1DD270020(a1 + 200, a4, 0);
  return a1;
}

void sub_1DD27A978(_Unwind_Exception *a1)
{
  sub_1DD270394(v2);
  uint64_t v4 = *(void *)(v1 + 8);
  *(void *)(v1 + 8) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  nullsub_1(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27A9D0(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8));
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  uint64_t v4 = sub_1DD238FA4(a2);
  int v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 24);
  return v5(a1, v4);
}

uint64_t sub_1DD27AA68(uint64_t result, unint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    unint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      if (v2 >= 0x40) {
        uint64_t v4 = 64;
      }
      else {
        uint64_t v4 = v2;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, unsigned char *, uint64_t, void))(*(void *)v3 + 32))(v3, v5, v4, 0);
      v2 -= v4;
    }
    while (v2);
  }
  return result;
}

unint64_t sub_1DD27AB1C(unint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a3)
  {
    uint64_t v7 = result;
    for (unint64_t i = 0; i < a3; i += result)
    {
      unint64_t v9 = i;
      while (a4)
      {
        if (*(unsigned char *)(a4 + v9))
        {
          unint64_t i = v9;
          break;
        }
        if (a3 == ++v9) {
          return result;
        }
      }
      if (*(void *)(v7 + 32) == *(void *)(v7 + 24))
      {
        *(_DWORD *)(v7 + 96) = 0;
        *(void *)(v7 + 88) = 0;
        unsigned int v10 = sub_1DD27A7F8(v7);
        *(unsigned char *)(v7 + 17) = v10;
      }
      else
      {
        unsigned int v10 = *(unsigned __int8 *)(v7 + 17);
      }
      unint64_t v11 = a3 - i;
      switch(v10 >> 6)
      {
        case 1u:
          uint64_t result = sub_1DD27AD84(v7, a2, i, v11, a4);
          break;
        case 2u:
          uint64_t result = sub_1DD27AEC4(v7, a2, i, v11, a4);
          break;
        case 3u:
          uint64_t result = sub_1DD27B1DC(v7, a2, i, v11, a4);
          break;
        default:
          uint64_t result = sub_1DD27AC50(v7, a2, i, v11, a4);
          break;
      }
    }
  }
  return result;
}

unint64_t sub_1DD27AC50(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  if (*(void *)(a1 + 32) == *(void *)(a1 + 24))
  {
    unint64_t v10 = 0;
    unint64_t v11 = *(unsigned __int8 *)(a1 + 17);
    uint64_t v12 = (v11 >> 3) & 7;
    *(void *)(a1 + 64) = v12 + 1;
    *(void *)(a1 + 24) = (v11 & 7) + 3;
    *(void *)(a1 + 32) = 0;
    uint64_t v13 = 8 * v12;
    do
    {
      v10 |= (unint64_t)sub_1DD27A7F8(a1) << v13;
      v13 -= 8;
    }
    while (v13 != -8);
    *(void *)(a1 + 72) = v10;
    if (*(unsigned char *)(a1 + 16)) {
      *(void *)(a1 + 72) = -(uint64_t)(v10 & 1) ^ (v10 >> 1);
    }
  }
  uint64_t v14 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 24) - v14 >= a4) {
    unint64_t result = a4;
  }
  else {
    unint64_t result = *(void *)(a1 + 24) - v14;
  }
  if (a5)
  {
    if (result + a3 > a3)
    {
      uint64_t v16 = (void *)(a2 + 8 * a3);
      size_t v17 = (unsigned __int8 *)(a5 + a3);
      unint64_t v18 = result;
      do
      {
        if (*v17++)
        {
          *uint64_t v16 = *(void *)(a1 + 72);
          ++*(void *)(a1 + 32);
        }
        ++v16;
        --v18;
      }
      while (v18);
    }
  }
  else if (result + a3 > a3)
  {
    unint64_t v20 = (void *)(a2 + 8 * a3);
    unint64_t v21 = result;
    do
    {
      *v20++ = *(void *)(a1 + 72);
      ++*(void *)(a1 + 32);
      --v21;
    }
    while (v21);
  }
  return result;
}

unint64_t sub_1DD27AD84(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10 == v11)
  {
    unint64_t v12 = *(unsigned __int8 *)(a1 + 17);
    *(_DWORD *)(a1 + 88) = byte_1DD32055A[(v12 >> 1) & 0x1F];
    *(void *)(a1 + 24) = (v12 & 1) << 8;
    unsigned int v13 = sub_1DD27A7F8(a1);
    uint64_t v10 = 0;
    uint64_t v11 = (*(void *)(a1 + 24) | v13) + 1;
    *(void *)(a1 + 24) = v11;
    *(void *)(a1 + 32) = 0;
  }
  unint64_t v14 = v11 - v10;
  if (v14 < a4) {
    a4 = v14;
  }
  *(void *)(a1 + 32) += sub_1DD27B4F8(a1, a2, a3, a4, *(unsigned int *)(a1 + 88), a5);
  if (*(unsigned char *)(a1 + 16))
  {
    if (a5)
    {
      if (a4 + a3 > a3)
      {
        uint64_t v15 = (uint64_t *)(a2 + 8 * a3);
        uint64_t v16 = (unsigned __int8 *)(a5 + a3);
        unint64_t v17 = a4;
        do
        {
          if (*v16++) {
            *uint64_t v15 = -(*v15 & 1) ^ ((unint64_t)*v15 >> 1);
          }
          ++v15;
          --v17;
        }
        while (v17);
      }
    }
    else if (a4 + a3 > a3)
    {
      int v19 = (uint64_t *)(a2 + 8 * a3);
      unint64_t v20 = a4;
      do
      {
        *int v19 = -(*v19 & 1) ^ ((unint64_t)*v19 >> 1);
        ++v19;
        --v20;
      }
      while (v20);
    }
  }
  return a4;
}

unint64_t sub_1DD27AEC4(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10 = *(void *)(a1 + 24);
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11 == v10)
  {
    unint64_t v12 = *(unsigned __int8 *)(a1 + 17);
    *(_DWORD *)(a1 + 88) = byte_1DD32055A[(v12 >> 1) & 0x1F];
    *(void *)(a1 + 24) = (v12 & 1) << 8;
    *(void *)(a1 + 24) = (*(void *)(a1 + 24) | sub_1DD27A7F8(a1)) + 1;
    *(void *)(a1 + 32) = 0;
    unsigned int v13 = sub_1DD27A7F8(a1);
    *(void *)(a1 + 64) = (v13 >> 5) + 1;
    *(_DWORD *)(a1 + 100) = byte_1DD32055A[v13 & 0x1F];
    unsigned int v14 = sub_1DD27A7F8(a1);
    unint64_t v15 = v14 & 0x1F;
    if (v15)
    {
      int v16 = (v14 >> 5) + 1;
      uint64_t v17 = *(void *)(a1 + 64);
      if (v17)
      {
        uint64_t v18 = 0;
        uint64_t v19 = 8 * v17 - 8;
        do
        {
          --v17;
          v18 |= (unint64_t)sub_1DD27A7F8(a1) << v19;
          v19 -= 8;
        }
        while (v17);
        uint64_t v20 = 8 * *(void *)(a1 + 64) - 1;
      }
      else
      {
        uint64_t v18 = 0;
        LOBYTE(v20) = -1;
      }
      uint64_t v21 = 1 << v20;
      if ((v21 & v18) != 0) {
        uint64_t v22 = -(v18 & ~v21);
      }
      else {
        uint64_t v22 = v18;
      }
      *(void *)(a1 + 120) = v22;
      sub_1DD26FB7C(a1 + 160, *(void *)(a1 + 24));
      *(void *)(a1 + 104) = 0;
      sub_1DD27B4F8(a1, *(void *)(a1 + 176), 0, *(void *)(a1 + 24), *(unsigned int *)(a1 + 88), 0);
      *(_DWORD *)(a1 + 92) = 0;
      *(_DWORD *)(a1 + 96) = 0;
      sub_1DD26FB7C(a1 + 200, v15);
      *(void *)(a1 + 112) = 0;
      unsigned int v23 = v16 + *(_DWORD *)(a1 + 100);
      if (v23 < 0x41)
      {
        sub_1DD27B4F8(a1, *(void *)(a1 + 216), 0, v15, byte_1DD32057A[v23], 0);
        *(_DWORD *)(a1 + 92) = 0;
        *(_DWORD *)(a1 + 96) = 0;
        *(void *)(a1 + 144) = ~(-1 << *(_DWORD *)(a1 + 100));
        sub_1DD27B60C(a1);
        uint64_t v10 = *(void *)(a1 + 24);
        uint64_t v11 = *(void *)(a1 + 32);
        goto LABEL_13;
      }
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Corrupt PATCHED_BASE encoded data (patchBitSize + pgw > 64)!");
    }
    else
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Corrupt PATCHED_BASE encoded data (pl==0)!");
    }
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
LABEL_13:
  unint64_t v24 = v10 - v11;
  if (v24 < a4) {
    a4 = v24;
  }
  if (a4 + a3 > a3)
  {
    uint64_t v25 = (void *)(a2 + 8 * a3);
    uint64_t v26 = (unsigned char *)(a5 + a3);
    unint64_t v27 = a4;
    do
    {
      if (!a5 || *v26)
      {
        uint64_t v28 = *(void *)(a1 + 104);
        if (v28 == *(void *)(a1 + 152))
        {
          *uint64_t v25 = ((*(void *)(a1 + 136) << *(_DWORD *)(a1 + 88)) | *(void *)(*(void *)(a1 + 176) + 8 * v28))
               + *(void *)(a1 + 120);
          unint64_t v29 = *(void *)(a1 + 112) + 1;
          *(void *)(a1 + 112) = v29;
          if (v29 < *(void *)(a1 + 224))
          {
            sub_1DD27B60C(a1);
            *(void *)(a1 + 152) += *(void *)(a1 + 104);
          }
        }
        else
        {
          *uint64_t v25 = *(void *)(*(void *)(a1 + 176) + 8 * v28) + *(void *)(a1 + 120);
        }
        ++*(void *)(a1 + 32);
        ++*(void *)(a1 + 104);
      }
      ++v25;
      ++v26;
      --v27;
    }
    while (v27);
  }
  return a4;
}

void sub_1DD27B1C4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD27B1DC(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v11 = *(void *)(a1 + 24);
  unint64_t v10 = *(void *)(a1 + 32);
  if (v10 == v11)
  {
    unint64_t v12 = *(unsigned __int8 *)(a1 + 17);
    uint64_t v13 = (v12 >> 1) & 0x1F;
    if (v13) {
      LODWORD(v13) = byte_1DD32055A[v13];
    }
    *(_DWORD *)(a1 + 88) = v13;
    *(void *)(a1 + 24) = (v12 & 1) << 8;
    unsigned int v14 = sub_1DD27A7F8(a1);
    uint64_t v15 = *(void *)(a1 + 24);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 24) = (v15 | v14) + 1;
    *(void *)(a1 + 32) = 0;
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v16 = 0;
      uint64_t v17 = 0;
      do
      {
        char v18 = sub_1DD27A7F8(a1);
        v16 |= (unint64_t)(v18 & 0x7F) << v17;
        v17 += 7;
      }
      while (v18 < 0);
      unint64_t v19 = -(uint64_t)(v16 & 1) ^ (v16 >> 1);
    }
    else
    {
      unint64_t v19 = 0;
      uint64_t v20 = 0;
      do
      {
        char v21 = sub_1DD27A7F8(a1);
        v19 |= (unint64_t)(v21 & 0x7F) << v20;
        v20 += 7;
      }
      while (v21 < 0);
    }
    unint64_t v22 = 0;
    uint64_t v23 = 0;
    *(void *)(a1 + 72) = v19;
    *(void *)(a1 + 80) = v19;
    do
    {
      char v24 = sub_1DD27A7F8(a1);
      v22 |= (unint64_t)(v24 & 0x7F) << v23;
      v23 += 7;
    }
    while (v24 < 0);
    *(void *)(a1 + 56) = -(uint64_t)(v22 & 1) ^ (v22 >> 1);
    uint64_t v11 = *(void *)(a1 + 24);
    unint64_t v10 = *(void *)(a1 + 32);
  }
  unint64_t v25 = v11 - v10;
  if (v25 < a4) {
    a4 = v25;
  }
  unint64_t v26 = a4 + a3;
  BOOL v27 = a4 + a3 > a3;
  unint64_t v28 = a3;
  if (a5 && a4 + a3 > a3)
  {
    unint64_t v28 = a3;
    while (!*(unsigned char *)(a5 + v28))
    {
      if (++v28 >= v26) {
        goto LABEL_25;
      }
    }
    BOOL v27 = 1;
  }
  if (!v10 && v27)
  {
    *(void *)(a2 + 8 * v28++) = *(void *)(a1 + 72);
    unint64_t v10 = *(void *)(a1 + 32) + 1;
    *(void *)(a1 + 32) = v10;
  }
LABEL_25:
  unint64_t v29 = *(unsigned int *)(a1 + 88);
  BOOL v30 = v28 < v26;
  if (v29)
  {
    if (a5 && v28 < v26)
    {
      while (!*(unsigned char *)(a5 + v28))
      {
        if (++v28 >= v26) {
          goto LABEL_42;
        }
      }
      BOOL v30 = 1;
    }
    if (v30 && v10 <= 1)
    {
      uint64_t v35 = *(void *)(a1 + 56) + *(void *)(a1 + 72);
      *(void *)(a2 + 8 * v28++) = v35;
      *(void *)(a1 + 80) = v35;
      ++*(void *)(a1 + 32);
    }
LABEL_42:
    *(void *)(a1 + 32) += sub_1DD27B4F8(a1, a2, v28, v26 - v28, v29, a5);
    if ((*(void *)(a1 + 56) & 0x8000000000000000) != 0)
    {
      if (v26 > v28)
      {
        unint64_t v40 = a3 + a4 - v28;
        long long v41 = (void *)(a2 + 8 * v28);
        uint64_t v42 = (unsigned char *)(a5 + v28);
        do
        {
          if (!a5 || *v42)
          {
            uint64_t v43 = *(void *)(a1 + 80) - *v41;
            void *v41 = v43;
            *(void *)(a1 + 80) = v43;
          }
          ++v41;
          ++v42;
          --v40;
        }
        while (v40);
      }
    }
    else if (v26 > v28)
    {
      unint64_t v36 = a3 + a4 - v28;
      unint64_t v37 = (void *)(a2 + 8 * v28);
      unint64_t v38 = (unsigned char *)(a5 + v28);
      do
      {
        if (!a5 || *v38)
        {
          uint64_t v39 = *v37 + *(void *)(a1 + 80);
          void *v37 = v39;
          *(void *)(a1 + 80) = v39;
        }
        ++v37;
        ++v38;
        --v36;
      }
      while (v36);
    }
  }
  else if (v28 < v26)
  {
    unint64_t v31 = a3 + a4 - v28;
    uint64_t v32 = (void *)(a2 + 8 * v28);
    int64_t v33 = (unsigned char *)(a5 + v28);
    do
    {
      if (!a5 || *v33)
      {
        uint64_t v34 = *(void *)(a1 + 56) + *(void *)(a1 + 80);
        *uint64_t v32 = v34;
        *(void *)(a1 + 80) = v34;
        ++*(void *)(a1 + 32);
      }
      ++v32;
      ++v33;
      --v31;
    }
    while (v31);
  }
  return a4;
}

uint64_t sub_1DD27B4F8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v6 = a4 + a3;
  if (a4 + a3 > a3)
  {
    unint64_t v9 = a3;
    uint64_t v12 = 0;
    while (1)
    {
      if (a6 && !*(unsigned char *)(a6 + v9)) {
        goto LABEL_11;
      }
      unint64_t v13 = *(unsigned int *)(a1 + 92);
      char v14 = *(_DWORD *)(a1 + 92);
      if (v13 >= a5)
      {
        uint64_t v15 = 0;
        LODWORD(v17) = a5;
        if (!a5) {
          goto LABEL_10;
        }
      }
      else
      {
        uint64_t v15 = 0;
        int v16 = *(_DWORD *)(a1 + 96);
        unint64_t v17 = a5;
        do
        {
          uint64_t v15 = (v15 << v13) | v16 & ~(-1 << v14);
          v17 -= v13;
          int v16 = sub_1DD27A7F8(a1);
          unint64_t v13 = 8;
          *(_DWORD *)(a1 + 92) = 8;
          *(_DWORD *)(a1 + 96) = v16;
          char v14 = 8;
        }
        while (v17 > 8);
        if (!v17) {
          goto LABEL_10;
        }
      }
      int v18 = v13 - v17;
      *(_DWORD *)(a1 + 92) = v18;
      uint64_t v15 = (v15 << v17) | (*(_DWORD *)(a1 + 96) >> v18) & ~(-1 << v17);
LABEL_10:
      *(void *)(a2 + 8 * v9) = v15;
      ++v12;
LABEL_11:
      if (++v9 == v6) {
        return v12;
      }
    }
  }
  return 0;
}

uint64_t sub_1DD27B60C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 112);
  uint64_t v2 = *(void *)(result + 216);
  int v3 = *(_DWORD *)(result + 100);
  uint64_t v4 = *(void *)(v2 + 8 * v1) >> v3;
  *(void *)(result + 128) = v4;
  uint64_t v5 = *(void *)(result + 144);
  uint64_t v6 = v5 & *(void *)(v2 + 8 * v1);
  *(void *)(result + 136) = v6;
  if (v4 == 255)
  {
    uint64_t v7 = 0;
    uint64_t v8 = v1 + 1;
    while (!v6)
    {
      v7 += 255;
      *(void *)(result + 152) = v7;
      *(void *)(result + 112) = v8;
      uint64_t v9 = *(void *)(v2 + 8 * v8) >> v3;
      *(void *)(result + 128) = v9;
      uint64_t v6 = *(void *)(v2 + 8 * v8) & v5;
      *(void *)(result + 136) = v6;
      ++v8;
      if (v9 != 255)
      {
        uint64_t v4 = v9;
        break;
      }
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  *(void *)(result + 152) = v7 + v4;
  return result;
}

uint64_t sub_1DD27B690(void *a1)
{
  *a1 = &unk_1F38794F0;
  sub_1DD270394((uint64_t)(a1 + 25));
  sub_1DD270394((uint64_t)(a1 + 20));
  uint64_t v2 = a1[1];
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return nullsub_1(a1);
}

void sub_1DD27B71C(void *a1)
{
  *a1 = &unk_1F38794F0;
  sub_1DD270394((uint64_t)(a1 + 25));
  sub_1DD270394((uint64_t)(a1 + 20));
  uint64_t v2 = a1[1];
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  int v3 = (void *)nullsub_1(a1);
  operator delete(v3);
}

uint64_t sub_1DD27B7AC(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, char a5, double a6)
{
  if (a6 > 1.0 || a6 <= 0.0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::to_string(&v21, a6);
    unint64_t v19 = std::string::insert(&v21, 0, "Invalid p value: ");
    long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v20;
    v19->__r_.__value_.__l.__size_ = 0;
    v19->__r_.__value_.__r.__words[2] = 0;
    v19->__r_.__value_.__r.__words[0] = 0;
    sub_1DD26D904(exception, &v22);
    __cxa_throw(exception, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if ((a5 & 1) == 0)
  {
    *(_OWORD *)(a1 + 200) = 0u;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 152) = 0u;
    *(_OWORD *)(a1 + 136) = 0u;
    *(_OWORD *)(a1 + 120) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    uint64_t v6 = a4 + a3;
    *(_OWORD *)(a1 + 88) = 0u;
    if (a4 + a3 > a3)
    {
      do
      {
        unint64_t v7 = *(void *)(a2 + 8 * a3);
        if ((v7 & 0x8000000000000000) != 0)
        {
          unint64_t v10 = &byte_1DD3205BA;
        }
        else
        {
          uint64_t v8 = 0;
          if (v7)
          {
            do
            {
              ++v8;
              BOOL v9 = v7 > 1;
              v7 >>= 1;
            }
            while (v9);
          }
          unint64_t v10 = &byte_1DD32057A[v8];
        }
        unint64_t v11 = *v10;
        if (v11 > 0x40) {
          uint64_t v12 = 31;
        }
        else {
          uint64_t v12 = byte_1DD3205FC[v11];
        }
        ++*(_DWORD *)(a1 + 4 * v12 + 88);
        ++a3;
      }
      while (a3 != v6);
    }
  }
  int v13 = (int)((1.0 - a6) * (double)a4);
  for (unsigned int i = 0x1Fu; ; --i)
  {
    unsigned int v15 = i;
    v13 -= *(_DWORD *)(a1 + 4 * i + 88);
    if (v13 < 0) {
      break;
    }
    if (!v15) {
      return 0;
    }
  }
  return byte_1DD32055A[i];
}

void sub_1DD27B968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1DD27B9C8(uint64_t a1, uint64_t *a2, char a3, char a4)
{
  uint64_t v5 = *a2;
  *a2 = 0;
  *(void *)(a1 + 8) = v5;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 48) = a3;
  *(void *)(a1 + 56) = 0;
  *(void *)a1 = &unk_1F3879580;
  *(unsigned char *)(a1 + 64) = a4;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 40) = operator new[](0x1000uLL);
  *(void *)(a1 + 216) = operator new[](0x1000uLL);
  *(void *)(a1 + 224) = operator new[](0x1000uLL);
  *(void *)(a1 + 232) = operator new[](0x1000uLL);
  *(void *)(a1 + 240) = operator new[](0x1000uLL);
  return a1;
}

void sub_1DD27BA64(_Unwind_Exception *a1)
{
  sub_1DD27D340(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27BA7C(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 32);
  if (v4 == 1)
  {
    unint64_t v7 = *(void **)(result + 40);
    *(void *)(result + 80) = a2 - *v7;
    *(void *)(result + 32) = 2;
    v7[1] = a2;
    if (*v7 == a2) {
      uint64_t v6 = 2;
    }
    else {
      uint64_t v6 = 0x200000000;
    }
    goto LABEL_12;
  }
  if (!v4)
  {
    uint64_t v5 = *(void **)(result + 40);
    *(void *)(result + 32) = 1;
    *uint64_t v5 = a2;
LABEL_4:
    uint64_t v6 = 0x100000001;
LABEL_12:
    *(void *)(v3 + 68) = v6;
    return result;
  }
  uint64_t v8 = *(void *)(result + 40);
  uint64_t v9 = *(void *)(v8 + 8 * v4 - 8);
  long long v18 = 0u;
  memset(v17, 0, sizeof(v17));
  if (*(void *)(result + 80) || v9 != a2)
  {
    unsigned int v13 = *(_DWORD *)(result + 68);
    if (v13 >= 3)
    {
      if (v13 >= 0xB)
      {
        BYTE8(v18) = 1;
        int v14 = 3;
      }
      else
      {
        int v14 = 0;
      }
      LODWORD(v17[0]) = v14;
      unint64_t result = sub_1DD27C24C(result, v17);
      unsigned int v13 = *(_DWORD *)(v3 + 68);
      uint64_t v4 = *(void *)(v3 + 32);
    }
    if (v13 - 1 <= 1 && *(void *)(*(void *)(v3 + 40) + 8 * v4 - 8) != a2)
    {
      *(_DWORD *)(v3 + 68) = 0;
      *(_DWORD *)(v3 + 72) = v13;
    }
    unsigned int v15 = *(void **)(v3 + 40);
    if (!v4)
    {
      *(void *)(v3 + 32) = 1;
      *unsigned int v15 = a2;
      goto LABEL_4;
    }
    int v16 = &v15[v4];
    *(void *)(v3 + 80) = a2 - *(v16 - 1);
    *(void *)(v3 + 32) = v4 + 1;
    *int v16 = a2;
    int v12 = *(_DWORD *)(v3 + 72) + 1;
    *(_DWORD *)(v3 + 72) = v12;
  }
  else
  {
    *(void *)(result + 32) = v4 + 1;
    *(void *)(v8 + 8 * v4) = a2;
    int v10 = *(_DWORD *)(result + 72);
    if (v10)
    {
      *(void *)(result + 32) = v4 - 2;
      *(_DWORD *)(result + 68) = 3;
      *(_DWORD *)(result + 72) = v10 - 2;
      sub_1DD27BC74((void *)result, (uint64_t)v17);
      unint64_t result = sub_1DD27C24C(v3, v17);
      unint64_t v11 = *(void **)(v3 + 40);
      void *v11 = a2;
      v11[1] = a2;
      void v11[2] = a2;
      *(void *)(v3 + 32) = 3;
      int v12 = *(_DWORD *)(v3 + 68);
    }
    else
    {
      int v12 = *(_DWORD *)(result + 68) + 1;
      *(_DWORD *)(result + 68) = v12;
    }
  }
  if (v12 == 512)
  {
    sub_1DD27BC74((void *)v3, (uint64_t)v17);
    return sub_1DD27C24C(v3, v17);
  }
  return result;
}

void sub_1DD27BC74(void *a1, uint64_t a2)
{
  unint64_t v4 = a1[4];
  if (v4 <= 3) {
    goto LABEL_15;
  }
  unint64_t v5 = 0;
  unint64_t v6 = 0;
  LOBYTE(v7) = 1;
  *(unsigned char *)(a2 + 88) = 1;
  uint64_t v8 = (uint64_t *)a1[5];
  *(void *)(a2 + 80) = *v8;
  uint64_t v9 = *v8;
  uint64_t v10 = v8[1];
  uint64_t v11 = v10 - *v8;
  uint64_t v12 = a1[30];
  uint64_t v13 = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = v13 + 1;
  *(void *)(v12 + 8 * v13) = v11;
  unint64_t v14 = v4 - 1;
  LOBYTE(v4) = 1;
  uint64_t v15 = v9;
  LOBYTE(v16) = 1;
  do
  {
    unint64_t v17 = v5 + 1;
    uint64_t v19 = v8[v5];
    uint64_t v18 = v8[v5 + 1];
    uint64_t v20 = *(void *)(a2 + 80);
    if (v18 < v20) {
      uint64_t v20 = v8[v5 + 1];
    }
    if (v15 <= v18) {
      uint64_t v15 = v8[v5 + 1];
    }
    uint64_t v21 = v18 - v19;
    *(void *)(a2 + 80) = v20;
    if (v17 >= 2)
    {
      if (v21 < 0) {
        uint64_t v21 = v19 - v18;
      }
      uint64_t v22 = *(void *)(a2 + 40);
      *(void *)(a2 + 40) = v22 + 1;
      *(void *)(v12 + 8 * v22) = v21;
      int64_t v23 = *(void *)(v12 + 8 * v5);
      if ((uint64_t)v6 <= v23) {
        unint64_t v6 = v23;
      }
    }
    int v7 = v7 & (v18 >= v19);
    LODWORD(v4) = v4 & (v18 <= v19);
    int v16 = (v18 - v19 == v11) & v16;
    unint64_t v5 = v17;
  }
  while (v14 != v17);
  *(unsigned char *)(a2 + 88) = v16;
  uint64_t v24 = *(void *)(a2 + 80);
  if ((v24 ^ v15) < 0 && ((v15 - v24) ^ v15) < 0)
  {
LABEL_15:
    sub_1DD27C330((uint64_t)a1, a2);
    *(_DWORD *)(a2 + 52) = sub_1DD27B7AC((uint64_t)a1, a1[28], 0, a1[4], 0, 1.0);
LABEL_16:
    int v25 = 1;
LABEL_17:
    *(_DWORD *)a2 = v25;
    return;
  }
  if (v15 == v24)
  {
    if ((v16 & 1) == 0)
    {
      uint64_t v45 = v15;
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      uint64_t v47 = a2;
      unint64_t v48 = exception;
      std::to_string(&v70, *(void *)(v47 + 80));
      uint64_t v49 = std::string::append(&v70, "==");
      long long v50 = *(_OWORD *)&v49->__r_.__value_.__l.__data_;
      v71.__r_.__value_.__r.__words[2] = v49->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v50;
      v49->__r_.__value_.__l.__size_ = 0;
      v49->__r_.__value_.__r.__words[2] = 0;
      v49->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v69, v45);
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        long long v51 = &v69;
      }
      else {
        long long v51 = (std::string *)v69.__r_.__value_.__r.__words[0];
      }
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type size = HIBYTE(v69.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type size = v69.__r_.__value_.__l.__size_;
      }
      unint64_t v53 = std::string::append(&v71, (const std::string::value_type *)v51, size);
      long long v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
      v72.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v72.__r_.__value_.__l.__data_ = v54;
      v53->__r_.__value_.__l.__size_ = 0;
      v53->__r_.__value_.__r.__words[2] = 0;
      v53->__r_.__value_.__r.__words[0] = 0;
      int v55 = std::string::append(&v72, ", isFixedDelta cannot be false");
      long long v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
      v73.__r_.__value_.__r.__words[2] = v55->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v56;
      v55->__r_.__value_.__l.__size_ = 0;
      v55->__r_.__value_.__r.__words[2] = 0;
      v55->__r_.__value_.__r.__words[0] = 0;
      sub_1DD26D904(v48, &v73);
      __cxa_throw(v48, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    if (v18 != v19)
    {
      uint64_t v57 = v15;
      uint64_t v58 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      uint64_t v59 = a2;
      std::string v60 = v58;
      std::to_string(&v70, *(void *)(v59 + 80));
      int v61 = std::string::append(&v70, "==");
      long long v62 = *(_OWORD *)&v61->__r_.__value_.__l.__data_;
      v71.__r_.__value_.__r.__words[2] = v61->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v62;
      v61->__r_.__value_.__l.__size_ = 0;
      v61->__r_.__value_.__r.__words[2] = 0;
      v61->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v69, v57);
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v63 = &v69;
      }
      else {
        uint64_t v63 = (std::string *)v69.__r_.__value_.__r.__words[0];
      }
      if ((v69.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v64 = HIBYTE(v69.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v64 = v69.__r_.__value_.__l.__size_;
      }
      uint64_t v65 = std::string::append(&v71, (const std::string::value_type *)v63, v64);
      long long v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
      v72.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v72.__r_.__value_.__l.__data_ = v66;
      v65->__r_.__value_.__l.__size_ = 0;
      v65->__r_.__value_.__r.__words[2] = 0;
      v65->__r_.__value_.__r.__words[0] = 0;
      uint64_t v67 = std::string::append(&v72, ", currDelta should be zero");
      long long v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
      v73.__r_.__value_.__r.__words[2] = v67->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v73.__r_.__value_.__l.__data_ = v68;
      v67->__r_.__value_.__l.__size_ = 0;
      v67->__r_.__value_.__r.__words[2] = 0;
      v67->__r_.__value_.__r.__words[0] = 0;
      sub_1DD26D904(v60, &v73);
      __cxa_throw(v60, (struct type_info *)&unk_1F38780E8, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    *(void *)(a2 + 8) = 0;
LABEL_22:
    int v25 = 3;
    goto LABEL_17;
  }
  if (v16)
  {
    *(_DWORD *)a2 = 3;
    *(void *)(a2 + 8) = v11;
  }
  else
  {
    if (v10 != v9)
    {
      uint64_t v26 = 0;
      if (v6)
      {
        do
        {
          ++v26;
          BOOL v27 = v6 > 1;
          v6 >>= 1;
        }
        while (v27);
      }
      *(_DWORD *)(a2 + 64) = byte_1DD32057A[v26];
      if ((v7 | v4) == 1) {
        goto LABEL_22;
      }
    }
    sub_1DD27C330((uint64_t)a1, a2);
    int v28 = sub_1DD27B7AC((uint64_t)a1, a1[28], 0, a1[4], 0, 1.0);
    *(_DWORD *)(a2 + 52) = v28;
    unint64_t v29 = a1[4];
    int v30 = (int)((double)v29 * 0.1);
    unsigned int v31 = 0x1Fu;
    while (1)
    {
      unsigned int v32 = v31;
      v30 -= *((_DWORD *)a1 + v31 + 22);
      if (v30 < 0) {
        break;
      }
      --v31;
      if (!v32)
      {
        int v33 = 0;
        goto LABEL_34;
      }
    }
    int v33 = byte_1DD32055A[v31];
LABEL_34:
    *(_DWORD *)(a2 + 48) = v33;
    if ((v28 - v33) < 2) {
      goto LABEL_16;
    }
    if (v29)
    {
      uint64_t v34 = (uint64_t *)a1[5];
      uint64_t v35 = a1[29];
      unint64_t v36 = v29;
      do
      {
        uint64_t v37 = *v34++;
        uint64_t v38 = v37 - *(void *)(a2 + 80);
        uint64_t v39 = *(void *)(a2 + 32);
        *(void *)(a2 + 32) = v39 + 1;
        *(void *)(v35 + 8 * v39) = v38;
        --v36;
      }
      while (v36);
    }
    else
    {
      uint64_t v35 = a1[29];
    }
    int v40 = sub_1DD27B7AC((uint64_t)a1, v35, 0, v29, 0, 0.95);
    int v41 = 0;
    *(_DWORD *)(a2 + 56) = v40;
    unsigned int v42 = 0x1Fu;
    while (1)
    {
      unsigned int v43 = v42;
      v41 -= *((_DWORD *)a1 + v42 + 22);
      if (v41 < 0) {
        break;
      }
      --v42;
      if (!v43)
      {
        int v44 = 0;
        goto LABEL_45;
      }
    }
    int v44 = byte_1DD32055A[v42];
LABEL_45:
    *(_DWORD *)(a2 + 60) = v44;
    if (v44 == v40) {
      goto LABEL_16;
    }
    *(_DWORD *)a2 = 2;
    sub_1DD27C374(a1, a2);
  }
}

void sub_1DD27C188(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (*(char *)(v35 - 57) < 0) {
    operator delete(*(void **)(v35 - 80));
  }
  if (a33 < 0) {
    operator delete(__p);
  }
  if (a14 < 0) {
    operator delete(a9);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  if (v34) {
    __cxa_free_exception(v33);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD27C24C(uint64_t result, _DWORD *a2)
{
  if (*(void *)(result + 32))
  {
    uint64_t v2 = result;
    switch(*a2)
    {
      case 0:
        unint64_t result = sub_1DD27C880(result);
        break;
      case 1:
        unint64_t result = sub_1DD27C9B0(result, (uint64_t)a2);
        break;
      case 2:
        unint64_t result = sub_1DD27CAA8(result, (uint64_t)a2);
        break;
      case 3:
        unint64_t result = sub_1DD27CD2C(result, (uint64_t)a2);
        break;
      default:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26D80C(exception, "Not implemented yet");
        __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
    }
    *(void *)(v2 + 32) = 0;
    *(void *)(v2 + 80) = 0;
  }
  return result;
}

void sub_1DD27C30C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27C330(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (v2)
  {
    int v3 = *(unsigned __int8 *)(result + 48);
    uint64_t v4 = *(void *)(result + 224);
    unint64_t v5 = *(uint64_t **)(result + 40);
    do
    {
      uint64_t v7 = *v5++;
      uint64_t v6 = v7;
      uint64_t v8 = (2 * v7) ^ (v7 >> 63);
      if (v3) {
        uint64_t v6 = v8;
      }
      uint64_t v9 = *(void *)(a2 + 24);
      *(void *)(a2 + 24) = v9 + 1;
      *(void *)(v4 + 8 * v9) = v6;
      --v2;
    }
    while (v2);
  }
  return result;
}

void sub_1DD27C374(void *a1, uint64_t a2)
{
  unint64_t v4 = a1[4];
  *(_DWORD *)(a2 + 76) = v4 / 0x14;
  int v5 = *(_DWORD *)(a2 + 56);
  unsigned int v6 = *(_DWORD *)(a2 + 60) - v5;
  *(_DWORD *)(a2 + 68) = v6;
  if (v6 >= 0x41)
  {
    *(_DWORD *)(a2 + 68) = 64;
  }
  else
  {
    int v7 = byte_1DD32057A[v6];
    *(_DWORD *)(a2 + 68) = v7;
    if (v7 != 64)
    {
      uint64_t v8 = ~(-1 << v5);
      goto LABEL_6;
    }
  }
  *(_DWORD *)(a2 + 68) = 56;
  *(_DWORD *)(a2 + 56) = 8;
  uint64_t v8 = 255;
LABEL_6:
  std::string __p = 0;
  long long v56 = 0;
  uint64_t v57 = 0;
  uint64_t v52 = 0;
  unint64_t v53 = 0;
  long long v54 = 0;
  if (!v4)
  {
    unint64_t v10 = 0;
    unsigned int v12 = 0;
    *(_DWORD *)(a2 + 76) = 0;
LABEL_53:
    uint64_t v39 = &byte_1DD32057A[v4];
    goto LABEL_54;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  unsigned int v12 = 0;
  uint64_t v13 = a1[29];
  do
  {
    if (*(void *)(v13 + 8 * v9) > v8)
    {
      unint64_t v14 = v9 - v11;
      if (v9 - v11 > v10) {
        unint64_t v10 = v9 - v11;
      }
      uint64_t v15 = v56;
      if (v56 >= v57)
      {
        unint64_t v17 = (char *)__p;
        uint64_t v18 = (v56 - (unsigned char *)__p) >> 3;
        unint64_t v19 = v18 + 1;
        if ((unint64_t)(v18 + 1) >> 61) {
          sub_1DD251DAC();
        }
        uint64_t v20 = v57 - (unsigned char *)__p;
        if ((v57 - (unsigned char *)__p) >> 2 > v19) {
          unint64_t v19 = v20 >> 2;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v21 = v19;
        }
        if (v21)
        {
          uint64_t v22 = (char *)sub_1DD251DC4((uint64_t)&v57, v21);
          unint64_t v17 = (char *)__p;
          uint64_t v15 = v56;
        }
        else
        {
          uint64_t v22 = 0;
        }
        int64_t v23 = &v22[8 * v18];
        *(void *)int64_t v23 = v14;
        int v16 = v23 + 8;
        while (v15 != v17)
        {
          uint64_t v24 = *((void *)v15 - 1);
          v15 -= 8;
          *((void *)v23 - 1) = v24;
          v23 -= 8;
        }
        std::string __p = v23;
        long long v56 = v16;
        uint64_t v57 = &v22[8 * v21];
        if (v17) {
          operator delete(v17);
        }
      }
      else
      {
        *(void *)long long v56 = v14;
        int v16 = v15 + 8;
      }
      long long v56 = v16;
      uint64_t v25 = *(uint64_t *)(a1[29] + 8 * v9) >> *(_DWORD *)(a2 + 56);
      uint64_t v26 = v53;
      if (v53 >= v54)
      {
        int v28 = v52;
        uint64_t v29 = v53 - v52;
        unint64_t v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 61) {
          sub_1DD251DAC();
        }
        uint64_t v31 = (char *)v54 - (char *)v52;
        if (((char *)v54 - (char *)v52) >> 2 > v30) {
          unint64_t v30 = v31 >> 2;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v30;
        }
        if (v32)
        {
          int v33 = (char *)sub_1DD251DC4((uint64_t)&v54, v32);
          int v28 = v52;
          uint64_t v26 = v53;
        }
        else
        {
          int v33 = 0;
        }
        char v34 = (uint64_t *)&v33[8 * v29];
        *char v34 = v25;
        BOOL v27 = v34 + 1;
        while (v26 != v28)
        {
          uint64_t v35 = *--v26;
          *--char v34 = v35;
        }
        uint64_t v52 = v34;
        long long v54 = (uint64_t *)&v33[8 * v32];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *unint64_t v53 = v25;
        BOOL v27 = v53 + 1;
      }
      unint64_t v53 = v27;
      uint64_t v13 = a1[29];
      ++v12;
      *(void *)(v13 + 8 * v9) &= v8;
      unint64_t v4 = a1[4];
      unint64_t v11 = v9;
    }
    ++v9;
  }
  while (v9 < v4);
  *(_DWORD *)(a2 + 76) = v12;
  if (!v10 && v12)
  {
    *(_DWORD *)(a2 + 72) = 1;
    unint64_t v36 = v52;
LABEL_60:
    unint64_t v42 = 0;
    int v43 = 0;
    int v44 = __p;
    int v45 = *(_DWORD *)(a2 + 68);
    uint64_t v46 = a1[27];
    do
    {
      uint64_t v47 = v44[v43];
      uint64_t v48 = v36[v43];
      if (v47 < 256)
      {
        uint64_t v50 = v44[v43];
      }
      else
      {
        do
        {
          uint64_t v49 = *(void *)(a2 + 16);
          *(void *)(a2 + 16) = v49 + 1;
          *(void *)(v46 + 8 * v49) = 255 << v45;
          ++v42;
          uint64_t v50 = v47 - 255;
          BOOL v38 = (unint64_t)v47 > 0x1FE;
          v47 -= 255;
        }
        while (v38);
      }
      ++v43;
      uint64_t v51 = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v51 + 1;
      *(void *)(v46 + 8 * v51) = (v50 << v45) | v48;
      ++v42;
    }
    while (v42 < v12);
    unint64_t v36 = v52;
    goto LABEL_67;
  }
  if ((v10 & 0x8000000000000000) == 0)
  {
    unint64_t v4 = 0;
    if (v10)
    {
      unint64_t v37 = v10;
      do
      {
        ++v4;
        BOOL v38 = v37 > 1;
        v37 >>= 1;
      }
      while (v38);
    }
    goto LABEL_53;
  }
  uint64_t v39 = &byte_1DD3205BA;
LABEL_54:
  unsigned int v40 = *v39;
  *(_DWORD *)(a2 + 72) = v40;
  if (v40 > 8)
  {
    if (v10 == 511) {
      int v41 = 2;
    }
    else {
      int v41 = 1;
    }
    v12 += v41;
    *(_DWORD *)(a2 + 72) = 8;
    *(_DWORD *)(a2 + 76) = v12;
  }
  unint64_t v36 = v52;
  if (v12) {
    goto LABEL_60;
  }
LABEL_67:
  if (v36) {
    operator delete(v36);
  }
  if (__p)
  {
    long long v56 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1DD27C754(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p) {
    operator delete(__p);
  }
  if (a14) {
    operator delete(a14);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD27C78C(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    long long v5 = 0u;
    memset(v4, 0, sizeof(v4));
    if (!*(_DWORD *)(a1 + 72))
    {
      unsigned int v3 = *(_DWORD *)(a1 + 68);
      if (!v3) {
        goto LABEL_5;
      }
      if (v3 > 2)
      {
        if (v3 >= 0xB)
        {
          LODWORD(v4[0]) = 3;
          BYTE8(v5) = 1;
        }
        goto LABEL_4;
      }
      *(_DWORD *)(a1 + 68) = 0;
      *(_DWORD *)(a1 + 72) = v3;
    }
    sub_1DD27BC74((void *)a1, (uint64_t)v4);
LABEL_4:
    sub_1DD27C24C(a1, v4);
  }
LABEL_5:
  (*(void (**)(void, void))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), (*(_DWORD *)(a1 + 24) - *(_DWORD *)(a1 + 16)));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t sub_1DD27C880(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48)) {
    uint64_t v2 = (2 * **(void **)(a1 + 40)) ^ (**(uint64_t **)(a1 + 40) >> 63);
  }
  else {
    uint64_t v2 = **(void **)(a1 + 40);
  }
  if (v2 < 0)
  {
    unsigned int v6 = &byte_1DD3205BA;
  }
  else
  {
    uint64_t v3 = 0;
    if (v2)
    {
      unint64_t v4 = v2;
      do
      {
        ++v3;
        BOOL v5 = v4 > 1;
        v4 >>= 1;
      }
      while (v5);
    }
    unsigned int v6 = &byte_1DD32057A[v3];
  }
  unsigned int v7 = *v6;
  BOOL v8 = (v7 & 7) == 0;
  unsigned int v9 = v7 >> 3;
  if ((v7 & 7) != 0) {
    int v10 = 0;
  }
  else {
    int v10 = -1;
  }
  int v11 = (__PAIR64__(v9, v7 & 7) - 1) >> 32;
  int v12 = *(_DWORD *)(a1 + 68) - 3;
  *(_DWORD *)(a1 + 68) = v12;
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)(v12 | (8 * (v9 - v8))));
  if ((v11 & 0x80000000) == 0)
  {
    int v14 = 8 * v11;
    int v15 = v9 + v10 + 1;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)(v2 >> (v14 & 0xF8)));
      v14 -= 8;
      --v15;
    }
    while (v15 > 0);
  }
  *(_DWORD *)(a1 + 68) = 0;
  return result;
}

uint64_t sub_1DD27C9B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 52);
  if (*(unsigned char *)(a1 + 64))
  {
    if (v3 > 0x40)
    {
      LODWORD(v3) = 0x40u;
      goto LABEL_7;
    }
    LODWORD(v3) = byte_1DD3205BB[v3];
  }
  if (v3 <= 0x40)
  {
LABEL_7:
    char v4 = (2 * byte_1DD3205FC[v3]) | 0x40;
    goto LABEL_8;
  }
  char v4 = 126;
LABEL_8:
  int v5 = *(_DWORD *)(a1 + 72) - 1;
  *(_DWORD *)(a1 + 72) = v5;
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (BYTE1(v5) & 1 | v4));
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)v5);
  uint64_t result = sub_1DD27CF54(a1, *(void *)(a1 + 224), 0, *(void *)(a1 + 32), v3);
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t sub_1DD27CAA8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 56);
  if (v4 > 0x40) {
    char v5 = -66;
  }
  else {
    char v5 = (2 * byte_1DD3205FC[v4]) | 0x80;
  }
  int v6 = *(_DWORD *)(a1 + 72) - 1;
  *(_DWORD *)(a1 + 72) = v6;
  uint64_t v7 = *(void *)(a2 + 80);
  if (v7 < 0)
  {
    unint64_t v8 = -v7;
    *(void *)(a2 + 80) = -v7;
LABEL_8:
    uint64_t v9 = 0;
    unint64_t v10 = v8;
    do
    {
      ++v9;
      BOOL v11 = v10 > 1;
      v10 >>= 1;
    }
    while (v11);
    goto LABEL_10;
  }
  unint64_t v8 = *(void *)(a2 + 80);
  if (v7) {
    goto LABEL_8;
  }
  uint64_t v9 = 0;
LABEL_10:
  unsigned int v12 = byte_1DD32057A[v9] + 1;
  BOOL v13 = (v12 & 7) == 0;
  unsigned int v14 = v12 >> 3;
  if (v13) {
    int v15 = v14;
  }
  else {
    int v15 = v14 + 1;
  }
  int v16 = v15 - 1;
  if (v7 < 0) {
    *(void *)(a2 + 80) = (1 << (8 * v15 - 1)) | v8;
  }
  char v17 = BYTE1(v6) & 1 | v5;
  uint64_t v18 = *(unsigned int *)(a2 + 68);
  if (v18 > 0x40) {
    unsigned __int8 v19 = 31;
  }
  else {
    unsigned __int8 v19 = byte_1DD3205FC[v18];
  }
  char v20 = v19 | (32 * v16);
  int v21 = (32 * *(_DWORD *)(a2 + 72) + 224) | *(_DWORD *)(a2 + 76);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v17);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)v6);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v20);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)v21);
  if (v15)
  {
    int v22 = 8 * v16;
    do
    {
      (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (char)(*(uint64_t *)(a2 + 80) >> (v22 & 0xF8)));
      v22 -= 8;
      BOOL v23 = __OFSUB__(v15--, 1);
    }
    while (!((v15 < 0) ^ v23 | (v15 == 0)));
  }
  uint64_t v24 = *(unsigned int *)(a2 + 56);
  if (v24 > 0x40) {
    unsigned int v25 = 64;
  }
  else {
    unsigned int v25 = byte_1DD32057A[v24];
  }
  sub_1DD27CF54(a1, *(void *)(a1 + 232), 0, *(void *)(a1 + 32), v25);
  unsigned int v26 = *(_DWORD *)(a2 + 68) + *(_DWORD *)(a2 + 72);
  if (v26 > 0x40) {
    unsigned int v27 = 64;
  }
  else {
    unsigned int v27 = byte_1DD32057A[v26];
  }
  uint64_t result = sub_1DD27CF54(a1, *(void *)(a1 + 216), 0, *(unsigned int *)(a2 + 76), v27);
  *(_DWORD *)(a1 + 72) = 0;
  return result;
}

uint64_t sub_1DD27CD2C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a2 + 64);
  if (*(unsigned char *)(a1 + 64))
  {
    if (v4 > 0x40) {
      LODWORD(v4) = 64;
    }
    else {
      LODWORD(v4) = byte_1DD3205BB[v4];
    }
  }
  if (*(unsigned char *)(a2 + 88))
  {
    unsigned int v5 = *(_DWORD *)(a1 + 68);
    if (v5 < 4)
    {
      unsigned int v5 = *(_DWORD *)(a1 + 72);
      *(_DWORD *)(a1 + 72) = 0;
    }
    else
    {
      *(_DWORD *)(a1 + 68) = 0;
    }
    char v6 = -64;
  }
  else
  {
    if (v4 == 1) {
      LODWORD(v4) = 2;
    }
    if (v4 > 0x40) {
      char v6 = -2;
    }
    else {
      char v6 = (2 * byte_1DD3205FC[v4]) | 0xC0;
    }
    unsigned int v5 = *(_DWORD *)(a1 + 72);
    *(_DWORD *)(a1 + 72) = 0;
  }
  char v7 = v5 - 1;
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, (((unsigned __int16)(v5 - 1) >> 8) & 1 | v6));
  (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v7);
  uint64_t v8 = **(void **)(a1 + 40);
  uint64_t v9 = *(void *)a1;
  if (*(unsigned char *)(a1 + 48)) {
    (*(void (**)(uint64_t, uint64_t))(v9 + 64))(a1, v8);
  }
  else {
    (*(void (**)(uint64_t, uint64_t))(v9 + 56))(a1, v8);
  }
  if (*(unsigned char *)(a2 + 88))
  {
    uint64_t v10 = *(void *)(a2 + 8);
    BOOL v11 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64);
    return v11(a1, v10);
  }
  else
  {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 64))(a1, **(void **)(a1 + 240));
    uint64_t v13 = *(void *)(a1 + 240);
    unint64_t v14 = *(void *)(a1 + 32) - 2;
    return sub_1DD27CF54(a1, v13, 1u, v14, v4);
  }
}

uint64_t sub_1DD27CF54(uint64_t result, uint64_t a2, unsigned int a3, unint64_t a4, unsigned int a5)
{
  if (!a2 || !a4 || !a5) {
    return result;
  }
  unsigned int v6 = a3;
  uint64_t v8 = result;
  if (a5 > 0x40) {
    int v9 = 64;
  }
  else {
    int v9 = byte_1DD3205BB[a5];
  }
  if (v9 == a5)
  {
    unint64_t v10 = a4 + a3;
    if (a5 > 7)
    {
      if (v10 > a3)
      {
        uint64_t v28 = a3;
        uint64_t v29 = 8 * (a5 >> 3);
        do
        {
          uint64_t v30 = v29;
          do
          {
            v30 -= 8;
            uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48))(v8, (char)(*(uint64_t *)(a2 + 8 * v28) >> v30));
          }
          while (v30);
          ++v28;
        }
        while (v28 != v10);
      }
    }
    else
    {
      int v33 = ~(-1 << a5);
      unint64_t v11 = 8u / a5;
      unsigned int v34 = a4 % v11;
      unint64_t v12 = v10 - v34;
      if (v12 > a3)
      {
        if (v11 <= 1) {
          uint64_t v13 = 1;
        }
        else {
          uint64_t v13 = v11;
        }
        unsigned int v14 = 8 - a5;
        do
        {
          uint64_t v15 = 0;
          char v16 = 0;
          uint64_t v17 = v13;
          unsigned int v18 = v14;
          do
          {
            uint64_t v19 = *(void *)(a2 + 8 * (v6 + v15++)) & v33;
            v16 |= v19 << v18;
            v18 -= a5;
            --v17;
          }
          while (v17);
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48))(v8, v16);
          v6 += v11;
        }
        while (v6 < v12);
      }
      if (v34)
      {
        if (v10 >= v34)
        {
          LOBYTE(v20) = 0;
          unsigned int v31 = 8 - a5;
          do
          {
            LOBYTE(v20) = v20 | ((unint64_t)(*(void *)(a2 + 8 * v12++) & v33) << v31);
            v31 -= a5;
          }
          while (v12 < v10);
        }
        else
        {
          LOBYTE(v20) = 0;
        }
LABEL_40:
        unint64_t v32 = *(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48);
        return v32(v8, (char)v20);
      }
    }
  }
  else
  {
    unint64_t v21 = a4 + a3;
    if (v21 > a3)
    {
      int v20 = 0;
      unsigned int v22 = 8;
      uint64_t v23 = a3;
      do
      {
        uint64_t v24 = *(void *)(a2 + 8 * v23);
        if (v22 >= a5)
        {
          int v27 = v20;
          unsigned int v25 = a5;
        }
        else
        {
          unsigned int v25 = a5;
          do
          {
            v25 -= v22;
            char v26 = v20 | (v24 >> v25);
            v24 &= ~(-1 << v25);
            uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48))(v8, v26);
            LOBYTE(v20) = 0;
            int v27 = 0;
            unsigned int v22 = 8;
          }
          while (v25 > 8);
        }
        v22 -= v25;
        int v20 = v27 | (v24 << v22);
        if (!v22)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v8 + 48))(v8, (char)v20);
          int v20 = 0;
          unsigned int v22 = 8;
        }
        uint64_t v23 = ++v6;
      }
      while (v21 > v6);
      if (v22 != 8) {
        goto LABEL_40;
      }
    }
  }
  return result;
}

void sub_1DD27D28C(void *a1)
{
  uint64_t v1 = sub_1DD27D2B4(a1);
  operator delete(v1);
}

void *sub_1DD27D2B4(void *a1)
{
  *a1 = &unk_1F3879580;
  uint64_t v2 = (void *)a1[5];
  if (v2) {
    operator delete[](v2);
  }
  uint64_t v3 = (void *)a1[27];
  if (v3) {
    operator delete[](v3);
  }
  uint64_t v4 = (void *)a1[28];
  if (v4) {
    operator delete[](v4);
  }
  unsigned int v5 = (void *)a1[29];
  if (v5) {
    operator delete[](v5);
  }
  unsigned int v6 = (void *)a1[30];
  if (v6) {
    operator delete[](v6);
  }
  return sub_1DD27D340(a1);
}

void *sub_1DD27D340(void *a1)
{
  uint64_t v2 = a1[1];
  *a1 = &unk_1F3879350;
  a1[1] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

uint64_t sub_1DD27D3B4@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X4>, void *a5@<X8>)
{
  if (a3 == 1)
  {
    unint64_t v12 = operator new(0xF8uLL);
    uint64_t v13 = *a1;
    *a1 = 0;
    uint64_t v15 = v13;
    sub_1DD27BA78(v12, &v15, a2, a4);
    *a5 = v12;
    uint64_t result = v15;
    uint64_t v15 = 0;
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  if (a3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D80C(exception, "Not implemented yet");
    __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
  uint64_t v8 = operator new(0x58uLL);
  uint64_t v9 = *a1;
  *a1 = 0;
  uint64_t v16 = v9;
  sub_1DD279B58(v8, &v16, a2);
  *a5 = v8;
  uint64_t result = v16;
  uint64_t v16 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void sub_1DD27D4D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27D51C@<X0>(uint64_t *a1@<X0>, char a2@<W1>, int a3@<W2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  if (a3 == 1)
  {
    uint64_t v13 = operator new(0xF0uLL);
    uint64_t v14 = *a1;
    *a1 = 0;
    uint64_t v16 = v14;
    sub_1DD27A9CC((uint64_t)v13, &v16, a2, a4);
    *a5 = v13;
    uint64_t result = v16;
    uint64_t v16 = 0;
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 8))(result, v10);
  }
  if (a3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D80C(exception, "Not implemented yet");
    __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
  uint64_t v8 = operator new(0x48uLL);
  uint64_t v9 = *a1;
  *a1 = 0;
  uint64_t v17 = v9;
  v10.n128_f64[0] = sub_1DD279F54((uint64_t)v8, &v17, a2);
  *a5 = v8;
  uint64_t result = v17;
  uint64_t v17 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t, __n128))(*(void *)result + 8))(result, v10);
  }
  return result;
}

void sub_1DD27D638(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27D684(uint64_t result, void *a2, uint64_t a3, unsigned char *a4)
{
  if (a3)
  {
    uint64_t v5 = a3;
    uint64_t v7 = result;
    uint64_t v8 = a4;
    do
    {
      if (!a4 || *v8) {
        uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)v7 + 40))(v7, *a2);
      }
      ++a2;
      ++v8;
      --v5;
    }
    while (v5);
  }
  return result;
}

uint64_t sub_1DD27D714(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, (2 * a2) ^ (a2 >> 63));
}

uint64_t sub_1DD27D740(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = a2;
  if (a2 >= 0x80)
  {
    do
    {
      (*(void (**)(uint64_t, void))(*(void *)a1 + 48))(a1, v2 | 0xFFFFFF80);
      unint64_t v4 = v2 >> 7;
      BOOL v5 = v2 >= 0x4000;
      v2 >>= 7;
    }
    while (v5);
  }
  else
  {
    LOBYTE(v4) = a2;
  }
  unsigned int v6 = *(uint64_t (**)(uint64_t, void))(*(void *)a1 + 48);
  return v6(a1, (char)v4);
}

uint64_t sub_1DD27D7E8(uint64_t result, char a2)
{
  uint64_t v3 = (void *)result;
  uint64_t v4 = *(void *)(result + 16);
  if (v4 == *(void *)(result + 24))
  {
    int v8 = 0;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, int *))(**(void **)(result + 8) + 16))(*(void *)(result + 8), result + 56, &v8);
    if ((result & 1) == 0)
    {
      exception = (std::bad_alloc *)__cxa_allocate_exception(8uLL);
      uint64_t v7 = std::bad_alloc::bad_alloc(exception);
      __cxa_throw(v7, MEMORY[0x1E4FBA360], MEMORY[0x1E4FBA2C0]);
    }
    uint64_t v4 = 0;
    v3[3] = v8;
  }
  uint64_t v5 = v3[7];
  v3[2] = v4 + 1;
  *(unsigned char *)(v5 + v4) = a2;
  return result;
}

uint64_t sub_1DD27D89C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  uint64_t v5 = *(void *)(a1 + 16);
  if ((*(unsigned int (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8))) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v4);
  }
  else {
    uint64_t v5 = v5 + v4 - *(void *)(a1 + 24);
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v5);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16);
  return v7(a2, v6);
}

void *sub_1DD27D9C8(uint64_t a1, unsigned char *a2)
{
  int v3 = *(_DWORD *)(a1 + 16);
  if (v3)
  {
    uint64_t v6 = operator new(0x40uLL);
    sub_1DD27ED94((uint64_t)v6, a1);
  }
  else if ((v3 & 2) != 0)
  {
    uint64_t v6 = operator new(0x40uLL);
    sub_1DD27ECE4((uint64_t)v6, a1);
  }
  else if ((v3 & 4) != 0)
  {
    uint64_t v6 = operator new(0x70uLL);
    sub_1DD27EE44((uint64_t)v6, a1, a2);
  }
  else if ((v3 & 8) != 0)
  {
    uint64_t v6 = operator new(0x40uLL);
    sub_1DD27EA80((uint64_t)v6, a1, a2);
  }
  else if ((v3 & 0x10) != 0)
  {
    uint64_t v6 = operator new(0x70uLL);
    sub_1DD27EBC0((uint64_t)v6, a1, a2);
  }
  else if ((v3 & 0x80) != 0)
  {
    uint64_t v6 = operator new(0x58uLL);
    sub_1DD27F008((uint64_t)v6, a1, (uint64_t)a2);
  }
  else if ((v3 & 0x20) != 0)
  {
    uint64_t v6 = operator new(0x38uLL);
    sub_1DD27EB20((uint64_t)v6, a1, a2);
  }
  else
  {
    uint64_t v5 = operator new(0x30uLL);
    uint64_t v6 = v5;
    if ((v3 & 0x40) != 0)
    {
      sub_1DD27E9EC((uint64_t)v5, a1, a2);
    }
    else
    {
      *uint64_t v5 = &unk_1F387A618;
      v5[1] = &unk_1F387A680;
      *((_DWORD *)v5 + 4) = 0;
      *((unsigned char *)v5 + 20) = 0;
      uint64_t v7 = *(void *)(a1 + 96);
      v5[3] = 0;
      v5[4] = v7;
      *((unsigned char *)v5 + 16) = *(unsigned char *)(a1 + 112);
    }
  }
  return v6;
}

void sub_1DD27DB4C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD27DB68(void *a1, uint64_t a2, unsigned char *a3)
{
  *a1 = &unk_1F3879788;
  a1[1] = 0;
  uint64_t v4 = (char **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  if (*(int *)(a2 + 32) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      int v8 = sub_1DD27D9C8(*(void *)(*(void *)(a2 + 40) + 8 * v7 + 8), a3);
      uint64_t v9 = v8;
      unint64_t v11 = (void *)a1[2];
      unint64_t v10 = a1[3];
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v13 = ((char *)v11 - *v4) >> 3;
        if ((unint64_t)(v13 + 1) >> 61) {
          sub_1DD251DAC();
        }
        uint64_t v14 = v10 - (void)*v4;
        uint64_t v15 = v14 >> 2;
        if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
          uint64_t v15 = v13 + 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16) {
          uint64_t v17 = (char *)sub_1DD251DC4((uint64_t)(a1 + 3), v16);
        }
        else {
          uint64_t v17 = 0;
        }
        unsigned int v18 = &v17[8 * v13];
        *(void *)unsigned int v18 = v9;
        unint64_t v12 = v18 + 8;
        int v20 = (char *)a1[1];
        uint64_t v19 = (char *)a1[2];
        if (v19 != v20)
        {
          do
          {
            uint64_t v21 = *((void *)v19 - 1);
            v19 -= 8;
            *((void *)v18 - 1) = v21;
            v18 -= 8;
          }
          while (v19 != v20);
          uint64_t v19 = *v4;
        }
        a1[1] = v18;
        a1[2] = v12;
        a1[3] = &v17[8 * v16];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        void *v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a1[2] = v12;
      ++v7;
    }
    while (v7 < *(int *)(a2 + 32));
  }
  return a1;
}

void sub_1DD27DCCC(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD27DCEC(void *a1, uint64_t a2, unsigned char *a3)
{
  *a1 = &unk_1F3879788;
  a1[1] = 0;
  uint64_t v4 = (char **)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  if (*(int *)(a2 + 104) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      int v8 = sub_1DD27D9C8(*(void *)(*(void *)(a2 + 112) + 8 * v7 + 8), a3);
      uint64_t v9 = v8;
      unint64_t v11 = (void *)a1[2];
      unint64_t v10 = a1[3];
      if ((unint64_t)v11 >= v10)
      {
        uint64_t v13 = ((char *)v11 - *v4) >> 3;
        if ((unint64_t)(v13 + 1) >> 61) {
          sub_1DD251DAC();
        }
        uint64_t v14 = v10 - (void)*v4;
        uint64_t v15 = v14 >> 2;
        if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
          uint64_t v15 = v13 + 1;
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        if (v16) {
          uint64_t v17 = (char *)sub_1DD251DC4((uint64_t)(a1 + 3), v16);
        }
        else {
          uint64_t v17 = 0;
        }
        unsigned int v18 = &v17[8 * v13];
        *(void *)unsigned int v18 = v9;
        unint64_t v12 = v18 + 8;
        int v20 = (char *)a1[1];
        uint64_t v19 = (char *)a1[2];
        if (v19 != v20)
        {
          do
          {
            uint64_t v21 = *((void *)v19 - 1);
            v19 -= 8;
            *((void *)v18 - 1) = v21;
            v18 -= 8;
          }
          while (v19 != v20);
          uint64_t v19 = *v4;
        }
        a1[1] = v18;
        a1[2] = v12;
        a1[3] = &v17[8 * v16];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        void *v11 = v8;
        unint64_t v12 = v11 + 1;
      }
      a1[2] = v12;
      ++v7;
    }
    while (v7 < *(int *)(a2 + 104));
  }
  return a1;
}

void sub_1DD27DE50(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD27DE74(void *a1)
{
  *a1 = &unk_1F3879788;
  int v3 = (void *)a1[1];
  unint64_t v2 = (void *)a1[2];
  if (v3 != v2)
  {
    do
    {
      if (*v3)
      {
        (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
        unint64_t v2 = (void *)a1[2];
      }
      ++v3;
    }
    while (v3 != v2);
    int v3 = (void *)a1[1];
  }
  if (v3)
  {
    a1[2] = v3;
    operator delete(v3);
  }
  return a1;
}

void sub_1DD27DF14(void *a1)
{
  uint64_t v1 = sub_1DD27DE74(a1);
  operator delete(v1);
}

uint64_t sub_1DD27DF3C(uint64_t a1)
{
  *(void *)a1 = &unk_1F387A718;
  uint64_t v4 = (void **)(a1 + 16);
  sub_1DD28579C(&v4);
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD27DFC8(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD27DF3C(a1);
  operator delete(v1);
}

uint64_t sub_1DD27DFF0(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned char *a4)
{
  *(void *)a1 = &unk_1F387A718;
  *(_OWORD *)(a1 + 8) = 0u;
  unint64_t v36 = (uint64_t *)(a1 + 8);
  uint64_t v7 = (uint64_t *)(a1 + 16);
  *(_OWORD *)(a1 + 24) = 0u;
  int v8 = operator new(0x20uLL);
  sub_1DD27DB68(v8, a2, a4);
  uint64_t v9 = *v36;
  uint64_t *v36 = (uint64_t)v8;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  sub_1DD27E2DC(v7, 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3));
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 24);
  if (v10 != v11)
  {
    unint64_t v12 = 0;
    uint64_t v13 = *a3;
    do
    {
      uint64_t v14 = *(void *)(v13 + 24 * v12);
      if (*(void *)(v13 + 24 * v12 + 8) != v14)
      {
        uint64_t v15 = 0;
        unint64_t v16 = 0;
        do
        {
          uint64_t v17 = *v7;
          unsigned int v18 = sub_1DD27D9C8(v14 + v15, a4);
          sub_1DD285BA0(&v38, (uint64_t)v18);
          unint64_t v19 = v17 + 24 * v12;
          unsigned int v22 = *(_OWORD **)(v19 + 8);
          uint64_t v21 = (uint64_t *)(v19 + 8);
          int v20 = v22;
          unint64_t v23 = v21[1];
          if ((unint64_t)v22 >= v23)
          {
            uint64_t v24 = (uint64_t *)(v17 + 24 * v12);
            uint64_t v25 = ((uint64_t)v20 - *v24) >> 4;
            unint64_t v26 = v25 + 1;
            if ((unint64_t)(v25 + 1) >> 60) {
              sub_1DD251DAC();
            }
            uint64_t v27 = v23 - *v24;
            if (v27 >> 3 > v26) {
              unint64_t v26 = v27 >> 3;
            }
            if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v28 = v26;
            }
            v39[4] = v21 + 1;
            uint64_t v29 = (char *)sub_1DD27753C((uint64_t)(v21 + 1), v28);
            uint64_t v30 = &v29[16 * v25];
            v39[0] = v29;
            v39[1] = v30;
            v39[3] = &v29[16 * v31];
            *(_OWORD *)uint64_t v30 = v38;
            long long v38 = 0uLL;
            v39[2] = v30 + 16;
            sub_1DD285C84(v24, v39);
            uint64_t v32 = *v21;
            sub_1DD279984(v39);
            int v33 = (std::__shared_weak_count *)*((void *)&v38 + 1);
            uint64_t *v21 = v32;
            if (v33) {
              sub_1DD25B904(v33);
            }
          }
          else
          {
            _OWORD *v20 = v38;
            uint64_t *v21 = (uint64_t)(v20 + 1);
          }
          ++v16;
          uint64_t v13 = *a3;
          unsigned int v34 = (uint64_t *)(*a3 + 24 * v12);
          uint64_t v14 = *v34;
          v15 += 120;
        }
        while (v16 < 0xEEEEEEEEEEEEEEEFLL * ((v34[1] - *v34) >> 3));
        uint64_t v11 = *(void *)(a1 + 16);
        uint64_t v10 = *(void *)(a1 + 24);
      }
      ++v12;
    }
    while (v12 < 0xAAAAAAAAAAAAAAABLL * ((v10 - v11) >> 3));
  }
  return a1;
}

void sub_1DD27E254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14)
{
  operator delete(v14);
  sub_1DD28579C((void ***)&a11);
  uint64_t v16 = *a9;
  *a9 = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  _Unwind_Resume(a1);
}

void sub_1DD27E2DC(uint64_t *a1, unint64_t a2)
{
  int v3 = (void **)a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1DD285810(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 24 * a2;
    while (v3 != (void **)v7)
    {
      v3 -= 3;
      int v8 = v3;
      sub_1DD277574(&v8);
    }
    a1[1] = v7;
  }
}

void *sub_1DD27E388(void *result)
{
  *uint64_t result = &unk_1F387A618;
  result[1] = &unk_1F387A680;
  return result;
}

void *sub_1DD27E3C8(void *result)
{
  *(result - 1) = &unk_1F387A618;
  *uint64_t result = &unk_1F387A680;
  return result;
}

void sub_1DD27E40C(uint64_t a1)
{
}

void *sub_1DD27E414(void *result)
{
  *uint64_t result = &unk_1F387B1E8;
  result[1] = &unk_1F387B260;
  return result;
}

void *sub_1DD27E454(void *result)
{
  *(result - 1) = &unk_1F387B1E8;
  *uint64_t result = &unk_1F387B260;
  return result;
}

void sub_1DD27E498(uint64_t a1)
{
}

void *sub_1DD27E4A0(void *result)
{
  *uint64_t result = &unk_1F387B480;
  result[1] = &unk_1F387B500;
  return result;
}

void *sub_1DD27E4E0(void *result)
{
  *(result - 1) = &unk_1F387B480;
  *uint64_t result = &unk_1F387B500;
  return result;
}

void sub_1DD27E524(uint64_t a1)
{
}

void *sub_1DD27E52C(void *result)
{
  *uint64_t result = &unk_1F387AF78;
  result[1] = &unk_1F387B000;
  return result;
}

void *sub_1DD27E56C(void *result)
{
  *(result - 1) = &unk_1F387AF78;
  *uint64_t result = &unk_1F387B000;
  return result;
}

void sub_1DD27E5B0(uint64_t a1)
{
}

void *sub_1DD27E5B8(void *result)
{
  *uint64_t result = &unk_1F387B550;
  result[1] = &unk_1F387B5E8;
  return result;
}

void *sub_1DD27E5F8(void *result)
{
  *(result - 1) = &unk_1F387B550;
  *uint64_t result = &unk_1F387B5E8;
  return result;
}

void sub_1DD27E63C(uint64_t a1)
{
}

void *sub_1DD27E644(void *result)
{
  *uint64_t result = &unk_1F387B2B0;
  result[1] = &unk_1F387B348;
  return result;
}

void *sub_1DD27E684(void *result)
{
  *(result - 1) = &unk_1F387B2B0;
  *uint64_t result = &unk_1F387B348;
  return result;
}

void sub_1DD27E6C8(uint64_t a1)
{
}

void *sub_1DD27E6D0(void *result)
{
  *uint64_t result = &unk_1F387B638;
  result[1] = &unk_1F387B6D0;
  return result;
}

void *sub_1DD27E710(void *result)
{
  *(result - 1) = &unk_1F387B638;
  *uint64_t result = &unk_1F387B6D0;
  return result;
}

void sub_1DD27E754(uint64_t a1)
{
}

uint64_t sub_1DD27E75C(uint64_t result, uint64_t a2, int a3)
{
  if (!*(unsigned char *)(result + 17))
  {
    *(_WORD *)(result + 17) = 257;
    *(void *)(result + 48) = a2;
    int v3 = (void *)(result + 40);
LABEL_6:
    void *v3 = a2;
    goto LABEL_7;
  }
  int v3 = (void *)(result + 40);
  if (*(void *)(result + 40) > a2) {
    goto LABEL_6;
  }
  int v3 = (void *)(result + 48);
  if (*(void *)(result + 48) < a2) {
    goto LABEL_6;
  }
LABEL_7:
  if (*(unsigned char *)(result + 19))
  {
    uint64_t v4 = *(void *)(result + 56);
    uint64_t v5 = v4 + a3 * a2;
    *(void *)(result + 56) = v5;
    if (((v4 ^ a2) & 0x8000000000000000) == 0) {
      *(unsigned char *)(result + 19) = (v5 ^ v4) >= 0;
    }
  }
  return result;
}

void *sub_1DD27E7D0(void *a1)
{
  *a1 = &unk_1F387B398;
  a1[1] = &unk_1F387B430;
  sub_1DD285748((uint64_t)(a1 + 2));
  return a1;
}

uint64_t sub_1DD27E838(void *a1)
{
  *(a1 - 1) = &unk_1F387B398;
  *a1 = &unk_1F387B430;
  return sub_1DD285748((uint64_t)(a1 + 1));
}

void sub_1DD27E878(void *a1)
{
  *a1 = &unk_1F387B398;
  a1[1] = &unk_1F387B430;
  sub_1DD285748((uint64_t)(a1 + 2));
  operator delete(a1);
}

void sub_1DD27E8F0(void *a1)
{
  uint64_t v1 = a1 - 1;
  *(a1 - 1) = &unk_1F387B398;
  *a1 = &unk_1F387B430;
  sub_1DD285748((uint64_t)(a1 + 1));
  operator delete(v1);
}

void *sub_1DD27E960(void *result)
{
  *uint64_t result = &unk_1F387B760;
  result[1] = &unk_1F387B808;
  return result;
}

void *sub_1DD27E9A0(void *result)
{
  *(result - 1) = &unk_1F387B760;
  *uint64_t result = &unk_1F387B808;
  return result;
}

void sub_1DD27E9E4(uint64_t a1)
{
}

uint64_t sub_1DD27E9EC(uint64_t result, uint64_t a2, unsigned char *a3)
{
  *(void *)uint64_t result = &unk_1F387B1E8;
  *(void *)(result + 8) = &unk_1F387B260;
  *(unsigned char *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 0x40) != 0 && *a3)
  {
    int v3 = *(unsigned char **)(a2 + 72);
    if (!v3) {
      int v3 = &unk_1EAB1F380;
    }
    *(unsigned char *)(result + 20) = v3[16] & 1;
    *(void *)(result + 24) = *((void *)v3 + 3);
  }
  return result;
}

uint64_t sub_1DD27EA80(uint64_t result, uint64_t a2, unsigned char *a3)
{
  *(void *)uint64_t result = &unk_1F387B480;
  *(void *)(result + 8) = &unk_1F387B500;
  *(unsigned char *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 8) != 0 && *a3)
  {
    *(unsigned char *)(result + 48) = 1;
    int v3 = *(void **)(a2 + 48);
    if (!v3) {
      int v3 = &unk_1EAB1F3A0;
    }
    uint64_t v4 = *(void *)(v3[4] + 8);
  }
  else
  {
    uint64_t v4 = 0;
    *(unsigned char *)(result + 48) = 0;
  }
  *(void *)(result + 56) = v4;
  return result;
}

uint64_t sub_1DD27EB20(uint64_t result, uint64_t a2, unsigned char *a3)
{
  *(void *)uint64_t result = &unk_1F387AF78;
  *(void *)(result + 8) = &unk_1F387B000;
  *(unsigned char *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 112);
  uint64_t v3 = 0;
  if ((*(unsigned char *)(a2 + 16) & 0x20) != 0 && *a3)
  {
    uint64_t v4 = *(unsigned char **)(a2 + 64);
    if (!v4) {
      uint64_t v4 = &unk_1EAB1F360;
    }
    char v5 = v4[16];
    *(unsigned char *)(result + 17) = v5 & 1;
    *(unsigned char *)(result + 18) = (v5 & 2) != 0;
    uint64_t v3 = *((void *)v4 + 3);
  }
  *(void *)(result + 40) = v3;
  return result;
}

uint64_t sub_1DD27EBC0(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  *(void *)a1 = &unk_1F387B550;
  *(void *)(a1 + 8) = &unk_1F387B5E8;
  sub_1DD285700(a1 + 16);
  *(void *)(a1 + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 0x10) != 0 && *a3)
  {
    if (*(void *)(a2 + 56)) {
      unint64_t v6 = *(void **)(a2 + 56);
    }
    else {
      unint64_t v6 = qword_1EAB1F510;
    }
    char v7 = *((unsigned char *)v6 + 16);
    *(unsigned char *)(a1 + 17) = v7 & 1;
    *(unsigned char *)(a1 + 18) = (v7 & 2) != 0;
    *(unsigned char *)(a1 + 19) = (v7 & 4) != 0;
    sub_1DD290E2C((int)&v13, (std::string *)v6[3]);
    *(_OWORD *)(a1 + 40) = v13;
    *(_DWORD *)(a1 + 56) = v14;
    sub_1DD290E2C((int)&v11, (std::string *)v6[4]);
    *(_OWORD *)(a1 + 64) = v11;
    *(_DWORD *)(a1 + 80) = v12;
    sub_1DD290E2C((int)&v9, (std::string *)v6[5]);
    *(_OWORD *)(a1 + 88) = v9;
    *(_DWORD *)(a1 + 104) = v10;
  }
  return a1;
}

uint64_t sub_1DD27ECE4(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &unk_1F387B2B0;
  *(void *)(result + 8) = &unk_1F387B348;
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 20) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(void *)(result + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 2) != 0)
  {
    uint64_t v4 = (char *)&unk_1EAB1F448;
    if (*(void *)(a2 + 32)) {
      uint64_t v4 = *(char **)(a2 + 32);
    }
    char v5 = v4[16];
    *(unsigned char *)(result + 17) = v5 & 1;
    *(unsigned char *)(result + 18) = (v5 & 2) != 0;
    *(unsigned char *)(result + 19) = (v5 & 4) != 0;
    long long v2 = *(_OWORD *)(v4 + 24);
    uint64_t v3 = *((void *)v4 + 5);
  }
  else
  {
    long long v2 = 0uLL;
    uint64_t v3 = 0;
  }
  *(_OWORD *)(result + 40) = v2;
  *(void *)(result + 56) = v3;
  return result;
}

uint64_t sub_1DD27ED94(uint64_t result, uint64_t a2)
{
  *(void *)uint64_t result = &unk_1F387B638;
  *(void *)(result + 8) = &unk_1F387B6D0;
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 20) = 0;
  long long v2 = 0uLL;
  *(_OWORD *)(result + 24) = 0u;
  *(void *)(result + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(result + 16) = *(unsigned char *)(a2 + 112);
  if (*(unsigned char *)(a2 + 16))
  {
    uint64_t v4 = (char *)&unk_1EAB1F588;
    if (*(void *)(a2 + 24)) {
      uint64_t v4 = *(char **)(a2 + 24);
    }
    char v5 = v4[16];
    *(unsigned char *)(result + 17) = v5 & 1;
    *(unsigned char *)(result + 18) = (v5 & 2) != 0;
    *(unsigned char *)(result + 19) = (v5 & 4) != 0;
    long long v2 = *(_OWORD *)(v4 + 24);
    uint64_t v3 = *((void *)v4 + 5);
  }
  else
  {
    uint64_t v3 = 0;
  }
  *(_OWORD *)(result + 40) = v2;
  *(void *)(result + 56) = v3;
  return result;
}

uint64_t sub_1DD27EE44(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v4 = 0;
  *(void *)a1 = &unk_1F387B398;
  *(void *)(a1 + 8) = &unk_1F387B430;
  *(_DWORD *)(a1 + 16) = 0;
  *(unsigned char *)(a1 + 20) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 4) != 0 && *a3)
  {
    if (*(void *)(a2 + 40)) {
      char v5 = *(void **)(a2 + 40);
    }
    else {
      char v5 = qword_1EAB1F478;
    }
    char v6 = *((unsigned char *)v5 + 16);
    *(unsigned char *)(a1 + 17) = v6 & 1;
    *(unsigned char *)(a1 + 18) = (v6 & 2) != 0;
    *(unsigned char *)(a1 + 20) = (v6 & 0x10) != 0;
    char v7 = (long long *)v5[3];
    if (*((char *)v7 + 23) < 0)
    {
      sub_1DD24F980(&__str, *(void **)v7, *((void *)v7 + 1));
    }
    else
    {
      long long v8 = *v7;
      __str.__r_.__value_.__r.__words[2] = *((void *)v7 + 2);
      *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v8;
    }
    std::string::operator=((std::string *)(a1 + 40), &__str);
    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__str.__r_.__value_.__l.__data_);
    }
    long long v9 = (long long *)v5[4];
    if (*((char *)v9 + 23) < 0)
    {
      sub_1DD24F980(&__p, *(void **)v9, *((void *)v9 + 1));
    }
    else
    {
      long long v10 = *v9;
      __p.__r_.__value_.__r.__words[2] = *((void *)v9 + 2);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v10;
    }
    std::string::operator=((std::string *)(a1 + 64), &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    uint64_t v4 = v5[7];
  }
  *(void *)(a1 + 24) = v4;
  return a1;
}

void sub_1DD27EFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_1DD285748(v21);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27F008(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F387B760;
  *(void *)(a1 + 8) = &unk_1F387B808;
  *(unsigned char *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 96);
  *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 112);
  if ((*(unsigned char *)(a2 + 16) & 0x80) != 0 && *(unsigned char *)a3)
  {
    if (*(void *)(a2 + 80)) {
      char v5 = *(void **)(a2 + 80);
    }
    else {
      char v5 = &unk_1EAB1F618;
    }
    int v6 = *((_DWORD *)v5 + 4);
    BOOL v7 = (v6 & 4) != 0 || (v6 & 1) != 0 && *(void *)(a3 + 8) != 0;
    *(unsigned char *)(a1 + 17) = v7;
    BOOL v8 = (v6 & 8) != 0 || (v6 & 2) != 0 && *(void *)(a3 + 8) != 0;
    *(unsigned char *)(a1 + 18) = v8;
    *(unsigned char *)(a1 + 64) = (v6 & 5) != 0;
    *(unsigned char *)(a1 + 65) = (v6 & 0xA) != 0;
    if ((v6 & 4) != 0)
    {
      uint64_t v13 = *((void *)v5 + 5);
      *(void *)(a1 + 40) = v13;
    }
    else
    {
      uint64_t v9 = *(void *)(a3 + 8);
      if (v9)
      {
        uint64_t v10 = *((void *)v5 + 3);
        uint64_t v11 = v10
            + 1000 * *(void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v9 + 16))(v9, v10 / 1000);
        *(void *)(a1 + 40) = v11;
        *(void *)(a1 + 72) = v11;
        if ((*((_DWORD *)v5 + 4) & 8) != 0)
        {
LABEL_20:
          uint64_t v12 = *((void *)v5 + 6);
          goto LABEL_26;
        }
LABEL_24:
        uint64_t v14 = *(void *)(a3 + 8);
        if (!v14)
        {
          *(void *)(a1 + 48) = 0;
          uint64_t v12 = *((void *)v5 + 4) + 90000000;
          goto LABEL_28;
        }
        uint64_t v15 = *((void *)v5 + 4);
        uint64_t v12 = v15
            + 1000 * *(void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 16))(v14, v15 / 1000);
LABEL_26:
        *(void *)(a1 + 48) = v12;
LABEL_28:
        *(void *)(a1 + 80) = v12 + 1;
        return a1;
      }
      *(void *)(a1 + 40) = 0;
      uint64_t v13 = *((void *)v5 + 3) - 90000000;
    }
    *(void *)(a1 + 72) = v13;
    if ((v6 & 8) != 0) {
      goto LABEL_20;
    }
    goto LABEL_24;
  }
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  return a1;
}

void *sub_1DD27F24C@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  switch((*(unsigned int (**)(uint64_t))(*(void *)a1 + 32))(a1))
  {
    case 0u:
      uint64_t result = operator new(0x40uLL);
      *uint64_t result = &unk_1F387B480;
      char v5 = result + 1;
      result[1] = &unk_1F387B500;
      *((_DWORD *)result + 4) = 0;
      *((unsigned char *)result + 20) = 0;
      result[3] = 0;
      result[4] = 0;
      *((unsigned char *)result + 48) = 1;
      goto LABEL_7;
    case 1u:
    case 2u:
    case 3u:
    case 4u:
      uint64_t result = operator new(0x40uLL);
      *uint64_t result = &unk_1F387B638;
      char v5 = result + 1;
      int v6 = &unk_1F387B6D0;
      goto LABEL_6;
    case 5u:
    case 6u:
      uint64_t result = operator new(0x40uLL);
      *uint64_t result = &unk_1F387B2B0;
      char v5 = result + 1;
      int v6 = &unk_1F387B348;
LABEL_6:
      result[1] = v6;
      *((_DWORD *)result + 4) = 0;
      *((unsigned char *)result + 20) = 0;
      result[3] = 0;
      result[4] = 0;
      *((unsigned char *)result + 19) = 1;
LABEL_7:
      result[7] = 0;
      goto LABEL_14;
    case 7u:
    case 0x10u:
    case 0x11u:
      uint64_t result = operator new(0x70uLL);
      *uint64_t result = &unk_1F387B398;
      char v5 = result + 1;
      result[1] = &unk_1F387B430;
      *((_DWORD *)result + 4) = 0;
      *((_OWORD *)result + 2) = 0u;
      *((_OWORD *)result + 3) = 0u;
      *((_OWORD *)result + 4) = 0u;
      *((_OWORD *)result + 5) = 0u;
      *((_OWORD *)result + 6) = 0u;
      *((unsigned char *)result + 20) = 1;
      result[3] = 0;
      goto LABEL_14;
    case 8u:
      uint64_t result = operator new(0x30uLL);
      char v5 = result + 1;
      *uint64_t result = &unk_1F387B1E8;
      result[1] = &unk_1F387B260;
      *((_DWORD *)result + 4) = 0;
      *((unsigned char *)result + 20) = 1;
      goto LABEL_13;
    case 9u:
      uint64_t result = operator new(0x58uLL);
      char v5 = result + 1;
      *uint64_t result = &unk_1F387B760;
      BOOL v7 = &unk_1F387B808;
      goto LABEL_12;
    case 0xAu:
    case 0xBu:
    case 0xCu:
    case 0xDu:
      uint64_t result = operator new(0x30uLL);
      char v5 = result + 1;
      *uint64_t result = &unk_1F387A618;
      BOOL v7 = &unk_1F387A680;
      goto LABEL_12;
    case 0xEu:
      BOOL v8 = operator new(0x70uLL);
      char v5 = v8 + 1;
      *BOOL v8 = &unk_1F387B550;
      v8[1] = &unk_1F387B5E8;
      sub_1DD285700((uint64_t)(v8 + 2));
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*v8 + 120))(v8);
      goto LABEL_14;
    case 0xFu:
      uint64_t result = operator new(0x38uLL);
      char v5 = result + 1;
      *uint64_t result = &unk_1F387AF78;
      BOOL v7 = &unk_1F387B000;
LABEL_12:
      result[1] = v7;
      *((_DWORD *)result + 4) = 0;
      *((unsigned char *)result + 20) = 0;
LABEL_13:
      result[3] = 0;
      result[4] = 0;
LABEL_14:
      *a2 = v5;
      return result;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      (*(void (**)(std::string *__return_ptr, uint64_t))(*(void *)a1 + 88))(&v12, a1);
      uint64_t v10 = std::string::insert(&v12, 0, "Not supported type: ");
      long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v13.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      sub_1DD26D7D8(exception, &v13);
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
}

void sub_1DD27F680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1DD27F73C(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

uint64_t sub_1DD27F744(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 16);
}

uint64_t sub_1DD27F74C(uint64_t a1)
{
  sub_1DD239280((uint64_t)v11);
  sub_1DD239B24(v11, (uint64_t)"Column has ", 11);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  long long v2 = (void *)std::ostream::operator<<();
  uint64_t v3 = sub_1DD239B24(v2, (uint64_t)" values", 7);
  uint64_t v4 = sub_1DD239B24(v3, (uint64_t)" and has null value: ", 21);
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v5) {
    int v6 = "yes";
  }
  else {
    int v6 = "no";
  }
  if (v5) {
    uint64_t v7 = 3;
  }
  else {
    uint64_t v7 = 2;
  }
  BOOL v8 = sub_1DD239B24(v4, (uint64_t)v6, v7);
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)));
  uint64_t v9 = std::locale::use_facet(&v14, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v14);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v11[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v11 + *(void *)(v11[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v11[1] = MEMORY[0x1E4FBA470] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v13);
}

void sub_1DD27F9B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 40));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27F9D4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) = a2;
  return result;
}

uint64_t sub_1DD27F9DC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) += a2;
  return result;
}

uint64_t sub_1DD27F9EC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 16) = a2;
  return result;
}

BOOL *sub_1DD27F9F4(uint64_t a1, void *lpsrc)
{
  uint64_t v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38784D8, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  return sub_1DD285068((BOOL *)(a1 + 16), v3 + 16);
}

uint64_t sub_1DD27FA80(uint64_t result)
{
  *(unsigned char *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

uint64_t sub_1DD27FA90(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(result + 16);
  uint64_t v3 = *(void *)(result + 32);
  *(_DWORD *)(a2 + 16) = v2 | 0xA00;
  *(void *)(a2 + 96) = v3;
  return result;
}

uint64_t sub_1DD27FAB4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) += a2;
  return result;
}

uint64_t sub_1DD27FAC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) = a2;
  return result;
}

uint64_t sub_1DD27FACC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 8) = a2;
  return result;
}

BOOL *sub_1DD27FAD4(uint64_t a1, void *a2)
{
  return sub_1DD27F9F4(a1 - 8, a2);
}

uint64_t sub_1DD27FADC(uint64_t result)
{
  *(unsigned char *)(result + 12) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

uint64_t sub_1DD27FAEC(uint64_t result, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(result + 8);
  uint64_t v3 = *(void *)(result + 24);
  *(_DWORD *)(a2 + 16) = v2 | 0xA00;
  *(void *)(a2 + 96) = v3;
  return result;
}

uint64_t sub_1DD27FB10(uint64_t a1)
{
  sub_1DD239280((uint64_t)v15);
  int v2 = sub_1DD239B24(v15, (uint64_t)"Data type: Binary", 17);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  uint64_t v3 = std::locale::use_facet(&v18, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v18);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v18, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v18);
  std::ostream::put();
  std::ostream::flush();
  int v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    BOOL v8 = "yes";
  }
  else {
    BOOL v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v18, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v18);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    sub_1DD239B24(v15, (uint64_t)"Total length: ", 14);
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    char v12 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v12 = sub_1DD239B24(v15, (uint64_t)"Total length: not defined", 25);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  uint64_t v13 = std::locale::use_facet(&v18, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v18);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v15[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v15 + *(void *)(v15[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v15[1] = MEMORY[0x1E4FBA470] + 16;
  if (v16 < 0) {
    operator delete((void *)v15[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v17);
}

void sub_1DD27FF88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD27FFB8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 20);
}

uint64_t sub_1DD27FFC0(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Total length is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[3];
}

void sub_1DD280044(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL *sub_1DD280058(uint64_t a1, void *lpsrc)
{
  uint64_t v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878900, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  return sub_1DD285068((BOOL *)(a1 + 16), v3 + 16);
}

uint64_t sub_1DD2800E4(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 20) = 1;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  return result;
}

void *sub_1DD2800F8(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA40;
  uint64_t result = *(void **)(a2 + 72);
  if (!result)
  {
    uint64_t result = sub_1DD24E76C(0);
    *(void *)(a2 + 72) = result;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  *((_DWORD *)result + 4) |= 1u;
  result[3] = v6;
  return result;
}

BOOL *sub_1DD280160(uint64_t a1, void *a2)
{
  return sub_1DD280058(a1 - 8, a2);
}

uint64_t sub_1DD280168(uint64_t result)
{
  *(_DWORD *)(result + 8) = 0;
  *(unsigned char *)(result + 12) = 1;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  return result;
}

void *sub_1DD28017C(uint64_t a1, uint64_t a2)
{
  return sub_1DD2800F8(a1 - 8, a2);
}

uint64_t sub_1DD280184(uint64_t a1)
{
  sub_1DD239280((uint64_t)v21);
  int v2 = sub_1DD239B24(v21, (uint64_t)"Data type: Boolean", 18);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    BOOL v8 = "yes";
  }
  else {
    BOOL v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    sub_1DD239B24(v21, (uint64_t)"(true: ", 7);
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    char v12 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v12, (uint64_t)"; false: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
    uint64_t v13 = (void *)std::ostream::operator<<();
    std::locale v14 = ")";
    uint64_t v15 = 1;
  }
  else
  {
    char v16 = sub_1DD239B24(v21, (uint64_t)"(true: not defined; false: not defined)", 39);
    std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
    uint64_t v17 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
    std::locale::~locale(&v24);
    std::ostream::put();
    std::ostream::flush();
    std::locale v14 = "True and false counts are not defined";
    uint64_t v13 = v21;
    uint64_t v15 = 37;
  }
  std::locale v18 = sub_1DD239B24(v13, (uint64_t)v14, v15);
  std::ios_base::getloc((const std::ios_base *)((char *)v18 + *(void *)(*v18 - 24)));
  unint64_t v19 = std::locale::use_facet(&v24, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v19->__vftable[2].~facet_0)(v19, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v21[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v21[1] = MEMORY[0x1E4FBA470] + 16;
  if (v22 < 0) {
    operator delete((void *)v21[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v23);
}

void sub_1DD2806E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD280714(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 48);
}

uint64_t sub_1DD28071C(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "False count is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return (*(uint64_t (**)(void *))(*a1 + 16))(a1) - a1[7];
}

void sub_1DD2807CC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2807E0(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "True count is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[7];
}

void sub_1DD280864(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD280878(uint64_t result, uint64_t a2)
{
  *(void *)(result + 32) += a2;
  *(unsigned char *)(result + 48) = 1;
  return result;
}

BOOL *sub_1DD280890(uint64_t a1, void *lpsrc)
{
  int v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38789A8, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  uint64_t v4 = v3;
  uint64_t result = sub_1DD285068((BOOL *)(a1 + 16), v3 + 16);
  char v6 = *(unsigned char *)(a1 + 48);
  if (v6) {
    char v6 = v4[48] != 0;
  }
  *(unsigned char *)(a1 + 48) = v6;
  *(void *)(a1 + 56) += *((void *)v4 + 7);
  return result;
}

uint64_t sub_1DD280938(uint64_t result)
{
  *(unsigned char *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 48) = 1;
  *(void *)(result + 56) = 0;
  return result;
}

void sub_1DD280954(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA08;
  uint64_t v4 = *(_DWORD **)(a2 + 48);
  if (!v4)
  {
    uint64_t v4 = sub_1DD24E51C(0);
    *(void *)(a2 + 48) = v4;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v6 = *(void *)(a1 + 56);
    int v7 = v4[6];
    if (v7 == v4[7])
    {
      sub_1DD24FA20(v4 + 6, v7 + 1);
      int v7 = v4[6];
    }
    uint64_t v8 = *((void *)v4 + 4);
    v4[6] = v7 + 1;
    *(void *)(v8 + 8 * v7 + 8) = v6;
  }
  else
  {
    v4[6] = 0;
  }
}

uint64_t sub_1DD280A00(uint64_t result, uint64_t a2)
{
  *(void *)(result + 24) += a2;
  *(unsigned char *)(result + 40) = 1;
  return result;
}

BOOL *sub_1DD280A18(uint64_t a1, void *a2)
{
  return sub_1DD280890(a1 - 8, a2);
}

uint64_t sub_1DD280A20(uint64_t result)
{
  *(unsigned char *)(result + 12) = 0;
  *(_DWORD *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 40) = 1;
  *(void *)(result + 48) = 0;
  return result;
}

void sub_1DD280A3C(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1DD280A44(uint64_t a1)
{
  sub_1DD239280((uint64_t)v17);
  int v2 = sub_1DD239B24(v17, (uint64_t)"Data type: Date", 15);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    uint64_t v8 = "yes";
  }
  else {
    uint64_t v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    sub_1DD239B24(v17, (uint64_t)"Minimum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    char v12 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v12 = sub_1DD239B24(v17, (uint64_t)"Minimum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  uint64_t v13 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    sub_1DD239B24(v17, (uint64_t)"Maximum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
    std::locale v14 = (void *)std::ostream::operator<<();
  }
  else
  {
    std::locale v14 = sub_1DD239B24(v17, (uint64_t)"Maximum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
  uint64_t v15 = std::locale::use_facet(&v20, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(&v20);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v17[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v17[1] = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v19);
}

void sub_1DD280FC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD280FFC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 17);
}

uint64_t sub_1DD281004(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 18);
}

uint64_t sub_1DD28100C(unsigned int *a1)
{
  if (!(*(unsigned int (**)(unsigned int *))(*(void *)a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[10];
}

void sub_1DD281090(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2810A4(unsigned int *a1)
{
  if (!(*(unsigned int (**)(unsigned int *))(*(void *)a1 + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[11];
}

void sub_1DD281128(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL *sub_1DD28113C(uint64_t a1, void *lpsrc)
{
  int v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878820, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  return sub_1DD285108((BOOL *)(a1 + 16), v3 + 16);
}

_DWORD *sub_1DD2811C8(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA20;
  uint64_t result = *(_DWORD **)(a2 + 64);
  if (!result)
  {
    uint64_t result = sub_1DD24E644(0);
    *(void *)(a2 + 64) = result;
  }
  if (*(unsigned char *)(a1 + 17))
  {
    int v6 = *(_DWORD *)(a1 + 44);
    int v7 = result[4];
    result[4] = v7 | 2;
    result[7] = v6;
    int v8 = *(_DWORD *)(a1 + 40);
    result[4] = v7 | 3;
    result[6] = v8;
  }
  else
  {
    int v9 = result[4];
    *((void *)result + 3) = 0;
    result[4] = v9 & 0xFFFFFFFC;
  }
  return result;
}

BOOL *sub_1DD28125C(uint64_t a1, void *a2)
{
  return sub_1DD28113C(a1 - 8, a2);
}

_DWORD *sub_1DD281264(uint64_t a1, uint64_t a2)
{
  return sub_1DD2811C8(a1 - 8, a2);
}

uint64_t sub_1DD28126C(uint64_t a1)
{
  sub_1DD239280((uint64_t)v36);
  int v2 = sub_1DD239B24(v36, (uint64_t)"Data type: Decimal", 18);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale((std::locale *)&v35);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale((std::locale *)&v35);
  std::ostream::put();
  std::ostream::flush();
  int v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    int v8 = "yes";
  }
  else {
    int v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale((std::locale *)&v35);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    char v12 = sub_1DD239B24(v36, (uint64_t)"Minimum: ", 9);
    (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a1 + 64))(v34, a1);
    sub_1DD290E3C((uint64_t)v34, &v35);
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v13 = &v35;
    }
    else {
      uint64_t v13 = (std::string *)v35.__r_.__value_.__r.__words[0];
    }
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type size = HIBYTE(v35.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type size = v35.__r_.__value_.__l.__size_;
    }
    uint64_t v15 = sub_1DD239B24(v12, (uint64_t)v13, size);
    std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
    char v16 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
    std::locale::~locale(&v39);
    std::ostream::put();
    std::ostream::flush();
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v17 = sub_1DD239B24(v36, (uint64_t)"Minimum: not defined", 20);
    std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
    char v18 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
    std::locale::~locale((std::locale *)&v35);
    std::ostream::put();
    std::ostream::flush();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    uint64_t v19 = sub_1DD239B24(v36, (uint64_t)"Maximum: ", 9);
    (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a1 + 72))(v34, a1);
    sub_1DD290E3C((uint64_t)v34, &v35);
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::locale v20 = &v35;
    }
    else {
      std::locale v20 = (std::string *)v35.__r_.__value_.__r.__words[0];
    }
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v21 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v21 = v35.__r_.__value_.__l.__size_;
    }
    char v22 = sub_1DD239B24(v19, (uint64_t)v20, v21);
    std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(void *)(*v22 - 24)));
    uint64_t v23 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
    std::locale::~locale(&v39);
    std::ostream::put();
    std::ostream::flush();
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::locale v24 = sub_1DD239B24(v36, (uint64_t)"Maximum: not defined", 20);
    std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
    uint64_t v25 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
    std::locale::~locale((std::locale *)&v35);
    std::ostream::put();
    std::ostream::flush();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1))
  {
    unint64_t v26 = sub_1DD239B24(v36, (uint64_t)"Sum: ", 5);
    (*(void (**)(void *__return_ptr, uint64_t))(*(void *)a1 + 80))(v34, a1);
    sub_1DD290E3C((uint64_t)v34, &v35);
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v27 = &v35;
    }
    else {
      uint64_t v27 = (std::string *)v35.__r_.__value_.__r.__words[0];
    }
    if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v28 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v28 = v35.__r_.__value_.__l.__size_;
    }
    uint64_t v29 = sub_1DD239B24(v26, (uint64_t)v27, v28);
    std::ios_base::getloc((const std::ios_base *)((char *)v29 + *(void *)(*v29 - 24)));
    uint64_t v30 = std::locale::use_facet(&v39, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v30->__vftable[2].~facet_0)(v30, 10);
    std::locale::~locale(&v39);
    std::ostream::put();
    std::ostream::flush();
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v35.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v31 = sub_1DD239B24(v36, (uint64_t)"Sum: not defined", 16);
    std::ios_base::getloc((const std::ios_base *)((char *)v31 + *(void *)(*v31 - 24)));
    uint64_t v32 = std::locale::use_facet((const std::locale *)&v35, MEMORY[0x1E4FBA258]);
    ((void (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 10);
    std::locale::~locale((std::locale *)&v35);
    std::ostream::put();
    std::ostream::flush();
  }
  std::stringbuf::str();
  v36[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v36 + *(void *)(v36[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v36[1] = MEMORY[0x1E4FBA470] + 16;
  if (v37 < 0) {
    operator delete((void *)v36[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v38);
}

void sub_1DD281B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  std::locale::~locale((std::locale *)(v18 - 56));
  if (a17 < 0) {
    operator delete(__p);
  }
  sub_1DD239418((uint64_t)&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD281B94(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 19);
}

__n128 sub_1DD281B9C@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *a2 = result;
  a2[1].n128_u64[0] = *(void *)(a1 + 56);
  return result;
}

void sub_1DD281C30(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1DD281C44@<Q0>(__n128 *a1@<X0>, __n128 *a2@<X8>)
{
  if (!(*(unsigned int (**)(__n128 *))(a1->n128_u64[0] + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  __n128 result = a1[4];
  *a2 = result;
  a2[1].n128_u64[0] = a1[5].n128_u64[0];
  return result;
}

void sub_1DD281CD8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 sub_1DD281CEC@<Q0>(uint64_t a1@<X0>, __n128 *a2@<X8>)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Sum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  __n128 result = *(__n128 *)(a1 + 88);
  *a2 = result;
  a2[1].n128_u64[0] = *(void *)(a1 + 104);
  return result;
}

void sub_1DD281D80(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_1DD281D94(uint64_t a1, void *lpsrc)
{
  int v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F38789E0, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  uint64_t v4 = v3;
  __n128 result = sub_1DD2851A8((unsigned __int8 *)(a1 + 16), v3 + 16);
  if (*(unsigned char *)(a1 + 19))
  {
    __n128 result = (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v4 + 56))(v4);
    *(unsigned char *)(a1 + 19) = (_BYTE)result;
    if (result)
    {
      (*(void (**)(uint64_t *__return_ptr, unsigned __int8 *))(*(void *)v4 + 80))(v6, v4);
      return (unsigned __int8 *)sub_1DD268998(a1, v6);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 19) = 0;
  }
  return result;
}

double sub_1DD281E94(uint64_t a1)
{
  *(unsigned char *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  sub_1DD290E30((uint64_t)&v3);
  *(unsigned char *)(a1 + 19) = 1;
  double result = *(double *)&v3;
  *(_OWORD *)(a1 + 88) = v3;
  *(_DWORD *)(a1 + 104) = v4;
  return result;
}

void sub_1DD281EE8(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA10;
  int v4 = *(void **)(a2 + 56);
  if (!v4)
  {
    int v4 = sub_1DD24E5B0(0);
    *(void *)(a2 + 56) = v4;
  }
  if (*(unsigned char *)(a1 + 17))
  {
    sub_1DD290E3C(a1 + 40, &__p);
    *((_DWORD *)v4 + 4) |= 1u;
    sub_1DD251B20((__n128 **)v4 + 3, (__n128 *)&qword_1EAB1F7D8, (__n128 *)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    sub_1DD290E3C(a1 + 64, &__p);
    *((_DWORD *)v4 + 4) |= 2u;
    sub_1DD251B20((__n128 **)v4 + 4, (__n128 *)&qword_1EAB1F7D8, (__n128 *)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v6 = v4[3];
    if ((uint64_t *)v6 != &qword_1EAB1F7D8)
    {
      if (*(char *)(v6 + 23) < 0)
      {
        **(unsigned char **)uint64_t v6 = 0;
        *(void *)(v6 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v6 = 0;
        *(unsigned char *)(v6 + 23) = 0;
      }
    }
    *((_DWORD *)v4 + 4) &= ~1u;
    uint64_t v7 = v4[4];
    if ((uint64_t *)v7 != &qword_1EAB1F7D8)
    {
      if (*(char *)(v7 + 23) < 0)
      {
        **(unsigned char **)uint64_t v7 = 0;
        *(void *)(v7 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v7 = 0;
        *(unsigned char *)(v7 + 23) = 0;
      }
    }
    *((_DWORD *)v4 + 4) &= ~2u;
  }
  if (*(unsigned char *)(a1 + 19))
  {
    long long v9 = *(_OWORD *)(a1 + 88);
    uint64_t v10 = *(void *)(a1 + 104);
    sub_1DD290E3C((uint64_t)&v9, &__p);
    *((_DWORD *)v4 + 4) |= 4u;
    sub_1DD251B20((__n128 **)v4 + 5, (__n128 *)&qword_1EAB1F7D8, (__n128 *)&__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    uint64_t v8 = v4[5];
    if ((uint64_t *)v8 != &qword_1EAB1F7D8)
    {
      if (*(char *)(v8 + 23) < 0)
      {
        **(unsigned char **)uint64_t v8 = 0;
        *(void *)(v8 + 8) = 0;
      }
      else
      {
        *(unsigned char *)uint64_t v8 = 0;
        *(unsigned char *)(v8 + 23) = 0;
      }
    }
    *((_DWORD *)v4 + 4) &= ~4u;
  }
}

void sub_1DD2820E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned __int8 *sub_1DD28210C(uint64_t a1, void *a2)
{
  return sub_1DD281D94(a1 - 8, a2);
}

double sub_1DD282114(uint64_t a1)
{
  *(unsigned char *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1DD290E30((uint64_t)&v3);
  *(unsigned char *)(a1 + 11) = 1;
  double result = *(double *)&v3;
  *(_OWORD *)(a1 + 80) = v3;
  *(_DWORD *)(a1 + 96) = v4;
  return result;
}

void sub_1DD282168(uint64_t a1, uint64_t a2)
{
}

uint64_t sub_1DD282170(uint64_t a1)
{
  sub_1DD239280((uint64_t)v19);
  int v2 = sub_1DD239B24(v19, (uint64_t)"Data type: Double", 17);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  long long v3 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  uint64_t v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    uint64_t v8 = "yes";
  }
  else {
    uint64_t v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Minimum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
    char v12 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v12 = sub_1DD239B24(v19, (uint64_t)"Minimum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  uint64_t v13 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Maximum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
    std::locale v14 = (void *)std::ostream::operator<<();
  }
  else
  {
    std::locale v14 = sub_1DD239B24(v19, (uint64_t)"Maximum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
  uint64_t v15 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Sum: ", 5);
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    char v16 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v16 = sub_1DD239B24(v19, (uint64_t)"Sum: not defined", 16);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
  uint64_t v17 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v19[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v19[1] = MEMORY[0x1E4FBA470] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v21);
}

void sub_1DD2827F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

double sub_1DD28282C(double *a1)
{
  if (!(*(unsigned int (**)(double *))(*(void *)a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[5];
}

void sub_1DD2828B0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double sub_1DD2828C4(double *a1)
{
  if (!(*(unsigned int (**)(double *))(*(void *)a1 + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[6];
}

void sub_1DD282948(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double sub_1DD28295C(double *a1)
{
  if (!(*(unsigned int (**)(double *))(*(void *)a1 + 56))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Sum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[7];
}

void sub_1DD2829E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD2829F4(uint64_t a1, void *lpsrc)
{
  long long v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878938, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  int v4 = v3;
  sub_1DD2852F0((BOOL *)(a1 + 16), v3 + 16);
  if (*(unsigned char *)(a1 + 19))
  {
    int v5 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v4 + 56))(v4);
    *(unsigned char *)(a1 + 19) = v5;
    if (v5)
    {
      double v6 = *(double *)(a1 + 56);
      *(double *)(a1 + 56) = v6 + (*(double (**)(unsigned __int8 *))(*(void *)v4 + 80))(v4);
    }
  }
  else
  {
    *(unsigned char *)(a1 + 19) = 0;
  }
}

uint64_t sub_1DD282AF0(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 20) = 0;
  *(void *)(result + 24) = 0;
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 19) = 1;
  *(void *)(result + 56) = 0;
  return result;
}

void *sub_1DD282B0C(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA02;
  double result = *(void **)(a2 + 32);
  if (!result)
  {
    double result = sub_1DD24E3F4(0);
    *(void *)(a2 + 32) = result;
  }
  int v6 = *((_DWORD *)result + 4);
  if (*(unsigned char *)(a1 + 17))
  {
    result[3] = *(void *)(a1 + 40);
    unsigned int v7 = v6 | 3;
    result[4] = *(void *)(a1 + 48);
  }
  else
  {
    result[3] = 0;
    result[4] = 0;
    unsigned int v7 = v6 & 0xFFFFFFFC;
  }
  if (*(unsigned char *)(a1 + 19))
  {
    uint64_t v8 = *(void *)(a1 + 56);
    *((_DWORD *)result + 4) = v7 | 4;
    result[5] = v8;
  }
  else
  {
    result[5] = 0;
    *((_DWORD *)result + 4) = v7 & 0xFFFFFFFB;
  }
  return result;
}

void sub_1DD282BB8(uint64_t a1, void *a2)
{
}

uint64_t sub_1DD282BC0(uint64_t result)
{
  *(_DWORD *)(result + 8) = 0;
  *(unsigned char *)(result + 12) = 0;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  *(unsigned char *)(result + 11) = 1;
  *(void *)(result + 48) = 0;
  return result;
}

void *sub_1DD282BDC(uint64_t a1, uint64_t a2)
{
  return sub_1DD282B0C(a1 - 8, a2);
}

uint64_t sub_1DD282BE4(uint64_t a1)
{
  sub_1DD239280((uint64_t)v19);
  int v2 = sub_1DD239B24(v19, (uint64_t)"Data type: Integer", 18);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  int v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    uint64_t v8 = "yes";
  }
  else {
    uint64_t v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Minimum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
    char v12 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v12 = sub_1DD239B24(v19, (uint64_t)"Minimum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  uint64_t v13 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Maximum: ", 9);
    (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
    std::locale v14 = (void *)std::ostream::operator<<();
  }
  else
  {
    std::locale v14 = sub_1DD239B24(v19, (uint64_t)"Maximum: not defined", 20);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(void *)(*v14 - 24)));
  uint64_t v15 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1))
  {
    sub_1DD239B24(v19, (uint64_t)"Sum: ", 5);
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    char v16 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v16 = sub_1DD239B24(v19, (uint64_t)"Sum: not defined", 16);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(void *)(*v16 - 24)));
  uint64_t v17 = std::locale::use_facet(&v22, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(&v22);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v19[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v19 + *(void *)(v19[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v19[1] = MEMORY[0x1E4FBA470] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v21);
}

void sub_1DD283274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2832AC(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[5];
}

void sub_1DD283330(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD283344(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[6];
}

void sub_1DD2833C8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2833DC(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 56))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Sum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[7];
}

void sub_1DD283460(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD283474(uint64_t a1, void *lpsrc)
{
  int v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878A18, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  int v4 = v3;
  uint64_t result = (uint64_t)sub_1DD285390((BOOL *)(a1 + 16), v3 + 16);
  char v6 = *(unsigned char *)(a1 + 19);
  if (!v6) {
    goto LABEL_6;
  }
  uint64_t result = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v4 + 56))(v4);
  *(unsigned char *)(a1 + 19) = result;
  if (result)
  {
    uint64_t v7 = *(void *)(a1 + 56);
    *(void *)(a1 + 56) = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v4 + 80))(v4) + v7;
    uint64_t result = (*(uint64_t (**)(unsigned __int8 *))(*(void *)v4 + 80))(v4);
    if (((result ^ v7) & 0x8000000000000000) == 0)
    {
      char v6 = (*(void *)(a1 + 56) ^ v7) >= 0;
LABEL_6:
      *(unsigned char *)(a1 + 19) = v6;
    }
  }
  return result;
}

void *sub_1DD2835AC(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA01;
  uint64_t result = *(void **)(a2 + 24);
  if (!result)
  {
    uint64_t result = sub_1DD24E360(0);
    *(void *)(a2 + 24) = result;
  }
  if (*(unsigned char *)(a1 + 17))
  {
    int v6 = *((_DWORD *)result + 4);
    result[3] = *(void *)(a1 + 40);
    unsigned int v7 = v6 | 3;
    result[4] = *(void *)(a1 + 48);
  }
  else
  {
    int v8 = *((_DWORD *)result + 4);
    result[3] = 0;
    result[4] = 0;
    unsigned int v7 = v8 & 0xFFFFFFFC;
  }
  if (*(unsigned char *)(a1 + 19))
  {
    uint64_t v9 = *(void *)(a1 + 56);
    *((_DWORD *)result + 4) = v7 | 4;
    result[5] = v9;
  }
  else
  {
    result[5] = 0;
    *((_DWORD *)result + 4) = v7 & 0xFFFFFFFB;
  }
  return result;
}

uint64_t sub_1DD283658(uint64_t a1, void *a2)
{
  return sub_1DD283474(a1 - 8, a2);
}

void *sub_1DD283660(uint64_t a1, uint64_t a2)
{
  return sub_1DD2835AC(a1 - 8, a2);
}

uint64_t sub_1DD283668(uint64_t a1)
{
  sub_1DD239280((uint64_t)v29);
  int v2 = sub_1DD239B24(v29, (uint64_t)"Data type: String", 17);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  int v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    int v8 = "yes";
  }
  else {
    int v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  long long v11 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    char v12 = sub_1DD239B24(v29, (uint64_t)"Minimum: ", 9);
    uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1);
    int v14 = *(char *)(v13 + 23);
    if (v14 >= 0) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = *(void *)v13;
    }
    if (v14 >= 0) {
      uint64_t v16 = *(unsigned __int8 *)(v13 + 23);
    }
    else {
      uint64_t v16 = *(void *)(v13 + 8);
    }
    uint64_t v17 = sub_1DD239B24(v12, v15, v16);
  }
  else
  {
    uint64_t v17 = sub_1DD239B24(v29, (uint64_t)"Minimum is not defined", 22);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(void *)(*v17 - 24)));
  uint64_t v18 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    uint64_t v19 = sub_1DD239B24(v29, (uint64_t)"Maximum: ", 9);
    uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 72))(a1);
    int v21 = *(char *)(v20 + 23);
    if (v21 >= 0) {
      uint64_t v22 = v20;
    }
    else {
      uint64_t v22 = *(void *)v20;
    }
    if (v21 >= 0) {
      uint64_t v23 = *(unsigned __int8 *)(v20 + 23);
    }
    else {
      uint64_t v23 = *(void *)(v20 + 8);
    }
    std::locale v24 = sub_1DD239B24(v19, v22, v23);
  }
  else
  {
    std::locale v24 = sub_1DD239B24(v29, (uint64_t)"Maximum is not defined", 22);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(void *)(*v24 - 24)));
  uint64_t v25 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 56))(a1))
  {
    sub_1DD239B24(v29, (uint64_t)"Total length: ", 14);
    (*(void (**)(uint64_t))(*(void *)a1 + 80))(a1);
    unint64_t v26 = (void *)std::ostream::operator<<();
  }
  else
  {
    unint64_t v26 = sub_1DD239B24(v29, (uint64_t)"Total length is not defined", 27);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v26 + *(void *)(*v26 - 24)));
  uint64_t v27 = std::locale::use_facet(&v32, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v29[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v29 + *(void *)(v29[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v29[1] = MEMORY[0x1E4FBA470] + 16;
  if (v30 < 0) {
    operator delete((void *)v29[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v31);
}

void sub_1DD283D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::locale::~locale((std::locale *)(v9 - 56));
  sub_1DD239418((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD283D58(uint64_t a1)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1 + 40;
}

void sub_1DD283DDC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD283DF0(uint64_t a1)
{
  if (!(*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1 + 64;
}

void sub_1DD283E74(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD283E88(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 56))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Total length is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[3];
}

void sub_1DD283F0C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD283F20(uint64_t a1, void *lpsrc)
{
  int v3 = (char *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878970, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  sub_1DD285430((BOOL *)(a1 + 16), (const std::string *)(v3 + 16));
}

std::string *sub_1DD283FAC(std::string *result, uint64_t a2)
{
  int v2 = result;
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = result->__r_.__value_.__s.__data_[16];
  *(void *)(a2 + 96) = result[1].__r_.__value_.__l.__size_;
  *(_DWORD *)(a2 + 16) = v3 | 0xA04;
  int v4 = *(std::string **)(a2 + 40);
  if (!v4)
  {
    uint64_t result = (std::string *)sub_1DD24E488(0);
    int v4 = result;
    *(void *)(a2 + 40) = result;
  }
  if (v2->__r_.__value_.__s.__data_[17])
  {
    int v6 = (std::string *)((char *)v2 + 40);
    data = (std::string *)v4[1].__r_.__value_.__l.__data_;
    LODWORD(v4->__r_.__value_.__r.__words[2]) |= 1u;
    if (data == (std::string *)&qword_1EAB1F7D8) {
      sub_1DD24F908(v4[1].__r_.__value_.__r.__words, (uint64_t)v6);
    }
    else {
      std::string::operator=(data, v6);
    }
    uint64_t v9 = (std::string *)((char *)v2 + 64);
    std::string::size_type size = (std::string *)v4[1].__r_.__value_.__l.__size_;
    LODWORD(v4->__r_.__value_.__r.__words[2]) |= 2u;
    if (size == (std::string *)&qword_1EAB1F7D8) {
      uint64_t result = (std::string *)sub_1DD24F908(&v4[1].__r_.__value_.__l.__size_, (uint64_t)v9);
    }
    else {
      uint64_t result = std::string::operator=(size, v9);
    }
  }
  else
  {
    std::string::pointer v8 = v4[1].__r_.__value_.__l.__data_;
    if (v8 != (std::string::pointer)&qword_1EAB1F7D8)
    {
      if (v8[23] < 0)
      {
        **(unsigned char **)std::string::pointer v8 = 0;
        *((void *)v8 + 1) = 0;
      }
      else
      {
        *std::string::pointer v8 = 0;
        v8[23] = 0;
      }
    }
    LODWORD(v4->__r_.__value_.__r.__words[2]) &= ~1u;
    std::string::size_type v11 = v4[1].__r_.__value_.__l.__size_;
    if ((uint64_t *)v11 != &qword_1EAB1F7D8)
    {
      if (*(char *)(v11 + 23) < 0)
      {
        **(unsigned char **)std::string::size_type v11 = 0;
        *(void *)(v11 + 8) = 0;
      }
      else
      {
        *(unsigned char *)std::string::size_type v11 = 0;
        *(unsigned char *)(v11 + 23) = 0;
      }
    }
    LODWORD(v4->__r_.__value_.__r.__words[2]) &= ~2u;
  }
  if (v2->__r_.__value_.__s.__data_[20])
  {
    std::string::pointer v12 = v2[1].__r_.__value_.__l.__data_;
    LODWORD(v4->__r_.__value_.__r.__words[2]) |= 0x10u;
    v4[2].__r_.__value_.__l.__size_ = (std::string::size_type)v12;
  }
  else
  {
    v4[2].__r_.__value_.__l.__size_ = 0;
    LODWORD(v4->__r_.__value_.__r.__words[2]) &= ~0x10u;
  }
  return result;
}

void sub_1DD28412C(uint64_t a1, void *a2)
{
}

std::string *sub_1DD284134(uint64_t a1, uint64_t a2)
{
  return sub_1DD283FAC((std::string *)(a1 - 8), a2);
}

uint64_t sub_1DD28413C(uint64_t a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  sub_1DD239280((uint64_t)v35);
  time_t v33 = 0;
  int v2 = sub_1DD239B24(v35, (uint64_t)"Data type: Timestamp", 20);
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(void *)(*v2 - 24)));
  int v3 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  sub_1DD239B24(v2, (uint64_t)"Values: ", 8);
  (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  int v4 = (void *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(void *)(*v4 - 24)));
  int v5 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  int v6 = sub_1DD239B24(v4, (uint64_t)"Has null: ", 10);
  int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  if (v7) {
    std::string::pointer v8 = "yes";
  }
  else {
    std::string::pointer v8 = "no";
  }
  if (v7) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  uint64_t v10 = sub_1DD239B24(v6, (uint64_t)v8, v9);
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(void *)(*v10 - 24)));
  std::string::size_type v11 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1))
  {
    time_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1) / 1000;
    gmtime_r(&v33, &v34);
    strftime(__s, 0x14uLL, "%Y-%m-%d %H:%M:%S", &v34);
    std::string::pointer v12 = sub_1DD239B24(v35, (uint64_t)"Minimum: ", 9);
    size_t v13 = strlen(__s);
    int v14 = sub_1DD239B24(v12, (uint64_t)__s, v13);
    sub_1DD239B24(v14, (uint64_t)".", 1);
    (*(void (**)(uint64_t))(*(void *)a1 + 56))(a1);
    uint64_t v15 = (void *)std::ostream::operator<<();
  }
  else
  {
    uint64_t v15 = sub_1DD239B24(v35, (uint64_t)"Minimum is not defined", 22);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(void *)(*v15 - 24)));
  uint64_t v16 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 72))(a1))
  {
    time_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 88))(a1) / 1000;
    gmtime_r(&v33, &v34);
    strftime(__s, 0x14uLL, "%Y-%m-%d %H:%M:%S", &v34);
    uint64_t v17 = sub_1DD239B24(v35, (uint64_t)"LowerBound: ", 12);
    size_t v18 = strlen(__s);
    uint64_t v19 = sub_1DD239B24(v17, (uint64_t)__s, v18);
    sub_1DD239B24(v19, (uint64_t)".", 1);
    (*(void (**)(uint64_t))(*(void *)a1 + 88))(a1);
    uint64_t v20 = (void *)std::ostream::operator<<();
  }
  else
  {
    uint64_t v20 = sub_1DD239B24(v35, (uint64_t)"LowerBound is not defined", 25);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(void *)(*v20 - 24)));
  int v21 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 48))(a1))
  {
    time_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 64))(a1) / 1000;
    gmtime_r(&v33, &v34);
    strftime(__s, 0x14uLL, "%Y-%m-%d %H:%M:%S", &v34);
    uint64_t v22 = sub_1DD239B24(v35, (uint64_t)"Maximum: ", 9);
    size_t v23 = strlen(__s);
    std::locale v24 = sub_1DD239B24(v22, (uint64_t)__s, v23);
    sub_1DD239B24(v24, (uint64_t)".", 1);
    (*(void (**)(uint64_t))(*(void *)a1 + 64))(a1);
    uint64_t v25 = (void *)std::ostream::operator<<();
  }
  else
  {
    uint64_t v25 = sub_1DD239B24(v35, (uint64_t)"Maximum is not defined", 22);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v25 + *(void *)(*v25 - 24)));
  unint64_t v26 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 80))(a1))
  {
    time_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) / 1000;
    gmtime_r(&v33, &v34);
    strftime(__s, 0x14uLL, "%Y-%m-%d %H:%M:%S", &v34);
    uint64_t v27 = sub_1DD239B24(v35, (uint64_t)"UpperBound: ", 12);
    size_t v28 = strlen(__s);
    uint64_t v29 = sub_1DD239B24(v27, (uint64_t)__s, v28);
    sub_1DD239B24(v29, (uint64_t)".", 1);
    (*(void (**)(uint64_t))(*(void *)a1 + 96))(a1);
    char v30 = (void *)std::ostream::operator<<();
  }
  else
  {
    char v30 = sub_1DD239B24(v35, (uint64_t)"UpperBound is not defined", 25);
  }
  std::ios_base::getloc((const std::ios_base *)((char *)v30 + *(void *)(*v30 - 24)));
  uint64_t v31 = std::locale::use_facet(&v38, MEMORY[0x1E4FBA258]);
  ((void (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 10);
  std::locale::~locale(&v38);
  std::ostream::put();
  std::ostream::flush();
  std::stringbuf::str();
  v35[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v35 + *(void *)(v35[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v35[1] = MEMORY[0x1E4FBA470] + 16;
  if (v36 < 0) {
    operator delete((void *)v35[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v37);
}

void sub_1DD284BE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t sub_1DD284C2C(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 40))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Minimum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[5];
}

void sub_1DD284CB0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD284CC4(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 48))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "Maximum is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[6];
}

void sub_1DD284D48(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD284D5C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 64);
}

uint64_t sub_1DD284D64(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 65);
}

uint64_t sub_1DD284D6C(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 72))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "LowerBound is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[9];
}

void sub_1DD284DF0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD284E04(void *a1)
{
  if (!(*(unsigned int (**)(void *))(*a1 + 80))(a1))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1DD26D8A0(exception, "UpperBound is not defined.");
    __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  return a1[10];
}

void sub_1DD284E88(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

BOOL *sub_1DD284E9C(uint64_t a1, void *lpsrc)
{
  int v3 = (unsigned __int8 *)__dynamic_cast(lpsrc, (const struct __class_type_info *)&unk_1F38787B0, (const struct __class_type_info *)&unk_1F3878A68, 8);
  if (!v3) {
    __cxa_bad_cast();
  }
  return sub_1DD285390((BOOL *)(a1 + 16), v3 + 16);
}

_DWORD *sub_1DD284F28(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 16);
  *(unsigned char *)(a2 + 112) = *(unsigned char *)(a1 + 16);
  *(void *)(a2 + 96) = *(void *)(a1 + 32);
  *(_DWORD *)(a2 + 16) = v3 | 0xA80;
  uint64_t result = *(_DWORD **)(a2 + 80);
  if (!result)
  {
    uint64_t result = sub_1DD24E6D8(0);
    *(void *)(a2 + 80) = result;
  }
  if (*(unsigned char *)(a1 + 17))
  {
    int v6 = result[4];
    *((void *)result + 5) = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    result[4] = v6 | 0xC;
    *((void *)result + 6) = v7;
  }
  else
  {
    int v8 = result[4];
    *((void *)result + 5) = 0;
    *((void *)result + 6) = 0;
    result[4] = v8 & 0xFFFFFFF3;
  }
  return result;
}

BOOL *sub_1DD284FB4(uint64_t a1, void *a2)
{
  return sub_1DD284E9C(a1 - 8, a2);
}

_DWORD *sub_1DD284FBC(uint64_t a1, uint64_t a2)
{
  return sub_1DD284F28(a1 - 8, a2);
}

uint64_t sub_1DD284FC4(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 8) + 8 * a2);
}

uint64_t sub_1DD284FD0(uint64_t a1)
{
  return (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >> 3;
}

uint64_t sub_1DD284FE0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 16))();
}

uint64_t sub_1DD285008(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_1DD285030(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return *(void *)(*(void *)(*(void *)(a1 + 16) + 24 * a2) + 16 * a3);
}

uint64_t sub_1DD28504C(uint64_t a1, unsigned int a2)
{
  return (*(void *)(*(void *)(a1 + 16) + 24 * a2 + 8) - *(void *)(*(void *)(a1 + 16) + 24 * a2)) >> 4;
}

BOOL *sub_1DD285068(BOOL *result, unsigned __int8 *a2)
{
  *uint64_t result = (*result | *a2) != 0;
  *((void *)result + 2) += *((void *)a2 + 2);
  if (a2[1])
  {
    if (result[1])
    {
      int v2 = (char)a2[25];
      if (result[25] < v2) {
        result[25] = v2;
      }
      int v3 = (char)a2[24];
      if (v3 < result[24]) {
        result[24] = v3;
      }
    }
    else
    {
      *(_WORD *)(result + 1) = 257;
      *((_WORD *)result + 12) = *((_WORD *)a2 + 12);
    }
  }
  char v5 = result[4] && a2[4] != 0;
  result[4] = v5;
  *((void *)result + 1) += *((void *)a2 + 1);
  return result;
}

BOOL *sub_1DD285108(BOOL *result, unsigned __int8 *a2)
{
  *uint64_t result = (*result | *a2) != 0;
  *((void *)result + 2) += *((void *)a2 + 2);
  if (a2[1])
  {
    if (result[1])
    {
      int v2 = *((_DWORD *)a2 + 7);
      if (*((_DWORD *)result + 7) < v2) {
        *((_DWORD *)result + 7) = v2;
      }
      int v3 = *((_DWORD *)a2 + 6);
      if (v3 < *((_DWORD *)result + 6)) {
        *((_DWORD *)result + 6) = v3;
      }
    }
    else
    {
      *(_WORD *)(result + 1) = 257;
      *((void *)result + 3) = *((void *)a2 + 3);
    }
  }
  char v5 = result[4] && a2[4] != 0;
  result[4] = v5;
  *((void *)result + 1) += *((void *)a2 + 1);
  return result;
}

unsigned __int8 *sub_1DD2851A8(unsigned __int8 *result, unsigned __int8 *a2)
{
  int v3 = result;
  *uint64_t result = (*result | *a2) != 0;
  *((void *)result + 2) += *((void *)a2 + 2);
  if (a2[1])
  {
    if (result[1])
    {
      long long v16 = *((_OWORD *)result + 3);
      uint64_t v17 = *((void *)result + 8);
      long long v14 = *((_OWORD *)a2 + 3);
      uint64_t v15 = *((void *)a2 + 8);
      if (sub_1DD268A80((uint64_t)&v16, (uint64_t)&v14))
      {
        long long v4 = *((_OWORD *)a2 + 3);
        *((_DWORD *)v3 + 16) = *((_DWORD *)a2 + 16);
        *((_OWORD *)v3 + 3) = v4;
      }
      long long v12 = *(_OWORD *)(a2 + 24);
      uint64_t v13 = *((void *)a2 + 5);
      long long v10 = *(_OWORD *)(v3 + 24);
      uint64_t v11 = *((void *)v3 + 5);
      uint64_t result = (unsigned __int8 *)sub_1DD268A80((uint64_t)&v12, (uint64_t)&v10);
      if (result)
      {
        long long v5 = *(_OWORD *)(a2 + 24);
        *((_DWORD *)v3 + 10) = *((_DWORD *)a2 + 10);
        *(_OWORD *)(v3 + 24) = v5;
      }
    }
    else
    {
      *(_WORD *)(result + 1) = 257;
      long long v6 = *(_OWORD *)(a2 + 24);
      *((_DWORD *)result + 10) = *((_DWORD *)a2 + 10);
      *(_OWORD *)(result + 24) = v6;
      long long v7 = *((_OWORD *)a2 + 3);
      *((_DWORD *)result + 16) = *((_DWORD *)a2 + 16);
      *((_OWORD *)result + 3) = v7;
    }
  }
  if (v3[4]) {
    BOOL v8 = a2[4] == 0;
  }
  else {
    BOOL v8 = 1;
  }
  char v9 = !v8;
  v3[4] = v9;
  *((void *)v3 + 1) += *((void *)a2 + 1);
  return result;
}

BOOL *sub_1DD2852F0(BOOL *result, unsigned __int8 *a2)
{
  *uint64_t result = (*result | *a2) != 0;
  *((void *)result + 2) += *((void *)a2 + 2);
  if (a2[1])
  {
    if (result[1])
    {
      double v2 = *((double *)a2 + 4);
      if (*((double *)result + 4) < v2) {
        *((double *)result + 4) = v2;
      }
      double v3 = *((double *)a2 + 3);
      if (v3 < *((double *)result + 3)) {
        *((double *)result + 3) = v3;
      }
    }
    else
    {
      *(_WORD *)(result + 1) = 257;
      *(_OWORD *)(result + 24) = *(_OWORD *)(a2 + 24);
    }
  }
  char v5 = result[4] && a2[4] != 0;
  result[4] = v5;
  *((void *)result + 1) += *((void *)a2 + 1);
  return result;
}

BOOL *sub_1DD285390(BOOL *result, unsigned __int8 *a2)
{
  *uint64_t result = (*result | *a2) != 0;
  *((void *)result + 2) += *((void *)a2 + 2);
  if (a2[1])
  {
    if (result[1])
    {
      uint64_t v2 = *((void *)a2 + 4);
      if (*((void *)result + 4) < v2) {
        *((void *)result + 4) = v2;
      }
      uint64_t v3 = *((void *)a2 + 3);
      if (v3 < *((void *)result + 3)) {
        *((void *)result + 3) = v3;
      }
    }
    else
    {
      *(_WORD *)(result + 1) = 257;
      *(_OWORD *)(result + 24) = *(_OWORD *)(a2 + 24);
    }
  }
  char v5 = result[4] && a2[4] != 0;
  result[4] = v5;
  *((void *)result + 1) += *((void *)a2 + 1);
  return result;
}

void sub_1DD285430(BOOL *a1, const std::string *a2)
{
  *a1 = (*a1 | a2->__r_.__value_.__s.__data_[0]) != 0;
  *((void *)a1 + 2) += *((void *)&a2->__r_.__value_.__l + 2);
  if (!a2->__r_.__value_.__s.__data_[1]) {
    goto LABEL_67;
  }
  if (!a1[1])
  {
    *(_WORD *)(a1 + 1) = 257;
    std::string::operator=((std::string *)a1 + 1, a2 + 1);
    long long v4 = a2 + 2;
    char v5 = (std::string *)(a1 + 48);
LABEL_66:
    std::string::operator=(v5, v4);
    goto LABEL_67;
  }
  if (a1[71] < 0)
  {
    sub_1DD24F980(__p, *((void **)a1 + 6), *((void *)a1 + 7));
  }
  else
  {
    *(_OWORD *)std::string __p = *((_OWORD *)a1 + 3);
    uint64_t v35 = *((void *)a1 + 8);
  }
  if (SHIBYTE(a2[2].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_1DD24F980(&__dst, a2[2].__r_.__value_.__l.__data_, a2[2].__r_.__value_.__l.__size_);
  }
  else
  {
    long long __dst = *(_OWORD *)&a2[2].__r_.__value_.__l.__data_;
    int64_t v33 = a2[2].__r_.__value_.__r.__words[2];
  }
  int v6 = SHIBYTE(v33);
  long long v7 = (void *)__dst;
  char v8 = HIBYTE(v35);
  if (v35 >= 0) {
    char v9 = (void *)HIBYTE(v35);
  }
  else {
    char v9 = __p[1];
  }
  if (v35 >= 0) {
    long long v10 = __p;
  }
  else {
    long long v10 = (void **)__p[0];
  }
  if (v33 >= 0) {
    size_t v11 = HIBYTE(v33);
  }
  else {
    size_t v11 = *((void *)&__dst + 1);
  }
  if (v33 >= 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (long long *)__dst;
  }
  if (v11 >= (unint64_t)v9) {
    size_t v13 = (size_t)v9;
  }
  else {
    size_t v13 = v11;
  }
  int v14 = memcmp(v10, p_dst, v13);
  if (v14) {
    BOOL v15 = v14 < 0;
  }
  else {
    BOOL v15 = (unint64_t)v9 < v11;
  }
  if (v6 < 0)
  {
    operator delete(v7);
    if ((v35 & 0x8000000000000000) == 0)
    {
LABEL_30:
      if (!v15) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
  }
  else if ((v8 & 0x80) == 0)
  {
    goto LABEL_30;
  }
  operator delete(__p[0]);
  if (v15) {
LABEL_31:
  }
    std::string::operator=((std::string *)a1 + 2, a2 + 2);
LABEL_32:
  if (SHIBYTE(a2[1].__r_.__value_.__r.__words[2]) < 0)
  {
    sub_1DD24F980(v30, a2[1].__r_.__value_.__l.__data_, a2[1].__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)char v30 = *(_OWORD *)&a2[1].__r_.__value_.__l.__data_;
    int64_t v31 = a2[1].__r_.__value_.__r.__words[2];
  }
  if (a1[47] < 0)
  {
    sub_1DD24F980(&v28, *((void **)a1 + 3), *((void *)a1 + 4));
  }
  else
  {
    long long v28 = *(_OWORD *)(a1 + 24);
    uint64_t v29 = *((void *)a1 + 5);
  }
  int v16 = SHIBYTE(v29);
  uint64_t v17 = (void *)v28;
  char v18 = HIBYTE(v31);
  if (v31 >= 0) {
    uint64_t v19 = (void *)HIBYTE(v31);
  }
  else {
    uint64_t v19 = v30[1];
  }
  if (v31 >= 0) {
    uint64_t v20 = v30;
  }
  else {
    uint64_t v20 = (void **)v30[0];
  }
  if (v29 >= 0) {
    size_t v21 = HIBYTE(v29);
  }
  else {
    size_t v21 = *((void *)&v28 + 1);
  }
  if (v29 >= 0) {
    uint64_t v22 = &v28;
  }
  else {
    uint64_t v22 = (long long *)v28;
  }
  if (v21 >= (unint64_t)v19) {
    size_t v23 = (size_t)v19;
  }
  else {
    size_t v23 = v21;
  }
  int v24 = memcmp(v20, v22, v23);
  if (v24) {
    BOOL v25 = v24 < 0;
  }
  else {
    BOOL v25 = (unint64_t)v19 < v21;
  }
  if ((v16 & 0x80000000) == 0)
  {
    if ((v18 & 0x80) == 0) {
      goto LABEL_61;
    }
LABEL_64:
    operator delete(v30[0]);
    if (!v25) {
      goto LABEL_67;
    }
    goto LABEL_65;
  }
  operator delete(v17);
  if (v31 < 0) {
    goto LABEL_64;
  }
LABEL_61:
  if (v25)
  {
LABEL_65:
    char v5 = (std::string *)(a1 + 24);
    long long v4 = a2 + 1;
    goto LABEL_66;
  }
LABEL_67:
  char v27 = a1[4] && a2->__r_.__value_.__s.__data_[4] != 0;
  a1[4] = v27;
  *((void *)a1 + 1) += a2->__r_.__value_.__l.__size_;
}

void sub_1DD2856CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a18 < 0) {
    operator delete(a13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD285700(uint64_t a1)
{
  *(unsigned char *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  return a1;
}

uint64_t sub_1DD285748(uint64_t a1)
{
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 47) < 0) {
    operator delete(*(void **)(a1 + 24));
  }
  return a1;
}

void sub_1DD28579C(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (void **)**a1;
  if (v2)
  {
    long long v4 = (void **)v1[1];
    char v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        int v6 = v4;
        sub_1DD277574(&v6);
      }
      while (v4 != v2);
      char v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DD285810(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 24 * ((24 * a2 - 24) / 0x18) + 24;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL) {
      sub_1DD251DAC();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      long long v12 = (char *)sub_1DD2697FC(v4, v11);
    }
    else {
      long long v12 = 0;
    }
    BOOL v15 = v12;
    int v16 = &v12[24 * v8];
    char v18 = &v12[24 * v11];
    size_t v14 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    sub_1DD285978(a1, &v15);
    sub_1DD285B18(&v15);
  }
}

void sub_1DD285964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD285B18((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD285978(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD2859F0((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD2859F0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v14 = a6;
  *((void *)&v14 + 1) = a7;
  long long v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  void v11[2] = &v14;
  if (a3 == a5)
  {
    uint64_t v9 = a6;
  }
  else
  {
    do
    {
      *(void *)(v7 - 24) = 0;
      *(void *)(v7 - 16) = 0;
      *(void *)(v7 - 8) = 0;
      long long v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(void *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      uint64_t v7 = *((void *)&v14 + 1) - 24;
      *((void *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    uint64_t v9 = v14;
  }
  char v12 = 1;
  sub_1DD285A94((uint64_t)v11);
  return v9;
}

uint64_t sub_1DD285A94(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD285ACC(a1);
  }
  return a1;
}

void sub_1DD285ACC(uint64_t a1)
{
  uint64_t v1 = *(void ***)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void ***)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = v1;
    sub_1DD277574(&v3);
    v1 += 3;
  }
}

void **sub_1DD285B18(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1DD285B4C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (void **)(i - 24);
    *(void *)(a1 + 16) = v4;
    uint64_t v5 = v4;
    sub_1DD277574(&v5);
  }
}

void *sub_1DD285BA0(void *a1, uint64_t a2)
{
  *a1 = a2;
  uint64_t v4 = operator new(0x20uLL);
  *uint64_t v4 = &unk_1F387CE80;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1DD285BF8(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1DD31CAF8(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD285C10(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1DD285C40(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878EA0)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD285C84(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD285CFC((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD285CFC(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *uint64_t v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1DD285D90((uint64_t)v12);
  return v10;
}

uint64_t sub_1DD285D90(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD279940(a1);
  }
  return a1;
}

void *sub_1DD285DC8(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *uint64_t result = &unk_1F3879EA8;
  result[1] = a2;
  result[2] = a4;
  result[3] = a5;
  result[4] = a3;
  result[5] = a6;
  result[6] = a7;
  result[7] = a8;
  return result;
}

void sub_1DD285DF8(uint64_t a1)
{
  uint64_t v1 = (void *)nullsub_1(a1);
  operator delete(v1);
}

uint64_t sub_1DD285E28(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

uint64_t sub_1DD285E50@<X0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  return sub_1DD243878(a3, *(void *)(*(void *)(*(void *)(a1 + 24) + 64) + 8 * a2 + 8));
}

uint64_t sub_1DD285E6C(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_1DD285E74(uint64_t a1)
{
  return *(void *)(sub_1DD273400(*(void *)(a1 + 8)) + 56);
}

void *sub_1DD285E94@<X0>(uint64_t *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v10 = a1[5];
  unint64_t v11 = (void *)a1[2];
  uint64_t v12 = v11[6];
  uint64_t v13 = v11[7];
  uint64_t v14 = v11[8];
  uint64_t result = (void *)sub_1DD273400(a1[1]);
  uint64_t v16 = a1[3];
  uint64_t v17 = *(unsigned int *)(v16 + 32);
  if ((int)v17 < 1)
  {
LABEL_7:
    *a5 = 0;
  }
  else
  {
    uint64_t v18 = 0;
    unint64_t v19 = v13 + v12 + v14;
    uint64_t v20 = result[6];
    uint64_t v21 = *(void *)(v16 + 40) + 8;
    while (1)
    {
      uint64_t v22 = *(void *)(v21 + 8 * v18);
      if ((*(unsigned char *)(v22 + 16) & 1) != 0 && *(_DWORD *)(v22 + 24) == a3 && *(_DWORD *)(v22 + 28) == a2) {
        break;
      }
      v10 += *(void *)(v22 + 32);
      if (v17 == ++v18) {
        goto LABEL_7;
      }
    }
    unint64_t v23 = *(void *)(v22 + 32);
    unint64_t v24 = v23;
    if (a4) {
      unint64_t v24 = (*(uint64_t (**)(uint64_t))(*(void *)a1[6] + 24))(a1[6]);
    }
    if (v23 + v10 > v19)
    {
      sub_1DD250F88((uint64_t)v37);
      sub_1DD239B24(v38, (uint64_t)"Malformed stream meta at stream index ", 38);
      long long v28 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v28, (uint64_t)" in stripe ", 11);
      uint64_t v29 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v29, (uint64_t)": streamOffset=", 15);
      char v30 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v30, (uint64_t)", streamLength=", 15);
      int64_t v31 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v31, (uint64_t)", stripeOffset=", 15);
      std::locale v32 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v32, (uint64_t)", stripeIndexLength=", 20);
      int64_t v33 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v33, (uint64_t)", stripeDataLength=", 19);
      std::ostream::operator<<();
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      sub_1DD26D86C(exception, &v36);
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t v25 = sub_1DD272A70(a1[1]);
    unint64_t v26 = operator new(0x48uLL);
    sub_1DD23960C(v26, a1[6], v10, *(void *)(v22 + 32), v20, v24);
    uint64_t v35 = v26;
    uint64_t v27 = sub_1DD272A7C(a1[1]);
    sub_1DD26C1EC(v25, (uint64_t *)&v35, v27, v20, a5);
    uint64_t result = v35;
    uint64_t v35 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  return result;
}

void sub_1DD286148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a16);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

uint64_t sub_1DD2861B8(uint64_t a1)
{
  return *(void *)(sub_1DD273400(*(void *)(a1 + 8)) + 48);
}

uint64_t sub_1DD2861D8(uint64_t a1)
{
  return sub_1DD273408(*(void *)(a1 + 8));
}

uint64_t sub_1DD2861E0(uint64_t a1)
{
  return sub_1DD273410(*(void *)(a1 + 8));
}

uint64_t sub_1DD2861E8(uint64_t result)
{
  if (!*(void *)(result + 80))
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(unsigned int *)(result + 64);
    uint64_t v3 = operator new(0x48uLL);
    sub_1DD23960C(v3, v1[6], v1[2] + v1[1] + v1[3], v1[4], v1[7], 0);
    uint64_t v8 = v3;
    sub_1DD26C1EC(v2, (uint64_t *)&v8, v1[9], v1[7], &v9);
    uint64_t v4 = (uint64_t)v8;
    uint64_t v8 = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = operator new(0x68uLL);
    sub_1DD2448B0((uint64_t)v5);
    uint64_t v6 = v1[10];
    v1[10] = v5;
    if (v6)
    {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
      uint64_t v5 = (void *)v1[10];
    }
    if ((sub_1DD2F9DB8((uint64_t)v5, v9) & 1) == 0)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D8A0(exception, "Failed to parse the stripe footer");
      __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
    }
    uint64_t result = v9;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  return result;
}

void sub_1DD286358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(a1);
}

_DWORD *sub_1DD2863DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  sub_1DD2861E8(a1);
  uint64_t v6 = *(void *)(a1 + 8);
  if (a2)
  {
    uint64_t v7 = 0;
    uint64_t v8 = a2;
    do
    {
      v6 += *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 40) + (v7 >> 29) + 8) + 32);
      v7 += 0x100000000;
      --v8;
    }
    while (v8);
  }
  uint64_t result = operator new(0x28uLL);
  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 80) + 40) + 8 * (int)a2 + 8);
  *(void *)uint64_t result = &unk_1F387A998;
  uint64_t v11 = *(unsigned int *)(v10 + 28);
  result[2] = *(_DWORD *)(v10 + 24);
  *((void *)result + 2) = v11;
  *((void *)result + 3) = v6;
  *((void *)result + 4) = *(void *)(v10 + 32);
  *a3 = result;
  return result;
}

uint64_t sub_1DD286498(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_1DD2864A0(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

void *sub_1DD2864A8(void *a1)
{
  *a1 = &unk_1F387A9D8;
  uint64_t v2 = a1[10];
  a1[10] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_1DD286518(void *__p)
{
  *std::string __p = &unk_1F387A9D8;
  uint64_t v2 = __p[10];
  __p[10] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  operator delete(__p);
}

uint64_t sub_1DD286598(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

uint64_t sub_1DD2865A0(void *a1)
{
  return a1[3] + a1[2] + a1[4];
}

uint64_t sub_1DD2865B4(uint64_t a1)
{
  return *(int *)(*(void *)(a1 + 80) + 32);
}

uint64_t sub_1DD2865E0(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 64) + 8 * a2 + 8) + 24);
}

uint64_t sub_1DD286620(uint64_t a1, int a2)
{
  return *(unsigned int *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 64) + 8 * a2 + 8) + 28);
}

uint64_t sub_1DD286660(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 80) + 96);
}

uint64_t sub_1DD28668C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = a1[1] - *a1;
  if (!v3) {
    return -1;
  }
  unint64_t v4 = (v3 >> 3) - 1;
  unint64_t v5 = v4 >> 1;
  uint64_t v6 = *(void *)(v2 + 8 * (v4 >> 1));
  if (v6 != a2 && v4 != 0)
  {
    unint64_t v8 = 0;
    unint64_t v9 = v4;
    do
    {
      if (v4 >= 2) {
        unint64_t v10 = v5 - 1;
      }
      else {
        unint64_t v10 = 0;
      }
      if (v6 >= a2) {
        unint64_t v9 = v10;
      }
      else {
        unint64_t v8 = v5 + 1;
      }
      unint64_t v4 = v9 + v8;
      unint64_t v5 = (v9 + v8) >> 1;
      uint64_t v6 = *(void *)(v2 + 8 * v5);
    }
    while (v6 != a2 && v8 < v9);
  }
  return v5 - (v6 > a2);
}

uint64_t sub_1DD286704(uint64_t a1)
{
  *(void *)a1 = &unk_1F38796D8;
  uint64_t v2 = *(void **)(a1 + 200);
  if (v2)
  {
    *(void *)(a1 + 208) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 119) < 0) {
    operator delete(*(void **)(a1 + 96));
  }
  if (*(char *)(a1 + 71) < 0) {
    operator delete(*(void **)(a1 + 48));
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1DD286788(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD286704(a1);
  operator delete(v1);
}

BOOL sub_1DD2867B0(uint64_t a1)
{
  if (*(char *)(a1 + 31) < 0) {
    uint64_t v1 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v1 = *(unsigned __int8 *)(a1 + 31);
  }
  return v1 != 0;
}

uint64_t sub_1DD2867D0(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return a1 + 32;
  }
  if (a2 % 0x2F0605980 >= 0) {
    uint64_t v3 = a2 % 0x2F0605980;
  }
  else {
    uint64_t v3 = a2 % 0x2F0605980 + 0x2F0605980;
  }
  if (*(unsigned char *)(a1 + 224) == ((sub_1DD28668C((uint64_t *)(a1 + 200), v3) & 1) == 0)) {
    return a1 + 32;
  }
  else {
    return a1 + 80;
  }
}

void sub_1DD286860(uint64_t a1, void *a2)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1))
  {
    unint64_t v4 = sub_1DD239B24(a2, (uint64_t)"  Future rule: ", 15);
    int v5 = *(char *)(a1 + 31);
    if (v5 >= 0) {
      uint64_t v6 = a1 + 8;
    }
    else {
      uint64_t v6 = *(void *)(a1 + 8);
    }
    if (v5 >= 0) {
      uint64_t v7 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      uint64_t v7 = *(void *)(a1 + 16);
    }
    unint64_t v8 = sub_1DD239B24(v4, v6, v7);
    sub_1DD239B24(v8, (uint64_t)"\n", 1);
    unint64_t v9 = sub_1DD239B24(a2, (uint64_t)"  standard ", 11);
    sub_1DD286AD4(a1 + 32);
    if ((v27 & 0x80u) == 0) {
      p_p = &__p;
    }
    else {
      p_p = __p;
    }
    if ((v27 & 0x80u) == 0) {
      uint64_t v11 = v27;
    }
    else {
      uint64_t v11 = v26;
    }
    uint64_t v12 = sub_1DD239B24(v9, (uint64_t)p_p, v11);
    sub_1DD239B24(v12, (uint64_t)"\n", 1);
    if ((char)v27 < 0) {
      operator delete(__p);
    }
    if (*(unsigned char *)(a1 + 72))
    {
      uint64_t v13 = sub_1DD239B24(a2, (uint64_t)"  dst ", 6);
      sub_1DD286AD4(a1 + 80);
      if ((v27 & 0x80u) == 0) {
        uint64_t v14 = &__p;
      }
      else {
        uint64_t v14 = __p;
      }
      if ((v27 & 0x80u) == 0) {
        uint64_t v15 = v27;
      }
      else {
        uint64_t v15 = v26;
      }
      uint64_t v16 = sub_1DD239B24(v13, (uint64_t)v14, v15);
      sub_1DD239B24(v16, (uint64_t)"\n", 1);
      if ((char)v27 < 0) {
        operator delete(__p);
      }
      int v17 = sub_1DD239B24(a2, (uint64_t)"  start ", 8);
      sub_1DD286CAC((int *)(a1 + 120));
      if ((v27 & 0x80u) == 0) {
        uint64_t v18 = &__p;
      }
      else {
        uint64_t v18 = __p;
      }
      if ((v27 & 0x80u) == 0) {
        uint64_t v19 = v27;
      }
      else {
        uint64_t v19 = v26;
      }
      uint64_t v20 = sub_1DD239B24(v17, (uint64_t)v18, v19);
      sub_1DD239B24(v20, (uint64_t)"\n", 1);
      if ((char)v27 < 0) {
        operator delete(__p);
      }
      uint64_t v21 = sub_1DD239B24(a2, (uint64_t)"  end ", 6);
      sub_1DD286CAC((int *)(a1 + 160));
      if ((v27 & 0x80u) == 0) {
        uint64_t v22 = &__p;
      }
      else {
        uint64_t v22 = __p;
      }
      if ((v27 & 0x80u) == 0) {
        uint64_t v23 = v27;
      }
      else {
        uint64_t v23 = v26;
      }
      unint64_t v24 = sub_1DD239B24(v21, (uint64_t)v22, v23);
      sub_1DD239B24(v24, (uint64_t)"\n", 1);
      if ((char)v27 < 0) {
        operator delete(__p);
      }
    }
  }
}

void sub_1DD286AAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD286AD4(uint64_t a1)
{
  sub_1DD250F88((uint64_t)v8);
  int v2 = *(char *)(a1 + 39);
  if (v2 >= 0) {
    uint64_t v3 = a1 + 16;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  if (v2 >= 0) {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 39);
  }
  else {
    uint64_t v4 = *(void *)(a1 + 24);
  }
  int v5 = sub_1DD239B24(v9, v3, v4);
  sub_1DD239B24(v5, (uint64_t)" ", 1);
  std::ostream::operator<<();
  if (*(unsigned char *)(a1 + 8)) {
    sub_1DD239B24(v9, (uint64_t)" (dst)", 6);
  }
  std::stringbuf::str();
  v8[0] = *MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v9[0] = v6;
  v9[1] = MEMORY[0x1E4FBA470] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E01B1EC0](&v11);
}

void sub_1DD286C98(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD251260((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD286CAC(int *a1)
{
  sub_1DD250F88((uint64_t)v11);
  int v2 = *a1;
  if (*a1 == 2)
  {
    sub_1DD239B24(v12, (uint64_t)"month ", 6);
    uint64_t v6 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v6, (uint64_t)" week ", 6);
    uint64_t v3 = (void *)std::ostream::operator<<();
    uint64_t v4 = " day ";
    uint64_t v5 = 5;
  }
  else if (v2 == 1)
  {
    uint64_t v3 = v12;
    uint64_t v4 = "day ";
    uint64_t v5 = 4;
  }
  else
  {
    if (v2) {
      goto LABEL_8;
    }
    uint64_t v3 = v12;
    uint64_t v4 = "julian ";
    uint64_t v5 = 7;
  }
  sub_1DD239B24(v3, (uint64_t)v4, v5);
  std::ostream::operator<<();
LABEL_8:
  sub_1DD239B24(v12, (uint64_t)" at ", 4);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v7, (uint64_t)":", 1);
  unint64_t v8 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v8, (uint64_t)":", 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  v11[0] = *MEMORY[0x1E4FBA408];
  uint64_t v9 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(void *)((char *)v11 + *(void *)(v11[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  v12[0] = v9;
  v12[1] = MEMORY[0x1E4FBA470] + 16;
  if (v13 < 0) {
    operator delete((void *)v12[9]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1E01B1EC0](&v14);
}

void sub_1DD286F64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD251260((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1DD286F78@<X0>(uint64_t a1@<X0>, const void **a2@<X8>)
{
  uint64_t v4 = operator new(0xE8uLL);
  v4[2] = 0u;
  v4[3] = 0u;
  v4[4] = 0u;
  _OWORD v4[5] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[8] = 0u;
  v4[9] = 0u;
  v4[10] = 0u;
  v4[11] = 0u;
  v4[12] = 0u;
  v4[13] = 0u;
  *((void *)v4 + 27) = 0;
  *((void *)v4 + 28) = 0;
  *(void *)uint64_t v4 = &unk_1F38796D8;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((void *)v4 + 6) = 0;
  *((void *)v4 + 7) = 0;
  *((void *)v4 + 8) = 0;
  *((void *)v4 + 12) = 0;
  *((void *)v4 + 13) = 0;
  *((void *)v4 + 14) = 0;
  *((void *)v4 + 25) = 0;
  *((void *)v4 + 26) = 0;
  sub_1DD2892CC(a2, (uint64_t)v4);
  if (*a2) {
    uint64_t v5 = __dynamic_cast(*a2, (const struct __class_type_info *)&unk_1F3877E28, (const struct __class_type_info *)&unk_1F3878018, 0);
  }
  else {
    uint64_t v5 = 0;
  }
  return sub_1DD2885F0(&v7, a1, (uint64_t)v5);
}

void sub_1DD28706C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    sub_1DD25B904(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD287094(uint64_t a1)
{
  return a1;
}

uint64_t sub_1DD2870C0(uint64_t a1, long long *a2, uint64_t *a3)
{
  *(void *)a1 = &unk_1F38795D8;
  if (*((char *)a2 + 23) < 0)
  {
    sub_1DD24F980((unsigned char *)(a1 + 8), *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    *(void *)(a1 + 24) = *((void *)a2 + 2);
    *(_OWORD *)(a1 + 8) = v5;
  }
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  uint64_t v6 = *a3;
  unint64_t v7 = a3[1] - *a3;
  *(void *)&v10.tm_sec = &unk_1F38797B8;
  sub_1DD287254(a1, v6, 0, v7, (uint64_t)&v10);
  *(_OWORD *)&v10.tm_sec = xmmword_1DD320B20;
  *(void *)&v10.tm_mon = 0x7300000000;
  v10.tm_isdst = 0;
  time_t v8 = timegm(&v10);
  *(void *)(a1 + 144) = v8 - *(void *)(*(uint64_t (**)(uint64_t, time_t))(*(void *)a1 + 16))(a1, v8);
  return a1;
}

void sub_1DD2871FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v12 = *(std::__shared_weak_count **)(v9 + 128);
  if (v12) {
    sub_1DD25B904(v12);
  }
  char v13 = *(void **)(v9 + 88);
  if (v13)
  {
    *(void *)(v9 + 96) = v13;
    operator delete(v13);
  }
  uint64_t v14 = *(void **)(v9 + 64);
  if (v14)
  {
    *(void *)(v9 + 72) = v14;
    operator delete(v14);
  }
  sub_1DD289460(&a9);
  if (*(char *)(v9 + 31) < 0) {
    operator delete(*v10);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_1DD287254(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3 + 44;
  if (a3 + 44 > a4 || strncmp((const char *)(a2 + a3), "TZif", 4uLL))
  {
    sub_1DD250F88((uint64_t)__p);
    uint64_t v35 = sub_1DD239B24(v55, (uint64_t)"non-tzfile ", 11);
    int v36 = *(char *)(a1 + 31);
    if (v36 >= 0) {
      uint64_t v37 = a1 + 8;
    }
    else {
      uint64_t v37 = *(void *)(a1 + 8);
    }
    if (v36 >= 0) {
      uint64_t v38 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      uint64_t v38 = *(void *)(a1 + 16);
    }
    sub_1DD239B24(v35, v37, v38);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(exception, &v53);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
    __cxa_throw(exception, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  uint64_t v9 = (unsigned int *)(a2 + a3 + 20);
  uint64_t v10 = bswap32(*v9);
  uint64_t v11 = bswap32(v9[1]);
  uint64_t v12 = bswap32(v9[2]);
  unint64_t v13 = bswap32(v9[3]);
  unint64_t v14 = bswap32(v9[4]);
  unint64_t v15 = bswap32(v9[5]);
  uint64_t v47 = v5;
  uint64_t v16 = v5 + (*(uint64_t (**)(uint64_t))(*(void *)a5 + 24))(a5) * v13;
  unint64_t v52 = v14;
  uint64_t v17 = v16 + v13 + 6 * v14;
  unint64_t v18 = v11 + v10 + v15 + v17 + ((*(uint64_t (**)(uint64_t))(*(void *)a5 + 24))(a5) + 4) * v12;
  if (a4 < v18)
  {
    sub_1DD250F88((uint64_t)__p);
    uint64_t v40 = sub_1DD239B24(v55, (uint64_t)"tzfile too short ", 17);
    int v41 = *(char *)(a1 + 31);
    if (v41 >= 0) {
      uint64_t v42 = a1 + 8;
    }
    else {
      uint64_t v42 = *(void *)(a1 + 8);
    }
    if (v41 >= 0) {
      uint64_t v43 = *(unsigned __int8 *)(a1 + 31);
    }
    else {
      uint64_t v43 = *(void *)(a1 + 16);
    }
    int v44 = sub_1DD239B24(v40, v42, v43);
    sub_1DD239B24(v44, (uint64_t)" needs ", 7);
    int v45 = (void *)std::ostream::operator<<();
    sub_1DD239B24(v45, (uint64_t)" and has ", 9);
    std::ostream::operator<<();
    uint64_t v46 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    std::runtime_error::runtime_error(v46, &v53);
    v46->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
    __cxa_throw(v46, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  if (!a3 && *(unsigned char *)(a2 + 4))
  {
    __p[0] = &unk_1F38797F8;
    return sub_1DD287254(a1, a2);
  }
  unint64_t v48 = a4 - v18;
  unint64_t v50 = v18;
  *(void *)(a1 + 32) = (*(uint64_t (**)(uint64_t))(*(void *)a5 + 16))(a5);
  sub_1DD28809C((uint64_t *)(a1 + 40), v52);
  sub_1DD259A10(a1 + 64, v13);
  sub_1DD259A10(a1 + 88, v13);
  __n128 v19 = sub_1DD287E88(a1, a2, v16 + v13, v52, v17, v15);
  if (v13)
  {
    uint64_t v20 = 0;
    char v21 = 0;
    while (1)
    {
      uint64_t v22 = (*(uint64_t (**)(uint64_t, __n128))(*(void *)a5 + 24))(a5, v19);
      *(void *)(*(void *)(a1 + 64) + 8 * v20) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a5 + 32))(a5, a2 + v47 + v22 * v20);
      unint64_t v23 = *(unsigned __int8 *)(a2 + v20 + v16);
      *(void *)(*(void *)(a1 + 88) + 8 * v20) = v23;
      if (v52 <= v23)
      {
        sub_1DD250F88((uint64_t)__p);
        long long v28 = sub_1DD239B24(v55, (uint64_t)"tzfile rule out of range ", 25);
        int v29 = *(char *)(a1 + 31);
        if (v29 >= 0) {
          uint64_t v30 = a1 + 8;
        }
        else {
          uint64_t v30 = *(void *)(a1 + 8);
        }
        if (v29 >= 0) {
          uint64_t v31 = *(unsigned __int8 *)(a1 + 31);
        }
        else {
          uint64_t v31 = *(void *)(a1 + 16);
        }
        std::locale v32 = sub_1DD239B24(v28, v30, v31);
        sub_1DD239B24(v32, (uint64_t)" references rule ", 17);
        int64_t v33 = (void *)std::ostream::operator<<();
        sub_1DD239B24(v33, (uint64_t)" of ", 4);
        std::ostream::operator<<();
        tm v34 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::stringbuf::str();
        std::runtime_error::runtime_error(v34, &v53);
        v34->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
        __cxa_throw(v34, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      if (v21) {
        goto LABEL_13;
      }
      if (*(unsigned char *)(*(void *)(a1 + 40) + 40 * v23 + 8))
      {
        char v21 = 0;
        if (++v20 == v13) {
          break;
        }
      }
      else
      {
        *(void *)(a1 + 112) = v23;
LABEL_13:
        ++v20;
        char v21 = 1;
        if (v20 == v13) {
          goto LABEL_16;
        }
      }
    }
  }
  *(void *)(a1 + 112) = 0;
LABEL_16:
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, unint64_t, unint64_t))(*(void *)a5 + 40))(__p, a5, a2, v50, v48);
  sub_1DD286F78((uint64_t)__p, (const void **)&v53.__r_.__value_.__l.__data_);
  long long v24 = *(_OWORD *)&v53.__r_.__value_.__l.__data_;
  *(_OWORD *)&v53.__r_.__value_.__l.__data_ = 0uLL;
  uint64_t v25 = *(std::__shared_weak_count **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = v24;
  if (v25)
  {
    sub_1DD25B904(v25);
    if (v53.__r_.__value_.__l.__size_) {
      sub_1DD25B904((std::__shared_weak_count *)v53.__r_.__value_.__l.__size_);
    }
  }
  if (SHIBYTE(v55[0]) < 0) {
    operator delete(__p[0]);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 16))(*(void *)(a1 + 120));
  if (result)
  {
    if (v13) {
      unint64_t v27 = *(void *)(*(void *)(a1 + 64) + 8 * v13 - 8);
    }
    else {
      unint64_t v27 = 0x8000000000000000;
    }
  }
  else
  {
    unint64_t v27 = 0x7FFFFFFFFFFFFFFFLL;
  }
  *(void *)(a1 + 136) = v27;
  return result;
}

void sub_1DD287878(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a22 < 0)
  {
    operator delete(__p);
    if ((v30 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a24);
      _Unwind_Resume(a1);
    }
  }
  else if (!v30)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v29);
  goto LABEL_6;
}

uint64_t sub_1DD2878F0(const void **a1)
{
  std::mutex::lock(&stru_1EAB1EBB8);
  int v2 = (uint64_t *)sub_1DD278490((uint64_t)&qword_1EB215138, a1);
  if (v2 == &qword_1EB215140)
  {
    sub_1DD2707B0((uint64_t)a1, &v17);
    size_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 16))(v17);
    sub_1DD289504(&v15, v3);
    (*(void (**)(uint64_t, void *, size_t, void))(*(void *)v17 + 32))(v17, v15, v3, 0);
    uint64_t v4 = operator new(0x98uLL);
    std::string __p = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    sub_1DD289710(&__p, v15, (uint64_t)v16, v16 - (unsigned char *)v15);
    sub_1DD2870C0((uint64_t)v4, (long long *)a1, (uint64_t *)&__p);
    sub_1DD28978C(&v14, (uint64_t)v4);
    unint64_t v18 = a1;
    uint64_t v5 = sub_1DD289578((uint64_t **)&qword_1EB215138, a1, (uint64_t)&unk_1DD320DDC, (long long **)&v18);
    long long v6 = v14;
    long long v14 = 0uLL;
    unint64_t v7 = (std::__shared_weak_count *)v5[8];
    *(_OWORD *)(v5 + 7) = v6;
    if (v7)
    {
      sub_1DD25B904(v7);
      if (*((void *)&v14 + 1)) {
        sub_1DD25B904(*((std::__shared_weak_count **)&v14 + 1));
      }
    }
    if (__p)
    {
      uint64_t v12 = __p;
      operator delete(__p);
    }
    if (v15)
    {
      uint64_t v16 = v15;
      operator delete(v15);
    }
    uint64_t v8 = v17;
    uint64_t v17 = 0;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
    unint64_t v15 = a1;
    int v2 = sub_1DD289578((uint64_t **)&qword_1EB215138, a1, (uint64_t)&unk_1DD320DDC, (long long **)&v15);
  }
  uint64_t v9 = v2[7];
  std::mutex::unlock(&stru_1EAB1EBB8);
  return v9;
}

void sub_1DD287AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, std::string *a15, std::string *a16)
{
  if (a14) {
    sub_1DD25B904(a14);
  }
  if (__p) {
    operator delete(__p);
  }
  if (a15)
  {
    a16 = a15;
    operator delete(a15);
  }
  uint64_t v19 = *(void *)(v16 - 56);
  *(void *)(v16 - 56) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  if (a2 == 1)
  {
    uint64_t v20 = __cxa_begin_catch(a1);
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    uint64_t v22 = (char *)(*(uint64_t (**)(void *))(*(void *)v20 + 16))(v20);
    sub_1DD314888(&a15, v22);
    std::runtime_error::runtime_error(exception, (const std::string *)&a15);
    exception->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
    __cxa_throw(exception, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
  }
  std::mutex::unlock(&stru_1EAB1EBB8);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD287CA0()
{
  sub_1DD314888(__p, "UTC");
  uint64_t v0 = sub_1DD287D10((uint64_t)__p);
  if (v3 < 0) {
    operator delete(__p[0]);
  }
  return v0;
}

void sub_1DD287CF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD287D10(uint64_t a1)
{
  int v2 = getenv("TZDIR");
  if (v2) {
    char v3 = v2;
  }
  else {
    char v3 = "/usr/share/zoneinfo";
  }
  sub_1DD314888(&v9, v3);
  std::string::append(&v9, "/");
  int v4 = *(char *)(a1 + 23);
  if (v4 >= 0) {
    uint64_t v5 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v5 = *(const std::string::value_type **)a1;
  }
  if (v4 >= 0) {
    std::string::size_type v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v6 = *(void *)(a1 + 8);
  }
  std::string::append(&v9, v5, v6);
  uint64_t v7 = sub_1DD2878F0((const void **)&v9.__r_.__value_.__l.__data_);
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v9.__r_.__value_.__l.__data_);
  }
  return v7;
}

void sub_1DD287DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD287DC8(uint64_t a1)
{
  *(void *)a1 = &unk_1F38795D8;
  int v2 = *(std::__shared_weak_count **)(a1 + 128);
  if (v2) {
    sub_1DD25B904(v2);
  }
  char v3 = *(void **)(a1 + 88);
  if (v3)
  {
    *(void *)(a1 + 96) = v3;
    operator delete(v3);
  }
  int v4 = *(void **)(a1 + 64);
  if (v4)
  {
    *(void *)(a1 + 72) = v4;
    operator delete(v4);
  }
  std::string::size_type v6 = (void **)(a1 + 40);
  sub_1DD289460(&v6);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void sub_1DD287E60(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD287DC8(a1);
  operator delete(v1);
}

__n128 sub_1DD287E88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (a4)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = a2 + a5;
    uint64_t v12 = (unsigned __int8 *)(a3 + a2 + 2);
    do
    {
      uint64_t v13 = *(void *)(a1 + 40) + v9;
      *(void *)uint64_t v13 = (*(v12 - 2) << 24) | ((unint64_t)*(v12 - 1) << 16) | ((unint64_t)*v12 << 8) | v12[1];
      *(unsigned char *)(v13 + 8) = v12[2] != 0;
      unint64_t v14 = v12[3];
      if (v14 >= a6)
      {
        sub_1DD250F88((uint64_t)&v22);
        sub_1DD239B24(v23, (uint64_t)"name out of range in variant ", 29);
        unint64_t v18 = (void *)std::ostream::operator<<();
        sub_1DD239B24(v18, (uint64_t)" - ", 3);
        uint64_t v19 = (void *)std::ostream::operator<<();
        sub_1DD239B24(v19, (uint64_t)" >= ", 4);
        std::ostream::operator<<();
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::stringbuf::str();
        std::runtime_error::runtime_error(exception, &v21);
        exception->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
        __cxa_throw(exception, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
      }
      sub_1DD314888(&v22, (char *)(v11 + v14));
      uint64_t v15 = *(void *)(a1 + 40) + v9;
      uint64_t v16 = v15 + 16;
      if (*(char *)(v15 + 39) < 0) {
        operator delete(*(void **)v16);
      }
      v12 += 6;
      __n128 result = v22;
      *(void *)(v16 + 16) = v23[0];
      *(__n128 *)uint64_t v16 = result;
      ++v10;
      v9 += 40;
    }
    while (a4 != v10);
  }
  return result;
}

void sub_1DD288054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      sub_1DD251260((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void sub_1DD28809C(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    sub_1DD289870(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 40 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 1) < 0) {
        operator delete(*(void **)(v3 - 24));
      }
      v3 -= 40;
    }
    a1[1] = v7;
  }
}

uint64_t sub_1DD28813C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 136) >= a2)
  {
    uint64_t v5 = sub_1DD28668C((uint64_t *)(a1 + 64), a2);
    if (v5 < 0) {
      unint64_t v6 = (void *)(a1 + 112);
    }
    else {
      unint64_t v6 = (void *)(*(void *)(a1 + 88) + 8 * v5);
    }
    return *(void *)(a1 + 40) + 40 * *v6;
  }
  else
  {
    uint64_t v3 = *(uint64_t (**)(void))(**(void **)(a1 + 120) + 24);
    return v3();
  }
}

void sub_1DD2881D4(uint64_t a1, void *a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = sub_1DD239B24(a2, (uint64_t)"Timezone file: ", 15);
  int v5 = *(char *)(a1 + 31);
  if (v5 >= 0) {
    uint64_t v6 = a1 + 8;
  }
  else {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  if (v5 >= 0) {
    uint64_t v7 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v7 = *(void *)(a1 + 16);
  }
  uint64_t v8 = sub_1DD239B24(v4, v6, v7);
  sub_1DD239B24(v8, (uint64_t)"\n", 1);
  sub_1DD239B24(a2, (uint64_t)"  Version: ", 11);
  uint64_t v9 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v9, (uint64_t)"\n", 1);
  (*(void (**)(void, void *))(**(void **)(a1 + 120) + 32))(*(void *)(a1 + 120), a2);
  if (*(void *)(a1 + 48) != *(void *)(a1 + 40))
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    do
    {
      sub_1DD239B24(a2, (uint64_t)"  Variant ", 10);
      uint64_t v12 = (void *)std::ostream::operator<<();
      uint64_t v13 = sub_1DD239B24(v12, (uint64_t)": ", 2);
      sub_1DD286AD4(*(void *)(a1 + 40) + v10);
      if (__p.tm_year >= 0) {
        p_p = &__p;
      }
      else {
        p_p = *(tm **)&__p.tm_sec;
      }
      if (__p.tm_year >= 0) {
        uint64_t tm_year_high = HIBYTE(__p.tm_year);
      }
      else {
        uint64_t tm_year_high = *(void *)&__p.tm_hour;
      }
      int v16 = sub_1DD239B24(v13, (uint64_t)p_p, tm_year_high);
      sub_1DD239B24(v16, (uint64_t)"\n", 1);
      if (SHIBYTE(__p.tm_year) < 0) {
        operator delete(*(void **)&__p.tm_sec);
      }
      ++v11;
      v10 += 40;
    }
    while (v11 < 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 3));
  }
  uint64_t v17 = *(void *)(a1 + 64);
  if (*(void *)(a1 + 72) != v17)
  {
    unint64_t v18 = 0;
    uint64_t v19 = (void *)MEMORY[0x1E4FBA250];
    do
    {
      time_t v35 = 0;
      time_t v35 = *(void *)(v17 + 8 * v18);
      if (gmtime_r(&v35, &__p))
      {
        strftime(v37, 0x19uLL, "%F %H:%M:%S", &__p);
        uint64_t v20 = v37;
      }
      else
      {
        uint64_t v20 = "null";
      }
      std::string v21 = sub_1DD239B24(v19, (uint64_t)"  Transition: ", 14);
      size_t v22 = strlen(v20);
      unint64_t v23 = sub_1DD239B24(v21, (uint64_t)v20, v22);
      sub_1DD239B24(v23, (uint64_t)" (", 2);
      long long v24 = (uint64_t *)(a1 + 64);
      uint64_t v25 = (void *)std::ostream::operator<<();
      uint64_t v26 = sub_1DD239B24(v25, (uint64_t)") -> ", 5);
      uint64_t v27 = *(void *)(a1 + 40) + 40 * *(void *)(*(void *)(a1 + 88) + 8 * v18);
      uint64_t v30 = *(void *)(v27 + 16);
      uint64_t v28 = v27 + 16;
      uint64_t v29 = v30;
      int v31 = *(char *)(v28 + 23);
      if (v31 >= 0) {
        uint64_t v32 = v28;
      }
      else {
        uint64_t v32 = v29;
      }
      if (v31 >= 0) {
        uint64_t v33 = *(unsigned __int8 *)(v28 + 23);
      }
      else {
        uint64_t v33 = *(void *)(v28 + 8);
      }
      tm v34 = sub_1DD239B24(v26, v32, v33);
      sub_1DD239B24(v34, (uint64_t)"\n", 1);
      ++v18;
      uint64_t v17 = *v24;
    }
    while (v18 < (*(void *)(a1 + 72) - *v24) >> 3);
  }
}

void sub_1DD2884E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD288504(std::runtime_error *a1)
{
  std::runtime_error::~runtime_error(a1);
  operator delete(v1);
}

uint64_t sub_1DD28852C()
{
  return 4;
}

unint64_t sub_1DD288534(uint64_t a1, unsigned __int8 *a2)
{
  return (*a2 << 24) | ((unint64_t)a2[1] << 16) | ((unint64_t)a2[2] << 8) | a2[3];
}

void *sub_1DD28855C@<X0>(void *a1@<X8>)
{
  return sub_1DD314888(a1, "");
}

uint64_t sub_1DD28856C()
{
  return 2;
}

uint64_t sub_1DD288574()
{
  return 8;
}

unint64_t sub_1DD28857C(uint64_t a1, unint64_t *a2)
{
  return bswap64(*a2);
}

void *sub_1DD288588@<X0>(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X3>, void *a4@<X8>)
{
  return sub_1DD251BA8(a4, (void *)(a1 + a2 + 1), a3 - 2);
}

uint64_t sub_1DD28859C(uint64_t a1)
{
  return *(void *)(a1 + 144);
}

uint64_t sub_1DD2885A4(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1) + a2;
}

uint64_t **sub_1DD2885F0(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  *a1 = (uint64_t *)a2;
  unint64_t v4 = (uint64_t *)*(unsigned __int8 *)(a2 + 23);
  if ((char)v4 < 0) {
    unint64_t v4 = *(uint64_t **)(a2 + 8);
  }
  a1[1] = v4;
  a1[2] = 0;
  a1[3] = (uint64_t *)a3;
  std::string::operator=((std::string *)(a3 + 8), (const std::string *)a2);
  if (a1[2] != a1[1])
  {
    sub_1DD288718((uint64_t)a1, (uint64_t)(a1[3] + 6));
    uint64_t v5 = sub_1DD2888B8(a1);
    uint64_t v6 = a1[3];
    v6[4] = -v5;
    *((unsigned char *)v6 + 40) = 0;
    uint64_t v8 = a1[1];
    uint64_t v7 = a1[2];
    *((unsigned char *)v6 + 72) = v7 < v8;
    if (v7 < v8)
    {
      sub_1DD288718((uint64_t)a1, (uint64_t)(v6 + 12));
      uint64_t v10 = a1[2];
      uint64_t v9 = a1[3];
      *((unsigned char *)v9 + 88) = 1;
      unint64_t v11 = *a1;
      if (*((char *)*a1 + 23) < 0) {
        unint64_t v11 = (uint64_t *)*v11;
      }
      if (*((unsigned char *)v10 + (void)v11) == 44)
      {
        uint64_t v12 = v9[4] + 3600;
      }
      else
      {
        uint64_t v12 = -sub_1DD2888B8(a1);
        uint64_t v9 = a1[3];
      }
      v9[10] = v12;
      sub_1DD2889AC(a1, (uint64_t)(v9 + 15));
      sub_1DD2889AC(a1, (uint64_t)(a1[3] + 20));
      uint64_t v8 = a1[1];
      uint64_t v7 = a1[2];
    }
    if (v7 != v8) {
      sub_1DD288B58(a1, "Extra text");
    }
    sub_1DD288DB8((uint64_t)a1[3]);
  }
  return a1;
}

double sub_1DD288718(uint64_t a1, uint64_t a2)
{
  std::string::size_type v3 = *(void *)(a1 + 16);
  if (v3 == *(void *)(a1 + 8)) {
    sub_1DD288B58((uint64_t **)a1, "name required");
  }
  unint64_t v4 = *(uint64_t **)a1;
  uint64_t v5 = *(uint64_t **)a1;
  if (*(char *)(*(void *)a1 + 23) < 0) {
    uint64_t v5 = (uint64_t *)*v4;
  }
  int v6 = *((unsigned __int8 *)v5 + v3);
  std::string::size_type v7 = *(void *)(a1 + 8);
  if (v6 == 60)
  {
    uint64_t v8 = *(void *)(a1 + 16);
    if (v3 < v7)
    {
      uint64_t v8 = *(void *)(a1 + 16);
      while (1)
      {
        uint64_t v9 = (uint64_t)v4;
        if (*((char *)v4 + 23) < 0) {
          uint64_t v9 = *v4;
        }
        if (*(unsigned char *)(v9 + v8) == 62) {
          break;
        }
        *(void *)(a1 + 16) = ++v8;
        if (v7 == v8) {
          goto LABEL_28;
        }
      }
    }
    if (v8 == v7) {
LABEL_28:
    }
      sub_1DD288B58((uint64_t **)a1, "missing close '>'");
    std::string::size_type v11 = v8 + 1;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    if (v3 >= v7) {
      goto LABEL_31;
    }
    uint64_t v10 = MEMORY[0x1E4F14390];
    std::string::size_type v11 = *(void *)(a1 + 16);
    while (1)
    {
      uint64_t v12 = (uint64_t)v4;
      if (*((char *)v4 + 23) < 0) {
        uint64_t v12 = *v4;
      }
      int v13 = *(char *)(v12 + v11);
      BOOL v14 = (v13 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 4 * v13 + 60) >> 10) & 1;
      if (v13 - 43 < 3 || v14) {
        break;
      }
      *(void *)(a1 + 16) = ++v11;
      if (v7 == v11)
      {
        std::string::size_type v11 = v7;
        break;
      }
    }
  }
  if (v11 == v3) {
LABEL_31:
  }
    sub_1DD288B58((uint64_t **)a1, "empty string not allowed");
  std::string::basic_string(&v17, *(const std::string **)a1, v3, v11 - v3, (std::allocator<char> *)&v18);
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  double result = *(double *)&v17.__r_.__value_.__l.__data_;
  *(std::string *)a2 = v17;
  return result;
}

uint64_t sub_1DD2888B8(void *a1)
{
  unint64_t v2 = a1[2];
  if (v2 >= a1[1])
  {
    BOOL v5 = 0;
  }
  else
  {
    std::string::size_type v3 = (void *)*a1;
    if (*(char *)(*a1 + 23) < 0) {
      std::string::size_type v3 = (void *)*v3;
    }
    int v4 = *((unsigned __int8 *)v3 + v2);
    BOOL v5 = v4 == 45;
    if (v4 == 45 || v4 == 43) {
      a1[2] = v2 + 1;
    }
  }
  uint64_t v6 = 3600 * sub_1DD288F4C((uint64_t)a1);
  unint64_t v7 = a1[2];
  if (v7 < a1[1])
  {
    unint64_t v8 = 3600;
    do
    {
      uint64_t v9 = (void *)*a1;
      if (*(char *)(*a1 + 23) < 0) {
        uint64_t v9 = (void *)*v9;
      }
      if (*((unsigned char *)v9 + v7) != 58) {
        break;
      }
      a1[2] = v7 + 1;
      v6 += sub_1DD288F4C((uint64_t)a1) * (v8 / 0x3C);
      unint64_t v7 = a1[2];
      if (v7 >= a1[1]) {
        break;
      }
      BOOL v10 = v8 > 0x77;
      v8 /= 0x3CuLL;
    }
    while (v10);
  }
  if (v5) {
    return -v6;
  }
  else {
    return v6;
  }
}

uint64_t sub_1DD2889AC(uint64_t **a1, uint64_t a2)
{
  int v4 = a1[2];
  if ((unint64_t)((char *)a1[1] - (char *)v4) < 2) {
    goto LABEL_5;
  }
  BOOL v5 = *a1;
  uint64_t v6 = *a1;
  if (*((char *)*a1 + 23) < 0) {
    uint64_t v6 = (uint64_t *)*v5;
  }
  if (*((unsigned char *)v4 + (void)v6) != 44) {
LABEL_5:
  }
    sub_1DD288B58(a1, "missing transition");
  a1[2] = (uint64_t *)((char *)v4 + 1);
  if (*((char *)v5 + 23) < 0) {
    BOOL v5 = (uint64_t *)*v5;
  }
  int v7 = *((unsigned __int8 *)v4 + (void)v5 + 1);
  if (v7 == 77)
  {
    *(_DWORD *)a2 = 2;
    a1[2] = (uint64_t *)((char *)v4 + 2);
    *(void *)(a2 + 24) = sub_1DD288F4C((uint64_t)a1);
    uint64_t v9 = a1[2];
    if (v9 == a1[1]) {
      goto LABEL_15;
    }
    BOOL v10 = *a1;
    if (*((char *)*a1 + 23) < 0) {
      BOOL v10 = (uint64_t *)*v10;
    }
    if (*((unsigned char *)v9 + (void)v10) != 46) {
LABEL_15:
    }
      sub_1DD288B58(a1, "missing first .");
    a1[2] = (uint64_t *)((char *)v9 + 1);
    *(void *)(a2 + 16) = sub_1DD288F4C((uint64_t)a1);
    std::string::size_type v11 = a1[2];
    if (v11 == a1[1]) {
      goto LABEL_20;
    }
    uint64_t v12 = *a1;
    if (*((char *)*a1 + 23) < 0) {
      uint64_t v12 = (uint64_t *)*v12;
    }
    if (*((unsigned char *)v11 + (void)v12) != 46) {
LABEL_20:
    }
      sub_1DD288B58(a1, "missing second .");
    unint64_t v8 = (uint64_t *)((char *)v11 + 1);
  }
  else
  {
    if (v7 != 74)
    {
      *(_DWORD *)a2 = 1;
      goto LABEL_24;
    }
    *(_DWORD *)a2 = 0;
    unint64_t v8 = (uint64_t *)((char *)v4 + 2);
  }
  a1[2] = v8;
LABEL_24:
  *(void *)(a2 + 8) = sub_1DD288F4C((uint64_t)a1);
  int v13 = a1[2];
  if (v13 >= a1[1]) {
    goto LABEL_29;
  }
  BOOL v14 = *a1;
  if (*((char *)*a1 + 23) < 0) {
    BOOL v14 = (uint64_t *)*v14;
  }
  if (*((unsigned char *)v13 + (void)v14) == 47)
  {
    a1[2] = (uint64_t *)((char *)v13 + 1);
    uint64_t result = sub_1DD2888B8(a1);
  }
  else
  {
LABEL_29:
    uint64_t result = 7200;
  }
  *(void *)(a2 + 32) = result;
  return result;
}

void sub_1DD288B58(uint64_t **a1, const char *a2)
{
  sub_1DD250F88((uint64_t)v14);
  size_t v4 = strlen(a2);
  BOOL v5 = sub_1DD239B24(v15, (uint64_t)a2, v4);
  sub_1DD239B24(v5, (uint64_t)" at ", 4);
  uint64_t v6 = (void *)std::ostream::operator<<();
  int v7 = sub_1DD239B24(v6, (uint64_t)" in '", 5);
  int v8 = *((char *)*a1 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (uint64_t)*a1;
  }
  else {
    uint64_t v9 = **a1;
  }
  if (v8 >= 0) {
    uint64_t v10 = *((unsigned __int8 *)*a1 + 23);
  }
  else {
    uint64_t v10 = (*a1)[1];
  }
  std::string::size_type v11 = sub_1DD239B24(v7, v9, v10);
  sub_1DD239B24(v11, (uint64_t)"'", 1);
  exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  std::stringbuf::str();
  std::runtime_error::runtime_error(exception, &v13);
  exception->__vftable = (std::runtime_error_vtbl *)&unk_1F3879690;
  __cxa_throw(exception, (struct type_info *)&unk_1F3877FC0, (void (*)(void *))std::runtime_error::~runtime_error);
}

void sub_1DD288C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v35 & 1) == 0)
    {
LABEL_6:
      a15 = *MEMORY[0x1E4FBA408];
      uint64_t v37 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(uint64_t *)((char *)&a15 + *(void *)(a15 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
      a17 = v37;
      a18 = MEMORY[0x1E4FBA470] + 16;
      if (a31 < 0) {
        operator delete(a26);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1E01B1EC0](&a34);
      _Unwind_Resume(a1);
    }
  }
  else if (!v35)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v34);
  goto LABEL_6;
}

void sub_1DD288DB8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72))
  {
    size_t v22 = (void *)(a1 + 200);
    sub_1DD259A10(a1 + 200, 0x321uLL);
    unint64_t v2 = (int *)(a1 + 120);
    uint64_t v3 = 1970;
    uint64_t v4 = sub_1DD288FF0((int *)(a1 + 120), 1970);
    BOOL v5 = (int *)(a1 + 160);
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    char v8 = v4 < sub_1DD288FF0((int *)(a1 + 160), 1970);
    *(unsigned char *)(a1 + 224) = v8;
    uint64_t v9 = (void *)(a1 + 32);
    uint64_t v21 = a1;
    uint64_t v10 = (void *)(a1 + 80);
    while (1)
    {
      if (v8) {
        std::string::size_type v11 = v2;
      }
      else {
        std::string::size_type v11 = v5;
      }
      if (v8) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = v10;
      }
      if (v8) {
        std::string v13 = v5;
      }
      else {
        std::string v13 = v2;
      }
      if (v8) {
        BOOL v14 = v10;
      }
      else {
        BOOL v14 = v9;
      }
      *(void *)(*v22 + v6 + 8) = sub_1DD288FF0(v11, v3) + v7 - *v12;
      uint64_t v15 = sub_1DD288FF0(v13, v3);
      int v16 = (void *)*v22;
      *(void *)(*v22 + v6 + 16) = v15 + v7 - *v14;
      uint64_t v17 = 31536000;
      if ((v3 & 3) == 0)
      {
        HIDWORD(v19) = -1030792151 * (unsigned __int16)v3;
        LODWORD(v19) = HIDWORD(v19);
        unsigned int v18 = v19 >> 2;
        LODWORD(v19) = HIDWORD(v19);
        BOOL v20 = (v19 >> 4) < 0xA3D70B || v18 > 0x28F5C28;
        uint64_t v17 = 31536000;
        if (v20) {
          uint64_t v17 = 31622400;
        }
      }
      if (v3 == 2369) {
        break;
      }
      v7 += v17;
      char v8 = *(unsigned char *)(v21 + 224);
      v6 += 16;
      ++v3;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 224) = 1;
    sub_1DD259A10(a1 + 200, 1uLL);
    int v16 = *(void **)(a1 + 200);
  }
  *int v16 = 0;
}

uint64_t sub_1DD288F4C(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 8);
  unint64_t v3 = *(void *)(a1 + 16);
  if (v3 >= v2) {
    sub_1DD288B58((uint64_t **)a1, "missing number");
  }
  uint64_t result = 0;
  BOOL v5 = *(uint64_t **)a1;
  uint64_t v6 = MEMORY[0x1E4F14390];
  do
  {
    uint64_t v7 = (uint64_t)v5;
    if (*((char *)v5 + 23) < 0) {
      uint64_t v7 = *v5;
    }
    unsigned int v8 = *(char *)(v7 + v3);
    if ((v8 & 0x80000000) != 0) {
      break;
    }
    if ((*(_DWORD *)(v6 + 4 * v8 + 60) & 0x400) == 0) {
      break;
    }
    uint64_t result = (int)v8 + 10 * result - 48;
    *(void *)(a1 + 16) = ++v3;
  }
  while (v2 != v3);
  return result;
}

uint64_t sub_1DD288FF0(int *a1, uint64_t a2)
{
  uint64_t result = *((void *)a1 + 4);
  int v4 = *a1;
  if (*a1 == 2)
  {
    if ((a2 & 3) != 0) {
      BOOL v9 = 0;
    }
    else {
      BOOL v9 = __ROR8__(0x8F5C28F5C28F5C29 * a2 + 0x51EB851EB851EB8, 2) > 0x28F5C28F5C28F5CuLL
    }
        || __ROR8__(0x8F5C28F5C28F5C29 * a2 + 0x51EB851EB851EB0, 4) < 0xA3D70A3D70A3D7uLL;
    uint64_t v10 = *((void *)a1 + 3);
    uint64_t v11 = a2 - (v10 < 3);
    uint64_t v12 = ((unsigned __int128)(v11 * (__int128)0x5C28F5C28F5C28F5) >> 64) - v11;
    uint64_t v13 = (uint64_t)(v11 / 400
                  + v11 % 100
                  + 2 * ((v12 >> 6) + ((unint64_t)v12 >> 63))
                  + ((int)(((v11 % 100) + (((v11 % 100) >> 13) & 3)) << 24) >> 26)
                  + (int)(((26215 * (__int16)(26 * (((int)v10 + 9) % 12) + 24)) >> 18)
                        + ((26215 * (__int16)(26 * (((int)v10 + 9) % 12) + 24)) >> 31)
                        + 1))
        % 7;
    int64_t v14 = v13 + (v13 < 0 ? 7uLL : 0);
    uint64_t v15 = *((void *)a1 + 1);
    uint64_t v16 = *((void *)a1 + 2);
    uint64_t v17 = v15 - v14;
    BOOL v7 = v15 < v14;
    uint64_t v18 = v15 - v14 + 7;
    if (v7) {
      uint64_t v19 = v18;
    }
    else {
      uint64_t v19 = v17;
    }
    uint64_t v20 = v10 - 1;
    if (v16 >= 2)
    {
      uint64_t v21 = v19 - v16 + 8 * v16 - 7;
      uint64_t v22 = v16 - 1;
      while (v19 + 7 < qword_1DD320BF8[12 * v9 + v20])
      {
        v19 += 7;
        if (!--v22)
        {
          uint64_t v19 = v21;
          break;
        }
      }
    }
    result += 86400 * v19;
    if (v10 >= 2)
    {
      unint64_t v23 = &qword_1DD320BF8[12 * v9];
      do
      {
        uint64_t v24 = *v23++;
        result += 86400 * v24;
        --v20;
      }
      while (v20);
    }
  }
  else if (v4 == 1)
  {
    result += 86400 * *((void *)a1 + 1);
  }
  else if (!v4)
  {
    uint64_t v5 = *((void *)a1 + 1);
    result += 86400 * v5;
    if ((a2 & 3) == 0)
    {
      unint64_t v6 = __ROR8__(0x8F5C28F5C28F5C29 * a2 + 0x51EB851EB851EB8, 2);
      BOOL v7 = __ROR8__(0x8F5C28F5C28F5C29 * a2 + 0x51EB851EB851EB0, 4) < 0xA3D70A3D70A3D7uLL
        || v6 > 0x28F5C28F5C28F5CLL;
      uint64_t v8 = result + 86400;
      if (!v7) {
        uint64_t v8 = result;
      }
      if (v5 >= 61) {
        return v8;
      }
    }
  }
  return result;
}

void *sub_1DD2892CC(void *a1, uint64_t a2)
{
  *a1 = a2;
  int v4 = operator new(0x20uLL);
  *int v4 = &unk_1F387CE48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1DD289324(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1DD31CB54(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD28933C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1DD28936C(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878EB8)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_1DD2893B0(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_1DD2893B0(a1, *a2);
    sub_1DD2893B0(a1, a2[1]);
    sub_1DD28940C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1DD28940C(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    sub_1DD25B904(v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    unint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

void sub_1DD289460(void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    sub_1DD2894B4((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_1DD2894B4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void *sub_1DD289504(void *a1, size_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1DD269740(a1, a2);
    int v4 = (char *)a1[1];
    uint64_t v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1DD28955C(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *sub_1DD289578(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  unint64_t v6 = (uint64_t **)sub_1DD277F14((uint64_t)a1, &v11, a2);
  BOOL v7 = *v6;
  if (!*v6)
  {
    uint64_t v8 = v6;
    sub_1DD289624((uint64_t)a1, a4, (uint64_t)v10);
    sub_1DD2694DC(a1, v11, v8, v10[0]);
    BOOL v7 = v10[0];
    v10[0] = 0;
    sub_1DD2896B8((uint64_t)v10, 0);
  }
  return v7;
}

unsigned char *sub_1DD289624@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  unint64_t v6 = operator new(0x48uLL);
  *(void *)a3 = v6;
  *(void *)(a3 + 8) = v5;
  *(unsigned char *)(a3 + 16) = 0;
  uint64_t result = v6 + 4;
  uint64_t v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_1DD24F980(result, *(void **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)uint64_t result = v9;
  }
  v6[7] = 0;
  unsigned char v6[8] = 0;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void sub_1DD2896A0(_Unwind_Exception *a1)
{
  sub_1DD2896B8(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1DD2896B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      sub_1DD28940C((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void *sub_1DD289710(void *result, const void *a2, uint64_t a3, size_t __sz)
{
  if (__sz)
  {
    unint64_t v6 = result;
    uint64_t result = sub_1DD269740(result, __sz);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1DD289770(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD28978C(void *a1, uint64_t a2)
{
  *a1 = a2;
  int v4 = operator new(0x20uLL);
  *int v4 = &unk_1F387CE10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1DD2897E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    sub_1DD31CB78(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD2897FC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t sub_1DD28982C(uint64_t a1, uint64_t a2)
{
  if (sub_1DD25B860(a2, (uint64_t)&unk_1F3878F00)) {
    return a1 + 24;
  }
  else {
    return 0;
  }
}

void sub_1DD289870(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666) {
      sub_1DD251DAC();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)sub_1DD269034(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[40 * v8];
    uint64_t v18 = &v12[40 * v11];
    size_t v14 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    sub_1DD2899D8(a1, &v15);
    sub_1DD289B7C((uint64_t)&v15);
  }
}

void sub_1DD2899C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD289B7C((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2899D8(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD289A50((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1DD289A50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    do
    {
      uint64_t v8 = *(void *)(a3 - 40);
      a3 -= 40;
      *(unsigned char *)(v7 - 32) = *(unsigned char *)(a3 + 8);
      *(void *)(v7 - 40) = v8;
      long long v9 = *(_OWORD *)(a3 + 16);
      *(void *)(v7 - 8) = *(void *)(a3 + 32);
      *(_OWORD *)(v7 - 24) = v9;
      *(void *)(a3 + 16) = 0;
      *(void *)(a3 + 24) = 0;
      *(void *)(a3 + 32) = 0;
      uint64_t v7 = *((void *)&v15 + 1) - 40;
      *((void *)&v15 + 1) -= 40;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  sub_1DD289AFC((uint64_t)v12);
  return v10;
}

uint64_t sub_1DD289AFC(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD289B34(a1);
  }
  return a1;
}

void sub_1DD289B34(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 39) < 0) {
      operator delete(*(void **)(v1 + 16));
    }
    v1 += 40;
  }
}

uint64_t sub_1DD289B7C(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DD289BB4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 40;
      *(void *)(a1 + 16) = v2 - 40;
      if (*(char *)(v2 - 1) < 0)
      {
        operator delete(*(void **)(v2 - 24));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_1DD289C0C(void *a1, uint64_t a2)
{
  a1[2] = a2;
  uint64_t v3 = a2 + 1;
  if (a1[11])
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void **)(a1[5] + 8 * v4);
      if (v5) {
        uint64_t v5 = __dynamic_cast(v5, (const struct __class_type_info *)&unk_1F3878AA0, (const struct __class_type_info *)&unk_1F3878DC8, 0);
      }
      uint64_t v3 = sub_1DD289C0C(v5, v3);
      ++v4;
    }
    while (v4 < a1[11]);
  }
  a1[3] = v3 - 1;
  return v3;
}

uint64_t sub_1DD289CCC(uint64_t a1)
{
  *(void *)a1 = &unk_1F387CBB8;
  uint64_t v3 = *(void **)(a1 + 40);
  uint64_t v2 = *(void **)(a1 + 48);
  while (v3 != v2)
  {
    if (*v3)
    {
      (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
      uint64_t v2 = *(void **)(a1 + 48);
    }
    ++v3;
  }
  uint64_t v6 = (void **)(a1 + 64);
  sub_1DD278584(&v6);
  unint64_t v4 = *(void **)(a1 + 40);
  if (v4)
  {
    *(void *)(a1 + 48) = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_1DD289D7C(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD289CCC(a1);
  operator delete(v1);
}

uint64_t sub_1DD289DA4(void *a1)
{
  uint64_t result = a1[2];
  if (result == -1)
  {
    uint64_t v3 = a1;
    do
    {
      unint64_t v4 = v3;
      uint64_t v3 = (void *)v3[1];
    }
    while (v3);
    sub_1DD289C0C(v4, 0);
    return a1[2];
  }
  return result;
}

uint64_t sub_1DD289DEC(void *a1)
{
  if (a1[2] == -1)
  {
    uint64_t v2 = a1;
    do
    {
      uint64_t v3 = v2;
      uint64_t v2 = (void *)v2[1];
    }
    while (v2);
    sub_1DD289C0C(v3, 0);
  }
  return a1[3];
}

uint64_t sub_1DD289E34(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t sub_1DD289E3C(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t sub_1DD289E44(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a1 + 40) + 8 * a2);
}

uint64_t sub_1DD289E50(uint64_t a1, uint64_t a2)
{
  return *(void *)(a1 + 64) + 24 * a2;
}

uint64_t sub_1DD289E60(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t sub_1DD289E68(uint64_t a1)
{
  return *(void *)(a1 + 104);
}

uint64_t sub_1DD289E70(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

void sub_1DD289E78(void *a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  if (v3) {
    unint64_t v4 = __dynamic_cast(v3, (const struct __class_type_info *)&unk_1F3878AA0, (const struct __class_type_info *)&unk_1F3878DC8, 0);
  }
  else {
    unint64_t v4 = 0;
  }
  unint64_t v5 = a1[7];
  uint64_t v6 = (void *)a1[6];
  if ((unint64_t)v6 >= v5)
  {
    uint64_t v8 = a1[5];
    uint64_t v9 = ((uint64_t)v6 - v8) >> 3;
    if ((unint64_t)(v9 + 1) >> 61) {
      sub_1DD251DAC();
    }
    uint64_t v10 = v5 - v8;
    uint64_t v11 = v10 >> 2;
    if (v10 >> 2 <= (unint64_t)(v9 + 1)) {
      uint64_t v11 = v9 + 1;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12) {
      char v13 = (char *)sub_1DD251DC4((uint64_t)(a1 + 7), v12);
    }
    else {
      char v13 = 0;
    }
    long long v14 = &v13[8 * v9];
    long long v15 = &v13[8 * v12];
    *(void *)long long v14 = v4;
    uint64_t v7 = v14 + 8;
    uint64_t v17 = (char *)a1[5];
    uint64_t v16 = (char *)a1[6];
    if (v16 != v17)
    {
      do
      {
        uint64_t v18 = *((void *)v16 - 1);
        v16 -= 8;
        *((void *)v14 - 1) = v18;
        v14 -= 8;
      }
      while (v16 != v17);
      uint64_t v16 = (char *)a1[5];
    }
    a1[5] = v14;
    a1[6] = v7;
    a1[7] = v15;
    if (v16) {
      operator delete(v16);
    }
  }
  else
  {
    void *v6 = v4;
    uint64_t v7 = v6 + 1;
  }
  a1[6] = v7;
  if (v4) {
    v4[1] = a1;
  }
  ++a1[11];
}

void *sub_1DD289FC0(void *a1, long long *a2, const void **a3)
{
  unint64_t v5 = *a3;
  *a3 = 0;
  uint64_t v10 = v5;
  sub_1DD289E78(a1, &v10);
  if (v10) {
    (*(void (**)(const void *))(*(void *)v10 + 8))(v10);
  }
  uint64_t v6 = a1 + 8;
  unint64_t v7 = a1[9];
  if (v7 >= a1[10])
  {
    uint64_t v8 = sub_1DD277B2C(v6, a2);
  }
  else
  {
    sub_1DD277ACC(v6, a2);
    uint64_t v8 = v7 + 24;
  }
  a1[9] = v8;
  return a1;
}

void sub_1DD28A060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CB9C(a10);
  }
  _Unwind_Resume(exception_object);
}

void *sub_1DD28A078(void *a1, const void **a2)
{
  uint64_t v3 = *a2;
  *a2 = 0;
  unint64_t v5 = v3;
  sub_1DD289E78(a1, &v5);
  if (v5) {
    (*(void (**)(const void *))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void sub_1DD28A0E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    sub_1DD31CB9C(a10);
  }
  _Unwind_Resume(exception_object);
}

void sub_1DD28A0FC(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  switch(*(_DWORD *)(a1 + 32))
  {
    case 0:
      unint64_t v4 = "BOOLean";
      goto LABEL_52;
    case 1:
      unint64_t v4 = "tinyint";
      goto LABEL_52;
    case 2:
      unint64_t v4 = "smallint";
      goto LABEL_52;
    case 3:
      unint64_t v4 = "int";
      goto LABEL_52;
    case 4:
      unint64_t v4 = "bigint";
      goto LABEL_52;
    case 5:
      unint64_t v4 = "float";
      goto LABEL_52;
    case 6:
      unint64_t v4 = "double";
      goto LABEL_52;
    case 7:
      unint64_t v4 = "string";
      goto LABEL_52;
    case 8:
      unint64_t v4 = "binary";
      goto LABEL_52;
    case 9:
      unint64_t v4 = "timestamp";
      goto LABEL_52;
    case 0xA:
      uint64_t v5 = **(void **)(a1 + 40);
      if (v5) {
        (*(void (**)(std::string *__return_ptr))(*(void *)v5 + 88))(&v50);
      }
      else {
        sub_1DD314888(&v50, "void");
      }
      uint64_t v24 = std::string::insert(&v50, 0, "array<");
      long long v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      uint64_t v26 = std::string::append(&__p, ">");
      long long v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
      a2->__r_.__value_.__r.__words[2] = v26->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v27;
      v26->__r_.__value_.__l.__size_ = 0;
      v26->__r_.__value_.__r.__words[2] = 0;
      v26->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      uint64_t v28 = (void *)v50.__r_.__value_.__r.__words[0];
      goto LABEL_85;
    case 0xB:
      uint64_t v6 = **(void **)(a1 + 40);
      if (v6) {
        (*(void (**)(std::string *__return_ptr))(*(void *)v6 + 88))(&v48);
      }
      else {
        sub_1DD314888(&v48, "void");
      }
      uint64_t v29 = std::string::insert(&v48, 0, "map<");
      long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
      v49.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v49.__r_.__value_.__l.__data_ = v30;
      v29->__r_.__value_.__l.__size_ = 0;
      v29->__r_.__value_.__r.__words[2] = 0;
      v29->__r_.__value_.__r.__words[0] = 0;
      int v31 = std::string::append(&v49, ",");
      long long v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
      v50.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v50.__r_.__value_.__l.__data_ = v32;
      v31->__r_.__value_.__l.__size_ = 0;
      v31->__r_.__value_.__r.__words[2] = 0;
      v31->__r_.__value_.__r.__words[0] = 0;
      uint64_t v33 = *(void *)(*(void *)(a1 + 40) + 8);
      if (v33) {
        (*(void (**)(void **__return_ptr))(*(void *)v33 + 88))(v46);
      }
      else {
        sub_1DD314888(v46, "void");
      }
      if ((v47 & 0x80u) == 0) {
        tm v34 = (const std::string::value_type *)v46;
      }
      else {
        tm v34 = (const std::string::value_type *)v46[0];
      }
      if ((v47 & 0x80u) == 0) {
        std::string::size_type v35 = v47;
      }
      else {
        std::string::size_type v35 = (std::string::size_type)v46[1];
      }
      int v36 = std::string::append(&v50, v34, v35);
      long long v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      __p.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      uint64_t v38 = std::string::append(&__p, ">");
      long long v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
      a2->__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
      *(_OWORD *)&a2->__r_.__value_.__l.__data_ = v39;
      v38->__r_.__value_.__l.__size_ = 0;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = 0;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      if ((char)v47 < 0) {
        operator delete(v46[0]);
      }
      if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v50.__r_.__value_.__l.__data_);
      }
      if (SHIBYTE(v49.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v49.__r_.__value_.__l.__data_);
      }
      if ((SHIBYTE(v48.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
      uint64_t v28 = (void *)v48.__r_.__value_.__r.__words[0];
LABEL_85:
      operator delete(v28);
      return;
    case 0xC:
      sub_1DD314888(a2, "struct<");
      if (*(void *)(a1 + 48) != *(void *)(a1 + 40))
      {
        uint64_t v7 = 0;
        unint64_t v8 = 0;
        do
        {
          if (v8) {
            std::string::append(a2, ",");
          }
          uint64_t v9 = *(void *)(a1 + 64) + v7;
          int v10 = *(char *)(v9 + 23);
          if (v10 >= 0) {
            uint64_t v11 = (const std::string::value_type *)(*(void *)(a1 + 64) + v7);
          }
          else {
            uint64_t v11 = *(const std::string::value_type **)v9;
          }
          if (v10 >= 0) {
            std::string::size_type v12 = *(unsigned __int8 *)(v9 + 23);
          }
          else {
            std::string::size_type v12 = *(void *)(v9 + 8);
          }
          std::string::append(a2, v11, v12);
          std::string::append(a2, ":");
          (*(void (**)(std::string *__return_ptr))(**(void **)(*(void *)(a1 + 40) + 8 * v8) + 88))(&__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_p = &__p;
          }
          else {
            p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type size = __p.__r_.__value_.__l.__size_;
          }
          std::string::append(a2, (const std::string::value_type *)p_p, size);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          ++v8;
          v7 += 24;
        }
        while (v8 < (uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 3);
      }
      goto LABEL_35;
    case 0xD:
      sub_1DD314888(a2, "uniontype<");
      uint64_t v15 = *(void *)(a1 + 40);
      if (*(void *)(a1 + 48) != v15)
      {
        unint64_t v16 = 0;
        do
        {
          if (v16)
          {
            std::string::append(a2, ",");
            uint64_t v15 = *(void *)(a1 + 40);
          }
          (*(void (**)(std::string *__return_ptr))(**(void **)(v15 + 8 * v16) + 88))(&__p);
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v17 = &__p;
          }
          else {
            uint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
          }
          if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v18 = __p.__r_.__value_.__l.__size_;
          }
          std::string::append(a2, (const std::string::value_type *)v17, v18);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__p.__r_.__value_.__l.__data_);
          }
          ++v16;
          uint64_t v15 = *(void *)(a1 + 40);
        }
        while (v16 < (*(void *)(a1 + 48) - v15) >> 3);
      }
LABEL_35:
      std::string::append(a2, ">");
      return;
    case 0xE:
      sub_1DD250F88((uint64_t)&__p);
      sub_1DD239B24(&__p.__r_.__value_.__r.__words[2], (uint64_t)"decimal(", 8);
      uint64_t v19 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v19, (uint64_t)",", 1);
      uint64_t v20 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v20, (uint64_t)")", 1);
      std::stringbuf::str();
      goto LABEL_57;
    case 0xF:
      unint64_t v4 = "date";
LABEL_52:
      sub_1DD314888(a2, v4);
      return;
    case 0x10:
      sub_1DD250F88((uint64_t)&__p);
      sub_1DD239B24(&__p.__r_.__value_.__r.__words[2], (uint64_t)"varchar(", 8);
      uint64_t v21 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v21, (uint64_t)")", 1);
      std::stringbuf::str();
      goto LABEL_57;
    case 0x11:
      sub_1DD250F88((uint64_t)&__p);
      sub_1DD239B24(&__p.__r_.__value_.__r.__words[2], (uint64_t)"char(", 5);
      uint64_t v22 = (void *)std::ostream::operator<<();
      sub_1DD239B24(v22, (uint64_t)")", 1);
      std::stringbuf::str();
LABEL_57:
      __p.__r_.__value_.__r.__words[0] = *MEMORY[0x1E4FBA408];
      std::string::size_type v23 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words
                                + *(void *)(__p.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x1E4FBA408]
                                                                                                  + 64);
      __p.__r_.__value_.__r.__words[2] = v23;
      uint64_t v42 = MEMORY[0x1E4FBA470] + 16;
      if (v44 < 0) {
        operator delete(v43);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1E01B1EC0](&v45);
      return;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(exception, "Unknown type");
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
}

void sub_1DD28A890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD28A9EC@<X0>(_DWORD *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W3>, void *a5@<X8>)
{
  switch(a1[8])
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 0xF:
      uint64_t v9 = operator new(0x78uLL);
      unint64_t result = sub_1DD28E1D4(v9, a2, a3);
      goto LABEL_65;
    case 5:
    case 6:
      uint64_t v9 = operator new(0x78uLL);
      unint64_t result = sub_1DD28E580(v9, a2, a3);
      goto LABEL_65;
    case 7:
    case 8:
    case 0x10:
    case 0x11:
      if (a4)
      {
        uint64_t v9 = operator new(0x100uLL);
        unint64_t result = sub_1DD28EADC(v9, a2, a3);
      }
      else
      {
        uint64_t v9 = operator new(0xC8uLL);
        unint64_t result = sub_1DD28ECEC(v9, a2, a3);
      }
      goto LABEL_65;
    case 9:
      uint64_t v9 = operator new(0xA0uLL);
      unint64_t result = sub_1DD290F38(v9, a2, a3);
      goto LABEL_65;
    case 0xA:
      uint64_t v29 = operator new(0x80uLL);
      sub_1DD28F568(v29, a2, a3);
      *a5 = v29;
      unint64_t result = (*(uint64_t (**)(_DWORD *, void))(*(void *)a1 + 48))(a1, 0);
      if (!result) {
        return result;
      }
      uint64_t v30 = (*(uint64_t (**)(_DWORD *, void))(*(void *)a1 + 48))(a1, 0);
      (*(void (**)(unint64_t *__return_ptr))(*(void *)v30 + 96))(&v58);
      unint64_t v31 = v58;
      unint64_t v58 = 0;
      unint64_t result = v29[15];
      v29[15] = v31;
      if (!result) {
        return result;
      }
      goto LABEL_41;
    case 0xB:
      long long v32 = operator new(0x88uLL);
      sub_1DD28FA04(v32, a2, a3);
      *a5 = v32;
      if ((*(uint64_t (**)(_DWORD *, void))(*(void *)a1 + 48))(a1, 0))
      {
        uint64_t v33 = (*(uint64_t (**)(_DWORD *, void))(*(void *)a1 + 48))(a1, 0);
        (*(void (**)(unint64_t *__return_ptr))(*(void *)v33 + 96))(&v58);
        unint64_t v34 = v58;
        unint64_t v58 = 0;
        uint64_t v35 = v32[15];
        v32[15] = v34;
        if (v35)
        {
          (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
          unint64_t v36 = v58;
          unint64_t v58 = 0;
          if (v36) {
            (*(void (**)(unint64_t))(*(void *)v36 + 8))(v36);
          }
        }
      }
      unint64_t result = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a1 + 48))(a1, 1);
      if (result)
      {
        uint64_t v37 = (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a1 + 48))(a1, 1);
        (*(void (**)(unint64_t *__return_ptr))(*(void *)v37 + 96))(&v58);
        unint64_t v38 = v58;
        unint64_t v58 = 0;
        unint64_t result = v32[16];
        v32[16] = v38;
        if (result)
        {
LABEL_41:
          (*(void (**)(unint64_t))(*(void *)result + 8))(result);
          unint64_t result = v58;
          unint64_t v58 = 0;
          if (result) {
            unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 8))(result);
          }
        }
      }
      break;
    case 0xC:
      uint64_t v11 = operator new(0x68uLL);
      sub_1DD28EF28((uint64_t)v11, a2, a3);
      unint64_t v12 = 0;
      *a5 = v11;
      char v13 = (char **)(v11 + 10);
      while (1)
      {
        unint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 40))(a1);
        if (v12 >= result) {
          break;
        }
        uint64_t v14 = (*(uint64_t (**)(_DWORD *, unint64_t))(*(void *)a1 + 48))(a1, v12);
        (*(void (**)(unint64_t *__return_ptr))(*(void *)v14 + 96))(&v58);
        unint64_t v15 = v58;
        unint64_t v58 = 0;
        uint64_t v17 = (unint64_t *)v11[11];
        unint64_t v16 = v11[12];
        if ((unint64_t)v17 >= v16)
        {
          uint64_t v19 = ((char *)v17 - *v13) >> 3;
          if ((unint64_t)(v19 + 1) >> 61) {
            sub_1DD251DAC();
          }
          uint64_t v20 = v16 - (void)*v13;
          uint64_t v21 = v20 >> 2;
          if (v20 >> 2 <= (unint64_t)(v19 + 1)) {
            uint64_t v21 = v19 + 1;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v21;
          }
          if (v22) {
            std::string::size_type v23 = (char *)sub_1DD251DC4((uint64_t)(v11 + 12), v22);
          }
          else {
            std::string::size_type v23 = 0;
          }
          uint64_t v24 = &v23[8 * v19];
          *(void *)uint64_t v24 = v15;
          std::string::size_type v18 = v24 + 8;
          uint64_t v26 = (char *)v11[10];
          long long v25 = (char *)v11[11];
          if (v25 != v26)
          {
            do
            {
              uint64_t v27 = *((void *)v25 - 1);
              v25 -= 8;
              *((void *)v24 - 1) = v27;
              v24 -= 8;
            }
            while (v25 != v26);
            long long v25 = *v13;
          }
          v11[10] = v24;
          void v11[11] = v18;
          v11[12] = &v23[8 * v22];
          if (v25) {
            operator delete(v25);
          }
        }
        else
        {
          *uint64_t v17 = v15;
          std::string::size_type v18 = v17 + 1;
        }
        void v11[11] = v18;
        unint64_t v28 = v58;
        unint64_t v58 = 0;
        if (v28) {
          (*(void (**)(unint64_t))(*(void *)v28 + 8))(v28);
        }
        ++v12;
      }
      break;
    case 0xD:
      long long v39 = operator new(0xB8uLL);
      sub_1DD290000(v39, a2, a3);
      unint64_t v40 = 0;
      *a5 = v39;
      int v41 = (char **)(v39 + 20);
      while (1)
      {
        unint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 40))(a1);
        if (v40 >= result) {
          break;
        }
        uint64_t v42 = (*(uint64_t (**)(_DWORD *, unint64_t))(*(void *)a1 + 48))(a1, v40);
        (*(void (**)(unint64_t *__return_ptr))(*(void *)v42 + 96))(&v58);
        unint64_t v43 = v58;
        unint64_t v58 = 0;
        uint64_t v45 = (unint64_t *)v39[21];
        unint64_t v44 = v39[22];
        if ((unint64_t)v45 >= v44)
        {
          uint64_t v47 = ((char *)v45 - *v41) >> 3;
          if ((unint64_t)(v47 + 1) >> 61) {
            sub_1DD251DAC();
          }
          uint64_t v48 = v44 - (void)*v41;
          uint64_t v49 = v48 >> 2;
          if (v48 >> 2 <= (unint64_t)(v47 + 1)) {
            uint64_t v49 = v47 + 1;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v50 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v50 = v49;
          }
          if (v50) {
            uint64_t v51 = (char *)sub_1DD251DC4((uint64_t)(v39 + 22), v50);
          }
          else {
            uint64_t v51 = 0;
          }
          unint64_t v52 = &v51[8 * v47];
          *(void *)unint64_t v52 = v43;
          uint64_t v46 = v52 + 8;
          long long v54 = (char *)v39[20];
          std::string v53 = (char *)v39[21];
          if (v53 != v54)
          {
            do
            {
              uint64_t v55 = *((void *)v53 - 1);
              v53 -= 8;
              *((void *)v52 - 1) = v55;
              v52 -= 8;
            }
            while (v53 != v54);
            std::string v53 = *v41;
          }
          v39[20] = v52;
          v39[21] = v46;
          v39[22] = &v51[8 * v50];
          if (v53) {
            operator delete(v53);
          }
        }
        else
        {
          *uint64_t v45 = v43;
          uint64_t v46 = v45 + 1;
        }
        v39[21] = v46;
        unint64_t v56 = v58;
        unint64_t v58 = 0;
        if (v56) {
          (*(void (**)(unint64_t))(*(void *)v56 + 8))(v56);
        }
        ++v40;
      }
      break;
    case 0xE:
      if ((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 72))(a1)
        && (unint64_t)(*(uint64_t (**)(_DWORD *))(*(void *)a1 + 72))(a1) < 0x13)
      {
        uint64_t v9 = operator new(0xA8uLL);
        unint64_t result = sub_1DD29064C(v9, a2, a3);
      }
      else
      {
        uint64_t v9 = operator new(0xA8uLL);
        unint64_t result = sub_1DD2909F8(v9, a2, a3);
      }
LABEL_65:
      *a5 = v9;
      break;
    default:
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(exception, "not supported yet");
      __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
  return result;
}

void sub_1DD28B204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  operator delete(v10);
  _Unwind_Resume(a1);
}

char *sub_1DD28B36C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char **a3@<X8>)
{
  int v3 = *(_DWORD *)(a1 + 96);
  switch(v3)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 15:
      unint64_t result = (char *)operator new(0x78uLL);
      *(void *)unint64_t result = &unk_1F387CBB8;
      *((void *)result + 1) = 0;
      *(_OWORD *)(result + 40) = 0u;
      *(_OWORD *)(result + 56) = 0u;
      *(_OWORD *)(result + 72) = 0u;
      *((void *)result + 2) = -1;
      *((void *)result + 3) = -1;
      *((_DWORD *)result + 8) = v3;
      *(_OWORD *)(result + 88) = 0u;
      *(_OWORD *)(result + 104) = 0u;
      goto LABEL_3;
    case 10:
    case 11:
    case 13:
      unint64_t result = (char *)operator new(0x78uLL);
      unint64_t v8 = result;
      *(void *)unint64_t result = &unk_1F387CBB8;
      *((void *)result + 1) = 0;
      *(_OWORD *)(result + 40) = 0u;
      *(_OWORD *)(result + 56) = 0u;
      *(_OWORD *)(result + 72) = 0u;
      *((void *)result + 2) = -1;
      *((void *)result + 3) = -1;
      *((_DWORD *)result + 8) = v3;
      *(_OWORD *)(result + 88) = 0u;
      *(_OWORD *)(result + 104) = 0u;
      *a3 = result;
      switch(v3)
      {
        case 10:
          if (*(_DWORD *)(a1 + 24) != 1)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            sub_1DD26D8A0(exception, "Illegal LIST type that doesn't contain one subtype");
LABEL_22:
            __cxa_throw(exception, (struct type_info *)&unk_1F3877E48, (void (*)(void *))std::runtime_error::~runtime_error);
          }
LABEL_25:
          uint64_t v17 = 0;
          do
          {
            sub_1DD28B36C(&v20, *(void *)(*(void *)(a2 + 64) + 8 * *(int *)(*(void *)(a1 + 32) + 4 * v17 + 8) + 8), a2);
            (*(void (**)(char *, char **))(*(void *)v8 + 112))(v8, &v20);
            unint64_t result = v20;
            uint64_t v20 = 0;
            if (result) {
              unint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)result + 8))(result);
            }
            ++v17;
          }
          while (v17 < *(int *)(a1 + 24));
          return result;
        case 11:
          if (*(_DWORD *)(a1 + 24) != 2)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            sub_1DD26D8A0(exception, "Illegal MAP type that doesn't contain two subtypes");
            goto LABEL_22;
          }
          goto LABEL_25;
        case 13:
          int v9 = *(_DWORD *)(a1 + 24);
          if (!v9)
          {
            exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
            sub_1DD26D8A0(exception, "Illegal UNION type that doesn't contain any subtypes");
            goto LABEL_22;
          }
          break;
        default:
          int v9 = *(_DWORD *)(a1 + 24);
          break;
      }
      if (v9 >= 1) {
        goto LABEL_25;
      }
      return result;
    case 12:
      unint64_t result = (char *)operator new(0x78uLL);
      *(void *)unint64_t result = &unk_1F387CBB8;
      *((void *)result + 1) = 0;
      *(_OWORD *)(result + 40) = 0u;
      *(_OWORD *)(result + 56) = 0u;
      *(_OWORD *)(result + 72) = 0u;
      *((void *)result + 2) = -1;
      *((void *)result + 3) = -1;
      *((_DWORD *)result + 8) = 12;
      *(_OWORD *)(result + 88) = 0u;
      *(_OWORD *)(result + 104) = 0u;
      *a3 = result;
      if (*(int *)(a1 + 24) >= 1)
      {
        uint64_t v14 = result;
        uint64_t v15 = 0;
        do
        {
          uint64_t v16 = *(void *)(*(void *)(a1 + 64) + 8 * v15 + 8);
          sub_1DD28B36C(&v19, *(void *)(*(void *)(a2 + 64) + 8 * *(int *)(*(void *)(a1 + 32) + 4 * v15 + 8) + 8), a2);
          (*(void (**)(char *, uint64_t, char **))(*(void *)v14 + 104))(v14, v16, &v19);
          unint64_t result = v19;
          uint64_t v19 = 0;
          if (result) {
            unint64_t result = (char *)(*(uint64_t (**)(char *))(*(void *)result + 8))(result);
          }
          ++v15;
        }
        while (v15 < *(int *)(a1 + 24));
      }
      return result;
    case 14:
      unint64_t result = (char *)operator new(0x78uLL);
      *(void *)unint64_t result = &unk_1F387CBB8;
      *((void *)result + 1) = 0;
      *(_OWORD *)(result + 40) = 0u;
      *(_OWORD *)(result + 56) = 0u;
      *(_OWORD *)(result + 72) = 0u;
      *((void *)result + 2) = -1;
      *((void *)result + 3) = -1;
      *((_DWORD *)result + 8) = 14;
      uint64_t v12 = *(void *)(a1 + 104);
      *(void *)&long long v13 = v12;
      *((void *)&v13 + 1) = HIDWORD(v12);
      *(_OWORD *)(result + 104) = v13;
      *((void *)result + 11) = 0;
      *((void *)result + 12) = 0;
      goto LABEL_3;
    case 16:
    case 17:
      unint64_t result = (char *)operator new(0x78uLL);
      uint64_t v11 = *(unsigned int *)(a1 + 100);
      *(void *)unint64_t result = &unk_1F387CBB8;
      *((void *)result + 1) = 0;
      *(_OWORD *)(result + 40) = 0u;
      *(_OWORD *)(result + 56) = 0u;
      *(_OWORD *)(result + 72) = 0u;
      *((void *)result + 2) = -1;
      *((void *)result + 3) = -1;
      *((_DWORD *)result + 8) = v3;
      *((void *)result + 11) = 0;
      *((void *)result + 12) = v11;
      *((void *)result + 13) = 0;
      *((void *)result + 14) = 0;
LABEL_3:
      *a3 = result;
      return result;
    default:
      std::string::size_type v18 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      sub_1DD26D80C(v18, "Unknown type kind");
      __cxa_throw(v18, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
  }
}

void sub_1DD28B7B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  __cxa_free_exception(v12);
  void *v10 = 0;
  (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  _Unwind_Resume(a1);
}

unint64_t sub_1DD28B890@<X0>(unint64_t result@<X0>, void *a2@<X1>, void *a3@<X8>)
{
  if (result
    && (unint64_t v5 = result,
        unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)result + 16))(result),
        ((*(void *)(*a2 + ((result >> 3) & 0x1FFFFFFFFFFFFFF8)) >> result) & 1) != 0))
  {
    switch((*(unsigned int (**)(unint64_t))(*(void *)v5 + 32))(v5))
    {
      case 0u:
      case 1u:
      case 2u:
      case 3u:
      case 4u:
      case 5u:
      case 6u:
      case 7u:
      case 8u:
      case 9u:
      case 0xFu:
        uint64_t v6 = operator new(0x78uLL);
        int v7 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v7;
        *(_OWORD *)(v6 + 11) = 0u;
        *(_OWORD *)(v6 + 13) = 0u;
        break;
      case 0xAu:
        uint64_t v6 = operator new(0x78uLL);
        int v11 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v11;
        *(_OWORD *)(v6 + 11) = 0u;
        *(_OWORD *)(v6 + 13) = 0u;
        uint64_t v12 = (*(uint64_t (**)(unint64_t, void))(*(void *)v5 + 48))(v5, 0);
        sub_1DD28B890(&v36, v12, a2);
        sub_1DD289E78(v6, &v36);
        long long v13 = v36;
        if (!v36) {
          break;
        }
        goto LABEL_14;
      case 0xBu:
        uint64_t v6 = operator new(0x78uLL);
        int v14 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v14;
        *(_OWORD *)(v6 + 11) = 0u;
        *(_OWORD *)(v6 + 13) = 0u;
        uint64_t v15 = (*(uint64_t (**)(unint64_t, void))(*(void *)v5 + 48))(v5, 0);
        sub_1DD28B890(&v35, v15, a2);
        sub_1DD289E78(v6, &v35);
        if (v35) {
          (*(void (**)(const void *))(*(void *)v35 + 8))(v35);
        }
        uint64_t v16 = (*(uint64_t (**)(unint64_t, uint64_t))(*(void *)v5 + 48))(v5, 1);
        sub_1DD28B890(&v34, v16, a2);
        sub_1DD289E78(v6, &v34);
        long long v13 = v34;
        if (v34) {
LABEL_14:
        }
          (*(void (**)(const void *))(*(void *)v13 + 8))(v13);
        break;
      case 0xCu:
        uint64_t v6 = operator new(0x78uLL);
        int v17 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v17;
        *(_OWORD *)(v6 + 11) = 0u;
        *(_OWORD *)(v6 + 13) = 0u;
        if ((*(uint64_t (**)(unint64_t))(*(void *)v5 + 40))(v5))
        {
          unint64_t v18 = 0;
          do
          {
            uint64_t v19 = (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)v5 + 48))(v5, v18);
            sub_1DD28B890(&v33, v19, a2);
            uint64_t v20 = v33;
            if (v33)
            {
              uint64_t v21 = (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)v5 + 56))(v5, v18);
              uint64_t v32 = v20;
              (*(void (**)(void *, uint64_t, uint64_t *))(*v6 + 104))(v6, v21, &v32);
              uint64_t v22 = v32;
              uint64_t v32 = 0;
              if (v22) {
                (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
              }
            }
            ++v18;
          }
          while (v18 < (*(uint64_t (**)(unint64_t))(*(void *)v5 + 40))(v5));
        }
        break;
      case 0xDu:
        uint64_t v6 = operator new(0x78uLL);
        int v23 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v23;
        *(_OWORD *)(v6 + 11) = 0u;
        *(_OWORD *)(v6 + 13) = 0u;
        if ((*(uint64_t (**)(unint64_t))(*(void *)v5 + 40))(v5))
        {
          unint64_t v24 = 0;
          do
          {
            uint64_t v25 = (*(uint64_t (**)(unint64_t, unint64_t))(*(void *)v5 + 48))(v5, v24);
            sub_1DD28B890(&v33, v25, a2);
            if (v33)
            {
              uint64_t v31 = v33;
              (*(void (**)(void *, uint64_t *))(*v6 + 112))(v6, &v31);
              uint64_t v26 = v31;
              uint64_t v31 = 0;
              if (v26) {
                (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
              }
            }
            ++v24;
          }
          while (v24 < (*(uint64_t (**)(unint64_t))(*(void *)v5 + 40))(v5));
        }
        break;
      case 0xEu:
        uint64_t v6 = operator new(0x78uLL);
        int v27 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        uint64_t v28 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 72))(v5);
        uint64_t v29 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 80))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v27;
        v6[13] = v28;
        v6[14] = v29;
        v6[11] = 0;
        v6[12] = 0;
        break;
      case 0x10u:
      case 0x11u:
        uint64_t v6 = operator new(0x78uLL);
        int v9 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 32))(v5);
        uint64_t v10 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 64))(v5);
        void *v6 = &unk_1F387CBB8;
        v6[1] = 0;
        *(_OWORD *)(v6 + 5) = 0u;
        *(_OWORD *)(v6 + 7) = 0u;
        *(_OWORD *)(v6 + 9) = 0u;
        v6[2] = -1;
        uint64_t v6[3] = -1;
        *((_DWORD *)v6 + 8) = v9;
        v6[11] = 0;
        v6[12] = v10;
        v6[13] = 0;
        v6[14] = 0;
        break;
      default:
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        sub_1DD26D80C(exception, "Unknown type kind");
        __cxa_throw(exception, (struct type_info *)&unk_1F38782A8, (void (*)(void *))std::logic_error::~logic_error);
    }
    uint64_t v8 = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 16))(v5);
    unint64_t result = (*(uint64_t (**)(unint64_t))(*(void *)v5 + 24))(v5);
    v6[2] = v8;
    uint64_t v6[3] = result;
  }
  else
  {
    uint64_t v6 = 0;
  }
  *a3 = v6;
  return result;
}

void sub_1DD28C12C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  __cxa_free_exception(v14);
  _Unwind_Resume(a1);
}

void sub_1DD28C248(uint64_t a1@<X0>, void *a2@<X8>)
{
  if (*(char *)(a1 + 23) >= 0) {
    std::string::size_type v3 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v3 = *(void *)(a1 + 8);
  }
  sub_1DD28C324(v6, (std::string *)a1, 0, v3);
  if (v6[1] - v6[0] != 32)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Invalid type string.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t v4 = *(void *)(v6[0] + 24);
  *(void *)(v6[0] + 24) = 0;
  *a2 = v4;
  int v7 = (void **)v6;
  sub_1DD28DD38(&v7);
}

void sub_1DD28C2F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_1DD28DD38(&a12);
  _Unwind_Resume(a1);
}

void sub_1DD28C324(uint64_t *__return_ptr a1@<X8>, std::string *__str@<X0>, std::string::size_type __pos@<X1>, std::string::size_type a4@<X2>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (__pos < a4)
  {
    std::string::size_type v5 = __pos;
    uint64_t v48 = a1 + 2;
    uint64_t v8 = MEMORY[0x1E4F14390];
    do
    {
      std::string::size_type v9 = v5;
      while (1)
      {
        uint64_t v10 = (__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? __str
            : (std::string *)__str->__r_.__value_.__r.__words[0];
        unsigned int v11 = v10->__r_.__value_.__s.__data_[v9];
        if (!((v11 & 0x80000000) != 0 ? __maskrune(v11, 0x500uLL) : *(_DWORD *)(v8 + 4 * v11 + 60) & 0x500))
        {
          int v13 = SHIBYTE(__str->__r_.__value_.__r.__words[2]);
          std::string::size_type v14 = __str->__r_.__value_.__r.__words[0];
          uint64_t v15 = v13 >= 0 ? __str : (std::string *)__str->__r_.__value_.__r.__words[0];
          if (v15->__r_.__value_.__s.__data_[v9] != 95) {
            break;
          }
        }
        if (++v9 >= a4)
        {
          LOBYTE(v13) = *((unsigned char *)&__str->__r_.__value_.__s + 23);
          std::string::size_type v14 = __str->__r_.__value_.__r.__words[0];
          break;
        }
      }
      memset(v57, 0, 7);
      if ((v13 & 0x80u) == 0) {
        uint64_t v16 = __str;
      }
      else {
        uint64_t v16 = (std::string *)v14;
      }
      if (v16->__r_.__value_.__s.__data_[v9] == 58)
      {
        std::string::basic_string(&v58, __str, v5, v9 - v5, (std::allocator<char> *)&v56);
        std::string::size_type size = (void *)v58.__r_.__value_.__l.__size_;
        __src = (void *)v58.__r_.__value_.__r.__words[0];
        v57[0] = v58.__r_.__value_.__r.__words[2];
        *(_DWORD *)((char *)v57 + 3) = *(_DWORD *)((char *)&v58.__r_.__value_.__r.__words[2] + 3);
        char v50 = HIBYTE(v58.__r_.__value_.__r.__words[2]);
        std::string::size_type v5 = v9 + 1;
        std::string::size_type v9 = v5;
        if (v5 < a4)
        {
          while (1)
          {
            unint64_t v18 = (__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                ? __str
                : (std::string *)__str->__r_.__value_.__r.__words[0];
            unsigned int v19 = v18->__r_.__value_.__s.__data_[v9];
            if (!((v19 & 0x80000000) != 0 ? __maskrune(v19, 0x100uLL) : *(_DWORD *)(v8 + 4 * v19 + 60) & 0x100)) {
              break;
            }
            if (a4 == ++v9)
            {
              std::string::size_type v9 = a4;
              break;
            }
          }
        }
      }
      else
      {
        __src = 0;
        std::string::size_type size = 0;
        char v50 = 0;
      }
      std::string::size_type v21 = v9 + 1;
      if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v22 = __str;
      }
      else {
        uint64_t v22 = (std::string *)__str->__r_.__value_.__r.__words[0];
      }
      int v23 = v22->__r_.__value_.__s.__data_[v9];
      std::string::size_type v24 = v9 + 1;
      if (v23 == 40)
      {
        if (v21 < a4)
        {
          std::string::size_type v24 = v9 + 1;
          while (v22->__r_.__value_.__s.__data_[v24] != 41)
          {
            if (a4 == ++v24) {
              goto LABEL_96;
            }
          }
        }
        if (v24 == a4)
        {
LABEL_96:
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "Invalid type string. Cannot find closing)");
LABEL_97:
          __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
        }
      }
      else if (v23 == 60)
      {
        if (v21 < a4)
        {
          int v25 = 1;
          std::string::size_type v24 = v9 + 1;
          while (1)
          {
            int v26 = v22->__r_.__value_.__s.__data_[v24];
            if (v26 == 60)
            {
              if (!++v25) {
                break;
              }
            }
            else if (v26 == 62 && !--v25)
            {
              break;
            }
            if (a4 == ++v24) {
              goto LABEL_95;
            }
          }
        }
        if (v24 == a4)
        {
LABEL_95:
          uint64_t v46 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(v46, "Invalid type string. Cannot find closing >");
          __cxa_throw(v46, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
        }
      }
      else if (v9 != a4)
      {
        std::string::size_type v24 = v9 + 1;
        if (v23 != 44)
        {
          exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "Unrecognized character.");
          goto LABEL_97;
        }
      }
      std::string::basic_string(&v56, __str, v5, v9 - v5, (std::allocator<char> *)&v58);
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
        sub_1DD24F980(&__dst, v56.__r_.__value_.__l.__data_, v56.__r_.__value_.__l.__size_);
      }
      else {
        std::string __dst = v56;
      }
      sub_1DD28D2E4(&__dst, __str, v21, v24, &v52);
      if (v50 < 0)
      {
        sub_1DD24F980(__p, __src, (unint64_t)size);
      }
      else
      {
        __p[0] = __src;
        __p[1] = size;
        LODWORD(v54) = v57[0];
        *(_DWORD *)((char *)&v54 + 3) = *(_DWORD *)((char *)v57 + 3);
        HIBYTE(v54) = v50;
      }
      int v27 = v52;
      unint64_t v52 = 0;
      uint64_t v55 = v27;
      unint64_t v28 = a1[1];
      unint64_t v29 = a1[2];
      if (v28 >= v29)
      {
        uint64_t v33 = (uint64_t)(v28 - *a1) >> 5;
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) >> 59) {
          sub_1DD251DAC();
        }
        uint64_t v35 = v29 - *a1;
        if (v35 >> 4 > v34) {
          unint64_t v34 = v35 >> 4;
        }
        if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v36 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v36 = v34;
        }
        std::string v60 = v48;
        uint64_t v37 = (char *)sub_1DD28DED8((uint64_t)v48, v36);
        std::string::size_type v38 = (std::string::size_type)&v37[32 * v33];
        v58.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
        v58.__r_.__value_.__l.__size_ = v38;
        uint64_t v59 = &v37[32 * v39];
        long long v40 = *(_OWORD *)__p;
        *(void *)(v38 + 16) = v54;
        *(_OWORD *)std::string::size_type v38 = v40;
        __p[0] = 0;
        __p[1] = 0;
        int v41 = v55;
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        *(void *)(v38 + 24) = v41;
        v58.__r_.__value_.__r.__words[2] = v38 + 32;
        sub_1DD28DE60(a1, &v58);
        uint64_t v32 = a1[1];
        sub_1DD28E04C((void **)&v58.__r_.__value_.__l.__data_);
      }
      else
      {
        long long v30 = *(_OWORD *)__p;
        *(void *)(v28 + 16) = v54;
        *(_OWORD *)unint64_t v28 = v30;
        __p[0] = 0;
        __p[1] = 0;
        uint64_t v31 = v55;
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        *(void *)(v28 + 24) = v31;
        uint64_t v32 = v28 + 32;
        a1[1] = v28 + 32;
      }
      a1[1] = v32;
      uint64_t v42 = v55;
      uint64_t v55 = 0;
      if (v42) {
        (*(void (**)(char *))(*(void *)v42 + 8))(v42);
      }
      if (SHIBYTE(v54) < 0) {
        operator delete(__p[0]);
      }
      unint64_t v43 = v52;
      unint64_t v52 = 0;
      if (v43) {
        (*(void (**)(char *))(*(void *)v43 + 8))(v43);
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      if (v24 < a4
        && ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? (unint64_t v44 = __str)
          : (unint64_t v44 = (std::string *)__str->__r_.__value_.__r.__words[0]),
            (int v45 = v44->__r_.__value_.__s.__data_[v24], v45 == 62) || v45 == 41))
      {
        std::string::size_type v5 = v24 + 2;
      }
      else
      {
        std::string::size_type v5 = v24;
      }
      if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v56.__r_.__value_.__l.__data_);
        if (v50 < 0) {
LABEL_93:
        }
          operator delete(__src);
      }
      else if (v50 < 0)
      {
        goto LABEL_93;
      }
    }
    while (v5 < a4);
  }
}

void sub_1DD28C898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, int a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  __cxa_free_exception(v32);
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_1DD28DD38((void ***)&a23);
  _Unwind_Resume(a1);
}

void sub_1DD28C97C(std::string *a1@<X0>, std::string::size_type a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (char *)operator new(0x78uLL);
  *(void *)uint64_t v6 = &unk_1F387CBB8;
  *((void *)v6 + 1) = 0;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *((void *)v6 + 2) = -1;
  *((void *)v6 + 3) = -1;
  *((_DWORD *)v6 + 8) = 10;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *a3 = v6;
  sub_1DD28C324(v10, a1, a2);
  if (v10[1] - v10[0] != 32)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Array type must contain exactly one sub type.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  int v7 = *(const void **)(v10[0] + 24);
  *(void *)(v10[0] + 24) = 0;
  std::string::size_type v9 = v7;
  sub_1DD289E78(v6, &v9);
  if (v9) {
    (*(void (**)(const void *))(*(void *)v9 + 8))(v9);
  }
  unsigned int v11 = (void **)v10;
  sub_1DD28DD38(&v11);
}

void sub_1DD28CAC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_1DD28DD38(&a14);
  void *v14 = 0;
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void sub_1DD28CB3C(std::string *a1@<X0>, std::string::size_type a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = operator new(0x78uLL);
  void *v6 = &unk_1F387CBB8;
  v6[1] = 0;
  *(_OWORD *)(v6 + 5) = 0u;
  *(_OWORD *)(v6 + 7) = 0u;
  *(_OWORD *)(v6 + 9) = 0u;
  v6[2] = -1;
  uint64_t v6[3] = -1;
  *((_DWORD *)v6 + 8) = 11;
  *(_OWORD *)(v6 + 11) = 0u;
  *(_OWORD *)(v6 + 13) = 0u;
  *a3 = v6;
  sub_1DD28C324(v12, a1, a2);
  if (v12[1] - v12[0] != 64)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Map type must contain exactly two sub types.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  int v7 = *(const void **)(v12[0] + 24);
  *(void *)(v12[0] + 24) = 0;
  unsigned int v11 = v7;
  sub_1DD289E78(v6, &v11);
  if (v11) {
    (*(void (**)(const void *))(*(void *)v11 + 8))(v11);
  }
  uint64_t v8 = *(const void **)(v12[0] + 56);
  *(void *)(v12[0] + 56) = 0;
  uint64_t v10 = v8;
  sub_1DD289E78(v6, &v10);
  if (v10) {
    (*(void (**)(const void *))(*(void *)v10 + 8))(v10);
  }
  int v13 = (void **)v12;
  sub_1DD28DD38(&v13);
}

void sub_1DD28CCD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_1DD28DD38(&a14);
  void *v14 = 0;
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void sub_1DD28CD58(std::string *a1@<X0>, std::string::size_type a2@<X1>, char **a3@<X8>)
{
  uint64_t v6 = (char *)operator new(0x78uLL);
  *(void *)uint64_t v6 = &unk_1F387CBB8;
  *((void *)v6 + 1) = 0;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *((void *)v6 + 2) = -1;
  *((void *)v6 + 3) = -1;
  *((_DWORD *)v6 + 8) = 12;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *a3 = v6;
  sub_1DD28C324(&v14, a1, a2);
  uint64_t v7 = v14;
  if (v15 == v14)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Struct type must contain at least one sub type.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t v8 = 0;
  unint64_t v9 = 0;
  do
  {
    uint64_t v10 = v7 + v8;
    uint64_t v11 = *(void *)(v7 + v8 + 24);
    *(void *)(v10 + 24) = 0;
    uint64_t v13 = v11;
    (*(void (**)(char *))(*(void *)v6 + 104))(v6);
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
    ++v9;
    uint64_t v7 = v14;
    v8 += 32;
  }
  while (v9 < (v15 - v14) >> 5);
  uint64_t v16 = (void **)&v14;
  sub_1DD28DD38(&v16);
}

void sub_1DD28CEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_1DD28DD38(&a14);
  void *v14 = 0;
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void sub_1DD28CF60(std::string *a1@<X0>, std::string::size_type a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (char *)operator new(0x78uLL);
  *(void *)uint64_t v6 = &unk_1F387CBB8;
  *((void *)v6 + 1) = 0;
  *(_OWORD *)(v6 + 40) = 0u;
  *(_OWORD *)(v6 + 56) = 0u;
  *(_OWORD *)(v6 + 72) = 0u;
  *((void *)v6 + 2) = -1;
  *((void *)v6 + 3) = -1;
  *((_DWORD *)v6 + 8) = 13;
  *(_OWORD *)(v6 + 88) = 0u;
  *(_OWORD *)(v6 + 104) = 0u;
  *a3 = v6;
  sub_1DD28C324(&v14, a1, a2);
  uint64_t v7 = v14;
  if (v15 == v14)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Union type must contain at least one sub type.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  unint64_t v8 = 0;
  uint64_t v9 = 24;
  do
  {
    uint64_t v10 = *(const void **)(v7 + v9);
    *(void *)(v7 + v9) = 0;
    uint64_t v13 = v10;
    sub_1DD289E78(v6, &v13);
    uint64_t v11 = v13;
    uint64_t v13 = 0;
    if (v11) {
      (*(void (**)(const void *))(*(void *)v11 + 8))(v11);
    }
    ++v8;
    uint64_t v7 = v14;
    v9 += 32;
  }
  while (v8 < (v15 - v14) >> 5);
  uint64_t v16 = (void **)&v14;
  sub_1DD28DD38(&v16);
}

void sub_1DD28D0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void **a14)
{
  a14 = (void **)&a11;
  sub_1DD28DD38(&a14);
  void *v14 = 0;
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

double sub_1DD28D140@<D0>(std::string::size_type __pos@<X1>, const std::string *a2@<X0>, std::string::size_type a3@<X2>, void *a4@<X8>)
{
  std::string::size_type v8 = std::string::find(a2, 44, __pos);
  std::string::size_type v9 = v8 + 1;
  if (v8 == -1 || v9 >= a3)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Decimal type must specify precision and scale.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  std::string::size_type v10 = v8;
  std::string::basic_string(&v18, a2, __pos, v8 - __pos, (std::allocator<char> *)&v19);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v12 = (void *)v18.__r_.__value_.__r.__words[0];
    int v11 = atoi(v18.__r_.__value_.__l.__data_);
    operator delete(v12);
  }
  else
  {
    int v11 = atoi((const char *)&v18);
  }
  std::string::basic_string(&v18, a2, v9, ~v10 + a3, (std::allocator<char> *)&v19);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
  {
    uint64_t v14 = (void *)v18.__r_.__value_.__r.__words[0];
    int v13 = atoi(v18.__r_.__value_.__l.__data_);
    operator delete(v14);
  }
  else
  {
    int v13 = atoi((const char *)&v18);
  }
  uint64_t v15 = (char *)operator new(0x78uLL);
  *(void *)uint64_t v15 = &unk_1F387CBB8;
  *((void *)v15 + 1) = 0;
  double result = 0.0;
  *(_OWORD *)(v15 + 40) = 0u;
  *(_OWORD *)(v15 + 56) = 0u;
  *(_OWORD *)(v15 + 72) = 0u;
  *((void *)v15 + 2) = -1;
  *((void *)v15 + 3) = -1;
  *((_DWORD *)v15 + 8) = 14;
  *((void *)v15 + 13) = v11;
  *((void *)v15 + 14) = v13;
  *((void *)v15 + 11) = 0;
  *((void *)v15 + 12) = 0;
  *a4 = v15;
  return result;
}

void sub_1DD28D2D0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

double sub_1DD28D2E4@<D0>(void *a1@<X0>, std::string *a2@<X1>, std::string::size_type a3@<X2>, std::string::size_type a4@<X3>, char **a5@<X8>)
{
  if ((*((char *)a1 + 23) & 0x80000000) == 0)
  {
    int v10 = *((unsigned __int8 *)a1 + 23);
    int v11 = a1;
    switch(*((unsigned char *)a1 + 23))
    {
      case 3:
        goto LABEL_3;
      case 5:
        goto LABEL_59;
      case 6:
        goto LABEL_54;
      case 7:
        if (*(_DWORD *)a1 == 1819242338 && *(_DWORD *)((char *)a1 + 3) == 1851876716) {
          goto LABEL_48;
        }
        if (*(_DWORD *)a1 == 2037279092 && *(_DWORD *)((char *)a1 + 3) == 1953393017) {
          goto LABEL_73;
        }
        if (v10 == 3) {
          goto LABEL_3;
        }
        int v11 = a1;
        if (v10 == 5) {
          goto LABEL_59;
        }
        if (v10 != 6) {
          goto LABEL_63;
        }
LABEL_54:
        if (*(_DWORD *)a1 == 1768384866 && *((_WORD *)a1 + 2) == 29806) {
          goto LABEL_72;
        }
        int v11 = a1;
        if (v10 == 5) {
          goto LABEL_59;
        }
        goto LABEL_63;
      case 8:
        if (*a1 == 0x746E696C6C616D73) {
          goto LABEL_71;
        }
        if (v10 == 6) {
          goto LABEL_54;
        }
        int v11 = a1;
        if (v10 == 5) {
          goto LABEL_59;
        }
        if (v10 != 3) {
          goto LABEL_63;
        }
LABEL_3:
        if (*(_WORD *)a1 != 28265 || *((unsigned char *)a1 + 2) != 116) {
          goto LABEL_63;
        }
        goto LABEL_70;
      default:
        goto LABEL_63;
    }
  }
  uint64_t v13 = a1[1];
  if (v13 == 7)
  {
    uint64_t v14 = (int *)*a1;
    if (*(_DWORD *)*a1 == 1819242338 && *(_DWORD *)(*a1 + 3) == 1851876716)
    {
LABEL_48:
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      *((_DWORD *)v23 + 8) = 0;
LABEL_77:
      *(_OWORD *)(v23 + 88) = v24;
      *(_OWORD *)(v23 + 104) = v24;
LABEL_78:
      *a5 = v23;
      return *(double *)&v24;
    }
    int v16 = *v14;
    int v17 = *(int *)((char *)v14 + 3);
    if (v16 == 2037279092 && v17 == 1953393017)
    {
LABEL_73:
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 1;
      goto LABEL_76;
    }
    uint64_t v13 = a1[1];
  }
  if (v13 == 8)
  {
    if (*(void *)*a1 == 0x746E696C6C616D73)
    {
LABEL_71:
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 2;
      goto LABEL_76;
    }
    uint64_t v13 = a1[1];
  }
  if (v13 == 3)
  {
    if (*(_WORD *)*a1 == 28265 && *(unsigned char *)(*a1 + 2) == 116)
    {
LABEL_70:
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 3;
      goto LABEL_76;
    }
    uint64_t v13 = a1[1];
  }
  if (v13 == 6)
  {
    if (*(_DWORD *)*a1 == 1768384866 && *(_WORD *)(*a1 + 4) == 29806)
    {
LABEL_72:
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 4;
      goto LABEL_76;
    }
    uint64_t v13 = a1[1];
  }
  if (v13 == 5)
  {
    int v11 = (void *)*a1;
LABEL_59:
    int v26 = *(_DWORD *)v11;
    int v27 = *((unsigned __int8 *)v11 + 4);
    if (v26 == 1634692198 && v27 == 116)
    {
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 5;
      goto LABEL_76;
    }
  }
LABEL_63:
  if (sub_1DD28DC40(a1, "double"))
  {
    int v23 = (char *)operator new(0x78uLL);
    *(void *)int v23 = &unk_1F387CBB8;
    *((void *)v23 + 1) = 0;
    long long v24 = 0uLL;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_OWORD *)(v23 + 72) = 0u;
    *((void *)v23 + 2) = -1;
    *((void *)v23 + 3) = -1;
    int v29 = 6;
LABEL_76:
    *((_DWORD *)v23 + 8) = v29;
    goto LABEL_77;
  }
  if (sub_1DD28DC40(a1, "string"))
  {
    int v23 = (char *)operator new(0x78uLL);
    *(void *)int v23 = &unk_1F387CBB8;
    *((void *)v23 + 1) = 0;
    long long v24 = 0uLL;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_OWORD *)(v23 + 72) = 0u;
    *((void *)v23 + 2) = -1;
    *((void *)v23 + 3) = -1;
    int v29 = 7;
    goto LABEL_76;
  }
  if (sub_1DD28DC40(a1, "binary"))
  {
    int v23 = (char *)operator new(0x78uLL);
    *(void *)int v23 = &unk_1F387CBB8;
    *((void *)v23 + 1) = 0;
    long long v24 = 0uLL;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_OWORD *)(v23 + 72) = 0u;
    *((void *)v23 + 2) = -1;
    *((void *)v23 + 3) = -1;
    int v29 = 8;
    goto LABEL_76;
  }
  if (sub_1DD28DC40(a1, "timestamp"))
  {
    int v23 = (char *)operator new(0x78uLL);
    *(void *)int v23 = &unk_1F387CBB8;
    *((void *)v23 + 1) = 0;
    long long v24 = 0uLL;
    *(_OWORD *)(v23 + 40) = 0u;
    *(_OWORD *)(v23 + 56) = 0u;
    *(_OWORD *)(v23 + 72) = 0u;
    *((void *)v23 + 2) = -1;
    *((void *)v23 + 3) = -1;
    int v29 = 9;
    goto LABEL_76;
  }
  if (sub_1DD28DC40(a1, "array"))
  {
    sub_1DD28C97C(a2, a3, a5);
  }
  else if (sub_1DD28DC40(a1, "map"))
  {
    sub_1DD28CB3C(a2, a3, a5);
  }
  else if (sub_1DD28DC40(a1, "struct"))
  {
    sub_1DD28CD58(a2, a3, a5);
  }
  else if (sub_1DD28DC40(a1, "uniontype"))
  {
    sub_1DD28CF60(a2, a3, a5);
  }
  else
  {
    if (!sub_1DD28DC40(a1, "decimal"))
    {
      if (!sub_1DD28DC40(a1, "date"))
      {
        if (sub_1DD28DC40(a1, "varchar"))
        {
          std::string::basic_string(&v36, a2, a3, a4 - a3, (std::allocator<char> *)&v37);
          if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v31 = (void *)v36.__r_.__value_.__r.__words[0];
            LODWORD(v30) = atoi(v36.__r_.__value_.__l.__data_);
            operator delete(v31);
          }
          else
          {
            LODWORD(v30) = atoi((const char *)&v36);
          }
          uint64_t v30 = (int)v30;
          int v23 = (char *)operator new(0x78uLL);
          *(void *)int v23 = &unk_1F387CBB8;
          *((void *)v23 + 1) = 0;
          *(void *)&long long v24 = 0;
          *(_OWORD *)(v23 + 40) = 0u;
          *(_OWORD *)(v23 + 56) = 0u;
          *(_OWORD *)(v23 + 72) = 0u;
          *((void *)v23 + 2) = -1;
          *((void *)v23 + 3) = -1;
          int v32 = 16;
        }
        else
        {
          if (!sub_1DD28DC40(a1, "char"))
          {
            exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::operator+<char>();
            std::logic_error::logic_error(exception, &v36);
            __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
          }
          std::string::basic_string(&v36, a2, a3, a4 - a3, (std::allocator<char> *)&v37);
          if (SHIBYTE(v36.__r_.__value_.__r.__words[2]) < 0)
          {
            uint64_t v33 = (void *)v36.__r_.__value_.__r.__words[0];
            LODWORD(v30) = atoi(v36.__r_.__value_.__l.__data_);
            operator delete(v33);
          }
          else
          {
            LODWORD(v30) = atoi((const char *)&v36);
          }
          uint64_t v30 = (int)v30;
          int v23 = (char *)operator new(0x78uLL);
          *(void *)int v23 = &unk_1F387CBB8;
          *((void *)v23 + 1) = 0;
          *(void *)&long long v24 = 0;
          *(_OWORD *)(v23 + 40) = 0u;
          *(_OWORD *)(v23 + 56) = 0u;
          *(_OWORD *)(v23 + 72) = 0u;
          *((void *)v23 + 2) = -1;
          *((void *)v23 + 3) = -1;
          int v32 = 17;
        }
        *((_DWORD *)v23 + 8) = v32;
        *((void *)v23 + 11) = 0;
        *((void *)v23 + 12) = v30;
        *((void *)v23 + 13) = 0;
        *((void *)v23 + 14) = 0;
        goto LABEL_78;
      }
      int v23 = (char *)operator new(0x78uLL);
      *(void *)int v23 = &unk_1F387CBB8;
      *((void *)v23 + 1) = 0;
      long long v24 = 0uLL;
      *(_OWORD *)(v23 + 40) = 0u;
      *(_OWORD *)(v23 + 56) = 0u;
      *(_OWORD *)(v23 + 72) = 0u;
      *((void *)v23 + 2) = -1;
      *((void *)v23 + 3) = -1;
      int v29 = 15;
      goto LABEL_76;
    }
    *(double *)&long long v24 = sub_1DD28D140(a3, a2, a4, a5);
  }
  return *(double *)&v24;
}

void sub_1DD28DBF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v15 & 1) == 0) {
LABEL_6:
    }
      _Unwind_Resume(a1);
  }
  else if (!v15)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v14);
  goto LABEL_6;
}

BOOL sub_1DD28DC40(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (*((char *)a1 + 23) < 0)
  {
    if (v4 == a1[1])
    {
      if (v4 == -1) {
        goto LABEL_10;
      }
      a1 = (void *)*a1;
      return memcmp(a1, __s, v4) == 0;
    }
  }
  else if (v4 == *((unsigned __int8 *)a1 + 23))
  {
    if (v4 == -1) {
LABEL_10:
    }
      sub_1DD28DE48();
    return memcmp(a1, __s, v4) == 0;
  }
  return 0;
}

uint64_t sub_1DD28DCD4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_1DD28DD38(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    std::string::size_type v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 32;
        sub_1DD28DDD0((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      std::string::size_type v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1DD28DDD0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  *(void *)(a2 + 24) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    uint64_t v4 = *(void **)a2;
    operator delete(v4);
  }
}

void sub_1DD28DE48()
{
}

uint64_t sub_1DD28DE60(uint64_t *a1, void *a2)
{
  uint64_t result = sub_1DD28DF10((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1DD28DED8(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59) {
    sub_1DD251C54();
  }
  return operator new(32 * a2);
}

uint64_t sub_1DD28DF10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = a7 - 32;
    do
    {
      long long v9 = *(_OWORD *)(a3 - 32);
      *(void *)(v8 + 16) = *(void *)(a3 - 16);
      *(_OWORD *)uint64_t v8 = v9;
      *(void *)(a3 - 32) = 0;
      *(void *)(a3 - 24) = 0;
      uint64_t v10 = *(void *)(a3 - 8);
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(v8 + 24) = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 32;
      v8 -= 32;
      a3 -= 32;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  sub_1DD28DFC0((uint64_t)v13);
  return v11;
}

uint64_t sub_1DD28DFC0(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_1DD28DFF8((uint64_t *)a1);
  }
  return a1;
}

void sub_1DD28DFF8(uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      sub_1DD28DDD0(v3, v1);
      v1 += 32;
    }
    while (v1 != v2);
  }
}

void **sub_1DD28E04C(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void sub_1DD28E080(void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 32;
    sub_1DD28DDD0(v4, i - 32);
  }
}

void sub_1DD28E0D0(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
  }
}

uint64_t sub_1DD28E0EC(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD28E0F4(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_1DD28E0FC()
{
  return 0;
}

uint64_t sub_1DD28E104(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879920;
  sub_1DD270020(a1 + 80, a3, a2);
  return a1;
}

void sub_1DD28E1BC(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD28E1D8(void *a1)
{
  *a1 = &unk_1F3879920;
  sub_1DD270394((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD28E240(void *a1)
{
  *a1 = &unk_1F3879920;
  sub_1DD270394((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  operator delete(a1);
}

uint64_t sub_1DD28E2B8()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Long vector <", 13);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD28E424(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD28E438(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2);
  }
}

uint64_t sub_1DD28E498(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD28E4A0(uint64_t a1)
{
  return *(void *)(a1 + 56) + 8 * *(void *)(a1 + 112);
}

uint64_t sub_1DD28E4B0(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879DF0;
  sub_1DD26FD30((void *)(a1 + 80), a3, a2);
  return a1;
}

void sub_1DD28E568(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD28E584(void *a1)
{
  *a1 = &unk_1F3879DF0;
  sub_1DD2702F4((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD28E5EC(void *a1)
{
  *a1 = &unk_1F3879DF0;
  sub_1DD2702F4((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  operator delete(a1);
}

uint64_t sub_1DD28E664()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Double vector <", 15);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD28E7D0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD28E7E4(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2);
  }
}

uint64_t sub_1DD28E844(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD28E84C(uint64_t a1)
{
  return *(void *)(a1 + 56) + 8 * *(void *)(a1 + 112);
}

uint64_t sub_1DD28E85C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1DD26FA14(a1, a2);
  sub_1DD270020(v4 + 40, a2, 0);
  return a1;
}

void sub_1DD28E89C(_Unwind_Exception *a1)
{
  sub_1DD2701B4(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD28E8B4(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (void *)sub_1DD28E93C(a1, a2, a3);
  void *v6 = &unk_1F387B050;
  v6[25] = 0;
  v6[26] = 0;
  sub_1DD270020(v6 + 27, a3, a2);
  return a1;
}

void sub_1DD28E91C(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)v1[26];
  if (v3) {
    sub_1DD25B904(v3);
  }
  sub_1DD28EA5C(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD28E93C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879E60;
  sub_1DD26FBC4((void *)(a1 + 80), a3, a2);
  sub_1DD270020(a1 + 120, a3, a2);
  sub_1DD26FA14(a1 + 160, a3);
  return a1;
}

void sub_1DD28EA24(_Unwind_Exception *a1)
{
  sub_1DD270394(v5);
  sub_1DD270254(v4);
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD28EA5C(void *a1)
{
  *a1 = &unk_1F3879E60;
  uint64_t v2 = (uint64_t)(a1 + 10);
  sub_1DD2701B4(a1 + 20);
  sub_1DD270394((uint64_t)(a1 + 15));
  sub_1DD270254(v2);
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void *sub_1DD28EAE0(void *a1)
{
  *a1 = &unk_1F387B050;
  sub_1DD270394((uint64_t)(a1 + 27));
  uint64_t v2 = (std::__shared_weak_count *)a1[26];
  if (v2) {
    sub_1DD25B904(v2);
  }
  return sub_1DD28EA5C(a1);
}

void sub_1DD28EB44(void *a1)
{
  uint64_t v1 = sub_1DD28EAE0(a1);
  operator delete(v1);
}

uint64_t sub_1DD28EB6C()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Encoded string vector <", 23);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD28ECD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD28ECF4(void *a1)
{
  uint64_t v1 = sub_1DD28EA5C(a1);
  operator delete(v1);
}

uint64_t sub_1DD28ED1C()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Byte vector <", 13);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD28EE88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD28EE9C(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2);
    sub_1DD26FB7C(a1 + 120, a2);
  }
}

uint64_t sub_1DD28EF08(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD28EF10(void *a1)
{
  return a1[7] + 8 * (a1[19] + a1[14]);
}

uint64_t sub_1DD28EF28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879F08;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  return a1;
}

void *sub_1DD28EFBC(void *a1)
{
  *a1 = &unk_1F3879F08;
  char v4 = a1 + 10;
  uint64_t v2 = (void *)a1[10];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = v2[v5];
    if (v6)
    {
      (*(void (**)(void))(*(void *)v6 + 8))(v2[v5]);
      uint64_t v2 = (void *)a1[10];
      uint64_t v3 = (void *)a1[11];
    }
    ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    a1[11] = v2;
    operator delete(v2);
  }
LABEL_8:
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD28F090(void *a1)
{
  uint64_t v1 = sub_1DD28EFBC(a1);
  operator delete(v1);
}

uint64_t sub_1DD28F0B8(uint64_t a1)
{
  sub_1DD239280((uint64_t)v11);
  sub_1DD239B24(v11, (uint64_t)"Struct vector <", 15);
  uint64_t v2 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v2, (uint64_t)" of ", 4);
  uint64_t v3 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v3, (uint64_t)"; ", 2);
  for (uint64_t i = *(void *)(a1 + 80); i != *(void *)(a1 + 88); i += 8)
  {
    (*(void (**)(void **__return_ptr))(**(void **)i + 16))(__p);
    if ((v10 & 0x80u) == 0) {
      unint64_t v5 = __p;
    }
    else {
      unint64_t v5 = (void **)__p[0];
    }
    if ((v10 & 0x80u) == 0) {
      uint64_t v6 = v10;
    }
    else {
      uint64_t v6 = (uint64_t)__p[1];
    }
    uint64_t v7 = sub_1DD239B24(v11, (uint64_t)v5, v6);
    sub_1DD239B24(v7, (uint64_t)"; ", 2);
    if ((char)v10 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_1DD239B24(v11, (uint64_t)">", 1);
  std::stringbuf::str();
  v11[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v11 + *(void *)(v11[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v11[1] = MEMORY[0x1E4FBA470] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v13);
}

void sub_1DD28F2D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1DD28F300(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
  }
}

uint64_t sub_1DD28F31C(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = *(void *)(result + 80);
  if (*(void *)(result + 88) != v2)
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v2 + 8 * v3) + 32))(*(void *)(v2 + 8 * v3));
      ++v3;
      uint64_t v2 = v1[10];
    }
    while (v3 < (v1[11] - v2) >> 3);
  }
  v1[2] = 0;
  return result;
}

uint64_t sub_1DD28F38C(void *a1)
{
  uint64_t v1 = a1[7];
  uint64_t v2 = a1[10];
  if (a1[11] != v2)
  {
    unint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      v1 += (*(uint64_t (**)(void))(**(void **)(v2 + 8 * v4) + 40))(*(void *)(v2 + 8 * v4));
      unint64_t v4 = v5;
      uint64_t v2 = a1[10];
      ++v5;
    }
    while (v4 < (a1[11] - v2) >> 3);
  }
  return v1;
}

uint64_t sub_1DD28F414(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 80);
  if (*(void *)(a1 + 88) == v1) {
    return 0;
  }
  unint64_t v3 = 0;
  unsigned int v4 = 1;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 8 * v3) + 48))(*(void *)(v1 + 8 * v3));
    if (result) {
      break;
    }
    unint64_t v3 = v4;
    uint64_t v1 = *(void *)(a1 + 80);
    ++v4;
  }
  while (v3 < (*(void *)(a1 + 88) - v1) >> 3);
  return result;
}

uint64_t sub_1DD28F494(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F38798D8;
  sub_1DD270020(a1 + 80, a3, a2 + 1);
  *(void *)(a1 + 120) = 0;
  return a1;
}

void sub_1DD28F550(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD28F56C(void *a1)
{
  *a1 = &unk_1F38798D8;
  uint64_t v2 = a1[15];
  a1[15] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  sub_1DD270394((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD28F60C(void *a1)
{
  uint64_t v1 = sub_1DD28F56C(a1);
  operator delete(v1);
}

uint64_t sub_1DD28F634(uint64_t a1)
{
  sub_1DD239280((uint64_t)v11);
  uint64_t v2 = sub_1DD239B24(v11, (uint64_t)"List vector <", 13);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 120) + 16))(__p);
  if ((v10 & 0x80u) == 0) {
    uint64_t v3 = __p;
  }
  else {
    uint64_t v3 = (void **)__p[0];
  }
  if ((v10 & 0x80u) == 0) {
    uint64_t v4 = v10;
  }
  else {
    uint64_t v4 = (uint64_t)__p[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  sub_1DD239B24(v5, (uint64_t)" with ", 6);
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v6, (uint64_t)" of ", 4);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v7, (uint64_t)">", 1);
  if ((char)v10 < 0) {
    operator delete(__p[0]);
  }
  std::stringbuf::str();
  v11[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v11 + *(void *)(v11[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v11[1] = MEMORY[0x1E4FBA470] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v13);
}

void sub_1DD28F81C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1DD28F84C(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2 + 1);
  }
}

uint64_t sub_1DD28F8AC(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
  return (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 32))();
}

uint64_t sub_1DD28F8D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56) + 8 * *(void *)(a1 + 112);
  return v1 + (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
}

uint64_t sub_1DD28F928()
{
  return 1;
}

uint64_t sub_1DD28F930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879710;
  sub_1DD270020(a1 + 80, a3, a2 + 1);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  return a1;
}

void sub_1DD28F9EC(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD28FA08(void *a1)
{
  *a1 = &unk_1F3879710;
  uint64_t v2 = a1[16];
  a1[16] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[15];
  a1[15] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  sub_1DD270394((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD28FAD8(void *a1)
{
  uint64_t v1 = sub_1DD28FA08(a1);
  operator delete(v1);
}

uint64_t sub_1DD28FB00(uint64_t a1)
{
  sub_1DD239280((uint64_t)v17);
  uint64_t v2 = sub_1DD239B24(v17, (uint64_t)"Map vector <", 12);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 120) + 16))(v15);
  if ((v16 & 0x80u) == 0) {
    uint64_t v3 = v15;
  }
  else {
    uint64_t v3 = (void **)v15[0];
  }
  if ((v16 & 0x80u) == 0) {
    uint64_t v4 = v16;
  }
  else {
    uint64_t v4 = (uint64_t)v15[1];
  }
  unsigned int v5 = sub_1DD239B24(v2, (uint64_t)v3, v4);
  uint64_t v6 = sub_1DD239B24(v5, (uint64_t)", ", 2);
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 128) + 16))(__p);
  if ((v14 & 0x80u) == 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v8 = v14;
  }
  else {
    uint64_t v8 = (uint64_t)__p[1];
  }
  long long v9 = sub_1DD239B24(v6, (uint64_t)v7, v8);
  sub_1DD239B24(v9, (uint64_t)" with ", 6);
  unsigned __int8 v10 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v10, (uint64_t)" of ", 4);
  uint64_t v11 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v11, (uint64_t)">", 1);
  if ((char)v14 < 0) {
    operator delete(__p[0]);
  }
  if ((char)v16 < 0) {
    operator delete(v15[0]);
  }
  std::stringbuf::str();
  v17[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v17[1] = MEMORY[0x1E4FBA470] + 16;
  if (v18 < 0) {
    operator delete((void *)v17[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v19);
}

void sub_1DD28FD5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  sub_1DD239418((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1DD28FDA8(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2 + 1);
  }
}

uint64_t sub_1DD28FE08(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 120) + 32))(*(void *)(a1 + 120));
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 32))(*(void *)(a1 + 128));
  *(void *)(a1 + 16) = 0;
  return result;
}

uint64_t sub_1DD28FE7C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56) + 8 * *(void *)(a1 + 112);
  uint64_t v3 = v2 + (*(uint64_t (**)(void))(**(void **)(a1 + 120) + 40))(*(void *)(a1 + 120));
  return v3 + (*(uint64_t (**)(void))(**(void **)(a1 + 128) + 40))(*(void *)(a1 + 128));
}

uint64_t sub_1DD28FEFC()
{
  return 1;
}

uint64_t sub_1DD28FF04(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F3879D60;
  sub_1DD270124(a1 + 80, a3, a2);
  sub_1DD2700A4((void *)(a1 + 120), a3, a2);
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  return a1;
}

void sub_1DD28FFD8(_Unwind_Exception *a1)
{
  sub_1DD2704D4(v4);
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD290004(void *a1)
{
  *a1 = &unk_1F3879D60;
  uint64_t v4 = a1 + 20;
  uint64_t v2 = (void *)a1[20];
  uint64_t v3 = (void *)v4[1];
  if (v3 == v2)
  {
    uint64_t v2 = v3;
    if (!v3) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  unint64_t v5 = 0;
  do
  {
    uint64_t v6 = v2[v5];
    if (v6)
    {
      (*(void (**)(void))(*(void *)v6 + 8))(v2[v5]);
      uint64_t v2 = (void *)a1[20];
      uint64_t v3 = (void *)a1[21];
    }
    ++v5;
  }
  while (v5 < v3 - v2);
  if (v2)
  {
LABEL_7:
    a1[21] = v2;
    operator delete(v2);
  }
LABEL_8:
  sub_1DD270434((uint64_t)(a1 + 15));
  sub_1DD2704D4((uint64_t)(a1 + 10));
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD2900E8(void *a1)
{
  uint64_t v1 = sub_1DD290004(a1);
  operator delete(v1);
}

uint64_t sub_1DD290110(uint64_t a1)
{
  sub_1DD239280((uint64_t)v11);
  sub_1DD239B24(v11, (uint64_t)"Union vector <", 14);
  uint64_t v2 = *(void *)(a1 + 160);
  if (*(void *)(a1 + 168) != v2)
  {
    unint64_t v3 = 0;
    do
    {
      if (v3)
      {
        sub_1DD239B24(v11, (uint64_t)", ", 2);
        uint64_t v2 = *(void *)(a1 + 160);
      }
      (*(void (**)(void **__return_ptr))(**(void **)(v2 + 8 * v3) + 16))(__p);
      if ((v10 & 0x80u) == 0) {
        uint64_t v4 = __p;
      }
      else {
        uint64_t v4 = (void **)__p[0];
      }
      if ((v10 & 0x80u) == 0) {
        uint64_t v5 = v10;
      }
      else {
        uint64_t v5 = (uint64_t)__p[1];
      }
      sub_1DD239B24(v11, (uint64_t)v4, v5);
      if ((char)v10 < 0) {
        operator delete(__p[0]);
      }
      ++v3;
      uint64_t v2 = *(void *)(a1 + 160);
    }
    while (v3 < (*(void *)(a1 + 168) - v2) >> 3);
  }
  sub_1DD239B24(v11, (uint64_t)"; with ", 7);
  uint64_t v6 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v6, (uint64_t)" of ", 4);
  uint64_t v7 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v7, (uint64_t)">", 1);
  std::stringbuf::str();
  v11[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v11 + *(void *)(v11[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v11[1] = MEMORY[0x1E4FBA470] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v13);
}

void sub_1DD29033C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
}

void sub_1DD290370(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26F9D0(a1 + 80, a2);
    sub_1DD26FB7C(a1 + 120, a2);
  }
}

uint64_t sub_1DD2903DC(uint64_t result)
{
  uint64_t v1 = (void *)result;
  uint64_t v2 = *(void *)(result + 160);
  if (*(void *)(result + 168) != v2)
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(v2 + 8 * v3) + 32))(*(void *)(v2 + 8 * v3));
      ++v3;
      uint64_t v2 = v1[20];
    }
    while (v3 < (v1[21] - v2) >> 3);
  }
  v1[2] = 0;
  return result;
}

uint64_t sub_1DD29044C(void *a1)
{
  uint64_t v1 = a1[20];
  uint64_t v2 = a1[14] + a1[7] + 8 * a1[19];
  if (a1[21] != v1)
  {
    unint64_t v4 = 0;
    do
    {
      v2 += (*(uint64_t (**)(void))(**(void **)(v1 + 8 * v4) + 40))(*(void *)(v1 + 8 * v4));
      ++v4;
      uint64_t v1 = a1[20];
    }
    while (v4 < (a1[21] - v1) >> 3);
  }
  return v2;
}

uint64_t sub_1DD2904DC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 160);
  if (*(void *)(a1 + 168) == v1) {
    return 0;
  }
  unint64_t v3 = 0;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v1 + 8 * v3) + 48))(*(void *)(v1 + 8 * v3));
    if (result) {
      break;
    }
    ++v3;
    uint64_t v1 = *(void *)(a1 + 160);
  }
  while (v3 < (*(void *)(a1 + 168) - v1) >> 3);
  return result;
}

uint64_t sub_1DD290554(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F387A6D0;
  *(void *)(a1 + 80) = 0;
  sub_1DD270020(a1 + 88, a3, a2);
  sub_1DD270020(a1 + 128, a3, a2);
  return a1;
}

void sub_1DD290624(_Unwind_Exception *a1)
{
  sub_1DD270394(v4);
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD290650(void *a1)
{
  *a1 = &unk_1F387A6D0;
  uint64_t v2 = (uint64_t)(a1 + 11);
  sub_1DD270394((uint64_t)(a1 + 16));
  sub_1DD270394(v2);
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD2906CC(void *a1)
{
  uint64_t v1 = sub_1DD290650(a1);
  operator delete(v1);
}

uint64_t sub_1DD2906F4()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Decimal64 vector  with ", 23);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD290860(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD290874(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 88, a2);
    sub_1DD26FB7C(a1 + 128, a2);
  }
}

uint64_t sub_1DD2908E0(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD2908E8(void *a1)
{
  return a1[7] + 8 * (a1[20] + a1[15]);
}

uint64_t sub_1DD290900(uint64_t a1, unint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F387A880;
  *(void *)(a1 + 80) = 0;
  sub_1DD26FE14((void *)(a1 + 88), a3, a2);
  sub_1DD270020(a1 + 128, a3, a2);
  return a1;
}

void sub_1DD2909D0(_Unwind_Exception *a1)
{
  sub_1DD26FE8C(v4);
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD2909FC(void *a1)
{
  *a1 = &unk_1F387A880;
  uint64_t v2 = (uint64_t)(a1 + 11);
  sub_1DD270394((uint64_t)(a1 + 16));
  sub_1DD26FE8C(v2);
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD290A78(void *a1)
{
  uint64_t v1 = sub_1DD2909FC(a1);
  operator delete(v1);
}

uint64_t sub_1DD290AA0()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Decimal128 vector  with ", 24);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD290C0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD290C20(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FDC0(a1 + 88, a2);
    sub_1DD26FB7C(a1 + 128, a2);
  }
}

uint64_t sub_1DD290C8C(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD290C94(void *a1)
{
  return a1[7] + 16 * a1[15] + 8 * a1[20];
}

__n128 sub_1DD290CAC(__n128 *a1, __n128 *a2, unsigned __int32 a3)
{
  __n128 result = *a2;
  *a1 = *a2;
  a1[1].n128_u32[0] = a3;
  return result;
}

uint64_t sub_1DD290CBC(uint64_t a1, std::string *__str)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  LODWORD(v4) = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  uint64_t v6 = (void *)__str->__r_.__value_.__r.__words[0];
  std::string::size_type size = __str->__r_.__value_.__l.__size_;
  if ((v4 & 0x80u) == 0) {
    int64_t v7 = HIBYTE(__str->__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t v7 = __str->__r_.__value_.__l.__size_;
  }
  if ((v4 & 0x80u) == 0) {
    uint64_t v8 = __str;
  }
  else {
    uint64_t v8 = (std::string *)__str->__r_.__value_.__r.__words[0];
  }
  if (v7 >= 1)
  {
    long long v9 = (char *)v8 + v7;
    unsigned __int8 v10 = v8;
    do
    {
      uint64_t v11 = memchr(v10, 46, v7);
      if (!v11) {
        break;
      }
      if (*v11 == 46)
      {
        if (v11 == v9) {
          break;
        }
        std::string::size_type v12 = v11 - (unsigned char *)v8;
        if (v12 == -1) {
          break;
        }
        if ((v4 & 0x80) != 0)
        {
          sub_1DD24F980(&__dst, v6, size);
          if ((__str->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            LODWORD(v4) = HIBYTE(__str->__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v4 = __str->__r_.__value_.__l.__size_;
          }
        }
        else
        {
          std::string __dst = *__str;
        }
        *(_DWORD *)(a1 + 16) = v4 + ~v12;
        unsigned __int8 v14 = std::string::replace(&__dst, v12, 1uLL, "");
        sub_1DD26DB78((int)&v15, v14);
        *(_OWORD *)a1 = v15;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        return a1;
      }
      unsigned __int8 v10 = (std::string *)(v11 + 1);
      int64_t v7 = v9 - (unsigned char *)v10;
    }
    while (v9 - (unsigned char *)v10 >= 1);
  }
  sub_1DD26DB78((int)&__dst, __str);
  *(_OWORD *)a1 = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
  *(_DWORD *)(a1 + 16) = 0;
  return a1;
}

void sub_1DD290E10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD290E30(uint64_t result)
{
  *(void *)__n128 result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

void sub_1DD290E3C(uint64_t a1@<X0>, std::string *a2@<X8>)
{
}

uint64_t sub_1DD290E44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a1 = &unk_1F3879DA8;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = 0;
  sub_1DD26FA14(a1 + 24, a3);
  *(_WORD *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = a3;
  memset(*(void **)(a1 + 40), 1, *(void *)(a1 + 8));
  *(void *)a1 = &unk_1F387A758;
  sub_1DD270020(a1 + 80, a3, a2);
  sub_1DD270020(a1 + 120, a3, a2);
  return a1;
}

void sub_1DD290F10(_Unwind_Exception *a1)
{
  sub_1DD270394(v4);
  *uint64_t v1 = v2;
  sub_1DD2701B4(v3);
  _Unwind_Resume(a1);
}

void *sub_1DD290F3C(void *a1)
{
  *a1 = &unk_1F387A758;
  uint64_t v2 = (uint64_t)(a1 + 10);
  sub_1DD270394((uint64_t)(a1 + 15));
  sub_1DD270394(v2);
  *a1 = &unk_1F3879DA8;
  sub_1DD2701B4(a1 + 3);
  return a1;
}

void sub_1DD290FB8(void *a1)
{
  uint64_t v1 = sub_1DD290F3C(a1);
  operator delete(v1);
}

uint64_t sub_1DD290FE0()
{
  sub_1DD239280((uint64_t)v3);
  sub_1DD239B24(v3, (uint64_t)"Timestamp vector <", 18);
  uint64_t v0 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v0, (uint64_t)" of ", 4);
  uint64_t v1 = (void *)std::ostream::operator<<();
  sub_1DD239B24(v1, (uint64_t)">", 1);
  std::stringbuf::str();
  v3[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v3 + *(void *)(v3[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v3[1] = MEMORY[0x1E4FBA470] + 16;
  if (v4 < 0) {
    operator delete((void *)v3[9]);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1E01B1EC0](&v5);
}

void sub_1DD29114C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_1DD239418((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1DD291160(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 8) < a2)
  {
    *(void *)(a1 + 8) = a2;
    sub_1DD26F9D0(a1 + 24, a2);
    sub_1DD26FB7C(a1 + 80, a2);
    sub_1DD26FB7C(a1 + 120, a2);
  }
}

uint64_t sub_1DD2911CC(uint64_t result)
{
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1DD2911D4(void *a1)
{
  return a1[7] + 8 * (a1[19] + a1[14]);
}

void *sub_1DD2911EC(void *a1)
{
  *a1 = &unk_1F38796B8;
  uint64_t v2 = operator new(0x80uLL);
  sub_1DD293078((uint64_t)v2);
  a1[1] = v2;
  return a1;
}

void sub_1DD291240(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_1DD291258(void *a1, uint64_t a2)
{
  *a1 = &unk_1F38796B8;
  char v4 = operator new(0x80uLL);
  uint64_t v5 = *(void *)(a2 + 8);
  long long v6 = *(_OWORD *)(v5 + 16);
  *(_OWORD *)char v4 = *(_OWORD *)v5;
  *((_OWORD *)v4 + 1) = v6;
  long long v8 = *(_OWORD *)(v5 + 48);
  long long v7 = *(_OWORD *)(v5 + 64);
  long long v9 = *(_OWORD *)(v5 + 32);
  *((unsigned char *)v4 + 80) = *(unsigned char *)(v5 + 80);
  *((_OWORD *)v4 + 3) = v8;
  *((_OWORD *)v4 + 4) = v7;
  *((_OWORD *)v4 + 2) = v9;
  sub_1DD293130((uint64_t *)v4 + 11, v5 + 88);
  uint64_t v10 = *(void *)(v5 + 112);
  *((_DWORD *)v4 + 30) = *(_DWORD *)(v5 + 120);
  *((void *)v4 + 14) = v10;
  a1[1] = v4;
  return a1;
}

void sub_1DD2912F4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DD291308(void ***a1, void **a2)
{
  uint64_t v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    sub_1DD268698((uint64_t)(v2 + 11), v2[12]);
    operator delete(v2);
  }
}

uint64_t sub_1DD29135C(uint64_t a1)
{
  *(void *)a1 = &unk_1F38796B8;
  sub_1DD291308((void ***)(a1 + 8), 0);
  return a1;
}

void sub_1DD2913A4(void ***a1)
{
  *a1 = (void **)&unk_1F38796B8;
  sub_1DD291308(a1 + 1, 0);
  operator delete(a1);
}

BOOL sub_1DD2913FC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = sub_1DD269D64();
  BOOL result = 1;
  if (*(_DWORD *)(v1 + 64) == *(_DWORD *)v2) {
    return *(_DWORD *)(v1 + 68) != *((_DWORD *)v2 + 1);
  }
  return result;
}

uint64_t sub_1DD29144C(uint64_t result, uint64_t a2)
{
  **(void **)(result + 8) = a2;
  return result;
}

uint64_t sub_1DD291458(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 8) + 8) = a2;
  return result;
}

uint64_t sub_1DD291464(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 8);
}

uint64_t sub_1DD291470(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 8) + 16) = a2;
  return result;
}

uint64_t sub_1DD29147C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 16);
}

uint64_t sub_1DD291488(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *(void *)(v2 + 24) = a2;
  *(unsigned char *)(v2 + 80) = a2 != 0;
  return result;
}

uint64_t sub_1DD2914A0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 24);
}

uint64_t sub_1DD2914AC(uint64_t result, double a2)
{
  *(double *)(*(void *)(result + 8) + 72) = a2;
  return result;
}

double sub_1DD2914B8(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 8) + 72);
}

uint64_t sub_1DD2914C4(uint64_t result, _DWORD *a2)
{
  if (*a2 || (a2[1] - 11) > 1)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unsupported file version specified.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  *(void *)(*(void *)(result + 8) + 64) = *(void *)a2;
  return result;
}

void sub_1DD29153C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD291550(uint64_t result, int a2)
{
  *(_DWORD *)(*(void *)(result + 8) + 32) = a2;
  return result;
}

uint64_t sub_1DD29155C(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 32);
}

uint64_t sub_1DD291568(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 36);
}

BOOL sub_1DD291574(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(a1 + 8) + 36) == 0;
}

uint64_t sub_1DD291588(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 8) + 40);
}

uint64_t sub_1DD291594(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 8) + 80);
}

BOOL sub_1DD2915A0(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 8) + 72) > 0.0;
}

BOOL sub_1DD2915B4(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v5 = *(void **)(v2 + 96);
  uint64_t v3 = (void *)(v2 + 96);
  char v4 = v5;
  if (!v5) {
    goto LABEL_12;
  }
  long long v6 = v3;
  do
  {
    unint64_t v7 = v4[4];
    BOOL v8 = v7 >= a2;
    if (v7 >= a2) {
      long long v9 = v4;
    }
    else {
      long long v9 = v4 + 1;
    }
    if (v8) {
      long long v6 = v4;
    }
    char v4 = (void *)*v9;
  }
  while (*v9);
  if (v6 == v3 || v6[4] > a2) {
LABEL_12:
  }
    long long v6 = v3;
  return v6 != v3;
}

double sub_1DD291604(uint64_t a1)
{
  return *(double *)(*(void *)(a1 + 8) + 112);
}

uint64_t sub_1DD291610(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 8) + 120);
}

uint64_t sub_1DD29161C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  *(void *)a1 = &unk_1F38793A8;
  *(_OWORD *)(a1 + 8) = 0u;
  long long v6 = (uint64_t *)(a1 + 8);
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 40) = a3;
  uint64_t v7 = a1 + 48;
  sub_1DD291258((void *)(a1 + 48), a4);
  *(void *)(a1 + 64) = a2;
  sub_1DD24B648(a1 + 104);
  sub_1DD24CC50(a1 + 272);
  sub_1DD246DF0(a1 + 368);
  sub_1DD248498(a1 + 464);
  sub_1DD25BC54(v7, *(void *)(a1 + 40), &v20);
  uint64_t v8 = v20;
  uint64_t v20 = 0;
  uint64_t v9 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    uint64_t v10 = v20;
    uint64_t v20 = 0;
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
    }
  }
  sub_1DD25D3B0(*(void *)(a1 + 64), *(void *)(a1 + 32), v7, &v20);
  uint64_t v11 = v20;
  uint64_t v20 = 0;
  uint64_t v12 = *v6;
  uint64_t *v6 = v11;
  if (v12)
  {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    uint64_t v13 = v20;
    uint64_t v20 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  sub_1DD26C0A0(*(_DWORD *)(*(void *)(a1 + 56) + 32), *(void *)(a1 + 40), *(_DWORD *)(*(void *)(a1 + 56) + 36), *(void *)(*(void *)(a1 + 56) + 16), *(void *)(*(void *)(a1 + 56) + 8), *(void *)(*(void *)(a1 + 56) + 40), &v20);
  uint64_t v14 = v20;
  uint64_t v20 = 0;
  uint64_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v14;
  if (v15)
  {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
    uint64_t v16 = v20;
    uint64_t v20 = 0;
    if (v16) {
      (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
    }
  }
  int v17 = operator new(0x20uLL);
  sub_1DD23A09C(v17, *(void *)(*(void *)(a1 + 56) + 40), *(void *)(a1 + 40), 0x400uLL, *(void *)(*(void *)(a1 + 56) + 8));
  uint64_t v18 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = v17;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  sub_1DD291A14(a1);
  return a1;
}

void sub_1DD2918B8(_Unwind_Exception *a1)
{
  uint64_t v8 = v6;
  operator delete(v8);
  sub_1DD2484EC(v5);
  sub_1DD246F68(v4);
  sub_1DD24CE48(v3);
  sub_1DD24B9E0(v2);
  *(void *)(v1 + 48) = &unk_1F38796B8;
  sub_1DD291308((void ***)(v1 + 56), 0);
  uint64_t v10 = *(void *)(v1 + 32);
  *(void *)(v1 + 32) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)(v1 + 24);
  *(void *)(v1 + 24) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = *v7;
  uint64_t *v7 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  _Unwind_Resume(a1);
}

void sub_1DD291A14(uint64_t a1)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1EAB1F820, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1EAB1F820))
  {
    qword_1EAB1F850 = strlen((const char *)qword_1EAB1EC28);
    __cxa_guard_release(&qword_1EAB1F820);
  }
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), qword_1EAB1EC28, qword_1EAB1F850);
  uint64_t v2 = *(void *)(a1 + 96) + qword_1EAB1F850;
  *(void *)(a1 + 96) = v2;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 232) = v2;
  uint64_t v3 = *(void *)(a1 + 64);
  *(_DWORD *)(a1 + 256) = *(void *)(*(void *)(a1 + 56) + 24);
  *(_DWORD *)(a1 + 120) |= 0x3Eu;
  *(_DWORD *)(a1 + 260) = 1;
  int v15 = 0;
  sub_1DD292B4C(a1, v3, a1 + 104, &v15);
  int v4 = *(_DWORD *)(a1 + 288);
  *(void *)(a1 + 328) = 0;
  uint64_t v5 = *(void *)(a1 + 56);
  *(_DWORD *)(a1 + 344) = *(_DWORD *)(v5 + 32);
  uint64_t v6 = *(void *)(v5 + 8);
  *(_DWORD *)(a1 + 288) = v4 | 0xE;
  *(void *)(a1 + 336) = v6;
  int v7 = *(_DWORD *)(v5 + 64);
  int v8 = *(_DWORD *)(a1 + 296);
  if (v8 == *(_DWORD *)(a1 + 300))
  {
    sub_1DD250120((unsigned int *)(a1 + 296), v8 + 1);
    int v8 = *(_DWORD *)(a1 + 296);
    uint64_t v5 = *(void *)(a1 + 56);
  }
  uint64_t v9 = *(void *)(a1 + 304);
  *(_DWORD *)(a1 + 296) = v8 + 1;
  *(_DWORD *)(v9 + 4 * v8 + 8) = v7;
  int v10 = *(_DWORD *)(v5 + 68);
  int v11 = *(_DWORD *)(a1 + 296);
  if (v11 == *(_DWORD *)(a1 + 300))
  {
    sub_1DD250120((unsigned int *)(a1 + 296), v11 + 1);
    int v11 = *(_DWORD *)(a1 + 296);
  }
  uint64_t v12 = *(void *)(a1 + 304);
  *(_DWORD *)(a1 + 296) = v11 + 1;
  *(_DWORD *)(v12 + 4 * v11 + 8) = v10;
  int v13 = *(_DWORD *)(a1 + 288);
  *(_DWORD *)(a1 + 348) = 6;
  *(_DWORD *)(a1 + 288) = v13 | 0x11;
  sub_1DD314888(&__p, "ORC");
  sub_1DD251B20((__n128 **)(a1 + 320), (__n128 *)&qword_1EAB1F7D8, &__p);
  if (v17 < 0) {
    operator delete((void *)__p.n128_u64[0]);
  }
  int v14 = *(_DWORD *)(a1 + 384) | 0x1F;
  *(void *)(a1 + 416) = *(void *)(a1 + 96);
  *(void *)(a1 + 424) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 384) = v14;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
}

void sub_1DD291C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_1DD291C30(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void, void))(**(void **)(a1 + 64) + 96))(*(void *)(a1 + 64), a2, *(void *)(*(void *)(a1 + 56) + 40), 0);
}

void sub_1DD291C64(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (*(unsigned char *)(v4 + 80))
  {
    unint64_t v5 = *(void *)(a2 + 16);
    if (v5)
    {
      unint64_t v6 = 0;
      unint64_t v7 = *(void *)(v4 + 24);
      unint64_t v8 = *(void *)(a1 + 88);
      do
      {
        unint64_t v9 = v5 - v6;
        unint64_t v10 = v7 - v8;
        if (v10 >= v9) {
          unint64_t v11 = v9;
        }
        else {
          unint64_t v11 = v10;
        }
        (*(void (**)(void, uint64_t, unint64_t, unint64_t, void))(**(void **)(a1 + 8)
                                                                                            + 16))(*(void *)(a1 + 8), a2, v6, v11, 0);
        unint64_t v8 = *(void *)(a1 + 88) + v11;
        *(void *)(a1 + 88) = v8;
        *(void *)(a1 + 72) += v11;
        if (v8 >= v7)
        {
          (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
          unint64_t v8 = 0;
          *(void *)(a1 + 88) = 0;
        }
        v6 += v11;
        unint64_t v5 = *(void *)(a2 + 16);
      }
      while (v6 < v5);
    }
  }
  else
  {
    *(void *)(a1 + 72) += *(void *)(a2 + 16);
    (*(void (**)(void, uint64_t, void))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), a2, 0);
  }
  if ((unint64_t)(*(uint64_t (**)(void))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8)) >= **(void **)(a1 + 56))
  {
    sub_1DD291E08(a1);
  }
}

void sub_1DD291E08(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 56) + 80) && *(void *)(a1 + 88))
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 80))(*(void *)(a1 + 8));
    *(void *)(a1 + 88) = 0;
  }
  else
  {
    (*(void (**)(void))(**(void **)(a1 + 8) + 64))(*(void *)(a1 + 8));
  }
  (*(void (**)(void))(**(void **)(a1 + 8) + 120))(*(void *)(a1 + 8));
  uint64_t v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  if (*(unsigned char *)(*(void *)(a1 + 56) + 80)) {
    (*(void (**)(void, uint64_t *))(**(void **)(a1 + 8) + 96))(*(void *)(a1 + 8), &v67);
  }
  (*(void (**)(void, uint64_t *))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), &v67);
  sub_1DD2448B0((uint64_t)v56);
  uint64_t v2 = v67;
  if (v68 != v67)
  {
    uint64_t v3 = 0;
    unsigned int v4 = 1;
    while (1)
    {
      unint64_t v5 = v61;
      if (!v61) {
        break;
      }
      uint64_t v6 = v59;
      int v7 = *v61;
      if (v59 >= *v61)
      {
        if (v7 == v60)
        {
LABEL_14:
          sub_1DD2FABC8((uint64_t)&v58, v7 + 1);
          unint64_t v5 = v61;
          int v7 = *v61;
        }
        *unint64_t v5 = v7 + 1;
        unint64_t v8 = (std::string *)sub_1DD24EB78(v58);
        uint64_t v9 = v59++;
        *(void *)&v61[2 * v9 + 2] = v8;
        goto LABEL_16;
      }
      ++v59;
      unint64_t v8 = *(std::string **)&v61[2 * v6 + 2];
LABEL_16:
      sub_1DD243628(v8, v2 + 40 * v3);
      uint64_t v3 = v4;
      uint64_t v2 = v67;
      BOOL v10 = 0xCCCCCCCCCCCCCCCDLL * ((v68 - v67) >> 3) > v4++;
      if (!v10) {
        goto LABEL_17;
      }
    }
    int v7 = v60;
    goto LABEL_14;
  }
LABEL_17:
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  (*(void (**)(void, uint64_t *))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), &v53);
  uint64_t v11 = v53;
  if (v54 != v53)
  {
    uint64_t v12 = 0;
    unsigned int v13 = 1;
    while (1)
    {
      int v14 = v65;
      if (!v65) {
        break;
      }
      uint64_t v15 = v63;
      int v16 = *v65;
      if (v63 >= *v65)
      {
        if (v16 == v64)
        {
LABEL_24:
          sub_1DD2FABC8((uint64_t)&v62, v16 + 1);
          int v14 = v65;
          int v16 = *v65;
        }
        _DWORD *v14 = v16 + 1;
        char v17 = (std::string *)sub_1DD24EC0C(v62);
        uint64_t v18 = v63++;
        *(void *)&v65[2 * v18 + 2] = v17;
        goto LABEL_26;
      }
      ++v63;
      char v17 = *(std::string **)&v65[2 * v15 + 2];
LABEL_26:
      sub_1DD243E7C(v17, v11 + 40 * v12);
      uint64_t v12 = v13;
      uint64_t v11 = v53;
      BOOL v10 = 0xCCCCCCCCCCCCCCCDLL * ((v54 - v53) >> 3) > v13++;
      if (!v10) {
        goto LABEL_27;
      }
    }
    int v16 = v64;
    goto LABEL_24;
  }
LABEL_27:
  v57 |= 1u;
  sub_1DD314888(&v70, "GMT");
  __n128 v19 = sub_1DD251B20(&v66, (__n128 *)&qword_1EAB1F7D8, &v70);
  if (SHIBYTE(v71) < 0) {
    operator delete((void *)v70.n128_u64[0]);
  }
  uint64_t v20 = *(int **)(a1 + 504);
  if (!v20)
  {
    int v22 = *(_DWORD *)(a1 + 500);
LABEL_34:
    sub_1DD2FABC8(a1 + 488, v22 + 1);
    uint64_t v20 = *(int **)(a1 + 504);
    int v22 = *v20;
    goto LABEL_35;
  }
  uint64_t v21 = *(int *)(a1 + 496);
  int v22 = *v20;
  if ((int)v21 < *v20)
  {
    *(_DWORD *)(a1 + 496) = v21 + 1;
    int v23 = *(void **)&v20[2 * v21 + 2];
    goto LABEL_36;
  }
  if (v22 == *(_DWORD *)(a1 + 500)) {
    goto LABEL_34;
  }
LABEL_35:
  int *v20 = v22 + 1;
  int v23 = sub_1DD24F018(*(void *)(a1 + 488));
  uint64_t v24 = *(void *)(a1 + 504);
  uint64_t v25 = *(int *)(a1 + 496);
  *(_DWORD *)(a1 + 496) = v25 + 1;
  *(void *)(v24 + 8 * v25 + 8) = v23;
LABEL_36:
  __n128 v70 = 0uLL;
  uint64_t v71 = 0;
  (*(void (**)(void, __n128 *, __n128))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), &v70, v19);
  unint64_t v26 = v70.n128_u64[0];
  if (v70.n128_u64[1] != v70.n128_u64[0])
  {
    uint64_t v27 = 0;
    unsigned int v28 = 1;
    while (1)
    {
      int v29 = (int *)v23[5];
      if (!v29) {
        break;
      }
      uint64_t v30 = *((int *)v23 + 8);
      int v31 = *v29;
      if ((int)v30 >= *v29)
      {
        if (v31 == *((_DWORD *)v23 + 9))
        {
LABEL_43:
          sub_1DD2FABC8((uint64_t)(v23 + 3), v31 + 1);
          int v29 = (int *)v23[5];
          int v31 = *v29;
        }
        *int v29 = v31 + 1;
        int v32 = (std::string *)sub_1DD24E894(v23[3]);
        uint64_t v33 = v23[5];
        uint64_t v34 = *((int *)v23 + 8);
        *((_DWORD *)v23 + 8) = v34 + 1;
        *(void *)(v33 + 8 * v34 + 8) = v32;
        goto LABEL_45;
      }
      *((_DWORD *)v23 + 8) = v30 + 1;
      int v32 = *(std::string **)&v29[2 * v30 + 2];
LABEL_45:
      sub_1DD240E54(v32, v26 + 120 * v27);
      uint64_t v27 = v28;
      unint64_t v26 = v70.n128_u64[0];
      BOOL v42 = 0xEEEEEEEEEEEEEEEFLL * ((uint64_t)(v70.n128_u64[1] - v70.n128_u64[0]) >> 3) == v28++;
      if (v42) {
        goto LABEL_47;
      }
    }
    int v31 = *((_DWORD *)v23 + 9);
    goto LABEL_43;
  }
LABEL_47:
  (*(void (**)(void))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8));
  if ((sub_1DD2FA720((uint64_t)v56, *(void *)(a1 + 16)) & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to write stripe footer.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t v35 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16));
  uint64_t v36 = v35;
  if (v68 == v67)
  {
    uint64_t v38 = 0;
    uint64_t v37 = 0;
  }
  else
  {
    uint64_t v37 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = (void *)(v67 + 32);
    unsigned int v40 = 1;
    do
    {
      int v41 = *((_DWORD *)v39 - 2);
      BOOL v42 = v41 == 8 || v41 == 6;
      if (v42) {
        v37 += *v39;
      }
      else {
        v38 += *v39;
      }
      v39 += 5;
      BOOL v10 = 0xCCCCCCCCCCCCCCCDLL * ((v68 - v67) >> 3) > v40++;
    }
    while (v10);
  }
  int v43 = *(_DWORD *)(a1 + 384);
  *(void *)(a1 + 424) = v37;
  *(void *)(a1 + 432) = v38;
  uint64_t v44 = *(void *)(a1 + 72);
  *(_DWORD *)(a1 + 384) = v43 | 0x1E;
  *(void *)(a1 + 440) = v35;
  *(void *)(a1 + 448) = v44;
  int v45 = *(int **)(a1 + 144);
  if (!v45)
  {
    int v47 = *(_DWORD *)(a1 + 140);
    goto LABEL_64;
  }
  uint64_t v46 = *(int *)(a1 + 136);
  int v47 = *v45;
  if ((int)v46 >= *v45)
  {
    if (v47 != *(_DWORD *)(a1 + 140))
    {
LABEL_65:
      *int v45 = v47 + 1;
      uint64_t v48 = (std::string *)sub_1DD24EEF0(*(void *)(a1 + 128));
      uint64_t v49 = *(void *)(a1 + 144);
      uint64_t v50 = *(int *)(a1 + 136);
      *(_DWORD *)(a1 + 136) = v50 + 1;
      *(void *)(v49 + 8 * v50 + 8) = v48;
      goto LABEL_66;
    }
LABEL_64:
    sub_1DD2FABC8(a1 + 128, v47 + 1);
    int v45 = *(int **)(a1 + 144);
    int v47 = *v45;
    goto LABEL_65;
  }
  *(_DWORD *)(a1 + 136) = v46 + 1;
  uint64_t v48 = *(std::string **)&v45[2 * v46 + 2];
LABEL_66:
  sub_1DD247880(v48, a1 + 368);
  *(void *)(a1 + 96) += v38 + v36 + v37;
  *(void *)(a1 + 80) += *(void *)(a1 + 72);
  (*(void (**)(void))(**(void **)(a1 + 8) + 112))(*(void *)(a1 + 8));
  int v51 = *(_DWORD *)(a1 + 384);
  *(void *)(a1 + 416) = *(void *)(a1 + 96);
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 424) = 0;
  *(_DWORD *)(a1 + 384) = v51 | 0x1F;
  *(void *)(a1 + 448) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  std::string v72 = &v70;
  sub_1DD2794A0((void ***)&v72);
  v70.n128_u64[0] = (unint64_t)&v53;
  sub_1DD293590((void ***)&v70);
  sub_1DD24498C(v56);
  v56[0] = (void **)&v67;
  sub_1DD293590(v56);
}

void sub_1DD292540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  __cxa_free_exception(v26);
  *(void *)(v27 - 88) = v27 - 112;
  sub_1DD2794A0((void ***)(v27 - 88));
  *(void *)(v27 - 88) = &a10;
  sub_1DD293590((void ***)(v27 - 88));
  sub_1DD24498C(&a13);
  a13 = &a26;
  sub_1DD293590((void ***)&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD2925DC(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_1DD291E08(a1);
  }
  sub_1DD292658(a1);
  sub_1DD29270C(a1);
  sub_1DD29292C(a1);
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 40) + 48);
  return v2();
}

uint64_t sub_1DD292658(uint64_t a1)
{
  if ((sub_1DD2FA720(a1 + 464, *(void *)(a1 + 16)) & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to write metadata.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16));
  *(_DWORD *)(a1 + 288) |= 0x20u;
  *(void *)(a1 + 352) = result;
  return result;
}

void sub_1DD2926F8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_1DD29270C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96) - *(void *)(a1 + 232);
  uint64_t v3 = *(void *)(a1 + 80);
  *(_DWORD *)(a1 + 120) |= 0xCu;
  *(void *)(a1 + 240) = v2;
  *(void *)(a1 + 248) = v3;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  (*(void (**)(void, uint64_t *))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), &v16);
  uint64_t v4 = v16;
  if (v17 != v16)
  {
    uint64_t v5 = 0;
    unsigned int v6 = 1;
    while (1)
    {
      int v7 = *(int **)(a1 + 216);
      if (!v7) {
        break;
      }
      uint64_t v8 = *(int *)(a1 + 208);
      int v9 = *v7;
      if ((int)v8 >= *v7)
      {
        if (v9 == *(_DWORD *)(a1 + 212))
        {
LABEL_8:
          sub_1DD2FABC8(a1 + 200, v9 + 1);
          int v7 = *(int **)(a1 + 216);
          int v9 = *v7;
        }
        int *v7 = v9 + 1;
        BOOL v10 = (std::string *)sub_1DD24E894(*(void *)(a1 + 200));
        uint64_t v11 = *(void *)(a1 + 216);
        uint64_t v12 = *(int *)(a1 + 208);
        *(_DWORD *)(a1 + 208) = v12 + 1;
        *(void *)(v11 + 8 * v12 + 8) = v10;
        goto LABEL_10;
      }
      *(_DWORD *)(a1 + 208) = v8 + 1;
      BOOL v10 = *(std::string **)&v7[2 * v8 + 2];
LABEL_10:
      sub_1DD240E54(v10, v4 + 120 * v5);
      uint64_t v5 = v6;
      uint64_t v4 = v16;
      if (0xEEEEEEEEEEEEEEEFLL * ((v17 - v16) >> 3) == v6++) {
        goto LABEL_12;
      }
    }
    int v9 = *(_DWORD *)(a1 + 212);
    goto LABEL_8;
  }
LABEL_12:
  if ((sub_1DD2FA720(a1 + 104, *(void *)(a1 + 16)) & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to write file footer.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  uint64_t v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 16) + 72))(*(void *)(a1 + 16));
  *(_DWORD *)(a1 + 288) |= 2u;
  *(void *)(a1 + 328) = v14;
  __n128 v19 = (void **)&v16;
  sub_1DD2794A0(&v19);
}

void sub_1DD2928FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t *a12)
{
  __cxa_free_exception(v12);
  a12 = &a9;
  sub_1DD2794A0((void ***)&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_1DD29292C(uint64_t a1)
{
  if ((sub_1DD2FA720(a1 + 272, *(void *)(a1 + 24)) & 1) == 0)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Failed to write post script.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  char v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 72))(*(void *)(a1 + 24));
  return (*(uint64_t (**)(void, char *, uint64_t))(**(void **)(a1 + 40) + 32))(*(void *)(a1 + 40), &v4, 1);
}

void sub_1DD2929F8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::string *sub_1DD292A0C(uint64_t a1, std::string *__str, const std::string *a3)
{
  unsigned int v6 = *(int **)(a1 + 192);
  if (!v6)
  {
    int v8 = *(_DWORD *)(a1 + 188);
LABEL_6:
    sub_1DD2FABC8(a1 + 176, v8 + 1);
    unsigned int v6 = *(int **)(a1 + 192);
    int v8 = *v6;
    goto LABEL_7;
  }
  uint64_t v7 = *(int *)(a1 + 184);
  int v8 = *v6;
  if ((int)v7 < *v6)
  {
    *(_DWORD *)(a1 + 184) = v7 + 1;
    int v9 = *(void **)&v6[2 * v7 + 2];
    goto LABEL_8;
  }
  if (v8 == *(_DWORD *)(a1 + 188)) {
    goto LABEL_6;
  }
LABEL_7:
  int *v6 = v8 + 1;
  int v9 = sub_1DD24EF84(*(void *)(a1 + 176));
  uint64_t v10 = *(void *)(a1 + 192);
  uint64_t v11 = *(int *)(a1 + 184);
  *(_DWORD *)(a1 + 184) = v11 + 1;
  *(void *)(v10 + 8 * v11 + 8) = v9;
LABEL_8:
  uint64_t v12 = (std::string *)v9[3];
  *((_DWORD *)v9 + 4) |= 1u;
  if (v12 == (std::string *)&qword_1EAB1F7D8) {
    sub_1DD24F908(v9 + 3, (uint64_t)__str);
  }
  else {
    std::string::operator=(v12, __str);
  }
  uint64_t v15 = (uint64_t *)v9[4];
  uint64_t v14 = v9 + 4;
  unsigned int v13 = (std::string *)v15;
  *((_DWORD *)v14 - 4) |= 2u;
  if (v15 == &qword_1EAB1F7D8)
  {
    return (std::string *)sub_1DD24F908(v14, (uint64_t)a3);
  }
  else
  {
    return std::string::operator=(v13, a3);
  }
}

uint64_t sub_1DD292B4C(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  sub_1DD245CF0((uint64_t)v29);
  int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
  v30 |= 2u;
  int v32 = v8;
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 72))(a2);
  v30 |= 4u;
  int v33 = v9;
  int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 80))(a2);
  v30 |= 8u;
  int v34 = v10;
  unsigned int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
  if (v11 >= 0x12)
  {
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Unknown type.");
    __cxa_throw(exception, MEMORY[0x1E4FBA328], MEMORY[0x1E4FBA1B0]);
  }
  v30 |= 1u;
  unsigned int v31 = v11;
  uint64_t v12 = *a4;
  unsigned int v13 = *(int **)(a3 + 64);
  if (!v13)
  {
    int v15 = *(_DWORD *)(a3 + 60);
    goto LABEL_7;
  }
  uint64_t v14 = *(int *)(a3 + 56);
  int v15 = *v13;
  if ((int)v14 >= *v13)
  {
    if (v15 != *(_DWORD *)(a3 + 60))
    {
LABEL_8:
      *unsigned int v13 = v15 + 1;
      uint64_t v16 = (unint64_t *)sub_1DD24EE5C(*(void *)(a3 + 48));
      uint64_t v17 = *(void *)(a3 + 64);
      uint64_t v18 = *(int *)(a3 + 56);
      *(_DWORD *)(a3 + 56) = v18 + 1;
      *(void *)(v17 + 8 * v18 + 8) = v16;
      goto LABEL_9;
    }
LABEL_7:
    sub_1DD2FABC8(a3 + 48, v15 + 1);
    unsigned int v13 = *(int **)(a3 + 64);
    int v15 = *v13;
    goto LABEL_8;
  }
  *(_DWORD *)(a3 + 56) = v14 + 1;
  uint64_t v16 = *(unint64_t **)&v13[2 * v14 + 2];
LABEL_9:
  sub_1DD246CE0(v16, (uint64_t)v29);
  for (unint64_t i = 0; i < (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2); ++i)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 32))(a2) == 12)
    {
      uint64_t v20 = *(void *)(*(void *)(a3 + 64) + 8 * v12 + 8);
      uint64_t v21 = (std::string *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 56))(a2, i);
      sub_1DD292ECC(v20, v21);
    }
    uint64_t v22 = *(void *)(*(void *)(a3 + 64) + 8 * v12 + 8);
    int v23 = *a4 + 1;
    *a4 = v23;
    int v24 = *(_DWORD *)(v22 + 24);
    if (v24 == *(_DWORD *)(v22 + 28))
    {
      sub_1DD250120((unsigned int *)(v22 + 24), v24 + 1);
      int v24 = *(_DWORD *)(v22 + 24);
    }
    uint64_t v25 = *(void *)(v22 + 32);
    *(_DWORD *)(v22 + 24) = v24 + 1;
    *(_DWORD *)(v25 + 4 * v24 + 8) = v23;
    uint64_t v26 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)a2 + 48))(a2, i);
    sub_1DD292B4C(a1, v26, a3, a4);
  }
  return sub_1DD245D70((uint64_t)v29);
}

void sub_1DD292EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  __cxa_free_exception(v9);
  sub_1DD245D70((uint64_t)&a9);
  _Unwind_Resume(a1);
}

std::string *sub_1DD292ECC(uint64_t a1, std::string *__str)
{
  char v4 = (uint64_t *)(a1 + 48);
  uint64_t v5 = *(int **)(a1 + 64);
  if (!v5)
  {
    int v7 = *(_DWORD *)(a1 + 60);
LABEL_6:
    sub_1DD2FABC8(a1 + 48, v7 + 1);
    uint64_t v5 = *(int **)(a1 + 64);
    int v7 = *v5;
    goto LABEL_7;
  }
  uint64_t v6 = *(int *)(a1 + 56);
  int v7 = *v5;
  if ((int)v6 < *v5)
  {
    *(_DWORD *)(a1 + 56) = v6 + 1;
    int v8 = *(std::string **)&v5[2 * v6 + 2];
    goto LABEL_13;
  }
  if (v7 == *(_DWORD *)(a1 + 60)) {
    goto LABEL_6;
  }
LABEL_7:
  *uint64_t v5 = v7 + 1;
  uint64_t v9 = *v4;
  if (v9)
  {
    if (*(void *)(v9 + 112)) {
      sub_1DD2F5330(v9, (uint64_t)&unk_1F3878F18, 24);
    }
    int v8 = (std::string *)sub_1DD2F4FD8(v9, 0x18uLL, (uint64_t)sub_1DD24FB50);
  }
  else
  {
    int v8 = (std::string *)operator new(0x18uLL);
  }
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  uint64_t v10 = *(void *)(a1 + 64);
  uint64_t v11 = *(int *)(a1 + 56);
  *(_DWORD *)(a1 + 56) = v11 + 1;
  *(void *)(v10 + 8 * v11 + 8) = v8;
LABEL_13:
  return std::string::operator=(v8, __str);
}

uint64_t sub_1DD292FDC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  int v8 = operator new(0x200uLL);
  uint64_t result = sub_1DD29161C((uint64_t)v8, a1, a2, a3);
  *a4 = v8;
  return result;
}

void sub_1DD293038(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1DD293050(uint64_t a1)
{
  uint64_t v1 = (void *)sub_1DD293444(a1);
  operator delete(v1);
}

uint64_t sub_1DD293078(uint64_t a1)
{
  *(void *)(a1 + 64) = *sub_1DD269DC0();
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = a1 + 96;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)a1 = xmmword_1DD321060;
  *(_OWORD *)(a1 + 16) = xmmword_1DD321070;
  *(void *)(a1 + 32) = 1;
  *(void *)(a1 + 40) = sub_1DD270500();
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = MEMORY[0x1E4FBA240];
  *(void *)(a1 + 72) = 0;
  *(unsigned char *)(a1 + 80) = 1;
  *(void *)(a1 + 112) = 0x3FA999999999999ALL;
  *(_DWORD *)(a1 + 120) = 1;
  return a1;
}

void sub_1DD293118(_Unwind_Exception *a1)
{
  sub_1DD268698(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1DD293130(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1DD293188(a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_1DD293170(_Unwind_Exception *a1)
{
  sub_1DD268698(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1DD293188(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    char v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = result + 1;
    do
    {
      uint64_t result = sub_1DD293214(v5, v6, v4 + 4, v4 + 4);
      int v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          int v8 = v7;
          int v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          char v4 = v8;
        }
        while (!v9);
      }
      char v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1DD293214(uint64_t **a1, void *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = (uint64_t **)sub_1DD29329C(a1, a2, &v11, &v10, a3);
  int v7 = *v6;
  if (!*v6)
  {
    int v8 = v6;
    int v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    sub_1DD2694DC(a1, v11, v8, v7);
  }
  return v7;
}

void *sub_1DD29329C(void *a1, void *a2, void *a3, void *a4, unint64_t *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    uint64_t v8 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      BOOL v9 = (void *)*a2;
      do
      {
        uint64_t v10 = v9;
        BOOL v9 = (void *)v9[1];
      }
      while (v9);
    }
    else
    {
      unsigned int v13 = a2;
      do
      {
        uint64_t v10 = (void *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        unsigned int v13 = v10;
      }
      while (v14);
    }
    unint64_t v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v16;
          unint64_t v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = (void *)*v17;
          uint64_t v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        uint64_t v5 = v17 + 1;
        uint64_t v16 = (void *)v17[1];
      }
      while (v16);
    }
    else
    {
      uint64_t v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    uint64_t v12 = (void *)a2[1];
    do
    {
      a4 = v12;
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    __n128 v19 = a2;
    do
    {
      a4 = (void *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      __n128 v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    uint64_t v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v21 = v20;
          unint64_t v22 = v20[4];
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = (void *)*v21;
          uint64_t v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        uint64_t v5 = v21 + 1;
        uint64_t v20 = (void *)v21[1];
      }
      while (v20);
    }
    else
    {
      uint64_t v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_1DD293444(uint64_t a1)
{
  *(void *)a1 = &unk_1F38793A8;
  sub_1DD2484EC((void *)(a1 + 464));
  sub_1DD246F68((void *)(a1 + 368));
  sub_1DD24CE48(a1 + 272);
  sub_1DD24B9E0(a1 + 104);
  *(void *)(a1 + 48) = &unk_1F38796B8;
  sub_1DD291308((void ***)(a1 + 56), 0);
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

void sub_1DD293590(void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      unint64_t v6 = v4 - 40;
      unint64_t v7 = v4 - 40;
      uint64_t v8 = v4 - 40;
      do
      {
        BOOL v9 = *(void (***)(char *))v8;
        v8 -= 40;
        (*v9)(v7);
        v6 -= 40;
        BOOL v10 = v7 == v2;
        unint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

unint64_t sub_1DD293650(void *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, size_t a5)
{
  v42[1] = *MEMORY[0x1E4F143B8];
  if (a5 > 7)
  {
    uint64_t v12 = (*a2 + 1);
    bzero(a1, 2 * v12);
    unsigned int v13 = *a4 & 0xF;
    if (v13 > 0xA) {
      return -44;
    }
    unsigned int v14 = 0;
    unsigned int v15 = *a4 >> 4;
    *a3 = v13 + 5;
    int v16 = 32 << v13;
    signed int v17 = (32 << v13) | 1;
    unsigned int v18 = v13 + 6;
    unint64_t v19 = (unint64_t)a4 + a5 - 7;
    unint64_t v20 = (unint64_t)a4 + a5 - 4;
    int v21 = 4;
    unint64_t v22 = a4;
    while (1)
    {
      int v30 = 2 * v16 - 1;
      unsigned int v31 = v30 - v17;
      unsigned int v32 = v15 & (v16 - 1);
      int v33 = v15 & v30;
      if (v33 >= v16) {
        int v34 = v30 - v17;
      }
      else {
        int v34 = 0;
      }
      int v35 = v33 - v34;
      unsigned int v36 = v18 - 1;
      if (v32 < v31) {
        int v35 = v32;
      }
      else {
        unsigned int v36 = v18;
      }
      int v28 = v36 + v21;
      int v37 = v35 - 1;
      if (v35 <= 0) {
        int v38 = v35 - 1;
      }
      else {
        int v38 = 1 - v35;
      }
      v17 += v38;
      *((_WORD *)a1 + v14++) = v37;
      BOOL v39 = v37 != 0;
      if (v17 < v16)
      {
        if (v17 < 2) {
          goto LABEL_43;
        }
        unsigned int v40 = __clz(v17);
        unsigned int v18 = 32 - v40;
        int v16 = 1 << (v40 ^ 0x1F);
      }
      if (v14 >= v12) {
        break;
      }
      uint64_t v41 = (uint64_t)v28 >> 3;
      if ((unint64_t)v22 <= v19 || (unint64_t)v22 + v41 <= v20)
      {
        unint64_t v22 = (_DWORD *)((char *)v22 + v41);
        int v21 = v28 & 7;
      }
      else
      {
        int v21 = ((_BYTE)v28 + 8 * ((_BYTE)v22 - (_BYTE)v20)) & 0x1F;
        unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
      }
      unsigned int v15 = *v22 >> v21;
      if (!v39)
      {
        unsigned int v23 = __clz(__rbit32(~v15 | 0x80000000));
        if (v23 >= 0x18)
        {
          do
          {
            int v24 = ((_BYTE)v21 + 8 * ((_BYTE)v22 - (_BYTE)v19)) & 0x1F;
            BOOL v25 = (unint64_t)v22 > v19;
            if ((unint64_t)v22 <= v19) {
              unint64_t v22 = (_DWORD *)((char *)v22 + 3);
            }
            else {
              unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
            }
            if (v25) {
              int v21 = v24;
            }
            unsigned int v15 = *v22 >> v21;
            unsigned int v23 = __clz(__rbit32(~v15 | 0x80000000));
            v14 += 36;
          }
          while (v23 > 0x17);
        }
        int v26 = 3 * (v23 >> 1);
        int v27 = v23 & 0x1E;
        v14 += v26 + ((v15 >> v27) & 3);
        int v28 = v21 + v27 + 2;
        if (v14 >= v12) {
          goto LABEL_43;
        }
        uint64_t v29 = v28 >> 3;
        if ((unint64_t)v22 <= v19 || (unint64_t)v22 + v29 <= v20)
        {
          unint64_t v22 = (_DWORD *)((char *)v22 + v29);
          int v21 = v28 & 7;
        }
        else
        {
          int v21 = ((_BYTE)v28 + 8 * ((_BYTE)v22 - (_BYTE)v20)) & 0x1F;
          unint64_t v22 = (_DWORD *)((char *)a4 + a5 - 4);
        }
        unsigned int v15 = *v22 >> v21;
      }
    }
    if (v17 != 1) {
      return -20;
    }
LABEL_43:
    if (v14 > v12) {
      return -48;
    }
    if (v28 <= 32)
    {
      *a2 = v14 - 1;
      return (char *)v22 + ((v28 + 7) >> 3) - (char *)a4;
    }
    else
    {
      return -20;
    }
  }
  else
  {
    v42[0] = 0;
    memcpy(v42, a4, a5);
    unint64_t result = sub_1DD293650(a1, a2, a3, v42, 8);
    if (result > a5 && result < 0xFFFFFFFFFFFFFF89) {
      return -20;
    }
  }
  return result;
}

uint64_t sub_1DD29394C(unsigned char *a1, unint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, char *a6, unint64_t a7)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  return sub_1DD2939AC(a1, a2, a3, a4, a5, a6, a7, v8, 0x36CuLL);
}

uint64_t sub_1DD2939AC(unsigned char *a1, unint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, char *a6, unint64_t a7, unsigned __int16 *a8, unint64_t a9)
{
  if (!a7) {
    return -72;
  }
  unint64_t v13 = *a6;
  if (*a6 < 0)
  {
    unint64_t v15 = (v13 - 126) >> 1;
    if (v15 < a7)
    {
      unint64_t v14 = v13 - 127;
      if (v13 - 127 < a2)
      {
        if (v13 != 127)
        {
          unint64_t v17 = 0;
          unsigned int v18 = a6 + 1;
          do
          {
            unint64_t v19 = &a1[v17];
            *unint64_t v19 = *v18 >> 4;
            char v20 = *v18++;
            v19[1] = v20 & 0xF;
            v17 += 2;
          }
          while (v17 < (v13 - 127));
LABEL_12:
          *(_DWORD *)(a3 + 48) = 0;
          *(_OWORD *)(a3 + 16) = 0u;
          *(_OWORD *)(a3 + 32) = 0u;
          *(_OWORD *)a3 = 0u;
          if (v14)
          {
            uint64_t v21 = 0;
            unsigned int v22 = 0;
            unsigned int v23 = 1;
            while (1)
            {
              unint64_t v24 = a1[v21];
              if (v24 > 0xC) {
                break;
              }
              ++*(_DWORD *)(a3 + 4 * v24);
              v22 += 1 << a1[v21] >> 1;
              uint64_t v21 = v23;
              if (v14 <= v23++)
              {
                if (v22 - 4096 < 0xFFFFF001) {
                  return -20;
                }
                unsigned int v26 = __clz(v22);
                *a5 = 32 - v26;
                unsigned int v27 = (1 << -(char)v26) - v22;
                unsigned int v28 = __clz(v27);
                if (0x80000000 >> v28 != v27) {
                  return -20;
                }
                unsigned int v29 = 32 - v28;
                a1[v14] = v29;
                ++*(_DWORD *)(a3 + 4 * v29);
                unsigned int v30 = *(_DWORD *)(a3 + 4);
                uint64_t v16 = -20;
                if (v30 >= 2 && (v30 & 1) == 0)
                {
                  *a4 = v14 + 1;
                  return v15 + 1;
                }
                return v16;
              }
            }
          }
          return -20;
        }
        *(_DWORD *)(a3 + 48) = 0;
        *(_OWORD *)(a3 + 16) = 0u;
        *(_OWORD *)(a3 + 32) = 0u;
        *(_OWORD *)a3 = 0u;
      }
      return -20;
    }
  }
  else if (v13 < a7)
  {
    unint64_t v14 = sub_1DD293D9C(a1, a2 - 1, a6 + 1, *a6, 6u, a8, a9);
    unint64_t v15 = v13;
    uint64_t v16 = v14;
    if (v14 > 0xFFFFFFFFFFFFFF88) {
      return v16;
    }
    goto LABEL_12;
  }
  return -72;
}

uint64_t sub_1DD293B88(_WORD *a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v6 = -46;
  if (a3 <= 0xFF)
  {
    uint64_t v7 = a3 + 1;
    if ((1 << a4) + 2 * (unint64_t)v7 + 8 <= a6)
    {
      if (a4 <= 0xC)
      {
        uint64_t v8 = 0;
        uint64_t v9 = a1 + 2;
        uint64_t v10 = a5 + 2 * a3;
        unint64_t v11 = (1 << a4);
        uint64_t v12 = (v11 - 1);
        __int16 v13 = 1;
        unsigned int v14 = v11 - 1;
        uint64_t v15 = a3;
        do
        {
          int v16 = *(__int16 *)(a2 + 2 * v8);
          if (v16 == -1)
          {
            unsigned int v18 = &v9[2 * v14--];
            *((unsigned char *)v18 + 2) = v8;
            __int16 v17 = 1;
          }
          else
          {
            __int16 v17 = *(_WORD *)(a2 + 2 * v8);
            if (0x8000 << a4 >> 16 <= v16) {
              __int16 v13 = 0;
            }
          }
          *(_WORD *)(a5 + 2 * v8++) = v17;
        }
        while (v7 != v8);
        *a1 = a4;
        a1[1] = v13;
        unsigned int v19 = v11 >> 1;
        if (v14 == v12)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          uint64_t v22 = 0;
          unsigned int v23 = v19 + (v11 >> 3) + 3;
          uint64_t v24 = a5 + 2 * v15;
          do
          {
            int v25 = *(__int16 *)(a2 + 2 * v20);
            unint64_t v26 = *(unsigned __int16 *)(a2 + 2 * v20);
            *(void *)(v10 + 2 + v22) = v21;
            if (v25 >= 9)
            {
              uint64_t v27 = 10;
              do
              {
                *(void *)(v24 + v22 + v27) = v21;
                unint64_t v28 = v27 + 6;
                v27 += 8;
              }
              while (v28 < v26);
            }
            v22 += (__int16)v26;
            ++v20;
            v21 += 0x101010101010101;
          }
          while (v20 != v7);
          unint64_t v29 = 0;
          uint64_t v30 = 0;
          do
          {
            LOBYTE(v9[2 * (v30 & v12) + 1]) = *(unsigned char *)(v10 + v29 + 2);
            LOBYTE(v9[2 * ((v30 + v23) & v12) + 1]) = *(unsigned char *)(v10 + v29 + 3);
            uint64_t v30 = (v30 + 2 * v23) & v12;
            v29 += 2;
          }
          while (v29 < v11);
        }
        else
        {
          uint64_t v31 = 0;
          unsigned int v32 = 0;
          do
          {
            int v33 = *(__int16 *)(a2 + 2 * v31);
            if (v33 >= 1)
            {
              for (int i = 0; i != v33; ++i)
              {
                LOBYTE(v9[2 * v32 + 1]) = v31;
                do
                  unsigned int v32 = (v19 + (v11 >> 3) + 3 + v32) & v12;
                while (v32 > v14);
              }
            }
            ++v31;
          }
          while (v31 != v7);
          if (v32) {
            return -1;
          }
        }
        int v35 = (char *)a1 + 7;
        uint64_t v36 = (1 << a4);
        do
        {
          uint64_t v37 = *(v35 - 1);
          unsigned int v38 = *(unsigned __int16 *)(a5 + 2 * v37);
          *(_WORD *)(a5 + 2 * v37) = v38 + 1;
          LOBYTE(v37) = a4 - 31 + __clz(v38);
          unsigned char *v35 = v37;
          *(_WORD *)(v35 - 3) = ((_WORD)v38 << v37) - v11;
          v35 += 4;
          --v36;
        }
        while (v36);
        return 0;
      }
      else
      {
        return -44;
      }
    }
  }
  return v6;
}

unint64_t sub_1DD293D9C(unsigned char *a1, uint64_t a2, _DWORD *a3, size_t a4, unsigned int a5, unsigned __int16 *a6, unint64_t a7)
{
  unsigned int v130 = 255;
  if (a7 < 0x204) {
    return -1;
  }
  unsigned int v131 = 0;
  unint64_t result = sub_1DD293650(a6, &v130, &v131, a3, a4);
  if (result > 0xFFFFFFFFFFFFFF88) {
    return result;
  }
  if (v131 > a5
    || (((1 << v131) + 4 * ((1 << v131) + 2) + 2 * (v130 + 1) + 11) & 0xFFFFFFFFFFFFFFFCLL) + 516 > a7)
  {
    return -44;
  }
  unint64_t v15 = result;
  int v16 = (1 << v131) + 1;
  __int16 v17 = a6 + 258;
  unint64_t v18 = a7 - 4 * v16 - 516;
  unsigned int v19 = a6 + 256;
  unint64_t result = sub_1DD293B88(a6 + 256, (uint64_t)a6, v130, v131, (uint64_t)&a6[2 * v16 + 258], v18);
  if (result > 0xFFFFFFFFFFFFFF88) {
    return result;
  }
  uint64_t v20 = (unsigned __int8 *)a3 + v15;
  unint64_t result = a4 - v15;
  uint64_t v21 = &a1[a2];
  unint64_t v22 = (unint64_t)&a1[a2 - 3];
  if (!a6[257])
  {
    if (!result) {
      return -72;
    }
    uint64_t v26 = result - 8;
    if (result < 8)
    {
      unint64_t v27 = *v20;
      switch(result)
      {
        case 2uLL:
          goto LABEL_38;
        case 3uLL:
          goto LABEL_37;
        case 4uLL:
          goto LABEL_36;
        case 5uLL:
          goto LABEL_35;
        case 6uLL:
          goto LABEL_34;
        case 7uLL:
          v27 |= (unint64_t)v20[6] << 48;
LABEL_34:
          v27 += (unint64_t)v20[5] << 40;
LABEL_35:
          v27 += (unint64_t)v20[4] << 32;
LABEL_36:
          v27 += (unint64_t)v20[3] << 24;
LABEL_37:
          v27 += (unint64_t)v20[2] << 16;
LABEL_38:
          v27 += (unint64_t)v20[1] << 8;
          break;
        default:
          break;
      }
      if (!v20[result - 1]) {
        return -20;
      }
      uint64_t v26 = 0;
      unsigned int v28 = __clz(v20[result - 1]) - 8 * result + 41;
    }
    else
    {
      if (!v20[result - 1]) {
        return -1;
      }
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t v27 = *(void *)&v20[v26];
      unsigned int v28 = __clz(v20[result - 1]) - 23;
    }
    uint64_t v35 = *v19;
    unsigned int v36 = v28 + v35;
    uint64_t v37 = dword_1DD3210C0[v35];
    unint64_t v38 = (v27 >> -(char)(v28 + v35)) & v37;
    if (v28 + v35 <= 0x40)
    {
      if (v26 >= 8)
      {
        unsigned int v39 = v36 >> 3;
        v36 &= 7u;
      }
      else
      {
        if (!v26) {
          goto LABEL_68;
        }
        if (&v20[v26 - (v36 >> 3)] >= v20) {
          unsigned int v39 = v36 >> 3;
        }
        else {
          unsigned int v39 = v26;
        }
        v36 -= 8 * v39;
      }
      v26 -= v39;
      unint64_t v27 = *(void *)&v20[v26];
    }
LABEL_68:
    unsigned int v46 = v36 + v35;
    unint64_t v42 = (v27 >> -(char)v46) & v37;
    if (v46 > 0x40)
    {
LABEL_69:
      int v47 = a1;
LABEL_89:
      unint64_t v75 = (unint64_t)(v21 - 2);
      if (v47 > v21 - 2) {
        return -70;
      }
      long long v76 = (unsigned char *)(v47 - a1);
      uint64_t v77 = v47 + 1;
      uint64_t v78 = 2;
      while (1)
      {
        v79 = &v17[2 * v38];
        uint64_t v80 = *v79;
        char v81 = *((unsigned char *)v79 + 2);
        uint64_t v82 = *((unsigned __int8 *)v79 + 3);
        unsigned int v83 = v46 + v82;
        uint64_t v84 = dword_1DD3210C0[v82];
        *(v77 - 1) = v81;
        if (v83 > 0x40)
        {
LABEL_154:
          *uint64_t v77 = v17[2 * v42 + 1];
          return (unint64_t)&v76[v78];
        }
        if (v26 >= 8) {
          break;
        }
        if (v26)
        {
          if (&v20[v26 - (v83 >> 3)] >= v20) {
            unsigned int v85 = v83 >> 3;
          }
          else {
            unsigned int v85 = v26;
          }
          int v86 = v83 - 8 * v85;
          goto LABEL_99;
        }
        int v86 = v83;
        unint64_t v87 = v27;
LABEL_100:
        if ((unint64_t)v77 > v75) {
          return -70;
        }
        unint64_t v38 = ((v27 >> -(char)v83) & v84) + v80;
        v88 = &v17[2 * v42];
        uint64_t v89 = *v88;
        char v90 = *((unsigned char *)v88 + 2);
        uint64_t v91 = *((unsigned __int8 *)v88 + 3);
        unsigned int v92 = v86 + v91;
        uint64_t v93 = dword_1DD3210C0[v91];
        *uint64_t v77 = v90;
        if (v92 > 0x40)
        {
          ++v77;
          uint64_t v78 = 3;
          unint64_t v42 = v38;
          goto LABEL_154;
        }
        if (v26 >= 8)
        {
          unsigned int v94 = v92 >> 3;
          unsigned int v46 = v92 & 7;
        }
        else
        {
          if (!v26)
          {
            unsigned int v46 = v92;
            unint64_t v27 = v87;
            goto LABEL_110;
          }
          if (&v20[v26 - (v92 >> 3)] >= v20) {
            unsigned int v94 = v92 >> 3;
          }
          else {
            unsigned int v94 = v26;
          }
          unsigned int v46 = v92 - 8 * v94;
        }
        v26 -= v94;
        unint64_t v27 = *(void *)&v20[v26];
LABEL_110:
        unint64_t v42 = ((v87 >> -(char)v92) & v93) + v89;
        v76 += 2;
        v95 = v77 + 1;
        v77 += 2;
        unint64_t result = -70;
        if ((unint64_t)v95 > v75) {
          return result;
        }
      }
      unsigned int v85 = v83 >> 3;
      int v86 = v83 & 7;
LABEL_99:
      v26 -= v85;
      unint64_t v87 = *(void *)&v20[v26];
      goto LABEL_100;
    }
    if (v26 >= 8)
    {
      uint64_t v50 = v46 >> 3;
      v46 &= 7u;
      v26 -= v50;
      unint64_t v27 = *(void *)&v20[v26];
    }
    else if (v26)
    {
      uint64_t v48 = v46 >> 3;
      uint64_t v49 = &v20[v26 - v48] >= v20 ? v48 : v26;
      v46 -= 8 * v49;
      v26 -= v49;
      unint64_t v27 = *(void *)&v20[v26];
      if (v46 > 0x40) {
        goto LABEL_69;
      }
    }
    int v47 = a1;
    do
    {
      if (v26 >= 8)
      {
        BOOL v52 = 0;
        unsigned int v53 = v46 >> 3;
        v46 &= 7u;
      }
      else
      {
        if (!v26) {
          goto LABEL_89;
        }
        int v51 = &v20[v26 - (v46 >> 3)];
        BOOL v52 = v51 < v20;
        if (v51 >= v20) {
          unsigned int v53 = v46 >> 3;
        }
        else {
          unsigned int v53 = v26;
        }
        v46 -= 8 * v53;
      }
      v26 -= v53;
      unint64_t v27 = *(void *)&v20[v26];
      if ((unint64_t)v47 >= v22) {
        break;
      }
      if (v52) {
        break;
      }
      uint64_t v54 = &v17[2 * v38];
      uint64_t v55 = *v54;
      char v56 = *((unsigned char *)v54 + 2);
      uint64_t v57 = *((unsigned __int8 *)v54 + 3);
      int v58 = v46 + v57;
      uint64_t v59 = ((v27 >> -(char)v58) & dword_1DD3210C0[v57]) + v55;
      *int v47 = v56;
      int v60 = &v17[2 * v42];
      uint64_t v61 = *v60;
      char v62 = *((unsigned char *)v60 + 2);
      uint64_t v63 = *((unsigned __int8 *)v60 + 3);
      int v64 = v58 + v63;
      uint64_t v65 = ((v27 >> -(char)v64) & dword_1DD3210C0[v63]) + v61;
      v47[1] = v62;
      long long v66 = &v17[2 * v59];
      uint64_t v67 = *v66;
      char v68 = *((unsigned char *)v66 + 2);
      uint64_t v69 = *((unsigned __int8 *)v66 + 3);
      int v70 = v64 + v69;
      unint64_t v38 = ((v27 >> -(char)v70) & dword_1DD3210C0[v69]) + v67;
      v47[2] = v68;
      uint64_t v71 = &v17[2 * v65];
      uint64_t v72 = *v71;
      char v73 = *((unsigned char *)v71 + 2);
      uint64_t v74 = *((unsigned __int8 *)v71 + 3);
      unsigned int v46 = v70 + v74;
      unint64_t v42 = ((v27 >> -(char)v46) & dword_1DD3210C0[v74]) + v72;
      v47[3] = v73;
      v47 += 4;
    }
    while (v46 <= 0x40);
    goto LABEL_89;
  }
  if (!result) {
    return -72;
  }
  if (result < 8)
  {
    unint64_t v23 = *v20;
    switch(result)
    {
      case 2uLL:
        goto LABEL_27;
      case 3uLL:
        goto LABEL_26;
      case 4uLL:
        goto LABEL_25;
      case 5uLL:
        goto LABEL_24;
      case 6uLL:
        goto LABEL_23;
      case 7uLL:
        v23 |= (unint64_t)v20[6] << 48;
LABEL_23:
        v23 += (unint64_t)v20[5] << 40;
LABEL_24:
        v23 += (unint64_t)v20[4] << 32;
LABEL_25:
        v23 += (unint64_t)v20[3] << 24;
LABEL_26:
        v23 += (unint64_t)v20[2] << 16;
LABEL_27:
        v23 += (unint64_t)v20[1] << 8;
        break;
      default:
        break;
    }
    if (v20[result - 1])
    {
      unsigned int v25 = __clz(v20[result - 1]) - 8 * result + 41;
      uint64_t v24 = (unsigned __int8 *)a3 + v15;
LABEL_30:
      unint64_t v29 = v20 + 8;
      uint64_t v30 = *v19;
      unsigned int v31 = v25 + v30;
      uint64_t v32 = dword_1DD3210C0[v30];
      unint64_t v33 = (v23 >> -(char)(v25 + v30)) & v32;
      if (v31 > 0x40)
      {
        int v34 = v24;
        goto LABEL_56;
      }
      if (v24 >= v29)
      {
        LODWORD(v40) = v31 >> 3;
        v31 &= 7u;
      }
      else
      {
        int v34 = (unsigned __int8 *)a3 + v15;
        if (v24 == v20) {
          goto LABEL_56;
        }
        uint64_t v40 = v31 >> 3;
        if (&v24[-v40] < v20) {
          LODWORD(v40) = v24 - v20;
        }
        v31 -= 8 * v40;
      }
      int v34 = &v24[-v40];
      unint64_t v23 = *(void *)v34;
LABEL_56:
      unsigned int v41 = v31 + v30;
      unint64_t v42 = (v23 >> -(char)v41) & v32;
      if (v41 >= 0x41)
      {
LABEL_57:
        int v43 = a1;
        goto LABEL_128;
      }
      if (v34 >= v29)
      {
        uint64_t v45 = v41 >> 3;
        v41 &= 7u;
        v34 -= v45;
        unint64_t v23 = *(void *)v34;
      }
      else if (v34 == v20)
      {
        int v34 = (unsigned __int8 *)a3 + v15;
      }
      else
      {
        uint64_t v44 = v41 >> 3;
        if (&v34[-v44] >= v20) {
          uint64_t v44 = v44;
        }
        else {
          uint64_t v44 = (v34 - v20);
        }
        v41 -= 8 * v44;
        v34 -= v44;
        unint64_t v23 = *(void *)v34;
        if (v41 > 0x40) {
          goto LABEL_57;
        }
      }
      int v43 = a1;
      while (1)
      {
        if (v34 >= v29)
        {
          BOOL v97 = 0;
          LODWORD(v96) = v41 >> 3;
          v41 &= 7u;
        }
        else
        {
          if (v34 == v20)
          {
            int v34 = (unsigned __int8 *)a3 + v15;
LABEL_128:
            unint64_t v116 = (unint64_t)(v21 - 2);
            if (v43 > v21 - 2) {
              return -70;
            }
            long long v76 = (unsigned char *)(v43 - a1);
            uint64_t v77 = v43 + 1;
            uint64_t v78 = 2;
            while (2)
            {
              v117 = &v17[2 * v33];
              uint64_t v118 = *v117;
              char v119 = *((unsigned char *)v117 + 2);
              int v120 = *((unsigned __int8 *)v117 + 3);
              unsigned int v121 = v41 + v120;
              *(v77 - 1) = v119;
              if (v41 + v120 > 0x40) {
                goto LABEL_154;
              }
              if (v34 >= v29)
              {
                LODWORD(v122) = v121 >> 3;
                v121 &= 7u;
                goto LABEL_138;
              }
              if (v34 == v20)
              {
                v123 = (unsigned __int8 *)a3 + v15;
                unint64_t v124 = v23;
              }
              else
              {
                uint64_t v122 = v121 >> 3;
                if (&v34[-v122] < v20) {
                  LODWORD(v122) = v34 - v20;
                }
                v121 -= 8 * v122;
LABEL_138:
                v123 = &v34[-v122];
                unint64_t v124 = *(void *)v123;
              }
              if ((unint64_t)v77 > v116) {
                return -70;
              }
              unint64_t v33 = (v23 << v41 >> -(char)v120) + v118;
              v125 = &v17[2 * v42];
              uint64_t v126 = *v125;
              int v127 = *((unsigned __int8 *)v125 + 3);
              unsigned int v41 = v121 + v127;
              *uint64_t v77 = *((unsigned char *)v125 + 2);
              if (v121 + v127 > 0x40)
              {
                ++v77;
                uint64_t v78 = 3;
                unint64_t v42 = v33;
                goto LABEL_154;
              }
              if (v123 < v29)
              {
                if (v123 == v20)
                {
                  int v34 = (unsigned __int8 *)a3 + v15;
                  unint64_t v23 = v124;
                }
                else
                {
                  uint64_t v128 = v41 >> 3;
                  if (&v123[-v128] < v20) {
                    LODWORD(v128) = v123 - v20;
                  }
                  v41 -= 8 * v128;
LABEL_147:
                  int v34 = &v123[-v128];
                  unint64_t v23 = *(void *)v34;
                }
                unint64_t v42 = (v124 << v121 >> -(char)v127) + v126;
                v76 += 2;
                v129 = v77 + 1;
                v77 += 2;
                unint64_t result = -70;
                if ((unint64_t)v129 > v116) {
                  return result;
                }
                continue;
              }
              break;
            }
            LODWORD(v128) = v41 >> 3;
            v41 &= 7u;
            goto LABEL_147;
          }
          uint64_t v96 = v41 >> 3;
          BOOL v97 = &v34[-v96] < v20;
          if (&v34[-v96] < v20) {
            LODWORD(v96) = v34 - v20;
          }
          v41 -= 8 * v96;
        }
        v34 -= v96;
        unint64_t v23 = *(void *)v34;
        if ((unint64_t)v43 < v22 && !v97)
        {
          v98 = &v17[2 * v33];
          uint64_t v99 = *v98;
          char v100 = *((unsigned char *)v98 + 2);
          LODWORD(v98) = *((unsigned __int8 *)v98 + 3);
          unint64_t v101 = v23 << v41 >> -(char)v98;
          LODWORD(v98) = v41 + v98;
          uint64_t v102 = v101 + v99;
          *int v43 = v100;
          v103 = &v17[2 * v42];
          uint64_t v104 = *v103;
          char v105 = *((unsigned char *)v103 + 2);
          LODWORD(v103) = *((unsigned __int8 *)v103 + 3);
          unint64_t v106 = v23 << (char)v98 >> -(char)v103;
          LODWORD(v98) = v98 + v103;
          uint64_t v107 = v106 + v104;
          v43[1] = v105;
          v108 = &v17[2 * v102];
          uint64_t v109 = *v108;
          char v110 = *((unsigned char *)v108 + 2);
          LODWORD(v108) = *((unsigned __int8 *)v108 + 3);
          unint64_t v111 = v23 << (char)v98 >> -(char)v108;
          LODWORD(v108) = v98 + v108;
          unint64_t v33 = v111 + v109;
          void v43[2] = v110;
          v112 = &v17[2 * v107];
          uint64_t v113 = *v112;
          char v114 = *((unsigned char *)v112 + 2);
          LODWORD(v112) = *((unsigned __int8 *)v112 + 3);
          unint64_t v115 = v23 << (char)v108 >> -(char)v112;
          unsigned int v41 = v108 + v112;
          unint64_t v42 = v115 + v113;
          v43[3] = v114;
          v43 += 4;
          if (v41 <= 0x40) {
            continue;
          }
        }
        goto LABEL_128;
      }
    }
    return -20;
  }
  if (!v20[result - 1]) {
    return -1;
  }
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v24 = (unsigned __int8 *)a3 + a4 - 8;
    unint64_t v23 = *(void *)v24;
    unsigned int v25 = __clz(v20[result - 1]) - 23;
    goto LABEL_30;
  }
  return result;
}

void sub_1DD2946B4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (pthread_mutex_t *)(a1 + 96);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 96));
    *(_DWORD *)(a1 + 256) = 1;
    pthread_mutex_unlock(v2);
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 160));
    pthread_cond_broadcast((pthread_cond_t *)(a1 + 208));
    if (*(void *)(a1 + 32))
    {
      unint64_t v3 = 0;
      do
        pthread_join(*(pthread_t *)(*(void *)(a1 + 24) + 8 * v3++), 0);
      while (v3 < *(void *)(a1 + 32));
    }
    pthread_mutex_destroy(v2);
    pthread_cond_destroy((pthread_cond_t *)(a1 + 160));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 208));
    uint64_t v5 = *(void (**)(uint64_t))(a1 + 8);
    uint64_t v4 = *(void *)(a1 + 16);
    if (*(void *)(a1 + 48))
    {
      if (v5) {
        v5(v4);
      }
      else {
        free(*(void **)(a1 + 48));
      }
      uint64_t v5 = *(void (**)(uint64_t))(a1 + 8);
      uint64_t v4 = *(void *)(a1 + 16);
    }
    if (*(void *)(a1 + 24))
    {
      if (v5) {
        v5(v4);
      }
      else {
        free(*(void **)(a1 + 24));
      }
    }
    uint64_t v6 = *(void (**)(uint64_t, uint64_t))(a1 + 8);
    if (v6)
    {
      uint64_t v7 = *(void *)(a1 + 16);
      v6(v7, a1);
    }
    else
    {
      free((void *)a1);
    }
  }
}

unint64_t sub_1DD2947FC(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v4 = a1;
  if (a2 < 0x20)
  {
    unint64_t v13 = a3 + 0x27D4EB2F165667C5;
  }
  else
  {
    unint64_t v5 = (unint64_t)a1 + a2 - 31;
    unint64_t v6 = a3 + 0x60EA27EEADC0B5D6;
    unint64_t v7 = a3 - 0x3D4D51C2D82B14B1;
    unint64_t v8 = a3 + 0x61C8864E7A143579;
    do
    {
      uint64_t v9 = __ROR8__(v6 - 0x3D4D51C2D82B14B1 * *v4, 33);
      unint64_t v6 = 0x9E3779B185EBCA87 * v9;
      uint64_t v10 = __ROR8__(v7 - 0x3D4D51C2D82B14B1 * v4[1], 33);
      unint64_t v7 = 0x9E3779B185EBCA87 * v10;
      uint64_t v11 = __ROR8__(a3 - 0x3D4D51C2D82B14B1 * v4[2], 33);
      a3 = 0x9E3779B185EBCA87 * v11;
      uint64_t v12 = __ROR8__(v8 - 0x3D4D51C2D82B14B1 * v4[3], 33);
      unint64_t v8 = 0x9E3779B185EBCA87 * v12;
      v4 += 4;
    }
    while ((unint64_t)v4 < v5);
    unint64_t v13 = 0x9E3779B185EBCA87
        * ((0x9E3779B185EBCA87
          * ((0x9E3779B185EBCA87
            * ((0x9E3779B185EBCA87
              * ((__ROR8__(v7, 57) + __ROR8__(v6, 63) + __ROR8__(a3, 52) + __ROR8__(v8, 46)) ^ (0x9E3779B185EBCA87
                                                                                              * __ROR8__(0xDEF35B010F796CA9* v9, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v10, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v11, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v12, 33)))- 0x7A1435883D4D519DLL;
  }
  return sub_1DD294C24(v13 + a2, v4, a2);
}

uint64_t sub_1DD294954(uint64_t a1, unint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(int64x2_t *)(a1 + 8) = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_1DD321140);
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a2 + 0x61C8864E7A143579;
  return 0;
}

uint64_t sub_1DD29499C(uint64_t a1, char *__src, size_t __n)
{
  if (__src)
  {
    int v3 = __n;
    uint64_t v4 = __src;
    *(void *)a1 += __n;
    uint64_t v6 = *(unsigned int *)(a1 + 72);
    if (v6 + __n <= 0x1F)
    {
      memcpy((void *)(a1 + v6 + 40), __src, __n);
      LODWORD(v7) = *(_DWORD *)(a1 + 72) + v3;
LABEL_11:
      *(_DWORD *)(a1 + 72) = v7;
      return 0;
    }
    unint64_t v8 = &__src[__n];
    if (v6)
    {
      memcpy((void *)(a1 + 40 + v6), __src, (32 - v6));
      uint64_t v9 = __ROR8__(*(void *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 48), 33);
      *(void *)(a1 + 8) = 0x9E3779B185EBCA87
                          * __ROR8__(*(void *)(a1 + 8) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 40), 33);
      *(void *)(a1 + 16) = 0x9E3779B185EBCA87 * v9;
      unint64_t v10 = 0x9E3779B185EBCA87 * __ROR8__(*(void *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 64), 33);
      *(void *)(a1 + 24) = 0x9E3779B185EBCA87
                           * __ROR8__(*(void *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 56), 33);
      *(void *)(a1 + 32) = v10;
      v4 += (32 - *(_DWORD *)(a1 + 72));
      *(_DWORD *)(a1 + 72) = 0;
    }
    if (v4 + 32 <= v8)
    {
      unint64_t v11 = *(void *)(a1 + 8);
      unint64_t v12 = *(void *)(a1 + 16);
      unint64_t v13 = *(void *)(a1 + 24);
      unint64_t v14 = *(void *)(a1 + 32);
      do
      {
        unint64_t v11 = 0x9E3779B185EBCA87 * __ROR8__(v11 - 0x3D4D51C2D82B14B1 * *(void *)v4, 33);
        *(void *)(a1 + 8) = v11;
        unint64_t v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 1), 33);
        *(void *)(a1 + 16) = v12;
        unint64_t v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 2), 33);
        *(void *)(a1 + 24) = v13;
        unint64_t v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 3), 33);
        *(void *)(a1 + 32) = v14;
        v4 += 32;
      }
      while (v4 <= v8 - 32);
    }
    if (v4 < v8)
    {
      size_t v7 = v8 - v4;
      memcpy((void *)(a1 + 40), v4, v7);
      goto LABEL_11;
    }
  }
  return 0;
}

unint64_t sub_1DD294B48(void *a1)
{
  if (*a1 < 0x20uLL) {
    uint64_t v1 = a1[3] + 0x27D4EB2F165667C5;
  }
  else {
    uint64_t v1 = 0x9E3779B185EBCA87
  }
       * ((0x9E3779B185EBCA87
         * ((0x9E3779B185EBCA87
           * ((0x9E3779B185EBCA87
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))
             - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))
           - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))
         - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)))
       - 0x7A1435883D4D519DLL;
  return sub_1DD294C24(v1 + *a1, a1 + 5, *a1);
}

unint64_t sub_1DD294C24(unint64_t a1, uint64_t *a2, char a3)
{
  unint64_t v3 = a3 & 0x1F;
  if (v3 >= 8)
  {
    do
    {
      uint64_t v4 = *a2++;
      a1 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * v4, 33)) ^ a1, 37);
      v3 -= 8;
    }
    while (v3 > 7);
  }
  if (v3 >= 4)
  {
    unsigned int v5 = *(_DWORD *)a2;
    a2 = (uint64_t *)((char *)a2 + 4);
    a1 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * v5) ^ a1, 41);
    v3 -= 4;
  }
  for (; v3; --v3)
  {
    unsigned int v6 = *(unsigned __int8 *)a2;
    a2 = (uint64_t *)((char *)a2 + 1);
    a1 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v6) ^ a1, 53);
  }
  unint64_t v7 = 0x165667B19E3779F9
     * ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) >> 29));
  return v7 ^ HIDWORD(v7);
}

uint64_t sub_1DD294D00(unint64_t a1)
{
  if (a1 >= 0xFFFFFFFFFFFFFF89) {
    return -(int)a1;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD294D0C(_WORD *a1, __int16 *a2, int a3, int a4, _WORD *a5, unint64_t a6)
{
  unint64_t v6 = (1 << a4);
  LODWORD(v7) = v6 >> 1;
  if (a4) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = 1;
  }
  uint64_t v8 = (a3 + 2);
  if (((2 * ((1 << a4) + v8)) & 0xFFFFFFFFFFFFFFFCLL) + 8 > a6) {
    return -44;
  }
  uint64_t v10 = (v6 - 1);
  unsigned int v11 = (v6 >> 3) + (v6 >> 1) + 3;
  *a1 = a4;
  unint64_t v12 = &a5[v8];
  a1[1] = a3;
  *a5 = 0;
  uint64_t v13 = (a3 + 1);
  if (a3 == -1)
  {
    a5[v13] = v6 + 1;
    uint64_t v24 = (char *)v12 + v6;
  }
  else
  {
    uint64_t v14 = 0;
    if (v8 <= 2) {
      uint64_t v15 = 2;
    }
    else {
      uint64_t v15 = v8;
    }
    uint64_t v16 = v15 - 1;
    unsigned int v17 = v6 - 1;
    do
    {
      int v18 = (unsigned __int16)a2[v14];
      unsigned int v19 = &a5[v14];
      __int16 v20 = *v19;
      if (v18 == 0xFFFF)
      {
        v19[1] = v20 + 1;
        *((unsigned char *)v12 + v17--) = v14;
      }
      else
      {
        v19[1] = v20 + v18;
      }
      ++v14;
    }
    while (v16 != v14);
    a5[v13] = v6 + 1;
    if (v17 != v10)
    {
      uint64_t v32 = 0;
      unsigned int v33 = 0;
      do
      {
        int v34 = a2[v32];
        if (v34 >= 1)
        {
          for (int i = 0; i != v34; ++i)
          {
            *((unsigned char *)v12 + v33) = v32;
            do
              unsigned int v33 = (v33 + v11) & v10;
            while (v33 > v17);
          }
        }
        ++v32;
      }
      while (v32 != v13);
      goto LABEL_33;
    }
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = (char *)v12 + v6;
    uint64_t v25 = (uint64_t)&a5[v8 + 4] + v6;
    do
    {
      int v26 = a2[v21];
      unint64_t v27 = (unsigned __int16)a2[v21];
      *(void *)&v24[v23] = v22;
      if (v26 >= 9)
      {
        uint64_t v28 = 0;
        do
        {
          *(void *)(v25 + v23 + v28) = v22;
          unint64_t v29 = v28 + 16;
          v28 += 8;
        }
        while (v29 < v27);
      }
      v23 += (__int16)v27;
      ++v21;
      v22 += 0x101010101010101;
    }
    while (v21 != v13);
  }
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  do
  {
    *((unsigned char *)v12 + (v31 & v10)) = v24[v30];
    *((unsigned char *)v12 + ((v31 + v11) & v10)) = v24[v30 + 1];
    uint64_t v31 = (v31 + 2 * v11) & v10;
    v30 += 2;
  }
  while (v30 < v6);
LABEL_33:
  uint64_t v36 = 0;
  do
  {
    uint64_t v37 = *((unsigned __int8 *)v12 + v36);
    uint64_t v38 = (unsigned __int16)a5[v37];
    a5[v37] = v38 + 1;
    a1[v38 + 2] = v6 + v36++;
  }
  while (v6 != v36);
  int v39 = 0;
  int v40 = (a4 << 16) - v6;
  if (v13 <= 1) {
    uint64_t v13 = 1;
  }
  else {
    uint64_t v13 = v13;
  }
  unsigned int v41 = &a1[2 * v7 + 4];
  do
  {
    int v43 = *a2++;
    int v42 = v43;
    if (v43 == -1 || v42 == 1)
    {
      *(v41 - 1) = v39 - 1;
      _DWORD *v41 = v40;
      ++v39;
    }
    else if (v42)
    {
      unsigned int v45 = a4 - 31 + __clz(v42 - 1);
      _DWORD *v41 = (v45 << 16) - (v42 << v45);
      *(v41 - 1) = v39 - v42;
      v39 += v42;
    }
    else
    {
      _DWORD *v41 = v40 + 0x10000;
    }
    v41 += 2;
    --v13;
  }
  while (v13);
  return 0;
}

uint64_t sub_1DD294F98(_WORD *a1, unint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  if (a5 > 0xC) {
    return -44;
  }
  if (a5 < 5) {
    return -1;
  }
  LODWORD(v6) = ((a5 + a5 * a4 + 6) >> 3) + 3;
  if (a4) {
    unint64_t v6 = v6;
  }
  else {
    unint64_t v6 = 512;
  }
  return sub_1DD294FE0(a1, a2, a3, a4, a5, v6 <= a2);
}

uint64_t sub_1DD294FE0(_WORD *a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6)
{
  uint64_t v6 = (a4 + 1);
  if (a4 == -1) {
    return -1;
  }
  BOOL v8 = 0;
  unsigned int v9 = 0;
  int v10 = 1 << a5;
  int v11 = (1 << a5) + 1;
  unsigned int v12 = a5 - 5;
  uint64_t v13 = (a5 + 1);
  unint64_t v14 = (unint64_t)a1 + a2 - 2;
  int v15 = 4;
  uint64_t v16 = a1;
  while (1)
  {
    if (!v8)
    {
      LODWORD(v17) = v9;
      goto LABEL_25;
    }
    LODWORD(v17) = v9;
    if (v9 < v6)
    {
      uint64_t v17 = v9;
      while (!*(_WORD *)(a3 + 2 * v17))
      {
        if (v6 == ++v17) {
          goto LABEL_43;
        }
      }
    }
    if (v17 == v6) {
      break;
    }
    if (v17 >= v9 + 24)
    {
      while (a6 || (unint64_t)v16 <= v14)
      {
        unsigned int v19 = v12 + (0xFFFF << v15);
        *v16++ = v19;
        unsigned int v12 = HIWORD(v19);
        unsigned int v18 = v9 + 24;
        unsigned int v20 = v9 + 48;
        v9 += 24;
        if (v17 < v20) {
          goto LABEL_17;
        }
      }
      return -70;
    }
    unsigned int v18 = v9;
LABEL_17:
    unsigned int v21 = v18 + 3;
    while (v17 >= v21)
    {
      v12 += 3 << v15;
      v15 += 2;
      unsigned int v21 = v18 + 6;
      v18 += 3;
    }
    v12 += (v17 - v18) << v15;
    if (v15 < 15)
    {
      v15 += 2;
    }
    else
    {
      if (!a6 && (unint64_t)v16 > v14) {
        return -70;
      }
      *v16++ = v12;
      v12 >>= 16;
      v15 -= 14;
    }
LABEL_25:
    int v22 = *(__int16 *)(a3 + 2 * v17);
    int v23 = ~v11 + 2 * v10;
    if (v22 >= 0) {
      int v24 = *(__int16 *)(a3 + 2 * v17);
    }
    else {
      int v24 = -v22;
    }
    v11 -= v24;
    int v25 = v22 + 1;
    if (v25 >= v10) {
      int v26 = v23;
    }
    else {
      int v26 = 0;
    }
    int v27 = v26 + v25;
    BOOL v28 = v26 + v25 < v23;
    BOOL v8 = v27 == 1;
    if (v11 < 1) {
      return -1;
    }
    if (v11 >= v10)
    {
      uint64_t v30 = v13;
    }
    else
    {
      int v29 = v10;
      LODWORD(v30) = v13;
      do
      {
        uint64_t v30 = (v30 - 1);
        int v10 = v29 >> 1;
        BOOL v31 = v11 < v29 >> 1;
        v29 >>= 1;
      }
      while (v31);
    }
    v12 += v27 << v15;
    int v15 = v15 + v13 - v28;
    if (v15 >= 17)
    {
      if (!a6 && (unint64_t)v16 > v14) {
        return -70;
      }
      *v16++ = v12;
      v12 >>= 16;
      v15 -= 16;
    }
    unsigned int v9 = v17 + 1;
    if ((int)v17 + 1 < v6)
    {
      uint64_t v13 = v30;
      if (v11 > 1) {
        continue;
      }
    }
    break;
  }
LABEL_43:
  if (v11 != 1) {
    return -1;
  }
  if (!a6 && (unint64_t)v16 > v14) {
    return -70;
  }
  *uint64_t v16 = v12;
  int v32 = v15 + 7;
  BOOL v31 = v15 < -7;
  int v33 = v15 + 14;
  if (v31) {
    int v32 = v33;
  }
  return (char *)v16 + (v32 >> 3) - (char *)a1;
}

uint64_t sub_1DD2951FC(unsigned int a1, unsigned int a2, unsigned int a3, int a4)
{
  unsigned int v4 = 31 - a4 - __clz(a2 - 1);
  unsigned int v5 = 32 - __clz(a2);
  unsigned int v6 = 33 - __clz(a3);
  if (v5 >= v6) {
    unsigned int v5 = v6;
  }
  if (a1) {
    unsigned int v7 = a1;
  }
  else {
    unsigned int v7 = 11;
  }
  if (v4 >= v7) {
    unsigned int v4 = v7;
  }
  if (v5 > v4) {
    unsigned int v4 = v5;
  }
  if (v4 <= 5) {
    unsigned int v4 = 5;
  }
  if (v4 >= 0xC) {
    return 12;
  }
  else {
    return v4;
  }
}

uint64_t sub_1DD295268(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3 = 29 - __clz(a2 - 1);
  unsigned int v4 = 32 - __clz(a2);
  unsigned int v5 = 33 - __clz(a3);
  if (v4 >= v5) {
    unsigned int v4 = v5;
  }
  if (a1) {
    unsigned int v6 = a1;
  }
  else {
    unsigned int v6 = 11;
  }
  if (v3 >= v6) {
    unsigned int v3 = v6;
  }
  if (v4 > v3) {
    unsigned int v3 = v4;
  }
  if (v3 <= 5) {
    unsigned int v3 = 5;
  }
  if (v3 >= 0xC) {
    return 12;
  }
  else {
    return v3;
  }
}

uint64_t sub_1DD2952D0(__int16 *a1, unsigned int a2, unsigned int *a3, unint64_t a4, unsigned int a5, int a6)
{
  if (a2) {
    uint64_t result = a2;
  }
  else {
    uint64_t result = 11;
  }
  if (result < 5) {
    return -1;
  }
  if (result > 0xC) {
    return -44;
  }
  unsigned int v8 = 32 - __clz(a4);
  unsigned int v9 = 33 - __clz(a5);
  if (v8 >= v9) {
    unsigned int v8 = v9;
  }
  if (result < v8) {
    return -1;
  }
  unsigned __int16 v10 = 0;
  int v11 = 0;
  unsigned int v12 = 0;
  if (a6) {
    __int16 v13 = -1;
  }
  else {
    __int16 v13 = 1;
  }
  char v14 = 62 - result;
  int v15 = 1 << result;
  unint64_t v16 = a4 >> result;
  LODWORD(v17) = 1 << result;
  do
  {
    uint64_t v18 = a3[v12];
    if (v18 == a4) {
      return 0;
    }
    uint64_t v19 = v12;
    if (v18)
    {
      if (v18 <= v16)
      {
        a1[v12] = v13;
        LODWORD(v17) = v17 - 1;
      }
      else
      {
        unint64_t v20 = 0x4000000000000000uLL / a4 * v18;
        unint64_t v21 = v20 >> v14;
        if (((v20 >> v14) & 0xFFF8) == 0
          && v20 - ((unint64_t)(unsigned __int16)(v20 >> v14) << v14) > (unint64_t)dword_1DD321150[(unsigned __int16)(v20 >> v14)] << (42 - result))
        {
          LOWORD(v21) = v21 + 1;
        }
        if ((unsigned __int16)v21 > v10)
        {
          int v11 = v19;
          unsigned __int16 v10 = v21;
        }
        a1[v19] = v21;
        LODWORD(v17) = v17 - (unsigned __int16)v21;
      }
    }
    else
    {
      a1[v12] = 0;
    }
    unsigned int v12 = v19 + 1;
  }
  while ((int)v19 + 1 <= a5);
  int v22 = &a1[v11];
  __int16 v23 = *v22;
  if (-(int)v17 < *v22 >> 1)
  {
LABEL_52:
    *int v22 = v23 + v17;
    return result;
  }
  int v24 = 0;
  unint64_t v25 = (3 * a4) >> (result + 1);
  uint64_t v26 = a5 + 1;
  int v27 = a3;
  uint64_t v28 = v26;
  int v29 = a1;
  do
  {
    unsigned int v31 = *v27++;
    uint64_t v30 = v31;
    if (v31)
    {
      if (v30 <= v16)
      {
        *int v29 = v13;
      }
      else
      {
        if (v30 > v25)
        {
          *int v29 = -2;
          goto LABEL_37;
        }
        *int v29 = 1;
      }
      ++v24;
      a4 -= v30;
    }
    else
    {
      *int v29 = 0;
    }
LABEL_37:
    ++v29;
    --v28;
  }
  while (v28);
  unint64_t v17 = (v15 - v24);
  if (v15 != v24)
  {
    if (a4 / v17 > v25)
    {
      int v32 = a1;
      uint64_t v33 = a5 + 1;
      int v34 = a3;
      unint64_t v35 = 3 * a4 / (2 * v17);
      do
      {
        if (*v32 == -2)
        {
          uint64_t v36 = *v34;
          if (v36 <= v35)
          {
            *int v32 = 1;
            ++v24;
            a4 -= v36;
          }
        }
        ++v34;
        ++v32;
        --v33;
      }
      while (v33);
      LODWORD(v17) = v15 - v24;
    }
    if (v24 == v26)
    {
      uint64_t v37 = 0;
      unsigned int v38 = 0;
      int v39 = 0;
      do
      {
        if (a3[v37] > v38)
        {
          int v39 = v37;
          unsigned int v38 = a3[v37];
        }
        ++v37;
      }
      while (v26 != v37);
      int v22 = &a1[v39];
      __int16 v23 = *v22;
      goto LABEL_52;
    }
    if (a4)
    {
      unsigned int v40 = 0;
      unint64_t v41 = ~(-1 << (61 - result));
      unint64_t v42 = (((unint64_t)v17 << v14) + v41) / a4;
      while (1)
      {
        uint64_t v43 = v40;
        if (a1[v40] == -2)
        {
          unint64_t v44 = v41 + v42 * a3[v40];
          int v45 = (v44 >> v14) - (v41 >> v14);
          if (!v45) {
            return -1;
          }
          a1[v43] = v45;
          unint64_t v41 = v44;
        }
        unsigned int v40 = v43 + 1;
        if ((int)v43 + 1 > a5) {
          return result;
        }
      }
    }
    if (v17)
    {
      unsigned int v46 = 0;
      do
      {
        uint64_t v47 = v46;
        int v48 = a1[v46];
        if (v48 >= 1)
        {
          LODWORD(v17) = v17 - 1;
          a1[v47] = v48 + 1;
        }
        if (v47 == a5) {
          unsigned int v46 = 0;
        }
        else {
          unsigned int v46 = v47 + 1;
        }
      }
      while (v17);
    }
  }
  return result;
}

uint64_t sub_1DD2955E0(uint64_t a1, unsigned int a2)
{
  *(_WORD *)a1 = 0;
  *(_WORD *)(a1 + 2) = a2;
  *(_DWORD *)(a1 + 4) = 0;
  *(void *)(a1 + 8 * a2 + 8) = 0;
  return 0;
}

uint64_t sub_1DD2955FC(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unsigned __int16 *a5)
{
  return sub_1DD295610(a1, a2, a3, a4, a5, a4 + (a4 >> 7) + 12 <= a2);
}

uint64_t sub_1DD295610(unint64_t *a1, unint64_t a2, unint64_t a3, unint64_t a4, unsigned __int16 *a5, int a6)
{
  if (a4 < 3 || a2 < 9) {
    return 0;
  }
  unint64_t v6 = a3 + a4;
  unint64_t v7 = (unint64_t)a1 + a2 - 8;
  unsigned int v10 = *a5;
  unsigned int v8 = a5 + 2;
  unsigned int v9 = v10;
  uint64_t v11 = 1 << (v10 - 1);
  if (!v10) {
    uint64_t v11 = 1;
  }
  unsigned int v12 = &v8[2 * v11];
  __int16 v13 = &v12[4 * *(unsigned __int8 *)(a3 + a4 - 1)];
  unint64_t v14 = v8[((unint64_t)(((*((_DWORD *)v13 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v13 + 1)) >> ((*((_DWORD *)v13 + 1) + 0x8000) >> 16))
         + *(int *)v13];
  if (a4)
  {
    int v23 = *(unsigned __int8 *)(v6 - 3);
    unint64_t v17 = (unsigned __int8 *)(v6 - 3);
    int v24 = &v12[4 * v17[1]];
    LODWORD(v22) = v8[((unint64_t)(((*((_DWORD *)v24 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v24 + 1)) >> ((*((_DWORD *)v24 + 1) + 0x8000) >> 16))
                    + *(int *)v24];
    unint64_t v25 = *(unsigned int *)&v12[4 * v23 + 2] + v14;
    unint64_t v26 = v25 >> 16;
    unint64_t v27 = dword_1DD321170[v25 >> 16] & v14;
    unsigned int v20 = v8[(v14 >> SBYTE2(v25)) + *(int *)&v12[4 * v23]];
    unint64_t v28 = v25 >> 19;
    *a1 = v27;
    int v29 = (unint64_t *)((char *)a1 + (v25 >> 19));
    if ((unint64_t)v29 <= v7) {
      unint64_t v21 = (unint64_t *)((char *)a1 + (v25 >> 19));
    }
    else {
      unint64_t v21 = (void *)v7;
    }
    int v15 = v26 & 7;
    unint64_t v16 = v27 >> (8 * v28);
    if (a6) {
      unint64_t v21 = v29;
    }
  }
  else
  {
    int v15 = 0;
    unint64_t v16 = 0;
    int v18 = *(unsigned __int8 *)(v6 - 2);
    unint64_t v17 = (unsigned __int8 *)(v6 - 2);
    uint64_t v19 = &v12[4 * v18];
    unsigned int v20 = v8[((unint64_t)(((*((_DWORD *)v19 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v19 + 1)) >> ((*((_DWORD *)v19 + 1) + 0x8000) >> 16))
           + *(int *)v19];
    unint64_t v21 = a1;
    LODWORD(v22) = v8[((unint64_t)(((*((_DWORD *)v13 + 1) + 0x8000) & 0xFFFF0000) - *((_DWORD *)v13 + 1)) >> ((*((_DWORD *)v13 + 1) + 0x8000) >> 16))
                    + *(int *)v13];
  }
  unint64_t v22 = v22;
  unint64_t v30 = v20;
  if ((a4 & 2) == 0)
  {
    int v31 = *(v17 - 2);
    v17 -= 2;
    int v32 = &v12[4 * v17[1]];
    int v33 = *(_DWORD *)v32;
    unint64_t v34 = (*((unsigned int *)v32 + 1) + (unint64_t)v22) >> 16;
    unint64_t v35 = (unint64_t)(dword_1DD321170[v34] & v22) << v15;
    int v36 = v15 + v34;
    unint64_t v22 = v8[(v22 >> v34) + (uint64_t)v33];
    uint64_t v37 = &v12[4 * v31];
    LODWORD(v34) = *(_DWORD *)v37;
    unint64_t v38 = (*((unsigned int *)v37 + 1) + v30) >> 16;
    unint64_t v39 = v35 | ((unint64_t)(dword_1DD321170[v38] & v30) << v36) | v16;
    unsigned int v40 = v36 + v38;
    unint64_t v30 = v8[(v30 >> v38) + (int)v34];
    uint64_t v41 = v40 >> 3;
    void *v21 = v39;
    unint64_t v21 = (void *)((char *)v21 + v41);
    if (!a6 && (unint64_t)v21 > v7) {
      unint64_t v21 = (void *)v7;
    }
    int v15 = v40 & 7;
    unint64_t v16 = v39 >> (8 * v41);
  }
  if ((unint64_t)v17 <= a3)
  {
    int v60 = v21;
  }
  else
  {
    do
    {
      int v42 = *(v17 - 4);
      v17 -= 4;
      uint64_t v43 = &v12[4 * v17[3]];
      int v44 = *(_DWORD *)v43;
      unint64_t v45 = (v22 + *((unsigned int *)v43 + 1)) >> 16;
      char v46 = v15 + ((v22 + *((_DWORD *)v43 + 1)) >> 16);
      unint64_t v47 = v8[(v22 >> v45) + v44];
      int v48 = &v12[4 * v17[2]];
      unint64_t v49 = (v30 + *((unsigned int *)v48 + 1)) >> 16;
      int v50 = v15 + v45 + v49;
      unint64_t v51 = v8[(v30 >> ((v30 + *((_DWORD *)v48 + 1)) >> 16)) + *(int *)v48];
      unint64_t v52 = (*(unsigned int *)&v12[4 * v17[1] + 2] + v47) >> 16;
      uint64_t v53 = *(int *)&v12[4 * v42];
      unint64_t v54 = (*(unsigned int *)&v12[4 * v42 + 2] + v51) >> 16;
      unsigned int v55 = v50 + v52 + v54;
      uint64_t v56 = v55 >> 3;
      BOOL v57 = (unint64_t)v21 + v56 > v7 && a6 == 0;
      unint64_t v58 = (unint64_t)(v22 & dword_1DD321170[v45]) << v15;
      unint64_t v22 = v8[(v47 >> ((*(_DWORD *)&v12[4 * v17[1] + 2] + v47) >> 16)) + *(int *)&v12[4 * v17[1]]];
      unint64_t v59 = v58 | v16 | ((unint64_t)(v30 & dword_1DD321170[v49]) << v46) | ((unint64_t)(dword_1DD321170[v52] & v47) << v50) | ((unint64_t)(dword_1DD321170[v54] & v51) << (v50 + ((*(_DWORD *)&v12[4 * v17[1] + 2] + v47) >> 16)));
      unint64_t v30 = v8[(v51 >> v54) + v53];
      if (v57) {
        int v60 = (void *)v7;
      }
      else {
        int v60 = (void *)((char *)v21 + v56);
      }
      void *v21 = v59;
      unint64_t v16 = v59 >> (8 * v56);
      int v15 = v55 & 7;
      unint64_t v21 = v60;
    }
    while ((unint64_t)v17 > a3);
  }
  uint64_t v61 = dword_1DD321170[v9];
  unint64_t v62 = ((v22 & v61) << v15) | v16;
  uint64_t v63 = (v15 + v9) >> 3;
  *int v60 = v62;
  int v64 = (void *)((char *)v60 + v63);
  if ((unint64_t)v60 + v63 > v7) {
    int v64 = (void *)v7;
  }
  int v65 = ((_BYTE)v15 + (_BYTE)v9) & 7;
  unint64_t v66 = ((v30 & v61) << v65) | (v62 >> (8 * v63));
  unsigned int v67 = v65 + v9;
  uint64_t v68 = v67 >> 3;
  *int v64 = v66;
  uint64_t v69 = (void *)((char *)v64 + v68);
  if ((unint64_t)v64 + v68 > v7) {
    uint64_t v69 = (void *)v7;
  }
  int v70 = v67 & 7;
  uint64_t v71 = (v66 >> (8 * v68)) | (1 << v70);
  unsigned int v72 = v70 + 1;
  *uint64_t v69 = v71;
  char v73 = (char *)v69 + (v72 >> 3);
  if (v7 <= (unint64_t)v73) {
    return 0;
  }
  if ((v72 & 7) != 0) {
    return v73 - (char *)a1 + 1;
  }
  return v73 - (char *)a1;
}

uint64_t sub_1DD2959D8(void *a1, unsigned int *a2, unsigned __int8 *a3, uint64_t a4)
{
  unsigned int v8 = *a2;
  bzero(a1, 4 * (*a2 + 1));
  if (a4)
  {
    if (a4 >= 1)
    {
      unsigned int v9 = &a3[a4];
      do
      {
        unsigned int v10 = *a3++;
        ++*((_DWORD *)a1 + v10);
      }
      while (a3 < v9);
    }
    do
      unsigned int v11 = v8;
    while (!*((_DWORD *)a1 + v8--));
    unint64_t v13 = 0;
    LODWORD(result) = 0;
    *a2 = v8 + 1;
    do
    {
      unsigned int v15 = *((_DWORD *)a1 + v13);
      if (v15 <= result) {
        uint64_t result = result;
      }
      else {
        uint64_t result = v15;
      }
    }
    while (v13++ < v11);
  }
  else
  {
    uint64_t result = 0;
    *a2 = 0;
  }
  return result;
}

uint64_t sub_1DD295A98(void *a1, unsigned int *a2, unsigned __int8 *a3, unint64_t a4, char *a5, unint64_t a6)
{
  if (a4 <= 0x5DB) {
    return sub_1DD2959D8(a1, a2, a3, a4);
  }
  if ((a5 & 3) != 0) {
    return -1;
  }
  if (a6 < 0x1000) {
    return -66;
  }
  return sub_1DD295AFC(a1, a2, (unsigned int *)a3, a4, 0, a5);
}

uint64_t sub_1DD295AFC(void *a1, unsigned int *a2, unsigned int *a3, uint64_t a4, int a5, char *a6)
{
  uint64_t v6 = a4;
  size_t v9 = 4 * (*a2 + 1);
  if (a4)
  {
    unint64_t v13 = (unsigned int *)((char *)a3 + a4);
    bzero(a6, 0x1000uLL);
    unint64_t v14 = a3;
    unsigned int v15 = a3;
    if (v6 >= 20)
    {
      unint64_t v16 = a6 + 1024;
      unint64_t v17 = a6 + 2048;
      int v18 = a6 + 3072;
      unsigned int v19 = *a3;
      unint64_t v14 = a3;
      unsigned int v15 = a3;
      do
      {
        unint64_t v20 = v15[1];
        ++*(_DWORD *)&a6[4 * v19];
        ++*(_DWORD *)&v16[4 * BYTE1(v19)];
        ++*(_DWORD *)&v17[4 * BYTE2(v19)];
        ++*(_DWORD *)&v18[4 * HIBYTE(v19)];
        unint64_t v21 = v15[2];
        ++*(_DWORD *)&a6[4 * v20];
        ++*(_DWORD *)&v16[4 * BYTE1(v20)];
        ++*(_DWORD *)&v17[4 * BYTE2(v20)];
        ++*(_DWORD *)&v18[(v20 >> 22) & 0x3FC];
        unint64_t v22 = v15[3];
        ++*(_DWORD *)&a6[4 * v21];
        ++*(_DWORD *)&v16[4 * BYTE1(v21)];
        ++*(_DWORD *)&v17[4 * BYTE2(v21)];
        ++*(_DWORD *)&v18[(v21 >> 22) & 0x3FC];
        unsigned int v23 = v15[4];
        v15 += 4;
        unsigned int v19 = v23;
        ++*(_DWORD *)&a6[4 * v22];
        ++*(_DWORD *)&v16[4 * BYTE1(v22)];
        ++*(_DWORD *)&v17[4 * BYTE2(v22)];
        ++*(_DWORD *)&v18[(v22 >> 22) & 0x3FC];
        v14 += 4;
      }
      while (v15 + 1 < (unsigned int *)((char *)a3 + v6 - 15));
    }
    if (v15 < v13)
    {
      int v24 = (char *)((char *)a3 + v6 - (char *)v14);
      do
      {
        int v25 = *(unsigned __int8 *)v15;
        unsigned int v15 = (unsigned int *)((char *)v15 + 1);
        ++*(_DWORD *)&a6[4 * v25];
        --v24;
      }
      while (v24);
    }
    uint64_t v26 = 0;
    uint32x4_t v27 = 0uLL;
    do
    {
      uint32x4_t v28 = (uint32x4_t)vaddq_s32(vaddq_s32(*(int32x4_t *)&a6[v26 + 2048], *(int32x4_t *)&a6[v26 + 1024]), vaddq_s32(*(int32x4_t *)&a6[v26 + 3072], *(int32x4_t *)&a6[v26]));
      *(uint32x4_t *)&a6[v26] = v28;
      uint32x4_t v27 = vmaxq_u32(v28, v27);
      v26 += 16;
    }
    while (v26 != 1024);
    uint64_t v6 = vmaxvq_u32(v27);
    unsigned int v29 = 256;
    do
      --v29;
    while (!*(_DWORD *)&a6[4 * v29]);
    if (a5 && v29 > *a2)
    {
      return -48;
    }
    else
    {
      *a2 = v29;
      memmove(a1, a6, v9);
    }
  }
  else
  {
    bzero(a1, 4 * (*a2 + 1));
    *a2 = 0;
  }
  return v6;
}

uint64_t sub_1DD295D84(void *a1, unsigned int *a2, unsigned int *a3, unint64_t a4, char *a5, unint64_t a6)
{
  if ((a5 & 3) != 0) {
    return -1;
  }
  if (a6 < 0x1000) {
    return -66;
  }
  if (*a2 <= 0xFE) {
    return sub_1DD295AFC(a1, a2, a3, a4, 1, a5);
  }
  *a2 = 255;
  return sub_1DD295A98(a1, a2, (unsigned __int8 *)a3, a4, a5, a6);
}

unint64_t sub_1DD295DD0(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7 = -(int)a6 & 3;
  unint64_t v8 = a7 - v7;
  if (a7 >= v7)
  {
    uint64_t v9 = a6 + v7;
  }
  else
  {
    unint64_t v8 = 0;
    uint64_t v9 = 0;
  }
  if (v8 < 0x2EC) {
    return -1;
  }
  if (a4 > 0xFF) {
    return -46;
  }
  *(unsigned char *)(v9 + 480) = 0;
  uint64_t v14 = (a5 + 1);
  if (v14 >= 2)
  {
    unsigned int v15 = (unsigned char *)(v9 + 481);
    uint64_t v16 = v14 - 1;
    do
      *v15++ = v16--;
    while (v16);
  }
  if (a4)
  {
    unint64_t v17 = (unsigned __int8 *)(a3 + 8);
    uint64_t v18 = a4;
    unsigned int v19 = (unsigned char *)(v9 + 493);
    do
    {
      unsigned int v20 = *v17;
      v17 += 8;
      *v19++ = *(unsigned char *)(v9 + v20 + 480);
      --v18;
    }
    while (v18);
  }
  if (!a2) {
    return -70;
  }
  unsigned int v26 = 12;
  if ((-(int)v9 & 3) != 0) {
    return -1;
  }
  if (a4 >= 2)
  {
    int v21 = sub_1DD2959D8((void *)(v9 + 400), &v26, (unsigned __int8 *)(v9 + 493), a4);
    if (v21 != 1 && v21 != a4)
    {
      unsigned int v22 = sub_1DD295268(6u, a4, v26);
      unint64_t result = sub_1DD2952D0((__int16 *)(v9 + 452), v22, (unsigned int *)(v9 + 400), a4, v26, 0);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t result = sub_1DD294F98((_WORD *)(a1 + 1), a2 - 1, v9 + 452, v26, v22);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t v23 = result;
      unint64_t result = sub_1DD294D0C((_WORD *)v9, (__int16 *)(v9 + 452), v26, v22, (_WORD *)(v9 + 236), 0xA4uLL);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      unint64_t result = sub_1DD2955FC((unint64_t *)(a1 + 1 + v23), a2 - (v23 + 1), v9 + 493, a4, (unsigned __int16 *)v9);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      if (result)
      {
        result += v23;
        if (result > 0xFFFFFFFFFFFFFF88) {
          return result;
        }
        if (result >= 2 && result < a4 >> 1)
        {
          *(unsigned char *)a1 = result++;
          return result;
        }
      }
    }
  }
  if (a4 > 0x80) {
    return -1;
  }
  unint64_t result = ((a4 + 1) >> 1) + 1;
  if (result > a2) {
    return -70;
  }
  *(unsigned char *)a1 = a4 + 127;
  *(unsigned char *)(v9 + a4 + 493) = 0;
  if (a4)
  {
    unint64_t v24 = 0;
    int v25 = (unsigned char *)(a1 + 1);
    do
    {
      *v25++ = *(unsigned char *)(v9 + v24 + 494) + 16 * *(unsigned char *)(v9 + v24 + 493);
      v24 += 2;
    }
    while (v24 < a4);
  }
  return result;
}

unint64_t sub_1DD296048(void *a1, _DWORD *a2, char *a3, unint64_t a4, _DWORD *a5)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v32 = 0;
  unint64_t result = sub_1DD29394C(v42, 0x100uLL, (uint64_t)v41, &v32, (_DWORD *)&v32 + 1, a3, a4);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    *a5 = v41[0] != 0;
    uint64_t v9 = HIDWORD(v32);
    if (HIDWORD(v32) <= 0xC)
    {
      uint64_t v10 = v32;
      if (v32 <= *a2 + 1)
      {
        unsigned int v11 = a1 + 1;
        *a1 = HIDWORD(v32);
        if (v9)
        {
          uint64_t v12 = 0;
          int v13 = 0;
          do
          {
            int v14 = v41[v12 + 1] << v12;
            v41[v12 + 1] = v13;
            v13 += v14;
            ++v12;
          }
          while (v9 != v12);
        }
        if (v10)
        {
          unsigned int v15 = v42;
          uint64_t v16 = v10;
          unint64_t v17 = a1 + 1;
          do
          {
            int v18 = *v15++;
            unsigned __int8 v19 = v9 + 1 - v18;
            if (v18) {
              unsigned __int8 v20 = v19;
            }
            else {
              unsigned __int8 v20 = 0;
            }
            *v17++ = v20;
            --v16;
          }
          while (v16);
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          int v40 = 0;
          uint64_t v39 = 0;
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          int v36 = 0;
          uint64_t v21 = v10;
          unsigned int v22 = (unsigned __int8 *)(a1 + 1);
          uint64_t v35 = 0;
          do
          {
            unsigned int v23 = *v22;
            v22 += 8;
            ++*((_WORD *)&v37 + v23);
            --v21;
          }
          while (v21);
        }
        else
        {
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          int v40 = 0;
          uint64_t v39 = 0;
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          int v36 = 0;
          uint64_t v35 = 0;
        }
        *((_WORD *)&v33 + (v9 + 1)) = 0;
        if (v9)
        {
          __int16 v24 = 0;
          int v25 = (_WORD *)&v33 + v9;
          unsigned int v26 = (__int16 *)&v37 + v9;
          do
          {
            *v25-- = v24;
            __int16 v27 = *v26--;
            __int16 v24 = (unsigned __int16)(v27 + v24) >> 1;
            LODWORD(v9) = v9 - 1;
          }
          while (v9);
        }
        if (v10)
        {
          uint64_t v28 = v10;
          do
          {
            uint64_t v29 = *v11;
            uint64_t v30 = *v11;
            uint64_t v31 = *((unsigned __int16 *)&v33 + v30);
            *((_WORD *)&v33 + v30) = v31 + 1;
            if (v30) {
              uint64_t *v11 = (v31 << -(char)v30) | v29;
            }
            ++v11;
            --v28;
          }
          while (v28);
        }
        *a2 = v10 - 1;
      }
      else
      {
        return -48;
      }
    }
    else
    {
      return -44;
    }
  }
  return result;
}

uint64_t sub_1DD29625C(uint64_t a1, unsigned int a2)
{
  return *(unsigned __int8 *)(a1 + 8 * a2 + 8);
}

uint64_t sub_1DD296268(uint64_t *a1, unsigned int *a2, uint64_t a3, unsigned int a4, uint64_t a5, unint64_t a6)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = -(int)a5 & 3;
  unint64_t v7 = a6 - v6;
  if (a6 >= v6)
  {
    unint64_t v8 = (_DWORD *)(a5 + v6);
  }
  else
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  if (v7 >> 8 < 0x13) {
    return -66;
  }
  if (a3 > 0xFF) {
    return -46;
  }
  int v14 = v8 + 2;
  unsigned int v15 = v8 + 1024;
  uint64_t v16 = (a3 + 1);
  bzero(v8, 0x1300uLL);
  unint64_t v17 = a2;
  uint64_t v18 = (a3 + 1);
  do
  {
    unsigned int v20 = *v17++;
    unsigned int v19 = v20;
    unsigned int v21 = 189 - __clz(v20);
    if (v20 >= 0xA5) {
      unsigned int v19 = v21;
    }
    ++LOWORD(v15[v19]);
    --v18;
  }
  while (v18);
  uint64_t v22 = 0;
  int v23 = *((unsigned __int16 *)v8 + 2430);
  do
  {
    __int16 v24 = &v8[v22];
    v23 += LOWORD(v8[v22 + 1214]);
    *((_WORD *)v24 + 2428) = v23;
    *((_WORD *)v24 + 2429) = v23;
    --v22;
  }
  while (v22 != -191);
  uint64_t v25 = 0;
  do
  {
    unsigned int v26 = a2[v25];
    unsigned int v27 = 189 - __clz(v26);
    if (v26 < 0xA5) {
      unsigned int v27 = a2[v25];
    }
    uint64_t v28 = &v15[v27 + 1];
    uint64_t v29 = *((unsigned __int16 *)v28 + 1);
    *((_WORD *)v28 + 1) = v29 + 1;
    uint64_t v30 = &v14[2 * v29];
    *uint64_t v30 = v26;
    *((unsigned char *)v30 + 6) = v25++;
  }
  while (v16 != v25);
  uint64_t v31 = 0x3FFFFFFFFFFFFFE6;
  do
  {
    uint64_t v32 = LOWORD(v8[v31 + 1215]);
    int v33 = HIWORD(v8[v31 + 1215]) - v32;
    if (v33 >= 2) {
      sub_1DD297FD4((uint64_t)&v14[2 * v32], 0, (v33 - 1));
    }
    ++v31;
  }
  while (v31 * 4);
  int v34 = 0;
  uint64_t v35 = a3 << 32;
  int v36 = a3 + 1;
  uint64_t v37 = &v8[2 * (int)a3 + 5];
  int v38 = -1;
  do
  {
    --v34;
    int v39 = *((_DWORD *)v37 - 3);
    v35 -= 0x100000000;
    --v36;
    v37 -= 4;
    --v38;
  }
  while (!v39);
  if (a4) {
    unsigned int v40 = a4;
  }
  else {
    unsigned int v40 = 11;
  }
  int v41 = a3 + v34;
  int v42 = a3 + v34 + 1;
  unint64_t v43 = (a3 + v34 + 256);
  int v44 = (char *)v14 + (v35 >> 29);
  v8[514] = *(_DWORD *)v44 + v39;
  *((_WORD *)v44 + 2) = 256;
  _WORD *v37 = 256;
  if (v42 >= 2)
  {
    int v45 = a3 + v38;
    uint64_t v46 = 257;
    if (v43 > 0x101) {
      uint64_t v46 = (v41 + 256);
    }
    uint64_t v47 = 8 * v46;
    uint64_t v48 = 2048;
    do
    {
      v8[(unint64_t)v48 / 4 + 4] = 0x40000000;
      v48 += 8;
    }
    while (v47 != v48);
    *unint64_t v8 = 0x80000000;
    if ((int)v43 <= 257) {
      uint64_t v49 = 257;
    }
    else {
      uint64_t v49 = v43;
    }
    int v50 = v8 + 516;
    uint64_t v51 = 256;
    int v52 = 256;
    do
    {
      unsigned int v53 = v14[2 * v45];
      ++v51;
      unsigned int v54 = v14[2 * v52];
      BOOL v55 = v53 >= v54;
      BOOL v56 = v53 < v54;
      if (v55) {
        int v57 = v52 + 1;
      }
      else {
        int v57 = v52;
      }
      if (!v55) {
        int v52 = v45;
      }
      int v58 = v45 - v56;
      unsigned int v59 = v14[2 * v58];
      unsigned int v60 = v14[2 * v57];
      BOOL v61 = v59 >= v60;
      if (v59 >= v60) {
        int v62 = v57;
      }
      else {
        int v62 = v58;
      }
      uint64_t v63 = &v14[2 * v52];
      int v64 = &v14[2 * v62];
      *int v50 = *v64 + *v63;
      v50 += 2;
      int v65 = !v61;
      if (v61) {
        int v52 = v57 + 1;
      }
      else {
        int v52 = v57;
      }
      int v45 = v58 - v65;
      *((_WORD *)v64 + 2) = v51;
      *((_WORD *)v63 + 2) = v51;
    }
    while (v49 != v51);
    HIBYTE(v14[2 * (int)v43 + 1]) = 0;
    unint64_t v66 = (char *)&v8[2 * (v41 + 255) + 3] + 3;
    do
    {
      *unint64_t v66 = HIBYTE(v14[2 * *(unsigned __int16 *)(v66 - 3) + 1]) + 1;
      v66 -= 8;
      LODWORD(v43) = v43 - 1;
    }
    while ((int)v43 > 256);
  }
  else
  {
    *unint64_t v8 = 0x80000000;
    HIBYTE(v14[2 * (int)v43 + 1]) = 0;
  }
  uint64_t v67 = (v41 + 2);
  if ((v42 & 0x80000000) == 0)
  {
    uint64_t v68 = (char *)v8 + 15;
    uint64_t v69 = v67;
    do
    {
      *uint64_t v68 = HIBYTE(v14[2 * *(unsigned __int16 *)(v68 - 3) + 1]) + 1;
      v68 += 8;
      --v69;
    }
    while (v69);
  }
  unsigned int v70 = HIBYTE(v14[2 * v36 + 1]);
  LODWORD(v71) = v70;
  char v72 = v70 - v40;
  if (v70 > v40)
  {
    LODWORD(v71) = v40;
    uint64_t v73 = v35 + 0x100000000;
    unsigned int v74 = *((unsigned __int8 *)v14 + ((v35 + 0x100000000) >> 29) + 7);
    if (v40 >= v74)
    {
      int v75 = 0;
      uint64_t v80 = v73 >> 32;
      LODWORD(v76) = a3 + v34 + 1;
    }
    else
    {
      int v75 = 0;
      uint64_t v76 = (a3 + v34 + 1);
      uint64_t v77 = (char *)&v8[2 * (int)v76 + 3] + 3;
      uint64_t v78 = v76 << 32;
      do
      {
        v75 += (1 << v72) + (-1 << (v70 - v74));
        *uint64_t v77 = v40;
        unsigned int v79 = *(v77 - 8);
        v77 -= 8;
        LOBYTE(v74) = v79;
        v78 -= 0x100000000;
        LODWORD(v76) = v76 - 1;
      }
      while (v40 < v79);
      uint64_t v80 = v78 >> 32;
    }
    int v81 = v76 + 1;
    int v82 = v80 + 1;
    unsigned int v83 = (unsigned __int8 *)&v8[2 * v80 + 3] + 3;
    do
    {
      int v84 = *v83;
      v83 -= 8;
      --v81;
      --v82;
    }
    while (v40 == v84);
    signed int v85 = v75 >> v72;
    unint64_t v125 = 0xF0F0F0F0F0F0F0F0;
    *(void *)&long long v86 = 0xF0F0F0F0F0F0F0F0;
    *((void *)&v86 + 1) = 0xF0F0F0F0F0F0F0F0;
    long long v123 = v86;
    long long v124 = v86;
    long long v122 = v86;
    if ((v82 & 0x80000000) == 0)
    {
      unint64_t v87 = (unsigned __int8 *)&v8[2 * v81 + 3] + 3;
      unsigned int v88 = v40;
      do
      {
        unsigned int v90 = *v87;
        v87 -= 8;
        unsigned int v89 = v90;
        if (v88 <= v90)
        {
          int v91 = v81;
        }
        else
        {
          *((_DWORD *)&v122 + v40 - v89) = v81;
          int v91 = v81;
          unsigned int v88 = v89;
        }
        --v81;
      }
      while (v91 > 0);
    }
    if (v85 >= 1)
    {
      do
      {
        unsigned int v92 = __clz(v85);
        if (v92 == 31)
        {
LABEL_78:
          LODWORD(v93) = 1;
        }
        else
        {
          uint64_t v93 = 32 - v92;
          while (1)
          {
            uint64_t v94 = *((unsigned int *)&v122 + v93);
            unsigned int v95 = v93 - 1;
            if (v94 != -252645136)
            {
              uint64_t v96 = *((unsigned int *)&v122 + v95);
              if (v96 == -252645136 || v14[2 * v94] <= (2 * v14[2 * v96])) {
                break;
              }
            }
            --v93;
            if ((v95 & 0xFFFFFFFE) == 0) {
              goto LABEL_78;
            }
          }
          if (v93 > 0xC) {
            goto LABEL_84;
          }
        }
        uint64_t v97 = 4 * v93;
        while (*(_DWORD *)((char *)&v122 + v97) == -252645136)
        {
          LODWORD(v93) = v93 + 1;
          v97 += 4;
          if (v97 == 52)
          {
            LODWORD(v93) = 13;
            break;
          }
        }
LABEL_84:
        unsigned int v98 = v93 - 1;
        uint64_t v99 = *((unsigned int *)&v122 + v93);
        int v100 = *((_DWORD *)&v122 + (v93 - 1));
        ++HIBYTE(v14[2 * v99 + 1]);
        if (v100 == -252645136) {
          int v101 = v99;
        }
        else {
          int v101 = v100;
        }
        *((_DWORD *)&v122 + v98) = v101;
        int v102 = -252645136;
        if (v99)
        {
          unsigned int v103 = v99 - 1;
          if (v40 - v93 == HIBYTE(v14[2 * v103 + 1])) {
            int v102 = v103;
          }
          else {
            int v102 = -252645136;
          }
        }
        v85 += -1 << v98;
        *((_DWORD *)&v122 + v93) = v102;
      }
      while (v85 > 0);
    }
    if (v85 < 0)
    {
      int v116 = DWORD1(v122);
      do
      {
        if (v85 < 0) {
          int v117 = -1;
        }
        else {
          int v117 = v85;
        }
        int v118 = v117 + 1;
        int v119 = v85;
        while (v116 != -252645136)
        {
          --HIBYTE(v14[2 * ++v116 + 1]);
          if (v118 == ++v119) {
            goto LABEL_93;
          }
        }
        int v116 = v82 + 2;
        int v120 = (unsigned __int8 *)&v8[2 * v82++ + 3] + 3;
        do
        {
          int v121 = *v120;
          v120 -= 8;
          --v82;
          --v116;
        }
        while (v40 == v121);
        --HIBYTE(v14[2 * v116 + 1]);
        signed int v85 = v119 + 1;
      }
      while (v119 <= -2);
    }
  }
LABEL_93:
  if (v71 > 0xC) {
    return -1;
  }
  long long v122 = 0uLL;
  WORD4(v123) = 0;
  *(void *)&long long v123 = 0;
  memset(v126, 0, sizeof(v126));
  __int16 v127 = 0;
  if ((v42 & 0x80000000) == 0)
  {
    uint64_t v104 = (unsigned __int8 *)v8 + 15;
    do
    {
      unsigned int v105 = *v104;
      v104 += 8;
      ++*((_WORD *)&v122 + v105);
      --v67;
    }
    while (v67);
  }
  uint64_t result = v71;
  if ((int)v71 >= 1)
  {
    __int16 v106 = 0;
    unint64_t v71 = v71;
    do
    {
      *((_WORD *)v126 + v71) = v106;
      __int16 v106 = (unsigned __int16)(*((_WORD *)&v122 + v71) + v106) >> 1;
    }
    while (v71-- > 1);
  }
  if ((a3 & 0x80000000) == 0)
  {
    v108 = a1 + 1;
    uint64_t v109 = (unsigned __int8 *)v8 + 15;
    uint64_t v110 = (a3 + 1);
    do
    {
      uint64_t v111 = *(v109 - 1);
      unsigned int v112 = *v109;
      v109 += 8;
      v108[v111] = v112;
      --v110;
    }
    while (v110);
    do
    {
      uint64_t v113 = *v108;
      uint64_t v114 = *v108;
      uint64_t v115 = *((unsigned __int16 *)v126 + v114);
      *((_WORD *)v126 + v114) = v115 + 1;
      if (v114) {
        uint64_t *v108 = (v115 << -(char)v114) | v113;
      }
      ++v108;
      --v16;
    }
    while (v16);
  }
  *a1 = result;
  return result;
}

unint64_t sub_1DD296948(uint64_t a1, unsigned int *a2, int a3)
{
  if (a3 < 0) {
    return 0;
  }
  unint64_t v3 = 0;
  unsigned int v4 = (unsigned __int8 *)(a1 + 8);
  uint64_t v5 = (a3 + 1);
  do
  {
    unsigned int v7 = *v4;
    v4 += 8;
    unsigned int v6 = v7;
    unsigned int v8 = *a2++;
    v3 += v6 * (unint64_t)v8;
    --v5;
  }
  while (v5);
  return v3 >> 3;
}

BOOL sub_1DD29697C(uint64_t a1, int *a2, int a3)
{
  if (a3 < 0) {
    return 1;
  }
  int v3 = 0;
  unsigned int v4 = (unsigned __int8 *)(a1 + 8);
  uint64_t v5 = (a3 + 1);
  do
  {
    int v6 = *a2++;
    BOOL v9 = v6 == 0;
    int v8 = *v4;
    v4 += 8;
    int v7 = v8;
    BOOL v9 = !v9 && v7 == 0;
    int v10 = v9;
    v3 |= v10;
    --v5;
  }
  while (v5);
  return v3 == 0;
}

uint64_t sub_1DD2969C4(unint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (a2 <= 8) {
    return 0;
  }
  uint64_t v9 = *a5;
  int v7 = a5 + 1;
  unsigned int v8 = v9;
  unint64_t v10 = (unint64_t)a1 + a2 - 8;
  if ((((unint64_t)v9 * a4) >> 3) + 8 > a2 || v8 >= 0xC)
  {
    if ((int)a4 <= 0) {
      int v12 = -(-(int)a4 & 3);
    }
    else {
      int v12 = a4 & 3;
    }
    int v13 = v12 - 1;
    if (v12 < 1)
    {
      unint64_t v15 = 0;
      uint64_t v20 = 0;
      uint64_t v22 = a1;
    }
    else
    {
      unsigned __int8 v14 = 0;
      unint64_t v15 = 0;
      uint64_t v16 = (unsigned __int8 *)(a3 + (int)a4 - 1);
      unsigned int v17 = v12 + 1;
      do
      {
        int v18 = *v16--;
        uint64_t v19 = v7[v18];
        unint64_t v15 = (v15 >> v19) | v19 & 0xFFFFFFFFFFFFFF00;
        v14 += v19;
        --v17;
      }
      while (v17 > 1);
      LODWORD(a4) = ~v13 + a4;
      uint64_t v20 = v14 & 7;
      *a1 = v15 >> -v14;
      unsigned int v21 = (unint64_t *)((char *)a1 + ((unint64_t)v14 >> 3));
      if ((unint64_t)v21 <= v10) {
        uint64_t v22 = v21;
      }
      else {
        uint64_t v22 = (unint64_t *)((char *)a1 + a2 - 8);
      }
    }
    if ((a4 & 7) != 0)
    {
      for (uint64_t i = 0; i != -3; --i)
      {
        uint64_t v31 = v7[*(unsigned __int8 *)(a3 + (int)a4 - 1 + i)];
        unint64_t v15 = (v15 >> v31) | v31;
        LOBYTE(v20) = v31 + v20;
      }
      a4 = (int)a4 - 4;
      uint64_t v32 = v7[*(unsigned __int8 *)(a3 + a4)];
      unint64_t v15 = (v15 >> v32) | v32 & 0xFFFFFFFFFFFFFF00;
      LOBYTE(v32) = v32 + v20;
      uint64_t v20 = v32 & 7;
      *uint64_t v22 = v15 >> -(char)v32;
      int v33 = (void *)((char *)v22 + ((unint64_t)v32 >> 3));
      if ((unint64_t)v33 <= v10) {
        uint64_t v22 = v33;
      }
      else {
        uint64_t v22 = (unint64_t *)((char *)a1 + a2 - 8);
      }
    }
    if ((int)a4 >= 1)
    {
      uint64_t v34 = a4;
      uint64_t v35 = a3 + a4;
      uint64_t v36 = v35 - 1;
      uint64_t v37 = v35 - 5;
      do
      {
        for (uint64_t j = 0; j != -3; --j)
        {
          uint64_t v39 = v7[*(unsigned __int8 *)(v36 + j)];
          unint64_t v15 = (v15 >> v39) | v39;
          LOBYTE(v20) = v39 + v20;
        }
        uint64_t v40 = 0;
        char v41 = 0;
        unint64_t v42 = 0;
        uint64_t v43 = v7[*(unsigned __int8 *)(v34 + a3 - 4)];
        unint64_t v44 = (v15 >> v43) | v43 & 0xFFFFFFFFFFFFFF00;
        unsigned __int8 v45 = v43 + v20;
        *uint64_t v22 = v44 >> -v45;
        uint64_t v46 = (void *)((char *)v22 + ((unint64_t)v45 >> 3));
        do
        {
          uint64_t v47 = v7[*(unsigned __int8 *)(v37 + v40)];
          unint64_t v42 = (v42 >> v47) | v47;
          v41 += v47;
          --v40;
        }
        while (v40 != -3);
        char v48 = v45 & 7;
        if ((unint64_t)v46 <= v10) {
          uint64_t v49 = v46;
        }
        else {
          uint64_t v49 = (void *)v10;
        }
        uint64_t v50 = v7[*(unsigned __int8 *)(a3 + v34 - 8)];
        char v51 = v50 + v41;
        unsigned __int8 v52 = v51 + v48;
        unsigned __int8 v53 = v52;
        uint64_t v22 = (void *)((char *)v49 + ((unint64_t)v52 >> 3));
        if ((unint64_t)v22 > v10) {
          uint64_t v22 = (void *)v10;
        }
        v36 -= 8;
        v37 -= 8;
        unint64_t v15 = (v42 >> v50) | v50 & 0xFFFFFFFFFFFFFF00 | (v44 >> v51);
        uint64_t v20 = v52 & 7;
        *uint64_t v49 = v15 >> -v53;
        BOOL v54 = v34 <= 8;
        v34 -= 8;
      }
      while (!v54);
    }
  }
  else
  {
    switch(v8)
    {
      case 7u:
        if ((int)a4 <= 0) {
          int v23 = -(-(int)a4 & 7);
        }
        else {
          int v23 = a4 & 7;
        }
        int v24 = v23 - 1;
        if (v23 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v25 = 0;
          unint64_t v15 = 0;
          unsigned int v26 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v27 = v23 + 1;
          do
          {
            int v28 = *v26--;
            uint64_t v29 = v7[v28];
            unint64_t v15 = (v15 >> v29) | v29 & 0xFFFFFFFFFFFFFF00;
            v25 += v29;
            --v27;
          }
          while (v27 > 1);
          LODWORD(a4) = ~v24 + a4;
          uint64_t v20 = v25 & 7;
          *a1 = v15 >> -v25;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v25 >> 3));
        }
        if ((a4 & 0xF) != 0)
        {
          for (uint64_t k = 0; k != -7; --k)
          {
            uint64_t v85 = v7[*(unsigned __int8 *)(a3 + (int)a4 - 1 + k)];
            unint64_t v15 = (v15 >> v85) | v85;
            LOBYTE(v20) = v85 + v20;
          }
          a4 = (int)a4 - 8;
          uint64_t v86 = v7[*(unsigned __int8 *)(a3 + a4)];
          unint64_t v15 = (v15 >> v86) | v86 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v86) = v86 + v20;
          uint64_t v20 = v86 & 7;
          *uint64_t v22 = v15 >> -(char)v86;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v86 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v87 = a4;
          uint64_t v88 = a3 + a4;
          uint64_t v89 = v88 - 1;
          uint64_t v90 = v88 - 9;
          do
          {
            for (uint64_t m = 0; m != -7; --m)
            {
              uint64_t v92 = v7[*(unsigned __int8 *)(v89 + m)];
              unint64_t v15 = (v15 >> v92) | v92;
              LOBYTE(v20) = v92 + v20;
            }
            uint64_t v93 = 0;
            char v94 = 0;
            unint64_t v95 = 0;
            uint64_t v96 = v7[*(unsigned __int8 *)(v87 + a3 - 8)];
            unint64_t v97 = (v15 >> v96) | v96 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v98 = v96 + v20;
            *uint64_t v22 = v97 >> -v98;
            do
            {
              uint64_t v99 = v7[*(unsigned __int8 *)(v90 + v93)];
              unint64_t v95 = (v95 >> v99) | v99;
              v94 += v99;
              --v93;
            }
            while (v93 != -7);
            int v100 = (void *)((char *)v22 + ((unint64_t)v98 >> 3));
            v89 -= 16;
            v90 -= 16;
            BOOL v54 = v87 <= 16;
            v87 -= 16;
            uint64_t v101 = v7[*(unsigned __int8 *)(a3 + v87)];
            char v102 = v101 + v94;
            unint64_t v15 = (v95 >> v101) | v101 & 0xFFFFFFFFFFFFFF00 | (v97 >> v102);
            unsigned __int8 v103 = v102 + (v98 & 7);
            unint64_t v104 = v103;
            unint64_t v105 = v15 >> -v103;
            uint64_t v20 = v103 & 7;
            *int v100 = v105;
            uint64_t v22 = (unint64_t *)((char *)v100 + (v104 >> 3));
          }
          while (!v54);
        }
        break;
      case 8u:
        if ((int)a4 % 7 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v64 = 0;
          unint64_t v15 = 0;
          int v65 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v66 = (int)a4 % 7 + 1;
          do
          {
            int v67 = *v65--;
            uint64_t v68 = v7[v67];
            unint64_t v15 = (v15 >> v68) | v68 & 0xFFFFFFFFFFFFFF00;
            v64 += v68;
            --v66;
          }
          while (v66 > 1);
          LODWORD(a4) = a4 - (int)a4 % 7;
          uint64_t v20 = v64 & 7;
          *a1 = v15 >> -v64;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v64 >> 3));
        }
        HIDWORD(v128) = -1227133513 * a4 + 306783378;
        LODWORD(v128) = HIDWORD(v128);
        if ((v128 >> 1) >= 0x12492493)
        {
          uint64_t v129 = (int)a4;
          for (uint64_t n = -1; n != -7; --n)
          {
            uint64_t v131 = v7[*(unsigned __int8 *)(a3 + (int)a4 + n)];
            unint64_t v15 = (v15 >> v131) | v131;
            LOBYTE(v20) = v131 + v20;
          }
          LODWORD(a4) = a4 - 7;
          uint64_t v132 = v7[*(unsigned __int8 *)(a3 + v129 - 7)];
          unint64_t v15 = (v15 >> v132) | v132 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v132) = v132 + v20;
          uint64_t v20 = v132 & 7;
          *uint64_t v22 = v15 >> -(char)v132;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v132 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v133 = a4;
          uint64_t v134 = a3 + a4;
          do
          {
            for (iuint64_t i = -1; ii != -7; --ii)
            {
              uint64_t v136 = v7[*(unsigned __int8 *)(v134 + ii)];
              unint64_t v15 = (v15 >> v136) | v136;
              LOBYTE(v20) = v136 + v20;
            }
            char v137 = 0;
            unint64_t v138 = 0;
            uint64_t v139 = v7[*(unsigned __int8 *)(v133 + a3 - 7)];
            unint64_t v140 = (v15 >> v139) | v139 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v141 = v139 + v20;
            *uint64_t v22 = v140 >> -v141;
            for (juint64_t j = -8; jj != -14; --jj)
            {
              uint64_t v143 = v7[*(unsigned __int8 *)(v134 + jj)];
              unint64_t v138 = (v138 >> v143) | v143;
              v137 += v143;
            }
            v144 = (void *)((char *)v22 + ((unint64_t)v141 >> 3));
            v134 -= 14;
            BOOL v54 = v133 <= 14;
            v133 -= 14;
            uint64_t v145 = v7[*(unsigned __int8 *)(a3 + v133)];
            char v146 = v145 + v137;
            unint64_t v15 = (v138 >> v145) | v145 & 0xFFFFFFFFFFFFFF00 | (v140 >> v146);
            unsigned __int8 v147 = v146 + (v141 & 7);
            unint64_t v148 = v147;
            unint64_t v149 = v15 >> -v147;
            uint64_t v20 = v147 & 7;
            unint64_t *v144 = v149;
            uint64_t v22 = (unint64_t *)((char *)v144 + (v148 >> 3));
          }
          while (!v54);
        }
        break;
      case 9u:
        if ((int)a4 % 6 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v69 = 0;
          unint64_t v15 = 0;
          unsigned int v70 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v71 = (int)a4 % 6 + 1;
          do
          {
            int v72 = *v70--;
            uint64_t v73 = v7[v72];
            unint64_t v15 = (v15 >> v73) | v73 & 0xFFFFFFFFFFFFFF00;
            v69 += v73;
            --v71;
          }
          while (v71 > 1);
          LODWORD(a4) = a4 - (int)a4 % 6;
          uint64_t v20 = v69 & 7;
          *a1 = v15 >> -v69;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v69 >> 3));
        }
        HIDWORD(v150) = -1431655765 * a4 + 715827880;
        LODWORD(v150) = HIDWORD(v150);
        if ((v150 >> 2) >= 0x15555555)
        {
          uint64_t v151 = (int)a4;
          for (kuint64_t k = -1; kk != -6; --kk)
          {
            uint64_t v153 = v7[*(unsigned __int8 *)(a3 + (int)a4 + kk)];
            unint64_t v15 = (v15 >> v153) | v153;
            LOBYTE(v20) = v153 + v20;
          }
          LODWORD(a4) = a4 - 6;
          uint64_t v154 = v7[*(unsigned __int8 *)(a3 + v151 - 6)];
          unint64_t v15 = (v15 >> v154) | v154 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v154) = v154 + v20;
          uint64_t v20 = v154 & 7;
          *uint64_t v22 = v15 >> -(char)v154;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v154 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v155 = a4;
          uint64_t v156 = a3 + a4;
          do
          {
            for (muint64_t m = -1; mm != -6; --mm)
            {
              uint64_t v158 = v7[*(unsigned __int8 *)(v156 + mm)];
              unint64_t v15 = (v15 >> v158) | v158;
              LOBYTE(v20) = v158 + v20;
            }
            char v159 = 0;
            unint64_t v160 = 0;
            uint64_t v161 = v7[*(unsigned __int8 *)(v155 + a3 - 6)];
            unint64_t v162 = (v15 >> v161) | v161 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v163 = v161 + v20;
            *uint64_t v22 = v162 >> -v163;
            for (nuint64_t n = -7; nn != -12; --nn)
            {
              uint64_t v165 = v7[*(unsigned __int8 *)(v156 + nn)];
              unint64_t v160 = (v160 >> v165) | v165;
              v159 += v165;
            }
            v166 = (void *)((char *)v22 + ((unint64_t)v163 >> 3));
            v156 -= 12;
            BOOL v54 = v155 <= 12;
            v155 -= 12;
            uint64_t v167 = v7[*(unsigned __int8 *)(a3 + v155)];
            char v168 = v167 + v159;
            unint64_t v15 = (v160 >> v167) | v167 & 0xFFFFFFFFFFFFFF00 | (v162 >> v168);
            unsigned __int8 v169 = v168 + (v163 & 7);
            unint64_t v170 = v169;
            unint64_t v171 = v15 >> -v169;
            uint64_t v20 = v169 & 7;
            unint64_t *v166 = v171;
            uint64_t v22 = (unint64_t *)((char *)v166 + (v170 >> 3));
          }
          while (!v54);
        }
        break;
      case 0xAu:
        if ((int)a4 % 5 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v74 = 0;
          unint64_t v15 = 0;
          int v75 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v76 = (int)a4 % 5 + 1;
          do
          {
            int v77 = *v75--;
            uint64_t v78 = v7[v77];
            unint64_t v15 = (v15 >> v78) | v78 & 0xFFFFFFFFFFFFFF00;
            v74 += v78;
            --v76;
          }
          while (v76 > 1);
          LODWORD(a4) = a4 - (int)a4 % 5;
          uint64_t v20 = v74 & 7;
          *a1 = v15 >> -v74;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v74 >> 3));
        }
        HIDWORD(v172) = -858993459 * a4 + 429496728;
        LODWORD(v172) = HIDWORD(v172);
        if ((v172 >> 1) >= 0x19999999)
        {
          uint64_t v173 = (int)a4;
          for (uint64_t i1 = -1; i1 != -5; --i1)
          {
            uint64_t v175 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i1)];
            unint64_t v15 = (v15 >> v175) | v175;
            LOBYTE(v20) = v175 + v20;
          }
          LODWORD(a4) = a4 - 5;
          uint64_t v176 = v7[*(unsigned __int8 *)(a3 + v173 - 5)];
          unint64_t v15 = (v15 >> v176) | v176;
          LOBYTE(v176) = v176 + v20;
          uint64_t v20 = v176 & 7;
          *uint64_t v22 = v15 >> -(char)v176;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v176 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v177 = a4;
          uint64_t v178 = a3 + a4;
          do
          {
            for (uint64_t i2 = -1; i2 != -5; --i2)
            {
              uint64_t v180 = v7[*(unsigned __int8 *)(v178 + i2)];
              unint64_t v15 = (v15 >> v180) | v180;
              LOBYTE(v20) = v180 + v20;
            }
            char v181 = 0;
            unint64_t v182 = 0;
            uint64_t v183 = v7[*(unsigned __int8 *)(v177 + a3 - 5)];
            unint64_t v184 = (v15 >> v183) | v183;
            unsigned __int8 v185 = v183 + v20;
            *uint64_t v22 = v184 >> -v185;
            for (uint64_t i3 = -6; i3 != -10; --i3)
            {
              uint64_t v187 = v7[*(unsigned __int8 *)(v178 + i3)];
              unint64_t v182 = (v182 >> v187) | v187;
              v181 += v187;
            }
            v188 = (void *)((char *)v22 + ((unint64_t)v185 >> 3));
            v178 -= 10;
            BOOL v54 = v177 <= 10;
            v177 -= 10;
            uint64_t v189 = v7[*(unsigned __int8 *)(a3 + v177)];
            char v190 = v189 + v181;
            unint64_t v15 = (v182 >> v189) | (v184 >> v190) | v189;
            unsigned __int8 v191 = v190 + (v185 & 7);
            unint64_t v192 = v191;
            unint64_t v193 = v15 >> -v191;
            uint64_t v20 = v191 & 7;
            unint64_t *v188 = v193;
            uint64_t v22 = (unint64_t *)((char *)v188 + (v192 >> 3));
          }
          while (!v54);
        }
        break;
      case 0xBu:
        if ((int)a4 % 5 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v79 = 0;
          unint64_t v15 = 0;
          uint64_t v80 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v81 = (int)a4 % 5 + 1;
          do
          {
            int v82 = *v80--;
            uint64_t v83 = v7[v82];
            unint64_t v15 = (v15 >> v83) | v83 & 0xFFFFFFFFFFFFFF00;
            v79 += v83;
            --v81;
          }
          while (v81 > 1);
          LODWORD(a4) = a4 - (int)a4 % 5;
          uint64_t v20 = v79 & 7;
          *a1 = v15 >> -v79;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v79 >> 3));
        }
        HIDWORD(v194) = -858993459 * a4 + 429496728;
        LODWORD(v194) = HIDWORD(v194);
        if ((v194 >> 1) >= 0x19999999)
        {
          uint64_t v195 = (int)a4;
          for (uint64_t i4 = -1; i4 != -5; --i4)
          {
            uint64_t v197 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i4)];
            unint64_t v15 = (v15 >> v197) | v197;
            LOBYTE(v20) = v197 + v20;
          }
          LODWORD(a4) = a4 - 5;
          uint64_t v198 = v7[*(unsigned __int8 *)(a3 + v195 - 5)];
          unint64_t v15 = (v15 >> v198) | v198 & 0xFFFFFFFFFFFFFF00;
          LOBYTE(v198) = v198 + v20;
          uint64_t v20 = v198 & 7;
          *uint64_t v22 = v15 >> -(char)v198;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v198 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v199 = a4;
          uint64_t v200 = a3 + a4;
          do
          {
            for (uint64_t i5 = -1; i5 != -5; --i5)
            {
              uint64_t v202 = v7[*(unsigned __int8 *)(v200 + i5)];
              unint64_t v15 = (v15 >> v202) | v202;
              LOBYTE(v20) = v202 + v20;
            }
            char v203 = 0;
            unint64_t v204 = 0;
            uint64_t v205 = v7[*(unsigned __int8 *)(v199 + a3 - 5)];
            unint64_t v206 = (v15 >> v205) | v205 & 0xFFFFFFFFFFFFFF00;
            unsigned __int8 v207 = v205 + v20;
            *uint64_t v22 = v206 >> -v207;
            for (uint64_t i6 = -6; i6 != -10; --i6)
            {
              uint64_t v209 = v7[*(unsigned __int8 *)(v200 + i6)];
              unint64_t v204 = (v204 >> v209) | v209;
              v203 += v209;
            }
            v210 = (void *)((char *)v22 + ((unint64_t)v207 >> 3));
            v200 -= 10;
            BOOL v54 = v199 <= 10;
            v199 -= 10;
            uint64_t v211 = v7[*(unsigned __int8 *)(a3 + v199)];
            char v212 = v211 + v203;
            unint64_t v15 = (v204 >> v211) | v211 & 0xFFFFFFFFFFFFFF00 | (v206 >> v212);
            unsigned __int8 v213 = v212 + (v207 & 7);
            unint64_t v214 = v213;
            unint64_t v215 = v15 >> -v213;
            uint64_t v20 = v213 & 7;
            unint64_t *v210 = v215;
            uint64_t v22 = (unint64_t *)((char *)v210 + (v214 >> 3));
          }
          while (!v54);
        }
        break;
      default:
        if ((int)a4 % 9 < 1)
        {
          unint64_t v15 = 0;
          uint64_t v20 = 0;
          uint64_t v22 = a1;
        }
        else
        {
          unsigned __int8 v59 = 0;
          unint64_t v15 = 0;
          unsigned int v60 = (unsigned __int8 *)(a3 + (int)a4 - 1);
          unsigned int v61 = (int)a4 % 9 + 1;
          do
          {
            int v62 = *v60--;
            uint64_t v63 = v7[v62];
            unint64_t v15 = (v15 >> v63) | v63 & 0xFFFFFFFFFFFFFF00;
            v59 += v63;
            --v61;
          }
          while (v61 > 1);
          LODWORD(a4) = a4 - (int)a4 % 9;
          uint64_t v20 = v59 & 7;
          *a1 = v15 >> -v59;
          uint64_t v22 = (unint64_t *)((char *)a1 + ((unint64_t)v59 >> 3));
        }
        HIDWORD(v106) = 954437177 * a4 + 238609294;
        LODWORD(v106) = HIDWORD(v106);
        if ((v106 >> 1) >= 0xE38E38F)
        {
          uint64_t v107 = (int)a4;
          for (uint64_t i7 = -1; i7 != -9; --i7)
          {
            uint64_t v109 = v7[*(unsigned __int8 *)(a3 + (int)a4 + i7)];
            unint64_t v15 = (v15 >> v109) | v109;
            LOBYTE(v20) = v109 + v20;
          }
          LODWORD(a4) = a4 - 9;
          uint64_t v110 = v7[*(unsigned __int8 *)(a3 + v107 - 9)];
          unint64_t v15 = (v15 >> v110) | v110;
          LOBYTE(v110) = v110 + v20;
          uint64_t v20 = v110 & 7;
          *uint64_t v22 = v15 >> -(char)v110;
          uint64_t v22 = (void *)((char *)v22 + ((unint64_t)v110 >> 3));
        }
        if ((int)a4 >= 1)
        {
          uint64_t v111 = a4;
          uint64_t v112 = a3 + a4;
          do
          {
            for (uint64_t i8 = -1; i8 != -9; --i8)
            {
              uint64_t v114 = v7[*(unsigned __int8 *)(v112 + i8)];
              unint64_t v15 = (v15 >> v114) | v114;
              LOBYTE(v20) = v114 + v20;
            }
            char v115 = 0;
            unint64_t v116 = 0;
            uint64_t v117 = v7[*(unsigned __int8 *)(v111 + a3 - 9)];
            unint64_t v118 = (v15 >> v117) | v117;
            unsigned __int8 v119 = v117 + v20;
            *uint64_t v22 = v118 >> -v119;
            for (uint64_t i9 = -10; i9 != -18; --i9)
            {
              uint64_t v121 = v7[*(unsigned __int8 *)(v112 + i9)];
              unint64_t v116 = (v116 >> v121) | v121;
              v115 += v121;
            }
            long long v122 = (void *)((char *)v22 + ((unint64_t)v119 >> 3));
            v112 -= 18;
            BOOL v54 = v111 <= 18;
            v111 -= 18;
            uint64_t v123 = v7[*(unsigned __int8 *)(a3 + v111)];
            char v124 = v123 + v115;
            unint64_t v15 = (v116 >> v123) | (v118 >> v124) | v123;
            unsigned __int8 v125 = v124 + (v119 & 7);
            unint64_t v126 = v125;
            unint64_t v127 = v15 >> -v125;
            uint64_t v20 = v125 & 7;
            *long long v122 = v127;
            uint64_t v22 = (unint64_t *)((char *)v122 + (v126 >> 3));
          }
          while (!v54);
        }
        break;
    }
  }
  uint64_t v5 = 0;
  unint64_t v55 = (v15 >> 1) | 0x8000000000000000;
  char v56 = v20 + 1;
  unint64_t v57 = (v20 - 0x7FFFFFFFFFFFFFFFLL) & 0xF;
  *uint64_t v22 = v55 >> -(char)v57;
  int v58 = (char *)v22 + (v57 >> 3);
  if (v10 > (unint64_t)v58)
  {
    uint64_t v5 = v58 - (char *)a1;
    if ((v56 & 7) != 0) {
      ++v5;
    }
  }
  return v5;
}

unint64_t sub_1DD29782C(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  unint64_t result = 0;
  if (a2 >= 0x11 && a4 >= 0xC)
  {
    unint64_t v11 = (a4 + 3) >> 2;
    uint64_t v12 = a1 + 6;
    unint64_t result = sub_1DD2969C4((unint64_t *)(a1 + 6), a2 - 6, a3, v11, a5);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
      {
        uint64_t v13 = a1 + a2;
        *(_WORD *)a1 = result;
        uint64_t v14 = v12 + result;
        unint64_t result = sub_1DD2969C4((unint64_t *)(v12 + result), v13 - (v12 + result), a3 + v11, (a4 + 3) >> 2, a5);
        if (result > 0xFFFFFFFFFFFFFF88) {
          return result;
        }
        if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
        {
          *(_WORD *)(a1 + 2) = result;
          unint64_t v15 = (unint64_t *)(v14 + result);
          unint64_t result = sub_1DD2969C4(v15, v13 - (void)v15, a3 + v11 + v11, (a4 + 3) >> 2, a5);
          if (result > 0xFFFFFFFFFFFFFF88) {
            return result;
          }
          if (result - 0x10000 >= 0xFFFFFFFFFFFF0001)
          {
            unint64_t v16 = a3 + a4;
            *(_WORD *)(a1 + 4) = result;
            unsigned int v17 = (char *)v15 + result;
            unint64_t result = sub_1DD2969C4((unint64_t *)((char *)v15 + result), v13 - ((void)v15 + result), a3 + v11 + v11 + v11, v16 - (a3 + v11 + v11 + v11), a5);
            if (result > 0xFFFFFFFFFFFFFF88) {
              return result;
            }
            if (result - 0x10000 >= 0xFFFFFFFFFFFF0001) {
              return (unint64_t)&v17[result - a1];
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

uint64_t sub_1DD297984(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t *a6, unsigned int *a7, char a8)
{
  unsigned int v9 = a1;
  if ((a8 & 2) != 0)
  {
    unsigned int v15 = 0;
    if (a3 != -1)
    {
      unint64_t v16 = a7;
      uint64_t v17 = (a3 + 1);
      do
      {
        if (*v16++) {
          ++v15;
        }
        --v17;
      }
      while (v17);
    }
    unsigned int v19 = 32 - __clz(v15);
    if (v19 <= a1)
    {
      uint64_t v35 = a4 + 748;
      uint64_t v32 = a6 + 1;
      uint64_t v33 = (a3 + 1);
      unint64_t v21 = -2;
      unsigned int v34 = v19;
      uint64_t v20 = a1;
      while (1)
      {
        unint64_t v22 = sub_1DD296268(a6, a7, a3, v19, a4, a5);
        if (v22 <= 0xFFFFFFFFFFFFFF88)
        {
          if (v22 < v19 && v19 > v34) {
            return v20;
          }
          unint64_t v23 = sub_1DD295DD0(v35, a5 - 748, (uint64_t)a6, a3, v22, a4, a5);
          if (v23 <= 0xFFFFFFFFFFFFFF88)
          {
            unint64_t v24 = 0;
            if ((a3 & 0x80000000) == 0)
            {
              unsigned __int8 v25 = v32;
              uint64_t v26 = v33;
              unsigned int v27 = a7;
              do
              {
                unsigned int v29 = *(unsigned __int8 *)v25++;
                unsigned int v28 = v29;
                unsigned int v30 = *v27++;
                v24 += v28 * (unint64_t)v30;
                --v26;
              }
              while (v26);
              v24 >>= 3;
            }
            unint64_t v31 = v24 + v23;
            if (v31 > v21 + 1) {
              return v20;
            }
            if (v31 >= v21)
            {
              uint64_t v20 = v20;
            }
            else
            {
              unint64_t v21 = v31;
              uint64_t v20 = v19;
            }
          }
        }
        if (++v19 > v9) {
          return v20;
        }
      }
    }
    return a1;
  }
  else
  {
    return sub_1DD2951FC(a1, a2, a3, 1);
  }
}

uint64_t sub_1DD297B38(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, char *a9, int *a10, char a11)
{
  return sub_1DD297B78(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9, a10, a11);
}

uint64_t sub_1DD297B78(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, unint64_t a9, char *a10, int *a11, char a12)
{
  unsigned int v64 = a5;
  unint64_t v12 = -(int)a8 & 7;
  unint64_t v13 = a9 - v12;
  if (a9 >= v12)
  {
    uint64_t v14 = a8 + v12;
  }
  else
  {
    unint64_t v13 = 0;
    uint64_t v14 = 0;
  }
  if (v13 >> 3 < 0x3E1) {
    return -66;
  }
  unint64_t v15 = 0;
  if (!a2 || !a4) {
    return v15;
  }
  if (a4 > 0x20000) {
    return -72;
  }
  if (a6 > 0xC) {
    return -44;
  }
  if (a5 > 0xFF) {
    return -46;
  }
  if (!a5)
  {
    a5 = 255;
    unsigned int v64 = 255;
  }
  if (a6) {
    int v21 = a6;
  }
  else {
    int v21 = 11;
  }
  BOOL v22 = (a12 & 4) == 0 || a11 == 0;
  char v23 = v22;
  if (v22 || *a11 != 2)
  {
    char v59 = v23;
    unsigned int v60 = v21;
    int v58 = (char *)a1 + a2;
    if (a4 >= 0xA000 && (a12 & 8) != 0)
    {
      unsigned int v63 = a5;
      unsigned int v25 = sub_1DD2959D8((void *)v14, &v63, a3, 4096);
      unsigned int v62 = v64;
      if (sub_1DD2959D8((void *)v14, &v62, &a3[a4 - 4096], 4096) + (unint64_t)v25 < 0x45) {
        return 0;
      }
    }
    uint64_t v57 = v14 + 3080;
    unint64_t v26 = sub_1DD295D84((void *)v14, &v64, (unsigned int *)a3, a4, (char *)(v14 + 3080), 0x1000uLL);
    unint64_t v15 = v26;
    if (v26 > 0xFFFFFFFFFFFFFF88) {
      return v15;
    }
    if (v26 == a4)
    {
      *(unsigned char *)a1 = *a3;
      return 1;
    }
    if (v26 <= (a4 >> 7) + 4) {
      return 0;
    }
    if (a11)
    {
      int v27 = *a11;
      if (*a11 == 1)
      {
        if ((v64 & 0x80000000) == 0)
        {
          int v28 = 0;
          unsigned int v29 = (unsigned __int8 *)(a10 + 8);
          uint64_t v30 = v64 + 1;
          unint64_t v31 = (int *)v14;
          do
          {
            int v32 = *v31++;
            BOOL v22 = v32 == 0;
            int v34 = *v29;
            v29 += 8;
            int v33 = v34;
            int v36 = !v22 && v33 == 0;
            v28 |= v36;
            --v30;
          }
          while (v30);
          if (v28)
          {
            *a11 = 0;
            goto LABEL_55;
          }
        }
        int v27 = 1;
      }
      BOOL v22 = v27 == 0;
      char v37 = v59;
      if (v22) {
        char v37 = 1;
      }
      if ((v37 & 1) == 0) {
        goto LABEL_66;
      }
    }
LABEL_55:
    unsigned int v38 = sub_1DD297984(v60, a4, v64, v57, 0x1300uLL, (uint64_t *)(v14 + 1024), (unsigned int *)v14, a12);
    uint64_t v39 = (char *)(v14 + 1024);
    unint64_t v15 = sub_1DD296268((uint64_t *)(v14 + 1024), (unsigned int *)v14, v64, v38, v57, 0x1300uLL);
    if (v15 > 0xFFFFFFFFFFFFFF88) {
      return v15;
    }
    unsigned int v61 = v64;
    bzero(&v39[8 * v64 + 16], 2056 - 8 * (v64 + 2));
    unint64_t v40 = sub_1DD295DD0((uint64_t)a1, a2, v14 + 1024, v61, v15, v57, 0x2ECuLL);
    unint64_t v15 = v40;
    if (v40 > 0xFFFFFFFFFFFFFF88) {
      return v15;
    }
    if (a11)
    {
      if (*a11)
      {
        if ((v64 & 0x80000000) != 0) {
          goto LABEL_66;
        }
        unint64_t v41 = 0;
        unint64_t v42 = (unsigned __int8 *)(a10 + 8);
        uint64_t v43 = (unsigned int *)v14;
        uint64_t v44 = v64 + 1;
        do
        {
          unsigned int v46 = *v42;
          v42 += 8;
          unsigned int v45 = v46;
          unsigned int v47 = *v43++;
          v41 += v45 * (unint64_t)v47;
          --v44;
        }
        while (v44);
        uint64_t v48 = 0;
        unint64_t v49 = 0;
        do
        {
          v49 += *(unsigned __int8 *)(v14 + 8 * v48 + 1032) * (unint64_t)*(unsigned int *)(v14 + 4 * v48);
          ++v48;
        }
        while (v64 + 1 != v48);
        if (v40 + 12 >= a4 || v41 >> 3 <= v40 + (v49 >> 3))
        {
LABEL_66:
          uint64_t v50 = (uint64_t)a1;
          char v51 = a1;
          uint64_t v52 = (uint64_t)v58;
          uint64_t v53 = (uint64_t)a3;
          unint64_t v54 = a4;
          int v55 = a7;
          char v56 = (uint64_t *)a10;
          return sub_1DD29811C(v50, v51, v52, v53, v54, v55, v56);
        }
        goto LABEL_70;
      }
      if (v40 + 12 < a4)
      {
LABEL_70:
        *a11 = 0;
        goto LABEL_71;
      }
    }
    else if (v40 + 12 < a4)
    {
LABEL_71:
      if (a10) {
        memcpy(a10, v39, 0x808uLL);
      }
      uint64_t v50 = (uint64_t)a1;
      char v51 = (unint64_t *)((char *)a1 + v15);
      uint64_t v52 = (uint64_t)v58;
      uint64_t v53 = (uint64_t)a3;
      unint64_t v54 = a4;
      int v55 = a7;
      char v56 = (uint64_t *)(v14 + 1024);
      return sub_1DD29811C(v50, v51, v52, v53, v54, v55, v56);
    }
    return 0;
  }
  return sub_1DD29811C((uint64_t)a1, a1, (uint64_t)a1 + a2, (uint64_t)a3, a4, a7, (uint64_t *)a10);
}

uint64_t sub_1DD297F94(unint64_t *a1, unint64_t a2, unsigned __int8 *a3, unint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unint64_t a8, char *a9, int *a10, char a11)
{
  return sub_1DD297B78(a1, a2, a3, a4, a5, a6, 1, a7, a8, a9, a10, a11);
}

uint64_t sub_1DD297FD4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  uint64_t v4 = result;
  int v5 = a3 - a2;
  if ((int)a3 - (int)a2 >= 8)
  {
    uint64_t v13 = a3;
    if ((int)a3 > (int)a2)
    {
      do
      {
        uint64_t v14 = (unsigned int *)(v4 + 8 * (int)v13);
        unsigned int v15 = *v14;
        uint64_t v16 = (v3 - 1);
        uint64_t v17 = (int)v13 - (uint64_t)(int)v3;
        uint64_t v18 = 8 * (int)v3;
        do
        {
          if (*(_DWORD *)(v4 + v18) > v15)
          {
            uint64_t v16 = (v16 + 1);
            uint64_t v19 = *(void *)(v4 + 8 * (int)v16);
            *(void *)(v4 + 8 * (int)v16) = *(void *)(v4 + v18);
            *(void *)(v4 + v18) = v19;
          }
          v18 += 8;
          --v17;
        }
        while (v17);
        uint64_t v20 = *(void *)(v4 + 8 * ((int)v16 + 1));
        *(void *)(v4 + 8 * ((int)v16 + 1)) = *(void *)v14;
        *(void *)uint64_t v14 = v20;
        if ((int)v16 + 1 - (int)v3 >= (int)v13 - ((int)v16 + 1))
        {
          unint64_t result = sub_1DD297FD4(v4, (v16 + 2), v13);
          uint64_t v13 = v16;
        }
        else
        {
          unint64_t result = sub_1DD297FD4(v4, v3, v16);
          uint64_t v3 = (v16 + 2);
        }
      }
      while ((int)v3 < (int)v13);
    }
  }
  else if (v5 >= 1)
  {
    uint64_t v6 = result + 8 * (int)a2;
    uint64_t v7 = (v5 + 1);
    uint64_t v8 = 1;
    do
    {
      uint64_t v9 = *(void *)(v6 + 8 * v8);
      uint64_t v10 = v8;
      while (1)
      {
        uint64_t v11 = v10 - 1;
        unint64_t v12 = (_DWORD *)(v6 + 8 * (v10 - 1));
        if (*v12 >= v9) {
          break;
        }
        *(void *)(v6 + 8 * v10--) = *(void *)v12;
        if (v11 + 1 <= 1)
        {
          LODWORD(v10) = 0;
          break;
        }
      }
      *(void *)(v6 + 8 * (int)v10) = v9;
      ++v8;
    }
    while (v8 != v7);
  }
  return result;
}

unint64_t sub_1DD29811C(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6, uint64_t *a7)
{
  unint64_t v10 = a3 - (void)a2;
  if (a6) {
    unint64_t result = sub_1DD29782C((uint64_t)a2, v10, a4, a5, a7);
  }
  else {
    unint64_t result = sub_1DD2969C4(a2, v10, a4, a5, a7);
  }
  unint64_t v12 = (unint64_t)a2 + result - a1;
  if (v12 >= a5 - 1) {
    unint64_t v12 = 0;
  }
  if (!result) {
    unint64_t v12 = 0;
  }
  if (result <= 0xFFFFFFFFFFFFFF88) {
    return v12;
  }
  return result;
}

uint64_t sub_1DD298194(unint64_t a1)
{
  if (a1 > 0xFF00FF00FF00FEFFLL) {
    return -72;
  }
  unint64_t v1 = a1 + (a1 >> 8);
  unint64_t v2 = (0x20000 - a1) >> 11;
  if (a1 >= 0x20000) {
    unint64_t v2 = 0;
  }
  uint64_t result = v1 + v2;
  if (!(v1 + v2)) {
    return -72;
  }
  return result;
}

uint64_t sub_1DD2981D0()
{
  return sub_1DD2981DC(&xmmword_1DD3211F0);
}

uint64_t sub_1DD2981DC(long long *a1)
{
  unint64_t v1 = *(uint64_t (**)(void, uint64_t))a1;
  if ((*(void *)a1 == 0) != (*((void *)a1 + 1) == 0)) {
    return 0;
  }
  if (v1) {
    uint64_t v4 = (void *)v1(*((void *)a1 + 2), 5240);
  }
  else {
    uint64_t v4 = malloc(0x1478uLL);
  }
  uint64_t v2 = (uint64_t)v4;
  if (v4)
  {
    long long v6 = *a1;
    uint64_t v7 = *((void *)a1 + 2);
    bzero(v4, 0x1478uLL);
    *(_OWORD *)(v2 + 848) = v6;
    *(void *)(v2 + 864) = v7;
    sub_1DD2984B0(v2);
    *(_OWORD *)(v2 + 5208) = 0u;
    *(_OWORD *)(v2 + 5224) = 0u;
    *(_OWORD *)(v2 + 16) = 0u;
    *(_OWORD *)(v2 + 32) = 0u;
    *(_OWORD *)(v2 + 48) = 0u;
    *(_OWORD *)(v2 + 64) = 0u;
    *(_OWORD *)(v2 + 80) = 0u;
    *(_OWORD *)(v2 + 96) = 0u;
    *(_OWORD *)(v2 + 112) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
    *(_OWORD *)(v2 + 176) = 0u;
    *(_OWORD *)(v2 + 192) = 0u;
    *(_OWORD *)(v2 + 208) = 0u;
    *(_DWORD *)(v2 + 60) = 3;
    *(_DWORD *)(v2 + 48) = 1;
  }
  return v2;
}

unint64_t sub_1DD2982C0(unint64_t result)
{
  if (result)
  {
    unint64_t v1 = (void *)result;
    if (*(void *)(result + 880)) {
      return -64;
    }
    if (*(void *)(result + 656) <= result)
    {
      unint64_t v2 = *(void *)(result + 664);
      sub_1DD298348(result);
      if (v2 > (unint64_t)v1) {
        return 0;
      }
    }
    else
    {
      sub_1DD298348(result);
    }
    uint64_t v3 = (void (*)(void, void *))v1[107];
    if (v3) {
      v3(v1[108], v1);
    }
    else {
      free(v1);
    }
    return 0;
  }
  return result;
}

void sub_1DD298348(uint64_t a1)
{
  sub_1DD2984B0(a1);
  sub_1DD2D7EAC(*(void *)(a1 + 3704));
  *(void *)(a1 + 3704) = 0;
  unint64_t v2 = *(void (**)(uint64_t))(a1 + 856);
  uint64_t v3 = *(void *)(a1 + 864);
  uint64_t v4 = *(void **)(a1 + 656);
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(void *)(a1 + 720) = 0;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  if (v4)
  {
    if (v2)
    {
      v2(v3);
    }
    else
    {
      free(v4);
    }
  }
}

uint64_t sub_1DD2983D8(uint64_t result, long long *a2, int a3)
{
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 16) = 0u;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)uint64_t result = 0u;
  long long v3 = *a2;
  *(_OWORD *)(result + 16) = *(long long *)((char *)a2 + 12);
  *(_OWORD *)(result + 4) = v3;
  int v4 = *((_DWORD *)a2 + 9);
  *(void *)(result + 32) = *(void *)((char *)a2 + 28);
  *(_DWORD *)(result + 40) = v4;
  *(_DWORD *)(result + 44) = a3;
  if ((*((_DWORD *)a2 + 6) - 6) >= 0xFFFFFFFD)
  {
    if (*(_DWORD *)a2 > 0xEu) {
      int v5 = 1;
    }
    else {
      int v5 = 2;
    }
  }
  else
  {
    int v5 = 2;
  }
  *(_DWORD *)(result + 144) = v5;
  if (*((_DWORD *)a2 + 6) < 7u)
  {
    int v6 = 2;
  }
  else if (*(_DWORD *)a2 > 0x10u)
  {
    int v6 = 1;
  }
  else
  {
    int v6 = 2;
  }
  *(_DWORD *)(result + 140) = v6;
  if (*((_DWORD *)a2 + 6) < 7u)
  {
    int v7 = 2;
  }
  else if (*(_DWORD *)a2 > 0x1Au)
  {
    int v7 = 1;
  }
  else
  {
    int v7 = 2;
  }
  *(_DWORD *)(result + 96) = v7;
  *(void *)(result + 192) = 0x20000;
  if (a3 >= 10) {
    int v8 = 1;
  }
  else {
    int v8 = 2;
  }
  *(_DWORD *)(result + 200) = v8;
  return result;
}

double sub_1DD2984B0(uint64_t a1)
{
  uint64_t v2 = a1 + 3632;
  if (*(void *)(a1 + 3632))
  {
    long long v3 = *(void (**)(void))(a1 + 856);
    if (v3) {
      v3(*(void *)(a1 + 864));
    }
    else {
      free(*(void **)(a1 + 3632));
    }
  }
  sub_1DD29A21C(*(void **)(a1 + 3664));
  double result = 0.0;
  *(_OWORD *)uint64_t v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(void *)(v2 + 64) = 0;
  return result;
}

__n128 sub_1DD298510@<Q0>(unsigned int *a1@<X0>, unint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, unsigned int a5@<W4>, uint64_t a6@<X8>)
{
  if (a3) {
    BOOL v6 = a2 == -1;
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v7 = 513;
  if (!v6) {
    uint64_t v7 = a2;
  }
  if (a4 != 2) {
    uint64_t v7 = a2;
  }
  if (a4 == 1) {
    unint64_t v8 = 0;
  }
  else {
    unint64_t v8 = a3;
  }
  if (a4 == 1) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = v7;
  }
  if (v8 >= 0x40000001 || v9 >= 0x40000001)
  {
    unsigned int v11 = *a1;
    if (v9 == -1) {
      goto LABEL_33;
    }
  }
  else
  {
    unsigned int v10 = 32 - __clz(v9 + v8 - 1);
    if ((v9 + v8) < 0x40) {
      unsigned int v10 = 6;
    }
    unsigned int v11 = *a1;
    if (*a1 > v10)
    {
      *a1 = v10;
      unsigned int v11 = v10;
    }
  }
  unint64_t v12 = (1 << v11) + v8;
  unint64_t v13 = v9 + v8;
  unint64_t v14 = v12 >> 31;
  unsigned int v15 = 32 - __clz(v12 - 1);
  if (v14) {
    unsigned int v15 = 31;
  }
  if (1 << v11 < v13) {
    unsigned int v16 = v15;
  }
  else {
    unsigned int v16 = v11;
  }
  if (v8) {
    unsigned int v17 = v16;
  }
  else {
    unsigned int v17 = v11;
  }
  unsigned int v18 = a1[1];
  unsigned int v19 = v18 - (a1[6] > 5);
  if (a1[2] > v17 + 1) {
    a1[2] = v17 + 1;
  }
  if (v19 > v17) {
    a1[1] = v18 + v17 - v19;
  }
LABEL_33:
  if (v11 <= 9) {
    *a1 = 10;
  }
  unsigned int v20 = a1[6];
  if (a4 == 2 && v20 - 3 >= 0xFFFFFFFE)
  {
    if (a1[2] >= 0x19) {
      a1[2] = 24;
    }
    if (a1[1] >= 0x19) {
      a1[1] = 24;
    }
  }
  if (a5 <= 1 && v20 - 6 >= 0xFFFFFFFD)
  {
    unsigned int v21 = a1[3];
    int v22 = v21 + 24;
    if (v21 >= 6) {
      int v22 = 30;
    }
    if (v21 >= 4) {
      unsigned int v23 = v22;
    }
    else {
      unsigned int v23 = 28;
    }
    if (a1[2] > v23) {
      a1[2] = v23;
    }
  }
  *(_OWORD *)a6 = *(_OWORD *)a1;
  __n128 result = *(__n128 *)(a1 + 3);
  *(__n128 *)(a6 + 12) = result;
  return result;
}

double sub_1DD2986B0@<D0>(int a1@<W0>, unint64_t a2@<X1>, unint64_t a3@<X2>, int a4@<W3>, uint64_t a5@<X8>)
{
  if (a4 == 1) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = a3;
  }
  unint64_t v8 = -1;
  if (a2 != -1 || v7)
  {
    if (v7) {
      BOOL v9 = a2 == -1;
    }
    else {
      BOOL v9 = 0;
    }
    uint64_t v10 = 500;
    if (!v9) {
      uint64_t v10 = 0;
    }
    unint64_t v8 = v7 + a2 + v10;
  }
  uint64_t v25 = v5;
  uint64_t v26 = v6;
  unsigned int v11 = 3;
  if (a1 >= 0x16) {
    int v12 = 22;
  }
  else {
    int v12 = a1;
  }
  if (a1 < 0) {
    int v12 = 0;
  }
  if (a1) {
    unsigned int v11 = v12;
  }
  int v13 = v8 < 0x40001;
  if (v8 <= 0x20000) {
    ++v13;
  }
  if (v8 > 0x4000) {
    int v14 = v13;
  }
  else {
    int v14 = v13 + 1;
  }
  unsigned int v15 = (char *)&unk_1DD321460 + 644 * v14 + 28 * v11;
  long long v21 = *(_OWORD *)v15;
  int v16 = *((_DWORD *)v15 + 4);
  int v17 = *((_DWORD *)v15 + 5);
  int v18 = *((_DWORD *)v15 + 6);
  if (a1 <= 0xFFFE0000) {
    int v19 = -131072;
  }
  else {
    int v19 = a1;
  }
  if (a1 < 0) {
    int v17 = -v19;
  }
  int v22 = v16;
  int v23 = v17;
  int v24 = v18;
  *(void *)&double result = sub_1DD298510((unsigned int *)&v21, a2, a3, a4, 0, a5).n128_u64[0];
  return result;
}

uint64_t sub_1DD298790(int *a1, long long *a2, int a3, int a4, uint64_t a5, uint64_t a6, unint64_t a7, int a8, unint64_t a9)
{
  unint64_t v14 = a9;
  unint64_t v15 = 1 << *a1;
  if (v15 >= a7) {
    unint64_t v15 = a7;
  }
  if (!a7) {
    unint64_t v15 = 1;
  }
  if (!a9) {
    unint64_t v14 = 0x20000;
  }
  if (v14 >= v15) {
    unint64_t v16 = v15;
  }
  else {
    unint64_t v16 = v14;
  }
  BOOL v17 = a1[4] != 3 && a8 == 0;
  unint64_t v18 = 3;
  if (v17) {
    unint64_t v18 = 4;
  }
  unint64_t v19 = v16 / v18;
  unint64_t v20 = (8 * (v16 / v18) + 63) & 0xFFFFFFFFFFFFFFC0;
  unint64_t v21 = sub_1DD29A158(a1, a4, 0, 1);
  long long v28 = *a2;
  uint64_t v29 = *((void *)a2 + 2);
  uint64_t v22 = sub_1DD2CEF04(&v28);
  long long v28 = *a2;
  uint64_t v29 = *((void *)a2 + 2);
  unint64_t v23 = sub_1DD2CEF38(&v28, v16);
  if (*(_DWORD *)a2 == 1) {
    unint64_t v24 = (12 * v23 + 63) & 0xFFFFFFFFFFFFFFC0;
  }
  else {
    unint64_t v24 = 0;
  }
  uint64_t v25 = (((8 * ((v16 * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFF0) + 79) & 0xFFFFFFFFFFFFFFC0;
  if (!a8) {
    uint64_t v25 = 0;
  }
  uint64_t v26 = 25424;
  if (!a3) {
    uint64_t v26 = 20184;
  }
  return a5 + a6 + v26 + v21 + v16 + 3 * v19 + v20 + v22 + v25 + v24 + 32;
}

uint64_t sub_1DD298908(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  unint64_t v3 = *(void *)(a1 + 8) - *(void *)a1;
  if ((v3 & 0x7FFFFFFF8) != 0)
  {
    uint64_t v4 = (v3 >> 3);
    uint64_t v5 = (unsigned __int16 *)(*(void *)a1 + 6);
    uint64_t v6 = *(unsigned char **)(a1 + 48);
    unint64_t v7 = *(unsigned char **)(a1 + 40);
    unint64_t v8 = *(unsigned char **)(a1 + 32);
    do
    {
      unsigned int v9 = *(v5 - 1);
      if (v9 < 0x40) {
        LOBYTE(v10) = byte_1DD321208[*(v5 - 1)];
      }
      else {
        unsigned int v10 = 50 - __clz(v9);
      }
      char v11 = __clz(*(_DWORD *)(v5 - 3));
      unsigned int v12 = *v5;
      *unint64_t v8 = v10;
      unsigned char *v6 = 31 - v11;
      if (v12 < 0x80) {
        LOBYTE(v13) = byte_1DD321248[v12];
      }
      else {
        unsigned int v13 = 67 - __clz(v12);
      }
      v5 += 4;
      *v7++ = v13;
      ++v8;
      ++v6;
      --v4;
    }
    while (v4);
  }
  int v14 = *(_DWORD *)(a1 + 72);
  if (v14 == 1)
  {
    *(unsigned char *)(v2 + *(unsigned int *)(a1 + 76)) = 35;
    int v14 = *(_DWORD *)(a1 + 72);
  }
  if (v14 == 2) {
    *(unsigned char *)(v1 + *(unsigned int *)(a1 + 76)) = 52;
  }
  return 0;
}

uint64_t (*sub_1DD2989E8(int a1, int a2, int a3))()
{
  unsigned int v3 = a1 - 3;
  BOOL v4 = a2 != 1 || v3 > 2;
  uint64_t v5 = &off_1F3877D08[3 * a3] + v3;
  if (v4) {
    uint64_t v5 = &off_1F3877BC8[10 * a3] + a1;
  }
  return *v5;
}

uint64_t sub_1DD298A28(uint64_t result)
{
  *(void *)(result + 24) = *(void *)(result + 16);
  *(void *)(result + 8) = *(void *)result;
  *(_DWORD *)(result + 72) = 0;
  return result;
}

uint64_t sub_1DD298A40(void *a1, char *__src, void *__dst, _DWORD *a4, uint64_t a5, void *a6, unint64_t a7)
{
  unint64_t v7 = a7;
  unint64_t v8 = a6;
  unint64_t v15 = (unsigned int *)a1[2];
  uint64_t v14 = a1[3];
  unsigned int v16 = a4[7];
  int v17 = a4[18];
  if (v17 == 1) {
    goto LABEL_8;
  }
  if (v17 == 2)
  {
    LODWORD(v43) = 255;
LABEL_4:
    memcpy(__dst, __src, 0x810uLL);
    int v18 = 0;
LABEL_17:
    *(_DWORD *)a5 = v18;
    *(void *)(a5 + 136) = 0;
    goto LABEL_18;
  }
  if (v16 != 1)
  {
LABEL_8:
    BOOL v39 = v16 > 7;
    unint64_t v19 = a6;
    unint64_t v20 = a7;
    uint64_t v22 = __src + 2056;
    int v41 = *((_DWORD *)__src + 514);
    LODWORD(v43) = 255;
    memcpy(__dst, __src, 0x810uLL);
  }
  else
  {
    BOOL v39 = 0;
    unint64_t v19 = a6;
    unint64_t v20 = a7;
    int v21 = a4[6];
    int v41 = *((_DWORD *)__src + 514);
    LODWORD(v43) = 255;
    memcpy(__dst, __src, 0x810uLL);
    if (v21)
    {
LABEL_15:
      int v18 = 0;
      unint64_t v7 = v20;
      goto LABEL_16;
    }
    uint64_t v22 = __src + 2056;
  }
  unint64_t v23 = v14 - (void)v15;
  unint64_t v24 = 63;
  if (*v22 == 2) {
    unint64_t v24 = 6;
  }
  if (v24 >= v23) {
    goto LABEL_15;
  }
  unint64_t v7 = v20;
  unint64_t v25 = sub_1DD295D84(v19, (unsigned int *)&v43, v15, v23, (char *)v19, v20);
  unint64_t v26 = v25;
  if (v25 > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_38;
  }
  if (v25 == v23)
  {
    int v18 = 1;
LABEL_16:
    unint64_t v8 = v19;
    goto LABEL_17;
  }
  if (v25 <= (v23 >> 7) + 4)
  {
    int v18 = 0;
    goto LABEL_16;
  }
  char v40 = 2 * v39;
  unint64_t v8 = v19;
  uint64_t v32 = (uint64_t)v19 + 1024;
  BOOL v33 = v41;
  if (v41 == 1) {
    BOOL v33 = sub_1DD29697C((uint64_t)__src, (int *)v8, v43);
  }
  BOOL v42 = v33;
  bzero(__dst, 0x808uLL);
  unsigned int v34 = sub_1DD297984(11, v23, v43, v32, v7 - 1024, (uint64_t *)__dst, (unsigned int *)v8, v40);
  unint64_t v26 = sub_1DD296268((uint64_t *)__dst, (unsigned int *)v8, v43, v34, v32, v7 - 1024);
  if (v26 > 0xFFFFFFFFFFFFFF88)
  {
LABEL_38:
    *(void *)(a5 + 136) = v26;
    return v26;
  }
  unint64_t v35 = sub_1DD296948((uint64_t)__dst, (unsigned int *)v8, v43);
  uint64_t v36 = v32;
  unint64_t v37 = v35;
  unint64_t v26 = sub_1DD295DD0(a5 + 4, 0x80uLL, (uint64_t)__dst, v43, v26, v36, v7 - 1024);
  if (v42)
  {
    unint64_t v38 = sub_1DD296948((uint64_t)__src, (unsigned int *)v8, v43);
    if (v38 < v23 && (v26 + 12 >= v23 || v38 <= v26 + v37))
    {
      memcpy(__dst, __src, 0x810uLL);
      int v18 = 3;
      goto LABEL_17;
    }
  }
  if (v26 + v37 >= v23) {
    goto LABEL_4;
  }
  *(_DWORD *)a5 = 2;
  *((_DWORD *)__dst + 514) = 1;
  *(void *)(a5 + 136) = v26;
  if (v26 > 0xFFFFFFFFFFFFFF88) {
    return v26;
  }
LABEL_18:
  uint64_t v27 = a1[1] - *a1;
  if (v27)
  {
    sub_1DD29BCC4(a1, v27 >> 3, (uint64_t)(__src + 2064), (uint64_t)__dst + 2064, (char *)(a5 + 156), a5 + 289, a4[7], v8, (uint64_t)&v43, (char *)v8 + 212, v7 - 212);
    uint64_t v27 = v45;
    if (v45 > 0xFFFFFFFFFFFFFF88) {
      goto LABEL_23;
    }
    uint64_t v28 = v43;
    int v29 = v44;
    uint64_t v30 = v46;
  }
  else
  {
    uint64_t v30 = 0;
    int v29 = 0;
    *((_DWORD *)__dst + 1401) = 0;
    uint64_t v28 = 0;
    *((void *)__dst + 701) = 0;
  }
  *(void *)(a5 + 144) = v28;
  *(_DWORD *)(a5 + 152) = v29;
  *(void *)(a5 + 304) = v30;
LABEL_23:
  *(void *)(a5 + 296) = v27;
  if ((unint64_t)v27 >= 0xFFFFFFFFFFFFFF89) {
    return v27;
  }
  else {
    return 0;
  }
}

uint64_t sub_1DD298DC0(uint64_t a1, char *a2, unint64_t a3, char *__src, size_t __n, int a6, int a7)
{
  if (!*(_DWORD *)a1) {
    return -60;
  }
  unint64_t v11 = a3;
  unsigned int v12 = a2;
  unint64_t v14 = 0;
  if (a6 && *(_DWORD *)a1 == 1)
  {
    unint64_t v15 = sub_1DD29A6FC(a2, a3, (_DWORD *)(a1 + 224), *(void *)(a1 + 736) - 1, *(_DWORD *)(a1 + 640));
    unint64_t v14 = v15;
    if (v15 > 0xFFFFFFFFFFFFFF88) {
      return v14;
    }
    v11 -= v15;
    v12 += v15;
    *(_DWORD *)a1 = 2;
  }
  if (!__n) {
    return v14;
  }
  unint64_t v95 = (uint32x2_t *)(a1 + 3192);
  unsigned int v16 = *(char **)(a1 + 3192);
  if (*(_DWORD *)(a1 + 3328)) {
    BOOL v17 = 0;
  }
  else {
    BOOL v17 = v16 == __src;
  }
  int v18 = !v17;
  if (v17)
  {
    uint64_t v19 = *(void *)(a1 + 3208);
    unsigned int v21 = *(_DWORD *)(a1 + 3220);
    LODWORD(v20) = *(_DWORD *)(a1 + 3216);
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 3200);
    unint64_t v20 = &v16[-v19];
    unsigned int v21 = *(_DWORD *)(a1 + 3216);
    *(_DWORD *)(a1 + 3220) = v21;
    *(_DWORD *)(a1 + 3216) = v20;
    *(void *)(a1 + 3208) = v19;
    *(void *)(a1 + 3200) = __src - v20;
    if (v20 - v21 <= 7)
    {
      *(_DWORD *)(a1 + 3220) = v20;
      unsigned int v21 = v20;
    }
  }
  unint64_t v24 = &__src[__n];
  uint32x2_t *v95 = (uint32x2_t)&__src[__n];
  if ((unint64_t)&__src[__n] > v19 + (unint64_t)v21
    && v19 + (unint64_t)v20 > (unint64_t)__src)
  {
    uint64_t v26 = (uint64_t)&v24[-v19];
    if (v26 > v20) {
      LODWORD(v26) = v20;
    }
    *(_DWORD *)(a1 + 3220) = v26;
  }
  if (v18)
  {
    *(_DWORD *)(a1 + 3328) = 0;
    *(_DWORD *)(a1 + 3236) = v20;
  }
  if (*(_DWORD *)(a1 + 320) == 1)
  {
    uint64_t v27 = *(char **)(a1 + 1008);
    if (v27 == __src)
    {
      uint64_t v28 = *(void *)(a1 + 1024);
      unsigned int v30 = *(_DWORD *)(a1 + 1036);
      LODWORD(v29) = *(_DWORD *)(a1 + 1032);
    }
    else
    {
      uint64_t v28 = *(void *)(a1 + 1016);
      int v29 = &v27[-v28];
      unsigned int v30 = *(_DWORD *)(a1 + 1032);
      *(_DWORD *)(a1 + 1036) = v30;
      *(_DWORD *)(a1 + 1032) = v29;
      *(void *)(a1 + 1024) = v28;
      *(void *)(a1 + 1016) = __src - v29;
      if (v29 - v30 <= 7)
      {
        *(_DWORD *)(a1 + 1036) = v29;
        unsigned int v30 = v29;
      }
    }
    *(void *)(a1 + 1008) = v24;
    if ((unint64_t)v24 > v28 + (unint64_t)v30
      && v28 + (unint64_t)v29 > (unint64_t)__src)
    {
      uint64_t v31 = (uint64_t)&v24[-v28];
      if (v31 > v29) {
        LODWORD(v31) = v29;
      }
      *(_DWORD *)(a1 + 1036) = v31;
    }
  }
  if (!a6)
  {
    sub_1DD29C034(v95, (void *)(a1 + 656), (_DWORD *)(a1 + 224), (int)__src, (int)v24);
    unint64_t v22 = sub_1DD29C2F4(a1, v12, v11, __src, __n, 0);
    goto LABEL_126;
  }
  unint64_t v85 = v14;
  unint64_t v32 = *(void *)(a1 + 728);
  int v33 = *(_DWORD *)(a1 + 228);
  if (*(_DWORD *)(a1 + 260)) {
    sub_1DD29499C(a1 + 760, __src, __n);
  }
  uint64_t v90 = (int8x16_t *)(a1 + 3176);
  uint64_t v88 = (uint64_t *)(a1 + 928);
  uint64_t v89 = (unsigned int *)(a1 + 4112);
  uint64_t v96 = (_OWORD *)(a1 + 4032);
  uint64_t v92 = (_OWORD *)(a1 + 3952);
  int v84 = v12;
  size_t v86 = __n;
  size_t v34 = __n;
  unint64_t v35 = v12;
  uint64_t v36 = (_DWORD *)(a1 + 224);
  int v93 = 1 << v33;
  do
  {
    BOOL v37 = v32 >= v34;
    if (v11 < 6) {
      return -70;
    }
    if (v34 < v32) {
      unint64_t v32 = v34;
    }
    sub_1DD29C034(v95, (void *)(a1 + 656), v36, (int)__src, __src + v32);
    uint64_t v38 = *(void *)(a1 + 3200);
    unsigned __int8 v98 = &__src[v32];
    int v39 = *(_DWORD *)(a1 + 3232);
    if (v39 + v93 < (__src + v32 - v38) || v39 != *(_DWORD *)(a1 + 3216))
    {
      int v39 = 0;
      *(_DWORD *)(a1 + 3232) = 0;
      *(void *)(a1 + 3440) = 0;
    }
    unsigned int v40 = __src - v38;
    unsigned int v41 = *(_DWORD *)(a1 + 3220);
    if (v39 + v93 < v40)
    {
      if (v41 < v40 - v93)
      {
        *(_DWORD *)(a1 + 3220) = v40 - v93;
        unsigned int v41 = v40 - v93;
      }
      if (*(_DWORD *)(a1 + 3216) < v41) {
        *(_DWORD *)(a1 + 3216) = v41;
      }
      *(_DWORD *)(a1 + 3232) = 0;
      *(void *)(a1 + 3440) = 0;
    }
    if (*(_DWORD *)(a1 + 3236) < v41) {
      *(_DWORD *)(a1 + 3236) = v41;
    }
    int v42 = v37 & a7;
    if (*(void *)(a1 + 280))
    {
      unint64_t v43 = sub_1DD29C440(a1, __src, v32);
      unint64_t v22 = v43;
      if (v43 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      if (!v43)
      {
        if (!*(_DWORD *)(a1 + 920)
          && *(void *)(a1 + 936) - *(void *)(a1 + 928) <= 0x1FuLL
          && *(void *)(a1 + 952) - *(void *)(a1 + 944) <= 9uLL
          && sub_1DD29C834(__src, v32))
        {
          char v75 = *__src;
          *(_WORD *)unint64_t v35 = v42 | (8 * v32) | 2;
          void v35[2] = v32 >> 13;
          v35[3] = v75;
          unint64_t v22 = 4;
LABEL_65:
          if (*(_DWORD *)(v90->i64[0] + 5604) == 2) {
            *(_DWORD *)(v90->i64[0] + 5604) = 1;
          }
          goto LABEL_116;
        }
        unint64_t v44 = sub_1DD29EAE0(a1, v35, v11, __src, v32, v42);
        if (v44 != -70)
        {
          unint64_t v22 = v44;
          if (v44 > 0xFFFFFFFFFFFFFF88) {
            return v22;
          }
          unsigned int v49 = *(_DWORD *)(a1 + 252);
          char v50 = v49 <= 7 ? 6 : v49 - 1;
          if (v44 && v44 < v32 - (v32 >> v50) + 1)
          {
            *uint64_t v90 = vextq_s8(*v90, *v90, 8uLL);
            goto LABEL_65;
          }
        }
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)unint64_t v35 = v42 | (8 * v32);
      void v35[2] = v32 >> 13;
      memcpy(v35 + 3, __src, v32);
      if (v22 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      goto LABEL_65;
    }
    char v94 = v35;
    if (*(_DWORD *)(a1 + 364) != 1)
    {
      unsigned int v47 = v35 + 3;
      unint64_t v48 = sub_1DD29C2F4(a1, v47, v11 - 3, __src, v32, 1);
      unint64_t v22 = v48;
      if (v48 > 0xFFFFFFFFFFFFFF88) {
        return v22;
      }
      if (v48 == 1)
      {
        int v76 = 8 * v32;
        __int16 v77 = 2;
LABEL_115:
        unint64_t v35 = v94;
        int v78 = v42 | v76;
        *(_WORD *)char v94 = v78 | v77;
        v94[2] = BYTE2(v78);
        unint64_t v22 = v48 + 3;
        goto LABEL_116;
      }
      if (v48)
      {
        int v76 = v42;
        int v42 = 8 * v48;
        __int16 v77 = 4;
        goto LABEL_115;
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)char v94 = v42 | (8 * v32);
      v94[2] = v32 >> 13;
      uint64_t v46 = v47;
      unint64_t v35 = v94;
      goto LABEL_79;
    }
    unint64_t v45 = sub_1DD29C440(a1, __src, v32);
    unint64_t v22 = v45;
    if (v45 > 0xFFFFFFFFFFFFFF88) {
      return v22;
    }
    if (v45 == 1)
    {
      if (*(_DWORD *)(v90->i64[0] + 5604) == 2) {
        *(_DWORD *)(v90->i64[0] + 5604) = 1;
      }
      unint64_t v22 = v32 + 3;
      if (v32 + 3 > v11) {
        return -70;
      }
      *(_WORD *)unint64_t v35 = v42 | (8 * v32);
      void v35[2] = v32 >> 13;
      uint64_t v46 = v35 + 3;
LABEL_79:
      memcpy(v46, __src, v32);
      goto LABEL_80;
    }
    unint64_t v51 = 0;
    unint64_t v52 = *(void *)(a1 + 936) - *(void *)(a1 + 928);
    unint64_t v53 = v52 >> 3;
    uint64_t v101 = a1 + 4112;
    unint64_t v102 = 0;
    if ((v52 >> 3) >= 5)
    {
      sub_1DD29CE54((unint64_t)&v101, 0, (v52 >> 3), a1, v88);
      unint64_t v51 = v102;
      *(_DWORD *)(v101 + 4 * v102) = v53;
    }
    uint64_t v54 = v90->i64[0];
    uint64_t v101 = *(void *)(v90->i64[0] + 5616);
    LODWORD(v102) = *(_DWORD *)(v54 + 5624);
    uint64_t v99 = v101;
    int v100 = v102;
    *uint64_t v96 = 0u;
    *(_OWORD *)(a1 + 4048) = 0u;
    *(_OWORD *)(a1 + 4064) = 0u;
    *(_OWORD *)(a1 + 4080) = 0u;
    *(_OWORD *)(a1 + 4096) = 0u;
    if (v51)
    {
      unint64_t v97 = v51;
      int v87 = v42;
      int v82 = a7;
      sub_1DD29CD00((uint64_t)v92, v88, 0, *v89);
      uint64_t v55 = a1 + 3952;
      unint64_t v56 = v11;
      uint64_t v57 = 0;
      unint64_t v58 = 0;
      unint64_t v22 = 0;
      uint64_t v59 = (uint64_t)v35;
      unint64_t v83 = v56;
      size_t v91 = v34;
      while (1)
      {
        uint64_t v60 = sub_1DD29CDF8(v55);
        uint64_t v61 = *(void *)(a1 + 3960);
        uint64_t v62 = *(void *)(a1 + 3952);
        uint64_t v63 = v61 - v62;
        if (v61 == v62)
        {
          uint64_t v64 = 0;
        }
        else
        {
          uint64_t v64 = 0;
          unint64_t v65 = v63 >> 3;
          uint64_t v66 = *(unsigned int *)(a1 + 4028);
          if (v65 <= 1) {
            unint64_t v65 = 1;
          }
          int v67 = (unsigned __int16 *)(v62 + 6);
          do
          {
            unsigned int v68 = *v67;
            v67 += 4;
            v64 += v68 + 3;
            if (!v66 && *(_DWORD *)(a1 + 4024) == 2) {
              v64 += 0x10000;
            }
            --v66;
            --v65;
          }
          while (v65);
        }
        size_t v69 = v64 + v60;
        v57 += v64 + v60;
        if (v58 == v97)
        {
          size_t v69 = v69 + v32 - v57;
          int v70 = v87;
        }
        else
        {
          sub_1DD29CD00((uint64_t)v96, v88, v89[v58], v89[v58 + 1]);
          int v70 = 0;
        }
        unint64_t v71 = sub_1DD29C998(a1, (uint64_t)v92, &v101, (int *)&v99, v59, v56, __src, v69, v70, 1);
        if (v71 > 0xFFFFFFFFFFFFFF88) {
          break;
        }
        __src += v69;
        v59 += v71;
        v56 -= v71;
        v22 += v71;
        long long v72 = *(_OWORD *)(a1 + 4080);
        *(_OWORD *)(a1 + 3984) = *(_OWORD *)(a1 + 4064);
        *(_OWORD *)(a1 + 4000) = v72;
        *(_OWORD *)(a1 + 4016) = *(_OWORD *)(a1 + 4096);
        long long v73 = *(_OWORD *)(a1 + 4048);
        *uint64_t v92 = *v96;
        *(_OWORD *)(a1 + 3968) = v73;
        ++v58;
        unint64_t v35 = v94;
        uint64_t v55 = a1 + 3952;
        size_t v34 = v91;
        if (v58 > v97)
        {
          uint64_t v74 = v90->i64[0];
          *(void *)(v74 + 5616) = v101;
          *(_DWORD *)(v74 + 5624) = v102;
          unint64_t v11 = v83;
          a7 = v82;
          uint64_t v36 = (_DWORD *)(a1 + 224);
          goto LABEL_80;
        }
      }
      unint64_t v22 = v71;
      unint64_t v11 = v83;
      a7 = v82;
      uint64_t v36 = (_DWORD *)(a1 + 224);
      unint64_t v35 = v94;
      size_t v34 = v91;
    }
    else
    {
      unint64_t v22 = sub_1DD29C998(a1, (uint64_t)v88, &v101, (int *)&v99, (uint64_t)v35, v11, __src, v32, v42, 0);
    }
LABEL_80:
    if (v22 >= 0xFFFFFFFFFFFFFF89) {
      return v22;
    }
LABEL_116:
    v35 += v22;
    v11 -= v22;
    *(_DWORD *)(a1 + 920) = 0;
    __src = v98;
    v34 -= v32;
  }
  while (v34);
  if (a7 && v35 > v84) {
    *(_DWORD *)a1 = 3;
  }
  unint64_t v22 = v35 - v84;
  unint64_t v14 = v85;
  __uint64_t n = v86;
LABEL_126:
  if (v22 <= 0xFFFFFFFFFFFFFF88)
  {
    size_t v79 = *(void *)(a1 + 744) + __n;
    *(void *)(a1 + 744) = v79;
    *(void *)(a1 + 752) += v22 + v14;
    unint64_t v80 = *(void *)(a1 + 736);
    if (v79 + 1 <= v80 || v80 == 0) {
      v22 += v14;
    }
    else {
      return -72;
    }
  }
  return v22;
}

uint64_t sub_1DD299678(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a3 + 8;
  *(_DWORD *)(a1 + 2056) = 1;
  unsigned int v40 = 31;
  v41[0] = 255;
  *(_DWORD *)int v42 = 1;
  unint64_t v9 = sub_1DD296048((void *)a1, v41, (char *)(a3 + 8), a4 - 8, v42);
  if (!*(_DWORD *)v42) {
    *(_DWORD *)(a1 + 2056) = 2;
  }
  if (v9 < 0xFFFFFFFFFFFFFF89 && v41[0] > 0xFEu) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = 0;
  }
  if (v9 < 0xFFFFFFFFFFFFFF89 && v41[0] > 0xFEu)
  {
    unint64_t v11 = a3 + a4;
    uint64_t v12 = v8 + v10;
    v41[0] = 0;
    unint64_t v13 = sub_1DD293948(v42, &v40, v41, (_DWORD *)(v8 + v10), v11 - (v8 + v10));
    if (v13 <= 0xFFFFFFFFFFFFFF88 && v41[0] < 9u)
    {
      unint64_t v14 = v13;
      unint64_t v15 = sub_1DD294D0C((_WORD *)(a1 + 2064), v42, 31, v41[0], a2, 0x2200uLL);
      unsigned int v16 = (_DWORD *)(v12 + v14);
      unint64_t v17 = v15 >= 0xFFFFFFFFFFFFFF89 ? v12 : v12 + v14;
      if (v15 <= 0xFFFFFFFFFFFFFF88)
      {
        unsigned int v38 = 0;
        unsigned int v39 = 52;
        unint64_t v18 = sub_1DD293948(v41, &v39, &v38, v16, v11 - (void)v16);
        if (v18 <= 0xFFFFFFFFFFFFFF88 && v38 <= 9)
        {
          unint64_t v19 = v18;
          if ((unint64_t)sub_1DD294D0C((_WORD *)(a1 + 2836), (__int16 *)v41, v39, v38, a2, 0x2200uLL) <= 0xFFFFFFFFFFFFFF88)
          {
            if (v39 >= 0x34)
            {
              uint64_t v21 = 0;
              while (*(_WORD *)((char *)v41 + v21))
              {
                v21 += 2;
                if (v21 == 106)
                {
                  int v20 = 2;
                  goto LABEL_22;
                }
              }
            }
            int v20 = 1;
LABEL_22:
            *(_DWORD *)(a1 + 5608) = v20;
            unint64_t v22 = (_DWORD *)(v17 + v19);
            unsigned int v38 = 0;
            unsigned int v39 = 35;
            unint64_t v23 = sub_1DD293948(v41, &v39, &v38, v22, v11 - (void)v22);
            if (v23 <= 0xFFFFFFFFFFFFFF88 && v38 <= 9)
            {
              unint64_t v24 = v23;
              if ((unint64_t)sub_1DD294D0C((_WORD *)(a1 + 4288), (__int16 *)v41, v39, v38, a2, 0x2200uLL) <= 0xFFFFFFFFFFFFFF88)
              {
                if (v39 >= 0x23)
                {
                  uint64_t v26 = 0;
                  while (*(_WORD *)((char *)v41 + v26))
                  {
                    v26 += 2;
                    if (v26 == 72)
                    {
                      int v25 = 2;
                      goto LABEL_31;
                    }
                  }
                }
                int v25 = 1;
LABEL_31:
                *(_DWORD *)(a1 + 5612) = v25;
                uint64_t v27 = (_DWORD *)((char *)v22 + v24);
                unint64_t v28 = (unint64_t)v22 + v24 + 12;
                if (v28 <= v11)
                {
                  *(_DWORD *)(a1 + 5616) = *v27;
                  *(_DWORD *)(a1 + 5620) = v27[1];
                  *(_DWORD *)(a1 + 5624) = v27[2];
                  unsigned int v30 = __clz(v11 - v28 + 0x20000) ^ 0x1F;
                  if (v11 - v28 >= 0xFFFE0000) {
                    unsigned int v30 = 31;
                  }
                  if (v40 >= v30)
                  {
                    unsigned int v32 = v30 + 1;
                    int v33 = (unsigned __int16 *)v42;
                    while (*v33++)
                    {
                      if (!--v32)
                      {
                        int v31 = 2;
                        goto LABEL_41;
                      }
                    }
                  }
                  int v31 = 1;
LABEL_41:
                  uint64_t v35 = 0;
                  *(_DWORD *)(a1 + 5604) = v31;
                  while (1)
                  {
                    unint64_t v36 = *(unsigned int *)(a1 + 5616 + v35);
                    if (!v36 || v11 - v28 < v36) {
                      break;
                    }
                    v35 += 4;
                    if (v35 == 12) {
                      return v28 - a3;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return -30;
}

unint64_t sub_1DD299990(uint64_t a1, _DWORD *a2, unint64_t a3, int a4, int a5, uint64_t a6, uint64_t a7, unint64_t a8, int a9)
{
  if (!a6)
  {
    unint64_t v13 = a3;
    unint64_t result = sub_1DD29A85C(a1, (_OWORD *)a7, a8, a3, 0, a9);
    if (result >= 0xFFFFFFFFFFFFFF89) {
      return result;
    }
    unint64_t result = sub_1DD29D774(*(void *)(a1 + 3176), a1 + 3192, a1 + 1008, (void *)(a1 + 656), (_DWORD *)(a1 + 224), a2, v13, a4, a5, 0, *(_WORD **)(a1 + 3496));
    goto LABEL_12;
  }
  unint64_t v13 = *(void *)(a6 + 8);
  if (!v13
    || a8 >= 0x20000 && a8 != -1 && 6 * v13 <= a8 && *(_DWORD *)(a6 + 6068)
    || (int v14 = *(_DWORD *)(a7 + 68), v14 == 3))
  {
    unint64_t result = sub_1DD29A85C(a1, (_OWORD *)a7, a8, *(void *)(a6 + 8), 0, a9);
    if (result >= 0xFFFFFFFFFFFFFF89) {
      return result;
    }
    unint64_t result = sub_1DD29D774(*(void *)(a1 + 3176), a1 + 3192, a1 + 1008, (void *)(a1 + 656), (_DWORD *)(a1 + 224), *(_DWORD **)a6, *(void *)(a6 + 8), *(_DWORD *)(a6 + 16), a5, 0, *(_WORD **)(a1 + 3496));
LABEL_12:
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    *(_DWORD *)(a1 + 640) = result;
    *(void *)(a1 + 648) = v13;
    return 0;
  }
  int v18 = *(_DWORD *)(a6 + 244);
  uint64_t v19 = *(unsigned int *)(a6 + 384);
  if (!v18)
  {
    if (a8 == -1 || qword_1DD321410[v19] >= a8)
    {
      if (v14 == 2) {
        goto LABEL_34;
      }
    }
    else if (v14 != 1)
    {
      goto LABEL_34;
    }
    if (!*(_DWORD *)(a7 + 48)) {
      goto LABEL_15;
    }
LABEL_34:
    long long v33 = *(_OWORD *)(a7 + 160);
    long long v34 = *(_OWORD *)(a7 + 176);
    long long v35 = *(_OWORD *)(a7 + 128);
    long long v71 = *(_OWORD *)(a7 + 144);
    long long v72 = v33;
    long long v36 = *(_OWORD *)(a7 + 192);
    long long v73 = v34;
    long long v74 = v36;
    long long v37 = *(_OWORD *)(a7 + 96);
    long long v38 = *(_OWORD *)(a7 + 112);
    long long v39 = *(_OWORD *)(a7 + 64);
    long long v67 = *(_OWORD *)(a7 + 80);
    long long v68 = v37;
    long long v69 = v38;
    long long v70 = v35;
    long long v40 = *(_OWORD *)(a7 + 32);
    long long v65 = *(_OWORD *)(a7 + 48);
    long long v66 = v39;
    long long v41 = *(_OWORD *)(a7 + 16);
    *(_OWORD *)uint64_t v63 = *(_OWORD *)a7;
    *(_OWORD *)&v63[16] = v41;
    int v42 = *(_DWORD *)&v63[4];
    *(_OWORD *)&v63[4] = *(_OWORD *)(a6 + 360);
    *(_OWORD *)&v63[16] = *(_OWORD *)(a6 + 372);
    long long v64 = v40;
    *(_DWORD *)&v63[4] = v42;
    LODWORD(v71) = *(_DWORD *)(a6 + 6072);
    unint64_t result = sub_1DD29A85C(a1, v63, a8, 0, 1, a9);
    if (result > 0xFFFFFFFFFFFFFF88) {
      return result;
    }
    *(void *)(a1 + 688) = *(void *)(a1 + 672);
    int v43 = *(_DWORD *)(a6 + 384);
    if (v43 == 1)
    {
      uint64_t v44 = 0;
      size_t v45 = 1 << *(_DWORD *)(a6 + 368);
      uint64_t v46 = a1 + 3192;
      unsigned int v47 = *(_DWORD **)(a1 + 3304);
      unint64_t v48 = *(_DWORD **)(a6 + 216);
      goto LABEL_42;
    }
    unsigned int v49 = v43 - 3;
    if ((v43 - 3) <= 2 && *(_DWORD *)(a6 + 6072) == 1)
    {
      uint64_t v44 = 0;
      int v50 = *(_DWORD *)(a6 + 368);
      size_t v45 = 1 << v50;
      uint64_t v46 = a1 + 3192;
      unsigned int v47 = *(_DWORD **)(a1 + 3304);
      unint64_t v48 = *(_DWORD **)(a6 + 216);
    }
    else
    {
      uint64_t v44 = 1 << *(_DWORD *)(a6 + 364);
      int v50 = *(_DWORD *)(a6 + 368);
      size_t v45 = 1 << v50;
      uint64_t v46 = a1 + 3192;
      unsigned int v47 = *(_DWORD **)(a1 + 3304);
      unint64_t v48 = *(_DWORD **)(a6 + 216);
      if (v49 >= 0xFFFFFFFE)
      {
LABEL_42:
        uint64_t v51 = 0;
        do
        {
          v47[v51] = v48[v51] >> 8;
          ++v51;
        }
        while (v45 != v51);
LABEL_44:
        int v52 = *(_DWORD *)(a1 + 252);
        if (v52 != 1 && ((v52 - 3) > 2 || *(_DWORD *)(a1 + 368) != 1))
        {
          uint64_t v54 = *(unsigned int **)(a1 + 3320);
          uint64_t v55 = *(unsigned int **)(a6 + 232);
          if ((*(_DWORD *)(a6 + 384) - 3) >= 0xFFFFFFFE)
          {
            for (; v44; --v44)
            {
              unsigned int v56 = *v55++;
              *v54++ = v56 >> 8;
            }
          }
          else
          {
            memcpy(v54, v55, 4 * v44);
          }
        }
        if ((*(_DWORD *)(a6 + 384) - 6) >= 0xFFFFFFFD && *(_DWORD *)(a6 + 6072) == 1)
        {
          memcpy(*(void **)(a1 + 3248), *(const void **)(a6 + 160), v45);
          *(void *)(a1 + 3288) = *(void *)(a6 + 200);
        }
        int v58 = *(_DWORD *)(a1 + 3240);
        if (v58) {
          size_t v59 = 4 << v58;
        }
        else {
          size_t v59 = 0;
        }
        bzero(*(void **)(a1 + 3312), v59);
        unint64_t v60 = *(void *)(a1 + 680);
        if (*(void *)(a1 + 688) < v60) {
          *(void *)(a1 + 688) = v60;
        }
        long long v61 = *(_OWORD *)(a6 + 104);
        long long v62 = *(_OWORD *)(a6 + 120);
        *(void *)(v46 + 32) = *(void *)(a6 + 136);
        *(_OWORD *)uint64_t v46 = v61;
        *(_OWORD *)(v46 + 16) = v62;
        *(void *)(a1 + 3232) = *(void *)(a6 + 144);
        goto LABEL_65;
      }
    }
    memcpy(v47, v48, 4 << v50);
    goto LABEL_44;
  }
LABEL_15:
  long long v20 = *(_OWORD *)(a7 + 176);
  long long v72 = *(_OWORD *)(a7 + 160);
  long long v73 = v20;
  long long v74 = *(_OWORD *)(a7 + 192);
  long long v21 = *(_OWORD *)(a7 + 112);
  long long v68 = *(_OWORD *)(a7 + 96);
  long long v69 = v21;
  long long v22 = *(_OWORD *)(a7 + 144);
  long long v70 = *(_OWORD *)(a7 + 128);
  long long v71 = v22;
  long long v23 = *(_OWORD *)(a7 + 48);
  long long v64 = *(_OWORD *)(a7 + 32);
  long long v65 = v23;
  long long v24 = *(_OWORD *)(a7 + 80);
  long long v66 = *(_OWORD *)(a7 + 64);
  long long v67 = v24;
  long long v25 = *(_OWORD *)(a7 + 16);
  *(_OWORD *)uint64_t v63 = *(_OWORD *)a7;
  *(_OWORD *)&v63[16] = v25;
  unsigned int v26 = *(_DWORD *)(a6 + 368) - 2;
  if (v26 <= 6) {
    unsigned int v26 = 6;
  }
  if ((v19 - 3) >= 3 || v18 == 0) {
    unsigned int v28 = *(_DWORD *)(a6 + 368);
  }
  else {
    unsigned int v28 = v26;
  }
  int v29 = *(_DWORD *)&v63[4];
  uint64_t v75 = *(void *)(a6 + 360);
  unsigned int v76 = v28;
  uint64_t v77 = *(void *)(a6 + 372);
  int v78 = *(_DWORD *)(a6 + 380);
  int v79 = v19;
  sub_1DD298510((unsigned int *)&v75, a8, v13, 1, v71, (uint64_t)&v63[4]);
  int v30 = *(_DWORD *)(a6 + 6072);
  *(_DWORD *)&v63[4] = v29;
  LODWORD(v71) = v30;
  unint64_t result = sub_1DD29A85C(a1, v63, a8, 0, 0, a9);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v31 = *(void *)(a6 + 104) - *(void *)(a6 + 112);
    if (*(_DWORD *)(a6 + 128) != v31)
    {
      *(void *)(a1 + 3440) = a6 + 104;
      unsigned int v32 = *(_DWORD *)(a1 + 3216);
      if (v32 < v31)
      {
        *(void *)(a1 + 3192) = *(void *)(a1 + 3200) + v31;
        *(_DWORD *)(a1 + 3220) = v31;
        *(_DWORD *)(a1 + 3216) = v31;
        unsigned int v32 = v31;
      }
      *(_DWORD *)(a1 + 3232) = v32;
    }
LABEL_65:
    *(_DWORD *)(a1 + 640) = *(_DWORD *)(a6 + 6064);
    *(void *)(a1 + 648) = *(void *)(a6 + 8);
    memcpy(*(void **)(a1 + 3176), (const void *)(a6 + 408), 0x1600uLL);
    return 0;
  }
  return result;
}

unint64_t sub_1DD299E80(uint64_t a1, char *a2, unint64_t a3, char *a4, size_t a5)
{
  unint64_t result = sub_1DD298DC0(a1, a2, a3, a4, a5, 1, 1);
  if (result > 0xFFFFFFFFFFFFFF88) {
    return result;
  }
  int v9 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1) {
    return -60;
  }
  unint64_t v10 = result;
  unint64_t v11 = &a2[result];
  unint64_t v12 = a3 - result;
  if (v9 == 3)
  {
    int v14 = v11;
  }
  else
  {
    if (v9 == 1)
    {
      unint64_t result = sub_1DD29A6FC(v11, v12, (_DWORD *)(a1 + 224), 0, 0);
      if (result > 0xFFFFFFFFFFFFFF88) {
        return result;
      }
      v12 -= result;
      unint64_t v13 = &v11[result];
      *(_DWORD *)a1 = 2;
    }
    else
    {
      unint64_t v13 = v11;
    }
    if (v12 < 4) {
      return -70;
    }
    *(_DWORD *)unint64_t v13 = 1;
    int v14 = v13 + 3;
    v12 -= 3;
  }
  if (!*(_DWORD *)(a1 + 260)) {
    goto LABEL_15;
  }
  int v15 = sub_1DD294B48((void *)(a1 + 760));
  if (v12 < 4) {
    return -70;
  }
  *(_DWORD *)int v14 = v15;
  v14 += 4;
LABEL_15:
  *(_DWORD *)a1 = 0;
  unint64_t result = v14 - v11;
  if ((unint64_t)(v14 - v11) <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v16 = *(void *)(a1 + 736);
    if (v16 && v16 != *(void *)(a1 + 744) + 1) {
      return -72;
    }
    else {
      result += v10;
    }
  }
  return result;
}

unint64_t sub_1DD299FA4(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, uint64_t a8)
{
  unint64_t result = sub_1DD299990(a1, a6, a7, 0, 0, 0, a8, a5, 0);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    return sub_1DD299E80(a1, a2, a3, a4, a5);
  }
  return result;
}

unint64_t sub_1DD29A054(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5, _DWORD *a6, unint64_t a7, int a8)
{
  *(_OWORD *)long long v22 = 0uLL;
  if (a6) {
    unint64_t v16 = a7;
  }
  else {
    unint64_t v16 = 0;
  }
  *(_DWORD *)&v22[24] = 0;
  *(void *)&v22[16] = 0;
  sub_1DD2986B0(a8, a5, v16, 0, (uint64_t)v22);
  uint64_t v21 = 0;
  *(_OWORD *)uint64_t v19 = *(_OWORD *)v22;
  *(_OWORD *)&v19[12] = *(_OWORD *)&v22[12];
  int v20 = 1;
  if (a8) {
    int v17 = a8;
  }
  else {
    int v17 = 3;
  }
  sub_1DD2983D8(a1 + 432, (long long *)v19, v17);
  return sub_1DD299FA4(a1, a2, a3, a4, a5, a6, a7, a1 + 432);
}

unint64_t sub_1DD29A148(uint64_t a1, char *a2, unint64_t a3, char *a4, unint64_t a5, int a6)
{
  return sub_1DD29A054(a1, a2, a3, a4, a5, 0, 0, a6);
}

unint64_t sub_1DD29A158(int *a1, int a2, int a3, int a4)
{
  unsigned int v4 = a1[6];
  if ((!a3 || a4) && (v4 == 1 || a2 == 1 && v4 - 3 < 3)) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 4 << a1[1];
  }
  int v6 = a1[2];
  if (a4 && a1[4] == 3)
  {
    int v7 = *a1;
    if (*a1 >= 0x11) {
      int v7 = 17;
    }
  }
  else
  {
    int v7 = 0;
  }
  BOOL v8 = v4 >= 6;
  unsigned int v9 = v4 - 6;
  BOOL v10 = v9 == 0 || !v8 || a4 == 0;
  uint64_t v11 = 128;
  if (!v10) {
    uint64_t v11 = 149312;
  }
  BOOL v12 = v9 >= 0xFFFFFFFD && a2 == 1;
  unint64_t v13 = ((1 << v6) + 63) & 0xFFFFFFFFFFFFFFC0;
  uint64_t v14 = 4 << v6;
  if (!v12) {
    unint64_t v13 = 0;
  }
  if (v7) {
    uint64_t v15 = 4 << v7;
  }
  else {
    uint64_t v15 = 0;
  }
  return v11 + v5 + v14 + v13 + v15;
}

uint64_t sub_1DD29A21C(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (void (*)(uint64_t))a1[756];
    uint64_t v3 = a1[757];
    unsigned int v4 = (void *)a1[4];
    BOOL v5 = v4 <= a1 && a1[5] > (unint64_t)a1;
    a1[12] = 0;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    if (v4)
    {
      if (!v2)
      {
        free(v4);
        if (v5) {
          return 0;
        }
        goto LABEL_12;
      }
      v2(v3);
    }
    if (!v5)
    {
      if (v2)
      {
        ((void (*)(uint64_t, void *))v2)(v3, a1);
        return 0;
      }
LABEL_12:
      free(a1);
    }
  }
  return 0;
}

uint64_t sub_1DD29A2C8(uint64_t a1, unsigned int *a2, uint64_t a3, unint64_t a4, char *__src, uint64_t a6, int a7)
{
  BOOL v8 = __src;
  BOOL v10 = a2;
  unint64_t v12 = *a2;
  uint64_t v13 = *(void *)(a1 + 3672);
  if (v13)
  {
    uint64_t v14 = (unsigned int *)(v13 + 8);
  }
  else
  {
    if (!*(void *)(a1 + 3680))
    {
      uint64_t v56 = 0;
      goto LABEL_6;
    }
    uint64_t v14 = (unsigned int *)(a1 + 3688);
  }
  uint64_t v56 = *v14;
LABEL_6:
  uint64_t v15 = &__src[a6];
  uint64_t v16 = *(void *)(a1 + 3176);
  *(void *)size_t v59 = *(void *)(v16 + 5616);
  *(_DWORD *)&v59[8] = *(_DWORD *)(v16 + 5624);
  if (v12 >= a4)
  {
    unint64_t v20 = v12;
    int v39 = v12;
    goto LABEL_66;
  }
  int v52 = v12;
  unint64_t v53 = &__src[a6];
  int v17 = v15 - 32;
  unsigned int v19 = *(_DWORD *)v59;
  unsigned int v18 = *(_DWORD *)&v59[4];
  unsigned int v57 = *(_DWORD *)&v59[8];
  unint64_t v20 = v12;
  int v21 = v12;
  uint64_t v54 = v15 - 32;
  while (1)
  {
    long long v22 = (unsigned int *)(a3 + 16 * v20);
    unint64_t v23 = v22[2];
    if (!v23 && !*v22) {
      break;
    }
    uint64_t v24 = v22[1];
    if (a7 == 2)
    {
      unsigned int v25 = *v22 + 3;
      goto LABEL_28;
    }
    unsigned int v26 = *v22;
    if (v24) {
      BOOL v27 = v19 == v26;
    }
    else {
      BOOL v27 = 0;
    }
    if (v27)
    {
      unsigned int v25 = 1;
    }
    else if (v18 == v26)
    {
      if (v24) {
        unsigned int v25 = 2;
      }
      else {
        unsigned int v25 = 1;
      }
    }
    else if (v57 == v26)
    {
      if (v24) {
        unsigned int v25 = 3;
      }
      else {
        unsigned int v25 = 2;
      }
    }
    else if (v24 || v19 - 1 != v26)
    {
      unsigned int v25 = v26 + 3;
      if (v26 != 0 && v26 < 0xFFFFFFFD) {
        goto LABEL_27;
      }
    }
    else
    {
      unsigned int v25 = 3;
    }
    int v28 = v24 != 0;
    unsigned int v29 = v25 - v28;
    if (v25 == v28) {
      goto LABEL_28;
    }
    if (v29 == 3) {
      unsigned int v26 = v19 - 1;
    }
    else {
      unsigned int v26 = *(_DWORD *)&v59[4 * v29];
    }
    if (v29 <= 1) {
      unsigned int v18 = v57;
    }
LABEL_27:
    *(_DWORD *)&v59[4] = v19;
    *(_DWORD *)&v59[8] = v18;
    unsigned int v57 = v18;
    unsigned int v18 = v19;
    unsigned int v19 = v26;
    *(_DWORD *)size_t v59 = v26;
LABEL_28:
    if (*(_DWORD *)(a1 + 360))
    {
      unint64_t v30 = *((void *)v10 + 1) + (v24 + v23);
      *((void *)v10 + 1) = v30;
      unint64_t v31 = v30 <= 1 << *(_DWORD *)(a1 + 228) ? v30 + v56 : 1 << *(_DWORD *)(a1 + 228);
      if (v31 + 3 < v25) {
        return -107;
      }
      BOOL v32 = *(_DWORD *)(a1 + 244) != 3 && *(_DWORD *)(a1 + 408) == 0;
      unint64_t v33 = 3;
      if (v32) {
        unint64_t v33 = 4;
      }
      if (v33 > v23) {
        return -107;
      }
    }
    if (*(void *)(a1 + 984) <= (unint64_t)(v21 - *v10)) {
      return -107;
    }
    long long v34 = *(_OWORD **)(a1 + 952);
    if (&v8[v24] > v17)
    {
      int v58 = v21;
      unint64_t v35 = a4;
      uint64_t v36 = a3;
      sub_1DD29DBFC(v34, v8, (unint64_t)&v8[v24], v17);
      a4 = v35;
      a3 = v36;
LABEL_42:
      *(void *)(a1 + 952) += v24;
      uint64_t v37 = *(void *)(a1 + 936);
      if (v24 >= 0x10000)
      {
        *(_DWORD *)(a1 + 1000) = 1;
        *(_DWORD *)(a1 + 1004) = (unint64_t)(v37 - *(void *)(a1 + 928)) >> 3;
      }
      int v17 = v54;
      BOOL v10 = a2;
      int v21 = v58;
      goto LABEL_48;
    }
    *long long v34 = *(_OWORD *)v8;
    if (v24 >= 0x11)
    {
      uint64_t v38 = *(void *)(a1 + 952);
      *(_OWORD *)(v38 + 16) = *((_OWORD *)v8 + 1);
      if ((unint64_t)(v24 - 16) >= 0x11)
      {
        int v58 = v21;
        unint64_t v40 = v38 + v24;
        long long v41 = (_OWORD *)(v38 + 32);
        int v42 = (long long *)(v8 + 48);
        do
        {
          _OWORD *v41 = *(v42 - 1);
          long long v43 = *v42;
          v42 += 2;
          v41[1] = v43;
          v41 += 2;
        }
        while ((unint64_t)v41 < v40);
        goto LABEL_42;
      }
    }
    *(void *)(a1 + 952) += v24;
    uint64_t v37 = *(void *)(a1 + 936);
LABEL_48:
    *(_WORD *)(v37 + 4) = v24;
    *(_DWORD *)uint64_t v37 = v25;
    if (v23 - 3 >= 0x10000)
    {
      *(_DWORD *)(a1 + 1000) = 2;
      *(_DWORD *)(a1 + 1004) = (unint64_t)(v37 - *(void *)(a1 + 928)) >> 3;
    }
    *(_WORD *)(v37 + 6) = v23 - 3;
    *(void *)(a1 + 936) = v37 + 8;
    v8 += (v24 + v23);
    unint64_t v20 = (v21 + 1);
    int v21 = v20;
    int v39 = v20;
    if (v20 >= a4) {
      goto LABEL_73;
    }
  }
  int v39 = v21;
LABEL_73:
  if (a7 == 2)
  {
    uint64_t v15 = v53;
    if (v39 != v52)
    {
      if (v39 - 1 >= (v52 + 2))
      {
        int v51 = *(_DWORD *)(a3 + 16 * (v39 - 3));
LABEL_80:
        *(_DWORD *)&v59[4] = *(_DWORD *)(a3 + 16 * (v39 - 2));
        *(_DWORD *)&v59[8] = v51;
      }
      else
      {
        if (v39 == v52 + 2)
        {
          int v51 = *(_DWORD *)v59;
          goto LABEL_80;
        }
        *(void *)&v59[4] = *(void *)v59;
      }
      *(_DWORD *)size_t v59 = *(_DWORD *)(a3 + 16 * (v39 - 1));
    }
  }
  else
  {
    uint64_t v15 = v53;
  }
LABEL_66:
  uint64_t v44 = *(void *)(a1 + 3184);
  *(void *)(v44 + 5616) = *(void *)v59;
  *(_DWORD *)(v44 + 5624) = *(_DWORD *)&v59[8];
  uint64_t v45 = a3 + 16 * v20;
  unsigned int v48 = *(_DWORD *)(v45 + 4);
  unsigned int v47 = (unsigned int *)(v45 + 4);
  size_t v46 = v48;
  if (v48)
  {
    memcpy(*(void **)(a1 + 952), v8, v46);
    *(void *)(a1 + 952) += v46;
    uint64_t v49 = *v47;
    v8 += v49;
    *((void *)v10 + 1) += v49;
  }
  if (v8 != v15) {
    return -107;
  }
  uint64_t result = 0;
  unsigned int *v10 = v39 + 1;
  return result;
}

uint64_t sub_1DD29A6FC(_DWORD *a1, unint64_t a2, _DWORD *a3, unint64_t a4, unsigned int a5)
{
  int v5 = a5 > 0xFF;
  if (a5) {
    ++v5;
  }
  if ((a5 & 0xFFFF0000) != 0) {
    ++v5;
  }
  if (a3[10]) {
    int v6 = 0;
  }
  else {
    int v6 = v5;
  }
  int v7 = a3[1];
  int v8 = a3[8];
  if (v8) {
    BOOL v9 = 1 << v7 >= a4;
  }
  else {
    BOOL v9 = 0;
  }
  int v10 = v9;
  int v11 = a4 >> 8 > 0x100;
  if (a4 > 0xFF) {
    ++v11;
  }
  if (a4 > 0xFFFFFFFE) {
    ++v11;
  }
  if (v8) {
    int v12 = v11;
  }
  else {
    int v12 = 0;
  }
  if (v10) {
    char v13 = 32;
  }
  else {
    char v13 = 0;
  }
  if (a2 < 0x12) {
    return -70;
  }
  char v15 = v13 | (v6 + 4 * (a3[9] > 0)) | ((_BYTE)v12 << 6);
  if (*a3)
  {
    uint64_t v16 = 0;
  }
  else
  {
    *a1 = -47205080;
    uint64_t v16 = 1;
  }
  uint64_t v14 = (v16 * 4) | 1;
  LOBYTE(a1[v16]) = v15;
  if ((v10 & 1) == 0)
  {
    *((unsigned char *)a1 + v14) = 8 * v7 - 80;
    uint64_t v14 = (v16 * 4) | 2;
  }
  switch(v6)
  {
    case 3:
      *(_DWORD *)((char *)a1 + v14) = a5;
      v14 += 4;
      break;
    case 2:
      *(_WORD *)((char *)a1 + v14) = a5;
      v14 += 2;
      break;
    case 1:
      *((unsigned char *)a1 + v14++) = a5;
      break;
  }
  switch(v12)
  {
    case 1:
      *(_WORD *)((char *)a1 + v14) = a4 - 256;
      v14 += 2;
      break;
    case 2:
      *(_DWORD *)((char *)a1 + v14) = a4;
      v14 += 4;
      break;
    case 3:
      *(void *)((char *)a1 + v14) = a4;
      v14 += 8;
      break;
    default:
      if (v10) {
        *((unsigned char *)a1 + v14++) = a4;
      }
      break;
  }
  return v14;
}

uint64_t sub_1DD29A85C(uint64_t a1, _OWORD *a2, unint64_t a3, unint64_t a4, int a5, int a6)
{
  *(_DWORD *)(a1 + 920) = 1;
  *(_OWORD *)(a1 + 224) = *a2;
  long long v11 = a2[1];
  long long v12 = a2[2];
  long long v13 = a2[4];
  *(_OWORD *)(a1 + 272) = a2[3];
  *(_OWORD *)(a1 + 288) = v13;
  *(_OWORD *)(a1 + 240) = v11;
  *(_OWORD *)(a1 + 256) = v12;
  long long v14 = a2[5];
  long long v15 = a2[6];
  long long v16 = a2[8];
  *(_OWORD *)(a1 + 336) = a2[7];
  *(_OWORD *)(a1 + 352) = v16;
  *(_OWORD *)(a1 + 304) = v14;
  *(_OWORD *)(a1 + 320) = v15;
  long long v17 = a2[9];
  long long v18 = a2[10];
  long long v19 = a2[12];
  *(_OWORD *)(a1 + 400) = a2[11];
  *(_OWORD *)(a1 + 416) = v19;
  *(_OWORD *)(a1 + 368) = v17;
  *(_OWORD *)(a1 + 384) = v18;
  uint64_t v20 = a1 + 320;
  if (*(_DWORD *)(a1 + 320) == 1) {
    sub_1DD2CEE9C((_DWORD *)(a1 + 320), (unsigned int *)(a1 + 228));
  }
  unint64_t v21 = 1 << *(_DWORD *)(a1 + 228);
  if (v21 >= a3) {
    unint64_t v21 = a3;
  }
  if (!a3) {
    unint64_t v21 = 1;
  }
  if (*(void *)(a1 + 416) >= v21) {
    unint64_t v22 = v21;
  }
  else {
    unint64_t v22 = *(void *)(a1 + 416);
  }
  if (*(_DWORD *)(a1 + 408)) {
    BOOL v23 = 1;
  }
  else {
    BOOL v23 = *(_DWORD *)(a1 + 244) == 3;
  }
  if (v23) {
    unint64_t v24 = 3;
  }
  else {
    unint64_t v24 = 4;
  }
  int v119 = a5;
  if (a6 == 1)
  {
    if (*(_DWORD *)(a1 + 352))
    {
      uint64_t v25 = 0;
    }
    else
    {
      if (v22 > 0xFF00FF00FF00FEFFLL) {
        goto LABEL_24;
      }
      unint64_t v27 = (0x20000 - v22) >> 11;
      if (v22 >= 0x20000) {
        unint64_t v27 = 0;
      }
      uint64_t v28 = v22 + (v22 >> 8) + v27;
      if (!v28) {
LABEL_24:
      }
        uint64_t v28 = -72;
      uint64_t v25 = v28 + 1;
    }
    uint64_t v29 = v22 + v21;
    if (*(_DWORD *)(a1 + 348)) {
      uint64_t v26 = 0;
    }
    else {
      uint64_t v26 = v29;
    }
  }
  else
  {
    uint64_t v25 = 0;
    uint64_t v26 = 0;
  }
  long long v121 = *(_OWORD *)v20;
  uint64_t v122 = *(void *)(v20 + 16);
  unint64_t v120 = v22;
  BOOL v30 = 1;
  unint64_t v118 = sub_1DD2CEF38(&v121, v22);
  if (!(a4 >> 29) && *(void *)(a1 + 3192) - *(void *)(a1 + 3200) <= 0xDF000000uLL) {
    BOOL v30 = *(_DWORD *)(a1 + 924) == 0;
  }
  unint64_t v31 = sub_1DD298790((int *)(a1 + 228), (long long *)v20, *(void *)(a1 + 880) != 0, *(_DWORD *)(a1 + 368), v26, v25, a3, *(_DWORD *)(a1 + 408), *(void *)(a1 + 416));
  size_t v32 = v31;
  if (v31 > 0xFFFFFFFFFFFFFF88) {
    return v32;
  }
  uint64_t v33 = *(void *)(a1 + 880);
  if (!v33) {
    ++*(_DWORD *)(a1 + 716);
  }
  uint64_t v34 = *(void *)(a1 + 664);
  unint64_t v35 = *(void **)(a1 + 656);
  unint64_t v117 = v24;
  BOOL v36 = *(void *)(a1 + 696) - *(void *)(a1 + 680) >= 3 * v31 && *(_DWORD *)(a1 + 716) > 128;
  if (v34 - (uint64_t)v35 < v31 || v36)
  {
    if (!v33)
    {
      unsigned int v48 = *(void (**)(uint64_t))(a1 + 856);
      uint64_t v49 = *(void *)(a1 + 864);
      *(_OWORD *)(a1 + 656) = 0u;
      *(_OWORD *)(a1 + 672) = 0u;
      *(_OWORD *)(a1 + 688) = 0u;
      *(_OWORD *)(a1 + 704) = 0u;
      *(void *)(a1 + 720) = 0;
      if (v35)
      {
        if (v48) {
          v48(v49);
        }
        else {
          free(v35);
        }
      }
      long long v62 = *(uint64_t (**)(void, size_t))(a1 + 848);
      uint64_t v63 = v62 ? (char *)v62(*(void *)(a1 + 864), v32) : (char *)malloc(v32);
      unint64_t v40 = v120;
      if (v63)
      {
        *(void *)(a1 + 656) = v63;
        *(void *)(a1 + 664) = &v63[v32];
        *(void *)(a1 + 672) = v63;
        *(void *)(a1 + 688) = v63;
        unint64_t v64 = (unint64_t)&v63[v32] & 0xFFFFFFFFFFFFFFC0;
        *(void *)(a1 + 704) = v64;
        *(void *)(a1 + 720) = 0;
        *(void *)(a1 + 680) = v63;
        *(void *)(a1 + 696) = v64;
        *(unsigned char *)(a1 + 712) = 0;
        *(_DWORD *)(a1 + 716) = 0;
        if ((uint64_t)v32 > 5631)
        {
          *(void *)(a1 + 672) = v63 + 5632;
          *(void *)(a1 + 680) = v63 + 5632;
          *(void *)(a1 + 688) = v63 + 5632;
          *(void *)(a1 + 3176) = v63;
          if (v32 >> 10 > 0xA)
          {
            *(void *)(a1 + 672) = v63 + 11264;
            *(void *)(a1 + 680) = v63 + 11264;
            *(void *)(a1 + 688) = v63 + 11264;
            *(void *)(a1 + 3184) = v63 + 5632;
            if (v32 >> 3 > 0x9DA)
            {
              int v115 = a6;
              uint64_t v116 = v25;
              *(void *)(a1 + 672) = v63 + 20184;
              int v39 = (unsigned int *)(a1 + 720);
              *(void *)(a1 + 688) = v63 + 20184;
              uint64_t v38 = (unsigned char *)(a1 + 712);
              *(void *)(a1 + 3496) = v63 + 11264;
              *(void *)(a1 + 680) = v63 + 20184;
              *(unsigned char *)(a1 + 712) = 0;
              BOOL v30 = 1;
              goto LABEL_45;
            }
            *(unsigned char *)(a1 + 712) = 1;
            *(void *)(a1 + 3496) = 0;
          }
          else
          {
            *(unsigned char *)(a1 + 712) = 1;
            *(void *)(a1 + 3184) = 0;
          }
        }
        else
        {
          *(unsigned char *)(a1 + 712) = 1;
          *(void *)(a1 + 3176) = 0;
        }
      }
    }
    return -64;
  }
  uint64_t v116 = v25;
  unsigned int v37 = *(_DWORD *)(a1 + 720);
  *(void *)(a1 + 680) = *(void *)(a1 + 672);
  *(void *)(a1 + 696) = v34 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v38 = (unsigned char *)(a1 + 712);
  *(unsigned char *)(a1 + 712) = 0;
  int v115 = a6;
  int v39 = (unsigned int *)(a1 + 720);
  if (v37 >= 2) {
    *(_DWORD *)(a1 + 720) = 1;
  }
  unint64_t v40 = v120;
LABEL_45:
  *(_OWORD *)(a1 + 3448) = *(_OWORD *)(a1 + 228);
  *(_OWORD *)(a1 + 3460) = *(_OWORD *)(a1 + 240);
  *(_DWORD *)(a1 + 3488) = *(_DWORD *)(a1 + 400) == 1;
  *(_OWORD *)(a1 + 744) = 0u;
  *(void *)(a1 + 736) = a3 + 1;
  if (a3 == -1) {
    *(_DWORD *)(a1 + 256) = 0;
  }
  *(void *)(a1 + 728) = v40;
  unint64_t v41 = v40;
  sub_1DD294954(a1 + 760, 0);
  *(_DWORD *)a1 = 1;
  *(_DWORD *)(a1 + 640) = 0;
  *(void *)(a1 + 648) = 0;
  uint64_t v42 = *(void *)(a1 + 3176);
  *(_DWORD *)(v42 + 5624) = 8;
  *(void *)(v42 + 5616) = 0x400000001;
  *(_DWORD *)(v42 + 2056) = 0;
  *(_DWORD *)(v42 + 5604) = 0;
  *(void *)(v42 + 5608) = 0;
  size_t v32 = sub_1DD29B4DC(a1 + 3192, a1 + 656, (_DWORD *)(a1 + 228), *(_DWORD *)(a1 + 368), v119, v30, 1);
  if (v32 <= 0xFFFFFFFFFFFFFF88)
  {
    unsigned int v43 = *v39;
    unint64_t v44 = v41 / v24;
    unint64_t v45 = v41;
    size_t v46 = v38;
    if (*v39 > 1)
    {
      uint64_t v47 = v116;
    }
    else
    {
      uint64_t v47 = v116;
      if (!v43)
      {
        uint64_t v51 = *(void *)(a1 + 672);
        *(void *)(a1 + 688) = v51;
        unint64_t v52 = *(void *)(a1 + 664);
        *(void *)(a1 + 704) = v52 & 0xFFFFFFFFFFFFFFC0;
        uint64_t v53 = -(int)v51 & 0x3FLL;
        unint64_t v54 = v51 + v53;
        if (v54 > v52)
        {
          unsigned int v43 = 0;
          unint64_t v50 = 0;
          goto LABEL_63;
        }
        *(void *)(a1 + 672) = v54;
        *(void *)(a1 + 680) = v54;
        if (v53) {
          *(void *)(a1 + 688) = v54;
        }
      }
      unsigned int v43 = 2;
      unsigned int *v39 = 2;
    }
    unint64_t v50 = (8 * v44 + 63) & 0xFFFFFFFFFFFFFFC0;
    if (v50)
    {
      unint64_t v50 = *(void *)(a1 + 696) - v50;
      if (v50 >= *(void *)(a1 + 680))
      {
        if (v50 < *(void *)(a1 + 688)) {
          *(void *)(a1 + 688) = v50;
        }
        *(void *)(a1 + 696) = v50;
      }
      else
      {
        unint64_t v50 = 0;
        *size_t v46 = 1;
      }
    }
LABEL_63:
    *(void *)(a1 + 928) = v50;
    if (*(_DWORD *)(a1 + 320) != 1) {
      goto LABEL_102;
    }
    size_t v55 = 8 << *(_DWORD *)(a1 + 324);
    if (v43 <= 1)
    {
      uint64_t v56 = *(void *)(a1 + 672);
      *(void *)(a1 + 688) = v56;
      unint64_t v57 = *(void *)(a1 + 664);
      *(void *)(a1 + 704) = v57 & 0xFFFFFFFFFFFFFFC0;
      uint64_t v58 = -(int)v56 & 0x3FLL;
      unint64_t v59 = v56 + v58;
      if (v59 > v57) {
        goto LABEL_72;
      }
      *(void *)(a1 + 672) = v59;
      *(void *)(a1 + 680) = v59;
      if (v58) {
        *(void *)(a1 + 688) = v59;
      }
      unsigned int *v39 = 2;
    }
    unint64_t v60 = (v55 + 63) & 0xFFFFFFFFFFFFFFC0;
    if (v60)
    {
      long long v61 = (void *)(*(void *)(a1 + 696) - v60);
      if ((unint64_t)v61 >= *(void *)(a1 + 680))
      {
        if ((unint64_t)v61 < *(void *)(a1 + 688)) {
          *(void *)(a1 + 688) = v61;
        }
        *(void *)(a1 + 696) = v61;
      }
      else
      {
        long long v61 = 0;
        *size_t v46 = 1;
      }
LABEL_85:
      *(void *)(a1 + 1048) = v61;
      bzero(v61, v55);
      unsigned int v43 = *(_DWORD *)(a1 + 720);
      if (v43 > 1)
      {
        unint64_t v45 = v120;
        unint64_t v65 = v118;
      }
      else
      {
        unint64_t v45 = v120;
        unint64_t v65 = v118;
        if (!v43)
        {
          uint64_t v67 = *(void *)(a1 + 672);
          *(void *)(a1 + 688) = v67;
          unint64_t v68 = *(void *)(a1 + 664);
          *(void *)(a1 + 704) = v68 & 0xFFFFFFFFFFFFFFC0;
          uint64_t v69 = -(int)v67 & 0x3FLL;
          unint64_t v70 = v67 + v69;
          if (v70 > v68)
          {
            unsigned int v43 = 0;
            unint64_t v66 = 0;
LABEL_101:
            *(void *)(a1 + 3120) = v66;
            *(void *)(a1 + 3128) = v65;
            *(void *)(a1 + 1040) = 0;
            *(void *)(a1 + 1016) = " ";
            *(void *)(a1 + 1024) = " ";
            *(void *)(a1 + 1032) = 0x200000002;
            *(void *)(a1 + 1008) = "\n";
            *(_DWORD *)(a1 + 1056) = 0;
LABEL_102:
            if (!*(_DWORD *)(a1 + 408)) {
              goto LABEL_116;
            }
            unint64_t v71 = v45 / 3 + 1;
            *(void *)(a1 + 5232) = v71;
            if (v43 <= 1)
            {
              uint64_t v72 = *(void *)(a1 + 672);
              *(void *)(a1 + 688) = v72;
              unint64_t v73 = *(void *)(a1 + 664);
              *(void *)(a1 + 704) = v73 & 0xFFFFFFFFFFFFFFC0;
              uint64_t v74 = -(int)v72 & 0x3FLL;
              unint64_t v75 = v72 + v74;
              if (v75 > v73)
              {
                unsigned int v43 = 0;
                unint64_t v76 = 0;
LABEL_115:
                *(void *)(a1 + 5224) = v76;
LABEL_116:
                if (v43 <= 2)
                {
                  if (!v43)
                  {
                    uint64_t v79 = *(void *)(a1 + 672);
                    *(void *)(a1 + 688) = v79;
                    unint64_t v80 = *(void *)(a1 + 664);
                    *(void *)(a1 + 704) = v80 & 0xFFFFFFFFFFFFFFC0;
                    uint64_t v81 = -(int)v79 & 0x3FLL;
                    unint64_t v82 = v79 + v81;
                    if (v82 > v80)
                    {
                      *(void *)(a1 + 944) = 0;
                      *(void *)(a1 + 992) = v45;
                      *(_DWORD *)(a1 + 3504) = v115;
                      *(void *)(a1 + 3520) = v26;
                      uint64_t v83 = *(void *)(a1 + 672);
                      *(void *)(a1 + 688) = v83;
                      unint64_t v84 = *(void *)(a1 + 664);
                      *(void *)(a1 + 704) = v84 & 0xFFFFFFFFFFFFFFC0;
                      uint64_t v85 = -(int)v83 & 0x3FLL;
                      unint64_t v86 = v83 + v85;
                      if (v86 > v84)
                      {
                        *(void *)(a1 + 3512) = 0;
                        *(void *)(a1 + 3560) = v47;
                        uint64_t v87 = *(void *)(a1 + 672);
                        *(void *)(a1 + 688) = v87;
                        unint64_t v88 = *(void *)(a1 + 664);
                        *(void *)(a1 + 704) = v88 & 0xFFFFFFFFFFFFFFC0;
                        uint64_t v89 = -(int)v87 & 0x3FLL;
                        unint64_t v90 = v87 + v89;
                        if (v90 <= v88)
                        {
                          *(void *)(a1 + 672) = v90;
                          *(void *)(a1 + 680) = v90;
                          if (v89) {
                            *(void *)(a1 + 688) = v90;
                          }
                          unsigned int v43 = 3;
                          unsigned int *v39 = 3;
                          if (v47) {
                            goto LABEL_146;
                          }
                        }
                        else
                        {
                          unsigned int v43 = 0;
                        }
                        goto LABEL_154;
                      }
                      *(void *)(a1 + 672) = v86;
                      *(void *)(a1 + 680) = v86;
                      if (v85) {
                        *(void *)(a1 + 688) = v86;
                      }
                      unsigned int v43 = 3;
                      unsigned int *v39 = 3;
                      if (v26) {
                        goto LABEL_127;
                      }
                      goto LABEL_144;
                    }
                    *(void *)(a1 + 672) = v82;
                    *(void *)(a1 + 680) = v82;
                    if (v81) {
                      *(void *)(a1 + 688) = v82;
                    }
                  }
                  unsigned int v43 = 3;
                  unsigned int *v39 = 3;
                }
                if (v45 == -32)
                {
                  unint64_t v77 = 0;
                }
                else
                {
                  unint64_t v77 = *(void *)(a1 + 696) - v45 - 32;
                  if (v77 >= *(void *)(a1 + 680))
                  {
                    if (v77 < *(void *)(a1 + 688)) {
                      *(void *)(a1 + 688) = v77;
                    }
                    *(void *)(a1 + 696) = v77;
                  }
                  else
                  {
                    unint64_t v77 = 0;
                    *size_t v46 = 1;
                  }
                }
                *(void *)(a1 + 944) = v77;
                *(void *)(a1 + 992) = v45;
                *(_DWORD *)(a1 + 3504) = v115;
                *(void *)(a1 + 3520) = v26;
                if (v26)
                {
LABEL_127:
                  unint64_t v78 = *(void *)(a1 + 696) - v26;
                  if (v78 >= *(void *)(a1 + 680))
                  {
                    if (v78 < *(void *)(a1 + 688)) {
                      *(void *)(a1 + 688) = v78;
                    }
                    *(void *)(a1 + 696) = v78;
                  }
                  else
                  {
                    unint64_t v78 = 0;
                    *size_t v46 = 1;
                  }
LABEL_145:
                  *(void *)(a1 + 3512) = v78;
                  *(void *)(a1 + 3560) = v47;
                  if (v47)
                  {
LABEL_146:
                    unint64_t v91 = *(void *)(a1 + 696) - v47;
                    if (v91 >= *(void *)(a1 + 680))
                    {
                      if (v91 < *(void *)(a1 + 688)) {
                        *(void *)(a1 + 688) = v91;
                      }
                      *(void *)(a1 + 696) = v91;
                    }
                    else
                    {
                      unint64_t v91 = 0;
                      *size_t v46 = 1;
                    }
LABEL_155:
                    *(void *)(a1 + 3552) = v91;
                    if (*(_DWORD *)(a1 + 320) != 1)
                    {
LABEL_168:
                      if (*(_DWORD *)a1 == 1 && *(_DWORD *)v20 != 1)
                      {
                        *(void *)(a1 + 3168) = 0;
                        *(_OWORD *)(a1 + 3152) = 0u;
                        *(_OWORD *)(a1 + 3136) = 0u;
                      }
                      *(void *)(a1 + 984) = v44;
                      unsigned int v98 = *(_DWORD *)(a1 + 720);
                      if (v98 <= 2)
                      {
                        if (!v98)
                        {
                          uint64_t v103 = *(void *)(a1 + 672);
                          *(void *)(a1 + 688) = v103;
                          unint64_t v104 = *(void *)(a1 + 664);
                          *(void *)(a1 + 704) = v104 & 0xFFFFFFFFFFFFFFC0;
                          uint64_t v105 = -(int)v103 & 0x3FLL;
                          unint64_t v106 = v103 + v105;
                          if (v106 > v104)
                          {
                            *(void *)(a1 + 960) = 0;
                            uint64_t v107 = *(void *)(a1 + 672);
                            *(void *)(a1 + 688) = v107;
                            unint64_t v108 = *(void *)(a1 + 664);
                            *(void *)(a1 + 704) = v108 & 0xFFFFFFFFFFFFFFC0;
                            uint64_t v109 = -(int)v107 & 0x3FLL;
                            unint64_t v110 = v107 + v109;
                            if (v110 > v108)
                            {
                              unint64_t v101 = 0;
                              *(void *)(a1 + 968) = 0;
                              uint64_t v111 = *(void *)(a1 + 672);
                              *(void *)(a1 + 688) = v111;
                              unint64_t v112 = *(void *)(a1 + 664);
                              *(void *)(a1 + 704) = v112 & 0xFFFFFFFFFFFFFFC0;
                              uint64_t v113 = -(int)v111 & 0x3FLL;
                              unint64_t v114 = v111 + v113;
                              if (v114 > v112)
                              {
LABEL_197:
                                size_t v32 = 0;
                                *(void *)(a1 + 976) = v101;
                                *(_DWORD *)(a1 + 924) = 1;
                                return v32;
                              }
                              *(void *)(a1 + 672) = v114;
                              *(void *)(a1 + 680) = v114;
                              if (v113) {
                                *(void *)(a1 + 688) = v114;
                              }
                              unsigned int *v39 = 3;
LABEL_190:
                              if (v117 <= v45)
                              {
                                unint64_t v101 = *(void *)(a1 + 696) - v44;
                                if (v101 >= *(void *)(a1 + 680))
                                {
                                  if (v101 < *(void *)(a1 + 688)) {
                                    *(void *)(a1 + 688) = v101;
                                  }
                                  *(void *)(a1 + 696) = v101;
                                }
                                else
                                {
                                  unint64_t v101 = 0;
                                  *size_t v46 = 1;
                                }
                              }
                              else
                              {
                                unint64_t v101 = 0;
                              }
                              goto LABEL_197;
                            }
                            *(void *)(a1 + 672) = v110;
                            *(void *)(a1 + 680) = v110;
                            if (v109) {
                              *(void *)(a1 + 688) = v110;
                            }
                            unsigned int *v39 = 3;
LABEL_182:
                            if (v117 <= v45)
                            {
                              unint64_t v100 = *(void *)(a1 + 696) - v44;
                              if (v100 >= *(void *)(a1 + 680))
                              {
                                if (v100 < *(void *)(a1 + 688)) {
                                  *(void *)(a1 + 688) = v100;
                                }
                                *(void *)(a1 + 696) = v100;
                              }
                              else
                              {
                                unint64_t v100 = 0;
                                *size_t v46 = 1;
                              }
                            }
                            else
                            {
                              unint64_t v100 = 0;
                            }
                            *(void *)(a1 + 968) = v100;
                            goto LABEL_190;
                          }
                          *(void *)(a1 + 672) = v106;
                          *(void *)(a1 + 680) = v106;
                          if (v105) {
                            *(void *)(a1 + 688) = v106;
                          }
                        }
                        unsigned int *v39 = 3;
                      }
                      if (v117 <= v45)
                      {
                        unint64_t v99 = *(void *)(a1 + 696) - v44;
                        if (v99 >= *(void *)(a1 + 680))
                        {
                          if (v99 < *(void *)(a1 + 688)) {
                            *(void *)(a1 + 688) = v99;
                          }
                          *(void *)(a1 + 696) = v99;
                        }
                        else
                        {
                          unint64_t v99 = 0;
                          *size_t v46 = 1;
                        }
                      }
                      else
                      {
                        unint64_t v99 = 0;
                      }
                      *(void *)(a1 + 960) = v99;
                      goto LABEL_182;
                    }
                    size_t v92 = 1 << (*(unsigned char *)(a1 + 324) - *(unsigned char *)(a1 + 328));
                    if (v43 <= 2)
                    {
                      uint64_t v93 = *(void *)(a1 + 672);
                      *(void *)(a1 + 688) = v93;
                      unint64_t v94 = *(void *)(a1 + 664);
                      *(void *)(a1 + 704) = v94 & 0xFFFFFFFFFFFFFFC0;
                      uint64_t v95 = -(int)v93 & 0x3FLL;
                      unint64_t v96 = v93 + v95;
                      if (v96 > v94)
                      {
                        unint64_t v97 = 0;
LABEL_167:
                        *(void *)(a1 + 1064) = v97;
                        bzero(v97, v92);
                        unint64_t v45 = v120;
                        goto LABEL_168;
                      }
                      *(void *)(a1 + 672) = v96;
                      *(void *)(a1 + 680) = v96;
                      if (v95) {
                        *(void *)(a1 + 688) = v96;
                      }
                      unsigned int *v39 = 3;
                    }
                    unint64_t v97 = (void *)(*(void *)(a1 + 696) - v92);
                    if ((unint64_t)v97 >= *(void *)(a1 + 680))
                    {
                      if ((unint64_t)v97 < *(void *)(a1 + 688)) {
                        *(void *)(a1 + 688) = v97;
                      }
                      *(void *)(a1 + 696) = v97;
                    }
                    else
                    {
                      unint64_t v97 = 0;
                      *size_t v46 = 1;
                    }
                    goto LABEL_167;
                  }
LABEL_154:
                  unint64_t v91 = 0;
                  goto LABEL_155;
                }
LABEL_144:
                unint64_t v78 = 0;
                goto LABEL_145;
              }
              *(void *)(a1 + 672) = v75;
              *(void *)(a1 + 680) = v75;
              if (v74) {
                *(void *)(a1 + 688) = v75;
              }
              unsigned int v43 = 2;
              unsigned int *v39 = 2;
            }
            unint64_t v76 = (16 * v71 + 63) & 0xFFFFFFFFFFFFFFC0;
            if (v76)
            {
              unint64_t v76 = *(void *)(a1 + 696) - v76;
              if (v76 >= *(void *)(a1 + 680))
              {
                if (v76 < *(void *)(a1 + 688)) {
                  *(void *)(a1 + 688) = v76;
                }
                *(void *)(a1 + 696) = v76;
              }
              else
              {
                unint64_t v76 = 0;
                *size_t v46 = 1;
              }
            }
            goto LABEL_115;
          }
          *(void *)(a1 + 672) = v70;
          *(void *)(a1 + 680) = v70;
          if (v69) {
            *(void *)(a1 + 688) = v70;
          }
        }
        unsigned int v43 = 2;
        unsigned int *v39 = 2;
      }
      unint64_t v66 = (12 * v65 + 63) & 0xFFFFFFFFFFFFFFC0;
      if (v66)
      {
        unint64_t v66 = *(void *)(a1 + 696) - v66;
        if (v66 >= *(void *)(a1 + 680))
        {
          if (v66 < *(void *)(a1 + 688)) {
            *(void *)(a1 + 688) = v66;
          }
          *(void *)(a1 + 696) = v66;
        }
        else
        {
          unint64_t v66 = 0;
          *size_t v46 = 1;
        }
      }
      goto LABEL_101;
    }
LABEL_72:
    long long v61 = 0;
    goto LABEL_85;
  }
  return v32;
}

uint64_t sub_1DD29B4DC(uint64_t a1, uint64_t a2, _DWORD *a3, int a4, int a5, int a6, int a7)
{
  int v12 = a3[6];
  if ((a7 || !*(_DWORD *)(a1 + 140)) && (v12 == 1 || a4 == 1 && (v12 - 3) < 3)) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = 4 << a3[1];
  }
  if (a7 == 1 && a3[4] == 3)
  {
    if (*a3 >= 0x11u) {
      int v14 = 17;
    }
    else {
      int v14 = *a3;
    }
  }
  else
  {
    int v14 = 0;
  }
  int v15 = a3[2];
  if (a6 == 1)
  {
    *(void *)(a1 + 32) = 0;
    long long v16 = " ";
    *(void *)(a1 + 8) = " ";
    *(void *)(a1 + 16) = " ";
    long long v17 = "\n";
    *(void *)a1 = "\n";
    unint64_t v18 = *(void *)(a2 + 16);
    *(void *)(a2 + 32) = v18;
  }
  else
  {
    long long v17 = *(const char **)a1;
    long long v16 = *(const char **)(a1 + 8);
    unint64_t v18 = *(void *)(a2 + 16);
  }
  *(_DWORD *)(a1 + 300) = 0;
  int v19 = v17 - v16;
  *(_DWORD *)(a1 + 24) = v19;
  *(_DWORD *)(a1 + 28) = v19;
  *(_DWORD *)(a1 + 44) = v19;
  *(_DWORD *)(a1 + 48) = v14;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a2 + 24) = v18;
  if (*(_DWORD *)(a2 + 64))
  {
    unint64_t v20 = v18;
LABEL_31:
    unint64_t v26 = v20 + (4 << v15);
    if (v26 <= *(void *)(a2 + 40))
    {
      *(void *)(a2 + 24) = v26;
    }
    else
    {
      *(unsigned char *)(a2 + 56) = 1;
      unint64_t v26 = v20;
      unint64_t v20 = 0;
    }
    *(void *)(a1 + 112) = v20;
LABEL_35:
    unint64_t v32 = v26 + v13;
    if (v32 <= *(void *)(a2 + 40))
    {
      *(void *)(a2 + 24) = v32;
    }
    else
    {
      *(unsigned char *)(a2 + 56) = 1;
      unint64_t v32 = v26;
      unint64_t v26 = 0;
    }
    *(void *)(a1 + 128) = v26;
    if (v14) {
      uint64_t v28 = 4 << v14;
    }
    else {
      uint64_t v28 = 0;
    }
LABEL_41:
    unint64_t v18 = v32 + v28;
    if (v32 + v28 <= *(void *)(a2 + 40))
    {
      *(void *)(a2 + 24) = v18;
      unint64_t v27 = v32;
    }
    else
    {
      unint64_t v27 = 0;
      *(unsigned char *)(a2 + 56) = 1;
      unint64_t v18 = v32;
    }
    goto LABEL_44;
  }
  *(void *)(a2 + 32) = v18;
  unint64_t v21 = *(void *)(a2 + 8);
  *(void *)(a2 + 48) = v21 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v22 = -(int)v18 & 0x3FLL;
  unint64_t v20 = v18 + v22;
  if (v18 + v22 <= v21)
  {
    *(void *)(a2 + 16) = v20;
    *(void *)(a2 + 24) = v20;
    if (v22) {
      *(void *)(a2 + 32) = v20;
    }
    *(_DWORD *)(a2 + 64) = 1;
    goto LABEL_31;
  }
  *(void *)(a1 + 112) = 0;
  unint64_t v24 = *(void *)(a2 + 8);
  uint64_t v23 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v23;
  *(void *)(a2 + 48) = v24 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v25 = -(int)v23 & 0x3FLL;
  unint64_t v26 = v23 + v25;
  if (v26 <= v24)
  {
    *(void *)(a2 + 16) = v26;
    *(void *)(a2 + 24) = v26;
    if (v25) {
      *(void *)(a2 + 32) = v26;
    }
    *(_DWORD *)(a2 + 64) = 1;
    goto LABEL_35;
  }
  unint64_t v27 = 0;
  *(void *)(a1 + 128) = 0;
  if (v14) {
    uint64_t v28 = 4 << v14;
  }
  else {
    uint64_t v28 = 0;
  }
  unint64_t v30 = *(void *)(a2 + 8);
  uint64_t v29 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v29;
  *(void *)(a2 + 48) = v30 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v31 = -(int)v29 & 0x3FLL;
  unint64_t v32 = v29 + v31;
  if (v32 <= v30)
  {
    *(void *)(a2 + 16) = v32;
    *(void *)(a2 + 24) = v32;
    if (v31) {
      *(void *)(a2 + 32) = v32;
    }
    *(_DWORD *)(a2 + 64) = 1;
    goto LABEL_41;
  }
LABEL_44:
  *(void *)(a1 + 120) = v27;
  if (*(unsigned char *)(a2 + 56)) {
    return -64;
  }
  if (a5 != 1)
  {
    uint64_t v34 = *(void **)(a2 + 32);
    if ((unint64_t)v34 < v18)
    {
      bzero(v34, v18 - (void)v34);
      unint64_t v18 = *(void *)(a2 + 24);
      uint64_t v34 = *(void **)(a2 + 32);
    }
    if ((unint64_t)v34 < v18) {
      *(void *)(a2 + 32) = v18;
    }
  }
  if (a4 == 1 && (a3[6] - 6) >= 0xFFFFFFFD)
  {
    unint64_t v35 = ((1 << v15) + 63) & 0xFFFFFFFFFFFFFFC0;
    unsigned int v36 = *(_DWORD *)(a2 + 64);
    if (a7 == 1)
    {
      if (!v36)
      {
        unint64_t v38 = *(void *)(a2 + 8);
        uint64_t v37 = *(void *)(a2 + 16);
        *(void *)(a2 + 32) = v37;
        *(void *)(a2 + 48) = v38 & 0xFFFFFFFFFFFFFFC0;
        uint64_t v39 = -(int)v37 & 0x3FLL;
        unint64_t v18 = v37 + v39;
        if (v18 > v38) {
          goto LABEL_71;
        }
        *(void *)(a2 + 16) = v18;
        *(void *)(a2 + 24) = v18;
        if (v39) {
          *(void *)(a2 + 32) = v18;
        }
        *(_DWORD *)(a2 + 64) = 1;
      }
      if (v35)
      {
        unint64_t v40 = (void *)(*(void *)(a2 + 40) - v35);
        if ((unint64_t)v40 >= v18)
        {
          if ((unint64_t)v40 < *(void *)(a2 + 32)) {
            *(void *)(a2 + 32) = v40;
          }
          *(void *)(a2 + 40) = v40;
          unint64_t v42 = *(void *)(a2 + 48);
          if ((unint64_t)v40 < v42)
          {
            size_t v43 = v42 - (void)v40;
            if (v43 >= v35) {
              size_t v44 = ((1 << v15) + 63) & 0xFFFFFFFFFFFFFFC0;
            }
            else {
              size_t v44 = v43;
            }
            bzero(v40, v44);
            *(void *)(a2 + 48) = v40;
          }
        }
        else
        {
          unint64_t v40 = 0;
          *(unsigned char *)(a2 + 56) = 1;
        }
        goto LABEL_82;
      }
LABEL_71:
      unint64_t v40 = 0;
LABEL_82:
      *(void *)(a1 + 56) = v40;
      uint64_t v45 = __ROR8__(*(void *)(a1 + 96), 24) ^ __ROR8__(*(void *)(a1 + 96), 49) ^ *(void *)(a1 + 96);
      unint64_t v46 = 0x9FB21C651E98DF25 * ((((0x9FB21C651E98DF25 * v45) >> 35) + 8) ^ (0x9FB21C651E98DF25 * v45));
      unint64_t v47 = 0x9FB21C651E98DF25
          * (__ROR8__(*(unsigned int *)(a1 + 104), 24) ^ ((unint64_t)*(unsigned int *)(a1 + 104) << 15) ^ *(unsigned int *)(a1 + 104));
      *(void *)(a1 + 96) = v46 ^ (((0x9FB21C651E98DF25 * (((v47 >> 35) + 4) ^ v47)) ^ v46) >> 28) ^ (0x9FB21C651E98DF25 * (((v47 >> 35) + 4) ^ v47));
LABEL_86:
      unsigned int v51 = a3[3];
      if (v51 >= 6) {
        unsigned int v51 = 6;
      }
      if (v51 <= 4) {
        unsigned int v51 = 4;
      }
      *(_DWORD *)(a1 + 52) = a3[2] - v51;
      goto LABEL_91;
    }
    if (v36 <= 1)
    {
      if (!v36)
      {
        unint64_t v49 = *(void *)(a2 + 8);
        uint64_t v48 = *(void *)(a2 + 16);
        *(void *)(a2 + 32) = v48;
        *(void *)(a2 + 48) = v49 & 0xFFFFFFFFFFFFFFC0;
        uint64_t v50 = -(int)v48 & 0x3FLL;
        unint64_t v18 = v48 + v50;
        if (v18 > v49) {
          goto LABEL_84;
        }
        *(void *)(a2 + 16) = v18;
        *(void *)(a2 + 24) = v18;
        if (v50) {
          *(void *)(a2 + 32) = v18;
        }
      }
      *(_DWORD *)(a2 + 64) = 2;
    }
    if (v35)
    {
      unint64_t v41 = (void *)(*(void *)(a2 + 40) - v35);
      if ((unint64_t)v41 >= v18)
      {
        if ((unint64_t)v41 < *(void *)(a2 + 32)) {
          *(void *)(a2 + 32) = v41;
        }
        *(void *)(a2 + 40) = v41;
      }
      else
      {
        unint64_t v41 = 0;
        *(unsigned char *)(a2 + 56) = 1;
      }
      goto LABEL_85;
    }
LABEL_84:
    unint64_t v41 = 0;
LABEL_85:
    *(void *)(a1 + 56) = v41;
    bzero(v41, 1 << v15);
    *(void *)(a1 + 96) = 0;
    goto LABEL_86;
  }
LABEL_91:
  if (a7 != 1 || a3[6] < 7u) {
    goto LABEL_132;
  }
  unsigned int v52 = *(_DWORD *)(a2 + 64);
  if (v52 > 1) {
    goto LABEL_96;
  }
  if (v52)
  {
LABEL_95:
    *(_DWORD *)(a2 + 64) = 2;
LABEL_96:
    unint64_t v53 = *(void *)(a2 + 40) - 1024;
    if (v53 >= *(void *)(a2 + 24))
    {
      if (v53 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v53;
      }
      *(void *)(a2 + 40) = v53;
    }
    else
    {
      unint64_t v53 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    *(void *)(a1 + 144) = v53;
LABEL_102:
    unint64_t v54 = *(void *)(a2 + 40) - 192;
    if (v54 >= *(void *)(a2 + 24))
    {
      if (v54 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v54;
      }
      *(void *)(a2 + 40) = v54;
    }
    else
    {
      unint64_t v54 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    *(void *)(a1 + 152) = v54;
LABEL_108:
    unint64_t v55 = *(void *)(a2 + 40) - 256;
    if (v55 >= *(void *)(a2 + 24))
    {
      if (v55 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v55;
      }
      *(void *)(a2 + 40) = v55;
    }
    else
    {
      unint64_t v55 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    *(void *)(a1 + 160) = v55;
LABEL_114:
    unint64_t v56 = *(void *)(a2 + 40) - 128;
    if (v56 >= *(void *)(a2 + 24))
    {
      if (v56 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v56;
      }
      *(void *)(a2 + 40) = v56;
    }
    else
    {
      unint64_t v56 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    *(void *)(a1 + 168) = v56;
LABEL_120:
    unint64_t v57 = *(void *)(a2 + 40) - 32832;
    if (v57 >= *(void *)(a2 + 24))
    {
      if (v57 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v57;
      }
      *(void *)(a2 + 40) = v57;
    }
    else
    {
      unint64_t v57 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    *(void *)(a1 + 176) = v57;
LABEL_126:
    unint64_t v58 = *(void *)(a2 + 40) - 114752;
    if (v58 >= *(void *)(a2 + 24))
    {
      if (v58 < *(void *)(a2 + 32)) {
        *(void *)(a2 + 32) = v58;
      }
      *(void *)(a2 + 40) = v58;
    }
    else
    {
      unint64_t v58 = 0;
      *(unsigned char *)(a2 + 56) = 1;
    }
    goto LABEL_131;
  }
  unint64_t v61 = *(void *)(a2 + 8);
  uint64_t v60 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v60;
  *(void *)(a2 + 48) = v61 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v62 = -(int)v60 & 0x3FLL;
  unint64_t v63 = v60 + v62;
  if (v63 <= v61)
  {
    *(void *)(a2 + 16) = v63;
    *(void *)(a2 + 24) = v63;
    if (v62) {
      *(void *)(a2 + 32) = v63;
    }
    goto LABEL_95;
  }
  *(void *)(a1 + 144) = 0;
  unint64_t v65 = *(void *)(a2 + 8);
  uint64_t v64 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v64;
  *(void *)(a2 + 48) = v65 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v66 = -(int)v64 & 0x3FLL;
  unint64_t v67 = v64 + v66;
  if (v67 <= v65)
  {
    *(void *)(a2 + 16) = v67;
    *(void *)(a2 + 24) = v67;
    if (v66) {
      *(void *)(a2 + 32) = v67;
    }
    *(_DWORD *)(a2 + 64) = 2;
    goto LABEL_102;
  }
  *(void *)(a1 + 152) = 0;
  unint64_t v69 = *(void *)(a2 + 8);
  uint64_t v68 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v68;
  *(void *)(a2 + 48) = v69 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v70 = -(int)v68 & 0x3FLL;
  unint64_t v71 = v68 + v70;
  if (v71 <= v69)
  {
    *(void *)(a2 + 16) = v71;
    *(void *)(a2 + 24) = v71;
    if (v70) {
      *(void *)(a2 + 32) = v71;
    }
    *(_DWORD *)(a2 + 64) = 2;
    goto LABEL_108;
  }
  *(void *)(a1 + 160) = 0;
  unint64_t v73 = *(void *)(a2 + 8);
  uint64_t v72 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v72;
  *(void *)(a2 + 48) = v73 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v74 = -(int)v72 & 0x3FLL;
  unint64_t v75 = v72 + v74;
  if (v75 <= v73)
  {
    *(void *)(a2 + 16) = v75;
    *(void *)(a2 + 24) = v75;
    if (v74) {
      *(void *)(a2 + 32) = v75;
    }
    *(_DWORD *)(a2 + 64) = 2;
    goto LABEL_114;
  }
  *(void *)(a1 + 168) = 0;
  unint64_t v77 = *(void *)(a2 + 8);
  uint64_t v76 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v76;
  *(void *)(a2 + 48) = v77 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v78 = -(int)v76 & 0x3FLL;
  unint64_t v79 = v76 + v78;
  if (v79 <= v77)
  {
    *(void *)(a2 + 16) = v79;
    *(void *)(a2 + 24) = v79;
    if (v78) {
      *(void *)(a2 + 32) = v79;
    }
    *(_DWORD *)(a2 + 64) = 2;
    goto LABEL_120;
  }
  unint64_t v58 = 0;
  *(void *)(a1 + 176) = 0;
  unint64_t v81 = *(void *)(a2 + 8);
  uint64_t v80 = *(void *)(a2 + 16);
  *(void *)(a2 + 32) = v80;
  *(void *)(a2 + 48) = v81 & 0xFFFFFFFFFFFFFFC0;
  uint64_t v82 = -(int)v80 & 0x3FLL;
  unint64_t v83 = v80 + v82;
  if (v83 <= v81)
  {
    *(void *)(a2 + 16) = v83;
    *(void *)(a2 + 24) = v83;
    if (v82) {
      *(void *)(a2 + 32) = v83;
    }
    *(_DWORD *)(a2 + 64) = 2;
    goto LABEL_126;
  }
LABEL_131:
  *(void *)(a1 + 184) = v58;
LABEL_132:
  long long v59 = *(_OWORD *)a3;
  *(_OWORD *)(a1 + 268) = *(_OWORD *)(a3 + 3);
  *(_OWORD *)(a1 + 256) = v59;
  if (*(unsigned char *)(a2 + 56)) {
    return -64;
  }
  else {
    return 0;
  }
}

unint64_t sub_1DD29BCC4@<X0>(void *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, char *a5@<X4>, uint64_t a6@<X5>, unsigned int a7@<W6>, void *a8@<X7>, uint64_t a9@<X8>, char *a10, unint64_t a11)
{
  std::string __dst = (_WORD *)(a4 + 2224);
  unint64_t v18 = (unsigned __int8 *)a1[4];
  uint64_t v31 = (unsigned __int8 *)a1[5];
  unint64_t v32 = (unsigned __int8 *)a1[6];
  *(_OWORD *)a9 = 0u;
  *(_OWORD *)(a9 + 16) = 0u;
  *(void *)(a9 + 32) = 0;
  sub_1DD298908((uint64_t)a1);
  *(_DWORD *)(a9 + 32) = 0;
  unsigned int v40 = 35;
  unint64_t v19 = sub_1DD295A98(a8, &v40, v18, a2, a10, a11);
  *(_DWORD *)(a4 + 3548) = *(_DWORD *)(a3 + 3548);
  uint64_t v34 = a3;
  a3 += 2224;
  unsigned int v35 = a7;
  int v20 = sub_1DD29E188((_DWORD *)(a4 + 3548), (unsigned int *)a8, v40, v19, a2, 9u, (unsigned __int16 *)a3, word_1DD3212C8, 6, 1, a7);
  *(_DWORD *)a9 = v20;
  unint64_t result = sub_1DD29E3D8(a5, a6 - (void)a5, __dst, 9u, v20, (unsigned int *)a8, v40, v18, a2, (__int16 *)word_1DD3212C8, 6, 35, (const void *)a3, 0x524uLL, (__int16 *)a10, a11);
  if (result > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_11;
  }
  unint64_t v30 = a2;
  if (v20 == 2) {
    *(void *)(a9 + 24) = result;
  }
  uint64_t v22 = &a5[result];
  unsigned int v39 = 31;
  unint64_t v23 = sub_1DD295A98(a8, &v39, v32, a2, a10, a11);
  unsigned int v24 = v39;
  *(_DWORD *)(a4 + 3540) = *(_DWORD *)(v34 + 3540);
  int v25 = sub_1DD29E188((_DWORD *)(a4 + 3540), (unsigned int *)a8, v24, v23, a2, 8u, (unsigned __int16 *)v34, word_1DD321310, 5, v24 < 0x1D, v35);
  *(_DWORD *)(a9 + 4) = v25;
  uint64_t v26 = a4;
  unint64_t result = sub_1DD29E3D8(v22, a6 - (void)v22, (_WORD *)a4, 8u, v25, (unsigned int *)a8, v39, v32, v30, (__int16 *)word_1DD321310, 5, 28, (const void *)v34, 0x304uLL, (__int16 *)a10, a11);
  if (result > 0xFFFFFFFFFFFFFF88)
  {
LABEL_11:
    *(void *)(a9 + 16) = result;
  }
  else
  {
    uint64_t v33 = (_WORD *)(a4 + 772);
    if (v25 == 2) {
      *(void *)(a9 + 24) = result;
    }
    unint64_t v27 = &v22[result];
    unsigned int v38 = 52;
    unint64_t v28 = sub_1DD295A98(a8, &v38, v31, v30, a10, a11);
    *(_DWORD *)(v26 + 3544) = *(_DWORD *)(v34 + 3544);
    int v29 = sub_1DD29E188((_DWORD *)(v26 + 3544), (unsigned int *)a8, v38, v28, v30, 9u, (unsigned __int16 *)(v34 + 772), word_1DD32134A, 6, 1, v35);
    *(_DWORD *)(a9 + 8) = v29;
    unint64_t result = sub_1DD29E3D8(v27, a6 - (void)v27, v33, 9u, v29, (unsigned int *)a8, v38, v31, v30, (__int16 *)word_1DD32134A, 6, 52, (const void *)(v34 + 772), 0x5ACuLL, (__int16 *)a10, a11);
    if (result > 0xFFFFFFFFFFFFFF88)
    {
      *(void *)(a9 + 16) = result;
    }
    else
    {
      if (v29 == 2) {
        *(void *)(a9 + 24) = result;
      }
      *(void *)(a9 + 16) = &v27[result] - a5;
    }
  }
  return result;
}

uint32x2_t *sub_1DD29C034(uint32x2_t *result, void *a2, _DWORD *a3, int a4, int a5)
{
  uint32x2_t v5 = result[1];
  if ((a5 - v5.i32[0]) >= 0xE0000001)
  {
    unsigned int v6 = a3[7];
    unsigned int v7 = 1 << a3[1];
    unsigned int v8 = 1 << (a3[2] - (v6 > 5));
    unsigned int v9 = (v8 - 1) & (a4 - v5.i32[0]);
    if (v8 <= 2) {
      int v10 = 2;
    }
    else {
      int v10 = 1 << (a3[2] - (v6 > 5));
    }
    if (v9 >= 2) {
      int v10 = 0;
    }
    if (v8 > v7) {
      unsigned int v7 = 1 << (a3[2] - (v6 > 5));
    }
    uint64_t v11 = a4 - v5.i32[0] - (v7 + v9) - v10;
    uint32x2_t v12 = (uint32x2_t)(*(void *)&result[2] + v11);
    result[1] = (uint32x2_t)(*(void *)&v5 + v11);
    result[2] = v12;
    unsigned int v13 = v11 + 2;
    result[3] = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)vdup_n_s32((int)v11 + 2), result[3]), (int8x8_t)0x200000002, (int8x8_t)vsub_s32((int32x2_t)result[3], vdup_n_s32(v11)));
    ++result[4].i32[0];
    unint64_t v14 = a2[2];
    a2[4] = v14;
    int v15 = 1 << a3[3];
    if (v15 >= 0) {
      int v16 = 1 << a3[3];
    }
    else {
      int v16 = v15 + 15;
    }
    if (v15 >= 16)
    {
      int v17 = 0;
      int v18 = 0;
      uint32x2_t v19 = result[14];
      int v20 = v16 >> 4;
      uint32x4_t v21 = (uint32x4_t)vdupq_n_s32(v13);
      int32x4_t v22 = vdupq_n_s32(v11);
      do
      {
        for (uint64_t i = 0; i != 64; i += 16)
          *(int8x16_t *)(*(void *)&v19 + 4 * v18 + i) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v19 + 4 * v18 + i), v22), (int8x16_t)vcgtq_u32(v21, *(uint32x4_t *)(*(void *)&v19+ 4 * v18+ i)));
        v18 += 16;
        ++v17;
      }
      while (v17 != v20);
    }
    if (result[17].i32[1] || v6 != 1 && (v6 - 3 > 2 || a3[36] != 1))
    {
      int v24 = 1 << a3[2];
      uint32x2_t v25 = result[16];
      int v26 = v24 / 16;
      if (v6 == 6)
      {
        if (v24 >= 16)
        {
          int v27 = 0;
          int v28 = 0;
          uint32x4_t v29 = (uint32x4_t)vdupq_n_s32(v13);
          int32x4_t v30 = vdupq_n_s32(v11);
          v31.i64[0] = 0x100000001;
          v31.i64[1] = 0x100000001;
          do
          {
            uint64_t v32 = 0;
            uint64_t v33 = *(void *)&v25 + 4 * v28;
            do
            {
              int32x4_t v34 = *(int32x4_t *)(v33 + v32);
              int32x4_t v35 = vceqq_s32(v34, v31);
              *(int32x4_t *)(v33 + v32) = vsubq_s32((int32x4_t)vbicq_s8(vbicq_s8((int8x16_t)vsubq_s32(v34, v30), (int8x16_t)vcgtq_u32(v29, (uint32x4_t)v34)), (int8x16_t)v35), v35);
              v32 += 16;
            }
            while (v32 != 64);
            v28 += 16;
            ++v27;
          }
          while (v27 != v26);
        }
      }
      else if (v24 >= 16)
      {
        int v36 = 0;
        int v37 = 0;
        uint32x4_t v38 = (uint32x4_t)vdupq_n_s32(v13);
        int32x4_t v39 = vdupq_n_s32(v11);
        do
        {
          for (uint64_t j = 0; j != 64; j += 16)
            *(int8x16_t *)(*(void *)&v25 + 4 * v37 + j) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v25+ 4 * v37+ j), v39), (int8x16_t)vcgtq_u32(v38, *(uint32x4_t *)(*(void *)&v25+ 4 * v37+ j)));
          v37 += 16;
          ++v36;
        }
        while (v36 != v26);
      }
    }
    __int32 v41 = result[6].i32[0];
    if (v41)
    {
      int v42 = 1 << v41;
      int v43 = v42 >= 0 ? v42 : v42 + 15;
      if (v42 >= 16)
      {
        int v44 = 0;
        int v45 = 0;
        uint32x2_t v46 = result[15];
        int v47 = v43 >> 4;
        uint32x4_t v48 = (uint32x4_t)vdupq_n_s32(v13);
        int32x4_t v49 = vdupq_n_s32(v11);
        do
        {
          for (uint64_t k = 0; k != 64; k += 16)
            *(int8x16_t *)(*(void *)&v46 + 4 * v45 + k) = vbicq_s8((int8x16_t)vsubq_s32(*(int32x4_t *)(*(void *)&v46+ 4 * v45+ k), v49), (int8x16_t)vcgtq_u32(v48, *(uint32x4_t *)(*(void *)&v46+ 4 * v45+ k)));
          v45 += 16;
          ++v44;
        }
        while (v44 != v47);
      }
    }
    unint64_t v51 = a2[3];
    if (v14 < v51) {
      a2[4] = v51;
    }
    unsigned int v52 = result[5].u32[1];
    BOOL v53 = v52 >= v11;
    __int32 v54 = v52 - v11;
    if (!v53) {
      __int32 v54 = 0;
    }
    result[5].i32[0] = 0;
    result[5].i32[1] = v54;
    result[31] = 0;
  }
  return result;
}

uint64_t sub_1DD29C2F4(uint64_t a1, char *a2, size_t a3, char *a4, unint64_t a5, int a6)
{
  unint64_t v12 = sub_1DD29C440(a1, a4, a5);
  int v13 = 4 * (v12 == 1);
  if (v12 >= 0xFFFFFFFFFFFFFF89) {
    int v13 = 1;
  }
  if (v13 == 4)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v14 = v12;
    if (v13) {
      return v14;
    }
    int v15 = (int8x16_t *)(a1 + 3176);
    if (*(_DWORD *)(a1 + 888))
    {
      sub_1DD29D5DC(a1);
      uint64_t v14 = 0;
      *int v15 = vextq_s8(*v15, *v15, 8uLL);
      return v14;
    }
    unint64_t v18 = sub_1DD29D2B8((uint64_t *)(a1 + 928), *(char **)(a1 + 3176), *(char **)(a1 + 3184), (_DWORD *)(a1 + 224), (uint64_t)a2, a3, a5, *(char **)(a1 + 3496), *(_DWORD *)(a1 + 8));
    uint64_t v14 = v18;
    if (a6 && !*(_DWORD *)(a1 + 920) && v18 <= 0x18 && sub_1DD29C834(a4, a5))
    {
      *a2 = *a4;
      uint64_t v14 = 1;
    }
    else if ((unint64_t)(v14 - 2) <= 0xFFFFFFFFFFFFFF86)
    {
      *int v15 = vextq_s8(*v15, *v15, 8uLL);
    }
  }
  uint64_t v16 = *(void *)(a1 + 3176);
  if (*(_DWORD *)(v16 + 5604) == 2) {
    *(_DWORD *)(v16 + 5604) = 1;
  }
  return v14;
}

uint64_t sub_1DD29C440(uint64_t a1, char *a2, unint64_t a3)
{
  if (a3 <= 6)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 252);
    unsigned int v6 = (uint64_t *)(a1 + 3136);
    if (v5 < 7) {
      sub_1DD2CFCCC(v6, a3, *(_DWORD *)(a1 + 244));
    }
    else {
      sub_1DD2CFD70((uint64_t)v6, a3);
    }
    return 1;
  }
  *(void *)(a1 + 952) = *(void *)(a1 + 944);
  *(void *)(a1 + 936) = *(void *)(a1 + 928);
  *(_DWORD *)(a1 + 1000) = 0;
  uint64_t v8 = *(void *)(a1 + 3176);
  *(void *)(a1 + 3424) = v8;
  *(_DWORD *)(a1 + 3432) = *(_DWORD *)(a1 + 296);
  unsigned int v9 = a2 - *(_DWORD *)(a1 + 3200);
  int v10 = *(_DWORD *)(a1 + 3236);
  if (v10 + 384 < v9)
  {
    unsigned int v11 = v9 - v10 - 384;
    if (v11 >= 0xC0) {
      unsigned int v11 = 192;
    }
    *(_DWORD *)(a1 + 3236) = v9 - v11;
  }
  if (*(_DWORD *)(a1 + 3220) >= *(_DWORD *)(a1 + 3216))
  {
    uint64_t v14 = *(void *)(a1 + 3440);
    if (v14)
    {
      if (*(_DWORD *)(v14 + 140)) {
        uint64_t v12 = 3;
      }
      else {
        uint64_t v12 = 2;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 1;
  }
  uint64_t v15 = 0;
  uint64_t v16 = *(void *)(a1 + 3184);
  uint64_t v17 = v8 + 5616;
  do
  {
    *(_DWORD *)(v16 + 5616 + v15) = *(_DWORD *)(v17 + v15);
    v15 += 4;
  }
  while (v15 != 12);
  if (*(void *)(a1 + 3144) < *(void *)(a1 + 3160))
  {
    if (!*(_DWORD *)(a1 + 408))
    {
      unint64_t v18 = (uint64_t *)(a1 + 3136);
      uint32x2_t v19 = (void *)(v16 + 5616);
      int v20 = *(_DWORD *)(a1 + 368);
LABEL_22:
      size_t v21 = sub_1DD2CFDE4(v18, a1 + 3192, a1 + 928, v19, v20, (unint64_t)a2, a3);
      goto LABEL_53;
    }
    return -41;
  }
  if (*(_DWORD *)(a1 + 320) == 1)
  {
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    if (!*(_DWORD *)(a1 + 408))
    {
      uint64_t v25 = *(void *)(a1 + 3128);
      uint64_t v45 = *(void *)(a1 + 3120);
      uint64_t v49 = v25;
      unint64_t v13 = sub_1DD2CF258((uint32x2_t *)(a1 + 1008), &v45, (_DWORD *)(a1 + 320), (uint64_t)a2, a3);
      if (v13 >= 0xFFFFFFFFFFFFFF89) {
        return v13;
      }
      uint32x2_t v19 = (void *)(*(void *)(a1 + 3184) + 5616);
      int v20 = *(_DWORD *)(a1 + 368);
      unint64_t v18 = &v45;
      goto LABEL_22;
    }
    return -41;
  }
  if (!*(_DWORD *)(a1 + 408))
  {
    uint64_t v26 = *(int *)(a1 + 252);
    unsigned int v27 = v26 - 3;
    BOOL v28 = *(_DWORD *)(a1 + 368) != 1 || v27 > 2;
    uint32x4_t v29 = &off_1F3877BC8[10 * v12] + v26;
    if (!v28) {
      uint32x4_t v29 = &off_1F3877D08[3 * v12] + v27;
    }
    int32x4_t v30 = *v29;
    *(void *)(a1 + 3480) = 0;
    size_t v21 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, char *, unint64_t))v30)(a1 + 3192, a1 + 928, v16 + 5616, a2, a3);
    goto LABEL_53;
  }
  uint64_t v22 = (*(uint64_t (**)(void, void, void, char *, unint64_t, void, void, void, uint64_t))(a1 + 5216))(*(void *)(a1 + 5208), *(void *)(a1 + 5224), *(void *)(a1 + 5232), a2, a3, 0, 0, *(unsigned int *)(a1 + 268), 1 << *(_DWORD *)(a1 + 228));
  unint64_t v23 = *(void *)(a1 + 5232);
  if (v22 - 1 >= v23) {
    goto LABEL_30;
  }
  unint64_t v13 = v22;
  uint64_t v24 = *(void *)(a1 + 5224);
  if (*(_DWORD *)(v24 + 16 * (v22 - 1)) | *(_DWORD *)(v24 + 16 * (v22 - 1) + 8))
  {
    if (v22 == v23)
    {
LABEL_30:
      unint64_t v13 = -106;
LABEL_46:
      if (!*(_DWORD *)(a1 + 404)) {
        return v13;
      }
      uint64_t v38 = *(int *)(a1 + 252);
      unsigned int v39 = v38 - 3;
      BOOL v40 = *(_DWORD *)(a1 + 368) != 1 || v39 > 2;
      __int32 v41 = &off_1F3877BC8[10 * v12] + v38;
      if (!v40) {
        __int32 v41 = &off_1F3877D08[3 * v12] + v39;
      }
      int v42 = *v41;
      *(void *)(a1 + 3480) = 0;
      size_t v21 = ((uint64_t (*)(uint64_t, uint64_t, uint64_t, char *, unint64_t))v42)(a1 + 3192, a1 + 928, *(void *)(a1 + 3184) + 5616, a2, a3);
LABEL_53:
      size_t v43 = v21;
      memcpy(*(void **)(a1 + 952), &a2[a3 - v21], v21);
      unint64_t v13 = 0;
      *(void *)(a1 + 952) += v43;
      return v13;
    }
    int32x4_t v31 = (void *)(v24 + 16 * v22);
    *int32x4_t v31 = 0;
    v31[1] = 0;
    unint64_t v13 = v22 + 1;
  }
  if (v13 > 0xFFFFFFFFFFFFFF88) {
    goto LABEL_46;
  }
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t v32 = *(void *)(a1 + 5224);
  if (!v13) {
    goto LABEL_55;
  }
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  int32x4_t v35 = (unsigned int *)(v32 + 8);
  unint64_t v36 = v13;
  do
  {
    v33 += *(v35 - 1);
    unsigned int v37 = *v35;
    v35 += 4;
    v34 += v37;
    --v36;
  }
  while (v36);
  if (v34 + v33 > a3) {
    return -107;
  }
LABEL_55:
  unint64_t v13 = sub_1DD29A2C8(a1, (unsigned int *)&v45, v32, v13, a2, a3, *(_DWORD *)(a1 + 424));
  if (v13 <= 0xFFFFFFFFFFFFFF88)
  {
    unint64_t v13 = 0;
    *(void *)(a1 + 3480) = 0;
  }
  return v13;
}

uint64_t sub_1DD29C834(void *a1, unint64_t a2)
{
  if (a2 == 1) {
    return 1;
  }
  unint64_t v2 = a2 & 0x1F;
  if ((a2 & 0x1F) != 0)
  {
    uint64_t v3 = (char *)a1 + v2;
    unsigned int v4 = (char *)a1 + 1;
    unsigned int v5 = a1;
    if (v2 >= 9)
    {
      unint64_t v6 = *(void *)((char *)a1 + 1) ^ *a1;
      if (v6)
      {
        unint64_t v7 = __clz(__rbit64(v6)) >> 3;
        goto LABEL_21;
      }
      uint64_t v8 = 0;
      while (1)
      {
        unsigned int v9 = &a1[v8];
        unsigned int v4 = (char *)&a1[v8 + 1] + 1;
        if (v4 >= v3 - 7) {
          break;
        }
        ++v8;
        unint64_t v10 = *(void *)v4 ^ v9[1];
        if (v10)
        {
          unint64_t v7 = v8 * 8 + (__clz(__rbit64(v10)) >> 3);
          goto LABEL_21;
        }
      }
      unsigned int v5 = v9 + 1;
    }
    if (v4 < v3 - 3 && *v5 == *(_DWORD *)v4)
    {
      v4 += 4;
      ++v5;
    }
    if (v4 < v3 - 1 && *(unsigned __int16 *)v5 == *(unsigned __int16 *)v4)
    {
      v4 += 2;
      unsigned int v5 = (_DWORD *)((char *)v5 + 2);
    }
    if (v4 < v3 && *(unsigned __int8 *)v5 == *v4) {
      ++v4;
    }
    unint64_t v7 = v4 - ((char *)a1 + 1);
LABEL_21:
    if (v7 != v2 - 1) {
      return 0;
    }
  }
  if (a2 < 0x20) {
    return 1;
  }
  uint64_t v12 = 0x101010101010101 * *(unsigned __int8 *)a1;
  unint64_t v13 = (char *)a1 + v2;
  uint64_t result = 1;
LABEL_25:
  unint64_t v14 = 0;
  while (*(void *)&v13[v14] == v12)
  {
    BOOL v15 = v14 > 0x17;
    v14 += 8;
    if (v15)
    {
      v2 += 32;
      v13 += 32;
      if (v2 != a2) {
        goto LABEL_25;
      }
      return result;
    }
  }
  return 0;
}

uint64_t sub_1DD29C998(uint64_t a1, uint64_t a2, uint64_t *a3, int *a4, uint64_t a5, unint64_t a6, void *a7, size_t a8, int a9, int a10)
{
  uint64_t v47 = *a3;
  int v48 = *((_DWORD *)a3 + 2);
  if (a10)
  {
    uint64_t v16 = *(void *)a2;
    unint64_t v17 = *(void *)(a2 + 8) - *(void *)a2;
    unint64_t v18 = v17 >> 3;
    if (*(_DWORD *)(a2 + 72) == 1) {
      LODWORD(v18) = *(_DWORD *)(a2 + 76);
    }
    if ((v17 >> 3))
    {
      uint32x2_t v19 = (_DWORD *)a3 + 1;
      int v20 = a3 + 1;
      uint64_t v21 = (v17 >> 3);
      unint64_t v18 = v18;
      do
      {
        BOOL v23 = v18-- != 0 && *(_WORD *)(v16 + 4) == 0;
        unsigned int v24 = *(_DWORD *)v16;
        unsigned int v25 = *(_DWORD *)v16 - 1;
        if (v25 > 2)
        {
          unsigned int v29 = *(_DWORD *)v16;
        }
        else
        {
          unsigned int v26 = v25 + v23;
          if (v25 + v23 == 3)
          {
            int v27 = *(_DWORD *)a3 - 1;
            int v28 = *a4 - 1;
          }
          else
          {
            int v27 = *((_DWORD *)a3 + v26);
            int v28 = a4[v26];
          }
          unsigned int v29 = *(_DWORD *)v16;
          if (v27 == v28) {
            goto LABEL_18;
          }
          unsigned int v29 = v28 + 3;
          *(_DWORD *)uint64_t v16 = v28 + 3;
        }
        if (v29 >= 4)
        {
          *(uint64_t *)((char *)a3 + 4) = *a3;
          int v30 = v29 - 3;
          goto LABEL_26;
        }
LABEL_18:
        unsigned int v31 = v29 - !v23;
        if (!v31) {
          goto LABEL_27;
        }
        if (v31 == 3)
        {
          int v32 = *(_DWORD *)a3;
          int v30 = *(_DWORD *)a3 - 1;
        }
        else
        {
          int v30 = *((_DWORD *)a3 + v31);
          int v32 = *(_DWORD *)a3;
        }
        if (v31 <= 1) {
          uint64_t v33 = a3 + 1;
        }
        else {
          uint64_t v33 = (_DWORD *)a3 + 1;
        }
        _DWORD *v20 = *v33;
        *uint32x2_t v19 = v32;
LABEL_26:
        *(_DWORD *)a3 = v30;
LABEL_27:
        if (v24 >= 4)
        {
          *(void *)(a4 + 1) = *(void *)a4;
          int v34 = v24 - 3;
LABEL_37:
          *a4 = v34;
          goto LABEL_38;
        }
        unsigned int v35 = v25 + v23;
        if (v25 + v23)
        {
          if (v35 == 3)
          {
            int v36 = *a4;
            int v34 = *a4 - 1;
          }
          else
          {
            int v34 = a4[v35];
            int v36 = *a4;
          }
          if (v35 <= 1) {
            unsigned int v37 = a4 + 2;
          }
          else {
            unsigned int v37 = a4 + 1;
          }
          a4[2] = *v37;
          a4[1] = v36;
          goto LABEL_37;
        }
LABEL_38:
        v16 += 8;
        --v21;
      }
      while (v21);
    }
  }
  size_t v38 = a6 - 3;
  if (a6 < 3) {
    return -70;
  }
  unint64_t v40 = sub_1DD29D2B8((uint64_t *)a2, *(char **)(a1 + 3176), *(char **)(a1 + 3184), (_DWORD *)(a1 + 224), a5 + 3, v38, a8, *(char **)(a1 + 3496), *(_DWORD *)(a1 + 8));
  unint64_t v39 = v40;
  if (v40 > 0xFFFFFFFFFFFFFF88) {
    return v39;
  }
  if (v40 <= 0x18 && !*(_DWORD *)(a1 + 920) && sub_1DD29C834(a7, a8)) {
    unint64_t v39 = 1;
  }
  __int32 v41 = (int8x16_t *)(a1 + 3176);
  if (*(_DWORD *)(a1 + 888))
  {
    sub_1DD29D5DC(a1);
    unint64_t v39 = 0;
    int8x16_t *v41 = vextq_s8(*v41, *v41, 8uLL);
    return v39;
  }
  if (v39 == 1)
  {
    if (a6 < 4) {
      return -70;
    }
    char v44 = *(unsigned char *)a7;
    int v45 = a9 + 8 * a8 + 2;
    *(_WORD *)a5 = v45;
    *(unsigned char *)(a5 + 2) = BYTE2(v45);
    *(unsigned char *)(a5 + 3) = v44;
    *a3 = v47;
    *((_DWORD *)a3 + 2) = v48;
    unint64_t v39 = 4;
  }
  else
  {
    if (!v39)
    {
      unint64_t v39 = a8 + 3;
      if (a8 + 3 <= a6)
      {
        int v43 = a9 + 8 * a8;
        *(_WORD *)a5 = v43;
        *(unsigned char *)(a5 + 2) = BYTE2(v43);
        memcpy((void *)(a5 + 3), a7, a8);
        if (v39 > 0xFFFFFFFFFFFFFF88) {
          return v39;
        }
        *a3 = v47;
        *((_DWORD *)a3 + 2) = v48;
        goto LABEL_57;
      }
      return -70;
    }
    int8x16_t *v41 = vextq_s8(*v41, *v41, 8uLL);
    int v46 = a9 + 8 * v39 + 4;
    *(_WORD *)a5 = v46;
    *(unsigned char *)(a5 + 2) = BYTE2(v46);
    v39 += 3;
  }
LABEL_57:
  if (*(_DWORD *)(v41->i64[0] + 5604) == 2) {
    *(_DWORD *)(v41->i64[0] + 5604) = 1;
  }
  return v39;
}

uint64_t sub_1DD29CD00(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7 = result;
  *(_OWORD *)uint64_t result = *(_OWORD *)a2;
  long long v8 = *((_OWORD *)a2 + 1);
  long long v9 = *((_OWORD *)a2 + 2);
  long long v10 = *((_OWORD *)a2 + 4);
  *(_OWORD *)(result + 48) = *((_OWORD *)a2 + 3);
  *(_OWORD *)(result + 64) = v10;
  *(_OWORD *)(result + 16) = v8;
  *(_OWORD *)(result + 32) = v9;
  if (a3)
  {
    *(void *)(result + 8) = *a2 + 8 * a3;
    uint64_t result = sub_1DD29CDF8(result);
    *(void *)(v7 + 16) += result;
  }
  if (*((_DWORD *)a2 + 18))
  {
    unint64_t v11 = *((unsigned int *)a2 + 19);
    if (v11 < a3 || v11 > a4) {
      *(_DWORD *)(v7 + 72) = 0;
    }
    else {
      *(_DWORD *)(v7 + 76) -= a3;
    }
  }
  *(void *)uint64_t v7 = *a2 + 8 * a3;
  uint64_t v12 = *a2;
  *(void *)(v7 + 8) = *a2 + 8 * a4;
  if (a4 != (a2[1] - v12) >> 3)
  {
    uint64_t result = sub_1DD29CDF8(v7);
    *(void *)(v7 + 24) = *(void *)(v7 + 16) + result;
  }
  unint64_t v13 = *(void *)(v7 + 40) + a3;
  *(void *)(v7 + 32) += a3;
  *(void *)(v7 + 40) = v13;
  *(void *)(v7 + 48) += a3;
  return result;
}

uint64_t sub_1DD29CDF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  uint64_t v2 = v1 - *(void *)a1;
  if (v1 == *(void *)a1) {
    return 0;
  }
  uint64_t v3 = 0;
  unint64_t v4 = v2 >> 3;
  uint64_t v5 = *(unsigned int *)(a1 + 76);
  if (v4 <= 1) {
    unint64_t v4 = 1;
  }
  unint64_t v6 = (unsigned __int16 *)(*(void *)a1 + 4);
  do
  {
    unsigned int v7 = *v6;
    v6 += 4;
    v3 += v7;
    if (!v5 && *(_DWORD *)(a1 + 72) == 1) {
      v3 += 0x10000;
    }
    --v5;
    --v4;
  }
  while (v4);
  return v3;
}

unint64_t sub_1DD29CE54(unint64_t result, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t *a5)
{
  if (a3 - a2 >= 0x12C)
  {
    unint64_t v8 = a2;
    long long v9 = (void *)result;
    unint64_t v17 = (void *)(a4 + 3712);
    long long v10 = (void *)(a4 + 3792);
    unint64_t v11 = (void *)(a4 + 3872);
    unint64_t v12 = *(void *)(result + 8);
    do
    {
      if (v12 > 0xC3) {
        break;
      }
      unint64_t v13 = (v8 + a3) >> 1;
      sub_1DD29CD00((uint64_t)v17, a5, v8, a3);
      sub_1DD29CD00((uint64_t)v10, a5, v8, v13);
      sub_1DD29CD00((uint64_t)v11, a5, v13, a3);
      unint64_t v14 = sub_1DD29CFA8(v17, a4);
      unint64_t v15 = sub_1DD29CFA8(v10, a4);
      uint64_t result = sub_1DD29CFA8(v11, a4);
      if (v14 > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (v15 > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (result > 0xFFFFFFFFFFFFFF88) {
        break;
      }
      if (result + v15 >= v14) {
        break;
      }
      uint64_t result = sub_1DD29CE54(v9, v8, (v8 + a3) >> 1, a4, a5);
      uint64_t v16 = v9[1];
      *(_DWORD *)(*v9 + 4 * v16) = v13;
      unint64_t v12 = v16 + 1;
      v9[1] = v16 + 1;
      unint64_t v8 = (v8 + a3) >> 1;
    }
    while (a3 - v13 > 0x12B);
  }
  return result;
}

unint64_t sub_1DD29CFA8(void *a1, uint64_t a2)
{
  unint64_t result = sub_1DD298A40(a1, *(char **)(a2 + 3176), *(void **)(a2 + 3184), (_DWORD *)(a2 + 224), a2 + 4896, *(void **)(a2 + 3496), 0x22D8uLL);
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v5 = (unsigned int *)a1[2];
    unint64_t v6 = a1[3] - (void)v5;
    unsigned int v7 = (unsigned __int8 *)a1[5];
    unint64_t v8 = (unsigned __int8 *)a1[6];
    long long v9 = (unsigned __int8 *)a1[4];
    uint64_t v10 = a1[1] - *a1;
    unint64_t v11 = *(unsigned __int16 **)(a2 + 3184);
    unint64_t v12 = *(unsigned int **)(a2 + 3496);
    int v13 = *(_DWORD *)(a2 + 4896);
    int v24 = 255;
    uint64_t v14 = 3;
    if (v6 > 0x3FF) {
      uint64_t v14 = 4;
    }
    if ((v6 & 0xFFFFFFFFFFFFC000) != 0) {
      uint64_t v15 = v14 + 1;
    }
    else {
      uint64_t v15 = v14;
    }
    BOOL v23 = v7;
    if ((v13 - 2) < 2)
    {
      if ((unint64_t)sub_1DD295D84(v12, (unsigned int *)&v24, v5, v6, (char *)v12, 0x22D8uLL) <= 0xFFFFFFFFFFFFFF88)
      {
        unint64_t v16 = sub_1DD296948((uint64_t)v11, v12, v24);
        if (v13 == 2) {
          v16 += *(void *)(a2 + 5032);
        }
        unint64_t v17 = v16 + 6;
        if (v6 < 0x100) {
          unint64_t v17 = v16;
        }
        unint64_t v6 = v15 + v17;
      }
    }
    else if (v13)
    {
      unint64_t v6 = v13 == 1;
    }
    unint64_t v18 = sub_1DD29D1B0(*(_DWORD *)(a2 + 5044), v8, v10 >> 3, 0x1Fu, v11 + 1032, 0, word_1DD321310, 5, v12);
    unint64_t v19 = sub_1DD29D1B0(*(_DWORD *)(a2 + 5040), v9, v10 >> 3, 0x23u, v11 + 2144, (uint64_t)&unk_1DD3213B4, word_1DD3212C8, 6, v12);
    unint64_t v20 = sub_1DD29D1B0(*(_DWORD *)(a2 + 5048), v23, v10 >> 3, 0x34u, v11 + 1418, (uint64_t)&unk_1DD3213D8, word_1DD32134A, 6, v12);
    uint64_t v21 = 2;
    if ((unint64_t)v10 > 0x3F8) {
      uint64_t v21 = 3;
    }
    uint64_t v22 = 3;
    if ((unint64_t)v10 > 0x3F7F8) {
      uint64_t v22 = 4;
    }
    return v22 + v21 + v6 + v18 + v19 + v20 + *(void *)(a2 + 5192);
  }
  return result;
}

unint64_t sub_1DD29D1B0(int a1, unsigned __int8 *a2, int64_t a3, unsigned int a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, char a8, void *a9)
{
  uint64_t v14 = a2;
  unsigned int v20 = a4;
  sub_1DD295A98(a9, &v20, a2, a3, (char *)a9, 0x22D8uLL);
  if (a1 == 1) {
    goto LABEL_8;
  }
  if (!a1)
  {
    unint64_t v16 = sub_1DD29E12C(a7, a8, (int *)a9, v20);
    goto LABEL_6;
  }
  if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_8:
    unint64_t v16 = 0;
    goto LABEL_9;
  }
  unint64_t v16 = sub_1DD29E098(a5, (unsigned int *)a9, v20);
LABEL_6:
  if (v16 > 0xFFFFFFFFFFFFFF88) {
    return 10 * a3;
  }
LABEL_9:
  if (a3 >= 1)
  {
    unint64_t v18 = &v14[a3];
    do
    {
      unint64_t v19 = v14;
      if (a6) {
        unint64_t v19 = (unsigned __int8 *)(a6 + *v14);
      }
      v16 += *v19;
      ++v14;
    }
    while (v14 < v18);
  }
  return v16 >> 3;
}

unint64_t sub_1DD29D2B8(uint64_t *a1, char *__src, char *__dst, _DWORD *a4, uint64_t a5, size_t a6, size_t a7, char *a8, int a9)
{
  size_t v9 = a6;
  unsigned int v15 = a4[7];
  uint64_t v16 = *a1;
  uint64_t v17 = a1[1];
  unint64_t v18 = (unsigned __int8 *)a1[2];
  size_t v19 = a1[3] - (void)v18;
  unsigned int v20 = a8 + 212;
  uint64_t v54 = v16;
  unint64_t v21 = v17 - *a1;
  unint64_t v51 = (v17 - v16) >> 3;
  int v22 = v17 == v16 || v19 / ((v17 - v16) >> 3) > 0x13;
  int v23 = a4[18];
  uint64_t v50 = a4;
  uint64_t v52 = v17;
  unint64_t v53 = v21;
  if (v23 == 1) {
    goto LABEL_9;
  }
  if (v23 == 2)
  {
    BOOL v24 = 1;
    goto LABEL_10;
  }
  if (v15 != 1) {
LABEL_9:
  }
    BOOL v24 = 0;
  else {
    BOOL v24 = a4[6] != 0;
  }
LABEL_10:
  uint64_t v25 = a1[5];
  uint64_t v55 = a1[6];
  uint64_t v26 = a1[4];
  unint64_t result = sub_1DD29DD68(a5, a6, v18, v19, (int)a8 + 212, 8708, __src, __dst, v15, v24, v22, a9);
  size_t v28 = a7;
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    uint64_t v29 = v26;
    uint64_t v30 = a5 + v9;
    unsigned int v31 = (unsigned char *)(a5 + result);
    if ((uint64_t)(v9 - result) < 4)
    {
      if (a7 <= v9) {
        return 0;
      }
      else {
        return -70;
      }
    }
    size_t v48 = v9;
    int v32 = __dst;
    uint64_t v33 = __dst + 2064;
    if (v53 > 0x3FF)
    {
      unsigned int v35 = __src;
      if (v53 >> 11 > 0x7E)
      {
        *unsigned int v31 = -1;
        *(_WORD *)(v31 + 1) = (v53 >> 3) - 32512;
        int v34 = v31 + 3;
      }
      else
      {
        *unsigned int v31 = BYTE1(v51) ^ 0x80;
        v31[1] = v53 >> 3;
        int v34 = v31 + 2;
      }
    }
    else
    {
      *unsigned int v31 = v53 >> 3;
      int v34 = v31 + 1;
      unsigned int v35 = __src;
    }
    uint64_t v36 = v29;
    uint64_t v37 = v55;
    if (v52 == v54)
    {
      memcpy(v33, v35 + 2064, 0xDE0uLL);
LABEL_27:
      unint64_t result = (unint64_t)&v34[-a5];
      if (v34 == (unsigned char *)a5) {
        return result;
      }
      goto LABEL_28;
    }
    uint64_t v56 = v25;
    uint64_t v60 = 0;
    long long v58 = 0u;
    long long v59 = 0u;
    uint64_t v47 = v20;
    size_t v38 = v34 + 1;
    uint64_t v39 = v30;
    sub_1DD29BCC4(a1, v51, (uint64_t)(v35 + 2064), (uint64_t)v33, v34 + 1, v30, v15, a8, (uint64_t)&v58, v47, 0x2204uLL);
    unint64_t result = v59;
    if ((unint64_t)v59 >= 0xFFFFFFFFFFFFFF89)
    {
LABEL_28:
      size_t v28 = a7;
      size_t v9 = v48;
      goto LABEL_29;
    }
    unint64_t v40 = (unsigned __int16 *)(v32 + 4288);
    __int32 v41 = (unsigned __int16 *)(v32 + 2836);
    *int v34 = ((_BYTE)v58 << 6) + 16 * BYTE4(v58) + 4 * BYTE8(v58);
    uint64_t v42 = *((void *)&v59 + 1);
    int v43 = (unsigned __int16 *)v33;
    char v44 = &v38[result];
    unint64_t result = sub_1DD29E590((unint64_t *)&v38[result], v39 - (void)&v38[result], v41, v56, v43, v37, v40, v36, v54, v51, v60);
    size_t v28 = a7;
    size_t v9 = v48;
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      if (v42 && result + v42 < 4) {
        return 0;
      }
      int v34 = &v44[result];
      goto LABEL_27;
    }
  }
LABEL_29:
  if (v28 <= v9 && result == -70) {
    return 0;
  }
  if (result <= 0xFFFFFFFFFFFFFF88)
  {
    unsigned int v45 = v50[7];
    if (v45 <= 7) {
      char v46 = 6;
    }
    else {
      char v46 = v45 - 1;
    }
    if (result >= v28 - (v28 >> v46) - 2) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1DD29D5DC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 928);
  uint64_t v2 = *(void *)(result + 936);
  uint64_t v3 = *(void *)(result + 952);
  uint64_t v4 = *(void *)(result + 944);
  uint64_t v5 = *(void *)(result + 904);
  uint64_t v6 = *(void *)(result + 896) + 16 * v5;
  uint64_t v7 = *(void *)(result + 3176);
  uint64_t v30 = *(void *)(v7 + 5616);
  int v31 = *(_DWORD *)(v7 + 5624);
  uint64_t v9 = v2 - v1;
  BOOL v8 = v9 == 0;
  unint64_t v10 = v9 >> 3;
  int v11 = 0;
  if (!v8)
  {
    uint64_t v12 = *(unsigned int *)(result + 1004);
    int v13 = v30;
    int v14 = HIDWORD(v30);
    if (v10 <= 1) {
      uint64_t v15 = 1;
    }
    else {
      uint64_t v15 = v10;
    }
    uint64_t v16 = v6 + 8;
    int v17 = v31;
    unint64_t v18 = (unsigned __int16 *)(v1 + 6);
    uint64_t v19 = v15;
    while (1)
    {
      uint64_t v20 = *(unsigned int *)(v18 - 3);
      int v21 = *(v18 - 1);
      *(_DWORD *)(v16 - 4) = v21;
      int v22 = *v18;
      *(void *)uint64_t v16 = (v22 + 3);
      if (v12) {
        goto LABEL_7;
      }
      int v26 = *(_DWORD *)(result + 1000);
      if (v26 == 2) {
        break;
      }
      int v23 = v21;
      if (v26 == 1)
      {
        int v23 = v21 | 0x10000;
        *(_DWORD *)(v16 - 4) = v21 | 0x10000;
      }
LABEL_8:
      if (v20 > 3)
      {
        int v25 = v20 - 3;
        *(_DWORD *)(v16 - 8) = v25;
      }
      else
      {
        *(_DWORD *)(v16 + 4) = v20;
        if (v23)
        {
          int v24 = *((_DWORD *)&v30 + (v20 - 1));
        }
        else if (v20 == 3)
        {
          int v24 = v13 - 1;
        }
        else
        {
          int v24 = *((_DWORD *)&v30 + v20);
        }
        *(_DWORD *)(v16 - 8) = v24;
        if (!v21) {
          LODWORD(v20) = v20 + 1;
        }
        unsigned int v27 = v20 - 1;
        if (v20 == 1) {
          goto LABEL_28;
        }
        if (v20 == 4) {
          int v25 = v13 - 1;
        }
        else {
          int v25 = *((_DWORD *)&v30 + v27);
        }
        if (v27 <= 1) {
          int v14 = v17;
        }
      }
      HIDWORD(v30) = v13;
      int v31 = v14;
      int v17 = v14;
      int v14 = v13;
      int v13 = v25;
      LODWORD(v30) = v25;
LABEL_28:
      v18 += 4;
      v11 += v23;
      --v12;
      v16 += 16;
      if (!--v19) {
        goto LABEL_31;
      }
    }
    *(_DWORD *)uint64_t v16 = v22 + 65539;
LABEL_7:
    int v23 = v21;
    goto LABEL_8;
  }
  uint64_t v15 = 0;
LABEL_31:
  int v28 = v3 - (v11 + v4);
  uint64_t v29 = v6 + 16 * v15;
  *(_DWORD *)uint64_t v29 = 0;
  *(_DWORD *)(v29 + 4) = v28;
  *(void *)(v29 + 8) = 0;
  *(void *)(result + 904) = v10 + v5 + 1;
  return result;
}

unint64_t sub_1DD29D774(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, _DWORD *a5, _DWORD *a6, unint64_t a7, int a8, int a9, int a10, _WORD *a11)
{
  if (a6 && a7 > 7)
  {
    *(_DWORD *)(a1 + 5624) = 8;
    *(void *)(a1 + 5616) = 0x400000001;
    *(_DWORD *)(a1 + 2056) = 0;
    *(_DWORD *)(a1 + 5604) = 0;
    *(void *)(a1 + 5608) = 0;
    if (a8 == 1)
    {
LABEL_4:
      sub_1DD29D8B4(a2, a3, a4, a5, (unint64_t)a6, a7, a9, a10);
      return 0;
    }
    if (*a6 != -332356553)
    {
      if (a8 == 2) {
        return -32;
      }
      if (!a8) {
        goto LABEL_4;
      }
    }
    if (a5[10]) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = a6[1];
    }
    unint64_t result = sub_1DD299678(a1, a11, (uint64_t)a6, a7);
    if (result <= 0xFFFFFFFFFFFFFF88)
    {
      sub_1DD29D8B4(a2, 0, a4, a5, (unint64_t)a6 + result, a7 - result, a9, a10);
      return v17;
    }
  }
  else if (a8 == 2)
  {
    return -32;
  }
  else
  {
    return 0;
  }
  return result;
}

unint64_t sub_1DD29D8B4(unint64_t result, unint64_t a2, void *a3, _DWORD *a4, unint64_t a5, unint64_t a6, int a7, int a8)
{
  uint64_t v12 = (uint32x2_t *)result;
  unint64_t v13 = a5 + a6;
  int v16 = a4[24];
  int v14 = a4 + 24;
  int v15 = v16;
  if (a2) {
    BOOL v17 = v15 == 1;
  }
  else {
    BOOL v17 = 0;
  }
  char v18 = v17;
  unsigned int v19 = *(v14 - 17);
  uint64_t v20 = -3758096382;
  if (a8 == 1 && v19 - 1 < 2) {
    uint64_t v20 = -16777214;
  }
  unint64_t v21 = 3758096382;
  if (a8 == 1 && v19 - 1 < 2) {
    unint64_t v21 = 16777214;
  }
  unint64_t v22 = v13 + v20;
  if (v21 >= a6) {
    unint64_t v23 = a6;
  }
  else {
    unint64_t v23 = v21;
  }
  if (v21 >= a6) {
    unint64_t v24 = a5;
  }
  else {
    unint64_t v24 = v22;
  }
  if (!v23)
  {
    if ((v18 & 1) == 0) {
      goto LABEL_46;
    }
    goto LABEL_42;
  }
  uint64_t v25 = *(void *)result;
  if (*(void *)result == v24)
  {
    uint64_t v26 = *(void *)(result + 16);
    unsigned int v27 = *(_DWORD *)(result + 24);
    unsigned int v28 = *(_DWORD *)(result + 28);
  }
  else
  {
    uint64_t v26 = *(void *)(result + 8);
    unsigned int v27 = v25 - v26;
    unsigned int v28 = *(_DWORD *)(result + 24);
    *(_DWORD *)(result + 24) = v25 - v26;
    *(_DWORD *)(result + 28) = v28;
    *(void *)(result + 8) = v24 - (v25 - v26);
    *(void *)(result + 16) = v26;
    if (v25 - v26 - v28 <= 7)
    {
      *(_DWORD *)(result + 28) = v27;
      unsigned int v28 = v25 - v26;
    }
  }
  unint64_t v29 = v24 + v23;
  *(void *)unint64_t result = v24 + v23;
  if (v24 + v23 > v26 + (unint64_t)v28 && v26 + (unint64_t)v27 > v24)
  {
    uint64_t v31 = v29 - v26;
    if (v31 > v27) {
      LODWORD(v31) = v27;
    }
    *(_DWORD *)(result + 28) = v31;
  }
  if (v18)
  {
    if (*(void *)a2 == v24)
    {
      uint64_t v32 = *(void *)(a2 + 16);
      LODWORD(v33) = *(_DWORD *)(a2 + 24);
      unsigned int v34 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      uint64_t v32 = *(void *)(a2 + 8);
      uint64_t v33 = *(void *)a2 - v32;
      unsigned int v34 = *(_DWORD *)(a2 + 24);
      *(_DWORD *)(a2 + 24) = v33;
      *(_DWORD *)(a2 + 28) = v34;
      *(void *)(a2 + 8) = v24 - v33;
      *(void *)(a2 + 16) = v32;
      if (v33 - v34 <= 7)
      {
        *(_DWORD *)(a2 + 28) = v33;
        unsigned int v34 = v33;
      }
    }
    *(void *)a2 = v29;
    if (v29 > v32 + (unint64_t)v34 && v32 + (unint64_t)v33 > v24)
    {
      uint64_t v35 = v29 - v32;
      if (v35 > v33) {
        LODWORD(v35) = v33;
      }
      *(_DWORD *)(a2 + 28) = v35;
    }
LABEL_42:
    if (a4[12]) {
      int v36 = 0;
    }
    else {
      int v36 = v13 - *(_DWORD *)(a2 + 8);
    }
    *(_DWORD *)(a2 + 48) = v36;
    unint64_t result = sub_1DD2CEF58(a2, v24, a5 + a6, v14);
    unsigned int v19 = a4[7];
  }
LABEL_46:
  if (v19 <= 7)
  {
    unsigned int v37 = a4[3];
    if (v37 <= a4[2]) {
      unsigned int v37 = a4[2];
    }
    if (v37 >= 0x1C) {
      LOBYTE(v37) = 28;
    }
    unint64_t v38 = (8 << v37);
    if (v23 > v38) {
      LODWORD(v24) = v13 - v38;
    }
    if (v23 >= v38) {
      unint64_t v23 = v38;
    }
  }
  __int32 v39 = v12[1].i32[0];
  __int32 v40 = v24 - v39;
  __int32 v41 = v13 - v39;
  if (a4[12]) {
    __int32 v41 = 0;
  }
  v12[5].i32[0] = v41;
  v12[5].i32[1] = v40;
  v12[17].i32[0] = a4[37];
  if (v23 >= 9)
  {
    unint64_t result = (unint64_t)sub_1DD29C034(v12, a3, a4, v24, v13);
    switch(a4[7])
    {
      case 1:
        unint64_t result = sub_1DD2A6DAC((uint64_t)v12, v13, a7, a8);
        break;
      case 2:
        unint64_t result = sub_1DD29F640((uint64_t)v12, v13, a7, a8);
        break;
      case 3:
      case 4:
      case 5:
        if (v12[17].i32[1])
        {
          unint64_t result = sub_1DD2ADCD4((uint64_t)v12, (int)v13 - 8);
        }
        else if (a4[36] == 1)
        {
          bzero(*(void **)&v12[7], 1 << a4[3]);
          unint64_t result = sub_1DD2AE23C((uint64_t)v12, (int)v13 - 8);
        }
        else
        {
          unint64_t result = sub_1DD2AE058((uint64_t)v12, (uint64_t *)(v13 - 8));
        }
        break;
      case 6:
      case 7:
      case 8:
      case 9:
        unint64_t result = sub_1DD2D01E0((uint64_t)v12, (int)v13 - 8, v13);
        break;
      default:
        break;
    }
    v12[5].i32[1] = v13 - v12[1].i32[0];
  }
  return result;
}

_OWORD *sub_1DD29DBFC(_OWORD *result, char *a2, unint64_t a3, char *a4)
{
  if (a2 <= a4)
  {
    uint64_t v4 = (_OWORD *)((char *)result + a4 - a2);
    *unint64_t result = *(_OWORD *)a2;
    if (a4 - a2 >= 17)
    {
      uint64_t v5 = result + 1;
      uint64_t v6 = (long long *)(a2 + 32);
      do
      {
        *uint64_t v5 = *(v6 - 1);
        long long v7 = *v6;
        v6 += 2;
        v5[1] = v7;
        v5 += 2;
      }
      while (v5 < v4);
    }
    a2 = a4;
    unint64_t result = v4;
  }
  if ((unint64_t)a2 < a3)
  {
    unint64_t v8 = a3 - (void)a2;
    do
    {
      char v9 = *a2++;
      *(unsigned char *)unint64_t result = v9;
      unint64_t result = (_OWORD *)((char *)result + 1);
      --v8;
    }
    while (v8);
  }
  return result;
}

size_t sub_1DD29DC68(_DWORD *a1, size_t a2, void *__src, size_t __n)
{
  if (__n <= 0x1F) {
    LODWORD(v4) = 1;
  }
  else {
    LODWORD(v4) = 2;
  }
  if (__n <= 0xFFF) {
    uint64_t v4 = v4;
  }
  else {
    uint64_t v4 = (v4 + 1);
  }
  size_t v5 = v4 + __n;
  if (v4 + __n > a2) {
    return -70;
  }
  switch(v4)
  {
    case 3:
      *a1 = (16 * __n) | 0xC;
      break;
    case 2:
      *(_WORD *)a1 = (16 * __n) | 4;
      break;
    case 1:
      *(unsigned char *)a1 = 8 * __n;
      break;
  }
  memcpy((char *)a1 + v4, __src, __n);
  return v5;
}

uint64_t sub_1DD29DD00(_DWORD *a1, uint64_t a2, unsigned char *a3, unint64_t a4)
{
  if (a4 <= 0x1F) {
    uint64_t v4 = 1;
  }
  else {
    uint64_t v4 = 2;
  }
  if (a4 > 0xFFF) {
    ++v4;
  }
  switch(v4)
  {
    case 3:
      *a1 = (16 * a4) | 0xD;
      break;
    case 2:
      *(_WORD *)a1 = (16 * a4) | 5;
      break;
    case 1:
      *(unsigned char *)a1 = (8 * a4) | 1;
      break;
  }
  *((unsigned char *)a1 + v4) = *a3;
  return (v4 + 1);
}

uint64_t sub_1DD29DD68(uint64_t a1, size_t a2, unsigned __int8 *a3, size_t a4, int a5, int a6, void *__src, void *__dst, unsigned int a9, int a10, int a11, int a12)
{
  uint64_t v18 = 3;
  if (a4 > 0x3FF) {
    uint64_t v18 = 4;
  }
  if ((a4 & 0xFFFFFFFFFFFFC000) != 0) {
    unint64_t v19 = v18 + 1;
  }
  else {
    unint64_t v19 = v18;
  }
  memcpy(__dst, __src, 0x810uLL);
  if (a10)
  {
    uint64_t v20 = (_DWORD *)a1;
    size_t v21 = a2;
    unint64_t v22 = a3;
LABEL_14:
    return sub_1DD29DC68(v20, v21, v22, a4);
  }
  unint64_t v22 = a3;
  uint64_t v20 = (_DWORD *)a1;
  int v23 = *((_DWORD *)__src + 514);
  char v24 = 9 - a9;
  if ((int)(9 - a9) >= 3) {
    char v24 = 3;
  }
  unint64_t v25 = 8 << v24;
  if (v23 == 2) {
    unint64_t v25 = 6;
  }
  if (v25 > a4)
  {
    size_t v21 = a2;
    goto LABEL_14;
  }
  size_t v27 = a2 - v19;
  if (a2 <= v19) {
    return -70;
  }
  unsigned int v28 = __src;
  size_t v29 = a2;
  int v44 = v23;
  BOOL v30 = v23 == 2 && v19 == 3;
  int v32 = v30 || a4 < 0x100;
  int v43 = v32;
  BOOL v30 = v32 == 0;
  uint64_t v33 = sub_1DD297F94;
  if (!v30) {
    uint64_t v33 = sub_1DD297B38;
  }
  if (a9 <= 7) {
    char v34 = 6;
  }
  else {
    char v34 = a9 - 1;
  }
  unint64_t v35 = ((uint64_t (*)(unint64_t, size_t))v33)(a1 + v19, v27);
  if (v44) {
    int v36 = 3;
  }
  else {
    int v36 = 2;
  }
  if (v35 - 1 > 0xFFFFFFFFFFFFFF87 || v35 >= a4 - (a4 >> v34) - 2)
  {
    memcpy(__dst, v28, 0x810uLL);
    return sub_1DD29DC68((_DWORD *)a1, v29, a3, a4);
  }
  else
  {
    if (v35 == 1)
    {
      if (a4 > 7 || a4 < 2)
      {
LABEL_43:
        memcpy(__dst, v28, 0x810uLL);
        return sub_1DD29DD00((_DWORD *)a1, v40, a3, a4);
      }
      size_t v37 = a4 - 1;
      unint64_t v38 = a3 + 1;
      while (1)
      {
        int v39 = *v38++;
        if (v39 != *a3) {
          break;
        }
        if (!--v37) {
          goto LABEL_43;
        }
      }
    }
    if (!v44) {
      *((_DWORD *)__dst + 514) = 1;
    }
    switch(v19)
    {
      case 5uLL:
        *(_DWORD *)a1 = ((v35 << 22) + 16 * a4) | v36 | 0xC;
        *(unsigned char *)(a1 + 4) = v35 >> 10;
        break;
      case 4uLL:
        *(_DWORD *)a1 = ((v35 << 18) + 16 * a4) | v36 | 8;
        break;
      case 3uLL:
        if (v43) {
          int v41 = 4;
        }
        else {
          int v41 = 0;
        }
        int v42 = ((v36 | v41 | (16 * a4)) ^ 4) + (v35 << 14);
        *(_WORD *)a1 = v42;
        *(unsigned char *)(a1 + 2) = BYTE2(v42);
        break;
    }
    return v35 + v19;
  }
}

uint64_t sub_1DD29E098(unsigned __int16 *a1, unsigned int *a2, unsigned int a3)
{
  int v3 = *a1;
  if (*a1) {
    uint64_t v4 = 1 << (v3 - 1);
  }
  else {
    uint64_t v4 = 1;
  }
  if (a1[1] < a3) {
    return -1;
  }
  unint64_t v6 = 0;
  uint64_t v7 = a3 + 1;
  unint64_t v8 = &a1[2 * v4 + 4];
  do
  {
    unsigned int v10 = *(_DWORD *)v8;
    v8 += 4;
    unsigned int v9 = v10;
    unsigned int v12 = *a2++;
    unsigned int v11 = v12;
    if (v12)
    {
      unsigned int v13 = ((HIWORD(v9) + 1) << 8) - ((((HIWORD(v9) + 1) << 24) - ((v9 + (1 << v3)) << 8)) >> v3);
      if (v13 >= (v3 << 8) + 256) {
        return -1;
      }
      v6 += v11 * (unint64_t)v13;
    }
    --v7;
  }
  while (v7);
  return v6 >> 8;
}

unint64_t sub_1DD29E12C(unsigned __int16 *a1, char a2, int *a3, int a4)
{
  unint64_t v4 = 0;
  if ((a4 + 1) > 1) {
    uint64_t v5 = (a4 + 1);
  }
  else {
    uint64_t v5 = 1;
  }
  do
  {
    int v7 = *a1++;
    __int16 v6 = v7;
    if (v7 == 0xFFFF) {
      __int16 v6 = 1;
    }
    int v8 = *a3++;
    v4 += (dword_1DD321E70[v6 << (8 - a2)] * v8);
    --v5;
  }
  while (v5);
  return v4 >> 8;
}

uint64_t sub_1DD29E188(_DWORD *a1, unsigned int *a2, unsigned int a3, unint64_t a4, unint64_t a5, unsigned int a6, unsigned __int16 *a7, unsigned __int16 *a8, char a9, int a10, unsigned int a11)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a4 != a5)
  {
    if (a11 > 3)
    {
      BOOL v17 = a2;
      if (a10)
      {
        unint64_t v18 = 0;
        if (a3 + 1 > 1) {
          uint64_t v19 = a3 + 1;
        }
        else {
          uint64_t v19 = 1;
        }
        uint64_t v20 = a2;
        do
        {
          int v22 = *a8++;
          __int16 v21 = v22;
          if (v22 == 0xFFFF) {
            __int16 v21 = 1;
          }
          int v23 = *v20++;
          v18 += (dword_1DD321E70[v21 << (8 - a9)] * v23);
          --v19;
        }
        while (v19);
        unint64_t v24 = v18 >> 8;
      }
      else
      {
        unint64_t v24 = -1;
      }
      if (*a1) {
        unint64_t v25 = sub_1DD29E098(a7, a2, a3);
      }
      else {
        unint64_t v25 = -1;
      }
      unsigned int v26 = sub_1DD295268(a6, a5, a3);
      unint64_t v27 = sub_1DD2952D0(v36, v26, v17, a5, a3, a5 > 0x7FF);
      if (v27 <= 0xFFFFFFFFFFFFFF88) {
        unint64_t v27 = sub_1DD294F98(v37, 0x200uLL, (uint64_t)v36, a3, v26);
      }
      unsigned int v28 = 0;
      if (a3 + 1 > 1) {
        uint64_t v29 = a3 + 1;
      }
      else {
        uint64_t v29 = 1;
      }
      do
      {
        unsigned int v31 = *v17++;
        unsigned int v30 = v31;
        unint64_t v32 = v31 << 8;
        if (v32 >= a5 || v30 == 0) {
          uint64_t v34 = v32 / a5;
        }
        else {
          uint64_t v34 = 1;
        }
        v28 += dword_1DD321E70[v34] * v30;
        --v29;
      }
      while (v29);
      unint64_t v35 = (v28 >> 8) + 8 * v27;
      if (v24 <= v25 && v24 <= v35) {
        goto LABEL_42;
      }
      if (v25 <= v35) {
        return 3;
      }
    }
    else if (a10)
    {
      if (a5 > 0x3E7 || *a1 != 2)
      {
        if (a5 >= (unint64_t)(10 - a11) << a9 >> 3 && a5 >> (a9 - 1) <= a4) {
          goto LABEL_44;
        }
LABEL_42:
        uint64_t result = 0;
        *a1 = 0;
        return result;
      }
      return 3;
    }
LABEL_44:
    *a1 = 1;
    return 2;
  }
  *a1 = 0;
  return a4 > 2 || a10 == 0;
}

unint64_t sub_1DD29E3D8(_WORD *a1, unint64_t a2, _WORD *__dst, unsigned int a4, int a5, unsigned int *a6, unsigned int a7, unsigned char *a8, uint64_t a9, __int16 *a10, int a11, int a12, const void *a13, size_t a14, __int16 *a15, unint64_t a16)
{
  switch(a5)
  {
    case 0:
      unint64_t v21 = sub_1DD294D0C(__dst, a10, a12, a11, a15, a16);
      if (v21 >= 0xFFFFFFFFFFFFFF89) {
        unint64_t v22 = v21;
      }
      else {
        unint64_t v22 = 0;
      }
      break;
    case 1:
      unint64_t v22 = sub_1DD2955E0((uint64_t)__dst, a7);
      if (v22 <= 0xFFFFFFFFFFFFFF88)
      {
        if (a2)
        {
          *(unsigned char *)a1 = *a8;
          unint64_t v22 = 1;
        }
        else
        {
          unint64_t v22 = -70;
        }
      }
      break;
    case 2:
      unint64_t v24 = a9;
      unsigned int v25 = sub_1DD295268(a4, a9, a7);
      uint64_t v26 = a8[a9 - 1];
      unsigned int v27 = a6[v26];
      if (v27 >= 2)
      {
        a6[v26] = v27 - 1;
        unint64_t v24 = a9 - 1;
      }
      unint64_t v22 = sub_1DD2952D0(a15, v25, a6, v24, a7, v24 > 0x7FF);
      if (v22 <= 0xFFFFFFFFFFFFFF88)
      {
        unint64_t v22 = sub_1DD294F98(a1, a2, (uint64_t)a15, a7, v25);
        if (v22 <= 0xFFFFFFFFFFFFFF88)
        {
          unint64_t v28 = sub_1DD294D0C(__dst, a15, a7, v25, a15 + 54, 0x474uLL);
          if (v28 >= 0xFFFFFFFFFFFFFF89) {
            unint64_t v22 = v28;
          }
        }
      }
      break;
    case 3:
      memcpy(__dst, a13, a14);
      unint64_t v22 = 0;
      break;
    default:
      unint64_t v22 = -1;
      break;
  }
  return v22;
}

uint64_t sub_1DD29E590(unint64_t *a1, unint64_t a2, unsigned __int16 *a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, uint64_t a8, uint64_t a9, unint64_t a10, int a11)
{
  if (a2 < 9) {
    return -70;
  }
  unint64_t v12 = a10 - 1;
  uint64_t v13 = *(unsigned __int8 *)(a4 + a10 - 1);
  unsigned int v15 = *a3;
  int v14 = a3 + 2;
  uint64_t v16 = 1 << (v15 - 1);
  unsigned int v105 = v15;
  if (!v15) {
    uint64_t v16 = 1;
  }
  unint64_t v106 = &v14[2 * v16];
  unint64_t v17 = v14[((unint64_t)(((*(_DWORD *)&v106[4 * v13 + 2] + 0x8000) & 0xFFFF0000) - *(_DWORD *)&v106[4 * v13 + 2]) >> ((*(_DWORD *)&v106[4 * v13 + 2] + 0x8000) >> 16))
          + *(int *)&v106[4 * v13]];
  unint64_t v18 = (char *)a1 + a2;
  uint64_t v19 = *(unsigned __int8 *)(a6 + v12);
  unsigned int v22 = *a5;
  uint64_t v20 = a5 + 2;
  unsigned int v21 = v22;
  uint64_t v23 = 1 << (v22 - 1);
  if (!v22) {
    uint64_t v23 = 1;
  }
  unint64_t v24 = &v20[2 * v23];
  unint64_t v25 = v20[((unint64_t)(((*(_DWORD *)&v24[4 * v19 + 2] + 0x8000) & 0xFFFF0000)
                              - *(_DWORD *)&v24[4 * v19 + 2]) >> ((*(_DWORD *)&v24[4 * v19 + 2]
                                                                                             + 0x8000) >> 16))
          + *(int *)&v24[4 * v19]];
  uint64_t v26 = *(unsigned __int8 *)(a8 + v12);
  unsigned int v27 = (unint64_t *)(v18 - 8);
  unsigned int v30 = *a7;
  unint64_t v28 = a7 + 2;
  unsigned int v29 = v30;
  uint64_t v31 = 1 << (v30 - 1);
  if (!v30) {
    uint64_t v31 = 1;
  }
  unint64_t v32 = &v28[2 * v31];
  unint64_t v33 = v28[((unint64_t)(((*(_DWORD *)&v32[4 * v26 + 2] + 0x8000) & 0xFFFF0000) - *(_DWORD *)&v32[4 * v26 + 2]) >> ((*(_DWORD *)&v32[4 * v26 + 2] + 0x8000) >> 16))
          + *(int *)&v32[4 * v26]];
  uint64_t v34 = (unsigned int *)(a9 + 8 * v12);
  uint64_t v35 = byte_1DD322270[v26];
  uint64_t v36 = byte_1DD322294[v13];
  unint64_t v37 = ((unint64_t)(dword_1DD3222CC[v36] & *((unsigned __int16 *)v34 + 3)) << v35) | dword_1DD3222CC[v35] & *((unsigned __int16 *)v34 + 2);
  int v38 = v36 + v35;
  if (a11)
  {
    if (v19 > 0x37)
    {
      unsigned int v40 = *v34;
      unsigned int v39 = v19 - 56;
      if (v19 != 56)
      {
        unint64_t v45 = ((unint64_t)(dword_1DD3222CC[v39] & v40) << v38) | v37;
        uint64_t v19 = (v38 + v39) >> 3;
        *a1 = v45;
        if ((unint64_t *)((char *)a1 + v19) <= v27) {
          int v44 = (unint64_t *)((char *)a1 + v19);
        }
        else {
          int v44 = v27;
        }
        int v38 = ((_BYTE)v38 + (_BYTE)v39) & 7;
        unint64_t v37 = v45 >> (8 * v19);
        LODWORD(v19) = 56;
        goto LABEL_20;
      }
      LODWORD(v19) = 56;
    }
    else
    {
      LOBYTE(v39) = 0;
      unsigned int v40 = *v34;
    }
    int v44 = a1;
LABEL_20:
    unint64_t v42 = ((unint64_t)(dword_1DD3222CC[v19] & (v40 >> v39)) << v38) | v37;
    unsigned int v43 = v38 + v19;
    goto LABEL_21;
  }
  unint64_t v42 = ((unint64_t)(dword_1DD3222CC[v19] & *v34) << v38) | v37;
  unsigned int v43 = v38 + v19;
  int v44 = a1;
LABEL_21:
  uint64_t v46 = v43 >> 3;
  *int v44 = v42;
  uint64_t v47 = (unint64_t *)((char *)v44 + v46);
  if ((unint64_t *)((char *)v44 + v46) > v27) {
    uint64_t v47 = v27;
  }
  unint64_t v48 = v42 >> (8 * v46);
  int v49 = v43 & 7;
  unint64_t v50 = a10 - 2;
  unint64_t v102 = a1;
  unsigned int v103 = v29;
  unsigned int v104 = v21;
  if (a10 >= 2)
  {
    uint64_t v51 = a9 + 8 * a10 - 16;
    do
    {
      uint64_t v52 = *(unsigned __int8 *)(a8 + v50);
      uint64_t v53 = *(unsigned __int8 *)(a6 + v50);
      uint64_t v54 = *(unsigned __int8 *)(a4 + v50);
      unsigned int v55 = byte_1DD322270[v52];
      unsigned int v56 = byte_1DD322294[v54];
      unint64_t v57 = (v25 + *(unsigned int *)&v24[4 * v53 + 2]) >> 16;
      unint64_t v58 = (unint64_t)(v25 & dword_1DD3222CC[v57]) << v49;
      int v59 = v49 + v57;
      unint64_t v25 = v20[(v25 >> ((v25 + *(_DWORD *)&v24[4 * v53 + 2]) >> 16)) + *(int *)&v24[4 * v53]];
      uint64_t v60 = &v106[4 * v54];
      int v61 = *(_DWORD *)v60;
      unint64_t v62 = (v17 + *((unsigned int *)v60 + 1)) >> 16;
      unint64_t v63 = (unint64_t)(v17 & dword_1DD3222CC[v62]) << v59;
      int v64 = v59 + v62;
      unint64_t v17 = v14[(v17 >> v62) + v61];
      unint64_t v65 = &v32[4 * v52];
      LODWORD(v62) = *(_DWORD *)v65;
      unint64_t v66 = (v33 + *((unsigned int *)v65 + 1)) >> 16;
      unint64_t v67 = v58 | v48 | v63 | ((unint64_t)(v33 & dword_1DD3222CC[v66]) << v64);
      unsigned int v68 = v64 + v66;
      unint64_t v33 = v28[(v33 >> v66) + (int)v62];
      unsigned int v69 = v55 + v53 + v56;
      if (v69 >= 0x1F)
      {
        uint64_t v70 = v68 >> 3;
        *uint64_t v47 = v67;
        if ((unint64_t *)((char *)v47 + v70) <= v27) {
          uint64_t v47 = (unint64_t *)((char *)v47 + v70);
        }
        else {
          uint64_t v47 = v27;
        }
        v68 &= 7u;
        v67 >>= 8 * v70;
      }
      unsigned int v71 = v68 + v55;
      unint64_t v72 = ((unint64_t)(dword_1DD3222CC[v55] & *(unsigned __int16 *)(v51 + 4)) << v68) | v67 | ((unint64_t)(dword_1DD3222CC[v56] & *(unsigned __int16 *)(v51 + 6)) << (v68 + v55));
      unsigned int v73 = v71 + v56;
      if (v69 >= 0x39)
      {
        uint64_t v74 = v73 >> 3;
        *uint64_t v47 = v72;
        if ((unint64_t *)((char *)v47 + v74) <= v27) {
          uint64_t v47 = (unint64_t *)((char *)v47 + v74);
        }
        else {
          uint64_t v47 = v27;
        }
        v73 &= 7u;
        v72 >>= 8 * v74;
      }
      if (a11)
      {
        if (v53 > 0x37)
        {
          unsigned int v76 = *(_DWORD *)v51;
          unsigned int v75 = v53 - 56;
          if (v53 != 56)
          {
            unint64_t v79 = ((unint64_t)(dword_1DD3222CC[v75] & v76) << v73) | v72;
            uint64_t v80 = (v73 + v75) >> 3;
            *uint64_t v47 = v79;
            if ((unint64_t *)((char *)v47 + v80) <= v27) {
              uint64_t v47 = (unint64_t *)((char *)v47 + v80);
            }
            else {
              uint64_t v47 = v27;
            }
            unsigned int v73 = ((_BYTE)v73 + (_BYTE)v75) & 7;
            unint64_t v72 = v79 >> (8 * v80);
          }
          LODWORD(v53) = 56;
        }
        else
        {
          LOBYTE(v75) = 0;
          unsigned int v76 = *(_DWORD *)v51;
        }
        unsigned int v77 = v76 >> v75;
        int v78 = dword_1DD3222CC[v53];
      }
      else
      {
        unsigned int v77 = *(_DWORD *)v51;
        int v78 = dword_1DD3222CC[v53];
      }
      unint64_t v81 = ((unint64_t)(v78 & v77) << v73) | v72;
      uint64_t v82 = (v73 + v53) >> 3;
      *uint64_t v47 = v81;
      if ((unint64_t *)((char *)v47 + v82) <= v27) {
        uint64_t v47 = (unint64_t *)((char *)v47 + v82);
      }
      else {
        uint64_t v47 = v27;
      }
      unint64_t v48 = v81 >> (8 * v82);
      --v50;
      int v49 = ((_BYTE)v73 + (_BYTE)v53) & 7;
      v51 -= 8;
    }
    while (v50 < a10);
  }
  unint64_t v83 = ((unint64_t)(v17 & dword_1DD3222CC[v105]) << v49) | v48;
  unsigned int v84 = v49 + v105;
  uint64_t v85 = v84 >> 3;
  *uint64_t v47 = v83;
  unint64_t v86 = (unint64_t *)((char *)v47 + v85);
  if ((unint64_t *)((char *)v47 + v85) > v27) {
    unint64_t v86 = v27;
  }
  int v87 = v84 & 7;
  unint64_t v88 = ((unint64_t)(v25 & dword_1DD3222CC[v104]) << v87) | (v83 >> (8 * v85));
  unsigned int v89 = v87 + v104;
  uint64_t v90 = v89 >> 3;
  *unint64_t v86 = v88;
  unint64_t v91 = (unint64_t *)((char *)v86 + v90);
  if (v91 > v27) {
    unint64_t v91 = v27;
  }
  int v92 = v89 & 7;
  unint64_t v93 = ((unint64_t)(v33 & dword_1DD3222CC[v103]) << v92) | (v88 >> (8 * v90));
  unsigned int v94 = v92 + v103;
  uint64_t v95 = v94 >> 3;
  *unint64_t v91 = v93;
  unint64_t v96 = (uint64_t *)((char *)v91 + v95);
  if (v96 > (uint64_t *)v27) {
    unint64_t v96 = (uint64_t *)v27;
  }
  int v97 = v94 & 7;
  uint64_t v98 = (v93 >> (8 * v95)) | (1 << v97);
  unsigned int v99 = v97 + 1;
  *unint64_t v96 = v98;
  unint64_t v100 = (unint64_t *)((char *)v96 + (v99 >> 3));
  if (v27 <= v100) {
    return -70;
  }
  uint64_t v101 = (v99 & 7) != 0 ? (uint64_t)v100 + 1 : (uint64_t)v96 + (v99 >> 3);
  uint64_t result = v101 - (void)v102;
  if ((unint64_t *)v101 == v102) {
    return -70;
  }
  return result;
}

uint64_t sub_1DD29EAE0(uint64_t a1, char *a2, uint64_t a3, char *a4, uint64_t a5, int a6)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  uint64_t v123 = 0;
  long long v121 = 0u;
  *(_OWORD *)uint64_t v122 = 0u;
  long long v119 = 0u;
  long long v120 = 0u;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  *(_OWORD *)uint64_t v113 = 0u;
  long long v114 = 0u;
  *(_OWORD *)__uint64_t n = 0u;
  memset(v111, 0, sizeof(v111));
  unint64_t v11 = sub_1DD298A40((void *)(a1 + 928), *(char **)(a1 + 3176), *(void **)(a1 + 3184), (_DWORD *)(a1 + 224), (uint64_t)v111, *(void **)(a1 + 3496), 0x22D8uLL);
  if (v11 <= 0xFFFFFFFFFFFFFF88)
  {
    unint64_t v12 = 0;
    int64_t v13 = 0;
    int v14 = *(unsigned __int16 **)(a1 + 3184);
    uint64_t v85 = a4;
    unint64_t v82 = (unint64_t)&a4[a5];
    uint64_t v107 = &a2[a3];
    BOOL v103 = LODWORD(v111[0]) == 2;
    unint64_t v105 = *(void *)(a1 + 936);
    int v97 = v14 + 2144;
    uint64_t v98 = v14 + 1032;
    std::string __dst = v14;
    unsigned int v84 = *(void **)(a1 + 3176);
    unsigned int v15 = *(unsigned int **)(a1 + 3496);
    unint64_t v16 = *(void *)(a1 + 928);
    unint64_t v108 = *(unsigned int **)(a1 + 944);
    uint64_t v95 = *(void *)(a1 + 952);
    unint64_t v96 = v14 + 1418;
    unint64_t v100 = *(unsigned __int8 **)(a1 + 968);
    uint64_t v101 = *(unsigned __int8 **)(a1 + 960);
    unsigned int v99 = *(unsigned __int8 **)(a1 + 976);
    unint64_t v104 = *(void *)(a1 + 280);
    unint64_t v83 = a2;
    unsigned int v94 = a2;
    int v102 = 1;
    unint64_t v17 = v16;
    unint64_t v86 = v15;
    unint64_t v90 = v16;
    while (1)
    {
      if (v16 == v105) {
        goto LABEL_8;
      }
      unint64_t v18 = v17 + 8 * v13;
      uint64_t v19 = *(unsigned __int16 *)(v18 + 4);
      if (*(_DWORD *)(a1 + 1004) == ((v18 - *(void *)(a1 + 928)) >> 3) && *(_DWORD *)(a1 + 1000) == 1) {
        v19 |= 0x10000uLL;
      }
      ++v13;
      if (v18 == v105 - 8)
      {
LABEL_8:
        unint64_t v12 = v95 - (void)v108;
        int v20 = 1;
      }
      else
      {
        int v20 = 0;
        v12 += v19;
      }
      LODWORD(v109) = 255;
      if ((LODWORD(v111[0]) - 2) < 2)
      {
        uint64_t v21 = v12;
        if ((unint64_t)sub_1DD295D84(v15, (unsigned int *)&v109, v108, v12, (char *)v15, 0x22D8uLL) <= 0xFFFFFFFFFFFFFF88)
        {
          unint64_t v22 = sub_1DD296948((uint64_t)__dst, v15, v109);
          size_t v23 = __n[1];
          if (!v103) {
            size_t v23 = 0;
          }
          uint64_t v21 = v22 + v23 + 3;
        }
      }
      else if (LODWORD(v111[0]))
      {
        uint64_t v21 = LODWORD(v111[0]) == 1;
      }
      else
      {
        uint64_t v21 = v12;
      }
      if (v13)
      {
        unint64_t v24 = v17;
        unint64_t v25 = sub_1DD29F530(v113[1], v99, 0x1Fu, v13, v98, 0, word_1DD32234C, 5, 0x1Cu, v15);
        unint64_t v26 = sub_1DD29F530(v113[0], v101, 0x23u, v13, v97, (uint64_t)&unk_1DD322386, word_1DD3223AA, 6, 0x23u, v15);
        unint64_t v27 = sub_1DD29F530(v113[2], v100, 0x34u, v13, v96, (uint64_t)&unk_1DD3223F2, word_1DD322428, 6, 0x34u, v15);
        size_t v28 = v122[1];
        if (!v102) {
          size_t v28 = 0;
        }
        if (v21 + v25 + v26 + v27 + v28 + 6 > v104) {
          char v29 = 1;
        }
        else {
          char v29 = v20;
        }
        if (v29)
        {
          unint64_t v17 = v24;
          unint64_t v30 = v24 + 8 * v13;
          uint64_t v31 = 0;
          if (v13 >= 1)
          {
            unint64_t v32 = v17 - *(void *)(a1 + 928);
            uint64_t v33 = 8 * v13;
            uint64_t v34 = (unsigned __int16 *)(v17 + 6);
            do
            {
              unsigned int v36 = *v34;
              v34 += 4;
              uint64_t v35 = v36;
              uint64_t v37 = v36 + 3;
              if (*(_DWORD *)(a1 + 1004) == (v32 >> 3))
              {
                uint64_t v38 = v35 + 65539;
                if (*(_DWORD *)(a1 + 1000) == 2) {
                  uint64_t v37 = v38;
                }
              }
              v31 += v37;
              v32 += 8;
              v33 -= 8;
            }
            while (v33 > 0);
          }
LABEL_36:
          unint64_t v91 = v30;
          uint64_t v106 = v17;
          if (a6) {
            int v40 = v20;
          }
          else {
            int v40 = 0;
          }
          int v92 = v40;
          int v41 = v94 + 3;
          if (v103) {
            uint64_t v42 = 200;
          }
          else {
            uint64_t v42 = 0;
          }
          if (v103) {
            int v43 = v111[0];
          }
          else {
            int v43 = 3;
          }
          if (1024 - v42 > v12) {
            uint64_t v44 = 3;
          }
          else {
            uint64_t v44 = 4;
          }
          if (0x4000 - v42 > v12) {
            unint64_t v45 = v44;
          }
          else {
            unint64_t v45 = v44 + 1;
          }
          if (!v12)
          {
LABEL_54:
            size_t v46 = sub_1DD29DC68(v94 + 3, v107 - v94 - 3, v108, v12);
LABEL_60:
            unint64_t v11 = v46;
            int v47 = 1;
            goto LABEL_61;
          }
          if (LODWORD(v111[0]) == 1)
          {
            size_t v46 = sub_1DD29DD00(v94 + 3, v107 - v94 - 3, v108, v12);
            goto LABEL_60;
          }
          if (!LODWORD(v111[0])) {
            goto LABEL_54;
          }
          size_t v52 = 0;
          uint64_t v53 = &v41[v45];
          if (v103 && LODWORD(v111[0]) == 2)
          {
            memcpy(v53, (char *)v111 + 4, __n[1]);
            size_t v52 = __n[1];
            uint64_t v53 = &v41[v45 + __n[1]];
          }
          unint64_t v88 = v53;
          if (v45 == 3) {
            uint64_t v54 = sub_1DD2969C0();
          }
          else {
            uint64_t v54 = sub_1DD297828();
          }
          if ((unint64_t)(v54 - 1) > 0xFFFFFFFFFFFFFF87)
          {
            unint64_t v16 = v90;
            unsigned int v15 = v86;
            if (v20) {
              goto LABEL_122;
            }
          }
          else
          {
            unint64_t v66 = v54 + v52;
            if (!v103 && v66 >= v12) {
              goto LABEL_111;
            }
            unint64_t v67 = 3;
            if (v66 > 0x3FF) {
              unint64_t v67 = 4;
            }
            if ((v66 & 0xFFFFFFFFFFFFC000) != 0) {
              ++v67;
            }
            if (v45 >= v67)
            {
              switch(v45)
              {
                case 5uLL:
                  *(_DWORD *)(v94 + 3) = v43 + 16 * v12 + (v66 << 22) + 12;
                  v94[7] = v66 >> 10;
                  break;
                case 4uLL:
                  *(_DWORD *)int v41 = v43 + 16 * v12 + (v66 << 18) + 8;
                  break;
                case 3uLL:
                  int v68 = 16 * v12 + v43 + (v66 << 14);
                  *(_WORD *)(v94 + 3) = v68;
                  v94[5] = BYTE2(v68);
                  break;
              }
              int v47 = 0;
              unint64_t v11 = &v88[v54] - v41;
            }
            else
            {
LABEL_111:
              unint64_t v11 = sub_1DD29DC68(v41, v107 - v94 - 3, v108, v12);
              int v47 = 1;
            }
            unsigned int v15 = v86;
LABEL_61:
            if (v11 > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11) {
              goto LABEL_99;
            }
            unint64_t v48 = &v41[v11];
            BOOL v49 = *(_DWORD *)(a1 + 228) > 0x39u;
            if (v107 - v48 < 4) {
              return -70;
            }
            int v87 = v47;
            if ((unint64_t)v13 >= 0x7F)
            {
              if ((unint64_t)v13 >> 8 > 0x7E)
              {
                *unint64_t v48 = -1;
                *(_WORD *)(v48 + 1) = v13 - 32512;
                unint64_t v50 = v48 + 3;
              }
              else
              {
                *unint64_t v48 = BYTE1(v13) ^ 0x80;
                v48[1] = v13;
                unint64_t v50 = v48 + 2;
              }
            }
            else
            {
              *unint64_t v48 = v13;
              unint64_t v50 = v48 + 1;
              if (!v13)
              {
                int v51 = 1;
                unint64_t v11 = 1;
                goto LABEL_86;
              }
            }
            unsigned int v55 = v50 + 1;
            if (v102)
            {
              *unint64_t v50 = (LOBYTE(v113[0]) << 6) + 16 * LOBYTE(v113[1]) + 4 * LOBYTE(v113[2]);
              memcpy(v50 + 1, &v113[3], v122[1]);
              unsigned int v56 = (unint64_t *)&v55[v122[1]];
              unint64_t v57 = sub_1DD29E590(v56, v107 - (char *)v56, v96, (uint64_t)v100, v98, (uint64_t)v99, v97, (uint64_t)v101, v106, v13, v49);
              unint64_t v11 = v57;
              if (v57 >= 0xFFFFFFFFFFFFFF89) {
                return v11;
              }
              unint64_t v58 = (char *)v56 + v57;
              if (v123 && v123 + v57 < 4) {
                goto LABEL_99;
              }
            }
            else
            {
              *unint64_t v50 = -4;
              unint64_t v59 = sub_1DD29E590((unint64_t *)(v50 + 1), v107 - v55, v96, (uint64_t)v100, v98, (uint64_t)v99, v97, (uint64_t)v101, v106, v13, v49);
              unint64_t v11 = v59;
              if (v59 >= 0xFFFFFFFFFFFFFF89) {
                return v11;
              }
              unint64_t v58 = &v55[v59];
            }
            if (v58 - v50 < 4) {
              goto LABEL_99;
            }
            unint64_t v11 = v58 - v48;
            if ((unint64_t)(v58 - v48) > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11)
            {
LABEL_99:
              unint64_t v16 = v90;
              goto LABEL_100;
            }
            int v51 = 0;
LABEL_86:
            uint64_t v60 = &v48[v11];
            unint64_t v11 = &v48[v11] - v94;
            if (v92) {
              int v61 = -19;
            }
            else {
              int v61 = -20;
            }
            int v62 = v61 + 8 * v11;
            *(_WORD *)unsigned int v94 = v62;
            v94[2] = BYTE2(v62);
            if (v11 > 0xFFFFFFFFFFFFFF88) {
              return v11;
            }
            if (!v11) {
              goto LABEL_99;
            }
            unint64_t v16 = v90;
            if (v11 >= v31 + v12)
            {
LABEL_100:
              unint64_t v17 = v106;
              if (v20) {
                goto LABEL_122;
              }
            }
            else
            {
              v85 += v31 + v12;
              unint64_t v108 = (unsigned int *)((char *)v108 + v12);
              v101 += v13;
              v100 += v13;
              v99 += v13;
              BOOL v63 = v103;
              if (!v87) {
                BOOL v63 = 0;
              }
              BOOL v64 = v51 == 0;
              int v65 = v102;
              if (v64) {
                int v65 = 0;
              }
              int v102 = v65;
              BOOL v103 = v63;
              unsigned int v94 = v60;
              unint64_t v17 = v91;
              unint64_t v12 = 0;
              int64_t v13 = 0;
              if (v20)
              {
LABEL_122:
                if (v103) {
                  memcpy(__dst, v84, 0x810uLL);
                }
                if (v102
                  && ((v113[0] - 1) < 2
                   || (v113[2] - 1) < 2
                   || (v113[1] - 3) > 0xFFFFFFFD))
                {
                  return 0;
                }
                if ((unint64_t)v85 < v82)
                {
                  size_t v69 = v82 - (void)v85;
                  unint64_t v11 = v82 - (void)v85 + 3;
                  if (v11 > v107 - v94) {
                    return -70;
                  }
                  int v70 = a6 + 8 * v69;
                  *(_WORD *)unsigned int v94 = v70;
                  v94[2] = BYTE2(v70);
                  memcpy(v94 + 3, v85, v69);
                  if (v11 > 0xFFFFFFFFFFFFFF88) {
                    return v11;
                  }
                  v94 += v11;
                  if (v17 < v105)
                  {
                    uint64_t v109 = *((void *)v84 + 702);
                    int v110 = *((_DWORD *)v84 + 1406);
                    if (v16 < v17)
                    {
                      int v71 = *(_DWORD *)(a1 + 1004);
                      int v72 = v109;
                      int v73 = HIDWORD(v109);
                      int v74 = v110;
                      unint64_t v75 = v16 - *(void *)(a1 + 928);
                      do
                      {
                        int v76 = *(unsigned __int16 *)(v16 + 4);
                        if (v71 == (v75 >> 3) && *(_DWORD *)(a1 + 1000) == 1) {
                          v76 |= 0x10000u;
                        }
                        int v77 = *(_DWORD *)v16;
                        if (*(_DWORD *)v16 < 4u)
                        {
                          if (v76) {
                            int v79 = *(_DWORD *)v16;
                          }
                          else {
                            int v79 = v77 + 1;
                          }
                          unsigned int v80 = v79 - 1;
                          if (v79 == 1) {
                            goto LABEL_152;
                          }
                          if (v79 == 4) {
                            int v78 = v72 - 1;
                          }
                          else {
                            int v78 = *((_DWORD *)&v109 + v80);
                          }
                          if (v80 <= 1) {
                            int v73 = v74;
                          }
                          int v110 = v73;
                          HIDWORD(v109) = v72;
                        }
                        else
                        {
                          int v110 = v73;
                          HIDWORD(v109) = v72;
                          int v78 = v77 - 3;
                        }
                        LODWORD(v109) = v78;
                        int v74 = v73;
                        int v73 = v72;
                        int v72 = v78;
LABEL_152:
                        v75 += 8;
                        v16 += 8;
                      }
                      while (v16 < v17);
                    }
                    *((void *)__dst + 702) = v109;
                    *((_DWORD *)__dst + 1406) = v110;
                  }
                }
                return v94 - v83;
              }
            }
          }
        }
        else
        {
          unint64_t v17 = v24;
          if (v20) {
            goto LABEL_122;
          }
        }
      }
      else
      {
        uint64_t v31 = 0;
        if (v21 + 6 > v104) {
          char v39 = 1;
        }
        else {
          char v39 = v20;
        }
        unint64_t v30 = v17;
        if (v39) {
          goto LABEL_36;
        }
        int64_t v13 = 0;
        if (v20) {
          goto LABEL_122;
        }
      }
    }
  }
  return v11;
}

unint64_t sub_1DD29F530(int a1, unsigned __int8 *a2, unsigned int a3, int64_t a4, unsigned __int16 *a5, uint64_t a6, unsigned __int16 *a7, char a8, unsigned int a9, void *a10)
{
  unsigned int v15 = a2;
  unsigned int v21 = a3;
  sub_1DD295A98(a10, &v21, a2, a4, (char *)a10, 0x22D8uLL);
  if (a1 == 1) {
    goto LABEL_9;
  }
  if (!a1)
  {
    if (v21 > a9) {
      return 10 * a4;
    }
    unint64_t v17 = sub_1DD29E12C(a7, a8, (int *)a10, v21);
    goto LABEL_7;
  }
  if ((a1 & 0xFFFFFFFE) != 2)
  {
LABEL_9:
    unint64_t v17 = 0;
    goto LABEL_10;
  }
  unint64_t v17 = sub_1DD29E098(a5, (unsigned int *)a10, v21);
LABEL_7:
  if (v17 > 0xFFFFFFFFFFFFFF88) {
    return 10 * a4;
  }
LABEL_10:
  if (a4 >= 1)
  {
    uint64_t v19 = &v15[a4];
    do
    {
      int v20 = v15;
      if (a6) {
        int v20 = (unsigned __int8 *)(a6 + *v15);
      }
      v17 += *v20;
      ++v15;
    }
    while (v15 < v19);
  }
  return v17 >> 3;
}

uint64_t sub_1DD29F640(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(result + 112);
  int v5 = *(_DWORD *)(result + 272);
  uint64_t v6 = *(void *)(result + 128);
  uint64_t v7 = *(void *)(result + 8);
  uint64_t v8 = *(unsigned int *)(result + 44);
  uint64_t v9 = v7 + v8;
  unint64_t v10 = a2 - 8;
  unint64_t v11 = v7 + v8 + 2;
  if (a4 != 1)
  {
    if (v11 > v10) {
      return result;
    }
    int v27 = *(_DWORD *)(result + 260);
    int v28 = *(_DWORD *)(result + 264);
    uint64_t result = (64 - v27);
    char v29 = 32 - v27;
    char v30 = 64 - v28;
    int v31 = v5 - 5;
    while (1)
    {
      unint64_t v32 = 0;
      int v33 = v8;
      do
      {
        switch(v31)
        {
          case 0:
            uint64_t v34 = *(void *)(v9 + v32);
            unint64_t v35 = 0xCF1BBCDCBB000000 * v34;
            goto LABEL_31;
          case 1:
            uint64_t v34 = *(void *)(v9 + v32);
            unint64_t v35 = 0xCF1BBCDCBF9B0000 * v34;
            goto LABEL_31;
          case 2:
            uint64_t v34 = *(void *)(v9 + v32);
            unint64_t v35 = 0xCF1BBCDCBFA56300 * v34;
            goto LABEL_31;
          case 3:
            uint64_t v34 = *(void *)(v9 + v32);
            unint64_t v35 = 0xCF1BBCDCB7A56463 * v34;
LABEL_31:
            unint64_t v36 = v35 >> result;
            break;
          default:
            unint64_t v36 = (-1640531535 * *(_DWORD *)(v9 + v32)) >> v29;
            uint64_t v34 = *(void *)(v9 + v32);
            break;
        }
        unint64_t v37 = (0xCF1BBCDCB7A56463 * v34) >> v30;
        if (v32)
        {
          if (*(_DWORD *)(v4 + 4 * v37))
          {
            if (!a3) {
              break;
            }
            goto LABEL_38;
          }
        }
        else
        {
          *(_DWORD *)(v6 + 4 * v36) = v9 - v7;
        }
        *(_DWORD *)(v4 + 4 * v37) = v33;
        if (!a3) {
          break;
        }
LABEL_38:
        ++v33;
        BOOL v25 = v32++ >= 2;
      }
      while (!v25);
      unint64_t v38 = v9 + 5;
      v9 += 3;
      LODWORD(v8) = v8 + 3;
      if (v38 > v10) {
        return result;
      }
    }
  }
  if (v11 > v10) {
    return result;
  }
  int v12 = *(_DWORD *)(result + 260);
  int v13 = *(_DWORD *)(result + 264);
  uint64_t result = (56 - v12);
  char v14 = 24 - v12;
  char v15 = 56 - v13;
  int v16 = v8 << 8;
  int v17 = v5 - 5;
  do
  {
    unint64_t v18 = 0;
    int v19 = v16;
    do
    {
      switch(v17)
      {
        case 0:
          uint64_t v20 = *(void *)(v9 + v18);
          unint64_t v21 = 0xCF1BBCDCBB000000 * v20;
          goto LABEL_11;
        case 1:
          uint64_t v20 = *(void *)(v9 + v18);
          unint64_t v21 = 0xCF1BBCDCBF9B0000 * v20;
          goto LABEL_11;
        case 2:
          uint64_t v20 = *(void *)(v9 + v18);
          unint64_t v21 = 0xCF1BBCDCBFA56300 * v20;
          goto LABEL_11;
        case 3:
          uint64_t v20 = *(void *)(v9 + v18);
          unint64_t v21 = 0xCF1BBCDCB7A56463 * v20;
LABEL_11:
          unint64_t v22 = v21 >> result;
          break;
        default:
          unint64_t v22 = (-1640531535 * *(_DWORD *)(v9 + v18)) >> v14;
          uint64_t v20 = *(void *)(v9 + v18);
          break;
      }
      unint64_t v23 = (0xCF1BBCDCB7A56463 * v20) >> v15;
      unint64_t v24 = v23 >> 8;
      if (v18)
      {
        if (*(_DWORD *)(v4 + 4 * v24))
        {
          if (!a3) {
            break;
          }
          goto LABEL_18;
        }
      }
      else
      {
        *(_DWORD *)(v6 + ((v22 >> 6) & 0x3FFFFFFFFFFFFFCLL)) = v22 | ((v9 - v7) << 8);
      }
      *(_DWORD *)(v4 + 4 * v24) = v19 + v23;
      if (!a3) {
        break;
      }
LABEL_18:
      v19 += 256;
      BOOL v25 = v18++ >= 2;
    }
    while (!v25);
    unint64_t v26 = v9 + 5;
    v9 += 3;
    v16 += 768;
  }
  while (v26 <= v10);
  return result;
}

unint64_t sub_1DD29F930(uint64_t a1, uint64_t a2, unsigned int *a3, unint64_t a4, uint64_t a5)
{
  int v6 = *(_DWORD *)(a1 + 272);
  switch(v6)
  {
    case 5:
      uint64_t v131 = *(void *)(a1 + 8);
      unint64_t v8 = a4 + a5;
      unsigned int v132 = 1 << *(_DWORD *)(a1 + 256);
      unsigned int v133 = *(_DWORD *)(a1 + 24);
      BOOL v134 = *(_DWORD *)(a1 + 40) == 0;
      if (v134 && v8 - v131 - v133 > v132) {
        uint64_t v135 = v8 - v131 - v132;
      }
      else {
        uint64_t v135 = v133;
      }
      unint64_t v136 = v8 - 8;
      unsigned int v15 = *a3;
      unsigned int v14 = a3[1];
      unint64_t v489 = v131 + v135;
      if (v131 + v135 == a4) {
        unint64_t v16 = a4 + 1;
      }
      else {
        unint64_t v16 = a4;
      }
      int v137 = v16 - v131;
      BOOL v138 = v16 - v131 - v133 > v132;
      int v139 = v16 - v131 - v132;
      if (!v134 || !v138) {
        int v139 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v20 = v137 - v139;
      if (v14 <= v137 - v139) {
        int64_t v21 = v14;
      }
      else {
        int64_t v21 = 0;
      }
      if (v15 <= v20) {
        int64_t v22 = v15;
      }
      else {
        int64_t v22 = 0;
      }
      _X8 = (void *)(v16 + 1);
      if (v16 + 1 <= v136)
      {
        unsigned int v505 = v135;
        uint64_t v141 = *(void *)(a1 + 112);
        int v537 = 64 - *(_DWORD *)(a1 + 260);
        int v541 = 64 - *(_DWORD *)(a1 + 264);
        unint64_t v509 = v8 - 1;
        unint64_t v513 = v8 - 3;
        unint64_t v529 = v8;
        uint64_t v533 = *(void *)(a1 + 128);
        unint64_t v521 = v8 - 7;
        v525 = (char *)(v8 - 32);
        uint64_t v481 = v131 + 12;
        uint64_t v485 = v131 - 1;
        uint64_t v477 = v131 + 16;
        unsigned int v497 = *a3;
        unsigned int v501 = a3[1];
        unsigned int v493 = v20;
        v517 = a3;
        while (1)
        {
          unint64_t v142 = v16 + 256;
          uint64_t v143 = *(void *)v16;
          unint64_t v144 = (0xCF1BBCDCB7A56463 * *(void *)v16) >> v541;
          uint64_t v145 = *(unsigned int *)(v141 + 4 * v144);
          char v146 = (void *)(v131 + v145);
          unint64_t v147 = 1;
          while (1)
          {
            unint64_t v148 = (0xCF1BBCDCBB000000 * v143) >> v537;
            uint64_t v149 = *(unsigned int *)(v533 + 4 * v148);
            int v150 = v16 - v131;
            *(_DWORD *)(v533 + 4 * v148) = v16 - v131;
            *(_DWORD *)(v141 + 4 * v144) = v16 - v131;
            if (v22)
            {
              unint64_t v151 = v16 + 1;
              if (*(_DWORD *)(v16 + 1 - v22) == *(_DWORD *)(v16 + 1))
              {
                uint64_t v156 = (char *)(v16 + 5);
                v157 = (void *)(v16 + 5 - v22);
                unint64_t v158 = v521;
                if (v521 <= v16 + 5)
                {
                  unint64_t v162 = (_DWORD *)(v16 + 5);
                  uint64_t v161 = v525;
                }
                else
                {
                  unint64_t v159 = *(void *)v156 ^ *v157;
                  if (v159)
                  {
                    unint64_t v160 = __clz(__rbit64(v159)) >> 3;
                    uint64_t v161 = v525;
                    goto LABEL_234;
                  }
                  unint64_t v209 = v16 + 13;
                  uint64_t v161 = v525;
                  while (1)
                  {
                    v210 = (void *)(v209 + v159);
                    if (v209 + v159 >= v521) {
                      break;
                    }
                    uint64_t v211 = *(void *)(v16 + 13 - v22 + v159);
                    v159 += 8;
                    unint64_t v212 = *v210 ^ v211;
                    if (v212)
                    {
                      unint64_t v160 = v159 + (__clz(__rbit64(v212)) >> 3);
                      goto LABEL_234;
                    }
                  }
                  unint64_t v162 = (_DWORD *)(v16 + v159 + 13);
                  v157 = (void *)((char *)v162 - v22);
                }
                if ((unint64_t)v162 < v513 && *(_DWORD *)v157 == *v162)
                {
                  ++v162;
                  v157 = (void *)((char *)v157 + 4);
                }
                if ((unint64_t)v162 < v509 && *(unsigned __int16 *)v157 == *(unsigned __int16 *)v162)
                {
                  unint64_t v162 = (_DWORD *)((char *)v162 + 2);
                  v157 = (void *)((char *)v157 + 2);
                }
                if ((unint64_t)v162 < v8 && *(unsigned __int8 *)v157 == *(unsigned __int8 *)v162) {
                  unint64_t v162 = (_DWORD *)((char *)v162 + 1);
                }
                unint64_t v160 = (char *)v162 - v156;
LABEL_234:
                uint64_t v163 = v151 - a4;
                v164 = *(_OWORD **)(a2 + 24);
                if (v151 > (unint64_t)v161)
                {
                  sub_1DD29DBFC(v164, (char *)a4, v151, v161);
                  goto LABEL_236;
                }
                _OWORD *v164 = *(_OWORD *)a4;
                uint64_t v167 = *(void *)(a2 + 24);
                if ((unint64_t)v163 <= 0x10)
                {
                  *(void *)(a2 + 24) = v167 + v163;
                  uint64_t v165 = *(void *)(a2 + 8);
                }
                else
                {
                  *(_OWORD *)(v167 + 16) = *(_OWORD *)(a4 + 16);
                  if (v163 >= 33)
                  {
                    unint64_t v168 = v167 + v163;
                    unsigned __int8 v169 = (_OWORD *)(v167 + 32);
                    unint64_t v170 = (long long *)(a4 + 48);
                    do
                    {
                      *unsigned __int8 v169 = *(v170 - 1);
                      long long v171 = *v170;
                      v170 += 2;
                      v169[1] = v171;
                      v169 += 2;
                    }
                    while ((unint64_t)v169 < v168);
                  }
LABEL_236:
                  *(void *)(a2 + 24) += v163;
                  uint64_t v165 = *(void *)(a2 + 8);
                  if ((unint64_t)v163 >= 0x10000)
                  {
                    unint64_t v166 = (unint64_t)(v165 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v166;
                  }
                  uint64_t v161 = v525;
                  unint64_t v8 = v529;
                  unint64_t v158 = v521;
                }
                unint64_t v185 = v160 + 4;
                *(_WORD *)(v165 + 4) = v163;
                *(_DWORD *)uint64_t v165 = 1;
                __int16 v186 = v160 + 1;
                unint64_t v187 = (v160 + 1) >> 16;
                int64_t v188 = v22;
                int64_t v189 = v22;
                if (!v187) {
                  goto LABEL_258;
                }
LABEL_257:
                unint64_t v190 = (unint64_t)(v165 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v190;
                int64_t v189 = v188;
                goto LABEL_258;
              }
            }
            unint64_t v144 = (0xCF1BBCDCB7A56463 * *_X8) >> v541;
            if (v145 > v505 && *v146 == v143) {
              break;
            }
            uint64_t v145 = *(unsigned int *)(v141 + 4 * v144);
            char v146 = (void *)(v131 + v145);
            if (v149 > v505)
            {
              uint64_t v152 = v131 + v149;
              if (*(_DWORD *)(v131 + v149) == *(_DWORD *)v16)
              {
                if (v145 > v505 && *v146 == *_X8)
                {
                  uint64_t v177 = (char *)(_X8 + 1);
                  uint64_t v178 = v146 + 1;
                  unint64_t v158 = v521;
                  uint64_t v161 = v525;
                  if (v521 <= (unint64_t)(_X8 + 1))
                  {
                    v227 = _X8 + 1;
                  }
                  else
                  {
                    unint64_t v179 = *(void *)v177 ^ *v178;
                    if (v179)
                    {
                      unint64_t v180 = __clz(__rbit64(v179)) >> 3;
                      goto LABEL_354;
                    }
                    uint64_t v238 = 0;
                    v239 = _X8 + 2;
                    while (1)
                    {
                      v240 = &v239[v238];
                      if ((unint64_t)&v239[v238] >= v521) {
                        break;
                      }
                      uint64_t v241 = *(void *)(v477 + v145 + v238 * 8);
                      ++v238;
                      unint64_t v242 = *v240 ^ v241;
                      if (v242)
                      {
                        unint64_t v180 = v238 * 8 + (__clz(__rbit64(v242)) >> 3);
                        goto LABEL_354;
                      }
                    }
                    v227 = &_X8[v238 + 2];
                    uint64_t v178 = (void *)(v477 + v145 + v238 * 8);
                  }
                  if ((unint64_t)v227 < v513 && *(_DWORD *)v178 == *v227)
                  {
                    ++v227;
                    uint64_t v178 = (void *)((char *)v178 + 4);
                  }
                  if ((unint64_t)v227 < v509 && *(unsigned __int16 *)v178 == *(unsigned __int16 *)v227)
                  {
                    v227 = (_DWORD *)((char *)v227 + 2);
                    uint64_t v178 = (void *)((char *)v178 + 2);
                  }
                  if ((unint64_t)v227 < v8 && *(unsigned __int8 *)v178 == *(unsigned __int8 *)v227) {
                    v227 = (_DWORD *)((char *)v227 + 1);
                  }
                  unint64_t v180 = (char *)v227 - v177;
LABEL_354:
                  unint64_t v185 = v180 + 8;
                  int64_t v188 = (char *)_X8 - (char *)v146;
                  if ((unint64_t)_X8 <= a4)
                  {
                    unint64_t v151 = (unint64_t)_X8;
                  }
                  else
                  {
                    v216 = (unsigned __int8 *)_X8 - 1;
                    v228 = (unsigned __int8 *)(v485 + v145);
                    while (*v216 == *v228)
                    {
                      ++v185;
                      unint64_t v214 = v216 - 1;
                      if ((unint64_t)v216 > a4)
                      {
                        --v216;
                        BOOL v96 = (unint64_t)v228-- > v489;
                        if (v96) {
                          continue;
                        }
                      }
                      goto LABEL_359;
                    }
LABEL_331:
                    unint64_t v151 = (unint64_t)(v216 + 1);
                  }
                  goto LABEL_361;
                }
                char v181 = (char *)(v16 + 4);
                unint64_t v182 = (void *)(v152 + 4);
                unint64_t v158 = v521;
                uint64_t v161 = v525;
                if (v521 <= v16 + 4)
                {
                  unsigned __int8 v213 = (_DWORD *)(v16 + 4);
                }
                else
                {
                  unint64_t v183 = *(void *)v181 ^ *v182;
                  if (v183)
                  {
                    unint64_t v184 = __clz(__rbit64(v183)) >> 3;
LABEL_326:
                    unint64_t v185 = v184 + 4;
                    int64_t v188 = v16 - v152;
                    if (v16 <= a4)
                    {
                      unint64_t v151 = v16;
                    }
                    else
                    {
                      unint64_t v214 = (unsigned __int8 *)(v16 - 1);
                      unint64_t v215 = (unsigned __int8 *)(v485 + v149);
                      while (*v214 == *v215)
                      {
                        ++v185;
                        v216 = v214 - 1;
                        if ((unint64_t)v214 > a4)
                        {
                          --v214;
                          BOOL v96 = (unint64_t)v215-- > v489;
                          if (v96) {
                            continue;
                          }
                        }
                        goto LABEL_331;
                      }
LABEL_359:
                      unint64_t v151 = (unint64_t)(v214 + 1);
                    }
                    goto LABEL_361;
                  }
                  uint64_t v222 = 0;
                  unint64_t v223 = v16 + 12;
                  while (1)
                  {
                    v224 = (void *)(v223 + v222);
                    if (v223 + v222 >= v521) {
                      break;
                    }
                    uint64_t v225 = *(void *)(v481 + v149 + v222);
                    v222 += 8;
                    unint64_t v226 = *v224 ^ v225;
                    if (v226)
                    {
                      unint64_t v184 = v222 + (__clz(__rbit64(v226)) >> 3);
                      goto LABEL_326;
                    }
                  }
                  unsigned __int8 v213 = (_DWORD *)(v16 + v222 + 12);
                  unint64_t v182 = (void *)(v481 + v149 + v222);
                }
                if ((unint64_t)v213 < v513 && *(_DWORD *)v182 == *v213)
                {
                  ++v213;
                  unint64_t v182 = (void *)((char *)v182 + 4);
                }
                if ((unint64_t)v213 < v509 && *(unsigned __int16 *)v182 == *(unsigned __int16 *)v213)
                {
                  unsigned __int8 v213 = (_DWORD *)((char *)v213 + 2);
                  unint64_t v182 = (void *)((char *)v182 + 2);
                }
                if ((unint64_t)v213 < v8 && *(unsigned __int8 *)v182 == *(unsigned __int8 *)v213) {
                  unsigned __int8 v213 = (_DWORD *)((char *)v213 + 1);
                }
                unint64_t v184 = (char *)v213 - v181;
                goto LABEL_326;
              }
            }
            if ((unint64_t)_X8 >= v142)
            {
              __asm
              {
                PRFM            #0, [X8,#0x40]
                PRFM            #0, [X8,#0x80]
              }
              ++v147;
              v142 += 256;
            }
            __asm { PRFM            #0, [X8,#0x100] }
            unint64_t v16 = (unint64_t)_X8;
            uint64_t v143 = *_X8;
            _X8 = (void *)((char *)_X8 + v147);
            if ((unint64_t)_X8 > v136) {
              goto LABEL_397;
            }
          }
          unint64_t v172 = (char *)(v16 + 8);
          uint64_t v173 = v146 + 1;
          unint64_t v158 = v521;
          if (v521 <= v16 + 8)
          {
            uint64_t v205 = (_DWORD *)(v16 + 8);
            unint64_t v175 = v489;
            uint64_t v161 = v525;
            goto LABEL_293;
          }
          unint64_t v174 = *(void *)v172 ^ *v173;
          unint64_t v175 = v489;
          uint64_t v161 = v525;
          if (v174)
          {
            unint64_t v176 = __clz(__rbit64(v174)) >> 3;
            goto LABEL_303;
          }
          unint64_t v217 = 0;
          unint64_t v218 = v16 + 16;
          while (2)
          {
            v219 = (void *)(v218 + v217);
            if (v218 + v217 >= v521)
            {
              uint64_t v205 = (_DWORD *)(v16 + v217 + 16);
              uint64_t v173 = &v146[v217 / 8 + 2];
LABEL_293:
              if ((unint64_t)v205 < v513 && *(_DWORD *)v173 == *v205)
              {
                ++v205;
                uint64_t v173 = (void *)((char *)v173 + 4);
              }
              if ((unint64_t)v205 < v509 && *(unsigned __int16 *)v173 == *(unsigned __int16 *)v205)
              {
                uint64_t v205 = (_DWORD *)((char *)v205 + 2);
                uint64_t v173 = (void *)((char *)v173 + 2);
              }
              if ((unint64_t)v205 < v8 && *(unsigned __int8 *)v173 == *(unsigned __int8 *)v205) {
                uint64_t v205 = (_DWORD *)((char *)v205 + 1);
              }
              unint64_t v176 = (char *)v205 - v172;
              goto LABEL_303;
            }
            uint64_t v220 = v146[v217 / 8 + 2];
            v217 += 8;
            unint64_t v221 = *v219 ^ v220;
            if (!v221) {
              continue;
            }
            break;
          }
          unint64_t v176 = v217 + (__clz(__rbit64(v221)) >> 3);
LABEL_303:
          unint64_t v185 = v176 + 8;
          int64_t v188 = v16 - (void)v146;
          if ((unint64_t)v146 <= v175 || v16 <= a4)
          {
            unint64_t v151 = v16;
          }
          else
          {
            unint64_t v206 = (unsigned __int8 *)(v16 - 1);
            unsigned __int8 v207 = (unsigned __int8 *)v146 - 1;
            while (*v206 == *v207)
            {
              ++v185;
              v208 = v206 - 1;
              if ((unint64_t)v206 > a4)
              {
                --v206;
                BOOL v96 = (unint64_t)v207-- > v175;
                if (v96) {
                  continue;
                }
              }
              unint64_t v151 = (unint64_t)(v208 + 1);
              goto LABEL_361;
            }
            unint64_t v151 = (unint64_t)(v206 + 1);
          }
LABEL_361:
          if (v147 <= 3) {
            *(_DWORD *)(v141 + 4 * v144) = _X8 - v131;
          }
          uint64_t v229 = v151 - a4;
          v230 = *(_OWORD **)(a2 + 24);
          if (v151 > (unint64_t)v161)
          {
            int64_t v231 = v188;
            sub_1DD29DBFC(v230, (char *)a4, v151, v161);
            int64_t v188 = v231;
            unint64_t v158 = v521;
            unint64_t v8 = v529;
            goto LABEL_369;
          }
          _OWORD *v230 = *(_OWORD *)a4;
          uint64_t v232 = *(void *)(a2 + 24);
          if ((unint64_t)v229 <= 0x10)
          {
            *(void *)(a2 + 24) = v232 + v229;
            uint64_t v165 = *(void *)(a2 + 8);
          }
          else
          {
            *(_OWORD *)(v232 + 16) = *(_OWORD *)(a4 + 16);
            if (v229 >= 33)
            {
              unint64_t v233 = v232 + v229;
              v234 = (_OWORD *)(v232 + 32);
              v235 = (long long *)(a4 + 48);
              do
              {
                _OWORD *v234 = *(v235 - 1);
                long long v236 = *v235;
                v235 += 2;
                v234[1] = v236;
                v234 += 2;
              }
              while ((unint64_t)v234 < v233);
            }
LABEL_369:
            *(void *)(a2 + 24) += v229;
            uint64_t v165 = *(void *)(a2 + 8);
            if ((unint64_t)v229 >= 0x10000)
            {
              unint64_t v237 = (unint64_t)(v165 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v237;
            }
            uint64_t v161 = v525;
          }
          *(_WORD *)(v165 + 4) = v229;
          *(_DWORD *)uint64_t v165 = v188 + 3;
          __int16 v186 = v185 - 3;
          int64_t v21 = v22;
          int64_t v189 = v188;
          if (v185 - 3 >= 0x10000) {
            goto LABEL_257;
          }
LABEL_258:
          *(_WORD *)(v165 + 6) = v186;
          *(void *)(a2 + 8) = v165 + 8;
          unint64_t v16 = v151 + v185;
          if (v151 + v185 <= v136)
          {
            uint64_t v191 = *(void *)(v131 + (v150 + 2));
            *(_DWORD *)(v141 + 4 * ((0xCF1BBCDCB7A56463 * v191) >> v541)) = v150 + 2;
            *(_DWORD *)(v141 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v16 - 2)) >> v541)) = v16 - 2 - v131;
            *(_DWORD *)(v533 + 4 * ((0xCF1BBCDCBB000000 * v191) >> v537)) = v150 + 2;
            *(_DWORD *)(v533 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v16 - 1)) >> v537)) = v16 - 1 - v131;
            while (1)
            {
              int64_t v77 = v189;
              int64_t v189 = v21;
              if (!v21 || *(_DWORD *)v16 != *(_DWORD *)(v16 - v21)) {
                break;
              }
              unint64_t v192 = (char *)(v16 + 4);
              unint64_t v193 = (void *)(v16 + 4 - v21);
              if (v158 <= v16 + 4)
              {
                v196 = (_DWORD *)(v16 + 4);
              }
              else
              {
                unint64_t v194 = *(void *)v192 ^ *v193;
                if (v194)
                {
                  unint64_t v195 = __clz(__rbit64(v194)) >> 3;
                  goto LABEL_277;
                }
                unint64_t v201 = v16 + 12;
                while (1)
                {
                  uint64_t v202 = (void *)(v201 + v194);
                  if (v201 + v194 >= v158) {
                    break;
                  }
                  uint64_t v203 = *(void *)(v16 + 12 - v21 + v194);
                  v194 += 8;
                  unint64_t v204 = *v202 ^ v203;
                  if (v204)
                  {
                    unint64_t v195 = v194 + (__clz(__rbit64(v204)) >> 3);
                    goto LABEL_277;
                  }
                }
                v196 = (_DWORD *)(v16 + v194 + 12);
                unint64_t v193 = (void *)((char *)v196 - v21);
              }
              if ((unint64_t)v196 < v513 && *(_DWORD *)v193 == *v196)
              {
                ++v196;
                unint64_t v193 = (void *)((char *)v193 + 4);
              }
              if ((unint64_t)v196 < v509 && *(unsigned __int16 *)v193 == *(unsigned __int16 *)v196)
              {
                v196 = (_DWORD *)((char *)v196 + 2);
                unint64_t v193 = (void *)((char *)v193 + 2);
              }
              if ((unint64_t)v196 < v8 && *(unsigned __int8 *)v193 == *(unsigned __int8 *)v196) {
                v196 = (_DWORD *)((char *)v196 + 1);
              }
              unint64_t v195 = (char *)v196 - v192;
LABEL_277:
              uint64_t v197 = *(void *)v16;
              *(_DWORD *)(v533 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v16) >> v537)) = v16 - v131;
              *(_DWORD *)(v141 + 4 * ((0xCF1BBCDCB7A56463 * v197) >> v541)) = v16 - v131;
              uint64_t v198 = *(_OWORD **)(a2 + 24);
              if (v16 <= (unint64_t)v161)
              {
                *uint64_t v198 = *(_OWORD *)v16;
              }
              else
              {
                sub_1DD29DBFC(v198, (char *)v16, v16, v161);
                unint64_t v158 = v521;
                uint64_t v161 = v525;
                unint64_t v8 = v529;
              }
              uint64_t v199 = *(void *)(a2 + 8);
              *(_WORD *)(v199 + 4) = 0;
              *(_DWORD *)uint64_t v199 = 1;
              if (v195 + 1 >= 0x10000)
              {
                unint64_t v200 = (unint64_t)(v199 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v200;
              }
              *(_WORD *)(v199 + 6) = v195 + 1;
              *(void *)(a2 + 8) = v199 + 8;
              v16 += v195 + 4;
              int64_t v21 = v77;
              int64_t v22 = v189;
              if (v16 > v136) {
                goto LABEL_290;
              }
            }
            int64_t v22 = v77;
            int64_t v77 = v21;
          }
          else
          {
            int64_t v22 = v189;
            int64_t v77 = v21;
          }
LABEL_290:
          _X8 = (void *)(v16 + 1);
          a4 = v16;
          int64_t v21 = v77;
          a3 = v517;
          unsigned int v15 = v497;
          unsigned int v14 = v501;
          unsigned int v20 = v493;
          if (v16 + 1 > v136) {
            goto LABEL_398;
          }
        }
      }
LABEL_397:
      LODWORD(v77) = v21;
      unint64_t v16 = a4;
      goto LABEL_398;
    case 6:
      uint64_t v243 = *(void *)(a1 + 8);
      unint64_t v8 = a4 + a5;
      unsigned int v244 = 1 << *(_DWORD *)(a1 + 256);
      unsigned int v245 = *(_DWORD *)(a1 + 24);
      BOOL v246 = *(_DWORD *)(a1 + 40) == 0;
      if (v246 && v8 - v243 - v245 > v244) {
        uint64_t v247 = v8 - v243 - v244;
      }
      else {
        uint64_t v247 = v245;
      }
      unint64_t v248 = v8 - 8;
      unsigned int v15 = *a3;
      unsigned int v14 = a3[1];
      unint64_t v490 = v243 + v247;
      if (v243 + v247 == a4) {
        unint64_t v16 = a4 + 1;
      }
      else {
        unint64_t v16 = a4;
      }
      int v249 = v16 - v243;
      BOOL v250 = v16 - v243 - v245 > v244;
      int v251 = v16 - v243 - v244;
      if (!v246 || !v250) {
        int v251 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v20 = v249 - v251;
      if (v14 <= v249 - v251) {
        int64_t v21 = v14;
      }
      else {
        int64_t v21 = 0;
      }
      if (v15 <= v20) {
        int64_t v22 = v15;
      }
      else {
        int64_t v22 = 0;
      }
      _X8 = (void *)(v16 + 1);
      if (v16 + 1 <= v248)
      {
        unsigned int v506 = v247;
        uint64_t v276 = *(void *)(a1 + 112);
        int v538 = 64 - *(_DWORD *)(a1 + 260);
        int v542 = 64 - *(_DWORD *)(a1 + 264);
        unint64_t v510 = v8 - 1;
        unint64_t v514 = v8 - 3;
        unint64_t v530 = v8;
        uint64_t v534 = *(void *)(a1 + 128);
        unint64_t v522 = v8 - 7;
        v526 = (char *)(v8 - 32);
        uint64_t v482 = v243 + 12;
        uint64_t v486 = v243 - 1;
        uint64_t v478 = v243 + 16;
        unsigned int v498 = *a3;
        unsigned int v502 = a3[1];
        unsigned int v494 = v20;
        v518 = a3;
        while (1)
        {
          unint64_t v277 = v16 + 256;
          uint64_t v278 = *(void *)v16;
          unint64_t v279 = (0xCF1BBCDCB7A56463 * *(void *)v16) >> v542;
          uint64_t v280 = *(unsigned int *)(v276 + 4 * v279);
          v281 = (void *)(v243 + v280);
          unint64_t v282 = 1;
          while (1)
          {
            unint64_t v283 = (0xCF1BBCDCBF9B0000 * v278) >> v538;
            uint64_t v284 = *(unsigned int *)(v534 + 4 * v283);
            int v285 = v16 - v243;
            *(_DWORD *)(v534 + 4 * v283) = v16 - v243;
            *(_DWORD *)(v276 + 4 * v279) = v16 - v243;
            if (v22)
            {
              unint64_t v286 = v16 + 1;
              if (*(_DWORD *)(v16 + 1 - v22) == *(_DWORD *)(v16 + 1))
              {
                v291 = (char *)(v16 + 5);
                v292 = (void *)(v16 + 5 - v22);
                unint64_t v293 = v522;
                if (v522 <= v16 + 5)
                {
                  v297 = (_DWORD *)(v16 + 5);
                  v296 = v526;
                }
                else
                {
                  unint64_t v294 = *(void *)v291 ^ *v292;
                  if (v294)
                  {
                    unint64_t v295 = __clz(__rbit64(v294)) >> 3;
                    v296 = v526;
                    goto LABEL_475;
                  }
                  unint64_t v344 = v16 + 13;
                  v296 = v526;
                  while (1)
                  {
                    v345 = (void *)(v344 + v294);
                    if (v344 + v294 >= v522) {
                      break;
                    }
                    uint64_t v346 = *(void *)(v16 + 13 - v22 + v294);
                    v294 += 8;
                    unint64_t v347 = *v345 ^ v346;
                    if (v347)
                    {
                      unint64_t v295 = v294 + (__clz(__rbit64(v347)) >> 3);
                      goto LABEL_475;
                    }
                  }
                  v297 = (_DWORD *)(v16 + v294 + 13);
                  v292 = (void *)((char *)v297 - v22);
                }
                if ((unint64_t)v297 < v514 && *(_DWORD *)v292 == *v297)
                {
                  ++v297;
                  v292 = (void *)((char *)v292 + 4);
                }
                if ((unint64_t)v297 < v510 && *(unsigned __int16 *)v292 == *(unsigned __int16 *)v297)
                {
                  v297 = (_DWORD *)((char *)v297 + 2);
                  v292 = (void *)((char *)v292 + 2);
                }
                if ((unint64_t)v297 < v8 && *(unsigned __int8 *)v292 == *(unsigned __int8 *)v297) {
                  v297 = (_DWORD *)((char *)v297 + 1);
                }
                unint64_t v295 = (char *)v297 - v291;
LABEL_475:
                uint64_t v298 = v286 - a4;
                v299 = *(_OWORD **)(a2 + 24);
                if (v286 > (unint64_t)v296)
                {
                  sub_1DD29DBFC(v299, (char *)a4, v286, v296);
                  goto LABEL_477;
                }
                _OWORD *v299 = *(_OWORD *)a4;
                uint64_t v302 = *(void *)(a2 + 24);
                if ((unint64_t)v298 <= 0x10)
                {
                  *(void *)(a2 + 24) = v302 + v298;
                  uint64_t v300 = *(void *)(a2 + 8);
                }
                else
                {
                  *(_OWORD *)(v302 + 16) = *(_OWORD *)(a4 + 16);
                  if (v298 >= 33)
                  {
                    unint64_t v303 = v302 + v298;
                    v304 = (_OWORD *)(v302 + 32);
                    v305 = (long long *)(a4 + 48);
                    do
                    {
                      _OWORD *v304 = *(v305 - 1);
                      long long v306 = *v305;
                      v305 += 2;
                      v304[1] = v306;
                      v304 += 2;
                    }
                    while ((unint64_t)v304 < v303);
                  }
LABEL_477:
                  *(void *)(a2 + 24) += v298;
                  uint64_t v300 = *(void *)(a2 + 8);
                  if ((unint64_t)v298 >= 0x10000)
                  {
                    unint64_t v301 = (unint64_t)(v300 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v301;
                  }
                  v296 = v526;
                  unint64_t v8 = v530;
                  unint64_t v293 = v522;
                }
                unint64_t v320 = v295 + 4;
                *(_WORD *)(v300 + 4) = v298;
                *(_DWORD *)uint64_t v300 = 1;
                __int16 v321 = v295 + 1;
                unint64_t v322 = (v295 + 1) >> 16;
                int64_t v323 = v22;
                int64_t v324 = v22;
                if (!v322) {
                  goto LABEL_499;
                }
LABEL_498:
                unint64_t v325 = (unint64_t)(v300 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v325;
                int64_t v324 = v323;
                goto LABEL_499;
              }
            }
            unint64_t v279 = (0xCF1BBCDCB7A56463 * *_X8) >> v542;
            if (v280 > v506 && *v281 == v278) {
              break;
            }
            uint64_t v280 = *(unsigned int *)(v276 + 4 * v279);
            v281 = (void *)(v243 + v280);
            if (v284 > v506)
            {
              uint64_t v287 = v243 + v284;
              if (*(_DWORD *)(v243 + v284) == *(_DWORD *)v16)
              {
                if (v280 > v506 && *v281 == *_X8)
                {
                  v312 = (char *)(_X8 + 1);
                  v313 = v281 + 1;
                  unint64_t v293 = v522;
                  v296 = v526;
                  if (v522 <= (unint64_t)(_X8 + 1))
                  {
                    v362 = _X8 + 1;
                  }
                  else
                  {
                    unint64_t v314 = *(void *)v312 ^ *v313;
                    if (v314)
                    {
                      unint64_t v315 = __clz(__rbit64(v314)) >> 3;
                      goto LABEL_595;
                    }
                    uint64_t v373 = 0;
                    v374 = _X8 + 2;
                    while (1)
                    {
                      v375 = &v374[v373];
                      if ((unint64_t)&v374[v373] >= v522) {
                        break;
                      }
                      uint64_t v376 = *(void *)(v478 + v280 + v373 * 8);
                      ++v373;
                      unint64_t v377 = *v375 ^ v376;
                      if (v377)
                      {
                        unint64_t v315 = v373 * 8 + (__clz(__rbit64(v377)) >> 3);
                        goto LABEL_595;
                      }
                    }
                    v362 = &_X8[v373 + 2];
                    v313 = (void *)(v478 + v280 + v373 * 8);
                  }
                  if ((unint64_t)v362 < v514 && *(_DWORD *)v313 == *v362)
                  {
                    ++v362;
                    v313 = (void *)((char *)v313 + 4);
                  }
                  if ((unint64_t)v362 < v510 && *(unsigned __int16 *)v313 == *(unsigned __int16 *)v362)
                  {
                    v362 = (_DWORD *)((char *)v362 + 2);
                    v313 = (void *)((char *)v313 + 2);
                  }
                  if ((unint64_t)v362 < v8 && *(unsigned __int8 *)v313 == *(unsigned __int8 *)v362) {
                    v362 = (_DWORD *)((char *)v362 + 1);
                  }
                  unint64_t v315 = (char *)v362 - v312;
LABEL_595:
                  unint64_t v320 = v315 + 8;
                  int64_t v323 = (char *)_X8 - (char *)v281;
                  if ((unint64_t)_X8 <= a4)
                  {
                    unint64_t v286 = (unint64_t)_X8;
                  }
                  else
                  {
                    v351 = (unsigned __int8 *)_X8 - 1;
                    v363 = (unsigned __int8 *)(v486 + v280);
                    while (*v351 == *v363)
                    {
                      ++v320;
                      v349 = v351 - 1;
                      if ((unint64_t)v351 > a4)
                      {
                        --v351;
                        BOOL v96 = (unint64_t)v363-- > v490;
                        if (v96) {
                          continue;
                        }
                      }
                      goto LABEL_600;
                    }
LABEL_572:
                    unint64_t v286 = (unint64_t)(v351 + 1);
                  }
                  goto LABEL_602;
                }
                v316 = (char *)(v16 + 4);
                v317 = (void *)(v287 + 4);
                unint64_t v293 = v522;
                v296 = v526;
                if (v522 <= v16 + 4)
                {
                  v348 = (_DWORD *)(v16 + 4);
                }
                else
                {
                  unint64_t v318 = *(void *)v316 ^ *v317;
                  if (v318)
                  {
                    unint64_t v319 = __clz(__rbit64(v318)) >> 3;
LABEL_567:
                    unint64_t v320 = v319 + 4;
                    int64_t v323 = v16 - v287;
                    if (v16 <= a4)
                    {
                      unint64_t v286 = v16;
                    }
                    else
                    {
                      v349 = (unsigned __int8 *)(v16 - 1);
                      v350 = (unsigned __int8 *)(v486 + v284);
                      while (*v349 == *v350)
                      {
                        ++v320;
                        v351 = v349 - 1;
                        if ((unint64_t)v349 > a4)
                        {
                          --v349;
                          BOOL v96 = (unint64_t)v350-- > v490;
                          if (v96) {
                            continue;
                          }
                        }
                        goto LABEL_572;
                      }
LABEL_600:
                      unint64_t v286 = (unint64_t)(v349 + 1);
                    }
                    goto LABEL_602;
                  }
                  uint64_t v357 = 0;
                  unint64_t v358 = v16 + 12;
                  while (1)
                  {
                    v359 = (void *)(v358 + v357);
                    if (v358 + v357 >= v522) {
                      break;
                    }
                    uint64_t v360 = *(void *)(v482 + v284 + v357);
                    v357 += 8;
                    unint64_t v361 = *v359 ^ v360;
                    if (v361)
                    {
                      unint64_t v319 = v357 + (__clz(__rbit64(v361)) >> 3);
                      goto LABEL_567;
                    }
                  }
                  v348 = (_DWORD *)(v16 + v357 + 12);
                  v317 = (void *)(v482 + v284 + v357);
                }
                if ((unint64_t)v348 < v514 && *(_DWORD *)v317 == *v348)
                {
                  ++v348;
                  v317 = (void *)((char *)v317 + 4);
                }
                if ((unint64_t)v348 < v510 && *(unsigned __int16 *)v317 == *(unsigned __int16 *)v348)
                {
                  v348 = (_DWORD *)((char *)v348 + 2);
                  v317 = (void *)((char *)v317 + 2);
                }
                if ((unint64_t)v348 < v8 && *(unsigned __int8 *)v317 == *(unsigned __int8 *)v348) {
                  v348 = (_DWORD *)((char *)v348 + 1);
                }
                unint64_t v319 = (char *)v348 - v316;
                goto LABEL_567;
              }
            }
            if ((unint64_t)_X8 >= v277)
            {
              __asm
              {
                PRFM            #0, [X8,#0x40]
                PRFM            #0, [X8,#0x80]
              }
              ++v282;
              v277 += 256;
            }
            __asm { PRFM            #0, [X8,#0x100] }
            unint64_t v16 = (unint64_t)_X8;
            uint64_t v278 = *_X8;
            _X8 = (void *)((char *)_X8 + v282);
            if ((unint64_t)_X8 > v248) {
              goto LABEL_397;
            }
          }
          v307 = (char *)(v16 + 8);
          v308 = v281 + 1;
          unint64_t v293 = v522;
          if (v522 <= v16 + 8)
          {
            v340 = (_DWORD *)(v16 + 8);
            unint64_t v310 = v490;
            v296 = v526;
            goto LABEL_534;
          }
          unint64_t v309 = *(void *)v307 ^ *v308;
          unint64_t v310 = v490;
          v296 = v526;
          if (v309)
          {
            unint64_t v311 = __clz(__rbit64(v309)) >> 3;
            goto LABEL_544;
          }
          unint64_t v352 = 0;
          unint64_t v353 = v16 + 16;
          while (2)
          {
            v354 = (void *)(v353 + v352);
            if (v353 + v352 >= v522)
            {
              v340 = (_DWORD *)(v16 + v352 + 16);
              v308 = &v281[v352 / 8 + 2];
LABEL_534:
              if ((unint64_t)v340 < v514 && *(_DWORD *)v308 == *v340)
              {
                ++v340;
                v308 = (void *)((char *)v308 + 4);
              }
              if ((unint64_t)v340 < v510 && *(unsigned __int16 *)v308 == *(unsigned __int16 *)v340)
              {
                v340 = (_DWORD *)((char *)v340 + 2);
                v308 = (void *)((char *)v308 + 2);
              }
              if ((unint64_t)v340 < v8 && *(unsigned __int8 *)v308 == *(unsigned __int8 *)v340) {
                v340 = (_DWORD *)((char *)v340 + 1);
              }
              unint64_t v311 = (char *)v340 - v307;
              goto LABEL_544;
            }
            uint64_t v355 = v281[v352 / 8 + 2];
            v352 += 8;
            unint64_t v356 = *v354 ^ v355;
            if (!v356) {
              continue;
            }
            break;
          }
          unint64_t v311 = v352 + (__clz(__rbit64(v356)) >> 3);
LABEL_544:
          unint64_t v320 = v311 + 8;
          int64_t v323 = v16 - (void)v281;
          if ((unint64_t)v281 <= v310 || v16 <= a4)
          {
            unint64_t v286 = v16;
          }
          else
          {
            v341 = (unsigned __int8 *)(v16 - 1);
            v342 = (unsigned __int8 *)v281 - 1;
            while (*v341 == *v342)
            {
              ++v320;
              v343 = v341 - 1;
              if ((unint64_t)v341 > a4)
              {
                --v341;
                BOOL v96 = (unint64_t)v342-- > v310;
                if (v96) {
                  continue;
                }
              }
              unint64_t v286 = (unint64_t)(v343 + 1);
              goto LABEL_602;
            }
            unint64_t v286 = (unint64_t)(v341 + 1);
          }
LABEL_602:
          if (v282 <= 3) {
            *(_DWORD *)(v276 + 4 * v279) = _X8 - v243;
          }
          uint64_t v364 = v286 - a4;
          v365 = *(_OWORD **)(a2 + 24);
          if (v286 > (unint64_t)v296)
          {
            int64_t v366 = v323;
            sub_1DD29DBFC(v365, (char *)a4, v286, v296);
            int64_t v323 = v366;
            unint64_t v293 = v522;
            unint64_t v8 = v530;
            goto LABEL_610;
          }
          _OWORD *v365 = *(_OWORD *)a4;
          uint64_t v367 = *(void *)(a2 + 24);
          if ((unint64_t)v364 <= 0x10)
          {
            *(void *)(a2 + 24) = v367 + v364;
            uint64_t v300 = *(void *)(a2 + 8);
          }
          else
          {
            *(_OWORD *)(v367 + 16) = *(_OWORD *)(a4 + 16);
            if (v364 >= 33)
            {
              unint64_t v368 = v367 + v364;
              v369 = (_OWORD *)(v367 + 32);
              v370 = (long long *)(a4 + 48);
              do
              {
                _OWORD *v369 = *(v370 - 1);
                long long v371 = *v370;
                v370 += 2;
                v369[1] = v371;
                v369 += 2;
              }
              while ((unint64_t)v369 < v368);
            }
LABEL_610:
            *(void *)(a2 + 24) += v364;
            uint64_t v300 = *(void *)(a2 + 8);
            if ((unint64_t)v364 >= 0x10000)
            {
              unint64_t v372 = (unint64_t)(v300 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v372;
            }
            v296 = v526;
          }
          *(_WORD *)(v300 + 4) = v364;
          *(_DWORD *)uint64_t v300 = v323 + 3;
          __int16 v321 = v320 - 3;
          int64_t v21 = v22;
          int64_t v324 = v323;
          if (v320 - 3 >= 0x10000) {
            goto LABEL_498;
          }
LABEL_499:
          *(_WORD *)(v300 + 6) = v321;
          *(void *)(a2 + 8) = v300 + 8;
          unint64_t v16 = v286 + v320;
          if (v286 + v320 <= v248)
          {
            uint64_t v326 = *(void *)(v243 + (v285 + 2));
            *(_DWORD *)(v276 + 4 * ((0xCF1BBCDCB7A56463 * v326) >> v542)) = v285 + 2;
            *(_DWORD *)(v276 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v16 - 2)) >> v542)) = v16 - 2 - v243;
            *(_DWORD *)(v534 + 4 * ((0xCF1BBCDCBF9B0000 * v326) >> v538)) = v285 + 2;
            *(_DWORD *)(v534 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v16 - 1)) >> v538)) = v16 - 1 - v243;
            while (1)
            {
              int64_t v77 = v324;
              int64_t v324 = v21;
              if (!v21 || *(_DWORD *)v16 != *(_DWORD *)(v16 - v21)) {
                break;
              }
              v327 = (char *)(v16 + 4);
              v328 = (void *)(v16 + 4 - v21);
              if (v293 <= v16 + 4)
              {
                v331 = (_DWORD *)(v16 + 4);
              }
              else
              {
                unint64_t v329 = *(void *)v327 ^ *v328;
                if (v329)
                {
                  unint64_t v330 = __clz(__rbit64(v329)) >> 3;
                  goto LABEL_518;
                }
                unint64_t v336 = v16 + 12;
                while (1)
                {
                  v337 = (void *)(v336 + v329);
                  if (v336 + v329 >= v293) {
                    break;
                  }
                  uint64_t v338 = *(void *)(v16 + 12 - v21 + v329);
                  v329 += 8;
                  unint64_t v339 = *v337 ^ v338;
                  if (v339)
                  {
                    unint64_t v330 = v329 + (__clz(__rbit64(v339)) >> 3);
                    goto LABEL_518;
                  }
                }
                v331 = (_DWORD *)(v16 + v329 + 12);
                v328 = (void *)((char *)v331 - v21);
              }
              if ((unint64_t)v331 < v514 && *(_DWORD *)v328 == *v331)
              {
                ++v331;
                v328 = (void *)((char *)v328 + 4);
              }
              if ((unint64_t)v331 < v510 && *(unsigned __int16 *)v328 == *(unsigned __int16 *)v331)
              {
                v331 = (_DWORD *)((char *)v331 + 2);
                v328 = (void *)((char *)v328 + 2);
              }
              if ((unint64_t)v331 < v8 && *(unsigned __int8 *)v328 == *(unsigned __int8 *)v331) {
                v331 = (_DWORD *)((char *)v331 + 1);
              }
              unint64_t v330 = (char *)v331 - v327;
LABEL_518:
              uint64_t v332 = *(void *)v16;
              *(_DWORD *)(v534 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v16) >> v538)) = v16 - v243;
              *(_DWORD *)(v276 + 4 * ((0xCF1BBCDCB7A56463 * v332) >> v542)) = v16 - v243;
              v333 = *(_OWORD **)(a2 + 24);
              if (v16 <= (unint64_t)v296)
              {
                _OWORD *v333 = *(_OWORD *)v16;
              }
              else
              {
                sub_1DD29DBFC(v333, (char *)v16, v16, v296);
                unint64_t v293 = v522;
                v296 = v526;
                unint64_t v8 = v530;
              }
              uint64_t v334 = *(void *)(a2 + 8);
              *(_WORD *)(v334 + 4) = 0;
              *(_DWORD *)uint64_t v334 = 1;
              if (v330 + 1 >= 0x10000)
              {
                unint64_t v335 = (unint64_t)(v334 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v335;
              }
              *(_WORD *)(v334 + 6) = v330 + 1;
              *(void *)(a2 + 8) = v334 + 8;
              v16 += v330 + 4;
              int64_t v21 = v77;
              int64_t v22 = v324;
              if (v16 > v248) {
                goto LABEL_531;
              }
            }
            int64_t v22 = v77;
            int64_t v77 = v21;
          }
          else
          {
            int64_t v22 = v324;
            int64_t v77 = v21;
          }
LABEL_531:
          _X8 = (void *)(v16 + 1);
          a4 = v16;
          int64_t v21 = v77;
          a3 = v518;
          unsigned int v15 = v498;
          unsigned int v14 = v502;
          unsigned int v20 = v494;
          if (v16 + 1 > v248) {
            goto LABEL_398;
          }
        }
      }
      goto LABEL_397;
    case 7:
      uint64_t v7 = *(void *)(a1 + 8);
      unint64_t v8 = a4 + a5;
      unsigned int v9 = 1 << *(_DWORD *)(a1 + 256);
      unsigned int v10 = *(_DWORD *)(a1 + 24);
      BOOL v11 = *(_DWORD *)(a1 + 40) == 0;
      if (v11 && v8 - v7 - v10 > v9) {
        uint64_t v12 = v8 - v7 - v9;
      }
      else {
        uint64_t v12 = v10;
      }
      unint64_t v13 = v8 - 8;
      unsigned int v15 = *a3;
      unsigned int v14 = a3[1];
      unint64_t v488 = v7 + v12;
      if (v7 + v12 == a4) {
        unint64_t v16 = a4 + 1;
      }
      else {
        unint64_t v16 = a4;
      }
      int v17 = v16 - v7;
      BOOL v18 = v16 - v7 - v10 > v9;
      int v19 = v16 - v7 - v9;
      if (!v11 || !v18) {
        int v19 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v20 = v17 - v19;
      if (v14 <= v17 - v19) {
        int64_t v21 = v14;
      }
      else {
        int64_t v21 = 0;
      }
      if (v15 <= v20) {
        int64_t v22 = v15;
      }
      else {
        int64_t v22 = 0;
      }
      _X8 = (void *)(v16 + 1);
      if (v16 + 1 <= v13)
      {
        unsigned int v504 = v12;
        uint64_t v24 = *(void *)(a1 + 112);
        int v536 = 64 - *(_DWORD *)(a1 + 260);
        int v540 = 64 - *(_DWORD *)(a1 + 264);
        unint64_t v508 = v8 - 1;
        unint64_t v512 = v8 - 3;
        unint64_t v528 = v8;
        uint64_t v532 = *(void *)(a1 + 128);
        unint64_t v520 = v8 - 7;
        v524 = (char *)(v8 - 32);
        uint64_t v480 = v7 + 12;
        uint64_t v484 = v7 - 1;
        uint64_t v476 = v7 + 16;
        unsigned int v496 = *a3;
        unsigned int v500 = a3[1];
        unsigned int v492 = v20;
        v516 = a3;
        while (1)
        {
          unint64_t v25 = v16 + 256;
          uint64_t v26 = *(void *)v16;
          unint64_t v27 = (0xCF1BBCDCB7A56463 * *(void *)v16) >> v540;
          uint64_t v28 = *(unsigned int *)(v24 + 4 * v27);
          char v29 = (void *)(v7 + v28);
          unint64_t v30 = 1;
          while (1)
          {
            unint64_t v31 = (0xCF1BBCDCBFA56300 * v26) >> v536;
            uint64_t v32 = *(unsigned int *)(v532 + 4 * v31);
            int v33 = v16 - v7;
            *(_DWORD *)(v532 + 4 * v31) = v16 - v7;
            *(_DWORD *)(v24 + 4 * v27) = v16 - v7;
            if (v22)
            {
              unint64_t v34 = v16 + 1;
              if (*(_DWORD *)(v16 + 1 - v22) == *(_DWORD *)(v16 + 1))
              {
                uint64_t v42 = (char *)(v16 + 5);
                int v43 = (void *)(v16 + 5 - v22);
                unint64_t v44 = v520;
                if (v520 <= v16 + 5)
                {
                  unint64_t v48 = (_DWORD *)(v16 + 5);
                  int v47 = v524;
                }
                else
                {
                  unint64_t v45 = *(void *)v42 ^ *v43;
                  if (v45)
                  {
                    unint64_t v46 = __clz(__rbit64(v45)) >> 3;
                    int v47 = v524;
                    goto LABEL_45;
                  }
                  unint64_t v97 = v16 + 13;
                  int v47 = v524;
                  while (1)
                  {
                    uint64_t v98 = (void *)(v97 + v45);
                    if (v97 + v45 >= v520) {
                      break;
                    }
                    uint64_t v99 = *(void *)(v16 + 13 - v22 + v45);
                    v45 += 8;
                    unint64_t v100 = *v98 ^ v99;
                    if (v100)
                    {
                      unint64_t v46 = v45 + (__clz(__rbit64(v100)) >> 3);
                      goto LABEL_45;
                    }
                  }
                  unint64_t v48 = (_DWORD *)(v16 + v45 + 13);
                  int v43 = (void *)((char *)v48 - v22);
                }
                if ((unint64_t)v48 < v512 && *(_DWORD *)v43 == *v48)
                {
                  ++v48;
                  int v43 = (void *)((char *)v43 + 4);
                }
                if ((unint64_t)v48 < v508 && *(unsigned __int16 *)v43 == *(unsigned __int16 *)v48)
                {
                  unint64_t v48 = (_DWORD *)((char *)v48 + 2);
                  int v43 = (void *)((char *)v43 + 2);
                }
                if ((unint64_t)v48 < v8 && *(unsigned __int8 *)v43 == *(unsigned __int8 *)v48) {
                  unint64_t v48 = (_DWORD *)((char *)v48 + 1);
                }
                unint64_t v46 = (char *)v48 - v42;
LABEL_45:
                uint64_t v49 = v34 - a4;
                unint64_t v50 = *(_OWORD **)(a2 + 24);
                if (v34 > (unint64_t)v47)
                {
                  sub_1DD29DBFC(v50, (char *)a4, v34, v47);
                  goto LABEL_47;
                }
                *unint64_t v50 = *(_OWORD *)a4;
                uint64_t v53 = *(void *)(a2 + 24);
                if ((unint64_t)v49 <= 0x10)
                {
                  *(void *)(a2 + 24) = v53 + v49;
                  uint64_t v51 = *(void *)(a2 + 8);
                }
                else
                {
                  *(_OWORD *)(v53 + 16) = *(_OWORD *)(a4 + 16);
                  if (v49 >= 33)
                  {
                    unint64_t v54 = v53 + v49;
                    unsigned int v55 = (_OWORD *)(v53 + 32);
                    unsigned int v56 = (long long *)(a4 + 48);
                    do
                    {
                      *unsigned int v55 = *(v56 - 1);
                      long long v57 = *v56;
                      v56 += 2;
                      v55[1] = v57;
                      v55 += 2;
                    }
                    while ((unint64_t)v55 < v54);
                  }
LABEL_47:
                  *(void *)(a2 + 24) += v49;
                  uint64_t v51 = *(void *)(a2 + 8);
                  if ((unint64_t)v49 >= 0x10000)
                  {
                    unint64_t v52 = (unint64_t)(v51 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 1;
                    *(_DWORD *)(a2 + 76) = v52;
                  }
                  int v47 = v524;
                  unint64_t v8 = v528;
                  unint64_t v44 = v520;
                }
                unint64_t v71 = v46 + 4;
                *(_WORD *)(v51 + 4) = v49;
                *(_DWORD *)uint64_t v51 = 1;
                __int16 v72 = v46 + 1;
                unint64_t v73 = (v46 + 1) >> 16;
                int64_t v74 = v22;
                int64_t v75 = v22;
                if (!v73) {
                  goto LABEL_69;
                }
LABEL_68:
                unint64_t v76 = (unint64_t)(v51 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v76;
                int64_t v75 = v74;
                goto LABEL_69;
              }
            }
            unint64_t v27 = (0xCF1BBCDCB7A56463 * *_X8) >> v540;
            if (v28 > v504 && *v29 == v26) {
              break;
            }
            uint64_t v28 = *(unsigned int *)(v24 + 4 * v27);
            char v29 = (void *)(v7 + v28);
            if (v32 > v504)
            {
              uint64_t v35 = v7 + v32;
              if (*(_DWORD *)(v7 + v32) == *(_DWORD *)v16)
              {
                if (v28 > v504 && *v29 == *_X8)
                {
                  BOOL v63 = (char *)(_X8 + 1);
                  BOOL v64 = v29 + 1;
                  unint64_t v44 = v520;
                  int v47 = v524;
                  if (v520 <= (unint64_t)(_X8 + 1))
                  {
                    long long v115 = _X8 + 1;
                  }
                  else
                  {
                    unint64_t v65 = *(void *)v63 ^ *v64;
                    if (v65)
                    {
                      unint64_t v66 = __clz(__rbit64(v65)) >> 3;
                      goto LABEL_165;
                    }
                    uint64_t v126 = 0;
                    unint64_t v127 = _X8 + 2;
                    while (1)
                    {
                      unint64_t v128 = &v127[v126];
                      if ((unint64_t)&v127[v126] >= v520) {
                        break;
                      }
                      uint64_t v129 = *(void *)(v476 + v28 + v126 * 8);
                      ++v126;
                      unint64_t v130 = *v128 ^ v129;
                      if (v130)
                      {
                        unint64_t v66 = v126 * 8 + (__clz(__rbit64(v130)) >> 3);
                        goto LABEL_165;
                      }
                    }
                    long long v115 = &_X8[v126 + 2];
                    BOOL v64 = (void *)(v476 + v28 + v126 * 8);
                  }
                  if ((unint64_t)v115 < v512 && *(_DWORD *)v64 == *v115)
                  {
                    ++v115;
                    BOOL v64 = (void *)((char *)v64 + 4);
                  }
                  if ((unint64_t)v115 < v508 && *(unsigned __int16 *)v64 == *(unsigned __int16 *)v115)
                  {
                    long long v115 = (_DWORD *)((char *)v115 + 2);
                    BOOL v64 = (void *)((char *)v64 + 2);
                  }
                  if ((unint64_t)v115 < v8 && *(unsigned __int8 *)v64 == *(unsigned __int8 *)v115) {
                    long long v115 = (_DWORD *)((char *)v115 + 1);
                  }
                  unint64_t v66 = (char *)v115 - v63;
LABEL_165:
                  unint64_t v71 = v66 + 8;
                  int64_t v74 = (char *)_X8 - (char *)v29;
                  if ((unint64_t)_X8 <= a4)
                  {
                    unint64_t v34 = (unint64_t)_X8;
                  }
                  else
                  {
                    unint64_t v104 = (unsigned __int8 *)_X8 - 1;
                    long long v116 = (unsigned __int8 *)(v484 + v28);
                    while (*v104 == *v116)
                    {
                      ++v71;
                      int v102 = v104 - 1;
                      if ((unint64_t)v104 > a4)
                      {
                        --v104;
                        BOOL v96 = (unint64_t)v116-- > v488;
                        if (v96) {
                          continue;
                        }
                      }
                      goto LABEL_170;
                    }
LABEL_142:
                    unint64_t v34 = (unint64_t)(v104 + 1);
                  }
                  goto LABEL_172;
                }
                unint64_t v67 = (char *)(v16 + 4);
                int v68 = (void *)(v35 + 4);
                unint64_t v44 = v520;
                int v47 = v524;
                if (v520 <= v16 + 4)
                {
                  uint64_t v101 = (_DWORD *)(v16 + 4);
                }
                else
                {
                  unint64_t v69 = *(void *)v67 ^ *v68;
                  if (v69)
                  {
                    unint64_t v70 = __clz(__rbit64(v69)) >> 3;
LABEL_137:
                    unint64_t v71 = v70 + 4;
                    int64_t v74 = v16 - v35;
                    if (v16 <= a4)
                    {
                      unint64_t v34 = v16;
                    }
                    else
                    {
                      int v102 = (unsigned __int8 *)(v16 - 1);
                      BOOL v103 = (unsigned __int8 *)(v484 + v32);
                      while (*v102 == *v103)
                      {
                        ++v71;
                        unint64_t v104 = v102 - 1;
                        if ((unint64_t)v102 > a4)
                        {
                          --v102;
                          BOOL v96 = (unint64_t)v103-- > v488;
                          if (v96) {
                            continue;
                          }
                        }
                        goto LABEL_142;
                      }
LABEL_170:
                      unint64_t v34 = (unint64_t)(v102 + 1);
                    }
                    goto LABEL_172;
                  }
                  uint64_t v110 = 0;
                  unint64_t v111 = v16 + 12;
                  while (1)
                  {
                    unint64_t v112 = (void *)(v111 + v110);
                    if (v111 + v110 >= v520) {
                      break;
                    }
                    uint64_t v113 = *(void *)(v480 + v32 + v110);
                    v110 += 8;
                    unint64_t v114 = *v112 ^ v113;
                    if (v114)
                    {
                      unint64_t v70 = v110 + (__clz(__rbit64(v114)) >> 3);
                      goto LABEL_137;
                    }
                  }
                  uint64_t v101 = (_DWORD *)(v16 + v110 + 12);
                  int v68 = (void *)(v480 + v32 + v110);
                }
                if ((unint64_t)v101 < v512 && *(_DWORD *)v68 == *v101)
                {
                  ++v101;
                  int v68 = (void *)((char *)v68 + 4);
                }
                if ((unint64_t)v101 < v508 && *(unsigned __int16 *)v68 == *(unsigned __int16 *)v101)
                {
                  uint64_t v101 = (_DWORD *)((char *)v101 + 2);
                  int v68 = (void *)((char *)v68 + 2);
                }
                if ((unint64_t)v101 < v8 && *(unsigned __int8 *)v68 == *(unsigned __int8 *)v101) {
                  uint64_t v101 = (_DWORD *)((char *)v101 + 1);
                }
                unint64_t v70 = (char *)v101 - v67;
                goto LABEL_137;
              }
            }
            if ((unint64_t)_X8 >= v25)
            {
              __asm
              {
                PRFM            #0, [X8,#0x40]
                PRFM            #0, [X8,#0x80]
              }
              ++v30;
              v25 += 256;
            }
            __asm { PRFM            #0, [X8,#0x100] }
            unint64_t v16 = (unint64_t)_X8;
            uint64_t v26 = *_X8;
            _X8 = (void *)((char *)_X8 + v30);
            if ((unint64_t)_X8 > v13) {
              goto LABEL_397;
            }
          }
          unint64_t v58 = (char *)(v16 + 8);
          unint64_t v59 = v29 + 1;
          unint64_t v44 = v520;
          if (v520 <= v16 + 8)
          {
            int v92 = (_DWORD *)(v16 + 8);
            unint64_t v61 = v488;
            int v47 = v524;
            goto LABEL_104;
          }
          unint64_t v60 = *(void *)v58 ^ *v59;
          unint64_t v61 = v488;
          int v47 = v524;
          if (v60)
          {
            unint64_t v62 = __clz(__rbit64(v60)) >> 3;
            goto LABEL_114;
          }
          unint64_t v105 = 0;
          unint64_t v106 = v16 + 16;
          while (2)
          {
            uint64_t v107 = (void *)(v106 + v105);
            if (v106 + v105 >= v520)
            {
              int v92 = (_DWORD *)(v16 + v105 + 16);
              unint64_t v59 = &v29[v105 / 8 + 2];
LABEL_104:
              if ((unint64_t)v92 < v512 && *(_DWORD *)v59 == *v92)
              {
                ++v92;
                unint64_t v59 = (void *)((char *)v59 + 4);
              }
              if ((unint64_t)v92 < v508 && *(unsigned __int16 *)v59 == *(unsigned __int16 *)v92)
              {
                int v92 = (_DWORD *)((char *)v92 + 2);
                unint64_t v59 = (void *)((char *)v59 + 2);
              }
              if ((unint64_t)v92 < v8 && *(unsigned __int8 *)v59 == *(unsigned __int8 *)v92) {
                int v92 = (_DWORD *)((char *)v92 + 1);
              }
              unint64_t v62 = (char *)v92 - v58;
              goto LABEL_114;
            }
            uint64_t v108 = v29[v105 / 8 + 2];
            v105 += 8;
            unint64_t v109 = *v107 ^ v108;
            if (!v109) {
              continue;
            }
            break;
          }
          unint64_t v62 = v105 + (__clz(__rbit64(v109)) >> 3);
LABEL_114:
          unint64_t v71 = v62 + 8;
          int64_t v74 = v16 - (void)v29;
          if ((unint64_t)v29 <= v61 || v16 <= a4)
          {
            unint64_t v34 = v16;
          }
          else
          {
            unint64_t v93 = (unsigned __int8 *)(v16 - 1);
            unsigned int v94 = (unsigned __int8 *)v29 - 1;
            while (*v93 == *v94)
            {
              ++v71;
              uint64_t v95 = v93 - 1;
              if ((unint64_t)v93 > a4)
              {
                --v93;
                BOOL v96 = (unint64_t)v94-- > v61;
                if (v96) {
                  continue;
                }
              }
              unint64_t v34 = (unint64_t)(v95 + 1);
              goto LABEL_172;
            }
            unint64_t v34 = (unint64_t)(v93 + 1);
          }
LABEL_172:
          if (v30 <= 3) {
            *(_DWORD *)(v24 + 4 * v27) = _X8 - v7;
          }
          uint64_t v117 = v34 - a4;
          long long v118 = *(_OWORD **)(a2 + 24);
          if (v34 > (unint64_t)v47)
          {
            int64_t v119 = v74;
            sub_1DD29DBFC(v118, (char *)a4, v34, v47);
            int64_t v74 = v119;
            unint64_t v44 = v520;
            unint64_t v8 = v528;
            goto LABEL_180;
          }
          *long long v118 = *(_OWORD *)a4;
          uint64_t v120 = *(void *)(a2 + 24);
          if ((unint64_t)v117 <= 0x10)
          {
            *(void *)(a2 + 24) = v120 + v117;
            uint64_t v51 = *(void *)(a2 + 8);
          }
          else
          {
            *(_OWORD *)(v120 + 16) = *(_OWORD *)(a4 + 16);
            if (v117 >= 33)
            {
              unint64_t v121 = v120 + v117;
              uint64_t v122 = (_OWORD *)(v120 + 32);
              uint64_t v123 = (long long *)(a4 + 48);
              do
              {
                *uint64_t v122 = *(v123 - 1);
                long long v124 = *v123;
                v123 += 2;
                v122[1] = v124;
                v122 += 2;
              }
              while ((unint64_t)v122 < v121);
            }
LABEL_180:
            *(void *)(a2 + 24) += v117;
            uint64_t v51 = *(void *)(a2 + 8);
            if ((unint64_t)v117 >= 0x10000)
            {
              unint64_t v125 = (unint64_t)(v51 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v125;
            }
            int v47 = v524;
          }
          *(_WORD *)(v51 + 4) = v117;
          *(_DWORD *)uint64_t v51 = v74 + 3;
          __int16 v72 = v71 - 3;
          int64_t v21 = v22;
          int64_t v75 = v74;
          if (v71 - 3 >= 0x10000) {
            goto LABEL_68;
          }
LABEL_69:
          *(_WORD *)(v51 + 6) = v72;
          *(void *)(a2 + 8) = v51 + 8;
          unint64_t v16 = v34 + v71;
          if (v34 + v71 > v13)
          {
            int64_t v22 = v75;
            int64_t v77 = v21;
            goto LABEL_101;
          }
          uint64_t v78 = *(void *)(v7 + (v33 + 2));
          *(_DWORD *)(v24 + 4 * ((0xCF1BBCDCB7A56463 * v78) >> v540)) = v33 + 2;
          *(_DWORD *)(v24 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v16 - 2)) >> v540)) = v16 - 2 - v7;
          *(_DWORD *)(v532 + 4 * ((0xCF1BBCDCBFA56300 * v78) >> v536)) = v33 + 2;
          *(_DWORD *)(v532 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v16 - 1)) >> v536)) = v16 - 1 - v7;
          while (2)
          {
            int64_t v77 = v75;
            int64_t v75 = v21;
            if (v21 && *(_DWORD *)v16 == *(_DWORD *)(v16 - v21))
            {
              int v79 = (char *)(v16 + 4);
              unsigned int v80 = (void *)(v16 + 4 - v21);
              if (v44 <= v16 + 4)
              {
                unint64_t v83 = (_DWORD *)(v16 + 4);
              }
              else
              {
                unint64_t v81 = *(void *)v79 ^ *v80;
                if (v81)
                {
                  unint64_t v82 = __clz(__rbit64(v81)) >> 3;
                  goto LABEL_88;
                }
                unint64_t v88 = v16 + 12;
                while (1)
                {
                  unsigned int v89 = (void *)(v88 + v81);
                  if (v88 + v81 >= v44) {
                    break;
                  }
                  uint64_t v90 = *(void *)(v16 + 12 - v21 + v81);
                  v81 += 8;
                  unint64_t v91 = *v89 ^ v90;
                  if (v91)
                  {
                    unint64_t v82 = v81 + (__clz(__rbit64(v91)) >> 3);
                    goto LABEL_88;
                  }
                }
                unint64_t v83 = (_DWORD *)(v16 + v81 + 12);
                unsigned int v80 = (void *)((char *)v83 - v21);
              }
              if ((unint64_t)v83 < v512 && *(_DWORD *)v80 == *v83)
              {
                ++v83;
                unsigned int v80 = (void *)((char *)v80 + 4);
              }
              if ((unint64_t)v83 < v508 && *(unsigned __int16 *)v80 == *(unsigned __int16 *)v83)
              {
                unint64_t v83 = (_DWORD *)((char *)v83 + 2);
                unsigned int v80 = (void *)((char *)v80 + 2);
              }
              if ((unint64_t)v83 < v8 && *(unsigned __int8 *)v80 == *(unsigned __int8 *)v83) {
                unint64_t v83 = (_DWORD *)((char *)v83 + 1);
              }
              unint64_t v82 = (char *)v83 - v79;
LABEL_88:
              uint64_t v84 = *(void *)v16;
              *(_DWORD *)(v532 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v16) >> v536)) = v16 - v7;
              *(_DWORD *)(v24 + 4 * ((0xCF1BBCDCB7A56463 * v84) >> v540)) = v16 - v7;
              uint64_t v85 = *(_OWORD **)(a2 + 24);
              if (v16 <= (unint64_t)v47)
              {
                *uint64_t v85 = *(_OWORD *)v16;
              }
              else
              {
                sub_1DD29DBFC(v85, (char *)v16, v16, v47);
                unint64_t v44 = v520;
                int v47 = v524;
                unint64_t v8 = v528;
              }
              uint64_t v86 = *(void *)(a2 + 8);
              *(_WORD *)(v86 + 4) = 0;
              *(_DWORD *)uint64_t v86 = 1;
              if (v82 + 1 >= 0x10000)
              {
                unint64_t v87 = (unint64_t)(v86 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v87;
              }
              *(_WORD *)(v86 + 6) = v82 + 1;
              *(void *)(a2 + 8) = v86 + 8;
              v16 += v82 + 4;
              int64_t v21 = v77;
              int64_t v22 = v75;
              if (v16 > v13) {
                goto LABEL_101;
              }
              continue;
            }
            break;
          }
          int64_t v22 = v77;
          int64_t v77 = v21;
LABEL_101:
          _X8 = (void *)(v16 + 1);
          a4 = v16;
          int64_t v21 = v77;
          a3 = v516;
          unsigned int v15 = v496;
          unsigned int v14 = v500;
          unsigned int v20 = v492;
          if (v16 + 1 > v13)
          {
LABEL_398:
            if (v15 <= v20) {
              unsigned int v253 = 0;
            }
            else {
              unsigned int v253 = v15;
            }
            if (v14 <= v20) {
              unsigned int v254 = 0;
            }
            else {
              unsigned int v254 = v14;
            }
            if (v22) {
              unsigned int v255 = v22;
            }
            else {
              unsigned int v255 = v253;
            }
            if (v22) {
              _ZF = v253 == 0;
            }
            else {
              _ZF = 1;
            }
            if (_ZF) {
              unsigned int v253 = v254;
            }
            if (v77) {
              unsigned int v253 = v77;
            }
            goto LABEL_448;
          }
        }
      }
      goto LABEL_397;
  }
  uint64_t v257 = *(void *)(a1 + 8);
  unint64_t v8 = a4 + a5;
  unsigned int v258 = 1 << *(_DWORD *)(a1 + 256);
  unsigned int v259 = *(_DWORD *)(a1 + 24);
  BOOL v260 = *(_DWORD *)(a1 + 40) == 0;
  if (v260 && v8 - v257 - v259 > v258) {
    uint64_t v261 = v8 - v257 - v258;
  }
  else {
    uint64_t v261 = v259;
  }
  unint64_t v262 = v8 - 8;
  unsigned int v263 = *a3;
  unsigned int v264 = a3[1];
  if (v257 + v261 == a4) {
    unint64_t v16 = a4 + 1;
  }
  else {
    unint64_t v16 = a4;
  }
  int v265 = v16 - v257;
  BOOL v266 = v16 - v257 - v259 > v258;
  int v267 = v16 - v257 - v258;
  if (!v260 || !v266) {
    int v267 = *(_DWORD *)(a1 + 24);
  }
  unsigned int v268 = v265 - v267;
  if (v264 <= v265 - v267) {
    int64_t v269 = v264;
  }
  else {
    int64_t v269 = 0;
  }
  if (v263 <= v268) {
    int64_t v270 = v263;
  }
  else {
    int64_t v270 = 0;
  }
  _X8 = (void *)(v16 + 1);
  if (v16 + 1 > v262)
  {
LABEL_430:
    LODWORD(v272) = v269;
    unint64_t v16 = a4;
    goto LABEL_431;
  }
  unint64_t v491 = v257 + v261;
  uint64_t v378 = *(void *)(a1 + 112);
  int v543 = 64 - *(_DWORD *)(a1 + 264);
  int v539 = 32 - *(_DWORD *)(a1 + 260);
  unint64_t v531 = v8;
  uint64_t v535 = *(void *)(a1 + 128);
  unint64_t v511 = v8 - 1;
  unint64_t v515 = v8 - 3;
  unint64_t v523 = v8 - 7;
  v527 = (char *)(v8 - 32);
  uint64_t v483 = v257 + 12;
  uint64_t v487 = v257 - 1;
  uint64_t v479 = v257 + 16;
  unsigned int v503 = *a3;
  unsigned int v507 = a3[1];
  unsigned int v499 = v268;
  int v495 = v261;
  v519 = a3;
  do
  {
    unint64_t v379 = v16 + 256;
    uint64_t v380 = *(void *)v16;
    unint64_t v381 = (0xCF1BBCDCB7A56463 * *(void *)v16) >> v543;
    uint64_t v382 = *(unsigned int *)(v378 + 4 * v381);
    v383 = (void *)(v257 + v382);
    unint64_t v384 = 1;
    while (1)
    {
      unsigned int v385 = (-1640531535 * v380) >> v539;
      uint64_t v386 = *(unsigned int *)(v535 + 4 * v385);
      int v387 = v16 - v257;
      *(_DWORD *)(v535 + 4 * v385) = v16 - v257;
      *(_DWORD *)(v378 + 4 * v381) = v16 - v257;
      if (v270)
      {
        unint64_t v388 = v16 + 1;
        if (*(_DWORD *)(v16 + 1 - v270) == *(_DWORD *)(v16 + 1))
        {
          v393 = (char *)(v16 + 5);
          v394 = (void *)(v16 + 5 - v270);
          unint64_t v395 = v523;
          if (v523 <= v16 + 5)
          {
            v399 = (_DWORD *)(v16 + 5);
            v398 = v527;
          }
          else
          {
            unint64_t v396 = *(void *)v393 ^ *v394;
            if (v396)
            {
              unint64_t v397 = __clz(__rbit64(v396)) >> 3;
              v398 = v527;
              goto LABEL_649;
            }
            unint64_t v444 = v16 + 13;
            v398 = v527;
            while (1)
            {
              v445 = (void *)(v444 + v396);
              if (v444 + v396 >= v523) {
                break;
              }
              uint64_t v446 = *(void *)(v16 + 13 - v270 + v396);
              v396 += 8;
              unint64_t v447 = *v445 ^ v446;
              if (v447)
              {
                unint64_t v397 = v396 + (__clz(__rbit64(v447)) >> 3);
                goto LABEL_649;
              }
            }
            v399 = (_DWORD *)(v16 + v396 + 13);
            v394 = (void *)((char *)v399 - v270);
          }
          if ((unint64_t)v399 < v515 && *(_DWORD *)v394 == *v399)
          {
            ++v399;
            v394 = (void *)((char *)v394 + 4);
          }
          if ((unint64_t)v399 < v511 && *(unsigned __int16 *)v394 == *(unsigned __int16 *)v399)
          {
            v399 = (_DWORD *)((char *)v399 + 2);
            v394 = (void *)((char *)v394 + 2);
          }
          if ((unint64_t)v399 < v8 && *(unsigned __int8 *)v394 == *(unsigned __int8 *)v399) {
            v399 = (_DWORD *)((char *)v399 + 1);
          }
          unint64_t v397 = (char *)v399 - v393;
LABEL_649:
          uint64_t v400 = v388 - a4;
          v401 = *(_OWORD **)(a2 + 24);
          if (v388 <= (unint64_t)v398)
          {
            _OWORD *v401 = *(_OWORD *)a4;
            uint64_t v404 = *(void *)(a2 + 24);
            if ((unint64_t)v400 <= 0x10)
            {
              *(void *)(a2 + 24) = v404 + v400;
              uint64_t v402 = *(void *)(a2 + 8);
              goto LABEL_671;
            }
            *(_OWORD *)(v404 + 16) = *(_OWORD *)(a4 + 16);
            if (v400 >= 33)
            {
              unint64_t v405 = v404 + v400;
              v406 = (_OWORD *)(v404 + 32);
              v407 = (long long *)(a4 + 48);
              do
              {
                _OWORD *v406 = *(v407 - 1);
                long long v408 = *v407;
                v407 += 2;
                v406[1] = v408;
                v406 += 2;
              }
              while ((unint64_t)v406 < v405);
            }
          }
          else
          {
            sub_1DD29DBFC(v401, (char *)a4, v388, v398);
          }
          *(void *)(a2 + 24) += v400;
          uint64_t v402 = *(void *)(a2 + 8);
          if ((unint64_t)v400 >= 0x10000)
          {
            unint64_t v403 = (unint64_t)(v402 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v403;
          }
          v398 = v527;
          unint64_t v8 = v531;
          unint64_t v395 = v523;
LABEL_671:
          unint64_t v422 = v397 + 4;
          *(_WORD *)(v402 + 4) = v400;
          *(_DWORD *)uint64_t v402 = 1;
          __int16 v423 = v397 + 1;
          unint64_t v424 = (v397 + 1) >> 16;
          int64_t v425 = v270;
          int64_t v426 = v270;
          if (!v424) {
            goto LABEL_673;
          }
LABEL_672:
          unint64_t v427 = (unint64_t)(v402 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v427;
          int64_t v426 = v425;
          goto LABEL_673;
        }
      }
      uint64_t v380 = *_X8;
      unint64_t v381 = (0xCF1BBCDCB7A56463 * *_X8) >> v543;
      if (v382 > v261 && *v383 == *(void *)v16) {
        break;
      }
      uint64_t v382 = *(unsigned int *)(v378 + 4 * v381);
      v383 = (void *)(v257 + v382);
      if (v386 > v261)
      {
        uint64_t v389 = v257 + v386;
        if (*(_DWORD *)(v257 + v386) == *(_DWORD *)v16)
        {
          if (v382 > v261 && *v383 == v380)
          {
            v414 = (char *)(_X8 + 1);
            v415 = v383 + 1;
            unint64_t v395 = v523;
            v398 = v527;
            if (v523 <= (unint64_t)(_X8 + 1))
            {
              v460 = _X8 + 1;
            }
            else
            {
              unint64_t v416 = *(void *)v414 ^ *v415;
              if (v416)
              {
                unint64_t v417 = __clz(__rbit64(v416)) >> 3;
                goto LABEL_767;
              }
              uint64_t v471 = 0;
              v472 = _X8 + 2;
              while (1)
              {
                v473 = &v472[v471];
                if ((unint64_t)&v472[v471] >= v523) {
                  break;
                }
                uint64_t v474 = *(void *)(v479 + v382 + v471 * 8);
                ++v471;
                unint64_t v475 = *v473 ^ v474;
                if (v475)
                {
                  unint64_t v417 = v471 * 8 + (__clz(__rbit64(v475)) >> 3);
                  goto LABEL_767;
                }
              }
              v460 = &_X8[v471 + 2];
              v415 = (void *)(v479 + v382 + v471 * 8);
            }
            if ((unint64_t)v460 < v515 && *(_DWORD *)v415 == *v460)
            {
              ++v460;
              v415 = (void *)((char *)v415 + 4);
            }
            if ((unint64_t)v460 < v511 && *(unsigned __int16 *)v415 == *(unsigned __int16 *)v460)
            {
              v460 = (_DWORD *)((char *)v460 + 2);
              v415 = (void *)((char *)v415 + 2);
            }
            if ((unint64_t)v460 < v8 && *(unsigned __int8 *)v415 == *(unsigned __int8 *)v460) {
              v460 = (_DWORD *)((char *)v460 + 1);
            }
            unint64_t v417 = (char *)v460 - v414;
LABEL_767:
            unint64_t v422 = v417 + 8;
            int64_t v425 = (char *)_X8 - (char *)v383;
            if ((unint64_t)_X8 <= a4)
            {
              unint64_t v388 = (unint64_t)_X8;
            }
            else
            {
              v443 = (unsigned __int8 *)_X8 - 1;
              v461 = (unsigned __int8 *)(v487 + v382);
              while (*v443 == *v461)
              {
                ++v422;
                v441 = v443 - 1;
                if ((unint64_t)v443 > a4)
                {
                  --v443;
                  BOOL v96 = (unint64_t)v461-- > v491;
                  if (v96) {
                    continue;
                  }
                }
                goto LABEL_772;
              }
LABEL_745:
              unint64_t v388 = (unint64_t)(v443 + 1);
            }
            goto LABEL_773;
          }
          v418 = (char *)(v16 + 4);
          v419 = (void *)(v389 + 4);
          unint64_t v395 = v523;
          v398 = v527;
          if (v523 <= v16 + 4)
          {
            v448 = (_DWORD *)(v16 + 4);
          }
          else
          {
            unint64_t v420 = *(void *)v418 ^ *v419;
            if (v420)
            {
              unint64_t v421 = __clz(__rbit64(v420)) >> 3;
              goto LABEL_740;
            }
            uint64_t v455 = 0;
            unint64_t v456 = v16 + 12;
            while (1)
            {
              v457 = (void *)(v456 + v455);
              if (v456 + v455 >= v523) {
                break;
              }
              uint64_t v458 = *(void *)(v483 + v386 + v455);
              v455 += 8;
              unint64_t v459 = *v457 ^ v458;
              if (v459)
              {
                unint64_t v421 = v455 + (__clz(__rbit64(v459)) >> 3);
                goto LABEL_740;
              }
            }
            v448 = (_DWORD *)(v16 + v455 + 12);
            v419 = (void *)(v483 + v386 + v455);
          }
          if ((unint64_t)v448 < v515 && *(_DWORD *)v419 == *v448)
          {
            ++v448;
            v419 = (void *)((char *)v419 + 4);
          }
          if ((unint64_t)v448 < v511 && *(unsigned __int16 *)v419 == *(unsigned __int16 *)v448)
          {
            v448 = (_DWORD *)((char *)v448 + 2);
            v419 = (void *)((char *)v419 + 2);
          }
          if ((unint64_t)v448 < v8 && *(unsigned __int8 *)v419 == *(unsigned __int8 *)v448) {
            v448 = (_DWORD *)((char *)v448 + 1);
          }
          unint64_t v421 = (char *)v448 - v418;
LABEL_740:
          unint64_t v422 = v421 + 4;
          int64_t v425 = v16 - v389;
          if (v16 > a4)
          {
            v441 = (unsigned __int8 *)(v16 - 1);
            v449 = (unsigned __int8 *)(v487 + v386);
            while (*v441 == *v449)
            {
              ++v422;
              v443 = v441 - 1;
              if ((unint64_t)v441 > a4)
              {
                --v441;
                BOOL v96 = (unint64_t)v449-- > v491;
                if (v96) {
                  continue;
                }
              }
              goto LABEL_745;
            }
            goto LABEL_772;
          }
LABEL_746:
          unint64_t v388 = v16;
          goto LABEL_773;
        }
      }
      if ((unint64_t)_X8 >= v379)
      {
        __asm
        {
          PRFM            #0, [X8,#0x40]
          PRFM            #0, [X8,#0x80]
        }
        ++v384;
        v379 += 256;
      }
      __asm { PRFM            #0, [X8,#0x100] }
      unint64_t v16 = (unint64_t)_X8;
      _X8 = (void *)((char *)_X8 + v384);
      if ((unint64_t)_X8 > v262) {
        goto LABEL_430;
      }
    }
    v409 = (char *)(v16 + 8);
    v410 = v383 + 1;
    unint64_t v395 = v523;
    if (v523 <= v16 + 8)
    {
      v440 = (_DWORD *)(v16 + 8);
      unint64_t v412 = v491;
      v398 = v527;
    }
    else
    {
      unint64_t v411 = *(void *)v409 ^ *v410;
      unint64_t v412 = v491;
      v398 = v527;
      if (v411)
      {
        unint64_t v413 = __clz(__rbit64(v411)) >> 3;
        goto LABEL_718;
      }
      unint64_t v450 = 0;
      unint64_t v451 = v16 + 16;
      while (1)
      {
        v452 = (void *)(v451 + v450);
        if (v451 + v450 >= v523) {
          break;
        }
        uint64_t v453 = v383[v450 / 8 + 2];
        v450 += 8;
        unint64_t v454 = *v452 ^ v453;
        if (v454)
        {
          unint64_t v413 = v450 + (__clz(__rbit64(v454)) >> 3);
          goto LABEL_718;
        }
      }
      v440 = (_DWORD *)(v16 + v450 + 16);
      v410 = &v383[v450 / 8 + 2];
    }
    if ((unint64_t)v440 < v515 && *(_DWORD *)v410 == *v440)
    {
      ++v440;
      v410 = (void *)((char *)v410 + 4);
    }
    if ((unint64_t)v440 < v511 && *(unsigned __int16 *)v410 == *(unsigned __int16 *)v440)
    {
      v440 = (_DWORD *)((char *)v440 + 2);
      v410 = (void *)((char *)v410 + 2);
    }
    if ((unint64_t)v440 < v8 && *(unsigned __int8 *)v410 == *(unsigned __int8 *)v440) {
      v440 = (_DWORD *)((char *)v440 + 1);
    }
    unint64_t v413 = (char *)v440 - v409;
LABEL_718:
    unint64_t v422 = v413 + 8;
    int64_t v425 = v16 - (void)v383;
    if ((unint64_t)v383 <= v412 || v16 <= a4) {
      goto LABEL_746;
    }
    v441 = (unsigned __int8 *)(v16 - 1);
    v442 = (unsigned __int8 *)v383 - 1;
    while (*v441 == *v442)
    {
      ++v422;
      v443 = v441 - 1;
      if ((unint64_t)v441 > a4)
      {
        --v441;
        BOOL v96 = (unint64_t)v442-- > v412;
        if (v96) {
          continue;
        }
      }
      goto LABEL_745;
    }
LABEL_772:
    unint64_t v388 = (unint64_t)(v441 + 1);
LABEL_773:
    if (v384 <= 3) {
      *(_DWORD *)(v378 + 4 * v381) = _X8 - v257;
    }
    uint64_t v462 = v388 - a4;
    v463 = *(_OWORD **)(a2 + 24);
    if (v388 > (unint64_t)v398)
    {
      int64_t v464 = v425;
      sub_1DD29DBFC(v463, (char *)a4, v388, v398);
      int64_t v425 = v464;
      unint64_t v395 = v523;
      unint64_t v8 = v531;
      goto LABEL_781;
    }
    _OWORD *v463 = *(_OWORD *)a4;
    uint64_t v465 = *(void *)(a2 + 24);
    if ((unint64_t)v462 <= 0x10)
    {
      *(void *)(a2 + 24) = v465 + v462;
      uint64_t v402 = *(void *)(a2 + 8);
    }
    else
    {
      *(_OWORD *)(v465 + 16) = *(_OWORD *)(a4 + 16);
      if (v462 >= 33)
      {
        unint64_t v466 = v465 + v462;
        v467 = (_OWORD *)(v465 + 32);
        v468 = (long long *)(a4 + 48);
        do
        {
          _OWORD *v467 = *(v468 - 1);
          long long v469 = *v468;
          v468 += 2;
          v467[1] = v469;
          v467 += 2;
        }
        while ((unint64_t)v467 < v466);
      }
LABEL_781:
      *(void *)(a2 + 24) += v462;
      uint64_t v402 = *(void *)(a2 + 8);
      if ((unint64_t)v462 >= 0x10000)
      {
        unint64_t v470 = (unint64_t)(v402 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v470;
      }
      v398 = v527;
    }
    *(_WORD *)(v402 + 4) = v462;
    *(_DWORD *)uint64_t v402 = v425 + 3;
    __int16 v423 = v422 - 3;
    int64_t v269 = v270;
    int64_t v426 = v425;
    if (v422 - 3 >= 0x10000) {
      goto LABEL_672;
    }
LABEL_673:
    *(_WORD *)(v402 + 6) = v423;
    *(void *)(a2 + 8) = v402 + 8;
    unint64_t v16 = v388 + v422;
    if (v388 + v422 > v262)
    {
      int64_t v270 = v426;
      int64_t v272 = v269;
      unsigned int v264 = v507;
      goto LABEL_705;
    }
    *(_DWORD *)(v378 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v257 + (v387 + 2))) >> v543)) = v387 + 2;
    *(_DWORD *)(v378 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v16 - 2)) >> v543)) = v16 - 2 - v257;
    *(_DWORD *)(v535 + 4 * ((-1640531535 * *(_DWORD *)(v257 + (v387 + 2))) >> v539)) = v387 + 2;
    *(_DWORD *)(v535 + 4 * ((-1640531535 * *(_DWORD *)(v16 - 1)) >> v539)) = v16 - 1 - v257;
    unsigned int v264 = v507;
    while (2)
    {
      int64_t v272 = v426;
      int64_t v426 = v269;
      if (v269 && *(_DWORD *)v16 == *(_DWORD *)(v16 - v269))
      {
        v428 = (char *)(v16 + 4);
        v429 = (void *)(v16 + 4 - v269);
        if (v395 <= v16 + 4)
        {
          v432 = (_DWORD *)(v16 + 4);
        }
        else
        {
          unint64_t v430 = *(void *)v428 ^ *v429;
          if (v430)
          {
            unint64_t v431 = __clz(__rbit64(v430)) >> 3;
            goto LABEL_692;
          }
          unint64_t v436 = v16 + 12;
          while (1)
          {
            v437 = (void *)(v436 + v430);
            if (v436 + v430 >= v395) {
              break;
            }
            uint64_t v438 = *(void *)(v16 + 12 - v269 + v430);
            v430 += 8;
            unint64_t v439 = *v437 ^ v438;
            if (v439)
            {
              unint64_t v431 = v430 + (__clz(__rbit64(v439)) >> 3);
              goto LABEL_692;
            }
          }
          v432 = (_DWORD *)(v16 + v430 + 12);
          v429 = (void *)((char *)v432 - v269);
        }
        if ((unint64_t)v432 < v515 && *(_DWORD *)v429 == *v432)
        {
          ++v432;
          v429 = (void *)((char *)v429 + 4);
        }
        if ((unint64_t)v432 < v511 && *(unsigned __int16 *)v429 == *(unsigned __int16 *)v432)
        {
          v432 = (_DWORD *)((char *)v432 + 2);
          v429 = (void *)((char *)v429 + 2);
        }
        if ((unint64_t)v432 < v8 && *(unsigned __int8 *)v429 == *(unsigned __int8 *)v432) {
          v432 = (_DWORD *)((char *)v432 + 1);
        }
        unint64_t v431 = (char *)v432 - v428;
LABEL_692:
        *(_DWORD *)(v535 + 4 * ((-1640531535 * *(_DWORD *)v16) >> v539)) = v16 - v257;
        *(_DWORD *)(v378 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)v16) >> v543)) = v16 - v257;
        v433 = *(_OWORD **)(a2 + 24);
        if (v16 <= (unint64_t)v398)
        {
          _OWORD *v433 = *(_OWORD *)v16;
        }
        else
        {
          sub_1DD29DBFC(v433, (char *)v16, v16, v398);
          unint64_t v395 = v523;
          v398 = v527;
          unint64_t v8 = v531;
        }
        uint64_t v434 = *(void *)(a2 + 8);
        *(_WORD *)(v434 + 4) = 0;
        *(_DWORD *)uint64_t v434 = 1;
        if (v431 + 1 >= 0x10000)
        {
          unint64_t v435 = (unint64_t)(v434 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v435;
        }
        *(_WORD *)(v434 + 6) = v431 + 1;
        *(void *)(a2 + 8) = v434 + 8;
        v16 += v431 + 4;
        int64_t v269 = v272;
        int64_t v270 = v426;
        if (v16 > v262) {
          goto LABEL_705;
        }
        continue;
      }
      break;
    }
    int64_t v270 = v272;
    int64_t v272 = v269;
LABEL_705:
    _X8 = (void *)(v16 + 1);
    a4 = v16;
    int64_t v269 = v272;
    a3 = v519;
    unsigned int v268 = v499;
    unsigned int v263 = v503;
    LODWORD(v261) = v495;
  }
  while (v16 + 1 <= v262);
LABEL_431:
  if (v263 <= v268) {
    unsigned int v253 = 0;
  }
  else {
    unsigned int v253 = v263;
  }
  if (v264 <= v268) {
    unsigned int v273 = 0;
  }
  else {
    unsigned int v273 = v264;
  }
  if (v270) {
    unsigned int v255 = v270;
  }
  else {
    unsigned int v255 = v253;
  }
  if (v270) {
    BOOL v274 = v253 == 0;
  }
  else {
    BOOL v274 = 1;
  }
  if (v274) {
    unsigned int v253 = v273;
  }
  if (v272) {
    unsigned int v253 = v272;
  }
LABEL_448:
  *a3 = v255;
  a3[1] = v253;
  return v8 - v16;
}

unint64_t sub_1DD2A2A30(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, uint64_t a5)
{
  unint64_t v5 = (unint64_t)a4;
  int v7 = *(_DWORD *)(a1 + 272);
  if (v7 == 5)
  {
    uint64_t v659 = *(void *)(a1 + 112);
    uint64_t v651 = *(void *)(a1 + 128);
    uint64_t v153 = *(void *)(a1 + 8);
    unint64_t v9 = (unint64_t)&a4[a5];
    int v154 = a4 + a5 - v153;
    unsigned int v155 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v156 = *(_DWORD *)(a1 + 24);
    unsigned int v157 = v154 - v156;
    unsigned int v158 = v154 - v155;
    if (v157 > v155 && *(_DWORD *)(a1 + 40) == 0) {
      uint64_t v160 = v158;
    }
    else {
      uint64_t v160 = v156;
    }
    unint64_t v663 = v9 - 8;
    uint64_t v18 = *a3;
    uint64_t v17 = a3[1];
    uint64_t v161 = *(void *)(a1 + 248);
    uint64_t v162 = *(void *)(v161 + 112);
    uint64_t v163 = *(void *)(v161 + 128);
    v164 = *(char **)v161;
    uint64_t v599 = *(unsigned int *)(v161 + 24);
    uint64_t v623 = *(void *)(v161 + 8);
    unsigned int v165 = *(_DWORD *)(v161 + 264);
    unsigned int v166 = *(_DWORD *)(v161 + 260);
    v667 = (unsigned __int8 *)(v153 + v160);
    v631 = v164;
    int v167 = a4 - (v623 + v599) - (v153 + v160) + v164;
    if (*(_DWORD *)(a1 + 296))
    {
      if (v165 <= 0x3D)
      {
        unint64_t v168 = 0;
        do
        {
          _X16 = v162 + v168;
          __asm { PRFM            #2, [X16] }
          v168 += 64;
        }
        while (v168 < 4 << v165);
      }
      if (v166 <= 0x3D)
      {
        unint64_t v171 = 0;
        do
        {
          _X15 = v163 + v171;
          __asm { PRFM            #2, [X15] }
          v171 += 64;
        }
        while (v171 < 4 << v166);
      }
    }
    if (v167) {
      unint64_t v174 = a4;
    }
    else {
      unint64_t v174 = a4 + 1;
    }
    if ((unint64_t)v174 >= v663) {
      goto LABEL_781;
    }
    unint64_t v574 = v623 + v599;
    v593 = a3;
    char v655 = 64 - *(_DWORD *)(a1 + 264);
    char v647 = 64 - *(_DWORD *)(a1 + 260);
    char v615 = 56 - v165;
    char v603 = 56 - v166;
    int v643 = v160 - 1;
    unint64_t v595 = v9 - 7;
    unint64_t v586 = v9 - 1;
    unint64_t v590 = v9 - 3;
    int v635 = v160;
    v639 = (char *)(v9 - 32);
    uint64_t v570 = v623 - 1;
    uint64_t v578 = v153 + 16;
    uint64_t v582 = v153 - 1;
    unsigned int v611 = v160 + v623 - v631;
    unint64_t v627 = v9;
    uint64_t v619 = v162;
    uint64_t v607 = v163;
    while (1)
    {
      uint64_t v175 = *(void *)v174;
      unint64_t v176 = 0xCF1BBCDCB7A56463 * *(void *)v174;
      unint64_t v177 = v176 >> v655;
      unint64_t v178 = 0xCF1BBCDCBB000000 * *(void *)v174;
      unint64_t v179 = v178 >> v647;
      unint64_t v180 = v176 >> v615;
      unint64_t v181 = v178 >> v603;
      unint64_t v182 = *(unsigned int *)(v162 + ((v176 >> v615 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      unint64_t v183 = *(unsigned int *)(v163 + ((v181 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      int v184 = v174 - v153;
      uint64_t v185 = *(unsigned int *)(v659 + 4 * (v176 >> v655));
      uint64_t v186 = *(unsigned int *)(v651 + 4 * v179);
      int v187 = v174 - v153 + 1;
      uint64_t v188 = (v187 - v18);
      uint64_t v189 = v623 + v188 - v611;
      if (v188 >= v160) {
        uint64_t v189 = v153 + v188;
      }
      *(_DWORD *)(v651 + 4 * v179) = v184;
      *(_DWORD *)(v659 + 4 * v177) = v184;
      if ((v643 - v188) >= 3)
      {
        unint64_t v190 = (unint64_t)(v174 + 1);
        if (*(_DWORD *)v189 == *(_DWORD *)(v174 + 1)) {
          break;
        }
      }
      if (v185 <= v160)
      {
        unint64_t v201 = v182 >> 8;
        if (v180 == v182 && v201 > v599)
        {
          uint64_t v238 = v623 + (v182 >> 8);
          if (*(void *)v238 == v175)
          {
            unint64_t v239 = sub_1DD2A6010((void *)v174 + 1, (char *)(v238 + 8), v9, v631, v667);
            int v184 = v174 - v153;
            unint64_t v226 = v239 + 8;
            uint64_t v227 = v174 - v153 - v611 - v201;
            if ((unint64_t)v174 > v5)
            {
              v228 = v174 - 1;
              v240 = (unsigned __int8 *)(v570 + v201);
              LODWORD(v160) = v635;
              while (*v228 == *v240)
              {
                ++v226;
                v230 = v228 - 1;
                if ((unint64_t)v228 > v5)
                {
                  --v228;
                  BOOL v63 = (unint64_t)v240-- > v574;
                  if (v63) {
                    continue;
                  }
                }
LABEL_319:
                unint64_t v190 = (unint64_t)(v230 + 1);
                goto LABEL_338;
              }
LABEL_337:
              unint64_t v190 = (unint64_t)(v228 + 1);
LABEL_338:
              unsigned int v253 = v639;
LABEL_339:
              uint64_t v254 = v190 - v5;
              unsigned int v255 = *(_OWORD **)(a2 + 24);
              if (v190 > (unint64_t)v253)
              {
                int v256 = v184;
                uint64_t v257 = (char *)v5;
                uint64_t v258 = v227;
                sub_1DD29DBFC(v255, v257, v190, v253);
                uint64_t v227 = v258;
                LODWORD(v160) = v635;
                goto LABEL_341;
              }
              *unsigned int v255 = *(_OWORD *)v5;
              uint64_t v260 = *(void *)(a2 + 24);
              if ((unint64_t)v254 <= 0x10)
              {
                *(void *)(a2 + 24) = v260 + v254;
                uint64_t v223 = *(void *)(a2 + 8);
              }
              else
              {
                int v256 = v184;
                *(_OWORD *)(v260 + 16) = *(_OWORD *)(v5 + 16);
                if (v254 >= 33)
                {
                  unint64_t v261 = v260 + v254;
                  unint64_t v262 = (_OWORD *)(v260 + 32);
                  unsigned int v263 = (long long *)(v5 + 48);
                  do
                  {
                    *unint64_t v262 = *(v263 - 1);
                    long long v264 = *v263;
                    v263 += 2;
                    v262[1] = v264;
                    v262 += 2;
                  }
                  while ((unint64_t)v262 < v261);
                }
LABEL_341:
                *(void *)(a2 + 24) += v254;
                uint64_t v223 = *(void *)(a2 + 8);
                if ((unint64_t)v254 >= 0x10000)
                {
                  unint64_t v259 = (unint64_t)(v223 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 1;
                  *(_DWORD *)(a2 + 76) = v259;
                }
                int v184 = v256;
              }
              *(_WORD *)(v223 + 4) = v254;
              *(_DWORD *)uint64_t v223 = v227 + 3;
              __int16 v241 = v226 - 3;
              uint64_t v17 = v18;
              uint64_t v18 = v227;
              if (v226 - 3 >= 0x10000)
              {
LABEL_351:
                unint64_t v265 = (unint64_t)(v223 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v265;
                uint64_t v18 = v227;
              }
LABEL_352:
              *(_WORD *)(v223 + 6) = v241;
              *(void *)(a2 + 8) = v223 + 8;
              unint64_t v5 = v190 + v226;
              if (v190 + v226 <= v663)
              {
                uint64_t v266 = *(void *)(v153 + (v184 + 2));
                *(_DWORD *)(v659 + 4 * ((0xCF1BBCDCB7A56463 * v266) >> v655)) = v184 + 2;
                *(_DWORD *)(v659 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v655)) = v5 - 2 - v153;
                *(_DWORD *)(v651 + 4 * ((0xCF1BBCDCBB000000 * v266) >> v647)) = v184 + 2;
                *(_DWORD *)(v651 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v5 - 1)) >> v647)) = v5 - 1 - v153;
                uint64_t v267 = v18;
                uint64_t v268 = v17;
                unint64_t v9 = v627;
                while (1)
                {
                  uint64_t v18 = v268;
                  uint64_t v268 = v267;
                  int v269 = v5 - v153;
                  uint64_t v270 = (v5 - v153 - v18);
                  uint64_t v271 = v623 - v611;
                  if (v270 >= v160) {
                    uint64_t v271 = v153;
                  }
                  if ((v643 - v270) < 3) {
                    break;
                  }
                  uint64_t v272 = v271 + v270;
                  if (*(_DWORD *)v272 != *(_DWORD *)v5) {
                    break;
                  }
                  if (v270 >= v160) {
                    unsigned int v273 = (char *)v627;
                  }
                  else {
                    unsigned int v273 = v631;
                  }
                  unint64_t v274 = sub_1DD2A6010((void *)(v5 + 4), (char *)(v272 + 4), v627, v273, v667);
                  v275 = *(_OWORD **)(a2 + 24);
                  if (v5 <= (unint64_t)v639) {
                    _OWORD *v275 = *(_OWORD *)v5;
                  }
                  else {
                    sub_1DD29DBFC(v275, (char *)v5, v5, v639);
                  }
                  LODWORD(v160) = v635;
                  uint64_t v276 = *(void *)(a2 + 8);
                  *(_WORD *)(v276 + 4) = 0;
                  *(_DWORD *)uint64_t v276 = 1;
                  if (v274 + 1 >= 0x10000)
                  {
                    unint64_t v277 = (unint64_t)(v276 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v277;
                  }
                  *(_WORD *)(v276 + 6) = v274 + 1;
                  uint64_t v278 = *(void *)v5;
                  *(_DWORD *)(v651 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v5) >> v647)) = v269;
                  *(_DWORD *)(v659 + 4 * ((0xCF1BBCDCB7A56463 * v278) >> v655)) = v269;
                  v5 += v274 + 4;
                  *(void *)(a2 + 8) = v276 + 8;
                  uint64_t v267 = v18;
                  uint64_t v17 = v268;
                  unint64_t v174 = (unsigned __int8 *)v5;
                  if (v5 > v663) {
                    goto LABEL_370;
                  }
                }
                uint64_t v17 = v18;
                uint64_t v18 = v267;
                unint64_t v174 = (unsigned __int8 *)v5;
              }
              else
              {
                unint64_t v174 = (unsigned __int8 *)(v190 + v226);
                unint64_t v9 = v627;
              }
              goto LABEL_370;
            }
LABEL_297:
            unint64_t v190 = (unint64_t)v174;
            LODWORD(v160) = v635;
            goto LABEL_338;
          }
        }
      }
      else
      {
        uint64_t v196 = v153 + v185;
        if (*(void *)(v153 + v185) == v175)
        {
          uint64_t v197 = (char *)(v174 + 8);
          uint64_t v198 = (void *)(v196 + 8);
          if (v595 <= (unint64_t)(v174 + 8))
          {
            uint64_t v225 = v174 + 8;
          }
          else
          {
            unint64_t v199 = *(void *)v197 ^ *v198;
            if (v199)
            {
              unint64_t v200 = __clz(__rbit64(v199)) >> 3;
              goto LABEL_263;
            }
            uint64_t v244 = 0;
            unsigned int v245 = v174 + 16;
            while (1)
            {
              BOOL v246 = &v245[v244];
              if ((unint64_t)&v245[v244] >= v595) {
                break;
              }
              uint64_t v247 = *(void *)(v578 + v185 + v244);
              v244 += 8;
              unint64_t v248 = *(void *)v246 ^ v247;
              if (v248)
              {
                unint64_t v200 = v244 + (__clz(__rbit64(v248)) >> 3);
                goto LABEL_263;
              }
            }
            uint64_t v225 = &v174[v244 + 16];
            uint64_t v198 = (void *)(v578 + v185 + v244);
          }
          if ((unint64_t)v225 < v590 && *(_DWORD *)v198 == *(_DWORD *)v225)
          {
            v225 += 4;
            uint64_t v198 = (void *)((char *)v198 + 4);
          }
          if ((unint64_t)v225 < v586 && *(unsigned __int16 *)v198 == *(unsigned __int16 *)v225)
          {
            v225 += 2;
            uint64_t v198 = (void *)((char *)v198 + 2);
          }
          if ((unint64_t)v225 < v9 && *(unsigned __int8 *)v198 == *v225) {
            ++v225;
          }
          unint64_t v200 = v225 - (unsigned __int8 *)v197;
LABEL_263:
          unint64_t v226 = v200 + 8;
          uint64_t v227 = (v174 - v196);
          if ((unint64_t)v174 > v5)
          {
            v228 = v174 - 1;
            uint64_t v229 = (unsigned __int8 *)(v582 + v185);
            while (*v228 == *v229)
            {
              ++v226;
              v230 = v228 - 1;
              if ((unint64_t)v228 > v5)
              {
                --v228;
                BOOL v63 = v229-- > v667;
                if (v63) {
                  continue;
                }
              }
              goto LABEL_319;
            }
            goto LABEL_337;
          }
          goto LABEL_320;
        }
      }
      if (v186 <= v160)
      {
        unint64_t v214 = v183 >> 8;
        if (v181 == v183 && v214 > v599)
        {
          unint64_t v203 = v623 + v214;
          if (*(_DWORD *)(v623 + v214) == *(_DWORD *)v174)
          {
            LODWORD(v186) = v214 + v611;
LABEL_236:
            unint64_t v190 = (unint64_t)(v174 + 1);
            uint64_t v204 = *(void *)(v174 + 1);
            unint64_t v205 = (0xCF1BBCDCB7A56463 * v204) >> v655;
            unint64_t v206 = (0xCF1BBCDCB7A56463 * v204) >> v615;
            uint64_t v207 = *(unsigned int *)(v659 + 4 * v205);
            unsigned int v208 = *(_DWORD *)(v619 + ((v206 >> 6) & 0x3FFFFFFFFFFFFFCLL));
            *(_DWORD *)(v659 + 4 * v205) = v187;
            if (v207 <= v160)
            {
              unsigned int v231 = v208 >> 8;
              if (v206 == v208 && v231 > v599)
              {
                uint64_t v279 = v231;
                uint64_t v280 = v623 + v231;
                if (*(void *)v280 == v204)
                {
                  unint64_t v226 = sub_1DD2A6010(v174 + 9, (char *)(v280 + 8), v9, v631, v667) + 8;
                  uint64_t v227 = v187 - v611 - v279;
                  if (v190 <= v5)
                  {
                    LODWORD(v160) = v635;
                    unsigned int v253 = v639;
                    int v184 = v174 - v153;
                    goto LABEL_339;
                  }
                  v281 = (unsigned __int8 *)(v570 + v279);
                  LODWORD(v160) = v635;
                  int v184 = v174 - v153;
                  while (*v174 == *v281)
                  {
                    ++v226;
                    v228 = v174 - 1;
                    if ((unint64_t)v281 > v574)
                    {
                      --v281;
                      BOOL v63 = (unint64_t)v174-- > v5;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_337;
                  }
                  goto LABEL_380;
                }
              }
            }
            else
            {
              uint64_t v209 = v153 + v207;
              if (*(void *)(v153 + v207) == v204)
              {
                v210 = (char *)(v174 + 9);
                uint64_t v211 = (void *)(v209 + 8);
                if (v595 <= (unint64_t)(v174 + 9))
                {
                  int v251 = v174 + 9;
                }
                else
                {
                  unint64_t v212 = *(void *)v210 ^ *v211;
                  if (v212)
                  {
                    unint64_t v213 = __clz(__rbit64(v212)) >> 3;
                    goto LABEL_332;
                  }
                  uint64_t v287 = 0;
                  v288 = v174 + 17;
                  while (1)
                  {
                    v289 = &v288[v287];
                    if ((unint64_t)&v288[v287] >= v595) {
                      break;
                    }
                    uint64_t v290 = *(void *)(v578 + v207 + v287);
                    v287 += 8;
                    unint64_t v291 = *(void *)v289 ^ v290;
                    if (v291)
                    {
                      unint64_t v213 = v287 + (__clz(__rbit64(v291)) >> 3);
                      goto LABEL_332;
                    }
                  }
                  int v251 = &v174[v287 + 17];
                  uint64_t v211 = (void *)(v578 + v207 + v287);
                }
                if ((unint64_t)v251 < v590 && *(_DWORD *)v211 == *(_DWORD *)v251)
                {
                  v251 += 4;
                  uint64_t v211 = (void *)((char *)v211 + 4);
                }
                if ((unint64_t)v251 < v586 && *(unsigned __int16 *)v211 == *(unsigned __int16 *)v251)
                {
                  v251 += 2;
                  uint64_t v211 = (void *)((char *)v211 + 2);
                }
                if ((unint64_t)v251 < v9 && *(unsigned __int8 *)v211 == *v251) {
                  ++v251;
                }
                unint64_t v213 = v251 - (unsigned __int8 *)v210;
LABEL_332:
                unint64_t v226 = v213 + 8;
                uint64_t v227 = (v190 - v209);
                if (v190 <= v5) {
                  goto LABEL_338;
                }
                v252 = (unsigned __int8 *)(v582 + v207);
                while (*v174 == *v252)
                {
                  ++v226;
                  v228 = v174 - 1;
                  if (v252 > v667)
                  {
                    --v252;
                    BOOL v63 = (unint64_t)v174-- > v5;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_337;
                }
LABEL_380:
                unint64_t v190 = (unint64_t)(v174 + 1);
                goto LABEL_338;
              }
            }
            unint64_t v233 = (char *)(v174 + 4);
            v234 = (char *)(v203 + 4);
            if (v186 < v160)
            {
              unint64_t v235 = v203;
              unint64_t v236 = sub_1DD2A6010(v233, v234, v9, v631, v667);
              int v184 = v174 - v153;
              unint64_t v226 = v236 + 4;
              uint64_t v227 = (v174 - v153 - v186);
              if ((unint64_t)v174 > v5 && v235 > v574)
              {
                v228 = v174 - 1;
                unint64_t v237 = (unsigned __int8 *)(v235 - 1);
                LODWORD(v160) = v635;
                while (*v228 == *v237)
                {
                  ++v226;
                  v230 = v228 - 1;
                  if ((unint64_t)v228 > v5)
                  {
                    --v228;
                    BOOL v63 = (unint64_t)v237-- > v574;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_319;
                }
                goto LABEL_337;
              }
              goto LABEL_297;
            }
            if (v595 <= (unint64_t)v233)
            {
              int v249 = v174 + 4;
            }
            else
            {
              unint64_t v242 = *(void *)v233 ^ *(void *)v234;
              if (v242)
              {
                unint64_t v243 = __clz(__rbit64(v242)) >> 3;
LABEL_313:
                unint64_t v226 = v243 + 4;
                uint64_t v227 = (v174 - v203);
                if ((unint64_t)v174 > v5 && v203 > (unint64_t)v667)
                {
                  v228 = v174 - 1;
                  BOOL v250 = (unsigned __int8 *)(v203 - 1);
                  while (*v228 == *v250)
                  {
                    ++v226;
                    v230 = v228 - 1;
                    if ((unint64_t)v228 > v5)
                    {
                      --v228;
                      BOOL v63 = v250-- > v667;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_319;
                  }
                  goto LABEL_337;
                }
LABEL_320:
                unint64_t v190 = (unint64_t)v174;
                goto LABEL_338;
              }
              uint64_t v282 = 0;
              unint64_t v283 = v174 + 12;
              while (1)
              {
                uint64_t v284 = &v283[v282];
                if ((unint64_t)&v283[v282] >= v595) {
                  break;
                }
                uint64_t v285 = *(void *)(v203 + 12 + v282);
                v282 += 8;
                unint64_t v286 = *(void *)v284 ^ v285;
                if (v286)
                {
                  unint64_t v243 = v282 + (__clz(__rbit64(v286)) >> 3);
                  goto LABEL_313;
                }
              }
              int v249 = &v174[v282 + 12];
              v234 = (char *)(v203 + v282 + 12);
            }
            if ((unint64_t)v249 < v590 && *(_DWORD *)v234 == *(_DWORD *)v249)
            {
              v249 += 4;
              v234 += 4;
            }
            if ((unint64_t)v249 < v586 && *(unsigned __int16 *)v234 == *(unsigned __int16 *)v249)
            {
              v249 += 2;
              v234 += 2;
            }
            if ((unint64_t)v249 < v9 && *v234 == *v249) {
              ++v249;
            }
            unint64_t v243 = v249 - (unsigned __int8 *)v233;
            goto LABEL_313;
          }
        }
      }
      else
      {
        unint64_t v203 = v153 + v186;
        if (*(_DWORD *)(v153 + v186) == *(_DWORD *)v174) {
          goto LABEL_236;
        }
      }
      _X8 = &v174[(uint64_t)&v174[-v5] >> 8];
      unint64_t v174 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
LABEL_370:
      uint64_t v162 = v619;
      uint64_t v163 = v607;
      if ((unint64_t)v174 >= v663)
      {
LABEL_780:
        a3 = v593;
        goto LABEL_781;
      }
    }
    int v191 = v174 - v153;
    if (v188 >= v160) {
      unint64_t v192 = (char *)v9;
    }
    else {
      unint64_t v192 = v631;
    }
    unint64_t v193 = sub_1DD2A6010(v174 + 5, (char *)(v189 + 4), v9, v192, v667);
    uint64_t v194 = v190 - v5;
    unint64_t v195 = *(_OWORD **)(a2 + 24);
    if (v190 <= (unint64_t)v639)
    {
      *unint64_t v195 = *(_OWORD *)v5;
      uint64_t v218 = *(void *)(a2 + 24);
      if ((unint64_t)v194 <= 0x10)
      {
        *(void *)(a2 + 24) = v218 + v194;
        uint64_t v223 = *(void *)(a2 + 8);
        LODWORD(v160) = v635;
        int v184 = v191;
        goto LABEL_290;
      }
      *(_OWORD *)(v218 + 16) = *(_OWORD *)(v5 + 16);
      LODWORD(v160) = v635;
      int v184 = v191;
      if (v194 >= 33)
      {
        unint64_t v219 = v218 + v194;
        uint64_t v220 = (_OWORD *)(v218 + 32);
        unint64_t v221 = (long long *)(v5 + 48);
        do
        {
          *uint64_t v220 = *(v221 - 1);
          long long v222 = *v221;
          v221 += 2;
          v220[1] = v222;
          v220 += 2;
        }
        while ((unint64_t)v220 < v219);
      }
    }
    else
    {
      sub_1DD29DBFC(v195, (char *)v5, v190, v639);
      LODWORD(v160) = v635;
      int v184 = v191;
    }
    *(void *)(a2 + 24) += v194;
    uint64_t v223 = *(void *)(a2 + 8);
    if ((unint64_t)v194 >= 0x10000)
    {
      unint64_t v224 = (unint64_t)(v223 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v224;
    }
LABEL_290:
    unint64_t v226 = v193 + 4;
    *(_WORD *)(v223 + 4) = v194;
    *(_DWORD *)uint64_t v223 = 1;
    __int16 v241 = v193 + 1;
    uint64_t v227 = v18;
    if ((v193 + 1) >> 16) {
      goto LABEL_351;
    }
    goto LABEL_352;
  }
  if (v7 == 6)
  {
    uint64_t v660 = *(void *)(a1 + 112);
    uint64_t v652 = *(void *)(a1 + 128);
    uint64_t v292 = *(void *)(a1 + 8);
    unint64_t v9 = (unint64_t)&a4[a5];
    int v293 = a4 + a5 - v292;
    unsigned int v294 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v295 = *(_DWORD *)(a1 + 24);
    unsigned int v296 = v293 - v295;
    unsigned int v297 = v293 - v294;
    if (v296 > v294 && *(_DWORD *)(a1 + 40) == 0) {
      uint64_t v299 = v297;
    }
    else {
      uint64_t v299 = v295;
    }
    unint64_t v664 = v9 - 8;
    uint64_t v18 = *a3;
    uint64_t v17 = a3[1];
    uint64_t v300 = *(void *)(a1 + 248);
    uint64_t v301 = *(void *)(v300 + 112);
    uint64_t v302 = *(void *)(v300 + 128);
    unint64_t v303 = *(char **)v300;
    uint64_t v600 = *(unsigned int *)(v300 + 24);
    uint64_t v624 = *(void *)(v300 + 8);
    unsigned int v304 = *(_DWORD *)(v300 + 264);
    unsigned int v305 = *(_DWORD *)(v300 + 260);
    v668 = (unsigned __int8 *)(v292 + v299);
    v632 = v303;
    int v306 = a4 - (v624 + v600) - (v292 + v299) + v303;
    if (*(_DWORD *)(a1 + 296))
    {
      if (v304 <= 0x3D)
      {
        unint64_t v307 = 0;
        do
        {
          _X16 = v301 + v307;
          __asm { PRFM            #2, [X16] }
          v307 += 64;
        }
        while (v307 < 4 << v304);
      }
      if (v305 <= 0x3D)
      {
        unint64_t v310 = 0;
        do
        {
          _X15 = v302 + v310;
          __asm { PRFM            #2, [X15] }
          v310 += 64;
        }
        while (v310 < 4 << v305);
      }
    }
    if (v306) {
      v313 = a4;
    }
    else {
      v313 = a4 + 1;
    }
    if ((unint64_t)v313 >= v664) {
      goto LABEL_781;
    }
    unint64_t v575 = v624 + v600;
    v593 = a3;
    char v656 = 64 - *(_DWORD *)(a1 + 264);
    char v648 = 64 - *(_DWORD *)(a1 + 260);
    char v616 = 56 - v304;
    char v604 = 56 - v305;
    int v644 = v299 - 1;
    unint64_t v596 = v9 - 7;
    unint64_t v587 = v9 - 1;
    unint64_t v591 = v9 - 3;
    int v636 = v299;
    v640 = (char *)(v9 - 32);
    uint64_t v571 = v624 - 1;
    uint64_t v579 = v292 + 16;
    uint64_t v583 = v292 - 1;
    unsigned int v612 = v299 + v624 - v632;
    unint64_t v628 = v9;
    uint64_t v620 = v301;
    uint64_t v608 = v302;
    while (1)
    {
      uint64_t v314 = *(void *)v313;
      unint64_t v315 = 0xCF1BBCDCB7A56463 * *(void *)v313;
      unint64_t v316 = v315 >> v656;
      unint64_t v317 = 0xCF1BBCDCBF9B0000 * *(void *)v313;
      unint64_t v318 = v317 >> v648;
      unint64_t v319 = v315 >> v616;
      unint64_t v320 = v317 >> v604;
      unint64_t v321 = *(unsigned int *)(v301 + ((v315 >> v616 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      unint64_t v322 = *(unsigned int *)(v302 + ((v320 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      int v323 = v313 - v292;
      uint64_t v324 = *(unsigned int *)(v660 + 4 * (v315 >> v656));
      uint64_t v325 = *(unsigned int *)(v652 + 4 * v318);
      int v326 = v313 - v292 + 1;
      uint64_t v327 = (v326 - v18);
      uint64_t v328 = v624 + v327 - v612;
      if (v327 >= v299) {
        uint64_t v328 = v292 + v327;
      }
      *(_DWORD *)(v652 + 4 * v318) = v323;
      *(_DWORD *)(v660 + 4 * v316) = v323;
      if ((v644 - v327) >= 3)
      {
        unint64_t v329 = (unint64_t)(v313 + 1);
        if (*(_DWORD *)v328 == *(_DWORD *)(v313 + 1)) {
          break;
        }
      }
      if (v324 <= v299)
      {
        unint64_t v340 = v321 >> 8;
        if (v319 == v321 && v340 > v600)
        {
          uint64_t v377 = v624 + (v321 >> 8);
          if (*(void *)v377 == v314)
          {
            unint64_t v378 = sub_1DD2A6010((void *)v313 + 1, (char *)(v377 + 8), v9, v632, v668);
            int v323 = v313 - v292;
            unint64_t v365 = v378 + 8;
            uint64_t v366 = v313 - v292 - v612 - v340;
            if ((unint64_t)v313 > v5)
            {
              uint64_t v367 = v313 - 1;
              unint64_t v379 = (unsigned __int8 *)(v571 + v340);
              LODWORD(v299) = v636;
              while (*v367 == *v379)
              {
                ++v365;
                v369 = v367 - 1;
                if ((unint64_t)v367 > v5)
                {
                  --v367;
                  BOOL v63 = (unint64_t)v379-- > v575;
                  if (v63) {
                    continue;
                  }
                }
LABEL_513:
                unint64_t v329 = (unint64_t)(v369 + 1);
                goto LABEL_532;
              }
LABEL_531:
              unint64_t v329 = (unint64_t)(v367 + 1);
LABEL_532:
              v392 = v640;
LABEL_533:
              uint64_t v393 = v329 - v5;
              v394 = *(_OWORD **)(a2 + 24);
              if (v329 > (unint64_t)v392)
              {
                int v395 = v323;
                unint64_t v396 = (char *)v5;
                uint64_t v397 = v366;
                sub_1DD29DBFC(v394, v396, v329, v392);
                uint64_t v366 = v397;
                LODWORD(v299) = v636;
                goto LABEL_535;
              }
              _OWORD *v394 = *(_OWORD *)v5;
              uint64_t v399 = *(void *)(a2 + 24);
              if ((unint64_t)v393 <= 0x10)
              {
                *(void *)(a2 + 24) = v399 + v393;
                uint64_t v362 = *(void *)(a2 + 8);
              }
              else
              {
                int v395 = v323;
                *(_OWORD *)(v399 + 16) = *(_OWORD *)(v5 + 16);
                if (v393 >= 33)
                {
                  unint64_t v400 = v399 + v393;
                  v401 = (_OWORD *)(v399 + 32);
                  uint64_t v402 = (long long *)(v5 + 48);
                  do
                  {
                    _OWORD *v401 = *(v402 - 1);
                    long long v403 = *v402;
                    v402 += 2;
                    v401[1] = v403;
                    v401 += 2;
                  }
                  while ((unint64_t)v401 < v400);
                }
LABEL_535:
                *(void *)(a2 + 24) += v393;
                uint64_t v362 = *(void *)(a2 + 8);
                if ((unint64_t)v393 >= 0x10000)
                {
                  unint64_t v398 = (unint64_t)(v362 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 1;
                  *(_DWORD *)(a2 + 76) = v398;
                }
                int v323 = v395;
              }
              *(_WORD *)(v362 + 4) = v393;
              *(_DWORD *)uint64_t v362 = v366 + 3;
              __int16 v380 = v365 - 3;
              uint64_t v17 = v18;
              uint64_t v18 = v366;
              if (v365 - 3 >= 0x10000)
              {
LABEL_545:
                unint64_t v404 = (unint64_t)(v362 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v404;
                uint64_t v18 = v366;
              }
LABEL_546:
              *(_WORD *)(v362 + 6) = v380;
              *(void *)(a2 + 8) = v362 + 8;
              unint64_t v5 = v329 + v365;
              if (v329 + v365 <= v664)
              {
                uint64_t v405 = *(void *)(v292 + (v323 + 2));
                *(_DWORD *)(v660 + 4 * ((0xCF1BBCDCB7A56463 * v405) >> v656)) = v323 + 2;
                *(_DWORD *)(v660 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v656)) = v5 - 2 - v292;
                *(_DWORD *)(v652 + 4 * ((0xCF1BBCDCBF9B0000 * v405) >> v648)) = v323 + 2;
                *(_DWORD *)(v652 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v5 - 1)) >> v648)) = v5 - 1 - v292;
                uint64_t v406 = v18;
                uint64_t v407 = v17;
                unint64_t v9 = v628;
                while (1)
                {
                  uint64_t v18 = v407;
                  uint64_t v407 = v406;
                  int v408 = v5 - v292;
                  uint64_t v409 = (v5 - v292 - v18);
                  uint64_t v410 = v624 - v612;
                  if (v409 >= v299) {
                    uint64_t v410 = v292;
                  }
                  if ((v644 - v409) < 3) {
                    break;
                  }
                  uint64_t v411 = v410 + v409;
                  if (*(_DWORD *)v411 != *(_DWORD *)v5) {
                    break;
                  }
                  if (v409 >= v299) {
                    unint64_t v412 = (char *)v628;
                  }
                  else {
                    unint64_t v412 = v632;
                  }
                  unint64_t v413 = sub_1DD2A6010((void *)(v5 + 4), (char *)(v411 + 4), v628, v412, v668);
                  v414 = *(_OWORD **)(a2 + 24);
                  if (v5 <= (unint64_t)v640) {
                    _OWORD *v414 = *(_OWORD *)v5;
                  }
                  else {
                    sub_1DD29DBFC(v414, (char *)v5, v5, v640);
                  }
                  LODWORD(v299) = v636;
                  uint64_t v415 = *(void *)(a2 + 8);
                  *(_WORD *)(v415 + 4) = 0;
                  *(_DWORD *)uint64_t v415 = 1;
                  if (v413 + 1 >= 0x10000)
                  {
                    unint64_t v416 = (unint64_t)(v415 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v416;
                  }
                  *(_WORD *)(v415 + 6) = v413 + 1;
                  uint64_t v417 = *(void *)v5;
                  *(_DWORD *)(v652 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v5) >> v648)) = v408;
                  *(_DWORD *)(v660 + 4 * ((0xCF1BBCDCB7A56463 * v417) >> v656)) = v408;
                  v5 += v413 + 4;
                  *(void *)(a2 + 8) = v415 + 8;
                  uint64_t v406 = v18;
                  uint64_t v17 = v407;
                  v313 = (unsigned __int8 *)v5;
                  if (v5 > v664) {
                    goto LABEL_564;
                  }
                }
                uint64_t v17 = v18;
                uint64_t v18 = v406;
                v313 = (unsigned __int8 *)v5;
              }
              else
              {
                v313 = (unsigned __int8 *)(v329 + v365);
                unint64_t v9 = v628;
              }
              goto LABEL_564;
            }
LABEL_491:
            unint64_t v329 = (unint64_t)v313;
            LODWORD(v299) = v636;
            goto LABEL_532;
          }
        }
      }
      else
      {
        uint64_t v335 = v292 + v324;
        if (*(void *)(v292 + v324) == v314)
        {
          unint64_t v336 = (char *)(v313 + 8);
          v337 = (void *)(v335 + 8);
          if (v596 <= (unint64_t)(v313 + 8))
          {
            uint64_t v364 = v313 + 8;
          }
          else
          {
            unint64_t v338 = *(void *)v336 ^ *v337;
            if (v338)
            {
              unint64_t v339 = __clz(__rbit64(v338)) >> 3;
              goto LABEL_457;
            }
            uint64_t v383 = 0;
            unint64_t v384 = v313 + 16;
            while (1)
            {
              unsigned int v385 = &v384[v383];
              if ((unint64_t)&v384[v383] >= v596) {
                break;
              }
              uint64_t v386 = *(void *)(v579 + v324 + v383);
              v383 += 8;
              unint64_t v387 = *(void *)v385 ^ v386;
              if (v387)
              {
                unint64_t v339 = v383 + (__clz(__rbit64(v387)) >> 3);
                goto LABEL_457;
              }
            }
            uint64_t v364 = &v313[v383 + 16];
            v337 = (void *)(v579 + v324 + v383);
          }
          if ((unint64_t)v364 < v591 && *(_DWORD *)v337 == *(_DWORD *)v364)
          {
            v364 += 4;
            v337 = (void *)((char *)v337 + 4);
          }
          if ((unint64_t)v364 < v587 && *(unsigned __int16 *)v337 == *(unsigned __int16 *)v364)
          {
            v364 += 2;
            v337 = (void *)((char *)v337 + 2);
          }
          if ((unint64_t)v364 < v9 && *(unsigned __int8 *)v337 == *v364) {
            ++v364;
          }
          unint64_t v339 = v364 - (unsigned __int8 *)v336;
LABEL_457:
          unint64_t v365 = v339 + 8;
          uint64_t v366 = (v313 - v335);
          if ((unint64_t)v313 > v5)
          {
            uint64_t v367 = v313 - 1;
            unint64_t v368 = (unsigned __int8 *)(v583 + v324);
            while (*v367 == *v368)
            {
              ++v365;
              v369 = v367 - 1;
              if ((unint64_t)v367 > v5)
              {
                --v367;
                BOOL v63 = v368-- > v668;
                if (v63) {
                  continue;
                }
              }
              goto LABEL_513;
            }
            goto LABEL_531;
          }
          goto LABEL_514;
        }
      }
      if (v325 <= v299)
      {
        unint64_t v353 = v322 >> 8;
        if (v320 == v322 && v353 > v600)
        {
          unint64_t v342 = v624 + v353;
          if (*(_DWORD *)(v624 + v353) == *(_DWORD *)v313)
          {
            LODWORD(v325) = v353 + v612;
LABEL_430:
            unint64_t v329 = (unint64_t)(v313 + 1);
            uint64_t v343 = *(void *)(v313 + 1);
            unint64_t v344 = (0xCF1BBCDCB7A56463 * v343) >> v656;
            unint64_t v345 = (0xCF1BBCDCB7A56463 * v343) >> v616;
            uint64_t v346 = *(unsigned int *)(v660 + 4 * v344);
            unsigned int v347 = *(_DWORD *)(v620 + ((v345 >> 6) & 0x3FFFFFFFFFFFFFCLL));
            *(_DWORD *)(v660 + 4 * v344) = v326;
            if (v346 <= v299)
            {
              unsigned int v370 = v347 >> 8;
              if (v345 == v347 && v370 > v600)
              {
                uint64_t v418 = v370;
                uint64_t v419 = v624 + v370;
                if (*(void *)v419 == v343)
                {
                  unint64_t v365 = sub_1DD2A6010(v313 + 9, (char *)(v419 + 8), v9, v632, v668) + 8;
                  uint64_t v366 = v326 - v612 - v418;
                  if (v329 <= v5)
                  {
                    LODWORD(v299) = v636;
                    v392 = v640;
                    int v323 = v313 - v292;
                    goto LABEL_533;
                  }
                  unint64_t v420 = (unsigned __int8 *)(v571 + v418);
                  LODWORD(v299) = v636;
                  int v323 = v313 - v292;
                  while (*v313 == *v420)
                  {
                    ++v365;
                    uint64_t v367 = v313 - 1;
                    if ((unint64_t)v420 > v575)
                    {
                      --v420;
                      BOOL v63 = (unint64_t)v313-- > v5;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_531;
                  }
                  goto LABEL_574;
                }
              }
            }
            else
            {
              uint64_t v348 = v292 + v346;
              if (*(void *)(v292 + v346) == v343)
              {
                v349 = (char *)(v313 + 9);
                v350 = (void *)(v348 + 8);
                if (v596 <= (unint64_t)(v313 + 9))
                {
                  v390 = v313 + 9;
                }
                else
                {
                  unint64_t v351 = *(void *)v349 ^ *v350;
                  if (v351)
                  {
                    unint64_t v352 = __clz(__rbit64(v351)) >> 3;
                    goto LABEL_526;
                  }
                  uint64_t v426 = 0;
                  unint64_t v427 = v313 + 17;
                  while (1)
                  {
                    v428 = &v427[v426];
                    if ((unint64_t)&v427[v426] >= v596) {
                      break;
                    }
                    uint64_t v429 = *(void *)(v579 + v346 + v426);
                    v426 += 8;
                    unint64_t v430 = *(void *)v428 ^ v429;
                    if (v430)
                    {
                      unint64_t v352 = v426 + (__clz(__rbit64(v430)) >> 3);
                      goto LABEL_526;
                    }
                  }
                  v390 = &v313[v426 + 17];
                  v350 = (void *)(v579 + v346 + v426);
                }
                if ((unint64_t)v390 < v591 && *(_DWORD *)v350 == *(_DWORD *)v390)
                {
                  v390 += 4;
                  v350 = (void *)((char *)v350 + 4);
                }
                if ((unint64_t)v390 < v587 && *(unsigned __int16 *)v350 == *(unsigned __int16 *)v390)
                {
                  v390 += 2;
                  v350 = (void *)((char *)v350 + 2);
                }
                if ((unint64_t)v390 < v9 && *(unsigned __int8 *)v350 == *v390) {
                  ++v390;
                }
                unint64_t v352 = v390 - (unsigned __int8 *)v349;
LABEL_526:
                unint64_t v365 = v352 + 8;
                uint64_t v366 = (v329 - v348);
                if (v329 <= v5) {
                  goto LABEL_532;
                }
                v391 = (unsigned __int8 *)(v583 + v346);
                while (*v313 == *v391)
                {
                  ++v365;
                  uint64_t v367 = v313 - 1;
                  if (v391 > v668)
                  {
                    --v391;
                    BOOL v63 = (unint64_t)v313-- > v5;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_531;
                }
LABEL_574:
                unint64_t v329 = (unint64_t)(v313 + 1);
                goto LABEL_532;
              }
            }
            unint64_t v372 = (char *)(v313 + 4);
            uint64_t v373 = (char *)(v342 + 4);
            if (v325 < v299)
            {
              unint64_t v374 = v342;
              unint64_t v375 = sub_1DD2A6010(v372, v373, v9, v632, v668);
              int v323 = v313 - v292;
              unint64_t v365 = v375 + 4;
              uint64_t v366 = (v313 - v292 - v325);
              if ((unint64_t)v313 > v5 && v374 > v575)
              {
                uint64_t v367 = v313 - 1;
                uint64_t v376 = (unsigned __int8 *)(v374 - 1);
                LODWORD(v299) = v636;
                while (*v367 == *v376)
                {
                  ++v365;
                  v369 = v367 - 1;
                  if ((unint64_t)v367 > v5)
                  {
                    --v367;
                    BOOL v63 = (unint64_t)v376-- > v575;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_513;
                }
                goto LABEL_531;
              }
              goto LABEL_491;
            }
            if (v596 <= (unint64_t)v372)
            {
              unint64_t v388 = v313 + 4;
            }
            else
            {
              unint64_t v381 = *(void *)v372 ^ *(void *)v373;
              if (v381)
              {
                unint64_t v382 = __clz(__rbit64(v381)) >> 3;
LABEL_507:
                unint64_t v365 = v382 + 4;
                uint64_t v366 = (v313 - v342);
                if ((unint64_t)v313 > v5 && v342 > (unint64_t)v668)
                {
                  uint64_t v367 = v313 - 1;
                  uint64_t v389 = (unsigned __int8 *)(v342 - 1);
                  while (*v367 == *v389)
                  {
                    ++v365;
                    v369 = v367 - 1;
                    if ((unint64_t)v367 > v5)
                    {
                      --v367;
                      BOOL v63 = v389-- > v668;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_513;
                  }
                  goto LABEL_531;
                }
LABEL_514:
                unint64_t v329 = (unint64_t)v313;
                goto LABEL_532;
              }
              uint64_t v421 = 0;
              unint64_t v422 = v313 + 12;
              while (1)
              {
                __int16 v423 = &v422[v421];
                if ((unint64_t)&v422[v421] >= v596) {
                  break;
                }
                uint64_t v424 = *(void *)(v342 + 12 + v421);
                v421 += 8;
                unint64_t v425 = *(void *)v423 ^ v424;
                if (v425)
                {
                  unint64_t v382 = v421 + (__clz(__rbit64(v425)) >> 3);
                  goto LABEL_507;
                }
              }
              unint64_t v388 = &v313[v421 + 12];
              uint64_t v373 = (char *)(v342 + v421 + 12);
            }
            if ((unint64_t)v388 < v591 && *(_DWORD *)v373 == *(_DWORD *)v388)
            {
              v388 += 4;
              v373 += 4;
            }
            if ((unint64_t)v388 < v587 && *(unsigned __int16 *)v373 == *(unsigned __int16 *)v388)
            {
              v388 += 2;
              v373 += 2;
            }
            if ((unint64_t)v388 < v9 && *v373 == *v388) {
              ++v388;
            }
            unint64_t v382 = v388 - (unsigned __int8 *)v372;
            goto LABEL_507;
          }
        }
      }
      else
      {
        unint64_t v342 = v292 + v325;
        if (*(_DWORD *)(v292 + v325) == *(_DWORD *)v313) {
          goto LABEL_430;
        }
      }
      _X8 = &v313[(uint64_t)&v313[-v5] >> 8];
      v313 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
LABEL_564:
      uint64_t v301 = v620;
      uint64_t v302 = v608;
      if ((unint64_t)v313 >= v664) {
        goto LABEL_780;
      }
    }
    int v330 = v313 - v292;
    if (v327 >= v299) {
      v331 = (char *)v9;
    }
    else {
      v331 = v632;
    }
    unint64_t v332 = sub_1DD2A6010(v313 + 5, (char *)(v328 + 4), v9, v331, v668);
    uint64_t v333 = v329 - v5;
    uint64_t v334 = *(_OWORD **)(a2 + 24);
    if (v329 <= (unint64_t)v640)
    {
      *uint64_t v334 = *(_OWORD *)v5;
      uint64_t v357 = *(void *)(a2 + 24);
      if ((unint64_t)v333 <= 0x10)
      {
        *(void *)(a2 + 24) = v357 + v333;
        uint64_t v362 = *(void *)(a2 + 8);
        LODWORD(v299) = v636;
        int v323 = v330;
        goto LABEL_484;
      }
      *(_OWORD *)(v357 + 16) = *(_OWORD *)(v5 + 16);
      LODWORD(v299) = v636;
      int v323 = v330;
      if (v333 >= 33)
      {
        unint64_t v358 = v357 + v333;
        v359 = (_OWORD *)(v357 + 32);
        uint64_t v360 = (long long *)(v5 + 48);
        do
        {
          _OWORD *v359 = *(v360 - 1);
          long long v361 = *v360;
          v360 += 2;
          v359[1] = v361;
          v359 += 2;
        }
        while ((unint64_t)v359 < v358);
      }
    }
    else
    {
      sub_1DD29DBFC(v334, (char *)v5, v329, v640);
      LODWORD(v299) = v636;
      int v323 = v330;
    }
    *(void *)(a2 + 24) += v333;
    uint64_t v362 = *(void *)(a2 + 8);
    if ((unint64_t)v333 >= 0x10000)
    {
      unint64_t v363 = (unint64_t)(v362 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v363;
    }
LABEL_484:
    unint64_t v365 = v332 + 4;
    *(_WORD *)(v362 + 4) = v333;
    *(_DWORD *)uint64_t v362 = 1;
    __int16 v380 = v332 + 1;
    uint64_t v366 = v18;
    if ((v332 + 1) >> 16) {
      goto LABEL_545;
    }
    goto LABEL_546;
  }
  if (v7 != 7)
  {
    uint64_t v661 = *(void *)(a1 + 112);
    uint64_t v653 = *(void *)(a1 + 128);
    uint64_t v431 = *(void *)(a1 + 8);
    unint64_t v9 = (unint64_t)&a4[a5];
    int v432 = a4 + a5 - v431;
    unsigned int v433 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v434 = *(_DWORD *)(a1 + 24);
    unsigned int v435 = v432 - v434;
    unsigned int v436 = v432 - v433;
    if (v435 > v433 && *(_DWORD *)(a1 + 40) == 0) {
      uint64_t v438 = v436;
    }
    else {
      uint64_t v438 = v434;
    }
    unint64_t v665 = v9 - 8;
    uint64_t v18 = *a3;
    uint64_t v17 = a3[1];
    uint64_t v439 = *(void *)(a1 + 248);
    uint64_t v440 = *(void *)(v439 + 112);
    uint64_t v441 = *(void *)(v439 + 128);
    v442 = *(char **)v439;
    uint64_t v601 = *(unsigned int *)(v439 + 24);
    uint64_t v625 = *(void *)(v439 + 8);
    unsigned int v443 = *(_DWORD *)(v439 + 264);
    unsigned int v444 = *(_DWORD *)(v439 + 260);
    v669 = (unsigned __int8 *)(v431 + v438);
    v633 = v442;
    int v445 = a4 - (v625 + v601) - (v431 + v438) + v442;
    if (*(_DWORD *)(a1 + 296))
    {
      if (v443 <= 0x3D)
      {
        unint64_t v446 = 0;
        do
        {
          _X16 = v440 + v446;
          __asm { PRFM            #2, [X16] }
          v446 += 64;
        }
        while (v446 < 4 << v443);
      }
      if (v444 <= 0x3D)
      {
        unint64_t v449 = 0;
        do
        {
          _X15 = v441 + v449;
          __asm { PRFM            #2, [X15] }
          v449 += 64;
        }
        while (v449 < 4 << v444);
      }
    }
    if (v445) {
      v452 = a4;
    }
    else {
      v452 = a4 + 1;
    }
    if ((unint64_t)v452 >= v665) {
      goto LABEL_781;
    }
    unint64_t v576 = v625 + v601;
    v593 = a3;
    char v657 = 64 - *(_DWORD *)(a1 + 264);
    char v649 = 32 - *(_DWORD *)(a1 + 260);
    char v617 = 56 - v443;
    char v605 = 24 - v444;
    int v645 = v438 - 1;
    unint64_t v597 = v9 - 7;
    unint64_t v588 = v9 - 1;
    unint64_t v592 = v9 - 3;
    int v637 = v438;
    v641 = (char *)(v9 - 32);
    uint64_t v572 = v625 - 1;
    uint64_t v580 = v431 + 16;
    uint64_t v584 = v431 - 1;
    unsigned int v613 = v438 + v625 - v633;
    unint64_t v629 = v9;
    uint64_t v621 = v440;
    uint64_t v609 = v441;
    while (1)
    {
      uint64_t v453 = *(void *)v452;
      unint64_t v454 = 0xCF1BBCDCB7A56463 * *(void *)v452;
      unint64_t v455 = v454 >> v657;
      unsigned int v456 = -1640531535 * *(void *)v452;
      unsigned int v457 = v456 >> v649;
      unint64_t v458 = v454 >> v617;
      unsigned int v459 = v456 >> v605;
      unint64_t v460 = *(unsigned int *)(v440 + ((v454 >> v617 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      unint64_t v461 = *(unsigned int *)(v441 + 4 * (v459 >> 8));
      int v462 = v452 - v431;
      uint64_t v463 = *(unsigned int *)(v661 + 4 * (v454 >> v657));
      uint64_t v464 = *(unsigned int *)(v653 + 4 * v457);
      int v465 = v452 - v431 + 1;
      uint64_t v466 = (v465 - v18);
      uint64_t v467 = v625 + v466 - v613;
      if (v466 >= v438) {
        uint64_t v467 = v431 + v466;
      }
      *(_DWORD *)(v653 + 4 * v457) = v462;
      *(_DWORD *)(v661 + 4 * v455) = v462;
      if ((v645 - v466) >= 3)
      {
        unint64_t v468 = (unint64_t)(v452 + 1);
        if (*(_DWORD *)v467 == *(_DWORD *)(v452 + 1)) {
          break;
        }
      }
      if (v463 <= v438)
      {
        unint64_t v479 = v460 >> 8;
        if (v458 == v460 && v479 > v601)
        {
          uint64_t v516 = v625 + (v460 >> 8);
          if (*(void *)v516 == v453)
          {
            unint64_t v517 = sub_1DD2A6010((void *)v452 + 1, (char *)(v516 + 8), v9, v633, v669);
            int v462 = v452 - v431;
            unint64_t v504 = v517 + 8;
            uint64_t v505 = v452 - v431 - v613 - v479;
            if ((unint64_t)v452 > v5)
            {
              unsigned int v506 = v452 - 1;
              v518 = (unsigned __int8 *)(v572 + v479);
              LODWORD(v438) = v637;
              while (*v506 == *v518)
              {
                ++v504;
                unint64_t v508 = v506 - 1;
                if ((unint64_t)v506 > v5)
                {
                  --v506;
                  BOOL v63 = (unint64_t)v518-- > v576;
                  if (v63) {
                    continue;
                  }
                }
LABEL_707:
                unint64_t v468 = (unint64_t)(v508 + 1);
                goto LABEL_726;
              }
LABEL_725:
              unint64_t v468 = (unint64_t)(v506 + 1);
LABEL_726:
              unint64_t v531 = v641;
LABEL_727:
              uint64_t v532 = v468 - v5;
              uint64_t v533 = *(_OWORD **)(a2 + 24);
              if (v468 > (unint64_t)v531)
              {
                int v534 = v462;
                uint64_t v535 = (char *)v5;
                uint64_t v536 = v505;
                sub_1DD29DBFC(v533, v535, v468, v531);
                uint64_t v505 = v536;
                LODWORD(v438) = v637;
                goto LABEL_729;
              }
              *uint64_t v533 = *(_OWORD *)v5;
              uint64_t v538 = *(void *)(a2 + 24);
              if ((unint64_t)v532 <= 0x10)
              {
                *(void *)(a2 + 24) = v538 + v532;
                uint64_t v501 = *(void *)(a2 + 8);
              }
              else
              {
                int v534 = v462;
                *(_OWORD *)(v538 + 16) = *(_OWORD *)(v5 + 16);
                if (v532 >= 33)
                {
                  unint64_t v539 = v538 + v532;
                  int v540 = (_OWORD *)(v538 + 32);
                  int v541 = (long long *)(v5 + 48);
                  do
                  {
                    *int v540 = *(v541 - 1);
                    long long v542 = *v541;
                    v541 += 2;
                    v540[1] = v542;
                    v540 += 2;
                  }
                  while ((unint64_t)v540 < v539);
                }
LABEL_729:
                *(void *)(a2 + 24) += v532;
                uint64_t v501 = *(void *)(a2 + 8);
                if ((unint64_t)v532 >= 0x10000)
                {
                  unint64_t v537 = (unint64_t)(v501 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 1;
                  *(_DWORD *)(a2 + 76) = v537;
                }
                int v462 = v534;
              }
              *(_WORD *)(v501 + 4) = v532;
              *(_DWORD *)uint64_t v501 = v505 + 3;
              __int16 v519 = v504 - 3;
              uint64_t v17 = v18;
              uint64_t v18 = v505;
              if (v504 - 3 >= 0x10000)
              {
LABEL_739:
                unint64_t v543 = (unint64_t)(v501 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v543;
                uint64_t v18 = v505;
              }
LABEL_740:
              *(_WORD *)(v501 + 6) = v519;
              *(void *)(a2 + 8) = v501 + 8;
              unint64_t v5 = v468 + v504;
              if (v468 + v504 <= v665)
              {
                *(_DWORD *)(v661 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v431 + (v462 + 2))) >> v657)) = v462 + 2;
                *(_DWORD *)(v661 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v657)) = v5 - 2 - v431;
                *(_DWORD *)(v653
                          + 4 * ((-1640531535 * *(_DWORD *)(v431 + (v462 + 2))) >> v649)) = v462 + 2;
                *(_DWORD *)(v653 + 4 * ((-1640531535 * *(_DWORD *)(v5 - 1)) >> v649)) = v5 - 1 - v431;
                uint64_t v544 = v18;
                uint64_t v545 = v17;
                unint64_t v9 = v629;
                while (1)
                {
                  uint64_t v18 = v545;
                  uint64_t v545 = v544;
                  int v546 = v5 - v431;
                  uint64_t v547 = (v5 - v431 - v18);
                  uint64_t v548 = v625 - v613;
                  if (v547 >= v438) {
                    uint64_t v548 = v431;
                  }
                  if ((v645 - v547) < 3) {
                    break;
                  }
                  uint64_t v549 = v548 + v547;
                  if (*(_DWORD *)v549 != *(_DWORD *)v5) {
                    break;
                  }
                  if (v547 >= v438) {
                    v550 = (char *)v629;
                  }
                  else {
                    v550 = v633;
                  }
                  unint64_t v551 = sub_1DD2A6010((void *)(v5 + 4), (char *)(v549 + 4), v629, v550, v669);
                  v552 = *(_OWORD **)(a2 + 24);
                  if (v5 <= (unint64_t)v641) {
                    _OWORD *v552 = *(_OWORD *)v5;
                  }
                  else {
                    sub_1DD29DBFC(v552, (char *)v5, v5, v641);
                  }
                  LODWORD(v438) = v637;
                  uint64_t v553 = *(void *)(a2 + 8);
                  *(_WORD *)(v553 + 4) = 0;
                  *(_DWORD *)uint64_t v553 = 1;
                  if (v551 + 1 >= 0x10000)
                  {
                    unint64_t v554 = (unint64_t)(v553 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v554;
                  }
                  *(_DWORD *)(v653 + 4 * ((-1640531535 * *(_DWORD *)v5) >> v649)) = v546;
                  *(_DWORD *)(v661 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)v5) >> v657)) = v546;
                  v5 += v551 + 4;
                  *(_WORD *)(v553 + 6) = v551 + 1;
                  *(void *)(a2 + 8) = v553 + 8;
                  uint64_t v544 = v18;
                  uint64_t v17 = v545;
                  v452 = (unsigned __int8 *)v5;
                  if (v5 > v665) {
                    goto LABEL_758;
                  }
                }
                uint64_t v17 = v18;
                uint64_t v18 = v544;
                v452 = (unsigned __int8 *)v5;
              }
              else
              {
                v452 = (unsigned __int8 *)(v468 + v504);
                unint64_t v9 = v629;
              }
              goto LABEL_758;
            }
LABEL_685:
            unint64_t v468 = (unint64_t)v452;
            LODWORD(v438) = v637;
            goto LABEL_726;
          }
        }
      }
      else
      {
        uint64_t v474 = v431 + v463;
        if (*(void *)(v431 + v463) == v453)
        {
          unint64_t v475 = (char *)(v452 + 8);
          uint64_t v476 = (void *)(v474 + 8);
          if (v597 <= (unint64_t)(v452 + 8))
          {
            unsigned int v503 = v452 + 8;
          }
          else
          {
            unint64_t v477 = *(void *)v475 ^ *v476;
            if (v477)
            {
              unint64_t v478 = __clz(__rbit64(v477)) >> 3;
              goto LABEL_651;
            }
            uint64_t v522 = 0;
            unint64_t v523 = v452 + 16;
            while (1)
            {
              v524 = &v523[v522];
              if ((unint64_t)&v523[v522] >= v597) {
                break;
              }
              uint64_t v525 = *(void *)(v580 + v463 + v522);
              v522 += 8;
              unint64_t v526 = *(void *)v524 ^ v525;
              if (v526)
              {
                unint64_t v478 = v522 + (__clz(__rbit64(v526)) >> 3);
                goto LABEL_651;
              }
            }
            unsigned int v503 = &v452[v522 + 16];
            uint64_t v476 = (void *)(v580 + v463 + v522);
          }
          if ((unint64_t)v503 < v592 && *(_DWORD *)v476 == *(_DWORD *)v503)
          {
            v503 += 4;
            uint64_t v476 = (void *)((char *)v476 + 4);
          }
          if ((unint64_t)v503 < v588 && *(unsigned __int16 *)v476 == *(unsigned __int16 *)v503)
          {
            v503 += 2;
            uint64_t v476 = (void *)((char *)v476 + 2);
          }
          if ((unint64_t)v503 < v9 && *(unsigned __int8 *)v476 == *v503) {
            ++v503;
          }
          unint64_t v478 = v503 - (unsigned __int8 *)v475;
LABEL_651:
          unint64_t v504 = v478 + 8;
          uint64_t v505 = (v452 - v474);
          if ((unint64_t)v452 > v5)
          {
            unsigned int v506 = v452 - 1;
            unsigned int v507 = (unsigned __int8 *)(v584 + v463);
            while (*v506 == *v507)
            {
              ++v504;
              unint64_t v508 = v506 - 1;
              if ((unint64_t)v506 > v5)
              {
                --v506;
                BOOL v63 = v507-- > v669;
                if (v63) {
                  continue;
                }
              }
              goto LABEL_707;
            }
            goto LABEL_725;
          }
          goto LABEL_708;
        }
      }
      if (v464 <= v438)
      {
        unint64_t v492 = v461 >> 8;
        if (v459 == v461 && v492 > v601)
        {
          unint64_t v481 = v625 + v492;
          if (*(_DWORD *)(v625 + v492) == *(_DWORD *)v452)
          {
            LODWORD(v464) = v492 + v613;
LABEL_624:
            unint64_t v468 = (unint64_t)(v452 + 1);
            uint64_t v482 = *(void *)(v452 + 1);
            unint64_t v483 = (0xCF1BBCDCB7A56463 * v482) >> v657;
            unint64_t v484 = (0xCF1BBCDCB7A56463 * v482) >> v617;
            uint64_t v485 = *(unsigned int *)(v661 + 4 * v483);
            unsigned int v486 = *(_DWORD *)(v621 + ((v484 >> 6) & 0x3FFFFFFFFFFFFFCLL));
            *(_DWORD *)(v661 + 4 * v483) = v465;
            if (v485 <= v438)
            {
              unsigned int v509 = v486 >> 8;
              if (v484 == v486 && v509 > v601)
              {
                uint64_t v555 = v509;
                uint64_t v556 = v625 + v509;
                if (*(void *)v556 == v482)
                {
                  unint64_t v504 = sub_1DD2A6010(v452 + 9, (char *)(v556 + 8), v9, v633, v669) + 8;
                  uint64_t v505 = v465 - v613 - v555;
                  if (v468 <= v5)
                  {
                    LODWORD(v438) = v637;
                    unint64_t v531 = v641;
                    int v462 = v452 - v431;
                    goto LABEL_727;
                  }
                  v557 = (unsigned __int8 *)(v572 + v555);
                  LODWORD(v438) = v637;
                  int v462 = v452 - v431;
                  while (*v452 == *v557)
                  {
                    ++v504;
                    unsigned int v506 = v452 - 1;
                    if ((unint64_t)v557 > v576)
                    {
                      --v557;
                      BOOL v63 = (unint64_t)v452-- > v5;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_725;
                  }
                  goto LABEL_768;
                }
              }
            }
            else
            {
              uint64_t v487 = v431 + v485;
              if (*(void *)(v431 + v485) == v482)
              {
                unint64_t v488 = (char *)(v452 + 9);
                unint64_t v489 = (void *)(v487 + 8);
                if (v597 <= (unint64_t)(v452 + 9))
                {
                  unint64_t v529 = v452 + 9;
                }
                else
                {
                  unint64_t v490 = *(void *)v488 ^ *v489;
                  if (v490)
                  {
                    unint64_t v491 = __clz(__rbit64(v490)) >> 3;
                    goto LABEL_720;
                  }
                  uint64_t v563 = 0;
                  v564 = v452 + 17;
                  while (1)
                  {
                    v565 = &v564[v563];
                    if ((unint64_t)&v564[v563] >= v597) {
                      break;
                    }
                    uint64_t v566 = *(void *)(v580 + v485 + v563);
                    v563 += 8;
                    unint64_t v567 = *(void *)v565 ^ v566;
                    if (v567)
                    {
                      unint64_t v491 = v563 + (__clz(__rbit64(v567)) >> 3);
                      goto LABEL_720;
                    }
                  }
                  unint64_t v529 = &v452[v563 + 17];
                  unint64_t v489 = (void *)(v580 + v485 + v563);
                }
                if ((unint64_t)v529 < v592 && *(_DWORD *)v489 == *(_DWORD *)v529)
                {
                  v529 += 4;
                  unint64_t v489 = (void *)((char *)v489 + 4);
                }
                if ((unint64_t)v529 < v588 && *(unsigned __int16 *)v489 == *(unsigned __int16 *)v529)
                {
                  v529 += 2;
                  unint64_t v489 = (void *)((char *)v489 + 2);
                }
                if ((unint64_t)v529 < v9 && *(unsigned __int8 *)v489 == *v529) {
                  ++v529;
                }
                unint64_t v491 = v529 - (unsigned __int8 *)v488;
LABEL_720:
                unint64_t v504 = v491 + 8;
                uint64_t v505 = (v468 - v487);
                if (v468 <= v5) {
                  goto LABEL_726;
                }
                unint64_t v530 = (unsigned __int8 *)(v584 + v485);
                while (*v452 == *v530)
                {
                  ++v504;
                  unsigned int v506 = v452 - 1;
                  if (v530 > v669)
                  {
                    --v530;
                    BOOL v63 = (unint64_t)v452-- > v5;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_725;
                }
LABEL_768:
                unint64_t v468 = (unint64_t)(v452 + 1);
                goto LABEL_726;
              }
            }
            unint64_t v511 = (char *)(v452 + 4);
            unint64_t v512 = (char *)(v481 + 4);
            if (v464 < v438)
            {
              unint64_t v513 = v481;
              unint64_t v514 = sub_1DD2A6010(v511, v512, v9, v633, v669);
              int v462 = v452 - v431;
              unint64_t v504 = v514 + 4;
              uint64_t v505 = (v452 - v431 - v464);
              if ((unint64_t)v452 > v5 && v513 > v576)
              {
                unsigned int v506 = v452 - 1;
                unint64_t v515 = (unsigned __int8 *)(v513 - 1);
                LODWORD(v438) = v637;
                while (*v506 == *v515)
                {
                  ++v504;
                  unint64_t v508 = v506 - 1;
                  if ((unint64_t)v506 > v5)
                  {
                    --v506;
                    BOOL v63 = (unint64_t)v515-- > v576;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_707;
                }
                goto LABEL_725;
              }
              goto LABEL_685;
            }
            if (v597 <= (unint64_t)v511)
            {
              v527 = v452 + 4;
            }
            else
            {
              unint64_t v520 = *(void *)v511 ^ *(void *)v512;
              if (v520)
              {
                unint64_t v521 = __clz(__rbit64(v520)) >> 3;
LABEL_701:
                unint64_t v504 = v521 + 4;
                uint64_t v505 = (v452 - v481);
                if ((unint64_t)v452 > v5 && v481 > (unint64_t)v669)
                {
                  unsigned int v506 = v452 - 1;
                  unint64_t v528 = (unsigned __int8 *)(v481 - 1);
                  while (*v506 == *v528)
                  {
                    ++v504;
                    unint64_t v508 = v506 - 1;
                    if ((unint64_t)v506 > v5)
                    {
                      --v506;
                      BOOL v63 = v528-- > v669;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_707;
                  }
                  goto LABEL_725;
                }
LABEL_708:
                unint64_t v468 = (unint64_t)v452;
                goto LABEL_726;
              }
              uint64_t v558 = 0;
              v559 = v452 + 12;
              while (1)
              {
                v560 = &v559[v558];
                if ((unint64_t)&v559[v558] >= v597) {
                  break;
                }
                uint64_t v561 = *(void *)(v481 + 12 + v558);
                v558 += 8;
                unint64_t v562 = *(void *)v560 ^ v561;
                if (v562)
                {
                  unint64_t v521 = v558 + (__clz(__rbit64(v562)) >> 3);
                  goto LABEL_701;
                }
              }
              v527 = &v452[v558 + 12];
              unint64_t v512 = (char *)(v481 + v558 + 12);
            }
            if ((unint64_t)v527 < v592 && *(_DWORD *)v512 == *(_DWORD *)v527)
            {
              v527 += 4;
              v512 += 4;
            }
            if ((unint64_t)v527 < v588 && *(unsigned __int16 *)v512 == *(unsigned __int16 *)v527)
            {
              v527 += 2;
              v512 += 2;
            }
            if ((unint64_t)v527 < v9 && *v512 == *v527) {
              ++v527;
            }
            unint64_t v521 = v527 - (unsigned __int8 *)v511;
            goto LABEL_701;
          }
        }
      }
      else
      {
        unint64_t v481 = v431 + v464;
        if (*(_DWORD *)(v431 + v464) == *(_DWORD *)v452) {
          goto LABEL_624;
        }
      }
      _X8 = &v452[(uint64_t)&v452[-v5] >> 8];
      v452 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
LABEL_758:
      uint64_t v440 = v621;
      uint64_t v441 = v609;
      if ((unint64_t)v452 >= v665) {
        goto LABEL_780;
      }
    }
    int v469 = v452 - v431;
    if (v466 >= v438) {
      unint64_t v470 = (char *)v9;
    }
    else {
      unint64_t v470 = v633;
    }
    unint64_t v471 = sub_1DD2A6010(v452 + 5, (char *)(v467 + 4), v9, v470, v669);
    uint64_t v472 = v468 - v5;
    v473 = *(_OWORD **)(a2 + 24);
    if (v468 <= (unint64_t)v641)
    {
      _OWORD *v473 = *(_OWORD *)v5;
      uint64_t v496 = *(void *)(a2 + 24);
      if ((unint64_t)v472 <= 0x10)
      {
        *(void *)(a2 + 24) = v496 + v472;
        uint64_t v501 = *(void *)(a2 + 8);
        LODWORD(v438) = v637;
        int v462 = v469;
        goto LABEL_678;
      }
      *(_OWORD *)(v496 + 16) = *(_OWORD *)(v5 + 16);
      LODWORD(v438) = v637;
      int v462 = v469;
      if (v472 >= 33)
      {
        unint64_t v497 = v496 + v472;
        unsigned int v498 = (_OWORD *)(v496 + 32);
        unsigned int v499 = (long long *)(v5 + 48);
        do
        {
          *unsigned int v498 = *(v499 - 1);
          long long v500 = *v499;
          v499 += 2;
          v498[1] = v500;
          v498 += 2;
        }
        while ((unint64_t)v498 < v497);
      }
    }
    else
    {
      sub_1DD29DBFC(v473, (char *)v5, v468, v641);
      LODWORD(v438) = v637;
      int v462 = v469;
    }
    *(void *)(a2 + 24) += v472;
    uint64_t v501 = *(void *)(a2 + 8);
    if ((unint64_t)v472 >= 0x10000)
    {
      unint64_t v502 = (unint64_t)(v501 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v502;
    }
LABEL_678:
    unint64_t v504 = v471 + 4;
    *(_WORD *)(v501 + 4) = v472;
    *(_DWORD *)uint64_t v501 = 1;
    __int16 v519 = v471 + 1;
    uint64_t v505 = v18;
    if ((v471 + 1) >> 16) {
      goto LABEL_739;
    }
    goto LABEL_740;
  }
  uint64_t v658 = *(void *)(a1 + 112);
  uint64_t v650 = *(void *)(a1 + 128);
  uint64_t v8 = *(void *)(a1 + 8);
  unint64_t v9 = (unint64_t)&a4[a5];
  int v10 = a4 + a5 - v8;
  unsigned int v11 = 1 << *(_DWORD *)(a1 + 256);
  unsigned int v12 = *(_DWORD *)(a1 + 24);
  unsigned int v13 = v10 - v12;
  unsigned int v14 = v10 - v11;
  if (v13 > v11 && *(_DWORD *)(a1 + 40) == 0) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v12;
  }
  unint64_t v662 = v9 - 8;
  uint64_t v18 = *a3;
  uint64_t v17 = a3[1];
  uint64_t v19 = *(void *)(a1 + 248);
  uint64_t v20 = *(void *)(v19 + 112);
  uint64_t v21 = *(void *)(v19 + 128);
  int64_t v22 = *(char **)v19;
  uint64_t v598 = *(unsigned int *)(v19 + 24);
  uint64_t v622 = *(void *)(v19 + 8);
  unsigned int v23 = *(_DWORD *)(v19 + 264);
  unsigned int v24 = *(_DWORD *)(v19 + 260);
  v666 = (unsigned __int8 *)(v8 + v16);
  v630 = v22;
  int v25 = a4 - (v622 + v598) - (v8 + v16) + v22;
  if (*(_DWORD *)(a1 + 296))
  {
    if (v23 <= 0x3D)
    {
      unint64_t v26 = 0;
      do
      {
        _X16 = v20 + v26;
        __asm { PRFM            #2, [X16] }
        v26 += 64;
      }
      while (v26 < 4 << v23);
    }
    if (v24 <= 0x3D)
    {
      unint64_t v32 = 0;
      do
      {
        _X15 = v21 + v32;
        __asm { PRFM            #2, [X15] }
        v32 += 64;
      }
      while (v32 < 4 << v24);
    }
  }
  if (v25) {
    uint64_t v35 = a4;
  }
  else {
    uint64_t v35 = a4 + 1;
  }
  if ((unint64_t)v35 < v662)
  {
    unint64_t v573 = v622 + v598;
    v593 = a3;
    char v654 = 64 - *(_DWORD *)(a1 + 264);
    char v646 = 64 - *(_DWORD *)(a1 + 260);
    char v614 = 56 - v23;
    char v602 = 56 - v24;
    int v642 = v16 - 1;
    unint64_t v594 = v9 - 7;
    unint64_t v585 = v9 - 1;
    unint64_t v589 = v9 - 3;
    int v634 = v16;
    v638 = (char *)(v9 - 32);
    uint64_t v569 = v622 - 1;
    uint64_t v577 = v8 + 16;
    uint64_t v581 = v8 - 1;
    unsigned int v610 = v16 + v622 - v630;
    unint64_t v626 = v9;
    uint64_t v618 = v20;
    uint64_t v606 = v21;
    while (1)
    {
      uint64_t v36 = *(void *)v35;
      unint64_t v37 = 0xCF1BBCDCB7A56463 * *(void *)v35;
      unint64_t v38 = v37 >> v654;
      unint64_t v39 = 0xCF1BBCDCBFA56300 * *(void *)v35;
      unint64_t v40 = v39 >> v646;
      unint64_t v41 = v37 >> v614;
      unint64_t v42 = v39 >> v602;
      unint64_t v43 = *(unsigned int *)(v20 + ((v37 >> v614 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      unint64_t v44 = *(unsigned int *)(v21 + ((v42 >> 6) & 0x3FFFFFFFFFFFFFCLL));
      int v45 = v35 - v8;
      uint64_t v46 = *(unsigned int *)(v658 + 4 * (v37 >> v654));
      uint64_t v47 = *(unsigned int *)(v650 + 4 * v40);
      int v48 = v35 - v8 + 1;
      uint64_t v49 = (v48 - v18);
      uint64_t v50 = v622 + v49 - v610;
      if (v49 >= v16) {
        uint64_t v50 = v8 + v49;
      }
      *(_DWORD *)(v650 + 4 * v40) = v45;
      *(_DWORD *)(v658 + 4 * v38) = v45;
      if ((v642 - v49) >= 3)
      {
        unint64_t v51 = (unint64_t)(v35 + 1);
        if (*(_DWORD *)v50 == *(_DWORD *)(v35 + 1)) {
          break;
        }
      }
      if (v46 <= v16)
      {
        unint64_t v62 = v43 >> 8;
        BOOL v63 = v41 == v43 && v62 > v598;
        if (v63)
        {
          uint64_t v99 = v622 + (v43 >> 8);
          if (*(void *)v99 == v36)
          {
            unint64_t v100 = sub_1DD2A6010((void *)v35 + 1, (char *)(v99 + 8), v9, v630, v666);
            int v45 = v35 - v8;
            unint64_t v87 = v100 + 8;
            uint64_t v88 = v35 - v8 - v610 - v62;
            if ((unint64_t)v35 > v5)
            {
              unsigned int v89 = v35 - 1;
              uint64_t v101 = (unsigned __int8 *)(v569 + v62);
              LODWORD(v16) = v634;
              while (*v89 == *v101)
              {
                ++v87;
                unint64_t v91 = v89 - 1;
                if ((unint64_t)v89 > v5)
                {
                  --v89;
                  BOOL v63 = (unint64_t)v101-- > v573;
                  if (v63) {
                    continue;
                  }
                }
LABEL_125:
                unint64_t v51 = (unint64_t)(v91 + 1);
                goto LABEL_144;
              }
LABEL_143:
              unint64_t v51 = (unint64_t)(v89 + 1);
LABEL_144:
              unint64_t v114 = v638;
LABEL_145:
              uint64_t v115 = v51 - v5;
              long long v116 = *(_OWORD **)(a2 + 24);
              if (v51 > (unint64_t)v114)
              {
                int v117 = v45;
                long long v118 = (char *)v5;
                uint64_t v119 = v88;
                sub_1DD29DBFC(v116, v118, v51, v114);
                uint64_t v88 = v119;
                LODWORD(v16) = v634;
                goto LABEL_147;
              }
              *long long v116 = *(_OWORD *)v5;
              uint64_t v121 = *(void *)(a2 + 24);
              if ((unint64_t)v115 <= 0x10)
              {
                *(void *)(a2 + 24) = v121 + v115;
                uint64_t v84 = *(void *)(a2 + 8);
              }
              else
              {
                int v117 = v45;
                *(_OWORD *)(v121 + 16) = *(_OWORD *)(v5 + 16);
                if (v115 >= 33)
                {
                  unint64_t v122 = v121 + v115;
                  uint64_t v123 = (_OWORD *)(v121 + 32);
                  long long v124 = (long long *)(v5 + 48);
                  do
                  {
                    _OWORD *v123 = *(v124 - 1);
                    long long v125 = *v124;
                    v124 += 2;
                    v123[1] = v125;
                    v123 += 2;
                  }
                  while ((unint64_t)v123 < v122);
                }
LABEL_147:
                *(void *)(a2 + 24) += v115;
                uint64_t v84 = *(void *)(a2 + 8);
                if ((unint64_t)v115 >= 0x10000)
                {
                  unint64_t v120 = (unint64_t)(v84 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 1;
                  *(_DWORD *)(a2 + 76) = v120;
                }
                int v45 = v117;
              }
              *(_WORD *)(v84 + 4) = v115;
              *(_DWORD *)uint64_t v84 = v88 + 3;
              __int16 v102 = v87 - 3;
              uint64_t v17 = v18;
              uint64_t v18 = v88;
              if (v87 - 3 >= 0x10000)
              {
LABEL_157:
                unint64_t v126 = (unint64_t)(v84 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v126;
                uint64_t v18 = v88;
              }
LABEL_158:
              *(_WORD *)(v84 + 6) = v102;
              *(void *)(a2 + 8) = v84 + 8;
              unint64_t v5 = v51 + v87;
              if (v51 + v87 <= v662)
              {
                uint64_t v127 = *(void *)(v8 + (v45 + 2));
                *(_DWORD *)(v658 + 4 * ((0xCF1BBCDCB7A56463 * v127) >> v654)) = v45 + 2;
                *(_DWORD *)(v658 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v5 - 2)) >> v654)) = v5 - 2 - v8;
                *(_DWORD *)(v650 + 4 * ((0xCF1BBCDCBFA56300 * v127) >> v646)) = v45 + 2;
                *(_DWORD *)(v650 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v5 - 1)) >> v646)) = v5 - 1 - v8;
                uint64_t v128 = v18;
                uint64_t v129 = v17;
                unint64_t v9 = v626;
                while (1)
                {
                  uint64_t v18 = v129;
                  uint64_t v129 = v128;
                  int v130 = v5 - v8;
                  uint64_t v131 = (v5 - v8 - v18);
                  uint64_t v132 = v622 - v610;
                  if (v131 >= v16) {
                    uint64_t v132 = v8;
                  }
                  if ((v642 - v131) < 3) {
                    break;
                  }
                  uint64_t v133 = v132 + v131;
                  if (*(_DWORD *)v133 != *(_DWORD *)v5) {
                    break;
                  }
                  if (v131 >= v16) {
                    BOOL v134 = (char *)v626;
                  }
                  else {
                    BOOL v134 = v630;
                  }
                  unint64_t v135 = sub_1DD2A6010((void *)(v5 + 4), (char *)(v133 + 4), v626, v134, v666);
                  unint64_t v136 = *(_OWORD **)(a2 + 24);
                  if (v5 <= (unint64_t)v638) {
                    *unint64_t v136 = *(_OWORD *)v5;
                  }
                  else {
                    sub_1DD29DBFC(v136, (char *)v5, v5, v638);
                  }
                  LODWORD(v16) = v634;
                  uint64_t v137 = *(void *)(a2 + 8);
                  *(_WORD *)(v137 + 4) = 0;
                  *(_DWORD *)uint64_t v137 = 1;
                  if (v135 + 1 >= 0x10000)
                  {
                    unint64_t v138 = (unint64_t)(v137 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v138;
                  }
                  *(_WORD *)(v137 + 6) = v135 + 1;
                  uint64_t v139 = *(void *)v5;
                  *(_DWORD *)(v650 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v5) >> v646)) = v130;
                  *(_DWORD *)(v658 + 4 * ((0xCF1BBCDCB7A56463 * v139) >> v654)) = v130;
                  v5 += v135 + 4;
                  *(void *)(a2 + 8) = v137 + 8;
                  uint64_t v128 = v18;
                  uint64_t v17 = v129;
                  uint64_t v35 = (unsigned __int8 *)v5;
                  if (v5 > v662) {
                    goto LABEL_176;
                  }
                }
                uint64_t v17 = v18;
                uint64_t v18 = v128;
                uint64_t v35 = (unsigned __int8 *)v5;
              }
              else
              {
                uint64_t v35 = (unsigned __int8 *)(v51 + v87);
                unint64_t v9 = v626;
              }
              goto LABEL_176;
            }
LABEL_103:
            unint64_t v51 = (unint64_t)v35;
            LODWORD(v16) = v634;
            goto LABEL_144;
          }
        }
      }
      else
      {
        uint64_t v57 = v8 + v46;
        if (*(void *)(v8 + v46) == v36)
        {
          unint64_t v58 = (char *)(v35 + 8);
          unint64_t v59 = (void *)(v57 + 8);
          if (v594 <= (unint64_t)(v35 + 8))
          {
            uint64_t v86 = v35 + 8;
          }
          else
          {
            unint64_t v60 = *(void *)v58 ^ *v59;
            if (v60)
            {
              unint64_t v61 = __clz(__rbit64(v60)) >> 3;
              goto LABEL_69;
            }
            uint64_t v105 = 0;
            unint64_t v106 = v35 + 16;
            while (1)
            {
              uint64_t v107 = &v106[v105];
              if ((unint64_t)&v106[v105] >= v594) {
                break;
              }
              uint64_t v108 = *(void *)(v577 + v46 + v105);
              v105 += 8;
              unint64_t v109 = *(void *)v107 ^ v108;
              if (v109)
              {
                unint64_t v61 = v105 + (__clz(__rbit64(v109)) >> 3);
                goto LABEL_69;
              }
            }
            uint64_t v86 = &v35[v105 + 16];
            unint64_t v59 = (void *)(v577 + v46 + v105);
          }
          if ((unint64_t)v86 < v589 && *(_DWORD *)v59 == *(_DWORD *)v86)
          {
            v86 += 4;
            unint64_t v59 = (void *)((char *)v59 + 4);
          }
          if ((unint64_t)v86 < v585 && *(unsigned __int16 *)v59 == *(unsigned __int16 *)v86)
          {
            v86 += 2;
            unint64_t v59 = (void *)((char *)v59 + 2);
          }
          if ((unint64_t)v86 < v9 && *(unsigned __int8 *)v59 == *v86) {
            ++v86;
          }
          unint64_t v61 = v86 - (unsigned __int8 *)v58;
LABEL_69:
          unint64_t v87 = v61 + 8;
          uint64_t v88 = (v35 - v57);
          if ((unint64_t)v35 > v5)
          {
            unsigned int v89 = v35 - 1;
            uint64_t v90 = (unsigned __int8 *)(v581 + v46);
            while (*v89 == *v90)
            {
              ++v87;
              unint64_t v91 = v89 - 1;
              if ((unint64_t)v89 > v5)
              {
                --v89;
                BOOL v63 = v90-- > v666;
                if (v63) {
                  continue;
                }
              }
              goto LABEL_125;
            }
            goto LABEL_143;
          }
          goto LABEL_126;
        }
      }
      if (v47 <= v16)
      {
        unint64_t v75 = v44 >> 8;
        if (v42 == v44 && v75 > v598)
        {
          unint64_t v64 = v622 + v75;
          if (*(_DWORD *)(v622 + v75) == *(_DWORD *)v35)
          {
            LODWORD(v47) = v75 + v610;
LABEL_42:
            unint64_t v51 = (unint64_t)(v35 + 1);
            uint64_t v65 = *(void *)(v35 + 1);
            unint64_t v66 = (0xCF1BBCDCB7A56463 * v65) >> v654;
            unint64_t v67 = (0xCF1BBCDCB7A56463 * v65) >> v614;
            uint64_t v68 = *(unsigned int *)(v658 + 4 * v66);
            unsigned int v69 = *(_DWORD *)(v618 + ((v67 >> 6) & 0x3FFFFFFFFFFFFFCLL));
            *(_DWORD *)(v658 + 4 * v66) = v48;
            if (v68 <= v16)
            {
              unsigned int v92 = v69 >> 8;
              if (v67 == v69 && v92 > v598)
              {
                uint64_t v140 = v92;
                uint64_t v141 = v622 + v92;
                if (*(void *)v141 == v65)
                {
                  unint64_t v87 = sub_1DD2A6010(v35 + 9, (char *)(v141 + 8), v9, v630, v666) + 8;
                  uint64_t v88 = v48 - v610 - v140;
                  if (v51 <= v5)
                  {
                    LODWORD(v16) = v634;
                    unint64_t v114 = v638;
                    int v45 = v35 - v8;
                    goto LABEL_145;
                  }
                  unint64_t v142 = (unsigned __int8 *)(v569 + v140);
                  LODWORD(v16) = v634;
                  int v45 = v35 - v8;
                  while (*v35 == *v142)
                  {
                    ++v87;
                    unsigned int v89 = v35 - 1;
                    if ((unint64_t)v142 > v573)
                    {
                      --v142;
                      BOOL v63 = (unint64_t)v35-- > v5;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_143;
                  }
                  goto LABEL_186;
                }
              }
            }
            else
            {
              uint64_t v70 = v8 + v68;
              if (*(void *)(v8 + v68) == v65)
              {
                unint64_t v71 = (char *)(v35 + 9);
                __int16 v72 = (void *)(v70 + 8);
                if (v594 <= (unint64_t)(v35 + 9))
                {
                  unint64_t v112 = v35 + 9;
                }
                else
                {
                  unint64_t v73 = *(void *)v71 ^ *v72;
                  if (v73)
                  {
                    unint64_t v74 = __clz(__rbit64(v73)) >> 3;
                    goto LABEL_138;
                  }
                  uint64_t v148 = 0;
                  uint64_t v149 = v35 + 17;
                  while (1)
                  {
                    int v150 = &v149[v148];
                    if ((unint64_t)&v149[v148] >= v594) {
                      break;
                    }
                    uint64_t v151 = *(void *)(v577 + v68 + v148);
                    v148 += 8;
                    unint64_t v152 = *(void *)v150 ^ v151;
                    if (v152)
                    {
                      unint64_t v74 = v148 + (__clz(__rbit64(v152)) >> 3);
                      goto LABEL_138;
                    }
                  }
                  unint64_t v112 = &v35[v148 + 17];
                  __int16 v72 = (void *)(v577 + v68 + v148);
                }
                if ((unint64_t)v112 < v589 && *(_DWORD *)v72 == *(_DWORD *)v112)
                {
                  v112 += 4;
                  __int16 v72 = (void *)((char *)v72 + 4);
                }
                if ((unint64_t)v112 < v585 && *(unsigned __int16 *)v72 == *(unsigned __int16 *)v112)
                {
                  v112 += 2;
                  __int16 v72 = (void *)((char *)v72 + 2);
                }
                if ((unint64_t)v112 < v9 && *(unsigned __int8 *)v72 == *v112) {
                  ++v112;
                }
                unint64_t v74 = v112 - (unsigned __int8 *)v71;
LABEL_138:
                unint64_t v87 = v74 + 8;
                uint64_t v88 = (v51 - v70);
                if (v51 <= v5) {
                  goto LABEL_144;
                }
                uint64_t v113 = (unsigned __int8 *)(v581 + v68);
                while (*v35 == *v113)
                {
                  ++v87;
                  unsigned int v89 = v35 - 1;
                  if (v113 > v666)
                  {
                    --v113;
                    BOOL v63 = (unint64_t)v35-- > v5;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_143;
                }
LABEL_186:
                unint64_t v51 = (unint64_t)(v35 + 1);
                goto LABEL_144;
              }
            }
            unsigned int v94 = (char *)(v35 + 4);
            uint64_t v95 = (char *)(v64 + 4);
            if (v47 < v16)
            {
              unint64_t v96 = v64;
              unint64_t v97 = sub_1DD2A6010(v94, v95, v9, v630, v666);
              int v45 = v35 - v8;
              unint64_t v87 = v97 + 4;
              uint64_t v88 = (v35 - v8 - v47);
              if ((unint64_t)v35 > v5 && v96 > v573)
              {
                unsigned int v89 = v35 - 1;
                uint64_t v98 = (unsigned __int8 *)(v96 - 1);
                LODWORD(v16) = v634;
                while (*v89 == *v98)
                {
                  ++v87;
                  unint64_t v91 = v89 - 1;
                  if ((unint64_t)v89 > v5)
                  {
                    --v89;
                    BOOL v63 = (unint64_t)v98-- > v573;
                    if (v63) {
                      continue;
                    }
                  }
                  goto LABEL_125;
                }
                goto LABEL_143;
              }
              goto LABEL_103;
            }
            if (v594 <= (unint64_t)v94)
            {
              uint64_t v110 = v35 + 4;
            }
            else
            {
              unint64_t v103 = *(void *)v94 ^ *(void *)v95;
              if (v103)
              {
                unint64_t v104 = __clz(__rbit64(v103)) >> 3;
LABEL_119:
                unint64_t v87 = v104 + 4;
                uint64_t v88 = (v35 - v64);
                if ((unint64_t)v35 > v5 && v64 > (unint64_t)v666)
                {
                  unsigned int v89 = v35 - 1;
                  unint64_t v111 = (unsigned __int8 *)(v64 - 1);
                  while (*v89 == *v111)
                  {
                    ++v87;
                    unint64_t v91 = v89 - 1;
                    if ((unint64_t)v89 > v5)
                    {
                      --v89;
                      BOOL v63 = v111-- > v666;
                      if (v63) {
                        continue;
                      }
                    }
                    goto LABEL_125;
                  }
                  goto LABEL_143;
                }
LABEL_126:
                unint64_t v51 = (unint64_t)v35;
                goto LABEL_144;
              }
              uint64_t v143 = 0;
              unint64_t v144 = v35 + 12;
              while (1)
              {
                uint64_t v145 = &v144[v143];
                if ((unint64_t)&v144[v143] >= v594) {
                  break;
                }
                uint64_t v146 = *(void *)(v64 + 12 + v143);
                v143 += 8;
                unint64_t v147 = *(void *)v145 ^ v146;
                if (v147)
                {
                  unint64_t v104 = v143 + (__clz(__rbit64(v147)) >> 3);
                  goto LABEL_119;
                }
              }
              uint64_t v110 = &v35[v143 + 12];
              uint64_t v95 = (char *)(v64 + v143 + 12);
            }
            if ((unint64_t)v110 < v589 && *(_DWORD *)v95 == *(_DWORD *)v110)
            {
              v110 += 4;
              v95 += 4;
            }
            if ((unint64_t)v110 < v585 && *(unsigned __int16 *)v95 == *(unsigned __int16 *)v110)
            {
              v110 += 2;
              v95 += 2;
            }
            if ((unint64_t)v110 < v9 && *v95 == *v110) {
              ++v110;
            }
            unint64_t v104 = v110 - (unsigned __int8 *)v94;
            goto LABEL_119;
          }
        }
      }
      else
      {
        unint64_t v64 = v8 + v47;
        if (*(_DWORD *)(v8 + v47) == *(_DWORD *)v35) {
          goto LABEL_42;
        }
      }
      _X8 = &v35[(uint64_t)&v35[-v5] >> 8];
      uint64_t v35 = _X8 + 1;
      _X8 += 257;
      __asm { PRFM            #0, [X8] }
LABEL_176:
      uint64_t v20 = v618;
      uint64_t v21 = v606;
      if ((unint64_t)v35 >= v662) {
        goto LABEL_780;
      }
    }
    int v52 = v35 - v8;
    if (v49 >= v16) {
      uint64_t v53 = (char *)v9;
    }
    else {
      uint64_t v53 = v630;
    }
    unint64_t v54 = sub_1DD2A6010(v35 + 5, (char *)(v50 + 4), v9, v53, v666);
    uint64_t v55 = v51 - v5;
    unsigned int v56 = *(_OWORD **)(a2 + 24);
    if (v51 <= (unint64_t)v638)
    {
      _OWORD *v56 = *(_OWORD *)v5;
      uint64_t v79 = *(void *)(a2 + 24);
      if ((unint64_t)v55 <= 0x10)
      {
        *(void *)(a2 + 24) = v79 + v55;
        uint64_t v84 = *(void *)(a2 + 8);
        LODWORD(v16) = v634;
        int v45 = v52;
        goto LABEL_96;
      }
      *(_OWORD *)(v79 + 16) = *(_OWORD *)(v5 + 16);
      LODWORD(v16) = v634;
      int v45 = v52;
      if (v55 >= 33)
      {
        unint64_t v80 = v79 + v55;
        unint64_t v81 = (_OWORD *)(v79 + 32);
        unint64_t v82 = (long long *)(v5 + 48);
        do
        {
          *unint64_t v81 = *(v82 - 1);
          long long v83 = *v82;
          v82 += 2;
          v81[1] = v83;
          v81 += 2;
        }
        while ((unint64_t)v81 < v80);
      }
    }
    else
    {
      sub_1DD29DBFC(v56, (char *)v5, v51, v638);
      LODWORD(v16) = v634;
      int v45 = v52;
    }
    *(void *)(a2 + 24) += v55;
    uint64_t v84 = *(void *)(a2 + 8);
    if ((unint64_t)v55 >= 0x10000)
    {
      unint64_t v85 = (unint64_t)(v84 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 1;
      *(_DWORD *)(a2 + 76) = v85;
    }
LABEL_96:
    unint64_t v87 = v54 + 4;
    *(_WORD *)(v84 + 4) = v55;
    *(_DWORD *)uint64_t v84 = 1;
    __int16 v102 = v54 + 1;
    uint64_t v88 = v18;
    if ((v54 + 1) >> 16) {
      goto LABEL_157;
    }
    goto LABEL_158;
  }
LABEL_781:
  *a3 = v18;
  a3[1] = v17;
  return v9 - v5;
}

unint64_t sub_1DD2A5FF8(uint64_t a1, uint64_t a2, unsigned int *a3, unint64_t a4, uint64_t a5)
{
  if ((*(_DWORD *)(a1 + 272) - 5) >= 3) {
    int v5 = 4;
  }
  else {
    int v5 = *(_DWORD *)(a1 + 272);
  }
  return sub_1DD2A6220(a1, a2, a3, a4, a5, v5);
}

unint64_t sub_1DD2A6010(void *a1, char *a2, unint64_t a3, char *a4, void *a5)
{
  int v5 = (char *)a1 + a4 - a2;
  if ((unint64_t)v5 >= a3) {
    int v5 = (char *)a3;
  }
  int v6 = (char *)a1;
  int v7 = a2;
  if (v5 - 7 > (char *)a1)
  {
    unint64_t v8 = *a1 ^ *(void *)a2;
    if (v8)
    {
      unint64_t v9 = __clz(__rbit64(v8)) >> 3;
      goto LABEL_21;
    }
    uint64_t v10 = 0;
    unsigned int v11 = a1 + 1;
    while (1)
    {
      unsigned int v12 = &v11[v10];
      if (&v11[v10] >= (void *)(v5 - 7)) {
        break;
      }
      uint64_t v13 = *(void *)&a2[v10 * 8 + 8];
      ++v10;
      unint64_t v14 = *v12 ^ v13;
      if (v14)
      {
        unint64_t v9 = v10 * 8 + (__clz(__rbit64(v14)) >> 3);
        goto LABEL_21;
      }
    }
    int v6 = (char *)&a1[v10 + 1];
    int v7 = &a2[v10 * 8 + 8];
  }
  if (v6 < v5 - 3 && *(_DWORD *)v7 == *(_DWORD *)v6)
  {
    v6 += 4;
    v7 += 4;
  }
  if (v6 < v5 - 1 && *(unsigned __int16 *)v7 == *(unsigned __int16 *)v6)
  {
    v6 += 2;
    v7 += 2;
  }
  if (v6 < v5 && *v7 == *v6) {
    ++v6;
  }
  unint64_t v9 = v6 - (char *)a1;
LABEL_21:
  if (&a2[v9] == a4)
  {
    unsigned int v15 = (char *)a1 + v9;
    if (a3 - 7 <= (unint64_t)a1 + v9)
    {
      uint64_t v18 = (_DWORD *)((char *)a1 + v9);
    }
    else
    {
      unint64_t v16 = *(void *)v15 ^ *a5;
      if (v16)
      {
        unint64_t v17 = __clz(__rbit64(v16)) >> 3;
LABEL_36:
        v9 += v17;
        return v9;
      }
      uint64_t v20 = (uint64_t)a1 + v9 + 8;
      while (1)
      {
        uint64_t v21 = (void *)(v20 + v16);
        if (v20 + v16 >= a3 - 7) {
          break;
        }
        uint64_t v22 = *(void *)((char *)a5 + v16 + 8);
        v16 += 8;
        unint64_t v23 = *v21 ^ v22;
        if (v23)
        {
          unint64_t v17 = v16 + (__clz(__rbit64(v23)) >> 3);
          goto LABEL_36;
        }
      }
      uint64_t v18 = (_DWORD *)((char *)a1 + v9 + v16 + 8);
      a5 = (void *)((char *)a5 + v16 + 8);
    }
    if ((unint64_t)v18 < a3 - 3 && *(_DWORD *)a5 == *v18)
    {
      ++v18;
      a5 = (void *)((char *)a5 + 4);
    }
    if ((unint64_t)v18 < a3 - 1 && *(unsigned __int16 *)a5 == *(unsigned __int16 *)v18)
    {
      uint64_t v18 = (_DWORD *)((char *)v18 + 2);
      a5 = (void *)((char *)a5 + 2);
    }
    if ((unint64_t)v18 < a3 && *(unsigned __int8 *)a5 == *(unsigned __int8 *)v18) {
      uint64_t v18 = (_DWORD *)((char *)v18 + 1);
    }
    unint64_t v17 = (char *)v18 - v15;
    goto LABEL_36;
  }
  return v9;
}

unint64_t sub_1DD2A6220(uint64_t a1, uint64_t a2, unsigned int *a3, unint64_t a4, uint64_t a5, int a6)
{
  int v6 = (unsigned __int8 *)a4;
  unint64_t v7 = a4 + a5;
  uint64_t v8 = *(void *)(a1 + 8);
  int v9 = a4 + a5 - v8;
  unsigned int v10 = 1 << *(_DWORD *)(a1 + 256);
  unsigned int v12 = *(_DWORD *)(a1 + 24);
  unsigned int v11 = *(_DWORD *)(a1 + 28);
  BOOL v54 = v9 - v11 > v10;
  unsigned int v13 = v9 - v10;
  if (v54 && *(_DWORD *)(a1 + 40) == 0) {
    uint64_t v15 = v13;
  }
  else {
    uint64_t v15 = v11;
  }
  if (v12 <= v15) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = v12;
  }
  if (v15 >= v12)
  {
    return sub_1DD29F930(a1, a2, a3, a4, a5);
  }
  unint64_t v17 = v7 - 8;
  uint64_t v18 = *a3;
  uint64_t v19 = a3[1];
  if (v7 - 8 <= (unint64_t)v6) {
    goto LABEL_168;
  }
  uint64_t v127 = a3;
  uint64_t v149 = *(void *)(a1 + 112);
  int v20 = *(_DWORD *)(a1 + 264);
  uint64_t v145 = (unsigned __int8 *)(v8 + v16);
  uint64_t v21 = *(void *)(a1 + 16);
  uint64_t v128 = (unsigned __int8 *)(v21 + v15);
  uint64_t v147 = v21;
  unint64_t v144 = (char *)(v21 + v16);
  LODWORD(v21) = *(_DWORD *)(a1 + 260);
  char v138 = 64 - v21;
  uint64_t v22 = *(void *)(a1 + 128);
  char v134 = 32 - v21;
  char v148 = 64 - v20;
  int v146 = v16 - 1;
  int v142 = v16;
  uint64_t v143 = (char *)(v7 - 32);
  int v23 = a6 - 5;
  unint64_t v24 = (unint64_t)v6;
  uint64_t v136 = v8;
  unsigned int v137 = v15;
  uint64_t v140 = v22;
  unint64_t v141 = v7 - 8;
  int v139 = a6 - 5;
  do
  {
    uint64_t v25 = v19;
    switch(v23)
    {
      case 0:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1157627904;
        goto LABEL_19;
      case 1:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1080360960;
        goto LABEL_19;
      case 2:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1079680256;
        goto LABEL_19;
      case 3:
        uint64_t v26 = *(void *)v6;
        unsigned int v27 = -1213897629;
LABEL_19:
        unint64_t v28 = (v26 * (v27 | 0xCF1BBCDC00000000)) >> v138;
        break;
      default:
        unint64_t v28 = (-1640531535 * *(_DWORD *)v6) >> v134;
        uint64_t v26 = *(void *)v6;
        break;
    }
    uint64_t v29 = *(unsigned int *)(v22 + 4 * v28);
    if (v29 >= v16) {
      uint64_t v30 = v8;
    }
    else {
      uint64_t v30 = v147;
    }
    unint64_t v31 = (0xCF1BBCDCB7A56463 * v26) >> v148;
    uint64_t v32 = *(unsigned int *)(v149 + 4 * v31);
    uint64_t v33 = v8;
    if (v32 < v16) {
      uint64_t v8 = v147;
    }
    int v34 = v6 - v33;
    int v35 = v6 - v33 + 1;
    uint64_t v36 = (v35 - v18);
    if (v36 < v16) {
      uint64_t v33 = v147;
    }
    *(_DWORD *)(v149 + 4 * v31) = v34;
    *(_DWORD *)(v22 + 4 * v28) = v34;
    if (v18 <= v35 - v137 && (v146 - v36) >= 3)
    {
      unint64_t v37 = (unint64_t)(v6 + 1);
      if (*(_DWORD *)(v33 + v36) == *(_DWORD *)(v6 + 1))
      {
        int v135 = v34;
        uint64_t v38 = v18;
        if (v36 >= v16) {
          unint64_t v39 = (char *)v7;
        }
        else {
          unint64_t v39 = v144;
        }
        unint64_t v40 = sub_1DD2A6010(v6 + 5, (char *)(v33 + v36 + 4), v7, v39, v145);
        uint64_t v41 = v37 - v24;
        unint64_t v42 = *(_OWORD **)(a2 + 24);
        unint64_t v129 = v37;
        if (v37 <= (unint64_t)v143)
        {
          *unint64_t v42 = *(_OWORD *)v24;
          uint64_t v69 = *(void *)(a2 + 24);
          uint64_t v45 = a2;
          if ((unint64_t)v41 <= 0x10)
          {
            *(void *)(a2 + 24) = v69 + v41;
            uint64_t v46 = *(void *)(a2 + 8);
            uint64_t v8 = v136;
            unsigned int v43 = v137;
            unint64_t v17 = v141;
            LODWORD(v16) = v142;
            int v23 = v139;
            uint64_t v22 = v140;
            uint64_t v44 = v38;
            goto LABEL_92;
          }
          *(_OWORD *)(v69 + 16) = *(_OWORD *)(v24 + 16);
          uint64_t v8 = v136;
          unsigned int v43 = v137;
          unint64_t v17 = v141;
          LODWORD(v16) = v142;
          int v23 = v139;
          uint64_t v22 = v140;
          uint64_t v44 = v38;
          if (v41 >= 33)
          {
            unint64_t v70 = v69 + v41;
            unint64_t v71 = (_OWORD *)(v69 + 32);
            __int16 v72 = (long long *)(v24 + 48);
            do
            {
              *unint64_t v71 = *(v72 - 1);
              long long v73 = *v72;
              v72 += 2;
              v71[1] = v73;
              v71 += 2;
            }
            while ((unint64_t)v71 < v70);
          }
        }
        else
        {
          sub_1DD29DBFC(v42, (char *)v24, v37, v143);
          uint64_t v8 = v136;
          unsigned int v43 = v137;
          unint64_t v17 = v141;
          LODWORD(v16) = v142;
          int v23 = v139;
          uint64_t v22 = v140;
          uint64_t v44 = v38;
          uint64_t v45 = a2;
        }
        *(void *)(v45 + 24) += v41;
        uint64_t v46 = *(void *)(v45 + 8);
        if ((unint64_t)v41 >= 0x10000)
        {
          unint64_t v47 = (unint64_t)(v46 - *(void *)v45) >> 3;
          *(_DWORD *)(v45 + 72) = 1;
          *(_DWORD *)(v45 + 76) = v47;
        }
LABEL_92:
        unint64_t v55 = v129;
        unint64_t v53 = v40 + 4;
        *(_WORD *)(v46 + 4) = v41;
        *(_DWORD *)uint64_t v46 = 1;
        __int16 v83 = v40 + 1;
        uint64_t v66 = v44;
        if (!((v40 + 1) >> 16)) {
          goto LABEL_131;
        }
LABEL_130:
        unint64_t v105 = (unint64_t)(v46 - *(void *)v45) >> 3;
        *(_DWORD *)(v45 + 72) = 2;
        *(_DWORD *)(v45 + 76) = v105;
        goto LABEL_131;
      }
    }
    unint64_t v48 = v7;
    if (v32 > v137)
    {
      unint64_t v49 = v8 + v32;
      if (*(void *)(v8 + v32) == v26)
      {
        int v135 = v34;
        unsigned int v132 = v18;
        if (v32 >= v16) {
          uint64_t v50 = (char *)v48;
        }
        else {
          uint64_t v50 = v144;
        }
        if (v32 >= v16) {
          unint64_t v51 = v145;
        }
        else {
          unint64_t v51 = v128;
        }
        uint64_t v52 = v32;
        unint64_t v53 = sub_1DD2A6010((void *)v6 + 1, (char *)(v49 + 8), v48, v50, v145) + 8;
        BOOL v54 = v49 > (unint64_t)v51 && (unint64_t)v6 > v24;
        uint64_t v45 = a2;
        if (v54)
        {
          unint64_t v80 = v6 - 1;
          unint64_t v81 = (unsigned __int8 *)(v8 + v52 - 1);
          unint64_t v7 = v48;
          int v57 = v52;
          while (*v80 == *v81)
          {
            ++v53;
            unint64_t v82 = v80 - 1;
            if (v81 > v51)
            {
              --v81;
              BOOL v54 = (unint64_t)v80-- > v24;
              if (v54) {
                continue;
              }
            }
            int v6 = v82 + 1;
            goto LABEL_100;
          }
          int v6 = v80 + 1;
LABEL_100:
          unint64_t v55 = (unint64_t)v6;
          uint64_t v8 = v136;
          unsigned int v56 = v143;
        }
        else
        {
          unint64_t v55 = (unint64_t)v6;
          unint64_t v7 = v48;
          uint64_t v8 = v136;
          unsigned int v56 = v143;
          int v57 = v52;
        }
        uint64_t v87 = (uint64_t)&v6[-v24];
        uint64_t v88 = *(_OWORD **)(a2 + 24);
        if (v6 <= (unsigned __int8 *)v56)
        {
          _OWORD *v88 = *(_OWORD *)v24;
          uint64_t v91 = *(void *)(a2 + 24);
          unint64_t v17 = v141;
          LODWORD(v16) = v142;
          if ((unint64_t)v87 <= 0x10)
          {
            *(void *)(a2 + 24) = v91 + v87;
            uint64_t v46 = *(void *)(a2 + 8);
            int v23 = v139;
            uint64_t v22 = v140;
            uint64_t v25 = v132;
LABEL_111:
            uint64_t v66 = (v135 - v57);
            goto LABEL_129;
          }
          *(_OWORD *)(v91 + 16) = *(_OWORD *)(v24 + 16);
          int v23 = v139;
          uint64_t v22 = v140;
          uint64_t v25 = v132;
          if (v87 >= 33)
          {
            unint64_t v92 = v91 + v87;
            unint64_t v93 = (_OWORD *)(v91 + 32);
            unsigned int v94 = (long long *)(v24 + 48);
            do
            {
              *unint64_t v93 = *(v94 - 1);
              long long v95 = *v94;
              v94 += 2;
              v93[1] = v95;
              v93 += 2;
            }
            while ((unint64_t)v93 < v92);
          }
        }
        else
        {
          int v89 = v57;
          sub_1DD29DBFC(v88, (char *)v24, (unint64_t)v6, v56);
          int v57 = v89;
          unint64_t v17 = v141;
          LODWORD(v16) = v142;
          int v23 = v139;
          uint64_t v22 = v140;
          uint64_t v25 = v132;
        }
        *(void *)(a2 + 24) += v87;
        uint64_t v46 = *(void *)(a2 + 8);
        if ((unint64_t)v87 >= 0x10000)
        {
          unint64_t v90 = (unint64_t)(v46 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v90;
        }
        goto LABEL_111;
      }
    }
    if (v29 <= v137 || (unint64_t v58 = v30 + v29, *(_DWORD *)(v30 + v29) != *(_DWORD *)v6))
    {
      v6 += ((uint64_t)&v6[-v24] >> 8) + 1;
      uint64_t v19 = v25;
      unint64_t v7 = v48;
      uint64_t v8 = v136;
      continue;
    }
    uint64_t v59 = *(void *)(v6 + 1);
    unint64_t v60 = (0xCF1BBCDCB7A56463 * v59) >> v148;
    uint64_t v61 = *(unsigned int *)(v149 + 4 * v60);
    uint64_t v62 = v136;
    if (v61 < v16) {
      uint64_t v62 = v147;
    }
    *(_DWORD *)(v149 + 4 * v60) = v35;
    unint64_t v7 = v48;
    unsigned int v133 = v18;
    int v135 = v34;
    if (v61 > v137 && *(void *)(v62 + v61) == v59)
    {
      uint64_t v130 = v62;
      if (v61 >= v16) {
        BOOL v63 = (char *)v48;
      }
      else {
        BOOL v63 = v144;
      }
      if (v61 >= v16) {
        unint64_t v64 = v145;
      }
      else {
        unint64_t v64 = v128;
      }
      unint64_t v65 = v62 + v61;
      unint64_t v53 = sub_1DD2A6010(v6 + 9, (char *)(v62 + v61 + 8), v48, v63, v145) + 8;
      uint64_t v66 = (v35 - v61);
      if (v65 <= (unint64_t)v64 || (unint64_t)(v6 + 1) <= v24)
      {
        uint64_t v8 = v136;
        uint64_t v68 = v143;
        unint64_t v55 = (unint64_t)(v6 + 1);
LABEL_84:
        uint64_t v45 = a2;
        goto LABEL_119;
      }
      uint64_t v45 = a2;
      unint64_t v96 = (unsigned __int8 *)(v130 + v61 - 1);
      uint64_t v8 = v136;
      uint64_t v68 = v143;
      while (*v6 == *v96)
      {
        ++v53;
        unint64_t v97 = v6 - 1;
        if (v96 > v64)
        {
          --v96;
          BOOL v54 = (unint64_t)v6-- > v24;
          if (v54) {
            continue;
          }
        }
        unint64_t v55 = (unint64_t)(v97 + 1);
        goto LABEL_119;
      }
      unint64_t v55 = (unint64_t)(v6 + 1);
    }
    else
    {
      uint64_t v74 = v30;
      if (v29 >= v16) {
        unint64_t v75 = (char *)v48;
      }
      else {
        unint64_t v75 = v144;
      }
      if (v29 >= v16) {
        unint64_t v76 = v145;
      }
      else {
        unint64_t v76 = v128;
      }
      unint64_t v77 = sub_1DD2A6010(v6 + 4, (char *)(v58 + 4), v48, v75, v145);
      int v78 = v34;
      unint64_t v53 = v77 + 4;
      uint64_t v66 = (v78 - v29);
      if (v58 <= (unint64_t)v76 || (unint64_t)v6 <= v24)
      {
        unint64_t v55 = (unint64_t)v6;
        uint64_t v8 = v136;
        uint64_t v68 = v143;
        goto LABEL_84;
      }
      uint64_t v84 = v6 - 1;
      unint64_t v85 = (unsigned __int8 *)(v74 + v29 - 1);
      uint64_t v8 = v136;
      uint64_t v68 = v143;
      uint64_t v45 = a2;
      while (*v84 == *v85)
      {
        ++v53;
        uint64_t v86 = v84 - 1;
        if (v85 > v76)
        {
          --v85;
          BOOL v54 = (unint64_t)v84-- > v24;
          if (v54) {
            continue;
          }
        }
        unint64_t v55 = (unint64_t)(v86 + 1);
        goto LABEL_119;
      }
      unint64_t v55 = (unint64_t)(v84 + 1);
    }
LABEL_119:
    uint64_t v87 = v55 - v24;
    uint64_t v98 = *(_OWORD **)(v45 + 24);
    if (v55 <= (unint64_t)v68)
    {
      _OWORD *v98 = *(_OWORD *)v24;
      uint64_t v100 = *(void *)(v45 + 24);
      unint64_t v17 = v141;
      LODWORD(v16) = v142;
      if ((unint64_t)v87 <= 0x10)
      {
        *(void *)(v45 + 24) = v100 + v87;
        uint64_t v46 = *(void *)(v45 + 8);
        int v23 = v139;
        uint64_t v22 = v140;
        uint64_t v25 = v133;
        goto LABEL_129;
      }
      *(_OWORD *)(v100 + 16) = *(_OWORD *)(v24 + 16);
      if (v87 >= 33)
      {
        unint64_t v101 = v100 + v87;
        __int16 v102 = (_OWORD *)(v100 + 32);
        unint64_t v103 = (long long *)(v24 + 48);
        do
        {
          *__int16 v102 = *(v103 - 1);
          long long v104 = *v103;
          v103 += 2;
          v102[1] = v104;
          v102 += 2;
        }
        while ((unint64_t)v102 < v101);
      }
    }
    else
    {
      sub_1DD29DBFC(v98, (char *)v24, v55, v68);
      unint64_t v17 = v141;
      LODWORD(v16) = v142;
    }
    *(void *)(v45 + 24) += v87;
    uint64_t v46 = *(void *)(v45 + 8);
    int v23 = v139;
    uint64_t v22 = v140;
    uint64_t v25 = v133;
    if ((unint64_t)v87 >= 0x10000)
    {
      unint64_t v99 = (unint64_t)(v46 - *(void *)v45) >> 3;
      *(_DWORD *)(v45 + 72) = 1;
      *(_DWORD *)(v45 + 76) = v99;
    }
LABEL_129:
    *(_WORD *)(v46 + 4) = v87;
    *(_DWORD *)uint64_t v46 = v66 + 3;
    __int16 v83 = v53 - 3;
    unsigned int v43 = v137;
    if ((v53 - 3) >> 16) {
      goto LABEL_130;
    }
LABEL_131:
    *(_WORD *)(v46 + 6) = v83;
    *(void *)(v45 + 8) = v46 + 8;
    unint64_t v24 = v55 + v53;
    if (v55 + v53 <= v17)
    {
      uint64_t v106 = (v135 + 2);
      uint64_t v107 = *(void *)(v8 + v106);
      *(_DWORD *)(v149 + 4 * ((0xCF1BBCDCB7A56463 * v107) >> v148)) = v106;
      *(_DWORD *)(v149 + 4 * ((0xCF1BBCDCB7A56463 * *(void *)(v24 - 2)) >> v148)) = v24 - 2 - v8;
      switch(v23)
      {
        case 0:
          unsigned int v108 = -1157627904;
          goto LABEL_138;
        case 1:
          unsigned int v108 = -1080360960;
          goto LABEL_138;
        case 2:
          unsigned int v108 = -1079680256;
LABEL_138:
          unint64_t v111 = v108 | 0xCF1BBCDC00000000;
          char v112 = v138;
          *(_DWORD *)(v22 + 4 * ((v107 * v111) >> v138)) = v106;
          int v109 = v24 - 1;
          uint64_t v113 = *(void *)(v24 - 1);
          goto LABEL_140;
        case 3:
          char v112 = v138;
          *(_DWORD *)(v22 + 4 * ((0xCF1BBCDCB7A56463 * v107) >> v138)) = v106;
          int v109 = v24 - 1;
          uint64_t v113 = *(void *)(v24 - 1);
          unint64_t v111 = 0xCF1BBCDCB7A56463;
LABEL_140:
          unint64_t v110 = (v113 * v111) >> v112;
          break;
        default:
          *(_DWORD *)(v22 + 4 * ((-1640531535 * *(_DWORD *)(v8 + v106)) >> v134)) = v106;
          int v109 = v24 - 1;
          unint64_t v110 = (-1640531535 * *(_DWORD *)(v24 - 1)) >> v134;
          break;
      }
      *(_DWORD *)(v22 + 4 * v110) = v109 - v8;
      while (1)
      {
        uint64_t v19 = v66;
        uint64_t v66 = v25;
        int v114 = v24 - v8;
        uint64_t v115 = (v24 - v8 - v66);
        uint64_t v116 = v147;
        if (v115 >= v16) {
          uint64_t v116 = v8;
        }
        if (v66 > v114 - v43) {
          break;
        }
        if ((v146 - v115) < 3) {
          break;
        }
        uint64_t v117 = v116 + v115;
        if (*(_DWORD *)v117 != *(_DWORD *)v24) {
          break;
        }
        if (v115 >= v16) {
          long long v118 = (char *)v7;
        }
        else {
          long long v118 = v144;
        }
        unint64_t v119 = sub_1DD2A6010((void *)(v24 + 4), (char *)(v117 + 4), v7, v118, v145);
        unint64_t v120 = *(_OWORD **)(v45 + 24);
        if (v24 <= (unint64_t)v143) {
          *unint64_t v120 = *(_OWORD *)v24;
        }
        else {
          sub_1DD29DBFC(v120, (char *)v24, v24, v143);
        }
        unint64_t v17 = v141;
        LODWORD(v16) = v142;
        int v23 = v139;
        uint64_t v22 = v140;
        uint64_t v121 = *(void *)(v45 + 8);
        *(_WORD *)(v121 + 4) = 0;
        *(_DWORD *)uint64_t v121 = 1;
        if (v119 + 1 >= 0x10000)
        {
          unint64_t v122 = (unint64_t)(v121 - *(void *)v45) >> 3;
          *(_DWORD *)(v45 + 72) = 2;
          *(_DWORD *)(v45 + 76) = v122;
        }
        *(_WORD *)(v121 + 6) = v119 + 1;
        *(void *)(v45 + 8) = v121 + 8;
        switch(v139)
        {
          case 0:
            uint64_t v123 = *(void *)v24;
            unsigned int v124 = -1157627904;
            goto LABEL_161;
          case 1:
            uint64_t v123 = *(void *)v24;
            unsigned int v124 = -1080360960;
            goto LABEL_161;
          case 2:
            uint64_t v123 = *(void *)v24;
            unsigned int v124 = -1079680256;
            goto LABEL_161;
          case 3:
            uint64_t v123 = *(void *)v24;
            unsigned int v124 = -1213897629;
LABEL_161:
            unint64_t v125 = (v123 * (v124 | 0xCF1BBCDC00000000)) >> v138;
            break;
          default:
            unint64_t v125 = (-1640531535 * *(_DWORD *)v24) >> v134;
            uint64_t v123 = *(void *)v24;
            break;
        }
        *(_DWORD *)(v140 + 4 * v125) = v114;
        *(_DWORD *)(v149 + 4 * ((0xCF1BBCDCB7A56463 * v123) >> v148)) = v114;
        v24 += v119 + 4;
        uint64_t v25 = v19;
        uint64_t v18 = v66;
        int v6 = (unsigned __int8 *)v24;
        if (v24 > v141) {
          goto LABEL_166;
        }
      }
      uint64_t v18 = v19;
      uint64_t v19 = v66;
    }
    else
    {
      uint64_t v18 = v66;
      uint64_t v19 = v25;
    }
    int v6 = (unsigned __int8 *)v24;
LABEL_166:
    ;
  }
  while ((unint64_t)v6 < v17);
  int v6 = (unsigned __int8 *)v24;
  a3 = v127;
LABEL_168:
  *a3 = v18;
  a3[1] = v19;
  return v7 - (void)v6;
}

uint64_t sub_1DD2A6DAC(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(result + 112);
  int v5 = *(_DWORD *)(result + 272);
  uint64_t v6 = *(void *)(result + 8);
  uint64_t v7 = *(unsigned int *)(result + 44);
  uint64_t v8 = (void *)(v6 + v7);
  unint64_t v9 = a2 - 6;
  unint64_t v10 = v6 + v7 + 3;
  if (a4 == 1)
  {
    if (v10 < v9)
    {
      int v11 = *(_DWORD *)(result + 264);
      uint64_t result = (56 - v11);
      char v12 = 24 - v11;
      int v13 = (v7 << 8) + 256;
      int v14 = v5 - 5;
      do
      {
        switch(v14)
        {
          case 0:
            unint64_t v15 = 0xCF1BBCDCBB000000 * *v8;
            goto LABEL_10;
          case 1:
            unint64_t v15 = 0xCF1BBCDCBF9B0000 * *v8;
            goto LABEL_10;
          case 2:
            unint64_t v15 = 0xCF1BBCDCBFA56300 * *v8;
            goto LABEL_10;
          case 3:
            unint64_t v15 = 0xCF1BBCDCB7A56463 * *v8;
LABEL_10:
            unint64_t v16 = v15 >> (56 - v11);
            break;
          default:
            unint64_t v16 = (-1640531535 * *(_DWORD *)v8) >> v12;
            break;
        }
        *(_DWORD *)(v4 + ((v16 >> 6) & 0x3FFFFFFFFFFFFFCLL)) = v16 | ((v8 - v6) << 8);
        if (a3)
        {
          int v17 = v13;
          for (uint64_t i = 1; i != 3; ++i)
          {
            switch(v14)
            {
              case 0:
                unint64_t v19 = 0xCF1BBCDCBB000000 * *(void *)((char *)v8 + i);
                goto LABEL_18;
              case 1:
                unint64_t v19 = 0xCF1BBCDCBF9B0000 * *(void *)((char *)v8 + i);
                goto LABEL_18;
              case 2:
                unint64_t v19 = 0xCF1BBCDCBFA56300 * *(void *)((char *)v8 + i);
                goto LABEL_18;
              case 3:
                unint64_t v19 = 0xCF1BBCDCB7A56463 * *(void *)((char *)v8 + i);
LABEL_18:
                unint64_t v20 = v19 >> (56 - v11);
                break;
              default:
                unint64_t v20 = (-1640531535 * *(_DWORD *)((char *)v8 + i)) >> v12;
                break;
            }
            if (!*(_DWORD *)(v4 + 4 * (v20 >> 8))) {
              *(_DWORD *)(v4 + 4 * (v20 >> 8)) = v17 + v20;
            }
            v17 += 256;
          }
        }
        v10 += 3;
        v13 += 768;
        uint64_t v8 = (void *)((char *)v8 + 3);
      }
      while (v10 < v9);
    }
  }
  else if (v10 < v9)
  {
    int v21 = *(_DWORD *)(result + 264);
    uint64_t result = (64 - v21);
    char v22 = 32 - v21;
    int v23 = v7 + 1;
    int v24 = v5 - 5;
    do
    {
      switch(v24)
      {
        case 0:
          unint64_t v25 = 0xCF1BBCDCBB000000 * *v8;
          goto LABEL_34;
        case 1:
          unint64_t v25 = 0xCF1BBCDCBF9B0000 * *v8;
          goto LABEL_34;
        case 2:
          unint64_t v25 = 0xCF1BBCDCBFA56300 * *v8;
          goto LABEL_34;
        case 3:
          unint64_t v25 = 0xCF1BBCDCB7A56463 * *v8;
LABEL_34:
          unint64_t v26 = v25 >> (64 - v21);
          break;
        default:
          unint64_t v26 = (-1640531535 * *(_DWORD *)v8) >> v22;
          break;
      }
      *(_DWORD *)(v4 + 4 * v26) = v8 - v6;
      if (a3)
      {
        for (uint64_t j = 0; j != 2; ++j)
        {
          unint64_t v28 = (char *)v8 + j;
          switch(v24)
          {
            case 0:
              unint64_t v29 = 0xCF1BBCDCBB000000 * *(void *)(v28 + 1);
              goto LABEL_42;
            case 1:
              unint64_t v29 = 0xCF1BBCDCBF9B0000 * *(void *)(v28 + 1);
              goto LABEL_42;
            case 2:
              unint64_t v29 = 0xCF1BBCDCBFA56300 * *(void *)(v28 + 1);
              goto LABEL_42;
            case 3:
              unint64_t v29 = 0xCF1BBCDCB7A56463 * *(void *)(v28 + 1);
LABEL_42:
              unint64_t v30 = v29 >> (64 - v21);
              break;
            default:
              unint64_t v30 = (-1640531535 * *(_DWORD *)(v28 + 1)) >> v22;
              break;
          }
          if (!*(_DWORD *)(v4 + 4 * v30)) {
            *(_DWORD *)(v4 + 4 * v30) = v23 + j;
          }
        }
      }
      v10 += 3;
      v23 += 3;
      uint64_t v8 = (void *)((char *)v8 + 3);
    }
    while (v10 < v9);
  }
  return result;
}

unint64_t sub_1DD2A7144(uint64_t a1, uint64_t a2, unsigned int *a3, unint64_t a4, uint64_t a5)
{
  int v5 = *(_DWORD *)(a1 + 272);
  unsigned int v6 = *(_DWORD *)(a1 + 276);
  if (v6 >= 2)
  {
    unint64_t v7 = v6 + 1;
    if (v5 != 5)
    {
      if (v5 != 6)
      {
        if (v5 == 7)
        {
          uint64_t v8 = *(void *)(a1 + 8);
          unint64_t v9 = a4 + a5;
          int v10 = a4 + a5 - v8;
          unsigned int v11 = 1 << *(_DWORD *)(a1 + 256);
          unsigned int v12 = *(_DWORD *)(a1 + 24);
          BOOL v13 = v10 - v12 > v11;
          unsigned int v14 = v10 - v11;
          BOOL v15 = *(_DWORD *)(a1 + 40) == 0;
          if (v15 && v13) {
            uint64_t v16 = v14;
          }
          else {
            uint64_t v16 = v12;
          }
          unint64_t v17 = v9 - 8;
          unsigned int v19 = *a3;
          unsigned int v18 = a3[1];
          if (v8 + v16 == a4) {
            unint64_t v20 = a4 + 1;
          }
          else {
            unint64_t v20 = a4;
          }
          int v21 = v20 - v8;
          BOOL v22 = v20 - v8 - v12 > v11;
          int v23 = v20 - v8 - v11;
          if (!v15 || !v22) {
            int v23 = *(_DWORD *)(a1 + 24);
          }
          unsigned int v24 = v21 - v23;
          if (v18 <= v21 - v23) {
            uint64_t v25 = v18;
          }
          else {
            uint64_t v25 = 0;
          }
          if (v19 <= v24) {
            uint64_t v26 = v19;
          }
          else {
            uint64_t v26 = 0;
          }
          unsigned int v27 = (_DWORD *)(v20 + v7);
          _X9 = (int *)(v20 + v7 + 1);
          unsigned int v704 = *a3;
          unsigned int v706 = a3[1];
          unsigned int v702 = v24;
          if ((unint64_t)_X9 < v17)
          {
            unsigned int v708 = v16;
            unint64_t v716 = v9 - 8;
            uint64_t v29 = *(void *)(a1 + 112);
            unint64_t v698 = v7;
            LODWORD(v30) = 64 - *(_DWORD *)(a1 + 264);
            unint64_t v31 = v9 - 7;
            unint64_t v740 = v9 - 1;
            unint64_t v748 = v9 - 3;
            uint64_t v32 = (char *)(v9 - 32);
            unint64_t v682 = v8 + v16;
            v724 = (char *)(v9 - 32);
            unint64_t v732 = v9 - 7;
            unint64_t v757 = v9;
            char v686 = v30;
LABEL_21:
            int v34 = (int *)(v20 + 1);
            uint64_t v33 = *(void *)(v20 + 1);
            unint64_t v35 = v20 + 128;
            unint64_t v36 = (0xCF1BBCDCBFA56300 * *(void *)v20) >> v30;
            LODWORD(v37) = *(_DWORD *)(v29 + 4 * v36);
            while (1)
            {
              unint64_t v38 = (0xCF1BBCDCBFA56300 * v33) >> v30;
              int v39 = *(_DWORD *)((char *)v27 - v26);
              unsigned int v40 = v20 - v8;
              *(_DWORD *)(v29 + 4 * v36) = v20 - v8;
              if (v26 && *v27 == v39)
              {
                BOOL v52 = *((unsigned __int8 *)v27 - 1) == *((unsigned __int8 *)v27 - v26 - 1);
                if (*((unsigned __int8 *)v27 - 1) == *((unsigned __int8 *)v27 - v26 - 1)) {
                  uint64_t v53 = 5;
                }
                else {
                  uint64_t v53 = 4;
                }
                int v54 = v34 - v8;
                int v34 = (_DWORD *)((char *)v27 - v52);
                unint64_t v55 = (unsigned __int8 *)((char *)v27 - v26 - v52);
                *(_DWORD *)(v29 + 4 * v38) = v54;
                int v56 = 1;
                uint64_t v57 = v26;
                uint64_t v26 = v25;
                goto LABEL_53;
              }
              if (v37 >= v708)
              {
                int v42 = *(_DWORD *)(v8 + v37);
                int v41 = *(_DWORD *)v20;
              }
              else
              {
                int v41 = *(_DWORD *)v20;
                int v42 = *(_DWORD *)v20 ^ 1;
              }
              if (v41 == v42)
              {
                LODWORD(v27) = v34;
                unint64_t v36 = v38;
                int v34 = (int *)v20;
                goto LABEL_43;
              }
              uint64_t v37 = *(unsigned int *)(v29 + 4 * v38);
              uint64_t v43 = *(void *)v27;
              unsigned int v40 = v34 - v8;
              *(_DWORD *)(v29 + 4 * v38) = v34 - v8;
              if (v37 >= v708)
              {
                int v45 = *(_DWORD *)(v8 + v37);
                int v44 = *v34;
              }
              else
              {
                int v44 = *v34;
                int v45 = *v34 ^ 1;
              }
              unint64_t v36 = (0xCF1BBCDCBFA56300 * v43) >> v30;
              if (v44 == v45) {
                break;
              }
              LODWORD(v37) = *(_DWORD *)(v29 + 4 * v36);
              uint64_t v33 = *(void *)_X9;
              if ((unint64_t)v27 + v7 >= v35)
              {
                unint64_t v46 = v7 + 1;
                __asm
                {
                  PRFM            #0, [X9,#0x40]
                  PRFM            #0, [X9,#0x80]
                }
                v35 += 128;
              }
              else
              {
                unint64_t v46 = v7;
              }
              int v34 = _X9;
              unint64_t v20 = (unint64_t)v27;
              unsigned int v27 = (_DWORD *)((char *)v27 + v7);
              _X9 = (int *)((char *)_X9 + v7);
              unint64_t v7 = v46;
              if ((unint64_t)_X9 >= v17) {
                goto LABEL_584;
              }
            }
            if (v7 < 5) {
LABEL_43:
            }
              *(_DWORD *)(v29 + 4 * v36) = v27 - v8;
            unint64_t v55 = (unsigned __int8 *)(v8 + v37);
            uint64_t v57 = (v34 - v55);
            int v56 = v57 + 3;
            if ((unint64_t)v34 <= a4 || v37 <= v708)
            {
              uint64_t v53 = 4;
            }
            else
            {
              unint64_t v58 = (unsigned __int8 *)(v8 - 1 + v37);
              uint64_t v59 = (unsigned __int8 *)v34 - 1;
              uint64_t v53 = 4;
              while (*v59 == *v58)
              {
                ++v53;
                unint64_t v60 = v58 - 1;
                uint64_t v61 = v59 - 1;
                if ((unint64_t)v58 > v682)
                {
                  --v58;
                  BOOL v62 = (unint64_t)v59-- > a4;
                  if (v62) {
                    continue;
                  }
                }
                unint64_t v55 = v60 + 1;
                int v34 = (int *)(v61 + 1);
                goto LABEL_53;
              }
              unint64_t v55 = v58 + 1;
              int v34 = (int *)(v59 + 1);
            }
LABEL_53:
            BOOL v63 = (char *)v34 + v53;
            unint64_t v64 = &v55[v53];
            if (v31 <= (unint64_t)v34 + v53)
            {
              unint64_t v67 = (int *)((char *)v34 + v53);
            }
            else
            {
              unint64_t v65 = *(void *)v63 ^ *(void *)v64;
              if (v65)
              {
                unint64_t v66 = __clz(__rbit64(v65)) >> 3;
                goto LABEL_67;
              }
              uint64_t v93 = 0;
              uint64_t v94 = (uint64_t)v34 + v53 + 8;
              while (1)
              {
                long long v95 = (void *)(v94 + v93);
                if (v94 + v93 >= v31) {
                  break;
                }
                uint64_t v96 = *(void *)&v55[v53 + 8 + v93];
                v93 += 8;
                unint64_t v97 = *v95 ^ v96;
                if (v97)
                {
                  unint64_t v66 = v93 + (__clz(__rbit64(v97)) >> 3);
                  goto LABEL_67;
                }
              }
              unint64_t v67 = (int *)((char *)v34 + v53 + v93 + 8);
              unint64_t v64 = &v55[v53 + 8 + v93];
            }
            if ((unint64_t)v67 < v748 && *(_DWORD *)v64 == *v67)
            {
              ++v67;
              v64 += 4;
            }
            if ((unint64_t)v67 < v740 && *(unsigned __int16 *)v64 == *(unsigned __int16 *)v67)
            {
              unint64_t v67 = (_DWORD *)((char *)v67 + 2);
              v64 += 2;
            }
            if ((unint64_t)v67 < v757 && *v64 == *(unsigned __int8 *)v67) {
              unint64_t v67 = (_DWORD *)((char *)v67 + 1);
            }
            unint64_t v66 = (char *)v67 - v63;
LABEL_67:
            uint64_t v68 = (uint64_t)v34 - a4;
            uint64_t v69 = *(_OWORD **)(a2 + 24);
            if (v34 <= (int *)v32)
            {
              *uint64_t v69 = *(_OWORD *)a4;
              uint64_t v72 = *(void *)(a2 + 24);
              if ((unint64_t)v68 <= 0x10)
              {
                *(void *)(a2 + 24) = v72 + v68;
                uint64_t v70 = *(void *)(a2 + 8);
LABEL_78:
                unint64_t v77 = v66 + v53;
                *(_WORD *)(v70 + 4) = v68;
                *(_DWORD *)uint64_t v70 = v56;
                unint64_t v78 = v66 + v53 - 3;
                if (v78 >= 0x10000)
                {
                  unint64_t v79 = (unint64_t)(v70 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v79;
                }
                *(_WORD *)(v70 + 6) = v78;
                *(void *)(a2 + 8) = v70 + 8;
                unint64_t v20 = (unint64_t)v34 + v77;
                if ((unint64_t)v34 + v77 > v17)
                {
                  uint64_t v25 = v26;
                  unint64_t v9 = v757;
                  goto LABEL_117;
                }
                *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v8 + 2 + v40)) >> v30)) = v40 + 2;
                *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v20 - 2)) >> v30)) = v20 - 2 - v8;
                unint64_t v9 = v757;
                if (!v26)
                {
                  uint64_t v25 = 0;
                  goto LABEL_117;
                }
                uint64_t v80 = v57;
                while (1)
                {
                  uint64_t v25 = v80;
                  uint64_t v80 = v26;
                  if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v26))
                  {
                    uint64_t v57 = v25;
                    uint64_t v25 = v26;
LABEL_117:
                    unint64_t v7 = v698;
                    unsigned int v27 = (_DWORD *)(v20 + v698);
                    _X9 = (int *)(v20 + v698 + 1);
                    uint64_t v26 = v57;
                    a4 = v20;
                    if ((unint64_t)_X9 >= v17)
                    {
LABEL_585:
                      unsigned int v426 = v704;
                      if (v704 <= v702) {
                        unsigned int v426 = 0;
                      }
                      unsigned int v427 = v706;
                      if (v706 <= v702) {
                        unsigned int v427 = 0;
                      }
                      if (v57) {
                        unsigned int v428 = v57;
                      }
                      else {
                        unsigned int v428 = v426;
                      }
                      if (v57) {
                        _ZF = v426 == 0;
                      }
                      else {
                        _ZF = 1;
                      }
                      if (_ZF) {
                        unsigned int v426 = v427;
                      }
                      if (v25) {
                        unsigned int v426 = v25;
                      }
                      *a3 = v428;
                      a3[1] = v426;
                      return v9 - v20;
                    }
                    goto LABEL_21;
                  }
                  unint64_t v81 = (char *)(v20 + 4);
                  unint64_t v82 = (void *)(v20 + 4 - v26);
                  if (v31 <= v20 + 4) {
                    break;
                  }
                  unint64_t v83 = *(void *)v81 ^ *v82;
                  if (!v83)
                  {
                    unint64_t v89 = v20 + 12;
                    while (1)
                    {
                      unint64_t v90 = (void *)(v89 + v83);
                      if (v89 + v83 >= v31) {
                        break;
                      }
                      uint64_t v91 = *(void *)(v20 + 12 - v26 + v83);
                      v83 += 8;
                      unint64_t v92 = *v90 ^ v91;
                      if (v92)
                      {
                        unint64_t v84 = v83 + (__clz(__rbit64(v92)) >> 3);
                        goto LABEL_99;
                      }
                    }
                    unint64_t v85 = (_DWORD *)(v20 + v83 + 12);
                    unint64_t v82 = (void *)((char *)v85 - v26);
                    goto LABEL_89;
                  }
                  unint64_t v84 = __clz(__rbit64(v83)) >> 3;
LABEL_99:
                  *(_DWORD *)(v29 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v20) >> v30)) = v20 - v8;
                  uint64_t v86 = *(_OWORD **)(a2 + 24);
                  if (v20 <= (unint64_t)v32)
                  {
                    *uint64_t v86 = *(_OWORD *)v20;
                  }
                  else
                  {
                    sub_1DD29DBFC(v86, (char *)v20, v20, v32);
                    uint64_t v32 = v724;
                    unint64_t v31 = v732;
                    unint64_t v17 = v716;
                  }
                  uint64_t v87 = *(void *)(a2 + 8);
                  *(_WORD *)(v87 + 4) = 0;
                  *(_DWORD *)uint64_t v87 = 1;
                  if (v84 + 1 >= 0x10000)
                  {
                    unint64_t v88 = (unint64_t)(v87 - *(void *)a2) >> 3;
                    *(_DWORD *)(a2 + 72) = 2;
                    *(_DWORD *)(a2 + 76) = v88;
                  }
                  v20 += v84 + 4;
                  *(_WORD *)(v87 + 6) = v84 + 1;
                  *(void *)(a2 + 8) = v87 + 8;
                  uint64_t v26 = v25;
                  uint64_t v57 = v80;
                  if (v20 > v17) {
                    goto LABEL_117;
                  }
                }
                unint64_t v85 = (_DWORD *)(v20 + 4);
LABEL_89:
                if ((unint64_t)v85 < v748 && *(_DWORD *)v82 == *v85)
                {
                  ++v85;
                  unint64_t v82 = (void *)((char *)v82 + 4);
                }
                if ((unint64_t)v85 < v740 && *(unsigned __int16 *)v82 == *(unsigned __int16 *)v85)
                {
                  unint64_t v85 = (_DWORD *)((char *)v85 + 2);
                  unint64_t v82 = (void *)((char *)v82 + 2);
                }
                if ((unint64_t)v85 < v757 && *(unsigned __int8 *)v82 == *(unsigned __int8 *)v85) {
                  unint64_t v85 = (_DWORD *)((char *)v85 + 1);
                }
                unint64_t v84 = (char *)v85 - v81;
                goto LABEL_99;
              }
              *(_OWORD *)(v72 + 16) = *(_OWORD *)(a4 + 16);
              if (v68 >= 33)
              {
                unint64_t v73 = v72 + v68;
                uint64_t v74 = (_OWORD *)(v72 + 32);
                unint64_t v75 = (long long *)(a4 + 48);
                do
                {
                  *uint64_t v74 = *(v75 - 1);
                  long long v76 = *v75;
                  v75 += 2;
                  v74[1] = v76;
                  v74 += 2;
                }
                while ((unint64_t)v74 < v73);
              }
            }
            else
            {
              unint64_t v30 = v66;
              sub_1DD29DBFC(v69, (char *)a4, (unint64_t)v34, v32);
              unint64_t v66 = v30;
              LOBYTE(v30) = v686;
              unint64_t v17 = v716;
            }
            *(void *)(a2 + 24) += v68;
            uint64_t v70 = *(void *)(a2 + 8);
            if ((unint64_t)v68 >= 0x10000)
            {
              unint64_t v71 = (unint64_t)(v70 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 1;
              *(_DWORD *)(a2 + 76) = v71;
            }
            uint64_t v32 = v724;
            unint64_t v31 = v732;
            goto LABEL_78;
          }
LABEL_583:
          unint64_t v20 = a4;
          LODWORD(v57) = v26;
          goto LABEL_585;
        }
        uint64_t v345 = *(void *)(a1 + 8);
        unint64_t v9 = a4 + a5;
        int v346 = a4 + a5 - v345;
        unsigned int v347 = 1 << *(_DWORD *)(a1 + 256);
        unsigned int v348 = *(_DWORD *)(a1 + 24);
        BOOL v349 = v346 - v348 > v347;
        unsigned int v350 = v346 - v347;
        BOOL v351 = *(_DWORD *)(a1 + 40) == 0;
        if (v351 && v349) {
          uint64_t v352 = v350;
        }
        else {
          uint64_t v352 = v348;
        }
        unint64_t v353 = v9 - 8;
        unsigned int v355 = *a3;
        unsigned int v354 = a3[1];
        if (v345 + v352 == a4) {
          unint64_t v20 = a4 + 1;
        }
        else {
          unint64_t v20 = a4;
        }
        int v356 = v20 - v345;
        BOOL v357 = v20 - v345 - v348 > v347;
        int v358 = v20 - v345 - v347;
        if (!v351 || !v357) {
          int v358 = *(_DWORD *)(a1 + 24);
        }
        unsigned int v359 = v356 - v358;
        if (v354 <= v356 - v358) {
          uint64_t v25 = v354;
        }
        else {
          uint64_t v25 = 0;
        }
        if (v355 <= v359) {
          uint64_t v26 = v355;
        }
        else {
          uint64_t v26 = 0;
        }
        uint64_t v360 = (int *)(v20 + v7);
        _X9 = (int *)(v20 + v7 + 1);
        unsigned int v704 = *a3;
        unsigned int v706 = a3[1];
        unsigned int v702 = v359;
        if ((unint64_t)_X9 >= v353) {
          goto LABEL_583;
        }
        unsigned int v712 = v352;
        unint64_t v720 = v9 - 8;
        uint64_t v362 = *(void *)(a1 + 112);
        unint64_t v701 = v7;
        int v363 = 32 - *(_DWORD *)(a1 + 264);
        unint64_t v364 = v9 - 7;
        unint64_t v744 = v9 - 1;
        unint64_t v752 = v9 - 3;
        unint64_t v365 = (char *)(v9 - 32);
        unint64_t v685 = v345 + v352;
        v728 = (char *)(v9 - 32);
        unint64_t v736 = v9 - 7;
        unint64_t v757 = v9;
        char v690 = v363;
        while (1)
        {
          uint64_t v367 = (int *)(v20 + 1);
          int v366 = *(_DWORD *)(v20 + 1);
          unint64_t v368 = v20 + 128;
          uint64_t v369 = (-1640531535 * *(_DWORD *)v20) >> v363;
          LODWORD(v370) = *(_DWORD *)(v362 + 4 * v369);
          while (1)
          {
            uint64_t v371 = (-1640531535 * v366) >> v363;
            int v372 = *(int *)((char *)v360 - v26);
            unsigned int v373 = v20 - v345;
            *(_DWORD *)(v362 + 4 * v369) = v20 - v345;
            int v374 = *v360;
            if (v26 && v374 == v372)
            {
              BOOL v382 = *((unsigned __int8 *)v360 - 1) == *((unsigned __int8 *)v360 - v26 - 1);
              if (*((unsigned __int8 *)v360 - 1) == *((unsigned __int8 *)v360 - v26 - 1)) {
                uint64_t v383 = 5;
              }
              else {
                uint64_t v383 = 4;
              }
              int v384 = v367 - v345;
              uint64_t v367 = (int *)((char *)v360 - v382);
              unsigned int v385 = (unsigned __int8 *)((char *)v360 - v26 - v382);
              *(_DWORD *)(v362 + 4 * v371) = v384;
              int v386 = 1;
              uint64_t v57 = v26;
              uint64_t v26 = v25;
              goto LABEL_516;
            }
            if (v370 >= v712)
            {
              int v376 = *(_DWORD *)(v345 + v370);
              int v375 = *(_DWORD *)v20;
            }
            else
            {
              int v375 = *(_DWORD *)v20;
              int v376 = *(_DWORD *)v20 ^ 1;
            }
            if (v375 == v376)
            {
              LODWORD(v360) = v367;
              uint64_t v369 = v371;
              uint64_t v367 = (int *)v20;
              goto LABEL_506;
            }
            uint64_t v370 = *(unsigned int *)(v362 + 4 * v371);
            unsigned int v373 = v367 - v345;
            *(_DWORD *)(v362 + 4 * v371) = v367 - v345;
            if (v370 >= v712)
            {
              int v378 = *(_DWORD *)(v345 + v370);
              int v377 = *v367;
            }
            else
            {
              int v377 = *v367;
              int v378 = *v367 ^ 1;
            }
            uint64_t v369 = (-1640531535 * v374) >> v363;
            if (v377 == v378) {
              break;
            }
            LODWORD(v370) = *(_DWORD *)(v362 + 4 * v369);
            int v366 = *_X9;
            if ((unint64_t)v360 + v7 >= v368)
            {
              unint64_t v379 = v7 + 1;
              __asm
              {
                PRFM            #0, [X9,#0x40]
                PRFM            #0, [X9,#0x80]
              }
              v368 += 128;
            }
            else
            {
              unint64_t v379 = v7;
            }
            uint64_t v367 = _X9;
            unint64_t v20 = (unint64_t)v360;
            uint64_t v360 = (int *)((char *)v360 + v7);
            _X9 = (int *)((char *)_X9 + v7);
            unint64_t v7 = v379;
            if ((unint64_t)_X9 >= v353) {
              goto LABEL_584;
            }
          }
          if (v7 < 5) {
LABEL_506:
          }
            *(_DWORD *)(v362 + 4 * v369) = v360 - v345;
          unsigned int v385 = (unsigned __int8 *)(v345 + v370);
          uint64_t v57 = (v367 - v385);
          int v386 = v57 + 3;
          if ((unint64_t)v367 <= a4 || v370 <= v712)
          {
            uint64_t v383 = 4;
          }
          else
          {
            unint64_t v387 = (unsigned __int8 *)(v345 - 1 + v370);
            unint64_t v388 = (unsigned __int8 *)v367 - 1;
            uint64_t v383 = 4;
            while (*v388 == *v387)
            {
              ++v383;
              uint64_t v389 = v387 - 1;
              v390 = v388 - 1;
              if ((unint64_t)v387 > v685)
              {
                --v387;
                BOOL v62 = (unint64_t)v388-- > a4;
                if (v62) {
                  continue;
                }
              }
              unsigned int v385 = v389 + 1;
              uint64_t v367 = (int *)(v390 + 1);
              goto LABEL_516;
            }
            unsigned int v385 = v387 + 1;
            uint64_t v367 = (int *)(v388 + 1);
          }
LABEL_516:
          v391 = (char *)v367 + v383;
          v392 = &v385[v383];
          if (v364 <= (unint64_t)v367 + v383)
          {
            int v395 = (int *)((char *)v367 + v383);
          }
          else
          {
            unint64_t v393 = *(void *)v391 ^ *(void *)v392;
            if (v393)
            {
              unint64_t v394 = __clz(__rbit64(v393)) >> 3;
              goto LABEL_530;
            }
            uint64_t v421 = 0;
            uint64_t v422 = (uint64_t)v367 + v383 + 8;
            while (1)
            {
              __int16 v423 = (void *)(v422 + v421);
              if (v422 + v421 >= v364) {
                break;
              }
              uint64_t v424 = *(void *)&v385[v383 + 8 + v421];
              v421 += 8;
              unint64_t v425 = *v423 ^ v424;
              if (v425)
              {
                unint64_t v394 = v421 + (__clz(__rbit64(v425)) >> 3);
                goto LABEL_530;
              }
            }
            int v395 = (int *)((char *)v367 + v383 + v421 + 8);
            v392 = &v385[v383 + 8 + v421];
          }
          if ((unint64_t)v395 < v752 && *(_DWORD *)v392 == *v395)
          {
            ++v395;
            v392 += 4;
          }
          if ((unint64_t)v395 < v744 && *(unsigned __int16 *)v392 == *(unsigned __int16 *)v395)
          {
            int v395 = (_DWORD *)((char *)v395 + 2);
            v392 += 2;
          }
          if ((unint64_t)v395 < v757 && *v392 == *(unsigned __int8 *)v395) {
            int v395 = (_DWORD *)((char *)v395 + 1);
          }
          unint64_t v394 = (char *)v395 - v391;
LABEL_530:
          uint64_t v396 = (uint64_t)v367 - a4;
          uint64_t v397 = *(_OWORD **)(a2 + 24);
          if (v367 <= (int *)v365)
          {
            *uint64_t v397 = *(_OWORD *)a4;
            uint64_t v400 = *(void *)(a2 + 24);
            if ((unint64_t)v396 <= 0x10)
            {
              *(void *)(a2 + 24) = v400 + v396;
              uint64_t v398 = *(void *)(a2 + 8);
              goto LABEL_541;
            }
            *(_OWORD *)(v400 + 16) = *(_OWORD *)(a4 + 16);
            if (v396 >= 33)
            {
              unint64_t v401 = v400 + v396;
              uint64_t v402 = (_OWORD *)(v400 + 32);
              long long v403 = (long long *)(a4 + 48);
              do
              {
                *uint64_t v402 = *(v403 - 1);
                long long v404 = *v403;
                v403 += 2;
                v402[1] = v404;
                v402 += 2;
              }
              while ((unint64_t)v402 < v401);
            }
          }
          else
          {
            int v363 = v386;
            sub_1DD29DBFC(v397, (char *)a4, (unint64_t)v367, v365);
            int v386 = v363;
            LOBYTE(v363) = v690;
            unint64_t v353 = v720;
          }
          *(void *)(a2 + 24) += v396;
          uint64_t v398 = *(void *)(a2 + 8);
          if ((unint64_t)v396 >= 0x10000)
          {
            unint64_t v399 = (unint64_t)(v398 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 1;
            *(_DWORD *)(a2 + 76) = v399;
          }
          unint64_t v365 = v728;
          unint64_t v364 = v736;
LABEL_541:
          unint64_t v405 = v394 + v383;
          *(_WORD *)(v398 + 4) = v396;
          *(_DWORD *)uint64_t v398 = v386;
          unint64_t v406 = v394 + v383 - 3;
          if (v406 >= 0x10000)
          {
            unint64_t v407 = (unint64_t)(v398 - *(void *)a2) >> 3;
            *(_DWORD *)(a2 + 72) = 2;
            *(_DWORD *)(a2 + 76) = v407;
          }
          *(_WORD *)(v398 + 6) = v406;
          *(void *)(a2 + 8) = v398 + 8;
          unint64_t v20 = (unint64_t)v367 + v405;
          if ((unint64_t)v367 + v405 <= v353)
          {
            *(_DWORD *)(v362 + 4 * ((-1640531535 * *(_DWORD *)(v345 + 2 + v373)) >> v363)) = v373 + 2;
            *(_DWORD *)(v362 + 4 * ((-1640531535 * *(_DWORD *)(v20 - 2)) >> v363)) = v20 - 2 - v345;
            unint64_t v9 = v757;
            if (v26)
            {
              uint64_t v408 = v57;
              while (1)
              {
                uint64_t v25 = v408;
                uint64_t v408 = v26;
                if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v26)) {
                  break;
                }
                uint64_t v409 = (char *)(v20 + 4);
                uint64_t v410 = (void *)(v20 + 4 - v26);
                if (v364 <= v20 + 4)
                {
                  unint64_t v413 = (_DWORD *)(v20 + 4);
                }
                else
                {
                  unint64_t v411 = *(void *)v409 ^ *v410;
                  if (v411)
                  {
                    unint64_t v412 = __clz(__rbit64(v411)) >> 3;
                    goto LABEL_562;
                  }
                  unint64_t v417 = v20 + 12;
                  while (1)
                  {
                    uint64_t v418 = (void *)(v417 + v411);
                    if (v417 + v411 >= v364) {
                      break;
                    }
                    uint64_t v419 = *(void *)(v20 + 12 - v26 + v411);
                    v411 += 8;
                    unint64_t v420 = *v418 ^ v419;
                    if (v420)
                    {
                      unint64_t v412 = v411 + (__clz(__rbit64(v420)) >> 3);
                      goto LABEL_562;
                    }
                  }
                  unint64_t v413 = (_DWORD *)(v20 + v411 + 12);
                  uint64_t v410 = (void *)((char *)v413 - v26);
                }
                if ((unint64_t)v413 < v752 && *(_DWORD *)v410 == *v413)
                {
                  ++v413;
                  uint64_t v410 = (void *)((char *)v410 + 4);
                }
                if ((unint64_t)v413 < v744 && *(unsigned __int16 *)v410 == *(unsigned __int16 *)v413)
                {
                  unint64_t v413 = (_DWORD *)((char *)v413 + 2);
                  uint64_t v410 = (void *)((char *)v410 + 2);
                }
                if ((unint64_t)v413 < v757 && *(unsigned __int8 *)v410 == *(unsigned __int8 *)v413) {
                  unint64_t v413 = (_DWORD *)((char *)v413 + 1);
                }
                unint64_t v412 = (char *)v413 - v409;
LABEL_562:
                *(_DWORD *)(v362 + 4 * ((-1640531535 * *(_DWORD *)v20) >> v363)) = v20 - v345;
                v414 = *(_OWORD **)(a2 + 24);
                if (v20 <= (unint64_t)v365)
                {
                  _OWORD *v414 = *(_OWORD *)v20;
                }
                else
                {
                  sub_1DD29DBFC(v414, (char *)v20, v20, v365);
                  unint64_t v365 = v728;
                  unint64_t v364 = v736;
                  unint64_t v353 = v720;
                }
                uint64_t v415 = *(void *)(a2 + 8);
                *(_WORD *)(v415 + 4) = 0;
                *(_DWORD *)uint64_t v415 = 1;
                if (v412 + 1 >= 0x10000)
                {
                  unint64_t v416 = (unint64_t)(v415 - *(void *)a2) >> 3;
                  *(_DWORD *)(a2 + 72) = 2;
                  *(_DWORD *)(a2 + 76) = v416;
                }
                v20 += v412 + 4;
                *(_WORD *)(v415 + 6) = v412 + 1;
                *(void *)(a2 + 8) = v415 + 8;
                uint64_t v26 = v25;
                uint64_t v57 = v408;
                if (v20 > v353) {
                  goto LABEL_580;
                }
              }
              uint64_t v57 = v25;
              uint64_t v25 = v26;
            }
            else
            {
              uint64_t v25 = 0;
            }
          }
          else
          {
            uint64_t v25 = v26;
            unint64_t v9 = v757;
          }
LABEL_580:
          unint64_t v7 = v701;
          uint64_t v360 = (int *)(v20 + v701);
          _X9 = (int *)(v20 + v701 + 1);
          uint64_t v26 = v57;
          a4 = v20;
          if ((unint64_t)_X9 >= v353) {
            goto LABEL_585;
          }
        }
      }
      uint64_t v264 = *(void *)(a1 + 8);
      unint64_t v9 = a4 + a5;
      int v265 = a4 + a5 - v264;
      unsigned int v266 = 1 << *(_DWORD *)(a1 + 256);
      unsigned int v267 = *(_DWORD *)(a1 + 24);
      BOOL v268 = v265 - v267 > v266;
      unsigned int v269 = v265 - v266;
      BOOL v270 = *(_DWORD *)(a1 + 40) == 0;
      if (v270 && v268) {
        uint64_t v271 = v269;
      }
      else {
        uint64_t v271 = v267;
      }
      unint64_t v272 = v9 - 8;
      unsigned int v274 = *a3;
      unsigned int v273 = a3[1];
      if (v264 + v271 == a4) {
        unint64_t v20 = a4 + 1;
      }
      else {
        unint64_t v20 = a4;
      }
      int v275 = v20 - v264;
      BOOL v276 = v20 - v264 - v267 > v266;
      int v277 = v20 - v264 - v266;
      if (!v270 || !v276) {
        int v277 = *(_DWORD *)(a1 + 24);
      }
      unsigned int v278 = v275 - v277;
      if (v273 <= v275 - v277) {
        uint64_t v25 = v273;
      }
      else {
        uint64_t v25 = 0;
      }
      if (v274 <= v278) {
        uint64_t v26 = v274;
      }
      else {
        uint64_t v26 = 0;
      }
      uint64_t v279 = (_DWORD *)(v20 + v7);
      _X9 = (int *)(v20 + v7 + 1);
      unsigned int v704 = *a3;
      unsigned int v706 = a3[1];
      unsigned int v702 = v278;
      if ((unint64_t)_X9 >= v272) {
        goto LABEL_583;
      }
      unsigned int v711 = v271;
      unint64_t v719 = v9 - 8;
      uint64_t v281 = *(void *)(a1 + 112);
      unint64_t v700 = v7;
      LODWORD(v282) = 64 - *(_DWORD *)(a1 + 264);
      unint64_t v283 = v9 - 7;
      unint64_t v743 = v9 - 1;
      unint64_t v751 = v9 - 3;
      uint64_t v284 = (char *)(v9 - 32);
      unint64_t v684 = v264 + v271;
      v727 = (char *)(v9 - 32);
      unint64_t v735 = v9 - 7;
      unint64_t v757 = v9;
      char v689 = v282;
      while (1)
      {
        unint64_t v286 = (int *)(v20 + 1);
        uint64_t v285 = *(void *)(v20 + 1);
        unint64_t v287 = v20 + 128;
        unint64_t v288 = (0xCF1BBCDCBF9B0000 * *(void *)v20) >> v282;
        LODWORD(v289) = *(_DWORD *)(v281 + 4 * v288);
        while (1)
        {
          unint64_t v290 = (0xCF1BBCDCBF9B0000 * v285) >> v282;
          int v291 = *(_DWORD *)((char *)v279 - v26);
          unsigned int v292 = v20 - v264;
          *(_DWORD *)(v281 + 4 * v288) = v20 - v264;
          if (v26 && *v279 == v291)
          {
            BOOL v301 = *((unsigned __int8 *)v279 - 1) == *((unsigned __int8 *)v279 - v26 - 1);
            if (*((unsigned __int8 *)v279 - 1) == *((unsigned __int8 *)v279 - v26 - 1)) {
              uint64_t v302 = 5;
            }
            else {
              uint64_t v302 = 4;
            }
            int v303 = v286 - v264;
            unint64_t v286 = (_DWORD *)((char *)v279 - v301);
            unsigned int v304 = (unsigned __int8 *)((char *)v279 - v26 - v301);
            *(_DWORD *)(v281 + 4 * v290) = v303;
            int v305 = 1;
            uint64_t v57 = v26;
            uint64_t v26 = v25;
            goto LABEL_401;
          }
          if (v289 >= v711)
          {
            int v294 = *(_DWORD *)(v264 + v289);
            int v293 = *(_DWORD *)v20;
          }
          else
          {
            int v293 = *(_DWORD *)v20;
            int v294 = *(_DWORD *)v20 ^ 1;
          }
          if (v293 == v294)
          {
            LODWORD(v279) = v286;
            unint64_t v288 = v290;
            unint64_t v286 = (int *)v20;
            goto LABEL_391;
          }
          uint64_t v289 = *(unsigned int *)(v281 + 4 * v290);
          uint64_t v295 = *(void *)v279;
          unsigned int v292 = v286 - v264;
          *(_DWORD *)(v281 + 4 * v290) = v286 - v264;
          if (v289 >= v711)
          {
            int v297 = *(_DWORD *)(v264 + v289);
            int v296 = *v286;
          }
          else
          {
            int v296 = *v286;
            int v297 = *v286 ^ 1;
          }
          unint64_t v288 = (0xCF1BBCDCBF9B0000 * v295) >> v282;
          if (v296 == v297) {
            break;
          }
          LODWORD(v289) = *(_DWORD *)(v281 + 4 * v288);
          uint64_t v285 = *(void *)_X9;
          if ((unint64_t)v279 + v7 >= v287)
          {
            unint64_t v298 = v7 + 1;
            __asm
            {
              PRFM            #0, [X9,#0x40]
              PRFM            #0, [X9,#0x80]
            }
            v287 += 128;
          }
          else
          {
            unint64_t v298 = v7;
          }
          unint64_t v286 = _X9;
          unint64_t v20 = (unint64_t)v279;
          uint64_t v279 = (_DWORD *)((char *)v279 + v7);
          _X9 = (int *)((char *)_X9 + v7);
          unint64_t v7 = v298;
          if ((unint64_t)_X9 >= v272) {
            goto LABEL_584;
          }
        }
        if (v7 < 5) {
LABEL_391:
        }
          *(_DWORD *)(v281 + 4 * v288) = v279 - v264;
        unsigned int v304 = (unsigned __int8 *)(v264 + v289);
        uint64_t v57 = (v286 - v304);
        int v305 = v57 + 3;
        if ((unint64_t)v286 <= a4 || v289 <= v711)
        {
          uint64_t v302 = 4;
        }
        else
        {
          int v306 = (unsigned __int8 *)(v264 - 1 + v289);
          unint64_t v307 = (unsigned __int8 *)v286 - 1;
          uint64_t v302 = 4;
          while (*v307 == *v306)
          {
            ++v302;
            v308 = v306 - 1;
            unint64_t v309 = v307 - 1;
            if ((unint64_t)v306 > v684)
            {
              --v306;
              BOOL v62 = (unint64_t)v307-- > a4;
              if (v62) {
                continue;
              }
            }
            unsigned int v304 = v308 + 1;
            unint64_t v286 = (int *)(v309 + 1);
            goto LABEL_401;
          }
          unsigned int v304 = v306 + 1;
          unint64_t v286 = (int *)(v307 + 1);
        }
LABEL_401:
        unint64_t v310 = (char *)v286 + v302;
        unint64_t v311 = &v304[v302];
        if (v283 <= (unint64_t)v286 + v302)
        {
          uint64_t v314 = (int *)((char *)v286 + v302);
        }
        else
        {
          unint64_t v312 = *(void *)v310 ^ *(void *)v311;
          if (v312)
          {
            unint64_t v313 = __clz(__rbit64(v312)) >> 3;
            goto LABEL_415;
          }
          uint64_t v340 = 0;
          uint64_t v341 = (uint64_t)v286 + v302 + 8;
          while (1)
          {
            unint64_t v342 = (void *)(v341 + v340);
            if (v341 + v340 >= v283) {
              break;
            }
            uint64_t v343 = *(void *)&v304[v302 + 8 + v340];
            v340 += 8;
            unint64_t v344 = *v342 ^ v343;
            if (v344)
            {
              unint64_t v313 = v340 + (__clz(__rbit64(v344)) >> 3);
              goto LABEL_415;
            }
          }
          uint64_t v314 = (int *)((char *)v286 + v302 + v340 + 8);
          unint64_t v311 = &v304[v302 + 8 + v340];
        }
        if ((unint64_t)v314 < v751 && *(_DWORD *)v311 == *v314)
        {
          ++v314;
          v311 += 4;
        }
        if ((unint64_t)v314 < v743 && *(unsigned __int16 *)v311 == *(unsigned __int16 *)v314)
        {
          uint64_t v314 = (_DWORD *)((char *)v314 + 2);
          v311 += 2;
        }
        if ((unint64_t)v314 < v757 && *v311 == *(unsigned __int8 *)v314) {
          uint64_t v314 = (_DWORD *)((char *)v314 + 1);
        }
        unint64_t v313 = (char *)v314 - v310;
LABEL_415:
        uint64_t v315 = (uint64_t)v286 - a4;
        unint64_t v316 = *(_OWORD **)(a2 + 24);
        if (v286 <= (int *)v284)
        {
          _OWORD *v316 = *(_OWORD *)a4;
          uint64_t v319 = *(void *)(a2 + 24);
          if ((unint64_t)v315 <= 0x10)
          {
            *(void *)(a2 + 24) = v319 + v315;
            uint64_t v317 = *(void *)(a2 + 8);
            goto LABEL_426;
          }
          *(_OWORD *)(v319 + 16) = *(_OWORD *)(a4 + 16);
          if (v315 >= 33)
          {
            unint64_t v320 = v319 + v315;
            unint64_t v321 = (_OWORD *)(v319 + 32);
            unint64_t v322 = (long long *)(a4 + 48);
            do
            {
              *unint64_t v321 = *(v322 - 1);
              long long v323 = *v322;
              v322 += 2;
              v321[1] = v323;
              v321 += 2;
            }
            while ((unint64_t)v321 < v320);
          }
        }
        else
        {
          unint64_t v282 = v313;
          sub_1DD29DBFC(v316, (char *)a4, (unint64_t)v286, v284);
          unint64_t v313 = v282;
          LOBYTE(v282) = v689;
          unint64_t v272 = v719;
        }
        *(void *)(a2 + 24) += v315;
        uint64_t v317 = *(void *)(a2 + 8);
        if ((unint64_t)v315 >= 0x10000)
        {
          unint64_t v318 = (unint64_t)(v317 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 1;
          *(_DWORD *)(a2 + 76) = v318;
        }
        uint64_t v284 = v727;
        unint64_t v283 = v735;
LABEL_426:
        unint64_t v324 = v313 + v302;
        *(_WORD *)(v317 + 4) = v315;
        *(_DWORD *)uint64_t v317 = v305;
        unint64_t v325 = v313 + v302 - 3;
        if (v325 >= 0x10000)
        {
          unint64_t v326 = (unint64_t)(v317 - *(void *)a2) >> 3;
          *(_DWORD *)(a2 + 72) = 2;
          *(_DWORD *)(a2 + 76) = v326;
        }
        *(_WORD *)(v317 + 6) = v325;
        *(void *)(a2 + 8) = v317 + 8;
        unint64_t v20 = (unint64_t)v286 + v324;
        if ((unint64_t)v286 + v324 <= v272)
        {
          *(_DWORD *)(v281 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v264 + 2 + v292)) >> v282)) = v292 + 2;
          *(_DWORD *)(v281 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v20 - 2)) >> v282)) = v20 - 2 - v264;
          unint64_t v9 = v757;
          if (v26)
          {
            uint64_t v327 = v57;
            while (1)
            {
              uint64_t v25 = v327;
              uint64_t v327 = v26;
              if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v26)) {
                break;
              }
              uint64_t v328 = (char *)(v20 + 4);
              unint64_t v329 = (void *)(v20 + 4 - v26);
              if (v283 <= v20 + 4)
              {
                unint64_t v332 = (_DWORD *)(v20 + 4);
              }
              else
              {
                unint64_t v330 = *(void *)v328 ^ *v329;
                if (v330)
                {
                  unint64_t v331 = __clz(__rbit64(v330)) >> 3;
                  goto LABEL_447;
                }
                unint64_t v336 = v20 + 12;
                while (1)
                {
                  v337 = (void *)(v336 + v330);
                  if (v336 + v330 >= v283) {
                    break;
                  }
                  uint64_t v338 = *(void *)(v20 + 12 - v26 + v330);
                  v330 += 8;
                  unint64_t v339 = *v337 ^ v338;
                  if (v339)
                  {
                    unint64_t v331 = v330 + (__clz(__rbit64(v339)) >> 3);
                    goto LABEL_447;
                  }
                }
                unint64_t v332 = (_DWORD *)(v20 + v330 + 12);
                unint64_t v329 = (void *)((char *)v332 - v26);
              }
              if ((unint64_t)v332 < v751 && *(_DWORD *)v329 == *v332)
              {
                ++v332;
                unint64_t v329 = (void *)((char *)v329 + 4);
              }
              if ((unint64_t)v332 < v743 && *(unsigned __int16 *)v329 == *(unsigned __int16 *)v332)
              {
                unint64_t v332 = (_DWORD *)((char *)v332 + 2);
                unint64_t v329 = (void *)((char *)v329 + 2);
              }
              if ((unint64_t)v332 < v757 && *(unsigned __int8 *)v329 == *(unsigned __int8 *)v332) {
                unint64_t v332 = (_DWORD *)((char *)v332 + 1);
              }
              unint64_t v331 = (char *)v332 - v328;
LABEL_447:
              *(_DWORD *)(v281 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v20) >> v282)) = v20 - v264;
              uint64_t v333 = *(_OWORD **)(a2 + 24);
              if (v20 <= (unint64_t)v284)
              {
                _OWORD *v333 = *(_OWORD *)v20;
              }
              else
              {
                sub_1DD29DBFC(v333, (char *)v20, v20, v284);
                uint64_t v284 = v727;
                unint64_t v283 = v735;
                unint64_t v272 = v719;
              }
              uint64_t v334 = *(void *)(a2 + 8);
              *(_WORD *)(v334 + 4) = 0;
              *(_DWORD *)uint64_t v334 = 1;
              if (v331 + 1 >= 0x10000)
              {
                unint64_t v335 = (unint64_t)(v334 - *(void *)a2) >> 3;
                *(_DWORD *)(a2 + 72) = 2;
                *(_DWORD *)(a2 + 76) = v335;
              }
              v20 += v331 + 4;
              *(_WORD *)(v334 + 6) = v331 + 1;
              *(void *)(a2 + 8) = v334 + 8;
              uint64_t v26 = v25;
              uint64_t v57 = v327;
              if (v20 > v272) {
                goto LABEL_465;
              }
            }
            uint64_t v57 = v25;
            uint64_t v25 = v26;
          }
          else
          {
            uint64_t v25 = 0;
          }
        }
        else
        {
          uint64_t v25 = v26;
          unint64_t v9 = v757;
        }
LABEL_465:
        unint64_t v7 = v700;
        uint64_t v279 = (_DWORD *)(v20 + v700);
        _X9 = (int *)(v20 + v700 + 1);
        uint64_t v26 = v57;
        a4 = v20;
        if ((unint64_t)_X9 >= v272) {
          goto LABEL_585;
        }
      }
    }
    uint64_t v183 = *(void *)(a1 + 8);
    unint64_t v9 = a4 + a5;
    int v184 = a4 + a5 - v183;
    unsigned int v185 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v186 = *(_DWORD *)(a1 + 24);
    BOOL v187 = v184 - v186 > v185;
    unsigned int v188 = v184 - v185;
    BOOL v189 = *(_DWORD *)(a1 + 40) == 0;
    if (v189 && v187) {
      uint64_t v190 = v188;
    }
    else {
      uint64_t v190 = v186;
    }
    unint64_t v191 = v9 - 8;
    unsigned int v193 = *a3;
    unsigned int v192 = a3[1];
    if (v183 + v190 == a4) {
      unint64_t v20 = a4 + 1;
    }
    else {
      unint64_t v20 = a4;
    }
    int v194 = v20 - v183;
    BOOL v195 = v20 - v183 - v186 > v185;
    int v196 = v20 - v183 - v185;
    if (!v189 || !v195) {
      int v196 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v197 = v194 - v196;
    if (v192 <= v194 - v196) {
      uint64_t v25 = v192;
    }
    else {
      uint64_t v25 = 0;
    }
    if (v193 <= v197) {
      uint64_t v26 = v193;
    }
    else {
      uint64_t v26 = 0;
    }
    uint64_t v198 = (_DWORD *)(v20 + v7);
    _X9 = (int *)(v20 + v7 + 1);
    unsigned int v704 = *a3;
    unsigned int v706 = a3[1];
    unsigned int v702 = v197;
    if ((unint64_t)_X9 >= v191) {
      goto LABEL_583;
    }
    unsigned int v710 = v190;
    unint64_t v718 = v9 - 8;
    uint64_t v200 = *(void *)(a1 + 112);
    unint64_t v699 = v7;
    int v201 = 64 - *(_DWORD *)(a1 + 264);
    unint64_t v202 = v9 - 7;
    unint64_t v742 = v9 - 1;
    unint64_t v750 = v9 - 3;
    unint64_t v203 = (char *)(v9 - 32);
    unint64_t v683 = v183 + v190;
    v726 = (char *)(v9 - 32);
    unint64_t v734 = v9 - 7;
    unint64_t v757 = v9;
    char v688 = v201;
    while (1)
    {
      unint64_t v205 = (int *)(v20 + 1);
      uint64_t v204 = *(void *)(v20 + 1);
      unint64_t v206 = v20 + 128;
      unint64_t v207 = (0xCF1BBCDCBB000000 * *(void *)v20) >> v201;
      LODWORD(v208) = *(_DWORD *)(v200 + 4 * v207);
      while (1)
      {
        unint64_t v209 = (0xCF1BBCDCBB000000 * v204) >> v201;
        int v210 = *(_DWORD *)((char *)v198 - v26);
        unsigned int v211 = v20 - v183;
        *(_DWORD *)(v200 + 4 * v207) = v20 - v183;
        if (v26 && *v198 == v210)
        {
          BOOL v220 = *((unsigned __int8 *)v198 - 1) == *((unsigned __int8 *)v198 - v26 - 1);
          if (*((unsigned __int8 *)v198 - 1) == *((unsigned __int8 *)v198 - v26 - 1)) {
            uint64_t v221 = 5;
          }
          else {
            uint64_t v221 = 4;
          }
          int v222 = v205 - v183;
          unint64_t v205 = (_DWORD *)((char *)v198 - v220);
          uint64_t v223 = (unsigned __int8 *)((char *)v198 - v26 - v220);
          *(_DWORD *)(v200 + 4 * v209) = v222;
          int v224 = 1;
          uint64_t v57 = v26;
          uint64_t v26 = v25;
          goto LABEL_286;
        }
        if (v208 >= v710)
        {
          int v213 = *(_DWORD *)(v183 + v208);
          int v212 = *(_DWORD *)v20;
        }
        else
        {
          int v212 = *(_DWORD *)v20;
          int v213 = *(_DWORD *)v20 ^ 1;
        }
        if (v212 == v213)
        {
          LODWORD(v198) = v205;
          unint64_t v207 = v209;
          unint64_t v205 = (int *)v20;
          goto LABEL_276;
        }
        uint64_t v208 = *(unsigned int *)(v200 + 4 * v209);
        uint64_t v214 = *(void *)v198;
        unsigned int v211 = v205 - v183;
        *(_DWORD *)(v200 + 4 * v209) = v205 - v183;
        if (v208 >= v710)
        {
          int v216 = *(_DWORD *)(v183 + v208);
          int v215 = *v205;
        }
        else
        {
          int v215 = *v205;
          int v216 = *v205 ^ 1;
        }
        unint64_t v207 = (0xCF1BBCDCBB000000 * v214) >> v201;
        if (v215 == v216) {
          break;
        }
        LODWORD(v208) = *(_DWORD *)(v200 + 4 * v207);
        uint64_t v204 = *(void *)_X9;
        if ((unint64_t)v198 + v7 >= v206)
        {
          unint64_t v217 = v7 + 1;
          __asm
          {
            PRFM            #0, [X9,#0x40]
            PRFM            #0, [X9,#0x80]
          }
          v206 += 128;
        }
        else
        {
          unint64_t v217 = v7;
        }
        unint64_t v205 = _X9;
        unint64_t v20 = (unint64_t)v198;
        uint64_t v198 = (_DWORD *)((char *)v198 + v7);
        _X9 = (int *)((char *)_X9 + v7);
        unint64_t v7 = v217;
        if ((unint64_t)_X9 >= v191)
        {
LABEL_584:
          unint64_t v20 = a4;
          LODWORD(v57) = v26;
          unint64_t v9 = v757;
          goto LABEL_585;
        }
      }
      if (v7 < 5) {
LABEL_276:
      }
        *(_DWORD *)(v200 + 4 * v207) = v198 - v183;
      uint64_t v223 = (unsigned __int8 *)(v183 + v208);
      uint64_t v57 = (v205 - v223);
      int v224 = v57 + 3;
      if ((unint64_t)v205 <= a4 || v208 <= v710)
      {
        uint64_t v221 = 4;
      }
      else
      {
        uint64_t v225 = (unsigned __int8 *)(v183 - 1 + v208);
        unint64_t v226 = (unsigned __int8 *)v205 - 1;
        uint64_t v221 = 4;
        while (*v226 == *v225)
        {
          ++v221;
          uint64_t v227 = v225 - 1;
          v228 = v226 - 1;
          if ((unint64_t)v225 > v683)
          {
            --v225;
            BOOL v62 = (unint64_t)v226-- > a4;
            if (v62) {
              continue;
            }
          }
          uint64_t v223 = v227 + 1;
          unint64_t v205 = (int *)(v228 + 1);
          goto LABEL_286;
        }
        uint64_t v223 = v225 + 1;
        unint64_t v205 = (int *)(v226 + 1);
      }
LABEL_286:
      uint64_t v229 = (char *)v205 + v221;
      v230 = &v223[v221];
      if (v202 <= (unint64_t)v205 + v221)
      {
        unint64_t v233 = (int *)((char *)v205 + v221);
      }
      else
      {
        unint64_t v231 = *(void *)v229 ^ *(void *)v230;
        if (v231)
        {
          unint64_t v232 = __clz(__rbit64(v231)) >> 3;
          goto LABEL_300;
        }
        uint64_t v259 = 0;
        uint64_t v260 = (uint64_t)v205 + v221 + 8;
        while (1)
        {
          unint64_t v261 = (void *)(v260 + v259);
          if (v260 + v259 >= v202) {
            break;
          }
          uint64_t v262 = *(void *)&v223[v221 + 8 + v259];
          v259 += 8;
          unint64_t v263 = *v261 ^ v262;
          if (v263)
          {
            unint64_t v232 = v259 + (__clz(__rbit64(v263)) >> 3);
            goto LABEL_300;
          }
        }
        unint64_t v233 = (int *)((char *)v205 + v221 + v259 + 8);
        v230 = &v223[v221 + 8 + v259];
      }
      if ((unint64_t)v233 < v750 && *(_DWORD *)v230 == *v233)
      {
        ++v233;
        v230 += 4;
      }
      if ((unint64_t)v233 < v742 && *(unsigned __int16 *)v230 == *(unsigned __int16 *)v233)
      {
        unint64_t v233 = (_DWORD *)((char *)v233 + 2);
        v230 += 2;
      }
      if ((unint64_t)v233 < v757 && *v230 == *(unsigned __int8 *)v233) {
        unint64_t v233 = (_DWORD *)((char *)v233 + 1);
      }
      unint64_t v232 = (char *)v233 - v229;
LABEL_300:
      uint64_t v234 = (uint64_t)v205 - a4;
      unint64_t v235 = *(_OWORD **)(a2 + 24);
      if (v205 <= (int *)v203)
      {
        _OWORD *v235 = *(_OWORD *)a4;
        uint64_t v238 = *(void *)(a2 + 24);
        if ((unint64_t)v234 <= 0x10)
        {
          *(void *)(a2 + 24) = v238 + v234;
          uint64_t v236 = *(void *)(a2 + 8);
          goto LABEL_311;
        }
        *(_OWORD *)(v238 + 16) = *(_OWORD *)(a4 + 16);
        if (v234 >= 33)
        {
          unint64_t v239 = v238 + v234;
          v240 = (_OWORD *)(v238 + 32);
          __int16 v241 = (long long *)(a4 + 48);
          do
          {
            _OWORD *v240 = *(v241 - 1);
            long long v242 = *v241;
            v241 += 2;
            v240[1] = v242;
            v240 += 2;
          }
          while ((unint64_t)v240 < v239);
        }
      }
      else
      {
        int v201 = v224;
        sub_1DD29DBFC(v235, (char *)a4, (unint64_t)v205, v203);
        int v224 = v201;
        LOBYTE(v201) = v688;
        unint64_t v191 = v718;
      }
      *(void *)(a2 + 24) += v234;
      uint64_t v236 = *(void *)(a2 + 8);
      if ((unint64_t)v234 >= 0x10000)
      {
        unint64_t v237 = (unint64_t)(v236 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v237;
      }
      unint64_t v203 = v726;
      unint64_t v202 = v734;
LABEL_311:
      unint64_t v243 = v232 + v221;
      *(_WORD *)(v236 + 4) = v234;
      *(_DWORD *)uint64_t v236 = v224;
      unint64_t v244 = v232 + v221 - 3;
      if (v244 >= 0x10000)
      {
        unint64_t v245 = (unint64_t)(v236 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v245;
      }
      *(_WORD *)(v236 + 6) = v244;
      *(void *)(a2 + 8) = v236 + 8;
      unint64_t v20 = (unint64_t)v205 + v243;
      if ((unint64_t)v205 + v243 <= v191)
      {
        *(_DWORD *)(v200 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v183 + 2 + v211)) >> v201)) = v211 + 2;
        *(_DWORD *)(v200 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v20 - 2)) >> v201)) = v20 - 2 - v183;
        unint64_t v9 = v757;
        if (v26)
        {
          uint64_t v246 = v57;
          while (1)
          {
            uint64_t v25 = v246;
            uint64_t v246 = v26;
            if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v26)) {
              break;
            }
            uint64_t v247 = (char *)(v20 + 4);
            unint64_t v248 = (void *)(v20 + 4 - v26);
            if (v202 <= v20 + 4)
            {
              int v251 = (_DWORD *)(v20 + 4);
            }
            else
            {
              unint64_t v249 = *(void *)v247 ^ *v248;
              if (v249)
              {
                unint64_t v250 = __clz(__rbit64(v249)) >> 3;
                goto LABEL_332;
              }
              unint64_t v255 = v20 + 12;
              while (1)
              {
                int v256 = (void *)(v255 + v249);
                if (v255 + v249 >= v202) {
                  break;
                }
                uint64_t v257 = *(void *)(v20 + 12 - v26 + v249);
                v249 += 8;
                unint64_t v258 = *v256 ^ v257;
                if (v258)
                {
                  unint64_t v250 = v249 + (__clz(__rbit64(v258)) >> 3);
                  goto LABEL_332;
                }
              }
              int v251 = (_DWORD *)(v20 + v249 + 12);
              unint64_t v248 = (void *)((char *)v251 - v26);
            }
            if ((unint64_t)v251 < v750 && *(_DWORD *)v248 == *v251)
            {
              ++v251;
              unint64_t v248 = (void *)((char *)v248 + 4);
            }
            if ((unint64_t)v251 < v742 && *(unsigned __int16 *)v248 == *(unsigned __int16 *)v251)
            {
              int v251 = (_DWORD *)((char *)v251 + 2);
              unint64_t v248 = (void *)((char *)v248 + 2);
            }
            if ((unint64_t)v251 < v757 && *(unsigned __int8 *)v248 == *(unsigned __int8 *)v251) {
              int v251 = (_DWORD *)((char *)v251 + 1);
            }
            unint64_t v250 = (char *)v251 - v247;
LABEL_332:
            *(_DWORD *)(v200 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v20) >> v201)) = v20 - v183;
            v252 = *(_OWORD **)(a2 + 24);
            if (v20 <= (unint64_t)v203)
            {
              _OWORD *v252 = *(_OWORD *)v20;
            }
            else
            {
              sub_1DD29DBFC(v252, (char *)v20, v20, v203);
              unint64_t v203 = v726;
              unint64_t v202 = v734;
              unint64_t v191 = v718;
            }
            uint64_t v253 = *(void *)(a2 + 8);
            *(_WORD *)(v253 + 4) = 0;
            *(_DWORD *)uint64_t v253 = 1;
            if (v250 + 1 >= 0x10000)
            {
              unint64_t v254 = (unint64_t)(v253 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v254;
            }
            v20 += v250 + 4;
            *(_WORD *)(v253 + 6) = v250 + 1;
            *(void *)(a2 + 8) = v253 + 8;
            uint64_t v26 = v25;
            uint64_t v57 = v246;
            if (v20 > v191) {
              goto LABEL_350;
            }
          }
          uint64_t v57 = v25;
          uint64_t v25 = v26;
        }
        else
        {
          uint64_t v25 = 0;
        }
      }
      else
      {
        uint64_t v25 = v26;
        unint64_t v9 = v757;
      }
LABEL_350:
      unint64_t v7 = v699;
      uint64_t v198 = (_DWORD *)(v20 + v699);
      _X9 = (int *)(v20 + v699 + 1);
      uint64_t v26 = v57;
      a4 = v20;
      if ((unint64_t)_X9 >= v191) {
        goto LABEL_585;
      }
    }
  }
  if (v5 == 5)
  {
    uint64_t v430 = *(void *)(a1 + 8);
    unint64_t v431 = a4 + a5;
    int v432 = a4 + a5 - v430;
    unsigned int v433 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v434 = *(_DWORD *)(a1 + 24);
    BOOL v435 = v432 - v434 > v433;
    unsigned int v436 = v432 - v433;
    BOOL v437 = *(_DWORD *)(a1 + 40) == 0;
    if (v437 && v435) {
      uint64_t v438 = v436;
    }
    else {
      uint64_t v438 = v434;
    }
    unint64_t v439 = v431 - 8;
    unsigned int v441 = *a3;
    unsigned int v440 = a3[1];
    if (v430 + v438 == a4) {
      unint64_t v20 = a4 + 1;
    }
    else {
      unint64_t v20 = a4;
    }
    BOOL v442 = v20 - v430 - v434 > v433;
    int v443 = v20 - v430 - v433;
    if (!v437 || !v442) {
      int v443 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v444 = v20 - v430 - v443;
    if (v440 <= v444) {
      uint64_t v113 = v440;
    }
    else {
      uint64_t v113 = 0;
    }
    if (v441 <= v444) {
      uint64_t v114 = v441;
    }
    else {
      uint64_t v114 = 0;
    }
    _X10 = (int *)(v20 + 3);
    unint64_t v758 = v431;
    unsigned int v705 = *a3;
    unsigned int v707 = a3[1];
    unsigned int v703 = v20 - v430 - v443;
    if (v20 + 3 >= v439) {
      goto LABEL_831;
    }
    unsigned int v713 = v438;
    unint64_t v721 = v431 - 8;
    uint64_t v446 = *(void *)(a1 + 112);
    LODWORD(v447) = 64 - *(_DWORD *)(a1 + 264);
    unint64_t v448 = v431 - 7;
    unint64_t v745 = v431 - 1;
    unint64_t v753 = v431 - 3;
    unint64_t v449 = (char *)(v431 - 32);
    unint64_t v691 = v430 + v438;
    v729 = (char *)(v431 - 32);
    unint64_t v737 = v431 - 7;
    char v695 = v447;
    while (1)
    {
      unint64_t v450 = (_DWORD *)(v20 + 2);
      v452 = (int *)(v20 + 1);
      uint64_t v451 = *(void *)(v20 + 1);
      unint64_t v453 = v20 + 128;
      unint64_t v454 = (0xCF1BBCDCBB000000 * *(void *)v20) >> v447;
      LODWORD(v455) = *(_DWORD *)(v446 + 4 * v454);
      unint64_t v456 = 2;
      while (1)
      {
        unint64_t v457 = (0xCF1BBCDCBB000000 * v451) >> v447;
        int v458 = *(_DWORD *)((char *)v450 - v114);
        unsigned int v459 = v20 - v430;
        *(_DWORD *)(v446 + 4 * v454) = v20 - v430;
        if (v114 && *v450 == v458)
        {
          BOOL v468 = *((unsigned __int8 *)v450 - 1) == *((unsigned __int8 *)v450 - v114 - 1);
          if (*((unsigned __int8 *)v450 - 1) == *((unsigned __int8 *)v450 - v114 - 1)) {
            uint64_t v469 = 5;
          }
          else {
            uint64_t v469 = 4;
          }
          int v470 = v452 - v430;
          v452 = (_DWORD *)((char *)v450 - v468);
          unint64_t v471 = (unsigned __int8 *)((char *)v450 - v114 - v468);
          *(_DWORD *)(v446 + 4 * v457) = v470;
          int v472 = 1;
          uint64_t v143 = v114;
          uint64_t v114 = v113;
          goto LABEL_649;
        }
        if (v455 >= v713)
        {
          int v461 = *(_DWORD *)(v430 + v455);
          int v460 = *(_DWORD *)v20;
        }
        else
        {
          int v460 = *(_DWORD *)v20;
          int v461 = *(_DWORD *)v20 ^ 1;
        }
        if (v460 == v461)
        {
          LODWORD(v450) = v452;
          unint64_t v454 = v457;
          v452 = (int *)v20;
          goto LABEL_639;
        }
        uint64_t v455 = *(unsigned int *)(v446 + 4 * v457);
        uint64_t v462 = *(void *)v450;
        unsigned int v459 = v452 - v430;
        *(_DWORD *)(v446 + 4 * v457) = v452 - v430;
        if (v455 >= v713)
        {
          int v464 = *(_DWORD *)(v430 + v455);
          int v463 = *v452;
        }
        else
        {
          int v463 = *v452;
          int v464 = *v452 ^ 1;
        }
        unint64_t v454 = (0xCF1BBCDCBB000000 * v462) >> v447;
        if (v463 == v464) {
          break;
        }
        LODWORD(v455) = *(_DWORD *)(v446 + 4 * v454);
        uint64_t v451 = *(void *)_X10;
        if ((unint64_t)v450 + v456 >= v453)
        {
          unint64_t v465 = v456 + 1;
          __asm
          {
            PRFM            #0, [X10,#0x40]
            PRFM            #0, [X10,#0x80]
          }
          v453 += 128;
        }
        else
        {
          unint64_t v465 = v456;
        }
        v452 = _X10;
        unint64_t v20 = (unint64_t)v450;
        unint64_t v450 = (_DWORD *)((char *)v450 + v456);
        _X10 = (int *)((char *)_X10 + v456);
        unint64_t v456 = v465;
        if ((unint64_t)_X10 >= v439) {
          goto LABEL_831;
        }
      }
      if (v456 < 5) {
LABEL_639:
      }
        *(_DWORD *)(v446 + 4 * v454) = v450 - v430;
      unint64_t v471 = (unsigned __int8 *)(v430 + v455);
      uint64_t v143 = (v452 - v471);
      int v472 = v143 + 3;
      if ((unint64_t)v452 <= a4 || v455 <= v713)
      {
        uint64_t v469 = 4;
      }
      else
      {
        v473 = (unsigned __int8 *)(v430 - 1 + v455);
        uint64_t v474 = (unsigned __int8 *)v452 - 1;
        uint64_t v469 = 4;
        while (*v474 == *v473)
        {
          ++v469;
          unint64_t v475 = v473 - 1;
          uint64_t v476 = v474 - 1;
          if ((unint64_t)v473 > v691)
          {
            --v473;
            BOOL v62 = (unint64_t)v474-- > a4;
            if (v62) {
              continue;
            }
          }
          unint64_t v471 = v475 + 1;
          v452 = (int *)(v476 + 1);
          goto LABEL_649;
        }
        unint64_t v471 = v473 + 1;
        v452 = (int *)(v474 + 1);
      }
LABEL_649:
      unint64_t v477 = (char *)v452 + v469;
      unint64_t v478 = &v471[v469];
      if (v448 <= (unint64_t)v452 + v469)
      {
        unint64_t v481 = (int *)((char *)v452 + v469);
      }
      else
      {
        unint64_t v479 = *(void *)v477 ^ *(void *)v478;
        if (v479)
        {
          unint64_t v480 = __clz(__rbit64(v479)) >> 3;
          goto LABEL_663;
        }
        uint64_t v507 = 0;
        uint64_t v508 = (uint64_t)v452 + v469 + 8;
        while (1)
        {
          unsigned int v509 = (void *)(v508 + v507);
          if (v508 + v507 >= v448) {
            break;
          }
          uint64_t v510 = *(void *)&v471[v469 + 8 + v507];
          v507 += 8;
          unint64_t v511 = *v509 ^ v510;
          if (v511)
          {
            unint64_t v480 = v507 + (__clz(__rbit64(v511)) >> 3);
            goto LABEL_663;
          }
        }
        unint64_t v481 = (int *)((char *)v452 + v469 + v507 + 8);
        unint64_t v478 = &v471[v469 + 8 + v507];
      }
      if ((unint64_t)v481 < v753 && *(_DWORD *)v478 == *v481)
      {
        ++v481;
        v478 += 4;
      }
      if ((unint64_t)v481 < v745 && *(unsigned __int16 *)v478 == *(unsigned __int16 *)v481)
      {
        unint64_t v481 = (_DWORD *)((char *)v481 + 2);
        v478 += 2;
      }
      if ((unint64_t)v481 < v758 && *v478 == *(unsigned __int8 *)v481) {
        unint64_t v481 = (_DWORD *)((char *)v481 + 1);
      }
      unint64_t v480 = (char *)v481 - v477;
LABEL_663:
      uint64_t v482 = (uint64_t)v452 - a4;
      unint64_t v483 = *(_OWORD **)(a2 + 24);
      if (v452 <= (int *)v449)
      {
        *unint64_t v483 = *(_OWORD *)a4;
        uint64_t v486 = *(void *)(a2 + 24);
        if ((unint64_t)v482 <= 0x10)
        {
          *(void *)(a2 + 24) = v486 + v482;
          uint64_t v484 = *(void *)(a2 + 8);
          goto LABEL_674;
        }
        *(_OWORD *)(v486 + 16) = *(_OWORD *)(a4 + 16);
        if (v482 >= 33)
        {
          unint64_t v487 = v486 + v482;
          unint64_t v488 = (_OWORD *)(v486 + 32);
          unint64_t v489 = (long long *)(a4 + 48);
          do
          {
            *unint64_t v488 = *(v489 - 1);
            long long v490 = *v489;
            v489 += 2;
            v488[1] = v490;
            v488 += 2;
          }
          while ((unint64_t)v488 < v487);
        }
      }
      else
      {
        unint64_t v447 = v480;
        sub_1DD29DBFC(v483, (char *)a4, (unint64_t)v452, v449);
        unint64_t v480 = v447;
        LOBYTE(v447) = v695;
        unint64_t v439 = v721;
      }
      *(void *)(a2 + 24) += v482;
      uint64_t v484 = *(void *)(a2 + 8);
      if ((unint64_t)v482 >= 0x10000)
      {
        unint64_t v485 = (unint64_t)(v484 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v485;
      }
      unint64_t v449 = v729;
      unint64_t v448 = v737;
LABEL_674:
      unint64_t v491 = v480 + v469;
      *(_WORD *)(v484 + 4) = v482;
      *(_DWORD *)uint64_t v484 = v472;
      unint64_t v492 = v480 + v469 - 3;
      if (v492 >= 0x10000)
      {
        unint64_t v493 = (unint64_t)(v484 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v493;
      }
      *(_WORD *)(v484 + 6) = v492;
      *(void *)(a2 + 8) = v484 + 8;
      unint64_t v20 = (unint64_t)v452 + v491;
      if ((unint64_t)v452 + v491 <= v439)
      {
        *(_DWORD *)(v446 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v430 + 2 + v459)) >> v447)) = v459 + 2;
        *(_DWORD *)(v446 + 4 * ((0xCF1BBCDCBB000000 * *(void *)(v20 - 2)) >> v447)) = v20 - 2 - v430;
        if (v114)
        {
          uint64_t v494 = v143;
          while (1)
          {
            uint64_t v113 = v494;
            uint64_t v494 = v114;
            if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v114)) {
              break;
            }
            int v495 = (char *)(v20 + 4);
            uint64_t v496 = (void *)(v20 + 4 - v114);
            if (v448 <= v20 + 4)
            {
              unsigned int v499 = (_DWORD *)(v20 + 4);
            }
            else
            {
              unint64_t v497 = *(void *)v495 ^ *v496;
              if (v497)
              {
                unint64_t v498 = __clz(__rbit64(v497)) >> 3;
                goto LABEL_695;
              }
              unint64_t v503 = v20 + 12;
              while (1)
              {
                unint64_t v504 = (void *)(v503 + v497);
                if (v503 + v497 >= v448) {
                  break;
                }
                uint64_t v505 = *(void *)(v20 + 12 - v114 + v497);
                v497 += 8;
                unint64_t v506 = *v504 ^ v505;
                if (v506)
                {
                  unint64_t v498 = v497 + (__clz(__rbit64(v506)) >> 3);
                  goto LABEL_695;
                }
              }
              unsigned int v499 = (_DWORD *)(v20 + v497 + 12);
              uint64_t v496 = (void *)((char *)v499 - v114);
            }
            if ((unint64_t)v499 < v753 && *(_DWORD *)v496 == *v499)
            {
              ++v499;
              uint64_t v496 = (void *)((char *)v496 + 4);
            }
            if ((unint64_t)v499 < v745 && *(unsigned __int16 *)v496 == *(unsigned __int16 *)v499)
            {
              unsigned int v499 = (_DWORD *)((char *)v499 + 2);
              uint64_t v496 = (void *)((char *)v496 + 2);
            }
            if ((unint64_t)v499 < v758 && *(unsigned __int8 *)v496 == *(unsigned __int8 *)v499) {
              unsigned int v499 = (_DWORD *)((char *)v499 + 1);
            }
            unint64_t v498 = (char *)v499 - v495;
LABEL_695:
            *(_DWORD *)(v446 + 4 * ((0xCF1BBCDCBB000000 * *(void *)v20) >> v447)) = v20 - v430;
            long long v500 = *(_OWORD **)(a2 + 24);
            if (v20 <= (unint64_t)v449)
            {
              *long long v500 = *(_OWORD *)v20;
            }
            else
            {
              sub_1DD29DBFC(v500, (char *)v20, v20, v449);
              unint64_t v449 = v729;
              unint64_t v448 = v737;
              unint64_t v439 = v721;
            }
            uint64_t v501 = *(void *)(a2 + 8);
            *(_WORD *)(v501 + 4) = 0;
            *(_DWORD *)uint64_t v501 = 1;
            if (v498 + 1 >= 0x10000)
            {
              unint64_t v502 = (unint64_t)(v501 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v502;
            }
            v20 += v498 + 4;
            *(_WORD *)(v501 + 6) = v498 + 1;
            *(void *)(a2 + 8) = v501 + 8;
            uint64_t v114 = v113;
            uint64_t v143 = v494;
            if (v20 > v439) {
              goto LABEL_713;
            }
          }
          uint64_t v143 = v113;
          uint64_t v113 = v114;
        }
        else
        {
          uint64_t v113 = 0;
        }
      }
      else
      {
        uint64_t v113 = v114;
      }
LABEL_713:
      _X10 = (int *)(v20 + 3);
      uint64_t v114 = v143;
      a4 = v20;
      if (v20 + 3 >= v439) {
        goto LABEL_948;
      }
    }
  }
  if (v5 == 6)
  {
    uint64_t v512 = *(void *)(a1 + 8);
    unint64_t v513 = a4 + a5;
    int v514 = a4 + a5 - v512;
    unsigned int v515 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v516 = *(_DWORD *)(a1 + 24);
    BOOL v517 = v514 - v516 > v515;
    unsigned int v518 = v514 - v515;
    BOOL v519 = *(_DWORD *)(a1 + 40) == 0;
    if (v519 && v517) {
      uint64_t v520 = v518;
    }
    else {
      uint64_t v520 = v516;
    }
    unint64_t v521 = v513 - 8;
    unsigned int v523 = *a3;
    unsigned int v522 = a3[1];
    if (v512 + v520 == a4) {
      unint64_t v20 = a4 + 1;
    }
    else {
      unint64_t v20 = a4;
    }
    BOOL v524 = v20 - v512 - v516 > v515;
    int v525 = v20 - v512 - v515;
    if (!v519 || !v524) {
      int v525 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v526 = v20 - v512 - v525;
    if (v522 <= v526) {
      uint64_t v113 = v522;
    }
    else {
      uint64_t v113 = 0;
    }
    if (v523 <= v526) {
      uint64_t v114 = v523;
    }
    else {
      uint64_t v114 = 0;
    }
    _X10 = (int *)(v20 + 3);
    unint64_t v758 = v513;
    unsigned int v705 = *a3;
    unsigned int v707 = a3[1];
    unsigned int v703 = v20 - v512 - v525;
    if (v20 + 3 >= v521) {
      goto LABEL_831;
    }
    unsigned int v714 = v520;
    unint64_t v722 = v513 - 8;
    uint64_t v528 = *(void *)(a1 + 112);
    LODWORD(v529) = 64 - *(_DWORD *)(a1 + 264);
    unint64_t v530 = v513 - 7;
    unint64_t v746 = v513 - 1;
    unint64_t v754 = v513 - 3;
    unint64_t v531 = (char *)(v513 - 32);
    unint64_t v692 = v512 + v520;
    v730 = (char *)(v513 - 32);
    unint64_t v738 = v513 - 7;
    char v696 = v529;
    while (1)
    {
      uint64_t v532 = (_DWORD *)(v20 + 2);
      int v534 = (int *)(v20 + 1);
      uint64_t v533 = *(void *)(v20 + 1);
      unint64_t v535 = v20 + 128;
      unint64_t v536 = (0xCF1BBCDCBF9B0000 * *(void *)v20) >> v529;
      LODWORD(v537) = *(_DWORD *)(v528 + 4 * v536);
      unint64_t v538 = 2;
      while (1)
      {
        unint64_t v539 = (0xCF1BBCDCBF9B0000 * v533) >> v529;
        int v540 = *(_DWORD *)((char *)v532 - v114);
        unsigned int v541 = v20 - v512;
        *(_DWORD *)(v528 + 4 * v536) = v20 - v512;
        if (v114 && *v532 == v540)
        {
          BOOL v550 = *((unsigned __int8 *)v532 - 1) == *((unsigned __int8 *)v532 - v114 - 1);
          if (*((unsigned __int8 *)v532 - 1) == *((unsigned __int8 *)v532 - v114 - 1)) {
            uint64_t v551 = 5;
          }
          else {
            uint64_t v551 = 4;
          }
          int v552 = v534 - v512;
          int v534 = (_DWORD *)((char *)v532 - v550);
          uint64_t v553 = (unsigned __int8 *)((char *)v532 - v114 - v550);
          *(_DWORD *)(v528 + 4 * v539) = v552;
          int v554 = 1;
          uint64_t v143 = v114;
          uint64_t v114 = v113;
          goto LABEL_764;
        }
        if (v537 >= v714)
        {
          int v543 = *(_DWORD *)(v512 + v537);
          int v542 = *(_DWORD *)v20;
        }
        else
        {
          int v542 = *(_DWORD *)v20;
          int v543 = *(_DWORD *)v20 ^ 1;
        }
        if (v542 == v543)
        {
          LODWORD(v532) = v534;
          unint64_t v536 = v539;
          int v534 = (int *)v20;
          goto LABEL_754;
        }
        uint64_t v537 = *(unsigned int *)(v528 + 4 * v539);
        uint64_t v544 = *(void *)v532;
        unsigned int v541 = v534 - v512;
        *(_DWORD *)(v528 + 4 * v539) = v534 - v512;
        if (v537 >= v714)
        {
          int v546 = *(_DWORD *)(v512 + v537);
          int v545 = *v534;
        }
        else
        {
          int v545 = *v534;
          int v546 = *v534 ^ 1;
        }
        unint64_t v536 = (0xCF1BBCDCBF9B0000 * v544) >> v529;
        if (v545 == v546) {
          break;
        }
        LODWORD(v537) = *(_DWORD *)(v528 + 4 * v536);
        uint64_t v533 = *(void *)_X10;
        if ((unint64_t)v532 + v538 >= v535)
        {
          unint64_t v547 = v538 + 1;
          __asm
          {
            PRFM            #0, [X10,#0x40]
            PRFM            #0, [X10,#0x80]
          }
          v535 += 128;
        }
        else
        {
          unint64_t v547 = v538;
        }
        int v534 = _X10;
        unint64_t v20 = (unint64_t)v532;
        uint64_t v532 = (_DWORD *)((char *)v532 + v538);
        _X10 = (int *)((char *)_X10 + v538);
        unint64_t v538 = v547;
        if ((unint64_t)_X10 >= v521) {
          goto LABEL_831;
        }
      }
      if (v538 < 5) {
LABEL_754:
      }
        *(_DWORD *)(v528 + 4 * v536) = v532 - v512;
      uint64_t v553 = (unsigned __int8 *)(v512 + v537);
      uint64_t v143 = (v534 - v553);
      int v554 = v143 + 3;
      if ((unint64_t)v534 <= a4 || v537 <= v714)
      {
        uint64_t v551 = 4;
      }
      else
      {
        uint64_t v555 = (unsigned __int8 *)(v512 - 1 + v537);
        uint64_t v556 = (unsigned __int8 *)v534 - 1;
        uint64_t v551 = 4;
        while (*v556 == *v555)
        {
          ++v551;
          v557 = v555 - 1;
          uint64_t v558 = v556 - 1;
          if ((unint64_t)v555 > v692)
          {
            --v555;
            BOOL v62 = (unint64_t)v556-- > a4;
            if (v62) {
              continue;
            }
          }
          uint64_t v553 = v557 + 1;
          int v534 = (int *)(v558 + 1);
          goto LABEL_764;
        }
        uint64_t v553 = v555 + 1;
        int v534 = (int *)(v556 + 1);
      }
LABEL_764:
      v559 = (char *)v534 + v551;
      v560 = &v553[v551];
      if (v530 <= (unint64_t)v534 + v551)
      {
        uint64_t v563 = (int *)((char *)v534 + v551);
      }
      else
      {
        unint64_t v561 = *(void *)v559 ^ *(void *)v560;
        if (v561)
        {
          unint64_t v562 = __clz(__rbit64(v561)) >> 3;
          goto LABEL_778;
        }
        uint64_t v589 = 0;
        uint64_t v590 = (uint64_t)v534 + v551 + 8;
        while (1)
        {
          unint64_t v591 = (void *)(v590 + v589);
          if (v590 + v589 >= v530) {
            break;
          }
          uint64_t v592 = *(void *)&v553[v551 + 8 + v589];
          v589 += 8;
          unint64_t v593 = *v591 ^ v592;
          if (v593)
          {
            unint64_t v562 = v589 + (__clz(__rbit64(v593)) >> 3);
            goto LABEL_778;
          }
        }
        uint64_t v563 = (int *)((char *)v534 + v551 + v589 + 8);
        v560 = &v553[v551 + 8 + v589];
      }
      if ((unint64_t)v563 < v754 && *(_DWORD *)v560 == *v563)
      {
        ++v563;
        v560 += 4;
      }
      if ((unint64_t)v563 < v746 && *(unsigned __int16 *)v560 == *(unsigned __int16 *)v563)
      {
        uint64_t v563 = (_DWORD *)((char *)v563 + 2);
        v560 += 2;
      }
      if ((unint64_t)v563 < v758 && *v560 == *(unsigned __int8 *)v563) {
        uint64_t v563 = (_DWORD *)((char *)v563 + 1);
      }
      unint64_t v562 = (char *)v563 - v559;
LABEL_778:
      uint64_t v564 = (uint64_t)v534 - a4;
      v565 = *(_OWORD **)(a2 + 24);
      if (v534 <= (int *)v531)
      {
        _OWORD *v565 = *(_OWORD *)a4;
        uint64_t v568 = *(void *)(a2 + 24);
        if ((unint64_t)v564 <= 0x10)
        {
          *(void *)(a2 + 24) = v568 + v564;
          uint64_t v566 = *(void *)(a2 + 8);
          goto LABEL_789;
        }
        *(_OWORD *)(v568 + 16) = *(_OWORD *)(a4 + 16);
        if (v564 >= 33)
        {
          unint64_t v569 = v568 + v564;
          uint64_t v570 = (_OWORD *)(v568 + 32);
          uint64_t v571 = (long long *)(a4 + 48);
          do
          {
            *uint64_t v570 = *(v571 - 1);
            long long v572 = *v571;
            v571 += 2;
            v570[1] = v572;
            v570 += 2;
          }
          while ((unint64_t)v570 < v569);
        }
      }
      else
      {
        unint64_t v529 = v562;
        sub_1DD29DBFC(v565, (char *)a4, (unint64_t)v534, v531);
        unint64_t v562 = v529;
        LOBYTE(v529) = v696;
        unint64_t v521 = v722;
      }
      *(void *)(a2 + 24) += v564;
      uint64_t v566 = *(void *)(a2 + 8);
      if ((unint64_t)v564 >= 0x10000)
      {
        unint64_t v567 = (unint64_t)(v566 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v567;
      }
      unint64_t v531 = v730;
      unint64_t v530 = v738;
LABEL_789:
      unint64_t v573 = v562 + v551;
      *(_WORD *)(v566 + 4) = v564;
      *(_DWORD *)uint64_t v566 = v554;
      unint64_t v574 = v562 + v551 - 3;
      if (v574 >= 0x10000)
      {
        unint64_t v575 = (unint64_t)(v566 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v575;
      }
      *(_WORD *)(v566 + 6) = v574;
      *(void *)(a2 + 8) = v566 + 8;
      unint64_t v20 = (unint64_t)v534 + v573;
      if ((unint64_t)v534 + v573 <= v521)
      {
        *(_DWORD *)(v528 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v512 + 2 + v541)) >> v529)) = v541 + 2;
        *(_DWORD *)(v528 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)(v20 - 2)) >> v529)) = v20 - 2 - v512;
        if (v114)
        {
          uint64_t v576 = v143;
          while (1)
          {
            uint64_t v113 = v576;
            uint64_t v576 = v114;
            if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v114)) {
              break;
            }
            uint64_t v577 = (char *)(v20 + 4);
            uint64_t v578 = (void *)(v20 + 4 - v114);
            if (v530 <= v20 + 4)
            {
              uint64_t v581 = (_DWORD *)(v20 + 4);
            }
            else
            {
              unint64_t v579 = *(void *)v577 ^ *v578;
              if (v579)
              {
                unint64_t v580 = __clz(__rbit64(v579)) >> 3;
                goto LABEL_810;
              }
              unint64_t v585 = v20 + 12;
              while (1)
              {
                unint64_t v586 = (void *)(v585 + v579);
                if (v585 + v579 >= v530) {
                  break;
                }
                uint64_t v587 = *(void *)(v20 + 12 - v114 + v579);
                v579 += 8;
                unint64_t v588 = *v586 ^ v587;
                if (v588)
                {
                  unint64_t v580 = v579 + (__clz(__rbit64(v588)) >> 3);
                  goto LABEL_810;
                }
              }
              uint64_t v581 = (_DWORD *)(v20 + v579 + 12);
              uint64_t v578 = (void *)((char *)v581 - v114);
            }
            if ((unint64_t)v581 < v754 && *(_DWORD *)v578 == *v581)
            {
              ++v581;
              uint64_t v578 = (void *)((char *)v578 + 4);
            }
            if ((unint64_t)v581 < v746 && *(unsigned __int16 *)v578 == *(unsigned __int16 *)v581)
            {
              uint64_t v581 = (_DWORD *)((char *)v581 + 2);
              uint64_t v578 = (void *)((char *)v578 + 2);
            }
            if ((unint64_t)v581 < v758 && *(unsigned __int8 *)v578 == *(unsigned __int8 *)v581) {
              uint64_t v581 = (_DWORD *)((char *)v581 + 1);
            }
            unint64_t v580 = (char *)v581 - v577;
LABEL_810:
            *(_DWORD *)(v528 + 4 * ((0xCF1BBCDCBF9B0000 * *(void *)v20) >> v529)) = v20 - v512;
            uint64_t v582 = *(_OWORD **)(a2 + 24);
            if (v20 <= (unint64_t)v531)
            {
              *uint64_t v582 = *(_OWORD *)v20;
            }
            else
            {
              sub_1DD29DBFC(v582, (char *)v20, v20, v531);
              unint64_t v531 = v730;
              unint64_t v530 = v738;
              unint64_t v521 = v722;
            }
            uint64_t v583 = *(void *)(a2 + 8);
            *(_WORD *)(v583 + 4) = 0;
            *(_DWORD *)uint64_t v583 = 1;
            if (v580 + 1 >= 0x10000)
            {
              unint64_t v584 = (unint64_t)(v583 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v584;
            }
            v20 += v580 + 4;
            *(_WORD *)(v583 + 6) = v580 + 1;
            *(void *)(a2 + 8) = v583 + 8;
            uint64_t v114 = v113;
            uint64_t v143 = v576;
            if (v20 > v521) {
              goto LABEL_828;
            }
          }
          uint64_t v143 = v113;
          uint64_t v113 = v114;
        }
        else
        {
          uint64_t v113 = 0;
        }
      }
      else
      {
        uint64_t v113 = v114;
      }
LABEL_828:
      _X10 = (int *)(v20 + 3);
      uint64_t v114 = v143;
      a4 = v20;
      if (v20 + 3 >= v521) {
        goto LABEL_948;
      }
    }
  }
  if (v5 != 7)
  {
    uint64_t v594 = *(void *)(a1 + 8);
    unint64_t v595 = a4 + a5;
    int v596 = a4 + a5 - v594;
    unsigned int v597 = 1 << *(_DWORD *)(a1 + 256);
    unsigned int v598 = *(_DWORD *)(a1 + 24);
    BOOL v599 = v596 - v598 > v597;
    unsigned int v600 = v596 - v597;
    BOOL v601 = *(_DWORD *)(a1 + 40) == 0;
    if (v601 && v599) {
      uint64_t v602 = v600;
    }
    else {
      uint64_t v602 = v598;
    }
    unint64_t v603 = v595 - 8;
    unsigned int v605 = *a3;
    unsigned int v604 = a3[1];
    if (v594 + v602 == a4) {
      unint64_t v20 = a4 + 1;
    }
    else {
      unint64_t v20 = a4;
    }
    BOOL v606 = v20 - v594 - v598 > v597;
    int v607 = v20 - v594 - v597;
    if (!v601 || !v606) {
      int v607 = *(_DWORD *)(a1 + 24);
    }
    unsigned int v608 = v20 - v594 - v607;
    if (v604 <= v608) {
      uint64_t v113 = v604;
    }
    else {
      uint64_t v113 = 0;
    }
    if (v605 <= v608) {
      uint64_t v609 = v605;
    }
    else {
      uint64_t v609 = 0;
    }
    _X10 = (int *)(v20 + 3);
    unint64_t v758 = v595;
    unsigned int v705 = *a3;
    unsigned int v707 = a3[1];
    unsigned int v703 = v20 - v594 - v607;
    if (v20 + 3 >= v603)
    {
LABEL_947:
      unint64_t v20 = a4;
      LODWORD(v143) = v609;
      goto LABEL_948;
    }
    unsigned int v715 = v602;
    unint64_t v723 = v595 - 8;
    uint64_t v611 = *(void *)(a1 + 112);
    LODWORD(v612) = 32 - *(_DWORD *)(a1 + 264);
    unint64_t v613 = v595 - 7;
    unint64_t v747 = v595 - 1;
    unint64_t v755 = v595 - 3;
    char v614 = (char *)(v595 - 32);
    unint64_t v693 = v594 + v602;
    v731 = (char *)(v595 - 32);
    unint64_t v739 = v595 - 7;
    char v697 = v612;
    while (1)
    {
      char v615 = (int *)(v20 + 2);
      char v617 = (int *)(v20 + 1);
      int v616 = *(_DWORD *)(v20 + 1);
      unint64_t v618 = v20 + 128;
      uint64_t v619 = (-1640531535 * *(_DWORD *)v20) >> v612;
      LODWORD(v620) = *(_DWORD *)(v611 + 4 * v619);
      unint64_t v621 = 2;
      while (1)
      {
        uint64_t v622 = (-1640531535 * v616) >> v612;
        int v623 = *(int *)((char *)v615 - v609);
        unsigned int v624 = v20 - v594;
        *(_DWORD *)(v611 + 4 * v619) = v20 - v594;
        int v625 = *v615;
        if (v609 && v625 == v623)
        {
          BOOL v633 = *((unsigned __int8 *)v615 - 1) == *((unsigned __int8 *)v615 - v609 - 1);
          if (*((unsigned __int8 *)v615 - 1) == *((unsigned __int8 *)v615 - v609 - 1)) {
            uint64_t v634 = 5;
          }
          else {
            uint64_t v634 = 4;
          }
          int v635 = v617 - v594;
          char v617 = (int *)((char *)v615 - v633);
          int v636 = (unsigned __int8 *)((char *)v615 - v609 - v633);
          *(_DWORD *)(v611 + 4 * v622) = v635;
          int v637 = 1;
          uint64_t v143 = v609;
          uint64_t v609 = v113;
          goto LABEL_880;
        }
        if (v620 >= v715)
        {
          int v627 = *(_DWORD *)(v594 + v620);
          int v626 = *(_DWORD *)v20;
        }
        else
        {
          int v626 = *(_DWORD *)v20;
          int v627 = *(_DWORD *)v20 ^ 1;
        }
        if (v626 == v627)
        {
          LODWORD(v615) = v617;
          uint64_t v619 = v622;
          char v617 = (int *)v20;
          goto LABEL_870;
        }
        uint64_t v620 = *(unsigned int *)(v611 + 4 * v622);
        unsigned int v624 = v617 - v594;
        *(_DWORD *)(v611 + 4 * v622) = v617 - v594;
        if (v620 >= v715)
        {
          int v629 = *(_DWORD *)(v594 + v620);
          int v628 = *v617;
        }
        else
        {
          int v628 = *v617;
          int v629 = *v617 ^ 1;
        }
        uint64_t v619 = (-1640531535 * v625) >> v612;
        if (v628 == v629) {
          break;
        }
        LODWORD(v620) = *(_DWORD *)(v611 + 4 * v619);
        int v616 = *_X10;
        if ((unint64_t)v615 + v621 >= v618)
        {
          unint64_t v630 = v621 + 1;
          __asm
          {
            PRFM            #0, [X10,#0x40]
            PRFM            #0, [X10,#0x80]
          }
          v618 += 128;
        }
        else
        {
          unint64_t v630 = v621;
        }
        char v617 = _X10;
        unint64_t v20 = (unint64_t)v615;
        char v615 = (int *)((char *)v615 + v621);
        _X10 = (int *)((char *)_X10 + v621);
        unint64_t v621 = v630;
        if ((unint64_t)_X10 >= v603) {
          goto LABEL_947;
        }
      }
      if (v621 < 5) {
LABEL_870:
      }
        *(_DWORD *)(v611 + 4 * v619) = v615 - v594;
      int v636 = (unsigned __int8 *)(v594 + v620);
      uint64_t v143 = (v617 - v636);
      int v637 = v143 + 3;
      if ((unint64_t)v617 <= a4 || v620 <= v715)
      {
        uint64_t v634 = 4;
      }
      else
      {
        v638 = (unsigned __int8 *)(v594 - 1 + v620);
        v639 = (unsigned __int8 *)v617 - 1;
        uint64_t v634 = 4;
        while (*v639 == *v638)
        {
          ++v634;
          v640 = v638 - 1;
          v641 = v639 - 1;
          if ((unint64_t)v638 > v693)
          {
            --v638;
            BOOL v62 = (unint64_t)v639-- > a4;
            if (v62) {
              continue;
            }
          }
          int v636 = v640 + 1;
          char v617 = (int *)(v641 + 1);
          goto LABEL_880;
        }
        int v636 = v638 + 1;
        char v617 = (int *)(v639 + 1);
      }
LABEL_880:
      int v642 = (char *)v617 + v634;
      int v643 = &v636[v634];
      if (v613 <= (unint64_t)v617 + v634)
      {
        char v646 = (int *)((char *)v617 + v634);
      }
      else
      {
        unint64_t v644 = *(void *)v642 ^ *(void *)v643;
        if (v644)
        {
          unint64_t v645 = __clz(__rbit64(v644)) >> 3;
          goto LABEL_894;
        }
        uint64_t v672 = 0;
        uint64_t v673 = (uint64_t)v617 + v634 + 8;
        while (1)
        {
          v674 = (void *)(v673 + v672);
          if (v673 + v672 >= v613) {
            break;
          }
          uint64_t v675 = *(void *)&v636[v634 + 8 + v672];
          v672 += 8;
          unint64_t v676 = *v674 ^ v675;
          if (v676)
          {
            unint64_t v645 = v672 + (__clz(__rbit64(v676)) >> 3);
            goto LABEL_894;
          }
        }
        char v646 = (int *)((char *)v617 + v634 + v672 + 8);
        int v643 = &v636[v634 + 8 + v672];
      }
      if ((unint64_t)v646 < v755 && *(_DWORD *)v643 == *v646)
      {
        ++v646;
        v643 += 4;
      }
      if ((unint64_t)v646 < v747 && *(unsigned __int16 *)v643 == *(unsigned __int16 *)v646)
      {
        char v646 = (_DWORD *)((char *)v646 + 2);
        v643 += 2;
      }
      if ((unint64_t)v646 < v758 && *v643 == *(unsigned __int8 *)v646) {
        char v646 = (_DWORD *)((char *)v646 + 1);
      }
      unint64_t v645 = (char *)v646 - v642;
LABEL_894:
      uint64_t v647 = (uint64_t)v617 - a4;
      char v648 = *(_OWORD **)(a2 + 24);
      if (v617 <= (int *)v614)
      {
        *char v648 = *(_OWORD *)a4;
        uint64_t v651 = *(void *)(a2 + 24);
        if ((unint64_t)v647 <= 0x10)
        {
          *(void *)(a2 + 24) = v651 + v647;
          uint64_t v649 = *(void *)(a2 + 8);
          goto LABEL_905;
        }
        *(_OWORD *)(v651 + 16) = *(_OWORD *)(a4 + 16);
        if (v647 >= 33)
        {
          unint64_t v652 = v651 + v647;
          uint64_t v653 = (_OWORD *)(v651 + 32);
          char v654 = (long long *)(a4 + 48);
          do
          {
            *uint64_t v653 = *(v654 - 1);
            long long v655 = *v654;
            v654 += 2;
            v653[1] = v655;
            v653 += 2;
          }
          while ((unint64_t)v653 < v652);
        }
      }
      else
      {
        unint64_t v612 = v645;
        sub_1DD29DBFC(v648, (char *)a4, (unint64_t)v617, v614);
        unint64_t v645 = v612;
        LOBYTE(v612) = v697;
        unint64_t v603 = v723;
      }
      *(void *)(a2 + 24) += v647;
      uint64_t v649 = *(void *)(a2 + 8);
      if ((unint64_t)v647 >= 0x10000)
      {
        unint64_t v650 = (unint64_t)(v649 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v650;
      }
      char v614 = v731;
      unint64_t v613 = v739;
LABEL_905:
      unint64_t v656 = v645 + v634;
      *(_WORD *)(v649 + 4) = v647;
      *(_DWORD *)uint64_t v649 = v637;
      unint64_t v657 = v645 + v634 - 3;
      if (v657 >= 0x10000)
      {
        unint64_t v658 = (unint64_t)(v649 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v658;
      }
      *(_WORD *)(v649 + 6) = v657;
      *(void *)(a2 + 8) = v649 + 8;
      unint64_t v20 = (unint64_t)v617 + v656;
      if ((unint64_t)v617 + v656 <= v603)
      {
        *(_DWORD *)(v611 + 4 * ((-1640531535 * *(_DWORD *)(v594 + 2 + v624)) >> v612)) = v624 + 2;
        *(_DWORD *)(v611 + 4 * ((-1640531535 * *(_DWORD *)(v20 - 2)) >> v612)) = v20 - 2 - v594;
        if (v609)
        {
          uint64_t v659 = v143;
          while (1)
          {
            uint64_t v113 = v659;
            uint64_t v659 = v609;
            if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v609)) {
              break;
            }
            uint64_t v660 = (char *)(v20 + 4);
            uint64_t v661 = (void *)(v20 + 4 - v609);
            if (v613 <= v20 + 4)
            {
              unint64_t v664 = (_DWORD *)(v20 + 4);
            }
            else
            {
              unint64_t v662 = *(void *)v660 ^ *v661;
              if (v662)
              {
                unint64_t v663 = __clz(__rbit64(v662)) >> 3;
                goto LABEL_926;
              }
              unint64_t v668 = v20 + 12;
              while (1)
              {
                v669 = (void *)(v668 + v662);
                if (v668 + v662 >= v613) {
                  break;
                }
                uint64_t v670 = *(void *)(v20 + 12 - v609 + v662);
                v662 += 8;
                unint64_t v671 = *v669 ^ v670;
                if (v671)
                {
                  unint64_t v663 = v662 + (__clz(__rbit64(v671)) >> 3);
                  goto LABEL_926;
                }
              }
              unint64_t v664 = (_DWORD *)(v20 + v662 + 12);
              uint64_t v661 = (void *)((char *)v664 - v609);
            }
            if ((unint64_t)v664 < v755 && *(_DWORD *)v661 == *v664)
            {
              ++v664;
              uint64_t v661 = (void *)((char *)v661 + 4);
            }
            if ((unint64_t)v664 < v747 && *(unsigned __int16 *)v661 == *(unsigned __int16 *)v664)
            {
              unint64_t v664 = (_DWORD *)((char *)v664 + 2);
              uint64_t v661 = (void *)((char *)v661 + 2);
            }
            if ((unint64_t)v664 < v758 && *(unsigned __int8 *)v661 == *(unsigned __int8 *)v664) {
              unint64_t v664 = (_DWORD *)((char *)v664 + 1);
            }
            unint64_t v663 = (char *)v664 - v660;
LABEL_926:
            *(_DWORD *)(v611 + 4 * ((-1640531535 * *(_DWORD *)v20) >> v612)) = v20 - v594;
            unint64_t v665 = *(_OWORD **)(a2 + 24);
            if (v20 <= (unint64_t)v614)
            {
              *unint64_t v665 = *(_OWORD *)v20;
            }
            else
            {
              sub_1DD29DBFC(v665, (char *)v20, v20, v614);
              char v614 = v731;
              unint64_t v613 = v739;
              unint64_t v603 = v723;
            }
            uint64_t v666 = *(void *)(a2 + 8);
            *(_WORD *)(v666 + 4) = 0;
            *(_DWORD *)uint64_t v666 = 1;
            if (v663 + 1 >= 0x10000)
            {
              unint64_t v667 = (unint64_t)(v666 - *(void *)a2) >> 3;
              *(_DWORD *)(a2 + 72) = 2;
              *(_DWORD *)(a2 + 76) = v667;
            }
            v20 += v663 + 4;
            *(_WORD *)(v666 + 6) = v663 + 1;
            *(void *)(a2 + 8) = v666 + 8;
            uint64_t v609 = v113;
            uint64_t v143 = v659;
            if (v20 > v603) {
              goto LABEL_944;
            }
          }
          uint64_t v143 = v113;
          uint64_t v113 = v609;
        }
        else
        {
          uint64_t v113 = 0;
        }
      }
      else
      {
        uint64_t v113 = v609;
      }
LABEL_944:
      _X10 = (int *)(v20 + 3);
      uint64_t v609 = v143;
      a4 = v20;
      if (v20 + 3 >= v603) {
        goto LABEL_948;
      }
    }
  }
  uint64_t v98 = *(void *)(a1 + 8);
  unint64_t v99 = a4 + a5;
  int v100 = a4 + a5 - v98;
  unsigned int v101 = 1 << *(_DWORD *)(a1 + 256);
  unsigned int v102 = *(_DWORD *)(a1 + 24);
  BOOL v103 = v100 - v102 > v101;
  unsigned int v104 = v100 - v101;
  BOOL v105 = *(_DWORD *)(a1 + 40) == 0;
  if (v105 && v103) {
    uint64_t v106 = v104;
  }
  else {
    uint64_t v106 = v102;
  }
  unint64_t v107 = v99 - 8;
  unsigned int v109 = *a3;
  unsigned int v108 = a3[1];
  if (v98 + v106 == a4) {
    unint64_t v20 = a4 + 1;
  }
  else {
    unint64_t v20 = a4;
  }
  BOOL v110 = v20 - v98 - v102 > v101;
  int v111 = v20 - v98 - v101;
  if (!v105 || !v110) {
    int v111 = *(_DWORD *)(a1 + 24);
  }
  unsigned int v112 = v20 - v98 - v111;
  if (v108 <= v112) {
    uint64_t v113 = v108;
  }
  else {
    uint64_t v113 = 0;
  }
  if (v109 <= v112) {
    uint64_t v114 = v109;
  }
  else {
    uint64_t v114 = 0;
  }
  _X10 = (int *)(v20 + 3);
  unint64_t v758 = v99;
  unsigned int v705 = *a3;
  unsigned int v707 = a3[1];
  unsigned int v703 = v20 - v98 - v111;
  if (v20 + 3 >= v107)
  {
LABEL_831:
    unint64_t v20 = a4;
    LODWORD(v143) = v114;
    goto LABEL_948;
  }
  unsigned int v709 = v106;
  unint64_t v717 = v99 - 8;
  uint64_t v116 = *(void *)(a1 + 112);
  LODWORD(v117) = 64 - *(_DWORD *)(a1 + 264);
  unint64_t v118 = v99 - 7;
  unint64_t v741 = v99 - 1;
  unint64_t v749 = v99 - 3;
  unint64_t v119 = (char *)(v99 - 32);
  unint64_t v687 = v98 + v106;
  v725 = (char *)(v99 - 32);
  unint64_t v733 = v99 - 7;
  char v694 = v117;
  do
  {
    unint64_t v120 = (_DWORD *)(v20 + 2);
    unint64_t v122 = (int *)(v20 + 1);
    uint64_t v121 = *(void *)(v20 + 1);
    unint64_t v123 = v20 + 128;
    unint64_t v124 = (0xCF1BBCDCBFA56300 * *(void *)v20) >> v117;
    LODWORD(v125) = *(_DWORD *)(v116 + 4 * v124);
    unint64_t v126 = 2;
    while (1)
    {
      unint64_t v127 = (0xCF1BBCDCBFA56300 * v121) >> v117;
      int v128 = *(_DWORD *)((char *)v120 - v114);
      unsigned int v129 = v20 - v98;
      *(_DWORD *)(v116 + 4 * v124) = v20 - v98;
      if (v114 && *v120 == v128)
      {
        BOOL v138 = *((unsigned __int8 *)v120 - 1) == *((unsigned __int8 *)v120 - v114 - 1);
        if (*((unsigned __int8 *)v120 - 1) == *((unsigned __int8 *)v120 - v114 - 1)) {
          uint64_t v139 = 5;
        }
        else {
          uint64_t v139 = 4;
        }
        int v140 = v122 - v98;
        unint64_t v122 = (_DWORD *)((char *)v120 - v138);
        unint64_t v141 = (unsigned __int8 *)((char *)v120 - v114 - v138);
        *(_DWORD *)(v116 + 4 * v127) = v140;
        int v142 = 1;
        uint64_t v143 = v114;
        uint64_t v114 = v113;
        goto LABEL_171;
      }
      if (v125 >= v709)
      {
        int v131 = *(_DWORD *)(v98 + v125);
        int v130 = *(_DWORD *)v20;
      }
      else
      {
        int v130 = *(_DWORD *)v20;
        int v131 = *(_DWORD *)v20 ^ 1;
      }
      if (v130 == v131)
      {
        LODWORD(v120) = v122;
        unint64_t v124 = v127;
        unint64_t v122 = (int *)v20;
        goto LABEL_161;
      }
      uint64_t v125 = *(unsigned int *)(v116 + 4 * v127);
      uint64_t v132 = *(void *)v120;
      unsigned int v129 = v122 - v98;
      *(_DWORD *)(v116 + 4 * v127) = v122 - v98;
      if (v125 >= v709)
      {
        int v134 = *(_DWORD *)(v98 + v125);
        int v133 = *v122;
      }
      else
      {
        int v133 = *v122;
        int v134 = *v122 ^ 1;
      }
      unint64_t v124 = (0xCF1BBCDCBFA56300 * v132) >> v117;
      if (v133 == v134) {
        break;
      }
      LODWORD(v125) = *(_DWORD *)(v116 + 4 * v124);
      uint64_t v121 = *(void *)_X10;
      if ((unint64_t)v120 + v126 >= v123)
      {
        unint64_t v135 = v126 + 1;
        __asm
        {
          PRFM            #0, [X10,#0x40]
          PRFM            #0, [X10,#0x80]
        }
        v123 += 128;
      }
      else
      {
        unint64_t v135 = v126;
      }
      unint64_t v122 = _X10;
      unint64_t v20 = (unint64_t)v120;
      unint64_t v120 = (_DWORD *)((char *)v120 + v126);
      _X10 = (int *)((char *)_X10 + v126);
      unint64_t v126 = v135;
      if ((unint64_t)_X10 >= v107) {
        goto LABEL_831;
      }
    }
    if (v126 >= 5) {
      goto LABEL_162;
    }
LABEL_161:
    *(_DWORD *)(v116 + 4 * v124) = v120 - v98;
LABEL_162:
    unint64_t v141 = (unsigned __int8 *)(v98 + v125);
    uint64_t v143 = (v122 - v141);
    int v142 = v143 + 3;
    if ((unint64_t)v122 <= a4 || v125 <= v709)
    {
      uint64_t v139 = 4;
    }
    else
    {
      unint64_t v144 = (unsigned __int8 *)(v98 - 1 + v125);
      uint64_t v145 = (unsigned __int8 *)v122 - 1;
      uint64_t v139 = 4;
      while (*v145 == *v144)
      {
        ++v139;
        int v146 = v144 - 1;
        uint64_t v147 = v145 - 1;
        if ((unint64_t)v144 > v687)
        {
          --v144;
          BOOL v62 = (unint64_t)v145-- > a4;
          if (v62) {
            continue;
          }
        }
        unint64_t v141 = v146 + 1;
        unint64_t v122 = (int *)(v147 + 1);
        goto LABEL_171;
      }
      unint64_t v141 = v144 + 1;
      unint64_t v122 = (int *)(v145 + 1);
    }
LABEL_171:
    char v148 = (char *)v122 + v139;
    uint64_t v149 = &v141[v139];
    if (v118 <= (unint64_t)v122 + v139)
    {
      unint64_t v152 = (int *)((char *)v122 + v139);
    }
    else
    {
      unint64_t v150 = *(void *)v148 ^ *(void *)v149;
      if (v150)
      {
        unint64_t v151 = __clz(__rbit64(v150)) >> 3;
        goto LABEL_185;
      }
      uint64_t v178 = 0;
      uint64_t v179 = (uint64_t)v122 + v139 + 8;
      while (1)
      {
        unint64_t v180 = (void *)(v179 + v178);
        if (v179 + v178 >= v118) {
          break;
        }
        uint64_t v181 = *(void *)&v141[v139 + 8 + v178];
        v178 += 8;
        unint64_t v182 = *v180 ^ v181;
        if (v182)
        {
          unint64_t v151 = v178 + (__clz(__rbit64(v182)) >> 3);
          goto LABEL_185;
        }
      }
      unint64_t v152 = (int *)((char *)v122 + v139 + v178 + 8);
      uint64_t v149 = &v141[v139 + 8 + v178];
    }
    if ((unint64_t)v152 < v749 && *(_DWORD *)v149 == *v152)
    {
      ++v152;
      v149 += 4;
    }
    if ((unint64_t)v152 < v741 && *(unsigned __int16 *)v149 == *(unsigned __int16 *)v152)
    {
      unint64_t v152 = (_DWORD *)((char *)v152 + 2);
      v149 += 2;
    }
    if ((unint64_t)v152 < v758 && *v149 == *(unsigned __int8 *)v152) {
      unint64_t v152 = (_DWORD *)((char *)v152 + 1);
    }
    unint64_t v151 = (char *)v152 - v148;
LABEL_185:
    uint64_t v153 = (uint64_t)v122 - a4;
    int v154 = *(_OWORD **)(a2 + 24);
    if (v122 > (int *)v119)
    {
      unint64_t v117 = v151;
      sub_1DD29DBFC(v154, (char *)a4, (unint64_t)v122, v119);
      unint64_t v151 = v117;
      LOBYTE(v117) = v694;
      unint64_t v107 = v717;
LABEL_187:
      *(void *)(a2 + 24) += v153;
      uint64_t v155 = *(void *)(a2 + 8);
      if ((unint64_t)v153 >= 0x10000)
      {
        unint64_t v156 = (unint64_t)(v155 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 1;
        *(_DWORD *)(a2 + 76) = v156;
      }
      unint64_t v119 = v725;
      unint64_t v118 = v733;
      goto LABEL_196;
    }
    *int v154 = *(_OWORD *)a4;
    uint64_t v157 = *(void *)(a2 + 24);
    if ((unint64_t)v153 > 0x10)
    {
      *(_OWORD *)(v157 + 16) = *(_OWORD *)(a4 + 16);
      if (v153 >= 33)
      {
        unint64_t v158 = v157 + v153;
        unint64_t v159 = (_OWORD *)(v157 + 32);
        uint64_t v160 = (long long *)(a4 + 48);
        do
        {
          *unint64_t v159 = *(v160 - 1);
          long long v161 = *v160;
          v160 += 2;
          v159[1] = v161;
          v159 += 2;
        }
        while ((unint64_t)v159 < v158);
      }
      goto LABEL_187;
    }
    *(void *)(a2 + 24) = v157 + v153;
    uint64_t v155 = *(void *)(a2 + 8);
LABEL_196:
    unint64_t v162 = v151 + v139;
    *(_WORD *)(v155 + 4) = v153;
    *(_DWORD *)uint64_t v155 = v142;
    unint64_t v163 = v151 + v139 - 3;
    if (v163 >= 0x10000)
    {
      unint64_t v164 = (unint64_t)(v155 - *(void *)a2) >> 3;
      *(_DWORD *)(a2 + 72) = 2;
      *(_DWORD *)(a2 + 76) = v164;
    }
    *(_WORD *)(v155 + 6) = v163;
    *(void *)(a2 + 8) = v155 + 8;
    unint64_t v20 = (unint64_t)v122 + v162;
    if ((unint64_t)v122 + v162 > v107)
    {
      uint64_t v113 = v114;
      goto LABEL_235;
    }
    *(_DWORD *)(v116 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v98 + 2 + v129)) >> v117)) = v129 + 2;
    *(_DWORD *)(v116 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)(v20 - 2)) >> v117)) = v20 - 2 - v98;
    if (!v114)
    {
      uint64_t v113 = 0;
      goto LABEL_235;
    }
    uint64_t v165 = v143;
    while (1)
    {
      uint64_t v113 = v165;
      uint64_t v165 = v114;
      if (*(_DWORD *)v20 != *(_DWORD *)(v20 - v114)) {
        break;
      }
      unsigned int v166 = (char *)(v20 + 4);
      int v167 = (_DWORD *)(v20 + 4 - v114);
      if (v118 <= v20 + 4)
      {
        unint64_t v170 = (_DWORD *)(v20 + 4);
LABEL_207:
        if ((unint64_t)v170 < v749 && *v167 == *v170)
        {
          ++v170;
          ++v167;
        }
        if ((unint64_t)v170 < v741 && *(unsigned __int16 *)v167 == *(unsigned __int16 *)v170)
        {
          unint64_t v170 = (_DWORD *)((char *)v170 + 2);
          int v167 = (_DWORD *)((char *)v167 + 2);
        }
        if ((unint64_t)v170 < v758 && *(unsigned __int8 *)v167 == *(unsigned __int8 *)v170) {
          unint64_t v170 = (_DWORD *)((char *)v170 + 1);
        }
        unint64_t v169 = (char *)v170 - v166;
        goto LABEL_217;
      }
      unint64_t v168 = *(void *)v166 ^ *(void *)v167;
      if (!v168)
      {
        unint64_t v174 = v20 + 12;
        while (1)
        {
          uint64_t v175 = (void *)(v174 + v168);
          if (v174 + v168 >= v118) {
            break;
          }
          uint64_t v176 = *(void *)(v20 + 12 - v114 + v168);
          v168 += 8;
          unint64_t v177 = *v175 ^ v176;
          if (v177)
          {
            unint64_t v169 = v168 + (__clz(__rbit64(v177)) >> 3);
            goto LABEL_217;
          }
        }
        unint64_t v170 = (_DWORD *)(v20 + v168 + 12);
        int v167 = (_DWORD *)((char *)v170 - v114);
        goto LABEL_207;
      }
      unint64_t v169 = __clz(__rbit64(v168)) >> 3;
LABEL_217:
      *(_DWORD *)(v116 + 4 * ((0xCF1BBCDCBFA56300 * *(void *)v20) >> v117)) = v20 - v98;
      unint64_t v171 = *(_OWORD **)(a2 + 24);
      if (v20 <= (unint64_t)v119)
      {
        *unint64_t v171 = *(_OWORD *)v20;
      }
      else
      {
        sub_1DD29DBFC(v171, (char *)v20, v20, v119);
        unint64_t v119 = v725;
        unint64_t v118 = v733;
        unint64_t v107 = v717;
      }
      uint64_t v172 = *(void *)(a2 + 8);
      *(_WORD *)(v172 + 4) = 0;
      *(_DWORD *)uint64_t v172 = 1;
      if (v169 + 1 >= 0x10000)
      {
        unint64_t v173 = (unint64_t)(v172 - *(void *)a2) >> 3;
        *(_DWORD *)(a2 + 72) = 2;
        *(_DWORD *)(a2 + 76) = v173;
      }
      v20 += v169 + 4;
      *(_WORD *)(v172 + 6) = v169 + 1;
      *(void *)(a2 + 8) = v172 + 8;
      uint64_t v114 = v113;
      uint64_t v143 = v165;
      if (v20 > v107) {
        goto LABEL_235;
      }
    }
    uint64_t v143 = v113;
    uint64_t v113 = v114;
LABEL_235:
    _X10 = (int *)(v20 + 3);
    uint64_t v114 = v143;
    a4 = v20;
  }
  while (v20 + 3 < v107);
LABEL_948:
  unsigned int v677 = v705;
  if (v705 <= v703) {
    unsigned int v677 = 0;
  }
  unsigned int v678 = v707;
  if (v707 <= v703) {
    unsigned int v678 = 0;
  }
  if (v143) {
    unsigned int v679 = v143;
  }
  else {
    unsigned int v679 = v677;
  }
  if (v143) {
    BOOL v680 = v677 == 0;
  }
  else {
    BOOL v680 = 1;
  }
  if (v680) {
    unsigned int v677 = v678;
  }
  if (v113) {
    unsigned int v677 = v113;
  }
  *a3 = v679;
  a3[1] = v677;
  unint64_t v9 = v758;
  return v9 - v20;
}