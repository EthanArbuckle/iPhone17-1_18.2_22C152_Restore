void *sub_19E4EFD7C(void *result, void *__dst, uint64_t a3)
{
  *((void *)result + 5) = atomic_fetch_add(&qword_1EC009428, 1uLL) + 1;
  if (a3) {
    return memmove(__dst, *((const void **)result + 6), 2 * a3);
  }
  return result;
}

void sub_19E4EFDB0(void *a1)
{
  *a1 = &unk_1EF0B9DB8;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    MEMORY[0x19F3BDCC0](v2, 0x1000C80BDFB0063);
  }
  *a1 = &unk_1EF0BAAE8;
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4EFE8C(void *a1)
{
  *a1 = &unk_1EF0B9DB8;
  uint64_t v2 = a1[6];
  a1[6] = 0;
  if (v2) {
    MEMORY[0x19F3BDCC0](v2, 0x1000C80BDFB0063);
  }
  *a1 = &unk_1EF0BAAE8;
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E4EFF58(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BE110;
  a2[1] = v2;
  return result;
}

void *sub_19E4EFF7C(uint64_t a1)
{
  result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BE110;
  result[1] = v3;
  return result;
}

void sub_19E4EFFC4()
{
}

__n128 sub_19E4EFFE4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BD980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E4F0014(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF0BD980;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E4F0068()
{
}

void *sub_19E4F0080(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_19E4F0104(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_19E4F0170()
{
  return &unk_1EF0B8138;
}

uint64_t sub_19E4F017C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_d"
                     "eleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEEUlvE_"
    || ((v3 & (unint64_t)"ZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_"
                                "14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8Resource"
                                "ERKNS_10ParametersEEUlvE_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEEUlvE_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEEUlvE_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E4F01D4()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19E4F04F0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_19E4F05D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v14)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  MEMORY[0x19F3BDCF0](v13, 0x10A1C405897D53FLL);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4F06EC(uint64_t a1)
{
  (*(void (**)(void))(**(void **)(a1 + 16) + 80))(*(void *)(a1 + 16));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(a1 + 8) + 80);
  return v2();
}

uint64_t sub_19E4F0768(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 72);
  return v4();
}

uint64_t sub_19E4F0814(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 64);
  return v4();
}

uint64_t sub_19E4F08D0()
{
  return 0;
}

uint64_t sub_19E4F08D8(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 48);
  return v4();
}

uint64_t sub_19E4F097C(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 40);
  return v4();
}

uint64_t sub_19E4F0A20(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 32);
  return v4();
}

uint64_t sub_19E4F0AC4(uint64_t a1)
{
  int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v3 = 8;
  if (v2) {
    uint64_t v3 = 16;
  }
  v4 = *(uint64_t (**)(void))(**(void **)(a1 + v3) + 24);
  return v4();
}

uint64_t sub_19E4F0B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  int v12 = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24));
  uint64_t v13 = *a4;
  if (v12)
  {
    uint64_t v14 = *(void *)(a1 + 16);
    *a4 = 0;
    uint64_t v20 = v13;
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v14 + 16))(v14, a2, a3, &v20, a5, a6);
    uint64_t v16 = v20;
    uint64_t v20 = 0;
    if (!v16) {
      return v15;
    }
    goto LABEL_5;
  }
  uint64_t v17 = *(void *)(a1 + 8);
  *a4 = 0;
  uint64_t v19 = v13;
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t))(*(void *)v17 + 16))(v17, a2, a3, &v19, a5, a6);
  uint64_t v16 = v19;
  uint64_t v19 = 0;
  if (v16) {
LABEL_5:
  }
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  return v15;
}

void sub_19E4F0CB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  if (a9) {
    (*(void (**)(uint64_t))(*(void *)a9 + 8))(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4F0CF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (!a10) {
    JUMPOUT(0x19E4F0CECLL);
  }
  JUMPOUT(0x19E4F0CC8);
}

void sub_19E4F0D08(void *a1)
{
  *a1 = &unk_1EF0BB118;
  int v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  a1[2] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4F0E10(void *a1)
{
  *a1 = &unk_1EF0BB118;
  int v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[2];
  a1[2] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[1];
  a1[1] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  return a1;
}

void *sub_19E4F0EF8()
{
  return &unk_1EF0B8338;
}

uint64_t sub_19E4F0F04(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_"
                     "deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEEN"
                     "KUlvE_clEvEUlvE0_"
    || ((v3 & (unint64_t)"ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1"
                                "_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8Resourc"
                                "eERKNS_10ParametersEENKUlvE_clEvEUlvE0_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE0_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE0_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E4F0F5C()
{
}

void sub_19E4F1000(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = atomic_fetch_add(&qword_1EC009428, 1uLL) + 1;
  v7 = (void **)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 48);
  *(void *)(a1 + 40) = v5;
  unint64_t v8 = (*(void *)(a1 + 64) - v6) >> 3;
  unint64_t v9 = (*(void *)(a1 + 56) - v6) >> 3;
  if (v8 <= v9)
  {
    if (v8 < v9) {
      *(void *)(a1 + 56) = v6 + 8 * v8;
    }
  }
  else
  {
    sub_19E4EC4BC((void **)(a1 + 48), v8 - v9);
  }
  v39 = v7;
  if (a3)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    while (1)
    {
      __asm { FCMP            H8, #0 }
      if (_NF ^ _VF | _ZF) {
        goto LABEL_9;
      }
      v18 = *(unsigned char **)(a1 + 48);
      uint64_t v19 = *(char **)(a1 + 56);
      unint64_t v20 = (v19 - v18) >> 3;
      if (v20 > v11)
      {
        int v12 = &v18[8 * v11];
        *(_DWORD *)int v12 = v10;
        *((_WORD *)v12 + 2) = _H8;
      }
      else
      {
        unint64_t v21 = *(void *)(a1 + 64);
        if ((unint64_t)v19 >= v21)
        {
          unint64_t v22 = v20 + 1;
          if ((v20 + 1) >> 61) {
            sub_19E37C7C4();
          }
          uint64_t v23 = v21 - (void)v18;
          if (v23 >> 2 > v22) {
            unint64_t v22 = v23 >> 2;
          }
          _CF = (unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8;
          unint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
          if (!_CF) {
            unint64_t v24 = v22;
          }
          if (v24 >> 61) {
            sub_19E37C2B8();
          }
          uint64_t v25 = 8 * v24;
          v26 = operator new(8 * v24);
          v27 = &v26[8 * v20];
          *(_DWORD *)v27 = v10;
          *((_WORD *)v27 + 2) = _H8;
          if (v19 == v18)
          {
            v29 = &v26[8 * v20];
          }
          else
          {
            unint64_t v28 = v19 - 8 - v18;
            if (v28 < 0x58)
            {
              v29 = &v26[8 * v20];
              goto LABEL_28;
            }
            v29 = &v26[8 * v20];
            if ((unint64_t)(v18 - v26) < 0x20) {
              goto LABEL_44;
            }
            uint64_t v30 = (v28 >> 3) + 1;
            v31 = &v26[8 * v20 - 16];
            v32 = v19 - 16;
            uint64_t v33 = v30 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v34 = *(_OWORD *)v32;
              *(v31 - 1) = *((_OWORD *)v32 - 1);
              _OWORD *v31 = v34;
              v31 -= 2;
              v32 -= 32;
              v33 -= 4;
            }
            while (v33);
            v29 = &v27[-8 * (v30 & 0x3FFFFFFFFFFFFFFCLL)];
            v19 -= 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
            if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_44:
              do
              {
LABEL_28:
                uint64_t v35 = *((void *)v19 - 1);
                v19 -= 8;
                *((void *)v29 - 1) = v35;
                v29 -= 8;
              }
              while (v19 != v18);
            }
          }
          v36 = v27 + 8;
          *(void *)(a1 + 48) = v29;
          *(void *)(a1 + 56) = v27 + 8;
          *(void *)(a1 + 64) = &v26[v25];
          if (v18) {
            operator delete(v18);
          }
          *(void *)(a1 + 56) = v36;
          goto LABEL_8;
        }
        *(_DWORD *)uint64_t v19 = v10;
        *((_WORD *)v19 + 2) = _H8;
        *(void *)(a1 + 56) = v19 + 8;
      }
LABEL_8:
      ++v11;
LABEL_9:
      if (++v10 == a3) {
        goto LABEL_33;
      }
    }
  }
  int v11 = 0;
LABEL_33:
  uint64_t v37 = *(void *)(a1 + 48);
  unint64_t v38 = (*(void *)(a1 + 56) - v37) >> 3;
  if (v11 <= v38)
  {
    if (v11 < v38) {
      *(void *)(a1 + 56) = v37 + 8 * v11;
    }
  }
  else
  {
    sub_19E4EC4BC(v39, v11 - v38);
  }
}

float sub_19E4F1298(void *a1, unsigned int a2)
{
  a1[5] = atomic_fetch_add(&qword_1EC009428, 1uLL) + 1;
  int v2 = (char *)a1[6];
  unint64_t v3 = (char *)a1[7];
  if (v3 != v2)
  {
    unint64_t v4 = (v3 - v2) >> 3;
    do
    {
      unint64_t v5 = v4 >> 1;
      uint64_t v6 = (unsigned int *)&v2[8 * (v4 >> 1)];
      unsigned int v8 = *v6;
      v7 = (char *)(v6 + 2);
      v4 += ~(v4 >> 1);
      if (v8 < a2) {
        int v2 = v7;
      }
      else {
        unint64_t v4 = v5;
      }
    }
    while (v4);
  }
  float result = 0.0;
  if (v2 != v3 && *(_DWORD *)v2 == a2)
  {
    _H0 = *((_WORD *)v2 + 2);
    __asm { FCVT            S0, H0 }
  }
  return result;
}

__int16 sub_19E4F1308@<H0>(void *a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>)
{
  a1[5] = atomic_fetch_add(&qword_1EC009428, 1uLL) + 1;
  if (2 * a3 >= 1) {
    bzero(a2, 2 * (((unint64_t)(2 * a3) >> 1) - (2 * a3 != 1)) + 2);
  }
  uint64_t v6 = (int *)a1[6];
  for (i = (int *)a1[7]; v6 != i; *((_WORD *)a2 + v8) = result)
  {
    __int16 result = *((_WORD *)v6 + 2);
    unsigned int v8 = *v6;
    v6 += 2;
  }
  return result;
}

void sub_19E4F138C(void *a1)
{
  *a1 = &unk_1EF0BA2B0;
  int v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  *a1 = &unk_1EF0BAAE8;
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4F1458(void *a1)
{
  *a1 = &unk_1EF0BA2B0;
  int v2 = (void *)a1[6];
  if (v2)
  {
    a1[7] = v2;
    operator delete(v2);
  }
  *a1 = &unk_1EF0BAAE8;
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  unint64_t v4 = (void *)a1[1];
  if (v4)
  {
    a1[2] = v4;
    operator delete(v4);
  }
  return a1;
}

void sub_19E4F150C(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BE060;
}

void *sub_19E4F152C()
{
  __int16 result = operator new(0x10uLL);
  void *result = &unk_1EF0BE060;
  return result;
}

void sub_19E4F1564()
{
}

uint64_t sub_19E4F157C()
{
  return 0;
}

uint64_t sub_19E4F1584(void *a1, char *a2, uint64_t a3)
{
  unsigned int v4 = sub_19E4EE334(a1, a2, a3);
  if ((v4 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1[2] + 8 * v4);
  *(void *)(v5 + 40) = atomic_fetch_add(&qword_1EC009428, 1uLL) + 1;
  return *(void *)(v5 + 32);
}

uint64_t sub_19E4F15D8(uint64_t a1, void *__src, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return 0;
  }
  uint64_t v7 = *a4;
  if (!*a4) {
    return 0;
  }
  unint64_t v9 = *(void **)(a1 + 16);
  uint64_t v10 = *(void **)(a1 + 24);
  if (v9 == v10 || a6 == 0) {
    return 0;
  }
  uint64_t v15 = 0;
  size_t v16 = 4 * a3;
  if ((unint64_t)(v10 - v9) <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v10 - v9;
  }
  while (1)
  {
    uint64_t v18 = v9[v15];
    uint64_t v19 = *(const void **)(v18 + 8);
    if (a3 == (uint64_t)(*(void *)(v18 + 16) - (void)v19) >> 2 && !memcmp(v19, __src, v16)) {
      break;
    }
    if (v17 == ++v15) {
      goto LABEL_16;
    }
  }
  if ((v15 & 0x80000000) == 0) {
    return 0;
  }
LABEL_16:
  unint64_t v20 = v9 + 1;
  if (v9 + 1 != v10)
  {
    unint64_t v21 = (void *)*v9;
    unint64_t v22 = v9 + 1;
    do
    {
      unint64_t v24 = (void *)*v22++;
      uint64_t v23 = v24;
      if (v24[5] < v21[5])
      {
        unint64_t v21 = v23;
        unint64_t v9 = v20;
      }
      unint64_t v20 = v22;
    }
    while (v22 != v10);
  }
  if (v9 == v10) {
    __assert_rtn("getOldestEntry", "LRUStateBaseCache.hpp", 31, "entryIterator != m_cache.end()");
  }
  uint64_t v25 = (void *)*v9;
  *a4 = 0;
  sub_19E494468(v25 + 1, (char *)__src, (char *)__src + v16, (4 * a3) >> 2);
  unint64_t add = atomic_fetch_add(&qword_1EC009428, 1uLL);
  uint64_t v27 = v25[4];
  v25[4] = v7;
  v25[5] = add + 1;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  (*(void (**)(void *, uint64_t, uint64_t))(*v25 + 32))(v25, a5, a6);
  return 1;
}

void sub_19E4F1798(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_19E4F17CC(void *a1)
{
  *a1 = &unk_1EF0BA6B0;
  int v2 = (void *)a1[2];
  if (v2)
  {
    uint64_t v3 = (void *)a1[3];
    unsigned int v4 = (void *)a1[2];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      unsigned int v4 = (void *)a1[2];
    }
    a1[3] = v2;
    operator delete(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4F1898(void *a1)
{
  *a1 = &unk_1EF0BA6B0;
  int v2 = (void *)a1[2];
  if (v2)
  {
    uint64_t v3 = (void *)a1[3];
    unsigned int v4 = (void *)a1[2];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      unsigned int v4 = (void *)a1[2];
    }
    a1[3] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E4F1944()
{
  return &unk_1EF0B8348;
}

uint64_t sub_19E4F1950(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_"
                     "deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEEN"
                     "KUlvE_clEvEUlvE_"
    || ((v3 & (unint64_t)"ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1"
                                "_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8Resourc"
                                "eERKNS_10ParametersEENKUlvE_clEvEUlvE_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN2LML23assembleSegregatedCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS1_10shared_ptrINS_21MontrealTokenIDMapperEEERKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E4F19A8()
{
}

void sub_19E4F1A80(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  uint64_t v5 = v1[4];
  v1[4] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *v3;
  if (*v3)
  {
    v1[2] = v6;
    operator delete(v6);
  }
  MEMORY[0x19F3BDCF0](v1, 0x10B1C40C560DF64);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4F1AF0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BE0B8;
  a2[1] = v2;
  return result;
}

void *sub_19E4F1B14(uint64_t a1)
{
  __int16 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BE0B8;
  result[1] = v3;
  return result;
}

void sub_19E4F1B5C()
{
}

void sub_19E4F1B74(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void sub_19E4F1BF0(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

__n128 sub_19E4F1C6C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BD928;
  *(_OWORD *)(a2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 32);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(void *)(a2 + 32) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(a2 + 40) = result;
  return result;
}

__n128 sub_19E4F1CB4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF0BD928;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 32);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  *((void *)v2 + 4) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void sub_19E4F1D20(void *a1)
{
  *a1 = &unk_1EF0BD928;
  uint64_t v1 = (std::__shared_weak_count *)a1[4];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4F1DC8(void *a1)
{
  *a1 = &unk_1EF0BD928;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void *sub_19E4F1E50()
{
  return &unk_1EF0B8128;
}

uint64_t sub_19E4F1E5C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_d"
                     "eleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEEUlvE_"
    || ((v3 & (unint64_t)"ZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_"
                                "14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEEUlvE_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEEUlvE_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEEUlvE_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E4F1EB4()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_19E4F1FF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v14)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  MEMORY[0x19F3BDCF0](v13, 0x10A1C405897D53FLL);
  _Unwind_Resume(a1);
}

void *sub_19E4F2080()
{
  return &unk_1EF0B8328;
}

uint64_t sub_19E4F208C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_"
                     "deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_"
    || ((v3 & (unint64_t)"ZZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1"
                                "_14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZZN2LML23assembleMonolithicCacheIDhEENSt3__110unique_ptrINS_18MontrealStateCacheIT_EENS1_14default_deleteIS5_EEEEmmRKNS_8ResourceERKNS_10ParametersEENKUlvE_clEvEUlvE_" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E4F20E4()
{
}

void sub_19E4F21BC(_Unwind_Exception *a1)
{
  *uint64_t v1 = v2;
  uint64_t v5 = v1[4];
  v1[4] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *v3;
  if (*v3)
  {
    v1[2] = v6;
    operator delete(v6);
  }
  MEMORY[0x19F3BDCF0](v1, 0x10B1C40C560DF64);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4F222C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BE008;
  a2[1] = v2;
  return result;
}

void *sub_19E4F2250(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BE008;
  result[1] = v3;
  return result;
}

void sub_19E4F2298()
{
}

__n128 sub_19E4F22B8(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BD8D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E4F22E8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF0BD8D0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E4F233C()
{
}

uint64_t sub_19E4F2358(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E4F237C(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE450;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E4F23D0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE450;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t sub_19E4F23F4(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void sub_19E4F2418(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE568;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E4F246C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF0BE568;
  std::__shared_weak_count::~__shared_weak_count(this);
}

os_log_t sub_19E4F248C()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "BaseLanguageModel");
  qword_1E945A2C8 = (uint64_t)result;
  return result;
}

BOOL sub_19E4F24BC(uint64_t a1, unsigned int a2)
{
  if (*(unsigned char *)(a1 + 292) && *(_DWORD *)(a1 + 288) == a2) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 80) == a2) {
    return 1;
  }
  uint64_t v3 = *(void *)(a1 + 8) + 24 * a2;
  if (*(char *)(v3 + 23) < 0)
  {
    uint64_t v3 = *(void *)v3;
    unint64_t v4 = *(void *)(*(void *)(a1 + 8) + 24 * a2 + 8);
    if (v4 < 3) {
      return 0;
    }
  }
  else
  {
    unint64_t v4 = *(unsigned __int8 *)(v3 + 23);
    if (v4 < 3) {
      return 0;
    }
  }
  unint64_t v5 = v4 + v3;
  int v6 = *(unsigned __int16 *)(v5 - 3);
  int v7 = *(unsigned __int8 *)(v5 - 1);
  return v6 == 38626 && v7 == 129;
}

uint64_t sub_19E4F2544(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t sub_19E4F254C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 324);
}

uint64_t sub_19E4F2554(uint64_t a1)
{
  return *(unsigned int *)(a1 + 328);
}

uint64_t sub_19E4F255C(uint64_t a1, unsigned int a2)
{
  return (*(void *)(*(void *)(a1 + 296) + (((unint64_t)a2 >> 3) & 0x1FFFFFF8)) >> a2) & 1;
}

BOOL sub_19E4F257C(uint64_t a1, int a2)
{
  return *(unsigned char *)(a1 + 292) && *(_DWORD *)(a1 + 288) == a2;
}

BOOL sub_19E4F259C(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 72) == a2 || *(_DWORD *)(a1 + 80) == a2;
}

BOOL sub_19E4F25C0(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 72) != a2 && *(_DWORD *)(a1 + 80) != a2;
}

uint64_t sub_19E4F25E4(uint64_t a1, void *a2, unint64_t a3)
{
  if (a3 >= (uint64_t)(a2[1] - *a2) >> 2) {
    __assert_rtn("isWordBoundaryIndex", "CoreLMSuffixCoder.cpp", 76, "index < encoding.size()");
  }
  unsigned int v3 = *(_DWORD *)(*a2 + 4 * a3);
  uint64_t v4 = *(void *)(a1 + 8) + 24 * v3;
  if (*(char *)(v4 + 23) < 0)
  {
    uint64_t v4 = *(void *)v4;
    unint64_t v5 = *(void *)(*(void *)(a1 + 8) + 24 * v3 + 8);
    if (v5 < 3) {
      return *(_DWORD *)(a1 + 76) == v3;
    }
  }
  else
  {
    unint64_t v5 = *(unsigned __int8 *)(v4 + 23);
    if (v5 < 3) {
      return *(_DWORD *)(a1 + 76) == v3;
    }
  }
  unint64_t v6 = v5 + v4;
  int v7 = *(unsigned __int16 *)(v6 - 3);
  int v8 = *(unsigned __int8 *)(v6 - 1);
  BOOL v9 = v7 == 38626 && v8 == 129;
  if (!v9 || *(unsigned char *)(a1 + 292) && *(_DWORD *)(a1 + 288) == v3) {
    return *(_DWORD *)(a1 + 76) == v3;
  }
  return 1;
}

BOOL sub_19E4F26A8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 84) == a2;
}

BOOL sub_19E4F26B8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 72) == a2;
}

BOOL sub_19E4F26C8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 80) == a2;
}

BOOL sub_19E4F26D8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 76) == a2;
}

BOOL sub_19E4F26E8(uint64_t a1, int a2)
{
  return *(_DWORD *)(a1 + 68) == a2;
}

BOOL sub_19E4F26F8(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 96);
  if (v2)
  {
    uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
    v3.i16[0] = vaddlv_u8(v3);
    if (v3.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v2 <= a2) {
        unint64_t v4 = a2 % v2;
      }
    }
    else
    {
      unint64_t v4 = (v2 - 1) & a2;
    }
    unint64_t v5 = *(uint64_t **)(*(void *)(a1 + 88) + 8 * v4);
    if (v5)
    {
      unint64_t v5 = (uint64_t *)*v5;
      if (v5)
      {
        if (v3.u32[0] < 2uLL)
        {
          unint64_t v6 = v2 - 1;
          while (1)
          {
            uint64_t v8 = v5[1];
            if (v8 == a2)
            {
              if (*((_DWORD *)v5 + 4) == a2) {
                return v5 != 0;
              }
            }
            else if ((v8 & v6) != v4)
            {
              goto LABEL_21;
            }
            unint64_t v5 = (uint64_t *)*v5;
            if (!v5) {
              return v5 != 0;
            }
          }
        }
        do
        {
          unint64_t v7 = v5[1];
          if (v7 == a2)
          {
            if (*((_DWORD *)v5 + 4) == a2) {
              return v5 != 0;
            }
          }
          else
          {
            if (v7 >= v2) {
              v7 %= v2;
            }
            if (v7 != v4) {
              goto LABEL_21;
            }
          }
          unint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
    }
  }
  else
  {
LABEL_21:
    unint64_t v5 = 0;
  }
  return v5 != 0;
}

uint64_t sub_19E4F27D8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void sub_19E4F27E0(uint64_t a1@<X8>)
{
  *(unsigned char *)(a1 + 23) = 3;
  *(_DWORD *)a1 = 8492770;
}

unsigned int *sub_19E4F27F8(unsigned int *result, int a2)
{
  switch(a2)
  {
    case 2:
      return (unsigned int *)result[20];
    case 1:
      return (unsigned int *)result[19];
    case 0:
      return (unsigned int *)result[17];
  }
  return result;
}

BOOL sub_19E4F2828(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a3 + 23);
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = *(void *)(a3 + 8);
  }
  if (!v3) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 292) && *(_DWORD *)(a1 + 288) == a2)
  {
    if ((*(_DWORD *)(a1 + 64) | 2) == 2) {
      return sub_19E4F2878(a1, a3);
    }
    return 1;
  }
  return sub_19E4F2D58(a1, a2, (void *)a3);
}

BOOL sub_19E4F2878(uint64_t a1, uint64_t a2)
{
  if (sub_19E4B9E40((void *)(a1 + 392), a2)) {
    return 0;
  }
  size_t v6 = *(unsigned __int8 *)(a2 + 23);
  char v7 = v6;
  unint64_t v8 = *(void *)(a2 + 8);
  size_t v9 = (v6 & 0x80u) == 0 ? *(unsigned __int8 *)(a2 + 23) : *(void *)(a2 + 8);
  if (!v9) {
    return 0;
  }
  int v10 = *(_DWORD *)(a1 + 328);
  if (v10 != 2) {
    goto LABEL_42;
  }
  if ((char)v6 < 0)
  {
    uint64_t v11 = *(void *)(a2 + 8);
    if (v8 == 1) {
      return 0;
    }
  }
  else
  {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 23);
    if ((char)v6 == 1) {
      return 0;
    }
  }
  if (!*(unsigned char *)(a1 + 360)) {
    sub_19E3F1AD4();
  }
  int v12 = (void **)(a1 + 336);
  uint64_t v13 = *(unsigned __int8 *)(a1 + 359);
  if (*(char *)(a1 + 359) < 0)
  {
    size_t v15 = *(void *)(a1 + 344);
    if (v11 != v15 + 1) {
      goto LABEL_27;
    }
    uint64_t v14 = *v12;
  }
  else
  {
    uint64_t v14 = (void *)(a1 + 336);
    size_t v15 = *(unsigned __int8 *)(a1 + 359);
    if (v11 != v13 + 1) {
      goto LABEL_25;
    }
  }
  BOOL v16 = v9 >= v15;
  size_t v17 = v9 - v15;
  if (v16)
  {
    uint64_t v18 = *(char **)a2;
    if ((v6 & 0x80u) == 0) {
      uint64_t v18 = (char *)a2;
    }
    if (!memcmp(&v18[v17], v14, v15)) {
      return 0;
    }
  }
  if ((v13 & 0x80) == 0)
  {
LABEL_25:
    *(_OWORD *)__p = *(_OWORD *)v12;
    uint64_t v46 = *(void *)(a1 + 352);
    goto LABEL_28;
  }
  size_t v15 = *(void *)(a1 + 344);
LABEL_27:
  sub_19E39369C(__p, *v12, v15);
  size_t v6 = *(unsigned __int8 *)(a2 + 23);
  unint64_t v8 = *(void *)(a2 + 8);
  char v7 = *(unsigned char *)(a2 + 23);
LABEL_28:
  if (v46 >= 0) {
    size_t v19 = HIBYTE(v46);
  }
  else {
    size_t v19 = (size_t)__p[1];
  }
  if (v7 >= 0) {
    size_t v20 = v6;
  }
  else {
    size_t v20 = v8;
  }
  if (v20 < v19
    || ((unint64_t v21 = *(void **)a2, v7 >= 0) ? (v22 = (char *)a2) : (v22 = *(char **)a2),
        v46 >= 0 ? (uint64_t v23 = __p) : (uint64_t v23 = (void **)__p[0]),
        memcmp(&v22[v20 - v19], v23, v19)))
  {
LABEL_42:
    if (v7 < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, v8);
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)a2;
      int64_t v48 = *(void *)(a2 + 16);
    }
    if (v10 != 2) {
      goto LABEL_48;
    }
    goto LABEL_46;
  }
  if (*(unsigned char *)(a1 + 360))
  {
    if (*(char *)(a1 + 359) < 0)
    {
      sub_19E39369C(v43, *(void **)(a1 + 336), *(void *)(a1 + 344));
      size_t v6 = *(unsigned __int8 *)(a2 + 23);
      unint64_t v21 = *(void **)a2;
      unint64_t v8 = *(void *)(a2 + 8);
      char v7 = *(unsigned char *)(a2 + 23);
    }
    else
    {
      *(_OWORD *)v43 = *(_OWORD *)v12;
      uint64_t v44 = *(void *)(a1 + 352);
    }
  }
  else
  {
    HIBYTE(v44) = 0;
    LOBYTE(v43[0]) = 0;
  }
  uint64_t v35 = (void *)HIBYTE(v44);
  if (v44 < 0) {
    uint64_t v35 = v43[1];
  }
  size_t v36 = v20 - (void)v35;
  if (v7 >= 0) {
    size_t v37 = v6;
  }
  else {
    size_t v37 = v8;
  }
  if (v7 >= 0) {
    unint64_t v38 = (const void *)a2;
  }
  else {
    unint64_t v38 = v21;
  }
  if (v37 >= v36) {
    size_t v39 = v36;
  }
  else {
    size_t v39 = v37;
  }
  if (v39 >= 0x7FFFFFFFFFFFFFF8) {
    sub_19E37C958();
  }
  if (v39 >= 0x17)
  {
    uint64_t v41 = (v39 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v39 | 7) != 0x17) {
      uint64_t v41 = v39 | 7;
    }
    uint64_t v42 = v41 + 1;
    v40 = operator new(v41 + 1);
    __dst[1] = (void *)v39;
    int64_t v48 = v42 | 0x8000000000000000;
    __dst[0] = v40;
    goto LABEL_92;
  }
  HIBYTE(v48) = v39;
  v40 = __dst;
  if (v39) {
LABEL_92:
  }
    memmove(v40, v38, v39);
  *((unsigned char *)v40 + v39) = 0;
  if (SHIBYTE(v44) < 0) {
    operator delete(v43[0]);
  }
LABEL_46:
  if (SHIBYTE(v46) < 0) {
    operator delete(__p[0]);
  }
LABEL_48:
  if (v48 >= 0) {
    unint64_t v24 = __dst;
  }
  else {
    unint64_t v24 = (void **)__dst[0];
  }
  if (v24)
  {
    if (v48 >= 0) {
      CFIndex v25 = HIBYTE(v48);
    }
    else {
      CFIndex v25 = (CFIndex)__dst[1];
    }
    CFStringRef v26 = CFStringCreateWithBytes(0, (const UInt8 *)v24, v25, 0x8000100u, 0);
    v43[0] = (void *)v26;
    if (!v26)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v26 = 0;
    v43[0] = 0;
  }
  CFLocaleRef v28 = *(const __CFLocale **)(a1 + 56);
  CFIndex Length = CFStringGetLength(v26);
  CFAllocatorRef v30 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Length, v26);
  CFStringLowercase(MutableCopy, v28);
  CFLocaleRef v32 = *(const __CFLocale **)(a1 + 56);
  CFIndex v33 = CFStringGetLength(v26);
  CFMutableStringRef v34 = CFStringCreateMutableCopy(v30, v33, v26);
  CFStringCapitalize(v34, v32);
  if (CFStringCompare(v26, v34, 0))
  {
    BOOL v4 = 0;
    if (!v34) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  BOOL v4 = CFStringCompare(v26, MutableCopy, 0) != kCFCompareEqualTo;
  if (v34) {
LABEL_62:
  }
    CFRelease(v34);
LABEL_63:
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v26) {
    CFRelease(v26);
  }
  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return v4;
}

void sub_19E4F2CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_19E4F2D58(uint64_t a1, unsigned int a2, void *__s2)
{
  uint64_t v3 = *((unsigned __int8 *)__s2 + 23);
  unsigned __int8 v4 = v3;
  if ((v3 & 0x80u) != 0) {
    uint64_t v3 = __s2[1];
  }
  if (!v3) {
    return 1;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 40) - v5) >> 3) <= a2) {
    __assert_rtn("fragmentString", "SentencePieceCoder.hpp", 107, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  size_t v6 = __s2;
  char v7 = (long long *)(v5 + 24 * a2);
  if (*((char *)v7 + 23) < 0)
  {
    sub_19E39369C(&v17, *(void **)v7, *((void *)v7 + 1));
    unsigned __int8 v4 = *((unsigned char *)v6 + 23);
  }
  else
  {
    long long v8 = *v7;
    uint64_t v18 = *((void *)v7 + 2);
    long long v17 = v8;
  }
  unint64_t v10 = HIBYTE(v18);
  int v11 = SHIBYTE(v18);
  if (v18 < 0) {
    unint64_t v10 = *((void *)&v17 + 1);
  }
  if ((v4 & 0x80) == 0)
  {
    size_t v12 = v4;
    if (v10 >= v4) {
      goto LABEL_23;
    }
LABEL_15:
    if ((v4 & 0x80u) == 0) {
      uint64_t v13 = (long long *)v6;
    }
    else {
      uint64_t v13 = (long long *)*v6;
    }
    uint64_t v14 = (void *)v17;
    if (v18 >= 0) {
      size_t v15 = &v17;
    }
    else {
      size_t v15 = (long long *)v17;
    }
    size_t v12 = v10;
    goto LABEL_27;
  }
  size_t v12 = v6[1];
  if (v10 < v12) {
    goto LABEL_15;
  }
  size_t v6 = (void *)*v6;
LABEL_23:
  uint64_t v14 = (void *)v17;
  if (v18 >= 0) {
    uint64_t v13 = &v17;
  }
  else {
    uint64_t v13 = (long long *)v17;
  }
  size_t v15 = (long long *)v6;
LABEL_27:
  BOOL v9 = memcmp(v13, v15, v12) == 0;
  if (v11 < 0) {
    operator delete(v14);
  }
  return v9;
}

void *sub_19E4F2EB0@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(result[5] - result[4]) >> 3) <= a2) {
    __assert_rtn("fragmentStringWithDelimiters", "SentencePieceCoder.hpp", 99, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  uint64_t v3 = result[1] + 24 * a2;
  if (*(char *)(v3 + 23) < 0)
  {
    uint64_t v5 = *(void **)v3;
    unint64_t v6 = *(void *)(v3 + 8);
    return sub_19E39369C((unsigned char *)a3, v5, v6);
  }
  else
  {
    long long v4 = *(_OWORD *)v3;
    *(void *)(a3 + 16) = *(void *)(v3 + 16);
    *(_OWORD *)a3 = v4;
  }
  return result;
}

void *sub_19E4F2F4C@<X0>(void *result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3 = result[4];
  if (0xAAAAAAAAAAAAAAABLL * ((result[5] - v3) >> 3) <= a2) {
    __assert_rtn("fragmentString", "SentencePieceCoder.hpp", 107, "fragmentID < m_tokenIDToFragmentStrMap.size()");
  }
  long long v4 = (long long *)(v3 + 24 * a2);
  if (*((char *)v4 + 23) < 0)
  {
    unint64_t v6 = *(void **)v4;
    unint64_t v7 = *((void *)v4 + 1);
    return sub_19E39369C((unsigned char *)a3, v6, v7);
  }
  else
  {
    long long v5 = *v4;
    *(void *)(a3 + 16) = *((void *)v4 + 2);
    *(_OWORD *)a3 = v5;
  }
  return result;
}

void sub_19E4F2FE4(unsigned char *a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v484 = *MEMORY[0x1E4F143B8];
  long long v5 = v427;
  sub_19E4F61A4((uint64_t)a1, a2, a3, (uint64_t)v427);
  unint64_t v6 = HIBYTE(v428);
  if (v428 < 0)
  {
    long long v5 = (void **)v427[0];
    unint64_t v6 = (unint64_t)v427[1];
  }
  unint64_t v7 = v6;
  do
  {
    if (!v7) {
      goto LABEL_14;
    }
    int v8 = *((unsigned __int8 *)v5 + --v7);
  }
  while (v8 == 32);
  if (v7 != -1)
  {
    if (v6 >= v7 + 1) {
      size_t v9 = v7 + 1;
    }
    else {
      size_t v9 = v6;
    }
    if (v9 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E37C958();
    }
    if (v9 >= 0x17)
    {
      uint64_t v11 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v9 | 7) != 0x17) {
        uint64_t v11 = v9 | 7;
      }
      uint64_t v12 = v11 + 1;
      unint64_t v10 = operator new(v11 + 1);
      *(void *)(a4 + 8) = v9;
      *(void *)(a4 + 16) = v12 | 0x8000000000000000;
      *(void *)a4 = v10;
    }
    else
    {
      *(unsigned char *)(a4 + 23) = v9;
      unint64_t v10 = (void *)a4;
      if (!v9) {
        goto LABEL_21;
      }
    }
    memmove(v10, v5, v9);
LABEL_21:
    *((unsigned char *)v10 + v9) = 0;
    goto LABEL_22;
  }
LABEL_14:
  if (SHIBYTE(v428) < 0)
  {
    sub_19E39369C((unsigned char *)a4, v427[0], (unint64_t)v427[1]);
  }
  else
  {
    *(_OWORD *)a4 = *(_OWORD *)v427;
    *(void *)(a4 + 16) = v428;
  }
LABEL_22:
  if (!a1[360]) {
    goto LABEL_36;
  }
  uint64_t v13 = a1 + 336;
  if ((char)a1[359] < 0) {
    uint64_t v13 = *(const char **)v13;
  }
  size_t v14 = strlen(v13);
  char v15 = *(unsigned char *)(a4 + 23);
  i = v15 >= 0 ? (unsigned char *)a4 : *(unsigned char **)a4;
  uint64_t v17 = v15 >= 0 ? *(unsigned __int8 *)(a4 + 23) : *(void *)(a4 + 8);
  BOOL v18 = !v17 || v14 == 0;
  if (v18) {
    goto LABEL_36;
  }
  CFIndex v25 = &v13[v14];
  CFStringRef v26 = &i[v17];
  size_t v27 = v14 - 1;
  uint64_t v28 = v17 - 1;
  v29 = i;
LABEL_53:
  uint64_t v31 = 0;
  do
  {
    if (v29[v31] != v13[v31])
    {
      CFAllocatorRef v30 = &v29[v31];
      if (&v13[v31] == v25) {
        goto LABEL_59;
      }
LABEL_52:
      ++v29;
      --v28;
      if (v29 == v26) {
        goto LABEL_36;
      }
      goto LABEL_53;
    }
    uint64_t v32 = v31 + 1;
    if (v28 == v31) {
      break;
    }
    BOOL v18 = v27 == v31++;
  }
  while (!v18);
  CFAllocatorRef v30 = &v29[v32];
  if (&v13[v32] != v25) {
    goto LABEL_52;
  }
LABEL_59:
  if (v29 == v30) {
    goto LABEL_36;
  }
  int64x2_t v466 = 0u;
  memset(v465, 0, sizeof(v465));
  CFIndex v33 = i;
  v409 = &v13[v14];
  size_t v410 = v14;
  uint64_t v407 = a4;
  do
  {
    i = sub_19E4F6DDC((uint64_t)v465, i, v33, v29);
    uint64_t v34 = v466.i64[1];
    uint64_t v35 = v466.i64[0];
    uint64_t v36 = v466.i64[0] + v466.i64[1];
    unint64_t v37 = (unint64_t)(v466.i64[0] + v466.i64[1]) >> 12;
    size_t v39 = *(char **)&v465[16];
    unint64_t v38 = *(char **)&v465[8];
    v40 = (char *)(*(void *)&v465[8] + 8 * v37);
    unint64_t v41 = (unint64_t)v466.i64[0] >> 12;
    uint64_t v42 = *(void *)&v465[16] - *(void *)&v465[8];
    if (*(void *)&v465[16] == *(void *)&v465[8]
      || (uint64_t v43 = *(void *)v40 + (v36 & 0xFFF),
          uint64_t v44 = (char *)(*(void *)&v465[8] + 8 * v41),
          uint64_t v45 = *(void *)v44 + (v466.i16[0] & 0xFFF),
          v43 == v45))
    {
      unint64_t v46 = 0;
    }
    else
    {
      unint64_t v46 = v43 + ((v40 - v44) << 9) - (v45 + *(void *)v40) + *(void *)v44;
    }
    v415 = v30;
    unint64_t v416 = v46;
    if (v46 < v466.i64[1] - v46)
    {
      if (v466.i64[0] <= 1uLL)
      {
        uint64_t v47 = (v42 << 9) - 1;
        if (*(void *)&v465[16] == *(void *)&v465[8]) {
          uint64_t v47 = 0;
        }
        unint64_t v48 = (*(void *)&v465[16] == *(void *)&v465[8]) - v466.i64[0] + 2;
        if ((v48 & 0xFFF) != 0) {
          unint64_t v49 = (v48 >> 12) + 1;
        }
        else {
          unint64_t v49 = v48 >> 12;
        }
        unint64_t v50 = (unint64_t)(v47 - v36) >> 12;
        if (v49 >= v50) {
          unint64_t v51 = v50;
        }
        else {
          unint64_t v51 = v49;
        }
        if (v49 <= v50)
        {
          for (v466.i64[0] += v51 << 12; v51; --v51)
          {
            cf.__r_.__value_.__r.__words[0] = *(void *)(*(void *)&v465[16] - 8);
            *(void *)&v465[16] -= 8;
            sub_19E4F77FC((void **)v465, &cf);
          }
        }
        else
        {
          v411 = i;
          unint64_t v52 = v49 - v51;
          uint64_t v53 = *(void *)&v465[24] - *(void *)v465;
          uint64_t v54 = (uint64_t)(*(void *)&v465[16] - *(void *)&v465[8]) >> 3;
          if (v49 - v51 > ((uint64_t)(*(void *)&v465[24] - *(void *)v465) >> 3) - v54)
          {
            BOOL v55 = *(void *)&v465[16] == *(void *)&v465[8];
            if (v53 >> 2 <= v52 + v54) {
              unint64_t v56 = v52 + v54;
            }
            else {
              unint64_t v56 = v53 >> 2;
            }
            if (v56)
            {
              if (v56 >> 61) {
LABEL_642:
              }
                sub_19E37C2B8();
              v57 = (char *)operator new(8 * v56);
            }
            else
            {
              v57 = 0;
            }
            unint64_t v408 = (v49 << 12) - v55;
            v96 = &v57[8 * v56];
            v97 = v57;
            v98 = v57;
            while (1)
            {
              __p = v57;
              v99 = v96;
              v100 = operator new(0x1000uLL);
              v96 = v99;
              if (v98 == v99) {
                break;
              }
LABEL_147:
              *(void *)v98 = v100;
              v98 += 8;
              if (!--v52)
              {
                v417 = v96;
                uint64_t v121 = *(void *)&v465[16];
                if (!v51)
                {
LABEL_175:
                  v122 = *(uint64_t **)&v465[8];
                  if (*(void *)&v465[8] == v121)
                  {
LABEL_176:
                    v123 = *(void **)v465;
                    *(void *)v465 = v57;
                    *(void *)&v465[8] = v97;
                    *(void *)&v465[16] = v98;
                    unint64_t v46 = v416;
                    *(void *)&v465[24] = v417;
                    v466.i64[0] += v408;
                    i = v411;
                    if (v123) {
                      operator delete(v123);
                    }
                    goto LABEL_178;
                  }
                  while (2)
                  {
                    if (v98 != v417)
                    {
                      v148 = v97;
                      goto LABEL_209;
                    }
                    if (v97 > v57)
                    {
                      uint64_t v150 = (v97 - v57) >> 3;
                      if (v150 >= -1) {
                        uint64_t v151 = v150 + 1;
                      }
                      else {
                        uint64_t v151 = v150 + 2;
                      }
                      uint64_t v152 = v151 >> 1;
                      v153 = &v97[-8 * (v151 >> 1)];
                      v154 = v417;
                      if (v417 != v97)
                      {
                        memmove(v153, v97, v417 - v97);
                        v154 = v97;
                      }
                      v98 = &v153[v417 - v97];
                      v148 = &v154[-8 * v152];
                      goto LABEL_209;
                    }
                    if (v417 == v57) {
                      unint64_t v155 = 1;
                    }
                    else {
                      unint64_t v155 = (v417 - v57) >> 2;
                    }
                    if (v155 >> 61) {
                      sub_19E37C2B8();
                    }
                    v156 = (char *)operator new(8 * v155);
                    v157 = v156;
                    unint64_t v158 = v155 >> 2;
                    v148 = &v156[8 * (v155 >> 2)];
                    v98 = v148;
                    int64_t v159 = v417 - v97;
                    if (v417 != v97)
                    {
                      v98 = &v148[v159 & 0xFFFFFFFFFFFFFFF8];
                      unint64_t v160 = v159 - 8;
                      if (v160 >= 0x38)
                      {
                        uint64_t v162 = 8 * v158;
                        if ((unint64_t)(&v156[8 * v158] - v97) < 0x20)
                        {
                          v161 = &v156[8 * (v155 >> 2)];
                          goto LABEL_231;
                        }
                        uint64_t v163 = (v160 >> 3) + 1;
                        uint64_t v164 = 8 * (v163 & 0x3FFFFFFFFFFFFFFCLL);
                        v161 = &v148[v164];
                        v165 = (long long *)(v97 + 16);
                        v166 = &v156[v162 + 16];
                        uint64_t v167 = v163 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v168 = *v165;
                          *((_OWORD *)v166 - 1) = *(v165 - 1);
                          *(_OWORD *)v166 = v168;
                          v165 += 2;
                          v166 += 32;
                          v167 -= 4;
                        }
                        while (v167);
                        if (v163 != (v163 & 0x3FFFFFFFFFFFFFFCLL))
                        {
                          v97 += v164;
                          goto LABEL_231;
                        }
                      }
                      else
                      {
                        v161 = &v156[8 * (v155 >> 2)];
                        do
                        {
LABEL_231:
                          uint64_t v169 = *(void *)v97;
                          v97 += 8;
                          *(void *)v161 = v169;
                          v161 += 8;
                        }
                        while (v161 != v98);
                      }
                    }
                    v417 = &v156[8 * v155];
                    if (v57) {
                      operator delete(v57);
                    }
                    v57 = v157;
LABEL_209:
                    uint64_t v149 = *v122++;
                    *(void *)v98 = v149;
                    v98 += 8;
                    v97 = v148;
                    if (v122 == *(uint64_t **)&v465[16]) {
                      goto LABEL_176;
                    }
                    continue;
                  }
                }
                while (2)
                {
                  if (v98 != v417)
                  {
                    v126 = v97;
                    goto LABEL_182;
                  }
                  if (v97 > v57)
                  {
                    uint64_t v127 = (v97 - v57) >> 3;
                    if (v127 >= -1) {
                      uint64_t v128 = v127 + 1;
                    }
                    else {
                      uint64_t v128 = v127 + 2;
                    }
                    uint64_t v129 = v128 >> 1;
                    v130 = &v97[-8 * (v128 >> 1)];
                    v131 = v417;
                    if (v417 != v97)
                    {
                      memmove(v130, v97, v417 - v97);
                      v131 = v97;
                    }
                    uint64_t v132 = -v129;
                    v98 = &v130[v417 - v97];
                    v126 = &v131[8 * v132];
                    goto LABEL_182;
                  }
                  __pa = v57;
                  if (v417 == v57) {
                    unint64_t v133 = 1;
                  }
                  else {
                    unint64_t v133 = (v417 - v57) >> 2;
                  }
                  if (v133 >> 61) {
                    sub_19E37C2B8();
                  }
                  v134 = (char *)operator new(8 * v133);
                  v135 = v134;
                  unint64_t v136 = v133 >> 2;
                  v126 = &v134[8 * (v133 >> 2)];
                  v98 = v126;
                  int64_t v137 = v417 - v97;
                  if (v417 != v97)
                  {
                    v98 = &v126[v137 & 0xFFFFFFFFFFFFFFF8];
                    unint64_t v138 = v137 - 8;
                    if (v138 >= 0x38)
                    {
                      uint64_t v140 = 8 * v136;
                      if ((unint64_t)(&v134[8 * v136] - v97) < 0x20)
                      {
                        v139 = &v134[8 * (v133 >> 2)];
                        goto LABEL_204;
                      }
                      uint64_t v141 = (v138 >> 3) + 1;
                      uint64_t v142 = 8 * (v141 & 0x3FFFFFFFFFFFFFFCLL);
                      v139 = &v126[v142];
                      v143 = (long long *)(v97 + 16);
                      v144 = &v134[v140 + 16];
                      uint64_t v145 = v141 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v146 = *v143;
                        *((_OWORD *)v144 - 1) = *(v143 - 1);
                        *(_OWORD *)v144 = v146;
                        v143 += 2;
                        v144 += 32;
                        v145 -= 4;
                      }
                      while (v145);
                      if (v141 != (v141 & 0x3FFFFFFFFFFFFFFCLL))
                      {
                        v97 += v142;
                        goto LABEL_204;
                      }
                    }
                    else
                    {
                      v139 = &v134[8 * (v133 >> 2)];
                      do
                      {
LABEL_204:
                        uint64_t v147 = *(void *)v97;
                        v97 += 8;
                        *(void *)v139 = v147;
                        v139 += 8;
                      }
                      while (v139 != v98);
                    }
                  }
                  v417 = &v134[8 * v133];
                  if (__pa) {
                    operator delete(__pa);
                  }
                  v57 = v135;
LABEL_182:
                  *(void *)v98 = *(void *)(v121 - 8);
                  v98 += 8;
                  uint64_t v121 = *(void *)&v465[16] - 8;
                  *(void *)&v465[16] -= 8;
                  v97 = v126;
                  if (!--v51) {
                    goto LABEL_175;
                  }
                  continue;
                }
              }
            }
            if (v97 > v57)
            {
              uint64_t v101 = (v97 - v57) >> 3;
              if (v101 >= -1) {
                uint64_t v102 = v101 + 1;
              }
              else {
                uint64_t v102 = v101 + 2;
              }
              uint64_t v103 = v102 >> 1;
              v104 = &v97[-8 * (v102 >> 1)];
              v105 = v99;
              if (v99 != v97)
              {
                memmove(v104, v97, v99 - v97);
                v105 = v97;
              }
              v98 = &v104[v99 - v97];
              v97 = &v105[-8 * v103];
              v57 = __p;
              goto LABEL_173;
            }
            if (v99 == v57) {
              unint64_t v106 = 1;
            }
            else {
              unint64_t v106 = (v99 - v57) >> 2;
            }
            if (v106 >> 61) {
              sub_19E37C2B8();
            }
            v107 = (char *)operator new(8 * v106);
            unint64_t v108 = v106 >> 2;
            v109 = &v107[8 * (v106 >> 2)];
            v98 = v109;
            int64_t v110 = v99 - v97;
            if (v99 != v97)
            {
              v98 = &v109[v110 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v111 = v110 - 8;
              if (v111 >= 0x38)
              {
                uint64_t v113 = 8 * v108;
                if ((unint64_t)(&v107[8 * v108] - v97) >= 0x20)
                {
                  uint64_t v114 = (v111 >> 3) + 1;
                  uint64_t v115 = 8 * (v114 & 0x3FFFFFFFFFFFFFFCLL);
                  v112 = &v109[v115];
                  v116 = (long long *)(v97 + 16);
                  v117 = &v107[v113 + 16];
                  uint64_t v118 = v114 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v119 = *v116;
                    *((_OWORD *)v117 - 1) = *(v116 - 1);
                    *(_OWORD *)v117 = v119;
                    v116 += 2;
                    v117 += 32;
                    v118 -= 4;
                  }
                  while (v118);
                  if (v114 == (v114 & 0x3FFFFFFFFFFFFFFCLL)) {
                    goto LABEL_170;
                  }
                  v97 += v115;
                }
                else
                {
                  v112 = &v107[8 * (v106 >> 2)];
                }
              }
              else
              {
                v112 = &v107[8 * (v106 >> 2)];
              }
              do
              {
                uint64_t v120 = *(void *)v97;
                v97 += 8;
                *(void *)v112 = v120;
                v112 += 8;
              }
              while (v112 != v98);
            }
LABEL_170:
            v99 = &v107[8 * v106];
            if (__p)
            {
              v57 = v107;
              v97 = v109;
              operator delete(__p);
            }
            else
            {
              v97 = v109;
              v57 = v107;
            }
LABEL_173:
            v96 = v99;
            goto LABEL_147;
          }
          if (v52)
          {
            if (*(void *)&v465[8] == *(void *)v465)
            {
LABEL_135:
              unint64_t v95 = v52;
              do
              {
                cf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x1000uLL);
                sub_19E4F7670((char **)v465, &cf);
                --v95;
              }
              while (v95);
              v51 += v52;
              uint64_t v35 = v466.i64[0];
            }
            else
            {
              while (1)
              {
                cf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x1000uLL);
                sub_19E4F77FC((void **)v465, &cf);
                uint64_t v94 = 4095;
                if (*(void *)&v465[16] - *(void *)&v465[8] != 8) {
                  uint64_t v94 = 4096;
                }
                uint64_t v35 = v94 + v466.i64[0];
                v466.i64[0] = v35;
                if (!--v52) {
                  break;
                }
                if (*(void *)&v465[8] == *(void *)v465) {
                  goto LABEL_135;
                }
              }
            }
          }
          v466.i64[0] = v35 + (v51 << 12);
          for (i = v411; v51; --v51)
          {
            cf.__r_.__value_.__r.__words[0] = *(void *)(*(void *)&v465[16] - 8);
            *(void *)&v465[16] -= 8;
            sub_19E4F77FC((void **)v465, &cf);
          }
        }
LABEL_178:
        LOWORD(v35) = v466.i16[0];
        size_t v39 = *(char **)&v465[16];
        unint64_t v38 = *(char **)&v465[8];
        unint64_t v41 = (unint64_t)v466.i64[0] >> 12;
      }
      v124 = (void **)&v38[8 * v41];
      if (v39 == v38) {
        v125 = 0;
      }
      else {
        v125 = (char *)*v124 + (v35 & 0xFFF);
      }
      if (v46 > 1)
      {
        unint64_t v175 = 2;
        v170 = "'s";
        v172 = (char **)&v38[8 * v41];
        v173 = v125;
      }
      else
      {
        v170 = &aS_1[-v46 + 2];
        uint64_t v171 = -(uint64_t)v46;
        v172 = (char **)&v38[8 * v41];
        v173 = v125;
        do
        {
          if (v173 == *v172)
          {
            uint64_t v174 = (uint64_t)*--v172;
            v173 = (char *)(v174 + 4096);
          }
          *--v173 = aS_1[v171 + 1];
          int64x2_t v466 = vaddq_s64(v466, (int64x2_t)xmmword_19E5730F0);
          --v171;
        }
        while (v171 != -2);
        unint64_t v175 = v46;
        if (!v46) {
          goto LABEL_501;
        }
      }
      uint64_t v176 = v125 - (unsigned char *)*v124 + v175;
      if (v176 < 1)
      {
        unint64_t v179 = 4095 - v176;
        v177 = &v124[-(v179 >> 12)];
        v178 = (char *)*v177 + (~(_WORD)v179 & 0xFFF);
      }
      else
      {
        v177 = &v124[(unint64_t)v176 >> 12];
        v178 = (char *)*v177 + (v176 & 0xFFF);
      }
      v180 = v177;
      for (j = v178; j != v125; int64x2_t v466 = vaddq_s64(v466, (int64x2_t)xmmword_19E5730F0))
      {
        if (v173 == *v172)
        {
          uint64_t v187 = (uint64_t)*--v172;
          v173 = (char *)(v187 + 4096);
        }
        if (j == *v180)
        {
          uint64_t v188 = (uint64_t)*--v180;
          j = (char *)(v188 + 4096);
        }
        char v186 = *--j;
        *--v173 = v186;
      }
      if (v175 >= v416)
      {
LABEL_302:
        if (v170 != "")
        {
          v213 = (char *)*v124;
          v212 = v124 + 1;
          v211 = v213;
          while (1)
          {
            uint64_t v214 = v211 - v125 + 4096;
            if ("'s" - v170 + 2 >= v214) {
              size_t v215 = v214;
            }
            else {
              size_t v215 = "'s" - v170 + 2;
            }
            if (v215) {
              memmove(v125, v170, v215);
            }
            v170 += v215;
            if (v170 == "") {
              break;
            }
            v216 = (char *)*v212++;
            v211 = v216;
            v125 = v216;
          }
        }
        goto LABEL_501;
      }
      __pb = v177;
      v413 = i;
      v182 = (char *)*v124;
      uint64_t v183 = v125 - (unsigned char *)*v124 + v416;
      if (v183 < 1)
      {
        unint64_t v189 = 4095 - v183;
        v184 = &v124[-(v189 >> 12)];
        v185 = (char *)*v184 + (~(_WORD)v189 & 0xFFF);
      }
      else
      {
        v184 = &v124[(unint64_t)v183 >> 12];
        v185 = (char *)*v184 + (v183 & 0xFFF);
      }
      if (v177 == v184)
      {
        if (v178 == v185)
        {
          i = v413;
          goto LABEL_302;
        }
        while (1)
        {
          uint64_t v209 = v182 - v125 + 4096;
          if (v185 - v178 >= v209) {
            size_t v206 = v209;
          }
          else {
            size_t v206 = v185 - v178;
          }
          if (v206) {
            memmove(v125, v178, v206);
          }
          v178 += v206;
          if (v178 == v185) {
            break;
          }
          v208 = (char *)v124[1];
          ++v124;
          v182 = v208;
          v125 = v208;
        }
      }
      else
      {
        uint64_t v190 = (uint64_t)*v177 + 4096;
        if ((char *)v190 != v178)
        {
          while (1)
          {
            uint64_t v191 = v182 - v125 + 4096;
            if (v190 - (uint64_t)v178 >= v191) {
              size_t v192 = v191;
            }
            else {
              size_t v192 = v190 - (void)v178;
            }
            if (v192) {
              memmove(v125, v178, v192);
            }
            v178 += v192;
            if (v178 == (char *)v190) {
              break;
            }
            v193 = (char *)v124[1];
            ++v124;
            v182 = v193;
            v125 = v193;
          }
          v125 += v192;
          v182 = (char *)*v124;
          if ((char *)*v124 + 4096 == v125)
          {
            v194 = (char *)v124[1];
            ++v124;
            v182 = v194;
            v125 = v194;
          }
        }
        v195 = (uint64_t *)(__pb + 1);
        if (__pb + 1 != v184)
        {
          __pc = v185;
          do
          {
            v196 = v184;
            uint64_t v197 = 0;
            uint64_t v198 = *v195;
            while (1)
            {
              uint64_t v199 = v182 - v125 + 4096;
              if (4096 - v197 >= v199) {
                size_t v200 = v199;
              }
              else {
                size_t v200 = 4096 - v197;
              }
              if (v200) {
                memmove(v125, (const void *)(v198 + v197), v200);
              }
              v197 += v200;
              if (v197 == 4096) {
                break;
              }
              v201 = (char *)v124[1];
              ++v124;
              v182 = v201;
              v125 = v201;
            }
            v125 += v200;
            v182 = (char *)*v124;
            if ((char *)*v124 + 4096 == v125)
            {
              v202 = (char *)v124[1];
              ++v124;
              v182 = v202;
              v125 = v202;
            }
            v184 = v196;
            ++v195;
          }
          while (v195 != (uint64_t *)v196);
          v185 = __pc;
        }
        v203 = (char *)*v184;
        if (*v184 == v185) {
          goto LABEL_301;
        }
        v204 = (char *)*v124;
        while (1)
        {
          uint64_t v205 = v204 - v125 + 4096;
          if (v185 - v203 >= v205) {
            size_t v206 = v205;
          }
          else {
            size_t v206 = v185 - v203;
          }
          if (v206) {
            memmove(v125, v203, v206);
          }
          v203 += v206;
          if (v203 == v185) {
            break;
          }
          v207 = (char *)v124[1];
          ++v124;
          v204 = v207;
          v125 = v207;
        }
      }
      v125 += v206;
      if ((char *)*v124 + 4096 == v125)
      {
        v210 = (char *)v124[1];
        ++v124;
        v125 = v210;
      }
LABEL_301:
      i = v413;
      goto LABEL_302;
    }
    uint64_t v58 = (v42 << 9) - 1;
    uint64_t v59 = *(void *)&v465[16] - *(void *)&v465[8];
    if (*(void *)&v465[16] == *(void *)&v465[8]) {
      uint64_t v58 = 0;
    }
    unint64_t v60 = v58 - v36;
    v412 = i;
    if (v60 > 1) {
      goto LABEL_402;
    }
    unint64_t v61 = (*(void *)&v465[16] == *(void *)&v465[8]) - v60 + 2;
    if ((v61 & 0xFFF) != 0) {
      unint64_t v62 = (v61 >> 12) + 1;
    }
    else {
      unint64_t v62 = v61 >> 12;
    }
    if (v62 >= v41) {
      unint64_t v63 = (unint64_t)v466.i64[0] >> 12;
    }
    else {
      unint64_t v63 = v62;
    }
    if (v62 <= v41)
    {
      v466.i64[0] -= v63 << 12;
      if (!v63) {
        goto LABEL_401;
      }
      while (1)
      {
        uint64_t v69 = *(void *)&v465[8];
        v70 = (char *)(*(void *)&v465[8] + 8);
        uint64_t v71 = **(void **)&v465[8];
        *(void *)&v465[8] += 8;
        if (v39 == *(char **)&v465[24])
        {
          v72 = *(void **)v465;
          if ((unint64_t)v70 <= *(void *)v465)
          {
            if (v39 == *(char **)v465) {
              unint64_t v78 = 1;
            }
            else {
              unint64_t v78 = (uint64_t)&v39[-*(void *)v465] >> 2;
            }
            if (v78 >> 61) {
              goto LABEL_642;
            }
            v79 = operator new(8 * v78);
            unint64_t v80 = v78 >> 2;
            v81 = &v79[8 * (v78 >> 2)];
            int64_t v82 = v39 - v70;
            BOOL v18 = v39 == v70;
            size_t v39 = v81;
            if (!v18)
            {
              size_t v39 = &v81[v82 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v83 = v82 - 8;
              if (v83 >= 0x38)
              {
                uint64_t v85 = 8 * v80;
                unint64_t v86 = &v79[8 * v80] - v70;
                v84 = &v79[8 * (v78 >> 2)];
                if (v86 < 0x20) {
                  goto LABEL_126;
                }
                uint64_t v87 = (v83 >> 3) + 1;
                uint64_t v88 = 8 * (v87 & 0x3FFFFFFFFFFFFFFCLL);
                v84 = &v81[v88];
                v89 = (long long *)(v69 + 24);
                v90 = &v79[v85 + 16];
                uint64_t v91 = v87 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v92 = *v89;
                  *(v90 - 1) = *(v89 - 1);
                  _OWORD *v90 = v92;
                  v89 += 2;
                  v90 += 2;
                  v91 -= 4;
                }
                while (v91);
                if (v87 != (v87 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v70 += v88;
                  goto LABEL_126;
                }
              }
              else
              {
                v84 = &v79[8 * (v78 >> 2)];
                do
                {
LABEL_126:
                  uint64_t v93 = *(void *)v70;
                  v70 += 8;
                  *(void *)v84 = v93;
                  v84 += 8;
                }
                while (v84 != v39);
              }
            }
            *(void *)v465 = v79;
            *(void *)&v465[8] = &v79[8 * (v78 >> 2)];
            *(void *)&v465[16] = v39;
            *(void *)&v465[24] = &v79[8 * v78];
            unint64_t v46 = v416;
            if (v72)
            {
              operator delete(v72);
              size_t v39 = *(char **)&v465[16];
            }
            goto LABEL_106;
          }
          uint64_t v73 = (uint64_t)&v70[-*(void *)v465] >> 3;
          if (v73 >= -1) {
            uint64_t v74 = v73 + 1;
          }
          else {
            uint64_t v74 = v73 + 2;
          }
          uint64_t v75 = v74 >> 1;
          v76 = &v70[-8 * (v74 >> 1)];
          int64_t v77 = v39 - v70;
          if (v39 != v70)
          {
            memmove(&v70[-8 * (v74 >> 1)], v70, v39 - v70);
            size_t v39 = *(char **)&v465[8];
          }
          v68 = &v39[-8 * v75];
          size_t v39 = &v76[v77];
          *(void *)&v465[16] = &v76[v77];
          *(void *)&v465[8] = v68;
          unint64_t v46 = v416;
        }
LABEL_106:
        *(void *)size_t v39 = v71;
        size_t v39 = (char *)(*(void *)&v465[16] + 8);
        *(void *)&v465[16] += 8;
        if (!--v63) {
          goto LABEL_401;
        }
      }
    }
    unint64_t v64 = v62 - v63;
    uint64_t v65 = v59 >> 3;
    if (v62 - v63 <= ((uint64_t)(*(void *)&v465[24] - *(void *)v465) >> 3) - (v59 >> 3))
    {
      if (!v64) {
        goto LABEL_399;
      }
      do
      {
        if (*(void *)&v465[24] == *(void *)&v465[16])
        {
          for (uint64_t k = 0; k != v64; ++k)
          {
            cf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x1000uLL);
            sub_19E4F77FC((void **)v465, &cf);
            size_t v39 = *(char **)&v465[16];
            uint64_t v292 = 4095;
            if (*(void *)&v465[16] - *(void *)&v465[8] != 8) {
              uint64_t v292 = 4096;
            }
            uint64_t v293 = v292 + v466.i64[0];
            v466.i64[0] = v293;
          }
          v63 += v64;
          goto LABEL_400;
        }
        cf.__r_.__value_.__r.__words[0] = (std::string::size_type)operator new(0x1000uLL);
        sub_19E4F7670((char **)v465, &cf);
        --v64;
      }
      while (v64);
      size_t v39 = *(char **)&v465[16];
LABEL_399:
      uint64_t v293 = v466.i64[0];
LABEL_400:
      v466.i64[0] = v293 - (v63 << 12);
      if (!v63) {
        goto LABEL_401;
      }
      while (1)
      {
        uint64_t v297 = *(void *)&v465[8];
        v298 = (char *)(*(void *)&v465[8] + 8);
        uint64_t v299 = **(void **)&v465[8];
        *(void *)&v465[8] += 8;
        if (v39 == *(char **)&v465[24])
        {
          v300 = *(void **)v465;
          if ((unint64_t)v298 <= *(void *)v465)
          {
            if (v39 == *(char **)v465) {
              unint64_t v306 = 1;
            }
            else {
              unint64_t v306 = (uint64_t)&v39[-*(void *)v465] >> 2;
            }
            if (v306 >> 61) {
              goto LABEL_642;
            }
            v307 = operator new(8 * v306);
            unint64_t v308 = v306 >> 2;
            v309 = &v307[8 * (v306 >> 2)];
            int64_t v310 = v39 - v298;
            BOOL v18 = v39 == v298;
            size_t v39 = v309;
            if (!v18)
            {
              size_t v39 = &v309[v310 & 0xFFFFFFFFFFFFFFF8];
              unint64_t v311 = v310 - 8;
              if (v311 >= 0x38)
              {
                uint64_t v313 = 8 * v308;
                unint64_t v314 = &v307[8 * v308] - v298;
                v312 = &v307[8 * (v306 >> 2)];
                if (v314 < 0x20) {
                  goto LABEL_425;
                }
                uint64_t v315 = (v311 >> 3) + 1;
                uint64_t v316 = 8 * (v315 & 0x3FFFFFFFFFFFFFFCLL);
                v312 = &v309[v316];
                v317 = (long long *)(v297 + 24);
                v318 = &v307[v313 + 16];
                uint64_t v319 = v315 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v320 = *v317;
                  *(v318 - 1) = *(v317 - 1);
                  _OWORD *v318 = v320;
                  v317 += 2;
                  v318 += 2;
                  v319 -= 4;
                }
                while (v319);
                if (v315 != (v315 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  v298 += v316;
                  goto LABEL_425;
                }
              }
              else
              {
                v312 = &v307[8 * (v306 >> 2)];
                do
                {
LABEL_425:
                  uint64_t v321 = *(void *)v298;
                  v298 += 8;
                  *(void *)v312 = v321;
                  v312 += 8;
                }
                while (v312 != v39);
              }
            }
            *(void *)v465 = v307;
            *(void *)&v465[8] = &v307[8 * (v306 >> 2)];
            *(void *)&v465[16] = v39;
            *(void *)&v465[24] = &v307[8 * v306];
            unint64_t v46 = v416;
            if (v300)
            {
              operator delete(v300);
              size_t v39 = *(char **)&v465[16];
            }
            goto LABEL_405;
          }
          uint64_t v301 = (uint64_t)&v298[-*(void *)v465] >> 3;
          if (v301 >= -1) {
            uint64_t v302 = v301 + 1;
          }
          else {
            uint64_t v302 = v301 + 2;
          }
          uint64_t v303 = v302 >> 1;
          v304 = &v298[-8 * (v302 >> 1)];
          int64_t v305 = v39 - v298;
          if (v39 != v298)
          {
            memmove(&v298[-8 * (v302 >> 1)], v298, v39 - v298);
            size_t v39 = *(char **)&v465[8];
          }
          v296 = &v39[-8 * v303];
          size_t v39 = &v304[v305];
          *(void *)&v465[16] = &v304[v305];
          *(void *)&v465[8] = v296;
          unint64_t v46 = v416;
        }
LABEL_405:
        *(void *)size_t v39 = v299;
        size_t v39 = (char *)(*(void *)&v465[16] + 8);
        *(void *)&v465[16] += 8;
        if (!--v63) {
          goto LABEL_401;
        }
      }
    }
    if ((uint64_t)(*(void *)&v465[24] - *(void *)v465) >> 2 <= v64 + v65) {
      unint64_t v66 = v64 + v65;
    }
    else {
      unint64_t v66 = (uint64_t)(*(void *)&v465[24] - *(void *)v465) >> 2;
    }
    if (v66)
    {
      if (v66 >> 61) {
        goto LABEL_642;
      }
      v67 = (char *)operator new(8 * v66);
    }
    else
    {
      v67 = 0;
    }
    unint64_t v418 = v63 << 12;
    v217 = &v67[8 * (v65 - v63)];
    v218 = &v67[8 * v66];
    size_t v39 = v217;
    do
    {
      __pd = v67;
      v219 = v218;
      v220 = operator new(0x1000uLL);
      if (v39 != v218) {
        goto LABEL_313;
      }
      if (v217 <= v67)
      {
        if (v218 == v67) {
          unint64_t v226 = 1;
        }
        else {
          unint64_t v226 = (v218 - v67) >> 2;
        }
        if (v226 >> 61) {
          sub_19E37C2B8();
        }
        v227 = (char *)operator new(8 * v226);
        unint64_t v228 = v226 >> 2;
        v229 = &v227[8 * (v226 >> 2)];
        size_t v39 = v229;
        int64_t v230 = v218 - v217;
        if (v218 != v217)
        {
          size_t v39 = &v229[v230 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v231 = v230 - 8;
          if (v231 >= 0x38)
          {
            uint64_t v233 = 8 * v228;
            if ((unint64_t)(&v227[8 * v228] - v217) < 0x20)
            {
              v232 = &v227[8 * (v226 >> 2)];
              goto LABEL_335;
            }
            uint64_t v234 = (v231 >> 3) + 1;
            uint64_t v235 = 8 * (v234 & 0x3FFFFFFFFFFFFFFCLL);
            v232 = &v229[v235];
            v236 = (long long *)(v217 + 16);
            v237 = &v227[v233 + 16];
            uint64_t v238 = v234 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v239 = *v236;
              *((_OWORD *)v237 - 1) = *(v236 - 1);
              *(_OWORD *)v237 = v239;
              v236 += 2;
              v237 += 32;
              v238 -= 4;
            }
            while (v238);
            if (v234 != (v234 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v217 += v235;
              goto LABEL_335;
            }
          }
          else
          {
            v232 = &v227[8 * (v226 >> 2)];
            do
            {
LABEL_335:
              uint64_t v240 = *(void *)v217;
              v217 += 8;
              *(void *)v232 = v240;
              v232 += 8;
            }
            while (v232 != v39);
          }
        }
        v218 = &v227[8 * v226];
        if (__pd)
        {
          v67 = v227;
          v217 = v229;
          operator delete(__pd);
        }
        else
        {
          v217 = v229;
          v67 = v227;
        }
        goto LABEL_313;
      }
      uint64_t v221 = (v217 - v67) >> 3;
      if (v221 >= -1) {
        uint64_t v222 = v221 + 1;
      }
      else {
        uint64_t v222 = v221 + 2;
      }
      uint64_t v223 = v222 >> 1;
      v224 = &v217[-8 * (v222 >> 1)];
      v225 = v219;
      if (v219 != v217)
      {
        memmove(v224, v217, v219 - v217);
        v225 = v217;
      }
      size_t v39 = &v224[v219 - v217];
      v217 = &v225[-8 * v223];
      v67 = __pd;
      v218 = v219;
LABEL_313:
      *(void *)size_t v39 = v220;
      v39 += 8;
      --v64;
    }
    while (v64);
    for (m = *(void **)&v465[8]; v63; v218 = v244)
    {
      if (v39 == v218)
      {
        if (v217 <= v67)
        {
          __pe = v67;
          if (v218 == v67) {
            unint64_t v254 = 1;
          }
          else {
            unint64_t v254 = (v218 - v67) >> 2;
          }
          if (v254 >> 61) {
            sub_19E37C2B8();
          }
          v255 = v218;
          v256 = (char *)operator new(8 * v254);
          v257 = v256;
          unint64_t v258 = v254 >> 2;
          v245 = &v256[8 * (v254 >> 2)];
          size_t v39 = v245;
          int64_t v259 = v255 - v217;
          if (v255 != v217)
          {
            size_t v39 = &v245[v259 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v260 = v259 - 8;
            if (v260 >= 0x38)
            {
              uint64_t v262 = 8 * v258;
              if ((unint64_t)(&v256[8 * v258] - v217) < 0x20)
              {
                v261 = &v256[8 * (v254 >> 2)];
                goto LABEL_366;
              }
              uint64_t v263 = (v260 >> 3) + 1;
              uint64_t v264 = 8 * (v263 & 0x3FFFFFFFFFFFFFFCLL);
              v261 = &v245[v264];
              v265 = (long long *)(v217 + 16);
              v266 = &v256[v262 + 16];
              uint64_t v267 = v263 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v268 = *v265;
                *((_OWORD *)v266 - 1) = *(v265 - 1);
                *(_OWORD *)v266 = v268;
                v265 += 2;
                v266 += 32;
                v267 -= 4;
              }
              while (v267);
              if (v263 != (v263 & 0x3FFFFFFFFFFFFFFCLL))
              {
                v217 += v264;
                goto LABEL_366;
              }
            }
            else
            {
              v261 = &v256[8 * (v254 >> 2)];
              do
              {
LABEL_366:
                uint64_t v269 = *(void *)v217;
                v217 += 8;
                *(void *)v261 = v269;
                v261 += 8;
              }
              while (v261 != v39);
            }
          }
          v244 = &v256[8 * v254];
          if (__pe) {
            operator delete(__pe);
          }
          v67 = v257;
          goto LABEL_344;
        }
        uint64_t v246 = (v217 - v67) >> 3;
        if (v246 >= -1) {
          uint64_t v247 = v246 + 1;
        }
        else {
          uint64_t v247 = v246 + 2;
        }
        uint64_t v248 = v247 >> 1;
        v249 = &v217[-8 * (v247 >> 1)];
        v250 = v218;
        v244 = v218;
        size_t v251 = v218 - v217;
        if (v218 != v217)
        {
          v252 = v249;
          memmove(v249, v217, v251);
          v249 = v252;
          v250 = v217;
        }
        uint64_t v253 = -v248;
        size_t v39 = &v249[v251];
        v245 = &v250[8 * v253];
      }
      else
      {
        v244 = v218;
        v245 = v217;
      }
LABEL_344:
      *(void *)size_t v39 = *m;
      v39 += 8;
      m = (void *)(*(void *)&v465[8] + 8);
      *(void *)&v465[8] += 8;
      v217 = v245;
      --v63;
    }
    uint64_t v242 = *(void *)&v465[16];
    if (*(void **)&v465[16] != m)
    {
      while (v217 != v67)
      {
LABEL_371:
        uint64_t v270 = *(void *)(v242 - 8);
        v242 -= 8;
        *((void *)v217 - 1) = v270;
        v217 -= 8;
        if (v242 == *(void *)&v465[8]) {
          goto LABEL_341;
        }
      }
      if (v39 < v218)
      {
        uint64_t v271 = (v218 - v39) >> 3;
        if (v271 >= -1) {
          uint64_t v272 = v271 + 1;
        }
        else {
          uint64_t v272 = v271 + 2;
        }
        uint64_t v273 = v272 >> 1;
        v217 = &v67[8 * (v272 >> 1)];
        v274 = v67;
        if (v39 != v67)
        {
          memmove(v217, v67, v39 - v67);
          v274 = v39;
        }
        size_t v39 = &v274[8 * v273];
        goto LABEL_371;
      }
      if (v218 == v67) {
        unint64_t v275 = 1;
      }
      else {
        unint64_t v275 = (v218 - v67) >> 2;
      }
      if (v275 >> 61) {
        sub_19E37C2B8();
      }
      v276 = (char *)operator new(8 * v275);
      v277 = v276;
      unint64_t v278 = (v275 + 3) >> 2;
      v217 = &v276[8 * v278];
      v218 = &v276[8 * v275];
      int64_t v279 = v39 - v67;
      BOOL v18 = v39 == v67;
      size_t v39 = v217;
      if (!v18)
      {
        size_t v39 = &v217[v279 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v280 = v279 - 8;
        v281 = &v276[8 * v278];
        v282 = v67;
        if (v280 >= 0x38)
        {
          uint64_t v283 = 8 * v278;
          v281 = &v276[8 * v278];
          v282 = v67;
          if ((unint64_t)(v281 - v67) >= 0x20)
          {
            uint64_t v284 = (v280 >> 3) + 1;
            uint64_t v285 = 8 * (v284 & 0x3FFFFFFFFFFFFFFCLL);
            v281 = &v217[v285];
            v286 = (long long *)(v67 + 16);
            v287 = &v276[v283 + 16];
            uint64_t v288 = v284 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v289 = *v286;
              *((_OWORD *)v287 - 1) = *(v286 - 1);
              *(_OWORD *)v287 = v289;
              v286 += 2;
              v287 += 32;
              v288 -= 4;
            }
            while (v288);
            if (v284 == (v284 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_392;
            }
            v282 = &v67[v285];
          }
        }
        do
        {
          uint64_t v290 = *(void *)v282;
          v282 += 8;
          *(void *)v281 = v290;
          v281 += 8;
        }
        while (v281 != v39);
      }
      if (!v67)
      {
LABEL_393:
        v67 = v277;
        goto LABEL_371;
      }
LABEL_392:
      operator delete(v67);
      goto LABEL_393;
    }
LABEL_341:
    v243 = *(void **)v465;
    *(void *)v465 = v67;
    *(void *)&v465[8] = v217;
    *(void *)&v465[16] = v39;
    *(void *)&v465[24] = v218;
    unint64_t v46 = v416;
    v466.i64[0] -= v418;
    if (v243)
    {
      operator delete(v243);
      size_t v39 = *(char **)&v465[16];
    }
LABEL_401:
    uint64_t v34 = v466.i64[1];
    unint64_t v38 = *(char **)&v465[8];
    LOWORD(v36) = v466.i16[0] + v466.i16[4];
    unint64_t v37 = (unint64_t)(v466.i64[0] + v466.i64[1]) >> 12;
    i = v412;
LABEL_402:
    v294 = &v38[8 * v37];
    if (v39 == v38) {
      v295 = 0;
    }
    else {
      v295 = (unsigned char *)(*(void *)v294 + (v36 & 0xFFF));
    }
    unint64_t v322 = v34 - v46;
    if (v34 - v46 > 1)
    {
      unint64_t v323 = 2;
      v324 = "";
      v326 = v294;
      v327 = v295;
      goto LABEL_438;
    }
    unint64_t v323 = v34 - v46;
    if (v322 == 2)
    {
      v324 = "";
      v327 = v295;
      v326 = v294;
    }
    else
    {
      v324 = &aS_1[v322];
      unint64_t v325 = v34 - v46;
      v326 = v294;
      v327 = v295;
      do
      {
        *v327++ = aS_1[v325];
        if (&v327[-*(void *)v326] == (unsigned char *)4096)
        {
          v328 = (unsigned char *)*((void *)v326 + 1);
          v326 += 8;
          v327 = v328;
        }
        ++v466.i64[1];
        ++v325;
      }
      while (v325 != 2);
    }
    if (!v322) {
      goto LABEL_501;
    }
LABEL_438:
    uint64_t v329 = (uint64_t)&v295[-v323 - *(void *)v294];
    if (v329 < 1)
    {
      unint64_t v332 = 4095 - v329;
      v330 = &v294[-8 * (v332 >> 12)];
      v331 = (unsigned char *)(*(void *)v330 + (~(_WORD)v332 & 0xFFF));
    }
    else
    {
      v330 = &v294[8 * ((unint64_t)v329 >> 12)];
      v331 = (unsigned char *)(*(void *)v330 + (v329 & 0xFFF));
    }
    v333 = v330;
    for (n = v331; n != v295; ++v466.i64[1])
    {
      *v327++ = *n;
      if (&v327[-*(void *)v326] == (unsigned char *)4096)
      {
        v343 = (unsigned char *)*((void *)v326 + 1);
        v326 += 8;
        v327 = v343;
      }
      if (&(++n)[-*(void *)v333] == (unsigned char *)4096)
      {
        v344 = (unsigned char *)*((void *)v333 + 1);
        v333 += 8;
        n = v344;
      }
    }
    if (v323 >= v322) {
      goto LABEL_492;
    }
    v335 = *(unsigned char **)v294;
    uint64_t v336 = (uint64_t)&v295[-v322 - *(void *)v294];
    if (v336 < 1)
    {
      unint64_t v345 = 4095 - v336;
      v337 = &v294[-8 * (v345 >> 12)];
      v338 = (unsigned char *)(*(void *)v337 + (~(_WORD)v345 & 0xFFF));
      if (v337 == v330) {
        goto LABEL_460;
      }
LABEL_445:
      v339 = *(unsigned char **)v330;
      if (*(unsigned char **)v330 != v331)
      {
        while (1)
        {
          v340 = (char *)(v295 - v335);
          if (v331 - v339 >= (uint64_t)v340) {
            size_t v341 = (size_t)v340;
          }
          else {
            size_t v341 = v331 - v339;
          }
          v331 -= v341;
          v295 -= v341;
          if (v341) {
            memmove(v295, v331, v341);
          }
          if (v331 == v339) {
            break;
          }
          v342 = (unsigned char *)*((void *)v294 - 1);
          v294 -= 8;
          v335 = v342;
          v295 = v342 + 4096;
        }
        goto LABEL_468;
      }
      while (1)
      {
        v330 -= 8;
        if (v330 == v337) {
          break;
        }
        v350 = *(unsigned char **)v330;
        v351 = (char *)(*(void *)v330 + 4096);
        while (1)
        {
          v352 = (char *)(v295 - v335);
          if (v351 - v350 >= (uint64_t)v352) {
            size_t v353 = (size_t)v352;
          }
          else {
            size_t v353 = v351 - v350;
          }
          v351 -= v353;
          v295 -= v353;
          if (v353) {
            memmove(v295, v351, v353);
          }
          if (v351 == v350) {
            break;
          }
          v354 = (unsigned char *)*((void *)v294 - 1);
          v294 -= 8;
          v335 = v354;
          v295 = v354 + 4096;
        }
LABEL_468:
        v335 = *(unsigned char **)v294;
        if ((unsigned char *)(*(void *)v294 + 4096) == v295)
        {
          v349 = (unsigned char *)*((void *)v294 + 1);
          v294 += 8;
          v335 = v349;
          v295 = v349;
        }
      }
      v355 = (char *)(*(void *)v337 + 4096);
      if (v355 != v338)
      {
        uint64_t v356 = *(void *)v294;
        while (1)
        {
          v357 = &v295[-v356];
          if (v355 - v338 >= (uint64_t)v357) {
            size_t v358 = (size_t)v357;
          }
          else {
            size_t v358 = v355 - v338;
          }
          v355 -= v358;
          v295 -= v358;
          if (v358) {
            memmove(v295, v355, v358);
          }
          if (v355 == v338) {
            break;
          }
          uint64_t v359 = *((void *)v294 - 1);
          v294 -= 8;
          uint64_t v356 = v359;
          v295 = (unsigned char *)(v359 + 4096);
        }
        goto LABEL_488;
      }
      goto LABEL_491;
    }
    v337 = &v294[8 * ((unint64_t)v336 >> 12)];
    v338 = (unsigned char *)(*(void *)v337 + (v336 & 0xFFF));
    if (v337 != v330) {
      goto LABEL_445;
    }
LABEL_460:
    if (v338 == v331)
    {
LABEL_491:
      i = v412;
      goto LABEL_492;
    }
    while (1)
    {
      v346 = (char *)(v295 - v335);
      if (v331 - v338 >= (uint64_t)v346) {
        size_t v347 = (size_t)v346;
      }
      else {
        size_t v347 = v331 - v338;
      }
      v331 -= v347;
      v295 -= v347;
      if (v347) {
        memmove(v295, v331, v347);
      }
      if (v331 == v338) {
        break;
      }
      v348 = (unsigned char *)*((void *)v294 - 1);
      v294 -= 8;
      v335 = v348;
      v295 = v348 + 4096;
    }
LABEL_488:
    if ((unsigned char *)(*(void *)v294 + 4096) == v295)
    {
      v360 = (unsigned char *)*((void *)v294 + 1);
      v294 += 8;
      v295 = v360;
    }
    i = v412;
LABEL_492:
    if (v324 != "'s")
    {
      uint64_t v363 = *(void *)v294;
      v362 = (uint64_t *)(v294 - 8);
      uint64_t v361 = v363;
      while (1)
      {
        v364 = &v295[-v361];
        if (v324 - "'s" >= (uint64_t)v364) {
          size_t v365 = (size_t)v364;
        }
        else {
          size_t v365 = v324 - "'s";
        }
        v324 -= v365;
        if (v365) {
          memmove(&v295[-v365], v324, v365);
        }
        if (v324 == "'s") {
          break;
        }
        uint64_t v366 = *v362--;
        uint64_t v361 = v366;
        v295 = (unsigned char *)(v366 + 4096);
      }
    }
LABEL_501:
    uint64_t v367 = *(unsigned __int8 *)(v407 + 23);
    if ((v367 & 0x80u) == 0) {
      uint64_t v368 = v407;
    }
    else {
      uint64_t v368 = *(void *)v407;
    }
    if ((v367 & 0x80u) != 0) {
      uint64_t v367 = *(void *)(v407 + 8);
    }
    v369 = (unsigned char *)(v368 + v367);
    CFIndex v33 = v415;
    if (v415 == v369 || v410 == 0) {
      break;
    }
    v29 = v415;
LABEL_513:
    uint64_t v373 = 0;
    do
    {
      if (v29[v373] != v13[v373])
      {
        v371 = &v13[v373];
        v372 = &v29[v373];
        if (v371 == v409) {
          goto LABEL_519;
        }
LABEL_512:
        if (++v29 == v369) {
          goto LABEL_520;
        }
        goto LABEL_513;
      }
      uint64_t v374 = v373 + 1;
      if (&v29[v373 + 1] == v369) {
        break;
      }
      BOOL v18 = v27 == v373++;
    }
    while (!v18);
    v372 = &v29[v374];
    if (&v13[v374] != v409) {
      goto LABEL_512;
    }
LABEL_519:
    CFAllocatorRef v30 = v372;
  }
  while (v29 != v372);
LABEL_520:
  v375 = sub_19E4F6DDC((uint64_t)v465, i, v415, v369);
  int v376 = *(char *)(v407 + 23);
  if (v376 >= 0) {
    size_t v377 = *(unsigned __int8 *)(v407 + 23);
  }
  else {
    size_t v377 = *(void *)(v407 + 8);
  }
  if (v466.i64[1])
  {
    v378 = (char *)(*(void *)&v465[8] + 8 * ((unint64_t)v466.i64[0] >> 12));
    if (*(void *)&v465[16] != *(void *)&v465[8])
    {
      v379 = (std::string::value_type *)(*(void *)v378 + (v466.i16[0] & 0xFFF));
      v380 = (char *)(*(void *)&v465[8] + 8 * ((unint64_t)(v466.i64[0] + v466.i64[1]) >> 12));
      uint64_t v381 = *(void *)v380 + ((v466.i64[0] + v466.i64[1]) & 0xFFF);
      if ((std::string::value_type *)v381 != v379)
      {
        unint64_t v396 = v381 + ((v380 - v378) << 9) - (void)&v379[*(void *)v380] + *(void *)v378;
        if (v396)
        {
          memset(&cf, 0, sizeof(cf));
          do
          {
            std::string::push_back(&cf, *v379++);
            if (&v379[-*(void *)v378] == (std::string::value_type *)4096)
            {
              v397 = (std::string::value_type *)*((void *)v378 + 1);
              v378 += 8;
              v379 = v397;
            }
          }
          while (v379 != (std::string::value_type *)v381);
          std::string::size_type size = HIBYTE(cf.__r_.__value_.__r.__words[2]);
          if ((cf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_std::string cf = &cf;
          }
          else {
            p_std::string cf = (std::string *)cf.__r_.__value_.__r.__words[0];
          }
          if ((cf.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            std::string::size_type size = cf.__r_.__value_.__l.__size_;
          }
          sub_19E44412C((void *)v407, v396, v377, (char *)p_cf, (char *)p_cf + size);
          if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(cf.__r_.__value_.__l.__data_);
          }
        }
      }
    }
  }
  else
  {
    uint64_t v392 = *(void *)v407;
    if (v376 >= 0) {
      uint64_t v393 = v407;
    }
    else {
      uint64_t v393 = *(void *)v407;
    }
    uint64_t v394 = (uint64_t)&v375[-v393];
    if (v377 < (unint64_t)&v375[-v393]) {
      sub_19E3C4C28();
    }
    unint64_t v395 = v393 + v377 - (void)v375;
    if (v395 == -1)
    {
      if (v376 < 0)
      {
        *(void *)(v407 + 8) = v394;
        *(unsigned char *)(v392 + v394) = 0;
      }
      else
      {
        *(unsigned char *)(v407 + 23) = v394 & 0x7F;
        *(unsigned char *)(v407 + v394) = 0;
      }
    }
    else
    {
      sub_19E4F7520((void *)v407, v394, v395);
    }
  }
  v401 = *(void ***)&v465[16];
  v400 = *(void ***)&v465[8];
  v466.i64[1] = 0;
  unint64_t v402 = *(void *)&v465[16] - *(void *)&v465[8];
  if (*(void *)&v465[16] - *(void *)&v465[8] >= 0x11uLL)
  {
    do
    {
      operator delete(*v400);
      v401 = *(void ***)&v465[16];
      v400 = (void **)(*(void *)&v465[8] + 8);
      *(void *)&v465[8] = v400;
      unint64_t v402 = *(void *)&v465[16] - (void)v400;
    }
    while (*(void *)&v465[16] - (void)v400 > 0x10uLL);
  }
  unint64_t v403 = v402 >> 3;
  a4 = v407;
  if (v403 == 1)
  {
    uint64_t v404 = 2048;
LABEL_634:
    v466.i64[0] = v404;
  }
  else if (v403 == 2)
  {
    uint64_t v404 = 4096;
    goto LABEL_634;
  }
  if (v400 != v401)
  {
    do
    {
      v405 = *v400++;
      operator delete(v405);
    }
    while (v400 != v401);
    if (*(void *)&v465[16] != *(void *)&v465[8]) {
      *(void *)&v465[16] += (*(void *)&v465[8] - *(void *)&v465[16] + 7) & 0xFFFFFFFFFFFFFFF8;
    }
  }
  if (*(void *)v465) {
    operator delete(*(void **)v465);
  }
LABEL_36:
  if (a1[292])
  {
    long long v431 = 0uLL;
    size_t v432 = 0;
    int v19 = *(char *)(a4 + 23);
    if (v19 >= 0) {
      uint64_t v20 = a4;
    }
    else {
      uint64_t v20 = *(void *)a4;
    }
    if (v19 >= 0) {
      uint64_t v21 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v21 = *(void *)(a4 + 8);
    }
    uint64_t v22 = v20 + v21;
    unint64_t v23 = (unint64_t)off_1EF0BEA48 + 1;
    v439 = (char *)off_1EF0BEA48 + 1;
    *(void *)&long long v440 = "_U_CAP_";
    *((void *)&v440 + 1) = "";
    v442.i64[0] = v20;
    v442.i64[1] = v20;
    uint64_t v443 = v20;
    uint64_t v444 = v20 + v21;
    char v445 = 0;
    if (!v21) {
      goto LABEL_49;
    }
    uint64_t v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(((unint64_t)off_1EF0BEA48 & 0xFFFFFFFFFFFFFFFELL)
                                                                 + 8))((uint64_t *)&v440, v20, v22);
    uint64_t v22 = v444;
    if (v444 == v24 && v444 == v20 && v442.i64[1] == v20) {
      char v445 = 1;
    }
    unint64_t v23 = (unint64_t)v439;
    v442.i64[0] = v443;
    v442.i64[1] = v24;
    uint64_t v443 = v20;
    *(void *)v465 = 0;
    if (v439)
    {
LABEL_49:
      *(void *)v465 = v23;
      if (v23)
      {
        *(_OWORD *)&v465[8] = v440;
        *(void *)&v465[24] = v441;
      }
      else
      {
        (*(void (**)(long long *, unsigned char *, void))(v23 & 0xFFFFFFFFFFFFFFFELL))(&v440, &v465[8], 0);
        uint64_t v20 = v443;
        uint64_t v22 = v444;
        unint64_t v23 = (unint64_t)v439;
      }
    }
    int64x2_t v466 = v442;
    *(void *)&long long v467 = v20;
    *((void *)&v467 + 1) = v22;
    char v468 = v445;
    if (v23)
    {
      if ((v23 & 1) == 0)
      {
        v382 = *(void (**)(long long *, long long *, uint64_t))(v23 & 0xFFFFFFFFFFFFFFFELL);
        if (v382) {
          v382(&v440, &v440, 2);
        }
      }
      v439 = 0;
    }
    cf.__r_.__value_.__r.__words[0] = 0;
    long long v459 = 0u;
    long long v460 = 0u;
    char v461 = 1;
    v453[0] = 0;
    std::string::size_type v383 = *(void *)v465;
    if (*(void *)v465)
    {
      v453[0] = *(void *)v465;
      if (v465[0])
      {
        std::string::size_type v383 = 0;
        *(_OWORD *)&v453[1] = *(_OWORD *)&v465[8];
        v453[3] = *(void *)&v465[24];
      }
      else
      {
        (*(void (**)(unsigned char *, uint64_t *, void))(*(void *)v465 & 0xFFFFFFFFFFFFFFFELL))(&v465[8], &v453[1], 0);
        std::string::size_type v383 = cf.__r_.__value_.__r.__words[0];
      }
    }
    int64x2_t v454 = v466;
    long long v455 = v467;
    char v456 = v468;
    std::string::size_type v433 = 0;
    if (v383)
    {
      std::string::size_type v433 = v383;
      if (v383)
      {
        long long v434 = *(_OWORD *)&cf.__r_.__value_.__r.__words[1];
        uint64_t v435 = v458;
      }
      else
      {
        (*(void (**)(std::string::size_type *, long long *, void))(v383 & 0xFFFFFFFFFFFFFFFELL))(&cf.__r_.__value_.__l.__size_, &v434, 0);
      }
    }
    long long v436 = v459;
    long long v437 = v460;
    char v438 = v461;
    sub_19E4F650C((uint64_t)&v481, v453, (uint64_t *)&v433);
    if (v433)
    {
      if ((v433 & 1) == 0)
      {
        v384 = *(void (**)(long long *, long long *, uint64_t))(v433 & 0xFFFFFFFFFFFFFFFELL);
        if (v384) {
          v384(&v434, &v434, 2);
        }
      }
      std::string::size_type v433 = 0;
    }
    if (v453[0])
    {
      if ((v453[0] & 1) == 0)
      {
        v385 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v453[0] & 0xFFFFFFFFFFFFFFFELL);
        if (v385) {
          v385(&v453[1], &v453[1], 2);
        }
      }
      v453[0] = 0;
    }
    long long v386 = v481;
    long long v431 = v481;
    size_t v432 = v482;
    if (cf.__r_.__value_.__r.__words[0])
    {
      if ((cf.__r_.__value_.__s.__data_[0] & 1) == 0)
      {
        v387 = *(void (**)(std::string::size_type *, std::string::size_type *, uint64_t))(cf.__r_.__value_.__r.__words[0] & 0xFFFFFFFFFFFFFFFELL);
        if (v387)
        {
          long long v425 = v481;
          v387(&cf.__r_.__value_.__l.__size_, &cf.__r_.__value_.__l.__size_, 2);
          long long v386 = v425;
        }
      }
    }
    v406 = (void *)(a4 + 8);
    if (*(void *)v465)
    {
      if ((v465[0] & 1) == 0)
      {
        v388 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)v465 & 0xFFFFFFFFFFFFFFFELL);
        if (v388)
        {
          long long v426 = v386;
          v388(&v465[8], &v465[8], 2);
          long long v386 = v426;
        }
      }
    }
    v389 = (void **)*((void *)&v386 + 1);
    v390 = (void **)v386;
    if (*((void *)&v386 + 1) - (void)v386 != 24)
    {
      if (*((void *)&v386 + 1) != (void)v386)
      {
        long long v429 = 0uLL;
        uint64_t v430 = 0;
        size_t __n = 1;
        __src = (void *)32;
        std::__sort<std::__less<char,char> &,char *>();
        size_t v449 = __n;
        v448[0] = 0;
        if (__n < 0x11)
        {
          memcpy(v448, &__src, __n);
          *(void *)&v465[16] = v449;
          *(void *)v465 = 0;
          if (v449 < 0x11)
          {
            memcpy(v465, v448, v449);
            size_t v451 = *(void *)&v465[16];
            __dst[0] = 0;
            if (*(void *)&v465[16] <= 0x10uLL)
            {
              memcpy(__dst, v465, *(size_t *)&v465[16]);
              int v452 = 1;
              size_t v463 = v451;
              v462[0] = 0;
              if (v451 < 0x11)
              {
                memcpy(v462, __dst, v451);
                int v464 = 1;
                size_t v470 = v463;
                v469[0] = 0;
                if (v463 < 0x11)
                {
                  memcpy(v469, v462, v463);
                  int v471 = 1;
                  size_t v473 = v470;
                  v472[0] = 0;
                  if (v470 < 0x11)
                  {
                    memcpy(v472, v469, v470);
                    int v474 = 1;
                    v439 = 0;
                    size_t v476 = v473;
                    v475[0] = 0;
                    if (v473 < 0x11)
                    {
                      memcpy(v475, v472, v473);
                      int v477 = 1;
                      size_t v479 = v476;
                      v478[0] = 0;
                      if (v476 < 0x11)
                      {
                        memcpy(v478, v475, v476);
                        int v480 = 1;
                        size_t v482 = v479;
                        *(void *)&long long v481 = 0;
                        if (v479 < 0x11)
                        {
                          memcpy(&v481, v478, v479);
                          int v483 = 1;
                          cf.__r_.__value_.__r.__words[2] = v482;
                          cf.__r_.__value_.__r.__words[0] = 0;
                          if (v482 < 0x11)
                          {
                            memcpy(&cf, &v481, v482);
                            LODWORD(v458) = 1;
                            operator new();
                          }
                          operator new[]();
                        }
                        operator new[]();
                      }
                      operator new[]();
                    }
                    operator new[]();
                  }
                  operator new[]();
                }
                operator new[]();
              }
              operator new[]();
            }
            operator new[]();
          }
          operator new[]();
        }
        operator new[]();
      }
      v453[0] = 0;
      *(uint64_t *)((char *)v453 + 7) = 0;
      memset(v465, 0, 24);
      if (*(char *)(a4 + 23) < 0)
      {
        operator delete(*(void **)a4);
        int v391 = v465[23];
        *(void *)a4 = 0;
        void *v406 = v453[0];
        *(void *)(a4 + 15) = *(uint64_t *)((char *)v453 + 7);
        *(unsigned char *)(a4 + 23) = 0;
        if (v391 < 0) {
          operator delete(*(void **)v465);
        }
      }
      else
      {
        *(void *)a4 = 0;
        void *v406 = v453[0];
        *(void *)(a4 + 15) = *(uint64_t *)((char *)v453 + 7);
        *(unsigned char *)(a4 + 23) = 0;
      }
    }
    if (v390)
    {
      if (v389 != v390)
      {
        do
        {
          if (*((char *)v389 - 1) < 0) {
            operator delete(*(v389 - 3));
          }
          v389 -= 3;
        }
        while (v389 != v390);
        v389 = v390;
      }
      operator delete(v389);
    }
  }
  if (SHIBYTE(v428) < 0) {
    operator delete(v427[0]);
  }
}

void sub_19E4F5C60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (*(char *)(a10 + 23) < 0) {
    operator delete(*(void **)a10);
  }
  if (a39 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void sub_19E4F5E0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
}

void sub_19E4F5E38()
{
}

void sub_19E4F5E40(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    if (SLOBYTE(STACK[0x267]) < 0) {
      operator delete((void *)STACK[0x250]);
    }
    __cxa_rethrow();
  }
  JUMPOUT(0x19E4F619CLL);
}

void sub_19E4F5E68()
{
}

void sub_19E4F5E78(_Unwind_Exception *exception_object)
{
}

void sub_19E4F5E98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,unint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  sub_19E4F6940((uint64_t *)&STACK[0x200]);
  sub_19E4F6940((uint64_t *)&STACK[0x250]);
  sub_19E4F6940((uint64_t *)&STACK[0x2C0]);
  if (v72 >= 0x11 && a72) {
    MEMORY[0x19F3BDCC0](a72, 0x1000C8077774924);
  }
  if (a31 >= 0x11 && a69) {
    MEMORY[0x19F3BDCC0](a69, 0x1000C8077774924);
  }
  if ((unint64_t)a68 >= 0x11 && a66) {
    MEMORY[0x19F3BDCC0](a66, 0x1000C8077774924);
  }
  sub_19E3EB09C(&a40);
  sub_19E3EB09C(&a44);
  if (*(char *)(a10 + 23) < 0) {
    operator delete(*(void **)a10);
  }
  if (a39 < 0) {
    operator delete(a34);
  }
  JUMPOUT(0x19E4F619CLL);
}

void sub_19E4F614C(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4F61A4(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  int v8 = a2;
  uint64_t v9 = a3 - 1;
  if (a3 == 1 && *a2 == *(_DWORD *)(a1 + 68))
  {
    *(unsigned char *)(a4 + 23) = 5;
    strcpy((char *)a4, "<unk>");
  }
  else
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    uint64_t v10 = a3;
    __p = 0;
    uint64_t v24 = 0;
    CFIndex v25 = 0;
    if (4 * a3)
    {
      if (v10 * 4 < 0) {
        sub_19E37C7C4();
      }
      uint64_t v11 = operator new(4 * a3);
      __p = v11;
      CFIndex v25 = &v11[(4 * a3) >> 2];
      if (a3)
      {
        if ((v9 & 0x3FFFFFFFFFFFFFFFuLL) < 7) {
          goto LABEL_25;
        }
        if ((unint64_t)((char *)v11 - (char *)a2) < 0x20) {
          goto LABEL_25;
        }
        uint64_t v12 = (v9 & 0x3FFFFFFFFFFFFFFFLL) + 1;
        uint64_t v13 = v12 & 0x7FFFFFFFFFFFFFF8;
        int v8 = &a2[v13];
        size_t v14 = v11 + 4;
        char v15 = (long long *)(a2 + 4);
        uint64_t v16 = v12 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v17 = *v15;
          *(v14 - 1) = *(v15 - 1);
          *size_t v14 = v17;
          v14 += 2;
          v15 += 2;
          v16 -= 8;
        }
        while (v16);
        uint64_t v11 = (_DWORD *)((char *)v11 + v13 * 4);
        if (v12 != (v12 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_25:
          do
          {
            int v18 = *v8++;
            *v11++ = v18;
          }
          while (v8 != &a2[v10]);
        }
      }
      uint64_t v24 = v11;
    }
    sub_19E387170(a1 + 128, (uint64_t)&__p, a4, &v22);
    if (v22)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      sub_19E3AD800((uint64_t)&v22, &v21);
      if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v20 = &v21;
      }
      else {
        uint64_t v20 = (std::string *)v21.__r_.__value_.__r.__words[0];
      }
      MEMORY[0x19F3BD790](exception, v20);
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    sub_19E3AD4CC(&v22);
    if (__p)
    {
      uint64_t v24 = __p;
      operator delete(__p);
    }
  }
}

void sub_19E4F6374(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18)
{
  if (__p)
  {
    operator delete(__p);
    if ((*(char *)(v18 + 23) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v18 + 23) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*(void **)v18);
  _Unwind_Resume(exception_object);
}

void sub_19E4F63F0(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a2 != a3)
  {
    int v6 = *(char *)(a2 + 23);
    if (v6 >= 0) {
      unint64_t v7 = (char *)a2;
    }
    else {
      unint64_t v7 = *(char **)a2;
    }
    if (v6 >= 0) {
      unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      unint64_t v8 = *(void *)(a2 + 8);
    }
    sub_19E443C00(a1, a1, v7, &v7[v8], v8);
    v4 += 24;
  }
  for (; v4 != a3; v4 += 24)
  {
    uint64_t v9 = *(unsigned __int8 *)(a1 + 23);
    if ((v9 & 0x80u) == 0) {
      unint64_t v10 = a1;
    }
    else {
      unint64_t v10 = *(void *)a1;
    }
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a1 + 8);
    }
    sub_19E443D84((unint64_t *)a1, v10 + v9, (unint64_t)" ", "", 1uLL);
    uint64_t v11 = *(unsigned __int8 *)(a1 + 23);
    if ((v11 & 0x80u) == 0) {
      unint64_t v12 = a1;
    }
    else {
      unint64_t v12 = *(void *)a1;
    }
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a1 + 8);
    }
    uint64_t v13 = v12 + v11;
    int v14 = *(char *)(v4 + 23);
    if (v14 >= 0) {
      char v15 = (char *)v4;
    }
    else {
      char v15 = *(char **)v4;
    }
    if (v14 >= 0) {
      unint64_t v16 = *(unsigned __int8 *)(v4 + 23);
    }
    else {
      unint64_t v16 = *(void *)(v4 + 8);
    }
    sub_19E443C00(a1, v13, v15, &v15[v16], v16);
  }
}

void sub_19E4F64E8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E4F650C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v42 = 0;
  uint64_t v6 = *a2;
  if (*a2)
  {
    uint64_t v42 = *a2;
    if (v6)
    {
      long long v43 = *(_OWORD *)(a2 + 1);
      uint64_t v44 = a2[3];
    }
    else
    {
      (*(void (**)(uint64_t *, long long *, void))(v6 & 0xFFFFFFFFFFFFFFFELL))(a2 + 1, &v43, 0);
    }
  }
  long long v7 = *((_OWORD *)a2 + 3);
  long long v45 = *((_OWORD *)a2 + 2);
  long long v46 = v7;
  char v47 = *((unsigned char *)a2 + 64);
  uint64_t v36 = 0;
  uint64_t v8 = *a3;
  if (*a3)
  {
    uint64_t v36 = *a3;
    if (v8)
    {
      long long v37 = *(_OWORD *)(a3 + 1);
      uint64_t v38 = a3[3];
    }
    else
    {
      (*(void (**)(uint64_t *, long long *, void))(v8 & 0xFFFFFFFFFFFFFFFELL))(a3 + 1, &v37, 0);
    }
  }
  long long v9 = *((_OWORD *)a3 + 3);
  long long v39 = *((_OWORD *)a3 + 2);
  long long v40 = v9;
  char v41 = *((unsigned char *)a3 + 64);
  uint64_t v50 = a1;
  char v51 = 0;
  while (1)
  {
    uint64_t v10 = v42;
    if (v42) {
      BOOL v11 = v47 == 0;
    }
    else {
      BOOL v11 = 0;
    }
    int v12 = !v11;
    if (!v36)
    {
      if (v12) {
        goto LABEL_57;
      }
      goto LABEL_26;
    }
    if (((v41 == 0) & ~v12) != 0) {
      break;
    }
    if (((v12 ^ (v41 != 0)) & 1) == 0) {
      goto LABEL_54;
    }
LABEL_26:
    int v14 = (char *)*((void *)&v45 + 1);
    uint64_t v13 = (char *)v45;
    unint64_t v15 = *((void *)&v45 + 1) - v45;
    if (*((void *)&v45 + 1) - (void)v45 >= 0x7FFFFFFFFFFFFFF8uLL) {
      sub_19E37C958();
    }
    if (v15 > 0x16)
    {
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v17 = v15 | 7;
      }
      uint64_t v18 = v17 + 1;
      unint64_t v16 = (long long *)operator new(v17 + 1);
      *((void *)&v48 + 1) = v15;
      unint64_t v49 = v18 | 0x8000000000000000;
      *(void *)&long long v48 = v16;
      if (v13 == v14) {
        goto LABEL_43;
      }
    }
    else
    {
      HIBYTE(v49) = BYTE8(v45) - v45;
      unint64_t v16 = &v48;
      if ((void)v45 == *((void *)&v45 + 1)) {
        goto LABEL_43;
      }
    }
    if (v15 < 0x20 || (unint64_t)((char *)v16 - v13) < 0x20)
    {
      uint64_t v20 = v16;
    }
    else
    {
      unint64_t v19 = v15 & 0xFFFFFFFFFFFFFFE0;
      uint64_t v20 = (long long *)((char *)v16 + (v15 & 0xFFFFFFFFFFFFFFE0));
      std::string v21 = (long long *)(v13 + 16);
      uint64_t v22 = v16 + 1;
      unint64_t v23 = v15 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v24 = *v21;
        *(v22 - 1) = *(v21 - 1);
        *uint64_t v22 = v24;
        v21 += 2;
        v22 += 2;
        v23 -= 32;
      }
      while (v23);
      if (v15 == v19)
      {
        unint64_t v16 = (long long *)((char *)v16 + (v15 & 0xFFFFFFFFFFFFFFE0));
        goto LABEL_43;
      }
      v13 += v19;
    }
    unint64_t v16 = v20;
    do
    {
      char v25 = *v13++;
      *(unsigned char *)unint64_t v16 = v25;
      unint64_t v16 = (long long *)((char *)v16 + 1);
    }
    while (v13 != v14);
LABEL_43:
    *(unsigned char *)unint64_t v16 = 0;
    unint64_t v26 = *(void *)(a1 + 8);
    if (v26 >= *(void *)(a1 + 16))
    {
      uint64_t v28 = sub_19E3EB1B8((void **)a1, (uint64_t)&v48);
      int v29 = SHIBYTE(v49);
      *(void *)(a1 + 8) = v28;
      if (v29 < 0) {
        operator delete((void *)v48);
      }
    }
    else
    {
      long long v27 = v48;
      *(void *)(v26 + 16) = v49;
      *(_OWORD *)unint64_t v26 = v27;
      *(void *)(a1 + 8) = v26 + 24;
    }
    uint64_t v30 = *((void *)&v46 + 1);
    if (v42)
    {
      uint64_t v31 = (*(uint64_t (**)(long long *, void, void))((v42 & 0xFFFFFFFFFFFFFFFELL) + 8))(&v43, v46, *((void *)&v46 + 1));
      uint64_t v30 = *((void *)&v46 + 1);
      if (v31 != *((void *)&v46 + 1)) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v32 = *((void *)&v46 + 1);
      uint64_t v31 = *((void *)&v46 + 1);
    }
    if (v32 == v30 && *((void *)&v45 + 1) == v30) {
      char v47 = 1;
    }
LABEL_10:
    *(void *)&long long v45 = v46;
    *((void *)&v45 + 1) = v31;
    *(void *)&long long v46 = v32;
  }
  if (*((void *)&v45 + 1) - (void)v45 != *((void *)&v39 + 1) - (void)v39
    || memcmp((const void *)v45, (const void *)v39, *((void *)&v45 + 1) - v45)
    || v46 != v40)
  {
    goto LABEL_26;
  }
LABEL_54:
  if ((v36 & 1) == 0)
  {
    CFIndex v33 = *(void (**)(long long *, long long *, uint64_t))(v36 & 0xFFFFFFFFFFFFFFFELL);
    if (v33)
    {
      v33(&v37, &v37, 2);
      uint64_t v10 = v42;
    }
  }
LABEL_57:
  if (v10)
  {
    if ((v10 & 1) == 0)
    {
      uint64_t v34 = *(void (**)(long long *, long long *, uint64_t))(v10 & 0xFFFFFFFFFFFFFFFELL);
      if (v34) {
        v34(&v43, &v43, 2);
      }
    }
  }
  return a1;
}

void sub_19E4F68A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  sub_19E4F6940((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E4F68EC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t *sub_19E4F6940(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

uint64_t *sub_19E4F6994(uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    if ((v2 & 1) == 0)
    {
      uint64_t v3 = *(void (**)(uint64_t *, uint64_t *, uint64_t))(v2 & 0xFFFFFFFFFFFFFFFELL);
      if (v3) {
        v3(a1 + 1, a1 + 1, 2);
      }
    }
    *a1 = 0;
  }
  return a1;
}

char *sub_19E4F69E8(uint64_t a1, char *a2, char *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  long long v5 = *(void **)a1;
  size_t v6 = *(void *)(*(void *)a1 + 16);
  unint64_t v40 = v6;
  v39[0] = 0;
  if (v6 >= 0x11) {
    operator new[]();
  }
  memcpy(v39, v5, v6);
  if (a2 == a3)
  {
LABEL_28:
    a2 = a3;
    if (v40 < 0x11) {
      goto LABEL_31;
    }
    goto LABEL_29;
  }
  if (v40 > 0x10)
  {
    while (1)
    {
      int v14 = *a2;
      unint64_t v15 = (char *)v39[0];
      unint64_t v16 = v40;
      do
      {
        unint64_t v17 = v16 >> 1;
        uint64_t v18 = &v15[v16 >> 1];
        int v20 = *v18;
        unint64_t v19 = v18 + 1;
        v16 += ~(v16 >> 1);
        if (v20 < v14) {
          unint64_t v15 = v19;
        }
        else {
          unint64_t v16 = v17;
        }
      }
      while (v16);
      if (v15 != (char *)(v39[0] + v40) && *v15 <= v14) {
        break;
      }
      if (++a2 == a3) {
        goto LABEL_28;
      }
    }
  }
  else
  {
    if (!v40) {
      return a3;
    }
    while (1)
    {
      int v7 = *a2;
      uint64_t v8 = v39;
      unint64_t v9 = v40;
      do
      {
        unint64_t v10 = v9 >> 1;
        BOOL v11 = (char *)v8 + (v9 >> 1);
        int v13 = *v11;
        int v12 = v11 + 1;
        v9 += ~(v9 >> 1);
        if (v13 < v7) {
          uint64_t v8 = v12;
        }
        else {
          unint64_t v9 = v10;
        }
      }
      while (v9);
      if (v8 != (void *)((char *)v39 + v40) && *(char *)v8 <= v7) {
        break;
      }
      if (++a2 == a3) {
        goto LABEL_28;
      }
    }
  }
  if (v40 >= 0x11)
  {
LABEL_29:
    if (v39[0]) {
      MEMORY[0x19F3BDCC0](v39[0], 0x1000C8077774924);
    }
  }
LABEL_31:
  if (a2 == a3) {
    return a3;
  }
  if (*((_DWORD *)v5 + 6)) {
    return a2;
  }
  unint64_t v21 = v5[2];
  if (v21 > 0x10)
  {
    uint64_t v30 = a2;
    while (1)
    {
      int v31 = *v30;
      uint64_t v32 = (char *)*v5;
      unint64_t v33 = v5[2];
      do
      {
        unint64_t v34 = v33 >> 1;
        uint64_t v35 = &v32[v33 >> 1];
        int v37 = *v35;
        uint64_t v36 = v35 + 1;
        v33 += ~(v33 >> 1);
        if (v37 < v31) {
          uint64_t v32 = v36;
        }
        else {
          unint64_t v33 = v34;
        }
      }
      while (v33);
      if (v32 == (char *)(*v5 + v21) || *v32 > v31) {
        break;
      }
      if (++v30 == a3) {
        return a2;
      }
    }
  }
  else
  {
    if (!v21) {
      return a2;
    }
    uint64_t v22 = a2;
    while (1)
    {
      int v23 = *v22;
      long long v24 = (char *)v5;
      unint64_t v25 = v5[2];
      do
      {
        unint64_t v26 = v25 >> 1;
        long long v27 = &v24[v25 >> 1];
        int v29 = *v27;
        uint64_t v28 = v27 + 1;
        v25 += ~(v25 >> 1);
        if (v29 < v23) {
          long long v24 = v28;
        }
        else {
          unint64_t v25 = v26;
        }
      }
      while (v25);
      if (v24 == (char *)v5 + v21 || *v24 > v23) {
        break;
      }
      if (++v22 == a3) {
        return a2;
      }
    }
  }
  return a2;
}

uint64_t sub_19E4F6CC0(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = a1[1];
    if (*a1 == v5) {
      return a3;
    }
    while (1)
    {
      uint64_t v6 = 0;
      do
      {
        if (*(unsigned __int8 *)(v3 + v6) != *(unsigned __int8 *)(v4 + v6)) {
          break;
        }
        if (++v6 + v3 == a3) {
          break;
        }
      }
      while (v6 + v4 != v5);
      if (v4 + v6 == v5) {
        break;
      }
      if (++v3 == a3) {
        return a3;
      }
    }
  }
  return v3;
}

uint64_t sub_19E4F6D3C(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(void *)a2 = &unk_1EF0B7590;
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      os_log_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost9algorithm6detail13first_finderFIPKcNS0_8is_equalEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (os_log_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost9algorithm6detail13first_finderFIPKcNS0_8is_equalEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

unsigned char *sub_19E4F6DDC(uint64_t a1, unsigned char *__dst, unsigned char *__src, unsigned char *a4)
{
  uint64_t v6 = __dst;
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    BOOL v9 = __dst == __src;
  }
  else {
    BOOL v9 = 1;
  }
  if (!v9)
  {
    v97 = *(void ***)(a1 + 8);
    unint64_t v98 = *(void *)(a1 + 32);
    do
    {
      *uint64_t v6 = (*(unsigned char **)((char *)v97 + ((v98 >> 9) & 0x7FFFFFFFFFFFF8)))[v98 & 0xFFF];
      v97 = *(void ***)(a1 + 8);
      uint64_t v8 = *(void *)(a1 + 40) - 1;
      unint64_t v98 = *(void *)(a1 + 32) + 1;
      *(void *)(a1 + 32) = v98;
      *(void *)(a1 + 40) = v8;
      if (v98 >= 0x2000)
      {
        operator delete(*v97);
        v97 = (void **)(*(void *)(a1 + 8) + 8);
        *(void *)(a1 + 8) = v97;
        uint64_t v8 = *(void *)(a1 + 40);
        unint64_t v98 = *(void *)(a1 + 32) - 4096;
        *(void *)(a1 + 32) = v98;
      }
      ++v6;
      if (v8) {
        BOOL v99 = v6 == __src;
      }
      else {
        BOOL v99 = 1;
      }
    }
    while (!v99);
  }
  if (v8)
  {
    if (v6 != a4)
    {
      unint64_t v10 = *(void ***)(a1 + 8);
      unint64_t v11 = *(void *)(a1 + 32);
      uint64_t v102 = a4;
      while (1)
      {
        int v12 = *(char **)(a1 + 16);
        uint64_t v13 = v12 - (char *)v10;
        uint64_t v14 = v12 == (char *)v10 ? 0 : ((v12 - (char *)v10) << 9) - 1;
        unint64_t v15 = *(void *)(a1 + 40) + v11;
        if (v14 == v15) {
          break;
        }
LABEL_93:
        (*(unsigned char **)((char *)v10 + ((v15 >> 9) & 0x7FFFFFFFFFFFF8)))[v15 & 0xFFF] = *v6;
        unint64_t v83 = *(void *)(a1 + 32);
        ++*(void *)(a1 + 40);
        *uint64_t v6 = *(unsigned char *)(*(void *)(*(void *)(a1 + 8) + ((v83 >> 9) & 0x7FFFFFFFFFFFF8)) + (v83 & 0xFFF));
        unint64_t v10 = *(void ***)(a1 + 8);
        int64x2_t v84 = vaddq_s64(*(int64x2_t *)(a1 + 32), (int64x2_t)xmmword_19E573100);
        *(int64x2_t *)(a1 + 32) = v84;
        unint64_t v11 = v84.i64[0];
        if (v84.i64[0] >= 0x2000uLL)
        {
          operator delete(*v10);
          unint64_t v10 = (void **)(*(void *)(a1 + 8) + 8);
          *(void *)(a1 + 8) = v10;
          unint64_t v11 = *(void *)(a1 + 32) - 4096;
          *(void *)(a1 + 32) = v11;
        }
        if (++v6 == a4) {
          return a4;
        }
      }
      BOOL v16 = v11 >= 0x1000;
      unint64_t v17 = v11 - 4096;
      if (v16)
      {
        *(void *)(a1 + 32) = v17;
        uint64_t v18 = (char *)(v10 + 1);
        unint64_t v19 = *v10;
        *(void *)(a1 + 8) = v10 + 1;
        if (v12 == *(char **)(a1 + 24))
        {
          int v20 = *(char **)a1;
          if ((unint64_t)v18 > *(void *)a1)
          {
            uint64_t v21 = (uint64_t)&v18[-*(void *)a1] >> 3;
            if (v21 >= -1) {
              uint64_t v22 = v21 + 1;
            }
            else {
              uint64_t v22 = v21 + 2;
            }
            uint64_t v23 = v22 >> 1;
            long long v24 = &v18[-8 * (v22 >> 1)];
            int64_t v25 = v12 - v18;
            if (v12 != v18)
            {
              memmove(&v18[-8 * (v22 >> 1)], v10 + 1, v12 - v18);
              int v12 = *(char **)(a1 + 8);
            }
            unint64_t v26 = &v12[-8 * v23];
            int v12 = &v24[v25];
            goto LABEL_24;
          }
          unint64_t v38 = (v12 - v20) >> 2;
          if (v12 == v20) {
            unint64_t v38 = 1;
          }
          if (v38 >> 61) {
LABEL_120:
          }
            sub_19E37C2B8();
          unint64_t v39 = v38 >> 2;
          uint64_t v40 = 8 * v38;
          uint64_t v41 = (char *)operator new(8 * v38);
          uint64_t v42 = &v41[8 * v39];
          int64_t v43 = v12 - v18;
          BOOL v9 = v12 == v18;
          int v12 = v42;
          if (!v9)
          {
            int v12 = &v42[v43 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v44 = v43 - 8;
            if ((unint64_t)(v43 - 8) >= 0x38)
            {
              long long v45 = &v41[8 * v39];
              if ((unint64_t)(v45 - v18) >= 0x20)
              {
                uint64_t v76 = (v44 >> 3) + 1;
                uint64_t v77 = 8 * (v76 & 0x3FFFFFFFFFFFFFFCLL);
                long long v45 = &v42[v77];
                unint64_t v78 = (long long *)(v10 + 3);
                v79 = &v41[8 * v39 + 16];
                uint64_t v80 = v76 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v81 = *v78;
                  *((_OWORD *)v79 - 1) = *(v78 - 1);
                  *(_OWORD *)v79 = v81;
                  v78 += 2;
                  v79 += 32;
                  v80 -= 4;
                }
                while (v80);
                if (v76 == (v76 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_89;
                }
                v18 += v77;
              }
            }
            else
            {
              long long v45 = &v41[8 * v39];
            }
            do
            {
              uint64_t v82 = *(void *)v18;
              v18 += 8;
              *(void *)long long v45 = v82;
              v45 += 8;
            }
            while (v45 != v12);
          }
LABEL_89:
          *(void *)a1 = v41;
          *(void *)(a1 + 8) = v42;
          *(void *)(a1 + 16) = v12;
          *(void *)(a1 + 24) = &v41[v40];
          a4 = v102;
          if (v20)
          {
            operator delete(v20);
            int v12 = *(char **)(a1 + 16);
          }
        }
LABEL_91:
        *(void *)int v12 = v19;
        *(void *)(a1 + 16) += 8;
        goto LABEL_92;
      }
      uint64_t v27 = v13 >> 3;
      uint64_t v28 = *(char **)(a1 + 24);
      uint64_t v29 = (uint64_t)&v28[-*(void *)a1];
      if (v13 >> 3 < (unint64_t)(v29 >> 3))
      {
        if (v28 != v12)
        {
          uint64_t v103 = operator new(0x1000uLL);
          sub_19E4F7670((char **)a1, &v103);
          a4 = v102;
LABEL_92:
          unint64_t v10 = *(void ***)(a1 + 8);
          unint64_t v15 = *(void *)(a1 + 40) + *(void *)(a1 + 32);
          goto LABEL_93;
        }
        uint64_t v103 = operator new(0x1000uLL);
        sub_19E4F77FC((void **)a1, &v103);
        long long v46 = *(void **)(a1 + 8);
        int v12 = *(char **)(a1 + 16);
        char v47 = (char *)(v46 + 1);
        unint64_t v19 = (void *)*v46;
        *(void *)(a1 + 8) = v46 + 1;
        a4 = v102;
        if (v12 == *(char **)(a1 + 24))
        {
          int v20 = *(char **)a1;
          if ((unint64_t)v47 > *(void *)a1)
          {
            uint64_t v48 = (uint64_t)&v47[-*(void *)a1] >> 3;
            if (v48 >= -1) {
              uint64_t v49 = v48 + 1;
            }
            else {
              uint64_t v49 = v48 + 2;
            }
            uint64_t v50 = v49 >> 1;
            char v51 = &v47[-8 * (v49 >> 1)];
            int64_t v52 = v12 - v47;
            if (v12 != v47)
            {
              memmove(&v47[-8 * (v49 >> 1)], v47, v12 - v47);
              char v47 = *(char **)(a1 + 8);
            }
            int v12 = &v51[v52];
            unint64_t v26 = &v47[-8 * v50];
LABEL_24:
            *(void *)(a1 + 8) = v26;
            *(void *)(a1 + 16) = v12;
            a4 = v102;
            goto LABEL_91;
          }
          unint64_t v85 = (v12 - v20) >> 2;
          if (v12 == v20) {
            unint64_t v85 = 1;
          }
          if (v85 >> 61) {
            goto LABEL_120;
          }
          unint64_t v86 = v85 >> 2;
          uint64_t v40 = 8 * v85;
          uint64_t v41 = (char *)operator new(8 * v85);
          uint64_t v42 = &v41[8 * v86];
          int64_t v87 = v12 - v47;
          BOOL v9 = v12 == v47;
          int v12 = v42;
          if (!v9)
          {
            int v12 = &v42[v87 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v88 = v87 - 8;
            if ((unint64_t)(v87 - 8) < 0x38)
            {
              v89 = &v41[8 * v86];
              goto LABEL_106;
            }
            v89 = &v41[8 * v86];
            if ((unint64_t)(v89 - v47) < 0x20)
            {
              do
              {
LABEL_106:
                uint64_t v96 = *(void *)v47;
                v47 += 8;
                *(void *)v89 = v96;
                v89 += 8;
              }
              while (v89 != v12);
              goto LABEL_89;
            }
            uint64_t v90 = (v88 >> 3) + 1;
            uint64_t v91 = 8 * (v90 & 0x3FFFFFFFFFFFFFFCLL);
            v89 = &v42[v91];
            long long v92 = (long long *)(v46 + 3);
            uint64_t v93 = &v41[8 * v86 + 16];
            uint64_t v94 = v90 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v95 = *v92;
              *((_OWORD *)v93 - 1) = *(v92 - 1);
              *(_OWORD *)uint64_t v93 = v95;
              v92 += 2;
              v93 += 32;
              v94 -= 4;
            }
            while (v94);
            if (v90 != (v90 & 0x3FFFFFFFFFFFFFFCLL))
            {
              v47 += v91;
              goto LABEL_106;
            }
          }
          goto LABEL_89;
        }
        goto LABEL_91;
      }
      uint64_t v30 = v29 >> 2;
      if (v28 == *(char **)a1) {
        unint64_t v31 = 1;
      }
      else {
        unint64_t v31 = v30;
      }
      if (v31 >> 61) {
        goto LABEL_120;
      }
      uint64_t v32 = (char *)operator new(8 * v31);
      unint64_t v33 = operator new(0x1000uLL);
      unint64_t v34 = &v32[8 * v27];
      uint64_t v35 = &v32[8 * v31];
      if (v27 == v31)
      {
        uint64_t v36 = v33;
        if (v13 < 1)
        {
          if (v12 == (char *)v10) {
            unint64_t v53 = 1;
          }
          else {
            unint64_t v53 = v13 >> 2;
          }
          if (v53 >> 61) {
            sub_19E37C2B8();
          }
          unint64_t v34 = (char *)operator new(8 * v53);
          uint64_t v35 = &v34[8 * v53];
          operator delete(v32);
          unint64_t v10 = *(void ***)(a1 + 8);
          int v12 = *(char **)(a1 + 16);
          uint64_t v32 = v34;
        }
        else
        {
          unint64_t v37 = v27 + 2;
          if (v27 >= -1) {
            unint64_t v37 = v27 + 1;
          }
          v34 -= 8 * (v37 >> 1);
        }
        unint64_t v33 = v36;
      }
      *(void *)unint64_t v34 = v33;
      uint64_t v54 = v34 + 8;
      a4 = v102;
      if (v12 == (char *)v10)
      {
LABEL_58:
        BOOL v55 = *(char **)a1;
        *(void *)a1 = v32;
        *(void *)(a1 + 8) = v34;
        *(void *)(a1 + 16) = v54;
        *(void *)(a1 + 24) = v35;
        if (v55) {
          operator delete(v55);
        }
        goto LABEL_92;
      }
      while (v34 != v32)
      {
        unint64_t v56 = v34;
        v57 = v54;
LABEL_61:
        uint64_t v58 = *((void *)v12 - 1);
        v12 -= 8;
        *((void *)v56 - 1) = v58;
        unint64_t v34 = v56 - 8;
        uint64_t v54 = v57;
        if (v12 == *(char **)(a1 + 8)) {
          goto LABEL_58;
        }
      }
      if (v54 < v35)
      {
        uint64_t v59 = (v35 - v54) >> 3;
        if (v59 >= -1) {
          unint64_t v60 = v59 + 1;
        }
        else {
          unint64_t v60 = v59 + 2;
        }
        v57 = &v54[8 * (v60 >> 1)];
        unint64_t v56 = &v34[8 * (v60 >> 1)];
        if (v54 == v34)
        {
          uint64_t v32 = v54;
        }
        else
        {
          memmove(&v34[8 * (v60 >> 1)], v34, v54 - v34);
          uint64_t v32 = v34;
        }
        goto LABEL_61;
      }
      if (v35 == v34) {
        unint64_t v61 = 1;
      }
      else {
        unint64_t v61 = (v35 - v34) >> 2;
      }
      if (v61 >> 61) {
        sub_19E37C2B8();
      }
      unint64_t v62 = (char *)operator new(8 * v61);
      uint64_t v32 = v62;
      unint64_t v63 = (v61 + 3) >> 2;
      unint64_t v56 = &v62[8 * v63];
      v57 = v56;
      int64_t v64 = v54 - v34;
      if (v54 != v34)
      {
        v57 = &v56[v64 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v65 = v64 - 8;
        unint64_t v66 = &v62[8 * v63];
        v67 = v34;
        if (v65 >= 0x38)
        {
          uint64_t v68 = 8 * v63;
          unint64_t v66 = &v62[8 * v63];
          v67 = v34;
          if ((unint64_t)(v66 - v34) >= 0x20)
          {
            uint64_t v69 = (v65 >> 3) + 1;
            uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
            unint64_t v66 = &v56[v70];
            uint64_t v71 = (long long *)(v34 + 16);
            unint64_t v72 = &v62[v68 + 16];
            uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v74 = *v71;
              *((_OWORD *)v72 - 1) = *(v71 - 1);
              *(_OWORD *)unint64_t v72 = v74;
              v71 += 2;
              v72 += 32;
              v73 -= 4;
            }
            while (v73);
            if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_81;
            }
            v67 = &v34[v70];
          }
        }
        do
        {
          uint64_t v75 = *(void *)v67;
          v67 += 8;
          *(void *)unint64_t v66 = v75;
          v66 += 8;
        }
        while (v66 != v57);
      }
LABEL_81:
      uint64_t v35 = &v62[8 * v61];
      operator delete(v34);
      goto LABEL_61;
    }
  }
  else if (v6 != __src)
  {
    size_t v100 = a4 - __src;
    if (v100) {
      memmove(v6, __src, v100);
    }
    return &v6[v100];
  }
  return a4;
}

void sub_19E4F74E8(_Unwind_Exception *a1)
{
  operator delete(v2);
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *sub_19E4F7520(void *result, uint64_t a2, unint64_t a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    int v4 = *((char *)result + 23);
    if (v4 < 0)
    {
      uint64_t v6 = (void *)*result;
      uint64_t v5 = result[1];
    }
    else
    {
      uint64_t v5 = *((unsigned __int8 *)result + 23);
      uint64_t v6 = result;
    }
    if (v5 - a2 >= a3) {
      unint64_t v7 = a3;
    }
    else {
      unint64_t v7 = v5 - a2;
    }
    if (v5 - a2 > a3)
    {
      os_log_t result = memmove((char *)v6 + a2, (char *)v6 + a2 + v7, v5 - a2 - v7);
      LOBYTE(v4) = *((unsigned char *)v3 + 23);
    }
    uint64_t v8 = v5 - v7;
    if ((v4 & 0x80) != 0) {
      v3[1] = v8;
    }
    else {
      *((unsigned char *)v3 + 23) = v8 & 0x7F;
    }
    *((unsigned char *)v6 + v8) = 0;
  }
  return result;
}

uint64_t sub_19E4F75A8(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 2048;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 4096;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      unint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_19E4F7670(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_23;
  }
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  if (v5 > *a1)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    unint64_t v11 = &v5[-8 * v9];
    int64_t v12 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v9], a1[1], v4 - v5);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_23;
  }
  unint64_t v14 = (v4 - v6) >> 2;
  if (v4 == v6) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    sub_19E37C2B8();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  unint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v5;
  BOOL v19 = v4 == v5;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v5) < 0x20)
    {
      do
      {
LABEL_20:
        uint64_t v30 = *(void *)v5;
        v5 += 8;
        *(void *)uint64_t v22 = v30;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_21;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    unint64_t v26 = (long long *)(v5 + 16);
    uint64_t v27 = v23 + 16;
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      _OWORD *v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v5 += v25;
      goto LABEL_20;
    }
  }
LABEL_21:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v6)
  {
    operator delete(v6);
    unint64_t v4 = a1[2];
  }
LABEL_23:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void sub_19E4F77FC(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    unint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v7 = a1[2];
  uint64_t v6 = a1[3];
  if (v7 >= v6)
  {
    uint64_t v13 = v6 - v4;
    BOOL v12 = v13 == 0;
    unint64_t v14 = v13 >> 2;
    if (v12) {
      unint64_t v14 = 1;
    }
    if (v14 >> 61) {
      sub_19E37C2B8();
    }
    unint64_t v15 = (v14 + 3) >> 2;
    uint64_t v16 = 8 * v14;
    unint64_t v17 = (char *)operator new(8 * v14);
    unint64_t v5 = &v17[8 * v15];
    uint64_t v18 = &v17[v16];
    BOOL v19 = v5;
    uint64_t v20 = v7 - v4;
    if (v7 != v4)
    {
      BOOL v19 = &v5[v20 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v21 = v20 - 8;
      uint64_t v22 = &v17[8 * v15];
      uint64_t v23 = v4;
      if (v21 > 0x37)
      {
        uint64_t v24 = &v17[8 * v15];
        uint64_t v22 = v24;
        uint64_t v23 = v4;
        if ((unint64_t)(v24 - v4) >= 0x20)
        {
          uint64_t v25 = (v21 >> 3) + 1;
          uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v22 = &v5[v26];
          uint64_t v27 = (long long *)(v4 + 16);
          uint64_t v28 = v24 + 16;
          uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v30 = *v27;
            *(v28 - 1) = *(v27 - 1);
            *uint64_t v28 = v30;
            v27 += 2;
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *a1 = v17;
            a1[1] = v5;
            a1[2] = v19;
            a1[3] = v18;
            goto LABEL_24;
          }
          uint64_t v23 = &v4[v26];
        }
      }
      do
      {
        uint64_t v31 = *(void *)v23;
        v23 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v19);
    }
    *a1 = v17;
    a1[1] = v5;
    a1[2] = v19;
    a1[3] = v18;
    if (!v4) {
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v4);
    unint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v8 = (v6 - v7) >> 3;
  if (v8 >= -1) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v9 >> 1;
  unint64_t v11 = &v7[8 * (v9 >> 1)];
  unint64_t v5 = &v11[-(v7 - v4)];
  if (v7 != v4)
  {
    memmove(&v11[-(v7 - v4)], v4, v7 - v4);
    unint64_t v4 = (char *)a1[2];
  }
  a1[1] = v5;
  a1[2] = &v4[8 * v10];
LABEL_25:
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void sub_19E4F79A4(uint64_t a1@<X0>, long long *a2@<X1>, void *a3@<X8>)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E39369C(&__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long __dst = *a2;
    uint64_t v12 = *((void *)a2 + 2);
  }
  sub_19E4F7B20(a1, (uint64_t)&__dst);
  sub_19E4F7D14(a1, (uint64_t)&__dst);
  if (SHIBYTE(v12) < 0)
  {
    sub_19E39369C(v8, (void *)__dst, *((unint64_t *)&__dst + 1));
  }
  else
  {
    *(_OWORD *)uint64_t v8 = __dst;
    uint64_t v9 = v12;
  }
  int v10 = 0;
  sub_19E371C70(__p, (const UInt8 *)v8);
  int v7 = v10;
  sub_19E4F83B8(a1, (uint64_t)__p, a3);
  if (v6 < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v9) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v12) & 0x80000000) == 0) {
        return;
      }
LABEL_13:
      operator delete((void *)__dst);
      return;
    }
  }
  else if ((SHIBYTE(v9) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v8[0]);
  if (SHIBYTE(v12) < 0) {
    goto LABEL_13;
  }
}

void sub_19E4F7AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((*(char *)(v21 - 25) & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(*(void **)(v21 - 48));
  _Unwind_Resume(exception_object);
}

void sub_19E4F7B20(uint64_t a1, uint64_t a2)
{
  v19[2] = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 360) && !sub_19E4B9E40((void *)(a1 + 432), a2))
  {
    if (*(char *)(a2 + 23) < 0)
    {
      unint64_t v4 = *(void *)(a2 + 8);
      std::string::size_type v5 = v4 - 2;
      if (v4 <= 2) {
        return;
      }
      char v6 = *(const void **)a2;
      if (*(_WORD *)(*(void *)a2 + v5) != 29479) {
        return;
      }
    }
    else
    {
      unint64_t v4 = *(unsigned __int8 *)(a2 + 23);
      if (v4 <= 2) {
        return;
      }
      std::string::size_type v5 = v4 - 2;
      if (*(_WORD *)(a2 + v4 - 2) != 29479) {
        return;
      }
      char v6 = (const void *)a2;
    }
    if (v4 >= v5) {
      std::string::size_type v7 = v5;
    }
    else {
      std::string::size_type v7 = v4;
    }
    if (v7 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E37C958();
    }
    if (v7 >= 0x17)
    {
      uint64_t v9 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v7 | 7) != 0x17) {
        uint64_t v9 = v7 | 7;
      }
      uint64_t v10 = v9 + 1;
      p_p = (std::string *)operator new(v9 + 1);
      __p.__r_.__value_.__l.__size_ = v7;
      __p.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = v7;
      p_p = &__p;
    }
    memmove(p_p, v6, v7);
    p_p->__r_.__value_.__s.__data_[v7] = 0;
    if (!*(unsigned char *)(a1 + 360)) {
      sub_19E3F1AD4();
    }
    int v11 = *(char *)(a1 + 359);
    if (v11 >= 0) {
      uint64_t v12 = (const std::string::value_type *)(a1 + 336);
    }
    else {
      uint64_t v12 = *(const std::string::value_type **)(a1 + 336);
    }
    if (v11 >= 0) {
      std::string::size_type v13 = *(unsigned __int8 *)(a1 + 359);
    }
    else {
      std::string::size_type v13 = *(void *)(a1 + 344);
    }
    unint64_t v14 = std::string::append(&__p, v12, v13);
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[0];
    v19[0] = v14->__r_.__value_.__l.__size_;
    *(void *)((char *)v19 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
    char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    uint64_t v17 = v19[0];
    *(void *)a2 = v15;
    *(void *)(a2 + 8) = v17;
    *(void *)(a2 + 15) = *(void *)((char *)v19 + 7);
    *(unsigned char *)(a2 + 23) = v16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
}

void sub_19E4F7CEC(_Unwind_Exception *exception_object)
{
}

void sub_19E4F7CF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4F7D14(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (*(_DWORD *)(a1 + 328) != 2)
  {
    sub_19E4F8DDC(a1, a2);
    return;
  }
  uint64_t v3 = a1 + 368;
  uint64_t v4 = *(unsigned __int8 *)(a1 + 391);
  uint64_t v39 = a2;
  uint64_t v40 = (const void **)(a1 + 368);
  if ((v4 & 0x80u) != 0)
  {
    uint64_t v3 = *(void *)(a1 + 368);
    uint64_t v4 = *(void *)(a1 + 376);
  }
  uint64_t v5 = v3 + v4;
  int v6 = *(char *)(a2 + 23);
  uint64_t v7 = *(void *)(a2 + 8);
  if (v6 >= 0) {
    uint64_t v7 = v6;
  }
  else {
    a2 = *(void *)a2;
  }
  uint64_t v8 = a2 + v7;
  unint64_t v9 = (unint64_t)off_1EF0BEA38 + 1;
  int64_t v64 = (char *)off_1EF0BEA38 + 1;
  *(void *)&long long v65 = v3;
  *((void *)&v65 + 1) = v5;
  *(void *)&long long v67 = a2;
  *((void *)&v67 + 1) = a2;
  uint64_t v68 = a2;
  uint64_t v69 = a2 + v7;
  char v70 = 0;
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(((unint64_t)off_1EF0BEA38 & 0xFFFFFFFFFFFFFFFELL)
                                                               + 8))((uint64_t *)&v65, a2, v8);
  uint64_t v8 = v69;
  if (v69 == v10 && v69 == a2 && *((void *)&v67 + 1) == a2) {
    char v70 = 1;
  }
  unint64_t v9 = (unint64_t)v64;
  *(void *)&long long v67 = v68;
  *((void *)&v67 + 1) = v10;
  uint64_t v68 = a2;
  *(void *)long long __dst = 0;
  if (v64)
  {
LABEL_13:
    *(void *)long long __dst = v9;
    if (v9)
    {
      *(_OWORD *)&__dst[8] = v65;
      uint64_t v72 = v66;
    }
    else
    {
      (*(void (**)(long long *, unsigned char *, void))(v9 & 0xFFFFFFFFFFFFFFFELL))(&v65, &__dst[8], 0);
      a2 = v68;
      uint64_t v8 = v69;
      unint64_t v9 = (unint64_t)v64;
    }
  }
  long long v73 = v67;
  *(void *)&long long v74 = a2;
  *((void *)&v74 + 1) = v8;
  char v75 = v70;
  if (v9)
  {
    if ((v9 & 1) == 0)
    {
      int v11 = *(void (**)(long long *, long long *, uint64_t))(v9 & 0xFFFFFFFFFFFFFFFELL);
      if (v11) {
        v11(&v65, &v65, 2);
      }
    }
    int64_t v64 = 0;
  }
  uint64_t v58 = 0;
  long long v61 = 0u;
  long long v62 = 0u;
  char v63 = 1;
  uint64_t v51 = 0;
  uint64_t v12 = *(void *)__dst;
  if (*(void *)__dst)
  {
    uint64_t v51 = *(void *)__dst;
    if (__dst[0])
    {
      uint64_t v12 = 0;
      long long v52 = *(_OWORD *)&__dst[8];
      uint64_t v53 = v72;
    }
    else
    {
      (*(void (**)(unsigned char *, long long *, void))(*(void *)__dst & 0xFFFFFFFFFFFFFFFELL))(&__dst[8], &v52, 0);
      uint64_t v12 = v58;
    }
  }
  long long v54 = v73;
  long long v55 = v74;
  char v56 = v75;
  uint64_t v45 = 0;
  if (v12)
  {
    uint64_t v45 = v12;
    if (v12)
    {
      long long v46 = v59;
      uint64_t v47 = v60;
    }
    else
    {
      (*(void (**)(long long *, long long *, void))(v12 & 0xFFFFFFFFFFFFFFFELL))(&v59, &v46, 0);
    }
  }
  long long v48 = v61;
  long long v49 = v62;
  char v50 = v63;
  sub_19E4F650C((uint64_t)&v57, &v51, &v45);
  if (v45)
  {
    if ((v45 & 1) == 0)
    {
      std::string::size_type v13 = *(void (**)(long long *, long long *, uint64_t))(v45 & 0xFFFFFFFFFFFFFFFELL);
      if (v13) {
        v13(&v46, &v46, 2);
      }
    }
    uint64_t v45 = 0;
  }
  if (v51)
  {
    if ((v51 & 1) == 0)
    {
      unint64_t v14 = *(void (**)(long long *, long long *, uint64_t))(v51 & 0xFFFFFFFFFFFFFFFELL);
      if (v14) {
        v14(&v52, &v52, 2);
      }
    }
    uint64_t v51 = 0;
  }
  long long v15 = v57;
  long long v44 = v57;
  if (v58)
  {
    if ((v58 & 1) == 0)
    {
      char v16 = *(void (**)(long long *, long long *, uint64_t))(v58 & 0xFFFFFFFFFFFFFFFELL);
      if (v16)
      {
        long long v42 = v57;
        v16(&v59, &v59, 2);
        long long v15 = v42;
      }
    }
  }
  if (*(void *)__dst)
  {
    if ((__dst[0] & 1) == 0)
    {
      uint64_t v17 = *(void (**)(unsigned char *, unsigned char *, uint64_t))(*(void *)__dst & 0xFFFFFFFFFFFFFFFELL);
      if (v17)
      {
        long long v43 = v15;
        v17(&__dst[8], &__dst[8], 2);
        long long v15 = v43;
      }
    }
  }
  uint64_t v18 = *((void *)&v15 + 1);
  BOOL v19 = (void *)v15;
  if (*((void *)&v15 + 1) - (void)v15 == 24)
  {
    sub_19E4F8DDC(v2, v39);
    if (v19) {
      goto LABEL_95;
    }
    return;
  }
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  do
  {
    sub_19E4F8DDC(v2, (uint64_t)v19 + v20);
    uint64_t v22 = (std::string *)(v44 + v20);
    if (*(char *)(v44 + v20 + 23) < 0) {
      std::string::size_type size = v22->__r_.__value_.__l.__size_;
    }
    else {
      std::string::size_type size = *(unsigned __int8 *)(v44 + v20 + 23);
    }
    int v24 = *(char *)(v2 + 391);
    if (v24 >= 0) {
      size_t v25 = *(unsigned __int8 *)(v2 + 391);
    }
    else {
      size_t v25 = *(void *)(v2 + 376);
    }
    size_t v26 = size != 0;
    if (size) {
      unint64_t v27 = v25 + 1;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27 >= 0x7FFFFFFFFFFFFFF8) {
      sub_19E37C958();
    }
    if (v27 <= 0x16)
    {
      memset(__dst, 0, sizeof(__dst));
      uint64_t v28 = __dst;
      __dst[23] = v27;
      if (!size) {
        goto LABEL_68;
      }
LABEL_67:
      memcpy(v28, " ", v26);
      goto LABEL_68;
    }
    uint64_t v41 = v20;
    unint64_t v33 = v21;
    std::string::size_type v34 = size;
    uint64_t v35 = v2;
    uint64_t v36 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v36 = v27 | 7;
    }
    uint64_t v37 = v36 + 1;
    uint64_t v28 = operator new(v36 + 1);
    *(void *)&__dst[8] = v27;
    *(void *)&__dst[16] = v37 | 0x8000000000000000;
    *(void *)long long __dst = v28;
    uint64_t v2 = v35;
    std::string::size_type v38 = v34;
    unint64_t v21 = v33;
    uint64_t v20 = v41;
    if (v38) {
      goto LABEL_67;
    }
LABEL_68:
    uint64_t v29 = &v28[v26];
    if (v25)
    {
      if (v24 >= 0) {
        long long v30 = v40;
      }
      else {
        long long v30 = *v40;
      }
      memmove(v29, v30, v25);
    }
    v29[v25] = 0;
    if (__dst[23] >= 0) {
      uint64_t v31 = __dst;
    }
    else {
      uint64_t v31 = *(const std::string::value_type **)__dst;
    }
    if (__dst[23] >= 0) {
      std::string::size_type v32 = __dst[23];
    }
    else {
      std::string::size_type v32 = *(void *)&__dst[8];
    }
    std::string::append(v22, v31, v32);
    BOOL v19 = (void *)v44;
    if ((__dst[23] & 0x80000000) != 0) {
      operator delete(*(void **)__dst);
    }
    ++v21;
    uint64_t v18 = *((void *)&v44 + 1);
    v20 += 24;
  }
  while (-1 - 0x5555555555555555 * ((uint64_t)(*((void *)&v44 + 1) - v44) >> 3) > v21);
  if (*(char *)(*((void *)&v44 + 1) - 1) < 0)
  {
    if (!*(void *)(*((void *)&v44 + 1) - 16))
    {
      operator delete(*(void **)(*((void *)&v44 + 1) - 24));
      goto LABEL_90;
    }
  }
  else if (!*(unsigned char *)(*((void *)&v44 + 1) - 1))
  {
LABEL_90:
    uint64_t v18 = *((void *)&v44 + 1) - 24;
  }
  sub_19E4F63F0((unint64_t)__dst, v44, v18);
  if (*(char *)(v39 + 23) < 0) {
    operator delete(*(void **)v39);
  }
  *(_OWORD *)uint64_t v39 = *(_OWORD *)__dst;
  *(void *)(v39 + 16) = *(void *)&__dst[16];
LABEL_95:
  while ((void *)v18 != v19)
  {
    if (*(char *)(v18 - 1) < 0) {
      operator delete(*(void **)(v18 - 24));
    }
    v18 -= 24;
  }
  operator delete(v19);
}

void sub_19E4F8300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  sub_19E4F6940(&a29);
  sub_19E4F6940(&a42);
  sub_19E4F6940((uint64_t *)(v42 - 176));
  sub_19E3EB09C(&a15);
  _Unwind_Resume(a1);
}

void sub_19E4F83B8(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  switch(*(_DWORD *)(a2 + 24))
  {
    case 1:
      int v5 = *(_DWORD *)(a1 + 76);
      goto LABEL_9;
    case 2:
      int v5 = *(_DWORD *)(a1 + 80);
LABEL_9:
      a3[1] = 0;
      a3[2] = 0;
      *a3 = 0;
      int v6 = operator new(4uLL);
      *a3 = v6;
      *v6++ = v5;
      a3[1] = v6;
      a3[2] = v6;
      break;
    case 3:
      sub_19E4F84B0(__p, (unsigned __int8 *)a2);
      sub_19E4F8B3C(a1, (uint64_t)__p, a3);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
      break;
    default:
      sub_19E4F8B3C(a1, a2, a3);
      break;
  }
}

void sub_19E4F8484(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4F84B0(void *__dst, unsigned __int8 *a2)
{
  int v4 = *((_DWORD *)a2 + 6);
  if (v4 != 3)
  {
    if ((char)a2[23] < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, *((void *)a2 + 1));
      int v4 = *((_DWORD *)a2 + 6);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      void __dst[2] = *((void *)a2 + 2);
    }
    *((_DWORD *)__dst + 6) = v4;
    return;
  }
  int v5 = (char)a2[23];
  if ((v5 & 0x80000000) == 0)
  {
    *(_OWORD *)size_t __n = *(_OWORD *)a2;
    uint64_t v64 = *((void *)a2 + 2);
    int v6 = (const void *)language_modeling::v1::kClassLabelNumber;
    size_t v7 = strlen((const char *)language_modeling::v1::kClassLabelNumber);
    goto LABEL_7;
  }
  sub_19E39369C(__n, *(void **)a2, *((void *)a2 + 1));
  int v5 = (char)a2[23];
  int v6 = (const void *)language_modeling::v1::kClassLabelNumber;
  size_t v8 = strlen((const char *)language_modeling::v1::kClassLabelNumber);
  size_t v7 = v8;
  if ((v5 & 0x80000000) == 0)
  {
LABEL_7:
    if (v7 != -1)
    {
      int v9 = 0;
      size_t v10 = v5;
      int v11 = a2;
      goto LABEL_9;
    }
LABEL_141:
    sub_19E3C4C28();
  }
  if (v8 == -1) {
    goto LABEL_141;
  }
  int v11 = *(const void **)a2;
  size_t v10 = *((void *)a2 + 1);
  int v9 = 1;
LABEL_9:
  uint64_t v12 = (size_t *)((char *)__n + 1);
  if (v10 >= v7) {
    size_t v13 = v7;
  }
  else {
    size_t v13 = v10;
  }
  if (!memcmp(v11, v6, v13) && v10 == v7) {
    goto LABEL_28;
  }
  size_t v15 = strlen((const char *)language_modeling::v1::kClassLabelPluralNumber);
  size_t v16 = v15;
  if (v9)
  {
    if (v15 != -1)
    {
      uint64_t v17 = *(const void **)a2;
      size_t v18 = *((void *)a2 + 1);
      goto LABEL_23;
    }
LABEL_142:
    sub_19E3C4C28();
  }
  if (v15 == -1) {
    goto LABEL_142;
  }
  size_t v18 = v5;
  uint64_t v17 = a2;
LABEL_23:
  if (v18 >= v16) {
    size_t v19 = v16;
  }
  else {
    size_t v19 = v18;
  }
  if (!memcmp(v17, (const void *)language_modeling::v1::kClassLabelPluralNumber, v19) && v18 == v16)
  {
LABEL_28:
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 1;
      uint64_t v20 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 1);
    }
    else
    {
      HIBYTE(v64) = 1;
      uint64_t v20 = __n;
    }
    char v21 = 57;
LABEL_32:
    *(unsigned char *)uint64_t v20 = v21;
    goto LABEL_33;
  }
  size_t v31 = strlen((const char *)language_modeling::v1::kClassLabelSingularNumber);
  size_t v32 = v31;
  if (v9)
  {
    if (v31 != -1)
    {
      unint64_t v33 = *(const void **)a2;
      size_t v34 = *((void *)a2 + 1);
      goto LABEL_68;
    }
LABEL_143:
    sub_19E3C4C28();
  }
  if (v31 == -1) {
    goto LABEL_143;
  }
  size_t v34 = v5;
  unint64_t v33 = a2;
LABEL_68:
  if (v34 >= v32) {
    size_t v36 = v32;
  }
  else {
    size_t v36 = v34;
  }
  if (!memcmp(v33, (const void *)language_modeling::v1::kClassLabelSingularNumber, v36) && v34 == v32)
  {
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 1;
      uint64_t v20 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 1);
    }
    else
    {
      HIBYTE(v64) = 1;
      uint64_t v20 = __n;
    }
    char v21 = 49;
    goto LABEL_32;
  }
  size_t v37 = strlen((const char *)language_modeling::v1::kClassLabelPause);
  size_t v38 = v37;
  if (v9)
  {
    if (v37 != -1)
    {
      uint64_t v39 = *(const void **)a2;
      size_t v40 = *((void *)a2 + 1);
      goto LABEL_83;
    }
LABEL_144:
    sub_19E3C4C28();
  }
  if (v37 == -1) {
    goto LABEL_144;
  }
  size_t v40 = v5;
  uint64_t v39 = a2;
LABEL_83:
  if (v40 >= v38) {
    size_t v41 = v38;
  }
  else {
    size_t v41 = v40;
  }
  if (!memcmp(v39, (const void *)language_modeling::v1::kClassLabelPause, v41) && v40 == v38)
  {
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 3;
      uint64_t v42 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 3);
    }
    else
    {
      uint64_t v12 = (size_t *)((char *)__n + 3);
      HIBYTE(v64) = 3;
      uint64_t v42 = __n;
    }
    *((unsigned char *)v42 + 2) = 46;
    *(_WORD *)uint64_t v42 = 11822;
    goto LABEL_33;
  }
  size_t v43 = strlen((const char *)language_modeling::v1::kClassLabelSentenceDelimiter);
  size_t v44 = v43;
  if (v9)
  {
    if (v43 != -1)
    {
      uint64_t v45 = *(const void **)a2;
      size_t v46 = *((void *)a2 + 1);
      goto LABEL_97;
    }
LABEL_145:
    sub_19E3C4C28();
  }
  if (v43 == -1) {
    goto LABEL_145;
  }
  size_t v46 = v5;
  uint64_t v45 = a2;
LABEL_97:
  if (v46 >= v44) {
    size_t v47 = v44;
  }
  else {
    size_t v47 = v46;
  }
  if (!memcmp(v45, (const void *)language_modeling::v1::kClassLabelSentenceDelimiter, v47) && v46 == v44)
  {
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 1;
      uint64_t v20 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 1);
    }
    else
    {
      HIBYTE(v64) = 1;
      uint64_t v20 = __n;
    }
    char v21 = 46;
    goto LABEL_32;
  }
  size_t v48 = strlen((const char *)language_modeling::v1::kClassLabelReplacementCharacter);
  size_t v49 = v48;
  if (v9)
  {
    if (v48 != -1)
    {
      char v50 = *(const void **)a2;
      size_t v51 = *((void *)a2 + 1);
      goto LABEL_111;
    }
LABEL_146:
    sub_19E3C4C28();
  }
  if (v48 == -1) {
    goto LABEL_146;
  }
  size_t v51 = v5;
  char v50 = a2;
LABEL_111:
  if (v51 >= v49) {
    size_t v52 = v49;
  }
  else {
    size_t v52 = v51;
  }
  if (!memcmp(v50, (const void *)language_modeling::v1::kClassLabelReplacementCharacter, v52) && v51 == v49)
  {
    if ((SHIBYTE(v64) & 0x80000000) == 0)
    {
LABEL_117:
      HIBYTE(v64) = 0;
      uint64_t v12 = __n;
      goto LABEL_33;
    }
LABEL_134:
    __n[1] = 0;
    uint64_t v12 = (size_t *)__n[0];
    goto LABEL_33;
  }
  size_t v53 = strlen((const char *)language_modeling::v1::kClassLabelUsername);
  size_t v54 = v53;
  if (v9)
  {
    if (v53 != -1)
    {
      long long v55 = *(const void **)a2;
      size_t v56 = *((void *)a2 + 1);
      goto LABEL_125;
    }
LABEL_147:
    sub_19E3C4C28();
  }
  if (v53 == -1) {
    goto LABEL_147;
  }
  size_t v56 = v5;
  long long v55 = a2;
LABEL_125:
  if (v56 >= v54) {
    size_t v57 = v54;
  }
  else {
    size_t v57 = v56;
  }
  if (!memcmp(v55, (const void *)language_modeling::v1::kClassLabelUsername, v57) && v56 == v54)
  {
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 4;
      uint64_t v58 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 4);
    }
    else
    {
      uint64_t v12 = (size_t *)((char *)__n + 4);
      HIBYTE(v64) = 4;
      uint64_t v58 = __n;
    }
    *(_DWORD *)uint64_t v58 = 1852337994;
  }
  else
  {
    if (std::string::compare((const std::string *)a2, (const std::string::value_type *)language_modeling::v1::kClassLabelLink))
    {
      if ((SHIBYTE(v64) & 0x80000000) == 0) {
        goto LABEL_117;
      }
      goto LABEL_134;
    }
    if (SHIBYTE(v64) < 0)
    {
      __n[1] = 7;
      long long v59 = (size_t *)__n[0];
      uint64_t v12 = (size_t *)(__n[0] + 7);
    }
    else
    {
      uint64_t v12 = (size_t *)((char *)__n + 7);
      HIBYTE(v64) = 7;
      long long v59 = __n;
    }
    *(_DWORD *)((char *)v59 + 3) = 1836016430;
    *(_DWORD *)long long v59 = 779778424;
  }
LABEL_33:
  *(unsigned char *)uint64_t v12 = 0;
  unint64_t v22 = __n[1];
  if (v64 >= 0) {
    size_t v23 = HIBYTE(v64);
  }
  else {
    size_t v23 = __n[1];
  }
  uint64_t v24 = a2[23];
  int v25 = (char)v24;
  unint64_t v26 = *((void *)a2 + 1);
  if ((v24 & 0x80u) != 0) {
    uint64_t v24 = *((void *)a2 + 1);
  }
  if (v23 == v24)
  {
    unint64_t v27 = *(void **)a2;
    if (v25 >= 0) {
      uint64_t v28 = a2;
    }
    else {
      uint64_t v28 = *(unsigned __int8 **)a2;
    }
    if (v64 < 0)
    {
      uint64_t v35 = (void *)__n[0];
      if (memcmp((const void *)__n[0], v28, __n[1])) {
        goto LABEL_55;
      }
    }
    else if (HIBYTE(v64))
    {
      uint64_t v29 = __n;
      uint64_t v30 = HIBYTE(v64);
      while (*(unsigned __int8 *)v29 == *v28)
      {
        uint64_t v29 = (size_t *)((char *)v29 + 1);
        ++v28;
        if (!--v30) {
          goto LABEL_60;
        }
      }
      goto LABEL_48;
    }
LABEL_60:
    if (v25 < 0)
    {
      sub_19E39369C(__dst, v27, v26);
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      void __dst[2] = *((void *)a2 + 2);
    }
    *((_DWORD *)__dst + 6) = *((_DWORD *)a2 + 6);
    if (SHIBYTE(v64) < 0) {
      goto LABEL_58;
    }
    return;
  }
LABEL_48:
  if ((v64 & 0x8000000000000000) == 0)
  {
    *(_OWORD *)std::string __p = *(_OWORD *)__n;
    uint64_t v61 = v64;
    goto LABEL_56;
  }
  uint64_t v35 = (void *)__n[0];
LABEL_55:
  sub_19E39369C(__p, v35, v22);
LABEL_56:
  int v62 = 0;
  sub_19E371C70(__dst, (const UInt8 *)__p);
  *((_DWORD *)__dst + 6) = v62;
  if ((SHIBYTE(v61) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v64) & 0x80000000) == 0) {
      return;
    }
    goto LABEL_58;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v64) < 0) {
LABEL_58:
  }
    operator delete((void *)__n[0]);
}

void sub_19E4F8ADC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((a21 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_19E4F8B3C(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v27 = *(void *)(a2 + 16);
  }
  size_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (v27 >= 0) {
    int v5 = __p;
  }
  else {
    int v5 = (void **)__p[0];
  }
  if (v27 >= 0) {
    uint64_t v6 = HIBYTE(v27);
  }
  else {
    uint64_t v6 = (uint64_t)__p[1];
  }
  sub_19E386A68(a1 + 128, (uint64_t)v5, v6, &v23, &v22);
  if (v22)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    sub_19E3AD800((uint64_t)&v22, &v21);
    if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v20 = &v21;
    }
    else {
      uint64_t v20 = (std::string *)v21.__r_.__value_.__r.__words[0];
    }
    MEMORY[0x19F3BD790](exception, v20);
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E3AD4CC(&v22);
  size_t v7 = v23;
  size_t v8 = v24;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  uint64_t v9 = v8 - v7;
  if (v8 == v7)
  {
LABEL_21:
    if (!v7) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  if (v9 < 0) {
    sub_19E37C7C4();
  }
  size_t v10 = operator new(v8 - v7);
  *a3 = v10;
  a3[2] = &v10[v9 >> 2];
  bzero(v10, v8 - v7);
  a3[1] = (char *)v10 + v9;
  if ((unint64_t)(v9 - 4) < 0x1C)
  {
    int v11 = v7;
    do
    {
LABEL_20:
      int v18 = *(_DWORD *)v11;
      v11 += 4;
      *v10++ = v18;
    }
    while (v11 != v8);
    goto LABEL_21;
  }
  int v11 = v7;
  if ((unint64_t)((char *)v10 - v7) < 0x20) {
    goto LABEL_20;
  }
  unint64_t v12 = ((unint64_t)(v9 - 4) >> 2) + 1;
  uint64_t v13 = 4 * (v12 & 0x7FFFFFFFFFFFFFF8);
  unint64_t v14 = (long long *)(v7 + 16);
  size_t v15 = v10 + 4;
  uint64_t v16 = v12 & 0x7FFFFFFFFFFFFFF8;
  do
  {
    long long v17 = *v14;
    *(v15 - 1) = *(v14 - 1);
    *size_t v15 = v17;
    v14 += 2;
    v15 += 2;
    v16 -= 8;
  }
  while (v16);
  if (v12 != (v12 & 0x7FFFFFFFFFFFFFF8))
  {
    int v11 = &v7[v13];
    size_t v10 = (_DWORD *)((char *)v10 + v13);
    goto LABEL_20;
  }
LABEL_22:
  uint64_t v24 = v7;
  operator delete(v7);
LABEL_23:
  if (SHIBYTE(v27) < 0) {
    operator delete(__p[0]);
  }
}

void sub_19E4F8D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, void *__p, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (__p)
  {
    operator delete(__p);
    if ((a25 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a25 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a20);
  _Unwind_Resume(exception_object);
}

void sub_19E4F8DDC(uint64_t a1, uint64_t a2)
{
  v27[2] = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 292) || !sub_19E4F2878(a1, a2)) {
    return;
  }
  *((unsigned char *)&v26.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v26, "_U_CAP_");
  char v4 = *(unsigned char *)(a2 + 23);
  if (v4 >= 0) {
    int v5 = (const UInt8 *)a2;
  }
  else {
    int v5 = *(const UInt8 **)a2;
  }
  if (v5)
  {
    if (v4 >= 0) {
      CFIndex v6 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      CFIndex v6 = *(void *)(a2 + 8);
    }
    CFStringRef v7 = CFStringCreateWithBytes(0, v5, v6, 0x8000100u, 0);
    if (!v7)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v7 = 0;
  }
  CFLocaleRef v9 = *(const __CFLocale **)(a1 + 56);
  CFIndex Length = CFStringGetLength(v7);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Length, v7);
  CFStringLowercase(MutableCopy, v9);
  sub_19E372124(&cf, MutableCopy);
  CFStringRef v12 = (const __CFString *)cf;
  if (!cf)
  {
    uint64_t v22 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v22, "Could not construct");
    __cxa_throw(v22, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(v12))
  {
    sub_19E3C6934(__p, v12);
    unsigned int v14 = v25;
    size_t v15 = (void **)__p[0];
  }
  else
  {
    size_t v15 = 0;
    unsigned int v14 = 0;
    __p[0] = 0;
    unsigned __int8 v25 = 0;
  }
  if ((v14 & 0x80u) == 0) {
    uint64_t v16 = __p;
  }
  else {
    uint64_t v16 = v15;
  }
  if ((v14 & 0x80u) == 0) {
    std::string::size_type v17 = v14;
  }
  else {
    std::string::size_type v17 = (std::string::size_type)__p[1];
  }
  int v18 = std::string::append(&v26, (const std::string::value_type *)v16, v17);
  std::string::size_type v19 = v18->__r_.__value_.__r.__words[0];
  v27[0] = v18->__r_.__value_.__l.__size_;
  *(void *)((char *)v27 + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
  char v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *(void *)a2 = v19;
  *(void *)(a2 + 8) = v27[0];
  *(void *)(a2 + 15) = *(void *)((char *)v27 + 7);
  *(unsigned char *)(a2 + 23) = v20;
  if (((char)v25 & 0x80000000) == 0)
  {
    CFTypeRef v21 = cf;
    if (!cf) {
      goto LABEL_30;
    }
    goto LABEL_29;
  }
  operator delete(__p[0]);
  CFTypeRef v21 = cf;
  if (cf) {
LABEL_29:
  }
    CFRelease(v21);
LABEL_30:
  if (v7) {
    CFRelease(v7);
  }
  if (SHIBYTE(v26.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v26.__r_.__value_.__l.__data_);
  }
}

void sub_19E4F9078(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E4F908C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E4F9104(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a2;
  if (a2 != a3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = a1[1];
    if (*a1 == v5) {
      return a3;
    }
    while (1)
    {
      uint64_t v6 = 0;
      do
      {
        if (*(unsigned __int8 *)(v3 + v6) != *(unsigned __int8 *)(v4 + v6)) {
          break;
        }
        if (++v6 + v3 == a3) {
          break;
        }
      }
      while (v6 + v4 != v5);
      if (v4 + v6 == v5) {
        break;
      }
      if (++v3 == a3) {
        return a3;
      }
    }
  }
  return v3;
}

uint64_t sub_19E4F9180(uint64_t result, uint64_t a2, unsigned int a3)
{
  if (a3 == 4) {
    goto LABEL_2;
  }
  uint64_t v4 = result;
  if (a3 > 1)
  {
    if (a3 != 2)
    {
      if (a3 != 3)
      {
LABEL_2:
        *(void *)a2 = &unk_1EF0B7580;
        *(_WORD *)(a2 + 8) = 0;
        return result;
      }
      os_log_t result = *(void *)(*(void *)a2 + 8) & 0x7FFFFFFFFFFFFFFFLL;
      if (result == ((unint64_t)"N5boost9algorithm6detail13first_finderFINSt3__111__wrap_iterIPKcEENS0_8is_equalEEE" & 0x7FFFFFFFFFFFFFFFLL)
        || (os_log_t result = strcmp((const char *)result, (const char *)((unint64_t)"N5boost9algorithm6detail13first_finderFINSt3__111__wrap_iterIPKcEENS0_8is_equalEEE" & 0x7FFFFFFFFFFFFFFFLL)), !result))
      {
        *(void *)a2 = v4;
      }
      else
      {
        *(void *)a2 = 0;
      }
    }
  }
  else
  {
    long long v5 = *(_OWORD *)result;
    *(void *)(a2 + 16) = *(void *)(result + 16);
    *(_OWORD *)a2 = v5;
  }
  return result;
}

void sub_19E4F9220(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  int v4 = *(char *)(a2 + 23);
  if (v4 >= 0) {
    uint64_t v5 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v5 = *(void *)(a2 + 8);
  }
  int v6 = *(_DWORD *)(a2 + 24);
  if (v5) {
    BOOL v7 = 0;
  }
  else {
    BOOL v7 = v6 == 0;
  }
  if (v7)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    return;
  }
  if (v4 < 0)
  {
    sub_19E39369C(&__dst, *(void **)a2, *(void *)(a2 + 8));
    int v6 = *(_DWORD *)(a2 + 24);
  }
  else
  {
    std::string __dst = *(std::string *)a2;
  }
  int v34 = v6;
  if (v6 == 3)
  {
    sub_19E4F84B0(&v31, (unsigned __int8 *)&__dst);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
    std::string __dst = v31;
    int v34 = v32;
    unint64_t v10 = HIBYTE(v31.__r_.__value_.__r.__words[2]);
    char v11 = HIBYTE(v31.__r_.__value_.__r.__words[2]);
    std::string::size_type size = v31.__r_.__value_.__l.__size_;
    if ((v31.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v13 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v13 = __dst.__r_.__value_.__l.__size_;
    }
    if (!v13)
    {
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      if ((v11 & 0x80) == 0) {
        return;
      }
      goto LABEL_38;
    }
  }
  else
  {
    unint64_t v10 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
    char v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  unsigned int v14 = (void *)__dst.__r_.__value_.__r.__words[0];
  if (v11 >= 0) {
    unint64_t v15 = v10;
  }
  else {
    unint64_t v15 = size;
  }
  if (v11 >= 0) {
    p_dst = &__dst;
  }
  else {
    p_dst = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if (v15 >= 5) {
    size_t v17 = 5;
  }
  else {
    size_t v17 = v15;
  }
  if (!memcmp(p_dst, "<unk>", v17) && v15 == 5)
  {
    int v19 = *(_DWORD *)(a1 + 68);
    a3[1] = 0;
    a3[2] = 0;
    *a3 = 0;
    char v20 = operator new(4uLL);
    *a3 = v20;
    *v20++ = v19;
    a3[1] = v20;
    a3[2] = v20;
    if ((v11 & 0x80) == 0) {
      return;
    }
    goto LABEL_38;
  }
  if (v11 < 0) {
    sub_19E39369C(&v30, v14, size);
  }
  else {
    std::string v30 = __dst;
  }
  if (*(_DWORD *)(a1 + 328) == 1)
  {
    std::string::size_type v21 = HIBYTE(v30.__r_.__value_.__r.__words[2]);
    if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type v21 = v30.__r_.__value_.__l.__size_;
    }
    if (v21 == 3)
    {
      uint64_t v22 = (std::string *)v30.__r_.__value_.__r.__words[0];
      size_t v23 = &v30;
      if ((v30.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
        size_t v23 = (std::string *)v30.__r_.__value_.__r.__words[0];
      }
      int data_low = LOWORD(v23->__r_.__value_.__l.__data_);
      int v25 = v23->__r_.__value_.__s.__data_[2];
      if (data_low == 11822 && v25 == 46)
      {
        if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
        {
          v30.__r_.__value_.__l.__size_ = 5;
        }
        else
        {
          *((unsigned char *)&v30.__r_.__value_.__s + 23) = 5;
          uint64_t v22 = &v30;
        }
        strcpy((char *)v22, ". . .");
      }
    }
  }
  sub_19E4F7B20(a1, (uint64_t)&v30);
  sub_19E4F7D14(a1, (uint64_t)&v30);
  if (!v34) {
    std::string::append(&v30, " ", 1uLL);
  }
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    sub_19E39369C(&__p, v30.__r_.__value_.__l.__data_, v30.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v30;
  }
  int v29 = v34;
  sub_19E371C70(&v31, (const UInt8 *)&__p);
  int v27 = v29;
  int v32 = v29;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    int v27 = v32;
  }
  std::string __dst = v31;
  *((unsigned char *)&v31.__r_.__value_.__s + 23) = 0;
  v31.__r_.__value_.__s.__data_[0] = 0;
  int v34 = v27;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  sub_19E4F83B8(a1, (uint64_t)&__dst, a3);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v30.__r_.__value_.__l.__data_);
  }
  if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_38:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
}

void sub_19E4F9524(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if (*(char *)(v21 - 57) < 0) {
      goto LABEL_6;
    }
  }
  else if (*(char *)(v21 - 57) < 0)
  {
LABEL_6:
    operator delete(*(void **)(v21 - 80));
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void sub_19E4F95A4(uint64_t a1)
{
  sub_19E4F95DC(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4F95DC(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BA518;
  uint64_t v2 = *(void ***)(a1 + 448);
  if (v2)
  {
    do
    {
      int v6 = (void **)*v2;
      if (*((char *)v2 + 39) < 0) {
        operator delete(v2[2]);
      }
      operator delete(v2);
      uint64_t v2 = v6;
    }
    while (v6);
  }
  uint64_t v3 = *(void **)(a1 + 432);
  *(void *)(a1 + 432) = 0;
  if (v3) {
    operator delete(v3);
  }
  int v4 = *(void ***)(a1 + 408);
  if (v4)
  {
    do
    {
      BOOL v7 = (void **)*v4;
      if (*((char *)v4 + 39) < 0) {
        operator delete(v4[2]);
      }
      operator delete(v4);
      int v4 = v7;
    }
    while (v7);
  }
  uint64_t v5 = *(void **)(a1 + 392);
  *(void *)(a1 + 392) = 0;
  if (v5) {
    operator delete(v5);
  }
  if (*(char *)(a1 + 391) < 0)
  {
    operator delete(*(void **)(a1 + 368));
    if (!*(unsigned char *)(a1 + 360)) {
      goto LABEL_19;
    }
  }
  else if (!*(unsigned char *)(a1 + 360))
  {
    goto LABEL_19;
  }
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }
LABEL_19:
  *(void *)a1 = &unk_1EF0B9B70;
  size_t v8 = *(void **)(a1 + 296);
  if (v8) {
    operator delete(v8);
  }
  CFLocaleRef v9 = *(void **)(a1 + 264);
  if (v9)
  {
    do
    {
      unint64_t v10 = (void *)*v9;
      operator delete(v9);
      CFLocaleRef v9 = v10;
    }
    while (v10);
  }
  char v11 = *(void **)(a1 + 248);
  *(void *)(a1 + 248) = 0;
  if (v11) {
    operator delete(v11);
  }
  return sub_19E4F9738((void *)a1);
}

void *sub_19E4F9738(void *a1)
{
  *a1 = &unk_1EF0BAC38;
  sub_19E382EFC((uint64_t)(a1 + 16));
  uint64_t v2 = (void *)a1[13];
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = (void *)a1[11];
  a1[11] = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (const void *)a1[7];
  if (v5) {
    CFRelease(v5);
  }
  a1[7] = 0;
  uint64_t v6 = a1[4];
  if (v6)
  {
    uint64_t v7 = a1[5];
    size_t v8 = (void *)a1[4];
    if (v7 != v6)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0) {
          operator delete(*(void **)(v7 - 24));
        }
        v7 -= 24;
      }
      while (v7 != v6);
      size_t v8 = (void *)a1[4];
    }
    a1[5] = v6;
    operator delete(v8);
  }
  uint64_t v9 = a1[1];
  if (v9)
  {
    uint64_t v10 = a1[2];
    char v11 = (void *)a1[1];
    if (v10 != v9)
    {
      do
      {
        if (*(char *)(v10 - 1) < 0) {
          operator delete(*(void **)(v10 - 24));
        }
        v10 -= 24;
      }
      while (v10 != v9);
      char v11 = (void *)a1[1];
    }
    a1[2] = v9;
    operator delete(v11);
  }
  return a1;
}

void *sub_19E4F9864(void *result, CFArrayRef theArray)
{
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (theArray)
  {
    uint64_t v3 = (uint64_t)result;
    CFIndex v4 = 0;
    while (1)
    {
      os_log_t result = (void *)CFArrayGetCount(theArray);
      if (v4 >= (uint64_t)result) {
        break;
      }
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v4);
      sub_19E37774C(ValueAtIndex, __p);
      unint64_t v7 = *(void *)(v3 + 8);
      if (v7 < *(void *)(v3 + 16))
      {
        long long v5 = *(_OWORD *)__p;
        *(void *)(v7 + 16) = v11;
        *(_OWORD *)unint64_t v7 = v5;
        *(void *)(v3 + 8) = v7 + 24;
        ++v4;
      }
      else
      {
        size_t v8 = sub_19E3EB1B8((void **)v3, (uint64_t)__p);
        int v9 = SHIBYTE(v11);
        *(void *)(v3 + 8) = v8;
        if (v9 < 0) {
          operator delete(__p[0]);
        }
        ++v4;
      }
    }
  }
  return result;
}

void sub_19E4F991C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_19E3EB09C(v15);
  _Unwind_Resume(a1);
}

uint64_t *sub_19E4F9950(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*(char *)(v2 + 95) < 0)
    {
      operator delete(*(void **)(v2 + 72));
      if ((*(char *)(v2 + 71) & 0x80000000) == 0)
      {
LABEL_4:
        if ((*(char *)(v2 + 47) & 0x80000000) == 0) {
          goto LABEL_5;
        }
        goto LABEL_10;
      }
    }
    else if ((*(char *)(v2 + 71) & 0x80000000) == 0)
    {
      goto LABEL_4;
    }
    operator delete(*(void **)(v2 + 48));
    if ((*(char *)(v2 + 47) & 0x80000000) == 0)
    {
LABEL_5:
      if ((*(char *)(v2 + 23) & 0x80000000) == 0)
      {
LABEL_6:
        MEMORY[0x19F3BDCF0](v2, 0x1012C4003C2D8E3);
        return a1;
      }
LABEL_11:
      operator delete(*(void **)v2);
      goto LABEL_6;
    }
LABEL_10:
    operator delete(*(void **)(v2 + 24));
    if ((*(char *)(v2 + 23) & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_11;
  }
  return a1;
}

char *sub_19E4F99F4(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E39369C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  int v5 = *((_DWORD *)a2 + 6);
  *((void *)__dst + 4) = 0;
  *((_DWORD *)__dst + 6) = v5;
  if (*((char *)a2 + 63) < 0)
  {
    sub_19E39369C(__dst + 40, *((void **)a2 + 5), *((void *)a2 + 6));
  }
  else
  {
    long long v6 = *(long long *)((char *)a2 + 40);
    *((void *)__dst + 7) = *((void *)a2 + 7);
    *(_OWORD *)(__dst + 40) = v6;
  }
  if (*((char *)a2 + 87) < 0)
  {
    sub_19E39369C(__dst + 64, *((void **)a2 + 8), *((void *)a2 + 9));
  }
  else
  {
    long long v7 = a2[4];
    *((void *)__dst + 10) = *((void *)a2 + 10);
    *((_OWORD *)__dst + 4) = v7;
  }
  if (*((void *)a2 + 4)) {
    operator new();
  }
  return __dst;
}

void sub_19E4F9B70(_Unwind_Exception *a1)
{
  if (*(char *)(v1 + 63) < 0) {
    operator delete(*v3);
  }
  sub_19E4F9950(v2);
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(a1);
}

char *sub_19E4F9BE4(char *__dst, long long *a2)
{
  if (*((char *)a2 + 23) < 0)
  {
    sub_19E39369C(__dst, *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *((void *)__dst + 2) = *((void *)a2 + 2);
    *(_OWORD *)std::string __dst = v4;
  }
  if (*((char *)a2 + 47) < 0)
  {
    sub_19E39369C(__dst + 24, *((void **)a2 + 3), *((void *)a2 + 4));
  }
  else
  {
    long long v5 = *(long long *)((char *)a2 + 24);
    *((void *)__dst + 5) = *((void *)a2 + 5);
    *(_OWORD *)(__dst + 24) = v5;
  }
  if (*((char *)a2 + 71) < 0)
  {
    sub_19E39369C(__dst + 48, *((void **)a2 + 6), *((void *)a2 + 7));
  }
  else
  {
    long long v6 = a2[3];
    *((void *)__dst + 8) = *((void *)a2 + 8);
    *((_OWORD *)__dst + 3) = v6;
  }
  long long v7 = __dst + 72;
  if (*((char *)a2 + 95) < 0)
  {
    sub_19E39369C(v7, *((void **)a2 + 9), *((void *)a2 + 10));
  }
  else
  {
    long long v8 = *(long long *)((char *)a2 + 72);
    *((void *)__dst + 11) = *((void *)a2 + 11);
    *(_OWORD *)long long v7 = v8;
  }
  return __dst;
}

void sub_19E4F9CC8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 71) < 0)
  {
    operator delete(*v3);
    if ((*(char *)(v1 + 47) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((*(char *)(v1 + 47) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v2);
  if ((*(char *)(v1 + 23) & 0x80000000) == 0) {
LABEL_4:
  }
    _Unwind_Resume(exception_object);
LABEL_7:
  operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void *sub_19E4F9D3C(void *a1, CFArrayRef theArray, unint64_t a3)
{
  if (CFArrayGetCount(theArray) <= a3
    || (ValueAtIndex = CFArrayGetValueAtIndex(theArray, a3), (long long v7 = ValueAtIndex) == 0))
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E401A0C();
  }
  CFRetain(ValueAtIndex);
  return sub_19E372124(a1, v7);
}

void sub_19E4F9DC0()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E4F9DE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E4F9E00(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(const void **)a1;
    if (*(void *)a1) {
      CFRelease(v2);
    }
  }
  return a1;
}

uint64_t sub_19E4F9E3C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 850045863;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  sub_19E4F99F4((char *)(a1 + 88), (long long *)(a2 + 88));
  CFTypeRef v4 = *(CFTypeRef *)(a2 + 176);
  if (v4) {
    CFTypeRef v4 = CFRetain(v4);
  }
  *(void *)(a1 + 176) = v4;
  *(void *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 192) = *(unsigned char *)(a2 + 192);
  *(void *)(a1 + 196) = *(void *)(a2 + 196);
  *(_OWORD *)(a1 + 204) = *(_OWORD *)(a2 + 204);
  *(_OWORD *)(a1 + 220) = *(_OWORD *)(a2 + 220);
  *(void *)(a1 + 236) = *(void *)(a2 + 236);
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 244);
  uint64_t v5 = *(void *)(a2 + 248);
  *(_DWORD *)(a1 + 256) = *(_DWORD *)(a2 + 256);
  *(void *)(a1 + 248) = v5;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 280) = 0;
  *(void *)(a1 + 264) = 0;
  long long v7 = *(unsigned char **)(a2 + 264);
  long long v6 = *(unsigned char **)(a2 + 272);
  int64_t v8 = v6 - v7;
  if (v6 != v7)
  {
    if (v8 < 0) {
      sub_19E37C7C4();
    }
    int v9 = (char *)operator new(v6 - v7);
    *(void *)(a1 + 264) = v9;
    *(void *)(a1 + 272) = v9;
    uint64_t v10 = &v9[4 * (v8 >> 2)];
    *(void *)(a1 + 280) = v10;
    memcpy(v9, v7, v8);
    *(void *)(a1 + 272) = v10;
  }
  *(void *)(a1 + 288) = *(void *)(a2 + 288);
  uint64_t v11 = *(void *)(a2 + 296);
  *(_DWORD *)(a1 + 304) = *(_DWORD *)(a2 + 304);
  *(void *)(a1 + 296) = v11;
  *(_DWORD *)(a1 + 308) = *(_DWORD *)(a2 + 308);
  *(_DWORD *)(a1 + 312) = *(_DWORD *)(a2 + 312);
  *(_DWORD *)(a1 + 316) = *(_DWORD *)(a2 + 316);
  *(_DWORD *)(a1 + 320) = *(_DWORD *)(a2 + 320);
  *(_OWORD *)(a1 + 324) = *(_OWORD *)(a2 + 324);
  *(_DWORD *)(a1 + 340) = *(_DWORD *)(a2 + 340);
  *(unsigned char *)(a1 + 344) = *(unsigned char *)(a2 + 344);
  *(_DWORD *)(a1 + 348) = *(_DWORD *)(a2 + 348);
  *(_DWORD *)(a1 + 352) = *(_DWORD *)(a2 + 352);
  *(void *)(a1 + 356) = *(void *)(a2 + 356);
  *(_WORD *)(a1 + 364) = *(_WORD *)(a2 + 364);
  *(_OWORD *)(a1 + 368) = *(_OWORD *)(a2 + 368);
  *(_DWORD *)(a1 + 384) = *(_DWORD *)(a2 + 384);
  *(_DWORD *)(a1 + 388) = *(_DWORD *)(a2 + 388);
  *(void *)(a1 + 392) = *(void *)(a2 + 392);
  *(_WORD *)(a1 + 400) = *(_WORD *)(a2 + 400);
  *(void *)(a1 + 408) = 0;
  *(_DWORD *)(a1 + 416) = *(_DWORD *)(a2 + 416);
  *(_DWORD *)(a1 + 420) = *(_DWORD *)(a2 + 420);
  *(_DWORD *)(a1 + 424) = *(_DWORD *)(a2 + 424);
  *(_WORD *)(a1 + 428) = *(_WORD *)(a2 + 428);
  if (*(char *)(a2 + 455) < 0)
  {
    sub_19E39369C((unsigned char *)(a1 + 432), *(void **)(a2 + 432), *(void *)(a2 + 440));
  }
  else
  {
    long long v12 = *(_OWORD *)(a2 + 432);
    *(void *)(a1 + 448) = *(void *)(a2 + 448);
    *(_OWORD *)(a1 + 432) = v12;
  }
  *(_DWORD *)(a1 + 456) = *(_DWORD *)(a2 + 456);
  *(void *)(a1 + 464) = *(void *)(a2 + 464);
  if (*(void *)(a2 + 184)) {
    operator new();
  }
  uint64_t v13 = *(void *)(a2 + 408);
  if (*(void *)(a1 + 408) != v13)
  {
    CFRetain(*(CFTypeRef *)(a2 + 408));
    unsigned int v14 = *(const void **)(a1 + 408);
    if (v14) {
      CFRelease(v14);
    }
    *(void *)(a1 + 408) = v13;
  }
  return a1;
}

void sub_19E4FA0B0(_Unwind_Exception *a1)
{
  CFTypeRef v4 = *(const void **)(v1 + 408);
  if (v4) {
    CFRelease(v4);
  }
  *(void *)(v1 + 408) = 0;
  uint64_t v5 = *(void **)(v1 + 264);
  if (v5)
  {
    *(void *)(v1 + 272) = v5;
    operator delete(v5);
  }
  long long v6 = *(void ***)(v1 + 184);
  *(void *)(v1 + 184) = 0;
  if (v6) {
    sub_19E3D7720(v6);
  }
  long long v7 = *(const void **)(v1 + 176);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v1 + 176) = 0;
  sub_19E3D7810(v2);
  int64_t v8 = *(void **)(v1 + 64);
  if (v8)
  {
    *(void *)(v1 + 72) = v8;
    operator delete(v8);
  }
  std::mutex::~mutex((std::mutex *)v1);
  _Unwind_Resume(a1);
}

float sub_19E4FA184(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 == a3) {
    return *(float *)(a1 + 228);
  }
  int v4 = *(_DWORD *)(a1 + 348);
  int v5 = a2 & 0x3F;
  if (v4 != 8) {
    int v5 = (a2 >> 6);
  }
  int v6 = a3 & 0x3F;
  if (v4 == 8)
  {
    BOOL v7 = 0;
  }
  else
  {
    int v6 = (a3 >> 6);
    BOOL v7 = ((a3 ^ a2) & 0x3F) == 0;
  }
  if (v7)
  {
    BOOL v7 = v5 == v6;
    uint64_t v14 = a1 + 236;
    if (!v7) {
      uint64_t v14 = a1 + 240;
    }
    return *(float *)v14;
  }
  else
  {
    char v8 = v4 - 2;
    unsigned int v9 = a2 >> (v4 - 2);
    unsigned int v10 = a3 >> v8;
    if (v9 == v10 || v5 == v6)
    {
      BOOL v12 = v5 != v6 && v9 == v10;
      uint64_t v13 = a1 + 236;
      if (v12) {
        uint64_t v13 = a1 + 224;
      }
      return *(float *)v13;
    }
    else
    {
      return *(float *)(a1 + 232);
    }
  }
}

float sub_19E4FA220(uint64_t a1, unsigned int a2, unsigned int a3)
{
  int v3 = *(_DWORD *)(a1 + 348);
  char v4 = v3 - 2;
  unsigned int v5 = a3 >> (v3 - 2);
  float result = 0.0;
  if (v5 != 1)
  {
    if (a2 == a3)
    {
      uint64_t v7 = a1 + 228;
    }
    else
    {
      BOOL v8 = v3 == 8;
      if (v3 == 8) {
        int v9 = a2 & 0x3F;
      }
      else {
        int v9 = (a2 >> 6);
      }
      int v10 = a3 & 0x3F;
      if (v8 || (int v10 = (a3 >> 6), ((a3 ^ a2) & 0x3F) != 0))
      {
        unsigned int v11 = a2 >> v4;
        if (v11 == v5 || v9 == v10)
        {
          if (v9 == v10 || v11 != v5) {
            uint64_t v7 = a1 + 236;
          }
          else {
            uint64_t v7 = a1 + 224;
          }
        }
        else
        {
          uint64_t v7 = a1 + 232;
        }
      }
      else
      {
        uint64_t v7 = a1 + 236;
        if (v9 != (a3 >> 6)) {
          uint64_t v7 = a1 + 240;
        }
      }
    }
    return *(float *)v7;
  }
  return result;
}

float sub_19E4FA2C4(uint64_t a1, int a2, int a3)
{
  float result = 0.0;
  if (a2 == a3) {
    return *(float *)(a1 + 228);
  }
  return result;
}

uint64_t sub_19E4FA2D8(uint64_t a1, unsigned int a2, _WORD *a3)
{
  unsigned int v3 = HIWORD(a2);
  unsigned int v4 = *(_DWORD *)(a1 + 40);
  if (HIWORD(a2) >= v4) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = (int *)(v5 + 4 * *(unsigned int *)(v6 + 4 * v3));
  if (v3 == v4 - 1)
  {
    BOOL v8 = (int *)(*(void *)(a1 + 8) + *(void *)(a1 + 16));
    if (v7 == v8) {
      return 0;
    }
  }
  else
  {
    BOOL v8 = (int *)(v5 + 4 * *(unsigned int *)(v6 + 4 * (v3 + 1)));
    if (v7 == v8) {
      return 0;
    }
  }
  unint64_t v9 = v8 - v7;
  do
  {
    unint64_t v10 = v9 >> 1;
    unsigned int v11 = &v7[v9 >> 1];
    unsigned int v12 = *((unsigned __int16 *)v11 + 1);
    uint64_t v13 = v11 + 1;
    v9 += ~(v9 >> 1);
    if (v12 < (unsigned __int16)a2) {
      uint64_t v7 = v13;
    }
    else {
      unint64_t v9 = v10;
    }
  }
  while (v9);
  if (v7 >= v8) {
    return 0;
  }
  int v14 = *v7;
  if ((v14 ^ (a2 << 16)) >> 16) {
    return 0;
  }
  if (a3) {
    *a3 = v14;
  }
  return 1;
}

void sub_19E4FA38C(void *a1)
{
  *a1 = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E4FA404(void *a1)
{
  *a1 = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  return a1;
}

void sub_19E4FA45C(void *a1)
{
  *a1 = &unk_1EF0B99D8;
  sub_19E3C2CE4();
}

void sub_19E4FA7EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v44 & 1) == 0)
    {
LABEL_8:
      a22 = *MEMORY[0x1E4FBA408];
      uint64_t v46 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(uint64_t *)((char *)&a22 + *(void *)(a22 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
      a24 = v46;
      a25 = MEMORY[0x1E4FBA470] + 16;
      if (a38 < 0) {
        operator delete(a33);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x19F3BDC30](&a41);
      if (*v42) {
        munmap(*v42, *(void *)(v41 + 16));
      }
      *(void *)(v41 + 16) = 0;
      _Unwind_Resume(a1);
    }
  }
  else if (!v44)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v43);
  goto LABEL_8;
}

void sub_19E4FA9C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x19E4FA9B8);
}

uint64_t sub_19E4FA9E4(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v6 = *(void *)(a1 + 16);
  if (a3 >= v6) {
    unint64_t v7 = v6 - 1;
  }
  else {
    unint64_t v7 = a3;
  }
  if (a3 >= v6) {
    unint64_t v8 = a2 + 4 * a3 + 4 * (1 - v6);
  }
  else {
    unint64_t v8 = a2;
  }
  if (v7 >= a4)
  {
    if (!v7) {
      goto LABEL_16;
    }
    uint64_t v13 = (const float *)(a1 + 24);
    unint64_t v14 = *(void *)(a1 + 56);
    if (v7 >= 8)
    {
      unint64_t v15 = 0;
      unint64_t v27 = v14 + 4 * v7;
      BOOL v29 = v14 < a1 + 28 && (unint64_t)v13 < v27;
      if ((v8 >= v27 || v14 >= v8 + 4 * v7) && !v29)
      {
        unint64_t v15 = v7 & 0xFFFFFFFFFFFFFFF8;
        uint32x4_t v31 = (uint32x4_t)vld1q_dup_f32(v13);
        int v32 = (int8x16_t *)(v8 + 16);
        unint64_t v33 = (int8x16_t *)(v14 + 16);
        unint64_t v34 = v7 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int8x16_t v35 = vbicq_s8(*v32, (int8x16_t)vcgtq_u32(*(uint32x4_t *)v32, v31));
          v33[-1] = vbicq_s8(v32[-1], (int8x16_t)vcgtq_u32((uint32x4_t)v32[-1], v31));
          *unint64_t v33 = v35;
          v32 += 2;
          v33 += 2;
          v34 -= 8;
        }
        while (v34);
        if (v7 == v15) {
          goto LABEL_16;
        }
      }
    }
    else
    {
      unint64_t v15 = 0;
    }
    unint64_t v16 = v7 - v15;
    uint64_t v17 = 4 * v15;
    int v18 = (unsigned int *)(v14 + v17);
    int v19 = (unsigned int *)(v8 + v17);
    do
    {
      unsigned int v21 = *v19++;
      unsigned int v20 = v21;
      if (v21 > *(_DWORD *)v13) {
        unsigned int v20 = 0;
      }
      *v18++ = v20;
      --v16;
    }
    while (v16);
LABEL_16:
    double v22 = 0.0;
    if (v7 > a4)
    {
      uint64_t v23 = 0;
      unint64_t v24 = v7;
      do
      {
        if (sub_19E4B0FF0(*(uint64_t ***)(a1 + 80), (unsigned int *)(*(void *)(a1 + 56) + v23), v24, v37) != 2)double v22 = *(double *)(**(void **)(a1 + 96) + 8 * BYTE1(v37[0])) + v22; {
        --v24;
        }
        v23 += 4;
      }
      while (v24 > a4);
    }
    if (!a4 && (a5 & 0x8000000000000000) == 0)
    {
      if (!*(void *)(a1 + 88))
      {
        v37[0] = &unk_1EF0BBF60;
        v37[1] = a1;
        v37[2] = a6;
        *(double *)&v37[3] = v22;
        *(_OWORD *)size_t v38 = 0u;
        long long v39 = 0u;
        *(_OWORD *)std::string __p = 0u;
        uint64_t v41 = 0;
        int v25 = *(_DWORD *)(**(void **)(a1 + 80) + 32);
        if (v25 != 5 && v25 != 3) {
          operator new();
        }
        operator new();
      }
      operator new();
    }
    operator new();
  }
  return 0;
}

void sub_19E4FAE54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x19F3BDCF0](v2, 0x30C400D66AB62);
  sub_19E4FAF10((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_19E4FAE88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p)
  {
    operator delete(__p);
    unsigned int v20 = a15;
    if (!a15) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    unsigned int v20 = a15;
    if (!a15) {
      goto LABEL_3;
    }
  }
  operator delete(v20);
  _Unwind_Resume(exception_object);
}

void sub_19E4FAEC4(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v2 + 72) = v5;
    operator delete(v5);
  }
  unint64_t v6 = *v1;
  if (*v1)
  {
    *(void *)(v2 + 48) = v6;
    operator delete(v6);
  }
  MEMORY[0x19F3BDCF0](v2, 0x10B1C4025CEEBF4);
  _Unwind_Resume(a1);
}

void *sub_19E4FAF10(void *a1)
{
  *a1 = &unk_1EF0BBF60;
  uint64_t v2 = a1[11];
  a1[11] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  unsigned int v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  unsigned int v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }
  return a1;
}

unint64_t sub_19E4FAFA0(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v4 = *(void *)(a1 + 72) - v3;
  unint64_t v5 = v4 >> 4;
  if (!v4)
  {
    double v8 = 0.0;
    goto LABEL_17;
  }
  if (v5 <= 1) {
    unint64_t v6 = 1;
  }
  else {
    unint64_t v6 = v4 >> 4;
  }
  if (a2)
  {
    unint64_t v7 = (double *)(v3 + 8);
    double v8 = 0.0;
    do
    {
      double v8 = *(v7 - 1) + v8;
      int v9 = *(_DWORD *)v7;
      v7 += 2;
      *a2++ = v9;
      --v6;
    }
    while (v6);
    goto LABEL_17;
  }
  if (v6 < 2)
  {
    unint64_t v10 = 0;
    double v8 = 0.0;
LABEL_15:
    unint64_t v17 = v6 - v10;
    int v18 = (double *)(v3 + 16 * v10);
    do
    {
      double v19 = *v18;
      v18 += 2;
      double v8 = v19 + v8;
      --v17;
    }
    while (v17);
    goto LABEL_17;
  }
  unint64_t v10 = v6 & 0xFFFFFFFFFFFFFFFELL;
  unsigned int v11 = (double *)(v3 + 16);
  double v12 = 0.0;
  unint64_t v13 = v6 & 0xFFFFFFFFFFFFFFFELL;
  double v14 = 0.0;
  do
  {
    double v15 = *(v11 - 2);
    double v16 = *v11;
    v11 += 4;
    double v12 = v15 + v12;
    double v14 = v16 + v14;
    v13 -= 2;
  }
  while (v13);
  double v8 = v14 + v12;
  if (v6 != v10) {
    goto LABEL_15;
  }
LABEL_17:
  if (a3)
  {
    *(void *)(a3 + 8) = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)(a3 + 16) = 0;
    *(_WORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 1;
    *(_OWORD *)(a3 + 40) = xmmword_19E572FD0;
    *(_DWORD *)(a3 + 56) = 0;
    *(_OWORD *)(a3 + 64) = xmmword_19E572FD0;
    *(void *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 80) = 0xFFEFFFFFFFFFFFFFLL;
    *(double *)a3 = v8;
    *(_DWORD *)(a3 + 116) = *(_DWORD *)(a1 + 96);
    *(unsigned char *)(a3 + 112) = 0;
    *(void *)(a3 + 104) = (*(uint64_t (**)(void, _DWORD *))(**(void **)(a1 + 88) + 32))(*(void *)(a1 + 88), a2);
  }
  return v5;
}

uint64_t sub_19E4FB0E0(uint64_t a1)
{
  if ((unint64_t)(*(void *)(a1 + 32) - 1) <= 2 && *(void *)(a1 + 16) >= 2uLL)
  {
    uint64_t v2 = *(void *)(a1 + 64);
    uint64_t v3 = *(void *)(a1 + 72);
    unint64_t v4 = (v3 - v2) >> 4;
    uint64_t v5 = *(void *)(a1 + 8);
    if (v4 < *(void *)(v5 + 16) - 1)
    {
      uint64_t v6 = *(void *)(a1 + 40);
      unint64_t v7 = *(unsigned char **)(a1 + 48);
      unint64_t v8 = (unint64_t)&v7[-v6];
      unint64_t v36 = (uint64_t)&v7[-v6] >> 2;
      if (v36 > v4)
      {
        memset(v37, 0, sizeof(v37));
        if ((v8 & 0x8000000000000000) != 0) {
          sub_19E37C7C4();
        }
        int v9 = (char *)operator new((size_t)&v7[-v6]);
        bzero(v9, (size_t)&v7[-v6]);
        unint64_t v10 = (unsigned char *)(v6 + 4 * v4);
        if (v7 != v10) {
          memmove(v9, v10, v7 - v10);
        }
        if (v3 != v2)
        {
          if (v4 <= 1) {
            unint64_t v11 = 1;
          }
          else {
            unint64_t v11 = (v3 - v2) >> 4;
          }
          if (v11 <= 0xF
            || (unint64_t)&v9[v8 - 4 * v4] < v2 + 16 * v11 - 4
            && v2 + 8 < (unint64_t)&v9[v8 + 4 * v11 - 4 * v4])
          {
            unint64_t v12 = 0;
            unint64_t v13 = v36 - v4;
            goto LABEL_16;
          }
          unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          int v32 = (_DWORD *)(v2 + 40);
          unint64_t v33 = &v9[4 * v36 + -4 * v4];
          unint64_t v34 = v11 & 0xFFFFFFFFFFFFFFFCLL;
          do
          {
            LODWORD(v35) = *(v32 - 8);
            DWORD1(v35) = *(v32 - 4);
            DWORD2(v35) = *v32;
            HIDWORD(v35) = v32[4];
            *(_OWORD *)unint64_t v33 = v35;
            v33 += 16;
            v32 += 16;
            v34 -= 4;
          }
          while (v34);
          if (v11 != v12)
          {
            unint64_t v13 = v36 - v4 + v12;
LABEL_16:
            unint64_t v14 = v11 - v12;
            double v15 = (int *)(v2 + 16 * v12 + 8);
            double v16 = &v9[4 * v13];
            do
            {
              int v17 = *v15;
              v15 += 4;
              *(_DWORD *)double v16 = v17;
              v16 += 4;
              --v14;
            }
            while (v14);
          }
        }
        sub_19E4B248C(*(uint64_t **)(v5 + 80), (unsigned int *)v9, v8 >> 2);
      }
    }
  }
  *(void *)(a1 + 72) = *(void *)(a1 + 64);
  uint64_t result = (***(uint64_t (****)(void))(a1 + 88))(*(void *)(a1 + 88));
  if (result)
  {
    LOBYTE(v37[0]) = 0;
    unsigned int v19 = (*(uint64_t (**)(void, void *))(**(void **)(a1 + 88) + 8))(*(void *)(a1 + 88), v37);
    double v20 = *(double *)(**(void **)(*(void *)(a1 + 8) + 104) + 8 * LOBYTE(v37[0])) + *(double *)(a1 + 24);
    uint64_t v21 = v19;
    uint64_t v23 = *(double **)(a1 + 72);
    unint64_t v22 = *(void *)(a1 + 80);
    if ((unint64_t)v23 >= v22)
    {
      int v25 = *(double **)(a1 + 64);
      uint64_t v26 = ((char *)v23 - (char *)v25) >> 4;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 60) {
        sub_19E37C7C4();
      }
      uint64_t v28 = v22 - (void)v25;
      if (v28 >> 3 > v27) {
        unint64_t v27 = v28 >> 3;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v27;
      }
      if (v29)
      {
        if (v29 >> 60) {
          sub_19E37C2B8();
        }
        std::string v30 = (char *)operator new(16 * v29);
      }
      else
      {
        std::string v30 = 0;
      }
      uint32x4_t v31 = &v30[16 * v26];
      *(double *)uint32x4_t v31 = v20;
      *((void *)v31 + 1) = v21;
      unint64_t v24 = (double *)(v31 + 16);
      if (v23 != v25)
      {
        do
        {
          *((_OWORD *)v31 - 1) = *((_OWORD *)v23 - 1);
          v31 -= 16;
          v23 -= 2;
        }
        while (v23 != v25);
        uint64_t v23 = *(double **)(a1 + 64);
      }
      *(void *)(a1 + 64) = v31;
      *(void *)(a1 + 72) = v24;
      *(void *)(a1 + 80) = &v30[16 * v29];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      *uint64_t v23 = v20;
      *((void *)v23 + 1) = v19;
      unint64_t v24 = v23 + 2;
    }
    *(void *)(a1 + 72) = v24;
    ++*(void *)(a1 + 32);
    return 1;
  }
  return result;
}

void sub_19E4FB4DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  operator delete(v15);
  _Unwind_Resume(a1);
}

void sub_19E4FB50C(char **a1, _OWORD *a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    unint64_t v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        sub_19E37C2B8();
      }
      unint64_t v12 = (char *)operator new(16 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    unint64_t v13 = &v12[16 * v8];
    *(_OWORD *)unint64_t v13 = *a2;
    uint64_t v6 = v13 + 16;
    if (v5 != v7)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v7);
      uint64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[16 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v5 = *a2;
    uint64_t v6 = v5 + 16;
  }
  a1[1] = v6;
}

void sub_19E4FB60C(void *a1)
{
  *a1 = &unk_1EF0BBF60;
  uint64_t v2 = a1[11];
  a1[11] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = (void *)a1[8];
  if (v3)
  {
    a1[9] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[5];
  if (v4)
  {
    a1[6] = v4;
    operator delete(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E4FB6BC(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, double *a5, unint64_t *a6)
{
  unint64_t v6 = *(void *)(a1 + 16);
  unint64_t v7 = v6 - 1;
  unint64_t v8 = a3 + 4 * a4 + 4 * (1 - v6);
  if (a4 < v6)
  {
    unint64_t v8 = a3;
    unint64_t v7 = a4;
  }
  if (v7)
  {
    unint64_t v9 = (const float *)(a1 + 24);
    unint64_t v10 = *(void *)(a1 + 56);
    if (v7 >= 8)
    {
      unint64_t v11 = 0;
      unint64_t v12 = v10 + 4 * v7;
      BOOL v14 = v10 < a1 + 28 && (unint64_t)v9 < v12;
      if ((v8 >= v12 || v10 >= v8 + 4 * v7) && !v14)
      {
        unint64_t v11 = v7 & 0xFFFFFFFFFFFFFFF8;
        uint32x4_t v16 = (uint32x4_t)vld1q_dup_f32(v9);
        int v17 = (int8x16_t *)(v8 + 16);
        int v18 = (int8x16_t *)(v10 + 16);
        unint64_t v19 = v7 & 0xFFFFFFFFFFFFFFF8;
        do
        {
          int8x16_t v20 = vbicq_s8(*v17, (int8x16_t)vcgtq_u32(*(uint32x4_t *)v17, v16));
          v18[-1] = vbicq_s8(v17[-1], (int8x16_t)vcgtq_u32((uint32x4_t)v17[-1], v16));
          int8x16_t *v18 = v20;
          v17 += 2;
          v18 += 2;
          v19 -= 8;
        }
        while (v19);
        if (v7 == v11) {
          goto LABEL_25;
        }
      }
    }
    else
    {
      unint64_t v11 = 0;
    }
    unint64_t v21 = v7 - v11;
    uint64_t v22 = 4 * v11;
    uint64_t v23 = (unsigned int *)(v10 + v22);
    unint64_t v24 = (unsigned int *)(v8 + v22);
    do
    {
      unsigned int v26 = *v24++;
      unsigned int v25 = v26;
      if (v26 > *(_DWORD *)v9) {
        unsigned int v25 = 0;
      }
      *v23++ = v25;
      --v21;
    }
    while (v21);
  }
LABEL_25:
  if (*(_DWORD *)(a1 + 24) >= a2)
  {
    double v29 = *(double *)(a1 + 32);
    unint64_t v27 = *(unsigned int **)(a1 + 56);
    v27[v7] = a2;
    double v28 = 0.0;
  }
  else
  {
    unint64_t v27 = *(unsigned int **)(a1 + 56);
    v27[v7] = 0;
    double v28 = -*(double *)(a1 + 40);
    double v29 = 0.0;
  }
  *a5 = sub_19E4FB818(a1, v27, v7 + 1, a6, 1, v29) + v28;
  return 1;
}

double sub_19E4FB818(uint64_t a1, unsigned int *a2, unint64_t a3, unint64_t *a4, uint64_t a5, double a6)
{
  double v8 = *(double *)(a1 + 128) - a6;
  unint64_t v9 = *(uint64_t ***)(a1 + 80);
  if (v9)
  {
    int v14 = sub_19E4B0FF0(v9, a2, a3, v18);
    if (v14 == 1)
    {
      if (a3 >= 2)
      {
        double v16 = 0.0;
        if (a5) {
          double v16 = *(double *)(**(void **)(a1 + 96) + 8 * v18[1]);
        }
        return sub_19E4FB818(a1, a2 + 1, a3 - 1, a4, a5, a6) + v16;
      }
    }
    else if (v14)
    {
      if (a3 >= 2) {
        return sub_19E4FB818(a1, a2 + 1, a3 - 1, a4, a5, a6);
      }
    }
    else
    {
      double v8 = *(double *)(**(void **)(a1 + 104) + 8 * v18[0]);
      if (a3 == 1)
      {
        double v15 = 0.0;
        if (!*a2) {
          double v15 = a6;
        }
        double v8 = v8 - v15;
      }
      if (a4) {
        *a4 = a3;
      }
    }
  }
  return v8;
}

void sub_19E4FB938(void *a1)
{
  sub_19E4580B4(a1);
  JUMPOUT(0x19F3BDCF0);
}

void sub_19E4FB974(uint64_t a1, CFDictionaryRef *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(*a2, @"Weight");
  if (Value)
  {
    valuePtr[0] = 0;
    CFNumberGetValue(Value, kCFNumberDoubleType, valuePtr);
    double v7 = *(double *)valuePtr;
  }
  else
  {
    double v7 = 1.0;
  }
  *(double *)(a1 + 8) = v7;
  *(void *)a1 = &unk_1EF0B9A00;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(double *)(a1 + 40) = *(float *)(a3 + 296);
  LODWORD(valuePtr[0]) = 0;
  CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(*a2, @"Type");
  CFNumberGetValue(v8, kCFNumberIntType, valuePtr);
  *(_OWORD *)(a1 + 56) = 0u;
  *(_DWORD *)(a1 + 48) = valuePtr[0];
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 72) = 0u;
  CFDictionaryGetValue(*a2, @"URL");
  sub_19E3C2CE4();
}

void sub_19E4FC0D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t *a11, uint64_t **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (*(char *)(v41 - 121) < 0) {
    operator delete(*(void **)(v41 - 144));
  }
  if (a28 < 0)
  {
    operator delete(__p);
    if ((v36 & 1) == 0)
    {
LABEL_8:
      sub_19E3933E0((uint64_t)&a29);
      sub_19E452D6C(v39);
      sub_19E4FC234(v38);
      sub_19E4FC234(v37);
      sub_19E4FC28C(a11);
      sub_19E4FC2F4(a12);
      size_t v43 = *v35;
      if (!*v35) {
        _Unwind_Resume(a1);
      }
      *(void *)(v34 + 64) = v43;
      operator delete(v43);
      _Unwind_Resume(a1);
    }
  }
  else if (!v36)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v40);
  goto LABEL_8;
}

uint64_t *sub_19E4FC234(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1080C409A65DFB4);
  }
  return a1;
}

uint64_t *sub_19E4FC28C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 24);
    if (v3)
    {
      *(void *)(v2 + 32) = v3;
      operator delete(v3);
    }
    unint64_t v4 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v4;
      operator delete(v4);
    }
    MEMORY[0x19F3BDCF0](v2, 0x30C400D66AB62);
  }
  return a1;
}

uint64_t **sub_19E4FC2F4(uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v4 = *(void *)(v3 + 24);
      if (v4)
      {
        sub_19E4AB828(v4 + 8);
        MEMORY[0x19F3BDCF0](v4, 0x1020C403F824CD1);
        if (*(void *)v3) {
          free(*(void **)v3);
        }
      }
      MEMORY[0x19F3BDCF0](v3, 0x1030C40FC63861FLL);
    }
    MEMORY[0x19F3BDCF0](v2, 0x20C4093837F09);
  }
  return a1;
}

double sub_19E4FC398(uint64_t a1, unsigned int *a2, unint64_t *a3, uint64_t a4, unsigned int *a5, uint64_t a6, uint64_t a7, int a8, double a9)
{
  if (!a4) {
    return 1.0;
  }
  unint64_t v10 = *a3;
  if (a4 != 1 && v10 > 1) {
    a8 = 1;
  }
  if (!v10) {
    return 0.0;
  }
  double v16 = a2;
  unint64_t v18 = a6 + 1;
  uint64_t v37 = a4 - 1;
  BOOL v19 = a4 == 1;
  if (a4 == 1) {
    char v20 = 1;
  }
  else {
    char v20 = a8;
  }
  unint64_t v21 = &a2[v10];
  uint64_t v22 = a3 + 1;
  if (!a7) {
    BOOL v19 = 0;
  }
  BOOL v35 = v19;
  if (v20)
  {
    unsigned int v36 = a8;
    uint64_t v23 = 0;
    double v24 = 0.0;
    double v25 = 0.0;
    do
    {
      a5[a6] = v16[v23];
      double v26 = sub_19E4FB818(a1, a5, v18, 0, 1, a9);
      double v27 = __exp10(v26);
      double v28 = sub_19E4FC398(a1, v21, v22, v37, a5, v18, a7, v36, a9) * v27;
      if (a4 == 1)
      {
        double v25 = 1.0;
        if (v35) {
          double v28 = *(double *)(a7 + 8 * v23) * v28;
        }
      }
      else
      {
        double v25 = v25 + v29 * v27;
      }
      double v24 = v28 + v24;
      ++v23;
    }
    while (v10 != v23);
  }
  else
  {
    double v24 = 0.0;
    double v30 = 0.0;
    do
    {
      unsigned int v31 = *v16++;
      a5[a6] = v31;
      double v32 = sub_19E4FC398(a1, v21, v22, v37, a5, v18, a7, 0, a9);
      double v30 = v33 + v30;
      double v24 = v32 + v24;
      --v10;
    }
    while (v10);
  }
  return v24;
}

void sub_19E4FC574(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_19E3FC478((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E4FC5E0(void *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  double v7 = *(unsigned char **)a3;
  unint64_t v6 = *(unsigned char **)(a3 + 8);
  uint64_t v191 = 0;
  size_t v192 = 0;
  uint64_t v190 = 0;
  int64_t v8 = v6 - v7;
  if (v6 == v7)
  {
    unint64_t v9 = 0;
  }
  else
  {
    if (v8 < 0) {
      sub_19E37C7C4();
    }
    unint64_t v9 = operator new(v6 - v7);
    uint64_t v190 = v9;
    size_t v192 = &v9[v8 >> 2];
    memmove(v9, v7, v8);
    uint64_t v191 = v192;
    if (*v9 == 1) {
      goto LABEL_7;
    }
  }
  sub_19E4FD734((void **)&v190, v9, byte_19E57CC10);
  if (*v190 != 1) {
    __assert_rtn("conditionalProbability", "CoreLMInferenceEngine.cpp", 177, "workingContext[0] == kMontrealTokenIDBeginningOfSentence");
  }
LABEL_7:
  uint64_t v11 = *a2;
  uint64_t v10 = a2[1];
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  uint64_t v12 = v10 - v11;
  unint64_t v170 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
  if (!v12)
  {
    unint64_t v164 = 0;
    goto LABEL_182;
  }
  uint64_t v171 = a1 + 28;
  unint64_t v172 = 0;
  int64x2_t v167 = vdupq_n_s64(4uLL);
  int64x2_t v166 = vdupq_n_s64(8uLL);
  uint64_t v174 = a4;
  char v186 = a1;
  do
  {
    if (v191 == v190) {
      __assert_rtn("_bestConfigurationMatch", "CoreLMInferenceEngine.cpp", 91, "contextLength > 0");
    }
    unint64_t v13 = v170 - v172;
    int v14 = (unint64_t *)a1[45];
    double v15 = (unint64_t *)a1[46];
    if (v15 != v14)
    {
      unint64_t v16 = v15 - v14;
      do
      {
        unint64_t v17 = v16 >> 1;
        unint64_t v18 = &v14[v16 >> 1];
        unint64_t v20 = *v18;
        BOOL v19 = v18 + 1;
        v16 += ~(v16 >> 1);
        if (v20 < v13) {
          int v14 = v19;
        }
        else {
          unint64_t v16 = v17;
        }
      }
      while (v16);
    }
    uint64_t v21 = *a2;
    if (v14 == v15) {
      int v14 = v15 - 1;
    }
    unint64_t v22 = *v14;
    if (v13 >= *v14) {
      unint64_t v23 = *v14;
    }
    else {
      unint64_t v23 = v170 - v172;
    }
    if (!v23)
    {
      unint64_t v26 = 0;
      goto LABEL_33;
    }
    unint64_t v24 = v191 - v190;
    if (v23 > 3)
    {
      int64x2_t v27 = vdupq_n_s64(v24);
      unint64_t v25 = v23 & 0xFFFFFFFFFFFFFFFCLL;
      double v28 = (uint64_t *)(v21 + 24 * v172 + 48);
      int8x16_t v29 = 0uLL;
      unint64_t v30 = v23 & 0xFFFFFFFFFFFFFFFCLL;
      int8x16_t v31 = 0uLL;
      do
      {
        v32.i64[0] = *(v28 - 5);
        v32.i64[1] = *(v28 - 2);
        v34.i64[0] = *v28;
        v33.i64[0] = v28[1];
        v33.i64[1] = v28[4];
        v35.i64[0] = *(v28 - 6);
        v35.i64[1] = *(v28 - 3);
        v34.i64[1] = v28[3];
        int64x2_t v36 = vsubq_s64(v33, v34);
        int8x16_t v37 = (int8x16_t)vsraq_n_s64(v27, vsubq_s64(v32, v35), 2uLL);
        int8x16_t v38 = (int8x16_t)vsraq_n_s64(v27, v36, 2uLL);
        int8x16_t v29 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v29, (uint64x2_t)v37), v29, v37);
        int8x16_t v31 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v31, (uint64x2_t)v38), v31, v38);
        v28 += 12;
        v30 -= 4;
      }
      while (v30);
      int8x16_t v39 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v29, (uint64x2_t)v31), v29, v31);
      unint64_t v40 = vextq_s8(v39, v39, 8uLL).u64[0];
      unint64_t v26 = (unint64_t)vbsl_s8((int8x8_t)vcgtd_u64(v39.u64[0], v40), *(int8x8_t *)v39.i8, (int8x8_t)v40);
      if (v23 == v25) {
        goto LABEL_33;
      }
    }
    else
    {
      unint64_t v25 = 0;
      unint64_t v26 = 0;
    }
    unint64_t v41 = v23 - v25;
    uint64_t v42 = (void *)(v21 + 24 * v25 + 24 * v172 + 8);
    do
    {
      if (v26 <= v24 + ((uint64_t)(*v42 - *(v42 - 1)) >> 2)) {
        unint64_t v26 = v24 + ((uint64_t)(*v42 - *(v42 - 1)) >> 2);
      }
      v42 += 3;
      --v41;
    }
    while (v41);
LABEL_33:
    size_t v43 = (void *)a1[43];
    if (!v43) {
LABEL_196:
    }
      sub_19E392294("map::at:  key not found");
    while (1)
    {
      while (1)
      {
        unint64_t v44 = v43[4];
        if (v22 >= v44) {
          break;
        }
        size_t v43 = (void *)*v43;
        if (!v43) {
          goto LABEL_196;
        }
      }
      if (v44 >= v22) {
        break;
      }
      size_t v43 = (void *)v43[1];
      if (!v43) {
        goto LABEL_196;
      }
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v46 = (unsigned char *)v43[5];
    uint64_t v45 = (unsigned char *)v43[6];
    int64_t v47 = v45 - v46;
    if (v45 == v46)
    {
      size_t v56 = (__CFError *)MEMORY[0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      if (v47 < 0) {
        sub_19E37C7C4();
      }
      size_t v48 = (char *)operator new(v45 - v46);
      memcpy(v48, v46, v47);
      size_t v49 = (__CFError **)v48;
      unint64_t v50 = v47 >> 3;
      do
      {
        unint64_t v51 = v50 >> 1;
        size_t v52 = &v49[v50 >> 1];
        unint64_t v54 = (unint64_t)*v52;
        size_t v53 = v52 + 1;
        v50 += ~(v50 >> 1);
        if (v54 < v26) {
          size_t v49 = v53;
        }
        else {
          unint64_t v50 = v51;
        }
      }
      while (v50);
      long long v55 = (__CFError **)&v48[8 * (v47 >> 3)];
      if (v49 == v55) {
        size_t v49 = v55 - 1;
      }
      size_t v56 = *v49;
      operator delete(v48);
      uint64_t v21 = *a2;
      a1 = v186;
    }
    uint64_t v184 = v21 + 24 * v172;
    unint64_t v189 = 0;
    unint64_t v169 = v22 * (void)v56;
    bzero((void *)a1[52], 12 * v22 * (void)v56);
    if (v22 + v172 <= v170) {
      size_t v57 = (void *)v22;
    }
    else {
      size_t v57 = (void *)(v170 - v172);
    }
    v181 = v56;
    unint64_t v185 = (unint64_t)v57;
    if (v57)
    {
      unint64_t v165 = v22;
      uint64_t v58 = 0;
      long long v59 = 0;
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      unint64_t v62 = 0;
      uint64_t v63 = 3 * (void)v56;
      long long v65 = v190;
      uint64_t v64 = v191;
      uint64_t v66 = 12 * (void)v56;
      uint64_t v67 = 60;
      uint64_t v182 = 12 * (void)v56;
      uint64_t v173 = 3 * (void)v56;
      while (1)
      {
        uint64_t v68 = (void *)(v184 + 24 * v62);
        uint64_t v69 = v68 + 1;
        char v70 = (char *)v56 - ((uint64_t)(v68[1] - *v68) >> 2);
        unint64_t v71 = v64 - v65;
        unint64_t v72 = v71 - (void)v70;
        uint64_t v187 = v68 + 1;
        if (v71 > (unint64_t)v70)
        {
          std::string __p = v60;
          long long v73 = v61;
          if (v72 < v71)
          {
            do
            {
              if ((*(uint64_t (**)(void, _DWORD **, unint64_t))(*(void *)a1[26] + 136))(a1[26], &v190, v72 - 1))break; {
              ++v72;
              }
            }
            while (v72 < v191 - v190);
          }
          if (qword_1E945A2E0 != -1) {
            dispatch_once(&qword_1E945A2E0, &unk_1EF0BEEB8);
          }
          long long v74 = qword_1E945A2D8;
          if (os_log_type_enabled((os_log_t)qword_1E945A2D8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 134218496;
            *(void *)&buf[4] = v191 - v190 - v72;
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v191 - v190;
            *(_WORD *)&buf[22] = 2048;
            unint64_t v197 = v72;
            _os_log_impl(&dword_19E36B000, v74, OS_LOG_TYPE_INFO, "limiting forward passes to %ld, with contextLength=%zu and priorContextLength=%zu", buf, 0x20u);
          }
          long long v65 = v190;
          uint64_t v64 = v191;
          unint64_t v71 = v191 - v190 - v72;
          uint64_t v61 = v73;
          uint64_t v68 = (void *)(v184 + 24 * v62);
          uint64_t v69 = v187;
          uint64_t v63 = v173;
          uint64_t v60 = __p;
          uint64_t v66 = v182;
        }
        if (v61 < (unint64_t *)v60)
        {
          *v61++ = v71;
          goto LABEL_86;
        }
        uint64_t v176 = v67;
        __pa = v58;
        char v75 = (char *)((char *)v61 - (char *)v59);
        uint64_t v76 = v61 - v59;
        unint64_t v77 = v76 + 1;
        if ((unint64_t)(v76 + 1) >> 61) {
          sub_19E37C7C4();
        }
        uint64_t v78 = v63;
        if ((v60 - (char *)v59) >> 2 > v77) {
          unint64_t v77 = (v60 - (char *)v59) >> 2;
        }
        if ((unint64_t)(v60 - (char *)v59) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v79 = v77;
        }
        unint64_t v175 = v68;
        if (v79)
        {
          if (v79 >> 61) {
            sub_19E37C2B8();
          }
          uint64_t v80 = v65;
          long long v81 = v64;
          uint64_t v82 = v61;
          unint64_t v83 = v79;
          int64x2_t v84 = operator new(8 * v79);
          uint64_t v61 = v82;
          uint64_t v64 = v81;
          long long v65 = v80;
          unint64_t v79 = v83;
        }
        else
        {
          int64x2_t v84 = 0;
        }
        unint64_t v85 = (unint64_t *)((char *)v84 + 8 * v76);
        *unint64_t v85 = v71;
        unint64_t v86 = v85 + 1;
        if (v61 == v59)
        {
          a1 = v186;
          uint64_t v69 = v187;
          uint64_t v63 = v78;
        }
        else
        {
          unint64_t v87 = (char *)(v61 - 1) - (char *)v59;
          if (v87 < 0x168
            || &v75[(void)v84 - 8 - (v87 & 0xFFFFFFFFFFFFFFF8)] > &v75[(void)v84 - 8]
            || (unint64_t *)((char *)v61 - (v87 & 0xFFFFFFFFFFFFFFF8) - 8) > v61 - 1
            || (unint64_t)((char *)v61 - &v75[(void)v84]) < 0x20)
          {
            unint64_t v88 = v61;
            a1 = v186;
            uint64_t v69 = v187;
            uint64_t v63 = v78;
          }
          else
          {
            uint64_t v118 = (v87 >> 3) + 1;
            unint64_t v88 = &v61[-(v118 & 0x3FFFFFFFFFFFFFFCLL)];
            long long v119 = (char *)v84 + 8 * v76 - 16;
            uint64_t v120 = v61 - 2;
            uint64_t v121 = v118 & 0x3FFFFFFFFFFFFFFCLL;
            a1 = v186;
            do
            {
              long long v122 = *(_OWORD *)v120;
              *(v119 - 1) = *((_OWORD *)v120 - 1);
              *long long v119 = v122;
              v119 -= 2;
              v120 -= 4;
              v121 -= 4;
            }
            while (v121);
            v85 -= v118 & 0x3FFFFFFFFFFFFFFCLL;
            uint64_t v63 = v78;
            uint64_t v69 = v187;
            if (v118 == (v118 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_83;
            }
          }
          do
          {
            unint64_t v89 = *--v88;
            *--unint64_t v85 = v89;
          }
          while (v88 != v59);
        }
LABEL_83:
        uint64_t v60 = (char *)v84 + 8 * v79;
        unint64_t v189 = v85;
        uint64_t v67 = v176;
        if (v59)
        {
          uint64_t v90 = v59;
          uint64_t v91 = v63;
          long long v92 = v60;
          operator delete(v90);
          uint64_t v60 = v92;
          uint64_t v63 = v91;
          long long v65 = v190;
          uint64_t v64 = v191;
        }
        long long v59 = v85;
        uint64_t v61 = v86;
        size_t v56 = v181;
        uint64_t v66 = v182;
        uint64_t v58 = __pa;
        uint64_t v68 = v175;
LABEL_86:
        uint64_t v93 = v63 * v62;
        uint64_t v94 = a1[52];
        if (!v71) {
          goto LABEL_92;
        }
        uint64_t v95 = v94 + 4 * v93;
        *(_DWORD *)(v95 + 8) = 0;
        *(void *)uint64_t v95 = 1065353216;
        unint64_t v96 = v71 - 1;
        if (v71 == 1) {
          goto LABEL_92;
        }
        uint64_t v97 = v64 - v65;
        if (v71 <= 0x10
          || (uint64_t v105 = v66 * v62,
              BOOL v106 = !is_mul_ok(v71 - 2, 0xCuLL),
              uint64_t v107 = 12 * (v71 - 2),
              v94 + v66 * v62 + 20 + v107 < v94 + v66 * v62 + 20)
          || v94 + v105 + 16 + v107 < (unint64_t)(v94 + v105 + 16)
          || v94 + v105 + 12 + v107 < (unint64_t)(v94 + v105 + 12))
        {
          uint64_t v98 = 1;
        }
        else
        {
          uint64_t v98 = 1;
          if (!v106)
          {
            unint64_t v108 = v96 & 0xFFFFFFFFFFFFFFF8;
            v109 = (float *)(v94 + v67);
            int64_t v110 = (uint32x4_t *)&v65[v97 - v71 + 5];
            unint64_t v111 = v96 & 0xFFFFFFFFFFFFFFF8;
            int64x2_t v112 = (int64x2_t)xmmword_19E573190;
            int64x2_t v113 = (int64x2_t)xmmword_19E573180;
            long long v114 = 0u;
            do
            {
              float32x4_t v115 = vcvtq_f32_u32(v110[-1]);
              float32x4_t v116 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)v112)), vcvtq_f64_u64((uint64x2_t)v113));
              v199.val[0] = vcvtq_f32_u32(*v110);
              v199.val[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)vaddq_s64(v112, v167))), vcvtq_f64_u64((uint64x2_t)vaddq_s64(v113, v167)));
              v199.val[2] = 0u;
              v117 = v109 - 12;
              vst3q_f32(v117, *(float32x4x3_t *)(&v114 - 2));
              vst3q_f32(v109, v199);
              int64x2_t v113 = vaddq_s64(v113, v166);
              int64x2_t v112 = vaddq_s64(v112, v166);
              v109 += 24;
              v110 += 2;
              v111 -= 8;
            }
            while (v111);
            if (v96 == v108) {
              goto LABEL_92;
            }
            uint64_t v98 = v108 | 1;
          }
        }
        BOOL v99 = &v65[v97 - v71];
        size_t v100 = (float *)&v58[12 * v98 + v94];
        do
        {
          float *v100 = (float)v99[v98];
          v100[1] = (float)(unint64_t)v98;
          v100[2] = 0.0;
          ++v98;
          v100 += 3;
        }
        while (v71 != v98);
LABEL_92:
        uint64_t v101 = (unsigned int *)*v68;
        uint64_t v102 = (uint64_t)(*v69 - *v68) >> 2;
        if (v71 < v102 + v71)
        {
          uint64_t v103 = (float *)&v58[12 * v71 + v94];
          do
          {
            if (v71) {
              unsigned int v104 = *v101;
            }
            else {
              unsigned int v104 = 1;
            }
            *uint64_t v103 = (float)v104;
            v103[1] = (float)v71;
            v103[2] = 0.0;
            ++v71;
            ++v101;
            v103 += 3;
            --v102;
          }
          while (v102);
        }
        if (*(float *)(v94 + 4 * v93) != 1.0) {
          __assert_rtn("_copyInput", "CoreLMInferenceEngine.cpp", 148, "m_inputs[offset] == kMontrealTokenIDBeginningOfSentence");
        }
        ++v62;
        v67 += v66;
        v58 += v66;
        if (v62 >= v185)
        {
          size_t v57 = v189;
          unint64_t v22 = v165;
          goto LABEL_117;
        }
      }
    }
    uint64_t v61 = 0;
LABEL_117:
    __pb = v57;
    if (v185 != v61 - v57) {
      __assert_rtn("conditionalProbability", "CoreLMInferenceEngine.cpp", 208, "truncatedContextLengths.size() == numInputs");
    }
    v123 = (char *)a1[49];
    if ((uint64_t)(v169 * (void)v56) >= 1) {
      memset_pattern16((void *)a1[49], &unk_19E573250, 4 * (v169 * (void)v56 - (((v169 * (void)v56) & 0x3FFFFFFFFFFFFFFFLL) != 0)) + 4);
    }
    if (v22 && v56)
    {
      for (uint64_t i = 0; i != v22; ++i)
      {
        size_t v125 = 4 * (void)v56;
        v126 = v123;
        uint64_t v127 = v56;
        do
        {
          bzero(v126, v125);
          v126 += 4 * (void)v56 + 4;
          v125 -= 4;
          uint64_t v127 = (__CFError *)((char *)v127 - 1);
        }
        while (v127);
        v123 += 4 * (void)v56 * (void)v56;
      }
    }
    a1 = v186;
    uint64_t v128 = (const void *)v186[52];
    buf[23] = 5;
    strcpy((char *)buf, "input");
    sub_19E4FDAA0((uint64_t)v171, v128, v56, (uint64_t)buf, (__CFError *)3, v22);
    uint64_t v129 = v174;
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    v130 = (const void *)v186[49];
    buf[23] = 7;
    strcpy((char *)buf, "qk_mask");
    sub_19E4FDAA0((uint64_t)v171, v130, v56, (uint64_t)buf, v56, v22);
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
    *(void *)buf = 0;
    sub_19E50A404(v171, 0);
    uint64_t v131 = v186[41];
    if (v131 != v186[25]) {
      goto LABEL_189;
    }
    unint64_t v195 = v131 * v169;
    char v194 = 6;
    strcpy((char *)v193, "output");
    sub_19E43F904((uint64_t)buf, v171, (int *)&v195, (uint64_t)v193);
    if (v194 < 0) {
      operator delete(v193[0]);
    }
    if (v186[41] != v186[25]) {
LABEL_189:
    }
      __assert_rtn("outputSize", "CoreLMInferenceEngine.cpp", 232, "m_coreOutputSize == MontrealInferenceEngine::outputSize()");
    if (v185)
    {
      uint64_t v132 = 0;
      uint64_t v177 = *(void *)&buf[16];
      do
      {
        uint64_t v133 = a1[25];
        if (a1[41] != v133) {
          __assert_rtn("outputSize", "CoreLMInferenceEngine.cpp", 232, "m_coreOutputSize == MontrealInferenceEngine::outputSize()");
        }
        uint64_t v134 = __pb[v132];
        v135 = (uint64_t *)(v184 + 24 * v132);
        memset(buf, 0, sizeof(buf));
        uint64_t v136 = *v135;
        uint64_t v183 = v132;
        if (v135[1] != *v135)
        {
          int64_t v137 = 0;
          unint64_t v138 = 0;
          v139 = 0;
          unint64_t v140 = 0;
          uint64_t v188 = v177 + 4 * v133 * (v134 + v132 * (void)v56 - 1);
          while (1)
          {
            uint64_t v142 = a1[25];
            if (a1[41] != v142) {
              __assert_rtn("outputSize", "CoreLMInferenceEngine.cpp", 232, "m_coreOutputSize == MontrealInferenceEngine::outputSize()");
            }
            unint64_t v143 = *(unsigned int *)(v136 + 4 * v140) + v142 * v140;
            if (v139 >= v138) {
              break;
            }
            *(_DWORD *)v139 = *(_DWORD *)(v188 + 4 * v143);
            uint64_t v141 = (uint64_t)(v139 + 4);
LABEL_142:
            *(void *)&buf[8] = v141;
            ++v140;
            uint64_t v136 = *v135;
            v139 = (char *)v141;
            if (v140 >= (v135[1] - *v135) >> 2) {
              goto LABEL_170;
            }
          }
          uint64_t v144 = (v139 - v137) >> 2;
          unint64_t v145 = v144 + 1;
          if ((unint64_t)(v144 + 1) >> 62) {
            sub_19E37C7C4();
          }
          if ((v138 - v137) >> 1 > v145) {
            unint64_t v145 = (v138 - v137) >> 1;
          }
          if ((unint64_t)(v138 - v137) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v146 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v146 = v145;
          }
          if (v146)
          {
            if (v146 >> 62) {
              sub_19E37C2B8();
            }
            uint64_t v147 = operator new(4 * v146);
          }
          else
          {
            uint64_t v147 = 0;
          }
          v148 = &v147[4 * v144];
          *(_DWORD *)v148 = *(_DWORD *)(v188 + 4 * v143);
          uint64_t v141 = (uint64_t)(v148 + 4);
          if (v139 == v137)
          {
            a1 = v186;
          }
          else
          {
            unint64_t v149 = v139 - 4 - v137;
            if (v149 < 0x2C || (unint64_t)(v137 - v147) < 0x20)
            {
              uint64_t v150 = v139;
              a1 = v186;
              goto LABEL_159;
            }
            uint64_t v152 = (v149 >> 2) + 1;
            uint64_t v150 = &v139[-4 * (v152 & 0x7FFFFFFFFFFFFFF8)];
            v153 = &v147[4 * v144 - 16];
            v154 = v139 - 16;
            uint64_t v155 = v152 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v156 = *(_OWORD *)v154;
              *(v153 - 1) = *((_OWORD *)v154 - 1);
              _OWORD *v153 = v156;
              v153 -= 2;
              v154 -= 32;
              v155 -= 8;
            }
            while (v155);
            v148 -= 4 * (v152 & 0x7FFFFFFFFFFFFFF8);
            a1 = v186;
            if (v152 != (v152 & 0x7FFFFFFFFFFFFFF8))
            {
              do
              {
LABEL_159:
                int v151 = *((_DWORD *)v150 - 1);
                v150 -= 4;
                *((_DWORD *)v148 - 1) = v151;
                v148 -= 4;
              }
              while (v150 != v137);
            }
          }
          unint64_t v138 = &v147[4 * v146];
          *(void *)buf = v148;
          *(void *)&buf[8] = v141;
          *(void *)&buf[16] = v138;
          if (v137) {
            operator delete(v137);
          }
          int64_t v137 = v148;
          goto LABEL_142;
        }
        uint64_t v141 = 0;
LABEL_170:
        uint64_t v129 = v174;
        v157 = (void *)v174[1];
        if ((unint64_t)v157 >= v174[2])
        {
          uint64_t v163 = sub_19E438A94((char **)v174, *(const void **)buf, v141);
          unint64_t v158 = *(void **)buf;
          size_t v56 = v181;
          v174[1] = v163;
          if (!v158) {
            goto LABEL_137;
          }
        }
        else
        {
          void *v157 = 0;
          v157[1] = 0;
          v157[2] = 0;
          unint64_t v158 = *(void **)buf;
          int64_t v160 = v141 - *(void *)buf;
          BOOL v159 = v141 == *(void *)buf;
          size_t v56 = v181;
          if (!v159)
          {
            if (v160 < 0) {
              sub_19E37C7C4();
            }
            v161 = (char *)operator new(v160);
            void *v157 = v161;
            v157[1] = v161;
            uint64_t v162 = &v161[4 * (v160 >> 2)];
            v157[2] = v162;
            memcpy(v161, v158, v160);
            v157[1] = v162;
          }
          v174[1] = v157 + 3;
          v174[1] = v157 + 3;
          if (!v158) {
            goto LABEL_137;
          }
        }
        operator delete(v158);
LABEL_137:
        uint64_t v132 = v183 + 1;
      }
      while (v183 + 1 < v185);
    }
    if (__pb) {
      operator delete(__pb);
    }
    v172 += v185;
  }
  while (v172 < v170);
  unint64_t v164 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v129[1] - *v129) >> 3);
LABEL_182:
  if (v164 != v170) {
    __assert_rtn("conditionalProbability", "CoreLMInferenceEngine.cpp", 226, "conditionalProbabilities.size() == numQueries");
  }
  if (v190)
  {
    uint64_t v191 = v190;
    operator delete(v190);
  }
}

void sub_19E4FD588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  int8x16_t v37 = *(void **)(v35 - 200);
  if (v37)
  {
    *(void *)(v35 - 192) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4FD734(void **a1, unsigned char *a2, char *a3)
{
  uint64_t v3 = a3;
  unint64_t v6 = (unint64_t)*a1;
  unint64_t v5 = (unint64_t)a1[1];
  uint64_t v7 = a2 - (unsigned char *)*a1;
  uint64_t v8 = v7 >> 2;
  unint64_t v9 = (char *)*a1 + (v7 & 0xFFFFFFFFFFFFFFFCLL);
  unint64_t v10 = (unint64_t)a1[2];
  if (v5 < v10)
  {
    if (v9 == (char *)v5)
    {
      *(_DWORD *)unint64_t v9 = *(_DWORD *)a3;
      a1[1] = v9 + 4;
    }
    else
    {
      int64_t v11 = v5 - (void)(v9 + 4);
      uint64_t v12 = v11 >> 2;
      unint64_t v13 = (int *)(v5 - 4);
      if (v5 < 4)
      {
        unint64_t v20 = a1[1];
      }
      else
      {
        unint64_t v14 = (v7 & 0xFFFFFFFFFFFFFFFCLL) + v11;
        double v15 = (char *)(v14 + v6);
        unint64_t v16 = v14 + v6 + 4;
        if (v5 > v16) {
          unint64_t v16 = (unint64_t)a1[1];
        }
        unint64_t v17 = v16 + ~v6 - v14;
        unint64_t v18 = v5 - (void)v15;
        BOOL v19 = v17 >= 0x2C && v18 > 0x1F;
        unint64_t v20 = a1[1];
        if (!v19) {
          goto LABEL_67;
        }
        uint64_t v21 = (v17 >> 2) + 1;
        uint64_t v22 = 4 * (v21 & 0x7FFFFFFFFFFFFFF8);
        unint64_t v13 = (int *)((char *)v13 + v22);
        unint64_t v23 = (_OWORD *)(v5 + 16);
        unint64_t v24 = (long long *)(4 * v12 + 4 * v8 + v6 + 16);
        uint64_t v25 = v21 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v26 = *v24;
          *(v23 - 1) = *(v24 - 1);
          *unint64_t v23 = v26;
          v23 += 2;
          v24 += 2;
          v25 -= 8;
        }
        while (v25);
        unint64_t v20 = (_DWORD *)(v5 + v22);
        if (v21 != (v21 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_67:
          do
          {
            int v27 = *v13++;
            *v20++ = v27;
          }
          while ((unint64_t)v13 < v5);
        }
      }
      a1[1] = v20;
      if ((char *)v5 != v9 + 4) {
        memmove((void *)(v5 - 4 * v12), v9, v11);
      }
      if (v9 <= v3) {
        v3 += 4 * (a1[1] > v3);
      }
      *(_DWORD *)unint64_t v9 = *(_DWORD *)v3;
    }
    return;
  }
  unint64_t v28 = ((uint64_t)(v5 - v6) >> 2) + 1;
  if (v28 >> 62) {
    sub_19E37C7C4();
  }
  uint64_t v30 = v10 - v6;
  if (v30 >> 1 > v28) {
    unint64_t v28 = v30 >> 1;
  }
  if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFFCLL) {
    unint64_t v31 = 0x3FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v31 = v28;
  }
  if (v31)
  {
    if (v31 >> 62) {
      sub_19E37C2B8();
    }
    int64x2_t v32 = (char *)operator new(4 * v31);
  }
  else
  {
    int64x2_t v32 = 0;
  }
  int64x2_t v33 = &v32[4 * v8];
  int64x2_t v34 = &v32[4 * v31];
  if (v8 != v31) {
    goto LABEL_32;
  }
  if (v7 >= 1)
  {
    unint64_t v35 = v8 + 2;
    if (v8 >= -1) {
      unint64_t v35 = v8 + 1;
    }
    v33 -= 4 * (v35 >> 1);
LABEL_32:
    int64x2_t v36 = (char *)v6;
    goto LABEL_33;
  }
  if ((unsigned char *)v6 == a2) {
    unint64_t v46 = 1;
  }
  else {
    unint64_t v46 = v7 >> 1;
  }
  if (v46 >> 62) {
    sub_19E37C2B8();
  }
  int64x2_t v33 = (char *)operator new(4 * v46);
  int64x2_t v34 = &v33[4 * v46];
  if (!v32) {
    goto LABEL_32;
  }
  operator delete(v32);
  int64x2_t v34 = &v33[4 * v46];
  int64x2_t v36 = (char *)*a1;
LABEL_33:
  *(_DWORD *)int64x2_t v33 = *(_DWORD *)v3;
  int8x16_t v37 = v33 + 4;
  if (v36 != v9)
  {
    int8x16_t v38 = (char *)((v7 & 0xFFFFFFFFFFFFFFFCLL) + v6);
    unint64_t v39 = v38 - v36 - 4;
    if (v39 < 0x2C)
    {
      unint64_t v41 = v9;
    }
    else if ((unint64_t)(v38 - v33) < 0x20)
    {
      unint64_t v41 = v9;
    }
    else
    {
      uint64_t v40 = (v39 >> 2) + 1;
      unint64_t v41 = &v9[-4 * (v40 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v42 = v33 - 16;
      size_t v43 = (long long *)(v6 + 4 * v8 - 16);
      uint64_t v44 = v40 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v45 = *v43;
        *((_OWORD *)v42 - 1) = *(v43 - 1);
        *(_OWORD *)uint64_t v42 = v45;
        v42 -= 32;
        v43 -= 2;
        v44 -= 8;
      }
      while (v44);
      v33 -= 4 * (v40 & 0x7FFFFFFFFFFFFFF8);
      if (v40 == (v40 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_55;
      }
    }
    do
    {
      int v47 = *((_DWORD *)v41 - 1);
      v41 -= 4;
      *((_DWORD *)v33 - 1) = v47;
      v33 -= 4;
    }
    while (v41 != v36);
  }
LABEL_55:
  size_t v48 = (char *)a1[1];
  int64_t v49 = v48 - v9;
  if (v48 != v9)
  {
    unint64_t v50 = v9;
    size_t v51 = v48 - v9;
    size_t v52 = v34;
    memmove(v37, v50, v51);
    int64x2_t v34 = v52;
    int64x2_t v36 = (char *)*a1;
  }
  *a1 = v33;
  a1[1] = &v37[v49];
  a1[2] = v34;
  if (v36)
  {
    operator delete(v36);
  }
}

void sub_19E4FDA88(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E4FDAA0(uint64_t a1, const void *a2, __CFError *a3, uint64_t a4, __CFError *a5, uint64_t a6)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(void *)(a1 + 16);
  if (v12 != v13)
  {
    char v14 = *(unsigned char *)(a4 + 23);
    if (v14 >= 0) {
      uint64_t v15 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      uint64_t v15 = *(void *)(a4 + 8);
    }
    if (v14 >= 0) {
      unint64_t v16 = (unsigned __int8 *)a4;
    }
    else {
      unint64_t v16 = *(unsigned __int8 **)a4;
    }
    while (1)
    {
      uint64_t v17 = *(unsigned __int8 *)(v12 + 23);
      if ((v17 & 0x80u) == 0) {
        uint64_t v18 = *(unsigned __int8 *)(v12 + 23);
      }
      else {
        uint64_t v18 = *(void *)(v12 + 8);
      }
      if (v18 == v15)
      {
        if ((v17 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v12, v16, *(void *)(v12 + 8))) {
            break;
          }
        }
        else
        {
          if (!*(unsigned char *)(v12 + 23)) {
            break;
          }
          uint64_t v19 = 0;
          while (*(unsigned __int8 *)(v12 + v19) == v16[v19])
          {
            if (v17 == ++v19) {
              goto LABEL_19;
            }
          }
        }
      }
      v12 += 24;
      if (v12 == v13) {
        goto LABEL_71;
      }
    }
  }
LABEL_19:
  if (v12 == v13)
  {
LABEL_71:
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    uint64_t v42 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a4 + 23) >= 0) {
        size_t v43 = (unsigned __int8 *)a4;
      }
      else {
        size_t v43 = *(unsigned __int8 **)a4;
      }
      *(_DWORD *)size_t v53 = 136315138;
      *(void *)&v53[4] = v43;
      _os_log_error_impl(&dword_19E36B000, v42, OS_LOG_TYPE_ERROR, "%s() not found as neural network input", v53, 0xCu);
    }
    __assert_rtn("setInputTensorANE", "NeuralNetwork.hpp", 204, "false");
  }
  unint64_t v20 = (uint64_t *)((void)a5 * (void)a3 * a6);
  sub_19E43FE94(a1, a2, v20, (const void **)a4);
  uint64_t v21 = sub_19E43FF80((uint64_t **)(a1 + 56), (const void **)a4, a4)[7];
  sub_19E440758((CFStringRef *)v53, "ShapeDimension");
  LODWORD(valuePtr) = 5;
  *(void *)&v53[8] = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!*(void *)&v53[8])
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E440758((CFStringRef *)&v53[16], "Width");
  valuePtr = a5;
  CFTypeRef v54 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  if (!v54)
  {
    long long v45 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v45, "Could not construct");
    __cxa_throw(v45, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E440758((CFStringRef *)&v55, "Height");
  LODWORD(valuePtr) = 1;
  CFTypeRef v56 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
  if (!v56)
  {
    unint64_t v46 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v46, "Could not construct");
    __cxa_throw(v46, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  sub_19E440758((CFStringRef *)&v57, "Channel");
  valuePtr = a3;
  CFTypeRef cf = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
  if (!cf)
  {
    int v47 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v47, "Could not construct");
    __cxa_throw(v47, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFDictionaryRef v22 = sub_19E411038((uint64_t *)v53, 4uLL);
  size_t v48 = v22;
  if (cf) {
    CFRelease(cf);
  }
  if (v57) {
    CFRelease(v57);
  }
  if (v56) {
    CFRelease(v56);
  }
  if (v55) {
    CFRelease(v55);
  }
  if (v54) {
    CFRelease(v54);
  }
  if (*(void *)&v53[16]) {
    CFRelease(*(CFTypeRef *)&v53[16]);
  }
  if (*(void *)&v53[8]) {
    CFRelease(*(CFTypeRef *)&v53[8]);
  }
  if (*(void *)v53) {
    CFRelease(*(CFTypeRef *)v53);
  }
  valuePtr = 0;
  p_valuePtr = &valuePtr;
  uint64_t v51 = 0x2000000000;
  unint64_t v23 = (__CFError *)off_1E945A2F0;
  size_t v52 = off_1E945A2F0;
  if (!off_1E945A2F0)
  {
    *(void *)size_t v53 = MEMORY[0x1E4F143A8];
    *(void *)&v53[8] = 0x40000000;
    *(void *)&v53[16] = sub_19E4FE804;
    CFTypeRef v54 = &unk_1E59A19C0;
    CFTypeRef v55 = &valuePtr;
    sub_19E4FE804((uint64_t)v53);
    unint64_t v23 = p_valuePtr[3];
  }
  _Block_object_dispose(&valuePtr, 8);
  if (!v23) {
    goto LABEL_81;
  }
  uint64_t v24 = ((uint64_t (*)(CFDictionaryRef))v23)(v22);
  CFRelease(v22);
  uint64_t v25 = (uint64_t **)(a1 + 80);
  long long v26 = sub_19E440108((uint64_t **)(a1 + 80), (const void **)a4, a4);
  int v27 = v26[7];
  if (v27) {
    CFRelease(v27);
  }
  v26[7] = (uint64_t *)v24;
  unint64_t v28 = sub_19E440108((uint64_t **)(a1 + 80), (const void **)a4, a4)[7];
  valuePtr = 0;
  p_valuePtr = &valuePtr;
  uint64_t v51 = 0x2000000000;
  int8x16_t v29 = (__CFError *)off_1E945A2F8;
  size_t v52 = off_1E945A2F8;
  if (!off_1E945A2F8)
  {
    *(void *)size_t v53 = MEMORY[0x1E4F143A8];
    *(void *)&v53[8] = 0x40000000;
    *(void *)&v53[16] = sub_19E4FE510;
    CFTypeRef v54 = &unk_1E59A19E8;
    CFTypeRef v55 = &valuePtr;
    sub_19E4FE510((uint64_t)v53);
    int8x16_t v29 = p_valuePtr[3];
  }
  _Block_object_dispose(&valuePtr, 8);
  if (!v29) {
    goto LABEL_81;
  }
  ((void (*)(uint64_t *, uint64_t *, uint64_t))v29)(v28, v21, 4 * (void)v20);
  size_t v48 = 0;
  uint64_t v30 = *(void *)a1;
  char v31 = *(unsigned char *)(a4 + 23);
  int64x2_t v32 = v31 >= 0 ? (const UInt8 *)a4 : *(const UInt8 **)a4;
  if (v32)
  {
    if (v31 >= 0) {
      CFIndex v33 = *(unsigned __int8 *)(a4 + 23);
    }
    else {
      CFIndex v33 = *(void *)(a4 + 8);
    }
    CFStringRef v34 = CFStringCreateWithBytes(0, v32, v33, 0x8000100u, 0);
    if (!v34)
    {
      unint64_t v35 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v35, "Could not construct");
      __cxa_throw(v35, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v34 = 0;
  }
  int64x2_t v36 = sub_19E440108(v25, (const void **)a4, a4)[7];
  valuePtr = 0;
  p_valuePtr = &valuePtr;
  uint64_t v51 = 0x2000000000;
  int8x16_t v37 = (__CFError *)off_1E945A300;
  size_t v52 = off_1E945A300;
  if (!off_1E945A300)
  {
    *(void *)size_t v53 = MEMORY[0x1E4F143A8];
    *(void *)&v53[8] = 0x40000000;
    *(void *)&v53[16] = sub_19E4FE650;
    CFTypeRef v54 = &unk_1E59A1A10;
    CFTypeRef v55 = &valuePtr;
    sub_19E4FE650((uint64_t)v53);
    int8x16_t v37 = p_valuePtr[3];
  }
  _Block_object_dispose(&valuePtr, 8);
  if (!v37)
  {
LABEL_81:
    dlerror();
    abort_report_np();
    __break(1u);
  }
  ((void (*)(uint64_t, CFStringRef, uint64_t *, __CFError **))v37)(v30, v34, v36, &v48);
  if (v34) {
    CFRelease(v34);
  }
  int8x16_t v38 = v48;
  if (v48)
  {
    unint64_t v39 = (char *)operator new(0x20uLL);
    strcpy(v39, "MRLNeuralNetworkSetInputTensor");
    valuePtr = v38;
    CFStringRef v40 = CFErrorCopyDescription(v38);
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    unint64_t v41 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)size_t v53 = 136315394;
      *(void *)&v53[4] = v39;
      *(_WORD *)&v53[12] = 2112;
      *(void *)&v53[14] = v40;
      _os_log_error_impl(&dword_19E36B000, v41, OS_LOG_TYPE_ERROR, "%s() failed: %@", v53, 0x16u);
      if (!v40) {
        goto LABEL_69;
      }
    }
    else if (!v40)
    {
LABEL_69:
      CFRelease(v38);
      operator delete(v39);
      return;
    }
    CFRelease(v40);
    goto LABEL_69;
  }
}

void sub_19E4FE2DC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E4FE2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, const void *a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,CFTypeRef a23,uint64_t a24,CFTypeRef a25,uint64_t a26,CFTypeRef a27,uint64_t a28,CFTypeRef cf)
{
}

void *sub_19E4FE510(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E945A2E8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4FE790;
    v5[4] = &unk_1E59A1998;
    v5[5] = v5;
    long long v6 = xmmword_1E59A1980;
    uint64_t v7 = 0;
    qword_1E945A2E8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E945A2E8;
    if (qword_1E945A2E8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E945A2E8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkTensorAppendData");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E945A2F8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E4FE650(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E945A2E8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4FE790;
    v5[4] = &unk_1E59A1998;
    v5[5] = v5;
    long long v6 = xmmword_1E59A1980;
    uint64_t v7 = 0;
    qword_1E945A2E8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E945A2E8;
    if (qword_1E945A2E8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E945A2E8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkSetInputTensor");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E945A300 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E4FE790()
{
  uint64_t result = _sl_dlopen();
  qword_1E945A2E8 = result;
  return result;
}

void *sub_19E4FE804(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E945A2E8)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E4FE790;
    v5[4] = &unk_1E59A1998;
    v5[5] = v5;
    long long v6 = xmmword_1E59A1980;
    uint64_t v7 = 0;
    qword_1E945A2E8 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E945A2E8;
    if (qword_1E945A2E8)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E945A2E8;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkTensorCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1E945A2F0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

os_log_t sub_19E4FE944()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "CoreLMInferenceEngine");
  qword_1E945A2D8 = (uint64_t)result;
  return result;
}

void sub_19E4FE974(uint64_t a1)
{
  sub_19E50A8CC((uint64_t *)(a1 + 16));
  sub_19E50A8CC((uint64_t *)(a1 + 224));
}

uint64_t sub_19E4FE9B0(uint64_t a1)
{
  uint64_t result = sub_19E43DFE4((uint64_t *)(a1 + 224));
  if (result)
  {
    return sub_19E43DFE4((uint64_t *)(a1 + 16));
  }
  return result;
}

uint64_t sub_19E4FE9FC(uint64_t a1)
{
  uint64_t result = sub_19E377E48((uint64_t *)(a1 + 224));
  if (result)
  {
    return sub_19E377E48((uint64_t *)(a1 + 16));
  }
  return result;
}

uint64_t sub_19E4FEA48(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 328);
  if (result != *(void *)(a1 + 200)) {
    __assert_rtn("outputSize", "CoreLMInferenceEngine.cpp", 232, "m_coreOutputSize == MontrealInferenceEngine::outputSize()");
  }
  return result;
}

void sub_19E4FEA90(uint64_t a1)
{
  sub_19E4FEAC8(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E4FEAC8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB228;
  uint64_t v2 = *(void **)(a1 + 416);
  if (v2)
  {
    *(void *)(a1 + 424) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)(a1 + 392);
  if (v3)
  {
    *(void *)(a1 + 400) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)(a1 + 360);
  if (v4)
  {
    *(void *)(a1 + 368) = v4;
    operator delete(v4);
  }
  sub_19E4881A0(*(void **)(a1 + 344));
  sub_19E440D2C(a1 + 224);
  unint64_t v5 = *(std::__shared_weak_count **)(a1 + 216);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *(void *)a1 = &unk_1EF0BB750;
  if ((*(char *)(a1 + 191) & 0x80000000) == 0)
  {
    if ((*(char *)(a1 + 167) & 0x80000000) == 0) {
      goto LABEL_12;
    }
LABEL_15:
    operator delete(*(void **)(a1 + 144));
    if ((*(char *)(a1 + 143) & 0x80000000) == 0) {
      goto LABEL_13;
    }
LABEL_16:
    operator delete(*(void **)(a1 + 120));
    goto LABEL_13;
  }
  operator delete(*(void **)(a1 + 168));
  if (*(char *)(a1 + 167) < 0) {
    goto LABEL_15;
  }
LABEL_12:
  if (*(char *)(a1 + 143) < 0) {
    goto LABEL_16;
  }
LABEL_13:
  sub_19E440D2C(a1 + 16);
  return a1;
}

void sub_19E4FEBFC(uint64_t a1)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v3 = a1 + 8 * i;
    uint64_t v6 = *(void *)(v3 + 16);
    unint64_t v5 = (void *)(v3 + 16);
    uint64_t v4 = v6;
    uint64_t v7 = v6 & 3;
    if (v7 == 2)
    {
      uint64_t v8 = (void *)(v4 & 0xFFFFFFFFFFFFFFFCLL);
      do
      {
        unint64_t v9 = (void *)*v8;
        free(v8);
        uint64_t v8 = v9;
      }
      while (v9);
    }
    else if (v7 == 1)
    {
      sub_19E4FEBFC(v4 & 0xFFFFFFFFFFFFFFFCLL);
      free((void *)(*v5 & 0xFFFFFFFFFFFFFFFCLL));
    }
  }
}

void sub_19E4FEC84(uint64_t a1, unsigned __int32 *a2, __n128 a3)
{
  if (a2) {
    uint64_t v4 = (uint64_t)(a2 + 5);
  }
  else {
    uint64_t v4 = 0;
  }
  if (a2)
  {
    uint64_t v5 = a2[4];
    uint64_t v6 = a2[2];
    a3.n128_u32[0] = *a2;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
    a3.n128_u64[0] = 0;
  }
  if (!*(void *)(a1 + 2084))
  {
    v9[0] = 0;
    v9[1] = 0;
    int v8 = 0;
    if (v6)
    {
      if ((v5 - 1) <= 0x3FE)
      {
        int v7 = 0;
        sub_19E4FED3C(a1, a1, v4, v5, 0, v6, (float *)&v7, &v8, a3, v9);
        if (v8 == 2) {
          ++*(_DWORD *)(a1 + 2064);
        }
      }
    }
  }
}

void sub_19E4FED3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, float *a7, int *a8, __n128 a9, void *a10)
{
  float v12 = a9.n128_f32[0];
  int v13 = a6;
  int v14 = a4;
  if (a5 >= a4)
  {
    *a8 = 1;
    float v20 = *(float *)(a2 + 8);
    if (v20 == 0.0) {
      *a8 = 2;
    }
    float v21 = v20 + v12;
    *(_DWORD *)(a2 + 12) = a6;
    *(float *)(a2 + 4) = v21;
    *(float *)(a2 + 8) = v21;
    if (a10)
    {
      CFDictionaryRef v22 = (float (*)(void, uint64_t, uint64_t))a10[1];
      if (v22) {
        float v21 = v22(*a10, a4, a6);
      }
    }
    *(float *)(a2 + 4) = v21;
    *a7 = v21;
  }
  else
  {
    uint64_t v18 = (unsigned __int8 *)(a3 + a5);
    uint64_t v19 = *(void *)(a2 + 8 * *v18 + 16);
    if ((v19 & 3) == 2)
    {
      unint64_t v28 = v19 & 0xFFFFFFFFFFFFFFFCLL;
      if (sub_19E4FEF68(a1, (uint64_t *)&v28, a3, a4, a5 + 1, a6, a7, a8, a9.n128_f32[0], a10) >= *(_DWORD *)(a1 + 2092)) {
        unint64_t v23 = (unint64_t)sub_19E4FF4E0(a1, (unsigned __int16 *)v28, a7, a10) | 1;
      }
      else {
        unint64_t v23 = v28 | 2;
      }
    }
    else
    {
      if ((v19 & 3) == 1)
      {
        sub_19E4FED3C(a1, v19 & 0xFFFFFFFFFFFFFFFCLL, a9);
        goto LABEL_19;
      }
      float v24 = a9.n128_f32[0];
      if (a10)
      {
        uint64_t v25 = (float (*)(void, uint64_t, uint64_t, __n128))a10[1];
        float v24 = a9.n128_f32[0];
        if (v25) {
          float v24 = v25(*a10, a4, a6, a9);
        }
      }
      *a7 = v24;
      size_t v26 = ~a5 + v14;
      unint64_t v27 = (unint64_t)malloc_type_calloc(1uLL, v26 + 27, 0xBAFAEA8FuLL);
      memcpy((void *)(v27 + 26), v18 + 1, v26);
      *(unsigned char *)(v27 + 26 + v26) = 0;
      *(_WORD *)(v27 + 24) = v26;
      *(_DWORD *)(v27 + 20) = v13;
      *(float *)(v27 + 12) = v24;
      *(float *)(v27 + 16) = v12;
      *(float *)(v27 + 8) = v24;
      *(void *)unint64_t v27 = 0;
      unint64_t v23 = v27 | 2;
      *a8 = 2;
    }
    *(void *)(a2 + 8 * *v18 + 16) = v23;
  }
LABEL_19:
  if (*a7 > *(float *)a2) {
    *(float *)a2 = *a7;
  }
}

unint64_t sub_19E4FEF68(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, _DWORD *a7, int *a8, float a9, void *a10)
{
  uint64_t v14 = *a2;
  int v15 = *(_DWORD *)(a1 + 2092);
  uint64_t v16 = (v15 + 1);
  if (v15 == -1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
  }
  else
  {
    uint64_t v19 = (int8x16_t *)operator new(8 * v16);
    uint64_t v18 = (int8x16_t *)((char *)v19 + 8 * v16);
    uint64_t v17 = v19;
  }
  float v20 = a10;
  __s1 = (void *)(a3 + a5);
  if (!v14)
  {
    unint64_t v39 = v17;
    float v40 = a9;
    if (!a10) {
      goto LABEL_49;
    }
LABEL_47:
    unint64_t v41 = (float (*)(void, uint64_t, void, float))v20[1];
    float v40 = a9;
    if (v41) {
      float v40 = v41(*v20, a4, a6, a9);
    }
LABEL_49:
    size_t v42 = a4 - a5;
    size_t v43 = (char *)malloc_type_calloc(1uLL, v42 + 27, 0xBAFAEA8FuLL);
    memcpy(v43 + 26, __s1, v42);
    v43[v42 + 26] = 0;
    *((_WORD *)v43 + 12) = v42;
    *((_DWORD *)v43 + 5) = a6;
    *((float *)v43 + 3) = v40;
    *((float *)v43 + 4) = a9;
    *((float *)v43 + 2) = v40;
    *(void *)size_t v43 = 0;
    if (v39 < v18)
    {
      v39->i64[0] = (uint64_t)v43;
      int v44 = 2;
      float v21 = (int8x16_t *)&v39->u64[1];
      goto LABEL_73;
    }
    uint64_t v45 = ((char *)v39 - (char *)v17) >> 3;
    unint64_t v46 = v45 + 1;
    if ((unint64_t)(v45 + 1) >> 61) {
      sub_19E37C7C4();
    }
    if (((char *)v18 - (char *)v17) >> 2 > v46) {
      unint64_t v46 = ((char *)v18 - (char *)v17) >> 2;
    }
    if ((unint64_t)((char *)v18 - (char *)v17) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v46)
    {
      if (v46 >> 61) {
        sub_19E37C2B8();
      }
      int v47 = operator new(8 * v46);
    }
    else
    {
      int v47 = 0;
    }
    size_t v48 = &v47[8 * v45];
    *size_t v48 = v43;
    float v21 = (int8x16_t *)(v48 + 1);
    if (v39 == v17) {
      goto LABEL_70;
    }
    unint64_t v49 = (char *)v39 - (char *)v17 - 8;
    if (v49 >= 0x58)
    {
      if ((unint64_t)((char *)v17 - v47) >= 0x20)
      {
        uint64_t v51 = (v49 >> 3) + 1;
        unint64_t v50 = (int8x16_t *)((char *)v39 - 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL));
        size_t v52 = (int8x16_t *)&v47[8 * v45 - 16];
        size_t v53 = v39 - 1;
        uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          int8x16_t v55 = *v53;
          v52[-1] = v53[-1];
          *size_t v52 = v55;
          v52 -= 2;
          v53 -= 2;
          v54 -= 4;
        }
        while (v54);
        v48 -= v51 & 0x3FFFFFFFFFFFFFFCLL;
        if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_70;
        }
      }
      else
      {
        unint64_t v50 = v39;
      }
    }
    else
    {
      unint64_t v50 = v39;
    }
    do
    {
      uint64_t v56 = v50[-1].i64[1];
      unint64_t v50 = (int8x16_t *)((char *)v50 - 8);
      *--size_t v48 = v56;
    }
    while (v50 != v17);
LABEL_70:
    if (v17) {
      operator delete(v17);
    }
    int v44 = 2;
    uint64_t v17 = (int8x16_t *)v48;
    goto LABEL_73;
  }
  int v72 = 2;
  float v21 = v17;
  do
  {
    while (1)
    {
      size_t v22 = *(unsigned __int16 *)(v14 + 24);
      if (v22 + a5 == a4 && !memcmp(__s1, (const void *)(v14 + 26), v22)) {
        break;
      }
      if (v21 >= v18) {
        goto LABEL_10;
      }
LABEL_6:
      v21->i64[0] = v14;
      float v21 = (int8x16_t *)((char *)v21 + 8);
      uint64_t v14 = *(void *)v14;
      if (!v14) {
        goto LABEL_43;
      }
    }
    *(_DWORD *)(v14 + 20) = a6;
    float v27 = *(float *)(v14 + 16) + a9;
    *(float *)(v14 + 12) = v27;
    *(float *)(v14 + 16) = v27;
    if (a10)
    {
      unint64_t v28 = (float (*)(void, uint64_t, void))a10[1];
      if (v28) {
        float v27 = v28(*a10, a4, a6);
      }
    }
    *(float *)(v14 + 12) = v27;
    int v72 = 1;
    if (v21 < v18) {
      goto LABEL_6;
    }
LABEL_10:
    uint64_t v23 = ((char *)v21 - (char *)v17) >> 3;
    unint64_t v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) >> 61) {
      sub_19E37C7C4();
    }
    if (((char *)v18 - (char *)v17) >> 2 > v24) {
      unint64_t v24 = ((char *)v18 - (char *)v17) >> 2;
    }
    if ((unint64_t)((char *)v18 - (char *)v17) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v25 = v24;
    }
    if (v25)
    {
      if (v25 >> 61) {
        sub_19E37C2B8();
      }
      size_t v26 = operator new(8 * v25);
    }
    else
    {
      size_t v26 = 0;
    }
    int8x16_t v29 = (uint64_t *)&v26[8 * v23];
    uint64_t *v29 = v14;
    uint64_t v30 = (int8x16_t *)(v29 + 1);
    if (v21 != v17)
    {
      unint64_t v31 = (char *)&v21[-1].u64[1] - (char *)v17;
      if (v31 < 0x168)
      {
        int64x2_t v32 = v21;
        goto LABEL_28;
      }
      if (&v26[(char *)v21 - (char *)v17 - 8 - (v31 & 0xFFFFFFFFFFFFFFF8)] > &v26[(char *)v21 - (char *)v17 - 8])
      {
        int64x2_t v32 = v21;
        do
        {
LABEL_28:
          uint64_t v33 = v32[-1].i64[1];
          int64x2_t v32 = (int8x16_t *)((char *)v32 - 8);
          *--int8x16_t v29 = v33;
        }
        while (v32 != v17);
        goto LABEL_29;
      }
      if ((unint64_t *)((char *)&v21[-1].u64[1] - (v31 & 0xFFFFFFFFFFFFFFF8)) > &v21[-1].u64[1])
      {
        int64x2_t v32 = v21;
        goto LABEL_28;
      }
      if ((unint64_t)((char *)v17 - v26) < 0x20)
      {
        int64x2_t v32 = v21;
        goto LABEL_28;
      }
      uint64_t v34 = (v31 >> 3) + 1;
      int64x2_t v32 = (int8x16_t *)((char *)v21 - 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL));
      unint64_t v35 = (int8x16_t *)&v26[8 * v23 - 16];
      int64x2_t v36 = v21 - 1;
      uint64_t v37 = v34 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        int8x16_t v38 = *v36;
        v35[-1] = v36[-1];
        *unint64_t v35 = v38;
        v35 -= 2;
        v36 -= 2;
        v37 -= 4;
      }
      while (v37);
      v29 -= v34 & 0x3FFFFFFFFFFFFFFCLL;
      if (v34 != (v34 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_28;
      }
    }
LABEL_29:
    uint64_t v18 = (int8x16_t *)&v26[8 * v25];
    if (v17) {
      operator delete(v17);
    }
    uint64_t v17 = (int8x16_t *)v29;
    float v21 = v30;
    uint64_t v14 = *(void *)v14;
  }
  while (v14);
LABEL_43:
  if (v72 == 2)
  {
    unint64_t v39 = v21;
    float v20 = a10;
    float v40 = a9;
    if (!a10) {
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  int v44 = 1;
LABEL_73:
  unint64_t v57 = ((char *)v21 - (char *)v17) >> 3;
  unint64_t v58 = 126 - 2 * __clz(v57);
  unint64_t v59 = (char *)v21 - (char *)v17;
  char v75 = sub_19E500690;
  if (v21 == v17) {
    uint64_t v60 = 0;
  }
  else {
    uint64_t v60 = v58;
  }
  sub_19E4FF6A0((uint64_t)v17, v21, (unsigned int (**)(uint64_t))&v75, v60, 1);
  uint64_t v61 = (void *)v17->i64[0];
  *a7 = *(_DWORD *)(v17->i64[0] + 12);
  unint64_t v62 = v61;
  if (v59 != 8)
  {
    uint64_t v63 = v57 - 1;
    if (v57 - 1 <= 1) {
      uint64_t v63 = 1;
    }
    uint64_t v64 = &v17->i64[1];
    long long v65 = v61;
    do
    {
      uint64_t v66 = *v64++;
      unint64_t v62 = (void *)v66;
      *long long v65 = v66;
      *(_DWORD *)(v66 + 8) = *a7;
      long long v65 = (void *)v66;
      --v63;
    }
    while (v63);
  }
  *unint64_t v62 = 0;
  *a2 = (uint64_t)v61;
  if (a8) {
    *a8 = v44;
  }
  if (v57 > *(unsigned int *)(a1 + 2092)) {
    __assert_rtn("completionTrieAddListNode", "LMCompletionTrie.cpp", 458, "nodes.size() <= trie->reserved[CONTAINER_SIZE]");
  }
  operator delete(v17);
  return v59 >> 3;
}

void sub_19E4FF4B4(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

float *sub_19E4FF4E0(uint64_t a1, unsigned __int16 *a2, float *a3, void *a4)
{
  int v8 = (float *)malloc_type_calloc(1uLL, 0x810uLL, 0x1000040A9A4BCADuLL);
  *a3 = 0.0;
  if (a2)
  {
    do
    {
      float v22 = 0.0;
      uint64_t v11 = a2[12];
      unsigned int v12 = *((_DWORD *)a2 + 5);
      float v14 = *((float *)a2 + 3);
      float v13 = *((float *)a2 + 4);
      if (a2[12])
      {
        uint64_t v15 = *(void *)&v8[2 * *((unsigned __int8 *)a2 + 26) + 4];
        if (v15)
        {
          unint64_t v23 = v15 & 0xFFFFFFFFFFFFFFFCLL;
          unsigned int v16 = sub_19E4FEF68(a1, (uint64_t *)&v23, (uint64_t)(a2 + 13), v11, 1u, v12, &v22, 0, v13, a4);
          uint64_t v17 = v23;
          if (v16 >= *(_DWORD *)(a1 + 2092))
          {
            uint64_t v17 = sub_19E4FF4E0(a1, v23, &v22, a4);
            uint64_t v18 = 1;
          }
          else
          {
            uint64_t v18 = 2;
          }
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 26) + 4] = v18 | v17;
          float v14 = v22;
        }
        else
        {
          size_t v19 = (v11 - 1);
          unint64_t v20 = (unint64_t)malloc_type_calloc(1uLL, v19 + 27, 0xBAFAEA8FuLL);
          memcpy((void *)(v20 + 26), (char *)a2 + 27, v19);
          *(unsigned char *)(v20 + 26 + v19) = 0;
          *(_WORD *)(v20 + 24) = v19;
          *(_DWORD *)(v20 + 20) = v12;
          *(float *)(v20 + 12) = v14;
          *(float *)(v20 + 16) = v13;
          *(float *)(v20 + 8) = v14;
          *(void *)unint64_t v20 = 0;
          *(void *)&v8[2 * *((unsigned __int8 *)a2 + 26) + 4] = v20 | 2;
        }
      }
      else
      {
        v8[1] = v14;
        v8[2] = v13;
        *((_DWORD *)v8 + 3) = v12;
      }
      *a3 = fmaxf(v14, *a3);
      unint64_t v10 = *(unsigned __int16 **)a2;
      free(a2);
      a2 = v10;
    }
    while (v10);
    float v9 = *a3;
  }
  else
  {
    float v9 = 0.0;
  }
  *int v8 = v9;
  return v8;
}

uint64_t sub_19E4FF6A0(uint64_t result, int8x16_t *a2, unsigned int (**a3)(uint64_t), uint64_t a4, char a5)
{
  float v9 = (int8x16_t *)result;
  while (2)
  {
    unint64_t v10 = a2;
    uint64_t v11 = &a2[-1].i64[1];
    unsigned int v12 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          float v9 = v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          uint64_t v14 = ((char *)v10 - (char *)v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v77 = v12->i64[0];
                v12->i64[0] = *v11;
                goto LABEL_169;
              case 3:
                char v78 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[1]);
                if (v78)
                {
                  uint64_t v79 = v12->i64[0];
                  if (result)
                  {
                    v12->i64[0] = *v11;
                    *uint64_t v11 = v79;
                  }
                  else
                  {
                    v12->i64[0] = v12->i64[1];
                    v12->i64[1] = v79;
                    uint64_t result = ((uint64_t (*)(uint64_t))*a3)(*v11);
                    if (result)
                    {
                      uint64_t v77 = v12->i64[1];
                      v12->i64[1] = *v11;
LABEL_169:
                      *uint64_t v11 = v77;
                    }
                  }
                }
                else if (result)
                {
                  uint64_t v105 = v12->i64[1];
                  v12->i64[1] = *v11;
                  *uint64_t v11 = v105;
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
LABEL_143:
                  if (result) {
                    *unsigned int v12 = vextq_s8(*v12, *v12, 8uLL);
                  }
                }
                break;
              case 4:
                return sub_19E500208(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, v11, a3);
              case 5:
                uint64_t v80 = v12 + 1;
                long long v81 = &v12[1].i64[1];
                sub_19E500208(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, &v12[1].i64[1], a3);
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12[1].i64[1]);
                if (!result) {
                  return result;
                }
                uint64_t v82 = *v81;
                uint64_t *v81 = *v11;
                *uint64_t v11 = v82;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v81, v80->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v83 = v80->i64[0];
                v80->i64[0] = *v81;
                uint64_t *v81 = v83;
                uint64_t result = ((uint64_t (*)(void))*a3)();
                if (!result) {
                  return result;
                }
                uint64_t v85 = v12->i64[1];
                uint64_t v84 = v12[1].i64[0];
                uint64_t v86 = v12->i64[0];
                v12->i64[1] = v84;
                v12[1].i64[0] = v85;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v84, v86);
                goto LABEL_143;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            unint64_t v87 = &v12->i64[1];
            BOOL v89 = v12 == v10 || v87 == (uint64_t *)v10;
            if (a5)
            {
              if (!v89)
              {
                uint64_t v90 = 0;
                uint64_t v91 = (uint64_t *)v12;
                do
                {
                  uint64_t v94 = *v91;
                  uint64_t v93 = v91[1];
                  uint64_t v91 = v87;
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v93, v94);
                  if (result)
                  {
                    uint64_t v95 = *v91;
                    uint64_t v96 = v90;
                    do
                    {
                      *(uint64_t *)((char *)&v12->i64[1] + v96) = *(uint64_t *)((char *)v12->i64 + v96);
                      if (!v96)
                      {
                        long long v92 = (uint64_t *)v12;
                        goto LABEL_117;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v95, *(uint64_t *)((char *)&v12->i64[-1] + v96));
                      v96 -= 8;
                    }
                    while ((result & 1) != 0);
                    long long v92 = (uint64_t *)((char *)&v12->i64[1] + v96);
LABEL_117:
                    *long long v92 = v95;
                  }
                  unint64_t v87 = v91 + 1;
                  v90 += 8;
                }
                while (v91 + 1 != (uint64_t *)a2);
              }
            }
            else if (!v89)
            {
              do
              {
                uint64_t v107 = v9->i64[0];
                uint64_t v106 = v9->i64[1];
                float v9 = (int8x16_t *)v87;
                uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v106, v107);
                if (result)
                {
                  uint64_t v108 = v9->i64[0];
                  v109 = (uint64_t *)v9;
                  do
                  {
                    int64_t v110 = v109;
                    uint64_t v111 = *--v109;
                    *int64_t v110 = v111;
                    uint64_t result = ((uint64_t (*)(uint64_t, void))*a3)(v108, *(v110 - 2));
                  }
                  while ((result & 1) != 0);
                  uint64_t *v109 = v108;
                }
                unint64_t v87 = &v9->i64[1];
              }
              while (&v9->u64[1] != (unint64_t *)a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != v10)
            {
              int64_t v97 = (unint64_t)(v14 - 2) >> 1;
              int64_t v128 = v97;
              do
              {
                if (v128 >= v97)
                {
                  uint64_t v99 = (2 * v97) | 1;
                  size_t v100 = &v9->i64[v99];
                  if (2 * v97 + 2 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                  {
                    ++v100;
                    uint64_t v99 = 2 * v97 + 2;
                  }
                  uint64_t v101 = &v9->i64[v97];
                  uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, *v101);
                  if ((result & 1) == 0)
                  {
                    uint64_t v126 = *v101;
                    do
                    {
                      uint64_t v102 = v100;
                      *uint64_t v101 = *v100;
                      if (v128 < v99) {
                        break;
                      }
                      uint64_t v103 = (2 * v99) | 1;
                      size_t v100 = &v9->i64[v103];
                      uint64_t v104 = 2 * v99 + 2;
                      if (v104 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                      {
                        ++v100;
                        uint64_t v103 = v104;
                      }
                      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, v126);
                      uint64_t v101 = v102;
                      uint64_t v99 = v103;
                    }
                    while (!result);
                    *uint64_t v102 = v126;
                  }
                }
                BOOL v98 = v97-- <= 0;
              }
              while (!v98);
              uint64_t v112 = (unint64_t)v13 >> 3;
              do
              {
                uint64_t v113 = 0;
                uint64_t v114 = v9->i64[0];
                float32x4_t v115 = (uint64_t *)v9;
                do
                {
                  float32x4_t v116 = (unint64_t *)&v115[v113 + 1];
                  uint64_t v117 = (2 * v113) | 1;
                  uint64_t v118 = 2 * v113 + 2;
                  if (v118 < v112)
                  {
                    uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v115[v113 + 1], v115[v113 + 2]);
                    if (result)
                    {
                      ++v116;
                      uint64_t v117 = v118;
                    }
                  }
                  *float32x4_t v115 = *v116;
                  float32x4_t v115 = (uint64_t *)v116;
                  uint64_t v113 = v117;
                }
                while (v117 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                long long v119 = &a2[-1].i64[1];
                BOOL v6 = v116 == &a2[-1].u64[1];
                a2 = (int8x16_t *)((char *)a2 - 8);
                if (v6)
                {
                  unint64_t *v116 = v114;
                }
                else
                {
                  unint64_t *v116 = *v119;
                  *long long v119 = v114;
                  uint64_t v120 = (char *)v116 - (char *)v9 + 8;
                  if (v120 >= 9)
                  {
                    unint64_t v121 = (((unint64_t)v120 >> 3) - 2) >> 1;
                    long long v122 = &v9->i64[v121];
                    uint64_t result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, *v116);
                    if (result)
                    {
                      unint64_t v123 = *v116;
                      do
                      {
                        v124 = v122;
                        unint64_t *v116 = *v122;
                        if (!v121) {
                          break;
                        }
                        unint64_t v121 = (v121 - 1) >> 1;
                        long long v122 = &v9->i64[v121];
                        uint64_t result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, v123);
                        float32x4_t v116 = (unint64_t *)v124;
                      }
                      while ((result & 1) != 0);
                      uint64_t *v124 = v123;
                    }
                  }
                }
                BOOL v98 = v112-- <= 2;
              }
              while (!v98);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          unsigned int v16 = *a3;
          if ((unint64_t)v13 >= 0x401)
          {
            char v17 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[v15], v9->i64[0]);
            int v18 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[v15]);
            if (v17)
            {
              uint64_t v19 = v9->i64[0];
              if (v18)
              {
                v9->i64[0] = *v11;
                *uint64_t v11 = v19;
              }
              else
              {
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v19;
                if ((*a3)(*v11))
                {
                  uint64_t v27 = v9->i64[v15];
                  v9->i64[v15] = *v11;
                  *uint64_t v11 = v27;
                }
              }
            }
            else if (v18)
            {
              uint64_t v23 = v9->i64[v15];
              v9->i64[v15] = *v11;
              *uint64_t v11 = v23;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[0]))
              {
                uint64_t v24 = v9->i64[0];
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v24;
              }
            }
            unint64_t v28 = v15 - 1;
            uint64_t v29 = v15 - 1;
            char v30 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]);
            int v31 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-1].i64[0], v9->i64[v29]);
            uint64_t v125 = a4;
            if (v30)
            {
              uint64_t v32 = v9->i64[1];
              if (v31)
              {
                v9->i64[1] = v10[-1].i64[0];
                v10[-1].i64[0] = v32;
              }
              else
              {
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v32;
                if ((*a3)(v10[-1].i64[0]))
                {
                  uint64_t v36 = v9->i64[v29];
                  v9->i64[v29] = v10[-1].i64[0];
                  v10[-1].i64[0] = v36;
                }
              }
            }
            else if (v31)
            {
              uint64_t v33 = v9->i64[v29];
              v9->i64[v29] = v10[-1].i64[0];
              v10[-1].i64[0] = v33;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]))
              {
                uint64_t v34 = v9->i64[1];
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v34;
              }
            }
            unint64_t v37 = v15 + 1;
            uint64_t v38 = v15 + 1;
            char v39 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]);
            int v40 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-2].i64[1], v9->i64[v38]);
            if (v39)
            {
              uint64_t v41 = v9[1].i64[0];
              if (v40)
              {
                v9[1].i64[0] = v10[-2].i64[1];
                v10[-2].i64[1] = v41;
              }
              else
              {
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v41;
                if ((*a3)(v10[-2].i64[1]))
                {
                  uint64_t v44 = v9->i64[v38];
                  v9->i64[v38] = v10[-2].i64[1];
                  v10[-2].i64[1] = v44;
                }
              }
            }
            else if (v40)
            {
              uint64_t v42 = v9->i64[v38];
              v9->i64[v38] = v10[-2].i64[1];
              v10[-2].i64[1] = v42;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]))
              {
                uint64_t v43 = v9[1].i64[0];
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v43;
              }
            }
            char v45 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[v28]);
            int v46 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v37], v9->i64[v15]);
            if (v45)
            {
              uint64_t v47 = v9->i64[v28];
              if (v46)
              {
                v9->i64[v28] = v9->i64[v38];
                v9->i64[v38] = v47;
                uint64_t v48 = v9->i64[v15];
                uint64_t v11 = &a2[-1].i64[1];
              }
              else
              {
                v9->i64[v28] = v9->i64[v15];
                v9->i64[v15] = v47;
                unsigned int v51 = (*a3)(v9->i64[v37]);
                uint64_t v48 = v9->i64[v15];
                uint64_t v11 = &a2[-1].i64[1];
                if (v51)
                {
                  uint64_t v52 = v9->i64[v38];
                  v9->i64[v15] = v52;
                  v9->i64[v38] = v48;
                  uint64_t v48 = v52;
                }
              }
              a4 = v125;
            }
            else
            {
              uint64_t v48 = v9->i64[v15];
              a4 = v125;
              if (v46)
              {
                v9->i64[v15] = v9->i64[v38];
                v9->i64[v38] = v48;
                int v49 = ((uint64_t (*)(void))*a3)();
                uint64_t v48 = v9->i64[v15];
                if (v49)
                {
                  uint64_t v50 = v9->i64[v29];
                  v9->i64[v29] = v48;
                  v9->i64[v15] = v50;
                  uint64_t v48 = v50;
                }
              }
              uint64_t v11 = &a2[-1].i64[1];
            }
            uint64_t v53 = v9->i64[0];
            v9->i64[0] = v48;
            v9->i64[v15] = v53;
          }
          else
          {
            char v20 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[0], v9->i64[v15]);
            int v21 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[0]);
            if (v20)
            {
              uint64_t v22 = v9->i64[v15];
              if (v21)
              {
                v9->i64[v15] = *v11;
                *uint64_t v11 = v22;
              }
              else
              {
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v22;
                if ((*a3)(*v11))
                {
                  uint64_t v35 = v9->i64[0];
                  v9->i64[0] = *v11;
                  *uint64_t v11 = v35;
                }
              }
            }
            else if (v21)
            {
              uint64_t v25 = v9->i64[0];
              v9->i64[0] = *v11;
              *uint64_t v11 = v25;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[0], v9->i64[v15]))
              {
                uint64_t v26 = v9->i64[v15];
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v26;
              }
            }
          }
          --a4;
          uint64_t v54 = v9->i64[0];
          if (a5) {
            break;
          }
          char v55 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9[-1].i64[1], v9->i64[0]);
          uint64_t v54 = v9->i64[0];
          if (v55) {
            break;
          }
          uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[0], *v11);
          if (result)
          {
            unsigned int v12 = v9;
            do
            {
              uint64_t v69 = v12->i64[1];
              unsigned int v12 = (int8x16_t *)((char *)v12 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v69);
            }
            while ((result & 1) == 0);
          }
          else
          {
            char v70 = (int8x16_t *)&v9->u64[1];
            do
            {
              unsigned int v12 = v70;
              if (v70 >= a2) {
                break;
              }
              char v70 = (int8x16_t *)((char *)v70 + 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v12->i64[0]);
            }
            while (!result);
          }
          unint64_t v10 = a2;
          unint64_t v71 = a2;
          if (v12 < a2)
          {
            unint64_t v71 = a2;
            do
            {
              uint64_t v72 = v71[-1].i64[1];
              unint64_t v71 = (int8x16_t *)((char *)v71 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v72);
            }
            while ((result & 1) != 0);
          }
          while (v12 < v71)
          {
            uint64_t v73 = v12->i64[0];
            v12->i64[0] = v71->i64[0];
            v71->i64[0] = v73;
            do
            {
              uint64_t v74 = v12->i64[1];
              unsigned int v12 = (int8x16_t *)((char *)v12 + 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v54, v74));
            do
            {
              uint64_t v75 = v71[-1].i64[1];
              unint64_t v71 = (int8x16_t *)((char *)v71 - 8);
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v75);
            }
            while ((result & 1) != 0);
          }
          uint64_t v76 = &v12[-1].i64[1];
          BOOL v5 = &v12[-1].u64[1] >= (unint64_t *)v9;
          BOOL v6 = &v12[-1].u64[1] == (unint64_t *)v9;
          if (&v12[-1].u64[1] != (unint64_t *)v9) {
            v9->i64[0] = *v76;
          }
          a5 = 0;
          uint64_t *v76 = v54;
        }
        uint64_t v56 = (uint64_t *)v9;
        do
        {
          unint64_t v57 = (int8x16_t *)v56;
          uint64_t v58 = v56[1];
          ++v56;
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v58, v54) & 1) != 0);
        uint64_t v59 = a4;
        uint64_t v60 = (uint64_t *)v10;
        if (v57 == v9)
        {
          uint64_t v60 = (uint64_t *)v10;
          do
          {
            if (v56 >= v60) {
              break;
            }
            uint64_t v62 = *--v60;
          }
          while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v62, v54) & 1) == 0);
        }
        else
        {
          do
            uint64_t v61 = *--v60;
          while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v61, v54));
        }
        if (v56 < v60)
        {
          uint64_t v63 = (int8x16_t *)v56;
          uint64_t v64 = (int8x16_t *)v60;
          do
          {
            uint64_t v65 = v63->i64[0];
            v63->i64[0] = v64->i64[0];
            v64->i64[0] = v65;
            do
            {
              unint64_t v57 = v63;
              uint64_t v66 = v63->i64[1];
              uint64_t v63 = (int8x16_t *)((char *)v63 + 8);
            }
            while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v66, v54) & 1) != 0);
            do
            {
              uint64_t v67 = v64[-1].i64[1];
              uint64_t v64 = (int8x16_t *)((char *)v64 - 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v67, v54));
          }
          while (v63 < v64);
        }
        if (v57 != v9) {
          v9->i64[0] = v57->i64[0];
        }
        v57->i64[0] = v54;
        unint64_t v10 = a2;
        a4 = v59;
        if (v56 >= v60) {
          break;
        }
LABEL_73:
        uint64_t result = sub_19E4FF6A0(v9, v57, a3, a4, a5 & 1);
        a5 = 0;
        unsigned int v12 = (int8x16_t *)&v57->u64[1];
      }
      BOOL v68 = sub_19E50035C(v9, v57, a3);
      unsigned int v12 = (int8x16_t *)&v57->u64[1];
      uint64_t result = sub_19E50035C(&v57->i64[1], a2, a3);
      if (result) {
        break;
      }
      if (!v68) {
        goto LABEL_73;
      }
    }
    a2 = v57;
    if (!v68) {
      continue;
    }
    return result;
  }
}

uint64_t sub_19E500208(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  char v10 = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
  int v11 = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
  if (v10)
  {
    uint64_t v12 = *a1;
    if (v11)
    {
      *a1 = *a3;
      *a3 = v12;
    }
    else
    {
      *a1 = *a2;
      *a2 = v12;
      if ((*a5)(*a3))
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
      }
    }
  }
  else if (v11)
  {
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    if (((unsigned int (*)(void, void))*a5)(*a2, *a1))
    {
      uint64_t v14 = *a1;
      *a1 = *a2;
      *a2 = v14;
    }
  }
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v17 = *a3;
    *a3 = *a4;
    *a4 = v17;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v19 = *a1;
        *a1 = *a2;
        *a2 = v19;
      }
    }
  }
  return result;
}

BOOL sub_19E50035C(void *a1, void *a2, unsigned int (**a3)(uint64_t))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      char v9 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v10 = ((uint64_t (*)(void, void))*a3)(*(a2 - 1), a1[1]);
      if (v9)
      {
        uint64_t v11 = *a1;
        if (v10)
        {
          *a1 = *(a2 - 1);
          *(a2 - 1) = v11;
        }
        else
        {
          *a1 = a1[1];
          a1[1] = v11;
          if ((*a3)(*(a2 - 1)))
          {
            uint64_t v26 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v26;
          }
        }
      }
      else if (v10)
      {
        uint64_t v24 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v24;
        int v19 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
LABEL_17:
        if (v19) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      return 1;
    case 4:
      sub_19E500208(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      uint64_t v12 = a1 + 2;
      uint64_t v13 = a1 + 3;
      sub_19E500208(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      if (!((unsigned int (*)(void, void))*a3)(*(a2 - 1), a1[3])) {
        return 1;
      }
      uint64_t v14 = *v13;
      *uint64_t v13 = *(a2 - 1);
      *(a2 - 1) = v14;
      if (!((unsigned int (*)(void, void))*a3)(*v13, *v12)) {
        return 1;
      }
      uint64_t v15 = *v12;
      *uint64_t v12 = *v13;
      *uint64_t v13 = v15;
      if (!((unsigned int (*)(void))*a3)()) {
        return 1;
      }
      uint64_t v17 = a1[1];
      uint64_t v16 = a1[2];
      uint64_t v18 = *a1;
      a1[1] = v16;
      a1[2] = v17;
      int v19 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v16, v18);
      goto LABEL_17;
    default:
      char v20 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v21 = a1 + 2;
      int v22 = ((uint64_t (*)(void, void))*a3)(a1[2], a1[1]);
      if (v20)
      {
        uint64_t v23 = *a1;
        if (v22)
        {
          *a1 = a1[2];
          a1[2] = v23;
        }
        else
        {
          uint64_t v27 = a1[2];
          *a1 = a1[1];
          a1[1] = v23;
          if ((*a3)(v27)) {
            *(int8x16_t *)(a1 + 1) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
          }
        }
      }
      else if (v22)
      {
        uint64_t v25 = a1[1];
        a1[1] = a1[2];
        a1[2] = v25;
        if (((unsigned int (*)(void))*a3)()) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      unint64_t v28 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v28, *v21))
    {
      uint64_t v32 = *v28;
      uint64_t v33 = v29;
      do
      {
        uint64_t v34 = (char *)a1 + v33;
        *(void *)((char *)a1 + v33 + 24) = *(void *)((char *)a1 + v33 + 16);
        if (v33 == -16)
        {
          int v31 = a1;
          goto LABEL_29;
        }
        v33 -= 8;
      }
      while ((((uint64_t (*)(uint64_t, void))*a3)(v32, *((void *)v34 + 1)) & 1) != 0);
      int v31 = (void *)((char *)a1 + v33 + 24);
LABEL_29:
      void *v31 = v32;
      if (++v30 == 8) {
        return v28 + 1 == a2;
      }
    }
    int v21 = v28;
    v29 += 8;
    if (++v28 == a2) {
      return 1;
    }
  }
}

BOOL sub_19E500690(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a1 + 12);
  float v3 = *(float *)(a2 + 12);
  if (v2 == v3) {
    return *(_DWORD *)(a1 + 20) > *(_DWORD *)(a2 + 20);
  }
  else {
    return v2 > v3;
  }
}

uint64_t sub_19E5006BC(uint64_t result, const void *a2, unsigned int a3, char a4, uint64_t a5)
{
  if (a3 <= 0x3FF)
  {
    unint64_t v9 = result;
    if (qword_1E9459D80 != -1) {
      dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
    }
    int v10 = pthread_getspecific(qword_1E9459D78);
    if (!v10)
    {
      int v10 = malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
      pthread_setspecific(qword_1E9459D78, v10);
    }
    memcpy(v10, a2, a3);
    v10[a3] = 0;
    uint64_t v11 = *(void *)(v9 + 2084);
    if (v11)
    {
      uint64_t v12 = (*(_DWORD *)(v11 + 4) & 0xFFFFFFFC) + v11;
      return sub_19E500818(v9, v12, v10, a3, 0, a4, a5);
    }
    else
    {
      return sub_19E500B24(v9, v10, a3, 0, a4, a5);
    }
  }
  return result;
}

uint64_t sub_19E500818(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7)
{
  uint64_t v12 = (void *)(a1 + 2084);
  uint64_t v13 = a5;
  if (a5 <= a4) {
    uint64_t v14 = a4;
  }
  else {
    uint64_t v14 = a5;
  }
  if (v14 == a5)
  {
LABEL_7:
    int v17 = *(_DWORD *)(a2 + 1024);
    if (!v17)
    {
      if (a6) {
        return 0;
      }
LABEL_29:
      uint64_t v27 = 0;
      uint64_t v28 = a4 + 1;
      while (1)
      {
        int v29 = *(_DWORD *)(a2 + 4 * v27);
        a3[v13] = v27;
        uint64_t v30 = v29 & 3;
        if (v30 == 1)
        {
          if (sub_19E500818(a1, (v29 & 0xFFFFFFFC) + *v12, a3, v28, (v13 + 1), 0, a7)) {
            return 1;
          }
        }
        else if (v30 == 2)
        {
          if (sub_19E501368(*(_DWORD *)(a1 + 2068), (unsigned int *)((v29 & 0xFFFFFFFC) + *v12), a3, v28, (int)v13 + 1, 0, a7))return 1; {
        }
          }
        else if (v30 == 3 {
               && (sub_19E500F38(a1, (int8x8_t *)((v29 & 0xFFFFFFFC) + *v12), a3, v28, (int)v13 + 1, 0, a7) & 1) != 0)
        }
        {
          return 1;
        }
        if (++v27 == 256) {
          return 0;
        }
      }
    }
    int v18 = *(_DWORD *)(a2 + 1032);
    int v19 = malloc_type_malloc(a4 + 21, 0x18AD45BuLL);
    v19[4] = a4;
    *((unsigned char *)v19 + a4 + 20) = 0;
    memcpy(v19 + 5, a3, a4);
    v19[1] = 1065353216;
    v19[2] = v17;
    *int v19 = v18;
    void v19[3] = 1;
    if (!a7) {
      goto LABEL_24;
    }
    if (*(_DWORD *)a7 <= 1u)
    {
      *(_DWORD *)(a7 + 4) = v17;
      *(_DWORD *)(a7 + 8) = v18;
      BOOL v20 = 1;
      goto LABEL_25;
    }
    char v32 = 0;
    uint64_t v25 = *(void (**)(void, _DWORD *, char *))(a7 + 24);
    if (v25)
    {
      v25(*(void *)(a7 + 16), v19, &v32);
      BOOL v20 = v32 != 0;
    }
    else
    {
LABEL_24:
      BOOL v20 = 0;
    }
LABEL_25:
    int v26 = v19[3] - 1;
    void v19[3] = v26;
    if (!v26) {
      free(v19);
    }
    uint64_t result = v20;
    if (v20 || (a6 & 1) != 0) {
      return result;
    }
    goto LABEL_29;
  }
  while (1)
  {
    int v15 = *(_DWORD *)(a2 + 4 * a3[v13]);
    uint64_t v16 = v15 & 3;
    if (v16 != 1) {
      break;
    }
    a2 = (v15 & 0xFFFFFFFC) + *v12;
    if (v14 == ++v13) {
      goto LABEL_7;
    }
  }
  if (v16 != 2)
  {
    if (v16 == 3)
    {
      int v21 = (int8x8_t *)((v15 & 0xFFFFFFFC) + *v12);
      return sub_19E500F38(a1, v21, a3, a4, (int)v13 + 1, a6, a7);
    }
    return 0;
  }
  uint64_t v23 = (unsigned int *)((v15 & 0xFFFFFFFC) + *v12);
  int v24 = *(_DWORD *)(a1 + 2068);
  return sub_19E501368(v24, v23, a3, a4, (int)v13 + 1, a6, a7);
}

uint64_t sub_19E500B24(unint64_t a1, unsigned char *a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6)
{
  uint64_t v11 = a4;
  if (a4 <= a3) {
    uint64_t v12 = a3;
  }
  else {
    uint64_t v12 = a4;
  }
  if (v12 == a4)
  {
LABEL_7:
    int v14 = *(_DWORD *)(a1 + 12);
    if (!v14)
    {
      if (a5) {
        return 0;
      }
      uint64_t v15 = v11;
LABEL_26:
      uint64_t v21 = 0;
      uint64_t v22 = a3 + 1;
      unint64_t v23 = a1 + 16;
      while (1)
      {
        uint64_t v24 = *(void *)(v23 + 8 * v21);
        a2[v15] = v21;
        if ((v24 & 3) == 1)
        {
          if (sub_19E500B24(v24 & 0xFFFFFFFFFFFFFFFCLL, a2, v22, (v11 + 1), 0, a6)) {
            return 1;
          }
        }
        else if (v24 & 3) == 2 && (sub_19E500D68(v24 & 0xFFFFFFFFFFFFFFFCLL, a2, v22, (int)v11 + 1, 0, a6))
        {
          return 1;
        }
        if (++v21 == 256) {
          return 0;
        }
      }
    }
    uint64_t v15 = v11;
    uint64_t v25 = *(void *)(a1 + 4);
    uint64_t v16 = malloc_type_malloc(v11 + 21, 0x18AD45BuLL);
    v16[4] = v11;
    *((unsigned char *)v16 + v11 + 20) = 0;
    memcpy(v16 + 5, a2, v11);
    *(void *)uint64_t v16 = v25;
    v16[2] = v14;
    v16[3] = 1;
    if (!a6) {
      goto LABEL_21;
    }
    if (*(_DWORD *)a6 <= 1u)
    {
      *(_DWORD *)(a6 + 4) = v14;
      *(_DWORD *)(a6 + 8) = v25;
      BOOL v17 = 1;
      goto LABEL_22;
    }
    char v26 = 0;
    int v19 = *(void (**)(void, _DWORD *, char *))(a6 + 24);
    if (v19)
    {
      v19(*(void *)(a6 + 16), v16, &v26);
      BOOL v17 = v26 != 0;
    }
    else
    {
LABEL_21:
      BOOL v17 = 0;
    }
LABEL_22:
    int v20 = v16[3] - 1;
    v16[3] = v20;
    if (!v20) {
      free(v16);
    }
    uint64_t result = v17;
    if (v17 || (a5 & 1) != 0) {
      return result;
    }
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v13 = *(void *)(a1 + 8 * a2[v11] + 16);
    if ((v13 & 3) != 1) {
      break;
    }
    a1 = v13 & 0xFFFFFFFFFFFFFFFCLL;
    if (v12 == ++v11) {
      goto LABEL_7;
    }
  }
  if ((v13 & 3) != 2) {
    return 0;
  }
  return sub_19E500D68(v13 & 0xFFFFFFFFFFFFFFFCLL, a2, a3, (int)v11 + 1, a5, a6);
}

uint64_t sub_19E500D68(uint64_t result, unsigned char *a2, unsigned int a3, int a4, char a5, uint64_t a6)
{
  if (result)
  {
    char v7 = a5;
    int v8 = a4;
    uint64_t v10 = result;
    uint64_t v11 = &a2[a4];
    size_t v12 = (int)(a3 - a4);
    size_t v27 = a3;
    std::string __dst = &a2[a3];
    while (1)
    {
      uint64_t v13 = *(unsigned __int16 *)(v10 + 24);
      if ((int)v12 > (int)v13
        || memcmp((const void *)(v10 + 26), v11, v12)
        || v12 != v13 && (v7 & 1) != 0)
      {
        goto LABEL_4;
      }
      uint64_t v14 = a6;
      size_t v15 = (v13 + v8);
      int v16 = a3;
      size_t v17 = v15 - a3;
      size_t v18 = v27;
      if ((int)v17 >= 1)
      {
        memcpy(__dst, (const void *)(v10 + 26 + v13 - (int)v17), v17);
        size_t v18 = v15;
        int v16 = v15;
      }
      a2[v18] = 0;
      int v19 = *(_DWORD *)(v10 + 20);
      uint64_t v29 = *(void *)(v10 + 12);
      int v20 = malloc_type_malloc(v18 + 21, 0x18AD45BuLL);
      v20[4] = v16;
      *((unsigned char *)v20 + v18 + 20) = 0;
      memcpy(v20 + 5, a2, v18);
      *(void *)int v20 = v29;
      v20[2] = v19;
      v20[3] = 1;
      a6 = v14;
      if (v14)
      {
        if (*(_DWORD *)v14 == 1) {
          goto LABEL_15;
        }
        if (*(_DWORD *)v14)
        {
          char v30 = 0;
          uint64_t v22 = *(void (**)(void, _DWORD *, char *))(v14 + 24);
          if (v22)
          {
            v22(*(void *)(v14 + 16), v20, &v30);
            BOOL v21 = v30 != 0;
            goto LABEL_19;
          }
        }
        else if (v12 == v13)
        {
LABEL_15:
          *(_DWORD *)(v14 + 4) = v19;
          *(_DWORD *)(v14 + 8) = v29;
          BOOL v21 = 1;
          goto LABEL_19;
        }
      }
      BOOL v21 = 0;
LABEL_19:
      int v8 = a4;
      char v7 = a5;
      int v23 = v20[3] - 1;
      v20[3] = v23;
      if (!v23) {
        free(v20);
      }
      if (v21) {
        return 1;
      }
LABEL_4:
      uint64_t v10 = *(void *)v10;
      if (!v10) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_19E500F38(uint64_t a1, int8x8_t *a2, unsigned char *a3, unsigned int a4, unsigned int a5, char a6, uint64_t a7)
{
  size_t v12 = (void *)(a1 + 2084);
  if (a5 <= a4) {
    uint64_t v13 = a4;
  }
  else {
    uint64_t v13 = a5;
  }
  if (v13 != a5)
  {
    do
    {
      unint64_t v14 = a3[a5];
      unint64_t v15 = v14 >> 6;
      int8x8_t v16 = a2[v14 >> 6];
      if (((1 << v14) & *(void *)&v16) == 0) {
        return 0;
      }
      if (v14 >= 0x40)
      {
        uint8x8_t v18 = (uint8x8_t)vcnt_s8(*a2);
        v18.i16[0] = vaddlv_u8(v18);
        __int32 v17 = v18.i32[0];
        if ((v14 & 0x80) != 0)
        {
          if (v15 <= 1) {
            LODWORD(v15) = 1;
          }
          uint8x8_t v19 = (uint8x8_t)vcnt_s8(a2[1]);
          v19.i16[0] = vaddlv_u8(v19);
          v17 += v19.i32[0];
          if (v15 != 2)
          {
            uint8x8_t v20 = (uint8x8_t)vcnt_s8(a2[2]);
            v20.i16[0] = vaddlv_u8(v20);
            v17 += v20.i32[0];
          }
        }
      }
      else
      {
        __int32 v17 = 0;
      }
      uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)(((1 << v14) - 1) & *(void *)&v16));
      v21.i16[0] = vaddlv_u8(v21);
      __int32 v22 = a2[5].i32[v17 + v21.i32[0] + 1];
      int v23 = v22 & 3;
      if (v23 != 3)
      {
        if (v23 == 1)
        {
          return ((uint64_t (*)(void))sub_19E500818)();
        }
        else
        {
          if (v23 != 2) {
            return 0;
          }
          uint64_t v28 = (unsigned int *)((v22 & 0xFFFFFFFC) + *v12);
          int v29 = a5 + 1;
          int v30 = *(_DWORD *)(a1 + 2068);
          return sub_19E501368(v30, v28, a3, a4, v29, a6, a7);
        }
      }
      a2 = (int8x8_t *)((v22 & 0xFFFFFFFC) + *v12);
    }
    while (v13 != ++a5);
  }
  __int32 v24 = a2[5].i32[0];
  if (!v24)
  {
    if (a6) {
      return 0;
    }
LABEL_37:
    unsigned int v34 = 0;
    uint64_t v35 = a4 + 1;
    while (1)
    {
      if (v34 >> 6 <= 1) {
        int v36 = 1;
      }
      else {
        int v36 = v34 >> 6;
      }
      int8x8_t v37 = a2[v34 >> 6];
      if ((*(void *)&v37 & (1 << v34)) != 0)
      {
        if (v34 > 0x3F)
        {
          uint8x8_t v39 = (uint8x8_t)vcnt_s8(*a2);
          v39.i16[0] = vaddlv_u8(v39);
          __int32 v38 = v39.i32[0];
          if (v34 >= 0x80)
          {
            uint8x8_t v40 = (uint8x8_t)vcnt_s8(a2[1]);
            v40.i16[0] = vaddlv_u8(v40);
            v38 += v40.i32[0];
            if (v36 != 2)
            {
              uint8x8_t v41 = (uint8x8_t)vcnt_s8(a2[2]);
              v41.i16[0] = vaddlv_u8(v41);
              v38 += v41.i32[0];
            }
          }
        }
        else
        {
          __int32 v38 = 0;
        }
        uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)(*(void *)&v37 & ((1 << v34) - 1)));
        v42.i16[0] = vaddlv_u8(v42);
        __int32 v43 = a2[5].i32[v38 + v42.i32[0] + 1];
        a3[v13] = v34;
        int v44 = v43 & 3;
        if (v44 == 1)
        {
          if (sub_19E500818(a1, *v12 + (v43 & 0xFFFFFFFC), a3, v35, (v13 + 1), 0, a7)) {
            return 1;
          }
        }
        else if (v44 == 2)
        {
          if (sub_19E501368(*(_DWORD *)(a1 + 2068), (unsigned int *)(*v12 + (v43 & 0xFFFFFFFC)), a3, v35, (int)v13 + 1, 0, a7))return 1; {
        }
          }
        else if (v44 == 3 {
               && (sub_19E500F38(a1, *v12 + (v43 & 0xFFFFFFFC), a3, v35, (v13 + 1), 0, a7) & 1) != 0)
        }
        {
          return 1;
        }
      }
      if (++v34 == 256) {
        return 0;
      }
    }
  }
  __int32 v25 = a2[4].i32[1];
  char v26 = malloc_type_malloc(a4 + 21, 0x18AD45BuLL);
  v26[4] = a4;
  *((unsigned char *)v26 + a4 + 20) = 0;
  memcpy(v26 + 5, a3, a4);
  v26[1] = 1065353216;
  v26[2] = v24;
  _DWORD *v26 = v25;
  v26[3] = 1;
  if (!a7) {
    goto LABEL_32;
  }
  if (*(_DWORD *)a7 <= 1u)
  {
    *(_DWORD *)(a7 + 4) = v24;
    *(_DWORD *)(a7 + 8) = v25;
    BOOL v27 = 1;
    goto LABEL_33;
  }
  char v46 = 0;
  char v32 = *(void (**)(void, _DWORD *, char *))(a7 + 24);
  if (v32)
  {
    v32(*(void *)(a7 + 16), v26, &v46);
    BOOL v27 = v46 != 0;
  }
  else
  {
LABEL_32:
    BOOL v27 = 0;
  }
LABEL_33:
  int v33 = v26[3] - 1;
  v26[3] = v33;
  if (!v33) {
    free(v26);
  }
  uint64_t result = v27;
  if (!v27 && (a6 & 1) == 0) {
    goto LABEL_37;
  }
  return result;
}

uint64_t sub_19E501368(char a1, unsigned int *a2, unsigned char *a3, unsigned int a4, int a5, char a6, uint64_t a7)
{
  char v7 = a6;
  int v8 = a5;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  int v10 = a4 - a5;
  unsigned int v11 = *a2;
  if ((a1 & 2) == 0)
  {
    if (v11)
    {
      int v12 = a4;
      unsigned int v13 = 0;
      __s2 = &a3[a5];
      size_t v50 = a4;
      std::string __dst = &a3[a4];
      unsigned int v54 = *a2;
      do
      {
        unint64_t v15 = (char *)a2 + v13;
        uint64_t v14 = *((unsigned __int16 *)v15 + 8);
        if (v10 > (int)v14) {
          goto LABEL_6;
        }
        int8x8_t v16 = v15 + 8;
        __int32 v17 = v15 + 18;
        if (memcmp(v15 + 18, __s2, v10) || v10 != v14 && (v7 & 1) != 0) {
          goto LABEL_6;
        }
        size_t v18 = (v14 + v8);
        size_t v19 = (v18 - v12);
        size_t v20 = v50;
        if ((int)v19 >= 1)
        {
          memcpy(__dst, &v17[v14 - (int)v19], v19);
          size_t v20 = v18;
          int v12 = v18;
        }
        a3[v20] = 0;
        int v21 = *((_DWORD *)v16 + 1);
        int v22 = *(_DWORD *)v16;
        int v23 = malloc_type_malloc(v20 + 21, 0x18AD45BuLL);
        v23[4] = v12;
        *((unsigned char *)v23 + v20 + 20) = 0;
        memcpy(v23 + 5, a3, v20);
        v23[1] = 1065353216;
        v23[2] = v21;
        *int v23 = v22;
        v23[3] = 1;
        if (a7)
        {
          char v7 = a6;
          int v12 = a4;
          if (*(_DWORD *)a7 != 1)
          {
            unsigned int v11 = v54;
            if (*(_DWORD *)a7)
            {
              LOBYTE(__s1[0]) = 0;
              __int32 v25 = *(void (**)(void, _DWORD *, _OWORD *))(a7 + 24);
              if (v25)
              {
                v25(*(void *)(a7 + 16), v23, __s1);
                BOOL v24 = LOBYTE(__s1[0]) != 0;
                goto LABEL_23;
              }
            }
            else if (v10 == v14)
            {
              *(_DWORD *)(a7 + 4) = v21;
              *(_DWORD *)(a7 + 8) = v22;
              BOOL v24 = 1;
LABEL_23:
              int v8 = a5;
              goto LABEL_24;
            }
            BOOL v24 = 0;
            goto LABEL_23;
          }
          *(_DWORD *)(a7 + 4) = v21;
          *(_DWORD *)(a7 + 8) = v22;
          BOOL v24 = 1;
          unsigned int v11 = v54;
          int v8 = a5;
        }
        else
        {
          BOOL v24 = 0;
          char v7 = a6;
          unsigned int v11 = v54;
          int v8 = a5;
          int v12 = a4;
        }
LABEL_24:
        int v26 = v23[3] - 1;
        v23[3] = v26;
        if (!v26) {
          free(v23);
        }
        if (v24) {
          return 1;
        }
        LODWORD(v14) = *((unsigned __int16 *)v16 + 4);
LABEL_6:
        v13 += v14 + 10;
      }
      while (v13 < v11);
    }
    return 0;
  }
  memset(__s1, 0, sizeof(__s1));
  if (!v11) {
    return 0;
  }
  BOOL v27 = 0;
  unsigned int v28 = 0;
  int v60 = a5 - a4;
  __s2a = &a3[a5];
  unsigned int v51 = &a3[a4];
  unsigned int v55 = v11;
  while (1)
  {
    int v30 = (char *)a2 + v28;
    uint64_t v31 = v30[18];
    if (v27)
    {
      uint64_t v32 = v27[10];
      if (v31 > v32) {
        memcpy((char *)__s1 + v32, v27 + 11, v31 - v32);
      }
    }
    BOOL v27 = v30 + 8;
    unsigned int v33 = *((unsigned __int16 *)v30 + 8);
    int v34 = v33 + v31;
    if ((int)(v33 + v31) < v10) {
      goto LABEL_32;
    }
    if (a4 != v8)
    {
      int v29 = (int)v31 >= v10 ? v10 : v31;
      if (memcmp(__s1, __s2a, v29)) {
        goto LABEL_32;
      }
    }
    unsigned int v35 = v10 - v31;
    if (v10 - (int)v31 >= 0)
    {
      size_t v36 = (int)v33 >= (int)v35 ? v35 : v33;
      if (memcmp(v27 + 11, &__s2a[v31], v36)) {
        goto LABEL_32;
      }
    }
    if (v10 != v34 && (v7 & 1) != 0) {
      goto LABEL_32;
    }
    unsigned int v37 = v31 + v8;
    int v38 = v37 - a4;
    if ((int)(v37 - a4) < 1)
    {
      unsigned int v37 = a4;
    }
    else
    {
      memcpy(v51, (char *)__s1 + v31 - v38, v37 - a4);
      unsigned int v33 = *((unsigned __int16 *)v27 + 4);
      LODWORD(v31) = v27[10];
    }
    int v39 = v60 + v33 + v31;
    if (v39 < 1)
    {
      uint8x8_t v41 = a3;
    }
    else
    {
      int v40 = v39 - (v38 & ~(v38 >> 31));
      uint8x8_t v41 = a3;
      memcpy(&a3[v37], &v27[v33 - v40 + 11], v40);
      v37 += v40;
    }
    v41[v37] = 0;
    int v42 = *((_DWORD *)v27 + 1);
    int v43 = *(_DWORD *)v27;
    int v44 = malloc_type_malloc(v37 + 21, 0x18AD45BuLL);
    v44[4] = v37;
    *((unsigned char *)v44 + v37 + 20) = 0;
    memcpy(v44 + 5, v41, v37);
    v44[1] = 1065353216;
    v44[2] = v42;
    *int v44 = v43;
    v44[3] = 1;
    if (!a7)
    {
      BOOL v45 = 0;
      unsigned int v11 = v55;
      int v8 = a5;
      goto LABEL_60;
    }
    unsigned int v11 = v55;
    int v8 = a5;
    if (*(_DWORD *)a7 == 1) {
      goto LABEL_55;
    }
    if (*(_DWORD *)a7)
    {
      char v64 = 0;
      char v46 = *(void (**)(void, _DWORD *, char *))(a7 + 24);
      if (v46)
      {
        v46(*(void *)(a7 + 16), v44, &v64);
        BOOL v45 = v64 != 0;
        goto LABEL_60;
      }
    }
    else if (v10 == v34)
    {
LABEL_55:
      *(_DWORD *)(a7 + 4) = v42;
      *(_DWORD *)(a7 + 8) = v43;
      BOOL v45 = 1;
      goto LABEL_60;
    }
    BOOL v45 = 0;
LABEL_60:
    int v47 = v44[3] - 1;
    v44[3] = v47;
    if (!v47) {
      free(v44);
    }
    if (v45) {
      return 1;
    }
    unsigned int v33 = *((unsigned __int16 *)v27 + 4);
    char v7 = a6;
LABEL_32:
    v28 += v33 + 11;
    if (v28 >= v11) {
      return 0;
    }
  }
}

uint64_t sub_19E50183C()
{
  return pthread_key_create((pthread_key_t *)&qword_1E9459D78, MEMORY[0x1E4F14838]);
}

uint64_t sub_19E501858(uint64_t a1, uint64_t a2)
{
  float v2 = *(float *)(a1 + 8);
  float v3 = *(float *)(a2 + 8);
  if (v2 == v3)
  {
    size_t v4 = *(unsigned int *)(a1 + 16);
    int v5 = *(_DWORD *)(a2 + 16);
    if (v4 == v5) {
      int v6 = memcmp((const void *)(a1 + 20), (const void *)(a2 + 20), v4);
    }
    else {
      int v6 = v4 - v5;
    }
    uint64_t v8 = -1;
    if (v6 <= 0) {
      uint64_t v8 = 1;
    }
    if (v6) {
      return v8;
    }
    else {
      return 0;
    }
  }
  else if (v2 <= v3)
  {
    return 1;
  }
  else
  {
    return -1;
  }
}

void sub_19E5018C0(int a1, _DWORD *a2)
{
  if (a2)
  {
    int v2 = a2[3] - 1;
    a2[3] = v2;
    if (!v2) {
      free(a2);
    }
  }
}

uint64_t sub_19E5018E0(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2) {
    ++*(_DWORD *)(a2 + 12);
  }
  return result;
}

uint64_t sub_19E5018F8(uint64_t a1, uint64_t a2)
{
  if (*(float *)a1 != *(float *)a2)
  {
    if (*(float *)a1 <= *(float *)a2) {
      return 1;
    }
    else {
      return -1;
    }
  }
  size_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a2 + 16);
  if (v2 != v3)
  {
    int v4 = v2 - v3;
LABEL_15:
    if (v4 > 0) {
      return -1;
    }
    else {
      return 1;
    }
  }
  int v4 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
  if (v4) {
    goto LABEL_15;
  }
  int v5 = memcmp((const void *)(a1 + 20), (const void *)(a2 + 20), v2);
  uint64_t v6 = -1;
  if (v5 <= 0) {
    uint64_t v6 = 1;
  }
  if (v5) {
    return v6;
  }
  else {
    return 0;
  }
}

void sub_19E501984(int a1, _DWORD *a2)
{
  if (a2)
  {
    int v2 = a2[3] - 1;
    a2[3] = v2;
    if (!v2) {
      free(a2);
    }
  }
}

uint64_t sub_19E5019A4(uint64_t a1, uint64_t a2)
{
  uint64_t result = a2;
  if (a2) {
    ++*(_DWORD *)(a2 + 12);
  }
  return result;
}

uint64_t sub_19E5019BC(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, unsigned int a5, __CFBinaryHeap *a6, __CFBinaryHeap *a7)
{
  if (a5 >= a4)
  {
LABEL_5:
    if (qword_1E9459D80 != -1) {
      dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
    }
    int8x8_t v16 = pthread_getspecific(qword_1E9459D78);
    if (!v16)
    {
      int8x8_t v16 = malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
      pthread_setspecific(qword_1E9459D78, v16);
    }
    if ((int)(a4 + 1) <= 1023)
    {
      memcpy(v16, a3, a4);
      uint64_t v17 = 0;
      *((unsigned char *)v16 + (int)(a4 + 1)) = 0;
      do
      {
        uint64_t v18 = *(unsigned int *)(a2 + 4 * v17);
        *((unsigned char *)v16 + a4) = v17;
        sub_19E502098(*(void *)(a1 + 2084), v18, v16, a4 + 1, a6);
        ++v17;
      }
      while (v17 != 256);
    }
    int v19 = *(_DWORD *)(a2 + 1024);
    if (!v19) {
      goto LABEL_15;
    }
    int v20 = *(_DWORD *)(a2 + 1032);
    int v21 = malloc_type_malloc(a4 + 21, 0x18AD45BuLL);
    v21[4] = a4;
    *((unsigned char *)v21 + a4 + 20) = 0;
    memcpy(v21 + 5, a3, a4);
    v21[1] = 1065353216;
    v21[2] = v19;
    *int v21 = v20;
    v21[3] = 1;
    int v22 = sub_19E5021D4((float *)v21, a6, a7);
    char v23 = v22;
    int v24 = v21[3] - 1;
    v21[3] = v24;
    if (v24)
    {
      if (v22)
      {
LABEL_15:
        sub_19E5023E0(a1, a6, a7);
        return 1;
      }
    }
    else
    {
      free(v21);
      if (v23) {
        goto LABEL_15;
      }
    }
    return 0;
  }
  unsigned int v11 = (void *)(a1 + 2084);
  uint64_t v12 = a5;
  while (1)
  {
    int v13 = *(_DWORD *)(a2 + 4 * a3[v12]);
    uint64_t v14 = v13 & 3;
    if (v14 != 1) {
      break;
    }
    a2 = (v13 & 0xFFFFFFFC) + *v11;
    if (a4 == ++v12) {
      goto LABEL_5;
    }
  }
  if (v14 != 2)
  {
    if (v14 == 3)
    {
      __int32 v25 = (int8x8_t *)((v13 & 0xFFFFFFFC) + *v11);
      return sub_19E5025F4(a1, v25, a3, a4, (int)v12 + 1, a6, a7);
    }
    return 1;
  }
  BOOL v27 = (unsigned int *)((v13 & 0xFFFFFFFC) + *v11);
  return sub_19E502A08(a1, v27, (char *)a3, a4, (int)v12 + 1, a6, a7);
}

uint64_t sub_19E501C64(uint64_t a1, unint64_t a2, unsigned __int8 *a3, unsigned int a4, unsigned int a5, __CFBinaryHeap *a6, __CFBinaryHeap *a7)
{
  if (a5 >= a4)
  {
LABEL_5:
    if (qword_1E9459D80 != -1) {
      dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
    }
    __int32 v25 = a7;
    unint64_t v15 = pthread_getspecific(qword_1E9459D78);
    if (!v15)
    {
      unint64_t v15 = malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
      pthread_setspecific(qword_1E9459D78, v15);
    }
    memcpy(v15, a3, a4);
    uint64_t v16 = 0;
    *((unsigned char *)v15 + (int)(a4 + 1)) = 0;
    do
    {
      uint64_t v17 = *(void *)(a2 + 16 + 8 * v16);
      *((unsigned char *)v15 + a4) = v16;
      sub_19E502098(*(void *)(a1 + 2084), v17, v15, a4 + 1, a6);
      ++v16;
    }
    while (v16 != 256);
    int v18 = *(_DWORD *)(a2 + 12);
    if (!v18) {
      goto LABEL_14;
    }
    int v19 = *(_DWORD *)(a2 + 4);
    int v20 = malloc_type_malloc(a4 + 21, 0x18AD45BuLL);
    v20[4] = a4;
    *((unsigned char *)v20 + a4 + 20) = 0;
    memcpy(v20 + 5, a3, a4);
    v20[1] = 1065353216;
    v20[2] = v18;
    *int v20 = v19;
    v20[3] = 1;
    int v21 = sub_19E5021D4((float *)v20, a6, v25);
    int v22 = v21;
    int v23 = v20[3] - 1;
    v20[3] = v23;
    if (v23)
    {
      if (v21)
      {
LABEL_14:
        return sub_19E5023E0(a1, a6);
      }
    }
    else
    {
      free(v20);
      if (v22) {
        goto LABEL_14;
      }
    }
    return 0;
  }
  uint64_t v13 = a5;
  while (1)
  {
    uint64_t v14 = *(void *)(a2 + 8 * a3[v13] + 16);
    if ((v14 & 3) != 1) {
      break;
    }
    a2 = v14 & 0xFFFFFFFFFFFFFFFCLL;
    if (a4 == ++v13) {
      goto LABEL_5;
    }
  }
  if ((v14 & 3) != 2) {
    return 1;
  }
  return sub_19E501ED4((uint64_t *)(v14 & 0xFFFFFFFFFFFFFFFCLL), (char *)a3, a4, (int)v13 + 1, a6, a7);
}

uint64_t sub_19E501ED4(uint64_t *a1, char *a2, int a3, unsigned int a4, __CFBinaryHeap *a5, __CFBinaryHeap *a6)
{
  if (a4 <= 0x3FF)
  {
    if (qword_1E9459D80 != -1) {
      dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
    }
    unsigned int v11 = (char *)pthread_getspecific(qword_1E9459D78);
    if (!v11)
    {
      unsigned int v11 = (char *)malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
      pthread_setspecific(qword_1E9459D78, v11);
    }
    memcpy(v11, a2, a4);
    v11[a4] = 0;
    if (a1)
    {
      int v12 = a3 - a4;
      uint64_t v13 = &a2[a4];
      char v6 = 1;
      do
      {
        memcpy(&v11[a4], (char *)a1 + 26, *((unsigned __int16 *)a1 + 12));
        size_t v14 = *((unsigned __int16 *)a1 + 12) + (unint64_t)a4;
        v11[v14] = 0;
        if (v12 <= *((unsigned __int16 *)a1 + 12) && !memcmp((char *)a1 + 26, v13, v12))
        {
          int v15 = *((_DWORD *)a1 + 5);
          int v16 = *((_DWORD *)a1 + 3);
          uint64_t v17 = malloc_type_malloc(v14 + 21, 0x18AD45BuLL);
          v17[4] = v14;
          *((unsigned char *)v17 + v14 + 20) = 0;
          memcpy(v17 + 5, v11, v14);
          v17[1] = 1065353216;
          v17[2] = v15;
          *uint64_t v17 = v16;
          v17[3] = 1;
          char v6 = sub_19E5021D4((float *)v17, a5, a6);
          int v18 = v17[3] - 1;
          v17[3] = v18;
          if (!v18) {
            free(v17);
          }
        }
        a1 = (uint64_t *)*a1;
      }
      while (a1);
    }
    else
    {
      char v6 = 1;
    }
  }
  else
  {
    char v6 = 0;
  }
  return v6 & 1;
}

void sub_19E502098(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, __CFBinaryHeap *a5)
{
  uint64_t v9 = a2 & 3;
  if (a1)
  {
    switch(v9)
    {
      case 3:
        int v10 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + a1 + 32);
        break;
      case 2:
        int v10 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + a1 + 4);
        break;
      case 1:
        int v10 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + a1 + 1028);
        break;
      default:
        return;
    }
  }
  else if (v9 == 2)
  {
    int v10 = *(_DWORD *)((a2 & 0xFFFFFFFFFFFFFFFCLL) + 8);
  }
  else
  {
    if (v9 != 1) {
      return;
    }
    int v10 = *(_DWORD *)(a2 & 0xFFFFFFFFFFFFFFFCLL);
  }
  unsigned int v11 = malloc_type_malloc(a4 + 25, 0x752CEB8EuLL);
  *(void *)unsigned int v11 = a2;
  v11[2] = v10;
  v11[3] = 1;
  v11[4] = a4;
  *((unsigned char *)v11 + a4 + 20) = 0;
  memcpy(v11 + 5, a3, a4);
  CFBinaryHeapAddValue(a5, v11);
  int v12 = v11[3] - 1;
  v11[3] = v12;
  if (!v12)
  {
    free(v11);
  }
}

uint64_t sub_19E5021D4(float *value, __CFBinaryHeap *a2, CFBinaryHeapRef heap)
{
  if (CFBinaryHeapContainsValue(heap, value) || CFBinaryHeapGetCount(heap) < 10) {
    goto LABEL_13;
  }
  Minimum = (float *)CFBinaryHeapGetMinimum(heap);
  char v7 = (float *)CFBinaryHeapGetMinimum(a2);
  float v8 = 0.0;
  float v9 = 0.0;
  if (value) {
    float v9 = *value;
  }
  if (Minimum) {
    float v8 = *Minimum;
  }
  if (v9 > v8 || v7 && (!Minimum ? (float v10 = 0.0) : (float v10 = *Minimum), v10 < v7[2])) {
LABEL_13:
  }
    uint64_t v11 = 1;
  else {
    uint64_t v11 = 0;
  }
  if (!CFBinaryHeapContainsValue(heap, value))
  {
    if (CFBinaryHeapGetCount(heap) < 10)
    {
LABEL_24:
      CFBinaryHeapAddValue(heap, value);
      return v11;
    }
    int v12 = (float *)CFBinaryHeapGetMinimum(heap);
    float v13 = 0.0;
    float v14 = 0.0;
    if (v12) {
      float v14 = *v12;
    }
    if (value) {
      float v13 = *value;
    }
    if (v14 < v13)
    {
      uint64_t v15 = (4 * *((_DWORD *)v12 + 2));
      int v16 = v12 + 5;
      size_t v17 = *((unsigned int *)v12 + 4);
      float v18 = *v12;
      int v19 = (float *)malloc_type_malloc(v17 + 25, 0x752CEB8EuLL);
      *(void *)int v19 = v15;
      v19[2] = v18;
      *((_DWORD *)v19 + 3) = 1;
      *((_DWORD *)v19 + 4) = v17;
      *((unsigned char *)v19 + v17 + 20) = 0;
      memcpy(v19 + 5, v16, v17);
      CFBinaryHeapAddValue(a2, v19);
      int v20 = *((_DWORD *)v19 + 3) - 1;
      *((_DWORD *)v19 + 3) = v20;
      if (!v20) {
        free(v19);
      }
      CFBinaryHeapRemoveMinimumValue(heap);
      goto LABEL_24;
    }
    uint64_t v22 = (4 * *((_DWORD *)value + 2));
    int v23 = (char *)(value + 5);
    size_t v24 = *((unsigned int *)value + 4);
    float v25 = *value;
    int v26 = (float *)malloc_type_malloc(v24 + 25, 0x752CEB8EuLL);
    *(void *)int v26 = v22;
    v26[2] = v25;
    *((_DWORD *)v26 + 3) = 1;
    *((_DWORD *)v26 + 4) = v24;
    *((unsigned char *)v26 + v24 + 20) = 0;
    memcpy(v26 + 5, v23, v24);
    CFBinaryHeapAddValue(a2, v26);
    int v27 = *((_DWORD *)v26 + 3) - 1;
    *((_DWORD *)v26 + 3) = v27;
    if (!v27) {
      free(v26);
    }
  }
  return v11;
}

BOOL sub_19E5023E0(uint64_t a1, CFBinaryHeapRef heap, __CFBinaryHeap *a3)
{
  char v6 = (void *)(a1 + 2084);
  do
  {
    CFIndex Count = CFBinaryHeapGetCount(heap);
    if (!Count) {
      break;
    }
    Minimum = (char *)CFBinaryHeapGetMinimum(heap);
    float v9 = Minimum;
    if (Minimum) {
      ++*((_DWORD *)Minimum + 3);
    }
    CFBinaryHeapRemoveMinimumValue(heap);
    unint64_t v10 = *(void *)v9;
    uint64_t v11 = *(void *)v9 & 3;
    if (!v11)
    {
      unint64_t v15 = v10 >> 2;
      size_t v16 = *((unsigned int *)v9 + 4);
      unsigned int v17 = *((_DWORD *)v9 + 2);
      float v18 = malloc_type_malloc(v16 + 21, 0x18AD45BuLL);
      v18[4] = v16;
      *((unsigned char *)v18 + v16 + 20) = 0;
      memcpy(v18 + 5, v9 + 20, v16);
      v18[1] = 1065353216;
      unsigned char v18[2] = v15;
      _DWORD *v18 = v17;
      v18[3] = 1;
      char v19 = sub_19E5021D4((float *)v18, heap, a3);
      int v20 = v18[3] - 1;
      v18[3] = v20;
      if (!v20) {
        free(v18);
      }
      goto LABEL_20;
    }
    if (*v6)
    {
      int v12 = (int8x8_t *)((v10 & 0xFFFFFFFFFFFFFFFCLL) + *v6);
      float v13 = (unsigned __int8 *)(v9 + 20);
      if (v11 == 3)
      {
        char v14 = sub_19E5025F4(a1, v12, v13, *((_DWORD *)v9 + 4), *((_DWORD *)v9 + 4), heap, a3);
      }
      else if (v11 == 1)
      {
        char v14 = sub_19E5019BC(a1, v12);
      }
      else
      {
        char v14 = sub_19E502A08(a1, (unsigned int *)v12, (char *)v13, *((_DWORD *)v9 + 4), *((_DWORD *)v9 + 4), heap, a3);
      }
    }
    else if (v11 == 2)
    {
      char v14 = sub_19E501ED4((uint64_t *)(v10 & 0xFFFFFFFFFFFFFFFCLL), v9 + 20, *((_DWORD *)v9 + 4), *((_DWORD *)v9 + 4), heap, a3);
    }
    else
    {
      if (v11 != 1)
      {
        char v19 = 1;
        goto LABEL_20;
      }
      char v14 = sub_19E501C64(a1, v10 & 0xFFFFFFFFFFFFFFFCLL, (unsigned __int8 *)v9 + 20, *((_DWORD *)v9 + 4), *((_DWORD *)v9 + 4), heap, a3);
    }
    char v19 = v14;
LABEL_20:
    int v21 = *((_DWORD *)v9 + 3) - 1;
    *((_DWORD *)v9 + 3) = v21;
    if (!v21) {
      free(v9);
    }
  }
  while ((v19 & 1) != 0);
  return Count == 0;
}

uint64_t sub_19E5025F4(uint64_t a1, int8x8_t *a2, unsigned __int8 *a3, unsigned int a4, unsigned int a5, __CFBinaryHeap *a6, __CFBinaryHeap *a7)
{
  if (a5 >= a4)
  {
LABEL_13:
    *(void *)int v44 = a1;
    if (qword_1E9459D80 != -1) {
      dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
    }
    float v25 = pthread_getspecific(qword_1E9459D78);
    if (!v25)
    {
      float v25 = malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
      pthread_setspecific(qword_1E9459D78, v25);
    }
    if ((int)(a4 + 1) <= 1023)
    {
      memcpy(v25, a3, a4);
      unsigned int v32 = 0;
      *((unsigned char *)v25 + (int)(a4 + 1)) = 0;
      do
      {
        if (v32 >> 6 <= 1) {
          int v36 = 1;
        }
        else {
          int v36 = v32 >> 6;
        }
        int8x8_t v37 = a2[v32 >> 6];
        if (((1 << v32) & *(void *)&v37) != 0)
        {
          if (v32 <= 0x3F)
          {
            __int32 v33 = 0;
          }
          else
          {
            uint8x8_t v38 = (uint8x8_t)vcnt_s8(*a2);
            v38.i16[0] = vaddlv_u8(v38);
            __int32 v33 = v38.i32[0];
            if (v32 >= 0x80)
            {
              uint8x8_t v39 = (uint8x8_t)vcnt_s8(a2[1]);
              v39.i16[0] = vaddlv_u8(v39);
              v33 += v39.i32[0];
              if (v36 != 2)
              {
                uint8x8_t v40 = (uint8x8_t)vcnt_s8(a2[2]);
                v40.i16[0] = vaddlv_u8(v40);
                v33 += v40.i32[0];
              }
            }
          }
          uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)(((1 << v32) - 1) & *(void *)&v37));
          v34.i16[0] = vaddlv_u8(v34);
          uint64_t v35 = a2[5].u32[v33 + v34.i32[0] + 1];
          *((unsigned char *)v25 + a4) = v32;
          sub_19E502098(*(void *)(*(void *)v44 + 2084), v35, v25, a4 + 1, a6);
        }
        ++v32;
      }
      while (v32 != 256);
    }
    __int32 v26 = a2[5].i32[0];
    if (!v26) {
      goto LABEL_21;
    }
    __int32 v27 = a2[4].i32[1];
    unsigned int v28 = malloc_type_malloc(a4 + 21, 0x18AD45BuLL);
    v28[4] = a4;
    *((unsigned char *)v28 + a4 + 20) = 0;
    memcpy(v28 + 5, a3, a4);
    v28[1] = 1065353216;
    v28[2] = v26;
    *unsigned int v28 = v27;
    v28[3] = 1;
    int v29 = sub_19E5021D4((float *)v28, a6, a7);
    int v30 = v29;
    int v31 = v28[3] - 1;
    v28[3] = v31;
    if (v31)
    {
      if (v29)
      {
LABEL_21:
        return sub_19E5023E0(v44[0], a6);
      }
    }
    else
    {
      free(v28);
      if (v30) {
        goto LABEL_21;
      }
    }
    return 0;
  }
  int v12 = (void *)(a1 + 2084);
  uint64_t v13 = a5;
  while (1)
  {
    unint64_t v14 = a3[v13];
    unint64_t v15 = v14 >> 6;
    int8x8_t v16 = a2[v14 >> 6];
    uint64_t result = 1;
    if (((1 << v14) & *(void *)&v16) == 0) {
      return result;
    }
    if (v14 >= 0x40)
    {
      uint8x8_t v19 = (uint8x8_t)vcnt_s8(*a2);
      v19.i16[0] = vaddlv_u8(v19);
      __int32 v18 = v19.i32[0];
      if ((v14 & 0x80) != 0)
      {
        if (v15 <= 1) {
          LODWORD(v15) = 1;
        }
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(a2[1]);
        v20.i16[0] = vaddlv_u8(v20);
        v18 += v20.i32[0];
        if (v15 != 2)
        {
          uint8x8_t v21 = (uint8x8_t)vcnt_s8(a2[2]);
          v21.i16[0] = vaddlv_u8(v21);
          v18 += v21.i32[0];
        }
      }
    }
    else
    {
      __int32 v18 = 0;
    }
    uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)(((1 << v14) - 1) & *(void *)&v16));
    v22.i16[0] = vaddlv_u8(v22);
    __int32 v23 = a2[5].i32[v18 + v22.i32[0] + 1];
    int v24 = v23 & 3;
    if (v24 != 3)
    {
      if (v24 == 1)
      {
        uint64_t v42 = (v23 & 0xFFFFFFFC) + *v12;
        return sub_19E5019BC(a1, v42);
      }
      else if (v24 == 2)
      {
        uint8x8_t v41 = (unsigned int *)((v23 & 0xFFFFFFFC) + *v12);
        return sub_19E502A08(a1, v41, (char *)a3, a4, (int)v13 + 1, a6, a7);
      }
      else
      {
        return 1;
      }
    }
    a2 = (int8x8_t *)((v23 & 0xFFFFFFFC) + *v12);
    if (a4 == ++v13) {
      goto LABEL_13;
    }
  }
}

uint64_t sub_19E502A08(uint64_t a1, unsigned int *a2, char *a3, unsigned int a4, unsigned int a5, __CFBinaryHeap *a6, __CFBinaryHeap *a7)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  unsigned int v48 = *a2;
  if (qword_1E9459D80 != -1) {
    dispatch_once(&qword_1E9459D80, &unk_1EF0BEED8);
  }
  int v12 = (char *)pthread_getspecific(qword_1E9459D78);
  if (!v12)
  {
    int v12 = (char *)malloc_type_malloc(0x400uLL, 0x55DFA995uLL);
    pthread_setspecific(qword_1E9459D78, v12);
  }
  int v13 = a4 - a5;
  unsigned int v47 = a5;
  if ((*(unsigned char *)(a1 + 2068) & 2) != 0)
  {
    if (a4 <= 0x3FF)
    {
      unsigned int v23 = a4;
      memcpy(v12, a3, a4);
      std::string __dst = &v12[a4];
      *std::string __dst = 0;
      memset(__s1, 0, sizeof(__s1));
      if (v48)
      {
        int v24 = 0;
        unsigned int v25 = 0;
        unsigned int v42 = v47 - a4;
        __s2a = &a3[v47];
        while (1)
        {
          __int32 v27 = (char *)a2 + v25;
          uint64_t v28 = v27[18];
          if (v24)
          {
            uint64_t v29 = v24[10];
            if (v28 > v29) {
              memcpy((char *)__s1 + v29, v24 + 11, v28 - v29);
            }
          }
          int v24 = v27 + 8;
          int v30 = *((unsigned __int16 *)v27 + 8);
          if (v30 + (int)v28 >= v13)
          {
            if (v23 == v47 || ((int)v28 >= v13 ? (int v26 = v13) : (int v26 = v28), !memcmp(__s1, __s2a, v26)))
            {
              int v31 = v13 - v28;
              if (v13 == v28) {
                goto LABEL_32;
              }
              if (v30 < v31) {
                int v31 = v30;
              }
              if (!memcmp(v27 + 19, &__s2a[v28], v31))
              {
LABEL_32:
                unsigned int v32 = v28 + v47;
                int v33 = v28 + v47 - v23;
                if (v33 < 1)
                {
                  unsigned int v32 = v23;
                }
                else
                {
                  memcpy(__dst, (char *)__s1 + v28 - v33, v32 - v23);
                  int v30 = *((unsigned __int16 *)v24 + 4);
                  LODWORD(v28) = v24[10];
                }
                int v34 = v42 + v30 + v28;
                if (v34 >= 1)
                {
                  int v35 = v34 - (v33 & ~(v33 >> 31));
                  memcpy(&v12[v32], &v24[v30 - v35 + 11], v35);
                  v32 += v35;
                }
                v12[v32] = 0;
                int v36 = *((_DWORD *)v24 + 1);
                int v37 = *(_DWORD *)v24;
                uint8x8_t v38 = malloc_type_malloc(v32 + 21, 0x18AD45BuLL);
                v38[4] = v32;
                *((unsigned char *)v38 + v32 + 20) = 0;
                memcpy(v38 + 5, v12, v32);
                v38[1] = 1065353216;
                v38[2] = v36;
                *uint8x8_t v38 = v37;
                v38[3] = 1;
                LODWORD(a3) = sub_19E5021D4((float *)v38, a6, a7);
                int v39 = v38[3] - 1;
                v38[3] = v39;
                if (!v39) {
                  free(v38);
                }
                if (!a3) {
                  return a3 & 1;
                }
                int v30 = *((unsigned __int16 *)v24 + 4);
              }
            }
          }
          v25 += v30 + 11;
          if (v25 >= v48) {
            goto LABEL_41;
          }
        }
      }
      goto LABEL_41;
    }
LABEL_15:
    LOBYTE(a3) = 0;
    return a3 & 1;
  }
  if (a5 > 0x3FF) {
    goto LABEL_15;
  }
  memcpy(v12, a3, a5);
  unint64_t v14 = &v12[a5];
  *unint64_t v14 = 0;
  if (!v48)
  {
LABEL_41:
    LOBYTE(a3) = 1;
    return a3 & 1;
  }
  unsigned int v15 = 0;
  __s2 = &a3[a5];
  LOBYTE(a3) = 1;
  do
  {
    int8x8_t v16 = (char *)a2 + v15;
    unsigned int v17 = v16 + 8;
    memcpy(v14, v16 + 18, *((unsigned __int16 *)v16 + 8));
    size_t v18 = *((unsigned __int16 *)v16 + 8) + (unint64_t)a5;
    v12[v18] = 0;
    if (v13 <= *((unsigned __int16 *)v16 + 8) && !memcmp(v16 + 18, __s2, v13))
    {
      int v19 = *((_DWORD *)v16 + 3);
      int v20 = *(_DWORD *)v17;
      uint8x8_t v21 = malloc_type_malloc(v18 + 21, 0x18AD45BuLL);
      v21[4] = v18;
      *((unsigned char *)v21 + v18 + 20) = 0;
      memcpy(v21 + 5, v12, v18);
      v21[1] = 1065353216;
      v21[2] = v19;
      *uint8x8_t v21 = v20;
      v21[3] = 1;
      LOBYTE(a3) = sub_19E5021D4((float *)v21, a6, a7);
      int v22 = v21[3] - 1;
      v21[3] = v22;
      if (!v22) {
        free(v21);
      }
    }
    v15 += *((unsigned __int16 *)v17 + 4) + 10;
    a5 = v47;
  }
  while (v15 < v48);
  return a3 & 1;
}

uint64_t sub_19E502E4C(uint64_t a1, uint64_t a2)
{
  if (*(float *)a1 != *(float *)a2)
  {
    if (*(float *)a1 >= *(float *)a2) {
      return 1;
    }
    else {
      return -1;
    }
  }
  size_t v2 = *(unsigned int *)(a1 + 16);
  int v3 = *(_DWORD *)(a2 + 16);
  if (v2 != v3)
  {
    int v4 = v2 - v3;
LABEL_15:
    if (v4 < 0) {
      return -1;
    }
    else {
      return 1;
    }
  }
  int v4 = *(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8);
  if (v4) {
    goto LABEL_15;
  }
  int v5 = memcmp((const void *)(a1 + 20), (const void *)(a2 + 20), v2);
  uint64_t v6 = -1;
  if (v5 >= 0) {
    uint64_t v6 = 1;
  }
  if (v5) {
    return v6;
  }
  else {
    return 0;
  }
}

void sub_19E502ED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v5 = a2;
  uint64_t v6 = a1;
  uint64_t v7 = 0;
  unsigned int __fd = a4;
  do
  {
    uint64_t v8 = v5 + 8 * v7;
    uint64_t v11 = *(void *)(v8 + 16);
    unint64_t v10 = (uint64_t *)(v8 + 16);
    uint64_t v9 = v11;
    uint64_t v12 = v11 & 3;
    if (v12 != 2)
    {
      if (v12 == 1) {
        sub_19E502ED8(v6, v9 & 0xFFFFFFFFFFFFFFFCLL, a3, v4);
      }
      goto LABEL_2;
    }
    int v13 = (_DWORD *)(v9 & 0xFFFFFFFFFFFFFFFCLL);
    int v14 = lseek(v4, 0, 1);
    unsigned int v15 = *(_DWORD *)(v6 + 2092);
    if (v15 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v15;
    }
    int v17 = v13[2];
    size_t v18 = malloc_type_malloc(1035 * v16 + 8, 0x774667DFuLL);
    size_t v19 = 8 * v16;
    uint64_t v76 = v10;
    uint64_t v77 = v7;
    int v75 = v14;
    if ((*(unsigned char *)(v6 + 2068) & 2) != 0)
    {
      uint8x8_t v38 = (int8x16_t *)operator new(v19);
      int v39 = (int8x16_t *)((char *)v38 + 8 * v16);
      int v22 = v38;
      uint8x8_t v40 = v13;
      while (1)
      {
        while (v38 < v39)
        {
          v38->i64[0] = (uint64_t)v40;
          uint8x8_t v38 = (int8x16_t *)((char *)v38 + 8);
          uint8x8_t v40 = (void *)*v40;
          if (!v40) {
            goto LABEL_80;
          }
        }
        uint64_t v41 = ((char *)v38 - (char *)v22) >> 3;
        unint64_t v42 = v41 + 1;
        if ((unint64_t)(v41 + 1) >> 61) {
          sub_19E37C7C4();
        }
        if (((char *)v39 - (char *)v22) >> 2 > v42) {
          unint64_t v42 = ((char *)v39 - (char *)v22) >> 2;
        }
        if ((unint64_t)((char *)v39 - (char *)v22) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v43 = v42;
        }
        if (v43)
        {
          if (v43 >> 61) {
            sub_19E37C2B8();
          }
          int v44 = operator new(8 * v43);
        }
        else
        {
          int v44 = 0;
        }
        BOOL v45 = &v44[8 * v41];
        int v39 = (int8x16_t *)&v44[8 * v43];
        *BOOL v45 = v40;
        char v46 = (int8x16_t *)(v45 + 1);
        if (v38 == v22)
        {
LABEL_59:
          operator delete(v22);
          goto LABEL_60;
        }
        unint64_t v47 = (char *)&v38[-1].u64[1] - (char *)v22;
        if (v47 < 0x168)
        {
          unsigned int v48 = v38;
          goto LABEL_57;
        }
        if (&v44[(char *)v38 - (char *)v22 - 8 - (v47 & 0xFFFFFFFFFFFFFFF8)] > &v44[(char *)v38 - (char *)v22 - 8]) {
          break;
        }
        if ((unint64_t *)((char *)&v38[-1].u64[1] - (v47 & 0xFFFFFFFFFFFFFFF8)) > &v38[-1].u64[1])
        {
          unsigned int v48 = v38;
          goto LABEL_57;
        }
        if ((unint64_t)((char *)v22 - v44) < 0x20)
        {
          unsigned int v48 = v38;
          goto LABEL_57;
        }
        uint64_t v50 = (v47 >> 3) + 1;
        unsigned int v48 = (int8x16_t *)((char *)v38 - 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL));
        unsigned int v51 = (int8x16_t *)&v44[8 * v41 - 16];
        uint64_t v52 = v38 - 1;
        uint64_t v53 = v50 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          int8x16_t v54 = *v52;
          v51[-1] = v52[-1];
          *unsigned int v51 = v54;
          v51 -= 2;
          v52 -= 2;
          v53 -= 4;
        }
        while (v53);
        v45 -= v50 & 0x3FFFFFFFFFFFFFFCLL;
        if (v50 != (v50 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_57;
        }
LABEL_58:
        if (v22) {
          goto LABEL_59;
        }
LABEL_60:
        int v22 = (int8x16_t *)v45;
        uint8x8_t v38 = v46;
        uint8x8_t v40 = (void *)*v40;
        if (!v40)
        {
LABEL_80:
          unint64_t v61 = 126 - 2 * __clz(((char *)v38 - (char *)v22) >> 3);
          uint64_t v79 = sub_19E50386C;
          if (v38 == v22) {
            uint64_t v62 = 0;
          }
          else {
            uint64_t v62 = v61;
          }
          sub_19E4FF6A0((uint64_t)v22, v38, (unsigned int (**)(uint64_t))&v79, v62, 1);
          if (v38 == v22)
          {
            unsigned int v57 = 0;
          }
          else
          {
            unsigned int v57 = 0;
            uint64_t v63 = 0;
            char v64 = v22;
            do
            {
              uint64_t v69 = v63;
              uint64_t v63 = v64->i64[0];
              if (!v69)
              {
                unsigned int v65 = 0;
                LOWORD(v66) = *(_WORD *)(v63 + 24);
                goto LABEL_86;
              }
              uint64_t v70 = 0;
              uint64_t v66 = *(unsigned __int16 *)(v63 + 24);
              unsigned int v65 = *(_WORD *)(v63 + 24);
              while (1)
              {
                if (v66 == v70) {
                  goto LABEL_86;
                }
                if (*(unsigned __int16 *)(v69 + 24) <= (unsigned __int16)v70
                  || *(unsigned __int8 *)(v63 + 26 + v70) != *(unsigned __int8 *)(v69 + 26 + v70))
                {
                  break;
                }
                if (++v70 == 255)
                {
                  unsigned int v65 = 255;
                  goto LABEL_86;
                }
              }
              unsigned int v65 = v70;
LABEL_86:
              uint64_t v67 = (char *)v18 + v57;
              unsigned __int16 v68 = v66 - v65;
              *((_WORD *)v67 + 8) = v68;
              *((_DWORD *)v67 + 2) = *(_DWORD *)(v63 + 12);
              *((_DWORD *)v67 + 3) = *(_DWORD *)(v63 + 20);
              v67[18] = v65;
              memcpy(v67 + 19, (const void *)(v63 + v65 + 26), v68);
              unsigned int v57 = v57 - v65 + *(unsigned __int16 *)(v63 + 24) + 11;
              char v64 = (int8x16_t *)((char *)v64 + 8);
            }
            while (v64 != v38);
          }
          uint64_t v4 = __fd;
          if (!v22) {
            goto LABEL_98;
          }
LABEL_97:
          operator delete(v22);
          goto LABEL_98;
        }
      }
      unsigned int v48 = v38;
      do
      {
LABEL_57:
        uint64_t v49 = v48[-1].i64[1];
        unsigned int v48 = (int8x16_t *)((char *)v48 - 8);
        *--BOOL v45 = v49;
      }
      while (v48 != v22);
      goto LABEL_58;
    }
    int v20 = (int8x16_t *)operator new(v19);
    uint8x8_t v21 = (int8x16_t *)((char *)v20 + 8 * v16);
    int v22 = v20;
    unsigned int v23 = v13;
    do
    {
      while (v20 < v21)
      {
        v20->i64[0] = (uint64_t)v23;
        int v20 = (int8x16_t *)((char *)v20 + 8);
        unsigned int v23 = (void *)*v23;
        if (!v23) {
          goto LABEL_72;
        }
      }
      uint64_t v24 = ((char *)v20 - (char *)v22) >> 3;
      unint64_t v25 = v24 + 1;
      if ((unint64_t)(v24 + 1) >> 61) {
        sub_19E37C7C4();
      }
      if (((char *)v21 - (char *)v22) >> 2 > v25) {
        unint64_t v25 = ((char *)v21 - (char *)v22) >> 2;
      }
      if ((unint64_t)((char *)v21 - (char *)v22) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v25;
      }
      if (v26)
      {
        if (v26 >> 61) {
          sub_19E37C2B8();
        }
        __int32 v27 = operator new(8 * v26);
      }
      else
      {
        __int32 v27 = 0;
      }
      uint64_t v28 = &v27[8 * v24];
      uint8x8_t v21 = (int8x16_t *)&v27[8 * v26];
      *uint64_t v28 = v23;
      uint64_t v29 = (int8x16_t *)(v28 + 1);
      if (v20 != v22)
      {
        unint64_t v30 = (char *)&v20[-1].u64[1] - (char *)v22;
        if (v30 >= 0x168)
        {
          if (&v27[(char *)v20 - (char *)v22 - 8 - (v30 & 0xFFFFFFFFFFFFFFF8)] > &v27[(char *)v20 - (char *)v22 - 8])
          {
            int v31 = v20;
          }
          else if ((unint64_t *)((char *)&v20[-1].u64[1] - (v30 & 0xFFFFFFFFFFFFFFF8)) > &v20[-1].u64[1])
          {
            int v31 = v20;
          }
          else if ((unint64_t)((char *)v22 - v27) >= 0x20)
          {
            uint64_t v33 = (v30 >> 3) + 1;
            int v31 = (int8x16_t *)((char *)v20 - 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL));
            int v34 = (int8x16_t *)&v27[8 * v24 - 16];
            int v35 = v20 - 1;
            uint64_t v36 = v33 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              int8x16_t v37 = *v35;
              v34[-1] = v35[-1];
              *int v34 = v37;
              v34 -= 2;
              v35 -= 2;
              v36 -= 4;
            }
            while (v36);
            v28 -= v33 & 0x3FFFFFFFFFFFFFFCLL;
            if (v33 == (v33 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_27:
              if (!v22) {
                goto LABEL_29;
              }
              goto LABEL_28;
            }
          }
          else
          {
            int v31 = v20;
          }
        }
        else
        {
          int v31 = v20;
        }
        do
        {
          uint64_t v32 = v31[-1].i64[1];
          int v31 = (int8x16_t *)((char *)v31 - 8);
          *--uint64_t v28 = v32;
        }
        while (v31 != v22);
        goto LABEL_27;
      }
LABEL_28:
      operator delete(v22);
LABEL_29:
      int v22 = (int8x16_t *)v28;
      int v20 = v29;
      unsigned int v23 = (void *)*v23;
    }
    while (v23);
LABEL_72:
    unint64_t v55 = 126 - 2 * __clz(((char *)v20 - (char *)v22) >> 3);
    uint64_t v79 = sub_19E500690;
    if (v20 == v22) {
      uint64_t v56 = 0;
    }
    else {
      uint64_t v56 = v55;
    }
    sub_19E4FF6A0((uint64_t)v22, v20, (unsigned int (**)(uint64_t))&v79, v56, 1);
    uint64_t v4 = __fd;
    unsigned int v57 = 0;
    if (v20 != v22)
    {
      uint64_t v58 = v22;
      do
      {
        uint64_t v59 = v58->i64[0];
        uint64_t v58 = (int8x16_t *)((char *)v58 + 8);
        int v60 = (char *)v18 + v57;
        *((_WORD *)v60 + 8) = *(_WORD *)(v59 + 24);
        *((_DWORD *)v60 + 2) = *(_DWORD *)(v59 + 12);
        *((_DWORD *)v60 + 3) = *(_DWORD *)(v59 + 20);
        memcpy(v60 + 18, (const void *)(v59 + 26), *(unsigned __int16 *)(v59 + 24));
        v57 += *(unsigned __int16 *)(v59 + 24) + 10;
      }
      while (v58 != v20);
    }
    if (v22) {
      goto LABEL_97;
    }
LABEL_98:
    _DWORD *v18 = v57;
    v18[1] = v17;
    write(v4, v18, (v57 + 11) & 0x1FFFFFFFCLL);
    free(v18);
    do
    {
      unint64_t v71 = *(_DWORD **)v13;
      free(v13);
      int v13 = v71;
    }
    while (v71);
    uint64_t v7 = v77;
    uint64_t *v76 = (v75 - a3) | 2;
    uint64_t v6 = a1;
    uint64_t v5 = a2;
LABEL_2:
    ++v7;
  }
  while (v7 != 256);
}

void sub_19E503518(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E503544(_DWORD *a1, uint64_t a2, unsigned int a3, int a4, int a5, int *a6)
{
  unsigned int v37 = a3;
  uint64_t v10 = 0;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int32x4_t v11 = 0uLL;
  int32x4_t v12 = 0uLL;
  do
  {
    int32x4_t v11 = vsubq_s32(v11, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[v10 + 4]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[v10 + 8]))));
    int32x4_t v12 = vsubq_s32(v12, (int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[v10 + 12]), (int32x4_t)vceqzq_s64(*(int64x2_t *)&a1[v10 + 16]))));
    v10 += 16;
  }
  while (v10 != 512);
  unsigned int v13 = vaddvq_s32(vaddq_s32(v12, v11));
  if (v13 > 0xC7) {
    a5 = 1;
  }
  unsigned int v36 = a5;
  if (a5)
  {
    uint64_t v15 = 0;
    uint64_t v16 = *a6;
    *a6 = v16 + 1036;
    do
    {
      uint64_t v17 = *(void *)&a1[2 * v15 + 4];
      if ((v17 & 3) == 1)
      {
        int v18 = *a6;
        if (sub_19E503544(v17 & 0xFFFFFFFFFFFFFFFCLL, a2, v37, 1, 0, a6)) {
          int v19 = v18 | 1;
        }
        else {
          int v19 = v18 | 3;
        }
        v38[v15] = v19;
      }
      else
      {
        v38[v15] = v17;
      }
      ++v15;
    }
    while (v15 != 256);
    v38[256] = a1[3];
    uint64_t v39 = *(void *)a1;
    pwrite(v37, v38, 0x40CuLL, v16 + a2);
    if (a4) {
LABEL_26:
    }
      free(a1);
  }
  else
  {
    int v34 = a4;
    uint64_t v35 = v13;
    size_t v20 = 4 * v13 + 44;
    uint64_t v21 = *a6;
    MEMORY[0x1F4188790](a1, a2);
    unsigned int v23 = (int8x16_t *)((char *)&v31 - v22);
    bzero((char *)&v31 - v22, v20);
    bzero(v23, v20);
    uint64_t v24 = 0;
    int v25 = 0;
    uint64_t v32 = v21;
    size_t v33 = v20;
    *a6 = v21 + v20;
    do
    {
      uint64_t v26 = *(void *)&a1[2 * v24 + 4];
      if (v26)
      {
        v23->i64[v24 >> 6] |= 1 << v24;
        __int32 v27 = &v23->i8[4 * v25];
        if ((v26 & 3) == 1)
        {
          int v28 = *a6;
          if (sub_19E503544(v26 & 0xFFFFFFFFFFFFFFFCLL, a2, v37, 1, 0, a6)) {
            int v29 = v28 | 1;
          }
          else {
            int v29 = v28 | 3;
          }
          *((_DWORD *)v27 + 11) = v29;
        }
        else
        {
          *((_DWORD *)v27 + 11) = v26;
        }
        ++v25;
      }
      ++v24;
    }
    while (v24 != 256);
    if (vaddvq_s32(vuzp1q_s32((int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(*v23)))), (int32x4_t)vpaddlq_u32(vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8(v23[1])))))) != v35)__assert_rtn("completionTrieSerializeLevels", "LMCompletionTrie.cpp", 1734, "bitcount == count"); {
    v23[2].i32[2] = a1[3];
    }
    v23[2].i64[0] = *(void *)a1;
    pwrite(v37, v23, v33, v32 + a2);
    if (v34) {
      goto LABEL_26;
    }
  }
  return v36;
}

BOOL sub_19E50386C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 24);
  unsigned int v3 = *(unsigned __int16 *)(a1 + 24);
  if (v2 >= v3) {
    size_t v4 = *(unsigned __int16 *)(a1 + 24);
  }
  else {
    size_t v4 = *(unsigned __int16 *)(a2 + 24);
  }
  int v5 = memcmp((const void *)(a1 + 26), (const void *)(a2 + 26), v4);
  if (v5) {
    return v5 < 0;
  }
  else {
    return v3 < v2;
  }
}

void *sub_19E5038C0()
{
  return &unk_19E57CC58;
}

_DWORD *sub_19E5038CC(uint64_t a1, unsigned int *a2)
{
  unint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return (_DWORD *)(a1 + 32);
  }
  unsigned int v3 = *a2;
  size_t v4 = *(_DWORD **)(a1 + 48);
  int v5 = &v4[2 * v2];
  do
  {
    unint64_t v6 = v2 >> 1;
    uint64_t v7 = &v4[2 * (v2 >> 1)];
    unsigned int v9 = *v7;
    uint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      size_t v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != v5 && *v4 == v3) {
    return v4 + 1;
  }
  else {
    return (_DWORD *)(a1 + 32);
  }
}

uint64_t sub_19E503928(uint64_t a1)
{
  return a1 + 32;
}

void *sub_19E503930()
{
  return &unk_19E57CC58;
}

void sub_19E50393C(void *a1)
{
  *a1 = &unk_1EF0B9D20;
  unint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E5039B4(void *a1)
{
  *a1 = &unk_1EF0B9D20;
  unint64_t v2 = (void *)a1[1];
  if (v2) {
    munmap(v2, a1[2]);
  }
  a1[2] = 0;
  return a1;
}

uint64_t sub_19E503A0C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1EF0B9D20;
  unsigned int v3 = (void *)(a1 + 8);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    v62[0] = *(void *)(a2 + 16);
  }
  sub_19E452978(v3, (uint64_t)__p);
  if (SHIBYTE(v62[0]) < 0) {
    operator delete(__p[0]);
  }
  unint64_t v4 = *(void *)(a1 + 16);
  if (v4 <= 0x13)
  {
    sub_19E393108((uint64_t)__p);
    sub_19E37CA70(v62, (uint64_t)"(file_size=", 11);
    int32x4_t v12 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v12, (uint64_t)", offset=", 9);
    unsigned int v13 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v13, (uint64_t)", object_size=", 14);
    int v14 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v14, (uint64_t)")", 1);
    exception = __cxa_allocate_exception(0x10uLL);
    if ((v68 & 0x10) != 0)
    {
      unint64_t v51 = v67;
      if (v67 < v66)
      {
        unint64_t v67 = v66;
        unint64_t v51 = v66;
      }
      uint64_t v52 = (const void **)&v65;
    }
    else
    {
      if ((v68 & 8) == 0)
      {
        std::string::size_type v16 = 0;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
        p_dst = &__dst;
        goto LABEL_81;
      }
      uint64_t v52 = (const void **)v63;
      unint64_t v51 = v64;
    }
    uint64_t v53 = *v52;
    std::string::size_type v16 = v51 - (void)*v52;
    if (v16 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v16 >= 0x17)
    {
      uint64_t v54 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v16 | 7) != 0x17) {
        uint64_t v54 = v16 | 7;
      }
      uint64_t v55 = v54 + 1;
      p_dst = (std::string *)operator new(v54 + 1);
      __dst.__r_.__value_.__l.__size_ = v16;
      __dst.__r_.__value_.__r.__words[2] = v55 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v51 - *(unsigned char *)v52;
      p_dst = &__dst;
      if (!v16)
      {
LABEL_81:
        p_dst->__r_.__value_.__s.__data_[v16] = 0;
        uint64_t v56 = std::string::insert(&__dst, 0, "attempted to read beyond the end of the mapped file ", 0x34uLL);
        long long v57 = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
        unint64_t v60 = v56->__r_.__value_.__r.__words[2];
        long long v59 = v57;
        v56->__r_.__value_.__l.__size_ = 0;
        v56->__r_.__value_.__r.__words[2] = 0;
        v56->__r_.__value_.__r.__words[0] = 0;
        MEMORY[0x19F3BD7A0](exception, &v59);
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    memmove(p_dst, v53, v16);
    goto LABEL_81;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  int v6 = *(_DWORD *)(v5 + 16);
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v5;
  *(_DWORD *)(a1 + 40) = v6;
  unint64_t v7 = *(unsigned int *)(a1 + 36);
  BOOL v8 = v4 > v7;
  unint64_t v9 = v4 - v7;
  if (!v8)
  {
    sub_19E393108((uint64_t)__p);
    sub_19E37CA70(v62, (uint64_t)"(file_size=", 11);
    int v18 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v18, (uint64_t)", offset=", 9);
    int v19 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v19, (uint64_t)")", 1);
    size_t v20 = __cxa_allocate_exception(0x10uLL);
    if ((v68 & 0x10) != 0)
    {
      unint64_t v34 = v67;
      if (v67 < v66)
      {
        unint64_t v67 = v66;
        unint64_t v34 = v66;
      }
      uint64_t v35 = (const void **)&v65;
    }
    else
    {
      if ((v68 & 8) == 0)
      {
        std::string::size_type v21 = 0;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
        uint64_t v22 = &__dst;
        goto LABEL_57;
      }
      uint64_t v35 = (const void **)v63;
      unint64_t v34 = v64;
    }
    uint64_t v40 = *v35;
    std::string::size_type v21 = v34 - (void)*v35;
    if (v21 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v21 >= 0x17)
    {
      uint64_t v43 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v21 | 7) != 0x17) {
        uint64_t v43 = v21 | 7;
      }
      uint64_t v44 = v43 + 1;
      uint64_t v22 = (std::string *)operator new(v43 + 1);
      __dst.__r_.__value_.__l.__size_ = v21;
      __dst.__r_.__value_.__r.__words[2] = v44 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v34 - *(unsigned char *)v35;
      uint64_t v22 = &__dst;
      if (!v21)
      {
LABEL_57:
        v22->__r_.__value_.__s.__data_[v21] = 0;
        BOOL v45 = std::string::insert(&__dst, 0, "attempted to read beyond the end of the mapped file ", 0x34uLL);
        long long v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
        unint64_t v60 = v45->__r_.__value_.__r.__words[2];
        long long v59 = v46;
        v45->__r_.__value_.__l.__size_ = 0;
        v45->__r_.__value_.__r.__words[2] = 0;
        v45->__r_.__value_.__r.__words[0] = 0;
        MEMORY[0x19F3BD7A0](v20, &v59);
        __cxa_throw(v20, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    memmove(v22, v40, v21);
    goto LABEL_57;
  }
  unint64_t v10 = v9 >> 3;
  *(void *)(a1 + 48) = v5 + v7;
  *(void *)(a1 + 56) = v10;
  if (*(_DWORD *)(a1 + 24) != 952409662)
  {
    unsigned int v23 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v23, "Invalid blocklistID map: mismatched magic number");
    __cxa_throw(v23, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (*(_DWORD *)(a1 + 28) != 1)
  {
    sub_19E393108((uint64_t)__p);
    sub_19E37CA70(v62, (uint64_t)"Unsupported blocklistID map version (recorded=", 46);
    uint64_t v24 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v24, (uint64_t)", required=", 11);
    int v25 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v25, (uint64_t)")", 1);
    uint64_t v26 = __cxa_allocate_exception(0x10uLL);
    if ((v68 & 0x10) != 0)
    {
      unint64_t v36 = v67;
      if (v67 < v66)
      {
        unint64_t v67 = v66;
        unint64_t v36 = v66;
      }
      unsigned int v37 = (const void **)&v65;
    }
    else
    {
      if ((v68 & 8) == 0)
      {
        size_t v27 = 0;
        HIBYTE(v60) = 0;
        int v28 = &v59;
        goto LABEL_62;
      }
      unsigned int v37 = (const void **)v63;
      unint64_t v36 = v64;
    }
    uint64_t v41 = *v37;
    size_t v27 = v36 - (void)*v37;
    if (v27 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v27 >= 0x17)
    {
      uint64_t v47 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v27 | 7) != 0x17) {
        uint64_t v47 = v27 | 7;
      }
      uint64_t v48 = v47 + 1;
      int v28 = (long long *)operator new(v47 + 1);
      *((void *)&v59 + 1) = v27;
      unint64_t v60 = v48 | 0x8000000000000000;
      *(void *)&long long v59 = v28;
    }
    else
    {
      HIBYTE(v60) = v36 - *(unsigned char *)v37;
      int v28 = &v59;
      if (!v27)
      {
LABEL_62:
        *((unsigned char *)v28 + v27) = 0;
        MEMORY[0x19F3BD7A0](v26, &v59);
        __cxa_throw(v26, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    memmove(v28, v41, v27);
    goto LABEL_62;
  }
  if (v10 != *(_DWORD *)(a1 + 40))
  {
    sub_19E393108((uint64_t)__p);
    sub_19E37CA70(v62, (uint64_t)"Corrupt blocklistID map: entry count mismatch (recorded=", 56);
    int v29 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v29, (uint64_t)", actual=", 9);
    unint64_t v30 = (void *)std::ostream::operator<<();
    sub_19E37CA70(v30, (uint64_t)")", 1);
    uint64_t v31 = __cxa_allocate_exception(0x10uLL);
    if ((v68 & 0x10) != 0)
    {
      unint64_t v38 = v67;
      if (v67 < v66)
      {
        unint64_t v67 = v66;
        unint64_t v38 = v66;
      }
      uint64_t v39 = (const void **)&v65;
    }
    else
    {
      if ((v68 & 8) == 0)
      {
        size_t v32 = 0;
        HIBYTE(v60) = 0;
        size_t v33 = &v59;
        goto LABEL_67;
      }
      uint64_t v39 = (const void **)v63;
      unint64_t v38 = v64;
    }
    unint64_t v42 = *v39;
    size_t v32 = v38 - (void)*v39;
    if (v32 > 0x7FFFFFFFFFFFFFF7) {
      sub_19E37C958();
    }
    if (v32 >= 0x17)
    {
      uint64_t v49 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v32 | 7) != 0x17) {
        uint64_t v49 = v32 | 7;
      }
      uint64_t v50 = v49 + 1;
      size_t v33 = (long long *)operator new(v49 + 1);
      *((void *)&v59 + 1) = v32;
      unint64_t v60 = v50 | 0x8000000000000000;
      *(void *)&long long v59 = v33;
    }
    else
    {
      HIBYTE(v60) = v38 - *(unsigned char *)v39;
      size_t v33 = &v59;
      if (!v32)
      {
LABEL_67:
        *((unsigned char *)v33 + v32) = 0;
        MEMORY[0x19F3BD7A0](v31, &v59);
        __cxa_throw(v31, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    memmove(v33, v42, v32);
    goto LABEL_67;
  }
  return a1;
}

void sub_19E50416C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v45 & 1) == 0) {
      goto LABEL_8;
    }
  }
  else if (!v45)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v44);
LABEL_8:
  a23 = *MEMORY[0x1E4FBA408];
  uint64_t v47 = *(void *)(MEMORY[0x1E4FBA408] + 72);
  *(uint64_t *)((char *)&a23 + *(void *)(a23 - 24)) = *(void *)(MEMORY[0x1E4FBA408] + 64);
  a25 = v47;
  a26 = MEMORY[0x1E4FBA470] + 16;
  if (a39 < 0) {
    operator delete(a34);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x19F3BDC30](&a42);
  if (*v43) {
    munmap(*v43, *(void *)(v42 + 16));
  }
  *(void *)(v42 + 16) = 0;
  _Unwind_Resume(a1);
}

void sub_19E50437C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a22 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x19E504374);
}

unint64_t sub_19E50439C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 80);
  uint64_t v7 = *(void *)(a1 + 272);
  uint64_t v8 = v7 + 72 * v6;
  float v38 = *(float *)v8;
  unint64_t v9 = (void **)(v8 + 8);
  if (*(char *)(v8 + 31) < 0)
  {
    sub_19E39369C(&__p, *v9, *(void *)(v7 + 72 * v6 + 16));
  }
  else
  {
    long long v10 = *(_OWORD *)v9;
    uint64_t v40 = *(void *)(v8 + 24);
    long long __p = v10;
  }
  uint64_t v11 = v7 + 72 * v6;
  long long v41 = *(_OWORD *)(v11 + 32);
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v42 = 0;
  unsigned int v13 = *(unsigned char **)(v11 + 48);
  int32x4_t v12 = *(unsigned char **)(v11 + 56);
  double v14 = -10.0;
  uint64_t v15 = v12 - v13;
  if (v12 == v13)
  {
    unint64_t v17 = 0;
    std::string::size_type v16 = 0;
LABEL_14:
    int v19 = 0;
    goto LABEL_26;
  }
  if (v15 < 0) {
    sub_19E37C7C4();
  }
  std::string::size_type v16 = (char *)operator new(v12 - v13);
  unint64_t v17 = v15 >> 3;
  uint64_t v42 = v16;
  uint64_t v43 = v16;
  uint64_t v44 = &v16[8 * (v15 >> 3)];
  size_t v18 = v15 & 0xFFFFFFFFFFFFFFF8;
  memcpy(v16, v13, v18);
  uint64_t v43 = &v16[v18];
  if (!v18) {
    goto LABEL_14;
  }
  int v19 = (float *)operator new(v18);
  memcpy(v19, v16, v18);
  if (a2)
  {
    if (v17 <= 1) {
      unint64_t v20 = 1;
    }
    else {
      unint64_t v20 = v17;
    }
    if (v20 > 8)
    {
      uint64_t v22 = v20 & 7;
      if ((v20 & 7) == 0) {
        uint64_t v22 = 8;
      }
      unint64_t v21 = v20 - v22;
      unsigned int v23 = (unsigned long long *)(a2 + 16);
      uint64_t v24 = v19 + 8;
      unint64_t v25 = v21;
      do
      {
        uint64_t v26 = v24 - 8;
        unsigned long long v27 = (unsigned __int128)vld2q_f32(v26);
        unsigned long long v28 = (unsigned __int128)vld2q_f32(v24);
        *(v23 - 1) = v27;
        *unsigned int v23 = v28;
        v23 += 2;
        v24 += 16;
        v25 -= 8;
      }
      while (v25);
    }
    else
    {
      unint64_t v21 = 0;
    }
    unint64_t v29 = v20 - v21;
    unint64_t v30 = (_DWORD *)(a2 + 4 * v21);
    uint64_t v31 = &v19[2 * v21];
    do
    {
      int v32 = *(_DWORD *)v31;
      v31 += 2;
      *v30++ = v32;
      --v29;
    }
    while (v29);
  }
  if (v38 > 0.0)
  {
    float v33 = log10f(*(float *)&v16[v18 - 4] / v38);
    double v34 = 1.0;
    if (v17 != 1)
    {
      if (!v17) {
        __assert_rtn("normalizationFactor", "LMDynamicInlineCompletionEnumerator.hpp", 78, "numWords >= 1");
      }
      float v35 = 1.15368974 / (float)(sqrtf((float)v17 + 0.1) * (float)((float)v17 + 0.1));
      double v34 = v35;
    }
    double v14 = v34 * v33;
  }
LABEL_26:
  if (a3)
  {
    uint64_t v36 = (uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 104) = v36;
    *(void *)(a3 + 8) = 0xFFEFFFFFFFFFFFFFLL;
    *(void *)(a3 + 16) = 0;
    *(_WORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 1;
    *(_OWORD *)(a3 + 40) = xmmword_19E572FD0;
    *(_DWORD *)(a3 + 56) = 0;
    *(void *)(a3 + 88) = 0;
    *(double *)a3 = v14;
    *(_DWORD *)(a3 + 116) = *(_DWORD *)(a1 + 72);
    *(unsigned char *)(a3 + 112) = 1;
    *(_OWORD *)(a3 + 72) = xmmword_19E5731A0;
    *(double *)(a3 + 64) = v14;
  }
  if (v19)
  {
    operator delete(v19);
    std::string::size_type v16 = v42;
  }
  if (v16)
  {
    uint64_t v43 = v16;
    operator delete(v16);
  }
  if (SHIBYTE(v40) < 0) {
    operator delete((void *)__p);
  }
  return v17;
}

void sub_19E504660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20)
{
}

uint64_t sub_19E5046C0(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

BOOL sub_19E504704(void *a1)
{
  unint64_t v1 = a1[10] + 1;
  a1[10] = v1;
  return v1 < 0x8E38E38E38E38E39 * ((uint64_t)(a1[35] - a1[34]) >> 3);
}

void sub_19E50473C(uint64_t a1)
{
  sub_19E504774(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E504774(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BC080;
  uint64_t v2 = *(void *)(a1 + 272);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 280);
    unint64_t v4 = *(void **)(a1 + 272);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 24);
        if (v5)
        {
          *(void *)(v3 - 16) = v5;
          operator delete(v5);
        }
        if (*(char *)(v3 - 41) < 0) {
          operator delete(*(void **)(v3 - 64));
        }
        v3 -= 72;
      }
      while (v3 != v2);
      unint64_t v4 = *(void **)(a1 + 272);
    }
    *(void *)(a1 + 280) = v2;
    operator delete(v4);
  }
  uint64_t v6 = *(void **)(a1 + 248);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      operator delete(v6);
      uint64_t v6 = v7;
    }
    while (v7);
  }
  uint64_t v8 = *(void **)(a1 + 232);
  *(void *)(a1 + 232) = 0;
  if (v8) {
    operator delete(v8);
  }
  unint64_t v9 = *(std::__shared_weak_count **)(a1 + 216);
  if (!v9 || atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (!*(unsigned char *)(a1 + 192)) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
  std::__shared_weak_count::__release_weak(v9);
  if (*(unsigned char *)(a1 + 192)) {
LABEL_18:
  }
    std::recursive_mutex::unlock(*(std::recursive_mutex **)(a1 + 184));
LABEL_19:
  return sub_19E5048B0((void *)a1);
}

void *sub_19E5048B0(void *a1)
{
  *a1 = &unk_1EF0BC170;
  uint64_t v2 = a1 + 19;
  uint64_t v3 = (void *)a1[22];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    unint64_t v4 = (void *)a1[16];
    if (v4)
    {
LABEL_5:
      a1[17] = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    unint64_t v4 = (void *)a1[16];
    if (v4) {
      goto LABEL_5;
    }
  }
  uint64_t v5 = (void *)a1[13];
  if (v5)
  {
    a1[14] = v5;
    operator delete(v5);
  }
  uint64_t v6 = a1[6];
  a1[6] = 0;
  if (v6)
  {
    uint64_t v7 = *(void **)v6;
    if (*(void *)v6)
    {
      *(void *)(v6 + 8) = v7;
      operator delete(v7);
    }
    MEMORY[0x19F3BDCF0](v6, 0x1020C4016EE4530);
  }
  uint64_t v8 = (std::__shared_weak_count *)a1[5];
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    unint64_t v9 = (std::__shared_weak_count *)a1[3];
    if (!v9) {
      return a1;
    }
  }
  else
  {
    unint64_t v9 = (std::__shared_weak_count *)a1[3];
    if (!v9) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

void sub_19E504A50(std::string *this, uint64_t a2, uint64_t a3)
{
  *((unsigned char *)&this->__r_.__value_.__s + 23) = 12;
  strcpy((char *)this, "Completion: ");
  uint64_t v7 = *(unsigned char **)(a3 + 48);
  uint64_t v6 = *(unsigned char **)(a3 + 56);
  int64_t v8 = v6 - v7;
  if (v6 != v7)
  {
    if (v8 < 0) {
      sub_19E37C7C4();
    }
    unint64_t v9 = (char *)operator new(v6 - v7);
    size_t v10 = v8 & 0xFFFFFFFFFFFFFFF8;
    memcpy(v9, v7, v10);
    if (v10)
    {
      for (uint64_t i = 0; i != v10; i += 8)
      {
        uint64_t v12 = *(void *)(a2 + 208);
        if (*(_DWORD *)(a2 + 296)) {
          sub_19E4B6110((uint64_t)__p, *(std::recursive_mutex **)(v12 + 464), *(unsigned int *)&v9[i]);
        }
        else {
          sub_19E3FDF08((void *)v12, *(unsigned int *)&v9[i], (uint64_t)__p);
        }
        if (v47 >= 0) {
          unsigned int v13 = __p;
        }
        else {
          unsigned int v13 = (void **)__p[0];
        }
        if (v47 >= 0) {
          std::string::size_type v14 = HIBYTE(v47);
        }
        else {
          std::string::size_type v14 = (std::string::size_type)__p[1];
        }
        std::string::append(this, (const std::string::value_type *)v13, v14);
        if (SHIBYTE(v47) < 0) {
          operator delete(__p[0]);
        }
        std::string::append(this, " ", 1uLL);
      }
    }
    operator delete(v9);
  }
  std::string::append(this, "\n Prefix: ", 0xAuLL);
  if (*(char *)(a3 + 31) < 0)
  {
    sub_19E39369C(__p, *(void **)(a3 + 8), *(void *)(a3 + 16));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)(a3 + 8);
    int64_t v47 = *(void *)(a3 + 24);
  }
  if (v47 >= 0) {
    uint64_t v15 = __p;
  }
  else {
    uint64_t v15 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v16 = HIBYTE(v47);
  }
  else {
    std::string::size_type v16 = (std::string::size_type)__p[1];
  }
  std::string::append(this, (const std::string::value_type *)v15, v16);
  if (SHIBYTE(v47) < 0) {
    operator delete(__p[0]);
  }
  double v17 = -10.0;
  if (*(float *)a3 > 0.0)
  {
    uint64_t v19 = *(void *)(a3 + 48);
    uint64_t v18 = *(void *)(a3 + 56);
    uint64_t v20 = v18 - v19;
    if (v18 != v19)
    {
      float v21 = log10f(*(float *)(v18 - 4) / *(float *)a3);
      uint64_t v22 = v20 >> 3;
      double v23 = 1.0;
      if (v20 >> 3 != 1)
      {
        if (!v22) {
          __assert_rtn("normalizationFactor", "LMDynamicInlineCompletionEnumerator.hpp", 78, "numWords >= 1");
        }
        float v24 = 1.15368974
            / (float)(sqrtf((float)(unint64_t)v22 + 0.1) * (float)((float)(unint64_t)v22 + 0.1));
        double v23 = v24;
      }
      double v17 = v23 * v21;
    }
  }
  std::to_string(&v45, v17);
  unint64_t v25 = std::string::insert(&v45, 0, "\n Score (normalized log probability): ", 0x26uLL);
  long long v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  int64_t v47 = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  if (v47 >= 0) {
    unsigned long long v27 = __p;
  }
  else {
    unsigned long long v27 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v28 = HIBYTE(v47);
  }
  else {
    std::string::size_type v28 = (std::string::size_type)__p[1];
  }
  std::string::append(this, (const std::string::value_type *)v27, v28);
  if (SHIBYTE(v47) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_43;
    }
  }
  else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_43;
  }
  operator delete(v45.__r_.__value_.__l.__data_);
LABEL_43:
  std::string::append(this, "\n Context: ", 0xBuLL);
  uint64_t v29 = *(void *)(a3 + 40);
  if (v29)
  {
    unint64_t v30 = *(unsigned int **)(a3 + 32);
    uint64_t v31 = 4 * v29;
    do
    {
      uint64_t v32 = *(void *)(a2 + 208);
      if (*(_DWORD *)(a2 + 296)) {
        sub_19E4B6110((uint64_t)__p, *(std::recursive_mutex **)(v32 + 464), *v30);
      }
      else {
        sub_19E3FDF08((void *)v32, *v30, (uint64_t)__p);
      }
      if (v47 >= 0) {
        float v33 = __p;
      }
      else {
        float v33 = (void **)__p[0];
      }
      if (v47 >= 0) {
        std::string::size_type v34 = HIBYTE(v47);
      }
      else {
        std::string::size_type v34 = (std::string::size_type)__p[1];
      }
      std::string::append(this, (const std::string::value_type *)v33, v34);
      if (SHIBYTE(v47) < 0) {
        operator delete(__p[0]);
      }
      std::string::append(this, " ", 1uLL);
      ++v30;
      v31 -= 4;
    }
    while (v31);
  }
  std::to_string(&v45, (unint64_t)*(float *)a3);
  float v35 = std::string::insert(&v45, 0, "\n Context count: ", 0x11uLL);
  long long v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
  int64_t v47 = v35->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v36;
  v35->__r_.__value_.__l.__size_ = 0;
  v35->__r_.__value_.__r.__words[2] = 0;
  v35->__r_.__value_.__r.__words[0] = 0;
  if (v47 >= 0) {
    unsigned int v37 = __p;
  }
  else {
    unsigned int v37 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v38 = HIBYTE(v47);
  }
  else {
    std::string::size_type v38 = (std::string::size_type)__p[1];
  }
  std::string::append(this, (const std::string::value_type *)v37, v38);
  if (SHIBYTE(v47) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_65;
    }
  }
  else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_65;
  }
  operator delete(v45.__r_.__value_.__l.__data_);
LABEL_65:
  uint64_t v39 = *(void *)(a3 + 56);
  if (v39 == *(void *)(a3 + 48)) {
    float v40 = 0.0;
  }
  else {
    float v40 = *(float *)(v39 - 4);
  }
  std::to_string(&v45, v40);
  long long v41 = std::string::insert(&v45, 0, "\n Completion count: ", 0x14uLL);
  long long v42 = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
  int64_t v47 = v41->__r_.__value_.__r.__words[2];
  *(_OWORD *)long long __p = v42;
  v41->__r_.__value_.__l.__size_ = 0;
  v41->__r_.__value_.__r.__words[2] = 0;
  v41->__r_.__value_.__r.__words[0] = 0;
  if (v47 >= 0) {
    uint64_t v43 = __p;
  }
  else {
    uint64_t v43 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v44 = HIBYTE(v47);
  }
  else {
    std::string::size_type v44 = (std::string::size_type)__p[1];
  }
  std::string::append(this, (const std::string::value_type *)v43, v44);
  if ((SHIBYTE(v47) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      return;
    }
LABEL_82:
    operator delete(v45.__r_.__value_.__l.__data_);
    return;
  }
  operator delete(__p[0]);
  if (SHIBYTE(v45.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_82;
  }
}

void sub_19E504EF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 + 23) < 0) {
    operator delete(*(void **)v21);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E504FB4(float *a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      size_t v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            size_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          size_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unsigned int v13 = operator new(0x20uLL);
  *unsigned int v13 = 0;
  v13[1] = v5;
  *((_OWORD *)v13 + 1) = *a3;
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v20 = operator new(8 * prime);
    uint64_t v21 = *(void **)a1;
    *(void *)a1 = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    float v24 = (uint64_t *)(a1 + 4);
    double v23 = (void *)*((void *)a1 + 2);
    if (!v23) {
      goto LABEL_59;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          double v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *double v23 = *i;
          uint64_t v30 = 8 * v29;
          void *i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          double v23 = i;
          size_t v27 = v29;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    std::string::size_type v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_64;
        }
        *double v23 = *v34;
        uint64_t v35 = 8 * v36;
        *std::string::size_type v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        std::string::size_type v34 = v23;
      }
      size_t v36 = v25;
LABEL_64:
      double v23 = v34;
      std::string::size_type v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
  {
    unint64_t v31 = std::__next_prime(v31);
  }
  else
  {
    uint64_t v33 = 1 << -(char)__clz(v31 - 1);
    if (v31 >= 2) {
      unint64_t v31 = v33;
    }
  }
  if (prime <= v31) {
    size_t prime = v31;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      float v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  unsigned int v37 = *(void **)a1;
  std::string::size_type v38 = *(void **)(*(void *)a1 + 8 * v5);
  if (v38)
  {
    *unsigned int v13 = *v38;
LABEL_80:
    *std::string::size_type v38 = v13;
    goto LABEL_81;
  }
  *unsigned int v13 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v13;
  v37[v5] = a1 + 4;
  if (*v13)
  {
    unint64_t v39 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v39 >= v7) {
        v39 %= v7;
      }
    }
    else
    {
      v39 &= v7 - 1;
    }
    std::string::size_type v38 = (void *)(*(void *)a1 + 8 * v39);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
}

void sub_19E505400(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_19E505414(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, std::string *a6)
{
  int v10 = *(_DWORD *)(a1 + 88);
  if (*(char *)(a5 + 23) < 0)
  {
    sub_19E39369C(__p, *(void **)a5, *(void *)(a5 + 8));
  }
  else
  {
    *(_OWORD *)long long __p = *(_OWORD *)a5;
    uint64_t v30 = *(void *)(a5 + 16);
  }
  int v31 = v10;
  if (SHIBYTE(v30) < 0)
  {
    sub_19E39369C(&v32, __p[0], (unint64_t)__p[1]);
  }
  else
  {
    long long v32 = *(_OWORD *)__p;
    uint64_t v33 = v30;
  }
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  unsigned int v37 = 0;
  uint64_t v38 = 0;
  size_t v36 = 0;
  if (SHIBYTE(v30) < 0) {
    operator delete(__p[0]);
  }
  if (qword_1E945A310 != -1) {
    dispatch_once(&qword_1E945A310, &unk_1EF0BEEF8);
  }
  sub_19E504A50(&v26, a1, (uint64_t)&v31);
  if ((v26.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v11 = &v26;
  }
  else {
    unint64_t v11 = (std::string *)v26.__r_.__value_.__r.__words[0];
  }
  sub_19E439798("Starting dynamic inline completion beam search , for context length %zu, seeded with empty completion: %s, with ", (uint64_t)&v39, a3, v11);
  if ((v41 & 0x80u) == 0) {
    uint64_t v12 = (const std::string::value_type *)&v39;
  }
  else {
    uint64_t v12 = v39;
  }
  if ((v41 & 0x80u) == 0) {
    std::string::size_type v13 = v41;
  }
  else {
    std::string::size_type v13 = v40;
  }
  std::string::append(a6, v12, v13);
  if (SHIBYTE(a6->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = a6->__r_.__value_.__l.__size_;
    if (size)
    {
      BOOL v16 = (std::string *)a6->__r_.__value_.__r.__words[0];
      if (!*(unsigned char *)(a6->__r_.__value_.__r.__words[0] + size - 1))
      {
        std::string::size_type v15 = size - 1;
        a6->__r_.__value_.__l.__size_ = v15;
        goto LABEL_27;
      }
    }
  }
  else
  {
    uint64_t v14 = HIBYTE(a6->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&a6->__r_.__value_.__s + 23) && !a6->__r_.__value_.__s.__data_[v14 - 1])
    {
      std::string::size_type v15 = v14 - 1;
      *((unsigned char *)&a6->__r_.__value_.__s + 23) = v14 - 1;
      BOOL v16 = a6;
LABEL_27:
      v16->__r_.__value_.__s.__data_[v15] = 0;
    }
  }
  std::string::push_back(a6, 10);
  if ((char)v41 < 0)
  {
    operator delete(v39);
    if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_30;
    }
  }
  else if ((SHIBYTE(v26.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_30;
  }
  operator delete(v26.__r_.__value_.__l.__data_);
LABEL_30:
  if (*(float *)(a1 + 88) >= (float)a4)
  {
    if (*(char *)(a5 + 23) < 0)
    {
      sub_19E39369C(__dst, *(void **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a5;
      uint64_t v28 = *(void *)(a5 + 16);
    }
    operator new();
  }
  if (qword_1E945A310 != -1) {
    dispatch_once(&qword_1E945A310, &unk_1EF0BEEF8);
  }
  sub_19E439798("Abandoning dynamic inline completion beam search , minimum count threshold %zu not met for context of length %zu", (uint64_t)&v39, a4, a3);
  if ((v41 & 0x80u) == 0) {
    unint64_t v18 = (const std::string::value_type *)&v39;
  }
  else {
    unint64_t v18 = v39;
  }
  if ((v41 & 0x80u) == 0) {
    std::string::size_type v19 = v41;
  }
  else {
    std::string::size_type v19 = v40;
  }
  std::string::append(a6, v18, v19);
  if (SHIBYTE(a6->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v23 = a6->__r_.__value_.__l.__size_;
    if (v23)
    {
      uint64_t v22 = (std::string *)a6->__r_.__value_.__r.__words[0];
      if (!*(unsigned char *)(a6->__r_.__value_.__r.__words[0] + v23 - 1))
      {
        std::string::size_type v21 = v23 - 1;
        a6->__r_.__value_.__l.__size_ = v21;
        goto LABEL_52;
      }
    }
  }
  else
  {
    uint64_t v20 = HIBYTE(a6->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&a6->__r_.__value_.__s + 23) && !a6->__r_.__value_.__s.__data_[v20 - 1])
    {
      std::string::size_type v21 = v20 - 1;
      *((unsigned char *)&a6->__r_.__value_.__s + 23) = v20 - 1;
      uint64_t v22 = a6;
LABEL_52:
      v22->__r_.__value_.__s.__data_[v21] = 0;
    }
  }
  std::string::push_back(a6, 10);
  if ((char)v41 < 0) {
    operator delete(v39);
  }
  if (v36)
  {
    unsigned int v37 = v36;
    operator delete(v36);
  }
  if (SHIBYTE(v33) < 0) {
    operator delete((void *)v32);
  }
}

void sub_19E506A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,void *a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,void *a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,int a51,__int16 a52,char a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,int a62,__int16 a63)
{
  if (*(char *)(v69 - 193) < 0) {
    operator delete(*(void **)(v69 - 216));
  }
  sub_19E5046C0(v69 - 192);
  sub_19E506FB8(&a40);
  uint64_t v71 = a12;
  uint64_t v72 = *(void *)(a12 + 16);
  if (v72)
  {
    uint64_t v73 = *(void *)(a12 + 24);
    uint64_t v74 = *(void **)(a12 + 16);
    if (v73 != v72)
    {
      do
      {
        int v75 = *(void **)(v73 - 24);
        if (v75)
        {
          *(void *)(v73 - 16) = v75;
          operator delete(v75);
        }
        if (*(char *)(v73 - 41) < 0) {
          operator delete(*(void **)(v73 - 64));
        }
        v73 -= 72;
      }
      while (v73 != v72);
      uint64_t v71 = a12;
      uint64_t v74 = *(void **)(a12 + 16);
    }
    *(void *)(v71 + 24) = v72;
    operator delete(v74);
  }
  MEMORY[0x19F3BDCF0](v71, 0x1020C402564D6C4);
  if (a28)
  {
    uint64_t v76 = *(void *)(a28 + 16);
    if (v76)
    {
      uint64_t v77 = *(void *)(a28 + 24);
      char v78 = *(void **)(a28 + 16);
      if (v77 != v76)
      {
        do
        {
          uint64_t v79 = *(void **)(v77 - 24);
          if (v79)
          {
            *(void *)(v77 - 16) = v79;
            operator delete(v79);
          }
          if (*(char *)(v77 - 41) < 0) {
            operator delete(*(void **)(v77 - 64));
          }
          v77 -= 72;
        }
        while (v77 != v76);
        char v78 = *(void **)(a28 + 16);
      }
      *(void *)(a28 + 24) = v76;
      operator delete(v78);
    }
    MEMORY[0x19F3BDCF0](a28, 0x1020C402564D6C4);
    if (!a29)
    {
LABEL_15:
      if ((a54 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      goto LABEL_39;
    }
  }
  else if (!a29)
  {
    goto LABEL_15;
  }
  uint64_t v80 = *(void *)(a29 + 16);
  if (v80)
  {
    uint64_t v81 = *(void *)(a29 + 24);
    uint64_t v82 = *(void **)(a29 + 16);
    if (v81 != v80)
    {
      do
      {
        uint64_t v83 = *(void **)(v81 - 24);
        if (v83)
        {
          *(void *)(v81 - 16) = v83;
          operator delete(v83);
        }
        if (*(char *)(v81 - 41) < 0) {
          operator delete(*(void **)(v81 - 64));
        }
        v81 -= 72;
      }
      while (v81 != v80);
      uint64_t v82 = *(void **)(a29 + 16);
    }
    *(void *)(a29 + 24) = v80;
    operator delete(v82);
  }
  MEMORY[0x19F3BDCF0](a29, 0x1020C402564D6C4);
  if ((a54 & 0x80000000) == 0)
  {
LABEL_40:
    if (a68)
    {
      a69 = (uint64_t)a68;
      operator delete(a68);
    }
    if (a65 < 0) {
      operator delete(a60);
    }
    _Unwind_Resume(a1);
  }
LABEL_39:
  operator delete(__p);
  goto LABEL_40;
}

void **sub_19E506FB8(void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        unint64_t v5 = (void *)*((void *)v3 - 3);
        if (v5)
        {
          *((void *)v3 - 2) = v5;
          operator delete(v5);
        }
        if (*(v3 - 41) < 0) {
          operator delete(*((void **)v3 - 8));
        }
        v3 -= 72;
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void *sub_19E50703C(void *a1, unint64_t a2)
{
  a1[2] = 0;
  a1[1] = a2;
  a1[3] = 0;
  a1[4] = 0;
  if (!a2) {
    __assert_rtn("PriorityQueue", "PriorityQueue.hpp", 21, "m_maxPredictionCount > 0");
  }
  if (a2 >= 0x38E38E38E38E38FLL) {
    sub_19E37C7C4();
  }
  unint64_t v4 = (char *)operator new(72 * a2);
  a1[2] = v4;
  a1[3] = v4;
  a1[4] = &v4[72 * a2];
  return a1;
}

void sub_19E5070E8(_Unwind_Exception *exception_object)
{
  unint64_t v4 = (char *)*v2;
  if (*v2)
  {
    unint64_t v5 = *(char **)(v1 + 24);
    uint64_t v6 = *v2;
    if (v5 != v4)
    {
      do
      {
        unint64_t v7 = (void *)*((void *)v5 - 3);
        if (v7)
        {
          *((void *)v5 - 2) = v7;
          operator delete(v7);
        }
        if (*(v5 - 41) < 0) {
          operator delete(*((void **)v5 - 8));
        }
        v5 -= 72;
      }
      while (v5 != v4);
      uint64_t v6 = *v2;
    }
    *(void *)(v1 + 24) = v4;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E50714C(void *a1, uint64_t a2)
{
  unint64_t v2 = a2;
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[3];
  unint64_t v6 = 0x8E38E38E38E38E39 * ((v5 - v4) >> 3);
  if (v6 >= a1[1])
  {
    if (v4 == v5) {
      __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
    }
    if (!sub_19E507D50(a2, v4))
    {
      uint8x8_t v8 = (int *)a1[2];
      uint64_t v9 = a1[3] - (void)v8;
      if (v9)
      {
        unint64_t v10 = 0x8E38E38E38E38E39 * (v9 >> 3);
        do
        {
          if (sub_19E507D50(v2, (uint64_t)&v8[18 * (v10 >> 1)]))
          {
            v10 >>= 1;
          }
          else
          {
            v8 += 18 * (v10 >> 1) + 18;
            v10 += ~(v10 >> 1);
          }
        }
        while (v10);
        unint64_t v11 = (int *)a1[2];
      }
      else
      {
        unint64_t v11 = (int *)a1[2];
      }
      std::string::size_type v40 = v11 + 18;
      if (v11 + 18 != v8)
      {
        while (1)
        {
          unsigned __int8 v41 = v11 + 18;
          sub_19E507A48(v11, v11 + 18);
          if (v11 + 36 == v8) {
            break;
          }
          if (v41 == v40) {
            std::string::size_type v40 = v11 + 36;
          }
          v11 += 18;
        }
        if (v41 != v40)
        {
          long long v42 = v40;
          while (1)
          {
            sub_19E507A48(v41, v40);
            v40 += 18;
            BOOL v43 = v41 + 18 == v42;
            if (v40 == v8)
            {
              if (v41 + 18 == v42) {
                break;
              }
              std::string::size_type v40 = v42 + 18;
              v41 += 36;
              while (1)
              {
                sub_19E507A48(v41 - 18, v42);
                BOOL v43 = v41 == v42;
                if (v40 != v8) {
                  break;
                }
                BOOL v44 = v41 == v42;
                v41 += 18;
                if (v44) {
                  goto LABEL_70;
                }
              }
            }
            else
            {
              v41 += 18;
            }
            if (v43) {
              long long v42 = v40;
            }
          }
        }
      }
LABEL_70:
      *(v8 - 18) = *(_DWORD *)v2;
      if (v8 - 18 == (int *)v2)
      {
        *(_OWORD *)(v8 - 10) = *(_OWORD *)(v2 + 32);
        return;
      }
      std::string v45 = (void **)(v8 - 16);
      char v46 = *(unsigned char *)(v2 + 31);
      if (*((char *)v8 - 41) < 0)
      {
        if (v46 >= 0) {
          uint64_t v48 = (void *)(v2 + 8);
        }
        else {
          uint64_t v48 = *(void **)(v2 + 8);
        }
        if (v46 >= 0) {
          size_t v49 = *(unsigned __int8 *)(v2 + 31);
        }
        else {
          size_t v49 = *(void *)(v2 + 16);
        }
        sub_19E3C6D44(v45, v48, v49);
      }
      else if ((*(unsigned char *)(v2 + 31) & 0x80) != 0)
      {
        sub_19E3C6C7C(v45, *(void **)(v2 + 8), *(void *)(v2 + 16));
      }
      else
      {
        long long v47 = *(_OWORD *)(v2 + 8);
        *((void *)v8 - 6) = *(void *)(v2 + 24);
        *(_OWORD *)std::string v45 = v47;
      }
      *(_OWORD *)(v8 - 10) = *(_OWORD *)(v2 + 32);
      uint64_t v66 = (uint64_t)(v8 - 6);
      goto LABEL_117;
    }
  }
  else
  {
    if (v5 == v4)
    {
      unint64_t v7 = a1[3];
      uint64_t v4 = v7;
    }
    else
    {
      do
      {
        if (sub_19E507D50(v2, v4 + 72 * (v6 >> 1)))
        {
          v6 >>= 1;
        }
        else
        {
          v4 += 72 * (v6 >> 1) + 72;
          v6 += ~(v6 >> 1);
        }
      }
      while (v6);
      uint64_t v5 = a1[2];
      unint64_t v7 = a1[3];
    }
    uint64_t v12 = (v4 - v5) / 72;
    std::string::size_type v13 = (char *)(v5 + 72 * v12);
    unint64_t v14 = a1[4];
    if (v7 >= v14)
    {
      unint64_t v31 = 0x8E38E38E38E38E39 * ((uint64_t)(v7 - v5) >> 3) + 1;
      if (v31 > 0x38E38E38E38E38ELL) {
        sub_19E37C7C4();
      }
      unint64_t v32 = 0x8E38E38E38E38E39 * ((uint64_t)(v14 - v5) >> 3);
      if (2 * v32 > v31) {
        unint64_t v31 = 2 * v32;
      }
      if (v32 >= 0x1C71C71C71C71C7) {
        unint64_t v33 = 0x38E38E38E38E38ELL;
      }
      else {
        unint64_t v33 = v31;
      }
      if (v33)
      {
        if (v33 > 0x38E38E38E38E38ELL) {
          sub_19E37C2B8();
        }
        uint64_t v34 = (char *)operator new(72 * v33);
      }
      else
      {
        uint64_t v34 = 0;
      }
      uint64_t v38 = (uint64_t)&v34[72 * v12];
      uint64_t v72 = v38;
      uint64_t v73 = v38;
      uint64_t v74 = &v34[72 * v33];
      if (v12 == v33)
      {
        if (v4 - v5 < 1)
        {
          if (v4 == v5) {
            unint64_t v50 = 1;
          }
          else {
            unint64_t v50 = 2 * v12;
          }
          if (v50 > 0x38E38E38E38E38ELL) {
            sub_19E37C2B8();
          }
          unint64_t v51 = (char *)operator new(72 * v50);
          uint64_t v38 = (uint64_t)&v51[72 * (v50 >> 2)];
          uint64_t v72 = v38;
          uint64_t v73 = v38;
          uint64_t v74 = &v51[72 * v50];
          if (v34) {
            operator delete(v34);
          }
        }
        else
        {
          uint64_t v39 = v12 + 2;
          if (v12 >= -1) {
            uint64_t v39 = v12 + 1;
          }
          v38 -= 72 * (v39 >> 1);
          uint64_t v72 = v38;
          uint64_t v73 = v38;
        }
      }
      sub_19E507BB0(v38, v2);
      uint64_t v52 = v72;
      uint64_t v53 = v73 + 72;
      uint64_t v54 = (char *)a1[2];
      if (v54 != v13)
      {
        uint64_t v55 = 0;
        do
        {
          uint64_t v56 = v72 + v55;
          long long v57 = &v13[v55];
          *(_DWORD *)(v56 - 72) = *(_DWORD *)&v13[v55 - 72];
          long long v58 = *(_OWORD *)&v13[v55 - 64];
          *(void *)(v56 - 48) = *(void *)&v13[v55 - 48];
          *(_OWORD *)(v56 - 64) = v58;
          *((void *)v57 - 7) = 0;
          *((void *)v57 - 6) = 0;
          *((void *)v57 - 8) = 0;
          *(_OWORD *)(v56 - 40) = *(_OWORD *)&v13[v55 - 40];
          *(void *)(v56 - 16) = 0;
          *(void *)(v56 - 8) = 0;
          *(void *)(v56 - 24) = 0;
          *(_OWORD *)(v56 - 24) = *(_OWORD *)&v13[v55 - 24];
          *(void *)(v56 - 8) = *(void *)&v13[v55 - 8];
          *((void *)v57 - 3) = 0;
          *((void *)v57 - 2) = 0;
          *((void *)v57 - 1) = 0;
          v55 -= 72;
        }
        while (&v13[v55] != v54);
        uint64_t v52 = v72 + v55;
      }
      long long v59 = (char *)a1[3];
      if (v59 != v13)
      {
        do
        {
          *(_DWORD *)uint64_t v53 = *(_DWORD *)v13;
          long long v60 = *(_OWORD *)(v13 + 8);
          *(void *)(v53 + 24) = *((void *)v13 + 3);
          *(_OWORD *)(v53 + 8) = v60;
          *((void *)v13 + 2) = 0;
          *((void *)v13 + 3) = 0;
          *((void *)v13 + 1) = 0;
          *(_OWORD *)(v53 + 32) = *((_OWORD *)v13 + 2);
          *(void *)(v53 + 56) = 0;
          *(void *)(v53 + 64) = 0;
          *(void *)(v53 + 48) = 0;
          *(_OWORD *)(v53 + 48) = *((_OWORD *)v13 + 3);
          *(void *)(v53 + 64) = *((void *)v13 + 8);
          *((void *)v13 + 6) = 0;
          *((void *)v13 + 7) = 0;
          *((void *)v13 + 8) = 0;
          v53 += 72;
          v13 += 72;
        }
        while (v13 != v59);
        std::string::size_type v13 = (char *)a1[3];
      }
      unint64_t v61 = (char *)a1[2];
      a1[2] = v52;
      a1[3] = v53;
      a1[4] = v74;
      if (v13 == v61)
      {
        if (!v13) {
          return;
        }
      }
      else
      {
        do
        {
          uint64_t v62 = v13 - 72;
          uint64_t v63 = (void *)*((void *)v13 - 3);
          if (v63)
          {
            *((void *)v13 - 2) = v63;
            operator delete(v63);
          }
          if (*(v13 - 41) < 0) {
            operator delete(*((void **)v13 - 8));
          }
          v13 -= 72;
        }
        while (v62 != v61);
        std::string::size_type v13 = v61;
        if (!v61) {
          return;
        }
      }
      operator delete(v13);
      return;
    }
    if (v13 == (char *)v7)
    {
      sub_19E507BB0(v7, v2);
      a1[3] = v7 + 72;
      return;
    }
    std::string::size_type v15 = v13 + 72;
    unint64_t v16 = v7 - 72;
    unint64_t v17 = v7;
    if (v7 >= 0x48)
    {
      unint64_t v17 = v7;
      do
      {
        *(_DWORD *)unint64_t v17 = *(_DWORD *)v16;
        long long v18 = *(_OWORD *)(v16 + 8);
        *(void *)(v17 + 24) = *(void *)(v16 + 24);
        *(_OWORD *)(v17 + 8) = v18;
        *(void *)(v16 + 16) = 0;
        *(void *)(v16 + 24) = 0;
        *(void *)(v16 + 8) = 0;
        *(_OWORD *)(v17 + 32) = *(_OWORD *)(v16 + 32);
        *(void *)(v17 + 56) = 0;
        *(void *)(v17 + 64) = 0;
        *(void *)(v17 + 48) = 0;
        *(_OWORD *)(v17 + 48) = *(_OWORD *)(v16 + 48);
        *(void *)(v17 + 64) = *(void *)(v16 + 64);
        *(void *)(v16 + 48) = 0;
        *(void *)(v16 + 56) = 0;
        *(void *)(v16 + 64) = 0;
        v17 += 72;
        v16 += 72;
      }
      while (v16 < v7);
    }
    uint64_t v70 = a1;
    uint64_t v71 = (v4 - v5) / 72;
    a1[3] = v17;
    if ((char *)v7 != v15)
    {
      uint64_t v19 = 0;
      unint64_t v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v7 - (void)v15) >> 3);
      uint64_t v21 = v5 + 72 * v20 + 72 * v71;
      uint64_t v22 = -72 * v20;
      do
      {
        uint64_t v24 = v21 + v19;
        uint64_t v25 = v7 + v19;
        *(_DWORD *)(v7 + v19 - 72) = *(_DWORD *)(v21 + v19 - 72);
        std::string v26 = (void **)(v7 + v19 - 64);
        if (*(char *)(v7 + v19 - 41) < 0) {
          operator delete(*v26);
        }
        long long v27 = *(_OWORD *)(v24 - 64);
        *(void *)(v7 + v19 - 48) = *(void *)(v24 - 48);
        *(_OWORD *)std::string v26 = v27;
        *(unsigned char *)(v24 - 41) = 0;
        *(unsigned char *)(v24 - 64) = 0;
        uint64_t v30 = *(void **)(v25 - 24);
        size_t v29 = (void *)(v25 - 24);
        uint64_t v28 = v30;
        *((_OWORD *)v29 - 1) = *(_OWORD *)(v24 - 40);
        if (v30)
        {
          *(void *)(v7 + v19 - 16) = v28;
          operator delete(v28);
          void *v29 = 0;
          v29[1] = 0;
          v29[2] = 0;
        }
        uint64_t v23 = v21 + v19;
        *(_OWORD *)size_t v29 = *(_OWORD *)(v21 + v19 - 24);
        *(void *)(v7 + v19 - 8) = *(void *)(v21 + v19 - 8);
        *(void *)(v23 - 24) = 0;
        *(void *)(v23 - 16) = 0;
        *(void *)(v23 - 8) = 0;
        v19 -= 72;
      }
      while (v22 != v19);
    }
    if ((unint64_t)v13 <= v2) {
      v2 += 72 * (v70[3] > v2);
    }
    *(_DWORD *)std::string::size_type v13 = *(_DWORD *)v2;
    if (v13 != (char *)v2)
    {
      uint64_t v35 = (void **)(v5 + 72 * v71 + 8);
      char v36 = *(unsigned char *)(v2 + 31);
      if (v13[31] < 0)
      {
        if (v36 >= 0) {
          unint64_t v64 = (void *)(v2 + 8);
        }
        else {
          unint64_t v64 = *(void **)(v2 + 8);
        }
        if (v36 >= 0) {
          size_t v65 = *(unsigned __int8 *)(v2 + 31);
        }
        else {
          size_t v65 = *(void *)(v2 + 16);
        }
        sub_19E3C6D44(v35, v64, v65);
      }
      else if ((*(unsigned char *)(v2 + 31) & 0x80) != 0)
      {
        sub_19E3C6C7C(v35, *(void **)(v2 + 8), *(void *)(v2 + 16));
      }
      else
      {
        long long v37 = *(_OWORD *)(v2 + 8);
        *(void *)(v5 + 72 * v71 + 24) = *(void *)(v2 + 24);
        *(_OWORD *)uint64_t v35 = v37;
      }
      uint64_t v67 = v5 + 72 * v71;
      *(_OWORD *)(v67 + 32) = *(_OWORD *)(v2 + 32);
      uint64_t v66 = v67 + 48;
LABEL_117:
      unint64_t v68 = *(void *)(v2 + 48);
      uint64_t v69 = *(char **)(v2 + 56);
      sub_19E507E90(v66, v68, v69, (uint64_t)&v69[-v68] >> 3);
    }
  }
}

void sub_19E50790C(_Unwind_Exception *a1)
{
  *(void *)(v2 + 24) = v1;
  _Unwind_Resume(a1);
}

void sub_19E507914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  sub_19E5081F0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E507928(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0x38E38E38E38E38FLL) {
      sub_19E37C7C4();
    }
    unint64_t v7 = (void *)result;
    uint64_t result = (uint64_t)operator new(72 * a4);
    uint64_t v8 = result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = result + 72 * a4;
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t result = sub_19E507BB0(v8 + v9, a2 + v9);
        v9 += 72;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    v7[1] = v8;
  }
  return result;
}

void sub_19E5079EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_19E507A48(int *a1, int *a2)
{
  int v4 = *a1;
  uint64_t v5 = *((void *)a1 + 1);
  *(void *)unint64_t v14 = *((void *)a1 + 2);
  *(void *)&v14[7] = *(void *)((char *)a1 + 23);
  char v6 = *((unsigned char *)a1 + 31);
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 1) = 0;
  unint64_t v7 = a1 + 12;
  long long v12 = *((_OWORD *)a1 + 3);
  long long v13 = *((_OWORD *)a1 + 2);
  uint64_t v8 = *((void *)a1 + 8);
  *((void *)a1 + 7) = 0;
  *((void *)a1 + 8) = 0;
  *((void *)a1 + 6) = 0;
  *a1 = *a2;
  long long v9 = *(_OWORD *)(a2 + 2);
  *((void *)a1 + 3) = *((void *)a2 + 3);
  *(_OWORD *)(a1 + 2) = v9;
  *((unsigned char *)a2 + 31) = 0;
  *((unsigned char *)a2 + 8) = 0;
  *((_OWORD *)a1 + 2) = *((_OWORD *)a2 + 2);
  unint64_t v10 = (void *)*((void *)a1 + 6);
  if (v10)
  {
    *((void *)a1 + 7) = v10;
    operator delete(v10);
    void *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
  }
  unint64_t v11 = 0;
  *((_OWORD *)a1 + 3) = *((_OWORD *)a2 + 3);
  *((void *)a1 + 8) = *((void *)a2 + 8);
  *((void *)a2 + 6) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  *a2 = v4;
  if (*((char *)a2 + 31) < 0)
  {
    operator delete(*((void **)a2 + 1));
    unint64_t v11 = (void *)*((void *)a2 + 6);
  }
  *((void *)a2 + 1) = v5;
  *((void *)a2 + 2) = *(void *)v14;
  *(void *)((char *)a2 + 23) = *(void *)&v14[7];
  *((unsigned char *)a2 + 31) = v6;
  *((_OWORD *)a2 + 2) = v13;
  if (v11)
  {
    *((void *)a2 + 7) = v11;
    operator delete(v11);
  }
  *((_OWORD *)a2 + 3) = v12;
  *((void *)a2 + 8) = v8;
}

uint64_t sub_19E507BB0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  if (*(char *)(a2 + 31) < 0)
  {
    sub_19E39369C((unsigned char *)(a1 + 8), *(void **)(a2 + 8), *(void *)(a2 + 16));
  }
  else
  {
    long long v4 = *(_OWORD *)(a2 + 8);
    *(void *)(a1 + 24) = *(void *)(a2 + 24);
    *(_OWORD *)(a1 + 8) = v4;
  }
  long long v5 = *(_OWORD *)(a2 + 32);
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 32) = v5;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  unint64_t v7 = *(unsigned char **)(a2 + 48);
  char v6 = *(unsigned char **)(a2 + 56);
  uint64_t v8 = v6 - v7;
  if (v6 != v7)
  {
    if (v8 < 0) {
      sub_19E37C7C4();
    }
    long long v9 = (char *)operator new(v6 - v7);
    *(void *)(a1 + 48) = v9;
    *(void *)(a1 + 56) = v9;
    *(void *)(a1 + 64) = &v9[8 * (v8 >> 3)];
    memcpy(v9, v7, v8 & 0xFFFFFFFFFFFFFFF8);
    *(void *)(a1 + 56) = &v9[v8 & 0xFFFFFFFFFFFFFFF8];
  }
  return a1;
}

void sub_19E507C80(_Unwind_Exception *exception_object)
{
  long long v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 56) = v5;
    operator delete(v5);
    if ((*(char *)(v1 + 31) & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((*(char *)(v1 + 31) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*v2);
  _Unwind_Resume(exception_object);
}

void ***sub_19E507CBC(void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    uint64_t v2 = *a1;
    unint64_t v3 = (char *)**a1;
    if (v3)
    {
      long long v4 = (char *)v2[1];
      long long v5 = **a1;
      if (v4 != v3)
      {
        do
        {
          char v6 = (void *)*((void *)v4 - 3);
          if (v6)
          {
            *((void *)v4 - 2) = v6;
            operator delete(v6);
          }
          if (*(v4 - 41) < 0) {
            operator delete(*((void **)v4 - 8));
          }
          v4 -= 72;
        }
        while (v4 != v3);
        long long v5 = **a1;
      }
      v2[1] = v3;
      operator delete(v5);
    }
  }
  return a1;
}

BOOL sub_19E507D50(uint64_t a1, uint64_t a2)
{
  double v3 = -10.0;
  double v4 = -10.0;
  if (*(float *)a1 > 0.0)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(a1 + 56);
    uint64_t v7 = v5 - v6;
    if (v5 != v6)
    {
      float v8 = log10f(*(float *)(v5 - 4) / *(float *)a1);
      uint64_t v9 = v7 >> 3;
      double v10 = 1.0;
      if (v7 >> 3 != 1)
      {
        if (!v9) {
          goto LABEL_14;
        }
        float v11 = 1.15368974
            / (float)(sqrtf((float)(unint64_t)v9 + 0.1) * (float)((float)(unint64_t)v9 + 0.1));
        double v10 = v11;
      }
      double v4 = v10 * v8;
    }
  }
  float v12 = *(float *)a2;
  if (*(float *)a2 > 0.0)
  {
    uint64_t v14 = *(void *)(a2 + 48);
    uint64_t v13 = *(void *)(a2 + 56);
    uint64_t v15 = v13 - v14;
    if (v13 != v14)
    {
      float v16 = log10f(*(float *)(v13 - 4) / v12);
      uint64_t v17 = v15 >> 3;
      double v18 = 1.0;
      if (v15 >> 3 == 1)
      {
LABEL_12:
        double v3 = v18 * v16;
        return v4 < v3;
      }
      if (v17)
      {
        float v19 = 1.15368974
            / (float)(sqrtf((float)(unint64_t)v17 + 0.1) * (float)((float)(unint64_t)v17 + 0.1));
        double v18 = v19;
        goto LABEL_12;
      }
LABEL_14:
      __assert_rtn("normalizationFactor", "LMDynamicInlineCompletionEnumerator.hpp", 78, "numWords >= 1");
    }
  }
  return v4 < v3;
}

_DWORD *sub_19E507E90(uint64_t a1, unint64_t a2, char *a3, size_t __sz)
{
  uint64_t v6 = (char *)a2;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t result = *(_DWORD **)a1;
  if (__sz <= (v8 - (uint64_t)result) >> 3)
  {
    uint64_t v17 = *(_DWORD **)(a1 + 8);
    float v16 = (void *)(a1 + 8);
    uint64_t v13 = v17;
    int64_t v18 = (char *)v17 - (char *)result;
    unint64_t v19 = ((char *)v17 - (char *)result) >> 3;
    if (v19 < __sz)
    {
      unint64_t v20 = (uint64_t *)(a2 + 8 * v19);
      if (v13 == result) {
        goto LABEL_18;
      }
      if ((unint64_t)(v18 - 8) >= 0x78)
      {
        unint64_t v34 = (v18 & 0xFFFFFFFFFFFFFFF8) - 4;
        uint64_t v35 = (char *)result + v34;
        unint64_t v36 = a2 + v34;
        BOOL v37 = (unint64_t)(result + 1) >= a2 + (v18 & 0xFFFFFFFFFFFFFFF8)
           || a2 + 4 >= (unint64_t)result + (v18 & 0xFFFFFFFFFFFFFFF8);
        char v38 = !v37;
        uint64_t v21 = (uint64_t *)a2;
        BOOL v39 = (unint64_t)v35 <= a2 || (unint64_t)result >= v36;
        if (v39 && (v38 & 1) == 0)
        {
          unint64_t v40 = ((unint64_t)(v18 - 8) >> 3) + 1;
          uint64_t v41 = 8 * (v40 & 0x3FFFFFFFFFFFFFF8);
          long long v42 = (long long *)(a2 + 32);
          BOOL v43 = result + 8;
          uint64_t v44 = v40 & 0x3FFFFFFFFFFFFFF8;
          do
          {
            long long v46 = *(v42 - 2);
            long long v45 = *(v42 - 1);
            long long v48 = *v42;
            long long v47 = v42[1];
            v42 += 4;
            *(v43 - 2) = v46;
            *(v43 - 1) = v45;
            *BOOL v43 = v48;
            v43[1] = v47;
            v43 += 4;
            v44 -= 8;
          }
          while (v44);
          if (v40 == (v40 & 0x3FFFFFFFFFFFFFF8))
          {
LABEL_18:
            if (v20 == (uint64_t *)a3)
            {
              int64_t v15 = 0;
              goto LABEL_68;
            }
            unint64_t v22 = v18 + a2;
            unint64_t v23 = (unint64_t)&a3[-v22 - 8];
            if (v23 < 0x38)
            {
              uint64_t v25 = (char *)v13;
            }
            else
            {
              unint64_t v24 = (unint64_t)v13 - v22;
              uint64_t v25 = (char *)v13;
              if (v24 >= 0x20)
              {
                uint64_t v26 = (v23 >> 3) + 1;
                uint64_t v27 = 2 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
                unint64_t v20 = (uint64_t *)((char *)v20 + v27 * 4);
                uint64_t v28 = v13 + 4;
                size_t v29 = (long long *)(a2 + 8 * v19 + 16);
                uint64_t v30 = v26 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v31 = *v29;
                  *(v28 - 1) = *(v29 - 1);
                  *uint64_t v28 = v31;
                  v28 += 2;
                  v29 += 2;
                  v30 -= 4;
                }
                while (v30);
                uint64_t v25 = (char *)&v13[v27];
                if (v26 == (v26 & 0x3FFFFFFFFFFFFFFCLL)) {
                  goto LABEL_67;
                }
              }
            }
            do
            {
              uint64_t v65 = *v20++;
              *(void *)uint64_t v25 = v65;
              v25 += 8;
            }
            while (v20 != (uint64_t *)a3);
LABEL_67:
            int64_t v15 = v25 - (char *)v13;
            goto LABEL_68;
          }
          uint64_t v21 = (uint64_t *)(a2 + v41);
          uint64_t result = (_DWORD *)((char *)result + v41);
        }
      }
      else
      {
        uint64_t v21 = (uint64_t *)a2;
      }
      do
      {
        _DWORD *result = *(_DWORD *)v21;
        result[1] = *((_DWORD *)v21++ + 1);
        result += 2;
      }
      while (v21 != v20);
      goto LABEL_18;
    }
    if ((char *)a2 == a3)
    {
      unint64_t v33 = (char *)result;
    }
    else
    {
      unint64_t v32 = (unint64_t)&a3[-a2 - 8];
      if (v32 >= 0x78)
      {
        unint64_t v49 = v32 & 0xFFFFFFFFFFFFFFF8 | 4;
        unint64_t v50 = (char *)result + v49;
        unint64_t v51 = a2 + v49;
        unint64_t v52 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
        BOOL v54 = (unint64_t)(result + 1) < a2 + v52 && a2 + 4 < (unint64_t)result + v52;
        if ((unint64_t)v50 <= a2 || (unint64_t)result >= v51)
        {
          if (v54)
          {
            unint64_t v33 = (char *)result;
          }
          else
          {
            uint64_t v56 = (v32 >> 3) + 1;
            uint64_t v57 = 2 * (v56 & 0x3FFFFFFFFFFFFFF8);
            unint64_t v33 = (char *)&result[v57];
            long long v58 = (long long *)(a2 + 32);
            long long v59 = result + 8;
            uint64_t v60 = v56 & 0x3FFFFFFFFFFFFFF8;
            do
            {
              long long v62 = *(v58 - 2);
              long long v61 = *(v58 - 1);
              long long v64 = *v58;
              long long v63 = v58[1];
              v58 += 4;
              *(v59 - 2) = v62;
              *(v59 - 1) = v61;
              *long long v59 = v64;
              v59[1] = v63;
              v59 += 4;
              v60 -= 8;
            }
            while (v60);
            if (v56 == (v56 & 0x3FFFFFFFFFFFFFF8)) {
              goto LABEL_32;
            }
            uint64_t v6 = (char *)(a2 + v57 * 4);
          }
        }
        else
        {
          unint64_t v33 = (char *)result;
        }
      }
      else
      {
        unint64_t v33 = (char *)result;
      }
      do
      {
        *(_DWORD *)unint64_t v33 = *(_DWORD *)v6;
        *((_DWORD *)v33 + 1) = *((_DWORD *)v6 + 1);
        v33 += 8;
        v6 += 8;
      }
      while (v6 != a3);
    }
LABEL_32:
    int64_t v15 = v33 - (char *)result;
    uint64_t v13 = result;
    goto LABEL_68;
  }
  if (result)
  {
    *(void *)(a1 + 8) = result;
    operator delete(result);
    uint64_t v8 = 0;
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
  }
  if (__sz >> 61) {
    goto LABEL_70;
  }
  uint64_t v10 = v8 >> 2;
  if (v8 >> 2 <= __sz) {
    uint64_t v10 = __sz;
  }
  BOOL v37 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8;
  unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v37) {
    unint64_t v11 = v10;
  }
  if (v11 >> 61) {
LABEL_70:
  }
    sub_19E37C7C4();
  uint64_t v12 = 2 * v11;
  uint64_t result = operator new(8 * v11);
  uint64_t v13 = result;
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = &result[v12];
  uint64_t v14 = (char *)result;
  if (v6 != a3)
  {
    uint64_t result = memcpy(result, v6, ((a3 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
    uint64_t v14 = (char *)v13 + ((a3 - v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8;
  }
  int64_t v15 = v14 - (char *)v13;
  float v16 = (void *)(a1 + 8);
LABEL_68:
  *float v16 = (char *)v13 + v15;
  return result;
}

uint64_t sub_19E5081F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    double v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 16) = v4;
      operator delete(v4);
    }
    if (*(char *)(i - 41) < 0) {
      operator delete(*(void **)(i - 64));
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

os_log_t sub_19E508268()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "DynamicInlineCompletion");
  qword_1E945A308 = (uint64_t)result;
  return result;
}

CFStringRef sub_19E508298(const __CFString *result)
{
  v50[1] = *MEMORY[0x1E4F143B8];
  if (result)
  {
    CFStringRef v1 = result;
    if (CFStringGetLength(result))
    {
      CFIndex Length = CFStringGetLength(v1);
      v50[0] = v50;
      uint64_t v4 = MEMORY[0x1F4188790](Length, v3);
      uint64_t v6 = (const UniChar *)((char *)v50 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0));
      if (v4 < 1)
      {
        CFIndex v8 = 0;
      }
      else
      {
        CFIndex v7 = 0;
        CFIndex v8 = 0;
        do
        {
          UniChar CharacterAtIndex = CFStringGetCharacterAtIndex(v1, v7);
          if ((unsigned __int16)((unsigned __int16)(CharacterAtIndex + 21504) >> 2) > 0xAE8u)
          {
            v6[v8] = CharacterAtIndex;
LABEL_6:
            ++v8;
          }
          else
          {
            v10.i32[0] = 0;
            UniChar v12 = 0;
            v13.i16[3] = 0;
            v13.i16[0] = ((28533 * (unsigned __int16)(CharacterAtIndex + 21504)) >> 24) | 0x1100;
            *(__int32 *)((char *)v13.i32 + 2) = (unsigned __int16)((unsigned __int16)(CharacterAtIndex + 21504) % 0x24Cu
                                                                 / 0x1C
                                                                 + 4449);
            v11.i32[0] = (unsigned __int16)(CharacterAtIndex + 21504) % 0x1Cu;
            int8x8_t v14 = (int8x8_t)vdup_lane_s16(vceq_s16(v11, v10), 0);
            int8x8_t v15 = v13;
            v15.i16[2] = (unsigned __int16)(CharacterAtIndex + 21504) % 0x1Cu + 4519;
            int8x8_t v16 = vbsl_s8(v14, v13, v15);
            unint64_t v17 = v16.u16[0] - 4352;
            if (v17 <= 0x12) {
              UniChar v12 = word_19E575B84[v17];
            }
            int v18 = 0;
            CFIndex v19 = v8 + 1;
            v6[v8] = v12;
            int v20 = 22;
            while (1)
            {
              int v21 = v20 + v18;
              if (v20 + v18 < 0 != __OFADD__(v20, v18)) {
                ++v21;
              }
              int v22 = v21 >> 1;
              uint64_t v23 = (uint64_t)v21 >> 1;
              unsigned int v24 = word_19E575C66[3 * v22 + 2];
              if (v24 == v16.u16[1]) {
                break;
              }
              if (v24 >= v16.u16[1]) {
                int v20 = v23 - 1;
              }
              else {
                int v18 = v23 + 1;
              }
              if (v18 > v20)
              {
                unsigned int v25 = v16.u16[1] - 4449;
                if (v25 > 0x14)
                {
                  if (v16.u16[1] == 4514) {
                    __int16 v35 = 4514;
                  }
                  else {
                    __int16 v35 = 0;
                  }
                  if (v16.u16[1] == 4510) {
                    __int16 v26 = 12685;
                  }
                  else {
                    __int16 v26 = v35;
                  }
                }
                else
                {
                  __int16 v26 = word_19E575BAA[v25];
                }
                v8 += 2;
                v6[v19] = v26;
                unsigned __int16 v34 = v16.u16[2];
                if (!v16.i16[2]) {
                  goto LABEL_7;
                }
                goto LABEL_45;
              }
            }
            uint64_t v27 = &word_19E575C66[3 * (int)v23];
            int v28 = *v27;
            if ((v28 - 4449) > 0x14)
            {
              if (v28 == 4514) {
                __int16 v30 = 4514;
              }
              else {
                __int16 v30 = 0;
              }
              if (v28 == 4510) {
                __int16 v29 = 12685;
              }
              else {
                __int16 v29 = v30;
              }
            }
            else
            {
              __int16 v29 = word_19E575BAA[v28 - 4449];
            }
            int v31 = v27[1];
            v6[v19] = v29;
            if ((v31 - 4449) > 0x14)
            {
              if (v31 == 4514) {
                __int16 v32 = 4514;
              }
              else {
                __int16 v32 = 0;
              }
              if (v31 == 4510) {
                __int16 v32 = 12685;
              }
            }
            else
            {
              __int16 v32 = word_19E575BAA[v31 - 4449];
            }
            CFIndex v33 = v8 + 2;
            v8 += 3;
            v6[v33] = v32;
            unsigned __int16 v34 = v16.u16[2];
            if (!v16.i16[2]) {
              goto LABEL_7;
            }
LABEL_45:
            int v36 = 0;
            int v37 = 22;
            while (1)
            {
              int v38 = v37 + v36;
              if (v37 + v36 < 0 != __OFADD__(v37, v36)) {
                ++v38;
              }
              int v39 = v38 >> 1;
              uint64_t v40 = (uint64_t)v38 >> 1;
              unsigned int v41 = word_19E575C66[3 * v39 + 2];
              if (v41 == v34) {
                break;
              }
              if (v41 >= v34) {
                int v37 = v40 - 1;
              }
              else {
                int v36 = v40 + 1;
              }
              if (v36 > v37)
              {
                unint64_t v42 = v34 - 4520;
                if (v42 > 0x1A) {
                  v6[v8] = 0;
                }
                else {
                  v6[v8] = word_19E575BD4[v42];
                }
                goto LABEL_6;
              }
            }
            BOOL v43 = &word_19E575C66[3 * (int)v40];
            unint64_t v44 = *v43 - 4520;
            if (v44 > 0x1A) {
              UniChar v45 = 0;
            }
            else {
              UniChar v45 = word_19E575BD4[v44];
            }
            uint64_t v46 = v43[1];
            v6[v8] = v45;
            unint64_t v47 = v46 - 4520;
            if (v47 > 0x1A) {
              UniChar v48 = 0;
            }
            else {
              UniChar v48 = word_19E575BD4[v47];
            }
            CFIndex v49 = v8 + 1;
            v8 += 2;
            v6[v49] = v48;
          }
LABEL_7:
          ++v7;
        }
        while (v7 != Length);
      }
      return CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v6, v8);
    }
    else
    {
      return &stru_1EF0BEFF0;
    }
  }
  return result;
}

os_log_t sub_19E508684()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "NeuralNetwork");
  qword_1E9459E80 = (uint64_t)result;
  return result;
}

void sub_19E5086B4(void *a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = (const void *)a2(a3);
  sub_19E36E590(&v87, v4);
  CFTypeRef v5 = v87;
  if (v87)
  {
    CFRetain(v87);
    CFRelease(v5);
    sub_19E509478((uint64_t)&v83, (CFDictionaryRef)v5);
    sub_19E509478((uint64_t)&v79, (CFDictionaryRef)v5);
    CFIndex v7 = v80[0];
    uint64_t v6 = v80[1];
  }
  else
  {
    CFIndex v7 = 0;
    uint64_t v6 = 0;
    *(_OWORD *)uint64_t v85 = 0u;
    long long v86 = 0u;
    long long v83 = 0u;
    *(_OWORD *)uint64_t v84 = 0u;
    *(_OWORD *)uint64_t v81 = 0u;
    long long v82 = 0u;
    long long v79 = 0u;
    *(_OWORD *)uint64_t v80 = 0u;
  }
  *((void *)&v79 + 1) = (v6 - v7) >> 3;
  uint64_t v71 = a1 + 2;
  uint64_t v72 = (void **)a1;
  while (1)
  {
    if ((void)v83)
    {
      unint64_t v8 = *((void *)&v83 + 1);
      uint64_t v9 = v79;
      if (*((void *)&v83 + 1) != ((char *)v84[1] - (char *)v84[0]) >> 3) {
        goto LABEL_13;
      }
      if (!(void)v79) {
        break;
      }
    }
    else
    {
      uint64_t v9 = v79;
      if (!(void)v79) {
        break;
      }
    }
    if (*((void *)&v79 + 1) == ((char *)v80[1] - (char *)v80[0]) >> 3) {
      break;
    }
    unint64_t v8 = *((void *)&v83 + 1);
LABEL_13:
    if ((void)v83 == v9 && v8 == *((void *)&v79 + 1)) {
      break;
    }
    if ((v8 & 0x8000000000000000) != 0 || v8 >= ((char *)v84[1] - (char *)v84[0]) >> 3)
    {
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "DictionaryRef_iterator iterator out of range.");
      exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D8] + 16);
      __cxa_throw(exception, (struct type_info *)off_1E599EF00, MEMORY[0x1E4FBA1D0]);
    }
    CFStringRef v11 = (const __CFString *)*((void *)v84[0] + v8);
    if (!v11 || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v11)))
    {
      uint64_t v69 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v69, "Could not convert");
      __cxa_throw(v69, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    sub_19E3721DC(&v91, v11);
    CFTypeRef cf = (const void *)*((void *)v85[1] + *((void *)&v83 + 1));
    if (!cf || (CFTypeID v13 = CFArrayGetTypeID(), v13 != CFGetTypeID(cf)))
    {
      unint64_t v68 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v68, "Could not convert");
      __cxa_throw(v68, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
    int v15 = Count;
    long long v88 = 0uLL;
    BOOL v89 = 0;
    if (!(Count << 32))
    {
      unint64_t v17 = 0;
      int8x8_t v16 = 0;
      if ((int)Count < 1) {
        goto LABEL_95;
      }
LABEL_28:
      CFIndex v18 = 0;
      uint64_t v19 = v15;
      int v20 = v16;
      uint64_t v73 = v15;
      while (2)
      {
        CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)cf, v18);
        if (!ValueAtIndex) {
          goto LABEL_141;
        }
        CFTypeID v22 = CFNumberGetTypeID();
        if (v22 == CFGetTypeID(ValueAtIndex))
        {
          switch(CFNumberGetType(ValueAtIndex))
          {
            case kCFNumberSInt8Type:
              LOBYTE(valuePtr) = 0;
              int Value = CFNumberGetValue(ValueAtIndex, kCFNumberSInt8Type, &valuePtr);
              goto LABEL_56;
            case kCFNumberSInt16Type:
              LOWORD(valuePtr) = 0;
              int v29 = CFNumberGetValue(ValueAtIndex, kCFNumberSInt16Type, &valuePtr);
              goto LABEL_49;
            case kCFNumberSInt32Type:
              LODWORD(valuePtr) = 0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
              goto LABEL_64;
            case kCFNumberSInt64Type:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &valuePtr);
              goto LABEL_64;
            case kCFNumberFloat32Type:
              LODWORD(valuePtr) = 0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberFloat32Type, &valuePtr);
              goto LABEL_41;
            case kCFNumberFloat64Type:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberFloat64Type, &valuePtr);
              goto LABEL_53;
            case kCFNumberCharType:
              LOBYTE(valuePtr) = 0;
              int Value = CFNumberGetValue(ValueAtIndex, kCFNumberCharType, &valuePtr);
LABEL_56:
              uint64_t v30 = Value != 0;
              if (Value) {
                unsigned __int8 v31 = LOBYTE(valuePtr);
              }
              else {
                unsigned __int8 v31 = 0;
              }
              int v32 = -256;
              if ((v30 & (SLOBYTE(valuePtr) < 0)) == 0) {
                int v32 = 0;
              }
              uint64_t v33 = v30 << 32;
              LODWORD(v25) = v32 & 0xFFFFFF00 | v31;
              int v34 = v25 & 0xFFFFFF00;
              break;
            case kCFNumberShortType:
              LOWORD(valuePtr) = 0;
              int v29 = CFNumberGetValue(ValueAtIndex, kCFNumberShortType, &valuePtr);
LABEL_49:
              if (v29) {
                uint64_t v25 = SLOWORD(valuePtr) | 0x100000000;
              }
              else {
                uint64_t v25 = 0;
              }
              goto LABEL_67;
            case kCFNumberIntType:
              LODWORD(valuePtr) = 0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr);
              goto LABEL_64;
            case kCFNumberLongType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberLongType, &valuePtr);
              goto LABEL_64;
            case kCFNumberLongLongType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberLongLongType, &valuePtr);
              goto LABEL_64;
            case kCFNumberFloatType:
              LODWORD(valuePtr) = 0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberFloatType, &valuePtr);
LABEL_41:
              uint64_t v28 = *(float *)&valuePtr;
              goto LABEL_65;
            case kCFNumberDoubleType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, &valuePtr);
              goto LABEL_53;
            case kCFNumberCFIndexType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberCFIndexType, &valuePtr);
              goto LABEL_64;
            case kCFNumberNSIntegerType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberNSIntegerType, &valuePtr);
LABEL_64:
              uint64_t v28 = LODWORD(valuePtr);
              goto LABEL_65;
            case kCFNumberCGFloatType:
              double valuePtr = 0.0;
              int v27 = CFNumberGetValue(ValueAtIndex, kCFNumberCGFloatType, &valuePtr);
LABEL_53:
              uint64_t v28 = valuePtr;
LABEL_65:
              uint64_t v25 = v28 | 0x100000000;
              if (!v27) {
                uint64_t v25 = 0;
              }
LABEL_67:
              int v34 = v25 & 0xFFFFFF00;
              uint64_t v33 = v25 & 0x100000000;
              break;
            default:
              int v34 = 0;
              uint64_t v33 = 0;
              LOBYTE(v25) = 0;
              break;
          }
          uint64_t v26 = v33 | v34 & 0xFFFFFF00;
          uint64_t v25 = v25;
        }
        else
        {
          CFTypeID v24 = CFBooleanGetTypeID();
          if (v24 == CFGetTypeID(ValueAtIndex))
          {
            uint64_t v25 = CFBooleanGetValue(ValueAtIndex);
            uint64_t v26 = 0x100000000;
          }
          else
          {
            uint64_t v25 = 0;
            uint64_t v26 = 0;
          }
        }
        int v35 = v26 | v25;
        if (!((v26 | (unint64_t)v25) >> 32))
        {
LABEL_141:
          BOOL v89 = v17;
          *(void *)&long long v88 = v16;
          uint64_t v67 = __cxa_allocate_exception(0x10uLL);
          MEMORY[0x19F3BD790](v67, "Could not convert");
          __cxa_throw(v67, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
        }
        if (v20 < v17)
        {
          *(_DWORD *)int v20 = v35;
          v20 += 4;
        }
        else
        {
          uint64_t v36 = (v20 - v16) >> 2;
          unint64_t v37 = v36 + 1;
          if ((unint64_t)(v36 + 1) >> 62)
          {
            *((void *)&v88 + 1) = v20;
            BOOL v89 = v17;
            *(void *)&long long v88 = v16;
            sub_19E37C7C4();
          }
          if ((v17 - v16) >> 1 > v37) {
            unint64_t v37 = (v17 - v16) >> 1;
          }
          if ((unint64_t)(v17 - v16) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v38 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v38 = v37;
          }
          if (v38)
          {
            if (v38 >> 62)
            {
              *((void *)&v88 + 1) = v20;
              BOOL v89 = v17;
              *(void *)&long long v88 = v16;
              sub_19E37C2B8();
            }
            int v39 = operator new(4 * v38);
          }
          else
          {
            int v39 = 0;
          }
          uint64_t v40 = &v39[4 * v36];
          *(_DWORD *)uint64_t v40 = v35;
          unsigned int v41 = v40 + 4;
          if (v20 != v16)
          {
            unint64_t v42 = v20 - 4 - v16;
            if (v42 < 0x2C)
            {
              BOOL v43 = v20;
              goto LABEL_89;
            }
            if ((unint64_t)(v16 - v39) < 0x20)
            {
              BOOL v43 = v20;
              goto LABEL_89;
            }
            uint64_t v44 = (v42 >> 2) + 1;
            BOOL v43 = &v20[-4 * (v44 & 0x7FFFFFFFFFFFFFF8)];
            UniChar v45 = &v39[4 * v36 - 16];
            uint64_t v46 = v20 - 16;
            uint64_t v47 = v44 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v48 = *(_OWORD *)v46;
              *(v45 - 1) = *((_OWORD *)v46 - 1);
              *UniChar v45 = v48;
              v45 -= 2;
              v46 -= 32;
              v47 -= 8;
            }
            while (v47);
            v40 -= 4 * (v44 & 0x7FFFFFFFFFFFFFF8);
            if (v44 != (v44 & 0x7FFFFFFFFFFFFFF8))
            {
              do
              {
LABEL_89:
                int v49 = *((_DWORD *)v43 - 1);
                v43 -= 4;
                *((_DWORD *)v40 - 1) = v49;
                v40 -= 4;
              }
              while (v43 != v16);
            }
          }
          unint64_t v17 = &v39[4 * v38];
          if (v16) {
            operator delete(v16);
          }
          int8x8_t v16 = v40;
          int v20 = v41;
          uint64_t v19 = v73;
        }
        if (++v18 == v19)
        {
          *((void *)&v88 + 1) = v20;
          BOOL v89 = v17;
          *(void *)&long long v88 = v16;
          goto LABEL_95;
        }
        continue;
      }
    }
    if (Count << 32 < 0) {
      sub_19E37C7C4();
    }
    int8x8_t v16 = (char *)operator new((4 * Count) & 0x3FFFFFFFFLL);
    unint64_t v17 = &v16[4 * v15];
    *(void *)&long long v88 = v16;
    *((void *)&v88 + 1) = v16;
    if (v15 >= 1) {
      goto LABEL_28;
    }
LABEL_95:
    *(_OWORD *)long long __p = v91;
    uint64_t v77 = v92;
    unint64_t v50 = (void *)v88;
    char v78 = (void *)v88;
    unint64_t v52 = (char *)v72[1];
    unint64_t v51 = (unint64_t)v72[2];
    if ((unint64_t)v52 < v51)
    {
      if (SHIBYTE(v92) < 0)
      {
        cfa = (void *)v88;
        sub_19E39369C(v72[1], (void *)v91, *((unint64_t *)&v91 + 1));
        unint64_t v50 = cfa;
      }
      else
      {
        *((void *)v52 + 2) = v92;
        *(_OWORD *)unint64_t v52 = *(_OWORD *)__p;
      }
      long long v59 = v50;
      v72[1] = v52 + 24;
      v72[1] = v52 + 24;
      if (v50) {
        goto LABEL_109;
      }
      goto LABEL_110;
    }
    uint64_t v53 = (char *)*v72;
    unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((v52 - (unsigned char *)*v72) >> 3);
    unint64_t v55 = v54 + 1;
    if (v54 + 1 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C7C4();
    }
    unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v51 - (void)v53) >> 3);
    if (2 * v56 > v55) {
      unint64_t v55 = 2 * v56;
    }
    if (v56 >= 0x555555555555555) {
      unint64_t v57 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v57 = v55;
    }
    uint64_t v94 = v71;
    if (v57)
    {
      if (v57 > 0xAAAAAAAAAAAAAAALL) {
        sub_19E37C2B8();
      }
      long long v58 = (char *)operator new(24 * v57);
    }
    else
    {
      long long v58 = 0;
    }
    uint64_t v60 = &v58[24 * v54];
    *(void *)&long long v91 = v58;
    *((void *)&v91 + 1) = v60;
    long long v92 = v60;
    uint64_t v93 = &v58[24 * v57];
    if (SHIBYTE(v77) < 0)
    {
      sub_19E39369C(v60, __p[0], (unint64_t)__p[1]);
      uint64_t v53 = (char *)*v72;
      unint64_t v52 = (char *)v72[1];
      uint64_t v60 = (char *)*((void *)&v91 + 1);
      long long v61 = v92;
      if (v52 == *v72)
      {
LABEL_119:
        long long v63 = v53;
        goto LABEL_120;
      }
    }
    else
    {
      *(_OWORD *)uint64_t v60 = *(_OWORD *)__p;
      *((void *)v60 + 2) = v77;
      long long v61 = &v58[24 * v54];
      if (v52 == v53) {
        goto LABEL_119;
      }
    }
    do
    {
      long long v62 = *(_OWORD *)(v52 - 24);
      *((void *)v60 - 1) = *((void *)v52 - 1);
      *(_OWORD *)(v60 - 24) = v62;
      v60 -= 24;
      *((void *)v52 - 2) = 0;
      *((void *)v52 - 1) = 0;
      *((void *)v52 - 3) = 0;
      v52 -= 24;
    }
    while (v52 != v53);
    long long v63 = (char *)*v72;
    uint64_t v53 = (char *)v72[1];
LABEL_120:
    long long v64 = v61 + 24;
    char *v72 = v60;
    v72[1] = v61 + 24;
    uint64_t v65 = (char *)v72[2];
    v72[2] = v93;
    uint64_t v93 = v65;
    *(void *)&long long v91 = v63;
    *((void *)&v91 + 1) = v63;
    if (v53 != v63)
    {
      uint64_t v66 = (void **)(v53 - 24);
      do
      {
        long long v92 = (char *)v66;
        if (*((char *)v66 + 23) < 0) {
          operator delete(*v66);
        }
        v66 -= 3;
      }
      while (v66 + 3 != (void **)v63);
      uint64_t v53 = v63;
    }
    if (v53) {
      operator delete(v53);
    }
    long long v59 = v78;
    v72[1] = v64;
    if (v78) {
LABEL_109:
    }
      operator delete(v59);
LABEL_110:
    if (SHIBYTE(v77) < 0) {
      operator delete(__p[0]);
    }
    ++*((void *)&v83 + 1);
  }
  if (v81[1])
  {
    *(void **)&long long v82 = v81[1];
    operator delete(v81[1]);
  }
  if (v80[0])
  {
    v80[1] = v80[0];
    operator delete(v80[0]);
  }
  if (v85[1])
  {
    *(void **)&long long v86 = v85[1];
    operator delete(v85[1]);
  }
  if (v84[0])
  {
    v84[1] = v84[0];
    operator delete(v84[0]);
  }
  if (v87) {
    CFRelease(v87);
  }
}

void sub_19E509054(_Unwind_Exception *a1)
{
  sub_19E3EB09C(v1);
  _Unwind_Resume(a1);
}

const void **sub_19E5091A0(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  *a1 = 0;
  return a1;
}

uint64_t sub_19E5091D8(uint64_t a1)
{
  uint64_t v6 = 0;
  CFIndex v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1EC009458;
  uint64_t v9 = off_1EC009458;
  if (!off_1EC009458)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E5092C4;
    v5[3] = &unk_1E59A1B70;
    v5[4] = &v6;
    sub_19E5092C4((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(a1);
}

void *sub_19E5092C4(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  os_log_t result = dlsym(v2, "MRLNeuralNetworkCopyOutputNamesAndDimensions");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009458 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E509404()
{
  uint64_t result = _sl_dlopen();
  qword_1E9459E78 = result;
  return result;
}

uint64_t sub_19E509478(uint64_t a1, CFDictionaryRef theDict)
{
  *(void *)a1 = theDict;
  *(_OWORD *)(a1 + 40) = 0u;
  uint64_t v3 = (const void ***)(a1 + 40);
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(void *)(a1 + 56) = 0;
  if (theDict)
  {
    unint64_t Count = CFDictionaryGetCount(theDict);
    unint64_t v5 = Count;
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = (*(void *)(a1 + 24) - v6) >> 3;
    if (Count <= v7)
    {
      if (Count < v7) {
        *(void *)(a1 + 24) = v6 + 8 * Count;
      }
    }
    else
    {
      sub_19E3C6F50(a1 + 16, Count - v7);
    }
    uint64_t v8 = *(const void ***)(a1 + 40);
    unint64_t v9 = (uint64_t)(*(void *)(a1 + 48) - (void)v8) >> 3;
    if (v5 <= v9)
    {
      if (v5 < v9) {
        *(void *)(a1 + 48) = &v8[v5];
      }
    }
    else
    {
      sub_19E3C6F50((uint64_t)v3, v5 - v9);
      uint64_t v8 = *v3;
    }
    CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)a1, *(const void ***)(a1 + 16), v8);
  }
  return a1;
}

uint64_t sub_19E50953C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(void *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_19E509580(uint64_t a1)
{
  uint64_t v6 = 0;
  unint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v2 = (uint64_t (*)(uint64_t))off_1EC009448;
  unint64_t v9 = off_1EC009448;
  if (!off_1EC009448)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E50966C;
    v5[3] = &unk_1E59A1B48;
    v5[4] = &v6;
    sub_19E50966C((uint64_t)v5);
    uint64_t v2 = (uint64_t (*)(uint64_t))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v2)
  {
    dlerror();
    uint64_t v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  return v2(a1);
}

void *sub_19E50966C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkCopyInputNamesAndDimensions");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009448 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E5097AC(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkCreate");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009438 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E5098EC(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "kMRLNeuralNetworkOptionModelURLKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_1EC009430 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E509A2C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "kMRLNeuralNetworkOptionEngineKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_1EC009440 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E509B6C(uint64_t a1, const UInt8 *a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  CFStringRef v40 = 0;
  unsigned int v41 = &v40;
  uint64_t v42 = 0x2000000000;
  long long v6 = (const void **)qword_1EC009430;
  BOOL v43 = (void *)qword_1EC009430;
  if (!qword_1EC009430)
  {
    *(void *)uint64_t v44 = MEMORY[0x1E4F143A8];
    *(void *)&v44[8] = 0x40000000;
    *(void *)&v44[16] = sub_19E5098EC;
    CFTypeRef v45 = &unk_1E59A1A78;
    uint64_t v46 = &v40;
    sub_19E5098EC((uint64_t)v44);
    long long v6 = (const void **)v41[3];
  }
  _Block_object_dispose(&v40, 8);
  if (!v6)
  {
    dlerror();
    abort_report_np();
LABEL_88:
    __break(1u);
LABEL_89:
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
LABEL_84:
    int v35 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v44 = 0;
      _os_log_error_impl(&dword_19E36B000, v35, OS_LOG_TYPE_ERROR, "Unable to load network model", v44, 2u);
    }
    exception = __cxa_allocate_exception(0x20uLL);
    sub_19E382340(v44, "MRLNeuralNetworkCreate returned nullptr");
    sub_19E3F5604(exception, (long long *)v44);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  uint64_t v7 = *v6;
  if (v7)
  {
    CFRetain(v7);
    sub_19E372124(&cf, v7);
  }
  else
  {
    CFTypeRef cf = 0;
  }
  int v8 = *((char *)a2 + 23);
  if (v8 >= 0) {
    unint64_t v9 = a2;
  }
  else {
    unint64_t v9 = *(const UInt8 **)a2;
  }
  if (v8 >= 0) {
    CFIndex v10 = a2[23];
  }
  else {
    CFIndex v10 = *((void *)a2 + 1);
  }
  CFURLRef v11 = CFURLCreateWithBytes(0, v9, v10, 0, 0);
  v38[1] = v11;
  if (!v11)
  {
    int v34 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v34, "Could not construct");
    __cxa_throw(v34, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFStringRef v40 = 0;
  unsigned int v41 = &v40;
  uint64_t v42 = 0x2000000000;
  UniChar v12 = (const void **)qword_1EC009440;
  BOOL v43 = (void *)qword_1EC009440;
  if (!qword_1EC009440)
  {
    *(void *)uint64_t v44 = MEMORY[0x1E4F143A8];
    *(void *)&v44[8] = 0x40000000;
    *(void *)&v44[16] = sub_19E509A2C;
    CFTypeRef v45 = &unk_1E59A1AD8;
    uint64_t v46 = &v40;
    sub_19E509A2C((uint64_t)v44);
    UniChar v12 = (const void **)v41[3];
  }
  _Block_object_dispose(&v40, 8);
  if (!v12)
  {
    dlerror();
    abort_report_np();
    goto LABEL_88;
  }
  CFTypeID v13 = *v12;
  if (v13) {
    CFRetain(v13);
  }
  sub_19E372124(v38, v13);
  char v14 = *(unsigned char *)(a3 + 23);
  if (v14 >= 0) {
    int v15 = (const UInt8 *)a3;
  }
  else {
    int v15 = *(const UInt8 **)a3;
  }
  if (!v15)
  {
    CFStringRef v17 = 0;
    CFStringRef v40 = 0;
    CFTypeRef v18 = cf;
    if (!cf) {
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  if (v14 >= 0) {
    CFIndex v16 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    CFIndex v16 = *(void *)(a3 + 8);
  }
  CFStringRef v17 = CFStringCreateWithBytes(0, v15, v16, 0x8000100u, 0);
  CFStringRef v40 = v17;
  if (!v17)
  {
    unint64_t v37 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v37, "Could not construct");
    __cxa_throw(v37, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFTypeRef v18 = cf;
  if (cf) {
LABEL_30:
  }
    CFRetain(v18);
LABEL_31:
  *(void *)uint64_t v44 = v18;
  CFRetain(v11);
  *(void *)&v44[8] = v11;
  CFTypeRef v19 = v38[0];
  if (v38[0]) {
    CFRetain(v38[0]);
  }
  *(void *)&v44[16] = v19;
  if (v17) {
    CFRetain(v17);
  }
  CFTypeRef v45 = v17;
  CFDictionaryRef v20 = sub_19E411038((uint64_t *)v44, 2uLL);
  if (v45) {
    CFRelease(v45);
  }
  if (*(void *)&v44[16]) {
    CFRelease(*(CFTypeRef *)&v44[16]);
  }
  if (*(void *)&v44[8]) {
    CFRelease(*(CFTypeRef *)&v44[8]);
  }
  if (*(void *)v44) {
    CFRelease(*(CFTypeRef *)v44);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v38[0]) {
    CFRelease(v38[0]);
  }
  CFRelease(v11);
  if (cf) {
    CFRelease(cf);
  }
  CFStringRef v40 = 0;
  unsigned int v41 = &v40;
  uint64_t v42 = 0x2000000000;
  CFStringRef v21 = (CFStringRef)off_1EC009438;
  BOOL v43 = off_1EC009438;
  if (!off_1EC009438)
  {
    *(void *)uint64_t v44 = MEMORY[0x1E4F143A8];
    *(void *)&v44[8] = 0x40000000;
    *(void *)&v44[16] = sub_19E5097AC;
    CFTypeRef v45 = &unk_1E59A1B20;
    uint64_t v46 = &v40;
    sub_19E5097AC((uint64_t)v44);
    CFStringRef v21 = v41[3];
  }
  _Block_object_dispose(&v40, 8);
  if (!v21)
  {
    dlerror();
    abort_report_np();
    goto LABEL_88;
  }
  uint64_t v22 = ((uint64_t (*)(CFDictionaryRef, void))v21)(v20, 0);
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v23 = (void **)(a1 + 8);
  *(void *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  CFTypeID v24 = (void **)(a1 + 32);
  *(_OWORD *)(a1 + 40) = 0u;
  *(void *)(a1 + 56) = a1 + 64;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = a1 + 88;
  *(void *)a1 = v22;
  if (!v22)
  {
    if (qword_1EC0095B8 == -1) {
      goto LABEL_84;
    }
    goto LABEL_89;
  }
  sub_19E5086B4(v44, sub_19E509580, v22);
  uint64_t v25 = (void **)*v23;
  if (*v23)
  {
    uint64_t v26 = *(void ***)(a1 + 16);
    int v27 = *v23;
    if (v26 != v25)
    {
      do
      {
        if (*((char *)v26 - 1) < 0) {
          operator delete(*(v26 - 3));
        }
        v26 -= 3;
      }
      while (v26 != v25);
      int v27 = *v23;
    }
    *(void *)(a1 + 16) = v25;
    operator delete(v27);
    *uint64_t v23 = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
  }
  *(_OWORD *)(a1 + 8) = *(_OWORD *)v44;
  *(void *)(a1 + 24) = *(void *)&v44[16];
  sub_19E5086B4(v44, sub_19E5091D8, *(void *)a1);
  uint64_t v28 = (void **)*v24;
  if (*v24)
  {
    int v29 = *(void ***)(a1 + 40);
    uint64_t v30 = *v24;
    if (v29 != v28)
    {
      do
      {
        if (*((char *)v29 - 1) < 0) {
          operator delete(*(v29 - 3));
        }
        v29 -= 3;
      }
      while (v29 != v28);
      uint64_t v30 = *v24;
    }
    *(void *)(a1 + 40) = v28;
    operator delete(v30);
    *CFTypeID v24 = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v44;
  *(void *)(a1 + 48) = *(void *)&v44[16];
  if (v20) {
    CFRelease(v20);
  }
  if (qword_1E9459E70 != -1) {
    dispatch_once(&qword_1E9459E70, &unk_1EF0BEF18);
  }
  unsigned __int8 v31 = qword_1E9459E80;
  if (os_log_type_enabled((os_log_t)qword_1E9459E80, OS_LOG_TYPE_DEFAULT))
  {
    if (*((char *)a2 + 23) >= 0) {
      int v32 = a2;
    }
    else {
      int v32 = *(const UInt8 **)a2;
    }
    *(_DWORD *)uint64_t v44 = 136315394;
    *(void *)&v44[4] = "NeuralNetwork";
    *(_WORD *)&v44[12] = 2080;
    *(void *)&v44[14] = v32;
    _os_log_impl(&dword_19E36B000, v31, OS_LOG_TYPE_DEFAULT, "%s: Loaded neural language model: %s", v44, 0x16u);
  }
  return a1;
}

void sub_19E50A278(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, const void *a13, const void *a14, const void *a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

void sub_19E50A404(uint64_t *a1, uint64_t a2)
{
  uint64_t v7 = 0;
  uint64_t v3 = *a1;
  if (a2) {
    sub_19E50A544(v3, a2, (uint64_t)&v7);
  }
  else {
    sub_19E50A544(v3, 0, (uint64_t)&v7);
  }
  sub_19E440E14((uint64_t)a1);
  uint64_t v4 = v7;
  if (v7)
  {
    long long __p = operator new(0x19uLL);
    long long v6 = xmmword_19E573160;
    strcpy((char *)__p, "MRLNeuralNetworkPredict");
    sub_19E50A648((uint64_t *)&__p, v4);
    if (SHIBYTE(v6) < 0) {
      operator delete(__p);
    }
  }
}

void sub_19E50A4AC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  __cxa_begin_catch(a1);
  if (qword_1EC0095B8 != -1) {
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
  }
  int v15 = qword_1EC0095B0;
  if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p) = 0;
    _os_log_impl(&dword_19E36B000, v15, OS_LOG_TYPE_DEFAULT, "Unable to run inference on the NN Model", (uint8_t *)&__p, 2u);
  }
  __cxa_end_catch();
  JUMPOUT(0x19E50A49CLL);
}

uint64_t sub_19E50A544(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  CFURLRef v11 = &v10;
  uint64_t v12 = 0x2000000000;
  long long v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))off_1EC0093D0;
  CFTypeID v13 = off_1EC0093D0;
  if (!off_1EC0093D0)
  {
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 0x40000000;
    void v9[2] = sub_19E50A78C;
    v9[3] = &unk_1E59A1B98;
    v9[4] = &v10;
    sub_19E50A78C((uint64_t)v9);
    long long v6 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v11[3];
  }
  _Block_object_dispose(&v10, 8);
  if (!v6)
  {
    dlerror();
    int v8 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v10, 8);
    _Unwind_Resume(v8);
  }
  return v6(a1, a2, a3);
}

void sub_19E50A648(uint64_t *a1, CFErrorRef err)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = CFErrorCopyDescription(err);
  if (qword_1EC0095B8 != -1) {
    dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
  }
  unint64_t v5 = qword_1EC0095B0;
  if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
  {
    if (*((char *)a1 + 23) >= 0) {
      long long v6 = a1;
    }
    else {
      long long v6 = (uint64_t *)*a1;
    }
    *(_DWORD *)buf = 136315394;
    int v8 = v6;
    __int16 v9 = 2112;
    CFStringRef v10 = v4;
    _os_log_error_impl(&dword_19E36B000, v5, OS_LOG_TYPE_ERROR, "%s() failed: %@", buf, 0x16u);
    if (v4) {
      goto LABEL_5;
    }
  }
  else if (v4)
  {
LABEL_5:
    CFRelease(v4);
  }
  CFRelease(err);
}

void sub_19E50A764(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E50A78C(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkPredict");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0093D0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_19E50A8CC(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  uint64_t v3 = (void (*)(uint64_t, void))off_1EC0091D8;
  __int16 v9 = off_1EC0091D8;
  if (!off_1EC0091D8)
  {
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    v5[2] = sub_19E50A9D0;
    v5[3] = &unk_1E59A1BC0;
    v5[4] = &v6;
    sub_19E50A9D0((uint64_t)v5);
    uint64_t v3 = (void (*)(uint64_t, void))v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (!v3)
  {
    dlerror();
    CFStringRef v4 = (_Unwind_Exception *)abort_report_np();
    _Block_object_dispose(&v6, 8);
    _Unwind_Resume(v4);
  }
  v3(v2, 0);
  sub_19E440E14((uint64_t)a1);
}

void *sub_19E50A9D0(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkClear");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0091D8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E50AB10(uint64_t a1, const UInt8 *a2)
{
  uint64_t v2 = a2;
  CFIndex v4 = a2[23];
  if ((v4 & 0x80u) != 0) {
    a2 = *(const UInt8 **)a2;
  }
  if (a2)
  {
    CFIndex v5 = *((void *)v2 + 1);
    if ((v4 & 0x80u) == 0) {
      CFIndex v6 = v4;
    }
    else {
      CFIndex v6 = v5;
    }
    CFStringRef v7 = CFStringCreateWithBytes(0, a2, v6, 0x8000100u, 0);
    if (!v7)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v7 = 0;
  }
  uint64_t v13 = 0;
  char v14 = &v13;
  uint64_t v15 = 0x2000000000;
  __int16 v9 = (uint64_t (*)(uint64_t, CFStringRef))off_1EC009450;
  CFIndex v16 = off_1EC009450;
  if (!off_1EC009450)
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    v12[2] = sub_19E50ACD4;
    v12[3] = &unk_1E59A1BE8;
    v12[4] = &v13;
    sub_19E50ACD4((uint64_t)v12);
    __int16 v9 = (uint64_t (*)(uint64_t, CFStringRef))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (v9)
  {
    uint64_t v10 = v9(a1, v7);
    if (v7) {
      CFRelease(v7);
    }
    return v10;
  }
  else
  {
    dlerror();
    uint64_t result = abort_report_np();
    __break(1u);
  }
  return result;
}

void sub_19E50AC94(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E50ACA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  CFIndex v4 = va_arg(va1, const void *);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  _Block_object_dispose(va1, 8);
  sub_19E3C6F1C((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_19E50ACD4(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkGetOutputDimension");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009450 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E50AE14(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkCopyStates");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC0093E8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_19E50AF54(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  v5[0] = 0;
  if (!qword_1E9459E78)
  {
    v5[1] = MEMORY[0x1E4F143A8];
    v5[2] = 0x40000000;
    v5[3] = sub_19E509404;
    v5[4] = &unk_1E59A1AB0;
    void v5[5] = v5;
    long long v6 = xmmword_1E59A1A98;
    uint64_t v7 = 0;
    qword_1E9459E78 = _sl_dlopen();
    uint64_t v3 = (void *)v5[0];
    uint64_t v2 = (void *)qword_1E9459E78;
    if (qword_1E9459E78)
    {
      if (!v5[0]) {
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v3 = (void *)abort_report_np();
    }
    free(v3);
    goto LABEL_5;
  }
  uint64_t v2 = (void *)qword_1E9459E78;
LABEL_5:
  uint64_t result = dlsym(v2, "MRLNeuralNetworkCopyIncrementalStates");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_1EC009208 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_19E50B094(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unsigned __int8 v8 = 0;
  if (a2) {
    *a2 = (*(uint64_t (**)(void, unsigned __int8 *))(**(void **)(a1 + 16) + 8))(*(void *)(a1 + 16), &v8);
  }
  if (a3)
  {
    *(int64x2_t *)a3 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    *(void *)(a3 + 16) = 0;
    *(_WORD *)(a3 + 24) = 0;
    *(unsigned char *)(a3 + 32) = 1;
    *(_OWORD *)(a3 + 40) = xmmword_19E572FD0;
    *(_OWORD *)(a3 + 64) = xmmword_19E572FD0;
    *(void *)(a3 + 88) = 0;
    *(void *)(a3 + 96) = 0;
    *(void *)(a3 + 80) = 0xFFEFFFFFFFFFFFFFLL;
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(**(void **)(*(void *)(a1 + 8) + 24) + 8 * v8);
    *(_DWORD *)(a3 + 56) = 0;
    *(void *)a3 = v6;
    *(void *)(a3 + 104) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 32))(v5);
    *(_DWORD *)(a3 + 116) = 9;
    *(unsigned char *)(a3 + 112) = 0;
  }
  return 1;
}

uint64_t sub_19E50B190(uint64_t a1)
{
  uint64_t v2 = (***(uint64_t (****)(void))(a1 + 16))(*(void *)(a1 + 16));
  char v4 = 0;
  if (v2)
  {
    (*(void (**)(void, char *))(**(void **)(a1 + 16) + 8))(*(void *)(a1 + 16), &v4);
    if (!v4) {
      return 0;
    }
  }
  return v2;
}

void sub_19E50B228(void *a1)
{
  *a1 = &unk_1EF0BBD28;
  uint64_t v1 = a1[2];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 24))(v1);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E50B2B4(void *a1)
{
  *a1 = &unk_1EF0BBD28;
  uint64_t v2 = a1[2];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  return a1;
}

void sub_19E50B320()
{
}

void sub_19E50B7C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v44 & 1) == 0)
    {
LABEL_8:
      a22 = (void *)*MEMORY[0x1E4FBA408];
      uint64_t v46 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(void **)((char *)&a22 + *(a22 - 3)) = *(void **)(MEMORY[0x1E4FBA408] + 64);
      a24 = v46;
      a25 = MEMORY[0x1E4FBA470] + 16;
      if (a38 < 0) {
        operator delete(a33);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x19F3BDC30](&a41);
      uint64_t v47 = *(void *)(v41 + 24);
      *(void *)(v41 + 24) = 0;
      if (v47)
      {
        long long v48 = *(void **)v47;
        if (*(void *)v47)
        {
          *(void *)(v47 + 8) = v48;
          operator delete(v48);
        }
        MEMORY[0x19F3BDCF0](v47, 0x1080C409A65DFB4);
      }
      int v49 = *v43;
      *BOOL v43 = 0;
      if (v49)
      {
        uint64_t v50 = *v49;
        if (*v49)
        {
          uint64_t v51 = *(void *)(v50 + 24);
          if (v51)
          {
            sub_19E4AB828(v51 + 8);
            MEMORY[0x19F3BDCF0](v51, 0x1020C403F824CD1);
            if (*(void *)v50) {
              free(*(void **)v50);
            }
          }
          MEMORY[0x19F3BDCF0](v50, 0x1030C40FC63861FLL);
        }
        MEMORY[0x19F3BDCF0](v49, 0x20C4093837F09);
      }
      if (*(void *)v41) {
        munmap(*(void **)v41, *(void *)(v41 + 8));
      }
      *(void *)(v41 + 8) = 0;
      _Unwind_Resume(a1);
    }
  }
  else if (!v44)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v42);
  goto LABEL_8;
}

uint64_t sub_19E50BAA0()
{
  return 0;
}

uint64_t sub_19E50BAA8()
{
  return 0;
}

uint64_t sub_19E50BAB0()
{
  return 0;
}

uint64_t sub_19E50BAB8()
{
  return 0;
}

uint64_t sub_19E50BAC0()
{
  return 3;
}

void sub_19E50BAC8(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  for (uint64_t i = *(void **)(a1 + 112); i; uint64_t i = (void *)*i)
  {
    unsigned __int8 v8 = (const void *)LXLexiconCopyEntryForTokenID();
    if (v8)
    {
      if ((LXEntryGetMetaFlags() & 0x4000000) != 0)
      {
        if (LXEntryGetUsageCount() > 3)
        {
          uint64_t v9 = (const void *)LXEntryCopyString();
          LXLexiconUpdateMetaFlags();
          LXLexiconIncrementUsageCount();
          if (v9) {
            CFRelease(v9);
          }
        }
        else
        {
          LXEntryGetTokenID();
          LXLexiconRemoveEntry();
        }
      }
      CFRelease(v8);
    }
  }
  if (*(void *)(a1 + 120))
  {
    char v4 = *(void **)(a1 + 112);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        operator delete(v4);
        char v4 = v5;
      }
      while (v5);
    }
    *(void *)(a1 + 112) = 0;
    uint64_t v6 = *(void *)(a1 + 104);
    if (v6)
    {
      for (uint64_t j = 0; j != v6; ++j)
        *(void *)(*(void *)(a1 + 96) + 8 * j) = 0;
    }
    *(void *)(a1 + 120) = 0;
  }
  std::mutex::unlock(v2);
}

void sub_19E50BC14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

void sub_19E50BC54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (std::mutex *)(a1 + 32);
  std::mutex::lock((std::mutex *)(a1 + 32));
  if (a3 >= 0x1F4)
  {
    uint64_t v7 = *(unsigned __int8 *)(a2 + 23);
    if ((v7 & 0x80u) != 0) {
      uint64_t v7 = *(void *)(a2 + 8);
    }
    if (v7)
    {
      CFStringRef v8 = sub_19E3C2A64(a2);
      uint64_t v9 = (const void *)LXLexiconCopyEntryForTokenID();
      if (v9 || (sub_19E50BDC8(*(void *)(a1 + 24), v8, a3) & 1) != 0)
      {
        uint64_t v10 = (const void *)LXLexiconCopyEntryForTokenID();
        if (v9) {
          CFRelease(v9);
        }
        if ((LXEntryGetMetaFlags() & 0x4000000) == 0)
        {
          LXLexiconUpdateMetaFlags();
          LXLexiconIncrementUsageCount();
          sub_19E4435B0((float *)(a1 + 96), a3, a3);
        }
        if (v10) {
          CFRelease(v10);
        }
      }
      if (v8) {
        CFRelease(v8);
      }
    }
  }
  std::mutex::unlock(v6);
}

void sub_19E50BD90(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50BDC8(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  CEMStringContainsEmoji();
  Mutable = (const void *)LXEntryCreateMutable();
  uint64_t v13 = Mutable;
  uint64_t v6 = LXLexiconAddEntryWithTokenID();
  if ((v6 & 1) == 0)
  {
    uint64_t v7 = (char *)operator new(0x28uLL);
    strcpy(v7, "Failed to add new entry into lexicon");
    sub_19E37774C(a2, __p);
    if (v15 >= 0) {
      CFStringRef v8 = __p;
    }
    else {
      CFStringRef v8 = *(unsigned char **)__p;
    }
    sub_19E439798("failed to add new entry with string=%s, tokenID=%u", (uint64_t)&v11, v8, a3);
    if (v15 < 0) {
      operator delete(*(void **)__p);
    }
    if (qword_1E945A320 != -1) {
      dispatch_once(&qword_1E945A320, &unk_1EF0BEF38);
    }
    uint64_t v9 = qword_1E945A318;
    if (os_log_type_enabled((os_log_t)qword_1E945A318, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long __p = 136315138;
      *(void *)&__p[4] = v7;
      _os_log_impl(&dword_19E36B000, v9, OS_LOG_TYPE_INFO, "%s", __p, 0xCu);
    }
    if (v12 < 0) {
      operator delete(v11);
    }
    operator delete(v7);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v6;
}

void sub_19E50BF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, const void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  operator delete(v20);
  sub_19E4E52B0(&a14);
  _Unwind_Resume(a1);
}

os_log_t sub_19E50BFD0()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "DynamicLexiconImpl");
  qword_1E945A318 = (uint64_t)result;
  return result;
}

uint64_t sub_19E50C000()
{
  uint64_t result = LXLexiconCopyEntryForTokenID();
  if (result)
  {
    uint64_t v1 = (const void *)result;
    unsigned int UserBitfield = LXEntryGetUserBitfield();
    CFRelease(v1);
    return (UserBitfield >> 1) & 1;
  }
  return result;
}

void sub_19E50C050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E50C064()
{
  uint64_t v0 = LXLexiconCopyEntryForTokenID();
  if (!v0) {
    __assert_rtn("blocklistToken", "LMDynamicLexiconImpl.cpp", 474, "entry");
  }
  uint64_t v1 = (const void *)v0;
  uint64_t v2 = (const void *)LXEntryCopyString();
  if (v2)
  {
    LXEntryGetUserBitfield();
    LXLexiconSetUserBitfield();
    CFRelease(v2);
  }
  CFRelease(v1);
}

void sub_19E50C10C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50C134()
{
  uint64_t v0 = LXLexiconCopyEntryForTokenID();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = (const void *)v0;
  Usageunint64_t Count = LXEntryGetUsageCount();
  CFRelease(v1);
  return UsageCount;
}

void sub_19E50C18C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50C1A0()
{
  uint64_t v0 = LXLexiconCopyEntryForTokenID();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = (const void *)v0;
  Penaltyunint64_t Count = LXEntryGetPenaltyCount();
  CFRelease(v1);
  return PenaltyCount;
}

void sub_19E50C1F8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E50C20C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= 0x1F4)
  {
    CFStringRef v5 = sub_19E3C2A64(a2);
    uint64_t v6 = (const void *)LXLexiconCopyEntryForTokenID();
    if (v6 || (sub_19E50BDC8(*(void *)(a1 + 24), v5, a3) & 1) != 0)
    {
      LXLexiconIncrementPenaltyCount();
      if (v6) {
        CFRelease(v6);
      }
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

void sub_19E50C2C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E50C2E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= 0x1F4)
  {
    CFStringRef v5 = sub_19E3C2A64(a2);
    uint64_t v6 = (const void *)LXLexiconCopyEntryForTokenID();
    if (v6 || (sub_19E50BDC8(*(void *)(a1 + 24), v5, a3) & 1) != 0)
    {
      LXLexiconIncrementUsageCount();
      if (v6) {
        CFRelease(v6);
      }
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

void sub_19E50C398(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E50C3BC(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x4002000000;
  int v27 = sub_19E50C7A8;
  uint64_t v28 = sub_19E50C7CC;
  int v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v16 = 0;
  CFStringRef v17 = &v16;
  uint64_t v18 = 0x4002000000;
  CFTypeRef v19 = sub_19E50C7A8;
  CFDictionaryRef v20 = sub_19E50C7CC;
  long long __p = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  v15[0] = 0;
  v15[1] = v15;
  v15[2] = 0x2000000000;
  v15[3] = a2;
  CFTypeRef cf = (CFTypeRef)LXLexiconCreateRootCursor();
  LXCursorEnumerateEntriesRecursively();
  char v4 = v25;
  uint64_t v5 = v25[5];
  uint64_t v6 = v25[6];
  if (v5 != v6)
  {
    do
    {
      LXLexiconRemoveEntry();
      v5 += 4;
    }
    while (v5 != v6);
    char v4 = v25;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a2 + 160))(a2, v4 + 5);
  uint64_t v7 = (int *)v17[5];
  for (uint64_t i = (int *)v17[6]; v7 != i; ++v7)
  {
    int v9 = *v7;
    uint64_t v10 = (const void *)LXLexiconCopyEntryForTokenID();
    int v32 = v10;
    if (v10)
    {
      LXEntryGetUserBitfield();
      uint64_t v11 = (const void *)LXEntryCopyString();
      *(void *)buf = v11;
      LXLexiconSetUserBitfield();
      if (v11) {
        CFRelease(v11);
      }
      CFRelease(v10);
    }
    else
    {
      if (qword_1E945A320 != -1) {
        dispatch_once(&qword_1E945A320, &unk_1EF0BEF38);
      }
      char v12 = qword_1E945A318;
      if (os_log_type_enabled((os_log_t)qword_1E945A318, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = *(void *)(a1 + 16);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v9;
        __int16 v34 = 2112;
        uint64_t v35 = v13;
        _os_log_impl(&dword_19E36B000, v12, OS_LOG_TYPE_DEFAULT, "Entry for tokenID=%u is missing from the '%@' lexicon", buf, 0x12u);
      }
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  _Block_object_dispose(v15, 8);
  _Block_object_dispose(&v16, 8);
  if (__p)
  {
    uint64_t v22 = __p;
    operator delete(__p);
  }
  _Block_object_dispose(&v24, 8);
  if (v29)
  {
    uint64_t v30 = v29;
    operator delete(v29);
  }
}

void sub_19E50C704(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_19E50C7A8(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E50C7CC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_19E50C7E4(uint64_t a1)
{
  if (LXEntryGetUserBitfield())
  {
    double v58 = 0.0;
    char Timestamp = LXEntryGetTimestamp();
    int TokenID = LXEntryGetTokenID();
    int v57 = TokenID;
    if (Timestamp)
    {
      if (v58 >= *(double *)(a1 + 56)) {
        return;
      }
      uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      if ((*(float (**)(uint64_t, int *, uint64_t, double))(*(void *)v4 + 80))(v4, &v57, 1, v58) <= 1.0)
      {
        uint64_t v5 = *(void **)(*(void *)(a1 + 48) + 8);
        uint64_t v7 = (char *)v5[6];
        unint64_t v24 = v5[7];
        if ((unint64_t)v7 >= v24)
        {
          CFStringRef v8 = (char *)v5[5];
          uint64_t v36 = (v7 - v8) >> 2;
          unint64_t v37 = v36 + 1;
          if (!((unint64_t)(v36 + 1) >> 62))
          {
            uint64_t v38 = v24 - (void)v8;
            if (v38 >> 1 > v37) {
              unint64_t v37 = v38 >> 1;
            }
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v39 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v39 = v37;
            }
            if (v39)
            {
              if (v39 >> 62) {
                goto LABEL_70;
              }
              CFStringRef v40 = operator new(4 * v39);
            }
            else
            {
              CFStringRef v40 = 0;
            }
            uint64_t v41 = &v40[4 * v36];
            uint64_t v42 = &v40[4 * v39];
            *uint64_t v41 = v57;
            uint64_t v25 = v41 + 1;
            if (v7 != v8)
            {
              unint64_t v50 = v7 - v8 - 4;
              if (v50 < 0x2C) {
                goto LABEL_73;
              }
              if ((unint64_t)(v8 - v40) < 0x20) {
                goto LABEL_73;
              }
              uint64_t v51 = (v50 >> 2) + 1;
              unint64_t v52 = &v40[4 * v36 - 16];
              uint64_t v53 = v7 - 16;
              uint64_t v54 = v51 & 0x7FFFFFFFFFFFFFF8;
              do
              {
                long long v55 = *(_OWORD *)v53;
                *(v52 - 1) = *((_OWORD *)v53 - 1);
                *unint64_t v52 = v55;
                v52 -= 2;
                v53 -= 32;
                v54 -= 8;
              }
              while (v54);
              v41 -= v51 & 0x7FFFFFFFFFFFFFF8;
              v7 -= 4 * (v51 & 0x7FFFFFFFFFFFFFF8);
              if (v51 != (v51 & 0x7FFFFFFFFFFFFFF8))
              {
LABEL_73:
                do
                {
                  int v56 = *((_DWORD *)v7 - 1);
                  v7 -= 4;
                  *--uint64_t v41 = v56;
                }
                while (v7 != v8);
              }
            }
            goto LABEL_65;
          }
LABEL_69:
          sub_19E37C7C4();
        }
      }
      else
      {
        uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8);
        uint64_t v7 = (char *)v5[6];
        unint64_t v6 = v5[7];
        if ((unint64_t)v7 >= v6)
        {
          CFStringRef v8 = (char *)v5[5];
          uint64_t v9 = (v7 - v8) >> 2;
          unint64_t v10 = v9 + 1;
          if (!((unint64_t)(v9 + 1) >> 62))
          {
            uint64_t v11 = v6 - (void)v8;
            if (v11 >> 1 > v10) {
              unint64_t v10 = v11 >> 1;
            }
            if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v12 = v10;
            }
            if (!v12)
            {
              uint64_t v13 = 0;
              goto LABEL_49;
            }
            if (!(v12 >> 62))
            {
              uint64_t v13 = operator new(4 * v12);
LABEL_49:
              uint64_t v41 = &v13[4 * v9];
              uint64_t v42 = &v13[4 * v12];
              *uint64_t v41 = v57;
              uint64_t v25 = v41 + 1;
              if (v7 != v8)
              {
                unint64_t v43 = v7 - v8 - 4;
                if (v43 < 0x2C) {
                  goto LABEL_74;
                }
                if ((unint64_t)(v8 - v13) < 0x20) {
                  goto LABEL_74;
                }
                uint64_t v44 = (v43 >> 2) + 1;
                CFTypeRef v45 = &v13[4 * v9 - 16];
                uint64_t v46 = v7 - 16;
                uint64_t v47 = v44 & 0x7FFFFFFFFFFFFFF8;
                do
                {
                  long long v48 = *(_OWORD *)v46;
                  *(v45 - 1) = *((_OWORD *)v46 - 1);
                  *CFTypeRef v45 = v48;
                  v45 -= 2;
                  v46 -= 32;
                  v47 -= 8;
                }
                while (v47);
                v41 -= v44 & 0x7FFFFFFFFFFFFFF8;
                v7 -= 4 * (v44 & 0x7FFFFFFFFFFFFFF8);
                if (v44 != (v44 & 0x7FFFFFFFFFFFFFF8))
                {
LABEL_74:
                  do
                  {
                    int v49 = *((_DWORD *)v7 - 1);
                    v7 -= 4;
                    *--uint64_t v41 = v49;
                  }
                  while (v7 != v8);
                }
              }
LABEL_65:
              void v5[5] = v41;
              void v5[6] = v25;
              v5[7] = v42;
              if (v8) {
                operator delete(v8);
              }
              goto LABEL_67;
            }
LABEL_70:
            sub_19E37C2B8();
          }
          goto LABEL_69;
        }
      }
      *(_DWORD *)uint64_t v7 = v57;
      uint64_t v25 = v7 + 4;
LABEL_67:
      void v5[6] = v25;
      return;
    }
    int v14 = TokenID;
    char v15 = *(void **)(*(void *)(a1 + 32) + 8);
    CFStringRef v17 = (char *)v15[6];
    unint64_t v16 = v15[7];
    if ((unint64_t)v17 < v16)
    {
      *(_DWORD *)CFStringRef v17 = TokenID;
      v15[6] = v17 + 4;
      return;
    }
    uint64_t v18 = (char *)v15[5];
    uint64_t v19 = (v17 - v18) >> 2;
    unint64_t v20 = v19 + 1;
    if ((unint64_t)(v19 + 1) >> 62) {
      goto LABEL_69;
    }
    uint64_t v21 = v16 - (void)v18;
    if (v21 >> 1 > v20) {
      unint64_t v20 = v21 >> 1;
    }
    if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v22 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v22 = v20;
    }
    if (v22)
    {
      if (v22 >> 62) {
        goto LABEL_70;
      }
      uint64_t v23 = operator new(4 * v22);
    }
    else
    {
      uint64_t v23 = 0;
    }
    uint64_t v26 = &v23[4 * v19];
    int v27 = &v23[4 * v22];
    _DWORD *v26 = v14;
    uint64_t v28 = v26 + 1;
    if (v17 != v18)
    {
      unint64_t v29 = v17 - v18 - 4;
      if (v29 < 0x2C) {
        goto LABEL_75;
      }
      if ((unint64_t)(v18 - v23) < 0x20) {
        goto LABEL_75;
      }
      uint64_t v30 = (v29 >> 2) + 1;
      uint64_t v31 = &v23[4 * v19 - 16];
      int v32 = v17 - 16;
      uint64_t v33 = v30 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v34 = *(_OWORD *)v32;
        *(v31 - 1) = *((_OWORD *)v32 - 1);
        _OWORD *v31 = v34;
        v31 -= 2;
        v32 -= 32;
        v33 -= 8;
      }
      while (v33);
      v26 -= v30 & 0x7FFFFFFFFFFFFFF8;
      v17 -= 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
      if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_75:
        do
        {
          int v35 = *((_DWORD *)v17 - 1);
          v17 -= 4;
          *--uint64_t v26 = v35;
        }
        while (v17 != v18);
      }
    }
    v15[5] = v26;
    v15[6] = v28;
    v15[7] = v27;
    if (v18) {
      operator delete(v18);
    }
    v15[6] = v28;
  }
}

uint64_t sub_19E50CC18(uint64_t a1)
{
  sub_19E50BAC8(a1);
  return LXLexiconWrite();
}

void sub_19E50CC50()
{
}

uint64_t sub_19E50CC80()
{
  uint64_t result = LXLexiconCopyEntryForTokenID();
  if (result)
  {
    uint64_t v1 = (const void *)result;
    unsigned int MetaFlags = LXEntryGetMetaFlags();
    CFRelease(v1);
    return (MetaFlags >> 29) & 1;
  }
  return result;
}

void sub_19E50CCD0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50CCE4()
{
  return LXLexiconRemoveEntry();
}

BOOL sub_19E50CCEC(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  CFStringRef v5 = sub_19E3C2A64(a2);
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  int v13 = 0;
  uint64_t v12 = 0x2000000000;
  LXLexiconEnumerateEntriesForString();
  int v6 = *((_DWORD *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  if (v6 || (CEMStringContainsEmoji(), int v8 = LXLexiconAdd(), (*a4 = v8) == 0))
  {
    BOOL v7 = 0;
    if (!v5) {
      return v7;
    }
    goto LABEL_6;
  }
  LXLexiconSetUserBitfield();
  BOOL v7 = *a4 != 0;
  if (v5) {
LABEL_6:
  }
    CFRelease(v5);
  return v7;
}

void sub_19E50CE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

uint64_t sub_19E50CE5C(uint64_t a1)
{
  return MEMORY[0x1F412A808](*(void *)(a1 + 24));
}

uint64_t sub_19E50CE64(uint64_t a1)
{
  return MEMORY[0x1F412A740](*(void *)(a1 + 24));
}

uint64_t sub_19E50CE6C(uint64_t a1)
{
  return MEMORY[0x1F412A7E0](*(void *)(a1 + 24));
}

uint64_t sub_19E50CE74()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  int v6 = 0;
  uint64_t v5 = 0x2000000000;
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  LXCursorEnumerateEntriesRecursivelyWithPolicy();
  uint64_t v1 = *((unsigned int *)v4 + 6);
  if (RootCursor) {
    CFRelease(RootCursor);
  }
  _Block_object_dispose(&v3, 8);
  return v1;
}

void sub_19E50CF34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  BOOL v7 = va_arg(va1, const void *);
  sub_19E421014((const void **)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50CF5C(uint64_t result)
{
  return result;
}

void sub_19E50CF74()
{
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  LXCursorEnumerateEntriesRecursively();
  if (RootCursor) {
    CFRelease(RootCursor);
  }
}

void sub_19E50D00C(_Unwind_Exception *a1)
{
  sub_19E421014((const void **)(v1 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_19E50D020(uint64_t a1)
{
  LXEntryGetTokenID();
  LXEntryGetProbability();
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
  return v2();
}

uint64_t sub_19E50D088(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

void sub_19E50D090()
{
}

void sub_19E50D0F4()
{
}

void sub_19E50D0FC()
{
  v0[4] = *MEMORY[0x1E4F143B8];
  v0[0] = &unk_1EF0BD668;
  v0[3] = v0;
  sub_19E51273C();
}

void sub_19E50D1EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

void sub_19E50D264(uint64_t a1@<X8>)
{
}

uint64_t sub_19E50D274(uint64_t a1, const UInt8 *a2)
{
  return sub_19E5124F8(*(void *)(a1 + 24), a2);
}

uint64_t sub_19E50D27C()
{
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  int v5 = 0;
  uint64_t v4 = 0x2000000000;
  LXLexiconEnumerateEntriesForString();
  uint64_t v0 = *((unsigned int *)v3 + 6);
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_19E50D324(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_19E50D33C(uint64_t a1)
{
  sub_19E50D374(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E50D374(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BA898;
  uint64_t v2 = *(void **)(a1 + 112);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v4) {
    operator delete(v4);
  }
  std::mutex::~mutex((std::mutex *)(a1 + 32));
  int v5 = *(const void **)(a1 + 24);
  if (v5) {
    CFRelease(v5);
  }
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  int v6 = *(const void **)(a1 + 16);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(a1 + 16) = 0;
  BOOL v7 = *(const void **)(a1 + 8);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(a1 + 8) = 0;
  return a1;
}

uint64_t sub_19E50D424(uint64_t a1, uint64_t a2, const void *a3, CFStringRef theString, const void *a5)
{
  *(void *)a1 = &unk_1EF0BA898;
  *(void *)(a1 + 8) = 0;
  uint64_t v10 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
  if (theString)
  {
    Copy = (__CFString *)CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString);
  }
  else
  {
    Copy = CFStringCreateMutable(0, 0);
    CFStringAppend(Copy, @"Dynamic");
    CFStringAppend(Copy, @".");
    CFStringRef v12 = (const __CFString *)MEMORY[0x19F3BCDE0](a3);
    CFStringAppend(Copy, v12);
  }
  *(void *)(a1 + 16) = Copy;
  if (a5
    && (int v13 = __dynamic_cast(a5, (const struct __class_type_info *)&unk_1EF0B6348, (const struct __class_type_info *)&unk_1EF0B6670, 0)) != 0)
  {
    int v14 = (const void *)v13[3];
  }
  else
  {
    int v14 = 0;
  }
  Mutable = CFDictionaryCreateMutable(*v10, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFStringRef v16 = sub_19E3C2A64(a2);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72460], Copy);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72430], v16);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72458], a3);
  CFStringRef v17 = (const __CFString *)MEMORY[0x19F3BCDE0](a3);
  if (CFEqual(v17, @"mul")) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72468], (const void *)*MEMORY[0x1E4F1CFD0]);
  }
  if (v14) {
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72428], v14);
  }
  uint64_t v23 = 0;
  uint64_t v18 = LXLexiconCreateMutable();
  if (!v18)
  {
    exception = __cxa_allocate_exception(0x20uLL);
    unint64_t v22 = (char *)operator new(0x28uLL);
    strcpy(v22, "Failed to create the lexicon: (null)");
    *(void *)exception = &unk_1EF0BD3F0;
    sub_19E39369C(exception + 8, v22, 0x24uLL);
    __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  *(void *)(a1 + 32) = 850045863;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v18;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 1065353216;
  if (*(const void **)(a1 + 8) != a3)
  {
    CFRetain(a3);
    uint64_t v19 = *(const void **)(a1 + 8);
    if (v19) {
      CFRelease(v19);
    }
    *(void *)(a1 + 8) = a3;
  }
  if (theString) {
    LXLexiconRepositoryAddOrUpdate();
  }
  return a1;
}

void sub_19E50D7B0(_Unwind_Exception *a1)
{
  operator delete(v5);
  CFRelease(v4);
  if (v3) {
    CFRelease(v3);
  }
  if (v2) {
    CFRelease(v2);
  }
  BOOL v7 = *(const void **)(v1 + 16);
  if (v7) {
    CFRelease(v7);
  }
  *(void *)(v1 + 16) = 0;
  int v8 = *(const void **)(v1 + 8);
  if (v8) {
    CFRelease(v8);
  }
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

uint64_t sub_19E50D8F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 280))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
  return v7;
}

void sub_19E50D974(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50D988(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 8) + 272))(*(void *)(a1 + 8), a2, a3, a4);
  std::mutex::unlock(v8);
  return v9;
}

void sub_19E50DA1C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50DA30(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 264))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
  return v5;
}

void sub_19E50DAAC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50DAC0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 256))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
  return v7;
}

void sub_19E50DB44(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50DB58(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 248))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
  return v7;
}

void sub_19E50DBD4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50DBE8(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void))(**(void **)(a1 + 8) + 240))(*(void *)(a1 + 8));
  std::mutex::unlock(v2);
}

void sub_19E50DC50(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50DC64(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 232))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
}

void sub_19E50DCE4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50DCF8()
{
  return 0;
}

void sub_19E50DD00()
{
}

void sub_19E50DD2C()
{
}

void sub_19E50DD58()
{
}

void sub_19E50DD84()
{
}

void sub_19E50DDB0(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  int v8 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t, uint64_t, float))(**(void **)(a1 + 8) + 184))(*(void *)(a1 + 8), a2, a3, a4);
  std::mutex::unlock(v8);
}

void sub_19E50DE40(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50DE54(uint64_t a1, uint64_t a2, double a3)
{
  int v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t, double))(**(void **)(a1 + 8) + 176))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
}

void sub_19E50DEDC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50DEF0(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void))(**(void **)(a1 + 8) + 168))(*(void *)(a1 + 8));
  std::mutex::unlock(v2);
}

void sub_19E50DF58(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50DF6C(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_19E50DF74(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)a2 + 216))(&v13, a2);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 8) + 160))(&v12);
  uint64_t v4 = v12;
  uint64_t v12 = 0;
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = v4;
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    uint64_t v6 = v12;
    uint64_t v12 = 0;
    if (v6) {
      (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    }
  }
  std::mutex::unlock((std::mutex *)(a1 + 16));
  uint64_t v7 = v13;
  int v13 = 0;
  uint64_t v11 = v7;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)a2 + 224))(a2, &v11);
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9)
  {
    if (*v9)
    {
      sub_19E374B30(v9);
      if (*v9) {
        MEMORY[0x19F3BDCF0](*v9, 0x1010C4006136809);
      }
    }
    uint64_t result = MEMORY[0x19F3BDCF0](v9, 0x20C4093837F09);
  }
  uint64_t v10 = v13;
  int v13 = 0;
  if (v10)
  {
    if (*v10)
    {
      sub_19E374B30(v10);
      if (*v10) {
        MEMORY[0x19F3BDCF0](*v10, 0x1010C4006136809);
      }
    }
    return MEMORY[0x19F3BDCF0](v10, 0x20C4093837F09);
  }
  return result;
}

void sub_19E50E160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, uint64_t *);
  uint64_t v5 = va_arg(va1, void);
  sub_19E42C508((uint64_t **)va);
  sub_19E42C508((uint64_t **)va1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50E194(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 144))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
  return v5;
}

void sub_19E50E208(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50E21C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 8) + 136))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
  return v5;
}

void sub_19E50E290(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50E2A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 8) + 128))(*(void *)(a1 + 8), a2, a3, a4);
  std::mutex::unlock(v8);
  return v9;
}

void sub_19E50E330(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50E344(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 120))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
}

void sub_19E50E3BC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50E3D0(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void))(**(void **)(a1 + 8) + 112))(*(void *)(a1 + 8));
  std::mutex::unlock(v2);
}

void sub_19E50E438(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50E44C(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 104))(*(void *)(a1 + 8));
  std::mutex::unlock(v2);
  return v3;
}

void sub_19E50E4B0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50E4C4(uint64_t a1)
{
  uint64_t v2 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 96))(*(void *)(a1 + 8));
  std::mutex::unlock(v2);
  return v3;
}

void sub_19E50E528(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50E53C(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x4002000000;
  uint64_t v23 = sub_19E50E788;
  unint64_t v24 = sub_19E50E7AC;
  long long __p = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v5 = v21;
  unsigned int v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 96))(*(void *)(a1 + 8));
  uint64_t v7 = v6;
  int v8 = (unsigned char *)v5[5];
  if (v6 > (unint64_t)((v5[7] - (uint64_t)v8) >> 4))
  {
    uint64_t v9 = (unsigned char *)v5[6];
    uint64_t v10 = (char *)operator new(16 * v6);
    uint64_t v11 = &v10[(v9 - v8) & 0xFFFFFFFFFFFFFFF0];
    uint64_t v12 = v11;
    if (v9 != v8)
    {
      int v13 = &v10[(v9 - v8) & 0xFFFFFFFFFFFFFFF0];
      do
      {
        uint64_t v12 = v13 - 16;
        *((_OWORD *)v13 - 1) = *((_OWORD *)v9 - 1);
        v9 -= 16;
        v13 -= 16;
      }
      while (v9 != v8);
    }
    void v5[5] = (uint64_t)v12;
    void v5[6] = (uint64_t)v11;
    v5[7] = (uint64_t)&v10[16 * v7];
    if (v8) {
      operator delete(v8);
    }
  }
  uint64_t v14 = *(void *)(a1 + 8);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  v19[2] = sub_19E50E7C4;
  void v19[3] = &unk_1E59A1CF8;
  v19[4] = &v20;
  (*(void (**)(uint64_t, void *))(*(void *)v14 + 88))(v14, v19);
  std::mutex::unlock(v4);
  char v18 = 0;
  char v15 = (double *)v21[5];
  CFStringRef v16 = (unsigned int *)v21[6];
  if (v15 != (double *)v16)
  {
    do
    {
      (*(void (**)(uint64_t, void, char *, double))(a2 + 16))(a2, *(unsigned int *)v15, &v18, v15[1]);
      v15 += 2;
      if (v18) {
        BOOL v17 = 1;
      }
      else {
        BOOL v17 = v15 == (double *)v16;
      }
    }
    while (!v17);
  }
  _Block_object_dispose(&v20, 8);
  if (__p)
  {
    uint64_t v26 = __p;
    operator delete(__p);
  }
}

void sub_19E50E74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_19E50E788(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E50E7AC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_19E50E7C4(uint64_t a1, int a2, double a3)
{
  uint64_t v5 = *(void **)(*(void *)(a1 + 32) + 8);
  uint64_t v7 = (double *)v5[6];
  unint64_t v6 = v5[7];
  if ((unint64_t)v7 >= v6)
  {
    uint64_t v9 = (double *)v5[5];
    uint64_t v10 = ((char *)v7 - (char *)v9) >> 4;
    unint64_t v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v12 = v6 - (void)v9;
    if (v12 >> 3 > v11) {
      unint64_t v11 = v12 >> 3;
    }
    BOOL v13 = (unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
    if (!v13) {
      unint64_t v14 = v11;
    }
    if (v14 >> 60) {
      sub_19E37C2B8();
    }
    uint64_t v15 = 16 * v14;
    CFStringRef v16 = (char *)operator new(16 * v14);
    BOOL v17 = (double *)&v16[16 * v10];
    *(_DWORD *)BOOL v17 = a2;
    v17[1] = a3;
    int v8 = v17 + 2;
    if (v7 == v9)
    {
      char v18 = &v16[16 * v10];
    }
    else
    {
      do
      {
        char v18 = (char *)(v17 - 2);
        *((_OWORD *)v17 - 1) = *((_OWORD *)v7 - 1);
        v7 -= 2;
        v17 -= 2;
      }
      while (v7 != v9);
    }
    void v5[5] = v18;
    void v5[6] = v8;
    v5[7] = &v16[v15];
    if (v9) {
      operator delete(v9);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v7 = a2;
    v7[1] = a3;
    int v8 = v7 + 2;
  }
  void v5[6] = v8;
}

uint64_t sub_19E50E8D4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 56))();
}

void sub_19E50E8FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
}

void sub_19E50E97C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50E990(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
}

void sub_19E50EA10(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50EA24(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), a2);
  std::mutex::unlock(v4);
}

void sub_19E50EAA4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50EAB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 24))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
  return v7;
}

void sub_19E50EB34(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E50EB48(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  uint64_t v7 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 16))(*(void *)(a1 + 8), a2, a3);
  std::mutex::unlock(v6);
  return v7;
}

void sub_19E50EBC4(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E50EBD8(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB3E8;
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E50EC6C(uint64_t a1)
{
  *(void *)a1 = &unk_1EF0BB3E8;
  std::mutex::~mutex((std::mutex *)(a1 + 16));
  uint64_t v2 = *(void *)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void sub_19E50ECE0(uint64_t a1, CFStringRef theString)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!theString) {
    goto LABEL_20;
  }
  uint64_t Length = CFStringGetLength(theString);
  CFIndex maxBufLen = 0;
  CFIndex usedBufLen = 0;
  if (Length > 165)
  {
    v23.location = 0;
    v23.length = Length;
    if (Length != CFStringGetBytes(theString, v23, 0x8000100u, 0, 0, 0, 0, &maxBufLen)) {
      goto LABEL_20;
    }
    int v8 = (char *)malloc_type_malloc(maxBufLen + 1, 0xFC12D035uLL);
    if (!v8) {
      goto LABEL_20;
    }
    *(_WORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0x100000;
    *(unsigned char *)(a1 + 6) = 0;
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
    v24.location = 0;
    v24.length = Length;
    if (Length == CFStringGetBytes(theString, v24, 0x8000100u, 0, 0, (UInt8 *)v8, maxBufLen, &usedBufLen))
    {
      v8[usedBufLen] = 0;
      *(_WORD *)&buffer[4] = 0;
      *(_DWORD *)buffer = 0x100000;
      char v18 = 1;
      uint64_t v19 = 0;
      __int16 v9 = strlen(v8);
      unsigned __int16 v10 = v9;
      long long v20 = 0uLL;
      if (v9)
      {
        sub_19E50EFF8((unsigned __int16 *)buffer, v9);
        if (*(unsigned __int16 *)&buffer[2] < v10) {
          __assert_rtn("initialize", "LMTIString.cpp", 269, "len <= m_capacity");
        }
        if (v19) {
          unint64_t v11 = v19;
        }
        else {
          unint64_t v11 = &v20;
        }
        memcpy(v11, v8, v10);
        int v12 = *(_DWORD *)&buffer[2];
        char v13 = v18;
        unint64_t v14 = v19;
        *(_WORD *)a1 = v10;
        *(_DWORD *)(a1 + 2) = v12;
        *(unsigned char *)(a1 + 6) = v13;
        *(void *)(a1 + 8) = v14;
        if (!v14) {
          *(_OWORD *)(a1 + 16) = v20;
        }
        goto LABEL_25;
      }
      *(_WORD *)a1 = v9;
      *(_DWORD *)(a1 + 2) = 16;
      *(unsigned char *)(a1 + 6) = 1;
    }
    else
    {
      *(_WORD *)(a1 + 4) = 0;
      *(_DWORD *)a1 = 0x100000;
      *(unsigned char *)(a1 + 6) = 0;
    }
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
LABEL_25:
    free(v8);
    return;
  }
  v22.location = 0;
  v22.length = Length;
  if (Length != CFStringGetBytes(theString, v22, 0x8000100u, 0, 0, buffer, 1000, &usedBufLen))
  {
LABEL_20:
    *(_WORD *)(a1 + 4) = 0;
    *(_DWORD *)a1 = 0x100000;
    *(unsigned char *)(a1 + 6) = 0;
    *(void *)(a1 + 8) = 0;
    *(unsigned char *)(a1 + 16) = 0;
    return;
  }
  buffer[usedBufLen] = 0;
  *(_WORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0x100000;
  *(unsigned char *)(a1 + 6) = 1;
  *(void *)(a1 + 8) = 0;
  __int16 v5 = strlen(buffer);
  unsigned __int16 v6 = v5;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  if (v5)
  {
    sub_19E50EFF8((unsigned __int16 *)a1, v5);
    if (*(unsigned __int16 *)(a1 + 2) < v6) {
      __assert_rtn("initialize", "LMTIString.cpp", 269, "len <= m_capacity");
    }
    if (*(void *)(a1 + 8)) {
      uint64_t v7 = *(void **)(a1 + 8);
    }
    else {
      uint64_t v7 = (void *)(a1 + 16);
    }
    memcpy(v7, buffer, v6);
    *(_WORD *)a1 = v6;
  }
}

void sub_19E50EFF8(unsigned __int16 *a1, __int16 a2)
{
  unsigned int v2 = a1[1];
  if (v2 <= 0xF) {
    __assert_rtn("ensure_capacity", "LMTIString.cpp", 303, "m_capacity >= InitialCapacity");
  }
  unsigned __int16 v3 = a2 + 1;
  if (v2 <= (unsigned __int16)(a2 + 1))
  {
    if (!*((unsigned char *)a1 + 6))
    {
      *((unsigned char *)a1 + 6) = 1;
      __int16 v5 = (const void *)*((void *)a1 + 1);
      *((void *)a1 + 1) = 0;
      size_t v6 = *a1;
      *((void *)a1 + 2) = 0;
      *((void *)a1 + 3) = 0;
      if (v5)
      {
        if (v6)
        {
          sub_19E50EFF8(a1, v6);
          if (a1[1] < v6) {
            __assert_rtn("initialize", "LMTIString.cpp", 269, "len <= m_capacity");
          }
          if (*((void *)a1 + 1)) {
            uint64_t v7 = (void *)*((void *)a1 + 1);
          }
          else {
            uint64_t v7 = a1 + 8;
          }
          memcpy(v7, v5, v6);
          *a1 = v6;
          unsigned int v2 = a1[1];
        }
      }
    }
    unsigned __int16 v8 = v2;
    if (v2 < v3)
    {
      unsigned __int16 v8 = v2;
      do
        unsigned __int16 v8 = 2 * v8 + 16;
      while ((v8 & 0xFFFEu) < v3);
      a1[1] = v8;
    }
    if (v8 >= 0x11u)
    {
      if (*((unsigned char *)a1 + 6) == 1 && (__int16 v9 = (void *)*((void *)a1 + 1)) != 0)
      {
        uint64_t v10 = v2;
        unint64_t v11 = (char *)malloc_type_realloc(v9, v8 + 1, 0xF65CB5B5uLL);
        *((void *)a1 + 1) = v11;
        bzero(&v11[v10], a1[1] - v10 + 1);
      }
      else
      {
        int v12 = malloc_type_malloc(v8 + 1, 0x3EEE0C76uLL);
        *((void *)a1 + 1) = v12;
        bzero(v12, a1[1] + 1);
        if (*a1)
        {
          strlcpy(*((char **)a1 + 1), (const char *)a1 + 16, a1[1] + 1);
          *((void *)a1 + 2) = 0;
          *((void *)a1 + 3) = 0;
        }
      }
      if (*((unsigned char *)a1 + 6) != 1 || !*((void *)a1 + 1)) {
        __assert_rtn("ensure_capacity", "LMTIString.cpp", 329, "data_in_allocated_internal_buffer()");
      }
    }
  }
}

void sub_19E50F1DC(uint64_t a1, unsigned __int16 *a2)
{
  v21[1] = *MEMORY[0x1E4F143B8];
  int v4 = *a2;
  if (a2[2])
  {
    if (v4 == a2[2])
    {
LABEL_3:
      uint64_t v5 = *a2;
      MEMORY[0x1F4188790]();
      uint64_t v7 = (char *)v21 - v6;
      if (v5)
      {
        for (unint64_t i = 0; i != v5; ++i)
        {
          unint64_t v9 = *a2;
          unsigned __int16 v10 = v9 - 1;
          if (!*a2) {
            unsigned __int16 v10 = 0;
          }
          if (i >= v9) {
            unsigned __int16 v11 = v10;
          }
          else {
            unsigned __int16 v11 = i;
          }
          int v12 = (unsigned __int16 *)*((void *)a2 + 1);
          if (!v12) {
            int v12 = a2 + 8;
          }
          v7[i] = __tolower(*((char *)v12 + v11));
        }
      }
      v7[v5] = 0;
      if (*((void *)a2 + 1)) {
        char v13 = (const char *)*((void *)a2 + 1);
      }
      else {
        char v13 = (const char *)(a2 + 8);
      }
      if (!strcmp(v13, v7))
      {
        sub_19E50F564(a1, a2);
      }
      else
      {
        *(_WORD *)(a1 + 4) = 0;
        *(_DWORD *)a1 = 0x100000;
        *(unsigned char *)(a1 + 6) = 1;
        *(void *)(a1 + 8) = 0;
        unsigned __int16 v14 = strlen(v7);
        unsigned __int16 v15 = v14;
        *(void *)(a1 + 16) = 0;
        *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
        if (v14)
        {
          unsigned int v16 = v14;
          sub_19E50EFF8((unsigned __int16 *)a1, v14);
          if (*(unsigned __int16 *)(a1 + 2) < v16) {
            __assert_rtn("initialize", "LMTIString.cpp", 269, "len <= m_capacity");
          }
          if (*(void *)(a1 + 8)) {
            BOOL v17 = *(void **)(a1 + 8);
          }
          else {
            BOOL v17 = (void *)(a1 + 16);
          }
          memcpy(v17, v7, v15);
          *(_WORD *)a1 = v15;
        }
      }
      return;
    }
  }
  else
  {
    sub_19E50F43C(a2);
    if (v4 == a2[2]) {
      goto LABEL_3;
    }
  }
  Mutable = CFStringCreateMutable(0, 0);
  uint64_t v19 = Mutable;
  if (*((void *)a2 + 1)) {
    long long v20 = (const char *)*((void *)a2 + 1);
  }
  else {
    long long v20 = (const char *)(a2 + 8);
  }
  CFStringAppendCString(Mutable, v20, 0x8000100u);
  CFStringLowercase(v19, 0);
  sub_19E50ECE0(a1, v19);
  if (v19) {
    CFRelease(v19);
  }
}

void sub_19E50F418(_Unwind_Exception *exception_object)
{
  unsigned __int16 v3 = *(void **)(v1 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v1 + 6) == 1) {
      free(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

unsigned __int16 *sub_19E50F43C(unsigned __int16 *result)
{
  result[2] = 0;
  unsigned int v1 = *result;
  if (*result)
  {
    int v2 = 0;
    __int16 v3 = 0;
    int v4 = (unsigned __int16 *)*((void *)result + 1);
    if (!v4) {
      int v4 = result + 8;
    }
    do
    {
      uint64_t v6 = (unsigned __int16)v2 + 1;
      if (v1 == (unsigned __int16)(v2 + 1)) {
        goto LABEL_7;
      }
      unsigned int v7 = *((unsigned __int8 *)v4 + (unsigned __int16)v2);
      if ((v7 + 11) < 0xCDu) {
        goto LABEL_7;
      }
      unint64_t v8 = *((unsigned __int8 *)v4 + v6);
      if ((v7 & 0xF0) == 0xE0)
      {
        if ((a00000000000000[v7 & 0xF] >> (*((unsigned char *)v4 + v6) >> 5)))
        {
          LODWORD(v6) = v2 + 2;
          if (v1 == (unsigned __int16)(v2 + 2)) {
            goto LABEL_23;
          }
          int v9 = *((char *)v4 + (unsigned __int16)(v2 + 2));
          int v10 = v2 + 3;
LABEL_14:
          if (v9 < -64) {
            LODWORD(v6) = v10;
          }
        }
      }
      else
      {
        if (v7 <= 0xDF)
        {
          int v5 = v2 + 2;
          if ((char)v8 < -64) {
            LODWORD(v6) = v5;
          }
          goto LABEL_7;
        }
        if ((byte_19E57CD41[v8 >> 4] >> (v7 & 7)))
        {
          LODWORD(v6) = v2 + 2;
          if (v1 == (unsigned __int16)(v2 + 2)) {
            goto LABEL_23;
          }
          if (*((char *)v4 + (unsigned __int16)(v2 + 2)) <= -65)
          {
            LODWORD(v6) = v2 + 3;
            if (v1 == (unsigned __int16)(v2 + 3))
            {
LABEL_23:
              result[2] = v3 + 1;
              return result;
            }
            int v9 = *((char *)v4 + (unsigned __int16)(v2 + 3));
            int v10 = v2 + 4;
            goto LABEL_14;
          }
        }
      }
LABEL_7:
      result[2] = ++v3;
      int v2 = v6;
    }
    while (v1 > (unsigned __int16)v6);
  }
  return result;
}

uint64_t sub_19E50F564(uint64_t a1, unsigned __int16 *a2)
{
  *(_WORD *)(a1 + 4) = 0;
  *(_DWORD *)a1 = 0x100000;
  int v4 = *((unsigned __int8 *)a2 + 6);
  *(unsigned char *)(a1 + 6) = v4;
  *(void *)(a1 + 8) = 0;
  if (v4 == 1)
  {
    if (*((void *)a2 + 1)) {
      uint64_t v6 = (const void *)*((void *)a2 + 1);
    }
    else {
      uint64_t v6 = a2 + 8;
    }
    size_t v7 = *a2;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    if (v7)
    {
      sub_19E50EFF8((unsigned __int16 *)a1, v7);
      if (*(unsigned __int16 *)(a1 + 2) < v7) {
        __assert_rtn("initialize", "LMTIString.cpp", 269, "len <= m_capacity");
      }
      if (*(void *)(a1 + 8)) {
        unint64_t v8 = *(void **)(a1 + 8);
      }
      else {
        unint64_t v8 = (void *)(a1 + 16);
      }
      memcpy(v8, v6, v7);
      *(_WORD *)a1 = v7;
    }
  }
  else if (!v4)
  {
    *(void *)(a1 + 8) = *((void *)a2 + 1);
    *(_WORD *)a1 = *a2;
    unsigned __int16 v5 = a2[2];
    if (!v5)
    {
      sub_19E50F43C(a2);
      unsigned __int16 v5 = a2[2];
    }
    *(_WORD *)(a1 + 4) = v5;
    *(unsigned char *)(a1 + 17) = 0;
  }
  return a1;
}

void sub_19E50F65C(uint64_t a1, void *a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  os_signpost_id_t spid = os_signpost_id_generate((os_log_t)qword_1EC009568);
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  if (spid - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    __int16 v3 = qword_1EC009568;
    if (os_signpost_enabled((os_log_t)qword_1EC009568))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_19E36B000, v3, OS_SIGNPOST_INTERVAL_BEGIN, spid, "ToucanGenerateCompletions", (const char *)&unk_19E5812E5, buf, 2u);
    }
  }
  if (*a2 != a2[1]) {
    operator new();
  }
  __assert_rtn("generateCompletions", "SingleWordBeamSearchPredictor.cpp", 199, "!stems.empty()");
}

void sub_19E5110A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41)
{
  unint64_t v43 = (void *)STACK[0x328];
  if (STACK[0x328])
  {
    STACK[0x330] = (unint64_t)v43;
    operator delete(v43);
  }
  uint64_t v44 = a37;
  a37 = 0;
  if (v44) {
    (*(void (**)(void *))(*(void *)v44 + 8))(v44);
  }
  sub_19E44C6E4((uint64_t)&a41);
  sub_19E4446FC((uint64_t)&STACK[0x340]);
  sub_19E5121F0(v41 - 200);
  sub_19E448ED4(&a22);
  sub_19E448ED4(&a26);
  _Unwind_Resume(a1);
}

void sub_19E511608(void *a1, long long *a2)
{
  int v2 = (void **)a2;
  uint64_t v3 = a1[2];
  unint64_t v4 = a1[3];
  unint64_t v5 = 0x84BDA12F684BDA13 * ((uint64_t)(v4 - v3) >> 3);
  if (v5 >= a1[1])
  {
    if (v3 == v4) {
      __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
    }
    double v14 = *((double *)a2 + 20) + *((float *)a2 + 6);
    if (v14 >= *(double *)(v3 + 160) + *(float *)(v3 + 24))
    {
      unsigned __int16 v15 = (long long *)a1[2];
      do
      {
        unint64_t v16 = v5 >> 1;
        BOOL v17 = (char *)v15 + 216 * (v5 >> 1);
        double v18 = *((double *)v17 + 20) + *((float *)v17 + 6);
        uint64_t v19 = (long long *)(v17 + 216);
        v5 += ~(v5 >> 1);
        if (v14 < v18) {
          unint64_t v5 = v16;
        }
        else {
          unsigned __int16 v15 = v19;
        }
      }
      while (v5);
      long long v20 = (long long *)(v3 + 216);
      if ((long long *)(v3 + 216) != v15)
      {
        while (1)
        {
          uint64_t v21 = v3 + 216;
          sub_19E512068(v3, (long long *)(v3 + 216));
          if ((long long *)(v3 + 432) == v15) {
            break;
          }
          if ((long long *)v21 == v20) {
            long long v20 = (long long *)(v3 + 432);
          }
          v3 += 216;
        }
        if ((long long *)v21 != v20)
        {
          uint64_t v33 = v20;
          while (1)
          {
            sub_19E512068(v21, v33);
            uint64_t v33 = (long long *)((char *)v33 + 216);
            BOOL v34 = v21 + 216 == (void)v20;
            if (v33 == v15)
            {
              if ((long long *)(v21 + 216) == v20) {
                break;
              }
              uint64_t v33 = (long long *)((char *)v20 + 216);
              v21 += 432;
              while (1)
              {
                sub_19E512068(v21 - 216, v20);
                BOOL v34 = v21 == (void)v20;
                if (v33 != v15) {
                  break;
                }
                BOOL v35 = v21 == (void)v20;
                v21 += 216;
                if (v35) {
                  goto LABEL_49;
                }
              }
            }
            else
            {
              v21 += 216;
            }
            if (v34) {
              long long v20 = v33;
            }
          }
        }
      }
LABEL_49:
      uint64_t v36 = (void **)v15 - 27;
      if ((void **)((char *)v15 - 216) != v2)
      {
        char v37 = *((unsigned char *)v2 + 23);
        if (*((char *)v15 - 193) < 0)
        {
          if (v37 >= 0) {
            unint64_t v50 = v2;
          }
          else {
            unint64_t v50 = *v2;
          }
          if (v37 >= 0) {
            size_t v51 = *((unsigned __int8 *)v2 + 23);
          }
          else {
            size_t v51 = (size_t)v2[1];
          }
          sub_19E3C6D44(v36, v50, v51);
        }
        else if ((*((unsigned char *)v2 + 23) & 0x80) != 0)
        {
          sub_19E3C6C7C(v36, *v2, (size_t)v2[1]);
        }
        else
        {
          long long v38 = *(_OWORD *)v2;
          *((void *)v15 - 25) = v2[2];
          *(_OWORD *)uint64_t v36 = v38;
        }
      }
      *((_DWORD *)v15 - 48) = *((_DWORD *)v2 + 6);
      uint64_t v71 = (uint64_t)v15 - 184;
      uint64_t v72 = (char **)(v2 + 4);
      goto LABEL_119;
    }
  }
  else
  {
    if (v4 == v3)
    {
      int64_t v13 = 0x84BDA12F684BDA13 * ((uint64_t)(v4 - v3) >> 3);
    }
    else
    {
      unint64_t v7 = 0x84BDA12F684BDA13 * ((uint64_t)(v4 - v3) >> 3);
      uint64_t v8 = a1[2];
      do
      {
        unint64_t v9 = v7 >> 1;
        uint64_t v10 = v8 + 216 * (v7 >> 1);
        double v11 = *(double *)(v10 + 160) + *(float *)(v10 + 24);
        uint64_t v12 = v10 + 216;
        v7 += ~(v7 >> 1);
        if (*((double *)a2 + 20) + *((float *)a2 + 6) < v11) {
          unint64_t v7 = v9;
        }
        else {
          uint64_t v8 = v12;
        }
      }
      while (v7);
      int64_t v13 = 0x84BDA12F684BDA13 * ((v8 - v3) >> 3);
    }
    unint64_t v22 = v3 + 216 * v13;
    unint64_t v23 = a1[4];
    if (v4 >= v23)
    {
      unint64_t v29 = v5 + 1;
      if (v29 > 0x12F684BDA12F684) {
        sub_19E37C7C4();
      }
      unint64_t v30 = 0x84BDA12F684BDA13 * ((uint64_t)(v23 - v3) >> 3);
      if (2 * v30 > v29) {
        unint64_t v29 = 2 * v30;
      }
      if (v30 >= 0x97B425ED097B42) {
        unint64_t v31 = 0x12F684BDA12F684;
      }
      else {
        unint64_t v31 = v29;
      }
      if (v31)
      {
        if (v31 > 0x12F684BDA12F684) {
          sub_19E37C2B8();
        }
        int v32 = (char *)operator new(216 * v31);
      }
      else
      {
        int v32 = 0;
      }
      CFStringRef v40 = &v32[216 * v13];
      uint64_t v76 = v40;
      *(void *)&long long v77 = v40;
      *((void *)&v77 + 1) = &v32[216 * v31];
      uint64_t v41 = v40;
      if (v13 == v31)
      {
        if (v13 < 1)
        {
          if (v13) {
            unint64_t v52 = 2 * v13;
          }
          else {
            unint64_t v52 = 1;
          }
          if (v52 > 0x12F684BDA12F684) {
            sub_19E37C2B8();
          }
          uint64_t v53 = (char *)operator new(216 * v52);
          uint64_t v41 = &v53[216 * (v52 >> 2)];
          *(void *)&long long v54 = v41;
          *((void *)&v54 + 1) = &v53[216 * v52];
          long long v55 = v40;
          uint64_t v76 = v41;
          long long v77 = v54;
          while (v55 != v40)
          {
            sub_19E3C3D24((void **)v55 - 23);
            if (*(v55 - 193) < 0) {
              operator delete(*((void **)v55 - 27));
            }
            v55 -= 216;
          }
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          uint64_t v41 = &v40[-216 * ((v13 + 1) >> 1)];
          uint64_t v76 = v41;
          *(void *)&long long v77 = v41;
        }
      }
      if (*((char *)v2 + 23) < 0)
      {
        sub_19E39369C(v41, *v2, (unint64_t)v2[1]);
      }
      else
      {
        *(_OWORD *)uint64_t v41 = *(_OWORD *)v2;
        *((void *)v41 + 2) = v2[2];
      }
      *((_DWORD *)v41 + 6) = *((_DWORD *)v2 + 6);
      sub_19E3C36C4((uint64_t)(v41 + 32), (uint64_t)(v2 + 4));
      int v56 = v76;
      uint64_t v57 = v77 + 216;
      uint64_t v58 = a1[2];
      if (v22 != v58)
      {
        uint64_t v59 = 0;
        do
        {
          uint64_t v60 = v22 + v59;
          long long v61 = &v76[v59];
          long long v62 = *(_OWORD *)(v22 + v59 - 216);
          *((void *)v61 - 25) = *(void *)(v22 + v59 - 200);
          *(_OWORD *)(v61 - 216) = v62;
          *(void *)(v60 - 208) = 0;
          *(void *)(v60 - 200) = 0;
          *(void *)(v60 - 216) = 0;
          LODWORD(v62) = *(_DWORD *)(v22 + v59 - 192);
          *((void *)v61 - 22) = 0;
          *((void *)v61 - 21) = 0;
          *((void *)v61 - 23) = 0;
          *((_DWORD *)v61 - 48) = v62;
          *(_OWORD *)(v61 - 184) = *(_OWORD *)(v22 + v59 - 184);
          *((void *)v61 - 21) = *(void *)(v22 + v59 - 168);
          *(void *)(v60 - 184) = 0;
          *(void *)(v60 - 176) = 0;
          *(void *)(v60 - 168) = 0;
          *((void *)v61 - 20) = 0;
          *((void *)v61 - 19) = 0;
          *((void *)v61 - 18) = 0;
          *((_OWORD *)v61 - 10) = *(_OWORD *)(v22 + v59 - 160);
          *((void *)v61 - 18) = *(void *)(v22 + v59 - 144);
          *(void *)(v60 - 160) = 0;
          *(void *)(v60 - 152) = 0;
          *(void *)(v60 - 144) = 0;
          *((void *)v61 - 17) = 0;
          *((void *)v61 - 16) = 0;
          *((void *)v61 - 15) = 0;
          *(_OWORD *)(v61 - 136) = *(_OWORD *)(v22 + v59 - 136);
          *((void *)v61 - 15) = *(void *)(v22 + v59 - 120);
          *(void *)(v60 - 136) = 0;
          *(void *)(v60 - 128) = 0;
          *(void *)(v60 - 120) = 0;
          *((void *)v61 - 14) = 0;
          *((void *)v61 - 13) = 0;
          *((void *)v61 - 12) = 0;
          *((_OWORD *)v61 - 7) = *(_OWORD *)(v22 + v59 - 112);
          *((void *)v61 - 12) = *(void *)(v22 + v59 - 96);
          *(void *)(v60 - 112) = 0;
          *(void *)(v60 - 104) = 0;
          *(void *)(v60 - 96) = 0;
          *((void *)v61 - 11) = 0;
          *((void *)v61 - 10) = 0;
          *((void *)v61 - 9) = 0;
          *(_OWORD *)(v61 - 88) = *(_OWORD *)(v22 + v59 - 88);
          *((void *)v61 - 9) = *(void *)(v22 + v59 - 72);
          *(void *)(v60 - 80) = 0;
          *(void *)(v60 - 72) = 0;
          long long v63 = *(_OWORD *)(v22 + v59 - 64);
          *(void *)(v60 - 88) = 0;
          *((_OWORD *)v61 - 4) = v63;
          *((void *)v61 - 5) = 0;
          *((void *)v61 - 4) = 0;
          *((void *)v61 - 6) = 0;
          *((_OWORD *)v61 - 3) = *(_OWORD *)(v22 + v59 - 48);
          *((void *)v61 - 4) = *(void *)(v22 + v59 - 32);
          *(void *)(v60 - 48) = 0;
          *(void *)(v60 - 40) = 0;
          *(void *)(v60 - 32) = 0;
          *((void *)v61 - 3) = 0;
          *((void *)v61 - 2) = 0;
          *((void *)v61 - 1) = 0;
          *(_OWORD *)(v61 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(v22 + v59 - 24);
          *((void *)v61 - 1) = *(void *)(v22 + v59 - 8);
          *(void *)(v60 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
          *(void *)(v60 - 16) = 0;
          *(void *)(v60 - 8) = 0;
          v59 -= 216;
        }
        while (v22 + v59 != v58);
        int v56 = &v76[v59];
      }
      for (uint64_t i = a1[3]; v22 != i; v22 += 216)
      {
        long long v65 = *(_OWORD *)v22;
        *(void *)(v57 + 16) = *(void *)(v22 + 16);
        *(_OWORD *)uint64_t v57 = v65;
        *(void *)(v22 + 8) = 0;
        *(void *)(v22 + 16) = 0;
        *(void *)unint64_t v22 = 0;
        *(_DWORD *)(v57 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(v22 + 24);
        *(void *)(v57 + 40) = 0;
        *(void *)(v57 + 48) = 0;
        *(void *)(v57 + 32) = 0;
        *(_OWORD *)(v57 + 32) = *(_OWORD *)(v22 + 32);
        *(void *)(v57 + 48) = *(void *)(v22 + 48);
        *(void *)(v22 + 32) = 0;
        *(void *)(v22 + 40) = 0;
        *(void *)(v22 + 48) = 0;
        *(void *)(v57 + 56) = 0;
        *(void *)(v57 + 64) = 0;
        *(void *)(v57 + 72) = 0;
        *(_OWORD *)(v57 + 56) = *(_OWORD *)(v22 + 56);
        *(void *)(v57 + 72) = *(void *)(v22 + 72);
        *(void *)(v22 + 56) = 0;
        *(void *)(v22 + 64) = 0;
        *(void *)(v22 + 72) = 0;
        *(void *)(v57 + 80) = 0;
        *(void *)(v57 + 88) = 0;
        *(void *)(v57 + 96) = 0;
        *(_OWORD *)(v57 + 80) = *(_OWORD *)(v22 + 80);
        *(void *)(v57 + 96) = *(void *)(v22 + 96);
        *(void *)(v22 + 80) = 0;
        *(void *)(v22 + 88) = 0;
        *(void *)(v22 + 96) = 0;
        *(void *)(v57 + 104) = 0;
        *(void *)(v57 + 112) = 0;
        *(void *)(v57 + 120) = 0;
        *(_OWORD *)(v57 + 104) = *(_OWORD *)(v22 + 104);
        *(void *)(v57 + 120) = *(void *)(v22 + 120);
        *(void *)(v22 + 104) = 0;
        *(void *)(v22 + 112) = 0;
        *(void *)(v22 + 120) = 0;
        *(void *)(v57 + 128) = 0;
        *(void *)(v57 + 136) = 0;
        *(void *)(v57 + 144) = 0;
        *(_OWORD *)(v57 + 128) = *(_OWORD *)(v22 + 128);
        *(void *)(v57 + 144) = *(void *)(v22 + 144);
        *(void *)(v22 + 136) = 0;
        *(void *)(v22 + 144) = 0;
        *(void *)(v22 + 128) = 0;
        *(_OWORD *)(v57 + 152) = *(_OWORD *)(v22 + 152);
        *(void *)(v57 + 176) = 0;
        *(void *)(v57 + 184) = 0;
        *(void *)(v57 + 168) = 0;
        *(_OWORD *)(v57 + 168) = *(_OWORD *)(v22 + 168);
        *(void *)(v57 + 184) = *(void *)(v22 + 184);
        *(void *)(v22 + 168) = 0;
        *(void *)(v22 + 176) = 0;
        *(void *)(v22 + 184) = 0;
        *(void *)(v57 + 192) = 0;
        *(void *)(v57 + 200) = 0;
        *(void *)(v57 + 208) = 0;
        *(_OWORD *)(v57 + 192) = *(_OWORD *)(v22 + 192);
        *(void *)(v57 + 208) = *(void *)(v22 + 208);
        *(void *)(v22 + 192) = 0;
        *(void *)(v22 + 200) = 0;
        *(void *)(v22 + 208) = 0;
        v57 += 216;
      }
      uint64_t v66 = (void *)a1[2];
      long long v67 = *(_OWORD *)(a1 + 3);
      a1[2] = v56;
      a1[3] = v57;
      a1[4] = *((void *)&v77 + 1);
      if ((void *)v67 != v66)
      {
        uint64_t v68 = v67 - 216;
        do
        {
          sub_19E3C3D24((void **)(v68 + 32));
          if (*(char *)(v68 + 23) < 0) {
            operator delete(*(void **)v68);
          }
          v68 -= 216;
        }
        while ((void *)(v68 + 216) != v66);
      }
      if (v66) {
        operator delete(v66);
      }
    }
    else
    {
      if (v22 != v4)
      {
        unint64_t v24 = v22 + 216;
        unint64_t v25 = v4 - 216;
        int64_t v75 = v13;
        if (v4 < 0xD8)
        {
          uint64_t v27 = a1[3];
        }
        else
        {
          unint64_t v26 = v4 - 216;
          uint64_t v27 = a1[3];
          do
          {
            long long v28 = *(_OWORD *)v26;
            *(void *)(v27 + 16) = *(void *)(v26 + 16);
            *(_OWORD *)uint64_t v27 = v28;
            *(void *)(v26 + 8) = 0;
            *(void *)(v26 + 16) = 0;
            *(void *)unint64_t v26 = 0;
            *(_DWORD *)(v27 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_DWORD *)(v26 + 24);
            *(void *)(v27 + 40) = 0;
            *(void *)(v27 + 48) = 0;
            *(void *)(v27 + 32) = 0;
            *(_OWORD *)(v27 + 32) = *(_OWORD *)(v26 + 32);
            *(void *)(v27 + 48) = *(void *)(v26 + 48);
            *(void *)(v26 + 32) = 0;
            *(void *)(v26 + 40) = 0;
            *(void *)(v26 + 48) = 0;
            *(void *)(v27 + 56) = 0;
            *(void *)(v27 + 64) = 0;
            *(void *)(v27 + 72) = 0;
            *(_OWORD *)(v27 + 56) = *(_OWORD *)(v26 + 56);
            *(void *)(v27 + 72) = *(void *)(v26 + 72);
            *(void *)(v26 + 56) = 0;
            *(void *)(v26 + 64) = 0;
            *(void *)(v26 + 72) = 0;
            *(void *)(v27 + 80) = 0;
            *(void *)(v27 + 88) = 0;
            *(void *)(v27 + 96) = 0;
            *(_OWORD *)(v27 + 80) = *(_OWORD *)(v26 + 80);
            *(void *)(v27 + 96) = *(void *)(v26 + 96);
            *(void *)(v26 + 80) = 0;
            *(void *)(v26 + 88) = 0;
            *(void *)(v26 + 96) = 0;
            *(void *)(v27 + 104) = 0;
            *(void *)(v27 + 112) = 0;
            *(void *)(v27 + 120) = 0;
            *(_OWORD *)(v27 + 104) = *(_OWORD *)(v26 + 104);
            *(void *)(v27 + 120) = *(void *)(v26 + 120);
            *(void *)(v26 + 104) = 0;
            *(void *)(v26 + 112) = 0;
            *(void *)(v26 + 120) = 0;
            *(void *)(v27 + 128) = 0;
            *(void *)(v27 + 136) = 0;
            *(void *)(v27 + 144) = 0;
            *(_OWORD *)(v27 + 128) = *(_OWORD *)(v26 + 128);
            *(void *)(v27 + 144) = *(void *)(v26 + 144);
            *(void *)(v26 + 136) = 0;
            *(void *)(v26 + 144) = 0;
            *(void *)(v26 + 128) = 0;
            *(_OWORD *)(v27 + 152) = *(_OWORD *)(v26 + 152);
            *(void *)(v27 + 176) = 0;
            *(void *)(v27 + 184) = 0;
            *(void *)(v27 + 168) = 0;
            *(_OWORD *)(v27 + 168) = *(_OWORD *)(v26 + 168);
            *(void *)(v27 + 184) = *(void *)(v26 + 184);
            *(void *)(v26 + 168) = 0;
            *(void *)(v26 + 176) = 0;
            *(void *)(v26 + 184) = 0;
            *(void *)(v27 + 192) = 0;
            *(void *)(v27 + 200) = 0;
            *(void *)(v27 + 208) = 0;
            *(_OWORD *)(v27 + 192) = *(_OWORD *)(v26 + 192);
            *(void *)(v27 + 208) = *(void *)(v26 + 208);
            *(void *)(v26 + 192) = 0;
            *(void *)(v26 + 200) = 0;
            *(void *)(v26 + 208) = 0;
            v27 += 216;
            v26 += 216;
          }
          while (v26 < v4);
        }
        a1[3] = v27;
        if (v4 != v24)
        {
          uint64_t v42 = 0;
          uint64_t v43 = -8 * ((uint64_t)(v4 - v24) >> 3);
          do
          {
            uint64_t v46 = v4 + v42;
            uint64_t v47 = (void **)(v4 + v42 - 216);
            if (*(char *)(v4 + v42 - 193) < 0) {
              operator delete(*v47);
            }
            uint64_t v44 = (long long *)(v25 + v42 - 216);
            long long v45 = *v44;
            *(void *)(v4 + v42 - 200) = *(void *)(v25 + v42 - 200);
            *(_OWORD *)uint64_t v47 = v45;
            *(unsigned char *)(v25 + v42 - 193) = 0;
            *(unsigned char *)uint64_t v44 = 0;
            *(_DWORD *)(v46 - 192) = *(_DWORD *)(v25 + v42 - 192);
            sub_19E4490FC(v46 - 184, v25 + v42 - 184);
            v42 -= 216;
          }
          while (v43 != v42);
        }
        if (v22 <= (unint64_t)v2) {
          v2 += 27 * (a1[3] > (unint64_t)v2);
        }
        if ((void **)v22 != v2)
        {
          char v48 = *((unsigned char *)v2 + 23);
          if (*(char *)(v22 + 23) < 0)
          {
            if (v48 >= 0) {
              uint64_t v69 = v2;
            }
            else {
              uint64_t v69 = *v2;
            }
            if (v48 >= 0) {
              size_t v70 = *((unsigned __int8 *)v2 + 23);
            }
            else {
              size_t v70 = (size_t)v2[1];
            }
            sub_19E3C6D44((void **)v22, v69, v70);
          }
          else if ((*((unsigned char *)v2 + 23) & 0x80) != 0)
          {
            sub_19E3C6C7C((void *)v22, *v2, (size_t)v2[1]);
          }
          else
          {
            long long v49 = *(_OWORD *)v2;
            *(void *)(v22 + 16) = v2[2];
            *(_OWORD *)unint64_t v22 = v49;
          }
        }
        uint64_t v74 = v3 + 216 * v75;
        *(_DWORD *)(v74 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((_DWORD *)v2 + 6);
        uint64_t v71 = v74 + 32;
        uint64_t v72 = (char **)(v2 + 4);
LABEL_119:
        sub_19E44A58C(v71, v72);
        return;
      }
      if (*((char *)a2 + 23) < 0)
      {
        sub_19E39369C((unsigned char *)a1[3], *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long v39 = *a2;
        *(void *)(v4 + 16) = *((void *)a2 + 2);
        *(_OWORD *)unint64_t v4 = v39;
      }
      uint64_t v73 = v3 + 216 * v13;
      *(_DWORD *)(v73 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((_DWORD *)v2 + 6);
      sub_19E3C36C4(v73 + 32, (uint64_t)(v2 + 4));
      a1[3] = v4 + 216;
    }
  }
}

void sub_19E512014(_Unwind_Exception *exception_object)
{
  *(void *)(v1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v2;
  _Unwind_Resume(exception_object);
}

void sub_19E51203C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_19E44D724((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E512068(uint64_t a1, long long *a2)
{
  *(_OWORD *)long long __p = *(_OWORD *)a1;
  uint64_t v9 = *(void *)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = 0;
  int v3 = *(_DWORD *)(a1 + 24);
  long long v10 = *(_OWORD *)(a1 + 32);
  uint64_t v11 = *(void *)(a1 + 48);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  long long v12 = *(_OWORD *)(a1 + 56);
  uint64_t v13 = *(void *)(a1 + 72);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  long long v14 = *(_OWORD *)(a1 + 80);
  uint64_t v15 = *(void *)(a1 + 96);
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 96) = 0;
  long long v16 = *(_OWORD *)(a1 + 104);
  uint64_t v17 = *(void *)(a1 + 120);
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  long long v18 = *(_OWORD *)(a1 + 128);
  uint64_t v4 = *(void *)(a1 + 144);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  long long v20 = *(_OWORD *)(a1 + 152);
  long long v21 = *(_OWORD *)(a1 + 168);
  uint64_t v5 = *(void *)(a1 + 184);
  uint64_t v19 = v4;
  uint64_t v22 = v5;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  long long v23 = *(_OWORD *)(a1 + 192);
  uint64_t v24 = *(void *)(a1 + 208);
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  long long v6 = *a2;
  *(void *)(a1 + 16) = *((void *)a2 + 2);
  *(_OWORD *)a1 = v6;
  *((unsigned char *)a2 + 23) = 0;
  *(unsigned char *)a2 = 0;
  uint64_t v7 = (uint64_t)(a2 + 2);
  *(_DWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((_DWORD *)a2 + 6);
  sub_19E4490FC(a1 + 32, (uint64_t)(a2 + 2));
  if (*((char *)a2 + 23) < 0) {
    operator delete(*(void **)a2);
  }
  *a2 = *(_OWORD *)__p;
  *((void *)a2 + 2) = v9;
  *((_DWORD *)a2 + 6) = v3;
  sub_19E4490FC(v7, (uint64_t)&v10);
  sub_19E3C3D24((void **)&v10);
}

uint64_t sub_19E5121F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    uint64_t v4 = *(void **)(a1 + 16);
    if (v3 != v2)
    {
      do
      {
        sub_19E3C3D24((void **)(v3 - 184));
        if (*(char *)(v3 - 193) < 0) {
          operator delete(*(void **)(v3 - 216));
        }
        v3 -= 216;
      }
      while (v3 != v2);
      uint64_t v4 = *(void **)(a1 + 16);
    }
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E51226C(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = **(void **)(a1 + 16);
    uint64_t v4 = **(void **)(a1 + 8);
    while (v3 != v4)
    {
      sub_19E3C3D24((void **)(v3 - 184));
      if (*(char *)(v3 - 193) < 0) {
        operator delete(*(void **)(v3 - 216));
      }
      v3 -= 216;
    }
  }
  return a1;
}

void sub_19E5122D8(void *a1)
{
  uint64_t v2 = (void *)a1[22];
  if (v2)
  {
    a1[23] = v2;
    operator delete(v2);
  }
  sub_19E44DB14(a1 + 5);
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  a1[3] = 0;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E512390(void *a1)
{
  uint64_t v2 = (void *)a1[22];
  if (v2)
  {
    a1[23] = v2;
    operator delete(v2);
  }
  sub_19E44DB14(a1 + 5);
  uint64_t v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  a1[3] = 0;
  uint64_t v4 = (std::__shared_weak_count *)a1[2];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void sub_19E512428(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  CFStringRef v6 = (const __CFString *)LXEntryCopyString();
  if (CFEqual(*(CFStringRef *)(a1 + 40), v6))
  {
    if (a2)
    {
      int TokenID = LXEntryGetTokenID();
      if (TokenID) {
        int v8 = TokenID;
      }
      else {
        int v8 = 500;
      }
    }
    else
    {
      int v8 = 0;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
    if (*(void *)(a1 + 48))
    {
      LXEntryGetProbability();
      **(void **)(a1 + 48) = v9;
    }
    if (a3) {
      *a3 = 1;
    }
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_19E5124E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E5124F8(uint64_t a1, const UInt8 *a2)
{
  uint64_t v2 = a2;
  CFIndex v3 = a2[23];
  if ((v3 & 0x80u) != 0) {
    a2 = *(const UInt8 **)a2;
  }
  if (a2)
  {
    CFIndex v4 = *((void *)v2 + 1);
    if ((v3 & 0x80u) == 0) {
      CFIndex v5 = v3;
    }
    else {
      CFIndex v5 = v4;
    }
    CFStringRef v6 = CFStringCreateWithBytes(0, a2, v5, 0x8000100u, 0);
    if (!v6)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v6 = 0;
  }
  uint64_t v10 = 0;
  uint64_t v11 = &v10;
  int v13 = 0;
  uint64_t v12 = 0x2000000000;
  LXLexiconEnumerateEntriesForString();
  uint64_t v8 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  if (v6) {
    CFRelease(v6);
  }
  return v8;
}

void sub_19E51264C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E512664(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

void sub_19E512684(uint64_t a1)
{
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
  uint64_t v2 = LXLexiconCopyEntryForTokenID();
  uint64_t v9 = v2;
  if (v2)
  {
    CFIndex v3 = (const void *)v2;
    CFStringRef v4 = (const __CFString *)LXEntryCopyString();
    CFStringRef v5 = v4;
    CFStringRef v8 = v4;
    if (v4)
    {
      sub_19E37774C(v4, &v6);
      *(_OWORD *)a1 = v6;
      *(void *)(a1 + 16) = v7;
      CFRelease(v5);
    }
    CFRelease(v3);
  }
}

void sub_19E512714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  long long v6 = va_arg(va1, const void *);
  sub_19E3DCC24((const void **)va);
  sub_19E420F7C((const void **)va1);
  _Unwind_Resume(a1);
}

void sub_19E51273C()
{
}

void sub_19E5128F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E512960()
{
  return &unk_1EF0B80B8;
}

uint64_t sub_19E51296C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LM12LexiconUtils19makeTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0"
    || ((v3 & (unint64_t)"ZN2LM12LexiconUtils19makeTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LM12LexiconUtils19makeTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LM12LexiconUtils19makeTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E5129C4()
{
  return 1;
}

void sub_19E5129D4(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD668;
}

void *sub_19E5129F4()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF0BD668;
  return result;
}

void sub_19E512A2C()
{
}

void *sub_19E512A44()
{
  return &unk_1EF0B80C8;
}

uint64_t sub_19E512A50(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN2LM12LexiconUtils25makePoliteTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0"
    || ((v3 & (unint64_t)"ZN2LM12LexiconUtils25makePoliteTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN2LM12LexiconUtils25makePoliteTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN2LM12LexiconUtils25makePoliteTokenEnumeratorEPK10_LXLexiconPK10__CFStringNS_11TokenSourceEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E512AA8()
{
  return (LXEntryGetMetaFlags() & 0x86) == 0;
}

void sub_19E512AD8(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD6C0;
}

void *sub_19E512AF8()
{
  __n128 result = operator new(0x10uLL);
  void *result = &unk_1EF0BD6C0;
  return result;
}

void sub_19E512B30()
{
}

void sub_19E512B48()
{
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  uint64_t v1 = (const void *)LXCursorCreateByAdvancingWithUTF8();
  if (v1)
  {
    LXCursorEnumerateEntries();
    CFRelease(v1);
  }
  if (RootCursor) {
    CFRelease(RootCursor);
  }
}

void sub_19E512C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_19E421014((const void **)va);
  sub_19E421014((const void **)(v7 - 40));
  _Unwind_Resume(a1);
}

void sub_19E512C44(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  char v12 = 0;
  long long v6 = (const void *)LXEntryCopyString();
  uint64_t v7 = *(void *)(a1 + 32);
  if (a2)
  {
    int TokenID = LXEntryGetTokenID();
    if (TokenID) {
      int v9 = TokenID;
    }
    else {
      int v9 = 500;
    }
  }
  else
  {
    int v9 = 0;
  }
  LXEntryGetProbability();
  uint64_t v15 = v6;
  int v14 = v9;
  uint64_t v13 = v10;
  uint64_t v11 = *(void *)(v7 + 24);
  if (!v11) {
    sub_19E3ACB9C();
  }
  (*(void (**)(uint64_t, const void **, int *, uint64_t *, char *))(*(void *)v11 + 48))(v11, &v15, &v14, &v13, &v12);
  *a3 = v12;
  if (v6) {
    CFRelease(v6);
  }
}

void sub_19E512D2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E512D40(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

void sub_19E512D48(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x19F3BCDE0](*(void *)(a1 + 40));
  if (CFEqual(v1, @"zh-Hans")) {
    operator new();
  }
  __assert_rtn("createLXCursorRoot", "LMCompositeLexicon.cpp", 655, "false && \"not implemented\"");
}

CFComparisonResult sub_19E512DDC(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x19F3BCDE0](*(void *)(a1 + 40));
  CFComparisonResult result = CFStringCompare(v1, @"zh-Hans", 0);
  if (result) {
    __assert_rtn("enumerateSortkeyEquivalentEntries", "LMCompositeLexicon.cpp", 648, "false && \"not implemented\"");
  }
  return result;
}

uint64_t sub_19E512E2C@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 8);
  if (v2 != *(void *)(result + 16)) {
    return (*(uint64_t (**)(void))(**(void **)v2 + 136))();
  }
  *a2 = 0;
  return result;
}

void sub_19E512E68(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  CFStringRef v4 = *(void **)(a1 + 8);
  CFStringRef v5 = *(void **)(a1 + 16);
  if (v4 == v5)
  {
LABEL_4:
    CFStringRef v8 = 0;
  }
  else
  {
    while (1)
    {
      uint64_t v7 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 128))(*v4, a2);
      if (v7) {
        break;
      }
      if (++v4 == v5) {
        goto LABEL_4;
      }
    }
    CFStringRef v8 = (const __CFString *)v7;
  }
  sub_19E37774C(v8, a3);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_19E512F0C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E512F28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v5 = sub_19E3C2A64(a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, CFStringRef, uint64_t))(*(void *)(a1 - 16) + 16))(a1 - 16, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

void sub_19E512FA8(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E512FC4(int a1, const __CFString *a2)
{
  return sub_19E512FCC(a1 - 16, a2);
}

uint64_t sub_19E512FCC(int a1, CFStringRef theString)
{
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  int v8 = 0;
  uint64_t v7 = 0x2000000000;
  v4[0] = 0;
  v4[1] = v4;
  v4[2] = 0x2000000000;
  v4[3] = 0;
  if (CFStringGetLength(theString) >= 1) {
    operator new[]();
  }
  uint64_t v2 = *((unsigned int *)v6 + 6);
  _Block_object_dispose(v4, 8);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_19E513400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  MEMORY[0x19F3BDCC0](v10, 0x1000C80BDFB0063);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E513464(void *a1)
{
  uint64_t result = a1[4];
  if (result - a1[3] == a1[6]) {
    operator new[]();
  }
  ++a1[7];
  a1[4] = result + a1[5];
  return result;
}

void sub_19E51353C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x19F3BDCC0](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E513564(uint64_t a1, int a2, char *cStr, double a4, uint64_t a5, uint64_t a6, unsigned char *a7)
{
  if (cStr)
  {
    CFStringRef v11 = CFStringCreateWithCStringNoCopy(0, cStr, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v11)
    {
      CFStringRef v12 = v11;
      if (CFEqual(*(CFStringRef *)(a1 + 48), v11))
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
        *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(double *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24)
                                                                    * a4;
        *a7 = 1;
      }
      CFRelease(v12);
    }
  }
  else if (a2)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
    *(double *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(double *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                            + 24)
                                                                * a4;
    *a7 = 1;
  }
}

void sub_19E51365C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v10 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 0;
  uint64_t v11 = 0x5000000000;
  do
  {
    uint64_t v12 = *(void *)(a1 + 24);
    if (v10 >= (*(void *)(a1 + 32) - v12) >> 3) {
      break;
    }
    uint64_t v13 = *(void *)(v12 + 8 * v10);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 0x40000000;
    v14[2] = sub_19E5137AC;
    v14[3] = &unk_1E59A1D68;
    v14[4] = a5;
    v14[5] = &v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(void *)v13 + 56))(v13, a2 + (v11 >> 32), a3, a4, v14);
    ++v10;
    v11 += 0x5000000000;
  }
  while (!*((unsigned char *)v16 + 24));
  _Block_object_dispose(&v15, 8);
}

void sub_19E513794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E5137AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    *a6 = 1;
  }
  return result;
}

void *sub_19E513804(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_19E37C2B8();
    }
    int v9 = (char *)operator new(8 * v8);
  }
  else
  {
    int v9 = 0;
  }
  unint64_t v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)unint64_t v10 = v12;
  uint64_t v13 = v10 + 8;
  uint64_t v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    goto LABEL_25;
  }
  unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
  if (v16 > 0x77
    && (&v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v10 || &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v15))
  {
    uint64_t v17 = (v16 >> 3) + 1;
    v10 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    char v18 = v15 - 32;
    uint64_t v19 = &v9[8 * v3 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *(_OWORD *)v18;
      long long v21 = *((_OWORD *)v18 + 1);
      *(_OWORD *)char v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      *((_OWORD *)v19 - 1) = v22;
      *(_OWORD *)uint64_t v19 = v21;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v15 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v23 = *((void *)v15 - 1);
    v15 -= 8;
    *(void *)uint64_t v15 = 0;
    *((void *)v10 - 1) = v23;
    v10 -= 8;
  }
  while (v15 != v14);
LABEL_20:
  uint64_t v15 = (char *)*a1;
  uint64_t v24 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v11;
  while (v24 != v15)
  {
    uint64_t v26 = *((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    *(void *)uint64_t v24 = 0;
    if (v26) {
      MEMORY[0x19F3BDCC0](v25, 0x1000C8077774924);
    }
  }
LABEL_25:
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void sub_19E5139A4(uint64_t a1)
{
  sub_19E5139E0((void *)(a1 - 16));
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E5139E0(void *a1)
{
  *a1 = &unk_1EF0BA1F0;
  a1[2] = &unk_1EF0BA248;
  if (a1[6])
  {
    uint64_t v2 = a1[3];
    if (a1[4] != v2)
    {
      unint64_t v3 = 0;
      do
      {
        if ((*(unsigned int (**)(void))(**(void **)(v2 + 8 * v3) + 144))(*(void *)(v2 + 8 * v3)))
        {
          unint64_t v4 = (void *)a1[6];
          if (v4[7])
          {
            unint64_t v5 = 0;
            do
            {
              uint64_t v6 = *(void *)(a1[3] + 8 * v3);
              (*(void (**)(uint64_t, unint64_t))(*(void *)v6 + 152))(v6, *(void *)(*v4 + ((v5 >> 4) & 0xFFFFFFFFFFFFFF8))+ v4[5] * (v5 & 0x7F)+ ((uint64_t)(0x5000000000 * v3 + 0x5000000000) >> 32));
              ++v5;
              unint64_t v4 = (void *)a1[6];
            }
            while (v5 < v4[7]);
          }
        }
        ++v3;
        uint64_t v2 = a1[3];
      }
      while (v3 < (a1[4] - v2) >> 3);
    }
  }
  uint64_t v7 = (const void *)a1[7];
  if (v7) {
    CFRelease(v7);
  }
  unint64_t v8 = (void *)a1[6];
  a1[6] = 0;
  a1[7] = 0;
  if (v8)
  {
    int v9 = (void *)*v8;
    if (*v8)
    {
      unint64_t v10 = (void *)v8[1];
      uint64_t v11 = (void *)*v8;
      if (v10 != v9)
      {
        do
        {
          uint64_t v13 = *--v10;
          uint64_t v12 = v13;
          *unint64_t v10 = 0;
          if (v13) {
            MEMORY[0x19F3BDCC0](v12, 0x1000C8077774924);
          }
        }
        while (v10 != v9);
        uint64_t v11 = (void *)*v8;
      }
      v8[1] = v9;
      operator delete(v11);
    }
    MEMORY[0x19F3BDCF0](v8, 0x1030C404F540F20);
  }
  uint64_t v14 = (void *)a1[3];
  if (v14)
  {
    uint64_t v15 = (void *)a1[4];
    unint64_t v16 = (void *)a1[3];
    if (v15 != v14)
    {
      do
      {
        uint64_t v18 = *--v15;
        uint64_t v17 = v18;
        *uint64_t v15 = 0;
        if (v18) {
          (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
        }
      }
      while (v15 != v14);
      unint64_t v16 = (void *)a1[3];
    }
    a1[4] = v14;
    operator delete(v16);
  }
  return a1;
}

void *sub_19E513C20(uint64_t a1)
{
  return sub_19E5139E0((void *)(a1 - 16));
}

uint64_t sub_19E513C28(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

void sub_19E513C30(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x19F3BCDE0](*(void *)(a1 + 56));
  if (CFEqual(v1, @"zh-Hans")) {
    operator new();
  }
  __assert_rtn("createLXCursorRoot", "LMCompositeLexicon.cpp", 655, "false && \"not implemented\"");
}

CFComparisonResult sub_19E513CC4(uint64_t a1)
{
  CFStringRef v1 = (const __CFString *)MEMORY[0x19F3BCDE0](*(void *)(a1 + 56));
  CFComparisonResult result = CFStringCompare(v1, @"zh-Hans", 0);
  if (result) {
    __assert_rtn("enumerateSortkeyEquivalentEntries", "LMCompositeLexicon.cpp", 648, "false && \"not implemented\"");
  }
  return result;
}

uint64_t sub_19E513D14@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 24);
  if (v2 != *(void *)(result + 32)) {
    return (*(uint64_t (**)(void))(**(void **)v2 + 136))();
  }
  *a2 = 0;
  return result;
}

void sub_19E513D50(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  unint64_t v4 = *(void **)(a1 + 24);
  unint64_t v5 = *(void **)(a1 + 32);
  if (v4 == v5)
  {
LABEL_4:
    CFStringRef v7 = 0;
  }
  else
  {
    while (1)
    {
      CFStringRef v7 = (const __CFString *)(*(uint64_t (**)(void, uint64_t))(*(void *)*v4 + 128))(*v4, a2);
      if (v7) {
        break;
      }
      if (++v4 == v5) {
        goto LABEL_4;
      }
    }
  }
  CFStringRef cf = v7;
  sub_19E37774C(v7, a3);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_19E513DEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E513E00(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFStringRef v5 = sub_19E3C2A64(a2);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, CFStringRef, uint64_t))(*(void *)a1 + 16))(a1, v5, a3);
  if (v5) {
    CFRelease(v5);
  }
  return v6;
}

void sub_19E513E8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3DCC24((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E513EA0(void *a1)
{
  sub_19E5139E0(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E513EDC(const __CFLocale *a1, int a2)
{
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(a1, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFStringRef v4 = (const __CFString *)CFLocaleGetValue(a1, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
  if (CFEqual(Value, @"zh")) {
    return v4 && CFEqual(v4, @"Hant");
  }
  if (CFStringCompare(Value, @"yue", 0))
  {
    if (CFStringCompare(Value, @"ja", 0)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 2;
    }
  }
  else if (v4)
  {
    if (CFStringCompare(v4, @"Hant", 0)) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 3;
    }
  }
  else
  {
    return 0xFFFFFFFFLL;
  }
}

void sub_19E513FE4(const __CFDictionary *a1, const __CFLocale *a2, uint64_t a3, uint64_t a4)
{
  v252[1] = *(CFTypeRef *)MEMORY[0x1E4F143B8];
  if (!a2) {
    return;
  }
  CFDictionaryRef v7 = a1;
  v239[0] = 0;
  v239[1] = 0;
  uint64_t v240 = 0;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, (const void *)kLMLanguageModelIsSiriModelKey);
  BOOL v225 = sub_19E377394(Value, 0);
  BOOL v9 = CFDictionaryContainsKey(v7, (const void *)kLMLanguageModelEnableSearchQueryModelLoadingKey) == 0;
  uint64_t v224 = a3;
  uint64_t v222 = a4;
  CFLocaleRef locale = a2;
  int v223 = sub_19E513EDC(a2, v9);
  if (!v7)
  {
    v244.n128_u8[0] = 0;
    LOBYTE(v246) = 0;
    goto LABEL_23;
  }
  if (kLMLanguageModelCustomResourceDirectoryKey
    && (CFArrayRef v10 = (const __CFArray *)CFDictionaryGetValue(v7, (const void *)kLMLanguageModelCustomResourceDirectoryKey)) != 0
    && (CFTypeID TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(v10)))
  {
    sub_19E4318FC((uint64_t)&v244, v10);
    if ((_BYTE)v246)
    {
      v237 = 0;
      uint64_t v238 = 0;
      v236 = 0;
      unint64_t v13 = v244.n128_u64[1];
      uint64_t v12 = (CFTypeRef *)v244.n128_u64[0];
      int64_t v14 = v244.n128_u64[1] - v244.n128_u64[0];
      if (v244.n128_u64[1] == v244.n128_u64[0])
      {
        uint64_t v15 = 0;
        int v32 = 0;
      }
      else
      {
        if (v14 < 0) {
          sub_19E37C7C4();
        }
        uint64_t v15 = operator new(v244.n128_u64[1] - v244.n128_u64[0]);
        v236 = v15;
        v237 = (char *)v15;
        uint64_t v238 = &v15[v14 >> 3];
        do
        {
          CFTypeRef v16 = *v12;
          if (*v12) {
            CFRetain(*v12);
          }
          *v15++ = v16;
          ++v12;
        }
        while (v12 != (CFTypeRef *)v13);
        int v32 = (CFTypeRef *)v236;
        v237 = (char *)v15;
      }
      sub_19E515A58(&v249, v32, (CFTypeRef *)v15);
      *(__n128 *)long long v239 = v249;
      uint64_t v240 = v250;
      uint64_t v250 = 0;
      __n128 v249 = 0uLL;
      if (!v236) {
        goto LABEL_341;
      }
      uint64_t v33 = v237;
      BOOL v34 = v236;
      if (v237 != v236)
      {
        do
        {
          uint64_t v36 = (const void *)*((void *)v33 - 1);
          v33 -= 8;
          BOOL v35 = v36;
          if (v36) {
            CFRelease(v35);
          }
        }
        while (v33 != v236);
        BOOL v34 = v236;
      }
      v237 = (char *)v236;
      operator delete(v34);
      if ((_BYTE)v246)
      {
LABEL_341:
        long long v28 = (void *)v244.n128_u64[0];
        if (v244.n128_u64[0])
        {
          for (unint64_t i = v244.n128_u64[1]; (void *)i != v28; i -= 8)
          {
            long long v39 = *(const void **)(i - 8);
            long long v38 = v39;
            if (v39) {
              CFRelease(v38);
            }
          }
LABEL_55:
          operator delete(v28);
          goto LABEL_56;
        }
      }
      goto LABEL_56;
    }
  }
  else
  {
    v244.n128_u8[0] = 0;
    LOBYTE(v246) = 0;
  }
  if (!kLMLanguageModelCustomResourceDirectoryKey
    || (uint64_t v17 = CFDictionaryGetValue(v7, (const void *)kLMLanguageModelCustomResourceDirectoryKey), (v18 = v17) == 0))
  {
LABEL_23:
    if ((_BYTE)v246)
    {
      uint64_t v24 = (void *)v244.n128_u64[0];
      if (v244.n128_u64[0])
      {
        for (unint64_t j = v244.n128_u64[1]; (void *)j != v24; j -= 8)
        {
          uint64_t v27 = *(const void **)(j - 8);
          uint64_t v26 = v27;
          if (v27) {
            CFRelease(v26);
          }
        }
        operator delete(v24);
      }
    }
    goto LABEL_57;
  }
  CFRetain(v17);
  CFRetain(v18);
  v252[0] = v18;
  sub_19E400D38(&__p, v252, 1uLL);
  sub_19E515A58(&v249, (CFTypeRef *)__p, v235);
  uint64_t v19 = (CFTypeRef *)__p;
  *(__n128 *)long long v239 = v249;
  uint64_t v240 = v250;
  uint64_t v250 = 0;
  __n128 v249 = 0uLL;
  if (__p)
  {
    uint64_t v20 = v235;
    long long v21 = __p;
    if (v235 != __p)
    {
      do
      {
        uint64_t v23 = *--v20;
        long long v22 = v23;
        if (v23) {
          CFRelease(v22);
        }
      }
      while (v20 != v19);
      long long v21 = __p;
    }
    uint64_t v235 = v19;
    operator delete(v21);
  }
  if (v252[0]) {
    CFRelease(v252[0]);
  }
  CFRelease(v18);
  if ((_BYTE)v246)
  {
    long long v28 = (void *)v244.n128_u64[0];
    if (v244.n128_u64[0])
    {
      for (unint64_t k = v244.n128_u64[1]; (void *)k != v28; k -= 8)
      {
        unint64_t v31 = *(const void **)(k - 8);
        unint64_t v30 = v31;
        if (v31) {
          CFRelease(v30);
        }
      }
      goto LABEL_55;
    }
  }
LABEL_56:
  CFStringRef v40 = (const __CFString *)CFDictionaryGetValue(v7, (const void *)kLMLanguageModelAddSystemToCustomResourcesKey);
  if (!sub_19E377394(v40, 0))
  {
    Mutable = 0;
    theArray = 0;
    goto LABEL_244;
  }
LABEL_57:
  theArray = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  uint64_t v41 = sub_19E36F060(a2);
  sub_19E40100C(&cf, v41);
  CFTypeRef v42 = cf;
  if (!cf)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    goto LABEL_334;
  }
  CFTypeID v43 = CFArrayGetTypeID();
  if (v43 != CFGetTypeID(v42))
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not convert");
LABEL_334:
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)v42);
  int v45 = Count;
  unint64_t v231 = 0;
  v232 = 0;
  CFDictionaryRef theDict = v7;
  if (Count << 32)
  {
    if (Count << 32 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v46 = (CFTypeRef *)operator new(8 * (int)Count);
    uint64_t v47 = (char *)&v46[v45];
    unint64_t v231 = (char *)v46;
    v232 = (char *)v46;
    if (v45 >= 1) {
      goto LABEL_62;
    }
  }
  else
  {
    uint64_t v47 = 0;
    uint64_t v46 = 0;
    if ((int)Count >= 1)
    {
LABEL_62:
      CFIndex v48 = 0;
      uint64_t v49 = v45;
      unint64_t v50 = (char *)v46;
      while (1)
      {
        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v42, v48);
        unint64_t v52 = ValueAtIndex;
        if (ValueAtIndex) {
          CFRetain(ValueAtIndex);
        }
        sub_19E36F3C4(&v244, v52);
        if (v50 >= v47) {
          break;
        }
        *(void *)unint64_t v50 = v244.n128_u64[0];
        v50 += 8;
LABEL_64:
        if (++v48 == v49)
        {
          v232 = v50;
          unint64_t v231 = (char *)v46;
          goto LABEL_99;
        }
      }
      uint64_t v53 = (v50 - (char *)v46) >> 3;
      unint64_t v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61) {
        sub_19E37C7C4();
      }
      if ((v47 - (char *)v46) >> 2 > v54) {
        unint64_t v54 = (v47 - (char *)v46) >> 2;
      }
      if ((unint64_t)(v47 - (char *)v46) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v55 = v54;
      }
      if (v55)
      {
        if (v55 >> 61) {
          sub_19E37C2B8();
        }
        int v56 = (char *)operator new(8 * v55);
      }
      else
      {
        int v56 = 0;
      }
      uint64_t v57 = &v56[8 * v53];
      uint64_t v47 = &v56[8 * v55];
      *(void *)uint64_t v57 = v244.n128_u64[0];
      uint64_t v58 = v57 + 8;
      v244.n128_u64[0] = 0;
      int64_t v59 = v50 - (char *)v46;
      if (v50 == (char *)v46)
      {
LABEL_91:
        if (v46) {
          operator delete(v46);
        }
        if (v244.n128_u64[0]) {
          CFRelease((CFTypeRef)v244.n128_u64[0]);
        }
        uint64_t v46 = (CFTypeRef *)v57;
        unint64_t v50 = v58;
        goto LABEL_64;
      }
      unint64_t v60 = v59 - 8;
      if ((unint64_t)(v59 - 8) >= 0x78)
      {
        if (&v56[v50 - (char *)v46 - (v60 & 0xFFFFFFFFFFFFFFF8) - 8] >= v50
          || (long long v61 = v50, &v50[-(v60 & 0xFFFFFFFFFFFFFFF8) - 8] >= v57))
        {
          uint64_t v62 = (v60 >> 3) + 1;
          v57 -= 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
          long long v63 = v50 - 32;
          long long v64 = &v56[8 * v53 - 16];
          uint64_t v65 = v62 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *((_OWORD *)v63 + 1);
            *((_OWORD *)v64 - 1) = *(_OWORD *)v63;
            *(_OWORD *)long long v64 = v66;
            *(_OWORD *)long long v63 = 0uLL;
            *((_OWORD *)v63 + 1) = 0uLL;
            v63 -= 32;
            v64 -= 32;
            v65 -= 4;
          }
          while (v65);
          if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_88:
            while (v50 != (char *)v46)
            {
              uint64_t v69 = (const void *)*((void *)v50 - 1);
              v50 -= 8;
              uint64_t v68 = v69;
              if (v69) {
                CFRelease(v68);
              }
            }
            goto LABEL_91;
          }
          long long v61 = &v50[-8 * (v62 & 0x3FFFFFFFFFFFFFFCLL)];
        }
      }
      else
      {
        long long v61 = v50;
      }
      do
      {
        uint64_t v67 = *((void *)v61 - 1);
        v61 -= 8;
        *((void *)v57 - 1) = v67;
        v57 -= 8;
        *(void *)long long v61 = 0;
      }
      while (v61 != (char *)v46);
      goto LABEL_88;
    }
  }
  unint64_t v50 = (char *)v46;
LABEL_99:
  uint64_t v70 = v50 - (char *)v46;
  if (v50 - (char *)v46 >= 1)
  {
    uint64_t v71 = v70 >> 3;
    unint64_t v73 = (unint64_t)v239[0];
    uint64_t v72 = (char *)v239[1];
    int64_t v74 = (char *)v239[1] - (char *)v239[0];
    int64_t v75 = ((char *)v239[1] - (char *)v239[0]) >> 3;
    uint64_t v76 = (char *)v239[0] + (((char *)v239[1] - (char *)v239[0]) & 0xFFFFFFFFFFFFFFF8);
    if (v70 >> 3 > (int64_t)(v240 - (unint64_t)v239[1]) >> 3)
    {
      unint64_t v220 = (char *)v239[1] - (char *)v239[0];
      unint64_t v77 = v75 + v71;
      if ((unint64_t)(v75 + v71) >> 61) {
        sub_19E37C7C4();
      }
      uint64_t v78 = v240 - (unint64_t)v239[0];
      if ((int64_t)(v240 - (unint64_t)v239[0]) >> 2 > v77) {
        unint64_t v77 = v78 >> 2;
      }
      if ((unint64_t)v78 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v79 = v77;
      }
      if (v79)
      {
        if (v79 >> 61) {
          sub_19E37C2B8();
        }
        uint64_t v80 = (char *)operator new(8 * v79);
      }
      else
      {
        uint64_t v80 = 0;
      }
      int64_t v216 = v75;
      CFTypeRef v87 = &v80[8 * v75];
      v217 = &v80[8 * v79];
      v219 = v80;
      uint64_t v88 = 8 * v71;
      BOOL v89 = &v87[8 * v71];
      uint64_t v214 = v88;
      uint64_t v90 = v87;
      do
      {
        CFTypeRef v91 = *v46;
        if (*v46) {
          CFRetain(*v46);
        }
        *(void *)uint64_t v90 = v91;
        v90 += 8;
        ++v46;
        v88 -= 8;
      }
      while (v88);
      if (v220 < 8)
      {
        long long v92 = v219;
        goto LABEL_139;
      }
      unint64_t v93 = (v220 & 0xFFFFFFFFFFFFFFF8) - 8;
      if (v93 >= 0x78)
      {
        unint64_t v95 = (v220 & 0xFFFFFFFFFFFFFFF8) - (v93 & 0xFFFFFFFFFFFFFFF8) - 8;
        long long v92 = v219;
        unint64_t v96 = (unint64_t)&v219[v95];
        int64_t v97 = (char *)(v73 + v95);
        BOOL v98 = v96 >= (unint64_t)v76 || v97 >= v87;
        uint64_t v94 = v76;
        if (v98)
        {
          uint64_t v99 = (v93 >> 3) + 1;
          v87 -= 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
          size_t v100 = (_OWORD *)(8 * v216 + v73 - 32);
          uint64_t v101 = &v219[8 * v216 - 16];
          uint64_t v102 = v99 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v103 = v100[1];
            *((_OWORD *)v101 - 1) = *v100;
            *(_OWORD *)uint64_t v101 = v103;
            _OWORD *v100 = 0uLL;
            v100[1] = 0uLL;
            v100 -= 2;
            v101 -= 32;
            v102 -= 4;
          }
          while (v102);
          if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_139;
          }
          uint64_t v94 = &v76[-8 * (v99 & 0x3FFFFFFFFFFFFFFCLL)];
        }
      }
      else
      {
        uint64_t v94 = v76;
        long long v92 = v219;
      }
      do
      {
        uint64_t v104 = *((void *)v94 - 1);
        v94 -= 8;
        *((void *)v87 - 1) = v104;
        v87 -= 8;
        *(void *)uint64_t v94 = 0;
      }
      while (v94 != (char *)v73);
      uint64_t v72 = (char *)v239[1];
LABEL_139:
      if (v72 == v76)
      {
        uint64_t v113 = v217;
        goto LABEL_154;
      }
      unint64_t v105 = (unint64_t)&v72[-(v220 & 0xFFFFFFFFFFFFFFF8) - v73 - 8];
      if (v105 >= 0xA8
        && ((unint64_t v106 = (v220 & 0xFFFFFFFFFFFFFFF8) + (v105 & 0xFFFFFFFFFFFFFFF8), (unint64_t)v89 < v106 + v73 + 8)
          ? (BOOL v107 = v76 >= &v92[v70 + 8 + v106])
          : (BOOL v107 = 1),
            v107))
      {
        uint64_t v108 = (v105 >> 3) + 1;
        uint64_t v109 = 8 * (v108 & 0x3FFFFFFFFFFFFFFCLL);
        int64_t v110 = &v76[v109];
        uint64_t v111 = &v92[8 * v216 + 16 + v214];
        uint64_t v112 = v108 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v113 = v217;
        do
        {
          long long v114 = *((_OWORD *)v76 + 1);
          *((_OWORD *)v111 - 1) = *(_OWORD *)v76;
          *(_OWORD *)uint64_t v111 = v114;
          *(_OWORD *)uint64_t v76 = 0uLL;
          *((_OWORD *)v76 + 1) = 0uLL;
          v76 += 32;
          v111 += 32;
          v112 -= 4;
        }
        while (v112);
        v89 += v109;
        if (v108 == (v108 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_152;
        }
      }
      else
      {
        int64_t v110 = v76;
        uint64_t v113 = v217;
      }
      do
      {
        *(void *)BOOL v89 = *(void *)v110;
        v89 += 8;
        *(void *)int64_t v110 = 0;
        v110 += 8;
      }
      while (v110 != v72);
LABEL_152:
      uint64_t v76 = v72;
LABEL_154:
      float32x4_t v115 = (char *)v239[0];
      v239[0] = v87;
      v239[1] = v89;
      uint64_t v240 = (uint64_t)v113;
      while (v76 != v115)
      {
        uint64_t v117 = (const void *)*((void *)v76 - 1);
        v76 -= 8;
        float32x4_t v116 = v117;
        if (v117) {
          CFRelease(v116);
        }
      }
      if (v115) {
        operator delete(v115);
      }
      goto LABEL_183;
    }
    uint64_t v81 = (char *)v239[1] - (char *)v76;
    uint64_t v82 = ((char *)v239[1] - (char *)v76) >> 3;
    if (v82 >= v71)
    {
      long long v83 = &v46[v71];
      uint64_t v85 = (char *)v239[1];
      goto LABEL_162;
    }
    long long v83 = &v46[v82];
    if (v83 == (CFTypeRef *)v50)
    {
      uint64_t v85 = (char *)v239[1];
    }
    else
    {
      v218 = (char *)((char *)v239[1] - (char *)v76);
      int64_t v221 = (char *)v239[1] - (char *)v239[0];
      int64_t v215 = ((char *)v239[1] - (char *)v239[0]) >> 3;
      uint64_t v84 = &v46[v82];
      uint64_t v85 = (char *)v239[1];
      do
      {
        CFTypeRef v86 = *v84;
        if (*v84) {
          CFRetain(*v84);
        }
        *(void *)uint64_t v85 = v86;
        v85 += 8;
        ++v84;
      }
      while (v84 != (CFTypeRef *)v50);
      int64_t v75 = v215;
      uint64_t v81 = (uint64_t)v218;
      int64_t v74 = v221;
    }
    v239[1] = v85;
    if (v81 >= 1)
    {
LABEL_162:
      uint64_t v118 = &v76[8 * v71];
      uint64_t v119 = v85 - v118;
      uint64_t v120 = &v85[-8 * v71];
      unint64_t v121 = v85;
      if (v120 < v72)
      {
        unint64_t v122 = (v74 & 0xFFFFFFFFFFFFFFF8) + v119;
        unint64_t v123 = (char *)(v122 + v73);
        unint64_t v124 = v122 + v73 + 8;
        if ((unint64_t)v72 > v124) {
          unint64_t v124 = (unint64_t)v72;
        }
        unint64_t v125 = v124 + ~v73 - v122;
        uint64_t v126 = &v85[-8 * v71];
        unint64_t v121 = v85;
        if (v125 <= 0xE7) {
          goto LABEL_342;
        }
        BOOL v127 = v85 >= &v123[(v125 & 0xFFFFFFFFFFFFFFF8) + 8] || v120 >= &v85[(v125 & 0xFFFFFFFFFFFFFFF8) + 8];
        uint64_t v126 = &v85[-8 * v71];
        unint64_t v121 = v85;
        if (!v127) {
          goto LABEL_342;
        }
        uint64_t v128 = (v125 >> 3) + 1;
        uint64_t v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v126 = &v120[v129];
        v130 = v85 + 16;
        uint64_t v131 = &v85[-8 * v71];
        uint64_t v132 = v128 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v133 = *((_OWORD *)v131 + 1);
          *(v130 - 1) = *(_OWORD *)v131;
          _OWORD *v130 = v133;
          *(_OWORD *)uint64_t v131 = 0uLL;
          *((_OWORD *)v131 + 1) = 0uLL;
          v131 += 32;
          v130 += 2;
          v132 -= 4;
        }
        while (v132);
        unint64_t v121 = &v85[v129];
        if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_342:
          do
          {
            *(void *)unint64_t v121 = *(void *)v126;
            v121 += 8;
            *(void *)uint64_t v126 = 0;
            v126 += 8;
          }
          while (v126 < v72);
        }
      }
      v239[1] = v121;
      if (v85 == v118) {
        goto LABEL_182;
      }
      if ((unint64_t)(v119 - 8) >= 0x68
        && (&v85[-(v119 & 0xFFFFFFFFFFFFFFF8)] >= v120
         || v73 + v119 + (v74 & 0xFFFFFFFFFFFFFFF8) - (v119 & 0xFFFFFFFFFFFFFFF8) >= (unint64_t)v85))
      {
        uint64_t v205 = v119 >> 3;
        unint64_t v206 = ((unint64_t)(v119 - 8) >> 3) + 1;
        uint64_t v134 = &v85[-8 * (v206 & 0x3FFFFFFFFFFFFFFCLL)];
        v207 = (long long *)(8 * v205 + 8 * v75 + v73 - 16);
        v208 = v85 - 16;
        uint64_t v209 = v206 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v211 = *((_OWORD *)v208 - 1);
          long long v210 = *(_OWORD *)v208;
          long long v212 = *v207;
          *((_OWORD *)v208 - 1) = *(v207 - 1);
          *(_OWORD *)v208 = v212;
          *(v207 - 1) = v211;
          long long *v207 = v210;
          v207 -= 2;
          v208 -= 32;
          v209 -= 4;
        }
        while (v209);
        if (v206 == (v206 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_182:
          while (v46 != v83)
          {
            unint64_t v140 = *(const void **)v76;
            CFTypeRef v141 = *v46;
            *(void *)uint64_t v76 = *v46;
            if (v141) {
              CFRetain(v141);
            }
            if (v140) {
              CFRelease(v140);
            }
            ++v46;
            v76 += 8;
          }
          goto LABEL_183;
        }
        v120 -= 8 * (v206 & 0x3FFFFFFFFFFFFFFCLL);
      }
      else
      {
        uint64_t v134 = v85;
      }
      v135 = (uint64_t *)(v134 - 8);
      do
      {
        uint64_t v136 = *((void *)v120 - 1);
        v120 -= 8;
        uint64_t v137 = *v135;
        *v135-- = v136;
        *(void *)uint64_t v120 = v137;
      }
      while (v120 != v76);
      goto LABEL_182;
    }
  }
LABEL_183:
  if (!v225)
  {
    if (theDict)
    {
      if (CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey))
      {
        uint64_t v147 = CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey);
        CFTypeID v148 = CFGetTypeID(v147);
        if (v148 == CFBooleanGetTypeID()) {
          CFBooleanGetValue((CFBooleanRef)v147);
        }
      }
    }
    uint64_t v149 = *MEMORY[0x1E4F724E0];
    v249.n128_u64[0] = 0;
    v249.n128_u64[1] = (unint64_t)&v249;
    uint64_t v250 = 0x2000000000;
    CFMutableArrayRef v251 = 0;
    CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    v244.n128_u64[0] = MEMORY[0x1E4F143A8];
    v244.n128_u64[1] = 0x40000000;
    v245 = sub_19E377330;
    uint64_t v246 = &unk_1E599F320;
    uint64_t v247 = &v249;
    uint64_t v248 = v149;
    LDEnumerateAssetDataItems();
    unint64_t v143 = *(__CFArray **)(v249.n128_u64[1] + 24);
    _Block_object_dispose(&v249, 8);
    v252[0] = v143;
    uint64_t v150 = *MEMORY[0x1E4F724E8];
    v249.n128_u64[0] = 0;
    v249.n128_u64[1] = (unint64_t)&v249;
    uint64_t v250 = 0x2000000000;
    CFMutableArrayRef v251 = 0;
    CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    v244.n128_u64[0] = MEMORY[0x1E4F143A8];
    v244.n128_u64[1] = 0x40000000;
    v245 = sub_19E377330;
    uint64_t v246 = &unk_1E599F320;
    uint64_t v247 = &v249;
    uint64_t v248 = v150;
    LDEnumerateAssetDataItems();
    CFArrayRef v151 = *(const __CFArray **)(v249.n128_u64[1] + 24);
    _Block_object_dispose(&v249, 8);
    CFArrayRef v243 = v151;
    CFStringRef v152 = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
    CFLocaleRef v242 = 0;
    CFRetain(locale);
    CFLocaleRef v242 = locale;
    v153 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    CFLocaleRef v154 = locale;
    if (v152)
    {
      CFLocaleRef v154 = locale;
      if (CFEqual(v152, @"Latn"))
      {
        CFStringRef v155 = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
        CFLocaleRef v154 = CFLocaleCreate(*v153, v155);
        CFRelease(locale);
        CFLocaleRef v242 = v154;
      }
    }
    uint64_t v156 = *MEMORY[0x1E4F72520];
    v249.n128_u64[0] = 0;
    v249.n128_u64[1] = (unint64_t)&v249;
    uint64_t v250 = 0x2000000000;
    CFMutableArrayRef v251 = 0;
    CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    v244.n128_u64[0] = MEMORY[0x1E4F143A8];
    v244.n128_u64[1] = 0x40000000;
    v245 = sub_19E377330;
    uint64_t v246 = &unk_1E599F320;
    uint64_t v247 = &v249;
    uint64_t v248 = v156;
    LDEnumerateAssetDataItems();
    CFArrayRef v157 = *(const __CFArray **)(v249.n128_u64[1] + 24);
    _Block_object_dispose(&v249, 8);
    CFArrayRef v241 = v157;
    if (CFArrayGetCount(v151) || CFArrayGetCount(v157))
    {
      CFIndex v158 = CFArrayGetCount(v143);
      CFIndex v159 = CFArrayGetCount(v151);
      CFIndex v160 = v159 + v158 + CFArrayGetCount(v157);
      CFAllocatorRef v161 = *v153;
      CFMutableStringRef MutableCopy = CFArrayCreateMutableCopy(*v153, v160, v143);
      CFIndex v163 = 0;
      v244.n128_u64[0] = (unint64_t)MutableCopy;
      while (v163 < CFArrayGetCount(v151))
      {
        CFURLRef v164 = (const __CFURL *)CFArrayGetValueAtIndex(v151, v163);
        CFURLRef v165 = CFURLCreateCopyAppendingPathComponent(v161, v164, @"morpheme.dat", 0);
        v249.n128_u64[0] = (unint64_t)v165;
        CFArrayAppendValue(MutableCopy, v165);
        if (v165) {
          CFRelease(v165);
        }
        ++v163;
      }
      v253.length = CFArrayGetCount(v157);
      v253.location = 0;
      CFArrayAppendArray(MutableCopy, v157, v253);
      int64x2_t v166 = v143;
      unint64_t v143 = MutableCopy;
      if (!v157) {
        goto LABEL_214;
      }
    }
    else
    {
      int64x2_t v166 = 0;
      v252[0] = 0;
      if (!v157) {
        goto LABEL_214;
      }
    }
    CFRelease(v157);
LABEL_214:
    if (v154) {
      CFRelease(v154);
    }
    if (v151) {
      CFRelease(v151);
    }
    if (v166) {
      CFRelease(v166);
    }
    if (theDict)
    {
      if (CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey))
      {
        int64x2_t v167 = CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey);
        CFTypeID v168 = CFGetTypeID(v167);
        if (v168 == CFBooleanGetTypeID()) {
          CFBooleanGetValue((CFBooleanRef)v167);
        }
      }
    }
    uint64_t v169 = *MEMORY[0x1E4F724C0];
    v249.n128_u64[0] = 0;
    v249.n128_u64[1] = (unint64_t)&v249;
    uint64_t v250 = 0x2000000000;
    CFMutableArrayRef v251 = 0;
    CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
    v244.n128_u64[0] = MEMORY[0x1E4F143A8];
    v244.n128_u64[1] = 0x40000000;
    v245 = sub_19E377330;
    uint64_t v246 = &unk_1E599F320;
    uint64_t v247 = &v249;
    uint64_t v248 = v169;
    LDEnumerateAssetDataItems();
    goto LABEL_225;
  }
  if (theDict)
  {
    if (CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey))
    {
      unint64_t v138 = CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey);
      CFTypeID v139 = CFGetTypeID(v138);
      if (v139 == CFBooleanGetTypeID()) {
        CFBooleanGetValue((CFBooleanRef)v138);
      }
    }
  }
  uint64_t v142 = *MEMORY[0x1E4F72510];
  v249.n128_u64[0] = 0;
  v249.n128_u64[1] = (unint64_t)&v249;
  uint64_t v250 = 0x2000000000;
  CFMutableArrayRef v251 = 0;
  CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v244.n128_u64[0] = MEMORY[0x1E4F143A8];
  v244.n128_u64[1] = 0x40000000;
  v245 = sub_19E377330;
  uint64_t v246 = &unk_1E599F320;
  uint64_t v247 = &v249;
  uint64_t v248 = v142;
  LDEnumerateAssetDataItems();
  unint64_t v143 = *(__CFArray **)(v249.n128_u64[1] + 24);
  _Block_object_dispose(&v249, 8);
  if (theDict)
  {
    if (CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey))
    {
      uint64_t v144 = CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey);
      CFTypeID v145 = CFGetTypeID(v144);
      if (v145 == CFBooleanGetTypeID()) {
        CFBooleanGetValue((CFBooleanRef)v144);
      }
    }
  }
  uint64_t v146 = *MEMORY[0x1E4F72518];
  v249.n128_u64[0] = 0;
  v249.n128_u64[1] = (unint64_t)&v249;
  uint64_t v250 = 0x2000000000;
  CFMutableArrayRef v251 = 0;
  CFMutableArrayRef v251 = CFArrayCreateMutable(0, 0, MEMORY[0x1E4F1D510]);
  v244.n128_u64[0] = MEMORY[0x1E4F143A8];
  v244.n128_u64[1] = 0x40000000;
  v245 = sub_19E377330;
  uint64_t v246 = &unk_1E599F320;
  uint64_t v247 = &v249;
  uint64_t v248 = v146;
  LDEnumerateAssetDataItems();
LABEL_225:
  CFArrayRef v170 = *(const __CFArray **)(v249.n128_u64[1] + 24);
  _Block_object_dispose(&v249, 8);
  if (v143 && CFArrayGetCount(v143) >= 1)
  {
    v254.length = CFArrayGetCount(v143);
    v254.location = 0;
    CFArrayAppendArray(theArray, v143, v254);
  }
  if (v170)
  {
    if (CFArrayGetCount(v170) >= 1)
    {
      v255.length = CFArrayGetCount(v170);
      v255.location = 0;
      CFArrayAppendArray(Mutable, v170, v255);
    }
    CFRelease(v170);
  }
  if (v143) {
    CFRelease(v143);
  }
  CFDictionaryRef v7 = theDict;
  if (v231)
  {
    uint64_t v171 = v232;
    unint64_t v172 = v231;
    if (v232 != v231)
    {
      do
      {
        uint64_t v174 = (const void *)*((void *)v171 - 1);
        v171 -= 8;
        uint64_t v173 = v174;
        if (v174) {
          CFRelease(v173);
        }
      }
      while (v171 != v231);
      unint64_t v172 = v231;
    }
    operator delete(v172);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_244:
  CFArrayRef v175 = sub_19E3781CC((char *)v239[0], (char *)v239[1]);
  if (CFDictionaryContainsKey(v7, (const void *)kLMLanguageModelCustomLexiconNameKey)) {
    CFStringRef v176 = (const __CFString *)CFDictionaryGetValue(v7, (const void *)kLMLanguageModelCustomLexiconNameKey);
  }
  else {
    CFStringRef v176 = 0;
  }
  if (CFDictionaryContainsKey(v7, (const void *)kLMLanguageModelCustomLexiconDeltaNameKey)) {
    CFStringRef v177 = (const __CFString *)CFDictionaryGetValue(v7, (const void *)kLMLanguageModelCustomLexiconDeltaNameKey);
  }
  else {
    CFStringRef v177 = 0;
  }
  if (v223 != -1)
  {
    if (v176) {
      CFStringRef v178 = v176;
    }
    else {
      CFStringRef v178 = @"lexicon";
    }
    sub_19E515BC4(&v244, theArray, v175, v178, 18);
    if (v244.n128_u64[0])
    {
      unint64_t v179 = *(__n128 **)(v224 + 8);
      if ((unint64_t)v179 >= *(void *)(v224 + 16))
      {
        unint64_t theDict_8 = v244.n128_u64[1];
        v181 = sub_19E40CC80(v224, v244);
        v180 = (std::__shared_weak_count *)theDict_8;
      }
      else
      {
        v179->n128_u64[0] = v244.n128_u64[0];
        v180 = (std::__shared_weak_count *)v244.n128_u64[1];
        v179->n128_u64[1] = v244.n128_u64[1];
        if (v180) {
          atomic_fetch_add_explicit(&v180->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v181 = v179 + 1;
      }
      *(void *)(v224 + 8) = v181;
      if (!v180) {
        goto LABEL_311;
      }
      goto LABEL_310;
    }
    goto LABEL_309;
  }
  if (v176)
  {
    sub_19E515BC4(&v244, theArray, v175, v176, 20);
    goto LABEL_286;
  }
  CFStringRef v182 = (const __CFString *)*MEMORY[0x1E4F1D218];
  CFStringRef v183 = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFComparisonResult v184 = CFStringCompare(v183, @"ko", 0);
  int v185 = _os_feature_enabled_impl();
  if (v184) {
    int v186 = v185;
  }
  else {
    int v186 = 0;
  }
  if (v186 == 1)
  {
    sub_19E515BC4(&v244, theArray, v175, @"morpheme", 20);
    if (v244.n128_u64[0]) {
      goto LABEL_286;
    }
    uint64_t v187 = (std::__shared_weak_count *)v244.n128_u64[1];
    if (v244.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v244.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v187->__on_zero_shared)(v187);
      std::__shared_weak_count::__release_weak(v187);
    }
  }
  if (v225)
  {
    CFStringRef v188 = @"Siri-Unigrams";
  }
  else
  {
    CFStringRef v189 = (const __CFString *)CFLocaleGetValue(locale, v182);
    CFStringRef v190 = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
    if (!v189
      || (CFStringRef v191 = v190, CFStringCompare(v189, @"hi", 0))
      || !v191
      || CFStringCompare(v191, @"Latn", 0))
    {
      sub_19E515ED8(&v244, theArray, v175, locale, @"UnifiedTransliteration", 20);
      if (v244.n128_u64[0]) {
        goto LABEL_286;
      }
      size_t v192 = (std::__shared_weak_count *)v244.n128_u64[1];
      if (v244.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v244.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v192->__on_zero_shared)(v192);
        std::__shared_weak_count::__release_weak(v192);
      }
    }
    CFStringRef v188 = @"Unigrams";
  }
  sub_19E515ED8(&v244, theArray, v175, locale, v188, 20);
LABEL_286:
  if (v177)
  {
    sub_19E515BC4(&v249, Mutable, v175, v177, 26);
  }
  else
  {
    if (v225) {
      CFStringRef v193 = @"Siri-Delta";
    }
    else {
      CFStringRef v193 = @"Delta";
    }
    sub_19E515ED8(&v249, Mutable, v175, locale, v193, 26);
  }
  if (v244.n128_u64[0])
  {
    char v194 = *(__n128 **)(v224 + 8);
    if ((unint64_t)v194 >= *(void *)(v224 + 16))
    {
      v196 = sub_19E40CC80(v224, v244);
    }
    else
    {
      v194->n128_u64[0] = v244.n128_u64[0];
      unint64_t v195 = v244.n128_u64[1];
      v194->n128_u64[1] = v244.n128_u64[1];
      if (v195) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v195 + 8), 1uLL, memory_order_relaxed);
      }
      v196 = v194 + 1;
    }
    *(void *)(v224 + 8) = v196;
  }
  if (v249.n128_u64[0] && !v225)
  {
    unint64_t v197 = *(__n128 **)(v222 + 8);
    if ((unint64_t)v197 >= *(void *)(v222 + 16))
    {
      float32x4x3_t v199 = sub_19E40CC80(v222, v249);
    }
    else
    {
      v197->n128_u64[0] = v249.n128_u64[0];
      unint64_t v198 = v249.n128_u64[1];
      v197->n128_u64[1] = v249.n128_u64[1];
      if (v198) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v198 + 8), 1uLL, memory_order_relaxed);
      }
      float32x4x3_t v199 = v197 + 1;
    }
    *(void *)(v222 + 8) = v199;
  }
  size_t v200 = (std::__shared_weak_count *)v249.n128_u64[1];
  if (v249.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v249.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v200->__on_zero_shared)(v200);
    std::__shared_weak_count::__release_weak(v200);
    v180 = (std::__shared_weak_count *)v244.n128_u64[1];
    if (!v244.n128_u64[1]) {
      goto LABEL_311;
    }
    goto LABEL_310;
  }
LABEL_309:
  v180 = (std::__shared_weak_count *)v244.n128_u64[1];
  if (!v244.n128_u64[1]) {
    goto LABEL_311;
  }
LABEL_310:
  if (!atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
    std::__shared_weak_count::__release_weak(v180);
    if (!theArray) {
      goto LABEL_313;
    }
    goto LABEL_312;
  }
LABEL_311:
  if (theArray) {
LABEL_312:
  }
    CFRelease(theArray);
LABEL_313:
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFRelease(v175);
  v201 = (char *)v239[0];
  if (v239[0])
  {
    for (m = (char *)v239[1]; m != v201; m -= 8)
    {
      v204 = (const void *)*((void *)m - 1);
      v203 = v204;
      if (v204) {
        CFRelease(v203);
      }
    }
    operator delete(v201);
  }
}

void sub_19E5157A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,void *a35)
{
  sub_19E400F9C(&a32);
  sub_19E431C34((char **)(v35 - 208));
  sub_19E431D88(&a35);
  _Unwind_Resume(a1);
}

void sub_19E515A58(void *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2 != a3)
  {
    CFStringRef v4 = a2;
    uint64_t v6 = 0;
    do
    {
      CFStringRef v7 = (const __CFString *)*v4;
      if (*v4)
      {
        CFTypeID v8 = CFGetTypeID(*v4);
        if (v8 == CFStringGetTypeID())
        {
          CFURLRef v9 = CFURLCreateWithFileSystemPath(0, v7, kCFURLPOSIXPathStyle, 1u);
LABEL_9:
          CFURLRef v11 = v9;
          if (v9)
          {
            CFTypeID v12 = CFGetTypeID(v9);
            if (v12 != CFURLGetTypeID()
              || ((unint64_t)v6 >= a1[2]
                ? (uint64_t v6 = sub_19E5164A0((uint64_t)a1, v11))
                : (CFRetain(v11), *uint64_t v6 = v11, ++v6),
                  a1[1] = v6,
                  v11))
            {
              CFRelease(v11);
            }
          }
          goto LABEL_3;
        }
        CFTypeID v10 = CFGetTypeID(v7);
        if (v10 == CFURLGetTypeID())
        {
          CFURLRef v9 = CFURLCopyAbsoluteURL((CFURLRef)v7);
          goto LABEL_9;
        }
      }
LABEL_3:
      ++v4;
    }
    while (v4 != a3);
  }
}

void sub_19E515B8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E410F68((const void **)va);
  sub_19E431D88(v2);
  _Unwind_Resume(a1);
}

void sub_19E515BC4(void *a1, const __CFArray *a2, CFArrayRef theArray, const __CFString *a4, int a5)
{
  int valuePtr = a5;
  uint64_t v22 = 0;
  CFTypeRef cf = 0;
  if (!a2) {
    goto LABEL_9;
  }
  CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"%@.dat", a4);
  CFURLRef v10 = 0;
  CFIndex v11 = 0;
  do
  {
    if (v11 >= CFArrayGetCount(a2)) {
      break;
    }
    CFURLRef ValueAtIndex = (const __CFURL *)CFArrayGetValueAtIndex(a2, v11);
    CFURLRef v13 = CFURLCopyAbsoluteURL(ValueAtIndex);
    CFStringRef v14 = CFURLCopyFileSystemPath(v13, kCFURLPOSIXPathStyle);
    if (CFStringHasSuffix(v14, v9))
    {
      CFTypeRef cf = v13;
      CFURLRef v10 = v13;
    }
    else
    {
      CFRelease(v13);
      CFURLRef v13 = 0;
    }
    CFRelease(v14);
    ++v11;
  }
  while (!v13);
  CFRelease(v9);
  if (v10)
  {
LABEL_12:
    CFDictionaryRef theDict = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFURLRef v17 = CFURLCopyAbsoluteURL(v10);
    CFNumberRef v18 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFNumberRef v19 = CFNumberCreate(0, kCFNumberCFIndexType, &v22);
    CFDictionarySetValue(theDict, @"URL", v17);
    CFDictionarySetValue(theDict, @"Name", a4);
    CFDictionarySetValue(theDict, @"Type", v18);
    CFDictionarySetValue(theDict, @"Priority", v19);
    uint64_t v20 = operator new(0x28uLL);
    v20[1] = 0;
    v20[2] = 0;
    *uint64_t v20 = &unk_1EF0BE728;
    v20[4] = 0;
    v20[3] = CFRetain(theDict);
    *a1 = v20 + 3;
    a1[1] = v20;
    if (v19) {
      CFRelease(v19);
    }
    if (v18) {
      CFRelease(v18);
    }
    if (v17) {
      CFRelease(v17);
    }
    if (theDict) {
      CFRelease(theDict);
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
LABEL_9:
    CFIndex v15 = 0;
    while (v15 < CFArrayGetCount(theArray))
    {
      CFURLRef v16 = (const __CFURL *)CFArrayGetValueAtIndex(theArray, v15);
      CFURLRef v10 = CFBundleCopyResourceURLInDirectory(v16, a4, @"dat", 0);
      CFTypeRef cf = v10;
      ++v15;
      if (v10) {
        goto LABEL_12;
      }
    }
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_19E515E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, const void *a11, const void *a12, const void *a13, uint64_t a14, const void *a15)
{
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  sub_19E431EA8(&a10);
  sub_19E431EA8(&a11);
  sub_19E3F6888(&a12);
  sub_19E410F30(&a13);
  sub_19E3F6888(&a15);
  _Unwind_Resume(a1);
}

void sub_19E515ED8(void *a1, const __CFArray *a2, const __CFArray *a3, CFLocaleRef locale, const __CFString *a5, int a6)
{
  *a1 = 0;
  a1[1] = 0;
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFTypeRef v12 = CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D220]);
  CFTypeRef v13 = CFLocaleGetValue(locale, (CFLocaleKey)*MEMORY[0x1E4F1D1F0]);
  if (CFStringCompare(Value, @"ars", 0)) {
    CFStringRef v14 = (__CFString *)Value;
  }
  else {
    CFStringRef v14 = @"ar";
  }
  if (!v12)
  {
    if (v13)
    {
      CFStringRef v32 = CFStringCreateWithFormat(0, 0, @"%@-%@_%@", a5, v14, v13);
      sub_19E515BC4(&v38, a2, a3, v32, a6);
      BOOL v34 = (atomic_ullong *)*((void *)&v38 + 1);
      uint64_t v33 = v38;
      *a1 = v38;
      a1[1] = v34;
      CFRelease(v32);
      if (v33) {
        return;
      }
    }
    else
    {
      BOOL v34 = 0;
    }
    CFStringRef v28 = CFStringCreateWithFormat(0, 0, @"%@-%@", a5, v14);
    sub_19E515BC4(&v38, a2, a3, v28, a6);
    long long v35 = v38;
    long long v38 = 0uLL;
    *(_OWORD *)a1 = v35;
    if (!v34 || atomic_fetch_add(v34 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_40;
    }
    (*(void (**)(atomic_ullong *))(*v34 + 16))(v34);
    unint64_t v31 = (std::__shared_weak_count *)v34;
    goto LABEL_39;
  }
  if (!v13) {
    goto LABEL_46;
  }
  CFStringRef v15 = CFStringCreateWithFormat(0, 0, @"%@-%@-%@_%@", a5, v14, v12, v13);
  sub_19E515BC4(&v38, a2, a3, v15, a6);
  long long v16 = v38;
  *(_OWORD *)a1 = v38;
  CFRelease(v15);
  if (!(void)v16)
  {
    CFStringRef v17 = CFStringCreateWithFormat(0, 0, @"%@-%@_%@_%@", a5, v14, v12, v13);
    sub_19E515BC4(&v38, a2, a3, v17, a6);
    long long v18 = v38;
    long long v38 = 0uLL;
    *(_OWORD *)a1 = v18;
    if (*((void *)&v16 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v16 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v16 + 1) + 16))(*((void *)&v16 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v16 + 1));
    }
    CFNumberRef v19 = (std::__shared_weak_count *)*((void *)&v38 + 1);
    if (*((void *)&v38 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    CFRelease(v17);
    if (!*a1)
    {
LABEL_46:
      CFStringRef v20 = CFStringCreateWithFormat(0, 0, @"%@-%@-%@", a5, v14, v12);
      sub_19E515BC4(&v38, a2, a3, v20, a6);
      long long v21 = v38;
      long long v38 = 0uLL;
      uint64_t v22 = (std::__shared_weak_count *)a1[1];
      *(_OWORD *)a1 = v21;
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
      uint64_t v23 = (std::__shared_weak_count *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
      CFRelease(v20);
      if (!*a1)
      {
        CFStringRef v24 = CFStringCreateWithFormat(0, 0, @"%@-%@_%@", a5, v14, v12);
        sub_19E515BC4(&v38, a2, a3, v24, a6);
        long long v25 = v38;
        long long v38 = 0uLL;
        uint64_t v26 = (std::__shared_weak_count *)a1[1];
        *(_OWORD *)a1 = v25;
        if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
        uint64_t v27 = (std::__shared_weak_count *)*((void *)&v38 + 1);
        if (*((void *)&v38 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
        CFRelease(v24);
        if (!*a1 && CFEqual(a5, @"UnifiedTransliteration"))
        {
          CFStringRef v28 = CFStringCreateWithFormat(0, 0, @"%@-%@", a5, v14);
          sub_19E515BC4(&v38, a2, a3, v28, a6);
          long long v29 = v38;
          long long v38 = 0uLL;
          unint64_t v30 = (atomic_ullong *)a1[1];
          *(_OWORD *)a1 = v29;
          if (!v30 || atomic_fetch_add(v30 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_40;
          }
          (*(void (**)(atomic_ullong *))(*v30 + 16))(v30);
          unint64_t v31 = (std::__shared_weak_count *)v30;
LABEL_39:
          std::__shared_weak_count::__release_weak(v31);
LABEL_40:
          uint64_t v36 = (std::__shared_weak_count *)*((void *)&v38 + 1);
          if (*((void *)&v38 + 1))
          {
            if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
              std::__shared_weak_count::__release_weak(v36);
            }
          }
          CFRelease(v28);
        }
      }
    }
  }
}

void sub_19E516468(_Unwind_Exception *a1)
{
  sub_19E3D73EC(v1);
  _Unwind_Resume(a1);
}

void *sub_19E5164A0(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(char **)a1;
  unint64_t v3 = *(char **)(a1 + 8);
  uint64_t v4 = (uint64_t)&v3[-*(void *)a1];
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v9 = *(void *)(a1 + 16) - (void)v2;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (!v10)
  {
    CFIndex v11 = 0;
    if (!a2) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v10 >> 61) {
    sub_19E37C2B8();
  }
  CFIndex v11 = (char *)operator new(8 * v10);
  if (a2)
  {
LABEL_12:
    CFRetain(a2);
    uint64_t v2 = *(char **)a1;
    unint64_t v3 = *(char **)(a1 + 8);
  }
LABEL_13:
  CFTypeRef v12 = &v11[8 * v5];
  CFTypeRef v13 = &v11[8 * v10];
  *(void *)CFTypeRef v12 = a2;
  CFStringRef v14 = v12 + 8;
  if (v3 == v2)
  {
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v14;
    *(void *)(a1 + 16) = v13;
    goto LABEL_27;
  }
  unint64_t v15 = v3 - v2 - 8;
  if (v15 > 0x77
    && (&v11[v4 - (v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v3 || &v3[-(v15 & 0xFFFFFFFFFFFFFFF8) - 8] >= v12))
  {
    uint64_t v16 = (v15 >> 3) + 1;
    v12 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
    CFStringRef v17 = v3 - 32;
    long long v18 = &v11[8 * v5 - 16];
    uint64_t v19 = v16 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v20 = *((_OWORD *)v17 + 1);
      *((_OWORD *)v18 - 1) = *(_OWORD *)v17;
      *(_OWORD *)long long v18 = v20;
      *(_OWORD *)CFStringRef v17 = 0uLL;
      *((_OWORD *)v17 + 1) = 0uLL;
      v17 -= 32;
      v18 -= 32;
      v19 -= 4;
    }
    while (v19);
    if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_22;
    }
    v3 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v21 = *((void *)v3 - 1);
    v3 -= 8;
    *((void *)v12 - 1) = v21;
    v12 -= 8;
    *(void *)unint64_t v3 = 0;
  }
  while (v3 != v2);
LABEL_22:
  uint64_t v2 = *(char **)a1;
  uint64_t v22 = *(char **)(a1 + 8);
  *(void *)a1 = v12;
  *(void *)(a1 + 8) = v14;
  *(void *)(a1 + 16) = v13;
  while (v22 != v2)
  {
    CFStringRef v24 = (const void *)*((void *)v22 - 1);
    v22 -= 8;
    uint64_t v23 = v24;
    if (v24) {
      CFRelease(v23);
    }
  }
LABEL_27:
  if (v2) {
    operator delete(v2);
  }
  return v14;
}

void ***sub_19E516648(void ***a1)
{
  if (!*((unsigned char *)a1 + 8))
  {
    uint64_t v2 = *a1;
    unint64_t v3 = (char *)**a1;
    if (v3)
    {
      uint64_t v4 = (char *)v2[1];
      uint64_t v5 = **a1;
      if (v4 != v3)
      {
        do
        {
          CFStringRef v7 = (const void *)*((void *)v4 - 1);
          v4 -= 8;
          unint64_t v6 = v7;
          if (v7) {
            CFRelease(v6);
          }
        }
        while (v4 != v3);
        uint64_t v5 = **a1;
      }
      v2[1] = v3;
      operator delete(v5);
    }
  }
  return a1;
}

uint64_t sub_19E5166C8(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4)
{
  BOOL v7 = CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelEnableSearchQueryModelLoadingKey) == 0;
  uint64_t result = sub_19E513EDC(*(const __CFLocale **)(a1 + 56), v7);
  uint64_t v9 = *(CFDictionaryRef ***)a3;
  if (*(void *)(a3 + 8) != *(void *)a3)
  {
    if (result != -1)
    {
      CFURLRef Value = (const __CFURL *)CFDictionaryGetValue(**v9, @"URL");
      CFURLCopyFileSystemPath(Value, kCFURLPOSIXPathStyle);
      operator new();
    }
    CFURLRef v11 = (const __CFURL *)CFDictionaryGetValue(**v9, @"URL");
    CFURLCopyFileSystemPath(v11, kCFURLPOSIXPathStyle);
    if ((uint64_t)(*(void *)(a4 + 8) - *(void *)a4) >> 4)
    {
      CFURLRef v12 = (const __CFURL *)CFDictionaryGetValue(***(CFDictionaryRef ***)a4, @"URL");
      CFURLCopyFileSystemPath(v12, kCFURLPOSIXPathStyle);
      operator new();
    }
    operator new();
  }
  return result;
}

void sub_19E516C0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (__p) {
    (*(void (**)(void *))(*(void *)__p + 8))(__p);
  }
  sub_19E3DCC24(&a15);
  _Unwind_Resume(a1);
}

void *sub_19E516E08(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    sub_19E37C7C4();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  unint64_t v10 = &v9[8 * v3];
  CFURLRef v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)unint64_t v10 = v12;
  CFTypeRef v13 = v10 + 8;
  CFStringRef v14 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    goto LABEL_25;
  }
  unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
  if (v16 > 0x77
    && (&v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v10 || &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] >= v15))
  {
    uint64_t v17 = (v16 >> 3) + 1;
    v10 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    long long v18 = v15 - 32;
    uint64_t v19 = &v9[8 * v3 - 16];
    uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v22 = *(_OWORD *)v18;
      long long v21 = *((_OWORD *)v18 + 1);
      *(_OWORD *)long long v18 = 0uLL;
      *((_OWORD *)v18 + 1) = 0uLL;
      v18 -= 32;
      *((_OWORD *)v19 - 1) = v22;
      *(_OWORD *)uint64_t v19 = v21;
      v19 -= 32;
      v20 -= 4;
    }
    while (v20);
    if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_20;
    }
    v15 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
  }
  do
  {
    uint64_t v23 = *((void *)v15 - 1);
    v15 -= 8;
    *(void *)unint64_t v15 = 0;
    *((void *)v10 - 1) = v23;
    v10 -= 8;
  }
  while (v15 != v14);
LABEL_20:
  unint64_t v15 = (char *)*a1;
  CFStringRef v24 = (char *)a1[1];
  *a1 = v10;
  a1[1] = v13;
  a1[2] = v11;
  while (v24 != v15)
  {
    uint64_t v26 = *((void *)v24 - 1);
    v24 -= 8;
    uint64_t v25 = v26;
    *(void *)CFStringRef v24 = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
LABEL_25:
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

uint64_t **sub_19E516FB8(uint64_t **result)
{
  uint64_t v1 = result;
  uint64_t v2 = *result;
  uint64_t v3 = result[1];
  if ((unint64_t)((char *)v3 - (char *)*result) < 9)
  {
    if (v2 == v3) {
      operator new[]();
    }
  }
  else
  {
    unint64_t v4 = v2 + 1;
    while (v3 != v4)
    {
      uint64_t v5 = (uint64_t **)*--v3;
      uint64_t result = v5;
      *uint64_t v3 = 0;
      if (v5) {
        uint64_t result = (uint64_t **)MEMORY[0x19F3BDCC0](result, 0x1000C8077774924);
      }
    }
    v1[1] = v4;
  }
  unint64_t v6 = (uint64_t *)**v1;
  v1[3] = v6;
  v1[4] = v6;
  v1[7] = 0;
  return result;
}

void sub_19E5170BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10) {
    MEMORY[0x19F3BDCC0](a10, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E5170E4(void *a1)
{
  uint64_t v2 = (uint64_t **)a1[6];
  if (v2)
  {
    uint64_t v3 = a1[3];
    if (a1[4] != v3)
    {
      unint64_t v4 = 0;
      do
      {
        if ((*(unsigned int (**)(void))(**(void **)(v3 + 8 * v4) + 144))(*(void *)(v3 + 8 * v4)))
        {
          uint64_t v5 = (void *)a1[6];
          if (v5[7])
          {
            unint64_t v6 = 0;
            do
            {
              uint64_t v7 = *(void *)(a1[3] + 8 * v4);
              (*(void (**)(uint64_t, unint64_t))(*(void *)v7 + 152))(v7, *(void *)(*v5 + ((v6 >> 4) & 0xFFFFFFFFFFFFFF8))+ v5[5] * (v6 & 0x7F)+ ((uint64_t)(0x5000000000 * v4 + 0x5000000000) >> 32));
              ++v6;
              uint64_t v5 = (void *)a1[6];
            }
            while (v6 < v5[7]);
          }
        }
        ++v4;
        uint64_t v3 = a1[3];
      }
      while (v4 < (a1[4] - v3) >> 3);
      uint64_t v2 = (uint64_t **)a1[6];
    }
  }
  sub_19E516FB8(v2);
  uint64_t result = sub_19E513464((void *)a1[6]);
  uint64_t v9 = a1[3];
  if (a1[4] != v9)
  {
    uint64_t v10 = result;
    unint64_t v11 = 0;
    uint64_t v12 = 0x5000000000;
    do
    {
      (*(void (**)(void))(**(void **)(v9 + 8 * v11) + 120))(*(void *)(v9 + 8 * v11));
      uint64_t v13 = *(void *)(a1[3] + 8 * v11);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v13 + 16))(v13, v10 + (v12 >> 32));
      ++v11;
      uint64_t v9 = a1[3];
      v12 += 0x5000000000;
    }
    while (v11 < (a1[4] - v9) >> 3);
  }
  return result;
}

void sub_19E517290(uint64_t a1, CFDictionaryRef theDict)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(void *)a1 = &unk_1EF0BA1F0;
  *(void *)(a1 + 16) = &unk_1EF0BA248;
  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelLocaleKey);
  CFStringRef v5 = Value;
  if (Value)
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFStringGetTypeID())
    {
      CFStringRef v7 = (const __CFString *)CFLocaleCreate(0, v5);
LABEL_6:
      CFStringRef v5 = v7;
      goto LABEL_8;
    }
    CFTypeID v8 = CFGetTypeID(v5);
    if (v8 == CFLocaleGetTypeID())
    {
      CFStringRef v7 = (const __CFString *)CFRetain(v5);
      goto LABEL_6;
    }
    CFStringRef v5 = 0;
  }
LABEL_8:
  if (sub_19E36E648((const __CFLocale *)v5, @"ars"))
  {
    CFLocaleRef v9 = sub_19E3C3258((uint64_t)v5, @"ar");
    CFRelease(v5);
    CFStringRef v5 = (const __CFString *)v9;
  }
  *(void *)(a1 + 56) = v5;
  if (v5)
  {
    if (CFDictionaryGetValue(theDict, (const void *)kLMLanguageModelCustomWordsKey))
    {
      BOOL v10 = CFDictionaryContainsKey(theDict, (const void *)kLMLanguageModelEnableSearchQueryModelLoadingKey) == 0;
      sub_19E513EDC(*(const __CFLocale **)(a1 + 56), v10);
      operator new();
    }
    long long __dst = 0uLL;
    uint64_t v23 = 0;
    long long __p = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    sub_19E513FE4(theDict, *(const __CFLocale **)(a1 + 56), (uint64_t)&__dst, (uint64_t)&__p);
    sub_19E5166C8(a1, theDict, (uint64_t)&__dst, (uint64_t)&__p);
    unint64_t v11 = (char *)__p;
    if (__p)
    {
      uint64_t v12 = v20;
      if (v20 != __p)
      {
        do
        {
          uint64_t v13 = (std::__shared_weak_count *)*((void *)v12 - 1);
          if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
          v12 -= 16;
        }
        while (v12 != v11);
        unint64_t v11 = (char *)__p;
      }
      operator delete(v11);
    }
    CFStringRef v14 = (char *)__dst;
    if ((void)__dst)
    {
      unint64_t v15 = (char *)*((void *)&__dst + 1);
      if (*((void *)&__dst + 1) != (void)__dst)
      {
        do
        {
          unint64_t v16 = (std::__shared_weak_count *)*((void *)v15 - 1);
          if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
            std::__shared_weak_count::__release_weak(v16);
          }
          v15 -= 16;
        }
        while (v15 != v14);
        CFStringRef v14 = (char *)__dst;
      }
      operator delete(v14);
    }
  }
  if (*(void *)(a1 + 24) != *(void *)(a1 + 32)) {
    operator new();
  }
  exception = __cxa_allocate_exception(0x20uLL);
  long long v18 = (char *)operator new(0x20uLL);
  strcpy(v18, "Lexicon resources not found");
  *(void *)exception = &unk_1EF0BD3F0;
  sub_19E39369C(exception + 8, v18, 0x1BuLL);
  __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
}

void sub_19E51851C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a18) {
    (*(void (**)(uint64_t))(*(void *)a18 + 8))(a18);
  }
  char v37 = (const void *)a17[7];
  if (v37) {
    CFRelease(v37);
  }
  a17[7] = 0;
  long long v38 = (void *)a17[6];
  a17[6] = 0;
  if (v38)
  {
    long long v39 = (void *)*v38;
    if (*v38)
    {
      CFStringRef v40 = (void *)v38[1];
      uint64_t v41 = (void *)*v38;
      if (v40 != v39)
      {
        do
        {
          uint64_t v43 = *--v40;
          uint64_t v42 = v43;
          void *v40 = 0;
          if (v43) {
            MEMORY[0x19F3BDCC0](v42, 0x1000C8077774924);
          }
        }
        while (v40 != v39);
        uint64_t v41 = (void *)*v38;
      }
      v38[1] = v39;
      operator delete(v41);
    }
    MEMORY[0x19F3BDCF0](v38, 0x1030C404F540F20);
  }
  uint64_t v44 = (void *)*a16;
  if (*a16)
  {
    int v45 = (void *)a17[4];
    uint64_t v46 = (void *)*a16;
    if (v45 != v44)
    {
      do
      {
        uint64_t v48 = *--v45;
        uint64_t v47 = v48;
        *int v45 = 0;
        if (v48) {
          (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
        }
      }
      while (v45 != v44);
      uint64_t v46 = (void *)*a16;
    }
    a17[4] = v44;
    operator delete(v46);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E518A20()
{
}

uint64_t sub_19E518A2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double *a5)
{
  uint64_t v10 = sub_19E513464(*(void **)(a1 + 48));
  uint64_t v11 = *(void *)(a1 + 24);
  if (*(void *)(a1 + 32) != v11)
  {
    uint64_t v12 = v10;
    uint64_t v26 = a5;
    unint64_t v13 = 0;
    char v14 = 0;
    double v15 = 0.0;
    uint64_t v16 = 0x5000000000;
    do
    {
      double v18 = (*(double (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(v11 + 8 * v13) + 24))(*(void *)(v11 + 8 * v13), a2 + (v16 >> 32), v12 + (v16 >> 32), a3, a4);
      uint64_t v19 = *(void *)(*(void *)(a1 + 24) + 8 * v13);
      if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v19 + 32))(v19, v12 + (v16 >> 32)))
      {
        char v14 = 1;
        if (v15 == 0.0) {
          double v15 = v18;
        }
      }
      ++v13;
      uint64_t v11 = *(void *)(a1 + 24);
      uint64_t v17 = *(void *)(a1 + 32);
      v16 += 0x5000000000;
    }
    while (v13 < (v17 - v11) >> 3);
    if (v14)
    {
      if (v26) {
        double *v26 = v15;
      }
      return v12;
    }
    if (v17 != v11)
    {
      unint64_t v20 = 0;
      uint64_t v21 = 0x5000000000;
      do
      {
        if ((*(unsigned int (**)(void))(**(void **)(v11 + 8 * v20) + 144))(*(void *)(v11 + 8 * v20)))
        {
          uint64_t v22 = *(void *)(*(void *)(a1 + 24) + 8 * v20);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 152))(v22, v12 + (v21 >> 32));
        }
        ++v20;
        uint64_t v11 = *(void *)(a1 + 24);
        v21 += 0x5000000000;
      }
      while (v20 < (*(void *)(a1 + 32) - v11) >> 3);
    }
  }
  uint64_t v23 = *(void **)(a1 + 48);
  unint64_t v24 = v23[4];
  uint64_t v12 = 0;
  if (v24 > v23[3])
  {
    v23[4] = v24 - v23[5];
    --v23[7];
  }
  return v12;
}

double sub_19E518C44(std::string *a1, uint64_t **a2, int a3, __n128 a4)
{
  uint64_t v176 = *MEMORY[0x1E4F143B8];
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  CFStringRef v5 = a1;
  switch(a3)
  {
    case 3:
      memset(&v162, 0, sizeof(v162));
      uint64_t v6 = **a2;
      uint64_t v7 = (*a2)[1];
      if (v6 != v7)
      {
        CFTypeID v8 = 0;
        do
        {
          if ((unint64_t)v8 < v162.__r_.__value_.__r.__words[2])
          {
            if (*(char *)(v6 + 23) < 0)
            {
              sub_19E39369C(v8, *(void **)v6, *(void *)(v6 + 8));
            }
            else
            {
              long long v9 = *(_OWORD *)v6;
              *((void *)v8 + 2) = *(void *)(v6 + 16);
              *(_OWORD *)CFTypeID v8 = v9;
            }
            v8 += 24;
          }
          else
          {
            CFTypeID v8 = sub_19E3FC244(&v162.__r_.__value_.__l.__data_, v6);
          }
          v162.__r_.__value_.__l.__size_ = (std::string::size_type)v8;
          v6 += 48;
        }
        while (v6 != v7);
      }
      v163[23] = 12;
      strcpy(v163, "INSERT INTO ");
      uint64_t v71 = (const std::string::value_type *)a2[1];
      uint64_t v70 = (const std::string::value_type *)(a2 + 1);
      uint64_t v69 = v71;
      int v72 = v70[23];
      if (v72 >= 0) {
        unint64_t v73 = v70;
      }
      else {
        unint64_t v73 = v69;
      }
      if (v72 >= 0) {
        std::string::size_type v74 = *((unsigned __int8 *)v70 + 23);
      }
      else {
        std::string::size_type v74 = *((void *)v70 + 1);
      }
      int64_t v75 = std::string::append((std::string *)v163, v73, v74);
      long long v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
      __dst.__r_.__value_.__r.__words[2] = v75->__r_.__value_.__r.__words[2];
      *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v76;
      v75->__r_.__value_.__l.__size_ = 0;
      v75->__r_.__value_.__r.__words[2] = 0;
      v75->__r_.__value_.__r.__words[0] = 0;
      unint64_t v77 = std::string::append(&__dst, " (TokenID", 9uLL);
      long long v78 = *(_OWORD *)&v77->__r_.__value_.__l.__data_;
      *(void *)&v165[16] = *((void *)&v77->__r_.__value_.__l + 2);
      *(_OWORD *)CFURLRef v165 = v78;
      v77->__r_.__value_.__l.__size_ = 0;
      v77->__r_.__value_.__r.__words[2] = 0;
      v77->__r_.__value_.__r.__words[0] = 0;
      unint64_t v79 = std::string::append((std::string *)v165, ", ", 2uLL);
      long long v80 = *(_OWORD *)&v79->__r_.__value_.__l.__data_;
      v161.__r_.__value_.__r.__words[2] = v79->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v161.__r_.__value_.__l.__data_ = v80;
      v79->__r_.__value_.__l.__size_ = 0;
      v79->__r_.__value_.__r.__words[2] = 0;
      v79->__r_.__value_.__r.__words[0] = 0;
      if ((v165[23] & 0x80000000) != 0)
      {
        operator delete(*(void **)v165);
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_120:
          if ((v163[23] & 0x80000000) == 0) {
            goto LABEL_121;
          }
          goto LABEL_188;
        }
      }
      else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
        goto LABEL_120;
      }
      operator delete(__dst.__r_.__value_.__l.__data_);
      if ((v163[23] & 0x80000000) == 0) {
        goto LABEL_121;
      }
LABEL_188:
      operator delete(*(void **)v163);
LABEL_121:
      long long v81 = *(_OWORD *)&v162.__r_.__value_.__l.__data_;
      if (v162.__r_.__value_.__r.__words[0] != v162.__r_.__value_.__l.__size_)
      {
        int v82 = *(char *)(v162.__r_.__value_.__r.__words[0] + 23);
        long long v83 = v82 >= 0
            ? (const std::string::value_type *)v162.__r_.__value_.__r.__words[0]
            : *(const std::string::value_type **)v162.__r_.__value_.__l.__data_;
        std::string::size_type v84 = v82 >= 0
            ? *(unsigned __int8 *)(v162.__r_.__value_.__r.__words[0] + 23)
            : *(void *)(v162.__r_.__value_.__r.__words[0] + 8);
        std::string::append(&v161, v83, v84);
        for (uint64_t i = v81 + 24; (void)v81 + 24 != *((void *)&v81 + 1); uint64_t i = v81 + 24)
        {
          std::string::append(&v161, ", ", 2uLL);
          int v86 = *(char *)(i + 23);
          if (v86 >= 0) {
            CFTypeRef v87 = (const std::string::value_type *)i;
          }
          else {
            CFTypeRef v87 = *(const std::string::value_type **)i;
          }
          if (v86 >= 0) {
            std::string::size_type v88 = *(unsigned __int8 *)(i + 23);
          }
          else {
            std::string::size_type v88 = *(void *)(i + 8);
          }
          std::string::append(&v161, v87, v88);
        }
      }
      std::string::append(&v161, ") VALUES (?", 0xBuLL);
      if (v162.__r_.__value_.__l.__size_ != v162.__r_.__value_.__r.__words[0])
      {
        unint64_t v89 = 0;
        do
        {
          std::string::append(&v161, ",?", 2uLL);
          ++v89;
        }
        while (0xAAAAAAAAAAAAAAABLL
              * ((uint64_t)(v162.__r_.__value_.__l.__size_ - v162.__r_.__value_.__r.__words[0]) >> 3) > v89);
      }
      std::string::append(&v161, ")", 1uLL);
      std::string::size_type v90 = v162.__r_.__value_.__r.__words[0];
      if (v162.__r_.__value_.__r.__words[0])
      {
        std::string::size_type size = v162.__r_.__value_.__l.__size_;
        long long v92 = (void *)v162.__r_.__value_.__r.__words[0];
        if (v162.__r_.__value_.__l.__size_ != v162.__r_.__value_.__r.__words[0])
        {
          do
          {
            if (*(char *)(size - 1) < 0) {
              operator delete(*(void **)(size - 24));
            }
            size -= 24;
          }
          while (size != v90);
          long long v92 = (void *)v162.__r_.__value_.__r.__words[0];
        }
        v162.__r_.__value_.__l.__size_ = v90;
        operator delete(v92);
      }
      a4.n128_u64[0] = v161.__r_.__value_.__r.__words[0];
      *CFStringRef v5 = v161;
      return a4.n128_f64[0];
    case 4:
      memset(v165, 0, 24);
      uint64_t v43 = **a2;
      uint64_t v44 = (*a2)[1];
      if (v43 != v44)
      {
        int v45 = 0;
        do
        {
          if ((unint64_t)v45 < *(void *)&v165[16])
          {
            if (*(char *)(v43 + 23) < 0)
            {
              sub_19E39369C(v45, *(void **)v43, *(void *)(v43 + 8));
            }
            else
            {
              long long v46 = *(_OWORD *)v43;
              *((void *)v45 + 2) = *(void *)(v43 + 16);
              *(_OWORD *)int v45 = v46;
            }
            v45 += 24;
          }
          else
          {
            int v45 = sub_19E3FC244((char **)v165, v43);
          }
          *(void *)&v165[8] = v45;
          v43 += 48;
        }
        while (v43 != v44);
      }
      sub_19E519F94(&__dst, (uint64_t)a2, (const void ***)v165);
      uint64_t v93 = *(void *)v165;
      if (*(void *)v165)
      {
        uint64_t v94 = *(void *)&v165[8];
        unint64_t v95 = *(void **)v165;
        if (*(void *)&v165[8] != *(void *)v165)
        {
          do
          {
            if (*(char *)(v94 - 1) < 0) {
              operator delete(*(void **)(v94 - 24));
            }
            v94 -= 24;
          }
          while (v94 != v93);
          unint64_t v95 = *(void **)v165;
        }
        *(void *)&v165[8] = v93;
        operator delete(v95);
      }
      a4.n128_u64[0] = __dst.__r_.__value_.__r.__words[0];
      *CFStringRef v5 = __dst;
      return a4.n128_f64[0];
    case 5:
      v165[23] = 7;
      strcpy(v165, "SELECT ");
      uint64_t v16 = **a2;
      uint64_t v17 = (*a2)[1];
      if (v16 != v17)
      {
        int v18 = *(char *)(v16 + 23);
        uint64_t v19 = v18 >= 0 ? (const std::string::value_type *)**a2 : *(const std::string::value_type **)v16;
        std::string::size_type v20 = v18 >= 0 ? *(unsigned __int8 *)(v16 + 23) : *(void *)(v16 + 8);
        std::string::append((std::string *)v165, v19, v20);
        for (uint64_t j = v16 + 48; j != v17; j += 48)
        {
          std::string::append((std::string *)v165, ", ", 2uLL);
          int v22 = *(char *)(j + 23);
          if (v22 >= 0) {
            uint64_t v23 = (const std::string::value_type *)j;
          }
          else {
            uint64_t v23 = *(const std::string::value_type **)j;
          }
          if (v22 >= 0) {
            std::string::size_type v24 = *(unsigned __int8 *)(j + 23);
          }
          else {
            std::string::size_type v24 = *(void *)(j + 8);
          }
          std::string::append((std::string *)v165, v23, v24);
        }
      }
      std::string::append((std::string *)v165, " FROM Words WHERE int TokenID = ?", 0x1DuLL);
      a4.n128_u64[0] = *(void *)v165;
      *(_OWORD *)&v5->__r_.__value_.__l.__data_ = *(_OWORD *)v165;
      v5->__r_.__value_.__r.__words[2] = *(void *)&v165[16];
      return a4.n128_f64[0];
    case 6:
      *((unsigned char *)&v162.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&v162, "SELECT ");
      uint64_t v25 = *a2;
      memset(v165, 0, 24);
      uint64_t v26 = (void **)*v25;
      uint64_t v27 = v25[1];
      if (*v25 != v27)
      {
        while (1)
        {
          if (v26 != (void **)v165 && *((unsigned char *)v26 + 37) != 0)
          {
            char v29 = *((unsigned char *)v26 + 23);
            if ((v165[23] & 0x80000000) != 0)
            {
              if (v29 >= 0) {
                unint64_t v31 = v26;
              }
              else {
                unint64_t v31 = *v26;
              }
              if (v29 >= 0) {
                size_t v32 = *((unsigned __int8 *)v26 + 23);
              }
              else {
                size_t v32 = (size_t)v26[1];
              }
              sub_19E3C6D44((void **)v165, v31, v32);
            }
            else if ((*((unsigned char *)v26 + 23) & 0x80) != 0)
            {
              sub_19E3C6C7C(v165, *v26, (size_t)v26[1]);
            }
            else
            {
              long long v30 = *(_OWORD *)v26;
              *(void *)&v165[16] = v26[2];
              *(_OWORD *)CFURLRef v165 = v30;
            }
          }
          int v33 = *((char *)v26 + 23);
          if (v33 >= 0) {
            size_t v34 = *((unsigned __int8 *)v26 + 23);
          }
          else {
            size_t v34 = (size_t)v26[1];
          }
          unint64_t v35 = v34 + 2;
          if (v34 + 2 > 0x7FFFFFFFFFFFFFF7) {
            sub_19E37C958();
          }
          if (v35 >= 0x17) {
            break;
          }
          memset(&__dst, 0, sizeof(__dst));
          p_dst = &__dst;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v34 + 2;
          if (v34) {
            goto LABEL_64;
          }
LABEL_68:
          strcpy((char *)p_dst + v34, ", ");
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            CFStringRef v40 = &__dst;
          }
          else {
            CFStringRef v40 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v41 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v41 = __dst.__r_.__value_.__l.__size_;
          }
          std::string::append(&v162, (const std::string::value_type *)v40, v41);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          v26 += 6;
          if (v26 == (void **)v27)
          {
            unsigned int v98 = v165[23];
            size_t v99 = *(void *)&v165[8];
            CFStringRef v5 = a1;
            goto LABEL_163;
          }
        }
        uint64_t v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v35 | 7) != 0x17) {
          uint64_t v37 = v35 | 7;
        }
        uint64_t v38 = v37 + 1;
        p_dst = (std::string *)operator new(v37 + 1);
        __dst.__r_.__value_.__l.__size_ = v34 + 2;
        __dst.__r_.__value_.__r.__words[2] = v38 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_64:
        if (v33 >= 0) {
          long long v39 = v26;
        }
        else {
          long long v39 = *v26;
        }
        memmove(p_dst, v39, v34);
        goto LABEL_68;
      }
      size_t v99 = 0;
      unsigned int v98 = 0;
LABEL_163:
      int v102 = (char)v98;
      if ((v98 & 0x80u) == 0) {
        size_t v103 = v98;
      }
      else {
        size_t v103 = v99;
      }
      unint64_t v104 = v103 + 25;
      if (v103 + 25 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v104 > 0x16)
      {
        uint64_t v106 = (v104 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v104 | 7) != 0x17) {
          uint64_t v106 = v104 | 7;
        }
        uint64_t v107 = v106 + 1;
        uint64_t v108 = (char *)operator new(v106 + 1);
        *(void *)&v163[8] = v103 + 25;
        *(void *)&v163[16] = v107 | 0x8000000000000000;
        *(void *)CFIndex v163 = v108;
        qmemcpy(v108, "TokenID FROM Words WHERE ", 25);
        unint64_t v105 = v108 + 25;
        if (!v103)
        {
LABEL_176:
          v105[v103] = 0;
          int64_t v110 = std::string::append((std::string *)v163, " = ?", 4uLL);
          long long v111 = *(_OWORD *)&v110->__r_.__value_.__l.__data_;
          __dst.__r_.__value_.__r.__words[2] = v110->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v111;
          v110->__r_.__value_.__l.__size_ = 0;
          v110->__r_.__value_.__r.__words[2] = 0;
          v110->__r_.__value_.__r.__words[0] = 0;
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v112 = &__dst;
          }
          else {
            uint64_t v112 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          }
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v113 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v113 = __dst.__r_.__value_.__l.__size_;
          }
          std::string::append(&v162, (const std::string::value_type *)v112, v113);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__dst.__r_.__value_.__l.__data_);
            if ((v163[23] & 0x80000000) == 0)
            {
LABEL_184:
              if ((v165[23] & 0x80000000) == 0)
              {
LABEL_185:
                a4.n128_u64[0] = v162.__r_.__value_.__r.__words[0];
                *CFStringRef v5 = v162;
                return a4.n128_f64[0];
              }
LABEL_191:
              operator delete(*(void **)v165);
              goto LABEL_185;
            }
          }
          else if ((v163[23] & 0x80000000) == 0)
          {
            goto LABEL_184;
          }
          operator delete(*(void **)v163);
          if ((v165[23] & 0x80000000) == 0) {
            goto LABEL_185;
          }
          goto LABEL_191;
        }
      }
      else
      {
        qmemcpy(v163, "TokenID FROM Words WHERE ", sizeof(v163));
        unint64_t v105 = v164;
      }
      if (v102 >= 0) {
        uint64_t v109 = v165;
      }
      else {
        uint64_t v109 = *(unsigned char **)v165;
      }
      memmove(v105, v109, v103);
      goto LABEL_176;
    case 7:
      uint64_t v10 = (const void **)(*a2)[8];
      if (!v10) {
        goto LABEL_151;
      }
      int v11 = *((char *)v10 + 23);
      if (v11 >= 0) {
        size_t v12 = *((unsigned __int8 *)v10 + 23);
      }
      else {
        size_t v12 = (size_t)v10[1];
      }
      unint64_t v13 = v12 + 7;
      if (v12 + 7 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v13 >= 0x17)
      {
        uint64_t v114 = (v13 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v13 | 7) != 0x17) {
          uint64_t v114 = v13 | 7;
        }
        uint64_t v115 = v114 + 1;
        float32x4_t v116 = operator new(v114 + 1);
        *(void *)&v165[8] = v12 + 7;
        *(void *)&v165[16] = v115 | 0x8000000000000000;
        *(void *)CFURLRef v165 = v116;
        char v14 = (char *)v116 + 7;
        _DWORD *v116 = 1162626387;
        *(_DWORD *)((char *)v116 + 3) = 542393157;
      }
      else
      {
        *(_OWORD *)&v165[8] = 0uLL;
        v165[23] = v12 + 7;
        char v14 = &v165[7];
        strcpy(v165, "SELECT ");
        if (!v12) {
          goto LABEL_199;
        }
      }
      if (v11 >= 0) {
        uint64_t v117 = v10;
      }
      else {
        uint64_t v117 = *v10;
      }
      memmove(v14, v117, v12);
LABEL_199:
      v14[v12] = 0;
      uint64_t v118 = std::string::append((std::string *)v165, " FROM Words WHERE TokenID = ?", 0x1DuLL);
      goto LABEL_208;
    case 8:
      uint64_t v47 = (const void **)(*a2)[8];
      if (!v47)
      {
LABEL_151:
        char v96 = 0;
        std::string::value_type v97 = 0;
        goto LABEL_210;
      }
      int v48 = *((char *)v47 + 23);
      if (v48 >= 0) {
        size_t v49 = *((unsigned __int8 *)v47 + 23);
      }
      else {
        size_t v49 = (size_t)v47[1];
      }
      unint64_t v50 = v49 + 32;
      if (v49 + 32 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v50 > 0x16)
      {
        uint64_t v119 = (v50 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v50 | 7) != 0x17) {
          uint64_t v119 = v50 | 7;
        }
        *(void *)&v165[8] = v49 + 32;
        *(void *)&v165[16] = (v119 + 1) | 0x8000000000000000;
        *(void *)CFURLRef v165 = operator new(v119 + 1);
        size_t v51 = (uint64_t *)(*(void *)v165 + 32);
        qmemcpy(*(void **)v165, "SELECT TokenID FROM Words WHERE ", 32);
        if (!v49)
        {
LABEL_207:
          *((unsigned char *)v51 + v49) = 0;
          uint64_t v118 = std::string::append((std::string *)v165, " = ? LIMIT 1", 0xCuLL);
LABEL_208:
          std::string::value_type v97 = v118->__r_.__value_.__s.__data_[0];
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)((char *)&v118->__r_.__value_.__l.__data_ + 1);
          *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6) = *(std::string::size_type *)((char *)&v118->__r_.__value_.__r.__words[1] + 7);
          char v96 = HIBYTE(v118->__r_.__value_.__r.__words[2]);
          v118->__r_.__value_.__l.__size_ = 0;
          v118->__r_.__value_.__r.__words[2] = 0;
          v118->__r_.__value_.__r.__words[0] = 0;
          if ((v165[23] & 0x80000000) != 0) {
            operator delete(*(void **)v165);
          }
LABEL_210:
          v5->__r_.__value_.__s.__data_[0] = v97;
          a4.n128_u64[0] = __dst.__r_.__value_.__r.__words[0];
          *(_OWORD *)((char *)&v5->__r_.__value_.__l.__data_ + 1) = *(_OWORD *)&__dst.__r_.__value_.__l.__data_;
          *(std::string::size_type *)((char *)&v5->__r_.__value_.__r.__words[1] + 7) = *(std::string::size_type *)((char *)&__dst.__r_.__value_.__r.__words[1] + 6);
          *((unsigned char *)&v5->__r_.__value_.__s + 23) = v96;
          return a4.n128_f64[0];
        }
      }
      else
      {
        size_t v51 = &v166;
        qmemcpy(v165, "SELECT TokenID FROM Words WHERE ", sizeof(v165));
      }
      if (v48 >= 0) {
        uint64_t v120 = v47;
      }
      else {
        uint64_t v120 = *v47;
      }
      memmove(v51, v120, v49);
      goto LABEL_207;
    case 9:
      sub_19E393108((uint64_t)v165);
      unint64_t v52 = sub_19E37CA70(&v165[16], (uint64_t)"UPDATE ", 7);
      unint64_t v55 = a2[1];
      unint64_t v54 = a2 + 1;
      uint64_t v53 = (uint64_t)v55;
      int v56 = *((char *)v54 + 23);
      if (v56 >= 0) {
        uint64_t v57 = (uint64_t)v54;
      }
      else {
        uint64_t v57 = v53;
      }
      if (v56 >= 0) {
        uint64_t v58 = *((unsigned __int8 *)v54 + 23);
      }
      else {
        uint64_t v58 = (uint64_t)v54[1];
      }
      int64_t v59 = sub_19E37CA70(v52, v57, v58);
      sub_19E37CA70(v59, (uint64_t)"SET int TokenID = ? WHERE int TokenID = ?", 33);
      if ((v173 & 0x10) != 0)
      {
        unint64_t v100 = v172;
        if (v172 < v169)
        {
          unint64_t v172 = v169;
          unint64_t v100 = v169;
        }
        uint64_t v101 = (const void **)&v168;
      }
      else
      {
        if ((v173 & 8) == 0)
        {
          std::string::size_type v60 = 0;
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
          long long v61 = &__dst;
          goto LABEL_238;
        }
        uint64_t v101 = (const void **)v167;
        unint64_t v100 = v167[2];
      }
      uint64_t v129 = *v101;
      std::string::size_type v60 = v100 - (void)*v101;
      if (v60 > 0x7FFFFFFFFFFFFFF7) {
        sub_19E37C958();
      }
      if (v60 >= 0x17)
      {
        uint64_t v130 = (v60 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v60 | 7) != 0x17) {
          uint64_t v130 = v60 | 7;
        }
        uint64_t v131 = v130 + 1;
        long long v61 = (std::string *)operator new(v130 + 1);
        __dst.__r_.__value_.__l.__size_ = v60;
        __dst.__r_.__value_.__r.__words[2] = v131 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v100 - *(unsigned char *)v101;
        long long v61 = &__dst;
        if (!v60) {
          goto LABEL_238;
        }
      }
      memmove(v61, v129, v60);
LABEL_238:
      v61->__r_.__value_.__s.__data_[v60] = 0;
      *(void *)CFURLRef v165 = *MEMORY[0x1E4FBA408];
      uint64_t v132 = *(void *)(MEMORY[0x1E4FBA408] + 72);
      *(void *)&v165[*(void *)(*(void *)v165 - 24)] = *(void *)(MEMORY[0x1E4FBA408] + 64);
      *(void *)&v165[16] = v132;
      *(void *)&v165[24] = MEMORY[0x1E4FBA470] + 16;
      if (v171 < 0) {
        operator delete(__p);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x19F3BDC30](&v174);
      if (&__dst != v5)
      {
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          sub_19E3C6C7C(v5, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
        }
        else
        {
          a4.n128_u64[0] = __dst.__r_.__value_.__r.__words[0];
          *CFStringRef v5 = __dst;
        }
      }
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      return a4.n128_f64[0];
    case 10:
      uint64_t v42 = (char *)operator new(0x20uLL);
      strcpy(v42, "SELECT MAX(TokenID) from Words");
      v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v42;
      a4 = (__n128)xmmword_19E573050;
      goto LABEL_103;
    case 11:
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 7;
      strcpy((char *)&__dst, "SELECT ");
      long long v63 = (const void **)**a2;
      long long v64 = (const void **)(*a2)[1];
      if (v63 == v64) {
        goto LABEL_278;
      }
      int v65 = *((char *)v63 + 23);
      if (v65 >= 0) {
        size_t v66 = *((unsigned __int8 *)v63 + 23);
      }
      else {
        size_t v66 = (size_t)v63[1];
      }
      unint64_t v67 = v66 + 1;
      if (v66 + 1 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_303;
      }
      if (v67 >= 0x17)
      {
        uint64_t v121 = (v67 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v67 | 7) != 0x17) {
          uint64_t v121 = v67 | 7;
        }
        uint64_t v122 = v121 + 1;
        uint64_t v68 = operator new(v121 + 1);
        *(void *)&v165[8] = v66 + 1;
        *(void *)&v165[16] = v122 | 0x8000000000000000;
        *(void *)CFURLRef v165 = v68;
      }
      else
      {
        memset(v165, 0, 24);
        uint64_t v68 = v165;
        v165[23] = v66 + 1;
        if (!v66) {
          goto LABEL_218;
        }
      }
      if (v65 >= 0) {
        unint64_t v123 = v63;
      }
      else {
        unint64_t v123 = *v63;
      }
      memmove(v68, v123, v66);
LABEL_218:
      *(_WORD *)&v68[v66] = 32;
      if (v165[23] >= 0) {
        unint64_t v124 = v165;
      }
      else {
        unint64_t v124 = *(const std::string::value_type **)v165;
      }
      if (v165[23] >= 0) {
        std::string::size_type v125 = v165[23];
      }
      else {
        std::string::size_type v125 = *(void *)&v165[8];
      }
      std::string::append(&__dst, v124, v125);
      if ((v165[23] & 0x80000000) != 0) {
        operator delete(*(void **)v165);
      }
      int v126 = *((_DWORD *)v63 + 8);
      if (v126)
      {
        if (v126 != 1) {
          goto LABEL_248;
        }
        BOOL v127 = "INTEGER";
        std::string::size_type v128 = 7;
      }
      else
      {
        BOOL v127 = "BLOB";
        std::string::size_type v128 = 4;
      }
      std::string::append(&__dst, v127, v128);
LABEL_248:
      long long v133 = v63 + 6;
      if (v63 + 6 == v64) {
        goto LABEL_278;
      }
      uint64_t v134 = ", ";
      break;
    case 12:
      double v15 = (char *)operator new(0x20uLL);
      strcpy(v15, "SELECT TokenID from Words");
      v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v15;
      a4 = (__n128)xmmword_19E573060;
      goto LABEL_103;
    case 13:
      uint64_t v62 = (char *)operator new(0x28uLL);
      strcpy(v62, "SELECT COUNT(TokenID) from Words");
      v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v62;
      a4 = (__n128)xmmword_19E5731E0;
LABEL_103:
      *(__n128 *)&v5->__r_.__value_.__r.__words[1] = a4;
      return a4.n128_f64[0];
    default:
      return a4.n128_f64[0];
  }
  do
  {
    std::string::append(&__dst, v134, 2uLL);
    int v137 = *((char *)v133 + 23);
    if (v137 >= 0) {
      size_t v138 = *((unsigned __int8 *)v133 + 23);
    }
    else {
      size_t v138 = (size_t)v133[1];
    }
    unint64_t v139 = v138 + 1;
    if (v138 + 1 > 0x7FFFFFFFFFFFFFF7) {
LABEL_303:
    }
      sub_19E37C958();
    if (v139 >= 0x17)
    {
      CFTypeRef v141 = v134;
      uint64_t v142 = (v139 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v139 | 7) != 0x17) {
        uint64_t v142 = v139 | 7;
      }
      uint64_t v143 = v142 + 1;
      unint64_t v140 = operator new(v142 + 1);
      *(void *)&v165[8] = v138 + 1;
      *(void *)&v165[16] = v143 | 0x8000000000000000;
      *(void *)CFURLRef v165 = v140;
      uint64_t v134 = v141;
    }
    else
    {
      memset(v165, 0, 24);
      unint64_t v140 = v165;
      v165[23] = v138 + 1;
      if (!v138) {
        goto LABEL_267;
      }
    }
    if (v137 >= 0) {
      uint64_t v144 = v133;
    }
    else {
      uint64_t v144 = *v133;
    }
    memmove(v140, v144, v138);
LABEL_267:
    *(_WORD *)&v140[v138] = 32;
    if (v165[23] >= 0) {
      CFTypeID v145 = v165;
    }
    else {
      CFTypeID v145 = *(const std::string::value_type **)v165;
    }
    if (v165[23] >= 0) {
      std::string::size_type v146 = v165[23];
    }
    else {
      std::string::size_type v146 = *(void *)&v165[8];
    }
    std::string::append(&__dst, v145, v146);
    if ((v165[23] & 0x80000000) != 0) {
      operator delete(*(void **)v165);
    }
    int v147 = *((_DWORD *)v133 + 8);
    if (v147 == 1)
    {
      v135 = "INTEGER";
      std::string::size_type v136 = 7;
LABEL_251:
      std::string::append(&__dst, v135, v136);
      goto LABEL_252;
    }
    if (!v147)
    {
      v135 = "BLOB";
      std::string::size_type v136 = 4;
      goto LABEL_251;
    }
LABEL_252:
    v133 += 6;
  }
  while (v133 != v64);
LABEL_278:
  int v148 = *((char *)a2 + 31);
  if (v148 >= 0) {
    size_t v149 = *((unsigned __int8 *)a2 + 31);
  }
  else {
    size_t v149 = (size_t)a2[2];
  }
  unint64_t v150 = v149 + 6;
  if (v149 + 6 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  if (v150 >= 0x17)
  {
    uint64_t v152 = (v150 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v150 | 7) != 0x17) {
      uint64_t v152 = v150 | 7;
    }
    uint64_t v153 = v152 + 1;
    CFLocaleRef v154 = (char *)operator new(v152 + 1);
    *(void *)&v165[8] = v149 + 6;
    *(void *)&v165[16] = v153 | 0x8000000000000000;
    *(void *)CFURLRef v165 = v154;
    *(_DWORD *)CFLocaleRef v154 = 1330791968;
    CFArrayRef v151 = v154 + 6;
    *((_WORD *)v154 + 2) = 8269;
  }
  else
  {
    *(_OWORD *)&v165[8] = 0uLL;
    v165[23] = v149 + 6;
    CFArrayRef v151 = &v165[6];
    *(void *)CFURLRef v165 = 0x204D4F524620;
    if (!v149) {
      goto LABEL_292;
    }
  }
  if (v148 >= 0) {
    CFStringRef v155 = (uint64_t *)(a2 + 1);
  }
  else {
    CFStringRef v155 = a2[1];
  }
  memmove(v151, v155, v149);
LABEL_292:
  v151[v149] = 0;
  if (v165[23] >= 0) {
    uint64_t v156 = v165;
  }
  else {
    uint64_t v156 = *(const std::string::value_type **)v165;
  }
  if (v165[23] >= 0) {
    std::string::size_type v157 = v165[23];
  }
  else {
    std::string::size_type v157 = *(void *)&v165[8];
  }
  std::string::append(&__dst, v156, v157);
  if ((v165[23] & 0x80000000) != 0) {
    operator delete(*(void **)v165);
  }
  a4.n128_u64[0] = __dst.__r_.__value_.__r.__words[0];
  *a1 = __dst;
  return a4.n128_f64[0];
}

void sub_19E519D70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (*(char *)(v36 - 105) < 0) {
    operator delete(*(void **)(v36 - 128));
  }
  if (*(char *)(v35 + 23) < 0) {
    operator delete(*(void **)v35);
  }
  _Unwind_Resume(exception_object);
}

std::string *sub_19E519F94(std::string *a1, uint64_t a2, const void ***a3)
{
  *((unsigned char *)&v38.__r_.__value_.__s + 23) = 7;
  strcpy((char *)&v38, "UPDATE ");
  uint64_t v7 = *(void *)(a2 + 8);
  uint64_t v5 = a2 + 8;
  uint64_t v6 = v7;
  std::string::size_type v8 = *(void *)(v5 + 8);
  if (*(char *)(v5 + 23) >= 0)
  {
    std::string::size_type v9 = *(unsigned __int8 *)(v5 + 23);
  }
  else
  {
    uint64_t v5 = v6;
    std::string::size_type v9 = v8;
  }
  uint64_t v10 = std::string::append(&v38, (const std::string::value_type *)v5, v9);
  long long v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  __dst.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  size_t v12 = std::string::append(&__dst, " SET ", 5uLL);
  long long v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  a1->__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_6;
    }
  }
  else if ((SHIBYTE(v38.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_6;
  }
  operator delete(v38.__r_.__value_.__l.__data_);
LABEL_6:
  char v14 = *a3;
  double v15 = a3[1];
  if (*a3 == v15) {
    return std::string::append(a1, " WHERE TokenID=?", 0x10uLL);
  }
  int v16 = *((char *)v14 + 23);
  if (v16 >= 0) {
    size_t v17 = *((unsigned __int8 *)v14 + 23);
  }
  else {
    size_t v17 = (size_t)v14[1];
  }
  unint64_t v18 = v17 + 2;
  if (v17 + 2 > 0x7FFFFFFFFFFFFFF7) {
LABEL_57:
  }
    sub_19E37C958();
  if (v18 >= 0x17)
  {
    uint64_t v20 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v20 = v18 | 7;
    }
    uint64_t v21 = v20 + 1;
    p_dst = operator new(v20 + 1);
    __dst.__r_.__value_.__l.__size_ = v17 + 2;
    __dst.__r_.__value_.__r.__words[2] = v21 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v17 + 2;
    if (!v17) {
      goto LABEL_23;
    }
  }
  if (v16 >= 0) {
    int v22 = v14;
  }
  else {
    int v22 = *v14;
  }
  memmove(p_dst, v22, v17);
LABEL_23:
  strcpy((char *)p_dst + v17, "=?");
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v23 = &__dst;
  }
  else {
    uint64_t v23 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  std::string::append(a1, (const std::string::value_type *)v23, size);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v25 = v14 + 3;
  if (v14 + 3 != v15)
  {
    uint64_t v26 = ", ";
    while (1)
    {
      std::string::append(a1, v26, 2uLL);
      int v27 = *((char *)v25 + 23);
      if (v27 >= 0) {
        size_t v28 = *((unsigned __int8 *)v25 + 23);
      }
      else {
        size_t v28 = (size_t)v25[1];
      }
      unint64_t v29 = v28 + 2;
      if (v28 + 2 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_57;
      }
      if (v29 >= 0x17) {
        break;
      }
      memset(&__dst, 0, sizeof(__dst));
      long long v30 = (char *)&__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v28 + 2;
      if (v28) {
        goto LABEL_44;
      }
LABEL_48:
      strcpy(&v30[v28], "=?");
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v35 = &__dst;
      }
      else {
        uint64_t v35 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v36 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v36 = __dst.__r_.__value_.__l.__size_;
      }
      std::string::append(a1, (const std::string::value_type *)v35, v36);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      v25 += 3;
      if (v25 == v15) {
        return std::string::append(a1, " WHERE TokenID=?", 0x10uLL);
      }
    }
    unint64_t v31 = v26;
    uint64_t v32 = (v29 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v29 | 7) != 0x17) {
      uint64_t v32 = v29 | 7;
    }
    uint64_t v33 = v32 + 1;
    long long v30 = (char *)operator new(v32 + 1);
    __dst.__r_.__value_.__l.__size_ = v28 + 2;
    __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v30;
    uint64_t v26 = v31;
LABEL_44:
    if (v27 >= 0) {
      size_t v34 = v25;
    }
    else {
      size_t v34 = *v25;
    }
    memmove(v30, v34, v28);
    goto LABEL_48;
  }
  return std::string::append(a1, " WHERE TokenID=?", 0x10uLL);
}

void sub_19E51A2B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (*(char *)(v21 + 23) < 0) {
    operator delete(*(void **)v21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E51A324(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  *a2 = 0;
  uint64_t v3 = *(uint64_t **)(result + 8);
  *(void *)(result + 8) = v2;
  if (v3)
  {
    if (*v3)
    {
      sub_19E374B30(v3);
      if (*v3) {
        MEMORY[0x19F3BDCF0](*v3, 0x1010C4006136809);
      }
    }
    JUMPOUT(0x19F3BDCF0);
  }
  return result;
}

void sub_19E51A3B0(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v1;
  size_t v3 = *(unsigned int *)(*v1 + 12);
  if (v3)
  {
    unint64_t v4 = (char *)operator new(*(unsigned int *)(*v1 + 12));
    uint64_t v5 = &v4[v3];
    bzero(v4, v3);
  }
  else
  {
    uint64_t v5 = 0;
    unint64_t v4 = 0;
  }
  size_t v45 = v5 - v4;
  long long v46 = v4;
  if ((unint64_t)(v5 - v4) < 0x18) {
    goto LABEL_31;
  }
  int v6 = *(_DWORD *)(v2 + 16);
  unsigned int v7 = *(_DWORD *)(v2 + 20);
  uint64_t v8 = *(unsigned __int8 *)(v2 + 7);
  int v9 = *(unsigned __int8 *)(v2 + 6);
  uint64_t v10 = *(unsigned __int8 *)(v2 + 5);
  uint64_t v11 = *(void *)(v2 + 24);
  *(_DWORD *)long long v46 = -1381269244;
  v46[4] = 0;
  v46[5] = v10;
  v46[7] = 64;
  v46[6] = v9;
  *((void *)v46 + 2) = 0;
  if (v6) {
    BOOL v12 = v11 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  *((void *)v46 + 1) = *(void *)(v2 + 8);
  if (v12)
  {
    uint64_t v13 = 24;
  }
  else
  {
    *((_DWORD *)v46 + 4) = v6;
    *((_DWORD *)v46 + 5) = v6;
    unint64_t v14 = ((3 * v6) & 0x1FFFFFFFu) + 24;
    if (v45 < v14) {
      goto LABEL_31;
    }
    if (v7) {
      BOOL v15 = v8 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15)
    {
      unsigned int v16 = 0;
      int v17 = 0;
      int v18 = v8 + 24;
      unint64_t v19 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v8;
      unint64_t v20 = ((6 * (unint64_t)v10 + 4) >> 3) + 3;
      while (1)
      {
        unsigned int v21 = v18 * v16;
        while (1)
        {
          uint64_t v22 = ((v21 + 24) >> 3) + v11;
          unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v24 = v21 & 7 | (8 * (v22 & 7));
          uint64_t v25 = *(void *)(v22 & 0xFFFFFFFFFFFFFFF8) >> v24;
          if ((unint64_t)(v24 + v8) >= 0x41) {
            v25 |= *(void *)(v23 + 8) << -(char)v24;
          }
          uint64_t v26 = (const void *)(v25 & v19);
          if ((v25 & v19) != 0) {
            break;
          }
          ++v16;
          v21 += v18;
          if (v16 >= v7)
          {
            uint64_t v13 = v14;
            goto LABEL_28;
          }
        }
        unint64_t v44 = v14;
        int v47 = v17;
        unint64_t v41 = v20;
        uint64_t v42 = v10;
        int v43 = v9;
        int v27 = sub_19E527EE4(v25 & v19, v10, v9, 0, (uint64_t)v26 + v20, 1u);
        uint64_t v28 = (v21 >> 3) + v11;
        unint64_t v29 = v28 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v30 = v21 & 7 | (8 * (v28 & 3));
        int v31 = *(_DWORD *)(v28 & 0xFFFFFFFFFFFFFFFCLL) >> v30;
        if (v30 >= 9) {
          v31 |= *(_DWORD *)(v29 + 4) << -(char)v30;
        }
        unint64_t v32 = (unint64_t)&v46[((unint64_t)(24 * v47) >> 3) + 24];
        *(_WORD *)unint64_t v32 = v31;
        *(unsigned char *)(v32 + 2) = BYTE2(v31);
        size_t v33 = (v27 - v26 + 3) & 0xFFFFFFFC;
        uint64_t v13 = v44 + v33;
        if (v44 + v33 > v45) {
          break;
        }
        size_t v34 = &v46[v44];
        uint64_t v35 = v26;
        unsigned int v36 = v27 - v26 + 3;
        memcpy(&v46[v44], v35, v33);
        uint64_t v10 = v42;
        int v9 = v43;
        *size_t v34 = v36 >> 2;
        v34[1] = v36 >> 10;
        v34[2] = v36 >> 18;
        int v17 = v47 + 1;
        ++v16;
        unint64_t v14 = v13;
        unint64_t v20 = v41;
        if (v16 >= v7) {
          goto LABEL_28;
        }
      }
LABEL_31:
      operator new();
    }
    uint64_t v13 = ((3 * v6) & 0x1FFFFFFFu) + 24;
  }
LABEL_28:
  uint64_t v37 = *(const void **)(v2 + 32);
  if (v37)
  {
    unsigned int v38 = sub_19E527EE4(*(void *)(v2 + 32), 1u, v9, 0, (uint64_t)v37 + 4, 1u) - v37 + 3;
    size_t v39 = v38 & 0xFFFFFFFC;
    if (v13 + v39 <= v45)
    {
      CFStringRef v40 = &v46[v13];
      memcpy(&v46[v13], v37, v39);
      char *v40 = v38 >> 2;
      v40[1] = v38 >> 10;
      v40[2] = v38 >> 18;
    }
  }
  goto LABEL_31;
}

void sub_19E51AED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E51AF38(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v2 = *(CFURLRef **)(a1 + 16);
  if (!v2) {
    return 1;
  }
  unint64_t v4 = sub_19E4C72F0(*(void *)(a1 + 16));
  BOOL v5 = sub_19E3C2D94(v4, *v2, kCFPropertyListBinaryFormat_v1_0, 1, a2);
  CFRelease(v4);
  return v5;
}

void sub_19E51AFA0(uint64_t a1, const __CFURL *a2)
{
  CFURLRef v3 = CFURLCreateCopyAppendingPathComponent(0, a2, @"tags.plist", 0);
  unint64_t v4 = sub_19E4C72F0(*(void *)(a1 + 16));
  sub_19E3C2D94(v4, v3, kCFPropertyListXMLFormat_v1_0, 1, 0);
  if (v4) {
    CFRelease(v4);
  }
  if (v3) {
    CFRelease(v3);
  }
}

void sub_19E51B028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
}

uint64_t sub_19E51B04C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1)
  {
    uint64_t v2 = *(uint64_t **)(a1 + 8);
    uint64_t v3 = *(void *)(v1 + 8);
    if (v3)
    {
      BOOL v4 = sub_19E4C69D4(v3, v2);
      uint64_t v5 = *(void *)(v1 + 16);
      if (!v5) {
        return v4 | v5;
      }
    }
    else
    {
      BOOL v4 = 0;
      uint64_t v5 = *(void *)(v1 + 16);
      if (!v5) {
        return v4 | v5;
      }
    }
    LODWORD(v5) = sub_19E4C69D4(v5, v2);
    return v4 | v5;
  }
  return 0;
}

void sub_19E51B0BC(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 0x40000000;
  v2[2] = sub_19E51B134;
  v2[3] = &unk_1E59A1DF8;
  v2[4] = a1;
  sub_19E52DAF0(*v1, 0, (uint64_t)v2);
}

BOOL sub_19E51B134(uint64_t a1, unsigned int a2)
{
  return a2 >> (*(_DWORD *)(*(void *)(a1 + 32) + 372) - 2) != 1;
}

uint64_t sub_19E51B150(uint64_t a1, int __fd)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *v2;
  if (!*v2) {
    return 1;
  }
  int v5 = *(_DWORD *)(v3 + 16);
  uint64_t v6 = *(unsigned int *)(v3 + 20);
  uint64_t v7 = *(unsigned __int8 *)(v3 + 7);
  int v8 = *(unsigned __int8 *)(v3 + 6);
  unsigned int v9 = *(unsigned __int8 *)(v3 + 5);
  uint64_t v10 = *(void *)(v3 + 24);
  int __buf = -1381269244;
  char v66 = 0;
  unsigned int v60 = v9;
  char v67 = v9;
  char v69 = 64;
  int v61 = v8;
  char v68 = v8;
  uint64_t v71 = 0;
  uint64_t v70 = *(void *)(v3 + 8);
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  if (v10) {
    BOOL v11 = v5 == 0;
  }
  else {
    BOOL v11 = 1;
  }
  uint64_t v72 = 0;
  if (!v11)
  {
    LODWORD(v71) = v5;
    HIDWORD(v71) = v5;
  }
  ssize_t v12 = write(__fd, &__buf, 0x18uLL);
  BOOL v13 = v12 == 24;
  if (v12 == 24) {
    uint64_t v14 = 24;
  }
  else {
    uint64_t v14 = 0;
  }
  if (v10) {
    BOOL v15 = v12 == 24;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15 || v5 == 0)
  {
    uint64_t v59 = v14;
    uint64_t v58 = v2;
    goto LABEL_19;
  }
  size_t v22 = (3 * v5) & 0x1FFFFFFF;
  uint64_t result = (uint64_t)malloc_type_calloc(v22, 1uLL, 0xD214B0D8uLL);
  if (result)
  {
    uint64_t v24 = (void *)result;
    uint64_t v25 = v14;
    uint64_t v58 = v2;
    int v26 = v7 + 24;
    if (v6) {
      BOOL v27 = v7 == 0;
    }
    else {
      BOOL v27 = 1;
    }
    if (!v27)
    {
      unsigned int v46 = 0;
      int v47 = 0;
      int v48 = v6;
      do
      {
        uint64_t v50 = ((v46 + 24) >> 3) + v10;
        unint64_t v51 = v50 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v52 = v46 & 7 | (8 * (v50 & 7));
        uint64_t v53 = *(void *)(v50 & 0xFFFFFFFFFFFFFFF8) >> v52;
        if ((unint64_t)(v52 + v7) >= 0x41) {
          v53 |= *(void *)(v51 + 8) << -(char)v52;
        }
        if ((v53 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v7)) != 0)
        {
          uint64_t v54 = (v46 >> 3) + v10;
          unint64_t v55 = v54 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v56 = v46 & 7 | (8 * (v54 & 3));
          int v57 = *(_DWORD *)(v54 & 0xFFFFFFFFFFFFFFFCLL) >> v56;
          if (v56 >= 9) {
            v57 |= *(_DWORD *)(v55 + 4) << -(char)v56;
          }
          uint64_t v49 = result + ((unint64_t)(24 * v47) >> 3);
          *(_WORD *)uint64_t v49 = v57;
          *(unsigned char *)(v49 + 2) = BYTE2(v57);
          ++v47;
        }
        v46 += v26;
        --v48;
      }
      while (v48);
    }
    ssize_t v28 = write(__fd, (const void *)result, v22);
    free(v24);
    BOOL v13 = v28 == v22;
    if (v28 == v22) {
      size_t v29 = v22;
    }
    else {
      size_t v29 = 0;
    }
    uint64_t v59 = v29 + v25;
    if (v28 == v22 && v6)
    {
      if (!v7)
      {
LABEL_20:
        uint64_t v17 = *v58;
        uint64_t v18 = *(void *)(*v58 + 32);
        if (!v18)
        {
          uint64_t v21 = v59;
          return v21 == *(unsigned int *)(v17 + 12);
        }
        unsigned int v19 = sub_19E527EE4(*(void *)(*v58 + 32), 1u, v61, 0, v18 + 4, 1u) - v18 + 3;
        char v62 = v19 >> 2;
        char v63 = v19 >> 10;
        char v64 = v19 >> 18;
        if (write(__fd, &v62, 3uLL) == 3)
        {
          unsigned int v20 = v19 & 0xFFFFFFFC;
          if (write(__fd, (const void *)(v18 + 3), v20 - 3) == v20 - 3)
          {
            uint64_t v21 = v59 + v20;
            uint64_t v17 = *v58;
            return v21 == *(unsigned int *)(v17 + 12);
          }
        }
        return 0;
      }
      int v30 = 0;
      unint64_t v31 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      unsigned int v32 = 1;
      do
      {
        uint64_t v33 = ((v30 + 24) >> 3) + v10;
        unint64_t v34 = v33 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v35 = v30 & 7 | (8 * (v33 & 7));
        uint64_t v36 = *(void *)(v33 & 0xFFFFFFFFFFFFFFF8) >> v35;
        if ((unint64_t)(v35 + v7) >= 0x41) {
          v36 |= *(void *)(v34 + 8) << -(char)v35;
        }
        unint64_t v37 = v36 & v31;
        if ((v36 & v31) != 0)
        {
          uint64_t v38 = v6;
          unsigned int v39 = sub_19E527EE4(v36 & v31, v60, v61, 0, v37 + ((6 * (unint64_t)v60 + 4) >> 3) + 3, 1u) - v37 + 3;
          char v62 = v39 >> 2;
          char v63 = v39 >> 10;
          char v64 = v39 >> 18;
          if (write(__fd, &v62, 3uLL) == 3)
          {
            uint64_t v40 = v39 & 0xFFFFFFFC;
            unint64_t v41 = (const void *)(v37 + 3);
            size_t v42 = (v40 - 3);
            ssize_t v43 = write(__fd, v41, v42);
            BOOL v13 = v43 == v42;
            if (v43 == v42) {
              uint64_t v44 = v40;
            }
            else {
              uint64_t v44 = 0;
            }
            v59 += v44;
          }
          else
          {
            BOOL v13 = 0;
          }
          uint64_t v6 = v38;
        }
        else
        {
          BOOL v13 = 1;
        }
        if (!v13) {
          break;
        }
        v30 += v26;
      }
      while (v32++ < v6);
    }
LABEL_19:
    if (!v13) {
      return 0;
    }
    goto LABEL_20;
  }
  return result;
}

void sub_19E51B560(uint64_t a1, void *a2)
{
  if (*a2 != a2[1])
  {
    uint64_t v2 = *(uint64_t **)(a1 + 8);
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 0x40000000;
    v3[2] = sub_19E51B5E4;
    v3[3] = &unk_1E59A1DD8;
    v3[4] = a2;
    sub_19E52DAF0(*v2, (uint64_t)v3, 0);
  }
}

BOOL sub_19E51B5E4(uint64_t a1, __int32 a2)
{
  uint64_t v3 = *(__int32 ***)(a1 + 32);
  BOOL v4 = v3[1];
  int v5 = wmemchr(*v3, a2, v4 - *v3);
  if (v5) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = v4;
  }
  return v6 == *(__int32 **)(*(void *)(a1 + 32) + 8);
}

uint64_t sub_19E51B630(uint64_t a1, unint64_t a2)
{
  char v96 = *(uint64_t **)(a1 + 8);
  uint64_t v2 = *v96;
  if (*v96)
  {
    unint64_t v3 = *(unsigned int *)(v2 + 12);
    if (v3 > a2)
    {
      if (*(_DWORD *)(v2 + 16))
      {
        unsigned int v4 = 0;
        float v5 = (float)a2 * 0.95;
        unsigned int v93 = a2;
        while (1)
        {
          unsigned int v95 = v3;
          unsigned int v94 = v4;
          uint64_t v6 = malloc_type_calloc(0x2710uLL, 4uLL, 0x100004052888210uLL);
          uint64_t v7 = *(void *)(v2 + 24);
          BOOL v8 = !v7 || *(_DWORD *)(v2 + 16) == 0;
          int v103 = *(_DWORD *)(v2 + 20);
          if (!v8 && *(_DWORD *)(v2 + 20) != 0)
          {
            uint64_t v101 = *(unsigned __int8 *)(v2 + 7);
            if (*(unsigned char *)(v2 + 7)) {
              break;
            }
          }
LABEL_64:
          int32x4_t v70 = 0uLL;
          uint64_t v71 = -40000;
          int32x4_t v72 = 0uLL;
          do
          {
            int32x4_t v70 = vaddq_s32(*(int32x4_t *)((char *)v6 + v71 + 40000), v70);
            int32x4_t v72 = vaddq_s32(*(int32x4_t *)((char *)v6 + v71 + 40016), v72);
            v71 += 32;
          }
          while (v71);
          unsigned int v73 = 0;
          unsigned int v74 = vaddvq_s32(vaddq_s32(v72, v70));
          unsigned int v75 = v74 - (float)((float)(v5 * (float)v74) / (float)v95);
          while (1)
          {
            v73 += v6[v71];
            if (v73 >= v75) {
              break;
            }
            if (++v71 == 10000)
            {
              float v76 = 1000.0;
              goto LABEL_71;
            }
          }
          float v76 = (float)((float)v71 * 0.1) + 0.05;
LABEL_71:
          free(v6);
          uint64_t v77 = *v96;
          unsigned int v99 = *(unsigned __int8 *)(*v96 + 5);
          uint64_t v104 = *(unsigned __int8 *)(*v96 + 7);
          unsigned int v78 = *(unsigned __int8 *)(*v96 + 6);
          int v79 = *(_DWORD *)(*v96 + 16);
          int v80 = *(_DWORD *)(*v96 + 20);
          uint64_t v102 = *(void *)(*v96 + 24);
          long long v81 = *(_OWORD **)(*v96 + 40);
          if (v81)
          {
            *(void *)&long long v82 = -1;
            *((void *)&v82 + 1) = -1;
            v81[1] = v82;
            v81[2] = v82;
            _OWORD *v81 = v82;
          }
          if (v102) {
            BOOL v83 = v79 == 0;
          }
          else {
            BOOL v83 = 1;
          }
          if (!v83 && v80 != 0 && v104 != 0)
          {
            unint64_t v87 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v104;
            unsigned int v88 = 24;
            do
            {
              uint64_t v89 = (v88 >> 3) + v102;
              unint64_t v90 = v89 & 0xFFFFFFFFFFFFFFF8;
              uint64_t v91 = ((_BYTE)v88 - 24) & 7 | (8 * (v89 & 7));
              uint64_t v92 = *(void *)(v89 & 0xFFFFFFFFFFFFFFF8) >> v91;
              if ((unint64_t)(v91 + v104) >= 0x41) {
                v92 |= *(void *)(v90 + 8) << -(char)v91;
              }
              if ((v92 & v87) != 0)
              {
                v105[0] = MEMORY[0x1E4F143A8];
                v105[1] = 0x40000000;
                v105[2] = sub_19E52E630;
                v105[3] = &unk_1E59A1ED8;
                v105[4] = v77;
                unsigned int v106 = v78;
                sub_19E52E698(v92 & v87, v99, v78, 0, (v92 & v87) + ((6 * (unint64_t)v99 + 4) >> 3) + 3, 1, 0, 1u, v76, (uint64_t)v105);
              }
              v88 += v104 + 24;
              --v80;
            }
            while (v80);
          }
          sub_19E52CFE4(v77, 0, 0, *(unsigned char *)(v77 + 6));
          uint64_t v2 = *v96;
          LODWORD(v3) = *(_DWORD *)(*v96 + 12);
          if (v3 <= v93) {
            return 1;
          }
          uint64_t result = 1;
          if (*(_DWORD *)(v2 + 16))
          {
            unsigned int v4 = v94 + 1;
            if (v94 <= 1) {
              continue;
            }
          }
          return result;
        }
        int v10 = 0;
        unsigned int v11 = *(unsigned __int8 *)(v2 + 5);
        int v12 = *(unsigned __int8 *)(v2 + 6);
        int v100 = v101 + 24;
        unint64_t v98 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v101;
        unint64_t v97 = ((6 * (unint64_t)*(unsigned __int8 *)(v2 + 5) + 4) >> 3) + 3;
        int v13 = ((_WORD)v12 + 31) & 0x1F8;
        while (1)
        {
          uint64_t v14 = ((v10 * v100 + 24) >> 3) + v7;
          uint64_t v15 = (v10 * v100) & 7 | (8 * (v14 & 7));
          uint64_t v16 = *(void *)(v14 & 0xFFFFFFFFFFFFFFF8) >> v15;
          if ((unint64_t)(v15 + v101) >= 0x41) {
            v16 |= *(void *)((v14 & 0xFFFFFFFFFFFFFFF8) + 8) << -(char)v15;
          }
          unint64_t v17 = v16 & v98;
          if ((v16 & v98) != 0) {
            break;
          }
LABEL_14:
          if (++v10 == v103) {
            goto LABEL_64;
          }
        }
        unsigned int v18 = 0;
        unint64_t v19 = v17 + v97;
        unint64_t v20 = v17 + 3;
        int v21 = 1;
        while (1)
        {
          if (v18) {
            int v22 = 24;
          }
          else {
            int v22 = 0;
          }
          int v23 = 6 * v18;
          unint64_t v24 = (((3 * v18) >> 2) & 0x1FFFFFFF) + v20;
          int v25 = *(_DWORD *)(v24 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * v18++) & 6 | (8 * (v24 & 3)));
          if (v18 >= v11)
          {
            unsigned int v31 = 0;
          }
          else
          {
            char v26 = v23 + 3;
            unint64_t v27 = ((v23 + 3) >> 3) + v20;
            unint64_t v28 = v27 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v29 = v26 & 7 | (8 * (v27 & 3));
            int v30 = *(_DWORD *)(v27 & 0xFFFFFFFFFFFFFFFCLL) >> v29;
            if (v29 >= 0x1E) {
              v30 |= *(_DWORD *)(v28 + 4) << -(char)v29;
            }
            unsigned int v31 = 4 * (v30 & 7);
          }
          char v32 = 4 * v25;
          uint64_t v33 = v32 & 0x1C;
          int v34 = ((v32 & 0x1C) + (_BYTE)v22 + (_BYTE)v31 + 7) & 0xF8;
          int v35 = v34 * (v21 - 1);
          if ((v32 & 0x1C) != 0)
          {
            unint64_t v36 = ((v35 + v22) >> 3) + v19;
            unint64_t v37 = (_DWORD *)(v36 & 0xFFFFFFFFFFFFFFFCLL);
            uint64_t v38 = 8 * (v36 & 3);
            int v39 = *v37 >> v38;
            if (v38 + (unint64_t)(v32 & 0x1C) >= 0x21) {
              v39 |= v37[1] << -(char)v38;
            }
            unsigned int v40 = v39 & (0xFFFFFFFF >> -(v32 & 0x1C));
            if (v31)
            {
LABEL_31:
              unint64_t v41 = ((v35 + v33 + v22) >> 3) + v19;
              uint64_t v42 = v32 & 4 | (8 * (v41 & 3));
              int v43 = *(_DWORD *)(v41 & 0xFFFFFFFFFFFFFFFCLL) >> v42;
              if (v42 + (unint64_t)v31 >= 0x21) {
                v43 |= *(_DWORD *)((v41 & 0xFFFFFFFFFFFFFFFCLL) + 4) << -(char)v42;
              }
              unsigned int v44 = v43 & (0xFFFFFFFF >> -(char)v31);
              goto LABEL_36;
            }
          }
          else
          {
            unsigned int v40 = 0;
            if (v31) {
              goto LABEL_31;
            }
          }
          unsigned int v44 = 0;
LABEL_36:
          unint64_t v45 = v19 + ((v34 * v21) >> 3);
          if (v33)
          {
            int v46 = 0;
            unsigned int v47 = 0xFFFFFFFF >> -(char)v33;
            do
            {
              unint64_t v49 = ((v22 + v46 * v34) >> 3) + v19;
              uint64_t v50 = (_DWORD *)(v49 & 0xFFFFFFFFFFFFFFFCLL);
              uint64_t v51 = 8 * (v49 & 3);
              int v52 = *v50 >> v51;
              if ((unint64_t)(v51 + v33) >= 0x21) {
                v52 |= v50[1] << -(char)v51;
              }
              if (v46)
              {
                unint64_t v53 = ((v22 + (v46 - 1) * v34) >> 3) + v19;
                uint64_t v54 = (_DWORD *)(v53 & 0xFFFFFFFFFFFFFFFCLL);
                uint64_t v55 = 8 * (v53 & 3);
                int v56 = *v54 >> v55;
                if ((unint64_t)(v55 + v33) >= 0x21) {
                  v56 |= v54[1] << -(char)v55;
                }
                unsigned int v57 = v56 & v47;
              }
              else
              {
                unsigned int v57 = 0;
              }
              unsigned int v58 = v52 & v47;
              unsigned int v59 = v58 - v57;
              if (v58 <= v57) {
                goto LABEL_38;
              }
              unsigned int v60 = v12 + v13 * v57;
              float v61 = 0.0;
              do
              {
                unint64_t v66 = (v60 >> 3) + v45;
                unint64_t v67 = v66 & 0xFFFFFFFFFFFFFFFCLL;
                unint64_t v68 = v12 & 7 | (8 * (v66 & 3));
                unsigned int v69 = *(_DWORD *)(v66 & 0xFFFFFFFFFFFFFFFCLL) >> v68;
                if (v68 >= 9) {
                  v69 |= *(_DWORD *)(v67 + 4) << -(char)v68;
                }
                int v62 = (v69 >> 22) & 3;
                float v63 = (float)(v69 & 0x3FFFFF);
                float v64 = v63 * 0.0078125;
                float v65 = v63 * 0.000061035;
                if (!v62) {
                  float v63 = v63 * 0.00000095367;
                }
                if (v62 == 1) {
                  float v63 = v65;
                }
                if (v62 == 2) {
                  float v63 = v64;
                }
                float v61 = v63 + v61;
                v60 += v13;
                --v59;
              }
              while (v59);
              if (v61 <= 0.0)
              {
LABEL_38:
                unsigned int v48 = 0;
              }
              else
              {
                unsigned int v48 = (float)((float)(v61 * 10.0) + 0.5);
                if (v48 >= 0x270F) {
                  unsigned int v48 = 9999;
                }
              }
              ++v6[v48];
              ++v46;
            }
            while (v46 != v21);
          }
          if (v18 < v11)
          {
            unint64_t v19 = v45 + ((v40 * v13) >> 3);
            int v21 = v44;
            if (v44) {
              continue;
            }
          }
          goto LABEL_14;
        }
      }
    }
  }
  return 0;
}

uint64_t sub_19E51BD64(uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 8);
  if (!v1) {
    return 1;
  }
  unsigned int v2 = *(unsigned __int8 *)(v1 + 5);
  if (*(unsigned char *)(v1 + 5))
  {
    uint64_t v3 = *(unsigned __int8 *)(v1 + 7);
    uint64_t v4 = *(unsigned __int8 *)(v1 + 6);
    unsigned int v5 = *(_DWORD *)(v1 + 20);
    uint64_t v7 = *(void *)(v1 + 24);
    unint64_t v6 = *(void *)(v1 + 32);
    if (v6) {
      int v8 = sub_19E52EFD0(v6, 1u, *(unsigned __int8 *)(v1 + 6));
    }
    else {
      int v8 = 1;
    }
    if (v7) {
      BOOL v10 = v5 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    if (v10 || v8 == 0) {
      return v8 & 1;
    }
    if (v3)
    {
      int v12 = 0;
      unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v3;
      unsigned int v14 = 1;
      LOBYTE(v8) = 1;
      do
      {
        uint64_t v15 = ((v12 + 24) >> 3) + v7;
        unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v17 = v12 & 7 | (8 * (v15 & 7));
        uint64_t v18 = *(void *)(v15 & 0xFFFFFFFFFFFFFFF8) >> v17;
        if ((unint64_t)(v17 + v3) >= 0x41) {
          v18 |= *(void *)(v16 + 8) << -(char)v17;
        }
        if ((v18 & v13) != 0) {
          LOBYTE(v8) = sub_19E52EFD0(v18 & v13, v2, v4);
        }
        if ((v8 & 1) == 0) {
          break;
        }
        v12 += v3 + 24;
      }
      while (v14++ < v5);
      return v8 & 1;
    }
  }
  LOBYTE(v8) = 1;
  return v8 & 1;
}

uint64_t sub_19E51BE8C(uint64_t result, float a2)
{
  uint64_t v2 = **(void **)(result + 8);
  if (v2)
  {
    unsigned int v4 = *(unsigned __int8 *)(v2 + 5);
    uint64_t v5 = *(unsigned __int8 *)(v2 + 7);
    unsigned int v6 = *(unsigned __int8 *)(v2 + 6);
    int v7 = *(_DWORD *)(v2 + 20);
    uint64_t v8 = *(void *)(v2 + 24);
    uint64_t result = *(void *)(v2 + 32);
    if (result) {
      uint64_t result = sub_19E52CBF4(result, 1u, *(unsigned __int8 *)(v2 + 6), result + 4, a2);
    }
    if (v8) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9 && v5 != 0)
    {
      int v11 = 0;
      unint64_t v12 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v5;
      do
      {
        uint64_t v13 = ((v11 + 24) >> 3) + v8;
        unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v15 = v11 & 7 | (8 * (v13 & 7));
        uint64_t v16 = *(void *)(v13 & 0xFFFFFFFFFFFFFFF8) >> v15;
        if ((unint64_t)(v15 + v5) >= 0x41) {
          v16 |= *(void *)(v14 + 8) << -(char)v15;
        }
        uint64_t result = v16 & v12;
        if ((v16 & v12) != 0) {
          uint64_t result = sub_19E52CBF4(result, v4, v6, result + ((6 * (unint64_t)v4 + 4) >> 3) + 3, a2);
        }
        v11 += v5 + 24;
        --v7;
      }
      while (v7);
    }
  }
  return result;
}

void sub_19E51BFB0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a1 + 16);
  if (v7)
  {
    unsigned int v8 = sub_19E4C6144(v7, a4);
  }
  else
  {
    uint64_t v9 = *(unsigned __int8 *)(a4 + 87);
    int v10 = (char)v9;
    if ((v9 & 0x80u) != 0) {
      uint64_t v9 = *(void *)(a4 + 72);
    }
    if (v9 == 10)
    {
      uint64_t v13 = *(void *)(a4 + 64);
      uint64_t v11 = a4 + 64;
      uint64_t v12 = v13;
      if (v10 >= 0) {
        uint64_t v14 = v11;
      }
      else {
        uint64_t v14 = v12;
      }
      unint64_t v15 = 0x73656C6653656E64;
      unint64_t v16 = bswap64(*(void *)v14);
      if (v16 == 0x73656C6653656E64
        && (v16 = bswap32(*(unsigned __int16 *)(v14 + 8)) >> 16, unint64_t v15 = 25970, v16 == 25970))
      {
        int v17 = 0;
      }
      else if (v16 < v15)
      {
        int v17 = -1;
      }
      else
      {
        int v17 = 1;
      }
      unsigned int v8 = v17 != 0;
    }
    else
    {
      unsigned int v8 = 1;
    }
  }
  uint64_t v18 = 0;
  unint64_t v19 = *(uint64_t **)(a1 + 8);
  unsigned int v20 = *(unsigned __int8 *)(*v19 + 5);
  if (v20 >= a3) {
    unsigned int v20 = a3;
  }
  int v21 = (unsigned int *)(a2 + 4 * a3);
  uint64_t v22 = v20 + 1;
  do
    sub_19E52A9A8(*v19, v21--, v18++, v8, -1.0);
  while (v22 != v18);
}

void sub_19E51C0CC(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, float a5)
{
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    unsigned int v10 = sub_19E4C6144(v9, a4);
  }
  else
  {
    uint64_t v11 = *(unsigned __int8 *)(a4 + 87);
    int v12 = (char)v11;
    if ((v11 & 0x80u) != 0) {
      uint64_t v11 = *(void *)(a4 + 72);
    }
    if (v11 == 10)
    {
      uint64_t v15 = *(void *)(a4 + 64);
      uint64_t v13 = a4 + 64;
      uint64_t v14 = v15;
      if (v12 >= 0) {
        uint64_t v16 = v13;
      }
      else {
        uint64_t v16 = v14;
      }
      unint64_t v17 = 0x73656C6653656E64;
      unint64_t v18 = bswap64(*(void *)v16);
      if (v18 == 0x73656C6653656E64
        && (v18 = bswap32(*(unsigned __int16 *)(v16 + 8)) >> 16, unint64_t v17 = 25970, v18 == 25970))
      {
        int v19 = 0;
      }
      else if (v18 < v17)
      {
        int v19 = -1;
      }
      else
      {
        int v19 = 1;
      }
      unsigned int v10 = v19 != 0;
    }
    else
    {
      unsigned int v10 = 1;
    }
  }
  uint64_t v20 = 0;
  int v21 = *(uint64_t **)(a1 + 8);
  unsigned int v22 = *(unsigned __int8 *)(*v21 + 5);
  if (v22 >= a3) {
    unsigned int v22 = a3;
  }
  int v23 = (unsigned int *)(a2 + 4 * a3);
  uint64_t v24 = v22 + 1;
  do
    sub_19E52A9A8(*v21, v23--, v20++, v10, a5);
  while (v24 != v20);
}

void sub_19E51C1F4(uint64_t a1@<X0>, int *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  int v30 = &v29;
  uint64_t v31 = 0x4002000000;
  char v32 = sub_19E51C608;
  uint64_t v33 = sub_19E51C62C;
  long long __p = 0;
  int v35 = 0;
  uint64_t v36 = 0;
  unsigned int v10 = operator new(0x20uLL);
  *unsigned int v10 = &unk_1EF0BD4B0;
  v10[1] = sub_19E4FA184;
  v10[2] = 0;
  v10[3] = a1 + 24;
  uint64_t v42 = v10;
  if (*(void *)(a1 + 16))
  {
    int v12 = sub_19E4C6144(*(void *)(a1 + 16), a4);
    unsigned int v10 = v42;
  }
  else
  {
    uint64_t v13 = *(unsigned __int8 *)(a4 + 87);
    int v14 = (char)v13;
    if ((v13 & 0x80u) != 0) {
      uint64_t v13 = *(void *)(a4 + 72);
    }
    if (v13 == 10)
    {
      uint64_t v17 = *(void *)(a4 + 64);
      uint64_t v16 = a4 + 64;
      uint64_t v15 = v17;
      if (v14 >= 0) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = v15;
      }
      unint64_t v19 = 0x73656C6653656E64;
      unint64_t v20 = bswap64(*(void *)v18);
      if (v20 == 0x73656C6653656E64
        && (v20 = bswap32(*(unsigned __int16 *)(v18 + 8)) >> 16, unint64_t v19 = 25970, v20 == 25970))
      {
        int v21 = 0;
      }
      else if (v20 < v19)
      {
        int v21 = -1;
      }
      else
      {
        int v21 = 1;
      }
      int v12 = v21 != 0;
    }
    else
    {
      int v12 = 1;
    }
  }
  unsigned int v22 = *(void **)(a1 + 8);
  v37[0] = MEMORY[0x1E4F143A8];
  v11.n128_u64[0] = 1174405120;
  v37[1] = 1174405120;
  v37[2] = sub_19E51C644;
  void v37[3] = &unk_1EF0BEF60;
  if (!v10) {
    goto LABEL_20;
  }
  if (v10 != v41)
  {
    unsigned int v10 = (void *)(*(uint64_t (**)(void *))(*v10 + 16))(v10);
LABEL_20:
    int v39 = v10;
    goto LABEL_22;
  }
  int v39 = v38;
  v11.n128_f64[0] = (*(double (**)(void *, void *))(v41[0] + 24))(v41, v38);
LABEL_22:
  int v40 = v12;
  void v37[4] = &v29;
  sub_19E52A010(v22, a2, a3, (uint64_t)v37, v11);
  int v23 = v30;
  a5[1] = 0;
  a5[2] = 0;
  *a5 = 0;
  int v25 = (unsigned char *)v23[5];
  uint64_t v24 = (unsigned char *)v23[6];
  int64_t v26 = v24 - v25;
  if (v24 != v25)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v26 >> 2) >= 0x1555555555555556) {
      sub_19E37C7C4();
    }
    unint64_t v27 = (char *)operator new(v26);
    *a5 = v27;
    unint64_t v28 = &v27[4 * (v26 >> 2)];
    a5[2] = v28;
    memcpy(v27, v25, v26);
    a5[1] = v28;
  }
  if (v39 == v38)
  {
    (*(void (**)(void *))(v38[0] + 32))(v38);
  }
  else if (v39)
  {
    (*(void (**)(void))(*v39 + 40))();
  }
  if (v42 == v41)
  {
    (*(void (**)(void *))(v41[0] + 32))(v41);
  }
  else if (v42)
  {
    (*(void (**)(void))(*v42 + 40))();
  }
  _Block_object_dispose(&v29, 8);
  if (__p)
  {
    int v35 = __p;
    operator delete(__p);
  }
}

void sub_19E51C5BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  sub_19E51C7B8(v16);
  sub_19E51C7B8((void *)(v17 - 104));
  _Block_object_dispose(&a10, 8);
  if (__p)
  {
    a16 = (uint64_t)__p;
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

__n128 sub_19E51C608(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E51C62C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_19E51C644(uint64_t a1, int a2, int a3, float a4)
{
  int v5 = *(_DWORD *)(a1 + 72);
  int v24 = a3;
  int v25 = v5;
  uint64_t v6 = *(void *)(a1 + 64);
  if (!v6) {
    sub_19E3ACB9C();
  }
  float v9 = (*(float (**)(uint64_t, int *, int *))(*(void *)v6 + 48))(v6, &v25, &v24);
  float v10 = v9;
  __n128 v11 = *(void **)(*(void *)(a1 + 32) + 8);
  uint64_t v13 = (char *)v11[6];
  unint64_t v12 = v11[7];
  if ((unint64_t)v13 >= v12)
  {
    uint64_t v15 = (char *)v11[5];
    unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v13 - v15) >> 2) + 1;
    if (v16 > 0x1555555555555555) {
      sub_19E37C7C4();
    }
    unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - (void)v15) >> 2);
    if (2 * v17 > v16) {
      unint64_t v16 = 2 * v17;
    }
    if (v17 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v18 = 0x1555555555555555;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18 > 0x1555555555555555) {
      sub_19E37C2B8();
    }
    uint64_t v19 = 12 * v18;
    unint64_t v20 = (char *)operator new(12 * v18);
    int v21 = (float *)&v20[4 * ((v13 - v15) >> 2)];
    *(_DWORD *)int v21 = a2;
    v21[1] = v10;
    void v21[2] = a4;
    for (uint64_t i = (char *)(v21 + 3); v13 != v15; *((_DWORD *)v21 + 2) = v23)
    {
      uint64_t v22 = *(void *)(v13 - 12);
      v13 -= 12;
      int v23 = *((_DWORD *)v13 + 2);
      *(void *)(v21 - 3) = v22;
      v21 -= 3;
    }
    v11[5] = v21;
    v11[6] = i;
    v11[7] = &v20[v19];
    if (v15) {
      operator delete(v15);
    }
  }
  else
  {
    *(_DWORD *)uint64_t v13 = a2;
    uint64_t i = v13 + 12;
    *((float *)v13 + 1) = v9;
    *((float *)v13 + 2) = a4;
  }
  v11[6] = i;
}

void *sub_19E51C7B8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t sub_19E51C83C(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t result = *(void *)(a1 + 64);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t sub_19E51C8A0(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 64);
  if (result)
  {
    if (result == a2 + 40)
    {
      *(void *)(a1 + 64) = a1 + 40;
      unsigned int v4 = *(uint64_t (**)(void))(**(void **)(a2 + 64) + 24);
      return v4();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a1 + 64) = result;
    }
  }
  else
  {
    *(void *)(a1 + 64) = 0;
  }
  return result;
}

void *sub_19E51C950()
{
  return &unk_1EF0B8008;
}

uint64_t sub_19E51C95C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__16__bindIMN2LM10ParametersEKFfjjEJPKS2_RKNS_12placeholders4__phILi1EEERKNS8_ILi2EEEEEE"
    || ((v3 & (unint64_t)"NSt3__16__bindIMN2LM10ParametersEKFfjjEJPKS2_RKNS_12placeholders4__phILi1EEERKNS8_ILi2EEEEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__16__bindIMN2LM10ParametersEKFfjjEJPKS2_RKNS_12placeholders4__phILi1EEERKNS8_ILi2EEEEEE")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__16__bindIMN2LM10ParametersEKFfjjEJPKS2_RKNS_12placeholders4__phILi1EEERKNS8_ILi2EEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E51C9B4(void *a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3 = a1[2];
  unsigned int v4 = (uint64_t (*)(void *, void, void))a1[1];
  int v5 = (void *)(a1[3] + (v3 >> 1));
  if (v3) {
    unsigned int v4 = *(uint64_t (**)(void *, void, void))(*v5 + v4);
  }
  return v4(v5, *a2, *a3);
}

__n128 sub_19E51C9EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BD4B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E51CA1C(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF0BD4B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E51CA70()
{
}

uint64_t sub_19E51CA88(uint64_t a1, int *a2, unsigned int a3, uint64_t a4, int a5, float *a6, float *a7)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = *(void *)(a1 + 16);
  if (v13)
  {
    int v14 = sub_19E4C6144(v13, a4);
    if (a5 == 2) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v15 = *(unsigned __int8 *)(a4 + 87);
    int v16 = (char)v15;
    if ((v15 & 0x80u) != 0) {
      uint64_t v15 = *(void *)(a4 + 72);
    }
    if (v15 == 10)
    {
      uint64_t v19 = *(void *)(a4 + 64);
      uint64_t v17 = a4 + 64;
      uint64_t v18 = v19;
      if (v16 >= 0) {
        uint64_t v20 = v17;
      }
      else {
        uint64_t v20 = v18;
      }
      unint64_t v21 = 0x73656C6653656E64;
      unint64_t v22 = bswap64(*(void *)v20);
      if (v22 == 0x73656C6653656E64
        && (v22 = bswap32(*(unsigned __int16 *)(v20 + 8)) >> 16, unint64_t v21 = 25970, v22 == 25970))
      {
        int v23 = 0;
      }
      else if (v22 < v21)
      {
        int v23 = -1;
      }
      else
      {
        int v23 = 1;
      }
      int v14 = v23 != 0;
      if (a5 == 2) {
        goto LABEL_22;
      }
    }
    else
    {
      int v14 = 1;
      if (a5 == 2)
      {
LABEL_22:
        uint64_t v24 = a1 + 24;
        int v25 = operator new(0x20uLL);
        *int v25 = &unk_1EF0BD4B0;
        int64_t v26 = sub_19E4FA220;
        goto LABEL_23;
      }
    }
  }
  if (a5 == 1)
  {
    uint64_t v24 = a1 + 24;
    int v25 = operator new(0x20uLL);
    *int v25 = &unk_1EF0BD4B0;
    int64_t v26 = sub_19E4FA184;
  }
  else
  {
    if (a5) {
      __assert_rtn("weightFunction", "LMNgramPoolFacadeImpl.cpp", 248, "false");
    }
    uint64_t v24 = a1 + 24;
    int v25 = operator new(0x20uLL);
    *int v25 = &unk_1EF0BD4B0;
    int64_t v26 = sub_19E4FA2C4;
  }
LABEL_23:
  v25[1] = v26;
  v25[2] = 0;
  v25[3] = v24;
  uint64_t v42 = v25;
  unint64_t v27 = *(uint64_t **)(a1 + 8);
  if (a6) {
    *a6 = 0.0;
  }
  if (a7) {
    *a7 = 0.0;
  }
  uint64_t v28 = *v27;
  if (*v27)
  {
    unsigned int v29 = *(unsigned __int8 *)(v28 + 5);
    if (v29 + 1 >= a3)
    {
      unsigned int v39 = *(unsigned __int8 *)(v28 + 6);
      if (a3)
      {
        uint64_t v30 = *(void *)(v28 + 24);
        if (v30) {
          BOOL v31 = *(_DWORD *)(v28 + 16) == 0;
        }
        else {
          BOOL v31 = 1;
        }
        if (!v31)
        {
          unsigned int v38 = *(unsigned __int8 *)(v28 + 7);
          unsigned int v32 = *(_DWORD *)(v28 + 20);
          uint64_t v40 = 0;
          if (!*(void *)(v28 + 40))
          {
            uint64_t v33 = malloc_type_malloc(0x30uLL, 0x100004052888210uLL);
            *(void *)(v28 + 40) = v33;
            if (v33)
            {
              *(void *)&long long v34 = -1;
              *((void *)&v34 + 1) = -1;
              v33[1] = v34;
              v33[2] = v34;
              *uint64_t v33 = v34;
            }
          }
          if (sub_19E5293C0(v30, v32, v38, *(_DWORD **)(*v27 + 40), *a2, 0, (unint64_t *)&v40)) {
            sub_19E529A5C(v40, v29, v39, (uint64_t)a2, a3, 0, v40 + ((6 * (unint64_t)v29 + 4) >> 3) + 3, 1, 0, 1u, v14, (uint64_t)v41, a6, a7);
          }
        }
        if (a3 == 1)
        {
          if (a7)
          {
            uint64_t v35 = *(void *)(*v27 + 32);
            if (v35)
            {
              LODWORD(v40) = 0;
              sub_19E529A5C(v35, 1u, v39, (uint64_t)&v40, 1, 0, v35 + 4, 1, 0, 1u, v14, (uint64_t)v41, a7, 0);
            }
          }
        }
      }
      else
      {
        uint64_t v36 = *(void *)(v28 + 32);
        if (v36)
        {
          LODWORD(v40) = 0;
          sub_19E529A5C(v36, 1u, v39, (uint64_t)&v40, 1, 0, v36 + 4, 1, 0, 1u, v14, (uint64_t)v41, a6, 0);
        }
      }
    }
  }
  uint64_t result = (uint64_t)v42;
  if (v42 == v41) {
    return (*(uint64_t (**)(void *))(v41[0] + 32))(v41);
  }
  if (v42) {
    return (*(uint64_t (**)(void))(*v42 + 40))();
  }
  return result;
}

void sub_19E51CEAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  sub_19E51C7B8((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E51CEC0(uint64_t a1, unsigned int a2, float a3)
{
  unsigned int v4 = 0;
  sub_19E52809C(**(void **)(a1 + 8), a2, &v4, a3);
  return v4;
}

uint64_t sub_19E51CEF4(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = 0;
  sub_19E52809C(**(void **)(a1 + 8), a2, &v3, 0.0);
  return v3;
}

float sub_19E51CF2C(uint64_t a1, int *a2, unsigned int a3)
{
  uint64_t v7 = 0;
  unsigned int v8 = (float *)&v7;
  uint64_t v9 = 0x2000000000;
  int v10 = 0;
  unsigned int v3 = *(void **)(a1 + 8);
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  v6[2] = sub_19E51CFF4;
  v6[3] = &unk_1E59A1DB8;
  v6[4] = &v7;
  sub_19E528DFC(v3, a2, a3, (uint64_t)v6);
  float v4 = v8[6];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_19E51CFDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

float sub_19E51CFF4(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  float result = *(float *)(v2 + 24) + a2;
  *(float *)(v2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_19E51D00C(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    unsigned int v4 = sub_19E4C6144(result, a2);
    if (*(void *)(a1 + 16)) {
      return v4 >> (*(unsigned char *)(a1 + 372) - 2);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_19E51D054(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if (v1 && (uint64_t v2 = *(void *)(v1 + 8)) != 0) {
    return *(void *)(v2 + 16);
  }
  else {
    return 0;
  }
}

uint64_t sub_19E51D074(uint64_t a1, int a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  uint64_t v3 = *v2;
  if (!*v2) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 24);
  if (!v4 || *(_DWORD *)(v3 + 16) == 0) {
    return 0;
  }
  unsigned int v8 = *(_DWORD *)(v3 + 20);
  unsigned int v9 = *(unsigned __int8 *)(v3 + 7);
  if (!*(void *)(v3 + 40))
  {
    int v10 = malloc_type_malloc(0x30uLL, 0x100004052888210uLL);
    *(void *)(v3 + 40) = v10;
    if (v10)
    {
      *(void *)&long long v11 = -1;
      *((void *)&v11 + 1) = -1;
      v10[1] = v11;
      v10[2] = v11;
      *int v10 = v11;
    }
  }
  unint64_t v12 = *(_DWORD **)(*v2 + 40);
  return sub_19E5293C0(v4, v8, v9, v12, a2, 0, 0);
}

float sub_19E51D148(uint64_t a1)
{
  uint64_t v8 = 0;
  unsigned int v9 = (float *)&v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 8);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  v7[2] = sub_19E51CFF4;
  v7[3] = &unk_1E59A1DB8;
  v7[4] = &v8;
  uint64_t v2 = *v1;
  float v3 = 0.0;
  if (*v1)
  {
    uint64_t v4 = *(void *)(v2 + 32);
    if (v4)
    {
      uint64_t v5 = *(unsigned __int8 *)(v2 + 6);
      int v12 = 0;
      sub_19E528F50(v4, 1u, v5, (uint64_t)&v12, 1u, 0, v4 + 4, 1, 0, 1u, (uint64_t)v7);
      float v3 = v9[6];
    }
  }
  _Block_object_dispose(&v8, 8);
  return v3;
}

void sub_19E51D234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E51D24C(uint64_t a1)
{
  return *(unsigned int *)(**(void **)(a1 + 8) + 12);
}

uint64_t sub_19E51D25C(uint64_t a1)
{
  return *(unsigned __int8 *)(**(void **)(a1 + 8) + 5);
}

BOOL sub_19E51D26C(uint64_t a1)
{
  return *(_DWORD *)(**(void **)(a1 + 8) + 16) == 0;
}

double sub_19E51D284(uint64_t a1, void *a2)
{
  if ((void *)(a1 + 24) == a2) {
    return result;
  }
  uint64_t v4 = (void **)(a1 + 112);
  char v5 = *((unsigned char *)a2 + 111);
  if (*(char *)(a1 + 135) < 0)
  {
    if (v5 >= 0) {
      uint64_t v7 = a2 + 11;
    }
    else {
      uint64_t v7 = (void *)a2[11];
    }
    if (v5 >= 0) {
      size_t v8 = *((unsigned __int8 *)a2 + 111);
    }
    else {
      size_t v8 = a2[12];
    }
    sub_19E3C6D44(v4, v7, v8);
  }
  else if ((*((unsigned char *)a2 + 111) & 0x80) != 0)
  {
    sub_19E3C6C7C(v4, (void *)a2[11], a2[12]);
  }
  else
  {
    long long v6 = *(_OWORD *)(a2 + 11);
    *(void *)(a1 + 128) = a2[13];
    *(_OWORD *)uint64_t v4 = v6;
  }
  *(_DWORD *)(a1 + 136) = *((_DWORD *)a2 + 28);
  if (a2[15]) {
    operator new();
  }
  unsigned int v9 = (void **)(a1 + 152);
  char v10 = *((unsigned char *)a2 + 151);
  if (*(char *)(a1 + 175) < 0)
  {
    if (v10 >= 0) {
      int v12 = a2 + 16;
    }
    else {
      int v12 = (void *)a2[16];
    }
    if (v10 >= 0) {
      size_t v13 = *((unsigned __int8 *)a2 + 151);
    }
    else {
      size_t v13 = a2[17];
    }
    sub_19E3C6D44(v9, v12, v13);
  }
  else if ((*((unsigned char *)a2 + 151) & 0x80) != 0)
  {
    sub_19E3C6C7C(v9, (void *)a2[16], a2[17]);
  }
  else
  {
    long long v11 = *((_OWORD *)a2 + 8);
    *(void *)(a1 + 168) = a2[18];
    *(_OWORD *)unsigned int v9 = v11;
  }
  int v14 = (void **)(a1 + 176);
  char v15 = *((unsigned char *)a2 + 175);
  if (*(char *)(a1 + 199) < 0)
  {
    if (v15 >= 0) {
      uint64_t v18 = a2 + 19;
    }
    else {
      uint64_t v18 = (void *)a2[19];
    }
    if (v15 >= 0) {
      size_t v19 = *((unsigned __int8 *)a2 + 175);
    }
    else {
      size_t v19 = a2[20];
    }
    sub_19E3C6D44(v14, v18, v19);
    uint64_t v17 = (const void *)a2[22];
    if (!v17) {
      goto LABEL_41;
    }
    goto LABEL_37;
  }
  if ((*((unsigned char *)a2 + 175) & 0x80) != 0)
  {
    sub_19E3C6C7C(v14, (void *)a2[19], a2[20]);
    uint64_t v17 = (const void *)a2[22];
    if (!v17) {
      goto LABEL_41;
    }
LABEL_37:
    if (*(const void **)(a1 + 200) != v17)
    {
      CFRetain(v17);
      uint64_t v20 = *(const void **)(a1 + 200);
      if (v20) {
        CFRelease(v20);
      }
      *(void *)(a1 + 200) = v17;
    }
    goto LABEL_41;
  }
  long long v16 = *(_OWORD *)(a2 + 19);
  *(void *)(a1 + 192) = a2[21];
  *(_OWORD *)int v14 = v16;
  uint64_t v17 = (const void *)a2[22];
  if (v17) {
    goto LABEL_37;
  }
LABEL_41:
  if (a2[23]) {
    operator new();
  }
  *(unsigned char *)(a1 + 216) = *((unsigned char *)a2 + 192);
  *(void *)(a1 + 220) = *(void *)((char *)a2 + 196);
  *(_OWORD *)(a1 + 228) = *(_OWORD *)((char *)a2 + 204);
  *(_OWORD *)(a1 + 244) = *(_OWORD *)((char *)a2 + 220);
  *(void *)(a1 + 260) = *(void *)((char *)a2 + 236);
  *(_DWORD *)(a1 + 268) = *((_DWORD *)a2 + 61);
  uint64_t v21 = a2[31];
  *(_DWORD *)(a1 + 280) = *((_DWORD *)a2 + 64);
  *(void *)(a1 + 272) = v21;
  sub_19E44A444((void *)(a1 + 288), (char *)a2[33], (char *)a2[34], (uint64_t)(a2[34] - a2[33]) >> 2);
  *(void *)(a1 + 312) = a2[36];
  uint64_t v22 = a2[37];
  *(_DWORD *)(a1 + 328) = *((_DWORD *)a2 + 76);
  *(void *)(a1 + 320) = v22;
  *(_DWORD *)(a1 + 332) = *((_DWORD *)a2 + 77);
  *(_DWORD *)(a1 + 336) = *((_DWORD *)a2 + 78);
  *(_DWORD *)(a1 + 340) = *((_DWORD *)a2 + 79);
  *(_DWORD *)(a1 + 344) = *((_DWORD *)a2 + 80);
  *(_OWORD *)(a1 + 348) = *(_OWORD *)((char *)a2 + 324);
  *(_DWORD *)(a1 + 364) = *((_DWORD *)a2 + 85);
  *(unsigned char *)(a1 + 368) = *((unsigned char *)a2 + 344);
  *(_DWORD *)(a1 + 372) = *((_DWORD *)a2 + 87);
  *(_DWORD *)(a1 + 376) = *((_DWORD *)a2 + 88);
  *(unsigned char *)(a1 + 4++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *((unsigned char *)a2 + 400);
  *(void *)(a1 + 380) = *(void *)((char *)a2 + 356);
  *(_WORD *)(a1 + 388) = *((_WORD *)a2 + 182);
  *(_OWORD *)(a1 + 392) = *((_OWORD *)a2 + 23);
  *(_DWORD *)(a1 + 408) = *((_DWORD *)a2 + 96);
  *(_DWORD *)(a1 + 412) = *((_DWORD *)a2 + 97);
  *(unsigned char *)(a1 + 425) = *((unsigned char *)a2 + 401);
  *(void *)(a1 + 416) = a2[49];
  *(_DWORD *)(a1 + 440) = *((_DWORD *)a2 + 104);
  *(_WORD *)(a1 + 452) = *((_WORD *)a2 + 214);
  *(_DWORD *)(a1 + 480) = *((_DWORD *)a2 + 114);
  int v23 = (void **)(a1 + 456);
  char v24 = *((unsigned char *)a2 + 455);
  if (*(char *)(a1 + 479) < 0)
  {
    if (v24 >= 0) {
      int64_t v26 = a2 + 54;
    }
    else {
      int64_t v26 = (void *)a2[54];
    }
    if (v24 >= 0) {
      size_t v27 = *((unsigned __int8 *)a2 + 455);
    }
    else {
      size_t v27 = a2[55];
    }
    sub_19E3C6D44(v23, v26, v27);
  }
  else if ((*((unsigned char *)a2 + 455) & 0x80) != 0)
  {
    sub_19E3C6C7C(v23, (void *)a2[54], a2[55]);
  }
  else
  {
    long long v25 = *((_OWORD *)a2 + 27);
    *(void *)(a1 + 472) = a2[56];
    *(_OWORD *)int v23 = v25;
  }
  double result = *((double *)a2 + 58);
  *(double *)(a1 + 488) = result;
  return result;
}

void sub_19E51D654(_Unwind_Exception *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1012C4003C2D8E3);
  _Unwind_Resume(a1);
}

void sub_19E51D694(void *a1)
{
  *a1 = &unk_1EF0BAD68;
  sub_19E3D7670((uint64_t)(a1 + 3));
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E4C6030(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1060C4064AC95D2);
  }
  uint64_t v4 = (uint64_t *)a1[1];
  a1[1] = 0;
  if (v4)
  {
    if (*v4)
    {
      sub_19E374B30(v4);
      if (*v4) {
        MEMORY[0x19F3BDCF0](*v4, 0x1010C4006136809);
      }
    }
    MEMORY[0x19F3BDCF0](v4, 0x20C4093837F09);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E51D76C(void *a1)
{
  *a1 = &unk_1EF0BAD68;
  sub_19E3D7670((uint64_t)(a1 + 3));
  uint64_t v2 = a1[2];
  a1[2] = 0;
  if (v2)
  {
    uint64_t v3 = sub_19E4C6030(v2);
    MEMORY[0x19F3BDCF0](v3, 0x1060C4064AC95D2);
  }
  uint64_t v4 = (uint64_t *)a1[1];
  a1[1] = 0;
  if (v4)
  {
    if (*v4)
    {
      sub_19E374B30(v4);
      if (*v4) {
        MEMORY[0x19F3BDCF0](*v4, 0x1010C4006136809);
      }
    }
    MEMORY[0x19F3BDCF0](v4, 0x20C4093837F09);
  }
  return a1;
}

double sub_19E51D824@<D0>(uint64_t a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)a1 = v2;
  *(_OWORD *)(a1 + 8) = xmmword_19E573210;
  strcpy(v2, "Beam Search V2 (Word-by-Word thresholding with early stopping)");
  return *(double *)" early stopping)";
}

uint64_t sub_19E51D880@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, std::string *a4@<X3>, void **a5@<X8>, float a6@<S0>)
{
  *a5 = 0;
  a5[1] = 0;
  a5[2] = 0;
  sub_19E444550((uint64_t)v55, *a2);
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  if (v12 == v13) {
    return sub_19E4446FC((uint64_t)v55);
  }
  char v14 = 0;
  do
  {
    if ((v14 & 1) != 0 && *(void *)(v12 + 264) < v57) {
      goto LABEL_4;
    }
    if (sub_19E51DFD0(a1, (void *)v12, a3, 0, a6)
      || *(void *)(v12 + 264) >= 2uLL && sub_19E51DFD0(a1, (void *)v12, a3, 1, a6))
    {
      if ((v14 & 1) == 0 || *(void *)(v12 + 264) > v57 || *(float *)(v12 + 24) > v56) {
        sub_19E449FE0((uint64_t)v55, v12);
      }
LABEL_4:
      char v14 = 1;
    }
    v12 += 304;
  }
  while (v12 != v13);
  if ((v14 & 1) == 0) {
    return sub_19E4446FC((uint64_t)v55);
  }
  if (!sub_19E51DFD0(a1, v55, a3, 0, a6))
  {
    if (qword_1E945A330 != -1) {
      dispatch_once(&qword_1E945A330, &unk_1EF0BEF90);
    }
    uint64_t v23 = *(void *)(a1 + 72);
    long long v16 = *(std::__shared_weak_count **)(a1 + 80);
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    sub_19E4DD754(&__p, v55, v23);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    sub_19E439798("Found final hypothesis satisfying secondary policy  = [%s]", (uint64_t)&v58, p_p);
    if (v60 >= 0) {
      long long v25 = (const std::string::value_type *)&v58;
    }
    else {
      long long v25 = v58;
    }
    if (v60 >= 0) {
      std::string::size_type v26 = HIBYTE(v60);
    }
    else {
      std::string::size_type v26 = v59;
    }
    std::string::append(a4, v25, v26);
    if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
    {
      std::string::size_type size = a4->__r_.__value_.__l.__size_;
      if (size)
      {
        unsigned int v29 = (std::string *)a4->__r_.__value_.__r.__words[0];
        if (!*(unsigned char *)(a4->__r_.__value_.__r.__words[0] + size - 1))
        {
          std::string::size_type v28 = size - 1;
          a4->__r_.__value_.__l.__size_ = v28;
          goto LABEL_63;
        }
      }
    }
    else
    {
      uint64_t v27 = HIBYTE(a4->__r_.__value_.__r.__words[2]);
      if (*((unsigned char *)&a4->__r_.__value_.__s + 23) && !a4->__r_.__value_.__s.__data_[v27 - 1])
      {
        std::string::size_type v28 = v27 - 1;
        *((unsigned char *)&a4->__r_.__value_.__s + 23) = v27 - 1;
        unsigned int v29 = a4;
LABEL_63:
        v29->__r_.__value_.__s.__data_[v28] = 0;
      }
    }
    std::string::push_back(a4, 10);
    if ((SHIBYTE(v60) & 0x80000000) == 0) {
      goto LABEL_57;
    }
    goto LABEL_65;
  }
  if (qword_1E945A330 != -1) {
    dispatch_once(&qword_1E945A330, &unk_1EF0BEF90);
  }
  uint64_t v15 = *(void *)(a1 + 72);
  long long v16 = *(std::__shared_weak_count **)(a1 + 80);
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  sub_19E4DD754(&__p, v55, v15);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v17 = &__p;
  }
  else {
    uint64_t v17 = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  sub_19E439798("Found final hypothesis satisfying primary policy  = [%s]", (uint64_t)&v58, v17);
  if (v60 >= 0) {
    uint64_t v18 = (const std::string::value_type *)&v58;
  }
  else {
    uint64_t v18 = v58;
  }
  if (v60 >= 0) {
    std::string::size_type v19 = HIBYTE(v60);
  }
  else {
    std::string::size_type v19 = v59;
  }
  std::string::append(a4, v18, v19);
  if (SHIBYTE(a4->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v30 = a4->__r_.__value_.__l.__size_;
    if (v30)
    {
      uint64_t v22 = (std::string *)a4->__r_.__value_.__r.__words[0];
      if (!*(unsigned char *)(a4->__r_.__value_.__r.__words[0] + v30 - 1))
      {
        std::string::size_type v21 = v30 - 1;
        a4->__r_.__value_.__l.__size_ = v21;
LABEL_55:
        v22->__r_.__value_.__s.__data_[v21] = 0;
      }
    }
  }
  else
  {
    uint64_t v20 = HIBYTE(a4->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&a4->__r_.__value_.__s + 23) && !a4->__r_.__value_.__s.__data_[v20 - 1])
    {
      std::string::size_type v21 = v20 - 1;
      *((unsigned char *)&a4->__r_.__value_.__s + 23) = v20 - 1;
      uint64_t v22 = a4;
      goto LABEL_55;
    }
  }
  std::string::push_back(a4, 10);
  if ((SHIBYTE(v60) & 0x80000000) == 0)
  {
LABEL_57:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_58;
    }
LABEL_66:
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v16) {
      goto LABEL_67;
    }
    goto LABEL_69;
  }
LABEL_65:
  operator delete(v58);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_66;
  }
LABEL_58:
  if (v16)
  {
LABEL_67:
    if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
LABEL_69:
  unsigned int v32 = a5[2];
  uint64_t v33 = a5[1];
  if (v33 < v32)
  {
    sub_19E444550((uint64_t)a5[1], (uint64_t)v55);
    uint64_t v34 = (uint64_t)(v33 + 304);
    a5[1] = (void *)v34;
    goto LABEL_88;
  }
  unint64_t v35 = 0x86BCA1AF286BCA1BLL * ((v33 - (unsigned char *)*a5) >> 4);
  if (v35 + 1 > 0xD79435E50D7943) {
    sub_19E37C7C4();
  }
  unint64_t v36 = 0x86BCA1AF286BCA1BLL * ((v32 - (unsigned char *)*a5) >> 4);
  uint64_t v37 = 2 * v36;
  if (2 * v36 <= v35 + 1) {
    uint64_t v37 = v35 + 1;
  }
  if (v36 >= 0x6BCA1AF286BCA1) {
    unint64_t v38 = 0xD79435E50D7943;
  }
  else {
    unint64_t v38 = v37;
  }
  int v62 = a5 + 2;
  if (v38)
  {
    if (v38 > 0xD79435E50D7943) {
      sub_19E37C2B8();
    }
    unsigned int v39 = (std::string::value_type *)operator new(304 * v38);
  }
  else
  {
    unsigned int v39 = 0;
  }
  unsigned int v58 = v39;
  std::string::size_type v59 = (std::string::size_type)&v39[304 * v35];
  uint64_t v60 = v59;
  float v61 = &v39[304 * v38];
  sub_19E444550(v59, (uint64_t)v55);
  uint64_t v40 = v59;
  uint64_t v34 = v60 + 304;
  unint64_t v41 = (char *)*a5;
  uint64_t v42 = (char *)a5[1];
  if (v42 == *a5)
  {
    *a5 = (void *)v59;
    a5[1] = (void *)v34;
    a5[2] = v61;
    if (v42) {
      goto LABEL_87;
    }
  }
  else
  {
    uint64_t v43 = 0;
    do
    {
      uint64_t v44 = v40 + v43;
      unint64_t v45 = (void *)(v40 + v43 - 304);
      int v46 = &v42[v43];
      uint64_t v47 = (uint64_t)&v42[v43 - 304];
      *(void *)(v40 + v43 - 296) = 0;
      *unint64_t v45 = 0;
      v45[2] = 0;
      *(_OWORD *)unint64_t v45 = *(_OWORD *)v47;
      *(void *)(v40 + v43 - 288) = *(void *)&v42[v43 - 288];
      *(void *)&v42[v43 - 296] = 0;
      *(void *)uint64_t v47 = 0;
      *(void *)(v47 + 16) = 0;
      *(void *)(v40 + v43 - 280) = *(void *)&v42[v43 - 280];
      uint64_t v48 = (uint64_t)&v42[v43 - 272];
      long long v49 = *(_OWORD *)v48;
      *(void *)(v44 - 256) = *(void *)&v42[v43 - 256];
      *(_OWORD *)(v40 + v43 - 272) = v49;
      *((void *)v46 - 32) = 0;
      *(void *)uint64_t v48 = 0;
      *(void *)(v48 + 8) = 0;
      *(void *)(v44 - 248) = 0;
      *(void *)(v44 - 240) = 0;
      *(void *)(v44 - 232) = 0;
      *(_OWORD *)(v44 - 248) = *(_OWORD *)&v42[v43 - 248];
      *(void *)(v44 - 232) = *(void *)&v42[v43 - 232];
      *((void *)v46 - 31) = 0;
      *((void *)v46 - 30) = 0;
      *((void *)v46 - 29) = 0;
      *(void *)(v44 - 2++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(void *)(v44 - 216) = 0;
      *(void *)(v44 - 208) = 0;
      *(_OWORD *)(v44 - 2++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)&v42[v43 - 224];
      *(void *)(v44 - 208) = *(void *)&v42[v43 - 208];
      *((void *)v46 - 28) = 0;
      *((void *)v46 - 27) = 0;
      *((void *)v46 - 26) = 0;
      *(void *)(v44 - 200) = 0;
      *(void *)(v44 - 192) = 0;
      *(void *)(v44 - 184) = 0;
      *(_OWORD *)(v44 - 200) = *(_OWORD *)&v42[v43 - 200];
      *(void *)(v44 - 184) = *(void *)&v42[v43 - 184];
      *((void *)v46 - 25) = 0;
      *((void *)v46 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *((void *)v46 - 23) = 0;
      *(void *)(v44 - 176) = 0;
      *(void *)(v44 - 168) = 0;
      *(void *)(v44 - 160) = 0;
      *(_OWORD *)(v44 - 176) = *(_OWORD *)&v42[v43 - 176];
      *(void *)(v44 - 160) = *(void *)&v42[v43 - 160];
      *((void *)v46 - 22) = 0;
      *((void *)v46 - 21) = 0;
      *((void *)v46 - 20) = 0;
      *(void *)(v44 - 152) = 0;
      *(void *)(v44 - 144) = 0;
      *(void *)(v44 - 136) = 0;
      *(_OWORD *)(v44 - 152) = *(_OWORD *)&v42[v43 - 152];
      *(void *)(v44 - 136) = *(void *)&v42[v43 - 136];
      *((void *)v46 - 18) = 0;
      *((void *)v46 - 17) = 0;
      long long v50 = *(_OWORD *)&v42[v43 - 128];
      *((void *)v46 - 19) = 0;
      *(_OWORD *)(v44 - 128) = v50;
      *(void *)(v44 - 104) = 0;
      *(void *)(v44 - 96) = 0;
      *(void *)(v44 - 112) = 0;
      *(_OWORD *)(v44 - 112) = *(_OWORD *)&v42[v43 - 112];
      *(void *)(v44 - 96) = *(void *)&v42[v43 - 96];
      *((void *)v46 - 14) = 0;
      *((void *)v46 - 13) = 0;
      *((void *)v46 - 12) = 0;
      *(void *)(v44 - 88) = 0;
      *(void *)(v44 - 80) = 0;
      *(void *)(v44 - 72) = 0;
      *(_OWORD *)(v44 - 88) = *(_OWORD *)&v42[v43 - 88];
      *(void *)(v44 - 72) = *(void *)&v42[v43 - 72];
      *((void *)v46 - 11) = 0;
      *((void *)v46 - 10) = 0;
      *((void *)v46 - 9) = 0;
      *(void *)(v44 - 64) = 0;
      *(void *)(v44 - 56) = 0;
      *(void *)(v44 - 48) = 0;
      *(_OWORD *)(v44 - 64) = *(_OWORD *)&v42[v43 - 64];
      *(void *)(v44 - 48) = *(void *)&v42[v43 - 48];
      *((void *)v46 - 8) = 0;
      *((void *)v46 - 7) = 0;
      *((void *)v46 - 6) = 0;
      uint64_t v51 = *(void *)&v42[v43 - 40];
      *(_DWORD *)(v44 - 32) = *(_DWORD *)&v42[v43 - 32];
      *(void *)(v44 - 16) = 0;
      *(void *)(v44 - 8) = 0;
      *(void *)(v44 - 40) = v51;
      *(void *)(v44 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(_OWORD *)(v44 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)&v42[v43 - 24];
      *(void *)(v44 - 8) = *(void *)&v42[v43 - 8];
      *((void *)v46 - 3) = 0;
      *((void *)v46 - 2) = 0;
      *((void *)v46 - 1) = 0;
      v43 -= 304;
    }
    while (&v42[v43] != v41);
    uint64_t v42 = (char *)*a5;
    uint64_t v52 = (uint64_t)a5[1];
    *a5 = (void *)(v40 + v43);
    a5[1] = (void *)v34;
    for (a5[2] = v61; (char *)v52 != v42; uint64_t v52 = sub_19E4446FC(v52 - 304))
      ;
    if (v42) {
LABEL_87:
    }
      operator delete(v42);
  }
LABEL_88:
  a5[1] = (void *)v34;
  return sub_19E4446FC((uint64_t)v55);
}

void sub_19E51DF38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  sub_19E44AD68(v20 - 120);
  sub_19E4446FC((uint64_t)&a19);
  sub_19E448E78(v19);
  _Unwind_Resume(a1);
}

BOOL sub_19E51DFD0(uint64_t a1, void *a2, uint64_t a3, int a4, float a5)
{
  if (!a2[33]) {
    return 1;
  }
  unsigned int v9 = (void *)(a1 + 72);
  if (*(char *)(a3 + 23) >= 0) {
    unint64_t v10 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    unint64_t v10 = *(void *)(a3 + 8);
  }
  float v11 = sub_19E4E18D0((void *)(a1 + 72), v10, 1uLL, a4);
  uint64_t v12 = (const void **)(a2 + 35);
  uint64_t v13 = a2[36];
  char v14 = (const void *)a2[35];
  size_t v15 = v13 - (void)v14;
  if (v13 - (uint64_t)v14 < 0) {
    sub_19E37C7C4();
  }
  long long v16 = (float *)operator new(v13 - (void)v14);
  memcpy(v16, v14, v15);
  float v17 = *v16 - a5;
  operator delete(v16);
  if (v17 < v11) {
    return 0;
  }
  for (unint64_t i = 1; ; ++i)
  {
    unint64_t v19 = a2[33];
    BOOL result = i >= v19;
    if (i >= v19) {
      break;
    }
    if (*(char *)(a3 + 23) >= 0) {
      unint64_t v21 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      unint64_t v21 = *(void *)(a3 + 8);
    }
    float v22 = sub_19E4E18D0(v9, v21, i + 1, a4);
    uint64_t v23 = a2[36];
    char v24 = *v12;
    int64_t v25 = v23 - (void)*v12;
    if (v25 < 0) {
      sub_19E37C7C4();
    }
    std::string::size_type v26 = operator new(v23 - (void)*v12);
    memcpy(v26, v24, v25);
    float v27 = *((float *)v26 + i);
    operator delete(v26);
    if (v27 < v22) {
      return 0;
    }
  }
  return result;
}

void sub_19E51E15C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

os_log_t sub_19E51E17C()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "InlineCompletionHypothesis");
  qword_1E945A328 = (uint64_t)result;
  return result;
}

void sub_19E51E1AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(void **)a3;
  if (0xD37A6F4DE9BD37A7 * ((uint64_t)(*(void *)(a3 + 8) - (void)v7) >> 3) >= 2) {
    __assert_rtn("_completions", "MultiWordBeamSearchPredictorV2.cpp", 262, "stems.size()<2");
  }
  if (byte_1E9459939)
  {
    sub_19E4E1EBC((void *)(a1 + 72), (uint64_t *)(a1 + 208), v7, a4);
    if (v9 > 0.0001) {
      __assert_rtn("_completions", "MultiWordBeamSearchPredictorV2.cpp", 268, "prefixProbabilityFirstWord<=1e-4");
    }
  }
  if (a7)
  {
    if (qword_1E945A330 != -1) {
      dispatch_once(&qword_1E945A330, &unk_1EF0BEF90);
    }
    unint64_t v10 = qword_1E945A328;
    if (os_log_type_enabled((os_log_t)qword_1E945A328, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      float v11 = "Starting Inline Completions Beam Search in Lexicon Constrained Prediction Mode";
LABEL_14:
      _os_log_impl(&dword_19E36B000, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
    }
  }
  else
  {
    if (qword_1E945A330 != -1) {
      dispatch_once(&qword_1E945A330, &unk_1EF0BEF90);
    }
    unint64_t v10 = qword_1E945A328;
    if (os_log_type_enabled((os_log_t)qword_1E945A328, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      float v11 = "Starting Inline Completions Beam Search in Open Ended Prediction Mode";
      goto LABEL_14;
    }
  }
  operator new();
}

void sub_19E520970(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  sub_19E37B770(a1);
}

void sub_19E520B38()
{
  sub_19E3D73EC((uint64_t)&STACK[0x400]);
  uint64_t v0 = (void *)STACK[0x560];
  if (STACK[0x560])
  {
    STACK[0x568] = (unint64_t)v0;
    operator delete(v0);
    uint64_t v1 = (void *)STACK[0x578];
    if (!STACK[0x578]) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v1 = (void *)STACK[0x578];
    if (!STACK[0x578])
    {
LABEL_6:
      sub_19E4446FC((uint64_t)&STACK[0x590]);
      JUMPOUT(0x19E521070);
    }
  }
  operator delete(v1);
  goto LABEL_6;
}

void sub_19E520B54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  sub_19E3D73EC((uint64_t)&a58);
  unsigned int v58 = (void *)STACK[0x2B8];
  if (STACK[0x2B8])
  {
    unint64_t v62 = STACK[0x2C0];
    if ((void *)STACK[0x2C0] != v58)
    {
      do
      {
        float v63 = *(std::__shared_weak_count **)(v62 - 16);
        if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
          std::__shared_weak_count::__release_weak(v63);
        }
        v62 -= 24;
      }
      while ((void *)v62 != v58);
      unsigned int v58 = (void *)STACK[0x2B8];
    }
    operator delete(v58);
  }
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if (SLOBYTE(STACK[0x547]) < 0)
  {
    operator delete((void *)STACK[0x530]);
    std::string::size_type v59 = (void *)STACK[0x548];
    if (!STACK[0x548]) {
      goto LABEL_17;
    }
  }
  else
  {
    std::string::size_type v59 = (void *)STACK[0x548];
    if (!STACK[0x548])
    {
LABEL_17:
      uint64_t v60 = (void *)STACK[0x560];
      if (!STACK[0x560])
      {
LABEL_18:
        float v61 = (void *)STACK[0x578];
        if (!STACK[0x578])
        {
LABEL_20:
          sub_19E4446FC((uint64_t)&STACK[0x590]);
          JUMPOUT(0x19E521070);
        }
LABEL_19:
        operator delete(v61);
        goto LABEL_20;
      }
LABEL_5:
      STACK[0x568] = (unint64_t)v60;
      operator delete(v60);
      float v61 = (void *)STACK[0x578];
      if (!STACK[0x578]) {
        goto LABEL_20;
      }
      goto LABEL_19;
    }
  }
  operator delete(v59);
  uint64_t v60 = (void *)STACK[0x560];
  if (!STACK[0x560]) {
    goto LABEL_18;
  }
  goto LABEL_5;
}

void sub_19E520B70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p)
{
  if (__p)
  {
    operator delete(__p);
    uint64_t v52 = (void *)STACK[0x2B8];
    if (!STACK[0x2B8]) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v52 = (void *)STACK[0x2B8];
    if (!STACK[0x2B8]) {
      goto LABEL_13;
    }
  }
  unint64_t v53 = STACK[0x2C0];
  if ((void *)STACK[0x2C0] != v52)
  {
    do
    {
      uint64_t v54 = *(std::__shared_weak_count **)(v53 - 16);
      if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
      v53 -= 24;
    }
    while ((void *)v53 != v52);
    uint64_t v52 = (void *)STACK[0x2B8];
  }
  operator delete(v52);
LABEL_13:
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if ((SLOBYTE(STACK[0x547]) & 0x80000000) == 0)
  {
    if (!STACK[0x548])
    {
      if (!STACK[0x560]) {
        JUMPOUT(0x19E52105CLL);
      }
      JUMPOUT(0x19E520F5CLL);
    }
    JUMPOUT(0x19E520F50);
  }
  JUMPOUT(0x19E520F40);
}

void sub_19E520B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (a57 < 0) {
    operator delete(__p);
  }
  sub_19E3D73EC((uint64_t)&a49);
  sub_19E4446FC((uint64_t)&a61);
  float v61 = (void *)STACK[0x2B8];
  if (STACK[0x2B8])
  {
    unint64_t v62 = STACK[0x2C0];
    if ((void *)STACK[0x2C0] != v61)
    {
      do
      {
        float v63 = *(std::__shared_weak_count **)(v62 - 16);
        if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
          std::__shared_weak_count::__release_weak(v63);
        }
        v62 -= 24;
      }
      while ((void *)v62 != v61);
      float v61 = (void *)STACK[0x2B8];
    }
    operator delete(v61);
  }
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if ((SLOBYTE(STACK[0x547]) & 0x80000000) == 0)
  {
    if (!STACK[0x548])
    {
      if (!STACK[0x560]) {
        JUMPOUT(0x19E52105CLL);
      }
      JUMPOUT(0x19E520F5CLL);
    }
    JUMPOUT(0x19E520F50);
  }
  JUMPOUT(0x19E520F40);
}

void sub_19E520BA4()
{
}

void sub_19E520BB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  sub_19E4449B8(&a55);
  if (SLOBYTE(STACK[0x2CF]) < 0)
  {
    operator delete((void *)STACK[0x2B8]);
    if ((a63 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a63 & 0x80000000) == 0)
  {
LABEL_3:
    float v63 = (void *)STACK[0x2D0];
    if (!STACK[0x2D0]) {
      goto LABEL_4;
    }
    goto LABEL_10;
  }
  operator delete(a58);
  float v63 = (void *)STACK[0x2D0];
  if (!STACK[0x2D0])
  {
LABEL_4:
    if (SLOBYTE(STACK[0x547]) < 0) {
      goto LABEL_5;
    }
    goto LABEL_15;
  }
LABEL_10:
  STACK[0x2D8] = (unint64_t)v63;
  operator delete(v63);
  if (SLOBYTE(STACK[0x547]) < 0)
  {
LABEL_5:
    operator delete((void *)STACK[0x530]);
    if (STACK[0x548])
    {
      operator delete((void *)STACK[0x548]);
      if (STACK[0x560]) {
        JUMPOUT(0x19E520F5CLL);
      }
      JUMPOUT(0x19E52105CLL);
    }
    JUMPOUT(0x19E521054);
  }
LABEL_15:
  JUMPOUT(0x19E52104CLL);
}

void sub_19E520BB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *__p,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (__p) {
    operator delete(__p);
  }
  sub_19E4449B8(&a55);
  if (SLOBYTE(STACK[0x2CF]) < 0)
  {
    operator delete((void *)STACK[0x2B8]);
    if ((a63 & 0x80000000) == 0)
    {
      if (!STACK[0x2D0])
      {
        if (SLOBYTE(STACK[0x547]) < 0) {
          JUMPOUT(0x19E520F40);
        }
        JUMPOUT(0x19E52104CLL);
      }
      JUMPOUT(0x19E520F88);
    }
    JUMPOUT(0x19E520F78);
  }
  JUMPOUT(0x19E520F70);
}

void sub_19E520C28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,char a58)
{
  sub_19E3D73EC((uint64_t)&a58);
  if (a55)
  {
    (*(void (**)(uint64_t))(*(void *)a55 + 8))(a55);
    unsigned int v58 = (void *)STACK[0x2B8];
    if (!STACK[0x2B8]) {
      goto LABEL_13;
    }
  }
  else
  {
    unsigned int v58 = (void *)STACK[0x2B8];
    if (!STACK[0x2B8]) {
      goto LABEL_13;
    }
  }
  unint64_t v59 = STACK[0x2C0];
  if ((void *)STACK[0x2C0] != v58)
  {
    do
    {
      uint64_t v60 = *(std::__shared_weak_count **)(v59 - 16);
      if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
        std::__shared_weak_count::__release_weak(v60);
      }
      v59 -= 24;
    }
    while ((void *)v59 != v58);
    unsigned int v58 = (void *)STACK[0x2B8];
  }
  operator delete(v58);
LABEL_13:
  sub_19E4446FC((uint64_t)&STACK[0x2D0]);
  sub_19E4446FC((uint64_t)&STACK[0x400]);
  if ((SLOBYTE(STACK[0x547]) & 0x80000000) == 0)
  {
    if (!STACK[0x548])
    {
      if (!STACK[0x560]) {
        JUMPOUT(0x19E52105CLL);
      }
      JUMPOUT(0x19E520F5CLL);
    }
    JUMPOUT(0x19E520F50);
  }
  JUMPOUT(0x19E520F40);
}

void sub_19E520C38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58)
{
  if (SLOBYTE(STACK[0x2E7]) < 0) {
    operator delete((void *)STACK[0x2D0]);
  }
  sub_19E3D73EC((uint64_t)&a58);
  JUMPOUT(0x19E520CECLL);
}

void sub_19E520CFC()
{
  if (STACK[0x2D0]) {
    JUMPOUT(0x19E520F88);
  }
  JUMPOUT(0x19E520F38);
}

void sub_19E520D10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0) {
    JUMPOUT(0x19E520F78);
  }
  JUMPOUT(0x19E520F30);
}

void sub_19E520D2C()
{
  if (SLOBYTE(STACK[0x547]) < 0)
  {
    operator delete((void *)STACK[0x530]);
    if (STACK[0x548])
    {
      operator delete((void *)STACK[0x548]);
      if (STACK[0x560]) {
        JUMPOUT(0x19E520F5CLL);
      }
      JUMPOUT(0x19E52105CLL);
    }
    JUMPOUT(0x19E521054);
  }
  JUMPOUT(0x19E52104CLL);
}

void sub_19E520D3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  if (a57 < 0) {
    operator delete(a52);
  }
  sub_19E3D73EC(&a49);
  sub_19E4446FC(&a61);
  if (!STACK[0x2B8]) {
    JUMPOUT(0x19E521034);
  }
  JUMPOUT(0x19E520FC0);
}

void sub_19E520D44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  if (a57 < 0) {
    operator delete(a52);
  }
  sub_19E3D73EC(&a49);
  sub_19E4446FC(&a61);
  if (!STACK[0x2B8]) {
    JUMPOUT(0x19E521034);
  }
  JUMPOUT(0x19E520FC0);
}

void sub_19E520D4C()
{
}

void sub_19E520D54()
{
}

void sub_19E520D9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a63 < 0)
  {
    operator delete(a58);
    if (!STACK[0x2B8]) {
      goto LABEL_7;
    }
  }
  else if (!STACK[0x2B8])
  {
LABEL_7:
    JUMPOUT(0x19E521034);
  }
  JUMPOUT(0x19E520FC0);
}

void sub_19E520DB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  sub_19E4449B8(&a52);
  if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
    std::__shared_weak_count::__release_weak(v60);
  }
  if (a60 < 0) {
    JUMPOUT(0x19E520E40);
  }
  if (!STACK[0x2B8]) {
    JUMPOUT(0x19E521034);
  }
  JUMPOUT(0x19E520FC0);
}

void sub_19E520DC0()
{
}

void sub_19E520DC8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *__p,uint64_t a50,uint64_t a51,void *a52)
{
  if (__p) {
    operator delete(__p);
  }
  sub_19E4449B8(&a52);
  if (!v52) {
    JUMPOUT(0x19E520E34);
  }
  JUMPOUT(0x19E520DF4);
}

void sub_19E520DEC()
{
  if (v0) {
    JUMPOUT(0x19E520DF4);
  }
  JUMPOUT(0x19E520E34);
}

void sub_19E520E50(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,void *__p,uint64_t a56,int a57,__int16 a58,char a59,char a60,uint64_t a61)
{
  if (a60 < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(a54) < 0) {
    operator delete(a52);
  }
  sub_19E3D73EC((uint64_t)&a49);
  sub_19E4446FC((uint64_t)&a61);
  if (!STACK[0x2B8]) {
    JUMPOUT(0x19E521034);
  }
  JUMPOUT(0x19E520FC0);
}

void sub_19E520E90()
{
  uint64_t v0 = (void *)STACK[0x560];
  if (STACK[0x560])
  {
    STACK[0x568] = (unint64_t)v0;
    operator delete(v0);
    uint64_t v1 = (void *)STACK[0x578];
    if (!STACK[0x578]) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v1 = (void *)STACK[0x578];
    if (!STACK[0x578])
    {
LABEL_6:
      sub_19E4446FC(&STACK[0x590]);
      JUMPOUT(0x19E521070);
    }
  }
  operator delete(v1);
  goto LABEL_6;
}

void sub_19E520EA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  if (a52) {
    (*(void (**)(uint64_t))(*(void *)a52 + 8))(a52);
  }
  sub_19E4449B8(&a55);
  if (SLOBYTE(STACK[0x2CF]) < 0)
  {
    operator delete((void *)STACK[0x2B8]);
    if ((a63 & 0x80000000) == 0)
    {
      if (!STACK[0x2D0])
      {
        if (SLOBYTE(STACK[0x547]) < 0) {
          JUMPOUT(0x19E520F40);
        }
        JUMPOUT(0x19E52104CLL);
      }
      JUMPOUT(0x19E520F88);
    }
    JUMPOUT(0x19E520F78);
  }
  JUMPOUT(0x19E520F70);
}

void sub_19E520F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
}

void sub_19E520FB4()
{
  if (STACK[0x2B8]) {
    JUMPOUT(0x19E520FC0);
  }
  JUMPOUT(0x19E521034);
}

float *sub_19E521098(float *result, float *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t)result;
LABEL_2:
  unint64_t v10 = (float *)v9;
  while (1)
  {
    unint64_t v9 = (unint64_t)v10;
    uint64_t v11 = (char *)a2 - (char *)v10;
    uint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return result;
        case 2:
          float v88 = *(a2 - 1);
          float v89 = v10[1];
          if (v88 > v89)
          {
            float v90 = *v10;
            *unint64_t v10 = *(a2 - 2);
            *(a2 - 2) = v90;
            v10[1] = v88;
            *(a2 - 1) = v89;
          }
          return result;
        case 3:
          float v91 = v10[3];
          float v92 = v10[1];
          float v93 = *(a2 - 1);
          if (v91 <= v92)
          {
            if (v93 > v91)
            {
              int v141 = *((_DWORD *)v10 + 2);
              v10[2] = *(a2 - 2);
              *((_DWORD *)a2 - 2) = v141;
              v10[3] = v93;
              *(a2 - 1) = v91;
              float v98 = v10[3];
              float v104 = v10[1];
              if (v98 > v104)
              {
                int v142 = *(_DWORD *)v10;
                *unint64_t v10 = v10[2];
                *((_DWORD *)v10 + 2) = v142;
LABEL_165:
                v10[1] = v98;
                v10[3] = v104;
              }
            }
          }
          else
          {
            int v94 = *(_DWORD *)v10;
            if (v93 <= v91)
            {
              *unint64_t v10 = v10[2];
              *((_DWORD *)v10 + 2) = v94;
              v10[1] = v91;
              v10[3] = v92;
              float v149 = *(a2 - 1);
              if (v149 <= v92) {
                return result;
              }
              v10[2] = *(a2 - 2);
              *((_DWORD *)a2 - 2) = v94;
              v10[3] = v149;
            }
            else
            {
              *unint64_t v10 = *(a2 - 2);
              *((_DWORD *)a2 - 2) = v94;
              v10[1] = v93;
            }
            *(a2 - 1) = v92;
          }
          break;
        case 4:
          return sub_19E521C28(v10, v10 + 2, v10 + 4, a2 - 2);
        case 5:
          os_log_t result = sub_19E521C28(v10, v10 + 2, v10 + 4, v10 + 6);
          float v95 = *(a2 - 1);
          float v96 = v10[7];
          if (v95 <= v96) {
            return result;
          }
          int v97 = *((_DWORD *)v10 + 6);
          v10[6] = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v97;
          v10[7] = v95;
          *(a2 - 1) = v96;
          float v98 = v10[7];
          float v99 = v10[5];
          if (v98 <= v99) {
            return result;
          }
          int v100 = *((_DWORD *)v10 + 4);
          int v101 = *((_DWORD *)v10 + 6);
          *((_DWORD *)v10 + 4) = v101;
          *((_DWORD *)v10 + 6) = v100;
          v10[5] = v98;
          v10[7] = v99;
          float v102 = v10[3];
          if (v98 <= v102) {
            return result;
          }
          int v103 = *((_DWORD *)v10 + 2);
          *((_DWORD *)v10 + 2) = v101;
          *((_DWORD *)v10 + 4) = v103;
          v10[3] = v98;
          v10[5] = v102;
          float v104 = v10[1];
          if (v98 <= v104) {
            return result;
          }
          float v105 = *v10;
          *(_DWORD *)unint64_t v10 = v101;
          v10[2] = v105;
          goto LABEL_165;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v10 == a2) {
        return result;
      }
      int64_t v117 = (unint64_t)(v12 - 2) >> 1;
      int64_t v118 = v117;
      do
      {
        if (v117 >= v118)
        {
          uint64_t v120 = (2 * v118) | 1;
          uint64_t v121 = &v10[2 * v120];
          if (2 * v118 + 2 < v12 && v121[1] > v121[3])
          {
            v121 += 2;
            uint64_t v120 = 2 * v118 + 2;
          }
          uint64_t v122 = &v10[2 * v118];
          float v123 = v122[1];
          if (v121[1] <= v123)
          {
            int v124 = *(_DWORD *)v122;
            do
            {
              std::string::size_type v125 = v122;
              uint64_t v122 = v121;
              float *v125 = *v121;
              v125[1] = v121[1];
              if (v117 < v120) {
                break;
              }
              uint64_t v126 = 2 * v120;
              uint64_t v120 = (2 * v120) | 1;
              uint64_t v121 = &v10[2 * v120];
              uint64_t v127 = v126 + 2;
              if (v127 < v12 && v121[1] > v121[3])
              {
                v121 += 2;
                uint64_t v120 = v127;
              }
            }
            while (v121[1] <= v123);
            *(_DWORD *)uint64_t v122 = v124;
            v122[1] = v123;
          }
        }
        BOOL v119 = v118-- <= 0;
      }
      while (!v119);
      uint64_t v128 = (unint64_t)v11 >> 3;
      while (2)
      {
        uint64_t v129 = 0;
        float v130 = *v10;
        float v131 = v10[1];
        uint64_t v132 = v10;
        do
        {
          long long v133 = v132;
          v132 += 2 * v129 + 2;
          uint64_t v134 = 2 * v129;
          uint64_t v129 = (2 * v129) | 1;
          uint64_t v135 = v134 + 2;
          if (v135 < v128 && v132[1] > v132[3])
          {
            v132 += 2;
            uint64_t v129 = v135;
          }
          *long long v133 = *v132;
          v133[1] = v132[1];
        }
        while (v129 <= (uint64_t)((unint64_t)(v128 - 2) >> 1));
        if (v132 == a2 - 2)
        {
          *uint64_t v132 = v130;
          goto LABEL_147;
        }
        *uint64_t v132 = *(a2 - 2);
        v132[1] = *(a2 - 1);
        *(a2 - 2) = v130;
        *(a2 - 1) = v131;
        uint64_t v136 = (char *)v132 - (char *)v10 + 8;
        if (v136 >= 9)
        {
          unint64_t v137 = (((unint64_t)v136 >> 3) - 2) >> 1;
          size_t v138 = &v10[2 * v137];
          float v131 = v132[1];
          if (v138[1] > v131)
          {
            int v139 = *(_DWORD *)v132;
            do
            {
              unint64_t v140 = v132;
              uint64_t v132 = v138;
              *unint64_t v140 = *v138;
              v140[1] = v138[1];
              if (!v137) {
                break;
              }
              unint64_t v137 = (v137 - 1) >> 1;
              size_t v138 = &v10[2 * v137];
            }
            while (v138[1] > v131);
            *(_DWORD *)uint64_t v132 = v139;
LABEL_147:
            v132[1] = v131;
          }
        }
        a2 -= 2;
        BOOL v119 = v128-- <= 2;
        if (v119) {
          return result;
        }
        continue;
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    uint64_t v14 = &v10[2 * ((unint64_t)v12 >> 1)];
    float v15 = *(a2 - 1);
    if ((unint64_t)v11 < 0x401)
    {
      float v19 = v10[1];
      float v20 = v14[1];
      if (v19 > v20)
      {
        float v21 = *v14;
        if (v15 > v19)
        {
          *uint64_t v14 = *(a2 - 2);
          *(a2 - 2) = v21;
          v14[1] = v15;
          goto LABEL_32;
        }
        *uint64_t v14 = *v10;
        *unint64_t v10 = v21;
        v14[1] = v19;
        v10[1] = v20;
        float v41 = *(a2 - 1);
        if (v41 > v20)
        {
          *unint64_t v10 = *(a2 - 2);
          *(a2 - 2) = v21;
          v10[1] = v41;
LABEL_32:
          *(a2 - 1) = v20;
        }
LABEL_33:
        --a3;
        if ((a4 & 1) == 0) {
          goto LABEL_58;
        }
        goto LABEL_34;
      }
      if (v15 <= v19) {
        goto LABEL_33;
      }
      float v26 = *v10;
      *unint64_t v10 = *(a2 - 2);
      *(a2 - 2) = v26;
      v10[1] = v15;
      *(a2 - 1) = v19;
      float v27 = v10[1];
      float v28 = v14[1];
      if (v27 <= v28) {
        goto LABEL_33;
      }
      int v29 = *(_DWORD *)v14;
      *uint64_t v14 = *v10;
      *(_DWORD *)unint64_t v10 = v29;
      v14[1] = v27;
      v10[1] = v28;
      --a3;
      if ((a4 & 1) == 0) {
        goto LABEL_58;
      }
LABEL_34:
      float v42 = *v10;
      float v43 = v10[1];
LABEL_59:
      float v64 = v10;
      do
      {
        float v65 = v64;
        v64 += 2;
      }
      while (v65[3] > v43);
      unint64_t v66 = a2;
      if (v65 == v10)
      {
        unsigned int v69 = a2;
        while (v64 < v69)
        {
          unint64_t v67 = v69 - 2;
          float v70 = *(v69 - 1);
          v69 -= 2;
          if (v70 > v43) {
            goto LABEL_68;
          }
        }
        unint64_t v67 = v69;
      }
      else
      {
        do
        {
          unint64_t v67 = v66 - 2;
          float v68 = *(v66 - 1);
          v66 -= 2;
        }
        while (v68 <= v43);
      }
LABEL_68:
      unint64_t v10 = v64;
      if (v64 < v67)
      {
        uint64_t v71 = v67;
        do
        {
          float v72 = *v10;
          *unint64_t v10 = *v71;
          *uint64_t v71 = v72;
          int v73 = *((_DWORD *)v10 + 1);
          v10[1] = v71[1];
          *((_DWORD *)v71 + 1) = v73;
          do
          {
            float v74 = v10[3];
            v10 += 2;
          }
          while (v74 > v43);
          do
          {
            float v75 = *(v71 - 1);
            v71 -= 2;
          }
          while (v75 <= v43);
        }
        while (v10 < v71);
      }
      if (v10 - 2 != (float *)v9)
      {
        *(float *)unint64_t v9 = *(v10 - 2);
        *(float *)(v9 + 4) = *(v10 - 1);
      }
      *(v10 - 2) = v42;
      *(v10 - 1) = v43;
      if (v64 < v67) {
        goto LABEL_79;
      }
      BOOL v76 = sub_19E521D64((float *)v9, v10 - 2);
      os_log_t result = (float *)sub_19E521D64(v10, a2);
      if (result)
      {
        a2 = v10 - 2;
        if (v76) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v76)
      {
LABEL_79:
        os_log_t result = (float *)sub_19E521098(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      float v16 = v14[1];
      float v17 = v10[1];
      if (v16 <= v17)
      {
        if (v15 > v16)
        {
          int v22 = *(_DWORD *)v14;
          *uint64_t v14 = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v22;
          v14[1] = v15;
          *(a2 - 1) = v16;
          float v23 = v14[1];
          float v24 = v10[1];
          if (v23 > v24)
          {
            float v25 = *v10;
            *unint64_t v10 = *v14;
            *uint64_t v14 = v25;
            v10[1] = v23;
            v14[1] = v24;
          }
        }
      }
      else
      {
        float v18 = *v10;
        if (v15 <= v16)
        {
          *unint64_t v10 = *v14;
          *uint64_t v14 = v18;
          v10[1] = v16;
          v14[1] = v17;
          float v30 = *(a2 - 1);
          if (v30 <= v17) {
            goto LABEL_24;
          }
          *uint64_t v14 = *(a2 - 2);
          *(a2 - 2) = v18;
          v14[1] = v30;
        }
        else
        {
          *unint64_t v10 = *(a2 - 2);
          *(a2 - 2) = v18;
          v10[1] = v15;
        }
        *(a2 - 1) = v17;
      }
LABEL_24:
      BOOL v31 = &v10[2 * v13];
      unsigned int v32 = v31 - 2;
      float v33 = *(v31 - 1);
      float v34 = v10[3];
      float v35 = *(a2 - 3);
      if (v33 <= v34)
      {
        if (v35 > v33)
        {
          float v37 = *v32;
          float *v32 = *(a2 - 4);
          *(a2 - 4) = v37;
          v32[1] = v35;
          *(a2 - 3) = v33;
          float v38 = v32[1];
          float v39 = v10[3];
          if (v38 > v39)
          {
            int v40 = *((_DWORD *)v10 + 2);
            v10[2] = *v32;
            *(_DWORD *)unsigned int v32 = v40;
            v10[3] = v38;
            v32[1] = v39;
          }
        }
      }
      else
      {
        int v36 = *((_DWORD *)v10 + 2);
        if (v35 <= v33)
        {
          v10[2] = *v32;
          *(_DWORD *)unsigned int v32 = v36;
          v10[3] = v33;
          v32[1] = v34;
          float v44 = *(a2 - 3);
          if (v44 <= v34) {
            goto LABEL_38;
          }
          float *v32 = *(a2 - 4);
          *((_DWORD *)a2 - 4) = v36;
          v32[1] = v44;
        }
        else
        {
          v10[2] = *(a2 - 4);
          *((_DWORD *)a2 - 4) = v36;
          v10[3] = v35;
        }
        *(a2 - 3) = v34;
      }
LABEL_38:
      unint64_t v45 = &v10[2 * v13];
      int v46 = v45 + 2;
      float v47 = v45[3];
      float v48 = v10[5];
      float v49 = *(a2 - 5);
      if (v47 <= v48)
      {
        if (v49 > v47)
        {
          float v51 = *v46;
          *int v46 = *(a2 - 6);
          *(a2 - 6) = v51;
          v46[1] = v49;
          *(a2 - 5) = v47;
          float v52 = v46[1];
          float v53 = v10[5];
          if (v52 > v53)
          {
            int v54 = *((_DWORD *)v10 + 4);
            v10[4] = *v46;
            *(_DWORD *)int v46 = v54;
            v10[5] = v52;
            v46[1] = v53;
          }
        }
      }
      else
      {
        int v50 = *((_DWORD *)v10 + 4);
        if (v49 <= v47)
        {
          v10[4] = *v46;
          *(_DWORD *)int v46 = v50;
          v10[5] = v47;
          v46[1] = v48;
          float v55 = *(a2 - 5);
          if (v55 <= v48) {
            goto LABEL_47;
          }
          *int v46 = *(a2 - 6);
          *((_DWORD *)a2 - 6) = v50;
          v46[1] = v55;
        }
        else
        {
          v10[4] = *(a2 - 6);
          *((_DWORD *)a2 - 6) = v50;
          v10[5] = v49;
        }
        *(a2 - 5) = v48;
      }
LABEL_47:
      float v56 = v14[1];
      float v57 = v32[1];
      float v58 = v46[1];
      if (v56 <= v57)
      {
        float v59 = *v14;
        if (v58 > v56)
        {
          float v60 = *v46;
          *uint64_t v14 = *v46;
          *int v46 = v59;
          v14[1] = v58;
          v46[1] = v56;
          if (v58 > v57)
          {
            float v59 = *v32;
            float *v32 = v60;
            *uint64_t v14 = v59;
            v32[1] = v58;
            v14[1] = v57;
          }
          else
          {
            float v57 = v58;
            float v59 = v60;
          }
        }
        else
        {
          float v57 = v14[1];
        }
      }
      else
      {
        float v59 = *v32;
        if (v58 <= v56)
        {
          float *v32 = *v14;
          *uint64_t v14 = v59;
          v32[1] = v56;
          v14[1] = v57;
          if (v58 > v57)
          {
            float v61 = *v46;
            *uint64_t v14 = *v46;
            *int v46 = v59;
            v14[1] = v58;
            v46[1] = v57;
            float v57 = v58;
            float v59 = v61;
          }
        }
        else
        {
          float *v32 = *v46;
          *int v46 = v59;
          v32[1] = v58;
          v46[1] = v57;
          float v59 = *v14;
          float v57 = v56;
        }
      }
      float v62 = *v10;
      *unint64_t v10 = v59;
      *uint64_t v14 = v62;
      float v63 = v10[1];
      v10[1] = v57;
      v10[2 * v13 + 1] = v63;
      --a3;
      if (a4) {
        goto LABEL_34;
      }
LABEL_58:
      float v43 = v10[1];
      float v42 = *v10;
      if (*(v10 - 1) > v43) {
        goto LABEL_59;
      }
      if (v43 > *(a2 - 1))
      {
        uint64_t v77 = v10;
        do
        {
          unint64_t v10 = v77 + 2;
          float v78 = v77[3];
          v77 += 2;
        }
        while (v43 <= v78);
      }
      else
      {
        int v79 = v10 + 2;
        do
        {
          unint64_t v10 = v79;
          if (v79 >= a2) {
            break;
          }
          float v80 = v79[1];
          v79 += 2;
        }
        while (v43 <= v80);
      }
      long long v81 = a2;
      if (v10 < a2)
      {
        long long v82 = a2;
        do
        {
          long long v81 = v82 - 2;
          float v83 = *(v82 - 1);
          v82 -= 2;
        }
        while (v43 > v83);
      }
      while (v10 < v81)
      {
        float v84 = *v10;
        *unint64_t v10 = *v81;
        float *v81 = v84;
        int v85 = *((_DWORD *)v10 + 1);
        v10[1] = v81[1];
        *((_DWORD *)v81 + 1) = v85;
        do
        {
          float v86 = v10[3];
          v10 += 2;
        }
        while (v43 <= v86);
        do
        {
          float v87 = *(v81 - 1);
          v81 -= 2;
        }
        while (v43 > v87);
      }
      BOOL v4 = (unint64_t)(v10 - 2) >= v9;
      BOOL v5 = v10 - 2 == (float *)v9;
      if (v10 - 2 != (float *)v9)
      {
        *(float *)unint64_t v9 = *(v10 - 2);
        *(float *)(v9 + 4) = *(v10 - 1);
      }
      a4 = 0;
      *(v10 - 2) = v42;
      *(v10 - 1) = v43;
    }
  }
  unsigned int v106 = v10 + 2;
  BOOL v108 = v10 == a2 || v106 == a2;
  if (a4)
  {
    if (!v108)
    {
      uint64_t v109 = 0;
      int64_t v110 = v10;
      do
      {
        float v112 = v110[3];
        float v113 = v110[1];
        int64_t v110 = v106;
        if (v112 > v113)
        {
          int v114 = *(_DWORD *)v106;
          uint64_t v115 = v109;
          do
          {
            float32x4_t v116 = (float *)((char *)v10 + v115);
            v116[2] = *(float *)((char *)v10 + v115);
            v116[3] = *(float *)((char *)v10 + v115 + 4);
            if (!v115)
            {
              uint64_t v111 = (uint64_t)v10;
              goto LABEL_124;
            }
            v115 -= 8;
          }
          while (v112 > *(v116 - 1));
          uint64_t v111 = (uint64_t)v10 + v115 + 8;
LABEL_124:
          *(_DWORD *)uint64_t v111 = v114;
          *(float *)(v111 + 4) = v112;
        }
        unsigned int v106 = v110 + 2;
        v109 += 8;
      }
      while (v110 + 2 != a2);
    }
  }
  else if (!v108)
  {
    uint64_t v143 = v10 + 1;
    do
    {
      float v144 = *(float *)(v9 + 12);
      float v145 = *(float *)(v9 + 4);
      unint64_t v9 = (unint64_t)v106;
      if (v144 > v145)
      {
        int v146 = *(_DWORD *)v106;
        int v147 = v143;
        do
        {
          v147[1] = *(v147 - 1);
          v147[2] = *v147;
          float v148 = *(v147 - 2);
          v147 -= 2;
        }
        while (v144 > v148);
        *((_DWORD *)v147 + 1) = v146;
        v147[2] = v144;
      }
      unsigned int v106 = (float *)(v9 + 8);
      v143 += 2;
    }
    while ((float *)(v9 + 8) != a2);
  }
  return result;
}

float *sub_19E521C28(float *result, float *a2, float *a3, float *a4)
{
  float v4 = a2[1];
  float v5 = result[1];
  float v6 = a3[1];
  if (v4 <= v5)
  {
    if (v6 <= v4)
    {
      float v4 = a3[1];
    }
    else
    {
      float v8 = *a2;
      *a2 = *a3;
      *a3 = v8;
      a2[1] = v6;
      a3[1] = v4;
      float v9 = a2[1];
      float v10 = result[1];
      if (v9 > v10)
      {
        float v11 = *result;
        void *result = *a2;
        *a2 = v11;
        result[1] = v9;
        a2[1] = v10;
        float v4 = a3[1];
      }
    }
  }
  else
  {
    float v7 = *result;
    if (v6 > v4)
    {
      void *result = *a3;
      *a3 = v7;
      result[1] = v6;
LABEL_9:
      a3[1] = v5;
      float v4 = v5;
      goto LABEL_11;
    }
    void *result = *a2;
    *a2 = v7;
    result[1] = v4;
    a2[1] = v5;
    float v4 = a3[1];
    if (v4 > v5)
    {
      *a2 = *a3;
      *a3 = v7;
      a2[1] = v4;
      goto LABEL_9;
    }
  }
LABEL_11:
  float v12 = a4[1];
  if (v12 > v4)
  {
    float v13 = *a3;
    *a3 = *a4;
    *a4 = v13;
    a3[1] = v12;
    a4[1] = v4;
    float v14 = a3[1];
    float v15 = a2[1];
    if (v14 > v15)
    {
      float v16 = *a2;
      *a2 = *a3;
      *a3 = v16;
      a2[1] = v14;
      a3[1] = v15;
      float v17 = a2[1];
      float v18 = result[1];
      if (v17 > v18)
      {
        float v19 = *result;
        void *result = *a2;
        *a2 = v19;
        result[1] = v17;
        a2[1] = v18;
      }
    }
  }
  return result;
}

BOOL sub_19E521D64(float *a1, float *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *(a2 - 1);
      float v7 = a1[1];
      if (v6 > v7)
      {
        float v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        a1[1] = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      float v9 = a1[3];
      float v10 = a1[1];
      float v11 = *(a2 - 1);
      if (v9 <= v10)
      {
        if (v11 > v9)
        {
          int v30 = *((_DWORD *)a1 + 2);
          a1[2] = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v30;
          a1[3] = v11;
          *(a2 - 1) = v9;
          float v31 = a1[3];
          float v32 = a1[1];
          if (v31 > v32)
          {
            int v33 = *(_DWORD *)a1;
            *a1 = a1[2];
            *((_DWORD *)a1 + 2) = v33;
            a1[1] = v31;
            a1[3] = v32;
          }
        }
      }
      else
      {
        int v12 = *(_DWORD *)a1;
        if (v11 <= v9)
        {
          *a1 = a1[2];
          *((_DWORD *)a1 + 2) = v12;
          a1[1] = v9;
          a1[3] = v10;
          float v37 = *(a2 - 1);
          if (v37 > v10)
          {
            a1[2] = *(a2 - 2);
            *((_DWORD *)a2 - 2) = v12;
            a1[3] = v37;
            *(a2 - 1) = v10;
          }
        }
        else
        {
          *a1 = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v12;
          a1[1] = v11;
          *(a2 - 1) = v10;
        }
      }
      return result;
    case 4:
      sub_19E521C28(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_19E521C28(a1, a1 + 2, a1 + 4, a1 + 6);
      float v19 = *(a2 - 1);
      float v20 = a1[7];
      if (v19 > v20)
      {
        int v21 = *((_DWORD *)a1 + 6);
        a1[6] = *(a2 - 2);
        *((_DWORD *)a2 - 2) = v21;
        a1[7] = v19;
        *(a2 - 1) = v20;
        float v22 = a1[7];
        float v23 = a1[5];
        if (v22 > v23)
        {
          int v24 = *((_DWORD *)a1 + 4);
          int v25 = *((_DWORD *)a1 + 6);
          *((_DWORD *)a1 + 4) = v25;
          *((_DWORD *)a1 + 6) = v24;
          a1[5] = v22;
          a1[7] = v23;
          float v26 = a1[3];
          if (v22 > v26)
          {
            int v27 = *((_DWORD *)a1 + 2);
            *((_DWORD *)a1 + 2) = v25;
            *((_DWORD *)a1 + 4) = v27;
            a1[3] = v22;
            a1[5] = v26;
            float v28 = a1[1];
            if (v22 > v28)
            {
              float v29 = *a1;
              *(_DWORD *)a1 = v25;
              a1[2] = v29;
              a1[1] = v22;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      float v13 = a1[1];
      float v14 = a1 + 3;
      float v15 = a1[3];
      float v16 = a1[5];
      if (v15 > v13)
      {
        float v17 = *a1;
        if (v16 <= v15)
        {
          *a1 = a1[2];
          a1[2] = v17;
          a1[1] = v15;
          a1[3] = v13;
          if (v16 <= v13) {
            goto LABEL_28;
          }
          a1[2] = a1[4];
          a1[4] = v17;
          float v18 = a1 + 3;
        }
        else
        {
          *a1 = a1[4];
          a1[4] = v17;
          float v18 = a1 + 1;
        }
        float v14 = a1 + 5;
        goto LABEL_27;
      }
      if (v16 > v15)
      {
        int v34 = *((_DWORD *)a1 + 2);
        int v35 = *((_DWORD *)a1 + 4);
        *((_DWORD *)a1 + 2) = v35;
        *((_DWORD *)a1 + 4) = v34;
        a1[3] = v16;
        a1[5] = v15;
        if (v16 > v13)
        {
          float v36 = *a1;
          *(_DWORD *)a1 = v35;
          a1[2] = v36;
          float v18 = a1 + 1;
LABEL_27:
          float *v18 = v16;
          *float v14 = v13;
        }
      }
LABEL_28:
      float v38 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v39 = 0;
      int v40 = 0;
      float v41 = a1 + 4;
      while (1)
      {
        float v43 = v38[1];
        if (v43 > v41[1])
        {
          int v44 = *(_DWORD *)v38;
          uint64_t v45 = v39;
          do
          {
            int v46 = (float *)((char *)a1 + v45);
            v46[6] = *(float *)((char *)a1 + v45 + 16);
            v46[7] = *(float *)((char *)a1 + v45 + 20);
            if (v45 == -16)
            {
              uint64_t v42 = (uint64_t)a1;
              goto LABEL_31;
            }
            v45 -= 8;
          }
          while (v43 > v46[3]);
          uint64_t v42 = (uint64_t)a1 + v45 + 24;
LABEL_31:
          *(_DWORD *)uint64_t v42 = v44;
          *(float *)(v42 + 4) = v43;
          if (++v40 == 8) {
            return v38 + 2 == a2;
          }
        }
        float v41 = v38;
        v39 += 8;
        v38 += 2;
        if (v38 == a2) {
          return 1;
        }
      }
  }
}

void sub_19E5220E0(void *a1)
{
  sub_19E44DA2C(a1);
  JUMPOUT(0x19F3BDCF0);
}

__CFDictionary *sub_19E52211C(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  v309 = Mutable;
  uint64_t v4 = (const void *)language_modeling::v1::kLocaleIdentifierOptionKey;
  size_t v5 = strlen((const char *)language_modeling::v1::kLocaleIdentifierOptionKey);
  if (v5 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_513;
  }
  std::string::size_type v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (std::string *)operator new(v8 + 1);
    __dst.__r_.__value_.__l.__size_ = v6;
    __dst.__r_.__value_.__r.__words[2] = v9 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v5;
  p_dst = &__dst;
  if (v5) {
LABEL_8:
  }
    memmove(p_dst, v4, v6);
  p_dst->__r_.__value_.__s.__data_[v6] = 0;
  float v10 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  unint64_t v308 = (uint64_t *)(a1 + 8);
  if ((uint64_t *)(a1 + 8) != v10)
  {
    if (*((_DWORD *)v10 + 20) != 1) {
      sub_19E3D72EC();
    }
    if (*((char *)v10 + 79) < 0) {
      sub_19E39369C(&__dst, (void *)v10[7], v10[8]);
    }
    else {
      std::string __dst = *(std::string *)(v10 + 7);
    }
    unsigned __int8 v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      float v13 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      if (__dst.__r_.__value_.__l.__size_ >= 3) {
        std::string::size_type size = 3;
      }
      else {
        std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      }
    }
    else
    {
      if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) >= 3u) {
        std::string::size_type size = 3;
      }
      else {
        std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
      }
      float v13 = &__dst;
    }
    int v14 = memcmp(v13, "ars", size);
    if (size >= 3 && !v14)
    {
      std::string::replace(&__dst, 0, 3uLL, "ar", 2uLL);
      unsigned __int8 v11 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
    }
    float v15 = (const void *)kLMLanguageModelLocaleKey;
    if ((v11 & 0x80u) == 0) {
      float v16 = &__dst;
    }
    else {
      float v16 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    }
    if (v16)
    {
      if ((v11 & 0x80u) == 0) {
        std::string::size_type v17 = v11;
      }
      else {
        std::string::size_type v17 = __dst.__r_.__value_.__l.__size_;
      }
      float v18 = (__CFString *)CFStringCreateWithBytes(0, (const UInt8 *)v16, v17, 0x8000100u, 0);
      value.isa = v18;
      if (!v18)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      float v18 = 0;
      value.isa = 0;
    }
    CFDictionaryAddValue(Mutable, v15, v18);
    if (v18) {
      CFRelease(v18);
    }
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__dst.__r_.__value_.__l.__data_);
    }
  }
  float v20 = (const void *)language_modeling::v1::kLanguageLocalesOptionKey;
  size_t v21 = strlen((const char *)language_modeling::v1::kLanguageLocalesOptionKey);
  if (v21 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_513;
  }
  float v22 = (const void *)v21;
  if (v21 >= 0x17)
  {
    uint64_t v24 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v21 | 7) != 0x17) {
      uint64_t v24 = v21 | 7;
    }
    uint64_t v25 = v24 + 1;
    float v23 = operator new(v24 + 1);
    cf[1] = v22;
    unint64_t v311 = v25 | 0x8000000000000000;
    cf[0] = v23;
  }
  else
  {
    HIBYTE(v311) = v21;
    float v23 = cf;
    if (!v21) {
      goto LABEL_49;
    }
  }
  memmove(v23, v20, (size_t)v22);
LABEL_49:
  *((unsigned char *)v22 + (void)v23) = 0;
  uint64_t v26 = kLMLanguageLocalesKey;
  int v27 = sub_19E374C3C(a1, cf);
  if (v308 == v27) {
    goto LABEL_150;
  }
  if (*((_DWORD *)v27 + 20) != 1) {
    sub_19E3D72EC();
  }
  if (*((char *)v27 + 79) < 0)
  {
    sub_19E39369C(&value, (void *)v27[7], v27[8]);
  }
  else
  {
    *(_OWORD *)&value.isa = *(_OWORD *)(v27 + 7);
    value.data = (char *)v27[9];
  }
  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 1;
  LOWORD(__p.__r_.__value_.__l.__data_) = 44;
  sub_19E439DAC((uint64_t)&__dst, &value.isa, (unsigned __int8 *)&__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  unint64_t v306 = (const void *)v26;
  v307 = Mutable;
  CFAllocatorRef v305 = v2;
  if (SHIBYTE(value.data) < 0) {
    operator delete(value.isa);
  }
  memset(&value, 0, 24);
  std::string::size_type v28 = __dst.__r_.__value_.__l.__size_;
  std::string::size_type v29 = __dst.__r_.__value_.__r.__words[0];
  if (__dst.__r_.__value_.__r.__words[0] == __dst.__r_.__value_.__l.__size_)
  {
    float v31 = 0;
    float v60 = 0;
    float v65 = 0;
    unint64_t v66 = 0;
    BOOL v62 = 1;
    float v64 = v306;
    float v63 = v307;
    goto LABEL_132;
  }
  uint64_t v304 = a1;
  int v30 = 0;
  float v31 = 0;
  do
  {
    if (*(char *)(v29 + 23) < 0)
    {
      sub_19E39369C(&__p, *(void **)v29, *(void *)(v29 + 8));
    }
    else
    {
      long long v32 = *(_OWORD *)v29;
      __p.__r_.__value_.__r.__words[2] = *(void *)(v29 + 16);
      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v32;
    }
    unsigned __int8 v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__l.__size_ >= 3) {
        std::string::size_type v34 = 3;
      }
      else {
        std::string::size_type v34 = __p.__r_.__value_.__l.__size_;
      }
    }
    else
    {
      if (HIBYTE(__p.__r_.__value_.__r.__words[2]) >= 3u) {
        std::string::size_type v34 = 3;
      }
      else {
        std::string::size_type v34 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      }
      p_p = &__p;
    }
    int v36 = memcmp(p_p, "ars", v34);
    if (v34 >= 3 && v36 == 0)
    {
      std::string::replace(&__p, 0, 3uLL, "ar", 2uLL);
      unsigned __int8 v33 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    }
    if ((v33 & 0x80u) == 0) {
      float v38 = &__p;
    }
    else {
      float v38 = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v38)
    {
      if ((v33 & 0x80u) == 0) {
        std::string::size_type v39 = v33;
      }
      else {
        std::string::size_type v39 = __p.__r_.__value_.__l.__size_;
      }
      CFStringRef v40 = CFStringCreateWithBytes(0, (const UInt8 *)v38, v39, 0x8000100u, 0);
      value.length = (uint64_t)v40;
      if (!v40)
      {
        v300 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v300, "Could not construct");
        __cxa_throw(v300, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      CFStringRef v40 = 0;
      value.length = 0;
    }
    if (v31 < value.data)
    {
      *(void *)float v31 = v40;
      v31 += 8;
      value.uint64_t info = (uint64_t)v31;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_61;
      }
LABEL_113:
      operator delete(__p.__r_.__value_.__l.__data_);
      goto LABEL_61;
    }
    uint64_t v41 = (v31 - v30) >> 3;
    unint64_t v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v43 = value.data - v30;
    if ((value.data - v30) >> 2 > v42) {
      unint64_t v42 = v43 >> 2;
    }
    if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v44 = v42;
    }
    if (v44)
    {
      if (v44 >> 61) {
        sub_19E37C2B8();
      }
      unint64_t v45 = v44;
      int v46 = (char *)operator new(8 * v44);
      unint64_t v44 = v45;
    }
    else
    {
      int v46 = 0;
    }
    float v47 = &v46[8 * v41];
    *(void *)float v47 = v40;
    uint64_t v48 = (uint64_t)(v47 + 8);
    value.length = 0;
    if (v31 != v30)
    {
      unint64_t v49 = v31 - v30 - 8;
      if (v49 < 0x78
        || &v46[v31 - v30 - (v49 & 0xFFFFFFFFFFFFFFF8) - 8] < v31 && &v31[-(v49 & 0xFFFFFFFFFFFFFFF8) - 8] < v47)
      {
        goto LABEL_104;
      }
      uint64_t v55 = (v49 >> 3) + 1;
      v47 -= 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
      float v56 = v31 - 32;
      float v57 = &v46[8 * v41 - 16];
      uint64_t v58 = v55 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v59 = *((_OWORD *)v56 + 1);
        *((_OWORD *)v57 - 1) = *(_OWORD *)v56;
        *(_OWORD *)float v57 = v59;
        *(_OWORD *)float v56 = 0uLL;
        *((_OWORD *)v56 + 1) = 0uLL;
        v56 -= 32;
        v57 -= 32;
        v58 -= 4;
      }
      while (v58);
      if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
      {
        v31 -= 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
        do
        {
LABEL_104:
          uint64_t v50 = *((void *)v31 - 1);
          v31 -= 8;
          *((void *)v47 - 1) = v50;
          v47 -= 8;
          *(void *)float v31 = 0;
        }
        while (v31 != v30);
      }
    }
    isa = value.isa;
    uint64_t info = value.info;
    value.isa = v47;
    value.uint64_t info = v48;
    value.data = &v46[8 * v44];
    while ((void *)info != isa)
    {
      int v54 = *(const void **)(info - 8);
      info -= 8;
      float v53 = v54;
      if (v54) {
        CFRelease(v53);
      }
    }
    if (isa) {
      operator delete(isa);
    }
    value.uint64_t info = v48;
    if (value.length)
    {
      CFRelease((CFTypeRef)value.length);
      int v30 = v47;
      float v31 = (char *)v48;
      if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_61;
      }
      goto LABEL_113;
    }
    int v30 = v47;
    float v31 = (char *)v48;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_113;
    }
LABEL_61:
    v29 += 24;
  }
  while (v29 != v28);
  float v60 = (char *)value.isa;
  size_t v61 = v31 - (char *)value.isa;
  BOOL v62 = v31 == value.isa;
  float v64 = v306;
  float v63 = v307;
  if (v31 == value.isa)
  {
    float v65 = 0;
    unint64_t v66 = 0;
    a1 = v304;
  }
  else
  {
    a1 = v304;
    if ((v61 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    float v65 = (char *)operator new(v31 - (char *)value.isa);
    bzero(v65, v61);
    unint64_t v66 = &v65[v61];
    unint64_t v67 = v65;
    float v68 = v60;
    if (v61 - 8 < 0x18 || (v67 = v65, float v68 = v60, (unint64_t)(v65 - v60) < 0x20))
    {
      do
      {
LABEL_128:
        uint64_t v75 = *(void *)v68;
        v68 += 8;
        *(void *)unint64_t v67 = v75;
        v67 += 8;
      }
      while (v68 != v31);
    }
    else
    {
      uint64_t v69 = 0;
      unint64_t v70 = ((v61 - 8) >> 3) + 1;
      uint64_t v71 = 8 * (v70 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v67 = &v65[v71];
      uint64_t v72 = v70 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        int v73 = &v65[v69];
        long long v74 = *(_OWORD *)&v60[v69 + 16];
        *(_OWORD *)int v73 = *(_OWORD *)&v60[v69];
        *((_OWORD *)v73 + 1) = v74;
        v69 += 32;
        v72 -= 4;
      }
      while (v72);
      if (v70 != (v70 & 0x3FFFFFFFFFFFFFFCLL))
      {
        float v68 = &v60[v71];
        goto LABEL_128;
      }
    }
  }
LABEL_132:
  CFArrayRef v76 = CFArrayCreate(0, (const void **)v65, (v66 - v65) >> 3, MEMORY[0x1E4F1D510]);
  if (!v76)
  {
    uint64_t v302 = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](v302, "Could not construct");
    __cxa_throw(v302, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
  if (v65) {
    operator delete(v65);
  }
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v76;
  CFDictionarySetValue(v63, v64, v76);
  CFRelease(v76);
  if (v60)
  {
    if (!v62)
    {
      do
      {
        long long v81 = (const void *)*((void *)v31 - 1);
        v31 -= 8;
        float v80 = v81;
        if (v81) {
          CFRelease(v80);
        }
      }
      while (v31 != v60);
    }
    operator delete(v60);
  }
  std::string::size_type v77 = __dst.__r_.__value_.__r.__words[0];
  if (__dst.__r_.__value_.__r.__words[0])
  {
    std::string::size_type v78 = __dst.__r_.__value_.__l.__size_;
    int v79 = (void *)__dst.__r_.__value_.__r.__words[0];
    if (__dst.__r_.__value_.__l.__size_ != __dst.__r_.__value_.__r.__words[0])
    {
      do
      {
        if (*(char *)(v78 - 1) < 0) {
          operator delete(*(void **)(v78 - 24));
        }
        v78 -= 24;
      }
      while (v78 != v77);
      int v79 = (void *)__dst.__r_.__value_.__r.__words[0];
    }
    __dst.__r_.__value_.__l.__size_ = v77;
    operator delete(v79);
  }
  CFAllocatorRef v2 = v305;
LABEL_150:
  if (SHIBYTE(v311) < 0) {
    operator delete((void *)cf[0]);
  }
  long long v82 = (const void *)language_modeling::v1::kEnableMultilingualDynamicOptionKey;
  size_t v83 = strlen((const char *)language_modeling::v1::kEnableMultilingualDynamicOptionKey);
  if (v83 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v84 = v83;
  if (v83 >= 0x17)
  {
    uint64_t v86 = (v83 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v83 | 7) != 0x17) {
      uint64_t v86 = v83 | 7;
    }
    uint64_t v87 = v86 + 1;
    int v85 = (std::string *)operator new(v86 + 1);
    __dst.__r_.__value_.__l.__size_ = v84;
    __dst.__r_.__value_.__r.__words[2] = v87 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v85;
    goto LABEL_159;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v83;
  int v85 = &__dst;
  if (v83) {
LABEL_159:
  }
    memmove(v85, v82, v84);
  v85->__r_.__value_.__s.__data_[v84] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMEnableMultilingualDynamicKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  float v88 = (const void *)language_modeling::v1::kMultilingualDynamicSeparateLexiconPerLocaleOptionKey;
  size_t v89 = strlen((const char *)language_modeling::v1::kMultilingualDynamicSeparateLexiconPerLocaleOptionKey);
  if (v89 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v90 = v89;
  if (v89 >= 0x17)
  {
    uint64_t v92 = (v89 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v89 | 7) != 0x17) {
      uint64_t v92 = v89 | 7;
    }
    uint64_t v93 = v92 + 1;
    float v91 = (std::string *)operator new(v92 + 1);
    __dst.__r_.__value_.__l.__size_ = v90;
    __dst.__r_.__value_.__r.__words[2] = v93 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v91;
    goto LABEL_169;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v89;
  float v91 = &__dst;
  if (v89) {
LABEL_169:
  }
    memmove(v91, v88, v90);
  v91->__r_.__value_.__s.__data_[v90] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMMultilingualDynamicSeparateLexiconPerLocaleKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  int v94 = (const void *)language_modeling::v1::kIsMultilingualModelOptionKey;
  size_t v95 = strlen((const char *)language_modeling::v1::kIsMultilingualModelOptionKey);
  if (v95 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v96 = v95;
  if (v95 >= 0x17)
  {
    uint64_t v98 = (v95 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v95 | 7) != 0x17) {
      uint64_t v98 = v95 | 7;
    }
    uint64_t v99 = v98 + 1;
    int v97 = (std::string *)operator new(v98 + 1);
    __dst.__r_.__value_.__l.__size_ = v96;
    __dst.__r_.__value_.__r.__words[2] = v99 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v97;
    goto LABEL_179;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v95;
  int v97 = &__dst;
  if (v95) {
LABEL_179:
  }
    memmove(v97, v94, v96);
  v97->__r_.__value_.__s.__data_[v96] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelIsMultilingualModelKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  int v100 = (const void *)language_modeling::v1::kIsSiriModelOptionKey;
  size_t v101 = strlen((const char *)language_modeling::v1::kIsSiriModelOptionKey);
  if (v101 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v102 = v101;
  if (v101 >= 0x17)
  {
    uint64_t v104 = (v101 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v101 | 7) != 0x17) {
      uint64_t v104 = v101 | 7;
    }
    uint64_t v105 = v104 + 1;
    int v103 = (std::string *)operator new(v104 + 1);
    __dst.__r_.__value_.__l.__size_ = v102;
    __dst.__r_.__value_.__r.__words[2] = v105 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v103;
    goto LABEL_189;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v101;
  int v103 = &__dst;
  if (v101) {
LABEL_189:
  }
    memmove(v103, v100, v102);
  v103->__r_.__value_.__s.__data_[v102] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelIsSiriModelKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  unsigned int v106 = (const void *)language_modeling::v1::kEnableAdaptationOptionKey;
  size_t v107 = strlen((const char *)language_modeling::v1::kEnableAdaptationOptionKey);
  if (v107 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v108 = v107;
  if (v107 >= 0x17)
  {
    uint64_t v110 = (v107 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v107 | 7) != 0x17) {
      uint64_t v110 = v107 | 7;
    }
    uint64_t v111 = v110 + 1;
    uint64_t v109 = (std::string *)operator new(v110 + 1);
    __dst.__r_.__value_.__l.__size_ = v108;
    __dst.__r_.__value_.__r.__words[2] = v111 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v109;
    goto LABEL_199;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v107;
  uint64_t v109 = &__dst;
  if (v107) {
LABEL_199:
  }
    memmove(v109, v106, v108);
  v109->__r_.__value_.__s.__data_[v108] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelAdaptationEnabledKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  float v112 = (const void *)language_modeling::v1::kEnableNeuralLanguageModelOptionKey;
  size_t v113 = strlen((const char *)language_modeling::v1::kEnableNeuralLanguageModelOptionKey);
  if (v113 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v114 = v113;
  if (v113 >= 0x17)
  {
    uint64_t v116 = (v113 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v113 | 7) != 0x17) {
      uint64_t v116 = v113 | 7;
    }
    uint64_t v117 = v116 + 1;
    uint64_t v115 = (std::string *)operator new(v116 + 1);
    __dst.__r_.__value_.__l.__size_ = v114;
    __dst.__r_.__value_.__r.__words[2] = v117 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v115;
    goto LABEL_209;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v113;
  uint64_t v115 = &__dst;
  if (v113) {
LABEL_209:
  }
    memmove(v115, v112, v114);
  v115->__r_.__value_.__s.__data_[v114] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelUseMontrealKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  int64_t v118 = (const void *)language_modeling::v1::kDynamicLexiconNameOptionKey;
  size_t v119 = strlen((const char *)language_modeling::v1::kDynamicLexiconNameOptionKey);
  if (v119 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v120 = v119;
  if (v119 >= 0x17)
  {
    uint64_t v122 = (v119 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v119 | 7) != 0x17) {
      uint64_t v122 = v119 | 7;
    }
    uint64_t v123 = v122 + 1;
    uint64_t v121 = (std::string *)operator new(v122 + 1);
    __dst.__r_.__value_.__l.__size_ = v120;
    __dst.__r_.__value_.__r.__words[2] = v123 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v121;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v119;
    uint64_t v121 = &__dst;
    if (!v119) {
      goto LABEL_220;
    }
  }
  memmove(v121, v118, v120);
LABEL_220:
  v121->__r_.__value_.__s.__data_[v120] = 0;
  int v124 = (const void *)kLMLanguageModelDynamicLexiconNameKey;
  std::string::size_type v125 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v125)
  {
    sub_19E52477C(&value, (uint64_t)(v125 + 7));
    uint64_t v126 = value.isa;
    CFDictionaryAddValue(v309, v124, value.isa);
    if (v126) {
      CFRelease(v126);
    }
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v127 = (const void *)language_modeling::v1::kMultilingualDynamicLexiconNameOptionKey;
  size_t v128 = strlen((const char *)language_modeling::v1::kMultilingualDynamicLexiconNameOptionKey);
  if (v128 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v129 = v128;
  if (v128 >= 0x17)
  {
    uint64_t v131 = (v128 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v128 | 7) != 0x17) {
      uint64_t v131 = v128 | 7;
    }
    uint64_t v132 = v131 + 1;
    float v130 = (std::string *)operator new(v131 + 1);
    __dst.__r_.__value_.__l.__size_ = v129;
    __dst.__r_.__value_.__r.__words[2] = v132 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v130;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v128;
    float v130 = &__dst;
    if (!v128) {
      goto LABEL_233;
    }
  }
  memmove(v130, v127, v129);
LABEL_233:
  v130->__r_.__value_.__s.__data_[v129] = 0;
  long long v133 = (const void *)kLMLanguageModelMultilingualDynamicLexiconNameKey;
  uint64_t v134 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v134)
  {
    sub_19E52477C(&value, (uint64_t)(v134 + 7));
    uint64_t v135 = value.isa;
    CFDictionaryAddValue(v309, v133, value.isa);
    if (v135) {
      CFRelease(v135);
    }
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v136 = (const void *)language_modeling::v1::kCustomResourceDirectoryPathOptionKey;
  size_t v137 = strlen((const char *)language_modeling::v1::kCustomResourceDirectoryPathOptionKey);
  if (v137 > 0x7FFFFFFFFFFFFFF7) {
LABEL_513:
  }
    sub_19E37C958();
  std::string::size_type v138 = v137;
  if (v137 >= 0x17)
  {
    uint64_t v140 = (v137 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v137 | 7) != 0x17) {
      uint64_t v140 = v137 | 7;
    }
    uint64_t v141 = v140 + 1;
    int v139 = (std::string *)operator new(v140 + 1);
    __dst.__r_.__value_.__l.__size_ = v138;
    __dst.__r_.__value_.__r.__words[2] = v141 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v139;
    goto LABEL_245;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v137;
  int v139 = &__dst;
  if (v137) {
LABEL_245:
  }
    memmove(v139, v136, v138);
  v139->__r_.__value_.__s.__data_[v138] = 0;
  int v142 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (v308 == v142) {
    goto LABEL_276;
  }
  sub_19E52477C(&value, (uint64_t)(v142 + 7));
  uint64_t v143 = value.isa;
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v2, (CFStringRef)value.isa, @",");
  sub_19E40100C(&__p, ArrayBySeparatingStrings);
  memset(&__dst, 0, sizeof(__dst));
  CFArrayRef v145 = (const __CFArray *)__p.__r_.__value_.__r.__words[0];
  if (!__p.__r_.__value_.__r.__words[0]) {
    goto LABEL_265;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)__p.__r_.__value_.__l.__data_);
  CFIndex v147 = Count;
  std::string::size_type v148 = __p.__r_.__value_.__r.__words[0];
  if (!__p.__r_.__value_.__r.__words[0])
  {
    CFIndex v149 = 0;
    if (!Count) {
      goto LABEL_265;
    }
LABEL_252:
    if (v145 == (const __CFArray *)v148)
    {
      unint64_t v150 = 0;
      unint64_t v151 = 0;
      while (1)
      {
        if (v149 == v151) {
          goto LABEL_266;
        }
        sub_19E4F9D3C(cf, v145, v151);
        uint64_t v152 = (const void *)MEMORY[0x19F3BD2A0](0, cf[0], 0, 1, 0);
        length = v152;
        value.length = (uint64_t)v152;
        if (!v152) {
          goto LABEL_511;
        }
        if ((unint64_t)v150 >= __dst.__r_.__value_.__r.__words[2])
        {
          unint64_t v150 = (char *)sub_19E5164A0((uint64_t)&__dst, v152);
          __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v150;
        }
        else
        {
          CFRetain(v152);
          *(void *)unint64_t v150 = length;
          v150 += 8;
          length = (const void *)value.length;
          __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v150;
          if (!value.length) {
            goto LABEL_262;
          }
        }
        CFRelease(length);
LABEL_262:
        if (cf[0]) {
          CFRelease(cf[0]);
        }
        if (v147 == ++v151) {
          goto LABEL_266;
        }
      }
    }
    unint64_t v150 = 0;
    unint64_t v297 = 0;
    while (1)
    {
      sub_19E4F9D3C(cf, v145, v297);
      v298 = (const void *)MEMORY[0x19F3BD2A0](0, cf[0], 0, 1, 0);
      uint64_t v299 = v298;
      value.length = (uint64_t)v298;
      if (!v298)
      {
LABEL_511:
        uint64_t v301 = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](v301, "Could not construct");
        __cxa_throw(v301, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      if ((unint64_t)v150 >= __dst.__r_.__value_.__r.__words[2])
      {
        unint64_t v150 = (char *)sub_19E5164A0((uint64_t)&__dst, v298);
        __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v150;
      }
      else
      {
        CFRetain(v298);
        *(void *)unint64_t v150 = v299;
        v150 += 8;
        uint64_t v299 = (const void *)value.length;
        __dst.__r_.__value_.__l.__size_ = (std::string::size_type)v150;
        if (!value.length) {
          goto LABEL_508;
        }
      }
      CFRelease(v299);
LABEL_508:
      if (cf[0]) {
        CFRelease(cf[0]);
      }
      if (v147 == ++v297) {
        goto LABEL_266;
      }
    }
  }
  CFIndex v149 = CFArrayGetCount((CFArrayRef)__p.__r_.__value_.__l.__data_);
  if (v147) {
    goto LABEL_252;
  }
LABEL_265:
  unint64_t v150 = 0;
LABEL_266:
  CFLocaleRef v154 = (const void *)kLMLanguageModelCustomResourceDirectoryKey;
  CFArrayRef v155 = sub_19E3781CC(__dst.__r_.__value_.__l.__data_, v150);
  cf[0] = v155;
  CFDictionarySetValue(v309, v154, v155);
  CFRelease(v155);
  uint64_t v156 = (void *)__dst.__r_.__value_.__r.__words[0];
  if (__dst.__r_.__value_.__r.__words[0])
  {
    for (std::string::size_type i = __dst.__r_.__value_.__l.__size_; (void *)i != v156; i -= 8)
    {
      CFIndex v159 = *(const void **)(i - 8);
      CFIndex v158 = v159;
      if (v159) {
        CFRelease(v158);
      }
    }
    operator delete(v156);
  }
  if (__p.__r_.__value_.__r.__words[0]) {
    CFRelease(__p.__r_.__value_.__l.__data_);
  }
  if (v143) {
    CFRelease(v143);
  }
LABEL_276:
  CFIndex v160 = (const void *)language_modeling::v1::kAddSystemResourcesOptionKey;
  size_t v161 = strlen((const char *)language_modeling::v1::kAddSystemResourcesOptionKey);
  if (v161 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v162 = v161;
  if (v161 >= 0x17)
  {
    uint64_t v164 = (v161 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v161 | 7) != 0x17) {
      uint64_t v164 = v161 | 7;
    }
    uint64_t v165 = v164 + 1;
    CFIndex v163 = (std::string *)operator new(v164 + 1);
    __dst.__r_.__value_.__l.__size_ = v162;
    __dst.__r_.__value_.__r.__words[2] = v165 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v163;
    goto LABEL_283;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v161;
  CFIndex v163 = &__dst;
  if (v161) {
LABEL_283:
  }
    memmove(v163, v160, v162);
  v163->__r_.__value_.__s.__data_[v162] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelAddSystemToCustomResourcesKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v166 = (const void *)language_modeling::v1::kIgnoreSystemLanguageModelsOptionKey;
  size_t v167 = strlen((const char *)language_modeling::v1::kIgnoreSystemLanguageModelsOptionKey);
  if (v167 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v168 = v167;
  if (v167 >= 0x17)
  {
    uint64_t v170 = (v167 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v167 | 7) != 0x17) {
      uint64_t v170 = v167 | 7;
    }
    uint64_t v171 = v170 + 1;
    unint64_t v169 = (std::string *)operator new(v170 + 1);
    __dst.__r_.__value_.__l.__size_ = v168;
    __dst.__r_.__value_.__r.__words[2] = v171 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v169;
    goto LABEL_293;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v167;
  unint64_t v169 = &__dst;
  if (v167) {
LABEL_293:
  }
    memmove(v169, v166, v168);
  v169->__r_.__value_.__s.__data_[v168] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelIgnoreSystemLanguageModelsKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  unint64_t v172 = (const void *)language_modeling::v1::kCustomDynamicResourceDirectoryPathOptionKey;
  size_t v173 = strlen((const char *)language_modeling::v1::kCustomDynamicResourceDirectoryPathOptionKey);
  if (v173 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v174 = v173;
  if (v173 >= 0x17)
  {
    uint64_t v176 = (v173 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v173 | 7) != 0x17) {
      uint64_t v176 = v173 | 7;
    }
    uint64_t v177 = v176 + 1;
    CFArrayRef v175 = (std::string *)operator new(v176 + 1);
    __dst.__r_.__value_.__l.__size_ = v174;
    __dst.__r_.__value_.__r.__words[2] = v177 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v175;
    goto LABEL_303;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v173;
  CFArrayRef v175 = &__dst;
  if (v173) {
LABEL_303:
  }
    memmove(v175, v172, v174);
  v175->__r_.__value_.__s.__data_[v174] = 0;
  CFStringRef v178 = (const void *)kLMLanguageModelCustomDynamicResourceDirectoryKey;
  unint64_t v179 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v179)
  {
    if (*((_DWORD *)v179 + 20) != 1) {
      sub_19E3D72EC();
    }
    uint64_t v182 = v179[7];
    v180 = v179 + 7;
    uint64_t v181 = v182;
    int v183 = *((char *)v180 + 23);
    if (v183 >= 0) {
      CFComparisonResult v184 = v180;
    }
    else {
      CFComparisonResult v184 = (uint64_t *)v181;
    }
    if (v183 >= 0) {
      uint64_t v185 = *((unsigned __int8 *)v180 + 23);
    }
    else {
      uint64_t v185 = v180[1];
    }
    int v186 = (void *)MEMORY[0x19F3BD270](0, v184, v185, 1, 0);
    value.isa = v186;
    if (!v186)
    {
      uint64_t v303 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v303, "Could not construct");
      __cxa_throw(v303, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFDictionaryAddValue(v309, v178, v186);
    CFRelease(v186);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v187 = (const void *)language_modeling::v1::kPreheatFSTOptionKey;
  size_t v188 = strlen((const char *)language_modeling::v1::kPreheatFSTOptionKey);
  if (v188 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v189 = v188;
  if (v188 >= 0x17)
  {
    uint64_t v191 = (v188 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v188 | 7) != 0x17) {
      uint64_t v191 = v188 | 7;
    }
    uint64_t v192 = v191 + 1;
    CFStringRef v190 = (std::string *)operator new(v191 + 1);
    __dst.__r_.__value_.__l.__size_ = v189;
    __dst.__r_.__value_.__r.__words[2] = v192 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v190;
    goto LABEL_323;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v188;
  CFStringRef v190 = &__dst;
  if (v188) {
LABEL_323:
  }
    memmove(v190, v187, v189);
  v190->__r_.__value_.__s.__data_[v189] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelGenerateFstPrimingTokenKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  CFStringRef v193 = (const void *)language_modeling::v1::kExcludeMobileAssetsKey;
  size_t v194 = strlen((const char *)language_modeling::v1::kExcludeMobileAssetsKey);
  if (v194 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v195 = v194;
  if (v194 >= 0x17)
  {
    uint64_t v197 = (v194 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v194 | 7) != 0x17) {
      uint64_t v197 = v194 | 7;
    }
    uint64_t v198 = v197 + 1;
    v196 = (std::string *)operator new(v197 + 1);
    __dst.__r_.__value_.__l.__size_ = v195;
    __dst.__r_.__value_.__r.__words[2] = v198 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v196;
    goto LABEL_333;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v194;
  v196 = &__dst;
  if (v194) {
LABEL_333:
  }
    memmove(v196, v193, v195);
  v196->__r_.__value_.__s.__data_[v195] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelShouldExcludeMobileAssetsKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  float32x4x3_t v199 = (const void *)language_modeling::v1::kDisableDynamicLanguageModelsKey;
  size_t v200 = strlen((const char *)language_modeling::v1::kDisableDynamicLanguageModelsKey);
  if (v200 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v201 = v200;
  if (v200 >= 0x17)
  {
    uint64_t v203 = (v200 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v200 | 7) != 0x17) {
      uint64_t v203 = v200 | 7;
    }
    uint64_t v204 = v203 + 1;
    v202 = (std::string *)operator new(v203 + 1);
    __dst.__r_.__value_.__l.__size_ = v201;
    __dst.__r_.__value_.__r.__words[2] = v204 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v202;
    goto LABEL_343;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v200;
  v202 = &__dst;
  if (v200) {
LABEL_343:
  }
    memmove(v202, v199, v201);
  v202->__r_.__value_.__s.__data_[v201] = 0;
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, (const void *)kLMLanguageModelDisableDynamicLanguageModelsKey);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v205 = (const void *)language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey;
  size_t v206 = strlen((const char *)language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey);
  if (v206 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v207 = v206;
  if (v206 >= 0x17)
  {
    uint64_t v209 = (v206 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v206 | 7) != 0x17) {
      uint64_t v209 = v206 | 7;
    }
    uint64_t v210 = v209 + 1;
    v208 = (std::string *)operator new(v209 + 1);
    __dst.__r_.__value_.__l.__size_ = v207;
    __dst.__r_.__value_.__r.__words[2] = v210 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v208;
    goto LABEL_353;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v206;
  v208 = &__dst;
  if (v206) {
LABEL_353:
  }
    memmove(v208, v205, v207);
  v208->__r_.__value_.__s.__data_[v207] = 0;
  long long v211 = (__CFString *)language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey;
  size_t v212 = strlen((const char *)language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey);
  if (language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey)
  {
    long long v211 = (__CFString *)CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kCacheStaticPredictionsForEmptyContextKey, v212, 0x8000100u, 0);
    value.isa = v211;
    if (!v211)
    {
      v213 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v213, "Could not construct");
      __cxa_throw(v213, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    value.isa = 0;
  }
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, v211);
  if (v211) {
    CFRelease(v211);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v214 = (const void *)language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey;
  size_t v215 = strlen((const char *)language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey);
  if (v215 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v216 = v215;
  if (v215 >= 0x17)
  {
    uint64_t v218 = (v215 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v215 | 7) != 0x17) {
      uint64_t v218 = v215 | 7;
    }
    uint64_t v219 = v218 + 1;
    v217 = (std::string *)operator new(v218 + 1);
    __dst.__r_.__value_.__l.__size_ = v216;
    __dst.__r_.__value_.__r.__words[2] = v219 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v217;
    goto LABEL_369;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v215;
  v217 = &__dst;
  if (v215) {
LABEL_369:
  }
    memmove(v217, v214, v216);
  v217->__r_.__value_.__s.__data_[v216] = 0;
  CFStringRef v220 = (CFStringRef)language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey;
  size_t v221 = strlen((const char *)language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey);
  if (language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey)
  {
    CFStringRef v220 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelForCompletionsAndPredictionsKey, v221, 0x8000100u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v220;
    if (!v220)
    {
      uint64_t v222 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v222, "Could not construct");
      __cxa_throw(v222, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = 0;
  }
  int v223 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v223)
  {
    sub_19E52477C(&value, (uint64_t)(v223 + 7));
    uint64_t v224 = value.isa;
    CFDictionaryAddValue(v309, v220, value.isa);
    if (v224) {
      CFRelease(v224);
    }
  }
  if (v220) {
    CFRelease(v220);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  BOOL v225 = (const void *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey;
  size_t v226 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey);
  if (v226 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v227 = v226;
  if (v226 >= 0x17)
  {
    uint64_t v229 = (v226 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v226 | 7) != 0x17) {
      uint64_t v229 = v226 | 7;
    }
    uint64_t v230 = v229 + 1;
    unint64_t v228 = (std::string *)operator new(v229 + 1);
    __dst.__r_.__value_.__l.__size_ = v227;
    __dst.__r_.__value_.__r.__words[2] = v230 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v228;
    goto LABEL_388;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v226;
  unint64_t v228 = &__dst;
  if (v226) {
LABEL_388:
  }
    memmove(v228, v225, v227);
  v228->__r_.__value_.__s.__data_[v227] = 0;
  CFStringRef v231 = (CFStringRef)language_modeling::v1::kLanguageModelForConditionalProbabilityKey;
  size_t v232 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey);
  if (language_modeling::v1::kLanguageModelForConditionalProbabilityKey)
  {
    CFStringRef v231 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelForConditionalProbabilityKey, v232, 0x8000100u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v231;
    if (!v231)
    {
      uint64_t v233 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v233, "Could not construct");
      __cxa_throw(v233, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = 0;
  }
  uint64_t v234 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v234)
  {
    sub_19E52477C(&value, (uint64_t)(v234 + 7));
    uint64_t v235 = value.isa;
    CFDictionaryAddValue(v309, v231, value.isa);
    if (v235) {
      CFRelease(v235);
    }
  }
  if (v231) {
    CFRelease(v231);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  v236 = (const void *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey;
  size_t v237 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey);
  if (v237 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v238 = v237;
  if (v237 >= 0x17)
  {
    uint64_t v240 = (v237 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v237 | 7) != 0x17) {
      uint64_t v240 = v237 | 7;
    }
    uint64_t v241 = v240 + 1;
    long long v239 = (std::string *)operator new(v240 + 1);
    __dst.__r_.__value_.__l.__size_ = v238;
    __dst.__r_.__value_.__r.__words[2] = v241 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v239;
    goto LABEL_407;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v237;
  long long v239 = &__dst;
  if (v237) {
LABEL_407:
  }
    memmove(v239, v236, v238);
  v239->__r_.__value_.__s.__data_[v238] = 0;
  CFStringRef v242 = (CFStringRef)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey;
  size_t v243 = strlen((const char *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey);
  if (language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey)
  {
    CFStringRef v242 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelForConditionalProbabilityUserSettingKey, v243, 0x8000100u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v242;
    if (!v242)
    {
      __n128 v244 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v244, "Could not construct");
      __cxa_throw(v244, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = 0;
  }
  v245 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v245)
  {
    sub_19E52477C(&value, (uint64_t)(v245 + 7));
    uint64_t v246 = value.isa;
    CFDictionaryAddValue(v309, v242, value.isa);
    if (v246) {
      CFRelease(v246);
    }
  }
  if (v242) {
    CFRelease(v242);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  uint64_t v247 = (const void *)language_modeling::v1::kCustomStaticPhraseLexiconPathKey;
  size_t v248 = strlen((const char *)language_modeling::v1::kCustomStaticPhraseLexiconPathKey);
  if (v248 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v249 = v248;
  if (v248 >= 0x17)
  {
    uint64_t v251 = (v248 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v248 | 7) != 0x17) {
      uint64_t v251 = v248 | 7;
    }
    uint64_t v252 = v251 + 1;
    uint64_t v250 = (std::string *)operator new(v251 + 1);
    __dst.__r_.__value_.__l.__size_ = v249;
    __dst.__r_.__value_.__r.__words[2] = v252 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v250;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v248;
    uint64_t v250 = &__dst;
    if (!v248) {
      goto LABEL_427;
    }
  }
  memmove(v250, v247, v249);
LABEL_427:
  v250->__r_.__value_.__s.__data_[v249] = 0;
  CFRange v253 = (const void *)kLMLanguageModelCustomStaticPhraseLexiconPathKey;
  CFRange v254 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v254)
  {
    sub_19E52477C(&value, (uint64_t)(v254 + 7));
    CFRange v255 = value.isa;
    CFDictionaryAddValue(v309, v253, value.isa);
    if (v255) {
      CFRelease(v255);
    }
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  v256 = (const void *)language_modeling::v1::kUseBeamSearchV1;
  size_t v257 = strlen((const char *)language_modeling::v1::kUseBeamSearchV1);
  if (v257 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v258 = v257;
  if (v257 >= 0x17)
  {
    uint64_t v260 = (v257 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v257 | 7) != 0x17) {
      uint64_t v260 = v257 | 7;
    }
    uint64_t v261 = v260 + 1;
    int64_t v259 = (std::string *)operator new(v260 + 1);
    __dst.__r_.__value_.__l.__size_ = v258;
    __dst.__r_.__value_.__r.__words[2] = v261 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v259;
    goto LABEL_439;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v257;
  int64_t v259 = &__dst;
  if (v257) {
LABEL_439:
  }
    memmove(v259, v256, v258);
  v259->__r_.__value_.__s.__data_[v258] = 0;
  uint64_t v262 = (__CFString *)language_modeling::v1::kUseBeamSearchV1;
  size_t v263 = strlen((const char *)language_modeling::v1::kUseBeamSearchV1);
  if (language_modeling::v1::kUseBeamSearchV1)
  {
    uint64_t v262 = (__CFString *)CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kUseBeamSearchV1, v263, 0x8000100u, 0);
    value.isa = v262;
    if (!v262)
    {
      uint64_t v264 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v264, "Could not construct");
      __cxa_throw(v264, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    value.isa = 0;
  }
  sub_19E5246D0(a1, (const void **)&__dst.__r_.__value_.__l.__data_, v309, v262);
  if (v262) {
    CFRelease(v262);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  v265 = (const void *)language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey;
  size_t v266 = strlen((const char *)language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey);
  if (v266 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v267 = v266;
  if (v266 >= 0x17)
  {
    uint64_t v269 = (v266 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v266 | 7) != 0x17) {
      uint64_t v269 = v266 | 7;
    }
    uint64_t v270 = v269 + 1;
    long long v268 = (std::string *)operator new(v269 + 1);
    __dst.__r_.__value_.__l.__size_ = v267;
    __dst.__r_.__value_.__r.__words[2] = v270 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v268;
    goto LABEL_455;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v266;
  long long v268 = &__dst;
  if (v266) {
LABEL_455:
  }
    memmove(v268, v265, v267);
  v268->__r_.__value_.__s.__data_[v267] = 0;
  CFStringRef v271 = (CFStringRef)language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey;
  size_t v272 = strlen((const char *)language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey);
  if (language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey)
  {
    CFStringRef v271 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelMontrealFullCacheSizeCategoryKey, v272, 0x8000100u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v271;
    if (!v271)
    {
      uint64_t v273 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v273, "Could not construct");
      __cxa_throw(v273, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = 0;
  }
  v274 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v274)
  {
    sub_19E52477C(&value, (uint64_t)(v274 + 7));
    unint64_t v275 = value.isa;
    CFDictionaryAddValue(v309, v271, value.isa);
    if (v275) {
      CFRelease(v275);
    }
  }
  if (v271) {
    CFRelease(v271);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  v276 = (const void *)language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey;
  size_t v277 = strlen((const char *)language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey);
  if (v277 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v278 = v277;
  if (v277 >= 0x17)
  {
    uint64_t v280 = (v277 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v277 | 7) != 0x17) {
      uint64_t v280 = v277 | 7;
    }
    uint64_t v281 = v280 + 1;
    int64_t v279 = (std::string *)operator new(v280 + 1);
    __dst.__r_.__value_.__l.__size_ = v278;
    __dst.__r_.__value_.__r.__words[2] = v281 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v279;
    goto LABEL_474;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v277;
  int64_t v279 = &__dst;
  if (v277) {
LABEL_474:
  }
    memmove(v279, v276, v278);
  v279->__r_.__value_.__s.__data_[v278] = 0;
  CFStringRef v282 = (CFStringRef)language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey;
  size_t v283 = strlen((const char *)language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey);
  if (language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey)
  {
    CFStringRef v282 = CFStringCreateWithBytes(0, (const UInt8 *)language_modeling::v1::kLanguageModelInlineCompletionPrecisionOperatingPointKey, v283, 0x8000100u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v282;
    if (!v282)
    {
      uint64_t v284 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v284, "Could not construct");
      __cxa_throw(v284, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    __p.__r_.__value_.__r.__words[0] = 0;
  }
  uint64_t v285 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v285)
  {
    sub_19E52477C(&value, (uint64_t)(v285 + 7));
    v286 = value.isa;
    CFDictionaryAddValue(v309, v282, value.isa);
    if (v286) {
      CFRelease(v286);
    }
  }
  if (v282) {
    CFRelease(v282);
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  v287 = (const void *)language_modeling::v1::kCustomInlineCompletionParametersPath;
  size_t v288 = strlen((const char *)language_modeling::v1::kCustomInlineCompletionParametersPath);
  if (v288 > 0x7FFFFFFFFFFFFFF7) {
    sub_19E37C958();
  }
  std::string::size_type v289 = v288;
  if (v288 >= 0x17)
  {
    uint64_t v291 = (v288 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v288 | 7) != 0x17) {
      uint64_t v291 = v288 | 7;
    }
    uint64_t v292 = v291 + 1;
    uint64_t v290 = (std::string *)operator new(v291 + 1);
    __dst.__r_.__value_.__l.__size_ = v289;
    __dst.__r_.__value_.__r.__words[2] = v292 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v290;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v288;
    uint64_t v290 = &__dst;
    if (!v288) {
      goto LABEL_494;
    }
  }
  memmove(v290, v287, v289);
LABEL_494:
  v290->__r_.__value_.__s.__data_[v289] = 0;
  uint64_t v293 = (const void *)kLMCustomInlineCompletionParametersPathKey;
  v294 = sub_19E374C3C(a1, (const void **)&__dst.__r_.__value_.__l.__data_);
  if (v308 != v294)
  {
    sub_19E52477C(&value, (uint64_t)(v294 + 7));
    v295 = value.isa;
    CFDictionaryAddValue(v309, v293, value.isa);
    if (v295) {
      CFRelease(v295);
    }
  }
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return v309;
}

void sub_19E5242BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, const void *a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *a29,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (*(char *)(v34 - 89) < 0) {
    operator delete(*(void **)(v34 - 112));
  }
  sub_19E410F30(&a15);
  _Unwind_Resume(a1);
}

void sub_19E5246D0(uint64_t a1, const void **a2, __CFDictionary *a3, const void *a4)
{
  float v7 = sub_19E374C3C(a1, a2);
  if ((uint64_t *)(a1 + 8) != v7)
  {
    if (*((_DWORD *)v7 + 20)) {
      sub_19E3D72EC();
    }
    if (*((unsigned char *)v7 + 56)) {
      uint64_t v8 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v8 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    uint64_t v9 = *v8;
    CFDictionaryAddValue(a3, a4, *v8);
    if (v9) {
      CFRelease(v9);
    }
  }
}

void sub_19E524768(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E524844((const void **)va);
  _Unwind_Resume(a1);
}

CFStringRef sub_19E52477C(CFStringRef result, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 24) != 1) {
    sub_19E3D72EC();
  }
  p_isa = &result->isa;
  char v3 = *(unsigned char *)(a2 + 23);
  if (v3 >= 0) {
    uint64_t v4 = (const UInt8 *)a2;
  }
  else {
    uint64_t v4 = *(const UInt8 **)a2;
  }
  if (v4)
  {
    if (v3 >= 0) {
      CFIndex v5 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      CFIndex v5 = *(void *)(a2 + 8);
    }
    BOOL result = CFStringCreateWithBytes(0, v4, v5, 0x8000100u, 0);
    void *p_isa = result;
    if (!result)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    result->isa = 0;
  }
  return result;
}

void sub_19E524830(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

const void **sub_19E524844(const void **a1)
{
  CFAllocatorRef v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_19E524878(unsigned char *a1, uint64_t *a2)
{
  if ((*((char *)a2 + 23) & 0x80000000) == 0)
  {
    CFIndex v3 = *((unsigned __int8 *)a2 + 23);
    if (*((unsigned char *)a2 + 23))
    {
      CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      goto LABEL_6;
    }
LABEL_15:
    __assert_rtn("wordSeparatorForLocale", "AdapterUtils.cpp", 154, "!localeIdentifier.empty()");
  }
  CFIndex v3 = a2[1];
  if (!v3) {
    goto LABEL_15;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  a2 = (uint64_t *)*a2;
  if (!a2)
  {
    CFStringRef v5 = 0;
    goto LABEL_7;
  }
LABEL_6:
  CFStringRef v5 = CFStringCreateWithBytes(0, (const UInt8 *)a2, v3, 0x8000100u, 0);
  if (!v5)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    MEMORY[0x19F3BD790](exception, "Could not construct");
    __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
  }
LABEL_7:
  CFLocaleRef v6 = CFLocaleCreate(v4, v5);
  if (v5) {
    CFRelease(v5);
  }
  CFStringRef Value = (const __CFString *)CFLocaleGetValue(v6, (CFLocaleKey)*MEMORY[0x1E4F1D218]);
  CFComparisonResult v8 = CFStringCompare(Value, @"th", 0);
  size_t v9 = v8 != kCFCompareEqualTo;
  a1[23] = v9;
  if (v8) {
    memcpy(a1, " ", v9);
  }
  a1[v9] = 0;
  if (v6) {
    CFRelease(v6);
  }
}

void sub_19E5249E0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E5249FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
}

void sub_19E524A10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F68C0((const void **)va);
  _Unwind_Resume(a1);
}

void *sub_19E524A24(void *result, CFTypeRef cf)
{
  CFAllocatorRef v2 = result;
  if (cf)
  {
    CFRetain(cf);
    return sub_19E36F3C4(v2, cf);
  }
  else
  {
    void *result = 0;
  }
  return result;
}

void *sub_19E524A80(void *result)
{
  if (!*result)
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E4A5E50();
  }
  return result;
}

void sub_19E524AB4()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E524AD4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void *sub_19E524AE8(void *result)
{
  if (!*result)
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E4A5E50();
  }
  return result;
}

void sub_19E524B1C()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E524B3C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_19E524B50(void *a1, const __CFString *a2)
{
  if (!a2 || (CFTypeID TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(a2)))
  {
    __cxa_allocate_exception(0x10uLL);
    sub_19E4144D4();
  }
  return sub_19E3721DC(a1, a2);
}

void sub_19E524BC0()
{
  __cxa_throw(v0, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
}

void sub_19E524BE0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_19E524BF4(uint64_t a1, unsigned int a2, unsigned int *a3, void *a4)
{
  if (a2 <= 0x1F3)
  {
    if (!a3) {
      goto LABEL_33;
    }
LABEL_32:
    *a3 = a2;
    goto LABEL_33;
  }
  if (*(_DWORD *)(a1 + 180) <= a2 && *(_DWORD *)(a1 + 184) >= a2)
  {
    if (a3) {
      *a3 = 0;
    }
    goto LABEL_33;
  }
  int v4 = *(_DWORD *)(a1 + 188);
  if (v4 != 1)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    if (a2 < (unint64_t)((*(void *)(a1 + 24) - v7) >> 2))
    {
      CFComparisonResult v8 = (unsigned int *)(v7 + 4 * a2);
      goto LABEL_28;
    }
    if (a3)
    {
LABEL_31:
      a2 = *(unsigned __int8 *)(a1 + 176);
      goto LABEL_32;
    }
LABEL_33:
    if (a4)
    {
      *a4 = 0;
      return 1;
    }
    return 1;
  }
  CFStringRef v5 = *(unsigned int **)(a1 + 40);
  if (*(unsigned char *)(a1 + 192))
  {
    if (a2 < *v5 || *(_DWORD *)(*(void *)(a1 + 48) - 8) < a2) {
      goto LABEL_29;
    }
    v5 += 2 * (a2 - *v5);
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 48) - (void)v5;
    if (v9)
    {
      unint64_t v10 = v9 >> 3;
      do
      {
        unint64_t v11 = v10 >> 1;
        int v12 = &v5[2 * (v10 >> 1)];
        unsigned int v14 = *v12;
        float v13 = v12 + 2;
        v10 += ~(v10 >> 1);
        if (v14 < a2) {
          CFStringRef v5 = v13;
        }
        else {
          unint64_t v10 = v11;
        }
      }
      while (v10);
    }
    if (*v5 != a2)
    {
LABEL_29:
      if (!a3) {
        goto LABEL_33;
      }
      if (v4 == 1) {
        goto LABEL_32;
      }
      goto LABEL_31;
    }
  }
  CFComparisonResult v8 = v5 + 1;
LABEL_28:
  unsigned int v15 = *v8;
  unsigned int v16 = v15 >> 28;
  if (!(v15 >> 28)) {
    goto LABEL_29;
  }
  float v18 = (unsigned __int8 *)(*(void *)(a1 + 64) + (v15 & 0xFFFFFFF));
  if (a4)
  {
    uint64_t v19 = **(void **)(a1 + 80);
    if (a3)
    {
      uint64_t v20 = *(void *)(a1 + 128);
      *a3 = *(_DWORD *)(v20 + 4 * *v18);
      *a4 = *(void *)(v19 + 8 * v18[1]);
      if (v15 >> 29)
      {
        a3[1] = *(_DWORD *)(v20 + 4 * v18[2]);
        a4[1] = *(void *)(v19 + 8 * v18[3]);
        unsigned int v21 = v15 >> 28;
        if (v15 >> 28 < 3) {
          return 2;
        }
        a3[2] = *(_DWORD *)(v20 + 4 * v18[4]);
        a4[2] = *(void *)(v19 + 8 * v18[5]);
        if (!(v15 >> 30)) {
          return 3;
        }
        a3[3] = *(_DWORD *)(v20 + 4 * v18[6]);
        a4[3] = *(void *)(v19 + 8 * v18[7]);
        if (v21 < 5) {
          return 4;
        }
        a3[4] = *(_DWORD *)(v20 + 4 * v18[8]);
        a4[4] = *(void *)(v19 + 8 * v18[9]);
        if (v15 >> 29 < 3) {
          return 5;
        }
        a3[5] = *(_DWORD *)(v20 + 4 * v18[10]);
        a4[5] = *(void *)(v19 + 8 * v18[11]);
        if (v21 < 7) {
          return 6;
        }
        a3[6] = *(_DWORD *)(v20 + 4 * v18[12]);
        a4[6] = *(void *)(v19 + 8 * v18[13]);
        if ((v15 & 0x80000000) == 0) {
          return 7;
        }
        a3[7] = *(_DWORD *)(v20 + 4 * v18[14]);
LABEL_85:
        a4[7] = *(void *)(v19 + 8 * v18[15]);
        return 8;
      }
    }
    else
    {
      *a4 = *(void *)(v19 + 8 * v18[1]);
      if (v15 >> 29)
      {
        a4[1] = *(void *)(v19 + 8 * v18[3]);
        unsigned int v26 = v15 >> 28;
        if (v15 >> 28 < 3) {
          return 2;
        }
        a4[2] = *(void *)(v19 + 8 * v18[5]);
        if (!(v15 >> 30)) {
          return 3;
        }
        a4[3] = *(void *)(v19 + 8 * v18[7]);
        if (v26 < 5) {
          return 4;
        }
        a4[4] = *(void *)(v19 + 8 * v18[9]);
        if (v15 >> 29 < 3) {
          return 5;
        }
        a4[5] = *(void *)(v19 + 8 * v18[11]);
        if (v26 < 7) {
          return 6;
        }
        a4[6] = *(void *)(v19 + 8 * v18[13]);
        if ((v15 & 0x80000000) == 0) {
          return 7;
        }
        goto LABEL_85;
      }
    }
    return 1;
  }
  if (a3)
  {
    uint64_t v22 = *(void *)(a1 + 128);
    *a3 = *(_DWORD *)(v22 + 4 * *v18);
    if (!(v15 >> 29)) {
      return 1;
    }
    a3[1] = *(_DWORD *)(v22 + 4 * v18[2]);
    unsigned int v23 = v15 >> 28;
    if (v15 >> 28 >= 3)
    {
      a3[2] = *(_DWORD *)(v22 + 4 * v18[4]);
      if (v15 >> 30)
      {
        a3[3] = *(_DWORD *)(v22 + 4 * v18[6]);
        if (v23 >= 5)
        {
          a3[4] = *(_DWORD *)(v22 + 4 * v18[8]);
          if (v15 >> 29 >= 3)
          {
            a3[5] = *(_DWORD *)(v22 + 4 * v18[10]);
            if (v23 >= 7)
            {
              a3[6] = *(_DWORD *)(v22 + 4 * v18[12]);
              if ((v15 & 0x80000000) != 0)
              {
                a3[7] = *(_DWORD *)(v22 + 4 * v18[14]);
                return 8;
              }
              else
              {
                return 7;
              }
            }
            else
            {
              return 6;
            }
          }
          else
          {
            return 5;
          }
        }
        else
        {
          return 4;
        }
      }
      else
      {
        return 3;
      }
    }
    else
    {
      return 2;
    }
  }
  else
  {
    if (v16 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v16;
    }
    unint64_t v25 = v24 - 1;
    if (v25 >= 7) {
      unint64_t v25 = 7;
    }
    return v25 + 1;
  }
}

void sub_19E525004(uint64_t a1, CFTypeRef *a2)
{
  if (*a2) {
    CFRelease(*a2);
  }
  *a2 = 0;
}

uint64_t sub_19E525038()
{
  return 1;
}

void sub_19E525040(void *a1@<X8>)
{
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  if (LXCursorCreateByAdvancing()) {
    operator new();
  }
  *a1 = 0;
  if (RootCursor) {
    CFRelease(RootCursor);
  }
}

void sub_19E5251A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, int a11, __int16 a12, char a13, char a14, int a15, __int16 a16, char a17, char a18)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E525200()
{
  return &unk_1EF0B8318;
}

uint64_t sub_19E52520C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK2LM23LexiconFrameworkAdaptor19makeTokenEnumeratorEPK10__CFStringE3$_0"
    || ((v3 & (unint64_t)"ZNK2LM23LexiconFrameworkAdaptor19makeTokenEnumeratorEPK10__CFStringE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK2LM23LexiconFrameworkAdaptor19makeTokenEnumeratorEPK10__CFStringE3$_0")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK2LM23LexiconFrameworkAdaptor19makeTokenEnumeratorEPK10__CFStringE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E525264()
{
  return 1;
}

void sub_19E525274(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BDFB0;
}

void *sub_19E525294()
{
  BOOL result = operator new(0x10uLL);
  void *result = &unk_1EF0BDFB0;
  return result;
}

void sub_19E5252CC()
{
}

uint64_t sub_19E5252E4()
{
  uint64_t v0 = LXLexiconCopyEntryForTokenID();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = (const void *)v0;
  uint64_t v2 = LXEntryCopyString();
  CFRelease(v1);
  return v2;
}

void sub_19E52533C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E420F7C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E525354()
{
  return 0;
}

uint64_t sub_19E52535C()
{
  return 0;
}

uint64_t sub_19E525364()
{
  uint64_t v2 = 0;
  unint64_t v3 = &v2;
  int v5 = 0;
  uint64_t v4 = 0x2000000000;
  LXCursorEnumerateEntries();
  uint64_t v0 = *((unsigned int *)v3 + 6);
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_19E525408(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_19E525420(uint64_t result, uint64_t a2, unsigned char *a3)
{
  uint64_t v4 = result;
  if (a2)
  {
    BOOL result = LXEntryGetTokenID();
    if (result) {
      int v5 = result;
    }
    else {
      int v5 = 500;
    }
  }
  else
  {
    int v5 = 0;
  }
  *(_DWORD *)(*(void *)(*(void *)(v4 + 32) + 8) + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  *a3 = 1;
  return result;
}

uint64_t sub_19E525478(uint64_t a1, void *a2)
{
  return MEMORY[0x1F412A658](*a2);
}

double sub_19E525480()
{
  LXCursorTerminationProbability();
  return __exp10(v0);
}

double sub_19E5254A0()
{
  LXCursorConditionalProbability();
  return __exp10(v0);
}

BOOL sub_19E5254C0()
{
  return LXCursorHasChildren() != 0;
}

uint64_t sub_19E5254E4()
{
  return LXCursorEnumerateEntries();
}

void sub_19E525554(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  CFStringRef v6 = (const __CFString *)LXEntryCopyString();
  CFStringRef v17 = v6;
  if (a2)
  {
    unsigned int TokenID = LXEntryGetTokenID();
    if (TokenID) {
      uint64_t v8 = TokenID;
    }
    else {
      uint64_t v8 = 500;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  sub_19E37774C(v6, __p);
  LXEntryGetPartialProbability();
  double v10 = __exp10(v9);
  char MetaFlags = LXEntryGetMetaFlags();
  uint64_t v12 = LXEntryGetMetaFlags() & 0x200021;
  char v14 = 0;
  if (v16 >= 0) {
    float v13 = __p;
  }
  else {
    float v13 = (void **)__p[0];
  }
  (*(void (**)(void, uint64_t, void **, void, uint64_t, char *, double))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v8, v13, MetaFlags & 0x86, v12, &v14, v10);
  if (v14) {
    *a3 = 1;
  }
  if (v16 < 0)
  {
    operator delete(__p[0]);
    if (!v6) {
      return;
    }
    goto LABEL_15;
  }
  if (v6) {
LABEL_15:
  }
    CFRelease(v6);
}

void sub_19E52567C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, const void *a17)
{
}

uint64_t sub_19E5256B8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return LXCursorHasEntries() != 0;
  }
  return result;
}

uint64_t sub_19E5256E0(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return LXCursorIsRoot() != 0;
  }
  return result;
}

BOOL sub_19E525708(uint64_t a1, void *a2)
{
  if (!*a2) {
    return 0;
  }
  if (LXCursorHasEntries()) {
    return 1;
  }
  return LXCursorHasChildren() != 0;
}

void sub_19E525758(int a1, int a2, CFTypeRef *a3, UniChar *chars, CFIndex numChars)
{
  CFStringRef v6 = CFStringCreateWithCharactersNoCopy(0, chars, numChars, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v7 = (const void *)LXCursorCreateByAdvancing();
  uint64_t v8 = v7;
  *a3 = 0;
  if (v7)
  {
    CFTypeRef v9 = CFRetain(v7);
    if (*a3) {
      CFRelease(*a3);
    }
    *a3 = v9;
  }
  LXCursorConditionalProbability();
  double v11 = v10;
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  __exp10(v11);
}

void sub_19E52582C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, const void *a10)
{
  if (*v10) {
    CFRelease(*v10);
  }
  *double v10 = 0;
  sub_19E421014(&a9);
  sub_19E3DCC24(&a10);
  _Unwind_Resume(a1);
}

void sub_19E52586C(uint64_t a1, CFTypeRef *a2)
{
  RootCursor = (const void *)LXLexiconCreateRootCursor();
  *a2 = 0;
  if (RootCursor)
  {
    uint64_t v4 = RootCursor;
    CFTypeRef v5 = CFRetain(RootCursor);
    if (*a2) {
      CFRelease(*a2);
    }
    *a2 = v5;
    CFRelease(v4);
  }
}

void sub_19E5258DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*v2) {
    CFRelease(*v2);
  }
  *uint64_t v2 = 0;
  sub_19E421014((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E525904(void *a1)
{
  *a1 = &unk_1EF0BB6A0;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  a1[1] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E525978(void *a1)
{
  *a1 = &unk_1EF0BB6A0;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  a1[1] = 0;
  return a1;
}

uint64_t sub_19E5259D0()
{
  return 0;
}

void sub_19E5259D8(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t sub_19E5259E0()
{
  return 0;
}

uint64_t sub_19E5259E8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 24))();
}

unint64_t sub_19E525A10(uint64_t a1, unint64_t a2, int8x16_t *a3, unint64_t a4)
{
  unint64_t v4 = a2;
  if (!a2) {
    return v4;
  }
  CFStringRef v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  while (*(void *)(v4 + 8))
  {
    unsigned int v10 = *(_DWORD *)(v4 + 16);
    if (HIWORD(v10))
    {
      __int16 v16 = v10 & 0x3FF | 0xDC00;
      if (v6 < v7)
      {
        *(_WORD *)CFStringRef v6 = v16;
        CFStringRef v17 = v6 + 2;
LABEL_46:
        int v31 = (*(_DWORD *)(v4 + 16) >> 10) - 10304;
        if (v17 >= v7)
        {
          uint64_t v32 = v17 - v8;
          if (v17 - v8 <= -3) {
            sub_19E37C7C4();
          }
          uint64_t v33 = v32 >> 1;
          if (v7 - v8 <= (unint64_t)((v32 >> 1) + 1)) {
            uint64_t v34 = v33 + 1;
          }
          else {
            uint64_t v34 = v7 - v8;
          }
          if ((unint64_t)(v7 - v8) >= 0x7FFFFFFFFFFFFFFELL) {
            uint64_t v35 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v35 = v34;
          }
          if (v35)
          {
            if (v35 < 0) {
              sub_19E37C2B8();
            }
            int v36 = operator new(2 * v35);
          }
          else
          {
            int v36 = 0;
          }
          float v37 = &v36[2 * v33];
          *float v37 = v31;
          CFTypeRef v9 = (int8x16_t *)(v37 + 1);
          if (v17 != v8)
          {
            unint64_t v38 = v17 - 2 - v8;
            if (v38 < 0x5E)
            {
              std::string::size_type v39 = v17;
              goto LABEL_62;
            }
            if (&v36[(v32 & 0xFFFFFFFFFFFFFFFELL) - 2 - (v38 & 0xFFFFFFFFFFFFFFFELL)] > &v36[(v32 & 0xFFFFFFFFFFFFFFFELL)
                                                                                            - 2])
            {
              std::string::size_type v39 = v17;
              goto LABEL_62;
            }
            if (&v17[-(v38 & 0xFFFFFFFFFFFFFFFELL) - 2] > v17 - 2)
            {
              std::string::size_type v39 = v17;
              goto LABEL_62;
            }
            if (v17 - v36 - (v32 & 0xFFFFFFFFFFFFFFFELL) < 0x20)
            {
              std::string::size_type v39 = v17;
              goto LABEL_62;
            }
            uint64_t v51 = (v38 >> 1) + 1;
            std::string::size_type v39 = &v17[-2 * (v51 & 0xFFFFFFFFFFFFFFF0)];
            float v52 = &v36[2 * v33 - 16];
            float v53 = v17 - 16;
            unint64_t v54 = v51 & 0xFFFFFFFFFFFFFFF0;
            do
            {
              long long v55 = *(_OWORD *)v53;
              *(v52 - 1) = *((_OWORD *)v53 - 1);
              *float v52 = v55;
              v52 -= 2;
              v53 -= 32;
              v54 -= 16;
            }
            while (v54);
            v37 -= v51 & 0xFFFFFFFFFFFFFFF0;
            if (v51 != (v51 & 0xFFFFFFFFFFFFFFF0))
            {
              do
              {
LABEL_62:
                __int16 v40 = *((_WORD *)v39 - 1);
                v39 -= 2;
                *--float v37 = v40;
              }
              while (v39 != v8);
            }
          }
          uint64_t v7 = &v36[2 * v35];
          if (v8) {
            operator delete(v8);
          }
          uint64_t v8 = (char *)v37;
          goto LABEL_4;
        }
        *(_WORD *)CFStringRef v17 = v31;
        CFTypeRef v9 = (int8x16_t *)(v17 + 2);
        goto LABEL_4;
      }
      uint64_t v18 = v6 - v8;
      if (v6 - v8 <= -3) {
        sub_19E37C7C4();
      }
      uint64_t v19 = v18 >> 1;
      if (v7 - v8 <= (unint64_t)((v18 >> 1) + 1)) {
        uint64_t v20 = v19 + 1;
      }
      else {
        uint64_t v20 = v7 - v8;
      }
      if ((unint64_t)(v7 - v8) >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v21 = v20;
      }
      if (v21)
      {
        if (v21 < 0) {
          sub_19E37C2B8();
        }
        uint64_t v22 = operator new(2 * v21);
      }
      else
      {
        uint64_t v22 = 0;
      }
      int v27 = &v22[2 * v19];
      *(_WORD *)int v27 = v16;
      CFStringRef v17 = v27 + 2;
      if (v6 != v8)
      {
        unint64_t v28 = v6 - 2 - v8;
        if (v28 < 0x5E)
        {
          std::string::size_type v29 = v6;
          goto LABEL_42;
        }
        if (&v22[(v18 & 0xFFFFFFFFFFFFFFFELL) - 2 - (v28 & 0xFFFFFFFFFFFFFFFELL)] > &v22[(v18 & 0xFFFFFFFFFFFFFFFELL)
                                                                                        - 2])
        {
          std::string::size_type v29 = v6;
          goto LABEL_42;
        }
        if (&v6[-(v28 & 0xFFFFFFFFFFFFFFFELL) - 2] > v6 - 2)
        {
          std::string::size_type v29 = v6;
          goto LABEL_42;
        }
        if (v6 - v22 - (v18 & 0xFFFFFFFFFFFFFFFELL) < 0x20)
        {
          std::string::size_type v29 = v6;
          goto LABEL_42;
        }
        uint64_t v46 = (v28 >> 1) + 1;
        std::string::size_type v29 = &v6[-2 * (v46 & 0xFFFFFFFFFFFFFFF0)];
        float v47 = &v22[2 * v19 - 16];
        uint64_t v48 = v6 - 16;
        unint64_t v49 = v46 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v50 = *(_OWORD *)v48;
          *(v47 - 1) = *((_OWORD *)v48 - 1);
          *float v47 = v50;
          v47 -= 2;
          v48 -= 32;
          v49 -= 16;
        }
        while (v49);
        v27 -= 2 * (v46 & 0xFFFFFFFFFFFFFFF0);
        if (v46 != (v46 & 0xFFFFFFFFFFFFFFF0))
        {
          do
          {
LABEL_42:
            __int16 v30 = *((_WORD *)v29 - 1);
            v29 -= 2;
            *((_WORD *)v27 - 1) = v30;
            v27 -= 2;
          }
          while (v29 != v8);
        }
      }
      uint64_t v7 = &v22[2 * v21];
      if (v8) {
        operator delete(v8);
      }
      uint64_t v8 = v27;
      goto LABEL_46;
    }
    if (v6 >= v7)
    {
      uint64_t v11 = v6 - v8;
      if (v6 - v8 <= -3) {
        sub_19E37C7C4();
      }
      uint64_t v12 = v11 >> 1;
      if (v7 - v8 <= (unint64_t)((v11 >> 1) + 1)) {
        uint64_t v13 = v12 + 1;
      }
      else {
        uint64_t v13 = v7 - v8;
      }
      if ((unint64_t)(v7 - v8) >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v14 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v14 = v13;
      }
      if (v14)
      {
        if (v14 < 0) {
          sub_19E37C2B8();
        }
        unsigned int v15 = operator new(2 * v14);
      }
      else
      {
        unsigned int v15 = 0;
      }
      unsigned int v23 = &v15[2 * v12];
      *unsigned int v23 = v10;
      CFTypeRef v9 = (int8x16_t *)(v23 + 1);
      if (v6 != v8)
      {
        unint64_t v24 = v6 - 2 - v8;
        if (v24 < 0x5E)
        {
          unint64_t v25 = v6;
          goto LABEL_34;
        }
        if (&v15[(v11 & 0xFFFFFFFFFFFFFFFELL) - 2 - (v24 & 0xFFFFFFFFFFFFFFFELL)] > &v15[(v11 & 0xFFFFFFFFFFFFFFFELL)
                                                                                        - 2])
        {
          unint64_t v25 = v6;
          goto LABEL_34;
        }
        if (&v6[-(v24 & 0xFFFFFFFFFFFFFFFELL) - 2] > v6 - 2)
        {
          unint64_t v25 = v6;
          goto LABEL_34;
        }
        if ((unint64_t)(v6 - &v15[v11 & 0xFFFFFFFFFFFFFFFELL]) < 0x20)
        {
          unint64_t v25 = v6;
          goto LABEL_34;
        }
        uint64_t v41 = (v24 >> 1) + 1;
        unint64_t v25 = &v6[-2 * (v41 & 0xFFFFFFFFFFFFFFF0)];
        unint64_t v42 = &v15[2 * v12 - 16];
        uint64_t v43 = v6 - 16;
        unint64_t v44 = v41 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          long long v45 = *(_OWORD *)v43;
          *(v42 - 1) = *((_OWORD *)v43 - 1);
          *unint64_t v42 = v45;
          v42 -= 2;
          v43 -= 32;
          v44 -= 16;
        }
        while (v44);
        v23 -= v41 & 0xFFFFFFFFFFFFFFF0;
        if (v41 != (v41 & 0xFFFFFFFFFFFFFFF0))
        {
          do
          {
LABEL_34:
            __int16 v26 = *((_WORD *)v25 - 1);
            v25 -= 2;
            *--unsigned int v23 = v26;
          }
          while (v25 != v8);
        }
      }
      uint64_t v7 = &v15[2 * v14];
      if (v8) {
        operator delete(v8);
      }
      uint64_t v8 = (char *)v23;
      goto LABEL_4;
    }
    *(_WORD *)CFStringRef v6 = v10;
    CFTypeRef v9 = (int8x16_t *)(v6 + 2);
LABEL_4:
    unint64_t v4 = *(void *)(v4 + 8);
    CFStringRef v6 = (char *)v9;
    if (!v4) {
      goto LABEL_97;
    }
  }
  CFTypeRef v9 = (int8x16_t *)v6;
LABEL_97:
  unint64_t v4 = ((char *)v9 - v8) >> 1;
  if (v4 <= a4)
  {
    if (v9 != (int8x16_t *)v8)
    {
      unint64_t v59 = (char *)v9 - v8 - 2;
      if (v59 >= 0x2E
        && (v9 <= a3
         || (char *)v9 - (v59 & 0xFFFFFFFFFFFFFFFELL) - 2 >= (char *)&a3->i16[1] + (v59 & 0xFFFFFFFFFFFFFFFELL)))
      {
        uint64_t v60 = (v59 >> 1) + 1;
        size_t v61 = (int16x8_t *)&v9[-1];
        BOOL v62 = a3 + 1;
        unint64_t v63 = v60 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          int8x16_t v64 = (int8x16_t)vrev64q_s16(*v61);
          int8x16_t v65 = (int8x16_t)vrev64q_s16(v61[-1]);
          v62[-1] = vextq_s8(v64, v64, 8uLL);
          *BOOL v62 = vextq_s8(v65, v65, 8uLL);
          v61 -= 2;
          v62 += 2;
          v63 -= 16;
        }
        while (v63);
        if (v60 == (v60 & 0xFFFFFFFFFFFFFFF0)) {
          goto LABEL_114;
        }
        a3 = (int8x16_t *)((char *)a3 + 2 * (v60 & 0xFFFFFFFFFFFFFFF0));
        CFTypeRef v9 = (int8x16_t *)((char *)v9 - 2 * (v60 & 0xFFFFFFFFFFFFFFF0));
      }
      do
      {
        __int16 v66 = v9[-1].i16[7];
        CFTypeRef v9 = (int8x16_t *)((char *)v9 - 2);
        a3->i16[0] = v66;
        a3 = (int8x16_t *)((char *)a3 + 2);
      }
      while (v9 != (int8x16_t *)v8);
    }
  }
  else if (a4)
  {
    unint64_t v56 = (a4 - 1) & 0x7FFFFFFFFFFFFFFFLL;
    if (v56 >= 0x17 && (v9 <= a3 || (char *)v9 - 2 * a4 >= (char *)a3 + 2 * a4))
    {
      unint64_t v68 = v56 + 1;
      uint64_t v69 = (int16x8_t *)&v9[-1];
      unint64_t v70 = a3 + 1;
      unint64_t v71 = v68 & 0xFFFFFFFFFFFFFFF0;
      do
      {
        int8x16_t v72 = (int8x16_t)vrev64q_s16(*v69);
        int8x16_t v73 = (int8x16_t)vrev64q_s16(v69[-1]);
        v70[-1] = vextq_s8(v72, v72, 8uLL);
        int8x16_t *v70 = vextq_s8(v73, v73, 8uLL);
        v69 -= 2;
        v70 += 2;
        v71 -= 16;
      }
      while (v71);
      if (v68 != (v68 & 0xFFFFFFFFFFFFFFF0))
      {
        a3 = (int8x16_t *)((char *)a3 + 2 * (v68 & 0xFFFFFFFFFFFFFFF0));
        float v57 = (int8x16_t *)((char *)v9 - 2 * (v68 & 0xFFFFFFFFFFFFFFF0));
        goto LABEL_103;
      }
    }
    else
    {
      float v57 = v9;
      do
      {
LABEL_103:
        __int16 v58 = v57[-1].i16[7];
        float v57 = (int8x16_t *)((char *)v57 - 2);
        a3->i16[0] = v58;
        a3 = (int8x16_t *)((char *)a3 + 2);
      }
      while (v57 != (int8x16_t *)((char *)v9 - 2 * a4));
    }
  }
LABEL_114:
  if (v8) {
    operator delete(v8);
  }
  return v4;
}

void sub_19E52602C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E526058(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
}

uint64_t sub_19E526080(uint64_t a1, uint64_t a2)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  if (result)
  {
    unint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a2 + 48);
    return v4(a2);
  }
  return result;
}

uint64_t sub_19E52610C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 32))(a2);
}

double sub_19E526134()
{
  return 0.0;
}

double sub_19E52613C()
{
  return 0.0;
}

uint64_t sub_19E526144(uint64_t a1, uint64_t a2)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a2 + 40))(a2) ^ 1;
}

uint64_t sub_19E526184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
  if (result)
  {
    char v9 = 0;
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 48))(a2);
    return (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, char *, double))(a5 + 16))(a5, v8, 0, 0, 0, &v9, 0.0);
  }
  return result;
}

uint64_t sub_19E526230(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
}

BOOL sub_19E526258(uint64_t a1, void *a2, void *a3)
{
  return a2[4] == a3[4] && a2[5] == a3[5] && a2[6] == a3[6];
}

uint64_t sub_19E52627C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 24))(a2);
}

double sub_19E5262A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a4, a5);
  if (!v7)
  {
    __int16 v10 = 0;
    uint64_t v7 = (*(uint64_t (**)(uint64_t, __int16 *, uint64_t))(*(void *)a2 + 16))(a2, &v10, 1);
  }
  *(void *)a3 = &unk_1EF0BB020;
  uint64_t v8 = *(void *)(v7 + 8);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v7 + 16);
  *(void *)a3 = &unk_1EF0BBA08;
  *(void *)(a3 + 8) = v8;
  *(void *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(v7 + 24);
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(v7 + 32);
  *(void *)(a3 + 40) = *(void *)(v7 + 40);
  *(unsigned char *)(a3 + 48) = *(unsigned char *)(v7 + 48);
  return 0.0;
}

void *sub_19E5263A0(void *result, uint64_t a2)
{
  uint64_t v3 = result[1];
  unint64_t v4 = **(_DWORD ***)(v3 + 16);
  if (v4)
  {
    if (qword_1E9459FB0 != -1) {
      dispatch_once(&qword_1E9459FB0, &unk_1EF0BEBA0);
    }
    uint64_t result = (*(void *(**)(void *__return_ptr))(**(void **)(qword_1E9459FB8 + 8 * (*v4 & 3)) + 32))(v8);
    int v5 = v8[0];
    uint64_t v6 = v8[1];
    char v7 = v9;
  }
  else
  {
    uint64_t v6 = 0;
    char v7 = 0;
    int v5 = 0;
  }
  *(_DWORD *)(a2 + 16) = 0;
  *(void *)a2 = &unk_1EF0BBA08;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v3;
  *(_DWORD *)(a2 + 32) = v5;
  *(void *)(a2 + 40) = v6;
  *(unsigned char *)(a2 + 48) = v7;
  return result;
}

void sub_19E526494(void *a1)
{
  *a1 = &unk_1EF0BB280;
  uint64_t v1 = a1[1];
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E526520(void *a1)
{
  *a1 = &unk_1EF0BB280;
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return a1;
}

void *sub_19E52658C(void *a1, const void *a2, const void *a3)
{
  *a1 = &unk_1EF0BB6A0;
  a1[1] = 0;
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72430], a2);
  if (a3)
  {
    uint64_t v8 = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(v8, a3);
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72438], v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E4F72440], (const void *)*MEMORY[0x1E4F1CFD0]);
  CFErrorRef err = 0;
  uint64_t v9 = LXLexiconCreate();
  __int16 v10 = (const void *)a1[1];
  if (v10) {
    CFRelease(v10);
  }
  a1[1] = v9;
  if (!v9)
  {
    if (err)
    {
      exception = __cxa_allocate_exception(0x20uLL);
      uint64_t v13 = (char *)operator new(0x30uLL);
      long long v14 = xmmword_19E573220;
      strcpy(v13, "Failed to create the lexicon framework adapter");
      sub_19E4991D0((uint64_t)exception, (const void **)&v13, err);
      __cxa_throw(exception, (struct type_info *)&unk_1EF0B7540, (void (*)(void *))sub_19E3F56B0);
    }
    __assert_rtn("LexiconFrameworkAdaptor", "LMLexiconAdaptor.cpp", 59, "error");
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return a1;
}

void sub_19E52676C(_Unwind_Exception *a1)
{
  operator delete(v4);
  CFRelease(v3);
  if (v2) {
    CFRelease(v2);
  }
  CFAllocatorRef v6 = *(const void **)(v1 + 8);
  if (v6) {
    CFRelease(v6);
  }
  *(void *)(v1 + 8) = 0;
  _Unwind_Resume(a1);
}

BOOL sub_19E52680C(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  if (!a3) {
    return 1;
  }
  if (a3 == 1 && *a2 == 3) {
    return 0;
  }
  return *(_DWORD *)sub_19E4A5E5C(a1 + 8, a2, a3) > 0xFA0u;
}

uint64_t sub_19E526860(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  if (a3)
  {
    CFAllocatorRef v6 = *(char **)(a1 + 208);
    uint64_t v7 = *(void *)(a1 + 216);
    if (a3 == 1 && *a2 == 3)
    {
      *(_DWORD *)CFAllocatorRef v6 = 4;
      size_t v8 = 1;
LABEL_21:
      sub_19E494468(a4, v6, &v6[4 * v8], v8);
      return 1;
    }
    uint64_t v9 = (_DWORD *)sub_19E4A5E5C(a1 + 8, a2, a3);
    unint64_t v10 = v9[1];
    uint64_t v11 = (v10 + *v9);
    if (v10 < v11)
    {
      int v12 = 0;
      uint64_t v13 = (16 * v10) | 8;
      while (1)
      {
        uint64_t v15 = v12;
        if ((v7 - (uint64_t)v6) >> 2 <= (unint64_t)v12) {
          return 0;
        }
        if (v10 >= *(unsigned int *)(a1 + 56)) {
          goto LABEL_23;
        }
        uint64_t v16 = *(void *)(a1 + 104);
        if (v12)
        {
          int v14 = *(_DWORD *)(v16 + v13);
          if (*(_DWORD *)&v6[4 * v12 - 4] == v14) {
            goto LABEL_9;
          }
        }
        else
        {
          int v14 = *(_DWORD *)(v16 + v13);
        }
        ++v12;
        *(_DWORD *)&v6[4 * v15] = v14;
LABEL_9:
        ++v10;
        v13 += 16;
        if (v11 == v10) {
          goto LABEL_16;
        }
      }
    }
    int v12 = 0;
LABEL_16:
    uint64_t v17 = v9[2];
    if (*(_DWORD *)(a1 + 56) <= v17) {
LABEL_23:
    }
      __assert_rtn("getEdge", "Network.h", 203, "edgeIdx < getNrOfEdges()");
    if (*(_DWORD *)(*(void *)(a1 + 104) + 16 * v17 + 12)) {
      *(_DWORD *)&v6[4 * v12++] = 4;
    }
    if (v12)
    {
      size_t v8 = v12;
      CFAllocatorRef v6 = *(char **)(a1 + 208);
      goto LABEL_21;
    }
  }
  return 0;
}

uint64_t sub_19E5269B4(uint64_t a1, unsigned int a2, unsigned int *a3, unint64_t a4)
{
  if (a4 < *(unsigned int *)(a1 + 80)) {
    __assert_rtn("findSinglePathForOutputId", "LMFSTNetwork.cpp", 43, "nnTokenIDs.size() >= maxMontrealTokensForLMTokenID()");
  }
  if (!a4) {
    return 0;
  }
  if (a2 - 1 <= 1)
  {
    *a3 = a2;
    return 1;
  }
  if (*(_DWORD *)(a1 + 68) <= a2) {
    goto LABEL_8;
  }
  uint64_t v5 = *(unsigned int *)(*(void *)(a1 + 120) + 4 * a2);
  if (v5 == -1) {
    return 0;
  }
  if (v5 == *(_DWORD *)(a1 + 76))
  {
LABEL_8:
    *(void *)a3 = 0x400000003;
    return 2;
  }
  if (*(_DWORD *)(a1 + 56) <= v5) {
LABEL_26:
  }
    __assert_rtn("getEdge", "Network.h", 203, "edgeIdx < getNrOfEdges()");
  uint64_t v6 = *(void *)(a1 + 104);
  *a3 = 4;
  a3[1] = *(_DWORD *)(v6 + 16 * (int)v5 + 8);
  unint64_t v7 = *(unsigned int *)(v6 + 16 * v5);
  if (*(unsigned int *)(a1 + 52) <= v7) {
LABEL_18:
  }
    __assert_rtn("isInitial", "Network.h", 223, "n < getNrOfNodes()");
  uint64_t v8 = 2;
  if (a4 <= 2) {
    uint64_t v9 = 2;
  }
  else {
    uint64_t v9 = a4;
  }
  while (*(_DWORD *)(a1 + 48) != v7)
  {
    if (v9 == v8) {
      return 0;
    }
    uint64_t v10 = *(unsigned int *)(*(void *)(a1 + 88) + 12 * v7 + 8);
    if (*(_DWORD *)(a1 + 56) <= v10) {
      goto LABEL_26;
    }
    uint64_t v11 = (unsigned int *)(v6 + 16 * v10);
    a3[v8++] = v11[2];
    unint64_t v7 = *v11;
    if (*(unsigned int *)(a1 + 52) <= v7) {
      goto LABEL_18;
    }
  }
  uint64_t result = v8;
  int v12 = &a3[v8 - 1];
  if (v12 > a3)
  {
    uint64_t v13 = a3 + 1;
    do
    {
      unsigned int v14 = *(v13 - 1);
      *(v13 - 1) = *v12;
      *v12-- = v14;
    }
    while (v13++ < v12);
  }
  return result;
}

void sub_19E526B6C(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, char **a5@<X8>)
{
  uint64_t v7 = a2;
  uint64_t v10 = *(unsigned int *)(a1 + 64);
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2) - 1 != v10) {
    __assert_rtn("predictions", "Network.cpp", 372, "largestInputId() == neuralModel.outputLayerSize() - 1");
  }
  unint64_t v11 = *(void *)(a1 + 32);
  v192[1] = (void *)v11;
  CFStringRef v193 = 0;
  size_t v194 = 0;
  std::string::size_type v195 = 0;
  if (!v11) {
    __assert_rtn("PriorityQueue", "PriorityQueue.hpp", 21, "m_maxPredictionCount > 0");
  }
  if (v11 >= 0x666666666666667) {
    sub_19E37C7C4();
  }
  CFStringRef v193 = operator new(40 * v11);
  size_t v194 = (char *)v193;
  std::string::size_type v195 = (char *)v193 + 40 * v11;
  float v196 = 0.0;
  *(_OWORD *)std::string __p = 0u;
  long long v198 = 0u;
  int v12 = *(const void **)a3;
  int64_t v13 = *(void *)(a3 + 8) - *(void *)a3;
  if (v13)
  {
    if (v13 < 0) {
      sub_19E37C7C4();
    }
    unsigned int v14 = (char *)operator new(v13);
    uint64_t v15 = &v14[4 * (v13 >> 2)];
    __p[1] = v14;
    *((void *)&v198 + 1) = v15;
    memcpy(v14, v12, v13);
    *(void *)&long long v198 = v15;
  }
  sub_19E4A61DC(v192, (unint64_t)&v196);
  if (__p[1])
  {
    *(void **)&long long v198 = __p[1];
    operator delete(__p[1]);
  }
  if (*(void *)(a1 + 24) >= a4) {
    unint64_t v16 = a4;
  }
  else {
    unint64_t v16 = *(void *)(a1 + 24);
  }
  if (!v16) {
    __assert_rtn("PriorityQueue", "PriorityQueue.hpp", 21, "m_maxPredictionCount > 0");
  }
  if (v16 >> 60) {
    sub_19E37C7C4();
  }
  CFArrayRef v175 = a5;
  uint64_t v17 = (double *)operator new(16 * v16);
  uint64_t v19 = (char *)v193;
  uint64_t v18 = v194;
  if (v193 == v194)
  {
    *CFArrayRef v175 = 0;
    v175[1] = 0;
    v175[2] = 0;
    goto LABEL_206;
  }
  uint64_t v20 = v17;
  uint64_t v21 = v17;
  uint64_t v178 = v7;
  unint64_t v179 = (char *)&v17[2 * v16];
  unint64_t v180 = v16;
  uint64_t v177 = a1 + 8;
LABEL_17:
  if (v16 > ((char *)v20 - (char *)v21) >> 4) {
    goto LABEL_20;
  }
  if (v21 == v20) {
    __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
  }
  if (*((double *)v18 - 4) > v21[1])
  {
LABEL_20:
    if (v19 == v18) {
      __assert_rtn("best", "PriorityQueue.h", 46, "!m_predictions.empty()");
    }
    long long v188 = *(_OWORD *)(v18 - 40);
    CFStringRef v190 = 0;
    uint64_t v191 = 0;
    std::string::size_type v189 = 0;
    unsigned int v23 = (unsigned char *)*((void *)v18 - 3);
    uint64_t v22 = (unsigned char *)*((void *)v18 - 2);
    int64_t v24 = v22 - v23;
    if (v22 == v23)
    {
      unint64_t v25 = (unint64_t)v20;
      __int16 v26 = v21;
      if (v23)
      {
LABEL_24:
        *((void *)v18 - 2) = v23;
        operator delete(v23);
      }
    }
    else
    {
      if (v24 < 0) {
        sub_19E37C7C4();
      }
      unint64_t v25 = (unint64_t)v20;
      __int16 v26 = v21;
      std::string::size_type v189 = operator new(v22 - v23);
      CFStringRef v190 = v189;
      int v27 = (char *)v189 + 4 * (v24 >> 2);
      uint64_t v191 = v27;
      memcpy(v189, v23, v24);
      CFStringRef v190 = v27;
      unsigned int v23 = (unsigned char *)*((void *)v18 - 3);
      if (v23) {
        goto LABEL_24;
      }
    }
    size_t v194 = v18 - 40;
    uint64_t v28 = *(void *)(a1 + 88);
    uint64_t v29 = *(unsigned int *)(v28 + 12 * v188);
    uint64_t v205 = 0;
    size_t v206 = 0;
    std::string::size_type v207 = 0;
    if (v29)
    {
      __int16 v30 = (int32x4_t *)operator new(4 * v29);
      uint64_t v205 = v30;
      std::string::size_type v207 = &v30->i32[v29];
      bzero(v30, 4 * v29);
      int v31 = (int32x4_t *)((char *)v30 + 4 * v29);
      size_t v206 = (char *)v31;
      unsigned int v32 = *(_DWORD *)(v28 + 12 * v188 + 4);
      if ((unint64_t)(4 * v29 - 4) >= 0x1C)
      {
        unint64_t v33 = ((unint64_t)(4 * v29 - 4) >> 2) + 1;
        uint64_t v34 = v33 & 0x7FFFFFFFFFFFFFF8;
        int32x4_t v35 = vaddq_s32(vdupq_n_s32(v32), (int32x4_t)xmmword_19E573230);
        int v36 = v30 + 1;
        uint64_t v37 = v33 & 0x7FFFFFFFFFFFFFF8;
        v38.i64[0] = 0x400000004;
        v38.i64[1] = 0x400000004;
        v39.i64[0] = 0x800000008;
        v39.i64[1] = 0x800000008;
        do
        {
          v36[-1] = v35;
          int32x4_t *v36 = vaddq_s32(v35, v38);
          int32x4_t v35 = vaddq_s32(v35, v39);
          v36 += 2;
          v37 -= 8;
        }
        while (v37);
        if (v33 == v34) {
          goto LABEL_32;
        }
        v32 += v34;
        __int16 v30 = (int32x4_t *)((char *)v30 + 4 * (v33 & 0x7FFFFFFFFFFFFFF8));
      }
      do
      {
        v30->i32[0] = v32;
        __int16 v30 = (int32x4_t *)((char *)v30 + 4);
        ++v32;
      }
      while (v30 != v31);
    }
LABEL_32:
    uint64_t v204 = 0;
    (*(void (**)(uint64_t, void **, uint64_t, uint64_t *))(*(void *)v7 + 48))(v7, &v189, a1 + 184, &v204);
    uint64_t v41 = (char *)v205;
    __int16 v40 = (unsigned int *)v206;
    if ((unint64_t)((v206 - (char *)v205) >> 2) >= *(void *)(a1 + 40)) {
      uint64_t v42 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v42 = (v206 - (char *)v205) >> 2;
    }
    if (v42)
    {
      if (v42 >= 2)
      {
        unint64_t v43 = (unint64_t)(v42 - 2) >> 1;
        unint64_t v44 = v43 + 1;
        long long v45 = &v205->i8[4 * v43];
        do
        {
          sub_19E4A60A8((uint64_t)v41, v177, v42, v45);
          v45 -= 4;
          --v44;
        }
        while (v44);
      }
      uint64_t v46 = (unsigned int *)&v41[4 * v42];
      if (v46 != v40)
      {
        float v47 = (unsigned int *)&v41[4 * v42];
        do
        {
          uint64_t v48 = *v47;
          uint64_t v49 = *(unsigned int *)v41;
          if (*(float *)(*(void *)(a1 + 184) + 4 * *(unsigned int *)(*(void *)(a1 + 104) + 16 * v48 + 8)) > *(float *)(*(void *)(a1 + 184) + 4 * *(unsigned int *)(*(void *)(a1 + 104) + 16 * v49 + 8)))
          {
            *float v47 = v49;
            *(_DWORD *)uint64_t v41 = v48;
            sub_19E4A60A8((uint64_t)v41, v177, v42, v41);
          }
          ++v47;
        }
        while (v47 != v40);
      }
      if (v42 >= 2)
      {
        uint64_t v50 = v42 & 0x3FFFFFFFFFFFFFFFLL;
        do
        {
          uint64_t v52 = 0;
          unsigned int v53 = *(_DWORD *)v41;
          unint64_t v54 = (unsigned int *)v41;
          do
          {
            long long v55 = v54;
            v54 += v52 + 1;
            uint64_t v56 = 2 * v52;
            uint64_t v52 = (2 * v52) | 1;
            uint64_t v57 = v56 + 2;
            if (v57 < v50
              && *(float *)(*(void *)(a1 + 184) + 4 * *(unsigned int *)(*(void *)(a1 + 104) + 16 * *v54 + 8)) > *(float *)(*(void *)(a1 + 184) + 4 * *(unsigned int *)(*(void *)(a1 + 104) + 16 * v54[1] + 8)))
            {
              ++v54;
              uint64_t v52 = v57;
            }
            *long long v55 = *v54;
          }
          while (v52 <= (uint64_t)((unint64_t)(v50 - 2) >> 1));
          if (v54 == --v46)
          {
            *unint64_t v54 = v53;
          }
          else
          {
            *unint64_t v54 = *v46;
            *uint64_t v46 = v53;
            uint64_t v58 = (char *)v54 - v41 + 4;
            if (v58 >= 5)
            {
              unint64_t v59 = (((unint64_t)v58 >> 2) - 2) >> 1;
              uint64_t v60 = (unsigned int *)&v41[4 * v59];
              uint64_t v61 = *v60;
              uint64_t v62 = *v54;
              uint64_t v63 = *(void *)(a1 + 104);
              uint64_t v64 = *(void *)(a1 + 184);
              uint64_t v65 = v63 + 16 * v62;
              unsigned int v67 = *(_DWORD *)(v65 + 8);
              __int16 v66 = (unsigned int *)(v65 + 8);
              if (*(float *)(v64 + 4 * *(unsigned int *)(v63 + 16 * v61 + 8)) > *(float *)(v64 + 4 * v67))
              {
                do
                {
                  unint64_t v68 = v60;
                  *unint64_t v54 = v61;
                  if (!v59) {
                    break;
                  }
                  unint64_t v59 = (v59 - 1) >> 1;
                  uint64_t v60 = (unsigned int *)&v41[4 * v59];
                  uint64_t v61 = *v60;
                  unint64_t v54 = v68;
                }
                while (*(float *)(v64 + 4 * *(unsigned int *)(v63 + 16 * v61 + 8)) > *(float *)(v64 + 4 * *v66));
                unsigned int *v68 = v62;
              }
            }
          }
        }
        while (v50-- > 2);
      }
    }
    unint64_t v69 = (v206 - (char *)v205) >> 2;
    if (v42 <= v69)
    {
      if (v42 < v69) {
        size_t v206 = &v205->i8[4 * v42];
      }
    }
    else
    {
      sub_19E3F9C70((uint64_t)&v205, v42 - v69);
    }
    unint64_t v70 = v189;
    v202 = 0;
    uint64_t v203 = 0;
    std::string::size_type v201 = 0;
    int64_t v71 = v190 - (unsigned char *)v189;
    if (v190 == v189)
    {
      int8x16_t v72 = 0;
    }
    else
    {
      if (v71 < 0) {
        sub_19E37C7C4();
      }
      int8x16_t v72 = (char *)operator new(v190 - (unsigned char *)v189);
      std::string::size_type v201 = v72;
      v202 = v72;
      uint64_t v203 = &v72[4 * (v71 >> 2)];
      memmove(v72, v70, v71);
      v202 = &v72[4 * (v71 >> 2)];
    }
    int8x16_t v73 = v205;
    CFComparisonResult v184 = (unsigned int *)v206;
    unint64_t v16 = v180;
    if (v205 == (int32x4_t *)v206)
    {
      if (!v72) {
        goto LABEL_72;
      }
      goto LABEL_71;
    }
    while (1)
    {
      uint64_t v75 = v73->u32[0];
      uint64_t v76 = *(void *)(a1 + 104);
      float v200 = 0.0;
      uint64_t v199 = 0;
      uint64_t v187 = v76;
      uint64_t v77 = v76 + 16 * v75;
      unsigned int v79 = *(_DWORD *)(v77 + 8);
      std::string::size_type v78 = (_DWORD *)(v77 + 8);
      (*(void (**)(uint64_t, void, char **, float *, uint64_t *))(*(void *)v7 + 16))(v7, v79, &v201, &v200, &v199);
      float v80 = v200;
      float v81 = log10f(v200);
      if (v80 <= 0.0) {
        float v81 = -10.0;
      }
      double v82 = *((double *)&v188 + 1) + v81;
      unint64_t v83 = (uint64_t)(v25 - (void)v26) >> 4;
      if (v83 >= v16)
      {
        if (v26 == (double *)v25) {
          __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
        }
        if (v82 < v26[1]) {
          goto LABEL_78;
        }
      }
      uint64_t v181 = v25 - (void)v26;
      std::string::size_type v84 = v202;
      if (v202 < v203)
      {
        *(_DWORD *)v202 = *v78;
        long long v74 = v84 + 4;
        goto LABEL_108;
      }
      uint64_t v182 = v75;
      uint64_t v185 = v26;
      int v85 = v201;
      uint64_t v86 = (v202 - v201) >> 2;
      unint64_t v87 = v86 + 1;
      if ((unint64_t)(v86 + 1) >> 62) {
        sub_19E37C7C4();
      }
      uint64_t v88 = v203 - v201;
      if ((v203 - v201) >> 1 > v87) {
        unint64_t v87 = v88 >> 1;
      }
      if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v89 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v89 = v87;
      }
      if (v89)
      {
        if (v89 >> 62) {
          sub_19E37C2B8();
        }
        std::string::size_type v90 = operator new(4 * v89);
      }
      else
      {
        std::string::size_type v90 = 0;
      }
      float v91 = &v90[4 * v86];
      *(_DWORD *)float v91 = *v78;
      long long v74 = v91 + 4;
      if (v84 == v85)
      {
        unint64_t v16 = v180;
      }
      else
      {
        unint64_t v92 = v84 - 4 - v85;
        if (v92 >= 0x2C)
        {
          unint64_t v16 = v180;
          if ((unint64_t)(v85 - v90) >= 0x20)
          {
            uint64_t v93 = (v92 >> 2) + 1;
            int v94 = &v90[4 * v86 - 16];
            size_t v95 = (long long *)(v84 - 16);
            uint64_t v96 = v93 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v97 = *v95;
              *(v94 - 1) = *(v95 - 1);
              *int v94 = v97;
              v94 -= 2;
              v95 -= 2;
              v96 -= 8;
            }
            while (v96);
            v91 -= 4 * (v93 & 0x7FFFFFFFFFFFFFF8);
            v84 -= 4 * (v93 & 0x7FFFFFFFFFFFFFF8);
            if (v93 == (v93 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_105;
            }
          }
        }
        else
        {
          unint64_t v16 = v180;
        }
        do
        {
          int v98 = *((_DWORD *)v84 - 1);
          v84 -= 4;
          *((_DWORD *)v91 - 1) = v98;
          v91 -= 4;
        }
        while (v84 != v85);
      }
LABEL_105:
      std::string::size_type v201 = v91;
      v202 = v74;
      uint64_t v203 = &v90[4 * v89];
      if (v85) {
        operator delete(v85);
      }
      __int16 v26 = v185;
      uint64_t v7 = v178;
      uint64_t v75 = v182;
LABEL_108:
      v202 = v74;
      uint64_t v99 = v187 + 16 * v75;
      int v101 = *(_DWORD *)(v99 + 12);
      int v100 = (int *)(v99 + 12);
      if (v101)
      {
        float v196 = 0.0;
        (*(void (**)(uint64_t, uint64_t, char **, float *, uint64_t *))(*(void *)v7 + 16))(v7, 4, &v201, &v196, &v199);
        float v102 = v196;
        float v103 = log10f(v196);
        if (v102 <= 0.0) {
          float v103 = -10.0;
        }
        double v104 = v82 + v103;
        int v105 = *v100;
        if (v83 >= v16)
        {
          if (v26 == (double *)v25) {
            __assert_rtn("worst", "PriorityQueue.h", 55, "!m_predictions.empty()");
          }
          double v113 = v26[1];
          if (v104 >= v113)
          {
            std::string::size_type v114 = v26;
            do
            {
              uint64_t v115 = &v114[2 * (v83 >> 1)];
              double v116 = v115[1];
              uint64_t v117 = v115 + 2;
              if (v104 < v116)
              {
                v83 >>= 1;
              }
              else
              {
                std::string::size_type v114 = v117;
                v83 += ~(v83 >> 1);
              }
            }
            while (v83);
            int64_t v118 = v26 + 2;
            if (v26 + 2 != v114)
            {
              int v119 = *(_DWORD *)v26;
              *(_DWORD *)__int16 v26 = *((_DWORD *)v26 + 4);
              *((_DWORD *)v26 + 4) = v119;
              v26[1] = v26[3];
              v26[3] = v113;
              if (v26 + 4 != v114)
              {
                std::string::size_type v120 = v26 + 5;
                do
                {
                  uint64_t v121 = v120;
                  uint64_t v122 = *(v120 - 2);
                  *(v120 - 2) = *v120;
                  *std::string::size_type v120 = v122;
                  uint64_t v123 = v120 + 2;
                  int v124 = (double *)(v120 + 1);
                  int v127 = *((_DWORD *)v120 - 6);
                  std::string::size_type v125 = (double *)(v120 - 3);
                  int v126 = v127;
                  int v129 = *((_DWORD *)v121 - 2);
                  size_t v128 = (double *)(v121 - 1);
                  *(_DWORD *)std::string::size_type v125 = v129;
                  if (v125 == v118) {
                    int64_t v118 = v128;
                  }
                  *(_DWORD *)size_t v128 = v126;
                  std::string::size_type v120 = v123;
                }
                while (v124 != v114);
                if (v128 != v118)
                {
                  float v130 = v118;
                  while (1)
                  {
                    int v131 = *(_DWORD *)v128;
                    *(_DWORD *)size_t v128 = *(_DWORD *)v130;
                    *(_DWORD *)float v130 = v131;
                    uint64_t v132 = *((void *)v128 + 1);
                    v128[1] = v130[1];
                    *((void *)v130 + 1) = v132;
                    v128 += 2;
                    v130 += 2;
                    BOOL v133 = v128 == v118;
                    if (v130 == v114)
                    {
                      if (v128 == v118) {
                        break;
                      }
                      float v130 = v118 + 2;
                      int v134 = *(_DWORD *)v118;
                      uint64_t v135 = *((void *)v118 + 1);
                      while (1)
                      {
                        uint64_t v136 = v135;
                        int v137 = *(_DWORD *)v128;
                        *(_DWORD *)size_t v128 = v134;
                        *(_DWORD *)int64_t v118 = v137;
                        uint64_t v135 = *((void *)v128 + 1);
                        *((void *)v128 + 1) = v136;
                        *((void *)v118 + 1) = v135;
                        v128 += 2;
                        BOOL v133 = v128 == v118;
                        if (v130 != v114) {
                          break;
                        }
                        int v134 = v137;
                        if (v128 == v118) {
                          goto LABEL_141;
                        }
                      }
                    }
                    if (v133) {
                      int64_t v118 = v130;
                    }
                  }
                }
              }
            }
LABEL_141:
            *((_DWORD *)v114 - 4) = v105;
            *(v114 - 1) = v104;
          }
          goto LABEL_184;
        }
        if ((double *)v25 == v26)
        {
          uint64_t v112 = v83;
          size_t v107 = (double *)v25;
        }
        else
        {
          unint64_t v106 = v83;
          size_t v107 = v26;
          do
          {
            unint64_t v108 = v106 >> 1;
            uint64_t v109 = &v107[2 * (v106 >> 1)];
            double v110 = v109[1];
            uint64_t v111 = v109 + 2;
            v106 += ~(v106 >> 1);
            if (v104 < v110) {
              unint64_t v106 = v108;
            }
            else {
              size_t v107 = v111;
            }
          }
          while (v106);
          uint64_t v181 = (char *)v107 - (char *)v26;
          uint64_t v112 = ((char *)v107 - (char *)v26) >> 4;
        }
        int v186 = v26;
        std::string::size_type v138 = &v26[2 * v112];
        if (v25 < (unint64_t)v179)
        {
          if (v138 == (double *)v25)
          {
            *(_DWORD *)unint64_t v25 = v105;
            *(double *)(v25 + 8) = v104;
            v25 += 16;
            __int16 v26 = v186;
          }
          else
          {
            int v139 = (long long *)(v25 - 16);
            uint64_t v140 = (_OWORD *)v25;
            if (v25 >= 0x10)
            {
              do
              {
                long long v141 = *v139++;
                *v140++ = v141;
              }
              while ((unint64_t)v139 < v25);
            }
            if ((double *)v25 != v138 + 2)
            {
              int v142 = (void *)(v25 - 8);
              uint64_t v143 = 2 * ((uint64_t)(v25 - (void)(v138 + 2)) >> 4);
              do
              {
                *((_DWORD *)v142 - 2) = LODWORD(v138[v143 - 2]);
                *int v142 = *(void *)&v138[v143 - 1];
                v142 -= 2;
                v143 -= 2;
              }
              while (v143 * 8);
            }
            *(_DWORD *)std::string::size_type v138 = v105;
            __int16 v26 = v186;
            v186[2 * v112 + 1] = v104;
            unint64_t v25 = (unint64_t)v140;
          }
          goto LABEL_184;
        }
        unint64_t v144 = v83 + 1;
        if ((v83 + 1) >> 60) {
          sub_19E37C7C4();
        }
        unint64_t v145 = v25;
        if ((v179 - (char *)v186) >> 3 > v144) {
          unint64_t v144 = (v179 - (char *)v186) >> 3;
        }
        if ((unint64_t)(v179 - (char *)v186) >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v146 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v146 = v144;
        }
        uint64_t v183 = v75;
        if (v146)
        {
          if (v146 >> 60) {
            sub_19E37C2B8();
          }
          uint64_t v147 = v112;
          uint64_t v148 = v7;
          int v149 = v105;
          unint64_t v150 = (char *)operator new(16 * v146);
          int v105 = v149;
          uint64_t v7 = v148;
          uint64_t v112 = v147;
        }
        else
        {
          unint64_t v150 = 0;
        }
        unint64_t v151 = &v150[16 * v112];
        unint64_t v179 = &v150[16 * v146];
        if (v112 == v146)
        {
          uint64_t v152 = (double *)v145;
          if (v181 < 1)
          {
            CFLocaleRef v154 = v150;
            int v176 = v105;
            if (v107 == v186) {
              unint64_t v155 = 1;
            }
            else {
              unint64_t v155 = v181 >> 3;
            }
            unint64_t v16 = v180;
            if (v155 >> 60) {
              sub_19E37C2B8();
            }
            unint64_t v151 = (char *)operator new(16 * v155);
            unint64_t v179 = &v151[16 * v155];
            if (v154) {
              operator delete(v154);
            }
            int v105 = v176;
          }
          else
          {
            unint64_t v153 = v112 + 2;
            if (v112 >= -1) {
              unint64_t v153 = v112 + 1;
            }
            v151 -= 16 * (v153 >> 1);
            unint64_t v16 = v180;
          }
        }
        else
        {
          uint64_t v152 = (double *)v145;
          unint64_t v16 = v180;
        }
        *(_DWORD *)unint64_t v151 = v105;
        *((double *)v151 + 1) = v104;
        uint64_t v156 = v151;
        if (v112)
        {
          uint64_t v157 = 2 * v112;
          CFIndex v158 = v151;
          do
          {
            uint64_t v156 = v158 - 16;
            *((_OWORD *)v158 - 1) = *(_OWORD *)&v186[v157 - 2];
            v158 -= 16;
            v157 -= 2;
          }
          while (v157 * 8);
        }
        CFIndex v159 = v151 + 16;
        if (v152 == v138)
        {
          uint64_t v75 = v183;
          size_t v161 = v186;
          if (v186) {
            goto LABEL_182;
          }
        }
        else
        {
          uint64_t v75 = v183;
          do
          {
            long long v160 = *(_OWORD *)v138;
            v138 += 2;
            *v159++ = v160;
          }
          while (v138 != v152);
          size_t v161 = v186;
          if (v186) {
LABEL_182:
          }
            operator delete(v161);
        }
        unint64_t v25 = (unint64_t)v159;
        __int16 v26 = (double *)v156;
LABEL_184:
        long long v74 = v202;
      }
      if (*(_DWORD *)(*(void *)(a1 + 104) + 16 * v75 + 4) != 1)
      {
        float v196 = *(float *)(v187 + 16 * v75 + 4);
        __p[0] = *(void **)&v82;
        long long v198 = 0uLL;
        __p[1] = 0;
        std::string::size_type v162 = v201;
        int64_t v163 = v74 - v201;
        if (v74 != v201)
        {
          if (v163 < 0) {
            sub_19E37C7C4();
          }
          __p[1] = operator new(v74 - v201);
          *(void **)&long long v198 = __p[1];
          uint64_t v164 = (char *)__p[1] + 4 * (v163 >> 2);
          *((void *)&v198 + 1) = v164;
          memcpy(__p[1], v162, v163);
          *(void *)&long long v198 = v164;
        }
        sub_19E4A61DC(v192, (unint64_t)&v196);
        if (__p[1])
        {
          *(void **)&long long v198 = __p[1];
          operator delete(__p[1]);
        }
        long long v74 = v202;
      }
      v202 = v74 - 4;
LABEL_78:
      int8x16_t v73 = (int32x4_t *)((char *)v73 + 4);
      if (v73 == (int32x4_t *)v184)
      {
        int8x16_t v72 = v201;
        if (!v201)
        {
LABEL_72:
          uint64_t v21 = v26;
          if (v205)
          {
            size_t v206 = (char *)v205;
            operator delete(v205);
          }
          uint64_t v20 = (double *)v25;
          if (v189)
          {
            CFStringRef v190 = v189;
            operator delete(v189);
          }
          uint64_t v19 = (char *)v193;
          uint64_t v18 = v194;
          if (v193 != v194) {
            goto LABEL_17;
          }
          break;
        }
LABEL_71:
        v202 = v72;
        operator delete(v72);
        goto LABEL_72;
      }
    }
  }
  *CFArrayRef v175 = 0;
  v175[1] = 0;
  v175[2] = 0;
  uint64_t v165 = (char *)v20 - (char *)v21;
  if (v20 != v21)
  {
    if (v165 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v166 = (char *)operator new((char *)v20 - (char *)v21);
    uint64_t v167 = 0;
    *CFArrayRef v175 = v166;
    v175[1] = v166;
    v175[2] = &v166[16 * (v165 >> 4)];
    do
    {
      *(_OWORD *)&v166[v167 * 8] = *(_OWORD *)&v21[v167];
      v167 += 2;
    }
    while (&v21[v167] != v20);
    std::string::size_type v168 = &v166[v167 * 8];
    v175[1] = v168;
    if (v168 != v166)
    {
      for (unint64_t i = (unint64_t)(v168 - 16); (unint64_t)v166 < i; i -= 16)
      {
        int v170 = *(_DWORD *)v166;
        *(_DWORD *)uint64_t v166 = *(_DWORD *)i;
        *(_DWORD *)unint64_t i = v170;
        uint64_t v171 = *((void *)v166 + 1);
        *((void *)v166 + 1) = *(void *)(i + 8);
        *(void *)(i + 8) = v171;
        v166 += 16;
      }
    }
  }
  uint64_t v17 = v21;
  if (v21)
  {
LABEL_206:
    operator delete(v17);
    uint64_t v19 = (char *)v193;
    if (!v193) {
      return;
    }
    goto LABEL_207;
  }
  if (!v19) {
    return;
  }
LABEL_207:
  unint64_t v172 = v194;
  size_t v173 = v19;
  if (v194 != v19)
  {
    do
    {
      std::string::size_type v174 = (void *)*((void *)v172 - 3);
      if (v174)
      {
        *((void *)v172 - 2) = v174;
        operator delete(v174);
      }
      v172 -= 40;
    }
    while (v172 != v19);
    size_t v173 = v193;
  }
  size_t v194 = v19;
  operator delete(v173);
}

void sub_19E527B64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41)
{
  if (v41)
  {
    operator delete(v41);
    unint64_t v43 = __p;
    if (!__p) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    unint64_t v43 = __p;
    if (!__p) {
      goto LABEL_3;
    }
  }
  uint64_t v44 = (uint64_t)a36;
  long long v45 = v43;
  if (a36 != v43)
  {
    do
    {
      uint64_t v46 = *(void **)(v44 - 24);
      if (v46)
      {
        *(void *)(v44 - 16) = v46;
        operator delete(v46);
      }
      v44 -= 40;
    }
    while ((void *)v44 != v43);
    long long v45 = __p;
  }
  operator delete(v45);
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E527D7C()
{
  return 4;
}

uint64_t sub_19E527D84(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t sub_19E527D8C(uint64_t a1)
{
  return a1 + 8;
}

void sub_19E527D94(void *a1)
{
  *a1 = &unk_1EF0B9D60;
  uint64_t v2 = (void *)a1[26];
  if (v2)
  {
    a1[27] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[23];
  if (v3)
  {
    a1[24] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[20];
  if (v4)
  {
    a1[21] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[17];
  if (v5)
  {
    a1[18] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[1];
  if (v6) {
    munmap(v6, a1[2]);
  }
  a1[2] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E527E4C(void *a1)
{
  *a1 = &unk_1EF0B9D60;
  uint64_t v2 = (void *)a1[26];
  if (v2)
  {
    a1[27] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[23];
  if (v3)
  {
    a1[24] = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)a1[20];
  if (v4)
  {
    a1[21] = v4;
    operator delete(v4);
  }
  uint64_t v5 = (void *)a1[17];
  if (v5)
  {
    a1[18] = v5;
    operator delete(v5);
  }
  uint64_t v6 = (void *)a1[1];
  if (v6) {
    munmap(v6, a1[2]);
  }
  a1[2] = 0;
  return a1;
}

uint64_t sub_19E527EE4(uint64_t a1, unsigned int a2, int a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6 = a1 + 3;
  unsigned int v7 = 6 * a4;
  while (a6)
  {
    if (a4) {
      int v8 = 24;
    }
    else {
      int v8 = 0;
    }
    if (++a4 >= a2)
    {
      unsigned int v12 = 0;
    }
    else
    {
      uint64_t v9 = (_DWORD *)((((v7 + 3) >> 3) + v6) & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v10 = (v7 + 3) & 7 | (8 * ((((v7 + 3) >> 3) + v6) & 3));
      int v11 = *v9 >> v10;
      if (v10 >= 0x1E) {
        v11 |= v9[1] << -(char)v10;
      }
      unsigned int v12 = 4 * (v11 & 7);
    }
    char v13 = 4 * (*(_DWORD *)(((v7 >> 3) + v6) & 0xFFFFFFFFFFFFFFFCLL) >> (v7 & 6 | (8 * (((v7 >> 3) + v6) & 3))));
    int v14 = (v13 & 0x1C) + v8;
    int v15 = ((v13 & 0x1C) + (_BYTE)v8 + (_BYTE)v12 + 7) & 0xF8;
    int v16 = v15 * (a6 - 1);
    if ((v13 & 0x1C) != 0)
    {
      uint64_t v17 = ((v16 + v8) >> 3) + a5;
      unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v19 = 8 * (v17 & 3);
      int v20 = *(_DWORD *)(v17 & 0xFFFFFFFFFFFFFFFCLL) >> v19;
      if (v19 + (unint64_t)(v13 & 0x1C) >= 0x21) {
        v20 |= *(_DWORD *)(v18 + 4) << -(char)v19;
      }
      unsigned int v21 = v20 & (0xFFFFFFFF >> -(v13 & 0x1C));
    }
    else
    {
      unsigned int v21 = 0;
    }
    uint64_t result = a5 + ((v21 * ((a3 + 31) & 0xFFFFFFF8)) >> 3) + ((v15 * a6) >> 3);
    if (a4 < a2 && v12)
    {
      uint64_t v23 = ((v16 + v14) >> 3) + a5;
      unint64_t v24 = v23 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v25 = v13 & 4 | (8 * (v23 & 3));
      int v26 = *(_DWORD *)(v23 & 0xFFFFFFFFFFFFFFFCLL) >> v25;
      if (v25 + (unint64_t)v12 >= 0x21) {
        v26 |= *(_DWORD *)(v24 + 4) << -(char)v25;
      }
      v7 += 6;
      a5 = result;
      a6 = v26 & (0xFFFFFFFF >> -(char)v12);
      if (a6) {
        continue;
      }
    }
    return result;
  }
  return a5;
}

uint64_t sub_19E52809C(uint64_t result, unsigned int a2, _DWORD *a3, float a4)
{
  uint64_t v24 = 0;
  if (result)
  {
    int v22 = *(unsigned __int8 *)(result + 6);
    if (a2)
    {
      uint64_t v6 = *(unsigned __int8 *)(result + 7);
      unsigned int v7 = *(unsigned __int8 *)(result + 5);
      uint64_t v8 = *(void *)(result + 24);
      int v9 = *(_DWORD *)(result + 20);
      if (v7 >= a2 && v8 != 0 && *(_DWORD *)(result + 16) != 0 && v9 != 0 && v6 != 0)
      {
        int v14 = 0;
        int v15 = 0;
        unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v6;
        do
        {
          uint64_t v17 = ((v14 + 24) >> 3) + v8;
          unint64_t v18 = v17 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v19 = v14 & 7 | (8 * (v17 & 7));
          uint64_t v20 = *(void *)(v17 & 0xFFFFFFFFFFFFFFF8) >> v19;
          if ((unint64_t)(v19 + v6) >= 0x41) {
            v20 |= *(void *)(v18 + 8) << -(char)v19;
          }
          uint64_t result = v20 & v16;
          if ((v20 & v16) != 0)
          {
            uint64_t v23 = 0;
            uint64_t result = sub_19E52821C(result, v7, v22, a2, result + ((6 * (unint64_t)v7 + 4) >> 3) + 3, (int *)&v23 + 1, (unsigned int *)&v23, a4);
            v15 += HIDWORD(v23);
            HIDWORD(v++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v15;
          }
          v14 += v6 + 24;
          --v9;
        }
        while (v9);
      }
    }
    else
    {
      uint64_t result = *(void *)(result + 32);
      if (result) {
        uint64_t result = sub_19E52821C(result, 1u, v22, 1u, result + 4, (int *)&v24 + 1, (unsigned int *)&v24, a4);
      }
    }
  }
  if (a3) {
    *a3 = HIDWORD(v24);
  }
  return result;
}

uint64_t sub_19E52821C(uint64_t a1, unsigned int a2, int a3, unsigned int a4, uint64_t a5, int *a6, unsigned int *a7, float a8)
{
  uint64_t v8 = a1 + 3;
  unsigned int v9 = (a3 + 31) & 0xFFFFFFF8;
  unsigned int v10 = 1;
  unsigned int v11 = 3;
  uint64_t result = 24;
  for (int i = 1; ; int i = v34)
  {
    int v14 = v10 == 1 ? 0 : 24;
    int v15 = *(_DWORD *)((((v11 - 3) >> 3) + v8) & 0xFFFFFFFFFFFFFFFCLL) >> ((v11 - 3) & 6 | (8
                                                                                         * ((((v11 - 3) >> 3) + v8) & 3)));
    if (v10 >= a2)
    {
      unsigned int v20 = 0;
    }
    else
    {
      uint64_t v16 = (v11 >> 3) + v8;
      unint64_t v17 = v16 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v18 = v11 & 7 | (8 * (v16 & 3));
      int v19 = *(_DWORD *)(v16 & 0xFFFFFFFFFFFFFFFCLL) >> v18;
      if (v18 >= 0x1E) {
        v19 |= *(_DWORD *)(v17 + 4) << -(char)v18;
      }
      unsigned int v20 = 4 * (v19 & 7);
    }
    char v21 = 4 * v15;
    uint64_t v22 = (4 * (_BYTE)v15) & 0x1C;
    int v23 = (((4 * (_BYTE)v15) & 0x1C) + (_BYTE)v14 + (_BYTE)v20 + 7) & 0xF8;
    int v24 = v23 * (i - 1);
    if (v22) {
      break;
    }
    unsigned int v29 = 0;
    if (a4 == v10) {
      goto LABEL_23;
    }
LABEL_16:
    if (v10 >= a4 || v10 >= a2 || !v20) {
      return result;
    }
    uint64_t v30 = ((v24 + v22 + v14) >> 3) + a5;
    unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v32 = v21 & 4 | (8 * (v30 & 3));
    int v33 = *(_DWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL) >> v32;
    if (v32 + (unint64_t)v20 >= 0x21) {
      v33 |= *(_DWORD *)(v31 + 4) << -(char)v32;
    }
    unsigned int v34 = v33 & (0xFFFFFFFF >> -(char)v20);
    if (!v34) {
      return result;
    }
    a5 += ((v29 * v9) >> 3) + (unint64_t)((v23 * i) >> 3);
    ++v10;
    v11 += 6;
  }
  uint64_t v25 = ((v24 + v14) >> 3) + a5;
  unint64_t v26 = v25 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v27 = 8 * (v25 & 3);
  int v28 = *(_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL) >> v27;
  if (v27 + (unint64_t)v22 >= 0x21) {
    v28 |= *(_DWORD *)(v26 + 4) << -(char)v27;
  }
  unsigned int v29 = v28 & (0xFFFFFFFF >> -(char)v22);
  if (a4 != v10) {
    goto LABEL_16;
  }
LABEL_23:
  if (a8 <= 0.0)
  {
    int v36 = i;
    goto LABEL_51;
  }
  if (v22)
  {
    int v35 = 0;
    unsigned int v29 = 0;
    int v36 = 0;
    uint64_t result = 0xFFFFFFFF >> -(char)v22;
    do
    {
      uint64_t v37 = ((v35 * v23 + v14) >> 3) + a5;
      unint64_t v38 = v37 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v39 = 8 * (v37 & 3);
      int v40 = *(_DWORD *)(v37 & 0xFFFFFFFFFFFFFFFCLL) >> v39;
      if ((unint64_t)(v39 + v22) >= 0x21) {
        v40 |= *(_DWORD *)(v38 + 4) << -(char)v39;
      }
      if (v35)
      {
        uint64_t v41 = (((v35 - 1) * v23 + v14) >> 3) + a5;
        unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v43 = 8 * (v41 & 3);
        int v44 = *(_DWORD *)(v41 & 0xFFFFFFFFFFFFFFFCLL) >> v43;
        if ((unint64_t)(v43 + v22) >= 0x21) {
          v44 |= *(_DWORD *)(v42 + 4) << -(char)v43;
        }
        unsigned int v45 = v44 & result;
      }
      else
      {
        unsigned int v45 = 0;
      }
      unsigned int v46 = v40 & result;
      float v47 = 0.0;
      BOOL v48 = v46 >= v45;
      unsigned int v49 = v46 - v45;
      if (v49 != 0 && v48)
      {
        unsigned int v50 = a3 + ((a3 + 31) & 0xFFFFFFF8) * v45;
        do
        {
          uint64_t v55 = (v50 >> 3) + a5 + ((v23 * i) >> 3);
          unint64_t v56 = v55 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v57 = a3 & 7 | (8 * (v55 & 3));
          unsigned int v58 = *(_DWORD *)(v55 & 0xFFFFFFFFFFFFFFFCLL) >> v57;
          if (v57 >= 9) {
            v58 |= *(_DWORD *)(v56 + 4) << -(char)v57;
          }
          int v51 = (v58 >> 22) & 3;
          float v52 = (float)(v58 & 0x3FFFFF);
          float v53 = v52 * 0.0078125;
          float v54 = v52 * 0.000061035;
          if (!v51) {
            float v52 = v52 * 0.00000095367;
          }
          if (v51 == 1) {
            float v52 = v54;
          }
          if (v51 == 2) {
            float v52 = v53;
          }
          float v47 = v52 + v47;
          if (v52 >= a8) {
            ++v29;
          }
          v50 += v9;
          --v49;
        }
        while (v49);
      }
      if (v47 >= a8) {
        ++v36;
      }
      ++v35;
    }
    while (v35 != i);
LABEL_51:
    if (a6) {
LABEL_52:
    }
      *a6 = v36;
  }
  else
  {
    unsigned int v29 = 0;
    if (a8 > 0.0) {
      int v36 = 0;
    }
    else {
      int v36 = i;
    }
    if (a6) {
      goto LABEL_52;
    }
  }
  if (a7) {
    *a7 = v29;
  }
  return result;
}

void *sub_19E5285A4(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int *a6)
{
  unsigned int v11 = 2 * a2;
  unsigned int v12 = malloc_type_calloc(((((a5 + 24) * 2 * a2 + 7) >> 3) & 0x1FFFFFF8) + 8, 1uLL, 0x4E18D228uLL);
  if (v12)
  {
    if (!a3 || !a4) {
      goto LABEL_17;
    }
    unsigned int v13 = 0;
    unsigned int v14 = a4 + 24;
    uint64_t v15 = a4;
    unint64_t v16 = 0xFFFFFFFFFFFFFFFFLL >> -(char)a4;
    do
    {
      while (1)
      {
        uint64_t v19 = ((v13 * v14 + 24) >> 3) + a1;
        unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v21 = ((_BYTE)v13 * (_BYTE)v14) & 7 | (8 * (v19 & 7));
        uint64_t v22 = *(void *)(v19 & 0xFFFFFFFFFFFFFFF8) >> v21;
        if ((unint64_t)(v21 + v15) >= 0x41) {
          v22 |= *(void *)(v20 + 8) << -(char)v21;
        }
        unint64_t v23 = v22 & v16;
        if ((v22 & v16) != 0) {
          break;
        }
        if (++v13 >= a3) {
          goto LABEL_17;
        }
      }
      uint64_t v24 = ((v13 * v14) >> 3) + a1;
      unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v26 = (v13 * v14) & 7 | (8 * (v24 & 3));
      int v27 = *(_DWORD *)(v24 & 0xFFFFFFFFFFFFFFFCLL) >> v26;
      if (v26 >= 9) {
        v27 |= *(_DWORD *)(v25 + 4) << -(char)v26;
      }
      int v17 = sub_19E528720((uint64_t)v12, v11, a5, v27 & 0xFFFFFF, v23);
      ++v13;
      if (v17) {
        BOOL v18 = v13 >= a3;
      }
      else {
        BOOL v18 = 1;
      }
    }
    while (!v18);
    if ((v17 & 1) == 0)
    {
      free(v12);
      return 0;
    }
    else
    {
LABEL_17:
      if (a6) {
        *a6 = v11;
      }
    }
  }
  return v12;
}

uint64_t sub_19E528720(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unint64_t a5)
{
  unsigned int v5 = a3 + 24;
  unsigned int v6 = -1640531573 * a4 % a2;
  if (a3)
  {
    unsigned int v7 = -1640531573 * a4 % a2;
    while (1)
    {
      unsigned int v8 = v7 * v5;
      uint64_t v9 = (v7 * v5 + 24) >> 3;
      int v10 = (v7 * v5) & 7;
      unsigned int v11 = (void *)((v9 + a1) & 0xFFFFFFFFFFFFFFF8);
      uint64_t v12 = ((_BYTE)v7 * (_BYTE)v5) & 7 | (8 * ((v9 + a1) & 7));
      uint64_t v13 = *v11 >> v12;
      if (v12 + (unint64_t)a3 >= 0x41) {
        v13 |= v11[1] << -(char)v12;
      }
      if ((v13 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3)) == 0) {
        break;
      }
      if (v7 + 1 == a2) {
        unsigned int v7 = 0;
      }
      else {
        ++v7;
      }
      if (v7 == v6) {
        return 0;
      }
    }
  }
  else
  {
    unsigned int v8 = v6 * v5;
    uint64_t v9 = (v6 * v5 + 24) >> 3;
    int v10 = (v6 * v5) & 7;
  }
  unint64_t v15 = (unint64_t)v8 >> 3;
  *(unsigned char *)(a1 + v15) = *(unsigned char *)(a1 + v15) & ~(0xFFu >> v10 << v10) | (((0xFFu >> v10) & a4) << v10);
  unsigned int v16 = v10 | 0x10;
  unsigned int v17 = v15 + 1;
  do
  {
    if (v16 >= 8) {
      int v18 = 8;
    }
    else {
      int v18 = v16;
    }
    *(unsigned char *)(a1 + v17) = (-256 >> (8 - v18)) & *(unsigned char *)(a1 + v17) | (0xFFu >> (8 - v18)) & (a4 >> (24 - v16));
    ++v17;
    v16 -= v18;
  }
  while (v16);
  if (a3)
  {
    unsigned int v19 = v10 + a3 <= 8 ? a3 : 8 - v10;
    *(unsigned char *)(a1 + v9) = *(unsigned char *)(a1 + v9) & ~(0xFFu >> (8 - v19) << v10) | (((0xFFu >> (8 - v19)) & a5) << v10);
    unsigned int v20 = a3 - v19;
    if (a3 != v19)
    {
      unsigned int v21 = v9 + 1;
      do
      {
        if (v20 >= 8) {
          int v22 = 8;
        }
        else {
          int v22 = v20;
        }
        *(unsigned char *)(a1 + v21) = (0xFFu >> (8 - v22)) & (a5 >> (a3 - v20)) | (-256 >> (8 - v22)) & *(unsigned char *)(a1 + v21);
        ++v21;
        v20 -= v22;
      }
      while (v20);
    }
  }
  return 1;
}

void sub_19E5288E0()
{
}

uint64_t *sub_19E528DAC(uint64_t *a1)
{
  if (*a1)
  {
    sub_19E374B30(a1);
    if (*a1) {
      MEMORY[0x19F3BDCF0](*a1, 0x1010C4006136809);
    }
  }
  return a1;
}

void *sub_19E528DFC(void *result, int *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *result;
  if (*result)
  {
    unsigned int v6 = *(unsigned __int8 *)(v4 + 5);
    if (v6 >= a3)
    {
      uint64_t v8 = *(unsigned __int8 *)(v4 + 6);
      if (a3)
      {
        uint64_t v9 = *(void *)(v4 + 24);
        if (v9) {
          BOOL v10 = *(_DWORD *)(v4 + 16) == 0;
        }
        else {
          BOOL v10 = 1;
        }
        if (!v10)
        {
          uint64_t v12 = result;
          unsigned int v13 = *(unsigned __int8 *)(v4 + 7);
          unsigned int v14 = *(_DWORD *)(v4 + 20);
          unint64_t v17 = 0;
          if (!*(void *)(v4 + 40))
          {
            unint64_t v15 = malloc_type_malloc(0x30uLL, 0x100004052888210uLL);
            *(void *)(v4 + 40) = v15;
            if (v15)
            {
              *(void *)&long long v16 = -1;
              *((void *)&v16 + 1) = -1;
              v15[1] = v16;
              v15[2] = v16;
              *unint64_t v15 = v16;
            }
          }
          uint64_t result = (void *)sub_19E5293C0(v9, v14, v13, *(_DWORD **)(*v12 + 40), *a2, 0, &v17);
          if (result) {
            return (void *)sub_19E528F50(v17, v6, v8, (uint64_t)a2, a3, 0, v17 + ((6 * (unint64_t)v6 + 4) >> 3) + 3, 1, 0, 1u, a4);
          }
        }
      }
      else
      {
        uint64_t result = *(void **)(v4 + 32);
        if (result)
        {
          int v18 = 0;
          return (void *)sub_19E528F50((uint64_t)result, 1u, v8, (uint64_t)&v18, 1u, 0, (uint64_t)result + 4, 1, 0, 1u, a4);
        }
      }
    }
  }
  return result;
}

uint64_t sub_19E528F50(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, int a8, unsigned int a9, unsigned int a10, uint64_t a11)
{
  if (a8 && a9 < a10)
  {
    unsigned int v14 = *(_DWORD *)(a4 + 4 * a6);
    if (a6) {
      unsigned int v15 = 24;
    }
    else {
      unsigned int v15 = 0;
    }
    uint64_t v16 = (((3 * a6) >> 2) & 0x1FFFFFFF) + result + 3;
    LODWORD(v16) = *(_DWORD *)(v16 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a6) & 6 | (8 * (v16 & 3)));
    char v62 = 4 * v16;
    unsigned int v17 = (4 * v16) & 0x1C;
    unsigned int v67 = a6 + 1;
    uint64_t v63 = result;
    if (a6 + 1 >= a2)
    {
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v18 = 6 * a6 + 3;
      uint64_t v19 = (v18 >> 3) + result + 3;
      unsigned int v20 = (_DWORD *)(v19 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v21 = v18 & 7 | (8 * (v19 & 3));
      int v22 = *v20 >> v21;
      if (v21 >= 0x1E) {
        v22 |= v20[1] << -(char)v21;
      }
      unsigned int v23 = 4 * (v22 & 7);
    }
    unsigned int v71 = 0;
    unsigned int v70 = 0;
    int v24 = ((_BYTE)v17 + (_BYTE)v15 + (_BYTE)v23 + 7) & 0xF8;
    uint64_t v69 = 0;
    uint64_t result = sub_19E5295EC(a7, a9, a10, v24, v15, v17, v23, v14, 0, &v70, &v71, (unsigned int *)&v69, (unsigned int *)&v69 + 1);
    if (result)
    {
      int v26 = a3;
      unsigned int v27 = a3 + 31;
      int v68 = (a3 + 31) & 0xFFFFFFF8;
      uint64_t v28 = a7 + ((v24 * a8) >> 3);
      if (v67 == a5)
      {
        unsigned int v29 = v70;
        if (v70 < v71)
        {
          if (a3)
          {
            unsigned int v30 = 8 * v70 * (v27 >> 3);
            do
            {
              uint64_t v35 = (v30 >> 3) + v28;
              unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFFCLL;
              uint64_t v37 = 8 * (v35 & 3);
              int v38 = *(_DWORD *)(v35 & 0xFFFFFFFFFFFFFFFCLL) >> v37;
              if (v37 + (unint64_t)a3 >= 0x21) {
                v38 |= *(_DWORD *)(v36 + 4) << -(char)v37;
              }
              uint64_t v39 = ((v26 + v30) >> 3) + v28;
              unint64_t v40 = v39 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v41 = a3 & 7 | (8 * (v39 & 3));
              unsigned int v42 = *(_DWORD *)(v39 & 0xFFFFFFFFFFFFFFFCLL) >> v41;
              if (v41 >= 9) {
                v42 |= *(_DWORD *)(v40 + 4) << -(char)v41;
              }
              uint64_t v31 = v38 & (0xFFFFFFFF >> -(char)a3);
              int v32 = (v42 >> 22) & 3;
              v25.n128_f32[0] = (float)(v42 & 0x3FFFFF);
              float v33 = v25.n128_f32[0] * 0.0078125;
              float v34 = v25.n128_f32[0] * 0.000061035;
              if (!v32) {
                v25.n128_f32[0] = v25.n128_f32[0] * 0.00000095367;
              }
              if (v32 == 1) {
                v25.n128_f32[0] = v34;
              }
              if (v32 == 2) {
                v25.n128_f32[0] = v33;
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(a11 + 16))(a11, v31, v25);
              ++v29;
              v30 += v68;
              int v26 = a3;
            }
            while (v29 < v71);
          }
          else
          {
            unsigned int v49 = 8 * v70 * (v27 >> 3);
            do
            {
              uint64_t v53 = (v49 >> 3) + v28;
              unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v55 = 8 * (v53 & 3);
              unsigned int v56 = *(_DWORD *)(v53 & 0xFFFFFFFFFFFFFFFCLL) >> v55;
              if (v55 >= 9) {
                v56 |= *(_DWORD *)(v54 + 4) << -(char)v55;
              }
              int v50 = (v56 >> 22) & 3;
              v25.n128_f32[0] = (float)(v56 & 0x3FFFFF);
              float v51 = v25.n128_f32[0] * 0.00000095367;
              float v52 = v25.n128_f32[0] * 0.000061035;
              if (v50 == 2) {
                v25.n128_f32[0] = v25.n128_f32[0] * 0.0078125;
              }
              if (v50 == 1) {
                v25.n128_f32[0] = v52;
              }
              if (!v50) {
                v25.n128_f32[0] = v51;
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, void, __n128))(a11 + 16))(a11, 0, v25);
              ++v29;
              v49 += v68;
            }
            while (v29 < v71);
          }
        }
      }
      else if (v69 < HIDWORD(v69))
      {
        int v43 = v24 * (a8 - 1);
        if (v17)
        {
          uint64_t v44 = ((v43 + v15) >> 3) + a7;
          unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v46 = 8 * (v44 & 3);
          int v47 = *(_DWORD *)(v44 & 0xFFFFFFFFFFFFFFFCLL) >> v46;
          if (v46 + (unint64_t)v17 >= 0x21) {
            v47 |= *(_DWORD *)(v45 + 4) << -(char)v46;
          }
          unsigned int v48 = v47 & (0xFFFFFFFF >> -(char)v17);
        }
        else
        {
          unsigned int v48 = 0;
        }
        if (v23)
        {
          uint64_t v57 = ((v43 + v17 + v15) >> 3) + a7;
          unint64_t v58 = v57 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v59 = v62 & 4 | (8 * (v57 & 3));
          int v60 = *(_DWORD *)(v57 & 0xFFFFFFFFFFFFFFFCLL) >> v59;
          if (v59 + (unint64_t)v23 >= 0x21) {
            v60 |= *(_DWORD *)(v58 + 4) << -(char)v59;
          }
          uint64_t v61 = v60 & (0xFFFFFFFF >> -(char)v23);
        }
        else
        {
          uint64_t v61 = 0;
        }
        return sub_19E528F50(v63, a2, a3, a4, a5, v67, v28 + ((v48 * v68) >> 3), v61, v69, a11);
      }
    }
  }
  return result;
}

uint64_t sub_19E5293C0(uint64_t a1, unsigned int a2, unsigned int a3, _DWORD *a4, int a5, unsigned int *a6, unint64_t *a7)
{
  unsigned int v7 = a3 + 24;
  if (a4)
  {
    if (*a4 == a5)
    {
      uint64_t v8 = 1;
      goto LABEL_14;
    }
    if (a4[2] == a5)
    {
      uint64_t v8 = 3;
      goto LABEL_14;
    }
    if (a4[4] == a5)
    {
      uint64_t v8 = 5;
      goto LABEL_14;
    }
    if (a4[6] == a5)
    {
      uint64_t v8 = 7;
      goto LABEL_14;
    }
    if (a4[8] == a5)
    {
      uint64_t v8 = 9;
      goto LABEL_14;
    }
    if (a4[10] == a5)
    {
      uint64_t v8 = 11;
LABEL_14:
      unsigned int v9 = a4[v8];
      if (v9 == -1 || !a3) {
        return 0;
      }
      int v10 = v9 * v7;
      uint64_t v11 = v10 & 7;
      uint64_t v12 = ((v10 + 24) >> 3) + a1;
      unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v14 = v11 & 0xFFFFFFFFFFFFFFC7 | (8 * (v12 & 7));
      uint64_t v15 = *(void *)(v12 & 0xFFFFFFFFFFFFFFF8) >> v14;
      if (v14 + a3 >= 0x41) {
        v15 |= *(void *)(v13 + 8) << -(char)v14;
      }
      unint64_t v16 = v15 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3);
      if (!v16) {
        return 0;
      }
      if (a6) {
        *a6 = v9;
      }
      if (a7) {
        *a7 = v16;
      }
      return 1;
    }
  }
  unsigned int v18 = -1640531573 * a5 % a2;
  if (a3)
  {
    unsigned int v19 = -1640531573 * a5 % a2;
    while (1)
    {
      uint64_t v20 = ((v19 * v7 + 24) >> 3) + a1;
      unint64_t v21 = v20 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v22 = ((_BYTE)v19 * (_BYTE)v7) & 7 | (8 * (v20 & 7));
      uint64_t v23 = *(void *)(v20 & 0xFFFFFFFFFFFFFFF8) >> v22;
      if (v22 + (unint64_t)a3 >= 0x41) {
        v23 |= *(void *)(v21 + 8) << -(char)v22;
      }
      unint64_t v24 = v23 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3);
      if (!v24)
      {
        uint64_t result = 0;
        unsigned int v18 = v19;
        if (a4) {
          goto LABEL_38;
        }
        return result;
      }
      uint64_t v25 = ((v19 * v7) >> 3) + a1;
      unint64_t v26 = v25 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v27 = (v19 * v7) & 7 | (8 * (v25 & 3));
      int v28 = *(_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL) >> v27;
      if (v27 >= 9) {
        v28 |= *(_DWORD *)(v26 + 4) << -(char)v27;
      }
      if ((v28 & 0xFFFFFF) == a5) {
        break;
      }
      if (v19 + 1 == a2) {
        unsigned int v19 = 0;
      }
      else {
        ++v19;
      }
      if (v19 == v18) {
        goto LABEL_37;
      }
    }
    if (a6) {
      *a6 = v19;
    }
    if (a7) {
      *a7 = v24;
    }
    uint64_t result = 1;
    unsigned int v18 = v19;
    if (a4) {
      goto LABEL_38;
    }
  }
  else
  {
LABEL_37:
    uint64_t result = 0;
    if (a4)
    {
LABEL_38:
      long long v29 = *((_OWORD *)a4 + 1);
      *(_OWORD *)(a4 + 2) = *(_OWORD *)a4;
      uint64_t v30 = *((void *)a4 + 4);
      *(_OWORD *)(a4 + 6) = v29;
      *((void *)a4 + 5) = v30;
      if (result) {
        int v31 = v18;
      }
      else {
        int v31 = -1;
      }
      *a4 = a5;
      a4[1] = v31;
    }
  }
  return result;
}

uint64_t sub_19E5295EC(uint64_t a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, _DWORD *a9, unsigned int *a10, unsigned int *a11, unsigned int *a12, unsigned int *a13)
{
  unsigned int v42 = 0;
  if (a5)
  {
    uint64_t result = sub_19E529864(a1, a2, a3, a4, a5, a8, &v42);
    unint64_t v21 = a10;
    uint64_t v20 = a11;
    if (!a9) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  uint64_t result = 1;
  unint64_t v21 = a10;
  uint64_t v20 = a11;
  if (a9) {
LABEL_3:
  }
    *a9 = v42;
LABEL_4:
  if (a6)
  {
    if (v42)
    {
      unsigned int v22 = a5 + (v42 - 1) * a4;
      uint64_t v23 = (_DWORD *)(((v22 >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v24 = v22 & 7 | (8 * (((v22 >> 3) + (_BYTE)a1) & 3));
      int v25 = *v23 >> v24;
      if (v24 + (unint64_t)a6 >= 0x21) {
        v25 |= v23[1] << -(char)v24;
      }
      unsigned int v26 = v25 & (0xFFFFFFFF >> -(char)a6);
    }
    else
    {
      unsigned int v26 = 0;
    }
    unsigned int v27 = v26;
    if (v42 < a3)
    {
      unsigned int v28 = a5 + v42 * a4;
      long long v29 = (_DWORD *)(((v28 >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v30 = v28 & 7 | (8 * (((v28 >> 3) + (_BYTE)a1) & 3));
      int v31 = *v29 >> v30;
      if (v30 + (unint64_t)a6 >= 0x21) {
        v31 |= v29[1] << -(char)v30;
      }
      unsigned int v27 = v31 & (0xFFFFFFFF >> -(char)a6);
    }
    if (v21) {
      *unint64_t v21 = v26;
    }
    if (v20) {
      goto LABEL_23;
    }
  }
  else
  {
    if (v21) {
      *unint64_t v21 = 0;
    }
    if (v20)
    {
      unsigned int v27 = 0;
LABEL_23:
      *uint64_t v20 = v27;
    }
  }
  if (a7)
  {
    if (v42)
    {
      unsigned int v32 = a6 + a5 + (v42 - 1) * a4;
      float v33 = (_DWORD *)(((v32 >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v34 = v32 & 7 | (8 * (((v32 >> 3) + (_BYTE)a1) & 3));
      int v35 = *v33 >> v34;
      if (v34 + (unint64_t)a7 >= 0x21) {
        v35 |= v33[1] << -(char)v34;
      }
      unsigned int v36 = v35 & (0xFFFFFFFF >> -(char)a7);
    }
    else
    {
      unsigned int v36 = 0;
    }
    unsigned int v37 = v36;
    if (v42 < a3)
    {
      unsigned int v38 = a6 + a5 + v42 * a4;
      uint64_t v39 = (_DWORD *)(((v38 >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v40 = v38 & 7 | (8 * (((v38 >> 3) + (_BYTE)a1) & 3));
      int v41 = *v39 >> v40;
      if (v40 + (unint64_t)a7 >= 0x21) {
        v41 |= v39[1] << -(char)v40;
      }
      unsigned int v37 = v41 & (0xFFFFFFFF >> -(char)a7);
    }
    if (a12) {
      *a12 = v36;
    }
    if (a13) {
      goto LABEL_41;
    }
  }
  else
  {
    if (a12) {
      *a12 = 0;
    }
    if (a13)
    {
      unsigned int v37 = 0;
LABEL_41:
      *a13 = v37;
    }
  }
  return result;
}

uint64_t sub_19E529864(uint64_t a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6, unsigned int *a7)
{
  if (a3 <= a2) {
    goto LABEL_34;
  }
  unsigned int v7 = a3 - 1;
  if (!a5)
  {
    unsigned int v15 = 0;
    if (!a6)
    {
      unsigned int v24 = a2;
      goto LABEL_31;
    }
LABEL_9:
    uint64_t result = 0;
    a2 = a3;
    if (!a7) {
      return result;
    }
LABEL_35:
    *a7 = a2;
    return result;
  }
  uint64_t v8 = ((a4 * a2) >> 3) + a1;
  unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v10 = (a4 * a2) & 7 | (8 * (v8 & 3));
  int v11 = *(_DWORD *)(v8 & 0xFFFFFFFFFFFFFFFCLL) >> v10;
  if (v10 + (unint64_t)a5 >= 0x21) {
    v11 |= *(_DWORD *)(v9 + 4) << -(char)v10;
  }
  unsigned int v12 = 0xFFFFFFFF >> -(char)a5;
  unsigned int v13 = v11 & v12;
  if (v13 > a6)
  {
LABEL_34:
    uint64_t result = 0;
    if (!a7) {
      return result;
    }
    goto LABEL_35;
  }
  if (v13 == a6)
  {
    unsigned int v14 = a2;
    goto LABEL_32;
  }
  unsigned int v17 = (_DWORD *)((((v7 * a4) >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
  uint64_t v18 = (v7 * a4) & 7 | (8 * ((((v7 * a4) >> 3) + a1) & 3));
  int v19 = *v17 >> v18;
  if (v18 + (unint64_t)a5 >= 0x21) {
    v19 |= v17[1] << -(char)v18;
  }
  unsigned int v15 = v19 & v12;
  if (v15 < a6) {
    goto LABEL_9;
  }
  if (v15 == a6) {
    unsigned int v20 = a3 - 1;
  }
  else {
    unsigned int v20 = a2;
  }
  if (v20 + 1 >= v7)
  {
    a2 = a3 - 1;
    unsigned int v24 = a3 - 1;
  }
  else
  {
    do
    {
      unsigned int v14 = (v7 + v20) >> 1;
      unint64_t v21 = (_DWORD *)((((v14 * a4) >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v22 = (v14 * a4) & 7 | (8 * ((((v14 * a4) >> 3) + (_BYTE)a1) & 3));
      int v23 = *v21 >> v22;
      if (v22 + (unint64_t)a5 >= 0x21) {
        v23 |= v21[1] << -(char)v22;
      }
      unsigned int v15 = v23 & (0xFFFFFFFF >> -(char)a5);
      if (v15 > a6)
      {
        unsigned int v7 = (v7 + v20) >> 1;
      }
      else
      {
        if (v15 == a6) {
          goto LABEL_32;
        }
        if (v15 < a6) {
          unsigned int v20 = (v7 + v20) >> 1;
        }
      }
    }
    while (v20 + 1 < v7);
    a2 = v7;
    unsigned int v24 = v14;
  }
LABEL_31:
  unsigned int v14 = v24;
  if (v15 != a6) {
    goto LABEL_34;
  }
LABEL_32:
  uint64_t result = 1;
  a2 = v14;
  if (a7) {
    goto LABEL_35;
  }
  return result;
}

void sub_19E529A5C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7, int a8, unsigned int a9, unsigned int a10, int a11, uint64_t a12, float *a13, float *a14)
{
  if (a8 && a9 < a10)
  {
    unsigned int v22 = *(_DWORD *)(a4 + 4 * a6);
    unsigned int v23 = a6 ? 24 : 0;
    int v24 = 6 * a6;
    uint64_t v25 = (((3 * a6) >> 2) & 0x1FFFFFFF) + a1 + 3;
    unsigned int v26 = (4 * (*(_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a6) & 6 | (8 * (v25 & 3))))) & 0x1C;
    unsigned int v27 = a6 + 1;
    int v73 = a8;
    if (a6 + 1 >= a2)
    {
      unsigned int v33 = 0;
    }
    else
    {
      unsigned int v28 = v24 + 3;
      uint64_t v29 = (v28 >> 3) + a1 + 3;
      uint64_t v30 = (_DWORD *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v31 = v28 & 7 | (8 * (v29 & 3));
      int v32 = *v30 >> v31;
      if (v31 >= 0x1E) {
        v32 |= v30[1] << -(char)v31;
      }
      unsigned int v33 = 4 * (v32 & 7);
    }
    uint64_t v76 = 0;
    int v34 = ((_BYTE)v26 + (_BYTE)v23 + (_BYTE)v33 + 7) & 0xF8;
    unsigned int v75 = 0;
    unsigned int v74 = 0;
    if (sub_19E5295EC(a7, a9, a10, v34, v23, v26, v33, v22, 0, (unsigned int *)&v76, (unsigned int *)&v76 + 1, &v74, &v75))
    {
      uint64_t v71 = a1;
      uint64_t v72 = a4;
      unsigned int v70 = a3 + 31;
      int v36 = (a3 + 31) & 0xFFFFFFF8;
      uint64_t v37 = a7 + ((v34 * v73) >> 3);
      if (a6 + 2 == a5)
      {
        if (a14)
        {
          unsigned int v38 = v76;
          if (v76 < HIDWORD(v76))
          {
            unsigned int v39 = 8 * v76 * (v70 >> 3);
            while (1)
            {
              if (a3)
              {
                uint64_t v40 = (v39 >> 3) + v37;
                unint64_t v41 = v40 & 0xFFFFFFFFFFFFFFFCLL;
                uint64_t v42 = 8 * (v40 & 3);
                int v43 = *(_DWORD *)(v40 & 0xFFFFFFFFFFFFFFFCLL) >> v42;
                if (v42 + (unint64_t)a3 >= 0x21) {
                  v43 |= *(_DWORD *)(v41 + 4) << -(char)v42;
                }
                unsigned int v44 = v43 & (0xFFFFFFFF >> -(char)a3);
              }
              else
              {
                unsigned int v44 = 0;
              }
              uint64_t v45 = ((a3 + v39) >> 3) + v37;
              unint64_t v46 = v45 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v47 = a3 & 7 | (8 * (v45 & 3));
              unsigned int v48 = *(_DWORD *)(v45 & 0xFFFFFFFFFFFFFFFCLL) >> v47;
              if (v47 >= 9) {
                v48 |= *(_DWORD *)(v46 + 4) << -(char)v47;
              }
              int v49 = (v48 >> 22) & 3;
              v35.n128_f32[0] = (float)(v48 & 0x3FFFFF);
              float v50 = v35.n128_f32[0] * 0.0078125;
              float v51 = v35.n128_f32[0] * 0.000061035;
              if (!v49) {
                v35.n128_f32[0] = v35.n128_f32[0] * 0.00000095367;
              }
              if (v49 == 1) {
                v35.n128_f32[0] = v51;
              }
              float v52 = v49 == 2 ? v50 : v35.n128_f32[0];
              unsigned int v77 = v44;
              v78[0] = a11;
              uint64_t v53 = *(void *)(a12 + 24);
              if (!v53) {
                break;
              }
              *a14 = *a14
                   + (float)((*(float (**)(uint64_t, _DWORD *, unsigned int *, __n128))(*(void *)v53 + 48))(v53, v78, &v77, v35)* v52);
              ++v38;
              v39 += v36;
              if (v38 >= HIDWORD(v76)) {
                goto LABEL_32;
              }
            }
LABEL_56:
            sub_19E3ACB9C();
          }
        }
      }
LABEL_32:
      if (v27 == a5)
      {
        if (a13)
        {
          unsigned int v54 = v76;
          if (v76 < HIDWORD(v76))
          {
            unsigned int v55 = 8 * v76 * (v70 >> 3);
            while (1)
            {
              if (a3)
              {
                uint64_t v56 = (v55 >> 3) + v37;
                unint64_t v57 = v56 & 0xFFFFFFFFFFFFFFFCLL;
                uint64_t v58 = 8 * (v56 & 3);
                int v59 = *(_DWORD *)(v56 & 0xFFFFFFFFFFFFFFFCLL) >> v58;
                if (v58 + (unint64_t)a3 >= 0x21) {
                  v59 |= *(_DWORD *)(v57 + 4) << -(char)v58;
                }
                unsigned int v60 = v59 & (0xFFFFFFFF >> -(char)a3);
              }
              else
              {
                unsigned int v60 = 0;
              }
              uint64_t v61 = ((a3 + v55) >> 3) + v37;
              unint64_t v62 = v61 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v63 = a3 & 7 | (8 * (v61 & 3));
              unsigned int v64 = *(_DWORD *)(v61 & 0xFFFFFFFFFFFFFFFCLL) >> v63;
              if (v63 >= 9) {
                v64 |= *(_DWORD *)(v62 + 4) << -(char)v63;
              }
              int v65 = (v64 >> 22) & 3;
              v35.n128_f32[0] = (float)(v64 & 0x3FFFFF);
              float v66 = v35.n128_f32[0] * 0.0078125;
              float v67 = v35.n128_f32[0] * 0.000061035;
              if (!v65) {
                v35.n128_f32[0] = v35.n128_f32[0] * 0.00000095367;
              }
              if (v65 == 1) {
                v35.n128_f32[0] = v67;
              }
              float v68 = v65 == 2 ? v66 : v35.n128_f32[0];
              unsigned int v77 = v60;
              v78[0] = a11;
              uint64_t v69 = *(void *)(a12 + 24);
              if (!v69) {
                break;
              }
              *a13 = *a13
                   + (float)((*(float (**)(uint64_t, _DWORD *, unsigned int *, __n128))(*(void *)v69 + 48))(v69, v78, &v77, v35)* v68);
              ++v54;
              v55 += v36;
              if (v54 >= HIDWORD(v76)) {
                return;
              }
            }
            goto LABEL_56;
          }
        }
      }
      else if (v74 < v75)
      {
        sub_19E529A5C(v71, a2, a3, v72);
      }
    }
  }
}

void *sub_19E52A010(void *result, int *a2, uint64_t a3, uint64_t a4, __n128 a5)
{
  uint64_t v5 = *result;
  if (*result)
  {
    unsigned int v7 = *(unsigned __int8 *)(v5 + 5);
    if ((int)a3 + 1 <= v7)
    {
      uint64_t v10 = *(unsigned __int8 *)(v5 + 7);
      unsigned int v30 = *(unsigned __int8 *)(v5 + 6);
      int v11 = *(_DWORD *)(v5 + 16);
      unsigned int v12 = *(_DWORD *)(v5 + 20);
      unsigned int v32 = 0;
      uint64_t v13 = *(void *)(v5 + 24);
      if (a3)
      {
        if (v13) {
          BOOL v14 = v11 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (!v14)
        {
          unsigned int v15 = result;
          unint64_t v31 = 0;
          if (!*(void *)(v5 + 40))
          {
            unint64_t v16 = malloc_type_malloc(0x30uLL, 0x100004052888210uLL);
            *(void *)(v5 + 40) = v16;
            if (v16)
            {
              *(void *)&long long v17 = -1;
              *((void *)&v17 + 1) = -1;
              v16[1] = v17;
              v16[2] = v17;
              *unint64_t v16 = v17;
            }
          }
          uint64_t result = (void *)sub_19E5293C0(v13, v12, v10, *(_DWORD **)(*v15 + 40), *a2, &v32, &v31);
          if (result) {
            return (void *)sub_19E52A244(v31, v7, v30, *a2, (uint64_t)a2, a3, 0, v31 + ((6 * (unint64_t)v7 + 4) >> 3) + 3, v18, 1, 0, 1u, a4);
          }
        }
      }
      else
      {
        if (v12) {
          BOOL v19 = v10 == 0;
        }
        else {
          BOOL v19 = 1;
        }
        if (!v19)
        {
          unsigned int v20 = 0;
          unint64_t v21 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v10;
          do
          {
            uint64_t v22 = ((v20 + 24) >> 3) + v13;
            unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v24 = v20 & 7 | (8 * (v22 & 7));
            uint64_t v25 = *(void *)(v22 & 0xFFFFFFFFFFFFFFF8) >> v24;
            if ((unint64_t)(v24 + v10) >= 0x41) {
              v25 |= *(void *)(v23 + 8) << -(char)v24;
            }
            uint64_t result = (void *)(v25 & v21);
            if ((v25 & v21) != 0)
            {
              uint64_t v26 = (v20 >> 3) + v13;
              unint64_t v27 = v26 & 0xFFFFFFFFFFFFFFFCLL;
              unint64_t v28 = v20 & 7 | (8 * (v26 & 3));
              int v29 = *(_DWORD *)(v26 & 0xFFFFFFFFFFFFFFFCLL) >> v28;
              if (v28 >= 9) {
                v29 |= *(_DWORD *)(v27 + 4) << -(char)v28;
              }
              uint64_t result = (void *)sub_19E52A244((uint64_t)result, v7, v30, v29 & 0xFFFFFF, (uint64_t)a2, 0, 0, (uint64_t)result + ((6 * (unint64_t)v7 + 4) >> 3) + 3, a5, 1, 0, 1u, a4);
            }
            v20 += v10 + 24;
            --v12;
          }
          while (v12);
        }
      }
    }
  }
  return result;
}

uint64_t sub_19E52A244(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, __n128 a9, int a10, unsigned int a11, unsigned int a12, uint64_t a13)
{
  unsigned int v14 = a11;
  if (a10) {
    BOOL v15 = a11 >= a12;
  }
  else {
    BOOL v15 = 1;
  }
  if (!v15)
  {
    if (a7 >= a6) {
      unsigned int v19 = 0;
    }
    else {
      unsigned int v19 = *(_DWORD *)(a5 + 4 * a7);
    }
    if (a7) {
      unsigned int v20 = 24;
    }
    else {
      unsigned int v20 = 0;
    }
    uint64_t v21 = (((3 * a7) >> 2) & 0x1FFFFFFF) + result + 3;
    char v22 = 4 * (*(_DWORD *)(v21 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a7) & 6 | (8 * (v21 & 3))));
    uint64_t v23 = v22 & 0x1C;
    if (a7 + 1 >= a2)
    {
      unsigned int v29 = 0;
    }
    else
    {
      unsigned int v24 = 6 * a7 + 3;
      uint64_t v25 = (v24 >> 3) + result + 3;
      uint64_t v26 = (_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v27 = v24 & 7 | (8 * (v25 & 3));
      int v28 = *v26 >> v27;
      if (v27 >= 0x1E) {
        v28 |= v26[1] << -(char)v27;
      }
      unsigned int v29 = 4 * (v28 & 7);
    }
    int v30 = v23 + v20;
    int v31 = ((_BYTE)v23 + (_BYTE)v20 + (_BYTE)v29 + 7) & 0xF8;
    int v32 = a3 + 31;
    int v33 = v31 * (a10 - 1);
    if ((v22 & 0x1C) != 0)
    {
      uint64_t v34 = ((v33 + v20) >> 3) + a8;
      unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v36 = 8 * (v34 & 3);
      int v37 = *(_DWORD *)(v34 & 0xFFFFFFFFFFFFFFFCLL) >> v36;
      if (v36 + (unint64_t)(v22 & 0x1C) >= 0x21) {
        v37 |= *(_DWORD *)(v35 + 4) << -(char)v36;
      }
      unsigned int v38 = v37 & (0xFFFFFFFF >> -(char)v23);
    }
    else
    {
      unsigned int v38 = 0;
    }
    unsigned int v122 = v32 & 0xFFFFFFF8;
    v125[0] = 0;
    unsigned int v124 = 0;
    uint64_t v123 = 0;
    uint64_t v39 = a8 + ((v31 * a10) >> 3);
    uint64_t v119 = a8;
    if (a7 == a6)
    {
      if (a7)
      {
        unsigned int v117 = 0xFFFFFFFF >> -(v22 & 0x1C);
        unsigned int v40 = 0xFFFFFFFF >> -(char)a3;
        uint64_t v41 = a3 & 7;
        unsigned int v112 = v32 & 0xFFFFFFF8;
        int v113 = ((_BYTE)v23 + (_BYTE)v20 + (_BYTE)v29 + 7) & 0xF8;
        int v42 = a3;
        uint64_t v43 = a3;
        unsigned int v114 = v20;
        while (1)
        {
          uint64_t v44 = ((v14 * v31) >> 3) + v119;
          unint64_t v45 = v44 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v46 = 8 * (v44 & 3);
          int v47 = *(_DWORD *)(v44 & 0xFFFFFFFFFFFFFFFCLL) >> v46;
          if (v46 >= 9) {
            v47 |= *(_DWORD *)(v45 + 4) << -(char)v46;
          }
          if (v23)
          {
            uint64_t v48 = ((v14 * v31 + v20) >> 3) + v119;
            unint64_t v49 = v48 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v50 = 8 * (v48 & 3);
            int v51 = *(_DWORD *)(v48 & 0xFFFFFFFFFFFFFFFCLL) >> v50;
            if ((unint64_t)(v50 + v23) >= 0x21) {
              v51 |= *(_DWORD *)(v49 + 4) << -(char)v50;
            }
            unsigned int v52 = v51 & v117;
            unsigned int v120 = v14;
            if (!v14) {
              goto LABEL_38;
            }
          }
          else
          {
            unsigned int v52 = 0;
            unsigned int v120 = v14;
            if (!v14) {
              goto LABEL_38;
            }
          }
          if (v23)
          {
            uint64_t v53 = ((v20 + (v14 - 1) * v31) >> 3) + v119;
            unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v55 = 8 * (v53 & 3);
            int v56 = *(_DWORD *)(v53 & 0xFFFFFFFFFFFFFFFCLL) >> v55;
            if ((unint64_t)(v55 + v23) >= 0x21) {
              v56 |= *(_DWORD *)(v54 + 4) << -(char)v55;
            }
            unsigned int v57 = v56 & v117;
            unsigned int v58 = v52 - v57;
            if (v52 <= v57) {
              goto LABEL_24;
            }
LABEL_39:
            uint64_t v59 = v47 & 0xFFFFFF;
            if (v42)
            {
              unsigned int v60 = v112 * v57;
              do
              {
                uint64_t v65 = (v60 >> 3) + v39;
                unint64_t v66 = v65 & 0xFFFFFFFFFFFFFFFCLL;
                uint64_t v67 = 8 * (v65 & 3);
                int v68 = *(_DWORD *)(v65 & 0xFFFFFFFFFFFFFFFCLL) >> v67;
                if ((unint64_t)(v67 + v43) >= 0x21) {
                  v68 |= *(_DWORD *)(v66 + 4) << -(char)v67;
                }
                uint64_t v69 = ((v42 + v60) >> 3) + v39;
                unint64_t v70 = v69 & 0xFFFFFFFFFFFFFFFCLL;
                unint64_t v71 = v41 & 0xFFFFFFFFFFFFFFE7 | (8 * (v69 & 3));
                unsigned int v72 = *(_DWORD *)(v69 & 0xFFFFFFFFFFFFFFFCLL) >> v71;
                if (v71 >= 9) {
                  v72 |= *(_DWORD *)(v70 + 4) << -(char)v71;
                }
                uint64_t v61 = v68 & v40;
                int v62 = (v72 >> 22) & 3;
                a9.n128_f32[0] = (float)(v72 & 0x3FFFFF);
                float v63 = a9.n128_f32[0] * 0.0078125;
                float v64 = a9.n128_f32[0] * 0.000061035;
                if (!v62) {
                  a9.n128_f32[0] = a9.n128_f32[0] * 0.00000095367;
                }
                if (v62 == 1) {
                  a9.n128_f32[0] = v64;
                }
                if (v62 == 2) {
                  a9.n128_f32[0] = v63;
                }
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, __n128))(a13 + 16))(a13, v59, v61, a9);
                v60 += v122;
                --v58;
              }
              while (v58);
            }
            else
            {
              unsigned int v73 = v112 * v57;
              do
              {
                uint64_t v77 = (v73 >> 3) + v39;
                unint64_t v78 = v77 & 0xFFFFFFFFFFFFFFFCLL;
                unint64_t v79 = v41 & 0xFFFFFFFFFFFFFFE7 | (8 * (v77 & 3));
                unsigned int v80 = *(_DWORD *)(v77 & 0xFFFFFFFFFFFFFFFCLL) >> v79;
                if (v79 >= 9) {
                  v80 |= *(_DWORD *)(v78 + 4) << -(char)v79;
                }
                int v74 = (v80 >> 22) & 3;
                a9.n128_f32[0] = (float)(v80 & 0x3FFFFF);
                float v75 = a9.n128_f32[0] * 0.00000095367;
                float v76 = a9.n128_f32[0] * 0.000061035;
                if (v74 == 2) {
                  a9.n128_f32[0] = a9.n128_f32[0] * 0.0078125;
                }
                if (v74 == 1) {
                  a9.n128_f32[0] = v76;
                }
                if (!v74) {
                  a9.n128_f32[0] = v75;
                }
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, __n128))(a13 + 16))(a13, v59, 0, a9);
                v73 += v122;
                --v58;
              }
              while (v58);
            }
            goto LABEL_24;
          }
LABEL_38:
          unsigned int v57 = 0;
          unsigned int v58 = v52;
          if (v52) {
            goto LABEL_39;
          }
LABEL_24:
          unsigned int v14 = v120 + 1;
          unsigned int v20 = v114;
          uint64_t v23 = v22 & 0x1C;
          int v31 = v113;
          if (v120 + 1 == a12) {
            return result;
          }
        }
      }
      if (v38)
      {
        int v94 = a3;
        uint64_t v95 = a3 & 7;
        if (a3)
        {
          int v96 = 0;
          do
          {
            uint64_t v100 = ((v94 + v96) >> 3) + v39;
            unint64_t v101 = v100 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v102 = v95 & 0xFFFFFFFFFFFFFFE7 | (8 * (v100 & 3));
            unsigned int v103 = *(_DWORD *)(v100 & 0xFFFFFFFFFFFFFFFCLL) >> v102;
            if (v102 >= 9) {
              v103 |= *(_DWORD *)(v101 + 4) << -(char)v102;
            }
            int v97 = (v103 >> 22) & 3;
            a9.n128_f32[0] = (float)(v103 & 0x3FFFFF);
            float v98 = a9.n128_f32[0] * 0.0078125;
            float v99 = a9.n128_f32[0] * 0.000061035;
            if (!v97) {
              a9.n128_f32[0] = a9.n128_f32[0] * 0.00000095367;
            }
            if (v97 == 1) {
              a9.n128_f32[0] = v99;
            }
            if (v97 == 2) {
              a9.n128_f32[0] = v98;
            }
            uint64_t result = (*(uint64_t (**)(uint64_t, __n128))(a13 + 16))(a13, a9);
            v96 += v122;
            --v38;
          }
          while (v38);
        }
        else
        {
          unsigned int v104 = 0;
          do
          {
            uint64_t v108 = (v104 >> 3) + v39;
            unint64_t v109 = v108 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v110 = v95 & 0xFFFFFFFFFFFFFFE7 | (8 * (v108 & 3));
            unsigned int v111 = *(_DWORD *)(v108 & 0xFFFFFFFFFFFFFFFCLL) >> v110;
            if (v110 >= 9) {
              v111 |= *(_DWORD *)(v109 + 4) << -(char)v110;
            }
            int v105 = (v111 >> 22) & 3;
            a9.n128_f32[0] = (float)(v111 & 0x3FFFFF);
            float v106 = a9.n128_f32[0] * 0.00000095367;
            float v107 = a9.n128_f32[0] * 0.000061035;
            if (v105 == 2) {
              a9.n128_f32[0] = a9.n128_f32[0] * 0.0078125;
            }
            if (v105 == 1) {
              a9.n128_f32[0] = v107;
            }
            if (!v105) {
              a9.n128_f32[0] = v106;
            }
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, __n128))(a13 + 16))(a13, a4, 0, a9);
            v104 += v122;
            --v38;
          }
          while (v38);
        }
      }
    }
    else
    {
      unsigned int v115 = a7 + 1;
      uint64_t v116 = result;
      unsigned int v118 = a2;
      uint64_t v121 = a5;
      uint64_t result = sub_19E5295EC(a8, a11, a12, ((v22 & 0x1C) + v20 + v29 + 7) & 0xF8, v20, v23, v29, v19, 0, &v124, v125, (unsigned int *)&v123, (unsigned int *)&v123 + 1);
      if (result && v123 < HIDWORD(v123))
      {
        if (v29)
        {
          uint64_t v83 = v121;
          uint64_t v84 = ((v33 + v30) >> 3) + v119;
          unint64_t v85 = v84 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v86 = v22 & 4 | (8 * (v84 & 3));
          int v87 = *(_DWORD *)(v84 & 0xFFFFFFFFFFFFFFFCLL) >> v86;
          uint64_t v88 = a3;
          uint64_t v89 = a4;
          uint64_t v90 = v116;
          if (v86 + (unint64_t)v29 >= 0x21) {
            v87 |= *(_DWORD *)(v85 + 4) << -(char)v86;
          }
          unsigned int v91 = v87 & (0xFFFFFFFF >> -(char)v29);
          uint64_t v92 = v118;
        }
        else
        {
          unsigned int v91 = 0;
          uint64_t v88 = a3;
          uint64_t v89 = a4;
          uint64_t v83 = v121;
          uint64_t v92 = v118;
          uint64_t v90 = v116;
        }
        return sub_19E52A244(v90, v92, v88, v89, v83, a6, v115, v39 + ((v38 * v122) >> 3), __PAIR64__(v123, v91), HIDWORD(v123), a13);
      }
    }
  }
  return result;
}

void sub_19E52A9A8(uint64_t a1, unsigned int *a2, uint64_t a3, unsigned int a4, float a5)
{
  if (!a1) {
    return;
  }
  unsigned int v7 = *(unsigned __int8 *)(a1 + 5);
  if (v7 < a3) {
    return;
  }
  unint64_t v9 = *(unsigned __int8 *)(a1 + 6);
  if (v9 <= 0x3F && a4 >> v9 != 0) {
    return;
  }
  if (a5 <= 0.0)
  {
    BOOL v14 = 0;
  }
  else
  {
    unsigned int v13 = *(_DWORD *)(a1 + 8);
    if (v13) {
      BOOL v14 = *(_DWORD *)(a1 + 12) < v13;
    }
    else {
      BOOL v14 = 1;
    }
  }
  uint64_t v15 = *(unsigned __int8 *)(a1 + 7);
  unsigned int v16 = *(_DWORD *)(a1 + 20);
  int v82 = *(_DWORD *)(a1 + 16);
  long long v17 = *(char **)(a1 + 24);
  __n128 v18 = *(_OWORD **)(a1 + 40);
  if (v18)
  {
    *(void *)&long long v19 = -1;
    *((void *)&v19 + 1) = -1;
    v18[1] = v19;
    unsigned char v18[2] = v19;
    _OWORD *v18 = v19;
  }
  if (*(void *)(a1 + 32)) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = v14;
  }
  if (v20)
  {
    uint64_t v21 = malloc_type_calloc(0x20uLL, 1uLL, 0xF8076CD9uLL);
    *(void *)(a1 + 32) = v21;
    *(_WORD *)uint64_t v21 = 8;
    void v21[2] = 0;
    *(unsigned char *)(*(void *)(a1 + 32) + 3) = *(unsigned char *)(*(void *)(a1 + 32) + 3) & 0xF8 | 1;
    *(_DWORD *)(a1 + 12) += 8;
  }
  BOOL v81 = v14;
  if (!a3)
  {
    uint64_t v39 = *(void *)(a1 + 32);
    if (!v39) {
      return;
    }
    unint64_t v84 = *(void *)(a1 + 32);
    int v40 = (sub_19E527EE4(v39, 1u, v9, 0, v39 + 4, 1u) - v39 + 3) & 0xFFFFFFFC;
    unsigned int v83 = 0;
    sub_19E52B1A8(v39, 1u, v9, (uint64_t)&v83, 1, a4, 0, v39 + 4, a5, 1u, 0, 1u, v14, 0, &v84);
    unint64_t v41 = v84;
    *(void *)(a1 + 32) = v84;
    int v42 = (sub_19E527EE4(v41, 1u, v9, 0, v41 + 4, 1u) - v41 + 3) & 0xFFFFFFFC;
    int v43 = *(_DWORD *)(a1 + 12) - v40;
    goto LABEL_99;
  }
  unint64_t v22 = 0;
  if (v17 && v82)
  {
    if (v15)
    {
      int v23 = v15 + 24;
      unint64_t v24 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v15;
      unsigned int v25 = -1640531573 * *a2 % v16;
      while (1)
      {
        unint64_t v26 = (unint64_t)&v17[(v25 * v23 + 24) >> 3];
        unint64_t v27 = v26 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v28 = ((_BYTE)v25 * (_BYTE)v23) & 7 | (8 * (v26 & 7));
        uint64_t v29 = *(void *)(v26 & 0xFFFFFFFFFFFFFFF8) >> v28;
        if ((unint64_t)(v28 + v15) >= 0x41) {
          v29 |= *(void *)(v27 + 8) << -(char)v28;
        }
        unint64_t v22 = v29 & v24;
        if ((v29 & v24) == 0) {
          break;
        }
        unint64_t v30 = (unint64_t)&v17[(v25 * v23) >> 3];
        unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v32 = (v25 * v23) & 7 | (8 * (v30 & 3));
        int v33 = *(_DWORD *)(v30 & 0xFFFFFFFFFFFFFFFCLL) >> v32;
        if (v32 >= 9) {
          v33 |= *(_DWORD *)(v31 + 4) << -(char)v32;
        }
        if ((v33 & 0xFFFFFF) == *a2) {
          break;
        }
        if (v25 + 1 == v16) {
          unsigned int v25 = 0;
        }
        else {
          ++v25;
        }
        if (v25 == -1640531573 * *a2 % v16) {
          goto LABEL_35;
        }
      }
    }
    else
    {
LABEL_35:
      unint64_t v22 = 0;
    }
  }
  if (a3 == 1 && !v22)
  {
    if (!v81) {
      return;
    }
    unint64_t v22 = (unint64_t)malloc_type_calloc(0x20uLL, 1uLL, 0x7115445CuLL);
    unint64_t v34 = 0;
    *(_WORD *)unint64_t v22 = 8;
    *(unsigned char *)(v22 + 2) = 0;
    unint64_t v35 = v22 + 3;
    unsigned int v36 = v7;
    do
    {
      int v37 = v34 & 6;
      if (v37 == 6) {
        char v38 = 3;
      }
      else {
        char v38 = 7;
      }
      *(unsigned char *)(v35 + (v34 >> 3)) = *(unsigned char *)(v35 + (v34 >> 3)) & ~(v38 << v37) | (1 << v37);
      if (v37 == 6) {
        *(unsigned char *)(v35 + (v34 >> 3) + 1) &= ~1u;
      }
      v34 += 6;
      --v36;
    }
    while (v36);
    if (v7 >= 2)
    {
      int v44 = 0;
      unsigned int v45 = 3;
      int v46 = 1;
      do
      {
        unint64_t v47 = (6 * v44 + 3);
        int v44 = v46;
        unsigned int v48 = v47 & 7;
        unint64_t v49 = v47 >> 3;
        int v50 = 8 - v48;
        if (v48 <= 5) {
          int v50 = 3;
        }
        *(unsigned char *)(v35 + v49) = *(unsigned char *)(v35 + v49) & ~(0xFFu >> (8 - v50) << v48) | (((0xFFu >> (8 - v50)) & 1) << v48);
        if (v50 != 3)
        {
          unsigned int v51 = (v45 >> 3) + 1;
          unsigned int v52 = 3 - v50;
          do
          {
            if (v52 >= 8) {
              int v53 = 8;
            }
            else {
              int v53 = v52;
            }
            *(unsigned char *)(v35 + v51) = (-256 >> (8 - v53)) & *(unsigned char *)(v35 + v51) | (0xFFu >> (8 - v53)) & (1u >> (3 - v52));
            ++v51;
            v52 -= v53;
          }
          while (v52);
        }
        int v46 = v44 + 1;
        v45 += 6;
      }
      while (v44 + 1 != v7);
    }
    int v78 = v82 + 1;
    if (5 * v16 < 8 * (v82 + 1) || v15 <= 0x3F && v22 >> v15)
    {
      unsigned int v54 = 0;
      LODWORD(v84) = 0;
      unint64_t v55 = v22;
      do
      {
        ++v54;
        BOOL v56 = v55 > 1;
        v55 >>= 1;
      }
      while (v56);
      if (v54 <= v15) {
        unsigned int v57 = v15;
      }
      else {
        unsigned int v57 = v54;
      }
      if (v17)
      {
        unsigned int v58 = v15;
        LODWORD(v15) = v57;
        unsigned int v80 = (char *)sub_19E5285A4((uint64_t)v17, v82, v16, v58, v57, (unsigned int *)&v84);
        free(v17);
        unsigned int v16 = v84;
        long long v17 = v80;
      }
      else
      {
        LODWORD(v15) = v57;
        long long v17 = (char *)malloc_type_calloc((((32 * v57 + 775) >> 3) & 0x1FFFFFF8) + 8, 1uLL, 0x4E18D228uLL);
        unsigned int v16 = 32 * (v17 != 0);
      }
      *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v17;
      *(unsigned char *)(a1 + 7) = v15;
      *(_DWORD *)(a1 + 20) = v16;
    }
    if (v17)
    {
      sub_19E528720((uint64_t)v17, v16, v15, *a2, v22);
      *(_DWORD *)(a1 + 12) += (((unsigned __int16)((6 * v7 + 4) >> 3) + 7) & 0x3FC)
                            - ((3 * v82) & 0x1FFFFFFF)
                            + ((3 * v78) & 0x1FFFFFFF);
      *(_DWORD *)(a1 + 16) = v78;
      ++v82;
    }
  }
  if (v22)
  {
    unint64_t v84 = v22;
    unint64_t v77 = ((6 * (unint64_t)v7 + 4) >> 3) + 3;
    int v79 = (sub_19E527EE4(v22, v7, v9, 0, v22 + v77, 1u) - v22 + 3) & 0xFFFFFFFC;
    sub_19E52B1A8(v22, v7, v9, (uint64_t)a2, a3, a4, 0, v22 + v77, a5, 1u, 0, 1u, v81, 0, &v84);
    if (v17)
    {
      unint64_t v59 = v84;
      if (v84 != v22)
      {
        unsigned int v60 = v15;
        uint64_t v61 = v15;
        if (v15 > 0x3F)
        {
          unsigned int v62 = v16;
        }
        else
        {
          unsigned int v62 = v16;
          if (v84 >> v15)
          {
            unsigned int v83 = 0;
            unsigned int v63 = 0;
            if (v84)
            {
              do
              {
                ++v63;
                BOOL v56 = v59 > 1;
                v59 >>= 1;
              }
              while (v56);
            }
            float v64 = (char *)sub_19E5285A4((uint64_t)v17, v82, v16, v15, v63, &v83);
            free(v17);
            *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v64;
            *(unsigned char *)(a1 + 7) = v63;
            unsigned int v62 = v83;
            *(_DWORD *)(a1 + 20) = v83;
            uint64_t v61 = v63;
            long long v17 = v64;
            unsigned int v60 = v63;
          }
        }
        unsigned int v65 = *a2;
        if (v60)
        {
          int v66 = v60 + 24;
          unsigned int v67 = -1640531573 * v65 % v62;
          do
          {
            unint64_t v68 = (unint64_t)&v17[(v67 * v66 + 24) >> 3];
            unint64_t v69 = v68 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v70 = ((_BYTE)v67 * (_BYTE)v66) & 7 | (8 * (v68 & 7));
            uint64_t v71 = *(void *)(v68 & 0xFFFFFFFFFFFFFFF8) >> v70;
            if ((unint64_t)(v70 + v61) >= 0x41) {
              v71 |= *(void *)(v69 + 8) << -(char)v70;
            }
            if ((v71 & (0xFFFFFFFFFFFFFFFFLL >> -(char)v60)) == 0) {
              break;
            }
            unint64_t v72 = (unint64_t)&v17[(v67 * v66) >> 3];
            unint64_t v73 = v72 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v74 = (v67 * v66) & 7 | (8 * (v72 & 3));
            int v75 = *(_DWORD *)(v72 & 0xFFFFFFFFFFFFFFFCLL) >> v74;
            if (v74 >= 9) {
              v75 |= *(_DWORD *)(v73 + 4) << -(char)v74;
            }
            if ((v75 & 0xFFFFFF) == v65)
            {
              sub_19E52BE90((uint64_t)v17, v66, v60, v67, v84);
              goto LABEL_98;
            }
            if (v67 + 1 == v62) {
              unsigned int v67 = 0;
            }
            else {
              ++v67;
            }
          }
          while (v67 != -1640531573 * v65 % v62);
        }
        sub_19E528720((uint64_t)v17, v62, v60, v65, v84);
      }
    }
LABEL_98:
    int v76 = v84;
    int v42 = (sub_19E527EE4(v84, v7, v9, 0, v84 + v77, 1u) - v76 + 3) & 0xFFFFFFFC;
    int v43 = *(_DWORD *)(a1 + 12) - v79;
LABEL_99:
    *(_DWORD *)(a1 + 12) = v43 + v42;
  }
}

uint64_t sub_19E52B1A8(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, uint64_t a8, float a9, unsigned int a10, unsigned int a11, unsigned int a12, unsigned __int8 a13, unsigned int *a14, void *a15)
{
  unsigned int v19 = a2;
  unsigned int v189 = a11;
  if (a7) {
    unsigned int v21 = 24;
  }
  else {
    unsigned int v21 = 0;
  }
  uint64_t v22 = a1 + 3;
  int v23 = 6 * a7;
  char v24 = (6 * a7) & 6;
  int v25 = *(_DWORD *)(((((3 * a7) >> 2) & 0x1FFFFFFF) + v22) & 0xFFFFFFFFFFFFFFFCLL) >> (v24 | (8
                                                                                            * ((((3 * a7) >> 2) + v22) & 3)));
  if (a7 + 1 >= a2)
  {
    unsigned int v30 = 0;
  }
  else
  {
    uint64_t v26 = ((v23 + 3) >> 3) + v22;
    unint64_t v27 = (_DWORD *)(v26 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v28 = (v23 + 3) & 7 | (8 * (v26 & 3));
    int v29 = *v27 >> v28;
    if (v28 >= 0x1E) {
      v29 |= v27[1] << -(char)v28;
    }
    unsigned int v30 = 4 * (v29 & 7);
  }
  uint64_t v31 = 0;
  unsigned int v32 = *(_DWORD *)(a4 + 4 * a7);
  uint64_t v187 = 0;
  uint64_t v188 = 0;
  int v186 = (unsigned char *)a1;
  if (a7 < a5 && !HIBYTE(v32))
  {
    char v33 = 4 * v25;
    unsigned int v34 = (4 * (_BYTE)v25) & 0x1C;
    unsigned int v35 = a10;
    int v36 = (((4 * (_BYTE)v25) & 0x1C) + (_BYTE)v21 + (_BYTE)v30 + 7) & 0xF8;
    uint64_t v37 = (v36 * a10) >> 3;
    char v38 = (char *)(a8 + v37);
    if (a10)
    {
      uint64_t v169 = ((3 * a7) >> 2) & 0x1FFFFFFF;
      uint64_t v171 = a4;
      unsigned int v174 = a6;
      uint64_t v177 = (char *)(a8 + v37);
      unsigned int v178 = a3;
      unsigned int v182 = a7 + 1;
      int v168 = 6 * a7;
      uint64_t v183 = a8;
      unsigned int v185 = v21;
      if (sub_19E5295EC(a8, a11, a12, v36, v21, v33 & 0x1C, v30, v32, &v189, (unsigned int *)&v188, (unsigned int *)&v188 + 1, (unsigned int *)&v187, (unsigned int *)&v187 + 1))
      {
        unsigned int v39 = v178;
        unsigned int v40 = v188;
        if (v34)
        {
          uint64_t v41 = v183;
          uint64_t v42 = ((v36 * (a10 - 1) + v185) >> 3) + v183;
          unint64_t v43 = v42 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v44 = 8 * (v42 & 3);
          int v45 = *(_DWORD *)(v42 & 0xFFFFFFFFFFFFFFFCLL) >> v44;
          uint64_t v46 = a2;
          if (v44 + (unint64_t)v34 >= 0x21) {
            v45 |= *(_DWORD *)(v43 + 4) << -(char)v44;
          }
          unsigned int v34 = v45 & (0xFFFFFFFF >> -(char)v34);
          if (v182 == a5)
          {
            if (v34 && v188 < HIDWORD(v188))
            {
              v190[0] = 0;
              unsigned int v47 = (v178 + 31) & 0xFFFFFFF8;
              unsigned int v48 = v188;
              int v49 = sub_19E529864((uint64_t)v177, v188, HIDWORD(v188), v47, v178, v174, v190);
              int v50 = v190[0];
              if (v49)
              {
                float v51 = sub_19E52BF34((uint64_t)v177, v47, v178, v190[0]);
                sub_19E52BFB8((uint64_t)v177, v47, v178, v50, v51 + a9);
                unsigned int v52 = 0;
LABEL_36:
                uint64_t v31 = 1;
                goto LABEL_141;
              }
              LODWORD(v46) = a2;
              unsigned int v39 = v178;
              uint64_t v41 = v183;
              unsigned int v40 = v48;
              unsigned int v52 = a13;
              if (!a13)
              {
LABEL_140:
                uint64_t v31 = 0;
                goto LABEL_141;
              }
LABEL_35:
              unsigned int v60 = sub_19E52C0D0(a1, v46, v39, v171, v174, a7, v41, a10, a9, v189, v40, v187, v177, v34, v50, 0);
              unsigned int v52 = 0;
              int v186 = v60;
              goto LABEL_36;
            }
            int v50 = v188;
LABEL_34:
            unsigned int v52 = a13;
            if (!a13) {
              goto LABEL_140;
            }
            goto LABEL_35;
          }
        }
        else
        {
          int v50 = v188;
          uint64_t v46 = a2;
          uint64_t v41 = v183;
          if (v182 == a5) {
            goto LABEL_34;
          }
        }
        unsigned int v166 = a10 - 1;
        v190[0] = 0;
        uint64_t v62 = (v34 * ((v178 + 31) & 0xFFFFFFF8)) >> 3;
        uint64_t v31 = sub_19E52B1A8(a1, v46, v178, v171, a5, v174, a9);
        int v63 = v190[0];
        if (!v190[0]) {
          goto LABEL_138;
        }
        unint64_t v64 = 8 * (a1 & 3);
        int v65 = *(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v64;
        unsigned int v66 = v185;
        if (v64 >= 9) {
          v65 |= *(_DWORD *)((a1 & 0xFFFFFFFFFFFFFFFCLL) + 4) << (-8 * (a1 & 3));
        }
        int v67 = *(_DWORD *)((a1 + 3 + v169) & 0xFFFFFFFFFFFFFFFCLL) >> (v24 & 0xE7 | (8 * ((a1 + 3 + v169) & 3)));
        char v68 = 4 * v67;
        uint64_t v69 = (4 * v67) & 0x1C;
        unsigned int v165 = v31;
        if (v182 >= a2)
        {
          unsigned int v74 = 0;
        }
        else
        {
          uint64_t v70 = a1 + 3 + ((v168 + 3) >> 3);
          uint64_t v71 = (_DWORD *)(v70 & 0xFFFFFFFFFFFFFFFCLL);
          unint64_t v72 = (v168 + 3) & 7 | (8 * (v70 & 3));
          int v73 = *v71 >> v72;
          if (v72 >= 0x1E) {
            v73 |= v71[1] << -(char)v72;
          }
          unsigned int v74 = 4 * (v73 & 7);
        }
        uint64_t v75 = v183;
        int v76 = v69 + v185 + 7;
        int v77 = (v74 + v76) & 0xF8;
        int v184 = v69 + v185;
        uint64_t v78 = v62;
        if (v74)
        {
          uint64_t v79 = ((v69 + v185 + v77 * v166) >> 3) + v75;
          unint64_t v80 = v79 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v81 = v68 & 4 | (8 * (v79 & 3));
          int v82 = *(_DWORD *)(v79 & 0xFFFFFFFFFFFFFFFCLL) >> v81;
          uint64_t v83 = v74;
          if (v81 + (unint64_t)v74 >= 0x21) {
            v82 |= *(_DWORD *)(v80 + 4) << -(char)v81;
          }
          unsigned int v84 = v82 & (0xFFFFFFFF >> -(char)v74);
        }
        else
        {
          uint64_t v83 = 0;
          unsigned int v84 = 0;
        }
        unsigned int v85 = v189;
        unint64_t v86 = v84 + v190[0];
        __src = v186;
        if (!(v86 >> v83))
        {
          unsigned int v92 = (v74 + v76) & 0xF8;
          unsigned int v93 = a10;
          int v94 = v69 + v185;
          goto LABEL_121;
        }
        uint64_t v180 = v83;
        char v170 = v68;
        size_t v87 = 4 * (v65 & 0xFFFFFFu);
        uint64_t v88 = sub_19E527EE4((uint64_t)v186, a2, v178, v182, (uint64_t)&v177[v78], v86);
        int v164 = v63;
        if (v86)
        {
          int v89 = -1;
          do
          {
            ++v89;
            BOOL v90 = v86 > 1;
            v86 >>= 1;
          }
          while (v90);
          int v91 = v89 + 4;
        }
        else
        {
          int v91 = 3;
        }
        size_t v95 = v87;
        unsigned int v96 = v91 & 0xFFFFFFFC;
        unsigned int v97 = (v91 & 0xFFFFFFFC) + v69 + v185 + 7;
        unsigned int v92 = v97 & 0xFFFFFFF8;
        unsigned int v98 = ((v97 & 0xFFFFFFF8) * a10) >> 3;
        unsigned int v99 = (v77 * a10) >> 3;
        uint64_t v100 = v98 - v99;
        unsigned int v101 = v95;
        do
        {
          size_t v102 = v101;
          unsigned int v103 = &v186[v101];
          v101 *= 2;
        }
        while (v88 + v100 > (unint64_t)v103);
        unsigned int v163 = v91;
        unint64_t v179 = v88;
        if (v102 <= v95)
        {
          unsigned int v104 = v177;
        }
        else
        {
          size_t __n = v95;
          unsigned int v172 = (v91 & 0xFFFFFFFC) + v69 + v185 + 7;
          uint64_t v162 = v98 - v99;
          unsigned int v161 = ((v97 & 0xFFFFFFF8) * a10) >> 3;
          CFArrayRef v175 = malloc_type_calloc(v102, 1uLL, 0x2E47B0D0uLL);
          memcpy(v175, v186, __n);
          *CFArrayRef v175 = v102 >> 2;
          v175[1] = v102 >> 10;
          v175[2] = v102 >> 18;
          v75 += v175 - v186;
          unsigned int v104 = &v177[v175 - v186];
          v179 += v175 - v186;
          free(v186);
          unsigned int v99 = (v77 * a10) >> 3;
          unsigned int v98 = v161;
          uint64_t v100 = v162;
          unsigned int v97 = v172;
          __src = v175;
        }
        if (v98 != v99)
        {
          size_t v105 = v179 - (void)v104;
          if (v179 > (unint64_t)v104)
          {
            float v106 = &v104[v100];
            float v107 = v104;
            unsigned int v108 = v97;
            memmove(v106, v107, v105);
            unsigned int v97 = v108;
          }
        }
        int v109 = v170 & 4;
        if (v69 >= 8) {
          int v110 = 8;
        }
        else {
          int v110 = v69;
        }
        unsigned int v176 = 0xFFu >> (8 - v110);
        int v173 = -256 >> (8 - v110);
        unsigned int v111 = v69 - v110;
        if (v96 + v109 <= 8) {
          unsigned int v112 = v96;
        }
        else {
          unsigned int v112 = 8 - v109;
        }
        unsigned int v113 = 0xFFu >> (8 - v112);
        unsigned int v114 = v96 - v112;
        unsigned int v115 = 8 * (v97 >> 3) * v166;
        unsigned int v116 = v185 + v115;
        unsigned int v117 = v185 + v115 + v69;
        while (1)
        {
          --v35;
          if (a7)
          {
            uint64_t v118 = ((v35 * v77) >> 3) + v75;
            unint64_t v119 = v118 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v120 = 8 * (v118 & 3);
            int v121 = *(_DWORD *)(v118 & 0xFFFFFFFFFFFFFFFCLL) >> v120;
            if (v120 >= 9) {
              v121 |= *(_DWORD *)(v119 + 4) << -(char)v120;
            }
            int v122 = v121 & 0xFFFFFF;
            if (!v69)
            {
LABEL_107:
              unsigned int v127 = 0;
              if (v74) {
                goto LABEL_87;
              }
              goto LABEL_108;
            }
          }
          else
          {
            int v122 = 0;
            if (!v69) {
              goto LABEL_107;
            }
          }
          uint64_t v123 = ((v185 + v35 * v77) >> 3) + v75;
          unint64_t v124 = v123 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v125 = 8 * (v123 & 3);
          int v126 = *(_DWORD *)(v123 & 0xFFFFFFFFFFFFFFFCLL) >> v125;
          if ((unint64_t)(v125 + v69) >= 0x21) {
            v126 |= *(_DWORD *)(v124 + 4) << -(char)v125;
          }
          unsigned int v127 = v126 & (0xFFFFFFFF >> -(char)v69);
          if (v74)
          {
LABEL_87:
            uint64_t v128 = ((v184 + v35 * v77) >> 3) + v75;
            unint64_t v129 = v128 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v130 = v170 & 4 | (8 * (v128 & 3));
            int v131 = *(_DWORD *)(v128 & 0xFFFFFFFFFFFFFFFCLL) >> v130;
            if ((unint64_t)(v130 + v180) >= 0x21) {
              v131 |= *(_DWORD *)(v129 + 4) << -(char)v130;
            }
            unsigned int v132 = v131 & (0xFFFFFFFF >> -(char)v74);
            if (!a7) {
              goto LABEL_91;
            }
LABEL_90:
            *(unsigned char *)(v75 + ((unint64_t)(v35 * v92) >> 3)) = v122;
            uint64_t v133 = (v115 >> 3) + v75;
            *(unsigned char *)(v133 + 1) = BYTE1(v122);
            *(unsigned char *)(v133 + 2) = BYTE2(v122);
            goto LABEL_91;
          }
LABEL_108:
          unsigned int v132 = 0;
          if (a7) {
            goto LABEL_90;
          }
LABEL_91:
          if (v69)
          {
            *(unsigned char *)(v75 + ((unint64_t)(v185 + v35 * v92) >> 3)) = v173 & *(unsigned char *)(v75
                                                                                            + ((unint64_t)(v185 + v35 * v92) >> 3)) | v127 & v176;
            if (v111)
            {
              unsigned int v134 = (v116 >> 3) + 1;
              unsigned int v135 = v111;
              do
              {
                if (v135 >= 8) {
                  int v136 = 8;
                }
                else {
                  int v136 = v135;
                }
                *(unsigned char *)(v75 + v134) = (-256 >> (8 - v136)) & *(unsigned char *)(v75 + v134) | (0xFFu >> (8 - v136)) & (v127 >> (v69 - v135));
                ++v134;
                v135 -= v136;
              }
              while (v135);
            }
          }
          if (v96)
          {
            *(unsigned char *)(v75 + ((unint64_t)(v184 + v35 * v92) >> 3)) = *(unsigned char *)(v75
                                                                                     + ((unint64_t)(v184 + v35 * v92) >> 3)) & ~((_BYTE)v113 << v109) | ((v132 & v113) << v109);
            if (v114)
            {
              unsigned int v137 = (v117 >> 3) + 1;
              unsigned int v138 = v114;
              do
              {
                if (v138 >= 8) {
                  int v139 = 8;
                }
                else {
                  int v139 = v138;
                }
                *(unsigned char *)(v75 + v137) = (-256 >> (8 - v139)) & *(unsigned char *)(v75 + v137) | (0xFFu >> (8 - v139)) & (v132 >> (v96 - v138));
                ++v137;
                v138 -= v139;
              }
              while (v138);
            }
          }
          v115 -= v92;
          v116 -= v92;
          v117 -= v92;
          if (!v35)
          {
            if (v182 < a2)
            {
              unsigned int v140 = v163 >> 2;
              long long v141 = __src + 3;
              unint64_t v142 = (unint64_t)(v168 + 3) >> 3;
              int v143 = (((_BYTE)v168 + 3) & 7u) <= 5 ? 3 : 8 - (((_BYTE)v168 + 3) & 7);
              v141[v142] = v141[v142] & ~(0xFFu >> (8 - v143) << ((v168 + 3) & 7)) | ((v140 & (0xFFu >> (8 - v143))) << ((v168 + 3) & 7));
              if (v143 != 3)
              {
                unsigned int v144 = 3 - v143;
                int v145 = v142 + 1;
                do
                {
                  if (v144 >= 8) {
                    int v146 = 8;
                  }
                  else {
                    int v146 = v144;
                  }
                  v141[v145] = (-256 >> (8 - v146)) & v141[v145] | (0xFFu >> (8 - v146)) & (v140 >> (3 - v144));
                  ++v145;
                  v144 -= v146;
                }
                while (v144);
              }
            }
            unsigned int v74 = v96;
            unsigned int v66 = v185;
            unsigned int v93 = a10;
            int v63 = v164;
            int v94 = v69 + v185;
            char v68 = v170;
LABEL_121:
            if (v85 < v93)
            {
              int v147 = v68 & 4;
              unsigned int v148 = v74 + v147 <= 8 ? v74 : 8 - v147;
              if (v74)
              {
                unsigned int v149 = 0xFFu >> (8 - v148);
                unsigned int v150 = v74 - v148;
                unsigned int v151 = v66 + v92 * v85 + v69;
                do
                {
                  unint64_t v152 = (unint64_t)(v94 + v85 * v92) >> 3;
                  unint64_t v153 = (_DWORD *)((v152 + v75) & 0xFFFFFFFFFFFFFFFCLL);
                  uint64_t v154 = v68 & 4 | (8 * ((v152 + v75) & 3));
                  int v155 = *v153 >> v154;
                  if (v154 + (unint64_t)v74 >= 0x21) {
                    v155 |= v153[1] << -(char)v154;
                  }
                  unsigned int v156 = (v155 & (0xFFFFFFFF >> -(char)v74)) + v63;
                  *(unsigned char *)(v75 + v152) = ((v156 & v149) << v147) | *(unsigned char *)(v75 + v152) & ~((_BYTE)v149 << v147);
                  if (v150)
                  {
                    unsigned int v157 = (v151 >> 3) + 1;
                    unsigned int v158 = v150;
                    do
                    {
                      if (v158 >= 8) {
                        int v159 = 8;
                      }
                      else {
                        int v159 = v158;
                      }
                      *(unsigned char *)(v75 + v157) = (-256 >> (8 - v159)) & *(unsigned char *)(v75 + v157) | (0xFFu >> (8 - v159)) & (v156 >> (v74 - v158));
                      ++v157;
                      v158 -= v159;
                    }
                    while (v158);
                  }
                  ++v85;
                  v151 += v92;
                }
                while (v85 != v93);
              }
            }
            int v186 = __src;
            uint64_t v31 = v165;
LABEL_138:
            unsigned int v52 = 0;
LABEL_141:
            unsigned int v54 = a14;
            unint64_t v55 = a15;
            if (!a15)
            {
LABEL_41:
              if (v54) {
                *unsigned int v54 = v52;
              }
              return v31;
            }
LABEL_40:
            *unint64_t v55 = v186;
            goto LABEL_41;
          }
        }
      }
      unsigned int v52 = 0;
      if (v182 == a5)
      {
        uint64_t v31 = 0;
        unsigned int v54 = a14;
        a8 = v183;
        unint64_t v55 = a15;
        unsigned int v19 = a2;
        a3 = v178;
        char v38 = v177;
        a6 = v174;
        a4 = v171;
        if (!a13) {
          goto LABEL_39;
        }
        unsigned int v52 = v188;
        if (v34)
        {
          uint64_t v56 = ((v185 + v36 * (a10 - 1)) >> 3) + v183;
          unint64_t v57 = v56 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v58 = 8 * (v56 & 3);
          int v59 = *(_DWORD *)(v56 & 0xFFFFFFFFFFFFFFFCLL) >> v58;
          if (v58 + (unint64_t)v34 >= 0x21) {
            v59 |= *(_DWORD *)(v57 + 4) << -(char)v58;
          }
          unsigned int v53 = v59 & (0xFFFFFFFF >> -(char)v34);
        }
        else
        {
          unsigned int v53 = 0;
        }
        goto LABEL_38;
      }
    }
    else
    {
      unsigned int v52 = 0;
      if (a7 + 1 == a5)
      {
        unsigned int v53 = 0;
        uint64_t v31 = 0;
        unsigned int v54 = a14;
        unint64_t v55 = a15;
        if ((a13 & 1) == 0)
        {
LABEL_39:
          if (!v55) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }
LABEL_38:
        uint64_t v31 = 1;
        int v186 = sub_19E52C0D0(a1, v19, a3, a4, a6, a7, a8, a10, a9, v189, v52, v187, v38, v53, v52, 1u);
        unsigned int v52 = 1;
        goto LABEL_39;
      }
    }
    uint64_t v31 = 0;
    goto LABEL_141;
  }
  return v31;
}

uint64_t sub_19E52BE90(uint64_t result, int a2, int a3, int a4, unint64_t a5)
{
  if (a3)
  {
    int v5 = (a4 * a2) & 7;
    unint64_t v6 = (unint64_t)(a4 * a2 + 24) >> 3;
    int v7 = 8 - v5;
    if ((v5 + a3) <= 8) {
      int v7 = a3;
    }
    *(unsigned char *)(result + v6) = *(unsigned char *)(result + v6) & ~(0xFFu >> (8 - v7) << v5) | (((0xFFu >> (8 - v7)) & a5) << v5);
    unsigned int v8 = a3 - v7;
    if (a3 != v7)
    {
      unsigned int v9 = v6 + 1;
      do
      {
        if (v8 >= 8) {
          int v10 = 8;
        }
        else {
          int v10 = v8;
        }
        *(unsigned char *)(result + v9) = (-256 >> (8 - v10)) & *(unsigned char *)(result + v9) | (0xFFu >> (8 - v10)) & (a5 >> (a3 - v8));
        ++v9;
        v8 -= v10;
      }
      while (v8);
    }
  }
  return result;
}

float sub_19E52BF34(uint64_t a1, int a2, int a3, int a4)
{
  unsigned int v4 = a3 + a4 * a2;
  int v5 = (_DWORD *)(((v4 >> 3) + a1) & 0xFFFFFFFFFFFFFFFCLL);
  unint64_t v6 = v4 & 7 | (8 * (((v4 >> 3) + a1) & 3));
  unsigned int v7 = *v5 >> v6;
  if (v6 >= 9) {
    v7 |= v5[1] << -(char)v6;
  }
  int v8 = (v7 >> 22) & 3;
  float result = (float)(v7 & 0x3FFFFF);
  float v10 = result * 0.0078125;
  float v11 = result * 0.000061035;
  if (!v8) {
    float result = result * 0.00000095367;
  }
  if (v8 == 1) {
    float result = v11;
  }
  if (v8 == 2) {
    return v10;
  }
  return result;
}

uint64_t sub_19E52BFB8(uint64_t result, int a2, int a3, int a4, float a5)
{
  if (a5 >= 4194300.0)
  {
    int v9 = 12582912;
    unsigned int v10 = 0x3FFFFF;
  }
  else
  {
    unsigned int v5 = vcvts_n_s32_f32(a5, 0x14uLL);
    if (a5 <= 0.0) {
      unsigned int v5 = 0;
    }
    unsigned int v6 = vcvts_n_s32_f32(a5, 0xEuLL);
    if (a5 >= 4.0) {
      int v7 = 0x400000;
    }
    else {
      int v7 = 0;
    }
    if (a5 >= 4.0) {
      unsigned int v5 = v6;
    }
    unsigned int v8 = vcvts_n_s32_f32(a5, 7uLL);
    if (a5 < 256.0) {
      unsigned int v8 = v5;
    }
    else {
      int v7 = 0x800000;
    }
    if (a5 >= 32768.0) {
      int v9 = 12582912;
    }
    else {
      int v9 = v7;
    }
    if (a5 >= 32768.0) {
      unsigned int v10 = (int)a5;
    }
    else {
      unsigned int v10 = v8;
    }
  }
  if (v10 >= 0x3FFFFF) {
    unsigned int v10 = 0x3FFFFF;
  }
  unsigned int v11 = v10 | v9;
  unint64_t v12 = (a3 + a4 * a2);
  *(unsigned char *)(result + (v12 >> 3)) = ((v10 & (0xFFu >> ((a3 + a4 * a2) & 7))) << ((a3 + a4 * a2) & 7)) | *(unsigned char *)(result + (v12 >> 3)) & ~(0xFFu >> ((a3 + a4 * a2) & 7) << ((a3 + a4 * a2) & 7));
  unsigned int v13 = (v12 | 0xFFFFFFF8) + 24;
  unsigned int v14 = ((a3 + a4 * a2) >> 3) + 1;
  do
  {
    if (v13 >= 8) {
      int v15 = 8;
    }
    else {
      int v15 = v13;
    }
    *(unsigned char *)(result + v14) = (-256 >> (8 - v15)) & *(unsigned char *)(result + v14) | (0xFFu >> (8 - v15)) & (v11 >> (24 - v13));
    ++v14;
    v13 -= v15;
  }
  while (v13);
  return result;
}

unsigned char *sub_19E52C0D0(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int a6, uint64_t a7, unsigned int a8, float a9, unsigned int a10, unsigned int a11, unsigned int a12, char *a13, int a14, int a15, unsigned __int8 a16)
{
  unsigned int v16 = a8;
  uint64_t v17 = a7;
  unint64_t v20 = 8 * (a1 & 3);
  int v21 = *(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v20;
  if (v20 >= 9) {
    v21 |= *(_DWORD *)((a1 & 0xFFFFFFFFFFFFFFFCLL) + 4) << (-8 * (a1 & 3));
  }
  if (a6) {
    int v22 = 24;
  }
  else {
    int v22 = 0;
  }
  int v154 = v22;
  unint64_t v23 = 6 * a6;
  int v24 = *(_DWORD *)(((v23 >> 3) + a1 + 3) & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a6) & 6 | (8 * (((v23 >> 3) + a1 + 3) & 3)));
  uint64_t v25 = (4 * v24) & 0x1C;
  unint64_t v129 = v23;
  int v131 = v23 & 6;
  unint64_t v132 = v23 >> 3;
  char v147 = 4 * v24;
  if (a6 + 1 >= a2)
  {
    unsigned int v30 = 0;
  }
  else
  {
    uint64_t v26 = ((v23 + 3) >> 3) + a1 + 3;
    unint64_t v27 = (_DWORD *)(v26 & 0xFFFFFFFFFFFFFFFCLL);
    unint64_t v28 = ((int)v23 + 3) & 7 | (8 * (v26 & 3));
    int v29 = *v27 >> v28;
    if (v28 >= 0x1E) {
      v29 |= v27[1] << -(char)v28;
    }
    unsigned int v30 = 4 * (v29 & 7);
  }
  uint64_t v31 = a13;
  unsigned int v32 = a10;
  int v33 = *(_DWORD *)(a4 + 4 * a6);
  size_t v34 = 4 * (v21 & 0xFFFFFFu);
  int v151 = v25 + v154;
  int v35 = ((_BYTE)v30 + (_BYTE)v25 + (_BYTE)v154 + 7) & 0x78;
  unsigned int v141 = a3 + 31;
  unsigned int v142 = (a3 + 31) >> 3;
  uint64_t v153 = v25;
  uint64_t v37 = sub_19E527EE4(a1, a2, a3, a6, a7, a8);
  uint64_t v38 = v153;
  unint64_t v39 = (a14 + 1);
  unint64_t v40 = v39 >> v153;
  unsigned int v134 = a2;
  int v130 = v33;
  if (v39 >> v153)
  {
    int v41 = -1;
    do
    {
      ++v41;
      BOOL v51 = v39 > 1;
      v39 >>= 1;
    }
    while (v51);
    unsigned int v42 = (v41 & 0x7FFFFFFC) + 4;
    unsigned int v43 = ((v154 | 4) + v30 + v42) & 0xFFFFFFF8;
  }
  else
  {
    unsigned int v42 = v153;
    unsigned int v43 = v35;
  }
  uint64_t v44 = (unsigned char *)a1;
  unsigned int v136 = a16 + v16;
  unsigned int v45 = (v35 * v16) >> 3;
  unsigned int v46 = v34;
  do
  {
    size_t v47 = v46;
    unint64_t v48 = (unint64_t)&v44[v46];
    v46 *= 2;
  }
  while (v37 + (unint64_t)(v142 - v45 + ((v43 * (a16 + v16)) >> 3)) > v48);
  unsigned int v137 = v141 & 0xFFFFFFF8;
  unint64_t v143 = v37;
  if (v47 > v34)
  {
    size_t __n = v34;
    __srca = v44;
    unint64_t v149 = v40;
    int v49 = malloc_type_calloc(v47, 1uLL, 0x4FC83FC7uLL);
    memcpy(v49, __srca, __n);
    *int v49 = v47 >> 2;
    v49[1] = v47 >> 10;
    v49[2] = v47 >> 18;
    v17 += v49 - (unsigned char *)__srca;
    uint64_t v31 = &a13[v49 - (unsigned char *)__srca];
    v143 += v49 - (unsigned char *)__srca;
    free(__srca);
    unsigned int v45 = (v35 * v16) >> 3;
    unint64_t v40 = v149;
    uint64_t v38 = v153;
    uint64_t v44 = v49;
  }
  unsigned int v50 = a6;
  if (!v40)
  {
    unsigned int v84 = a5;
    int v85 = a15;
    unint64_t v83 = v143;
    if (!a16) {
      goto LABEL_100;
    }
    goto LABEL_75;
  }
  __src = v44;
  uint64_t v133 = ((v43 * v16) >> 3) - v45;
  BOOL v51 = (v43 * v16) >> 3 != v45 && v143 > (unint64_t)v31;
  if (v51)
  {
    memmove(&v31[v133], v31, v143 - (void)v31);
    uint64_t v38 = v153;
    unsigned int v50 = a6;
  }
  if (v16)
  {
    unsigned int v150 = 0xFFFFFFFF >> -(char)v38;
    uint64_t v148 = v147 & 4;
    if (v42 >= 8) {
      int v52 = 8;
    }
    else {
      int v52 = v42;
    }
    unsigned int v145 = 0xFFu >> (8 - v52);
    int v144 = -256 >> (8 - v52);
    unsigned int v53 = v42 - v52;
    if ((v42 & 4) + v30 <= 8) {
      int v54 = v30;
    }
    else {
      int v54 = 8 - (v42 & 4);
    }
    unsigned int v55 = 0xFFu >> (8 - v54);
    unsigned int v56 = v30 - v54;
    unsigned int v57 = v43 * (v16 - 1);
    unsigned int v58 = v154 + v57;
    unsigned int v59 = v154 + v57 + v42;
    do
    {
      --v16;
      if (v50)
      {
        uint64_t v60 = ((v16 * v35) >> 3) + v17;
        unint64_t v61 = v60 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v62 = 8 * (v60 & 3);
        int v63 = *(_DWORD *)(v60 & 0xFFFFFFFFFFFFFFFCLL) >> v62;
        if (v62 >= 9) {
          v63 |= *(_DWORD *)(v61 + 4) << -(char)v62;
        }
        int v64 = v63 & 0xFFFFFF;
        if (!v38)
        {
LABEL_63:
          unsigned int v69 = 0;
          if (v30) {
            goto LABEL_43;
          }
          goto LABEL_64;
        }
      }
      else
      {
        int v64 = 0;
        if (!v38) {
          goto LABEL_63;
        }
      }
      uint64_t v65 = ((v154 + v16 * v35) >> 3) + v17;
      unsigned int v66 = (_DWORD *)(v65 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v67 = 8 * (v65 & 3);
      int v68 = *v66 >> v67;
      if ((unint64_t)(v67 + v38) >= 0x21) {
        v68 |= v66[1] << -(char)v67;
      }
      unsigned int v69 = v68 & v150;
      if (v30)
      {
LABEL_43:
        uint64_t v70 = (_DWORD *)((((v151 + v16 * v35) >> 3) + v17) & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v71 = v148 & 0xFFFFFFFFFFFFFFE7 | (8 * ((((v151 + v16 * v35) >> 3) + (_BYTE)v17) & 3));
        int v72 = *v70 >> v71;
        if (v71 + v30 >= 0x21) {
          v72 |= v70[1] << -(char)v71;
        }
        unsigned int v73 = v72 & (0xFFFFFFFF >> -(char)v30);
        if (!v50) {
          goto LABEL_47;
        }
LABEL_46:
        *(unsigned char *)(v17 + ((unint64_t)(v16 * v43) >> 3)) = v64;
        uint64_t v74 = (v57 >> 3) + v17;
        *(unsigned char *)(v74 + 1) = BYTE1(v64);
        *(unsigned char *)(v74 + 2) = BYTE2(v64);
        goto LABEL_47;
      }
LABEL_64:
      unsigned int v73 = 0;
      if (v50) {
        goto LABEL_46;
      }
LABEL_47:
      if (v42)
      {
        *(unsigned char *)(v17 + ((unint64_t)(v154 + v16 * v43) >> 3)) = v144 & *(unsigned char *)(v17
                                                                                        + ((unint64_t)(v154 + v16 * v43) >> 3)) | v69 & v145;
        if (v53)
        {
          unsigned int v75 = (v58 >> 3) + 1;
          unsigned int v76 = v53;
          do
          {
            if (v76 >= 8) {
              int v77 = 8;
            }
            else {
              int v77 = v76;
            }
            *(unsigned char *)(v17 + v75) = (-256 >> (8 - v77)) & *(unsigned char *)(v17 + v75) | (0xFFu >> (8 - v77)) & (v69 >> (v42 - v76));
            ++v75;
            v76 -= v77;
          }
          while (v76);
        }
      }
      if (v30)
      {
        *(unsigned char *)(v17 + ((unint64_t)(v42 + v154 + v16 * v43) >> 3)) = *(unsigned char *)(v17
                                                                                       + ((unint64_t)(v42 + v154 + v16 * v43) >> 3)) & ~((_BYTE)v55 << (v42 & 4)) | ((v73 & v55) << (v42 & 4));
        if (v56)
        {
          unsigned int v78 = (v59 >> 3) + 1;
          unsigned int v79 = v56;
          do
          {
            if (v79 >= 8) {
              int v80 = 8;
            }
            else {
              int v80 = v79;
            }
            *(unsigned char *)(v17 + v78) = (-256 >> (8 - v80)) & *(unsigned char *)(v17 + v78) | (0xFFu >> (8 - v80)) & (v73 >> (v30 - v79));
            ++v78;
            v79 -= v80;
          }
          while (v79);
        }
      }
      v57 -= v43;
      v58 -= v43;
      v59 -= v43;
      unsigned int v50 = a6;
      uint64_t v38 = v153;
    }
    while (v16);
  }
  uint64_t v44 = __src;
  if (v50 < v134)
  {
    uint64_t v81 = __src + 3;
    int v82 = v131 == 6 ? 3 : 7;
    v81[v132] = v81[v132] & ~((_BYTE)v82 << v131) | ((v82 & (v42 >> 2)) << v131);
    if (v131 == 6) {
      v81[(v129 >> 3) + 1] = v81[(v129 >> 3) + 1] & 0xFE | ((v42 & 0x10) != 0);
    }
  }
  v31 += v133;
  unint64_t v83 = v143 + v133;
  unsigned int v84 = a5;
  int v85 = a15;
  if (a16)
  {
LABEL_75:
    uint64_t v86 = v43 >> 3;
    if (v43)
    {
      size_t v87 = (char *)(v17 + v86 * a10);
      if (v83 > (unint64_t)v87)
      {
        unint64_t v88 = v83;
        int v89 = v44;
        memmove(&v87[v86], v87, v83 - (void)v87);
        unsigned int v50 = a6;
        unint64_t v83 = v88;
        uint64_t v44 = v89;
        int v85 = a15;
      }
    }
    if (v50)
    {
      unint64_t v90 = v17 + ((unint64_t)(v43 * a10) >> 3);
      *(_WORD *)unint64_t v90 = v130;
      *(unsigned char *)(v90 + 2) = BYTE2(v130);
    }
    if (v42)
    {
      unint64_t v91 = (unint64_t)(v154 + v43 * a10) >> 3;
      int v92 = v42 >= 8 ? 8 : v42;
      *(unsigned char *)(v17 + v91) = (-256 >> (8 - v92)) & *(unsigned char *)(v17 + v91) | (0xFFu >> (8 - v92)) & a11;
      unsigned int v93 = v42 - v92;
      if (v93)
      {
        unsigned int v94 = v91 + 1;
        do
        {
          if (v93 >= 8) {
            int v95 = 8;
          }
          else {
            int v95 = v93;
          }
          *(unsigned char *)(v17 + v94) = (-256 >> (8 - v95)) & *(unsigned char *)(v17 + v94) | (0xFFu >> (8 - v95)) & (a11 >> (v42 - v93));
          ++v94;
          v93 -= v95;
        }
        while (v93);
      }
    }
    if (v30)
    {
      unint64_t v96 = (unint64_t)(v42 + v154 + v43 * a10) >> 3;
      int v97 = 8 - (v42 & 4);
      if ((v42 & 4) + v30 <= 8) {
        int v97 = v30;
      }
      *(unsigned char *)(v17 + v96) = *(unsigned char *)(v17 + v96) & ~(0xFFu >> (8 - v97) << (v42 & 4)) | (((0xFFu >> (8 - v97)) & a12) << (v42 & 4));
      unsigned int v98 = v30 - v97;
      if (v30 != v97)
      {
        unsigned int v99 = v96 + 1;
        do
        {
          if (v98 >= 8) {
            int v100 = 8;
          }
          else {
            int v100 = v98;
          }
          *(unsigned char *)(v17 + v99) = (-256 >> (8 - v100)) & *(unsigned char *)(v17 + v99) | (0xFFu >> (8 - v100)) & (a12 >> (v30 - v98));
          ++v99;
          v98 -= v100;
        }
        while (v98);
      }
    }
    v31 += v86;
    v83 += v86;
  }
LABEL_100:
  if (v141 >= 8)
  {
    unsigned int v101 = &v31[v142 * v85];
    if (v83 > (unint64_t)v101)
    {
      size_t v102 = v44;
      memmove(&v101[v142], v101, v83 - (void)v101);
      uint64_t v44 = v102;
    }
  }
  if (a3)
  {
    unint64_t v103 = (unint64_t)(v137 * v85) >> 3;
    int v104 = a3 >= 8 ? 8 : a3;
    v31[v103] = (-256 >> (8 - v104)) & v31[v103] | (0xFFu >> (8 - v104)) & v84;
    unsigned int v105 = a3 - v104;
    if (v105)
    {
      int v106 = v103 + 1;
      do
      {
        if (v105 >= 8) {
          int v107 = 8;
        }
        else {
          int v107 = v105;
        }
        v31[v106] = (-256 >> (8 - v107)) & v31[v106] | (0xFFu >> (8 - v107)) & (v84 >> (a3 - v105));
        ++v106;
        v105 -= v107;
      }
      while (v105);
    }
  }
  if (a9 >= 4194300.0)
  {
    int v108 = 12582912;
    unsigned int v109 = 0x3FFFFF;
  }
  else if (a9 >= 32768.0)
  {
    unsigned int v109 = (int)a9;
    int v108 = 12582912;
  }
  else if (a9 >= 256.0)
  {
    unsigned int v109 = vcvts_n_s32_f32(a9, 7uLL);
    int v108 = 0x800000;
  }
  else if (a9 >= 4.0)
  {
    unsigned int v109 = vcvts_n_s32_f32(a9, 0xEuLL);
    int v108 = 0x400000;
  }
  else
  {
    int v108 = 0;
    if (a9 <= 0.0) {
      unsigned int v109 = 0;
    }
    else {
      unsigned int v109 = vcvts_n_s32_f32(a9, 0x14uLL);
    }
  }
  if (v109 >= 0x3FFFFF) {
    unsigned int v109 = 0x3FFFFF;
  }
  unsigned int v110 = v109 | v108;
  unint64_t v111 = (unint64_t)(a3 + v137 * v85) >> 3;
  v31[v111] = ((v109 & (0xFFu >> (a3 & 7))) << (a3 & 7)) | v31[v111] & ~(0xFFu >> (a3 & 7) << (a3 & 7));
  unsigned int v112 = (a3 | 0xFFFFFFF8) + 24;
  int v113 = v111 + 1;
  do
  {
    if (v112 >= 8) {
      int v114 = 8;
    }
    else {
      int v114 = v112;
    }
    v31[v113] = (-256 >> (8 - v114)) & v31[v113] | (0xFFu >> (8 - v114)) & (v110 >> (24 - v112));
    ++v113;
    v112 -= v114;
  }
  while (v112);
  if (v136 > a10)
  {
    int v115 = v42 >= 8 ? 8 : v42;
    if (v42)
    {
      unsigned int v116 = 0xFFu >> (8 - v115);
      int v117 = -256 >> (8 - v115);
      unsigned int v118 = v42 - v115;
      unsigned int v119 = v154 + v43 * a10;
      do
      {
        unint64_t v120 = (unint64_t)(v154 + v32 * v43) >> 3;
        int v121 = (_DWORD *)((v120 + v17) & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v122 = 8 * ((v120 + v17) & 3);
        int v123 = *v121 >> v122;
        if (v122 + (unint64_t)v42 >= 0x21) {
          v123 |= v121[1] << (-8 * ((v120 + v17) & 3));
        }
        unsigned int v124 = (v123 & (0xFFFFFFFF >> -(char)v42)) + 1;
        *(unsigned char *)(v17 + v120) = v117 & *(unsigned char *)(v17 + v120) | v124 & v116;
        if (v118)
        {
          unsigned int v125 = (v119 >> 3) + 1;
          unsigned int v126 = v118;
          do
          {
            if (v126 >= 8) {
              int v127 = 8;
            }
            else {
              int v127 = v126;
            }
            *(unsigned char *)(v17 + v125) = (-256 >> (8 - v127)) & *(unsigned char *)(v17 + v125) | (0xFFu >> (8 - v127)) & (v124 >> (v42 - v126));
            ++v125;
            v126 -= v127;
          }
          while (v126);
        }
        ++v32;
        v119 += v43;
      }
      while (v32 != v136);
    }
  }
  return v44;
}

uint64_t sub_19E52CBF4(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, float a5)
{
  int v6 = 0;
  uint64_t v7 = a1 + 3;
  unsigned int v8 = (a3 + 31) & 0xFFFFFFF8;
  uint64_t v9 = a3 & 7;
  unsigned int v10 = 0xFFu >> (a3 & 7);
  int v11 = ~(v10 << (a3 & 7));
  unsigned int v12 = (a3 | 0xFFFFFFF8) + 24;
  if (a2 <= 1) {
    int v13 = 1;
  }
  else {
    int v13 = a2;
  }
  int v14 = v13 - 1;
  unsigned int v15 = 1;
  uint64_t result = 947912704;
  uint64_t v60 = v7;
  int v59 = v13 - 1;
  while (1)
  {
    int v17 = v6 ? 24 : 0;
    int v18 = 6 * v6;
    int v19 = *(_DWORD *)(((((3 * v6) >> 2) & 0x1FFFFFFF) + v7) & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * v6) & 6 | (8 * ((((3 * v6) >> 2) + v7) & 3)));
    if (v6 + 1 >= a2)
    {
      unsigned int v25 = 0;
    }
    else
    {
      char v20 = v18 + 3;
      uint64_t v21 = ((v18 + 3) >> 3) + v7;
      int v22 = (_DWORD *)(v21 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v23 = v20 & 7 | (8 * (v21 & 3));
      int v24 = *v22 >> v23;
      if (v23 >= 0x1E) {
        v24 |= v22[1] << -(char)v23;
      }
      unsigned int v25 = 4 * (v24 & 7);
    }
    unsigned int v26 = (4 * v19) & 0x1C;
    unsigned int v27 = v26 + v17;
    int v28 = (((4 * (_BYTE)v19) & 0x1C) + (_BYTE)v17 + (_BYTE)v25 + 7) & 0xF8;
    int v29 = v28 * (v15 - 1);
    unsigned int v30 = v28 * v15;
    if (v26) {
      break;
    }
    unsigned int v36 = 0;
    uint64_t v35 = a4 + (v30 >> 3);
    if (v6 == v14) {
      return result;
    }
LABEL_50:
    if (!v25) {
      return result;
    }
    uint64_t v55 = ((v29 + v27) >> 3) + a4;
    unint64_t v56 = v55 & 0xFFFFFFFFFFFFFFFCLL;
    uint64_t v57 = (4 * (_BYTE)v19) & 4 | (8 * (v55 & 3));
    int v58 = *(_DWORD *)(v55 & 0xFFFFFFFFFFFFFFFCLL) >> v57;
    if (v57 + (unint64_t)v25 >= 0x21) {
      v58 |= *(_DWORD *)(v56 + 4) << -(char)v57;
    }
    unsigned int v15 = v58 & (0xFFFFFFFF >> -(char)v25);
    if (!v15) {
      return result;
    }
    a4 = v35 + ((v36 * v8) >> 3);
    ++v6;
  }
  int v62 = v29;
  uint64_t v31 = ((v29 + v17) >> 3) + a4;
  unint64_t v32 = v31 & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v33 = 8 * (v31 & 3);
  int v34 = *(_DWORD *)(v31 & 0xFFFFFFFFFFFFFFFCLL) >> v33;
  if (v33 + (unint64_t)v26 >= 0x21) {
    v34 |= *(_DWORD *)(v32 + 4) << -(char)v33;
  }
  uint64_t v35 = a4 + (v30 >> 3);
  unsigned int v36 = v34 & (0xFFFFFFFF >> -(char)v26);
  if (v36)
  {
    int v37 = 0;
    unsigned int v38 = a3;
    do
    {
      unint64_t v39 = (unint64_t)(a3 + v37 * v8) >> 3;
      unint64_t v40 = (_DWORD *)((v39 + v35) & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v41 = v9 & 0xFFFFFFFFFFFFFFE7 | (8 * ((v39 + v35) & 3));
      unsigned int v42 = *v40 >> v41;
      if (v41 >= 9) {
        v42 |= v40[1] << -(char)v41;
      }
      int v43 = (v42 >> 22) & 3;
      float v44 = (float)(v42 & 0x3FFFFF);
      float v45 = v44 * 0.0078125;
      float v46 = v44 * 0.000061035;
      if (!v43) {
        float v44 = v44 * 0.00000095367;
      }
      if (v43 == 1) {
        float v44 = v46;
      }
      if (v43 == 2) {
        float v44 = v45;
      }
      float v47 = v44 * a5;
      if (v47 >= 4194300.0)
      {
        unsigned int v49 = 0x3FFFFF;
        int v48 = 12582912;
      }
      else if (v47 >= 32768.0)
      {
        unsigned int v49 = (int)v47;
        int v48 = 12582912;
      }
      else if (v47 >= 256.0)
      {
        unsigned int v49 = vcvts_n_s32_f32(v47, 7uLL);
        int v48 = 0x800000;
      }
      else if (v47 >= 4.0)
      {
        unsigned int v49 = vcvts_n_s32_f32(v47, 0xEuLL);
        int v48 = 0x400000;
      }
      else
      {
        int v48 = 0;
        if (v47 <= 0.0) {
          unsigned int v49 = 0;
        }
        else {
          unsigned int v49 = vcvts_n_s32_f32(v47, 0x14uLL);
        }
      }
      unsigned int v50 = (v38 >> 3) + 1;
      if (v49 >= 0x3FFFFF) {
        int v51 = 0x3FFFFF;
      }
      else {
        int v51 = v49;
      }
      unsigned int v52 = v51 | v48;
      *(unsigned char *)(v35 + v39) = ((v51 & v10) << v9) | *(unsigned char *)(v35 + v39) & v11;
      unsigned int v53 = v12;
      do
      {
        if (v53 >= 8) {
          int v54 = 8;
        }
        else {
          int v54 = v53;
        }
        *(unsigned char *)(v35 + v50) = (-256 >> (8 - v54)) & *(unsigned char *)(v35 + v50) | (0xFFu >> (8 - v54)) & (v52 >> (24 - v53));
        ++v50;
        v53 -= v54;
      }
      while (v53);
      ++v37;
      v38 += v8;
    }
    while (v37 != v36);
    uint64_t v7 = v60;
    int v14 = v59;
  }
  int v29 = v62;
  if (v6 != v14) {
    goto LABEL_50;
  }
  return result;
}

void sub_19E52CFE4(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7 = *(unsigned __int8 *)(a1 + 7);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 6);
  int v9 = *(_DWORD *)(a1 + 20);
  size_t v30 = *(unsigned __int8 *)(a1 + 5);
  unsigned int v10 = (unsigned int *)malloc_type_calloc(v30, 4uLL, 0x100004052888210uLL);
  int v14 = *(char **)(a1 + 24);
  unsigned int v15 = *(void **)(a1 + 32);
  unsigned int v16 = *(void **)(a1 + 40);
  *(unsigned char *)(a1 + 6) = a4;
  *(unsigned char *)(a1 + 7) = 64;
  *(_DWORD *)(a1 + 20) = 0;
  *(void *)(a1 + 12) = 24;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  if (v15)
  {
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 0x40000000;
    v31[2] = sub_19E52D248;
    v31[3] = &unk_1E59A1E90;
    v31[4] = a3;
    v31[5] = a1;
    sub_19E528F50((uint64_t)v15, 1u, v8, (uint64_t)v10, 1u, 0, (uint64_t)v15 + 4, 1, 0, 1u, (uint64_t)v31);
    free(v15);
  }
  if (v14)
  {
    unsigned int v27 = v16;
    uint64_t v28 = a3;
    if (v9 && v7)
    {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v7;
      unsigned int v18 = 24;
      do
      {
        int v19 = (_DWORD *)((unint64_t)&v14[(v18 - 24) >> 3] & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v20 = (v18 - 24) & 7 | (8 * ((unint64_t)&v14[(v18 - 24) >> 3] & 3));
        int v21 = *v19 >> v20;
        if (v20 >= 9) {
          v21 |= v19[1] << -(char)v20;
        }
        unint64_t v22 = (unint64_t)&v14[v18 >> 3];
        unint64_t v23 = v22 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v24 = (v18 - 24) & 7 | (8 * (v22 & 7));
        uint64_t v25 = *(void *)(v22 & 0xFFFFFFFFFFFFFFF8) >> v24;
        if ((unint64_t)(v24 + v7) >= 0x41) {
          v25 |= *(void *)(v23 + 8) << -(char)v24;
        }
        unsigned int v26 = (void *)(v25 & v17);
        if ((v25 & v17) != 0)
        {
          sub_19E52D2C0(a1, v25 & v17, v30, v8, v21 & 0xFFFFFF, v10, 0, (uint64_t)v26 + ((6 * (unint64_t)v30 + 4) >> 3) + 3, v11, v12, v13, 1u, 0, 1u, a2, v28);
          free(v26);
        }
        v18 += v7 + 24;
        --v9;
      }
      while (v9);
    }
    free(v14);
    unsigned int v16 = v27;
  }
  if (v16) {
    free(v16);
  }
  free(v10);
}

void sub_19E52D248(uint64_t a1, uint64_t a2, float a3)
{
  if (a3 > 0.0)
  {
    unsigned int v5 = a2;
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      unsigned int v5 = (*(uint64_t (**)(uint64_t, uint64_t))(v7 + 16))(v7, a2);
    }
    uint64_t v8 = *(void *)(a1 + 40);
    sub_19E52A9A8(v8, 0, 0, v5, a3);
  }
}

void sub_19E52D2C0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int *a6, unsigned int a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, unsigned int a12, unsigned int a13, unsigned int a14, uint64_t a15, uint64_t a16)
{
  unsigned int v16 = a12;
  unsigned int v102 = a14;
  if (a12) {
    BOOL v17 = a13 >= a14;
  }
  else {
    BOOL v17 = 1;
  }
  if (!v17)
  {
    unsigned int v20 = a13;
    uint64_t v100 = a2 + 3;
    int v93 = a4 + 31;
    int v21 = (a4 + 31) & 0xFFFFFFF8;
    uint64_t v22 = a4 & 7;
    uint64_t v114 = a4;
    unsigned int v113 = 0xFFFFFFFF >> -(char)a4;
    while (1)
    {
      int v23 = a7 ? 24 : 0;
      int v24 = 6 * a7;
      uint64_t v25 = (((3 * a7) >> 2) & 0x1FFFFFFF) + v100;
      int v26 = *(_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a7) & 6 | (8 * (v25 & 3)));
      unsigned int v112 = a7 + 1;
      if (a7 + 1 < a3)
      {
        char v28 = v24 + 3;
        uint64_t v29 = ((v24 + 3) >> 3) + v100;
        size_t v30 = (_DWORD *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v31 = v28 & 7 | (8 * (v29 & 3));
        int v32 = *v30 >> v31;
        if (v31 >= 0x1E) {
          v32 |= v30[1] << -(char)v31;
        }
        int v27 = 4 * (v32 & 7);
      }
      else
      {
        int v27 = 0;
      }
      char v105 = 4 * v26;
      unsigned int v33 = (4 * v26) & 0x1C;
      unsigned int v109 = v33 + v23;
      int v34 = (((4 * (_BYTE)v26) & 0x1C) + (_BYTE)v23 + (_BYTE)v27 + 7) & 0xF8;
      uint64_t v103 = v33;
      uint64_t v111 = a8;
      int v99 = v23;
      unsigned int v107 = v27;
      int v104 = v34 * (v16 - 1);
      if (v33)
      {
        uint64_t v35 = ((v34 * (v16 - 1) + v23) >> 3) + a8;
        unint64_t v36 = v35 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v37 = 8 * (v35 & 3);
        int v38 = *(_DWORD *)(v35 & 0xFFFFFFFFFFFFFFFCLL) >> v37;
        if (v37 + (unint64_t)v33 >= 0x21) {
          v38 |= *(_DWORD *)(v36 + 4) << -(char)v37;
        }
        unsigned int v39 = v38 & (0xFFFFFFFF >> -(char)v33);
      }
      else
      {
        unsigned int v39 = 0;
      }
      uint64_t v40 = a8 + ((v34 * v16) >> 3);
      uint64_t v108 = v40 + ((v39 * v21) >> 3);
      if (a7) {
        break;
      }
      unsigned int v41 = a5;
      if (a15) {
        unsigned int v41 = (*(uint64_t (**)(uint64_t))(a15 + 16))(a15);
      }
      *a6 = v41;
      if (v39)
      {
        unsigned int v42 = 0;
        while (2)
        {
          uint64_t v43 = ((a4 + v42) >> 3) + v40;
          unint64_t v44 = v43 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v45 = v22 & 0xFFFFFFFFFFFFFFE7 | (8 * (v43 & 3));
          unsigned int v46 = *(_DWORD *)(v43 & 0xFFFFFFFFFFFFFFFCLL) >> v45;
          if (v45 >= 9) {
            v46 |= *(_DWORD *)(v44 + 4) << -(char)v45;
          }
          int v47 = (v46 >> 22) & 3;
          unsigned int v48 = v46 & 0x3FFFFF;
          a9.n128_f32[0] = (float)v48;
          a10.n128_f32[0] = (float)v48 * 0.0078125;
          a11.n128_f32[0] = (float)v48 * 0.000061035;
          if (!v47) {
            a9.n128_f32[0] = (float)v48 * 0.00000095367;
          }
          if (v47 == 1) {
            a9.n128_f32[0] = (float)v48 * 0.000061035;
          }
          if (v47 == 2) {
            float v49 = (float)v48 * 0.0078125;
          }
          else {
            float v49 = a9.n128_f32[0];
          }
          if (v49 <= 0.0) {
            goto LABEL_27;
          }
          if (a4)
          {
            uint64_t v50 = (v42 >> 3) + v40;
            unint64_t v51 = v50 & 0xFFFFFFFFFFFFFFFCLL;
            uint64_t v52 = 8 * (v50 & 3);
            int v53 = *(_DWORD *)(v50 & 0xFFFFFFFFFFFFFFFCLL) >> v52;
            if ((unint64_t)(v52 + v114) >= 0x21) {
              v53 |= *(_DWORD *)(v51 + 4) << -(char)v52;
            }
            uint64_t v54 = v53 & v113;
            if (!a16)
            {
LABEL_26:
              sub_19E52A9A8(a1, a6, 1, v54, v49);
LABEL_27:
              v42 += v21;
              if (!--v39) {
                goto LABEL_45;
              }
              continue;
            }
          }
          else
          {
            uint64_t v54 = 0;
            if (!a16) {
              goto LABEL_26;
            }
          }
          break;
        }
        LODWORD(v54) = (*(uint64_t (**)(uint64_t, uint64_t, __n128, __n128, __n128))(a16 + 16))(a16, v54, a9, a10, a11);
        goto LABEL_26;
      }
LABEL_45:
      if (a3 >= 2 && v107)
      {
        uint64_t v55 = ((v104 + v109) >> 3) + v111;
        unint64_t v56 = v55 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v57 = v105 & 4 | (8 * (v55 & 3));
        int v58 = *(_DWORD *)(v55 & 0xFFFFFFFFFFFFFFFCLL) >> v57;
        if (v57 + (unint64_t)v107 >= 0x21) {
          v58 |= *(_DWORD *)(v56 + 4) << -(char)v57;
        }
        unsigned int v20 = 0;
        a7 = 1;
        a8 = v108;
        unsigned int v16 = v58 & (0xFFFFFFFF >> -(char)v107);
        unsigned int v102 = v16;
        if (v16) {
          continue;
        }
      }
      return;
    }
    int v101 = v34;
    uint64_t v59 = a8;
    if (v20 < v102)
    {
      BOOL v61 = v112 >= a3 || v107 == 0;
      BOOL v95 = v61;
      unsigned int v96 = 0xFFFFFFFF >> -(char)v33;
      unsigned int v94 = v93 & 0xFFFFFFF8;
      uint64_t v106 = a7;
      while (1)
      {
        uint64_t v62 = ((v20 * v101) >> 3) + v59;
        unint64_t v63 = v62 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v64 = 8 * (v62 & 3);
        int v65 = *(_DWORD *)(v62 & 0xFFFFFFFFFFFFFFFCLL) >> v64;
        if (v64 >= 9) {
          v65 |= *(_DWORD *)(v63 + 4) << -(char)v64;
        }
        int v66 = v65 & 0xFFFFFF;
        if (a15) {
          int v66 = (*(uint64_t (**)(void))(a15 + 16))();
        }
        a6[v106] = v66;
        if (v103)
        {
          uint64_t v67 = ((v20 * v101 + v99) >> 3) + v59;
          unint64_t v68 = v67 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v69 = 8 * (v67 & 3);
          int v70 = *(_DWORD *)(v67 & 0xFFFFFFFFFFFFFFFCLL) >> v69;
          if ((unint64_t)(v69 + v103) >= 0x21) {
            v70 |= *(_DWORD *)(v68 + 4) << -(char)v69;
          }
          unsigned int v71 = v70 & v96;
          if (!v20)
          {
LABEL_73:
            uint64_t v72 = v59;
            unsigned int v77 = 0;
            unsigned int v78 = v71;
            if (v71) {
              break;
            }
            goto LABEL_94;
          }
        }
        else
        {
          unsigned int v71 = 0;
          if (!v20) {
            goto LABEL_73;
          }
        }
        if (!v103) {
          goto LABEL_73;
        }
        uint64_t v72 = v59;
        uint64_t v73 = ((v99 + (v20 - 1) * v101) >> 3) + v59;
        unint64_t v74 = v73 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v75 = 8 * (v73 & 3);
        int v76 = *(_DWORD *)(v73 & 0xFFFFFFFFFFFFFFFCLL) >> v75;
        if ((unint64_t)(v75 + v103) >= 0x21) {
          v76 |= *(_DWORD *)(v74 + 4) << -(char)v75;
        }
        unsigned int v77 = v76 & v96;
        unsigned int v78 = v71 - v77;
        if (v71 > v77) {
          break;
        }
LABEL_94:
        uint64_t v59 = v72;
        if (!v95) {
          sub_19E52D2C0(a1, a2, a3, a4);
        }
        if (++v20 == v102) {
          return;
        }
      }
      unsigned int v79 = v94 * v77;
      while (1)
      {
        uint64_t v80 = ((a4 + v79) >> 3) + v40;
        unint64_t v81 = v80 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v82 = v22 & 0xFFFFFFFFFFFFFFE7 | (8 * (v80 & 3));
        unsigned int v83 = *(_DWORD *)(v80 & 0xFFFFFFFFFFFFFFFCLL) >> v82;
        if (v82 >= 9) {
          v83 |= *(_DWORD *)(v81 + 4) << -(char)v82;
        }
        int v84 = (v83 >> 22) & 3;
        a9.n128_f32[0] = (float)(v83 & 0x3FFFFF);
        float v85 = a9.n128_f32[0] * 0.0078125;
        float v86 = a9.n128_f32[0] * 0.000061035;
        if (!v84) {
          a9.n128_f32[0] = a9.n128_f32[0] * 0.00000095367;
        }
        if (v84 == 1) {
          a9.n128_f32[0] = v86;
        }
        if (v84 == 2) {
          float v87 = v85;
        }
        else {
          float v87 = a9.n128_f32[0];
        }
        if (v87 <= 0.0) {
          goto LABEL_76;
        }
        if (a4) {
          break;
        }
        uint64_t v92 = 0;
        if (a16) {
          goto LABEL_93;
        }
LABEL_75:
        sub_19E52A9A8(a1, a6, v112, v92, v87);
LABEL_76:
        v79 += v21;
        if (!--v78) {
          goto LABEL_94;
        }
      }
      uint64_t v88 = (v79 >> 3) + v40;
      unint64_t v89 = v88 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v90 = 8 * (v88 & 3);
      int v91 = *(_DWORD *)(v88 & 0xFFFFFFFFFFFFFFFCLL) >> v90;
      if ((unint64_t)(v90 + v114) >= 0x21) {
        v91 |= *(_DWORD *)(v89 + 4) << -(char)v90;
      }
      uint64_t v92 = v91 & v113;
      if (!a16) {
        goto LABEL_75;
      }
LABEL_93:
      LODWORD(v92) = (*(uint64_t (**)(uint64_t, uint64_t, __n128))(a16 + 16))(a16, v92, a9);
      goto LABEL_75;
    }
  }
}

void sub_19E52DAF0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    uint64_t v4 = *(unsigned __int8 *)(a1 + 7);
    uint64_t v5 = *(unsigned __int8 *)(a1 + 6);
    int v6 = *(_DWORD *)(a1 + 20);
    size_t v24 = *(unsigned __int8 *)(a1 + 5);
    uint64_t v7 = (unsigned int *)malloc_type_calloc(v24, 4uLL, 0x100004052888210uLL);
    __n128 v11 = *(char **)(a1 + 24);
    __n128 v12 = *(void **)(a1 + 32);
    __n128 v13 = *(void **)(a1 + 40);
    *(unsigned char *)(a1 + 7) = 64;
    *(_DWORD *)(a1 + 20) = 0;
    *(void *)(a1 + 12) = 24;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    if (v12)
    {
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 0x40000000;
      v27[2] = sub_19E52DD50;
      void v27[3] = &unk_1E59A1EB8;
      v27[4] = a3;
      v27[5] = a1;
      sub_19E528F50((uint64_t)v12, 1u, v5, (uint64_t)v7, 1u, 0, (uint64_t)v12 + 4, 1, 0, 1u, (uint64_t)v27);
      free(v12);
    }
    if (v11)
    {
      if (v6 && v4)
      {
        unint64_t v14 = 0xFFFFFFFFFFFFFFFFLL >> -(char)v4;
        unsigned int v15 = 24;
        do
        {
          unsigned int v16 = (_DWORD *)((unint64_t)&v11[(v15 - 24) >> 3] & 0xFFFFFFFFFFFFFFFCLL);
          unint64_t v17 = (v15 - 24) & 7 | (8 * ((unint64_t)&v11[(v15 - 24) >> 3] & 3));
          int v18 = *v16 >> v17;
          if (v17 >= 9) {
            v18 |= v16[1] << -(char)v17;
          }
          unint64_t v19 = (unint64_t)&v11[v15 >> 3];
          unint64_t v20 = v19 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v21 = (v15 - 24) & 7 | (8 * (v19 & 7));
          uint64_t v22 = *(void *)(v19 & 0xFFFFFFFFFFFFFFF8) >> v21;
          if ((unint64_t)(v21 + v4) >= 0x41) {
            v22 |= *(void *)(v20 + 8) << -(char)v21;
          }
          int v23 = (void *)(v22 & v14);
          if ((v22 & v14) != 0)
          {
            sub_19E52DDD8(a1, v22 & v14, v24, v5, v18 & 0xFFFFFF, v7, 0, (uint64_t)v23 + ((6 * (unint64_t)v24 + 4) >> 3) + 3, v8, v9, v10, 1u, 0, 1u, a2, a3);
            free(v23);
          }
          v15 += v4 + 24;
          --v6;
        }
        while (v6);
      }
      free(v11);
    }
    if (v13) {
      free(v13);
    }
    free(v7);
  }
}

void sub_19E52DD50(uint64_t a1, uint64_t a2, float a3)
{
  if (a3 > 0.0)
  {
    unsigned int v4 = a2;
    uint64_t v6 = *(void *)(a1 + 32);
    if (!v6 || (*(unsigned int (**)(uint64_t, uint64_t))(v6 + 16))(v6, a2))
    {
      uint64_t v7 = *(void *)(a1 + 40);
      sub_19E52A9A8(v7, 0, 0, v4, a3);
    }
  }
}

void sub_19E52DDD8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, unsigned int *a6, unsigned int a7, uint64_t a8, __n128 a9, __n128 a10, __n128 a11, unsigned int a12, unsigned int a13, unsigned int a14, uint64_t a15, uint64_t a16)
{
  unsigned int v16 = a12;
  unsigned int v119 = a14;
  if (a12) {
    BOOL v17 = a13 >= a14;
  }
  else {
    BOOL v17 = 1;
  }
  if (v17) {
    return;
  }
  unsigned int v20 = a13;
  uint64_t v117 = a2 + 3;
  int v107 = a4 + 31;
  int v21 = (a4 + 31) & 0xFFFFFFF8;
  uint64_t v22 = a4 & 7;
  uint64_t v134 = a4;
  unsigned int v133 = 0xFFFFFFFF >> -(char)a4;
  while (1)
  {
    int v23 = a7 ? 24 : 0;
    int v24 = 6 * a7;
    uint64_t v25 = (((3 * a7) >> 2) & 0x1FFFFFFF) + v117;
    int v26 = *(_DWORD *)(v25 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a7) & 6 | (8 * (v25 & 3)));
    unsigned int v131 = a7 + 1;
    if (a7 + 1 < a3)
    {
      char v28 = v24 + 3;
      uint64_t v29 = ((v24 + 3) >> 3) + v117;
      size_t v30 = (_DWORD *)(v29 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v31 = v28 & 7 | (8 * (v29 & 3));
      int v32 = *v30 >> v31;
      if (v31 >= 0x1E) {
        v32 |= v30[1] << -(char)v31;
      }
      int v27 = 4 * (v32 & 7);
    }
    else
    {
      int v27 = 0;
    }
    unsigned int v33 = (4 * (_BYTE)v26) & 0x1C;
    int v126 = ((4 * v26) & 0x1C) + v23;
    int v130 = (((4 * (_BYTE)v26) & 0x1C) + (_BYTE)v23 + (_BYTE)v27 + 7) & 0xF8;
    int v115 = v23;
    uint64_t v116 = (4 * (_BYTE)v26) & 0x1C;
    unsigned int v128 = v27;
    char v122 = 4 * v26;
    int v120 = v130 * (v16 - 1);
    if (((4 * (_BYTE)v26) & 0x1C) != 0)
    {
      uint64_t v34 = ((v130 * (v16 - 1) + v23) >> 3) + a8;
      unint64_t v35 = v34 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v36 = 8 * (v34 & 3);
      int v37 = *(_DWORD *)(v34 & 0xFFFFFFFFFFFFFFFCLL) >> v36;
      if (v36 + (unint64_t)v33 >= 0x21) {
        v37 |= *(_DWORD *)(v35 + 4) << -(char)v36;
      }
      unsigned int v38 = v37 & (0xFFFFFFFF >> -(char)v33);
      if (!a15) {
        goto LABEL_23;
      }
    }
    else
    {
      unsigned int v38 = 0;
      if (!a15) {
        goto LABEL_23;
      }
    }
    if (!(*(unsigned int (**)(uint64_t, void))(a15 + 16))(a15, a5)) {
      return;
    }
LABEL_23:
    uint64_t v39 = a8 + ((v130 * v16) >> 3);
    uint64_t v125 = v39 + ((v38 * v21) >> 3);
    if (a7) {
      break;
    }
    *a6 = a5;
    if (v38)
    {
      unsigned int v40 = 0;
      do
      {
        uint64_t v41 = ((a4 + v40) >> 3) + v39;
        unint64_t v42 = v41 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v43 = v22 & 0xFFFFFFFFFFFFFFE7 | (8 * (v41 & 3));
        unsigned int v44 = *(_DWORD *)(v41 & 0xFFFFFFFFFFFFFFFCLL) >> v43;
        if (v43 >= 9) {
          v44 |= *(_DWORD *)(v42 + 4) << -(char)v43;
        }
        int v45 = (v44 >> 22) & 3;
        unsigned int v46 = v44 & 0x3FFFFF;
        a9.n128_f32[0] = (float)v46;
        a10.n128_f32[0] = (float)v46 * 0.0078125;
        a11.n128_f32[0] = (float)v46 * 0.000061035;
        if (!v45) {
          a9.n128_f32[0] = (float)v46 * 0.00000095367;
        }
        if (v45 == 1) {
          a9.n128_f32[0] = (float)v46 * 0.000061035;
        }
        if (v45 == 2) {
          float v47 = (float)v46 * 0.0078125;
        }
        else {
          float v47 = a9.n128_f32[0];
        }
        if (v47 <= 0.0) {
          goto LABEL_27;
        }
        if (a4)
        {
          uint64_t v48 = (v40 >> 3) + v39;
          unint64_t v49 = v48 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v50 = 8 * (v48 & 3);
          int v51 = *(_DWORD *)(v48 & 0xFFFFFFFFFFFFFFFCLL) >> v50;
          if ((unint64_t)(v50 + v134) >= 0x21) {
            v51 |= *(_DWORD *)(v49 + 4) << -(char)v50;
          }
          uint64_t v52 = v51 & v133;
          if (a16)
          {
LABEL_44:
            if (!(*(unsigned int (**)(uint64_t, uint64_t, __n128, __n128, __n128))(a16 + 16))(a16, v52, a9, a10, a11))goto LABEL_27; {
          }
            }
        }
        else
        {
          uint64_t v52 = 0;
          if (a16) {
            goto LABEL_44;
          }
        }
        sub_19E52A9A8(a1, a6, 1, v52, v47);
LABEL_27:
        v40 += v21;
        --v38;
      }
      while (v38);
    }
    if (a3 >= 2 && v128)
    {
      uint64_t v53 = ((v120 + v126) >> 3) + a8;
      unint64_t v54 = v53 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v55 = v122 & 4 | (8 * (v53 & 3));
      int v56 = *(_DWORD *)(v53 & 0xFFFFFFFFFFFFFFFCLL) >> v55;
      if (v55 + (unint64_t)v128 >= 0x21) {
        v56 |= *(_DWORD *)(v54 + 4) << -(char)v55;
      }
      unsigned int v20 = 0;
      a7 = 1;
      a8 = v125;
      unsigned int v16 = v56 & (0xFFFFFFFF >> -(char)v128);
      unsigned int v119 = v16;
      if (v16) {
        continue;
      }
    }
    return;
  }
  if (v20 < v119)
  {
    unsigned int v118 = 0xFFFFFFFF >> -(char)v116;
    BOOL v58 = v131 >= a3 || v128 == 0;
    BOOL v113 = v58;
    uint64_t v59 = ((v120 + v126) >> 3) + a8;
    unsigned int v112 = (_DWORD *)(v59 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v123 = v122 & 4;
    unint64_t v60 = v123 & 0xFFFFFFFFFFFFFFE7 | (8 * (v59 & 3));
    uint64_t v121 = v128;
    unint64_t v110 = v60 + v128;
    char v111 = v123 & 0xE7 | (8 * (v59 & 3));
    char v106 = 32 - v60;
    unsigned int v108 = v107 & 0xFFFFFFF8;
    unsigned int v109 = 0xFFFFFFFF >> -(char)v128;
    uint64_t v129 = a7;
    while (2)
    {
      unsigned int v62 = v20;
      int v63 = v20 * v130;
      uint64_t v64 = ((v20 * v130) >> 3) + a8;
      unint64_t v65 = v64 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v66 = 8 * (v64 & 3);
      int v67 = *(_DWORD *)(v64 & 0xFFFFFFFFFFFFFFFCLL) >> v66;
      if (v66 >= 9) {
        v67 |= *(_DWORD *)(v65 + 4) << -(char)v66;
      }
      uint64_t v68 = v67 & 0xFFFFFF;
      if (a15 && !(*(unsigned int (**)(uint64_t, uint64_t))(a15 + 16))(a15, v68)) {
        goto LABEL_60;
      }
      a6[v129] = v68;
      if (v116)
      {
        int v69 = v115;
        uint64_t v70 = ((v63 + v115) >> 3) + a8;
        unint64_t v71 = v70 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v72 = 8 * (v70 & 3);
        int v73 = *(_DWORD *)(v70 & 0xFFFFFFFFFFFFFFFCLL) >> v72;
        if ((unint64_t)(v72 + v116) >= 0x21) {
          v73 |= *(_DWORD *)(v71 + 4) << -(char)v72;
        }
        unsigned int v74 = v73 & v118;
        int v75 = v130;
        if (!v20) {
          goto LABEL_76;
        }
LABEL_71:
        if (v116)
        {
          uint64_t v76 = ((v69 + (v20 - 1) * v75) >> 3) + a8;
          unint64_t v77 = v76 & 0xFFFFFFFFFFFFFFFCLL;
          uint64_t v78 = 8 * (v76 & 3);
          int v79 = *(_DWORD *)(v76 & 0xFFFFFFFFFFFFFFFCLL) >> v78;
          if ((unint64_t)(v78 + v116) >= 0x21) {
            v79 |= *(_DWORD *)(v77 + 4) << -(char)v78;
          }
          unsigned int v80 = v79 & v118;
          unsigned int v81 = v74 - v80;
          if (v74 <= v80) {
            goto LABEL_98;
          }
LABEL_77:
          unsigned int v82 = v108 * v80;
          while (2)
          {
            uint64_t v83 = ((a4 + v82) >> 3) + v39;
            unint64_t v84 = v83 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v85 = v22 & 0xFFFFFFFFFFFFFFE7 | (8 * (v83 & 3));
            unsigned int v86 = *(_DWORD *)(v83 & 0xFFFFFFFFFFFFFFFCLL) >> v85;
            if (v85 >= 9) {
              v86 |= *(_DWORD *)(v84 + 4) << -(char)v85;
            }
            int v87 = (v86 >> 22) & 3;
            a9.n128_f32[0] = (float)(v86 & 0x3FFFFF);
            float v88 = a9.n128_f32[0] * 0.0078125;
            float v89 = a9.n128_f32[0] * 0.000061035;
            if (!v87) {
              a9.n128_f32[0] = a9.n128_f32[0] * 0.00000095367;
            }
            if (v87 == 1) {
              a9.n128_f32[0] = v89;
            }
            if (v87 == 2) {
              float v90 = v88;
            }
            else {
              float v90 = a9.n128_f32[0];
            }
            if (v90 > 0.0)
            {
              if (a4)
              {
                uint64_t v91 = (v82 >> 3) + v39;
                unint64_t v92 = v91 & 0xFFFFFFFFFFFFFFFCLL;
                uint64_t v93 = 8 * (v91 & 3);
                int v94 = *(_DWORD *)(v91 & 0xFFFFFFFFFFFFFFFCLL) >> v93;
                if ((unint64_t)(v93 + v134) >= 0x21) {
                  v94 |= *(_DWORD *)(v92 + 4) << -(char)v93;
                }
                uint64_t v95 = v94 & v133;
                if (!a16)
                {
LABEL_78:
                  sub_19E52A9A8(a1, a6, v131, v95, v90);
                  goto LABEL_79;
                }
              }
              else
              {
                uint64_t v95 = 0;
                if (!a16) {
                  goto LABEL_78;
                }
              }
              if ((*(unsigned int (**)(uint64_t, uint64_t, __n128))(a16 + 16))(a16, v95, a9)) {
                goto LABEL_78;
              }
            }
LABEL_79:
            v82 += v21;
            if (!--v81) {
              goto LABEL_98;
            }
            continue;
          }
        }
      }
      else
      {
        unsigned int v74 = 0;
        int v69 = v115;
        int v75 = v130;
        if (v20) {
          goto LABEL_71;
        }
      }
LABEL_76:
      unsigned int v80 = 0;
      unsigned int v81 = v74;
      if (v74) {
        goto LABEL_77;
      }
LABEL_98:
      unsigned int v62 = v20;
      if (!v113)
      {
        int v96 = *v112 >> v111;
        if (v110 >= 0x21) {
          v96 |= v112[1] << v106;
        }
        uint64_t v97 = ((v63 + v126) >> 3) + a8;
        unint64_t v98 = v97 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v99 = v123 & 0xFFFFFFFFFFFFFFE7 | (8 * (v97 & 3));
        int v100 = *(_DWORD *)(v97 & 0xFFFFFFFFFFFFFFFCLL) >> v99;
        if (v99 + v121 >= 0x21) {
          v100 |= *(_DWORD *)(v98 + 4) << -(char)v99;
        }
        if (v20)
        {
          uint64_t v101 = ((v126 + (v20 - 1) * v130) >> 3) + a8;
          unint64_t v102 = v101 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v103 = v123 & 0xFFFFFFFFFFFFFFE7 | (8 * (v101 & 3));
          int v104 = *(_DWORD *)(v101 & 0xFFFFFFFFFFFFFFFCLL) >> v103;
          if (v103 + v121 >= 0x21) {
            v104 |= *(_DWORD *)(v102 + 4) << -(char)v103;
          }
          int v61 = v104 & v109;
        }
        else
        {
          int v61 = 0;
        }
        HIDWORD(v105) = v61;
        LODWORD(v105) = v96 & v109;
        sub_19E52DDD8(a1, a2, a3, a4, a5, a6, v131, v125, v105, v100 & v109, a15, a16);
      }
LABEL_60:
      unsigned int v20 = v62 + 1;
      if (v62 + 1 == v119) {
        return;
      }
      continue;
    }
  }
}

uint64_t sub_19E52E630(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t result = *(void *)(*(void *)(a1 + 32) + 32);
  if (result)
  {
    int v5 = 0;
    return sub_19E52B1A8(result, 1u, *(_DWORD *)(a1 + 40), (uint64_t)&v5, 1, a2, 0, result + 4, -a3, 1u, 0, 1u, 0, 0, 0);
  }
  return result;
}

uint64_t sub_19E52E698(uint64_t result, unsigned int a2, unsigned int a3, int a4, uint64_t a5, int a6, unsigned int a7, unsigned int a8, float a9, uint64_t a10)
{
  uint64_t v92 = result;
  if (a6)
  {
    unsigned int v10 = a7;
    if (a7 < a8)
    {
      if (a4) {
        int v12 = 24;
      }
      else {
        int v12 = 0;
      }
      uint64_t v13 = (((3 * a4) >> 2) & 0x1FFFFFFF) + result + 3;
      char v14 = 4 * (*(_DWORD *)(v13 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * a4) & 6 | (8 * (v13 & 3))));
      uint64_t v15 = v14 & 0x1C;
      unsigned int v91 = a4 + 1;
      if (a4 + 1 < a2)
      {
        unsigned int v17 = 6 * a4 + 3;
        uint64_t v18 = (v17 >> 3) + result + 3;
        unint64_t v19 = (_DWORD *)(v18 & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v20 = v17 & 7 | (8 * (v18 & 3));
        int v21 = *v19 >> v20;
        if (v20 >= 0x1E) {
          v21 |= v19[1] << -(char)v20;
        }
        unsigned int v16 = 4 * (v21 & 7);
      }
      else
      {
        unsigned int v16 = 0;
      }
      int v97 = v15 + v12;
      unsigned int v22 = (a3 + 31) & 0xFFFFFFF8;
      int v102 = ((v14 & 0x1C) + (_BYTE)v12 + (_BYTE)v16 + 7) & 0xF8;
      int v23 = v102 * (a6 - 1);
      uint64_t v105 = v14 & 0x1C;
      if ((v14 & 0x1C) != 0)
      {
        uint64_t v24 = ((v23 + v12) >> 3) + a5;
        unint64_t v25 = v24 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v26 = 8 * (v24 & 3);
        int v27 = *(_DWORD *)(v24 & 0xFFFFFFFFFFFFFFFCLL) >> v26;
        if ((unint64_t)(v26 + v15) >= 0x21) {
          v27 |= *(_DWORD *)(v25 + 4) << -(char)v26;
        }
        unsigned int v100 = 0xFFFFFFFF >> -(char)v15;
        int v28 = v27 & v100;
      }
      else
      {
        int v28 = 0;
        unsigned int v100 = -1;
      }
      unsigned int v106 = 0;
      unsigned int v29 = 0;
      uint64_t v30 = a5 + ((v102 * a6) >> 3);
      uint64_t v90 = v30 + ((v28 * v22) >> 3);
      BOOL v32 = v91 >= a2 || v16 == 0;
      BOOL v98 = v32;
      uint64_t v33 = ((v23 + v97) >> 3) + a5;
      uint64_t v96 = v14 & 4;
      uint64_t v34 = v96 | (8 * (v33 & 3));
      int v94 = (_DWORD *)(v33 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v95 = v16;
      unint64_t v88 = v34 + v16;
      char v89 = v14 & 4 | (8 * (v33 & 3));
      char v85 = 32 - v34;
      unsigned int v86 = 0xFFFFFFFF >> -(char)v16;
      uint64_t v35 = a3 & 7;
      uint64_t v109 = a3;
      unsigned int v108 = 0xFFFFFFFF >> -(char)a3;
      int v111 = ~(-1 << (a3 & 7));
      unsigned int v110 = (a3 | 0xFFFFFFF8) + 24;
      unsigned int v87 = (a3 + 31) & 0xFFFFFFF8;
      unsigned int v107 = a3;
      int v99 = v12;
      while (1)
      {
        if (!v105) {
          goto LABEL_31;
        }
        uint64_t v36 = ((v12 + v10 * v102) >> 3) + a5;
        unint64_t v37 = v36 & 0xFFFFFFFFFFFFFFFCLL;
        uint64_t v38 = 8 * (v36 & 3);
        int v39 = *(_DWORD *)(v36 & 0xFFFFFFFFFFFFFFFCLL) >> v38;
        if ((unint64_t)(v38 + v105) >= 0x21) {
          v39 |= *(_DWORD *)(v37 + 4) << -(char)v38;
        }
        unsigned int v29 = v39 & v100;
        if (v10) {
          break;
        }
        unsigned int v106 = 0;
        if (!v98)
        {
LABEL_32:
          int v44 = *v94 >> v89;
          if (v88 >= 0x21) {
            v44 |= v94[1] << v85;
          }
          uint64_t v45 = ((v97 + v10 * v102) >> 3) + a5;
          unint64_t v46 = v45 & 0xFFFFFFFFFFFFFFFCLL;
          unint64_t v47 = v96 & 0xFFFFFFFFFFFFFFE7 | (8 * (v45 & 3));
          int v48 = *(_DWORD *)(v45 & 0xFFFFFFFFFFFFFFFCLL) >> v47;
          if (v47 + v95 >= 0x21) {
            v48 |= *(_DWORD *)(v46 + 4) << -(char)v47;
          }
          if (v10)
          {
            uint64_t v49 = ((v97 + (v10 - 1) * v102) >> 3) + a5;
            unint64_t v50 = v49 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v51 = v96 & 0xFFFFFFFFFFFFFFE7 | (8 * (v49 & 3));
            int v52 = *(_DWORD *)(v49 & 0xFFFFFFFFFFFFFFFCLL) >> v51;
            if (v51 + v95 >= 0x21) {
              v52 |= *(_DWORD *)(v50 + 4) << -(char)v51;
            }
            uint64_t v53 = v52 & v86;
            unsigned int v54 = v86;
          }
          else
          {
            uint64_t v53 = 0;
            unsigned int v54 = v86;
          }
          v112[0] = MEMORY[0x1E4F143A8];
          v112[1] = 0x40000000;
          v112[2] = sub_19E52EDA4;
          v112[3] = &unk_1E59A1F00;
          int v113 = v105;
          unsigned int v114 = v106;
          unsigned int v115 = v29;
          unsigned int v116 = a3;
          unsigned int v117 = v22;
          v112[4] = a10;
          v112[5] = v30;
          uint64_t result = sub_19E52E698(v92, a2, v107, v91, v90, v44 & v54, v53, v48 & v54, a9, v112);
          a3 = v107;
        }
LABEL_44:
        unsigned int v104 = v10;
        if (v106 < v29)
        {
          unsigned int v55 = v106;
          unsigned int v56 = a3 + v87 * v106;
          float v57 = 0.0;
          unsigned int v58 = v56;
          do
          {
            uint64_t v63 = (v58 >> 3) + v30;
            unint64_t v64 = v63 & 0xFFFFFFFFFFFFFFFCLL;
            unint64_t v65 = v35 & 0xFFFFFFFFFFFFFFE7 | (8 * (v63 & 3));
            unsigned int v66 = *(_DWORD *)(v63 & 0xFFFFFFFFFFFFFFFCLL) >> v65;
            if (v65 >= 9) {
              v66 |= *(_DWORD *)(v64 + 4) << -(char)v65;
            }
            int v59 = (v66 >> 22) & 3;
            float v60 = (float)(v66 & 0x3FFFFF);
            float v61 = v60 * 0.0078125;
            float v62 = v60 * 0.000061035;
            if (!v59) {
              float v60 = v60 * 0.00000095367;
            }
            if (v59 == 1) {
              float v60 = v62;
            }
            if (v59 == 2) {
              float v60 = v61;
            }
            float v57 = v60 + v57;
            ++v55;
            v58 += v22;
          }
          while (v29 != v55);
          if (v57 < a9)
          {
            unsigned int v67 = v106;
            do
            {
              unsigned int v68 = v67 * v22;
              if (a3)
              {
                uint64_t v69 = (v68 >> 3) + v30;
                unint64_t v70 = v69 & 0xFFFFFFFFFFFFFFFCLL;
                uint64_t v71 = 8 * (v69 & 3);
                int v72 = *(_DWORD *)(v69 & 0xFFFFFFFFFFFFFFFCLL) >> v71;
                if ((unint64_t)(v71 + v109) >= 0x21) {
                  v72 |= *(_DWORD *)(v70 + 4) << -(char)v71;
                }
                uint64_t v73 = v72 & v108;
              }
              else
              {
                uint64_t v73 = 0;
              }
              unint64_t v74 = (unint64_t)(v68 + a3) >> 3;
              int v75 = (_DWORD *)((v74 + v30) & 0xFFFFFFFFFFFFFFFCLL);
              unint64_t v76 = v35 & 0xFFFFFFFFFFFFFFE7 | (8 * ((v74 + v30) & 3));
              unsigned int v77 = *v75 >> v76;
              if (v76 >= 9) {
                v77 |= v75[1] << -(char)v76;
              }
              unsigned int v78 = (v56 >> 3) + 1;
              float v79 = (float)(v77 & 0x3FFFFF);
              int v80 = (v77 >> 22) & 3;
              float v81 = v79 * 0.0078125;
              float v82 = v79 * 0.000061035;
              if (!v80) {
                float v79 = v79 * 0.00000095367;
              }
              if (v80 == 1) {
                float v79 = v82;
              }
              if (v80 == 2) {
                float v79 = v81;
              }
              *(unsigned char *)(v30 + v74) &= v111;
              unsigned int v83 = v110;
              do
              {
                if (v83 >= 8) {
                  int v84 = 8;
                }
                else {
                  int v84 = v83;
                }
                *(unsigned char *)(v30 + v78++) &= -256 >> (8 - v84);
                v83 -= v84;
              }
              while (v83);
              if (v79 > 0.0)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a10 + 16))(a10, v73);
                a3 = v107;
              }
              ++v67;
              v56 += v22;
            }
            while (v67 != v29);
          }
        }
        unsigned int v10 = v104 + 1;
        int v12 = v99;
        if (v104 + 1 == a8) {
          return result;
        }
      }
      uint64_t v40 = ((v12 + (v10 - 1) * v102) >> 3) + a5;
      unint64_t v41 = v40 & 0xFFFFFFFFFFFFFFFCLL;
      uint64_t v42 = 8 * (v40 & 3);
      int v43 = *(_DWORD *)(v40 & 0xFFFFFFFFFFFFFFFCLL) >> v42;
      if ((unint64_t)(v42 + v105) >= 0x21) {
        v43 |= *(_DWORD *)(v41 + 4) << -(char)v42;
      }
      unsigned int v106 = v43 & v100;
LABEL_31:
      if (!v98) {
        goto LABEL_32;
      }
      goto LABEL_44;
    }
  }
  return result;
}

uint64_t sub_19E52EDA4(uint64_t a1, unsigned int a2, float a3)
{
  if (*(_DWORD *)(a1 + 48))
  {
    unsigned int v6 = *(_DWORD *)(a1 + 52);
    unsigned int v7 = *(_DWORD *)(a1 + 56);
    if (v6 < v7)
    {
      uint64_t v8 = *(void *)(a1 + 40);
      unsigned int v9 = *(_DWORD *)(a1 + 60);
      unsigned int v28 = 0;
      if (sub_19E529864(v8, v6, v7, (v9 + 31) & 0xFFFFFFF8, v9, a2, &v28))
      {
        uint64_t v10 = *(void *)(a1 + 40);
        unint64_t v11 = *(_DWORD *)(a1 + 60) + *(_DWORD *)(a1 + 64) * v28;
        unint64_t v12 = v11 >> 3;
        uint64_t v13 = (_DWORD *)(((v11 >> 3) + v10) & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v15 = v11 & 7 | (8 * (((v11 >> 3) + (_BYTE)v10) & 3));
        unsigned int v16 = *v13 >> v15;
        if (v15 >= 9) {
          v16 |= v13[1] << -(char)v15;
        }
        int v17 = (v16 >> 22) & 3;
        float v18 = (float)(v16 & 0x3FFFFF);
        float v19 = v18 * 0.0078125;
        float v20 = v18 * 0.000061035;
        if (!v17) {
          float v18 = v18 * 0.00000095367;
        }
        if (v17 == 1) {
          float v18 = v20;
        }
        if (v17 == 2) {
          float v18 = v19;
        }
        float v21 = v18 - a3;
        if (v21 >= 4194300.0)
        {
          int v22 = 12582912;
          unsigned int v23 = 0x3FFFFF;
        }
        else if (v21 >= 32768.0)
        {
          unsigned int v23 = (int)v21;
          int v22 = 12582912;
        }
        else if (v21 >= 256.0)
        {
          unsigned int v23 = vcvts_n_s32_f32(v21, 7uLL);
          int v22 = 0x800000;
        }
        else if (v21 >= 4.0)
        {
          unsigned int v23 = vcvts_n_s32_f32(v21, 0xEuLL);
          int v22 = 0x400000;
        }
        else
        {
          int v22 = 0;
          if (v21 <= 0.0) {
            unsigned int v23 = 0;
          }
          else {
            unsigned int v23 = vcvts_n_s32_f32(v21, 0x14uLL);
          }
        }
        if (v23 >= 0x3FFFFF) {
          unsigned int v23 = 0x3FFFFF;
        }
        char v14 = (*(unsigned char *)(a1 + 60) + *(unsigned char *)(a1 + 64) * v28) & 7;
        *(unsigned char *)(v10 + v12) = ((v23 & (0xFFu >> v14)) << v14) | *(unsigned char *)(v10 + v12) & ~(0xFFu >> v14 << v14);
        unsigned int v24 = (v11 | 0xFFFFFFF8) + 24;
        unsigned int v25 = v12 + 1;
        do
        {
          if (v24 >= 8) {
            int v26 = 8;
          }
          else {
            int v26 = v24;
          }
          *(unsigned char *)(v10 + v25) = (-256 >> (8 - v26)) & *(unsigned char *)(v10 + v25) | (0xFFu >> (8 - v26)) & ((v23 | v22) >> (24 - v24));
          ++v25;
          v24 -= v26;
        }
        while (v24);
      }
    }
  }
  return (*(uint64_t (**)(float))(*(void *)(a1 + 32) + 16))(a3);
}

uint64_t sub_19E52EFD0(unint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unint64_t v6 = a1 & 0xFFFFFFFFFFFFFFFCLL;
  unint64_t v7 = 8 * (a1 & 3);
  int v8 = *(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v7;
  if (v7 >= 9) {
    int v8 = (*(_DWORD *)(v6 + 4) << (-8 * (a1 & 3))) | (*(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> (8 * (a1 & 3)));
  }
  unsigned int v9 = 4 * (v8 & 0xFFFFFF);
  unsigned int v10 = ((6 * a2 + 4) >> 3) + 3;
  if (v9 < v10) {
    return 0;
  }
  int v95 = *(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v7;
  unint64_t v11 = a1 + v10;
  unint64_t v12 = sub_19E52F5BC(a1, a2, a3, 0, v11, 1u);
  uint64_t result = 0;
  unint64_t v96 = v12;
  if (v11 <= v12 && v12 <= a1 + v9)
  {
    unsigned int v15 = (v12 - a1 + 3) & 0xFFFFFFFC;
    if (v9 < v15 || v15 < v10) {
      return 0;
    }
    int v94 = 0;
    unint64_t v93 = a1 + 3;
    int v87 = (v3 + 31) & 0xFFFFFFF8;
    if (a2 <= 1) {
      int v17 = 1;
    }
    else {
      int v17 = a2;
    }
    int v85 = v17 - 1;
    unsigned int v18 = 1;
    unint64_t v89 = v6;
    while (1)
    {
      int v19 = v95;
      if (v7 >= 9) {
        int v19 = (*(_DWORD *)(v6 + 4) << (32 - v7)) | v95;
      }
      if (v94) {
        unsigned int v20 = 24;
      }
      else {
        unsigned int v20 = 0;
      }
      int v21 = 6 * v94;
      unint64_t v22 = (((3 * v94) >> 2) & 0x1FFFFFFF) + v93;
      int v23 = *(_DWORD *)(v22 & 0xFFFFFFFFFFFFFFFCLL) >> ((6 * v94) & 6 | (8 * (v22 & 3)));
      uint64_t v24 = v3;
      if (v94 + 1 >= a2)
      {
        int v30 = 0;
      }
      else
      {
        char v25 = v21 + 3;
        unint64_t v26 = ((v21 + 3) >> 3) + v93;
        int v27 = (_DWORD *)(v26 & 0xFFFFFFFFFFFFFFFCLL);
        unint64_t v28 = v25 & 7 | (8 * (v26 & 3));
        int v29 = *v27 >> v28;
        if (v28 >= 0x1E) {
          v29 |= v27[1] << -(char)v28;
        }
        int v30 = 4 * (v29 & 7);
      }
      unsigned int v31 = 4 * (v19 & 0xFFFFFF);
      char v92 = 4 * v23;
      uint64_t v32 = (4 * v23) & 0x1C;
      unsigned int v97 = v30;
      int v90 = v32 + v20;
      int v33 = (((4 * (_BYTE)v23) & 0x1C) + (_BYTE)v20 + (_BYTE)v30 + 7) & 0xF8;
      unint64_t v34 = sub_19E52F5BC(a1, a2, v24, v94, v11, v18);
      unsigned int v35 = v18 - 1;
      unint64_t v36 = ((v33 * (v18 - 1) + v20) >> 3) + v11;
      unint64_t v37 = (_DWORD *)(v36 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v38 = 8 * (v36 & 3);
      unint64_t v39 = a1 + v31;
      uint64_t v40 = 2;
      if ((unint64_t)(v38 + v32) > 0x20) {
        uint64_t v40 = 1;
      }
      unint64_t v41 = &v37[v40];
      if ((unint64_t)v37 < a1 || (unint64_t)v41 > v39) {
        return 0;
      }
      unint64_t v43 = v34;
      if (v32)
      {
        int v44 = *v37 >> v38;
        uint64_t v3 = v24;
        if ((unint64_t)(v38 + v32) >= 0x21) {
          v44 |= v37[1] << -(char)v38;
        }
        unsigned int v45 = v44 & (0xFFFFFFFF >> -(char)v32);
      }
      else
      {
        unsigned int v45 = 0;
        uint64_t v3 = v24;
      }
      unint64_t v6 = v89;
      uint64_t result = 0;
      if (v39 < v96) {
        return result;
      }
      if (v43 != v96) {
        return result;
      }
      int v88 = v33 * (v18 - 1);
      unint64_t v86 = v11 + ((v33 * v18) >> 3) + ((v45 * v87) >> 3);
      if (v86 > v96) {
        return result;
      }
      if (v18 >= 2) {
        break;
      }
LABEL_82:
      if (v94 == v85) {
        return 1;
      }
      uint64_t v76 = v92 & 4;
      unint64_t v77 = ((v88 + v90) >> 3) + v11;
      unsigned int v78 = (_DWORD *)(v77 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v79 = 8 * (v77 & 3);
      if (v79 + (unint64_t)(v97 + v76) <= 0x20) {
        uint64_t v80 = 2;
      }
      else {
        uint64_t v80 = 1;
      }
      float v81 = &v78[v80];
      if ((unint64_t)v78 < a1 || (unint64_t)v81 > v39) {
        return 0;
      }
      if (!v97) {
        return 1;
      }
      uint64_t v83 = v79 | v76;
      int v84 = *v78 >> v83;
      if (v83 + (unint64_t)v97 >= 0x21) {
        v84 |= v78[1] << -(char)v83;
      }
      uint64_t result = 1;
      unint64_t v11 = v86;
      ++v94;
      unsigned int v18 = v84 & (0xFFFFFFFF >> -(char)v97);
      if (!v18) {
        return result;
      }
    }
    uint64_t v46 = v92 & 4;
    uint64_t v47 = v97 + v46;
    unsigned int v91 = 0xFFFFFFFF >> -(char)v32;
    unsigned int v48 = 0xFFFFFFFF >> -(char)v97;
    while (1)
    {
      unint64_t v49 = (v20 >> 3) + v11;
      unint64_t v50 = (_DWORD *)(v49 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v51 = 8 * (v49 & 3);
      if ((unint64_t)(v51 + v32) <= 0x20) {
        uint64_t v52 = 2;
      }
      else {
        uint64_t v52 = 1;
      }
      uint64_t v53 = &v50[v52];
      uint64_t result = 0;
      if ((unint64_t)v50 < a1 || (unint64_t)v53 > v39) {
        return result;
      }
      unint64_t v55 = ((v33 + v20) >> 3) + v11;
      unsigned int v56 = (_DWORD *)(v55 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v57 = 8 * (v55 & 3);
      uint64_t v58 = (unint64_t)(v57 + v32) <= 0x20 ? 8 : 4;
      if ((unint64_t)v56 < a1 || (unint64_t)v56 + v58 > v39) {
        return result;
      }
      uint64_t result = 0;
      unint64_t v59 = ((v32 + v20) >> 3) + v11;
      float v60 = (_DWORD *)(v59 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v61 = 8 * (v59 & 3);
      uint64_t v62 = (unint64_t)(v61 + v47) <= 0x20 ? 8 : 4;
      if ((unint64_t)v60 < a1 || (unint64_t)v60 + v62 > v39) {
        return result;
      }
      uint64_t result = 0;
      unint64_t v63 = ((v32 + v33 + v20) >> 3) + v11;
      unint64_t v64 = (_DWORD *)(v63 & 0xFFFFFFFFFFFFFFFCLL);
      uint64_t v65 = 8 * (v63 & 3);
      uint64_t v66 = (unint64_t)(v65 + v47) <= 0x20 ? 8 : 4;
      if ((unint64_t)v64 < a1 || (unint64_t)v64 + v66 > v39) {
        return result;
      }
      if (v32)
      {
        int v67 = *v50 >> v51;
        if ((unint64_t)(v51 + v32) >= 0x21) {
          v67 |= v50[1] << -(char)v51;
        }
        int v68 = *v56 >> v57;
        if ((unint64_t)(v57 + v32) >= 0x21) {
          v68 |= v56[1] << -(char)v57;
        }
        unsigned int v69 = v67 & v91;
        unsigned int v70 = v68 & v91;
        if (!v97)
        {
LABEL_78:
          unsigned int v74 = 0;
          unsigned int v75 = 0;
          goto LABEL_79;
        }
      }
      else
      {
        unsigned int v69 = 0;
        unsigned int v70 = 0;
        if (!v97) {
          goto LABEL_78;
        }
      }
      uint64_t v71 = v61 | v46;
      int v72 = *v60 >> v71;
      if (v71 + (unint64_t)v97 >= 0x21) {
        v72 |= v60[1] << -(char)v71;
      }
      int v73 = *v64 >> (v65 | v46);
      if ((v65 | v46) + (unint64_t)v97 >= 0x21) {
        v73 |= v64[1] << -(v65 | v46);
      }
      unsigned int v74 = v72 & v48;
      unsigned int v75 = v73 & v48;
LABEL_79:
      uint64_t result = 0;
      if (v69 > v70 || v74 > v75) {
        return result;
      }
      v20 += v33;
      if (!--v35) {
        goto LABEL_82;
      }
    }
  }
  return result;
}

unint64_t sub_19E52F5BC(unint64_t a1, unsigned int a2, int a3, int a4, unint64_t a5, unsigned int a6)
{
  unint64_t v6 = 8 * (a1 & 3);
  unint64_t v7 = a1 + 3;
  unsigned int v8 = a4 + 1;
  unsigned int v9 = 6 * a4;
  while (1)
  {
    int v10 = *(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v6;
    if (v6 >= 9) {
      int v10 = (*(_DWORD *)((a1 & 0xFFFFFFFFFFFFFFFCLL) + 4) << (32 - v6)) | (*(_DWORD *)(a1 & 0xFFFFFFFFFFFFFFFCLL) >> v6);
    }
    if (v8 == 1) {
      int v11 = 0;
    }
    else {
      int v11 = 24;
    }
    if (v8 < a2)
    {
      uint64_t v13 = (_DWORD *)((((v9 + 3) >> 3) + v7) & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v14 = (v9 + 3) & 7 | (8 * ((((v9 + 3) >> 3) + v7) & 3));
      int v15 = *v13 >> v14;
      if (v14 >= 0x1E) {
        v15 |= v13[1] << -(char)v14;
      }
      unsigned int v12 = 4 * (v15 & 7);
    }
    else
    {
      unsigned int v12 = 0;
    }
    char v16 = 4 * (*(_DWORD *)(((v9 >> 3) + v7) & 0xFFFFFFFFFFFFFFFCLL) >> (v9 & 6 | (8 * (((v9 >> 3) + v7) & 3))));
    int v17 = (v16 & 0x1C) + v11;
    int v18 = ((v16 & 0x1C) + (_BYTE)v11 + (_BYTE)v12 + 7) & 0xF8;
    int v19 = v18 * (a6 - 1);
    unint64_t v20 = ((v19 + v11) >> 3) + a5;
    int v21 = (_DWORD *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v22 = 8 * (v20 & 3);
    unint64_t v23 = v22 + (v16 & 0x1C);
    unint64_t v24 = a1 + 4 * (v10 & 0xFFFFFFu);
    if (v23 <= 0x20) {
      uint64_t v25 = 2;
    }
    else {
      uint64_t v25 = 1;
    }
    unint64_t v26 = &v21[v25];
    if ((unint64_t)v21 < a1 || (unint64_t)v26 > v24) {
      return 0;
    }
    if ((v16 & 0x1C) != 0)
    {
      int v28 = *v21 >> v22;
      if (v23 >= 0x21) {
        v28 |= v21[1] << -(char)v22;
      }
      unsigned int v29 = v28 & (0xFFFFFFFF >> -(v16 & 0x1C));
    }
    else
    {
      unsigned int v29 = 0;
    }
    unint64_t v30 = a5 + ((v29 * ((a3 + 31) & 0xFFFFFFF8)) >> 3) + ((v18 * a6) >> 3);
    BOOL v31 = v30 < a5 || v30 > v24;
    BOOL v32 = v31;
    if (v8 >= a2 || v32) {
      break;
    }
    uint64_t v33 = (4
         * (*(_DWORD *)(((v9 >> 3) + v7) & 0xFFFFFFFFFFFFFFFCLL) >> (v9 & 6 | (8
                                                                                              * (((v9 >> 3) + v7) & 3))))) & 4;
    unint64_t v34 = ((v19 + v17) >> 3) + a5;
    unsigned int v35 = (_DWORD *)(v34 & 0xFFFFFFFFFFFFFFFCLL);
    uint64_t v36 = 8 * (v34 & 3);
    if ((unint64_t)v12 + v33 + v36 <= 0x20) {
      uint64_t v37 = 2;
    }
    else {
      uint64_t v37 = 1;
    }
    uint64_t v38 = &v35[v37];
    if ((unint64_t)v35 < a1 || (unint64_t)v38 > v24) {
      return 0;
    }
    a5 = v30;
    if (v12)
    {
      int v40 = *v35 >> (v36 | v33);
      if ((v36 | v33) + (unint64_t)v12 >= 0x21) {
        v40 |= v35[1] << -(v36 | v33);
      }
      ++v8;
      v9 += 6;
      a6 = v40 & (0xFFFFFFFF >> -(char)v12);
      if (a6) {
        continue;
      }
    }
    return a5;
  }
  if (v32) {
    return 0;
  }
  else {
    return v30;
  }
}

uint64_t sub_19E52F830(uint64_t result, char *a2, uint64_t a3, char a4)
{
  unsigned int v9 = (unsigned int *)result;
LABEL_2:
  int v10 = (unsigned int *)(a2 - 8);
  int v11 = a2 - 4;
  unsigned int v12 = v9;
  while (1)
  {
    unsigned int v9 = v12;
    uint64_t v13 = a2 - (char *)v12;
    uint64_t v14 = (a2 - (char *)v12) >> 3;
    if (v5 || !v4)
    {
      switch(v14)
      {
        case 0:
        case 1:
          return result;
        case 2:
          int v102 = *v12;
          if (*v10 < *v12)
          {
            *unsigned int v12 = *v10;
            *int v10 = v102;
            unsigned int v103 = v12[1];
            v12[1] = *(_DWORD *)v11;
            *(_DWORD *)int v11 = v103;
          }
          return result;
        case 3:
          unsigned int v104 = v12[2];
          unsigned int v105 = *v12;
          unsigned int v106 = *v10;
          if (v104 >= *v12)
          {
            if (v106 >= v104) {
              return result;
            }
            v12[2] = v106;
            *int v10 = v104;
            unsigned int v142 = v12[3];
            v12[3] = *(_DWORD *)v11;
            *(_DWORD *)int v11 = v142;
            unsigned int v143 = v12[2];
            unsigned int v144 = *v12;
            if (v143 >= *v12) {
              return result;
            }
            *unsigned int v12 = v143;
            v12[2] = v144;
            unsigned int v107 = (int *)(v12 + 1);
            int v11 = (char *)(v12 + 3);
          }
          else
          {
            if (v106 >= v104)
            {
              unsigned int v107 = (int *)(v12 + 3);
              unsigned int v167 = v12[3];
              unsigned int v168 = v12[1];
              *unsigned int v12 = v104;
              v12[1] = v167;
              v12[2] = v105;
              v12[3] = v168;
              if (*v10 >= v105) {
                return result;
              }
              v12[2] = *v10;
            }
            else
            {
              unsigned int v107 = (int *)(v12 + 1);
              *unsigned int v12 = v106;
            }
            *int v10 = v105;
          }
          int v169 = *v107;
          int *v107 = *(_DWORD *)v11;
          *(_DWORD *)int v11 = v169;
          return result;
        case 4:
          return (uint64_t)sub_19E530390((int *)v12, v12 + 2, v12 + 4, (unsigned int *)a2 - 2);
        case 5:
          uint64_t result = (uint64_t)sub_19E530390((int *)v12, v12 + 2, v12 + 4, v12 + 6);
          unsigned int v108 = v12[6];
          if (*v10 < v108)
          {
            v12[6] = *v10;
            *int v10 = v108;
            unsigned int v109 = v12[7];
            v12[7] = *(_DWORD *)v11;
            *(_DWORD *)int v11 = v109;
            unsigned int v110 = v12[6];
            unsigned int v111 = v12[4];
            if (v110 < v111)
            {
              unsigned int v112 = v12[5];
              unsigned int v113 = v12[7];
              v12[4] = v110;
              void v12[5] = v113;
              v12[6] = v111;
              v12[7] = v112;
              unsigned int v114 = v12[2];
              if (v110 < v114)
              {
                unsigned int v115 = v12[3];
                v12[2] = v110;
                v12[3] = v113;
                v12[4] = v114;
                void v12[5] = v115;
                int v116 = *v12;
                if (v110 < *v12)
                {
                  unsigned int v117 = v12[1];
                  *unsigned int v12 = v110;
                  v12[1] = v113;
                  v12[2] = v116;
                  v12[3] = v117;
                }
              }
            }
          }
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v13 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v12 != (unsigned int *)a2)
      {
        int64_t v131 = (unint64_t)(v14 - 2) >> 1;
        int64_t v132 = v131;
        do
        {
          if (v131 >= v132)
          {
            uint64_t v134 = (2 * v132) | 1;
            unsigned int v135 = &v12[2 * v134];
            if (2 * v132 + 2 < v14)
            {
              unsigned int v137 = *v135;
              unsigned int v136 = v135[2];
              if (*v135 <= v136) {
                unsigned int v137 = v135[2];
              }
              if (*v135 < v136)
              {
                v135 += 2;
                uint64_t v134 = 2 * v132 + 2;
              }
            }
            else
            {
              unsigned int v137 = *v135;
            }
            unsigned int v138 = &v12[2 * v132];
            if (v137 >= *v138)
            {
              unsigned int v139 = *v138;
              unsigned int v140 = v138[1];
              while (1)
              {
                uint64_t result = (uint64_t)v138;
                unsigned int v138 = v135;
                *(_DWORD *)uint64_t result = v137;
                *(_DWORD *)(result + 4) = v135[1];
                if (v131 < v134) {
                  break;
                }
                uint64_t result = (2 * v134) | 1;
                unsigned int v135 = &v12[2 * result];
                uint64_t v134 = 2 * v134 + 2;
                if (v134 < v14)
                {
                  unsigned int v137 = *v135;
                  unsigned int v141 = v135[2];
                  if (*v135 <= v141) {
                    unsigned int v137 = v135[2];
                  }
                  if (*v135 >= v141) {
                    uint64_t v134 = result;
                  }
                  else {
                    v135 += 2;
                  }
                  if (v137 < v139) {
                    break;
                  }
                }
                else
                {
                  unsigned int v137 = *v135;
                  uint64_t v134 = result;
                  if (*v135 < v139) {
                    break;
                  }
                }
              }
              *unsigned int v138 = v139;
              v138[1] = v140;
            }
          }
          BOOL v133 = v132-- <= 0;
        }
        while (!v133);
        uint64_t v152 = (unint64_t)v13 >> 3;
        do
        {
          uint64_t v153 = 0;
          uint64_t v154 = *(void *)v12;
          int v155 = v12;
          do
          {
            unsigned int v158 = (char *)&v155[2 * v153 + 2];
            uint64_t v159 = (2 * v153) | 1;
            uint64_t v153 = 2 * v153 + 2;
            if (v153 < v152)
            {
              unsigned int v156 = *(_DWORD *)v158;
              unsigned int v157 = *((_DWORD *)v158 + 2);
              if (*(_DWORD *)v158 <= v157) {
                unsigned int v156 = *((_DWORD *)v158 + 2);
              }
              if (*(_DWORD *)v158 >= v157) {
                uint64_t v153 = v159;
              }
              else {
                v158 += 8;
              }
            }
            else
            {
              unsigned int v156 = *(_DWORD *)v158;
              uint64_t v153 = v159;
            }
            *int v155 = v156;
            v155[1] = *((_DWORD *)v158 + 1);
            int v155 = v158;
          }
          while (v153 <= (uint64_t)((unint64_t)(v152 - 2) >> 1));
          if (v158 == a2 - 8)
          {
            *(void *)unsigned int v158 = v154;
          }
          else
          {
            *(_DWORD *)unsigned int v158 = *((_DWORD *)a2 - 2);
            *((_DWORD *)v158 + 1) = *((_DWORD *)a2 - 1);
            *((void *)a2 - 1) = v154;
            uint64_t v160 = v158 - (char *)v12 + 8;
            if (v160 >= 9)
            {
              unint64_t v161 = (((unint64_t)v160 >> 3) - 2) >> 1;
              uint64_t v162 = (char *)&v12[2 * v161];
              int v163 = *(_DWORD *)v162;
              if (*(_DWORD *)v162 < *(_DWORD *)v158)
              {
                unsigned int v164 = *(_DWORD *)v158;
                int v165 = *((_DWORD *)v158 + 1);
                do
                {
                  unsigned int v166 = v158;
                  unsigned int v158 = v162;
                  *(_DWORD *)unsigned int v166 = v163;
                  *((_DWORD *)v166 + 1) = *((_DWORD *)v162 + 1);
                  if (!v161) {
                    break;
                  }
                  unint64_t v161 = (v161 - 1) >> 1;
                  uint64_t v162 = (char *)&v12[2 * v161];
                  int v163 = *(_DWORD *)v162;
                }
                while (*(_DWORD *)v162 < v164);
                *(_DWORD *)unsigned int v158 = v164;
                *((_DWORD *)v158 + 1) = v165;
              }
            }
          }
          a2 -= 8;
          BOOL v133 = v152-- <= 2;
        }
        while (!v133);
      }
      return result;
    }
    unint64_t v15 = (unint64_t)v14 >> 1;
    char v16 = &v12[2 * ((unint64_t)v14 >> 1)];
    unsigned int v17 = *v10;
    if ((unint64_t)v13 >= 0x401)
    {
      unsigned int v18 = *v16;
      unsigned int v19 = *v12;
      if (*v16 >= *v12)
      {
        if (v17 < v18)
        {
          *char v16 = v17;
          *int v10 = v18;
          unint64_t v24 = &v12[2 * v15];
          unsigned int v26 = v24[1];
          uint64_t v25 = (char *)(v24 + 1);
          *(_DWORD *)uint64_t v25 = *(_DWORD *)v11;
          *(_DWORD *)int v11 = v26;
          int v27 = *v12;
          if (*v16 < *v12)
          {
            *unsigned int v12 = *v16;
            unint64_t v20 = v12 + 1;
            *char v16 = v27;
            goto LABEL_23;
          }
        }
      }
      else
      {
        if (v17 < v18)
        {
          unint64_t v20 = v12 + 1;
          *unsigned int v12 = v17;
          goto LABEL_22;
        }
        *unsigned int v12 = v18;
        *char v16 = v19;
        unsigned int v31 = v12[1];
        unint64_t v20 = &v12[2 * v15 + 1];
        v12[1] = *v20;
        *unint64_t v20 = v31;
        if (*v10 < v19)
        {
          *char v16 = *v10;
LABEL_22:
          *int v10 = v19;
          uint64_t v25 = a2 - 4;
LABEL_23:
          unsigned int v32 = *v20;
          *unint64_t v20 = *(_DWORD *)v25;
          *(_DWORD *)uint64_t v25 = v32;
        }
      }
      unint64_t v33 = v15 - 1;
      unint64_t v34 = &v12[2 * v15 - 2];
      unsigned int v35 = *v34;
      unsigned int v36 = v12[2];
      unsigned int v37 = *((_DWORD *)a2 - 4);
      if (*v34 >= v36)
      {
        if (v37 < v35)
        {
          *unint64_t v34 = v37;
          *((_DWORD *)a2 - 4) = v35;
          unint64_t v39 = &v12[2 * v33];
          unsigned int v41 = v39[1];
          int v40 = (char *)(v39 + 1);
          *(_DWORD *)int v40 = *((_DWORD *)a2 - 3);
          *((_DWORD *)a2 - 3) = v41;
          unsigned int v42 = v12[2];
          if (*v34 < v42)
          {
            v12[2] = *v34;
            *unint64_t v34 = v42;
            uint64_t v38 = v12 + 3;
            goto LABEL_36;
          }
        }
      }
      else
      {
        if (v37 < v35)
        {
          uint64_t v38 = v12 + 3;
          v12[2] = v37;
          goto LABEL_35;
        }
        unsigned int v45 = &v12[2 * v33];
        unsigned int v46 = v45[1];
        uint64_t v38 = v45 + 1;
        unsigned int v47 = v12[3];
        v12[2] = v35;
        v12[3] = v46;
        *unint64_t v34 = v36;
        *uint64_t v38 = v47;
        unsigned int v48 = *((_DWORD *)a2 - 4);
        if (v48 < v36)
        {
          *unint64_t v34 = v48;
LABEL_35:
          *((_DWORD *)a2 - 4) = v36;
          int v40 = a2 - 12;
LABEL_36:
          unsigned int v49 = *v38;
          *uint64_t v38 = *(_DWORD *)v40;
          *(_DWORD *)int v40 = v49;
        }
      }
      unint64_t v50 = v15 + 1;
      uint64_t v51 = &v12[2 * v15 + 2];
      unsigned int v52 = *v51;
      unsigned int v53 = v12[4];
      unsigned int v54 = *((_DWORD *)a2 - 6);
      if (*v51 >= v53)
      {
        if (v54 < v52)
        {
          *uint64_t v51 = v54;
          *((_DWORD *)a2 - 6) = v52;
          unsigned int v56 = &v12[2 * v50];
          unsigned int v58 = v56[1];
          uint64_t v57 = (char *)(v56 + 1);
          *(_DWORD *)uint64_t v57 = *((_DWORD *)a2 - 5);
          *((_DWORD *)a2 - 5) = v58;
          unsigned int v52 = *v51;
          unsigned int v59 = v12[4];
          if (*v51 < v59)
          {
            v12[4] = v52;
            *uint64_t v51 = v59;
            unint64_t v55 = (int *)(v12 + 5);
            goto LABEL_46;
          }
        }
      }
      else
      {
        if (v54 < v52)
        {
          unint64_t v55 = (int *)(v12 + 5);
          v12[4] = v54;
          goto LABEL_45;
        }
        float v60 = &v12[2 * v50];
        unsigned int v61 = v60[1];
        unint64_t v55 = (int *)(v60 + 1);
        uint64_t result = v12[5];
        v12[4] = v52;
        void v12[5] = v61;
        *uint64_t v51 = v53;
        *unint64_t v55 = result;
        unsigned int v62 = *((_DWORD *)a2 - 6);
        if (v62 >= v53)
        {
          unsigned int v52 = v53;
        }
        else
        {
          *uint64_t v51 = v62;
LABEL_45:
          *((_DWORD *)a2 - 6) = v53;
          uint64_t v57 = a2 - 20;
LABEL_46:
          int v63 = *v55;
          *unint64_t v55 = *(_DWORD *)v57;
          *(_DWORD *)uint64_t v57 = v63;
          unsigned int v52 = *v51;
        }
      }
      unsigned int v64 = *v16;
      unsigned int v65 = *v34;
      if (*v16 >= *v34)
      {
        if (v52 < v64)
        {
          *char v16 = v52;
          int v68 = &v12[2 * v15];
          unsigned int v69 = v68[1];
          int v67 = v68 + 1;
          uint64_t result = v69;
          *uint64_t v51 = v64;
          unsigned int v70 = &v12[2 * v50];
          unsigned int *v67 = v70[1];
          v70[1] = v69;
          if (v52 < v65)
          {
            *unint64_t v34 = v52;
            *char v16 = v65;
            uint64_t v66 = &v12[2 * v33 + 1];
            goto LABEL_55;
          }
          unsigned int v64 = v52;
        }
      }
      else
      {
        uint64_t v66 = &v12[2 * v33 + 1];
        if (v52 < v64)
        {
          *unint64_t v34 = v52;
          *uint64_t v51 = v65;
          int v67 = &v12[2 * v50 + 1];
          goto LABEL_55;
        }
        *unint64_t v34 = v64;
        *char v16 = v65;
        uint64_t v71 = &v12[2 * v15];
        unsigned int v73 = v71[1];
        int v72 = v71 + 1;
        unsigned int v74 = *v66;
        *uint64_t v66 = v73;
        unsigned int *v72 = v74;
        if (v52 >= v65)
        {
          unsigned int v64 = v65;
        }
        else
        {
          *char v16 = v52;
          *uint64_t v51 = v65;
          int v67 = &v12[2 * v50 + 1];
          uint64_t v66 = v72;
LABEL_55:
          unsigned int v75 = *v66;
          *uint64_t v66 = *v67;
          unsigned int *v67 = v75;
          unsigned int v64 = *v16;
        }
      }
      int v76 = *v12;
      *unsigned int v12 = v64;
      unint64_t v23 = v12 + 1;
      *char v16 = v76;
      unsigned int v29 = (char *)&v12[2 * v15 + 1];
      goto LABEL_57;
    }
    unsigned int v21 = *v12;
    unsigned int v22 = *v16;
    if (*v12 >= *v16)
    {
      if (v17 >= v21) {
        goto LABEL_58;
      }
      *unsigned int v12 = v17;
      *int v10 = v21;
      unsigned int v29 = (char *)(v12 + 1);
      unsigned int v28 = v12[1];
      v12[1] = *(_DWORD *)v11;
      *(_DWORD *)int v11 = v28;
      unsigned int v30 = *v16;
      if (*v12 >= *v16) {
        goto LABEL_58;
      }
      *char v16 = *v12;
      *unsigned int v12 = v30;
      unint64_t v23 = &v12[2 * v15 + 1];
    }
    else
    {
      unint64_t v23 = &v12[2 * v15 + 1];
      if (v17 >= v21)
      {
        *char v16 = v21;
        unsigned int v43 = v12[1];
        *unsigned int v12 = v22;
        unsigned int v44 = *v23;
        *unint64_t v23 = v43;
        v12[1] = v44;
        if (*v10 >= v22) {
          goto LABEL_58;
        }
        *unsigned int v12 = *v10;
        *int v10 = v22;
        unint64_t v23 = v12 + 1;
      }
      else
      {
        *char v16 = v17;
        *int v10 = v22;
      }
      unsigned int v29 = a2 - 4;
    }
LABEL_57:
    unsigned int v77 = *v23;
    *unint64_t v23 = *(_DWORD *)v29;
    *(_DWORD *)unsigned int v29 = v77;
LABEL_58:
    --a3;
    if ((a4 & 1) != 0 || *(v12 - 2) < *v12)
    {
      uint64_t v78 = *(void *)v12;
      uint64_t v79 = v12;
      do
      {
        uint64_t v80 = v79;
        unsigned int v82 = v79[2];
        v79 += 2;
        unsigned int v81 = v82;
      }
      while (v82 < v78);
      uint64_t v83 = a2;
      if (v80 == v12)
      {
        uint64_t v83 = a2;
        do
        {
          if (v79 >= (unsigned int *)v83) {
            break;
          }
          unsigned int v85 = *((_DWORD *)v83 - 2);
          v83 -= 8;
        }
        while (v85 >= v78);
      }
      else
      {
        do
        {
          unsigned int v84 = *((_DWORD *)v83 - 2);
          v83 -= 8;
        }
        while (v84 >= v78);
      }
      if (v79 < (unsigned int *)v83)
      {
        unsigned int v86 = *(_DWORD *)v83;
        unsigned int v12 = v79;
        int v87 = (unsigned int *)v83;
        do
        {
          *unsigned int v12 = v86;
          *int v87 = v81;
          unsigned int v88 = v12[1];
          v12[1] = v87[1];
          v87[1] = v88;
          do
          {
            unsigned int v89 = v12[2];
            v12 += 2;
            unsigned int v81 = v89;
          }
          while (v89 < v78);
          do
          {
            unsigned int v90 = *(v87 - 2);
            v87 -= 2;
            unsigned int v86 = v90;
          }
          while (v90 >= v78);
        }
        while (v12 < v87);
      }
      else
      {
        unsigned int v12 = v79;
      }
      if (v12 - 2 != v9)
      {
        *unsigned int v9 = *(v12 - 2);
        v9[1] = *(v12 - 1);
      }
      *((void *)v12 - 1) = v78;
      if (v79 < (unsigned int *)v83) {
        goto LABEL_80;
      }
      BOOL v91 = sub_19E5304C0(v9, (char *)v12 - 8);
      uint64_t result = sub_19E5304C0(v12, a2);
      if (result)
      {
        a2 = (char *)(v12 - 2);
        if (v91) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v91)
      {
LABEL_80:
        uint64_t result = sub_19E52F830(v9, v12 - 2, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v92 = *(void *)v12;
      if (*v10 > *(void *)v12)
      {
        do
        {
          unsigned int v93 = v12[2];
          v12 += 2;
        }
        while (v93 <= v92);
      }
      else
      {
        int v94 = v12 + 2;
        do
        {
          unsigned int v12 = v94;
          if (v94 >= (unsigned int *)a2) {
            break;
          }
          v94 += 2;
        }
        while (*v12 <= v92);
      }
      int v95 = (unsigned int *)a2;
      if (v12 < (unsigned int *)a2)
      {
        int v95 = (unsigned int *)a2;
        do
        {
          unsigned int v96 = *(v95 - 2);
          v95 -= 2;
        }
        while (v96 > v92);
      }
      if (v12 < v95)
      {
        int v97 = *v12;
        unsigned int v98 = *v95;
        do
        {
          *unsigned int v12 = v98;
          *int v95 = v97;
          unsigned int v99 = v12[1];
          v12[1] = v95[1];
          v95[1] = v99;
          do
          {
            unsigned int v100 = v12[2];
            v12 += 2;
            int v97 = v100;
          }
          while (v100 <= v92);
          do
          {
            unsigned int v101 = *(v95 - 2);
            v95 -= 2;
            unsigned int v98 = v101;
          }
          while (v101 > v92);
        }
        while (v12 < v95);
      }
      BOOL v4 = v12 - 2 >= v9;
      BOOL v5 = v12 - 2 == v9;
      if (v12 - 2 != v9)
      {
        *unsigned int v9 = *(v12 - 2);
        v9[1] = *(v12 - 1);
      }
      a4 = 0;
      *((void *)v12 - 1) = v92;
    }
  }
  unsigned int v118 = (char *)(v12 + 2);
  BOOL v120 = v12 == (unsigned int *)a2 || v118 == a2;
  if (a4)
  {
    if (!v120)
    {
      uint64_t v121 = 0;
      char v122 = v12;
      do
      {
        unsigned int v124 = v122[2];
        unsigned int v125 = *v122;
        char v122 = v118;
        if (v124 < v125)
        {
          unsigned int v127 = *(_DWORD *)v118;
          unsigned int v126 = *((_DWORD *)v118 + 1);
          uint64_t v128 = v121;
          do
          {
            uint64_t v129 = (char *)v12 + v128;
            int v130 = *(unsigned int *)((char *)v12 + v128 + 4);
            *((_DWORD *)v129 + 2) = v125;
            *((_DWORD *)v129 + 3) = v130;
            if (!v128)
            {
              uint64_t v123 = v12;
              goto LABEL_128;
            }
            unsigned int v125 = *((_DWORD *)v129 - 2);
            v128 -= 8;
          }
          while (v125 > v127);
          uint64_t v123 = (unsigned int *)((char *)v12 + v128 + 8);
LABEL_128:
          unsigned int *v123 = v127;
          v123[1] = v126;
        }
        unsigned int v118 = (char *)(v122 + 2);
        v121 += 8;
      }
      while (v122 + 2 != (_DWORD *)a2);
    }
  }
  else if (!v120)
  {
    unsigned int v145 = v12 + 3;
    do
    {
      unsigned int v146 = v9[2];
      unsigned int v147 = *v9;
      unsigned int v9 = (unsigned int *)v118;
      if (v146 < v147)
      {
        uint64_t v148 = *(void *)v118;
        unint64_t v149 = v145;
        do
        {
          unsigned int v150 = v149;
          *(v149 - 1) = v147;
          int v151 = *(v149 - 2);
          v149 -= 2;
          *unsigned int v150 = v151;
          unsigned int v147 = *(v150 - 5);
        }
        while (v147 > v148);
        *(void *)(v149 - 1) = v148;
      }
      unsigned int v118 = (char *)(v9 + 2);
      v145 += 2;
    }
    while (v9 + 2 != (unsigned int *)a2);
  }
  return result;
}

int *sub_19E530390(int *result, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *result;
  unsigned int v6 = *a3;
  if (*a2 >= *result)
  {
    if (v6 < v4)
    {
      *a2 = v6;
      *a3 = v4;
      unsigned int v9 = (int *)(a2 + 1);
      unsigned int v8 = a2[1];
      a2[1] = a3[1];
      a3[1] = v8;
      unsigned int v10 = *result;
      if (*a2 < *result)
      {
        void *result = *a2;
        unint64_t v7 = result + 1;
        *a2 = v10;
LABEL_10:
        int v12 = *v7;
        int *v7 = *v9;
        *unsigned int v9 = v12;
      }
    }
  }
  else
  {
    if (v6 < v4)
    {
      unint64_t v7 = result + 1;
      void *result = v6;
LABEL_9:
      *a3 = v5;
      unsigned int v9 = (int *)(a3 + 1);
      goto LABEL_10;
    }
    void *result = v4;
    *a2 = v5;
    unint64_t v7 = (int *)(a2 + 1);
    int v11 = result[1];
    result[1] = a2[1];
    a2[1] = v11;
    unsigned int v5 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      goto LABEL_9;
    }
  }
  unsigned int v13 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v13;
    unsigned int v14 = a3[1];
    a3[1] = a4[1];
    a4[1] = v14;
    unsigned int v15 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v15;
      unsigned int v16 = a2[1];
      a2[1] = a3[1];
      a3[1] = v16;
      unsigned int v17 = *result;
      if (*a2 < *result)
      {
        void *result = *a2;
        *a2 = v17;
        int v18 = result[1];
        result[1] = a2[1];
        a2[1] = v18;
      }
    }
  }
  return result;
}

BOOL sub_19E5304C0(unsigned int *a1, char *a2)
{
  uint64_t v4 = (a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *((_DWORD *)a2 - 2);
      int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *((_DWORD *)a2 - 2) = v7;
        unsigned int v8 = a1[1];
        a1[1] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v8;
      }
      return result;
    case 3:
      unsigned int v9 = a1[2];
      unsigned int v10 = *a1;
      unsigned int v11 = *((_DWORD *)a2 - 2);
      if (v9 < *a1)
      {
        if (v11 >= v9)
        {
          int v12 = (int *)(a1 + 3);
          unsigned int v36 = a1[3];
          unsigned int v37 = a1[1];
          *a1 = v9;
          a1[1] = v36;
          a1[2] = v10;
          a1[3] = v37;
          unsigned int v38 = *((_DWORD *)a2 - 2);
          if (v38 >= v10) {
            return result;
          }
          a1[2] = v38;
        }
        else
        {
          int v12 = (int *)(a1 + 1);
          *a1 = v11;
        }
        *((_DWORD *)a2 - 2) = v10;
        unsigned int v30 = a2 - 4;
        goto LABEL_25;
      }
      if (v11 < v9)
      {
        a1[2] = v11;
        *((_DWORD *)a2 - 2) = v9;
        unsigned int v30 = (char *)(a1 + 3);
        unsigned int v29 = a1[3];
        a1[3] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v29;
        unsigned int v31 = a1[2];
        int v32 = *a1;
        if (v31 < *a1)
        {
          *a1 = v31;
          a1[2] = v32;
          int v12 = (int *)(a1 + 1);
LABEL_25:
          int v39 = *v12;
          *int v12 = *(_DWORD *)v30;
          *(_DWORD *)unsigned int v30 = v39;
          return result;
        }
      }
      return result;
    case 4:
      sub_19E530390((int *)a1, a1 + 2, a1 + 4, (unsigned int *)a2 - 2);
      return 1;
    case 5:
      sub_19E530390((int *)a1, a1 + 2, a1 + 4, a1 + 6);
      unsigned int v18 = *((_DWORD *)a2 - 2);
      unsigned int v19 = a1[6];
      if (v18 < v19)
      {
        a1[6] = v18;
        *((_DWORD *)a2 - 2) = v19;
        unsigned int v20 = a1[7];
        a1[7] = *((_DWORD *)a2 - 1);
        *((_DWORD *)a2 - 1) = v20;
        unsigned int v21 = a1[6];
        unsigned int v22 = a1[4];
        if (v21 < v22)
        {
          unsigned int v23 = a1[5];
          unsigned int v24 = a1[7];
          a1[4] = v21;
          a1[5] = v24;
          a1[6] = v22;
          a1[7] = v23;
          unsigned int v25 = a1[2];
          if (v21 < v25)
          {
            unsigned int v26 = a1[3];
            a1[2] = v21;
            a1[3] = v24;
            a1[4] = v25;
            a1[5] = v26;
            int v27 = *a1;
            if (v21 < *a1)
            {
              unsigned int v28 = a1[1];
              *a1 = v21;
              a1[1] = v24;
              a1[2] = v27;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v13 = (char *)(a1 + 4);
      unsigned int v14 = a1[4];
      unsigned int v15 = a1[2];
      unsigned int v16 = *a1;
      if (v15 < *a1)
      {
        if (v14 >= v15)
        {
          unsigned int v17 = (int *)(a1 + 3);
          unsigned int v40 = a1[3];
          unsigned int v41 = a1[1];
          *a1 = v15;
          a1[1] = v40;
          a1[2] = v16;
          a1[3] = v41;
          if (v14 >= v16) {
            goto LABEL_30;
          }
          a1[2] = v14;
        }
        else
        {
          unsigned int v17 = (int *)(a1 + 1);
          *a1 = v14;
        }
        a1[4] = v16;
        unint64_t v34 = (int *)(a1 + 5);
        goto LABEL_29;
      }
      if (v14 < v15)
      {
        unint64_t v34 = (int *)(a1 + 3);
        unsigned int v33 = a1[3];
        unsigned int v35 = a1[5];
        a1[4] = v15;
        a1[5] = v33;
        a1[2] = v14;
        a1[3] = v35;
        if (v14 < v16)
        {
          *a1 = v14;
          a1[2] = v16;
          unsigned int v17 = (int *)(a1 + 1);
LABEL_29:
          int v42 = *v17;
          *unsigned int v17 = *v34;
          *unint64_t v34 = v42;
        }
      }
LABEL_30:
      unsigned int v43 = (char *)(a1 + 6);
      if (a1 + 6 == (unsigned int *)a2) {
        return 1;
      }
      uint64_t v44 = 0;
      int v45 = 0;
      while (1)
      {
        unsigned int v47 = *(_DWORD *)v13;
        if (*(_DWORD *)v43 < *(_DWORD *)v13)
        {
          unsigned int v49 = *(_DWORD *)v43;
          unsigned int v48 = *((_DWORD *)v43 + 1);
          uint64_t v50 = v44;
          do
          {
            uint64_t v51 = (unsigned int *)((char *)a1 + v50);
            int v52 = *(unsigned int *)((char *)a1 + v50 + 20);
            v51[6] = v47;
            v51[7] = v52;
            if (v50 == -16)
            {
              unsigned int v46 = a1;
              goto LABEL_33;
            }
            unsigned int v47 = v51[2];
            v50 -= 8;
          }
          while (v47 > v49);
          unsigned int v46 = (unsigned int *)((char *)a1 + v50 + 24);
LABEL_33:
          *unsigned int v46 = v49;
          v46[1] = v48;
          if (++v45 == 8) {
            return v43 + 8 == a2;
          }
        }
        unsigned int v13 = v43;
        v44 += 8;
        v43 += 8;
        if (v43 == a2) {
          return 1;
        }
      }
  }
}

uint64_t sub_19E5307F0(uint64_t a1)
{
  int v1 = a1 - 68;
  uint64_t result = 126;
  switch(v1)
  {
    case 0:
    case 2:
      return result;
    case 1:
    case 3:
      uint64_t result = 123;
      break;
    case 4:
    case 59:
    case 60:
      uint64_t result = a1;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

__n128 sub_19E530930(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void sub_19E530954(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_19E53096C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 8);
  double v4 = *(double *)(a2 + 16) + *(double *)(*(void *)(a1 + 40) + 104);
  unsigned int v6 = (double *)v3[6];
  unint64_t v5 = v3[7];
  if ((unint64_t)v6 >= v5)
  {
    unsigned int v8 = (double *)v3[5];
    uint64_t v9 = ((char *)v6 - (char *)v8) >> 4;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60) {
      sub_19E37C7C4();
    }
    uint64_t v11 = v5 - (void)v8;
    if (v11 >> 3 > v10) {
      unint64_t v10 = v11 >> 3;
    }
    BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    if (!v12) {
      unint64_t v13 = v10;
    }
    if (v13 >> 60) {
      sub_19E37C2B8();
    }
    uint64_t v14 = 16 * v13;
    unsigned int v15 = (char *)operator new(16 * v13);
    unsigned int v16 = (double *)&v15[16 * v9];
    *(_DWORD *)unsigned int v16 = *(_DWORD *)(a2 + 4);
    v16[1] = v4;
    int v7 = v16 + 2;
    if (v6 == v8)
    {
      unsigned int v17 = &v15[16 * v9];
    }
    else
    {
      do
      {
        unsigned int v17 = (char *)(v16 - 2);
        *((_OWORD *)v16 - 1) = *((_OWORD *)v6 - 1);
        v6 -= 2;
        v16 -= 2;
      }
      while (v6 != v8);
    }
    void v3[5] = v17;
    v3[6] = v7;
    v3[7] = &v15[v14];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(_DWORD *)unsigned int v6 = *(_DWORD *)(a2 + 4);
    v6[1] = v4;
    int v7 = v6 + 2;
  }
  v3[6] = v7;
}

uint64_t sub_19E530A8C(uint64_t *a1, uint64_t a2, const __CFString *cf, char a4)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    CFStringRef v7 = cf;
    CFRetain(cf);
    CFStringRef v129 = v7;
    if (a4) {
      goto LABEL_14;
    }
  }
  else
  {
    char v8 = *(unsigned char *)(a2 + 23);
    if (v8 >= 0) {
      uint64_t v9 = (const UInt8 *)a2;
    }
    else {
      uint64_t v9 = *(const UInt8 **)a2;
    }
    if (v9)
    {
      if (v8 >= 0) {
        CFIndex v10 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        CFIndex v10 = *(void *)(a2 + 8);
      }
      CFStringRef v7 = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
      CFStringRef v129 = v7;
      if (!v7)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
      if (a4) {
        goto LABEL_14;
      }
    }
    else
    {
      CFStringRef v7 = 0;
      CFStringRef v129 = 0;
      if (a4) {
        goto LABEL_14;
      }
    }
  }
  if (!sub_19E531960(&v129))
  {
    uint64_t v63 = 0;
    if (v7) {
      goto LABEL_159;
    }
    return v63;
  }
LABEL_14:
  unsigned int v128 = 0;
  uint64_t v11 = *a1;
  uint64_t v12 = *(void *)(v11 + 464);
  if (!v12)
  {
    sub_19E415218(v11, v7, (int *)&v128);
    goto LABEL_147;
  }
  std::recursive_mutex::lock(*(std::recursive_mutex **)(v11 + 464));
  if (!v7) {
    goto LABEL_142;
  }
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)uint64_t v134 = 0u;
  float v135 = 1.0;
  unint64_t v13 = *(CFTypeRef ***)(v12 + 104);
  uint64_t v122 = v11;
  unsigned int v124 = *(CFTypeRef ***)(v12 + 112);
  CFStringRef v126 = v7;
  uint64_t v127 = v12;
  if (v13 == v124) {
    goto LABEL_131;
  }
  while (2)
  {
    uint64_t v14 = (*v13)[1];
    unsigned int v15 = (*v13)[2];
LABEL_25:
    if (v14 != v15)
    {
      if (!(*(unsigned int (**)(void, const __CFString *, void))(*(void *)*v14 + 16))(*v14, v7, 0)) {
        goto LABEL_24;
      }
      unint64_t v16 = (unint64_t)**v13;
      if (v16)
      {
        CFRetain(**v13);
        CFTypeRef cfa = (CFTypeRef)v16;
        CFHashCode v17 = CFHash((CFTypeRef)v16);
        unint64_t v18 = (unint64_t)__p[1];
        if (!__p[1]) {
          goto LABEL_65;
        }
      }
      else
      {
        CFTypeRef cfa = 0;
        CFHashCode v17 = 0xD7C06285B9DE677ALL;
        unint64_t v18 = (unint64_t)__p[1];
        if (!__p[1]) {
          goto LABEL_65;
        }
      }
      uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)v18);
      v19.i16[0] = vaddlv_u8(v19);
      if (v19.u32[0] > 1uLL)
      {
        CFHashCode v4 = v17;
        if (v17 >= v18) {
          CFHashCode v4 = v17 % v18;
        }
      }
      else
      {
        CFHashCode v4 = (v18 - 1) & v17;
      }
      unsigned int v20 = (void *)*((void *)__p[0] + v4);
      if (!v20 || (unsigned int v21 = (void *)*v20) == 0)
      {
LABEL_65:
        unsigned int v30 = operator new(0x18uLL);
        *(void *)&long long buf = v30;
        *((void *)&buf + 1) = v134;
        *unsigned int v30 = 0;
        v30[1] = v17;
        v30[2] = v16;
        CFTypeRef cfa = 0;
        LOBYTE(v137) = 1;
        float v31 = (float)((unint64_t)v134[1] + 1);
        if (!v18 || (float)(v135 * (float)v18) < v31)
        {
          BOOL v32 = (v18 & (v18 - 1)) != 0;
          if (v18 < 3) {
            BOOL v32 = 1;
          }
          unint64_t v33 = v32 | (2 * v18);
          unint64_t v34 = vcvtps_u32_f32(v31 / v135);
          if (v33 <= v34) {
            size_t prime = v34;
          }
          else {
            size_t prime = v33;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
          }
          unint64_t v18 = (unint64_t)__p[1];
          if ((void *)prime > __p[1])
          {
LABEL_77:
            if (prime >> 61) {
              sub_19E37C2B8();
            }
            unsigned int v36 = operator new(8 * prime);
            unsigned int v37 = __p[0];
            __p[0] = v36;
            if (v37) {
              operator delete(v37);
            }
            uint64_t v38 = 0;
            __p[1] = (void *)prime;
            do
              *((void *)__p[0] + v38++) = 0;
            while (prime != v38);
            int v39 = (void **)v134[0];
            if (!v134[0]) {
              goto LABEL_101;
            }
            size_t v40 = *((void *)v134[0] + 1);
            size_t v41 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v42 = v40 & v41;
              *((void *)__p[0] + v42) = v134;
              for (int i = *v39; *v39; int i = *v39)
              {
                size_t v44 = i[1] & v41;
                if (v44 == v42)
                {
                  int v39 = (void **)i;
                }
                else if (*((void *)__p[0] + v44))
                {
                  *int v39 = (void *)*i;
                  uint64_t v45 = 8 * v44;
                  void *i = **(void **)((char *)__p[0] + v45);
                  **(void **)((char *)__p[0] + v45) = i;
                }
                else
                {
                  *((void *)__p[0] + v44) = v39;
                  int v39 = (void **)i;
                  size_t v42 = v44;
                }
              }
              goto LABEL_101;
            }
            if (v40 >= prime) {
              v40 %= prime;
            }
            *((void *)__p[0] + v40) = v134;
            unsigned int v49 = *v39;
            if (!*v39)
            {
LABEL_101:
              unint64_t v18 = prime;
              goto LABEL_102;
            }
            while (2)
            {
              size_t v51 = v49[1];
              if (v51 >= prime) {
                v51 %= prime;
              }
              if (v51 != v40)
              {
                if (!*((void *)__p[0] + v51))
                {
                  *((void *)__p[0] + v51) = v39;
LABEL_106:
                  int v39 = (void **)v49;
                  unsigned int v49 = (void *)*v49;
                  size_t v40 = v51;
                  if (!v49) {
                    goto LABEL_101;
                  }
                  continue;
                }
                *int v39 = (void *)*v49;
                uint64_t v50 = 8 * v51;
                *unsigned int v49 = **(void **)((char *)__p[0] + v50);
                **(void **)((char *)__p[0] + v50) = v49;
                unsigned int v49 = v39;
              }
              break;
            }
            size_t v51 = v40;
            goto LABEL_106;
          }
          if ((void *)prime < __p[1])
          {
            unint64_t v46 = vcvtps_u32_f32((float)(unint64_t)v134[1] / v135);
            if (__p[1] < (void *)3
              || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
            {
              unint64_t v46 = std::__next_prime(v46);
            }
            else
            {
              uint64_t v48 = 1 << -(char)__clz(v46 - 1);
              if (v46 >= 2) {
                unint64_t v46 = v48;
              }
            }
            if (prime <= v46) {
              size_t prime = v46;
            }
            if (prime >= v18)
            {
              unint64_t v18 = (unint64_t)__p[1];
            }
            else
            {
              if (prime) {
                goto LABEL_77;
              }
              unint64_t v55 = __p[0];
              __p[0] = 0;
              if (v55) {
                operator delete(v55);
              }
              unint64_t v18 = 0;
              __p[1] = 0;
            }
          }
LABEL_102:
          if ((v18 & (v18 - 1)) != 0)
          {
            if (v17 >= v18) {
              CFHashCode v4 = v17 % v18;
            }
            else {
              CFHashCode v4 = v17;
            }
          }
          else
          {
            CFHashCode v4 = (v18 - 1) & v17;
          }
        }
        int v52 = __p[0];
        unsigned int v53 = (void *)*((void *)__p[0] + v4);
        if (!v53)
        {
          *unsigned int v30 = v134[0];
          v134[0] = v30;
          v52[v4] = v134;
          if (*v30)
          {
            unint64_t v54 = *(void *)(*v30 + 8);
            if ((v18 & (v18 - 1)) != 0)
            {
              if (v54 >= v18) {
                v54 %= v18;
              }
            }
            else
            {
              v54 &= v18 - 1;
            }
            unsigned int v53 = (char *)__p[0] + 8 * v54;
LABEL_21:
            *unsigned int v53 = v30;
          }
          ++v134[1];
          goto LABEL_23;
        }
        *unsigned int v30 = *v53;
        goto LABEL_21;
      }
      if (v19.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v26 = v21[1];
          if (v26 == v17)
          {
            unint64_t v27 = v21[2];
            if (v27) {
              BOOL v28 = v16 == 0;
            }
            else {
              BOOL v28 = 1;
            }
            if (v28)
            {
              if (!(v27 | v16)) {
                goto LABEL_23;
              }
            }
            else if (CFEqual((CFTypeRef)v27, (CFTypeRef)v16))
            {
              goto LABEL_64;
            }
          }
          else if ((v26 & (v18 - 1)) != v4)
          {
            goto LABEL_65;
          }
          unsigned int v21 = (void *)*v21;
          if (!v21) {
            goto LABEL_65;
          }
        }
      }
      while (1)
      {
        unint64_t v22 = v21[1];
        if (v22 == v17)
        {
          unint64_t v23 = v21[2];
          if (v23) {
            BOOL v24 = v16 == 0;
          }
          else {
            BOOL v24 = 1;
          }
          if (v24)
          {
            if (!(v23 | v16)) {
              goto LABEL_23;
            }
          }
          else if (CFEqual((CFTypeRef)v23, (CFTypeRef)v16))
          {
LABEL_64:
            CFRelease((CFTypeRef)v16);
LABEL_23:
            CFStringRef v7 = v126;
            uint64_t v12 = v127;
LABEL_24:
            ++v14;
            goto LABEL_25;
          }
        }
        else
        {
          if (v22 >= v18) {
            v22 %= v18;
          }
          if (v22 != v4) {
            goto LABEL_65;
          }
        }
        unsigned int v21 = (void *)*v21;
        if (!v21) {
          goto LABEL_65;
        }
      }
    }
    v13 += 2;
    if (v13 != v124) {
      continue;
    }
    break;
  }
LABEL_131:
  CFTypeRef cfa = 0;
  uint64_t v56 = *(void *)(v12 + 152);
  uint64_t v57 = *(void *)(v12 + 160);
  if (v56 == v57)
  {
LABEL_134:
    CFArrayRef v58 = 0;
    goto LABEL_135;
  }
  while (*(void *)v56 != v122)
  {
    v56 += 16;
    if (v56 == v57) {
      goto LABEL_134;
    }
  }
  if (!v134[1])
  {
    unsigned int v73 = *(const void **)(v56 + 8);
    if (v73) {
      CFRetain(*(CFTypeRef *)(v56 + 8));
    }
    sub_19E40100C(&buf, v73);
    CFArrayRef v58 = (CFArrayRef)buf;
    CFTypeRef cfa = (CFTypeRef)buf;
    goto LABEL_135;
  }
  long long buf = 0uLL;
  unint64_t v137 = 0;
  int v67 = *(const void **)(v56 + 8);
  if (v67) {
    CFRetain(*(CFTypeRef *)(v56 + 8));
  }
  sub_19E40100C(&theArray, v67);
  CFArrayRef v68 = theArray;
  if (!theArray)
  {
    int v72 = 0;
    goto LABEL_238;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v70 = Count;
  CFArrayRef v71 = theArray;
  if (theArray)
  {
    CFIndex v125 = CFArrayGetCount(theArray);
    int v72 = 0;
    if (!v70) {
      goto LABEL_234;
    }
  }
  else
  {
    CFIndex v125 = 0;
    int v72 = 0;
    if (!Count) {
      goto LABEL_234;
    }
  }
  unint64_t v74 = 0;
  do
  {
    if (v68 == v71 && v74 == v125) {
      break;
    }
    if (CFArrayGetCount(v68) <= v74 || (ValueAtIndex = CFArrayGetValueAtIndex(v68, v74), (int v76 = ValueAtIndex) == 0))
    {
      unsigned int v119 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v119, "Could not find item");
      __cxa_throw(v119, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFRetain(ValueAtIndex);
    int v130 = v76;
    CFHashCode v77 = CFHash(v76);
    unint64_t v78 = (unint64_t)__p[1];
    if (!__p[1]) {
      goto LABEL_232;
    }
    CFHashCode v79 = v77;
    uint8x8_t v80 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
    v80.i16[0] = vaddlv_u8(v80);
    if (v80.u32[0] > 1uLL)
    {
      unint64_t v81 = v77;
      if ((void *)v77 >= __p[1]) {
        unint64_t v81 = v77 % (CFHashCode)__p[1];
      }
    }
    else
    {
      unint64_t v81 = ((CFHashCode)__p[1] - 1) & v77;
    }
    unsigned int v82 = (void *)*((void *)__p[0] + v81);
    if (!v82) {
      goto LABEL_232;
    }
    uint64_t v83 = (void *)*v82;
    if (!*v82) {
      goto LABEL_232;
    }
    if (v80.u32[0] < 2uLL)
    {
      unint64_t v84 = (unint64_t)__p[1] - 1;
      while (1)
      {
        uint64_t v87 = v83[1];
        if (v79 == v87)
        {
          unsigned int v88 = (const void *)v83[2];
          if (v88 && CFEqual(v88, v76)) {
            goto LABEL_202;
          }
        }
        else if ((v87 & v84) != v81)
        {
          goto LABEL_231;
        }
        uint64_t v83 = (void *)*v83;
        if (!v83) {
          goto LABEL_231;
        }
      }
    }
    while (1)
    {
      unint64_t v85 = v83[1];
      if (v79 == v85) {
        break;
      }
      if (v85 >= v78) {
        v85 %= v78;
      }
      if (v85 != v81) {
        goto LABEL_231;
      }
LABEL_190:
      uint64_t v83 = (void *)*v83;
      if (!v83) {
        goto LABEL_231;
      }
    }
    unsigned int v86 = (const void *)v83[2];
    if (!v86 || !CFEqual(v86, v76)) {
      goto LABEL_190;
    }
LABEL_202:
    if ((unint64_t)v72 >= v137)
    {
      unsigned int v90 = (char *)buf;
      BOOL v91 = &v72[-buf];
      uint64_t v123 = (uint64_t)&v72[-buf] >> 3;
      unint64_t v92 = v123 + 1;
      if ((unint64_t)(v123 + 1) >> 61) {
        sub_19E37C7C4();
      }
      uint64_t v93 = v137 - buf;
      if ((uint64_t)(v137 - buf) >> 2 > v92) {
        unint64_t v92 = v93 >> 2;
      }
      if ((unint64_t)v93 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v94 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v94 = v92;
      }
      if (v94)
      {
        if (v94 >> 61) {
          sub_19E37C2B8();
        }
        int v95 = (char *)operator new(8 * v94);
      }
      else
      {
        int v95 = 0;
      }
      CFRetain(v76);
      unsigned int v96 = &v95[8 * v123];
      int v97 = &v95[8 * v94];
      *(void *)unsigned int v96 = v76;
      unsigned int v89 = v96 + 8;
      if (v72 == v90)
      {
        *(void *)&long long buf = &v95[8 * v123];
        *((void *)&buf + 1) = v96 + 8;
        unint64_t v137 = (unint64_t)v97;
        goto LABEL_228;
      }
      unint64_t v98 = v72 - v90 - 8;
      if (v98 > 0x77
        && (&v91[(void)v95 - (v98 & 0xFFFFFFFFFFFFFFF8) - 8] >= v72 || &v72[-(v98 & 0xFFFFFFFFFFFFFFF8) - 8] >= v96))
      {
        uint64_t v99 = (v98 >> 3) + 1;
        v96 -= 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v100 = v72 - 32;
        unsigned int v101 = &v95[8 * v123 - 16];
        uint64_t v102 = v99 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v103 = *((_OWORD *)v100 + 1);
          *((_OWORD *)v101 - 1) = *(_OWORD *)v100;
          *(_OWORD *)unsigned int v101 = v103;
          *(_OWORD *)unsigned int v100 = 0uLL;
          *((_OWORD *)v100 + 1) = 0uLL;
          v100 -= 32;
          v101 -= 32;
          v102 -= 4;
        }
        while (v102);
        if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_223:
          unsigned int v105 = (char *)*((void *)&buf + 1);
          int v72 = (char *)buf;
          *(void *)&long long buf = v96;
          *((void *)&buf + 1) = v89;
          unint64_t v137 = (unint64_t)v97;
          while (v105 != v72)
          {
            unsigned int v107 = (const void *)*((void *)v105 - 1);
            v105 -= 8;
            unsigned int v106 = v107;
            if (v107) {
              CFRelease(v106);
            }
          }
LABEL_228:
          if (v72) {
            operator delete(v72);
          }
          goto LABEL_230;
        }
        v72 -= 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
      }
      do
      {
        uint64_t v104 = *((void *)v72 - 1);
        v72 -= 8;
        *((void *)v96 - 1) = v104;
        v96 -= 8;
        *(void *)int v72 = 0;
      }
      while (v72 != v90);
      goto LABEL_223;
    }
    CFRetain(v76);
    *(void *)int v72 = v76;
    unsigned int v89 = v72 + 8;
LABEL_230:
    *((void *)&buf + 1) = v89;
    int v76 = v130;
    int v72 = v89;
LABEL_231:
    if (v76) {
LABEL_232:
    }
      CFRelease(v76);
    ++v74;
  }
  while (v74 != v70);
LABEL_234:
  if (theArray) {
    CFRelease(theArray);
  }
  CFStringRef v7 = v126;
  uint64_t v12 = v127;
LABEL_238:
  if ((char *)buf == v72)
  {
    unsigned int v108 = v134[0];
    if (v134[0])
    {
      unint64_t v109 = -1;
      unsigned int v110 = v134[0];
      do
      {
        unint64_t v111 = v109;
        unsigned int v110 = (void *)*v110;
        ++v109;
      }
      while (v110);
      if (v109 >= 0x1FFFFFFFFFFFFFFFLL) {
        sub_19E37C7C4();
      }
      size_t v112 = 8 * (v111 + 2);
      unsigned int v113 = (char *)operator new(v112);
      bzero(v113, v112);
      unsigned int v114 = v113;
      do
      {
        *v114++ = v108[2];
        unsigned int v108 = (void *)*v108;
      }
      while (v108);
      unsigned int v115 = &v113[v112];
    }
    else
    {
      unsigned int v115 = 0;
      unsigned int v113 = 0;
    }
    CFArrayRef v58 = CFArrayCreate(0, (const void **)v113, (v115 - v113) >> 3, MEMORY[0x1E4F1D510]);
    if (!v58)
    {
      uint64_t v121 = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](v121, "Could not construct");
      __cxa_throw(v121, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    if (v113) {
      operator delete(v113);
    }
  }
  else
  {
    CFArrayRef v58 = sub_19E400E28((char *)buf, v72);
    int v72 = (char *)buf;
  }
  CFTypeRef cfa = v58;
  if (v72)
  {
    for (uint64_t j = (char *)*((void *)&buf + 1); j != v72; j -= 8)
    {
      unsigned int v118 = (const void *)*((void *)j - 1);
      unsigned int v117 = v118;
      if (v118) {
        CFRelease(v117);
      }
    }
    *((void *)&buf + 1) = v72;
    operator delete(v72);
  }
LABEL_135:
  sub_19E4BB22C(&buf, *(void *)(v12 + 104), *(void *)(v12 + 112));
  sub_19E4BA2A4(v7, (int *)&v128, *(void *)(v12 + 128), (uint64_t)&buf, *(const void **)(v12 + 176), v58);
  if ((void)buf) {
    operator delete((void *)buf);
  }
  if (cfa) {
    CFRelease(cfa);
  }
  unsigned int v59 = v134[0];
  if (v134[0])
  {
    do
    {
      unsigned int v61 = (void *)*v59;
      unsigned int v62 = (const void *)v59[2];
      if (v62) {
        CFRelease(v62);
      }
      operator delete(v59);
      unsigned int v59 = v61;
    }
    while (v61);
  }
  float v60 = __p[0];
  __p[0] = 0;
  if (v60) {
    operator delete(v60);
  }
LABEL_142:
  std::recursive_mutex::unlock((std::recursive_mutex *)v12);
LABEL_147:
  uint64_t v63 = v128;
  if (v128)
  {
    if (!v7) {
      return v63;
    }
LABEL_159:
    CFRelease(v7);
  }
  else
  {
    unsigned int v64 = (char *)operator new(0x20uLL);
    strcpy(v64, "addTokenForString() failed");
    sub_19E439798("addTokenForString() failed for: %@", (uint64_t)__p, v7);
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    unsigned int v65 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = v64;
      _os_log_impl(&dword_19E36B000, v65, OS_LOG_TYPE_INFO, "%s", (uint8_t *)&buf, 0xCu);
    }
    if (SHIBYTE(v134[0]) < 0) {
      operator delete(__p[0]);
    }
    operator delete(v64);
    uint64_t v63 = v128;
    if (v7) {
      goto LABEL_159;
    }
  }
  return v63;
}

void sub_19E5317D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::recursive_mutex *a13, uint64_t a14, const void *a15, const void *a16, const void *a17, const void *a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p)
{
}

uint64_t sub_19E531960(CFStringRef *a1)
{
  v20[1] = *MEMORY[0x1E4F143B8];
  uint64_t Length = CFStringGetLength(*a1);
  MEMORY[0x1F4188790]();
  CFHashCode v4 = (UniChar *)((char *)v20 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0));
  v21.location = 0;
  v21.length = Length;
  CFStringGetCharacters(*a1, v21, v4);
  uint64_t v5 = 0;
  uint64_t v6 = Length - 1;
  if (Length < 1) {
    return v5;
  }
  unsigned int v7 = *v4;
  if (v7 <= 0x2D && ((1 << v7) & 0x20C000000000) != 0) {
    return v5;
  }
  if (v7 - 1523 < 2 || v7 == 8217) {
    return v5;
  }
  int8_t v11 = u_charType(v7);
  if (((1 << v11) & 0x40003FE) == 0) {
    return 0;
  }
  uint64_t v5 = (0x3Eu >> v11) & 1;
  if (Length == 1)
  {
    if (!v5) {
      return v5;
    }
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v12 = v4 + 1;
    do
    {
      while (1)
      {
        unsigned int v14 = *v12++;
        UChar32 v13 = v14;
        uint64_t v15 = (1 << v14) & 0x20C000000000;
        if ((v14 > 0x2D || v15 == 0) && (v13 - 1523) >= 2 && v13 != 8217) {
          break;
        }
        if (v6 == 1) {
          return 0;
        }
        if (!--v6) {
          goto LABEL_31;
        }
      }
      int8_t v18 = u_charType(v13);
      if (((0x40003FEu >> v18) & 1) == 0) {
        return 0;
      }
      uint64_t v5 = ((0x3Eu >> v18) & 1) + v5;
      --v6;
    }
    while (v6);
LABEL_31:
    if (!v5) {
      return v5;
    }
  }
  if ((float)((float)v5 / (float)Length) < 0.49 || Length - v5 > 3) {
    return 0;
  }
  return v5;
}

uint64_t sub_19E531B44(uint64_t a1, uint64_t *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v5[0] = &unk_1EF0BD5B8;
  uint64_t v6 = v5;
  v3[0] = &unk_1EF0B4F28;
  v3[1] = a1;
  CFHashCode v4 = v3;
  v7[0] = &unk_1EF0B4F80;
  v7[1] = v3;
  char v8 = v7;
  sub_19E49AA70(a2, (uint64_t)v5, (uint64_t)v7);
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void *))(*v8 + 40))(v8);
  }
  if (v4 == v3)
  {
    (*(void (**)(void *))(v3[0] + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(void))(*v4 + 40))();
  }
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

void sub_19E531D40(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  sub_19E49AC30((void *)(v2 - 56));
  sub_19E49ACB4((uint64_t *)va);
  sub_19E49AD38((uint64_t *)va1);
  _Unwind_Resume(a1);
}

void *sub_19E531D64()
{
  return &unk_1EF0B8058;
}

uint64_t sub_19E531D70(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_1"
    || ((v3 & (unint64_t)"ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_1")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E531DC8(uint64_t a1, uint64_t a2, const __CFString **a3, _DWORD *a4)
{
  return sub_19E530A8C(*(uint64_t **)(a1 + 8), a2, *a3, *a4 != 0);
}

uint64_t sub_19E531DE8(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B4F28;
  a2[1] = v2;
  return result;
}

void *sub_19E531E0C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B4F28;
  result[1] = v3;
  return result;
}

void sub_19E531E54()
{
}

void *sub_19E531E6C()
{
  return &unk_1EF0B8048;
}

uint64_t sub_19E531E78(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_0")
    && !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v112TokenLearner17learnFromSequenceERNS0_13TokenSequenceEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

BOOL sub_19E531ED0(uint64_t a1, _DWORD *a2)
{
  return (*a2 - 500) < 0xFFFFFE0D;
}

void sub_19E531EEC(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF0BD5B8;
}

void *sub_19E531F0C()
{
  uint64_t result = operator new(0x10uLL);
  void *result = &unk_1EF0BD5B8;
  return result;
}

void sub_19E531F44()
{
}

uint64_t sub_19E531F5C()
{
  return 5;
}

const char *sub_19E531F64()
{
  return "dynamic model";
}

uint64_t sub_19E531F70(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 24) + 368);
}

float sub_19E531F7C(uint64_t a1, int a2)
{
  uint64_t v2 = 304;
  if (a2 == 1) {
    uint64_t v2 = 220;
  }
  return *(float *)(*(void *)(a1 + 24) + v2);
}

float sub_19E531F98(uint64_t a1, int a2)
{
  uint64_t v2 = 256;
  if (a2 == 1) {
    uint64_t v2 = 216;
  }
  return *(float *)(*(void *)(a1 + 24) + v2);
}

void sub_19E531FB4(void *a1)
{
  sub_19E49CB94(a1);
  JUMPOUT(0x19F3BDCF0);
}

unint64_t sub_19E531FF0(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  unint64_t v6 = *(void *)(a1 + 128);
  uint64_t v5 = *(void *)(a1 + 136);
  double v7 = 0.0;
  unint64_t v8 = v5 - v6;
  unint64_t v9 = (uint64_t)(v5 - v6) >> 3;
  if (v5 != v6)
  {
    if (!a3)
    {
      if (!a2) {
        return v9;
      }
      if (v9 <= 1) {
        unint64_t v16 = 1;
      }
      else {
        unint64_t v16 = (uint64_t)(v5 - v6) >> 3;
      }
      if (v16 >= 0xA
        && (v6 + 8 * v16 - 4 > (unint64_t)a2 ? (BOOL v17 = v6 >= (unint64_t)&a2[v16]) : (BOOL v17 = 1), v17))
      {
        unint64_t v18 = v16 & 0xFFFFFFFFFFFFFFFCLL;
        uint8x8_t v19 = (int *)(v6 + 16);
        unsigned int v20 = a2 + 2;
        unint64_t v21 = v16 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          unint64_t v22 = v19 + 2;
          LODWORD(v23) = *(v19 - 4);
          HIDWORD(v23) = *(v19 - 2);
          int v24 = *v19;
          v19 += 8;
          LODWORD(v25) = v24;
          HIDWORD(v25) = *v22;
          *(v20 - 1) = v23;
          *unsigned int v20 = v25;
          v20 += 2;
          v21 -= 4;
        }
        while (v21);
        if (v16 == v18) {
          goto LABEL_32;
        }
      }
      else
      {
        unint64_t v18 = 0;
      }
      unint64_t v30 = v16 - v18;
      float v31 = &a2[v18];
      BOOL v32 = (int *)(v6 + 8 * v18);
      do
      {
        int v33 = *v32;
        v32 += 2;
        *v31++ = v33;
        --v30;
      }
      while (v30);
      goto LABEL_32;
    }
    if (v9 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = (uint64_t)(v5 - v6) >> 3;
    }
    double v7 = log10(*(float *)(v6 + 4) / *(float *)(a1 + 88));
    if (a2)
    {
      *a2 = *(_DWORD *)v6;
      if (v8 >= 0x10)
      {
        uint64_t v12 = v11 - 1;
        UChar32 v13 = a2 + 1;
        unint64_t v14 = v6 + 8;
        do
        {
          double v7 = log10(*(float *)(v14 + 4) / *(float *)(v14 - 4)) + v7;
          int v15 = *(_DWORD *)v14;
          v14 += 8;
          *v13++ = v15;
          --v12;
        }
        while (v12);
        goto LABEL_32;
      }
LABEL_33:
      uint64_t v34 = (uint64_t)(*(void *)(a1 + 112) - *(void *)(a1 + 104)) >> 2;
      *(void *)(a3 + 96) = 0;
      *(void *)(a3 + 104) = v34;
      *(void *)(a3 + 8) = 0xFFEFFFFFFFFFFFFFLL;
      *(void *)(a3 + 16) = 0;
      *(_WORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      *(unsigned char *)(a3 + 32) = 1;
      *(_OWORD *)(a3 + 40) = xmmword_19E572FD0;
      *(_DWORD *)(a3 + 56) = 0;
      *(void *)(a3 + 88) = 0;
      *(double *)a3 = v7;
      *(_DWORD *)(a3 + 116) = *(_DWORD *)(a1 + 72);
      *(unsigned char *)(a3 + 112) = 1;
      *(_OWORD *)(a3 + 72) = xmmword_19E5731A0;
      *(double *)(a3 + 64) = v7;
      return v9;
    }
    if (v8 < 0x10) {
      goto LABEL_33;
    }
    uint64_t v26 = v11 - 1;
    unint64_t v27 = (float *)(v6 + 12);
    do
    {
      double v28 = *(v27 - 2);
      float v29 = *v27;
      v27 += 2;
      double v7 = log10(v29 / v28) + v7;
      --v26;
    }
    while (v26);
  }
LABEL_32:
  if (a3) {
    goto LABEL_33;
  }
  return v9;
}

uint64_t sub_19E5321F0(uint64_t a1)
{
  unint64_t v1 = *(void *)(a1 + 80) + 1;
  *(void *)(a1 + 80) = v1;
  if (v1 > *(void *)(a1 + 64)) {
    return 0;
  }
  unint64_t v3 = *(float **)(a1 + 128);
  if (*(float **)(a1 + 136) == v3)
  {
    unint64_t v3 = *(float **)(a1 + 136);
  }
  else if (*(double *)(a1 + 96) >= 0.5)
  {
    unint64_t v5 = *(void *)(a1 + 128);
    uint64_t v4 = *(void *)(a1 + 136);
    unint64_t v6 = (uint64_t)(v4 - v5) >> 3;
    if (v6 < *(void *)(a1 + 56))
    {
      double v7 = *(unsigned char **)(a1 + 104);
      unint64_t v8 = *(unsigned char **)(a1 + 112);
      size_t v9 = v8 - v7;
      uint64_t v10 = (v8 - v7) >> 2;
      unint64_t v11 = v10 + v6;
      if (v10 + v6)
      {
        __src = *(unsigned char **)(a1 + 104);
        if (v11 >> 62) {
          sub_19E37C7C4();
        }
        size_t v12 = v8 - v7;
        size_t v13 = 4 * v11;
        unint64_t v14 = (char *)operator new(4 * v11);
        bzero(v14, v13);
        size_t v9 = v12;
        double v7 = __src;
        if (v8 != __src) {
          goto LABEL_8;
        }
      }
      else
      {
        unint64_t v14 = 0;
        if (v8 != v7) {
LABEL_8:
        }
          memmove(v14, v7, v9);
      }
      if (v4 == v5) {
        goto LABEL_26;
      }
      if (v6 <= 1) {
        unint64_t v15 = 1;
      }
      else {
        unint64_t v15 = (uint64_t)(v4 - v5) >> 3;
      }
      if (v15 >= 0xC
        && ((unint64_t)&v14[v9] < v5 + 8 * v15 - 4
          ? (BOOL v16 = v5 >= (unint64_t)&v14[4 * v15 + v9])
          : (BOOL v16 = 1),
            v16))
      {
        unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFFCLL;
        unint64_t v18 = (_DWORD *)(v5 + 16);
        uint8x8_t v19 = &v14[4 * v10];
        unint64_t v20 = v15 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          LODWORD(v21) = *(v18 - 4);
          DWORD1(v21) = *(v18 - 2);
          DWORD2(v21) = *v18;
          HIDWORD(v21) = v18[2];
          *(_OWORD *)uint8x8_t v19 = v21;
          v19 += 16;
          v18 += 8;
          v20 -= 4;
        }
        while (v20);
        if (v15 == v17) {
LABEL_26:
        }
          operator new();
        v10 += v17;
      }
      else
      {
        unint64_t v17 = 0;
      }
      unint64_t v22 = v15 - v17;
      uint64_t v23 = (int *)(v5 + 8 * v17);
      int v24 = &v14[4 * v10];
      do
      {
        int v25 = *v23;
        v23 += 2;
        *(_DWORD *)int v24 = v25;
        v24 += 4;
        --v22;
      }
      while (v22);
      goto LABEL_26;
    }
    unint64_t v3 = *(float **)(a1 + 128);
  }
  *(void *)(a1 + 136) = v3;
  uint64_t v26 = *(uint64_t **)(a1 + 48);
  unint64_t v27 = v26[3] + 1;
  v26[3] = v27;
  uint64_t v28 = *v26;
  if (v27 >= (v26[1] - *v26) >> 3) {
    return 0;
  }
  unint64_t v29 = *(void *)(a1 + 144);
  if ((unint64_t)v3 >= v29)
  {
    uint64_t v32 = v29 - (void)v3;
    uint64_t v33 = v32 >> 2;
    if ((unint64_t)(v32 >> 2) <= 1) {
      uint64_t v33 = 1;
    }
    BOOL v16 = (unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8;
    unint64_t v34 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16) {
      unint64_t v34 = v33;
    }
    if (v34 >> 61) {
      sub_19E37C2B8();
    }
    uint64_t v35 = v34;
    unsigned int v36 = operator new(8 * v34);
    unsigned int v37 = &v36[v35];
    void *v36 = *(void *)(v28 + 8 * v27);
    unint64_t v30 = (float *)(v36 + 1);
    *(void *)(a1 + 128) = v36;
    *(void *)(a1 + 136) = v36 + 1;
    *(void *)(a1 + 144) = v37;
    if (v3) {
      operator delete(v3);
    }
  }
  else
  {
    *(void *)unint64_t v3 = *(void *)(v28 + 8 * v27);
    unint64_t v30 = v3 + 2;
  }
  *(void *)(a1 + 136) = v30;
  *(double *)(a1 + 96) = (float)(*(v30 - 1) / *(float *)(a1 + 88));
  return 1;
}

void sub_19E532704(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_19E532C04((uint64_t *)va);
  if (v7) {
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E532764(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = -1;
  (*(void (**)(void **__return_ptr, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 112))(&__p, a2, a3, a4, a5);
  unint64_t v8 = (char *)__p;
  size_t v9 = (char *)v54;
  if (__p == v54)
  {
    uint64_t v10 = (char *)__p;
  }
  else
  {
    uint64_t v10 = (char *)v54;
    while (1)
    {
      uint64_t v11 = *(void *)(a6 + 24);
      if (!v11) {
LABEL_63:
      }
        sub_19E3ACB9C();
      if (!(*(unsigned int (**)(uint64_t, char *))(*(void *)v11 + 48))(v11, v8)) {
        break;
      }
      v8 += 12;
      if (v8 == v9) {
        goto LABEL_15;
      }
    }
    if (v8 != v9)
    {
      size_t v12 = v8 + 12;
      uint64_t v10 = v8;
      while (v12 != v9)
      {
        uint64_t v13 = *(void *)(a6 + 24);
        if (!v13) {
          goto LABEL_63;
        }
        if ((*(unsigned int (**)(uint64_t, char *))(*(void *)v13 + 48))(v13, v12))
        {
          uint64_t v14 = *(void *)v12;
          *((_DWORD *)v10 + 2) = *((_DWORD *)v12 + 2);
          *(void *)uint64_t v10 = v14;
          v10 += 12;
        }
        v12 += 12;
      }
    }
  }
LABEL_15:
  unint64_t v15 = (char *)__p;
  if (v10 != (char *)v54) {
    unint64_t v54 = (unsigned int *)v10;
  }
  unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v10 - (unsigned char *)__p) >> 2);
  unint64_t v17 = *(unsigned char **)a1;
  if (v16 > (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3)
  {
    if (v16 >> 61) {
      sub_19E37C7C4();
    }
    unint64_t v18 = *(unsigned char **)(a1 + 8);
    uint8x8_t v19 = (char *)operator new(0x5555555555555558 * ((v10 - (unsigned char *)__p) >> 2));
    uint64_t v20 = v18 - v17;
    long long v21 = &v19[(v18 - v17) & 0xFFFFFFFFFFFFFFF8];
    unint64_t v22 = v21;
    if (v18 == v17) {
      goto LABEL_27;
    }
    if ((unint64_t)(v20 - 8) >= 0x58)
    {
      unint64_t v22 = &v19[(v18 - v17) & 0xFFFFFFFFFFFFFFF8];
      if ((unint64_t)(&v18[-(v20 & 0xFFFFFFFFFFFFFFF8)] - v19) >= 0x20)
      {
        uint64_t v23 = v20 >> 3;
        unint64_t v24 = ((unint64_t)(v20 - 8) >> 3) + 1;
        int v25 = &v19[8 * v23 - 16];
        uint64_t v26 = (long long *)(v18 - 16);
        uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v28 = *v26;
          *((_OWORD *)v25 - 1) = *(v26 - 1);
          *(_OWORD *)int v25 = v28;
          v25 -= 32;
          v26 -= 2;
          v27 -= 4;
        }
        while (v27);
        unint64_t v22 = &v21[-8 * (v24 & 0x3FFFFFFFFFFFFFFCLL)];
        v18 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_27:
          *(void *)a1 = v22;
          *(void *)(a1 + 8) = v21;
          *(void *)(a1 + 16) = &v19[0x5555555555555558 * ((v10 - v15) >> 2)];
          if (v17)
          {
            operator delete(v17);
            unint64_t v15 = (char *)__p;
            uint64_t v10 = (char *)v54;
          }
          goto LABEL_29;
        }
      }
    }
    else
    {
      unint64_t v22 = &v19[(v18 - v17) & 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      uint64_t v29 = *((void *)v18 - 1);
      v18 -= 8;
      *((void *)v22 - 1) = v29;
      v22 -= 8;
    }
    while (v18 != v17);
    goto LABEL_27;
  }
LABEL_29:
  unint64_t v30 = *(float **)(a1 + 8);
  if (v15 != v10)
  {
    while (1)
    {
      unint64_t v35 = *(unsigned int *)v15 | ((unint64_t)*((unsigned int *)v15 + 2) << 32);
      unint64_t v36 = *(void *)(a1 + 16);
      if ((unint64_t)v30 >= v36) {
        break;
      }
      *(void *)unint64_t v30 = v35;
      float v31 = v30 + 2;
LABEL_38:
      *(void *)(a1 + 8) = v31;
      v15 += 12;
      unint64_t v30 = v31;
      if (v15 == v10) {
        goto LABEL_31;
      }
    }
    unsigned int v37 = *(float **)a1;
    uint64_t v38 = (uint64_t)v30 - *(void *)a1;
    uint64_t v39 = v38 >> 3;
    unint64_t v40 = (v38 >> 3) + 1;
    if (v40 >> 61) {
      sub_19E37C7C4();
    }
    uint64_t v41 = v36 - (void)v37;
    if (v41 >> 2 > v40) {
      unint64_t v40 = v41 >> 2;
    }
    if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v42 = v40;
    }
    if (v42)
    {
      if (v42 >> 61) {
        sub_19E37C2B8();
      }
      unsigned int v43 = operator new(8 * v42);
    }
    else
    {
      unsigned int v43 = 0;
    }
    size_t v44 = (unint64_t *)&v43[8 * v39];
    *size_t v44 = v35;
    float v31 = (float *)(v44 + 1);
    if (v30 == v37)
    {
      unsigned int v37 = v30;
      goto LABEL_61;
    }
    unint64_t v45 = (char *)v30 - (char *)v37 - 8;
    if (v45 >= 0x58)
    {
      if ((unint64_t)((char *)v30 - v43 - v38) >= 0x20)
      {
        uint64_t v47 = (v45 >> 3) + 1;
        unint64_t v46 = &v30[-2 * (v47 & 0x3FFFFFFFFFFFFFFCLL)];
        uint64_t v48 = &v43[8 * v39 - 16];
        unsigned int v49 = v30 - 4;
        uint64_t v50 = v47 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v51 = *(_OWORD *)v49;
          *(v48 - 1) = *((_OWORD *)v49 - 1);
          *uint64_t v48 = v51;
          v48 -= 2;
          v49 -= 8;
          v50 -= 4;
        }
        while (v50);
        v44 -= v47 & 0x3FFFFFFFFFFFFFFCLL;
        if (v47 == (v47 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_61;
        }
      }
      else
      {
        unint64_t v46 = v30;
      }
    }
    else
    {
      unint64_t v46 = v30;
    }
    do
    {
      unint64_t v52 = *((void *)v46 - 1);
      v46 -= 2;
      *--size_t v44 = v52;
    }
    while (v46 != v37);
    unsigned int v37 = *(float **)a1;
LABEL_61:
    *(void *)a1 = v44;
    *(void *)(a1 + 8) = v31;
    *(void *)(a1 + 16) = &v43[8 * v42];
    if (v37) {
      operator delete(v37);
    }
    goto LABEL_38;
  }
  float v31 = *(float **)(a1 + 8);
LABEL_31:
  unint64_t v32 = 126 - 2 * __clz(((uint64_t)v31 - *(void *)a1) >> 3);
  if (v31 == *(float **)a1) {
    uint64_t v33 = 0;
  }
  else {
    uint64_t v33 = v32;
  }
  sub_19E532C5C(*(float **)a1, v31, v33, 1);
  if (__p)
  {
    unint64_t v54 = (unsigned int *)__p;
    operator delete(__p);
  }
  return a1;
}

void sub_19E532BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
  {
    operator delete(__p);
    uint64_t v13 = *(void **)v11;
    if (!*(void *)v11) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    uint64_t v13 = *(void **)v11;
    if (!*(void *)v11) {
      goto LABEL_3;
    }
  }
  *(void *)(v11 + 8) = v13;
  operator delete(v13);
  _Unwind_Resume(exception_object);
}

uint64_t *sub_19E532C04(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    unint64_t v3 = *(void **)v2;
    if (*(void *)v2)
    {
      *(void *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x19F3BDCF0](v2, 0x1020C4016EE4530);
  }
  return a1;
}

float *sub_19E532C5C(float *result, float *a2, uint64_t a3, char a4)
{
  size_t v9 = result;
  while (2)
  {
    uint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          size_t v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          uint64_t v12 = ((char *)a2 - (char *)v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0:
              case 1:
                return result;
              case 2:
                float v94 = *(a2 - 1);
                float v95 = v10[1];
                if (v94 > v95)
                {
                  float v96 = *v10;
                  *uint64_t v10 = *(a2 - 2);
                  *(a2 - 2) = v96;
                  v10[1] = v94;
                  *(a2 - 1) = v95;
                }
                return result;
              case 3:
                float v97 = v10[3];
                float v98 = v10[1];
                float v99 = *(a2 - 1);
                if (v97 <= v98)
                {
                  if (v99 > v97)
                  {
                    int v135 = *((_DWORD *)v10 + 2);
                    v10[2] = *(a2 - 2);
                    *((_DWORD *)a2 - 2) = v135;
                    v10[3] = v99;
                    *(a2 - 1) = v97;
                    float v104 = v10[3];
                    float v110 = v10[1];
                    if (v104 > v110)
                    {
                      int v136 = *(_DWORD *)v10;
                      *uint64_t v10 = v10[2];
                      *((_DWORD *)v10 + 2) = v136;
LABEL_150:
                      v10[1] = v104;
                      v10[3] = v110;
                    }
                  }
                }
                else
                {
                  int v100 = *(_DWORD *)v10;
                  if (v99 <= v97)
                  {
                    *uint64_t v10 = v10[2];
                    *((_DWORD *)v10 + 2) = v100;
                    v10[1] = v97;
                    v10[3] = v98;
                    float v158 = *(a2 - 1);
                    if (v158 <= v98) {
                      return result;
                    }
                    v10[2] = *(a2 - 2);
                    *((_DWORD *)a2 - 2) = v100;
                    v10[3] = v158;
                  }
                  else
                  {
                    *uint64_t v10 = *(a2 - 2);
                    *((_DWORD *)a2 - 2) = v100;
                    v10[1] = v99;
                  }
                  *(a2 - 1) = v98;
                }
                break;
              case 4:
                return sub_19E521C28(v10, v10 + 2, v10 + 4, a2 - 2);
              case 5:
                uint64_t result = sub_19E521C28(v10, v10 + 2, v10 + 4, v10 + 6);
                float v101 = *(a2 - 1);
                float v102 = v10[7];
                if (v101 <= v102) {
                  return result;
                }
                int v103 = *((_DWORD *)v10 + 6);
                v10[6] = *(a2 - 2);
                *((_DWORD *)a2 - 2) = v103;
                v10[7] = v101;
                *(a2 - 1) = v102;
                float v104 = v10[7];
                float v105 = v10[5];
                if (v104 <= v105) {
                  return result;
                }
                int v106 = *((_DWORD *)v10 + 4);
                int v107 = *((_DWORD *)v10 + 6);
                *((_DWORD *)v10 + 4) = v107;
                *((_DWORD *)v10 + 6) = v106;
                v10[5] = v104;
                v10[7] = v105;
                float v108 = v10[3];
                if (v104 <= v108) {
                  return result;
                }
                int v109 = *((_DWORD *)v10 + 2);
                *((_DWORD *)v10 + 2) = v107;
                *((_DWORD *)v10 + 4) = v109;
                v10[3] = v104;
                v10[5] = v108;
                float v110 = v10[1];
                if (v104 <= v110) {
                  return result;
                }
                float v111 = *v10;
                *(_DWORD *)uint64_t v10 = v107;
                v10[2] = v111;
                goto LABEL_150;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            size_t v112 = v10 + 2;
            BOOL v114 = v10 == a2 || v112 == a2;
            if (a4)
            {
              if (!v114)
              {
                uint64_t v115 = 0;
                int v116 = v10;
                do
                {
                  float v118 = v116[3];
                  float v119 = v116[1];
                  int v116 = v112;
                  if (v118 > v119)
                  {
                    float v120 = *v112;
                    uint64_t v121 = v115;
                    do
                    {
                      uint64_t v122 = (float *)((char *)v10 + v121);
                      v122[2] = *(float *)((char *)v10 + v121);
                      v122[3] = *(float *)((char *)v10 + v121 + 4);
                      if (!v121)
                      {
                        uint64_t v117 = (uint64_t)v10;
                        goto LABEL_124;
                      }
                      v121 -= 8;
                    }
                    while (v118 > *(v122 - 1));
                    uint64_t v117 = (uint64_t)v10 + v121 + 8;
LABEL_124:
                    *(float *)uint64_t v117 = v120;
                    *(float *)(v117 + 4) = v118;
                  }
                  size_t v112 = v116 + 2;
                  v115 += 8;
                }
                while (v116 + 2 != a2);
              }
            }
            else if (!v114)
            {
              unint64_t v137 = v10 + 1;
              do
              {
                float v138 = v9[3];
                float v139 = v9[1];
                size_t v9 = v112;
                if (v138 > v139)
                {
                  float v140 = *v112;
                  unsigned int v141 = v137;
                  do
                  {
                    v141[1] = *(v141 - 1);
                    v141[2] = *v141;
                    float v142 = *(v141 - 2);
                    v141 -= 2;
                  }
                  while (v138 > v142);
                  v141[1] = v140;
                  v141[2] = v138;
                }
                size_t v112 = v9 + 2;
                v137 += 2;
              }
              while (v9 + 2 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v123 = (unint64_t)(v12 - 2) >> 1;
              int64_t v124 = v123;
              do
              {
                if (v123 >= v124)
                {
                  uint64_t v126 = (2 * v124) | 1;
                  uint64_t v127 = &v10[2 * v126];
                  if (2 * v124 + 2 < v12 && v127[1] > v127[3])
                  {
                    v127 += 2;
                    uint64_t v126 = 2 * v124 + 2;
                  }
                  float v128 = v127[1];
                  float v129 = v10[2 * v124 + 1];
                  if (v128 <= v129)
                  {
                    int v130 = &v10[2 * v124];
                    int v131 = *(_DWORD *)v130;
                    do
                    {
                      int64_t v132 = v130;
                      int v130 = v127;
                      *int64_t v132 = *v127;
                      v132[1] = v128;
                      if (v123 < v126) {
                        break;
                      }
                      uint64_t v133 = 2 * v126;
                      uint64_t v126 = (2 * v126) | 1;
                      uint64_t v127 = &v10[2 * v126];
                      uint64_t v134 = v133 + 2;
                      if (v134 < v12 && v127[1] > v127[3])
                      {
                        v127 += 2;
                        uint64_t v126 = v134;
                      }
                      float v128 = v127[1];
                    }
                    while (v128 <= v129);
                    *(_DWORD *)int v130 = v131;
                    v130[1] = v129;
                  }
                }
                BOOL v125 = v124-- <= 0;
              }
              while (!v125);
              uint64_t v143 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v144 = 0;
                float v145 = *v10;
                int v146 = *((_DWORD *)v10 + 1);
                unsigned int v147 = v10;
                do
                {
                  uint64_t v148 = v147;
                  v147 += 2 * v144 + 2;
                  uint64_t v149 = 2 * v144;
                  uint64_t v144 = (2 * v144) | 1;
                  uint64_t v150 = v149 + 2;
                  if (v150 < v143 && v147[1] > v147[3])
                  {
                    v147 += 2;
                    uint64_t v144 = v150;
                  }
                  float *v148 = *v147;
                  v148[1] = v147[1];
                }
                while (v144 <= (uint64_t)((unint64_t)(v143 - 2) >> 1));
                if (v147 == a2 - 2)
                {
                  *unsigned int v147 = v145;
                  *((_DWORD *)v147 + 1) = v146;
                }
                else
                {
                  *unsigned int v147 = *(a2 - 2);
                  v147[1] = *(a2 - 1);
                  *(a2 - 2) = v145;
                  *((_DWORD *)a2 - 1) = v146;
                  uint64_t v151 = (char *)v147 - (char *)v10 + 8;
                  if (v151 >= 9)
                  {
                    unint64_t v152 = (((unint64_t)v151 >> 3) - 2) >> 1;
                    float v153 = v10[2 * v152 + 1];
                    float v154 = v147[1];
                    if (v153 > v154)
                    {
                      int v155 = *(_DWORD *)v147;
                      do
                      {
                        unint64_t v156 = v152;
                        unsigned int v157 = v147;
                        unsigned int v147 = &v10[2 * v156];
                        float *v157 = *v147;
                        v157[1] = v153;
                        if (!v156) {
                          break;
                        }
                        unint64_t v152 = (v156 - 1) >> 1;
                        float v153 = v10[2 * v152 + 1];
                      }
                      while (v153 > v154);
                      *(_DWORD *)unsigned int v147 = v155;
                      v10[2 * v156 + 1] = v154;
                    }
                  }
                }
                a2 -= 2;
                BOOL v125 = v143-- <= 2;
              }
              while (!v125);
            }
            return result;
          }
          unint64_t v13 = (unint64_t)v12 >> 1;
          uint64_t v14 = &v10[2 * ((unint64_t)v12 >> 1)];
          float v15 = *(a2 - 1);
          if ((unint64_t)v11 < 0x401) {
            break;
          }
          float v16 = v10[1];
          unint64_t v17 = &v10[2 * v13 + 1];
          float v18 = *v17;
          if (*v17 <= v16)
          {
            if (v15 > v18)
            {
              float v24 = *v14;
              *uint64_t v14 = *(a2 - 2);
              *(a2 - 2) = v24;
              *unint64_t v17 = v15;
              *(a2 - 1) = v18;
              float v25 = *v17;
              float v26 = v10[1];
              if (*v17 > v26)
              {
                float v27 = *v10;
                *uint64_t v10 = *v14;
                *uint64_t v14 = v27;
                v10[1] = v25;
                *unint64_t v17 = v26;
              }
            }
          }
          else
          {
            float v19 = *v10;
            if (v15 <= v18)
            {
              *uint64_t v10 = *v14;
              *uint64_t v14 = v19;
              v10[1] = v18;
              *unint64_t v17 = v16;
              float v32 = *(a2 - 1);
              if (v32 <= v16) {
                goto LABEL_24;
              }
              *uint64_t v14 = *(a2 - 2);
              *(a2 - 2) = v19;
              *unint64_t v17 = v32;
            }
            else
            {
              *uint64_t v10 = *(a2 - 2);
              *(a2 - 2) = v19;
              v10[1] = v15;
            }
            *(a2 - 1) = v16;
          }
LABEL_24:
          uint64_t v33 = &v10[2 * v13];
          float v35 = *(v33 - 1);
          unint64_t v34 = v33 - 1;
          float v36 = v35;
          unsigned int v37 = v34 - 1;
          float v38 = v10[3];
          float v39 = *(a2 - 3);
          if (v35 <= v38)
          {
            if (v39 > v36)
            {
              float v41 = *v37;
              *unsigned int v37 = *(a2 - 4);
              *(a2 - 4) = v41;
              *unint64_t v34 = v39;
              *(a2 - 3) = v36;
              float v42 = *v34;
              float v43 = v10[3];
              if (*v34 > v43)
              {
                int v44 = *((_DWORD *)v10 + 2);
                v10[2] = *v37;
                *(_DWORD *)unsigned int v37 = v44;
                v10[3] = v42;
                *unint64_t v34 = v43;
              }
            }
          }
          else
          {
            int v40 = *((_DWORD *)v10 + 2);
            if (v39 <= v36)
            {
              v10[2] = *v37;
              *(_DWORD *)unsigned int v37 = v40;
              v10[3] = v36;
              *unint64_t v34 = v38;
              float v48 = *(a2 - 3);
              if (v48 <= v38) {
                goto LABEL_38;
              }
              *unsigned int v37 = *(a2 - 4);
              *((_DWORD *)a2 - 4) = v40;
              *unint64_t v34 = v48;
            }
            else
            {
              v10[2] = *(a2 - 4);
              *((_DWORD *)a2 - 4) = v40;
              v10[3] = v39;
            }
            *(a2 - 3) = v38;
          }
LABEL_38:
          unsigned int v49 = &v10[2 * v13];
          float v51 = v49[3];
          uint64_t v50 = v49 + 3;
          float v52 = v51;
          unsigned int v53 = v50 - 1;
          float v54 = v10[5];
          float v55 = *(a2 - 5);
          if (v51 <= v54)
          {
            if (v55 > v52)
            {
              float v57 = *v53;
              *unsigned int v53 = *(a2 - 6);
              *(a2 - 6) = v57;
              *uint64_t v50 = v55;
              *(a2 - 5) = v52;
              float v58 = *v50;
              float v59 = v10[5];
              if (*v50 > v59)
              {
                int v60 = *((_DWORD *)v10 + 4);
                v10[4] = *v53;
                *(_DWORD *)unsigned int v53 = v60;
                v10[5] = v58;
                *uint64_t v50 = v59;
              }
            }
          }
          else
          {
            int v56 = *((_DWORD *)v10 + 4);
            if (v55 <= v52)
            {
              v10[4] = *v53;
              *(_DWORD *)unsigned int v53 = v56;
              v10[5] = v52;
              *uint64_t v50 = v54;
              float v61 = *(a2 - 5);
              if (v61 <= v54) {
                goto LABEL_47;
              }
              *unsigned int v53 = *(a2 - 6);
              *((_DWORD *)a2 - 6) = v56;
              *uint64_t v50 = v61;
            }
            else
            {
              v10[4] = *(a2 - 6);
              *((_DWORD *)a2 - 6) = v56;
              v10[5] = v55;
            }
            *(a2 - 5) = v54;
          }
LABEL_47:
          float v62 = *v17;
          float v63 = *v34;
          float v64 = *v50;
          if (*v17 <= *v34)
          {
            int v65 = *(_DWORD *)v14;
            if (v64 > v62)
            {
              int v66 = *(_DWORD *)v53;
              *uint64_t v14 = *v53;
              *(_DWORD *)unsigned int v53 = v65;
              *unint64_t v17 = v64;
              *uint64_t v50 = v62;
              if (v64 > v63)
              {
                int v65 = *(_DWORD *)v37;
                *(_DWORD *)unsigned int v37 = v66;
                *(_DWORD *)uint64_t v14 = v65;
                *unint64_t v34 = v64;
                *unint64_t v17 = v63;
              }
              else
              {
                float v63 = v64;
                int v65 = v66;
              }
            }
            else
            {
              float v63 = *v17;
            }
          }
          else
          {
            int v65 = *(_DWORD *)v37;
            if (v64 <= v62)
            {
              *unsigned int v37 = *v14;
              *(_DWORD *)uint64_t v14 = v65;
              *unint64_t v34 = v62;
              *unint64_t v17 = v63;
              if (v64 > v63)
              {
                int v67 = *(_DWORD *)v53;
                *uint64_t v14 = *v53;
                *(_DWORD *)unsigned int v53 = v65;
                *unint64_t v17 = v64;
                *uint64_t v50 = v63;
                float v63 = v64;
                int v65 = v67;
              }
            }
            else
            {
              *unsigned int v37 = *v53;
              *(_DWORD *)unsigned int v53 = v65;
              *unint64_t v34 = v64;
              *uint64_t v50 = v63;
              int v65 = *(_DWORD *)v14;
              float v63 = v62;
            }
          }
          float v68 = *v10;
          *(_DWORD *)uint64_t v10 = v65;
          *uint64_t v14 = v68;
          int v69 = *((_DWORD *)v10 + 1);
          v10[1] = v63;
          *(_DWORD *)unint64_t v17 = v69;
          --a3;
          if (a4) {
            goto LABEL_34;
          }
LABEL_58:
          float v47 = v10[1];
          float v46 = *v10;
          if (*(v10 - 1) > v47) {
            goto LABEL_59;
          }
          if (v47 > *(a2 - 1))
          {
            uint64_t v83 = v10;
            do
            {
              uint64_t v10 = v83 + 2;
              float v84 = v83[3];
              v83 += 2;
            }
            while (v47 <= v84);
          }
          else
          {
            unint64_t v85 = v10 + 2;
            do
            {
              uint64_t v10 = v85;
              if (v85 >= a2) {
                break;
              }
              float v86 = v85[1];
              v85 += 2;
            }
            while (v47 <= v86);
          }
          uint64_t v87 = a2;
          if (v10 < a2)
          {
            unsigned int v88 = a2;
            do
            {
              uint64_t v87 = v88 - 2;
              float v89 = *(v88 - 1);
              v88 -= 2;
            }
            while (v47 > v89);
          }
          while (v10 < v87)
          {
            float v90 = *v10;
            *uint64_t v10 = *v87;
            *uint64_t v87 = v90;
            int v91 = *((_DWORD *)v10 + 1);
            v10[1] = v87[1];
            *((_DWORD *)v87 + 1) = v91;
            do
            {
              float v92 = v10[3];
              v10 += 2;
            }
            while (v47 <= v92);
            do
            {
              float v93 = *(v87 - 1);
              v87 -= 2;
            }
            while (v47 > v93);
          }
          BOOL v4 = v10 - 2 >= v9;
          BOOL v5 = v10 - 2 == v9;
          if (v10 - 2 != v9)
          {
            *size_t v9 = *(v10 - 2);
            v9[1] = *(v10 - 1);
          }
          a4 = 0;
          *(v10 - 2) = v46;
          *(v10 - 1) = v47;
        }
        float v20 = v10[1];
        long long v21 = &v10[2 * v13 + 1];
        float v22 = *v21;
        if (v20 > *v21)
        {
          int v23 = *(_DWORD *)v14;
          if (v15 <= v20)
          {
            *uint64_t v14 = *v10;
            *(_DWORD *)uint64_t v10 = v23;
            *long long v21 = v20;
            v10[1] = v22;
            float v45 = *(a2 - 1);
            if (v45 <= v22) {
              goto LABEL_33;
            }
            *uint64_t v10 = *(a2 - 2);
            *((_DWORD *)a2 - 2) = v23;
            v10[1] = v45;
          }
          else
          {
            *uint64_t v14 = *(a2 - 2);
            *((_DWORD *)a2 - 2) = v23;
            *long long v21 = v15;
          }
          *(a2 - 1) = v22;
LABEL_33:
          --a3;
          if ((a4 & 1) == 0) {
            goto LABEL_58;
          }
          goto LABEL_34;
        }
        if (v15 <= v20) {
          goto LABEL_33;
        }
        float v28 = *v10;
        *uint64_t v10 = *(a2 - 2);
        *(a2 - 2) = v28;
        v10[1] = v15;
        *(a2 - 1) = v20;
        float v29 = v10[1];
        float v30 = *v21;
        if (v29 <= *v21) {
          goto LABEL_33;
        }
        int v31 = *(_DWORD *)v14;
        *uint64_t v14 = *v10;
        *(_DWORD *)uint64_t v10 = v31;
        *long long v21 = v29;
        v10[1] = v30;
        --a3;
        if ((a4 & 1) == 0) {
          goto LABEL_58;
        }
LABEL_34:
        float v46 = *v10;
        float v47 = v10[1];
LABEL_59:
        CFIndex v70 = v10;
        do
        {
          CFArrayRef v71 = v70;
          v70 += 2;
        }
        while (v71[3] > v47);
        int v72 = a2;
        if (v71 == v10)
        {
          unsigned int v75 = a2;
          while (v70 < v75)
          {
            unsigned int v73 = v75 - 2;
            float v76 = *(v75 - 1);
            v75 -= 2;
            if (v76 > v47) {
              goto LABEL_68;
            }
          }
          unsigned int v73 = v75;
        }
        else
        {
          do
          {
            unsigned int v73 = v72 - 2;
            float v74 = *(v72 - 1);
            v72 -= 2;
          }
          while (v74 <= v47);
        }
LABEL_68:
        uint64_t v10 = v70;
        if (v70 < v73)
        {
          CFHashCode v77 = v73;
          do
          {
            float v78 = *v10;
            *uint64_t v10 = *v77;
            *CFHashCode v77 = v78;
            int v79 = *((_DWORD *)v10 + 1);
            v10[1] = v77[1];
            *((_DWORD *)v77 + 1) = v79;
            do
            {
              float v80 = v10[3];
              v10 += 2;
            }
            while (v80 > v47);
            do
            {
              float v81 = *(v77 - 1);
              v77 -= 2;
            }
            while (v81 <= v47);
          }
          while (v10 < v77);
        }
        if (v10 - 2 != v9)
        {
          *size_t v9 = *(v10 - 2);
          v9[1] = *(v10 - 1);
        }
        *(v10 - 2) = v46;
        *(v10 - 1) = v47;
        if (v70 >= v73) {
          break;
        }
LABEL_79:
        uint64_t result = (float *)sub_19E532C5C(v9, v10 - 2, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v82 = sub_19E533808(v9, v10 - 2);
      uint64_t result = (float *)sub_19E533808(v10, a2);
      if (result) {
        break;
      }
      if (!v82) {
        goto LABEL_79;
      }
    }
    a2 = v10 - 2;
    if (!v82) {
      continue;
    }
    return result;
  }
}

BOOL sub_19E533808(float *a1, float *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v6 = *(a2 - 1);
      float v7 = a1[1];
      if (v6 > v7)
      {
        float v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        a1[1] = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      float v9 = a1[3];
      float v10 = a1[1];
      float v11 = *(a2 - 1);
      if (v9 <= v10)
      {
        if (v11 > v9)
        {
          int v30 = *((_DWORD *)a1 + 2);
          a1[2] = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v30;
          a1[3] = v11;
          *(a2 - 1) = v9;
          float v31 = a1[3];
          float v32 = a1[1];
          if (v31 > v32)
          {
            int v33 = *(_DWORD *)a1;
            *a1 = a1[2];
            *((_DWORD *)a1 + 2) = v33;
            a1[1] = v31;
            a1[3] = v32;
          }
        }
      }
      else
      {
        int v12 = *(_DWORD *)a1;
        if (v11 <= v9)
        {
          *a1 = a1[2];
          *((_DWORD *)a1 + 2) = v12;
          a1[1] = v9;
          a1[3] = v10;
          float v37 = *(a2 - 1);
          if (v37 > v10)
          {
            a1[2] = *(a2 - 2);
            *((_DWORD *)a2 - 2) = v12;
            a1[3] = v37;
            *(a2 - 1) = v10;
          }
        }
        else
        {
          *a1 = *(a2 - 2);
          *((_DWORD *)a2 - 2) = v12;
          a1[1] = v11;
          *(a2 - 1) = v10;
        }
      }
      return result;
    case 4:
      sub_19E521C28(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      sub_19E521C28(a1, a1 + 2, a1 + 4, a1 + 6);
      float v19 = *(a2 - 1);
      float v20 = a1[7];
      if (v19 > v20)
      {
        int v21 = *((_DWORD *)a1 + 6);
        a1[6] = *(a2 - 2);
        *((_DWORD *)a2 - 2) = v21;
        a1[7] = v19;
        *(a2 - 1) = v20;
        float v22 = a1[7];
        float v23 = a1[5];
        if (v22 > v23)
        {
          int v24 = *((_DWORD *)a1 + 4);
          int v25 = *((_DWORD *)a1 + 6);
          *((_DWORD *)a1 + 4) = v25;
          *((_DWORD *)a1 + 6) = v24;
          a1[5] = v22;
          a1[7] = v23;
          float v26 = a1[3];
          if (v22 > v26)
          {
            int v27 = *((_DWORD *)a1 + 2);
            *((_DWORD *)a1 + 2) = v25;
            *((_DWORD *)a1 + 4) = v27;
            a1[3] = v22;
            a1[5] = v26;
            float v28 = a1[1];
            if (v22 > v28)
            {
              float v29 = *a1;
              *(_DWORD *)a1 = v25;
              a1[2] = v29;
              a1[1] = v22;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      float v13 = a1[1];
      uint64_t v14 = a1 + 3;
      float v15 = a1[3];
      float v16 = a1[5];
      if (v15 > v13)
      {
        float v17 = *a1;
        if (v16 <= v15)
        {
          *a1 = a1[2];
          a1[2] = v17;
          a1[1] = v15;
          a1[3] = v13;
          if (v16 <= v13) {
            goto LABEL_28;
          }
          a1[2] = a1[4];
          a1[4] = v17;
          float v18 = a1 + 3;
        }
        else
        {
          *a1 = a1[4];
          a1[4] = v17;
          float v18 = a1 + 1;
        }
        uint64_t v14 = a1 + 5;
        goto LABEL_27;
      }
      if (v16 > v15)
      {
        int v34 = *((_DWORD *)a1 + 2);
        int v35 = *((_DWORD *)a1 + 4);
        *((_DWORD *)a1 + 2) = v35;
        *((_DWORD *)a1 + 4) = v34;
        a1[3] = v16;
        a1[5] = v15;
        if (v16 > v13)
        {
          float v36 = *a1;
          *(_DWORD *)a1 = v35;
          a1[2] = v36;
          float v18 = a1 + 1;
LABEL_27:
          float *v18 = v16;
          *uint64_t v14 = v13;
        }
      }
LABEL_28:
      float v38 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v39 = 0;
      int v40 = 0;
      float v41 = a1 + 4;
      while (1)
      {
        float v43 = v38[1];
        if (v43 > v41[1])
        {
          int v44 = *(_DWORD *)v38;
          uint64_t v45 = v39;
          do
          {
            float v46 = (float *)((char *)a1 + v45);
            v46[6] = *(float *)((char *)a1 + v45 + 16);
            v46[7] = *(float *)((char *)a1 + v45 + 20);
            if (v45 == -16)
            {
              uint64_t v42 = (uint64_t)a1;
              goto LABEL_31;
            }
            v45 -= 8;
          }
          while (v43 > v46[3]);
          uint64_t v42 = (uint64_t)a1 + v45 + 24;
LABEL_31:
          *(_DWORD *)uint64_t v42 = v44;
          *(float *)(v42 + 4) = v43;
          if (++v40 == 8) {
            return v38 + 2 == a2;
          }
        }
        float v41 = v38;
        v39 += 8;
        v38 += 2;
        if (v38 == a2) {
          return 1;
        }
      }
  }
}

void sub_19E533B84(void *a1)
{
  sub_19E5048B0(a1);
  JUMPOUT(0x19F3BDCF0);
}

uint64_t sub_19E533BC0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6)
{
  *(void *)a1 = &unk_1EF0BAEA8;
  uint64_t v8 = a2[1];
  *(void *)(a1 + 8) = *a2;
  float v9 = (void *)(a1 + 8);
  *(void *)(a1 + 16) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = a5[1];
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *a5;
  *(void *)(a1 + 32) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = a4[1];
  *(void *)(a1 + 40) = *a4;
  *(void *)(a1 + 48) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v12 = a3[1];
  *(void *)(a1 + 56) = *a3;
  *(void *)(a1 + 64) = v12;
  float v13 = (uint64_t *)(a1 + 56);
  if (v12) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  unsigned int v14 = (*(uint64_t (**)(void))(*(void *)*a2 + 32))();
  *(unsigned char *)(a1 + 96) = v14;
  *(void *)(a1 + 112) = a6;
  uint64_t v15 = *(void *)(a1 + 72);
  unint64_t v16 = (*(void *)(a1 + 80) - v15) >> 2;
  if (v14 <= v16)
  {
    if (v14 < v16) {
      *(void *)(a1 + 80) = v15 + 4 * v14;
    }
  }
  else
  {
    sub_19E3F9C70(a1 + 72, v14 - v16);
  }
  uint64_t v17 = *v13;
  if (*v13 && *v9)
  {
    float v18 = (*(float (**)(void))(*(void *)*v9 + 48))(*v9);
    std::mutex::lock((std::mutex *)(v17 + 96));
    if (!*(void *)(v17 + 40) && v18 > 0.0)
    {
      *(void *)(v17 + 40) = (unint64_t)v18;
      *(unsigned char *)(v17 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
    std::mutex::unlock((std::mutex *)(v17 + 96));
  }
  return a1;
}

void sub_19E533D70(_Unwind_Exception *a1)
{
  uint64_t v8 = *v6;
  if (*v6)
  {
    *(void *)(v1 + 80) = v8;
    operator delete(v8);
  }
  sub_19E3D73EC(v5);
  sub_19E3D73EC(v4);
  sub_19E3D73EC(v3);
  sub_19E3D73EC(v2);
  _Unwind_Resume(a1);
}

void sub_19E533DAC(uint64_t a1, int a2, double *a3, int a4, _DWORD *a5, unint64_t a6, void **a7)
{
  if (!a4) {
    return;
  }
  unsigned int v14 = &a5[a6];
  unint64_t v15 = *(unsigned __int8 *)(a1 + 96);
  unint64_t v16 = v15 - 1;
  BOOL v17 = a6 >= v15;
  if (a6 < v15) {
    unint64_t v16 = a6;
  }
  float v18 = &v14[1 - v15];
  if (!v17) {
    float v18 = a5;
  }
  if (!v16)
  {
LABEL_10:
    if (a4 < 0) {
      return;
    }
    double Current = CFAbsoluteTimeGetCurrent();
    if (a3)
    {
      double v21 = fmin(*a3, Current);
      uint64_t v22 = *(void *)(a1 + 24);
      float v23 = floor((Current - v21) / *(float *)(v22 + 212));
      float v24 = expf(*(float *)(v22 + 208) * v23);
      if (v24 <= *(float *)(v22 + 316)) {
        return;
      }
    }
    else
    {
      uint64_t v22 = *(void *)(a1 + 24);
      float v24 = 1.0;
      double v21 = Current;
    }
    sub_19E4F99F4(__dst, (long long *)(v22 + 88));
    if (&v47 != (long long *)a7)
    {
      char v25 = *((unsigned char *)a7 + 23);
      if (SHIBYTE(v48) < 0)
      {
        if (v25 >= 0) {
          float v26 = a7;
        }
        else {
          float v26 = *a7;
        }
        if (v25 >= 0) {
          size_t v27 = *((unsigned __int8 *)a7 + 23);
        }
        else {
          size_t v27 = (size_t)a7[1];
        }
        sub_19E3C6D44((void **)&v47, v26, v27);
      }
      else if ((*((unsigned char *)a7 + 23) & 0x80) != 0)
      {
        sub_19E3C6C7C(&v47, *a7, (size_t)a7[1]);
      }
      else
      {
        long long v47 = *(_OWORD *)a7;
        float v48 = a7[2];
      }
    }
    uint64_t v28 = *(void *)(a1 + 56);
    if (!v28)
    {
LABEL_36:
      uint64_t v32 = *(void *)(a1 + 72);
      unint64_t v33 = *(unsigned __int8 *)(a1 + 96);
      int v34 = &v14[1 - v33];
      if (a6 >= v33)
      {
        unint64_t v35 = v33 - 1;
      }
      else
      {
        int v34 = a5;
        unint64_t v35 = a6;
      }
      float v36 = *(int **)(a1 + 72);
      if (!v35) {
        goto LABEL_49;
      }
      float v37 = v34;
      unint64_t v38 = (v35 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v38 < 7)
      {
        float v36 = *(int **)(a1 + 72);
      }
      else
      {
        float v36 = *(int **)(a1 + 72);
        if ((unint64_t)(v32 - (void)v34) >= 0x20)
        {
          uint64_t v39 = (v38 + 1) & 0x7FFFFFFFFFFFFFF8;
          float v36 = (int *)(v32 + 4 * v39);
          int v40 = v34 + 4;
          float v41 = (_OWORD *)(v32 + 16);
          uint64_t v42 = v39;
          do
          {
            *(void *)&long long v43 = __PAIR64__(HIDWORD(*v40), *(_OWORD *)v40) & 0xFFFFFF00FFFFFFLL;
            DWORD2(v43) = v40[1] & 0xFFFFFF;
            HIDWORD(v43) = HIDWORD(*v40) & 0xFFFFFF;
            *(v41 - 1) = *((_OWORD *)v40 - 1) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL);
            *float v41 = v43;
            v40 += 4;
            v41 += 2;
            v42 -= 8;
          }
          while (v42);
          if (v38 + 1 == v39) {
            goto LABEL_49;
          }
          float v37 = &v34[v39];
        }
      }
      int v44 = &v34[v35];
      do
      {
        int v45 = *v37++;
        *v36++ = v45 & 0xFFFFFF;
      }
      while (v37 != v44);
LABEL_49:
      int *v36 = a4 & 0xFFFFFF;
      (*(void (**)(void, uint64_t, void, char *, float))(**(void **)(a1 + 8) + 120))(*(void *)(a1 + 8), v32, (v35 + 1), __dst, v24);
      sub_19E3D7810((uint64_t)__dst);
      return;
    }
    int v29 = (*(uint64_t (**)(void, char *))(**(void **)(a1 + 8) + 72))(*(void *)(a1 + 8), __dst);
    std::mutex::lock((std::mutex *)(v28 + 96));
    if (a2)
    {
      if (a2 == 1)
      {
        if (v29 == 1)
        {
          int v30 = (double *)(v28 + 72);
          double v31 = *(double *)(v28 + 72);
LABEL_52:
          if (v31 >= v21) {
            goto LABEL_35;
          }
          goto LABEL_34;
        }
        if (v29 == 2)
        {
          int v30 = (double *)(v28 + 80);
          double v31 = *(double *)(v28 + 80);
          goto LABEL_52;
        }
      }
    }
    else
    {
      int v30 = (double *)(v28 + 56);
      if (*(double *)(v28 + 56) == 0.0) {
LABEL_34:
      }
        *int v30 = v21;
    }
LABEL_35:
    *(unsigned char *)(v28 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    *(int64x2_t *)(v28 + 32) = vaddq_s64(*(int64x2_t *)(v28 + 32), vdupq_n_s64(1uLL));
    std::mutex::unlock((std::mutex *)(v28 + 96));
    goto LABEL_36;
  }
  uint64_t v19 = 4 * v16;
  while (*v18)
  {
    ++v18;
    v19 -= 4;
    if (!v19) {
      goto LABEL_10;
    }
  }
}

void sub_19E5340C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3D7810((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_19E5340DC(uint64_t a1, int a2, uint64_t a3, unint64_t a4)
{
  uint64_t v6 = *(void *)(a1 + 72);
  unint64_t v7 = *(unsigned __int8 *)(a1 + 96);
  uint64_t v8 = a3 + 4 * a4 + 4 * (1 - v7);
  if (a4 >= v7)
  {
    unint64_t v9 = v7 - 1;
  }
  else
  {
    uint64_t v8 = a3;
    unint64_t v9 = a4;
  }
  uint64_t v10 = *(int **)(a1 + 72);
  if (v9)
  {
    uint64_t v11 = (int *)v8;
    unint64_t v12 = (v9 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    if (v12 < 7)
    {
      uint64_t v10 = *(int **)(a1 + 72);
LABEL_12:
      float v18 = (int *)(v8 + 4 * v9);
      do
      {
        int v19 = *v11++;
        *v10++ = v19 & 0xFFFFFF;
      }
      while (v11 != v18);
      goto LABEL_14;
    }
    uint64_t v10 = *(int **)(a1 + 72);
    if ((unint64_t)(v6 - v8) < 0x20) {
      goto LABEL_12;
    }
    uint64_t v13 = (v12 + 1) & 0x7FFFFFFFFFFFFFF8;
    uint64_t v10 = (int *)(v6 + 4 * v13);
    unsigned int v14 = (void *)(v8 + 16);
    unint64_t v15 = (_OWORD *)(v6 + 16);
    uint64_t v16 = v13;
    do
    {
      *(void *)&long long v17 = __PAIR64__(HIDWORD(*v14), *(_OWORD *)v14) & 0xFFFFFF00FFFFFFLL;
      DWORD2(v17) = v14[1] & 0xFFFFFF;
      HIDWORD(v17) = HIDWORD(*v14) & 0xFFFFFF;
      *(v15 - 1) = *((_OWORD *)v14 - 1) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL);
      *unint64_t v15 = v17;
      v14 += 4;
      v15 += 2;
      v16 -= 8;
    }
    while (v16);
    if (v12 + 1 != v13)
    {
      uint64_t v11 = (int *)(v8 + 4 * v13);
      goto LABEL_12;
    }
  }
LABEL_14:
  *uint64_t v10 = a2 & 0xFFFFFF;
  (*(void (**)(void, uint64_t, void, uint64_t))(**(void **)(a1 + 8) + 128))(*(void *)(a1 + 8), v6, (v9 + 1), *(void *)(a1 + 24) + 88);
  uint64_t v20 = *(void *)(a1 + 56);
  if (v20)
  {
    std::mutex::lock((std::mutex *)(v20 + 96));
    *(unsigned char *)(v20 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    v21.i64[0] = -1;
    v21.i64[1] = -1;
    *(int64x2_t *)(v20 + 32) = vaddq_s64(*(int64x2_t *)(v20 + 32), v21);
    std::mutex::unlock((std::mutex *)(v20 + 96));
  }
}

uint64_t sub_19E534244(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, double *a5, uint64_t a6, int a7)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1[1] + 56))(a1[1]);
  if (!v13) {
    return v13;
  }
  uint64_t v14 = a1[5];
  if (v14) {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v14 + 144))(v14, a2);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = a1[9];
  unint64_t v17 = *((unsigned __int8 *)a1 + 96);
  uint64_t v18 = a3 + 4 * a4 + 4 * (1 - v17);
  if (a4 >= v17) {
    a4 = v17 - 1;
  }
  else {
    uint64_t v18 = a3;
  }
  if (a4)
  {
    int v19 = (int *)v18;
    unint64_t v20 = (a4 - 1) & 0x3FFFFFFFFFFFFFFFLL;
    if (v20 < 7)
    {
      int64x2_t v21 = (int *)a1[9];
    }
    else
    {
      int64x2_t v21 = (int *)a1[9];
      if ((unint64_t)(v16 - v18) >= 0x20)
      {
        uint64_t v22 = (v20 + 1) & 0x7FFFFFFFFFFFFFF8;
        int64x2_t v21 = (int *)(v16 + 4 * v22);
        float v23 = (void *)(v18 + 16);
        float v24 = (_OWORD *)(v16 + 16);
        uint64_t v25 = v22;
        do
        {
          *(void *)&long long v26 = __PAIR64__(HIDWORD(*v23), *(_OWORD *)v23) & 0xFFFFFF00FFFFFFLL;
          DWORD2(v26) = v23[1] & 0xFFFFFF;
          HIDWORD(v26) = HIDWORD(*v23) & 0xFFFFFF;
          *(v24 - 1) = *((_OWORD *)v23 - 1) & __PAIR128__(0xFFFFFF00FFFFFFLL, 0xFFFFFF00FFFFFFLL);
          *float v24 = v26;
          v23 += 4;
          v24 += 2;
          v25 -= 8;
        }
        while (v25);
        if (v20 + 1 == v22) {
          goto LABEL_19;
        }
        int v19 = (int *)(v18 + 4 * v22);
      }
    }
    size_t v27 = (int *)(v18 + 4 * a4);
    do
    {
      int v28 = *v19++;
      *v21++ = v28 & 0xFFFFFF;
    }
    while (v19 != v27);
  }
  else
  {
    int64x2_t v21 = (int *)a1[9];
  }
LABEL_19:
  *int64x2_t v21 = a2 & 0xFFFFFF;
  unint64_t v29 = a4 + 1;
  *a5 = 0.0;
  if (a2 == 2) {
    unsigned int v30 = 2;
  }
  else {
    unsigned int v30 = 1;
  }
  uint64_t v44 = 0;
  if (v30 <= v29)
  {
    uint64_t v31 = v16 + 4 * v29;
    uint64_t v32 = a1[3];
    float v33 = 0.0;
    while (1)
    {
      if (v15 == 1)
      {
        uint64_t v35 = 0;
      }
      else if (*(unsigned char *)(v32 + 401))
      {
        uint64_t v35 = 2;
      }
      else
      {
        uint64_t v35 = 1;
      }
      (*(void (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, uint64_t *))(*(void *)a1[1] + 104))(a1[1], v31 - 4 * (a4 + 1), (a4 + 1), v32 + 88, v35, (char *)&v44 + 4, &v44);
      uint64_t v36 = *a1;
      if ((a4 + 1) < 2) {
        float v37 = (*(float (**)(uint64_t *, uint64_t))(v36 + 24))(a1, v15);
      }
      else {
        (*(void (**)(uint64_t *, uint64_t))(v36 + 16))(a1, v15);
      }
      if (*((float *)&v44 + 1) >= v37 && *(float *)&v44 > 0.0)
      {
        if ((a4 + 1) >= 2)
        {
          uint64_t v38 = a1[3];
LABEL_39:
          float v39 = *(float *)(*(void *)(v38 + 264) + 4 * (a4 + 1) - 4);
          double v40 = (float)(*((float *)&v44 + 1) / *(float *)&v44);
          uint64_t v41 = *(void *)(a6 + 24);
          if (v41)
          {
            uint64_t v45 = a4;
            double v40 = (*(double (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v45) * v40;
          }
          *a5 = *a5 + fmin(v40, 1.0) * v39;
          goto LABEL_25;
        }
        if (a7)
        {
          uint64_t v38 = a1[3];
          if (*(float *)&v44 > *(float *)(v38 + 300)) {
            goto LABEL_39;
          }
        }
      }
LABEL_25:
      uint64_t v32 = a1[3];
      float v33 = *(float *)(*(void *)(v32 + 264) + 4 * (a4 + 1) - 4) + v33;
      BOOL v34 = a4 >= v30;
      LODWORD(a4) = a4 - 1;
      if (!v34)
      {
        if (v33 > 0.0) {
          *a5 = *a5 / v33;
        }
        return v13;
      }
    }
  }
  return v13;
}

void sub_19E5345CC(uint64_t a1, void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(void *)a1 = &unk_1EF0BC170;
  *(void *)(a1 + 8) = a2;
  uint64_t v10 = a2[4];
  *(void *)(a1 + 16) = a2[3];
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v11 = a2[6];
  *(void *)(a1 + 32) = a2[5];
  *(void *)(a1 + 40) = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = a5;
  *(void *)(a1 + 64) = a6;
  int v12 = (*(uint64_t (**)(void *))(*a2 + 48))(a2);
  *(_DWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 72) = v12;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  if (4 * a4)
  {
    if (4 * a4 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v13 = (char *)operator new(4 * a4);
    *(void *)(a1 + 104) = v13;
    *(void *)(a1 + 112) = v13;
    uint64_t v14 = &v13[4 * ((4 * a4) >> 2)];
    *(void *)(a1 + 120) = v14;
    if (a4) {
      memmove(v13, a3, 4 * a4);
    }
    *(void *)(a1 + 112) = v14;
  }
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 176) = 0;
  uint64_t v15 = operator new(0x20uLL);
  *uint64_t v15 = &unk_1EF0BD508;
  v15[1] = sub_19E53492C;
  v15[2] = 0;
  v15[3] = a1;
  *(void *)(a1 + 176) = v15;
  (*(void (**)(void, const void *, uint64_t, uint64_t, uint64_t, uint64_t, void))(**(void **)(*(void *)(a1 + 8) + 8)
                                                                                           + 104))(*(void *)(*(void *)(a1 + 8) + 8), a3, a4, a2[3] + 88, 1, a1 + 88, 0);
  operator new();
}

void sub_19E534820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  MEMORY[0x19F3BDCF0](v15, 0x1020C4016EE4530);
  sub_19E5348A8(v16);
  uint64_t v18 = *v14;
  if (*v14)
  {
    *(void *)(v11 + 136) = v18;
    operator delete(v18);
  }
  int v19 = *a10;
  if (*a10)
  {
    *(void *)(v11 + 112) = v19;
    operator delete(v19);
  }
  sub_19E532C04(v13);
  sub_19E3D73EC(v12);
  sub_19E3D73EC(v10);
  _Unwind_Resume(a1);
}

void *sub_19E5348A8(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL sub_19E53492C(uint64_t a1, float *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    return a2[2] >= *(float *)(*(void *)(a1 + 16) + 256);
  }
  int v5 = (*(uint64_t (**)(uint64_t, void))(*(void *)v4 + 144))(v4, *(unsigned int *)a2);
  uint64_t v6 = *(void *)(a1 + 16);
  float v7 = a2[2];
  if (v5 != 1) {
    return v7 >= *(float *)(v6 + 256);
  }
  if (v7 >= *(float *)(v6 + 216)) {
    return a2[1] == 1.0;
  }
  return 0;
}

void *sub_19E5349E0()
{
  return &unk_1EF0B8020;
}

uint64_t sub_19E5349EC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "NSt3__16__bindIMN2LM40DynamicLanguageModelPredictionEnumeratorEKFbRKNS1_15NgramPredictionEEJPS2_RKN"
                     "S_12placeholders4__phILi1EEEEEE"
    || ((v3 & (unint64_t)"NSt3__16__bindIMN2LM40DynamicLanguageModelPredictionEnumeratorEKFbRKNS1_15NgramPredictio"
                                "nEEJPS2_RKNS_12placeholders4__phILi1EEEEEE" & 0x8000000000000000) != 0) != __OFSUB__(v3, "NSt3__16__bindIMN2LM40DynamicLanguageModelPredictionEnumeratorEKFbRKNS1_15NgramPredictionEEJPS2_RKNS_12placeholders4__phILi1EEEEEE")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"NSt3__16__bindIMN2LM40DynamicLanguageModelPredictionEnumeratorEKFbRKNS1_15NgramPredictionEEJPS2_RKNS_12placeholders4__phILi1EEEEEE" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E534A44(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  unint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

__n128 sub_19E534A94(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BD508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E534AC4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF0BD508;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void sub_19E534B18()
{
}

double sub_19E534B30(uint64_t a1)
{
  return *(double *)(a1 + 8);
}

uint64_t sub_19E534B38(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  if (!a4) {
    return 1;
  }
  unsigned int v4 = HIWORD(a2);
  unsigned int v5 = *(_DWORD *)(a1 + 56);
  if (HIWORD(a2) >= v5) {
    return 1;
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = (int *)(v8 + 4 * *(unsigned int *)(v9 + 4 * v4));
  unsigned int v11 = v5 - 1;
  if (v4 == v5 - 1)
  {
    uint64_t v12 = (int *)(*(void *)(a1 + 24) + *(void *)(a1 + 32));
    if (v10 == v12) {
      return 1;
    }
  }
  else
  {
    uint64_t v12 = (int *)(v8 + 4 * *(unsigned int *)(v9 + 4 * (v4 + 1)));
    if (v10 == v12) {
      return 1;
    }
  }
  uint64_t v14 = a1 + 16;
  unint64_t v15 = v12 - v10;
  do
  {
    unint64_t v16 = v15 >> 1;
    unint64_t v17 = &v10[v15 >> 1];
    unsigned int v18 = *((unsigned __int16 *)v17 + 1);
    int v19 = v17 + 1;
    v15 += ~(v15 >> 1);
    if (v18 < (unsigned __int16)a2) {
      uint64_t v10 = v19;
    }
    else {
      unint64_t v15 = v16;
    }
  }
  while (v15);
  if (v10 >= v12) {
    return 1;
  }
  int v20 = *v10;
  if ((*v10 ^ (a2 << 16)) >> 16) {
    return 1;
  }
  unint64_t v21 = *(unsigned int *)(a3 + 4 * a4 - 4);
  unint64_t v22 = v21 >> 16;
  if (HIWORD(*(_DWORD *)(a3 + 4 * a4 - 4)) >= v5) {
    return 1;
  }
  float v23 = (unsigned int *)(v8 + 4 * *(unsigned int *)(v9 + 4 * v22));
  float v24 = (unsigned int *)(v22 == v11
                       ? *(void *)(a1 + 24) + *(void *)(a1 + 32)
                       : v8 + 4 * *(unsigned int *)(v9 + 4 * (v22 + 1)));
  if (v23 == v24) {
    return 1;
  }
  unsigned __int16 v25 = v20;
  unint64_t v26 = v24 - v23;
  do
  {
    unint64_t v27 = v26 >> 1;
    int v28 = &v23[v26 >> 1];
    unsigned int v29 = *((unsigned __int16 *)v28 + 1);
    unsigned int v30 = v28 + 1;
    v26 += ~(v26 >> 1);
    if (v29 < (unsigned __int16)*(_DWORD *)(a3 + 4 * a4 - 4)) {
      float v23 = v30;
    }
    else {
      unint64_t v26 = v27;
    }
  }
  while (v26);
  if (v23 >= v24) {
    return 1;
  }
  unsigned int v31 = *v23;
  if ((v31 ^ (v21 << 16)) >> 16) {
    return 1;
  }
  unsigned __int16 v32 = v31;
  unsigned __int16 v49 = v31;
  if ((v20 & 0x80) != 0
    && (v20 & 0x1200) != 0
    && a4 >= 2
    && (v31 & 0x100) != 0
    && (*(_DWORD *)(a3 + 4 * a4 - 8) == 1 || a4 >= 3 && *(_DWORD *)(a3 + 4 * a4 - 12) == 1))
  {
    if ((v20 & 0x7000) != 0 && (v31 & 0x7000) != 0) {
      return 1;
    }
    if ((v20 & 0xE00) != 0)
    {
      BOOL v33 = (v31 & 0xE00) == 0;
      return !v33;
    }
    return 0;
  }
  if ((v20 & 0x100) != 0)
  {
    if (a4 >= 2 && (v31 & 4) != 0 && *(_DWORD *)(a3 + 4 * a4 - 8) == 1) {
      return 0;
    }
    if ((v31 & 0x50) != 0)
    {
      __int16 v34 = v20 & v31;
LABEL_65:
      BOOL v33 = (v34 & 0x7E00) == 0;
      return !v33;
    }
  }
  if ((v20 & 0x10) == 0) {
    return 1;
  }
  if (a4 >= 2 && (v31 & 0x6100) == 0x6100)
  {
    unint64_t v35 = *(unsigned int *)(a3 + 4 * a4 - 8);
    unint64_t v36 = v35 >> 16;
    if (HIWORD(*(_DWORD *)(a3 + 4 * a4 - 8)) < v5)
    {
      float v37 = (int *)(v8 + 4 * *(unsigned int *)(v9 + 4 * v36));
      uint64_t v38 = (int *)(v36 == v11
                  ? *(void *)(a1 + 24) + *(void *)(a1 + 32)
                  : v8 + 4 * *(unsigned int *)(v9 + 4 * (v36 + 1)));
      if (v37 != v38)
      {
        unint64_t v39 = v38 - v37;
        do
        {
          unint64_t v40 = v39 >> 1;
          uint64_t v41 = &v37[v39 >> 1];
          unsigned int v42 = *((unsigned __int16 *)v41 + 1);
          long long v43 = v41 + 1;
          v39 += ~(v39 >> 1);
          if (v42 < (unsigned __int16)*(_DWORD *)(a3 + 4 * a4 - 8)) {
            float v37 = v43;
          }
          else {
            unint64_t v39 = v40;
          }
        }
        while (v39);
        if (v37 < v38)
        {
          int v44 = *v37;
          if (!((*v37 ^ (v35 << 16)) >> 16))
          {
            unsigned __int16 v32 = *v37;
            unsigned __int16 v49 = v32;
            if ((v44 & 0x40) != 0) {
              goto LABEL_64;
            }
          }
        }
      }
    }
  }
  if ((v32 & 0x140) != 0)
  {
LABEL_64:
    __int16 v34 = v32 & v25;
    goto LABEL_65;
  }
  if ((v32 & 0x20) == 0)
  {
LABEL_70:
    if (a4 >= 2 && (v32 & 2) != 0)
    {
      int v45 = sub_19E4FA2D8(v14, *(_DWORD *)(a3 + 4 * a4 - 8), &v49);
      unsigned __int16 v32 = v49;
      if (v45)
      {
        if ((v49 & 0x10) != 0) {
          goto LABEL_64;
        }
      }
    }
    goto LABEL_85;
  }
  if (a4 >= 2)
  {
    int v46 = sub_19E4FA2D8(a1 + 16, *(_DWORD *)(a3 + 4 * a4 - 8), &v49);
    unsigned __int16 v32 = v49;
    if (v46)
    {
      if ((v49 & 0x100) != 0) {
        goto LABEL_64;
      }
      if ((v49 & 1) == 0) {
        return 1;
      }
      if ((v49 & 0x7000) != 0 && (v25 & 0x7000) != 0 || (uint64_t result = 0, (v49 & 0xE00) != 0) && (v25 & 0xE00) != 0)
      {
        if (a4 < 3) {
          return 1;
        }
        unsigned int v47 = *(_DWORD *)(a3 + 4 * a4 - 12);
        goto LABEL_98;
      }
      return result;
    }
    goto LABEL_70;
  }
LABEL_85:
  if ((v32 & 1) == 0) {
    return (v32 & 0x10) == 0 || (v32 & v25 & 0x7E00) != 0;
  }
  if ((v32 & 0x7000) != 0 && (v25 & 0x7000) != 0)
  {
    if (a4 < 2) {
      return 1;
    }
    goto LABEL_97;
  }
  BOOL v48 = (v32 & 0xE00) == 0;
  if ((v25 & 0xE00) == 0) {
    BOOL v48 = 1;
  }
  uint64_t result = !v48;
  if (!v48 && a4 >= 2)
  {
LABEL_97:
    unsigned int v47 = *(_DWORD *)(a3 + 4 * a4 - 8);
LABEL_98:
    if (!sub_19E4FA2D8(v14, v47, &v49)) {
      return 1;
    }
    unsigned __int16 v32 = v49;
    if ((v49 & 0x100) == 0) {
      return 1;
    }
    goto LABEL_64;
  }
  return result;
}

void sub_19E534F48(void *a1)
{
  *a1 = &unk_1EF0BBF90;
  a1[2] = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {
    munmap(v2, a1[4]);
  }
  a1[4] = 0;
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E534FE0(void *a1)
{
  *a1 = &unk_1EF0BBF90;
  a1[2] = &unk_1EF0B99D8;
  uint64_t v2 = (void *)a1[3];
  if (v2) {
    munmap(v2, a1[4]);
  }
  a1[4] = 0;
  return a1;
}

BOOL sub_19E535058()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  int v0 = 16;
  while (1)
  {
    std::istream::tellg();
    uint64_t v1 = v6;
    if (v6 < 0) {
      break;
    }
    if ((v6 & 0xF) != 0)
    {
      std::istream::read();
      if (--v0) {
        continue;
      }
    }
    return v1 >= 0;
  }
  char v5 = 5;
  strcpy((char *)__p, "ERROR");
  uint64_t v2 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v2, (uint64_t)": ", 2);
  sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"AlignInput: can't determine stream position", 43);
  sub_19E43C8CC();
  if (v5 < 0) {
    operator delete(__p[0]);
  }
  return v1 >= 0;
}

void sub_19E53516C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t sub_19E5351A0(void *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  int v2 = 16;
  while (1)
  {
    unint64_t v3 = (char *)a1 + *(void *)(*a1 - 24);
    if ((v3[32] & 5) != 0) {
      break;
    }
    (*(void (**)(void **__return_ptr))(**((void **)v3 + 5) + 32))(__p);
    if (v8 < 0) {
      break;
    }
    if ((v8 & 0xF) != 0)
    {
      std::ostream::write();
      if (--v2) {
        continue;
      }
    }
    return 1;
  }
  char v7 = 5;
  strcpy((char *)__p, "ERROR");
  char v5 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v5, (uint64_t)": ", 2);
  sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"AlignOutput: can't determine stream position", 44);
  sub_19E43C8CC();
  if (v7 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_19E535308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void *sub_19E53533C()
{
  return &unk_1EF0B4B88;
}

uint64_t sub_19E535348(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v133enumerateComparableLexiconEntriesERKNSt3__16vectorINS1_10unique_ptrIN2LM7"
                     "LexiconENS1_14default_deleteIS5_EEEENS1_9allocatorIS8_EEEERKNS1_12basic_stringIcNS1_11char_traitsIc"
                     "EENS9_IcEEEEmRKNS1_8functionIFvPK10__CFStringjdNS4_13SourceLexiconEPK10__CFLocaleRbEEEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v133enumerateComparableLexiconEntriesERKNSt3__16vectorINS1_10uniqu"
                                "e_ptrIN2LM7LexiconENS1_14default_deleteIS5_EEEENS1_9allocatorIS8_EEEERKNS1_12basic_strin"
                                "gIcNS1_11char_traitsIcEENS9_IcEEEEmRKNS1_8functionIFvPK10__CFStringjdNS4_13SourceLexicon"
                                "EPK10__CFLocaleRbEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v133enumerateComparableLexiconEntriesERKNSt3__16vectorINS1_10unique_ptrIN2LM7LexiconENS1_14default_deleteIS5_EEEENS1_9allocatorIS8_EEEERKNS1_12basic_stringIcNS1_11char_traitsIcEENS9_IcEEEEmRKNS1_8functionIFvPK10__CFStringjdNS4_13SourceLexiconEPK10__CFLocaleRbEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v133enumerateComparableLexiconEntriesERKNSt3__16vectorINS1_10unique_ptrIN2LM7LexiconENS1_14default_deleteIS5_EEEENS1_9allocatorIS8_EEEERKNS1_12basic_stringIcNS1_11char_traitsIcEENS9_IcEEEEmRKNS1_8functionIFvPK10__CFStringjdNS4_13SourceLexiconEPK10__CFLocaleRbEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFComparisonResult sub_19E5353A0(uint64_t a1, const __CFString **a2, int *a3, uint64_t *a4, int *a5, const __CFLocale **a6, uint64_t a7)
{
  CFStringRef v9 = *a2;
  int v10 = *a3;
  uint64_t v11 = *a4;
  int v12 = *a5;
  CFLocaleRef v13 = *a6;
  uint64_t v14 = *(void **)(a1 + 8);
  if (!*v14)
  {
    unint64_t v15 = *(const UInt8 **)(a1 + 16);
    if ((char)v15[23] < 0)
    {
      if (!*(void *)v15)
      {
        *uint64_t v14 = 0;
        goto LABEL_10;
      }
      CFIndex v16 = *((void *)v15 + 1);
      unint64_t v15 = *(const UInt8 **)v15;
    }
    else
    {
      CFIndex v16 = v15[23];
    }
    CFStringRef v17 = CFStringCreateWithBytes(0, v15, v16, 0x8000100u, 0);
    if (!v17)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
    CFStringRef v18 = v17;
    int v19 = *(const void ***)(a1 + 8);
    int v20 = *v19;
    *int v19 = v18;
    if (v20) {
      CFRelease(v20);
    }
  }
LABEL_10:
  CFStringRef v21 = **(const __CFString ***)(a1 + 8);
  v31.length = CFStringGetLength(v21);
  v31.location = 0;
  CFComparisonResult result = CFStringCompareWithOptionsAndLocale(v21, v9, v31, **(void **)(a1 + 24), v13);
  if (result == kCFCompareEqualTo)
  {
    uint64_t v23 = *(void *)(a1 + 32);
    CFStringRef v30 = v9;
    int v29 = v10;
    uint64_t v28 = v11;
    int v27 = v12;
    CFLocaleRef v26 = v13;
    uint64_t v24 = *(void *)(v23 + 24);
    if (!v24) {
      sub_19E3ACB9C();
    }
    return (*(uint64_t (**)(uint64_t, const __CFString **, int *, uint64_t *, int *, const __CFLocale **, uint64_t))(*(void *)v24 + 48))(v24, &v30, &v29, &v28, &v27, &v26, a7);
  }
  return result;
}

void sub_19E535534(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

__n128 sub_19E535554(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5088;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E535584(uint64_t a1)
{
  int v2 = (char *)operator new(0x28uLL);
  *(void *)int v2 = &unk_1EF0B5088;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  return result;
}

void sub_19E5355D8()
{
}

BOOL sub_19E5355F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFIndex v4 = *(unsigned __int8 *)(a2 + 23);
  if ((v4 & 0x80u) != 0) {
    a2 = *(void *)a2;
  }
  if (a2)
  {
    if ((v4 & 0x80u) == 0) {
      CFIndex v5 = v4;
    }
    else {
      CFIndex v5 = *(void *)(v2 + 8);
    }
    CFTypeRef cf = CFStringCreateWithBytes(0, (const UInt8 *)a2, v5, 0x8000100u, 0);
    if (!cf)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFTypeRef cf = 0;
  }
  unsigned __int8 v9 = 0;
  v11[0] = &unk_1EF0B5190;
  v11[1] = &cf;
  v11[2] = &v9;
  int v12 = v11;
  sub_19E3FCB90(a1, v2, 1, (uint64_t)v11);
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  int v7 = v9;
  if (cf) {
    CFRelease(cf);
  }
  return v7 != 0;
}

void sub_19E535790(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E5357A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, int a12, __int16 a13, char a14, char a15)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E5357D0()
{
  return &unk_1EF0B8098;
}

uint64_t sub_19E5357DC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v134isOneWayCaseEquivalentLexiconMatchERKN2LM22CompositeLanguageModelERKNSt3_"
                     "_112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS1_22TokenEnumerationPolicyEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v134isOneWayCaseEquivalentLexiconMatchERKN2LM22CompositeLanguageMo"
                                "delERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS1_22TokenEnumera"
                                "tionPolicyEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v134isOneWayCaseEquivalentLexiconMatchERKN2LM22CompositeLanguageModelERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS1_22TokenEnumerationPolicyEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v134isOneWayCaseEquivalentLexiconMatchERKN2LM22CompositeLanguageModelERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEENS1_22TokenEnumerationPolicyEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

CFComparisonResult sub_19E535834(uint64_t a1, const __CFString **a2, uint64_t a3, uint64_t a4, uint64_t a5, const __CFLocale **a6, unsigned char *a7)
{
  CFStringRef v9 = *a2;
  CFLocaleRef v10 = *a6;
  BOOL v11 = sub_19E5358CC(*a2, *a6);
  CFStringRef v12 = **(const __CFString ***)(a1 + 8);
  v14.length = CFStringGetLength(v12);
  v14.location = 0;
  CFComparisonResult result = CFStringCompareWithOptionsAndLocale(v12, v9, v14, v11, v10);
  if (result == kCFCompareEqualTo)
  {
    **(unsigned char **)(a1 + 16) = 1;
    *a7 = 1;
  }
  return result;
}

BOOL sub_19E5358CC(const __CFString *a1, const __CFLocale *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Length = CFStringGetLength(a1);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v4, Length, a1);
  CFStringLowercase(MutableCopy, a2);
  sub_19E372124(&theString2, MutableCopy);
  CFComparisonResult v7 = CFStringCompare(a1, theString2, 0);
  if (theString2) {
    CFRelease(theString2);
  }
  return v7 == kCFCompareEqualTo;
}

void sub_19E535964(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3C6F1C((const void **)va);
  _Unwind_Resume(a1);
}

__n128 sub_19E535980(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E5359A8(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF0B5190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_19E5359F4()
{
}

BOOL sub_19E535A0C(CFStringRef *a1, const __CFLocale *a2)
{
  CFStringRef v4 = *a1;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Length = CFStringGetLength(*a1);
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v5, Length, v4);
  CFStringUppercase(MutableCopy, a2);
  sub_19E372124(&theString2, MutableCopy);
  CFComparisonResult v8 = CFStringCompare(*a1, theString2, 0);
  if (theString2) {
    CFRelease(theString2);
  }
  return v8 == kCFCompareEqualTo;
}

void sub_19E535AAC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3C6F1C((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E535AC0(unsigned int a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(*(void *)(a2 + 232) + 288) <= a1) {
    return 0;
  }
  uint64_t v9 = 0;
  __int16 v10 = 0;
  char v11 = 1;
  long long v12 = xmmword_19E572FD0;
  int v13 = 0;
  long long v14 = xmmword_19E572FD0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v15 = 0xFFEFFFFFFFFFFFFFLL;
  __n128 v4 = 0uLL;
  memset(v7, 0, sizeof(v7));
  int64x2_t v8 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  if (qword_1EC009490 != -1) {
    dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
  }
  int v19 = 0;
  unsigned int v5 = sub_19E413378(a2, a1 | ((unint64_t)a1 << 32), (uint64_t *)v7, (uint64_t)&v8, qword_1EC009488, 0, 0, v18, v4);
  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void *))(*v19 + 40))(v19);
  }
  if (*(double *)v8.i64 >= -3.0) {
    return v5;
  }
  else {
    return 0;
  }
}

void sub_19E535C48(_Unwind_Exception *a1)
{
  sub_19E3C76B8((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_19E535C5C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v12 = 0;
  std::istream::read();
  char v11 = 5;
  strcpy((char *)__p, "ERROR");
  __n128 v4 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)__p, 5);
  sub_19E37CA70(v4, (uint64_t)": ", 2);
  unsigned int v5 = sub_19E37CA70(MEMORY[0x1E4FBA240], (uint64_t)"FstHeader::Read: Bad FST header: ", 33);
  int v6 = *(char *)(a3 + 23);
  if (v6 >= 0) {
    uint64_t v7 = a3;
  }
  else {
    uint64_t v7 = *(void *)a3;
  }
  if (v6 >= 0) {
    uint64_t v8 = *(unsigned __int8 *)(a3 + 23);
  }
  else {
    uint64_t v8 = *(void *)(a3 + 8);
  }
  sub_19E37CA70(v5, v7, v8);
  sub_19E43C8CC();
  if (v11 < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void sub_19E535F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL sub_19E535F74(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, double *a5, unint64_t *a6, uint64_t a7)
{
  uint64_t v7 = *(void *)(a1 + 152);
  if (v7)
  {
    unint64_t v11 = *(void *)(a1 + 16);
    if (a4 >= v11) {
      uint64_t v12 = a3 + 4 * a4 + 4 * (1 - v11);
    }
    else {
      uint64_t v12 = a3;
    }
    if (a4 >= v11) {
      unint64_t v13 = v11 - 1;
    }
    else {
      unint64_t v13 = a4;
    }
    double v14 = *(double *)(a1 + 32);
    int v47 = *(_DWORD *)(a1 + 48);
    if (v13)
    {
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      char v18 = 0;
      do
      {
        unsigned int v20 = *(_DWORD *)(v12 + 4 * v16);
        if (*(unsigned char *)(a1 + 288) && (v20 < *(_DWORD *)(a1 + 280) || v20 > *(_DWORD *)(a1 + 284)))
        {
          if (v20 <= *(_DWORD *)(a1 + 24)) {
            int v21 = *(_DWORD *)(v12 + 4 * v16);
          }
          else {
            int v21 = 0;
          }
          *(_DWORD *)(*(void *)(a1 + 184) + 4 * v17) = v21;
          unint64_t v19 = 1;
        }
        else
        {
          unint64_t v19 = sub_19E524BF4(*(void *)(a1 + 152), v20, (unsigned int *)(*(void *)(a1 + 184) + 4 * v17), 0);
          v18 |= v19 > 1;
        }
        *(void *)(*(void *)(a1 + 232) + 8 * v16) = v19;
        v17 += v19;
        ++v16;
      }
      while (v13 != v16);
    }
    else
    {
      char v18 = 0;
      uint64_t v17 = 0;
    }
    if (*(unsigned char *)(a1 + 288) && (*(_DWORD *)(a1 + 280) > a2 || *(_DWORD *)(a1 + 284) < a2))
    {
      a2 = a2 & ~((int)a2 >> 31);
      if (a2 <= *(_DWORD *)(a1 + 24))
      {
        *(_DWORD *)(*(void *)(a1 + 184) + 4 * v17) = a2;
        double v22 = 0.0;
      }
      else
      {
        *(_DWORD *)(*(void *)(a1 + 56) + 4 * v13) = 0;
        double v22 = -*(double *)(a1 + 40);
        double v14 = 0.0;
      }
      unsigned __int16 v25 = *(unint64_t **)(a1 + 232);
      v25[v13] = 1;
      unint64_t v26 = v13 + 1;
      if (v18)
      {
        uint64_t v23 = 0;
        unint64_t v27 = 0;
        goto LABEL_30;
      }
    }
    else
    {
      uint64_t v23 = (unsigned int *)(*(void *)(a1 + 184) + 4 * v17);
      unint64_t v24 = sub_19E524BF4(*(void *)(a1 + 152), a2, v23, *(void **)(a1 + 208));
      unsigned __int16 v25 = *(unint64_t **)(a1 + 232);
      v25[v13] = v24;
      unint64_t v26 = v13 + 1;
      double v22 = 0.0;
      if ((v24 > 1) | v18 & 1)
      {
        unint64_t v27 = v24;
LABEL_30:
        if (v47 == 5)
        {
          uint64_t v28 = 0;
        }
        else
        {
          double v48 = 0.0;
          (*(void (**)(void, uint64_t, void, void, double *, unint64_t *, uint64_t))(**(void **)(a1 + 168) + 16))(*(void *)(a1 + 168), a2, 0, 0, &v48, a6, a7);
          uint64_t v28 = *(void *)(a1 + 208);
          if (v27)
          {
            for (uint64_t i = 0; i != v27; ++i)
            {
              BOOL v33 = *(void **)(a1 + 152);
              int8x8_t v34 = (int8x8_t)v33[12];
              double v31 = -10.0;
              if (v34)
              {
                unint64_t v35 = v23[i];
                uint8x8_t v36 = (uint8x8_t)vcnt_s8(v34);
                v36.i16[0] = vaddlv_u8(v36);
                if (v36.u32[0] > 1uLL)
                {
                  unint64_t v37 = v23[i];
                  if (*(void *)&v34 <= v35) {
                    unint64_t v37 = v35 % *(void *)&v34;
                  }
                }
                else
                {
                  unint64_t v37 = (v34.i32[0] - 1) & v35;
                }
                uint64_t v38 = *(uint64_t ***)(v33[11] + 8 * v37);
                if (v38)
                {
                  unint64_t v39 = *v38;
                  if (v39)
                  {
                    if (v36.u32[0] < 2uLL)
                    {
                      uint64_t v40 = *(void *)&v34 - 1;
                      while (1)
                      {
                        uint64_t v42 = v39[1];
                        if (v42 == v35)
                        {
                          if (*((_DWORD *)v39 + 4) == v35) {
                            goto LABEL_35;
                          }
                        }
                        else if ((v42 & v40) != v37)
                        {
                          goto LABEL_36;
                        }
                        unint64_t v39 = (uint64_t *)*v39;
                        if (!v39) {
                          goto LABEL_36;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v41 = v39[1];
                      if (v41 == v35)
                      {
                        if (*((_DWORD *)v39 + 4) == v35)
                        {
LABEL_35:
                          double v31 = *(double *)(v33[19] + 8 * *((unsigned __int8 *)v39 + 20));
                          break;
                        }
                      }
                      else
                      {
                        if (v41 >= *(void *)&v34) {
                          v41 %= *(void *)&v34;
                        }
                        if (v41 != v37) {
                          break;
                        }
                      }
                      unint64_t v39 = (uint64_t *)*v39;
                    }
                    while (v39);
                  }
                }
              }
LABEL_36:
              double v32 = __exp10(*(double *)(v28 + 8 * i) - v31 + v48);
              uint64_t v28 = *(void *)(a1 + 208);
              *(double *)(v28 + 8 * i) = v32;
            }
          }
          unsigned __int16 v25 = *(unint64_t **)(a1 + 232);
        }
        double v43 = sub_19E4FC398(a1, *(unsigned int **)(a1 + 184), v25, v26, *(unsigned int **)(a1 + 256), 0, v28, 0, v14);
        double v29 = log10(v43 / v44);
        goto LABEL_60;
      }
    }
    double v29 = sub_19E4FB818(a1, *(unsigned int **)(a1 + 184), v26, a6, 1, v14);
LABEL_60:
    *a5 = v29 + v22;
  }
  return v7 != 0;
}

void sub_19E536328(void *a1)
{
  sub_19E536360(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E536360(void *a1)
{
  *a1 = &unk_1EF0B9F28;
  uint64_t v2 = (void *)a1[32];
  if (v2)
  {
    a1[33] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[29];
  if (v3)
  {
    a1[30] = v3;
    operator delete(v3);
  }
  __n128 v4 = (void *)a1[26];
  if (v4)
  {
    a1[27] = v4;
    operator delete(v4);
  }
  unsigned int v5 = (void *)a1[23];
  if (v5)
  {
    a1[24] = v5;
    operator delete(v5);
  }
  int v6 = (std::__shared_weak_count *)a1[22];
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)a1[20];
    if (!v7) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)a1[20];
    if (!v7) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_15:
  return sub_19E4580B4(a1);
}

void sub_19E536490(uint64_t a1, CFDictionaryRef *a2, uint64_t a3, uint64_t a4)
{
}

void sub_19E536638(_Unwind_Exception *a1)
{
  uint64_t v7 = *v5;
  if (*v5)
  {
    v1[33] = v7;
    operator delete(v7);
    uint64_t v8 = *v4;
    if (!*v4)
    {
LABEL_3:
      uint64_t v9 = *v3;
      if (!*v3) {
        goto LABEL_4;
      }
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v8 = *v4;
    if (!*v4) {
      goto LABEL_3;
    }
  }
  v1[30] = v8;
  operator delete(v8);
  uint64_t v9 = *v3;
  if (!*v3)
  {
LABEL_4:
    __int16 v10 = *v2;
    if (!*v2) {
      goto LABEL_5;
    }
    goto LABEL_10;
  }
LABEL_9:
  v1[27] = v9;
  operator delete(v9);
  __int16 v10 = *v2;
  if (!*v2)
  {
LABEL_5:
    unint64_t v11 = (std::__shared_weak_count *)v1[22];
    if (!v11) {
      goto LABEL_13;
    }
    goto LABEL_11;
  }
LABEL_10:
  v1[24] = v10;
  operator delete(v10);
  unint64_t v11 = (std::__shared_weak_count *)v1[22];
  if (!v11) {
    goto LABEL_13;
  }
LABEL_11:
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_13:
  uint64_t v12 = (std::__shared_weak_count *)v1[20];
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  sub_19E4580B4(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_19E536740(uint64_t a1, void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (uint64_t)(a2[1] - *a2) >> 2;
  unint64_t v3 = *(void *)(a1 + 88);
  BOOL v4 = v2 > v3;
  unint64_t v5 = v2 - v3;
  if (!v4) {
    __assert_rtn("_truncatedPriorContextLength", "CoreLanguageModel.cpp", 39, "context.size() > m_forwardPassLimit");
  }
  unint64_t v8 = v5 + 1;
  do
  {
    unint64_t v9 = v8 - 1;
    if (v8 == 1) {
      break;
    }
    int v10 = (*(uint64_t (**)(void, void *, unint64_t))(**(void **)(a1 + 208) + 136))(*(void *)(a1 + 208), a2, v8 - 2);
    unint64_t v8 = v9;
  }
  while (!v10);
  if (qword_1E945A340 != -1) {
    dispatch_once(&qword_1E945A340, &unk_1EF0BEFB0);
  }
  unint64_t v11 = qword_1E945A338;
  if (os_log_type_enabled((os_log_t)qword_1E945A338, OS_LOG_TYPE_INFO))
  {
    uint64_t v12 = (uint64_t)(a2[1] - *a2) >> 2;
    int v14 = 134218496;
    unint64_t v15 = v12 - v9;
    __int16 v16 = 2048;
    uint64_t v17 = v12;
    __int16 v18 = 2048;
    unint64_t v19 = v9;
    _os_log_impl(&dword_19E36B000, v11, OS_LOG_TYPE_INFO, "limiting forward passes to %ld, with contextLength=%zu and priorContextLength=%zu", (uint8_t *)&v14, 0x20u);
  }
  return v9;
}

os_log_t sub_19E5368B8()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "CoreLanguageModel");
  qword_1E945A338 = (uint64_t)result;
  return result;
}

uint64_t sub_19E5368E8(uint64_t a1)
{
  return (*(void *)(a1 + 96) << 32) - 0x100000000;
}

uint64_t sub_19E5368F8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 208) + 136))();
}

uint64_t sub_19E536920(uint64_t a1, void *a2, unint64_t a3, void *a4)
{
  BOOL v4 = (_DWORD *)*a2;
  if (*(_DWORD *)*a2 != 1) {
    __assert_rtn("_forward", "CoreLanguageModel.cpp", 189, "context[0] == kMontrealTokenIDBeginningOfSentence");
  }
  unint64_t v5 = a3;
  int v6 = a2;
  uint64_t v7 = (unsigned char *)a2[1];
  unint64_t v8 = (v7 - (unsigned char *)v4) >> 2;
  if (v8 == a3) {
    __assert_rtn("_forward", "CoreLanguageModel.cpp", 190, "context.size() != priorContextLength");
  }
  BOOL v9 = v8 > a3;
  unint64_t v10 = v8 - a3;
  if (v9 && v10 > *(void *)(a1 + 88))
  {
    unint64_t v5 = sub_19E536740(a1, a2);
    BOOL v4 = (_DWORD *)*v6;
    uint64_t v7 = (unsigned char *)v6[1];
    int v11 = 1;
  }
  else
  {
    int v11 = 0;
  }
  uint64_t v12 = &v4[v5];
  float v110 = 0;
  long long v111 = 0uLL;
  if (v12 == (_DWORD *)v7)
  {
    __int16 v16 = 0;
    int v14 = 0;
    if (!v11) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  uint64_t v13 = v7 - (unsigned char *)v12;
  if (v7 - (unsigned char *)v12 < 0) {
    sub_19E37C7C4();
  }
  int v14 = (char *)operator new(v7 - (unsigned char *)v12);
  float v110 = v14;
  *((void *)&v111 + 1) = &v14[4 * (v13 >> 2)];
  size_t v15 = v13;
  __int16 v16 = (char *)*((void *)&v111 + 1);
  memcpy(v14, v12, v15);
  *(void *)&long long v111 = *((void *)&v111 + 1);
  if (v11)
  {
LABEL_13:
    if (*(_DWORD *)v14 != 1)
    {
      sub_19E4FD734(&v110, v14, byte_19E57E0F0);
      int v14 = (char *)v110;
      __int16 v16 = (char *)v111;
    }
  }
LABEL_15:
  std::string __p = 0;
  float v108 = 0;
  int v109 = 0;
  unint64_t v17 = (v16 - v14) >> 2;
  if (v16 != v14)
  {
    if (v16 - v14 < 0) {
      sub_19E37C7C4();
    }
    std::string __p = operator new(v16 - v14);
    int v109 = (char *)__p + 4 * v17;
    memmove(__p, v14, v16 - v14);
    float v108 = v109;
  }
  if (v5) {
    char v18 = v11;
  }
  else {
    char v18 = 1;
  }
  if (v18)
  {
    uint64_t v95 = 0;
    goto LABEL_77;
  }
  float v97 = v16;
  uint64_t v19 = (*(uint64_t (**)(void, void, unint64_t))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8), *v6, v5);
  uint64_t v21 = v20;
  if (v20 + v17 < *(void *)(a1 + 224))
  {
    double v22 = (const void *)v19;
    uint64_t v95 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 48))(*(void *)(a1 + 8), v19, v20);
    float v96 = v6;
    uint64_t v23 = 0;
    unint64_t v24 = 0;
    *(void *)long long buf = 0;
    long long v119 = 0uLL;
    if (4 * v21)
    {
      if (4 * v21 < 0) {
        sub_19E37C7C4();
      }
      unsigned __int16 v25 = (char *)operator new(4 * v21);
      unint64_t v24 = v25;
      uint64_t v23 = &v25[4 * ((4 * v21) >> 2)];
      if (v21) {
        memmove(v25, v22, 4 * v21);
      }
    }
    if (__p)
    {
      float v108 = __p;
      operator delete(__p);
    }
    std::string __p = v24;
    float v108 = v23;
    int v109 = v23;
    unint64_t v26 = v97;
    if (v97 != v14)
    {
      unint64_t v27 = v14;
      while (1)
      {
        unint64_t v29 = v17;
        int v30 = *(_DWORD *)v27;
        if (v23 >= v109) {
          break;
        }
        *(_DWORD *)uint64_t v23 = v30;
        uint64_t v28 = v23 + 4;
        unint64_t v17 = v29;
LABEL_33:
        float v108 = v28;
        v27 += 4;
        uint64_t v23 = (char *)v28;
        if (v27 == v26) {
          goto LABEL_62;
        }
      }
      double v31 = v14;
      double v32 = (char *)__p;
      int64_t v33 = v23 - (unsigned char *)__p;
      uint64_t v34 = (v23 - (unsigned char *)__p) >> 2;
      unint64_t v35 = v34 + 1;
      if ((unint64_t)(v34 + 1) >> 62) {
        sub_19E37C7C4();
      }
      uint64_t v36 = v109 - (unsigned char *)__p;
      if ((v109 - (unsigned char *)__p) >> 1 > v35) {
        unint64_t v35 = v36 >> 1;
      }
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v37 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v37 = v35;
      }
      if (v37)
      {
        if (v37 >> 62) {
          sub_19E37C2B8();
        }
        uint64_t v38 = operator new(4 * v37);
      }
      else
      {
        uint64_t v38 = 0;
      }
      unint64_t v39 = &v38[4 * v34];
      *unint64_t v39 = v30;
      uint64_t v28 = v39 + 1;
      if (v23 == v32)
      {
        int v14 = v31;
        unint64_t v17 = v29;
      }
      else
      {
        unint64_t v40 = v23 - 4 - v32;
        unint64_t v17 = v29;
        if (v40 < 0xBC
          || &v38[v33 - 4 - (v40 & 0xFFFFFFFFFFFFFFFCLL)] > &v38[v33 - 4]
          || &v23[-(v40 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v23 - 4
          || (unint64_t)(v23 - v38 - v33) < 0x20)
        {
          unint64_t v41 = v23;
          int v14 = v31;
        }
        else
        {
          uint64_t v43 = (v40 >> 2) + 1;
          unint64_t v41 = &v23[-4 * (v43 & 0x7FFFFFFFFFFFFFF8)];
          double v44 = &v38[4 * v34 - 16];
          int v45 = v23 - 16;
          uint64_t v46 = v43 & 0x7FFFFFFFFFFFFFF8;
          int v14 = v31;
          do
          {
            long long v47 = *(_OWORD *)v45;
            *(v44 - 1) = *((_OWORD *)v45 - 1);
            *double v44 = v47;
            v44 -= 2;
            v45 -= 32;
            v46 -= 8;
          }
          while (v46);
          v39 -= v43 & 0x7FFFFFFFFFFFFFF8;
          if (v43 == (v43 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_51;
          }
        }
        do
        {
          int v42 = *((_DWORD *)v41 - 1);
          v41 -= 4;
          *--unint64_t v39 = v42;
        }
        while (v41 != v32);
      }
LABEL_51:
      std::string __p = v39;
      float v108 = v28;
      int v109 = &v38[4 * v37];
      if (v32) {
        operator delete(v32);
      }
      unint64_t v26 = v97;
      goto LABEL_33;
    }
LABEL_62:
    if (v95)
    {
      LOBYTE(v11) = 0;
      goto LABEL_77;
    }
    int v6 = v96;
  }
  uint64_t v49 = *v6;
  double v48 = (unsigned char *)v6[1];
  if (*(void *)(a1 + 88) >= (unint64_t)((uint64_t)&v48[-*v6] >> 2))
  {
    unint64_t v50 = 0;
  }
  else
  {
    unint64_t v50 = sub_19E536740(a1, v6);
    uint64_t v49 = *v6;
    double v48 = (unsigned char *)v6[1];
  }
  LOBYTE(v11) = v50 != 0;
  float v51 = (unsigned char *)(v49 + 4 * v50);
  *(void *)long long buf = 0;
  long long v119 = 0uLL;
  if (v51 == v48)
  {
    unsigned int v53 = 0;
  }
  else
  {
    int64_t v52 = v48 - v51;
    if (v48 - v51 < 0) {
      sub_19E37C7C4();
    }
    unsigned int v53 = operator new(v48 - v51);
    *(void *)long long buf = v53;
    *((void *)&v119 + 1) = &v53[v52 >> 2];
    memcpy(v53, v51, v52);
    *(void *)&long long v119 = &v53[v52 >> 2];
  }
  if (*v53 != 1) {
    sub_19E4FD734((void **)buf, v53, byte_19E57E0F0);
  }
  if (v110)
  {
    *(void *)&long long v111 = v110;
    operator delete(v110);
  }
  uint64_t v95 = 0;
  int v14 = *(char **)buf;
  float v110 = *(void **)buf;
  long long v111 = v119;
  unint64_t v17 = (uint64_t)(v119 - *(void *)buf) >> 2;
LABEL_77:
  float v104 = 0;
  float v105 = 0;
  uint64_t v106 = 0;
  float v102 = 0;
  long long v103 = 0uLL;
  if (qword_1EC009570 != -1) {
    dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
  }
  os_signpost_id_t v54 = os_signpost_id_generate((os_log_t)qword_1EC009568);
  if ((v11 & 1) != 0 || v17 > *(void *)(a1 + 88) - 4)
  {
    if (qword_1EC009570 != -1) {
      dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
    }
    if (v54 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      float v55 = qword_1EC009568;
      if (os_signpost_enabled((os_log_t)qword_1EC009568))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl(&dword_19E36B000, v55, OS_SIGNPOST_INTERVAL_BEGIN, v54, "TruncatedContextMaxForwardPassesCalculated", (const char *)&unk_19E5812E5, buf, 2u);
      }
    }
  }
  os_signpost_id_t v94 = v54;
  if (v17)
  {
    char v56 = 0;
    ++*a4;
    uint64_t v57 = (*(uint64_t (**)(void, uint64_t, void, uint64_t, void, void))(**(void **)(a1 + 40) + 24))(*(void *)(a1 + 40), v95, *(unsigned int *)v14, 5, 0, 0);
    if (v58)
    {
      float v59 = *(float16x8_t **)(a1 + 16);
      if (v58 != (uint64_t)(*(void *)(a1 + 24) - (void)v59) >> 1) {
        __assert_rtn("compressOutputLayer", "NeuralNetworkUtils.hpp", 84, "uncompressed.size() == compressed.size() && \"mismatched output layer sizes\"");
      }
      unint64_t v60 = (v58 - 1) & 0x3FFFFFFFFFFFFFFFLL;
      if (v60 >= 0xF)
      {
        uint64_t v62 = (v60 + 1) & 0x7FFFFFFFFFFFFFF0;
        float v63 = (float32x4_t *)(v57 + 32);
        float v64 = v59 + 1;
        uint64_t v65 = v62;
        do
        {
          float32x4_t v67 = v63[-2];
          float32x4_t v66 = v63[-1];
          float32x4_t v69 = *v63;
          float32x4_t v68 = v63[1];
          v63 += 4;
          v64[-1] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v67), v66);
          *float v64 = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v69), v68);
          v64 += 2;
          v65 -= 16;
        }
        while (v65);
        if (v60 + 1 == v62) {
          goto LABEL_96;
        }
        float v59 = (float16x8_t *)((char *)v59 + 2 * v62);
        float v61 = (int *)(v57 + 4 * v62);
      }
      else
      {
        float v61 = (int *)v57;
      }
      do
      {
        int v70 = *v61++;
        _S0 = v70;
        __asm { FCVT            H0, S0 }
        v59->i16[0] = _S0;
        float v59 = (float16x8_t *)((char *)v59 + 2);
      }
      while (v61 != (int *)(v57 + 4 * v58));
LABEL_96:
      if (v17 != 1)
      {
        (*(void (**)(uint8_t *__return_ptr))(**(void **)(a1 + 40) + 32))(buf);
        *(void *)long long buf = 0;
      }
      uint64_t v76 = *(void *)(a1 + 40);
      uint64_t v77 = *(void *)(a1 + 48);
      uint64_t v100 = v76;
      uint64_t v101 = v77;
      if (v77) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v77 + 8), 1uLL, memory_order_relaxed);
      }
      if (*(_DWORD *)(v76 + 8) != 1) {
        __assert_rtn("copyCurrentIncrementalState", "MontrealInferenceEngine.cpp", 153, "m_architecture == NNModelArchitecture::Transformer");
      }
      unsigned int v113 = 0;
      uint64_t v114 = 0;
      uint64_t v78 = *(void *)(v76 + 16);
      uint64_t v115 = &v114;
      uint64_t v116 = 0x2000000000;
      int v79 = (uint64_t (*)(uint64_t, __CFError **))off_1EC009208;
      uint64_t v117 = off_1EC009208;
      if (!off_1EC009208)
      {
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&long long v119 = 0x40000000;
        *((void *)&v119 + 1) = sub_19E50AF54;
        float v120 = &unk_1E59A1C38;
        uint64_t v121 = &v114;
        sub_19E50AF54((uint64_t)buf);
        int v79 = (uint64_t (*)(uint64_t, __CFError **))v115[3];
      }
      _Block_object_dispose(&v114, 8);
      if (v79)
      {
        float v80 = (const void *)v79(v78, &v113);
        sub_19E40100C(&v112, v80);
        float v81 = v113;
        if (v113)
        {
          *(void *)long long buf = operator new(0x20uLL);
          long long v119 = xmmword_19E573030;
          strcpy(*(char **)buf, "MRLNeuralNetworkCopyStates");
          sub_19E50A648((uint64_t *)buf, v81);
          if (SHIBYTE(v119) < 0) {
            operator delete(*(void **)buf);
          }
        }
        operator new();
      }
      dlerror();
      uint64_t result = abort_report_np();
      __break(1u);
      return result;
    }
  }
  else
  {
    if (v11)
    {
      if (qword_1EC009570 != -1) {
        dispatch_once(&qword_1EC009570, &unk_1EF0BEAF0);
      }
      if (v54 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        BOOL v82 = qword_1EC009568;
        if (os_signpost_enabled((os_log_t)qword_1EC009568))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl(&dword_19E36B000, v82, OS_SIGNPOST_INTERVAL_END, v94, "TruncatedContextMaxForwardPassesCalculated", (const char *)&unk_19E5812E5, buf, 2u);
        }
      }
    }
    float v105 = v104;
    char v56 = 1;
  }
  uint64_t v83 = (char *)v102;
  if (v102)
  {
    float v84 = (char *)v103;
    unint64_t v85 = v102;
    if ((void *)v103 != v102)
    {
      float v86 = (char *)v103;
      do
      {
        unsigned int v88 = (void *)*((void *)v86 - 3);
        v86 -= 24;
        uint64_t v87 = v88;
        if (v88)
        {
          *((void *)v84 - 2) = v87;
          operator delete(v87);
        }
        float v84 = v86;
      }
      while (v86 != v83);
      unint64_t v85 = v102;
    }
    *(void *)&long long v103 = v83;
    operator delete(v85);
  }
  float v89 = v104;
  if (v104)
  {
    float v90 = v105;
    while (v90 != v89)
    {
      uint64_t v92 = *--v90;
      uint64_t v91 = v92;
      void *v90 = 0;
      if (v92) {
        (*(void (**)(uint64_t))(*(void *)v91 + 8))(v91);
      }
    }
    operator delete(v89);
  }
  if (__p)
  {
    float v108 = __p;
    operator delete(__p);
  }
  if (v110)
  {
    *(void *)&long long v111 = v110;
    operator delete(v110);
  }
  return v56 & 1;
}

void sub_19E537A8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39)
{
  unint64_t v41 = *(void **)(v39 - 160);
  if (v41)
  {
    *(void *)(v39 - 152) = v41;
    operator delete(v41);
    int v42 = a35;
    if (!a35)
    {
LABEL_3:
      uint64_t v43 = __p;
      if (!__p) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else
  {
    int v42 = a35;
    if (!a35) {
      goto LABEL_3;
    }
  }
  operator delete(v42);
  uint64_t v43 = __p;
  if (!__p) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  operator delete(v43);
  goto LABEL_5;
}

void *sub_19E537CA8(void *a1)
{
  unint64_t v2 = (void *)*a1;
  if (*a1)
  {
    unint64_t v3 = (void *)a1[1];
    BOOL v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *unint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      BOOL v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t sub_19E537D38(uint64_t a1, unsigned char **a2, uint64_t a3)
{
  sub_19E538094(&__p, a1, *a2, a2[1]);
  uint64_t v5 = v24;
  unint64_t v6 = (v24 - (unsigned char *)__p) >> 2;
  if (v24 == __p)
  {
    uint64_t v7 = v24;
  }
  else
  {
    do
    {
      if ((*(uint64_t (**)(void, void *, unint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), __p, v6))break; {
      --v6;
      }
    }
    while (v6);
    uint64_t v5 = __p;
    uint64_t v7 = v24;
  }
  if (v6 == (v7 - v5) >> 2)
  {
    uint64_t v8 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v8, v9);
  }
  else
  {
    sub_19E53829C(&v21, a1, &__p, v6);
    int v11 = v21;
    uint64_t v10 = (*(uint64_t (**)(void, int *, uint64_t))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v21, (uint64_t)(v22 - (void)v21) >> 2);
    if (!v10)
    {
      if ((sub_19E4E87DC(a1, &__p, a3) & 1) == 0) {
        __assert_rtn("_getNetworkState", "CoreLanguageModel.cpp", 161, "false");
      }
      uint64_t v12 = v24;
      unint64_t v13 = (v24 - (unsigned char *)__p) >> 2;
      if (v24 == __p)
      {
        int v14 = v24;
      }
      else
      {
        do
        {
          if ((*(uint64_t (**)(void, void *, unint64_t))(**(void **)(a1 + 8) + 32))(*(void *)(a1 + 8), __p, v13))break; {
          --v13;
          }
        }
        while (v13);
        uint64_t v12 = __p;
        int v14 = v24;
      }
      if (v13 == (v14 - v12) >> 2)
      {
        uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
        uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v15, v16);
      }
      else
      {
        sub_19E53829C(&v19, a1, &__p, v13);
        if (v11) {
          operator delete(v11);
        }
        int v11 = v19;
        uint64_t v21 = v19;
        long long v22 = v20;
        uint64_t v17 = (*(uint64_t (**)(void, int *, uint64_t))(**(void **)(a1 + 8) + 56))(*(void *)(a1 + 8), v19, (uint64_t)(v20 - (void)v19) >> 2);
      }
      uint64_t v10 = v17;
    }
    if (v11) {
      operator delete(v11);
    }
  }
  if (__p)
  {
    unint64_t v24 = __p;
    operator delete(__p);
  }
  return v10;
}

void sub_19E538030(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (v17)
  {
    operator delete(v17);
    uint64_t v19 = __p;
    if (!__p) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    uint64_t v19 = __p;
    if (!__p) {
      goto LABEL_3;
    }
  }
  operator delete(v19);
  _Unwind_Resume(exception_object);
}

void sub_19E538094(void **a1, uint64_t a2, unsigned char *a3, unsigned char *a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  int64_t v6 = a4 - a3;
  if (a4 == a3)
  {
    uint64_t v8 = 0;
LABEL_6:
    sub_19E4FD734(a1, v8, byte_19E57E0F0);
    uint64_t v8 = *a1;
    uint64_t v9 = (char *)a1[1];
    goto LABEL_7;
  }
  if (v6 < 0) {
    sub_19E37C7C4();
  }
  uint64_t v8 = operator new(a4 - a3);
  *a1 = v8;
  uint64_t v9 = &v8[4 * (v6 >> 2)];
  a1[2] = v9;
  memcpy(v8, a3, v6);
  a1[1] = v9;
  if (*(_DWORD *)v8 != 1) {
    goto LABEL_6;
  }
LABEL_7:
  unint64_t v10 = (v9 - v8) >> 2;
  unint64_t v11 = *(void *)(a2 + 224);
  BOOL v12 = v10 >= v11;
  unint64_t v13 = v10 - v11;
  if (v13 != 0 && v12) {
    unint64_t v14 = v13 + 1;
  }
  else {
    unint64_t v14 = 0;
  }
  if (v14 < v10)
  {
    while (((*(uint64_t (**)(void, void **, unint64_t))(**(void **)(a2 + 208) + 136))(*(void *)(a2 + 208), a1, v14) & 1) == 0)
    {
      ++v14;
      uint64_t v16 = (char *)*a1;
      uint64_t v15 = (char *)a1[1];
      if (v14 >= (v15 - (unsigned char *)*a1) >> 2) {
        goto LABEL_16;
      }
    }
  }
  if (v14)
  {
    uint64_t v16 = (char *)*a1;
    uint64_t v15 = (char *)a1[1];
LABEL_16:
    uint64_t v17 = &v16[4 * v14];
    if (v15 == v17)
    {
      long long v20 = 0;
      uint64_t v19 = 0;
      if (!v16) {
        goto LABEL_20;
      }
    }
    else
    {
      int64_t v18 = v15 - v17;
      if (v15 - v17 < 0) {
        sub_19E37C7C4();
      }
      uint64_t v19 = (char *)operator new(v15 - v17);
      long long v20 = &v19[4 * (v18 >> 2)];
      memmove(v19, v17, v18);
      if (!v16) {
        goto LABEL_20;
      }
    }
    a1[1] = v16;
    operator delete(v16);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
LABEL_20:
    *a1 = v19;
    a1[1] = v20;
    a1[2] = v20;
    if (v19 == v20 || *(_DWORD *)v19 != 1) {
      sub_19E4FD734(a1, v19, byte_19E57E0F0);
    }
  }
}

void sub_19E53825C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  unint64_t v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53829C(int **a1, uint64_t a2, void *a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v9 = *a3;
  uint64_t v8 = (unsigned char *)a3[1];
  unint64_t v10 = (uint64_t)&v8[-*a3] >> 2;
  BOOL v11 = v10 > a4;
  unint64_t v12 = v10 - a4;
  if (v11 && v12 > *(void *)(a2 + 88))
  {
    unint64_t v4 = sub_19E536740(a2, a3);
    uint64_t v9 = *a3;
    uint64_t v8 = (unsigned char *)a3[1];
    int v13 = 1;
  }
  else
  {
    int v13 = 0;
  }
  unint64_t v14 = (unsigned char *)(v9 + 4 * v4);
  float32x4_t v67 = 0;
  float32x4_t v68 = 0;
  float32x4_t v69 = 0;
  unint64_t v60 = a1;
  if (v14 == v8)
  {
    uint64_t v17 = 0;
    uint64_t v16 = 0;
    if (!v13) {
      goto LABEL_13;
    }
    goto LABEL_11;
  }
  int64_t v15 = v8 - v14;
  if (v8 - v14 < 0) {
    sub_19E37C7C4();
  }
  uint64_t v16 = (int *)operator new(v8 - v14);
  uint64_t v17 = &v16[v15 >> 2];
  float32x4_t v67 = v16;
  float32x4_t v69 = v17;
  memcpy(v16, v14, v15);
  float32x4_t v68 = v17;
  if (v13)
  {
LABEL_11:
    if (*v16 != 1)
    {
      sub_19E4FD734(&v67, v16, byte_19E57E0F0);
      uint64_t v16 = (int *)v67;
      uint64_t v17 = v68;
    }
  }
LABEL_13:
  std::string __p = 0;
  uint64_t v65 = 0;
  float32x4_t v66 = 0;
  uint64_t v18 = (char *)v17 - (char *)v16;
  if (v17 == v16)
  {
    uint64_t v19 = 0;
  }
  else
  {
    if (v18 < 0) {
      sub_19E37C7C4();
    }
    std::string __p = operator new((char *)v17 - (char *)v16);
    uint64_t v19 = (char *)__p + 4 * (v18 >> 2);
    float32x4_t v66 = v19;
    memmove(__p, v16, (char *)v17 - (char *)v16);
    uint64_t v65 = v19;
  }
  if (v4) {
    char v20 = v13;
  }
  else {
    char v20 = 1;
  }
  if (v20)
  {
    uint64_t v59 = 0;
    if (!v13) {
      goto LABEL_66;
    }
    goto LABEL_22;
  }
  uint64_t v22 = (*(uint64_t (**)(void, void, unint64_t))(**(void **)(a2 + 8) + 40))(*(void *)(a2 + 8), *a3, v4);
  unint64_t v24 = (int *)v67;
  uint64_t v17 = v68;
  if ((unint64_t)(v23 + (((char *)v68 - (unsigned char *)v67) >> 2)) >= *(void *)(a2 + 224))
  {
    uint64_t v48 = *a3;
    long long v47 = (unsigned char *)a3[1];
    if (*(void *)(a2 + 88) >= (unint64_t)((uint64_t)&v47[-*a3] >> 2))
    {
      unint64_t v49 = 0;
    }
    else
    {
      unint64_t v49 = sub_19E536740(a2, a3);
      uint64_t v48 = *a3;
      long long v47 = (unsigned char *)a3[1];
    }
    char v56 = (unsigned char *)(v48 + 4 * v49);
    float v61 = 0;
    uint64_t v62 = 0;
    float v63 = 0;
    if (v56 == v47)
    {
      uint64_t v58 = 0;
    }
    else
    {
      int64_t v57 = v47 - v56;
      if (v47 - v56 < 0) {
        sub_19E37C7C4();
      }
      uint64_t v58 = (int *)operator new(v47 - v56);
      float v61 = v58;
      float v63 = &v58[v57 >> 2];
      memcpy(v58, v56, v57);
      uint64_t v62 = v63;
    }
    if (*v58 != 1) {
      sub_19E4FD734((void **)&v61, v58, byte_19E57E0F0);
    }
    if (v67)
    {
      float32x4_t v68 = (int *)v67;
      operator delete(v67);
      float32x4_t v68 = 0;
      float32x4_t v69 = 0;
    }
    uint64_t v16 = v61;
    uint64_t v17 = v62;
    uint64_t v21 = v63;
    goto LABEL_82;
  }
  uint64_t v19 = 0;
  unsigned __int16 v25 = 0;
  uint64_t v59 = v23;
  size_t v26 = 4 * v23;
  float v61 = 0;
  uint64_t v62 = 0;
  float v63 = 0;
  if (4 * v23)
  {
    if ((v26 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    unint64_t v27 = (const void *)v22;
    uint64_t v28 = (char *)operator new(4 * v23);
    unsigned __int16 v25 = v28;
    uint64_t v19 = &v28[4 * ((4 * v59) >> 2)];
    if (v59) {
      memmove(v28, v27, v26);
    }
  }
  if (__p)
  {
    uint64_t v65 = (char *)__p;
    operator delete(__p);
    unint64_t v24 = (int *)v67;
    uint64_t v17 = v68;
  }
  std::string __p = v25;
  uint64_t v65 = v19;
  float32x4_t v66 = v19;
  if (v24 == v17)
  {
    uint64_t v16 = v17;
    if (v13) {
      goto LABEL_22;
    }
LABEL_66:
    unint64_t v50 = v59 + v17 - v16;
    float v51 = (int *)__p;
    unint64_t v52 = (v19 - (unsigned char *)__p) >> 2;
    BOOL v53 = v50 >= v52;
    if (v50 <= v52)
    {
      os_signpost_id_t v54 = v60;
      if (!v53)
      {
        uint64_t v19 = (char *)__p + 4 * v50;
        uint64_t v65 = v19;
      }
    }
    else
    {
      sub_19E3F9C70((uint64_t)&__p, v50 - v52);
      os_signpost_id_t v54 = v60;
      float v51 = (int *)__p;
      uint64_t v19 = v65;
    }
    *os_signpost_id_t v54 = v51;
    v54[1] = (int *)v19;
    v54[2] = (int *)v66;
    float v55 = (int *)v67;
    if (v67) {
      goto LABEL_84;
    }
    return;
  }
  do
  {
    int v29 = *v24;
    if (v19 < v66)
    {
      *(_DWORD *)uint64_t v19 = v29;
      v19 += 4;
      goto LABEL_34;
    }
    int v30 = (char *)__p;
    int64_t v31 = v19 - (unsigned char *)__p;
    uint64_t v32 = (v19 - (unsigned char *)__p) >> 2;
    unint64_t v33 = v32 + 1;
    if ((unint64_t)(v32 + 1) >> 62) {
      sub_19E37C7C4();
    }
    uint64_t v34 = v66 - (unsigned char *)__p;
    if ((v66 - (unsigned char *)__p) >> 1 > v33) {
      unint64_t v33 = v34 >> 1;
    }
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v35 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v35 = v33;
    }
    if (v35)
    {
      if (v35 >> 62) {
        sub_19E37C2B8();
      }
      uint64_t v36 = operator new(4 * v35);
    }
    else
    {
      uint64_t v36 = 0;
    }
    unint64_t v37 = &v36[4 * v32];
    *(_DWORD *)unint64_t v37 = v29;
    uint64_t v38 = v37 + 4;
    if (v19 != v30)
    {
      unint64_t v39 = v19 - 4 - v30;
      if (v39 >= 0xBC)
      {
        if (&v36[v31 - 4 - (v39 & 0xFFFFFFFFFFFFFFFCLL)] > &v36[v31 - 4])
        {
          unint64_t v40 = v19;
        }
        else if (&v19[-(v39 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v19 - 4)
        {
          unint64_t v40 = v19;
        }
        else if ((unint64_t)(v19 - v36 - v31) >= 0x20)
        {
          uint64_t v42 = (v39 >> 2) + 1;
          unint64_t v40 = &v19[-4 * (v42 & 0x7FFFFFFFFFFFFFF8)];
          uint64_t v43 = &v36[4 * v32 - 16];
          double v44 = v19 - 16;
          uint64_t v45 = v42 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v46 = *(_OWORD *)v44;
            *(v43 - 1) = *((_OWORD *)v44 - 1);
            *uint64_t v43 = v46;
            v43 -= 2;
            v44 -= 32;
            v45 -= 8;
          }
          while (v45);
          v37 -= 4 * (v42 & 0x7FFFFFFFFFFFFFF8);
          if (v42 == (v42 & 0x7FFFFFFFFFFFFFF8)) {
            goto LABEL_50;
          }
        }
        else
        {
          unint64_t v40 = v19;
        }
      }
      else
      {
        unint64_t v40 = v19;
      }
      do
      {
        int v41 = *((_DWORD *)v40 - 1);
        v40 -= 4;
        *((_DWORD *)v37 - 1) = v41;
        v37 -= 4;
      }
      while (v40 != v30);
    }
LABEL_50:
    std::string __p = v37;
    uint64_t v65 = v38;
    float32x4_t v66 = &v36[4 * v35];
    if (v30) {
      operator delete(v30);
    }
    uint64_t v19 = v38;
LABEL_34:
    uint64_t v65 = v19;
    ++v24;
  }
  while (v24 != v17);
  uint64_t v16 = (int *)v67;
  uint64_t v17 = v68;
  if (!v13) {
    goto LABEL_66;
  }
LABEL_22:
  uint64_t v21 = v69;
LABEL_82:
  *unint64_t v60 = v16;
  v60[1] = v17;
  v60[2] = v21;
  float32x4_t v68 = 0;
  float32x4_t v69 = 0;
  float32x4_t v67 = 0;
  if (__p)
  {
    uint64_t v65 = (char *)__p;
    operator delete(__p);
    float v55 = (int *)v67;
    if (v67)
    {
LABEL_84:
      float32x4_t v68 = v55;
      operator delete(v55);
    }
  }
}

void sub_19E5387E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (a12)
  {
    operator delete(a12);
    char v20 = a15;
    if (!a15)
    {
LABEL_3:
      uint64_t v21 = __p;
      if (!__p) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else
  {
    char v20 = a15;
    if (!a15) {
      goto LABEL_3;
    }
  }
  operator delete(v20);
  uint64_t v21 = __p;
  if (!__p) {
LABEL_5:
  }
    _Unwind_Resume(exception_object);
LABEL_4:
  operator delete(v21);
  goto LABEL_5;
}

uint64_t sub_19E538874(uint64_t a1, unsigned char **a2, uint64_t a3)
{
  sub_19E538094(__p, a1, *a2, a2[1]);
  uint64_t v5 = sub_19E4E87DC(a1, __p, a3);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  return v5;
}

void sub_19E5388D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E5388F4(void *a1)
{
  *a1 = &unk_1EF0BA5F8;
  unint64_t v2 = (std::__shared_weak_count *)a1[27];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  sub_19E438D34(a1);
  JUMPOUT(0x19F3BDCF0);
}

void *sub_19E5389A0(void *a1)
{
  *a1 = &unk_1EF0BA5F8;
  unint64_t v2 = (std::__shared_weak_count *)a1[27];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return sub_19E438D34(a1);
}

void sub_19E538A38(uint64_t a1, CFTypeRef *a2, uint64_t a3, void *a4, int a5)
{
  unint64_t v10 = operator new(0x20uLL);
  v10[1] = 0;
  v10[2] = 0;
  *unint64_t v10 = &unk_1EF0BE5A0;
  v10[3] = &unk_1EF0BB7D0;
  v16[0] = v10 + 3;
  v16[1] = v10;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  v15[0] = 0;
  v15[1] = 0;
  uint64_t v11 = a4[1];
  v14[0] = *a4;
  v14[1] = v11;
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  sub_19E4EA12C(a1, a2, (uint64_t)v16, (uint64_t)v15, a3, (uint64_t)v14, a5);
}

void sub_19E538D3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    if ((v17 & 1) == 0)
    {
LABEL_6:
      sub_19E3D73EC(v15);
      sub_19E438D34(v14);
      _Unwind_Resume(a1);
    }
  }
  else if (!v17)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v16);
  goto LABEL_6;
}

void sub_19E538D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, char a15, uint64_t a16, char a17)
{
}

uint64_t sub_19E538DB8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  v11[0] = &unk_1EF0BDE50;
  v11[1] = a1;
  uint64_t v12 = v11;
  v9[0] = &unk_1EF0BDEA8;
  v9[1] = a1;
  unint64_t v10 = v9;
  uint64_t v8 = v7;
  v7[0] = &unk_1EF0BDE50;
  v7[1] = a1;
  int64_t v6 = v5;
  v5[0] = &unk_1EF0BDEA8;
  v5[1] = a1;
  sub_19E539074(a4, a1, a2, a3);
  if (v6 == v5)
  {
    (*(void (**)(void *))(v5[0] + 32))(v5);
  }
  else if (v6)
  {
    (*(void (**)(void))(*v6 + 40))();
  }
  if (v8 == v7)
  {
    (*(void (**)(void *))(v7[0] + 32))(v7);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
  }
  else if (v10)
  {
    (*(void (**)(void))(*v10 + 40))();
  }
  uint64_t result = (uint64_t)v12;
  if (v12 == v11) {
    return (*(uint64_t (**)(void *))(v11[0] + 32))(v11);
  }
  if (v12) {
    return (*(uint64_t (**)(void *))(*v12 + 40))(v12);
  }
  return result;
}

void sub_19E539048(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  sub_19E3D99A4((uint64_t *)va);
  sub_19E3D9A28((uint64_t *)va1);
  sub_19E3D99A4((uint64_t *)va2);
  sub_19E3D9A28((void *)(v2 - 56));
  _Unwind_Resume(a1);
}

void *sub_19E539074(void *result, uint64_t a2, uint64_t *a3, void *a4)
{
  uint64_t v5 = *a3;
  uint64_t v4 = a3[1];
  if (v4 - *a3 != a4[1] - *a4) {
    __assert_rtn("normalizedNameTokenConditionalProbabilityWithBlock", "TokenIDLanguageModelSession.cpp", 1437, "tokens.size() == tokensMetadata.size()");
  }
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  if (v4 != v5) {
    operator new();
  }
  return result;
}

void sub_19E53A1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,_Unwind_Exception *exception_object,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  *(void *)(a10 + 8) = v44;
  sub_19E3F4804(&a41);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&a44);
  sub_19E3F401C((void ***)a10);
  _Unwind_Resume(a1);
}

void sub_19E53A5DC(_Unwind_Exception *exception_object, int a2)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  sub_19E37B770(exception_object);
}

char *sub_19E53A5F4(void ***a1, void *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_19E37C7C4();
  }
  if (0x5555555555555556 * (a1[2] - *a1) > v3) {
    unint64_t v3 = 0x5555555555555556 * (a1[2] - *a1);
  }
  if (0xAAAAAAAAAAAAAAABLL * (a1[2] - *a1) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      sub_19E37C2B8();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v22 = &v7[24 * v2];
  uint64_t v23 = (void **)&v7[24 * v6];
  sub_19E3F4510(v22, a2);
  uint64_t v8 = (void **)v22;
  uint64_t v9 = (void **)(v22 + 24);
  unint64_t v10 = *a1;
  uint64_t v11 = a1[1];
  if (v11 == *a1)
  {
    *a1 = (void **)v22;
    a1[1] = v9;
    a1[2] = v23;
  }
  else
  {
    do
    {
      *(v8 - 3) = 0;
      *(v8 - 2) = 0;
      v8 -= 3;
      void v8[2] = 0;
      long long v12 = *(_OWORD *)(v11 - 3);
      v11 -= 3;
      *(_OWORD *)uint64_t v8 = v12;
      void v8[2] = v11[2];
      *uint64_t v11 = 0;
      v11[1] = 0;
      v11[2] = 0;
    }
    while (v11 != v10);
    uint64_t v11 = *a1;
    uint64_t v13 = a1[1];
    *a1 = v8;
    a1[1] = v9;
    a1[2] = v23;
    if (v13 != v11)
    {
      unint64_t v14 = v13;
      do
      {
        int v17 = *(v14 - 3);
        v14 -= 3;
        uint64_t v16 = v17;
        if (v17)
        {
          uint64_t v18 = *(v13 - 2);
          uint64_t v15 = v16;
          if (v18 != v16)
          {
            do
            {
              uint64_t v20 = *--v18;
              uint64_t v19 = v20;
              void *v18 = 0;
              if (v20) {
                MEMORY[0x19F3BDCF0](v19, 0x1000C4065B674BELL);
              }
            }
            while (v18 != v16);
            uint64_t v15 = *v14;
          }
          *(v13 - 2) = v16;
          operator delete(v15);
        }
        uint64_t v13 = v14;
      }
      while (v14 != v11);
    }
  }
  if (v11) {
    operator delete(v11);
  }
  return v22 + 24;
}

void sub_19E53A7B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3F4A20((uint64_t)va);
  _Unwind_Resume(a1);
}

void *sub_19E53A7C4()
{
  return &unk_1EF0B82D8;
}

uint64_t sub_19E53A7D0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityER"
                     "KNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataEN"
                     "S5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_1"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalPr"
                                "obabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_"
                                "INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E53A828(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  *(_OWORD *)uint64_t v7 = *(_OWORD *)a2;
  uint64_t v8 = *(void *)(a2 + 16);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a2 = 0;
  int v9 = *(_DWORD *)(a2 + 24);
  uint64_t v6 = *(void *)(a1 + 8);
  sub_19E371C70(__p, (const UInt8 *)v7);
  int v11 = v9;
  sub_19E53A920(v6, (uint64_t)__p, a3, a4);
}

void sub_19E53A8D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
  {
    operator delete(__p);
    if ((a14 & 0x80000000) == 0) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  _Unwind_Resume(exception_object);
}

void sub_19E53A920(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  int64x2_t v4 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v5 = 0;
  __int16 v6 = 0;
  char v7 = 1;
  long long v8 = xmmword_19E572FD0;
  int v9 = 0;
  long long v10 = xmmword_19E572FD0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v11 = 0xFFEFFFFFFFFFFFFFLL;
  v14[3] = 0;
  sub_19E53AAAC(a4, a1, a2, *a3, (uint64_t)&v4, 1, v14);
}

void sub_19E53AA38(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 32);
  if (v3 == v1 - 56)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 - 56) + 32))(v1 - 56);
    _Unwind_Resume(exception_object);
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53AAAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, void *a7)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = *(unsigned __int16 *)(a2 + 8);
  uint64_t v65 = (int32x2_t *)&unk_1EF0B5A80;
  uint64_t v66 = a2;
  float32x4_t v67 = &v65;
  sub_19E3F9E24(a4, v13, (uint64_t)&v65);
  if (v67 == &v65)
  {
    ((void (*)(int32x2_t **))v65[4])(&v65);
  }
  else if (v67)
  {
    ((void (*)(int32x2_t **))(*v67)[5])(v67);
  }
  int v50 = a6;
  float v51 = a7;
  uint64_t v43 = a4;
  sub_19E53B260(&v65, a4, *(void *)(a2 + 72), v13, *(unsigned __int16 *)(a2 + 8));
  unint64_t v14 = v65;
  uint64_t v15 = (v66 - (uint64_t)v65) >> 2;
  uint64_t v48 = v68;
  uint64_t v49 = (uint64_t)v67;
  uint64_t v46 = v70;
  uint64_t v47 = v69;
  uint64_t v44 = v72;
  uint64_t v45 = v71;
  CFTypeRef cf = 0;
  unsigned int v16 = (*(uint64_t (**)(void, uint64_t, CFTypeRef *, int32x2_t *, uint64_t, uint64_t))(**(void **)(a2 + 104)
                                                                                               + 40))(*(void *)(a2 + 104), a3, &cf, v65, v15, 3);
  uint64_t v17 = *(void *)(a2 + 72);
  CFTypeRef v18 = cf;
  int v19 = *(char *)(a3 + 23);
  if (!cf)
  {
    if (v19 < 0)
    {
      sub_19E39369C(__p, *(void **)a3, *(void *)(a3 + 8));
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a3;
      uint64_t v61 = *(void *)(a3 + 16);
    }
    goto LABEL_19;
  }
  if (v19 < 0)
  {
    sub_19E39369C(__dst, *(void **)a3, *(void *)(a3 + 8));
    CFStringRef v20 = (const __CFString *)cf;
    if ((SHIBYTE(v58) & 0x80000000) == 0) {
      goto LABEL_8;
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a3;
    uint64_t v58 = *(void *)(a3 + 16);
    CFStringRef v20 = (const __CFString *)cf;
    if ((SHIBYTE(v58) & 0x80000000) == 0)
    {
LABEL_8:
      long long v62 = *(_OWORD *)__dst;
      uint64_t v63 = v58;
LABEL_13:
      if (v20 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v20)))
      {
        sub_19E3C6934(__p, v20);
        if (SHIBYTE(v63) < 0) {
          operator delete((void *)v62);
        }
      }
      else
      {
        *(_OWORD *)std::string __p = v62;
        uint64_t v61 = v63;
      }
LABEL_19:
      uint64_t v22 = sub_19E53BBDC(v17, (uint64_t)__p);
      if (SHIBYTE(v61) < 0) {
        operator delete(__p[0]);
      }
      if (v18 && SHIBYTE(v58) < 0) {
        operator delete(__dst[0]);
      }
      BOOL v24 = 0;
      if (v16 == 500) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = v16;
      }
      uint64_t v26 = *(void *)(a2 + 72);
      if (*(_DWORD *)(a2 + 40) != 3) {
        BOOL v24 = *(unsigned char *)(*(void *)(v26 + 232) + 192) != 0;
      }
      v56[0] = (uint64_t)v14;
      v56[1] = v15;
      v56[2] = v49;
      v56[3] = v48;
      v56[4] = v47;
      v56[5] = v46;
      v56[6] = v45;
      v56[7] = v44;
      if (qword_1EC009490 != -1) {
        dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
      }
      if ((sub_19E413378(v26, v25 | (v22 << 32), v56, a5, qword_1EC009488, v24, v50, v51, v23) & 1) == 0) {
        __assert_rtn("combinedConditionalProbability", "TokenIDLanguageModelSession.cpp", 364, "success");
      }
      if (!v24 || !*(unsigned char *)(a2 + 88)) {
LABEL_66:
      }
        operator new();
      unsigned int v27 = *(unsigned __int16 *)(a2 + 8) | 0x50000;
      *(void *)&long long v62 = &unk_1EF0B5AD8;
      *((void *)&v62 + 1) = a2;
      float v64 = &v62;
      sub_19E3F9E24(v43, v27, (uint64_t)&v62);
      if (v64 == &v62)
      {
        (*(void (**)(long long *))(v62 + 32))(&v62);
      }
      else if (v64)
      {
        (*(void (**)(long long *))(*(void *)v64 + 40))(v64);
      }
      v28.n128_f64[0] = sub_19E53BD30((uint64_t)&v62, v43, *(void *)(a2 + 72), v27, *(unsigned __int16 *)(a2 + 8));
      CFTypeRef v29 = cf;
      CFTypeRef cf = 0;
      if (v29) {
        CFRelease(v29);
      }
      (*(void (**)(void, uint64_t, CFTypeRef *, void, void, uint64_t, __n128))(**(void **)(a2 + 96)
                                                                                            + 40))(*(void *)(a2 + 96), a3, &cf, v62, *((void *)&v62 + 1), 3, v28);
      int v30 = *(std::recursive_mutex **)(*(void *)(a2 + 72) + 464);
      CFTypeRef v31 = cf;
      int v32 = *(char *)(a3 + 23);
      if (!cf)
      {
        if (v32 < 0)
        {
          sub_19E39369C(v54, *(void **)a3, *(void *)(a3 + 8));
        }
        else
        {
          *(_OWORD *)os_signpost_id_t v54 = *(_OWORD *)a3;
          uint64_t v55 = *(void *)(a3 + 16);
        }
LABEL_54:
        uint64_t v35 = sub_19E4B5D64(v30, (uint64_t)v54);
        if (SHIBYTE(v55) < 0) {
          operator delete(v54[0]);
        }
        if (v31 && SHIBYTE(v53) < 0) {
          operator delete(v52[0]);
        }
        uint64_t v36 = *(void *)(a2 + 72);
        uint64_t v37 = *(void *)(v36 + 272);
        if (v37)
        {
          unint64_t v38 = *(void *)(v37 + 56);
          if (v38)
          {
            unint64_t v39 = (std::mutex *)(v38 + 96);
            std::mutex::lock((std::mutex *)(v38 + 96));
            unint64_t v38 = *(void *)(v38 + 40);
            std::mutex::unlock(v39);
            uint64_t v36 = *(void *)(a2 + 72);
          }
        }
        else
        {
          unint64_t v38 = 0;
        }
        uint64_t v40 = *(void *)(v36 + 464);
        uint64_t v41 = v63;
        unint64_t v42 = (unint64_t)v64;
        if (qword_1EC009490 != -1) {
          dispatch_once(&qword_1EC009490, &unk_1EF0BEE38);
        }
        sub_19E4B69CC(v40, v35, v41, v42, a5, v50, (uint64_t)v51, v38);
        goto LABEL_66;
      }
      if (v32 < 0)
      {
        sub_19E39369C(v52, *(void **)a3, *(void *)(a3 + 8));
        CFStringRef v33 = (const __CFString *)cf;
        if ((SHIBYTE(v53) & 0x80000000) == 0) {
          goto LABEL_43;
        }
      }
      else
      {
        *(_OWORD *)unint64_t v52 = *(_OWORD *)a3;
        uint64_t v53 = *(void *)(a3 + 16);
        CFStringRef v33 = (const __CFString *)cf;
        if ((SHIBYTE(v53) & 0x80000000) == 0)
        {
LABEL_43:
          *(_OWORD *)std::string __p = *(_OWORD *)v52;
          uint64_t v61 = v53;
LABEL_48:
          if (v33 && (CFTypeID v34 = CFStringGetTypeID(), v34 == CFGetTypeID(v33)))
          {
            sub_19E3C6934(v54, v33);
            if (SHIBYTE(v61) < 0) {
              operator delete(__p[0]);
            }
          }
          else
          {
            *(_OWORD *)os_signpost_id_t v54 = *(_OWORD *)__p;
            uint64_t v55 = v61;
          }
          goto LABEL_54;
        }
      }
      sub_19E39369C(__p, v52[0], (unint64_t)v52[1]);
      goto LABEL_48;
    }
  }
  sub_19E39369C(&v62, __dst[0], (unint64_t)__dst[1]);
  goto LABEL_13;
}

void sub_19E53B16C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,const void *a47,void *a48,uint64_t a49,int a50,__int16 a51,char a52,char a53)
{
  sub_19E3C6F1C(&a47);
  uint64_t v55 = *(void **)(v53 - 168);
  if (!v55) {
    _Unwind_Resume(a1);
  }
  *(void *)(v53 - 160) = v55;
  operator delete(v55);
  _Unwind_Resume(a1);
}

int32x2_t *sub_19E53B260(int32x2_t **a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a3;
  unint64_t v9 = a5 | 0x40000u;
  v65[0] = &unk_1EF0B52F0;
  v65[1] = &v60;
  uint64_t v66 = v65;
  float32x4_t v67 = (void (**)(void **))&unk_1EF0B5298;
  uint64_t v68 = v65;
  uint64_t v69 = (void **)&v67;
  sub_19E3FA8C0(a2, a4, a5 | 0x40000, (uint64_t)&v67);
  if (v69 == (void **)&v67)
  {
    v67[4]((void **)&v67);
  }
  else if (v69)
  {
    (*((void (**)(void))*v69 + 5))();
  }
  if (v66 == v65)
  {
    (*(void (**)(void *))(v65[0] + 32))(v65);
  }
  else if (v66)
  {
    (*(void (**)(void))(*v66 + 40))();
  }
  unint64_t v10 = a5 | 0x20000u;
  v63[0] = &unk_1EF0B5348;
  v63[1] = &v60;
  float v64 = v63;
  float32x4_t v67 = (void (**)(void **))&unk_1EF0B5298;
  uint64_t v68 = v63;
  uint64_t v69 = (void **)&v67;
  sub_19E3FA8C0(a2, a4, a5 | 0x20000, (uint64_t)&v67);
  if (v69 == (void **)&v67)
  {
    v67[4]((void **)&v67);
  }
  else if (v69)
  {
    (*((void (**)(void))*v69 + 5))();
  }
  if (v64 == v63)
  {
    (*(void (**)(void *))(v63[0] + 32))(v63);
  }
  else if (v64)
  {
    (*(void (**)(void))(*v64 + 40))();
  }
  unint64_t v11 = a5 | 0x30000u;
  v61[0] = &unk_1EF0B53A0;
  v61[1] = &v60;
  long long v62 = (int32x2_t *)v61;
  float32x4_t v67 = (void (**)(void **))&unk_1EF0B5298;
  uint64_t v68 = v61;
  uint64_t v69 = (void **)&v67;
  sub_19E3FA8C0(a2, a4, v11, (uint64_t)&v67);
  if (v69 == (void **)&v67)
  {
    v67[4]((void **)&v67);
  }
  else if (v69)
  {
    (*((void (**)(void))*v69 + 5))();
  }
  uint64_t result = v62;
  if (v62 != (int32x2_t *)v61)
  {
    if (v62) {
      uint64_t result = (int32x2_t *)(*(uint64_t (**)(void))(*(void *)v62 + 40))();
    }
    unint64_t v13 = *(void *)(a2 + 56);
    if (v13) {
      goto LABEL_25;
    }
LABEL_28:
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    __src = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    goto LABEL_112;
  }
  uint64_t result = (int32x2_t *)(*(uint64_t (**)(void *))(v61[0] + 32))(v61);
  unint64_t v13 = *(void *)(a2 + 56);
  if (!v13) {
    goto LABEL_28;
  }
LABEL_25:
  uint64_t v14 = *(void *)(a2 + 48);
  uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    unint64_t v16 = a4;
    if (v13 <= a4) {
      unint64_t v16 = a4 % v13;
    }
  }
  else
  {
    unint64_t v16 = (v13 - 1) & a4;
  }
  uint64_t v22 = *(uint64_t ***)(v14 + 8 * v16);
  if (!v22 || (__n128 v23 = *v22) == 0)
  {
    unsigned int v27 = 0;
    uint64_t v26 = 0;
    goto LABEL_48;
  }
  if (v15.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v25 = v23[1];
      if (v25 == a4)
      {
        if (*((_DWORD *)v23 + 4) == a4) {
          goto LABEL_110;
        }
      }
      else if ((v25 & (v13 - 1)) != v16)
      {
        goto LABEL_46;
      }
      __n128 v23 = (uint64_t *)*v23;
      if (!v23) {
        goto LABEL_46;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = v23[1];
    if (v24 == a4) {
      break;
    }
    if (v24 >= v13) {
      v24 %= v13;
    }
    if (v24 != v16)
    {
LABEL_46:
      uint64_t v26 = 0;
      unsigned int v27 = 0;
      goto LABEL_48;
    }
LABEL_36:
    __n128 v23 = (uint64_t *)*v23;
    if (!v23) {
      goto LABEL_46;
    }
  }
  if (*((_DWORD *)v23 + 4) != a4) {
    goto LABEL_36;
  }
LABEL_110:
  unsigned int v27 = (void *)v23[3];
  uint64_t v26 = (v23[4] - (uint64_t)v27) >> 2;
LABEL_48:
  uint8x8_t v28 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = v9;
    if (v13 <= v9) {
      unint64_t v29 = v9 % v13;
    }
  }
  else
  {
    unint64_t v29 = (v13 - 1) & v9;
  }
  int v30 = *(uint64_t ***)(v14 + 8 * v29);
  __src = v27;
  if (!v30 || (CFTypeRef v31 = *v30) == 0)
  {
    uint64_t v21 = 0;
    uint64_t v20 = 0;
    uint64_t v19 = v26;
    goto LABEL_69;
  }
  if (v28.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v33 = v31[1];
      if (v33 == v9)
      {
        if (*((_DWORD *)v31 + 4) == v9) {
          goto LABEL_111;
        }
      }
      else if ((v33 & (v13 - 1)) != v29)
      {
        goto LABEL_67;
      }
      CFTypeRef v31 = (uint64_t *)*v31;
      if (!v31) {
        goto LABEL_67;
      }
    }
  }
  while (2)
  {
    unint64_t v32 = v31[1];
    if (v32 != v9)
    {
      if (v32 >= v13) {
        v32 %= v13;
      }
      if (v32 != v29)
      {
LABEL_67:
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v19 = v26;
        goto LABEL_69;
      }
      goto LABEL_57;
    }
    if (*((_DWORD *)v31 + 4) != v9)
    {
LABEL_57:
      CFTypeRef v31 = (uint64_t *)*v31;
      if (!v31) {
        goto LABEL_67;
      }
      continue;
    }
    break;
  }
LABEL_111:
  uint64_t v21 = (int32x2_t *)v31[3];
  uint64_t v20 = (v31[4] - (uint64_t)v21) >> 2;
  uint64_t v19 = v26;
LABEL_69:
  uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v34.i16[0] = vaddlv_u8(v34);
  if (v34.u32[0] > 1uLL)
  {
    unint64_t v35 = v10;
    if (v13 <= v10) {
      unint64_t v35 = v10 % v13;
    }
  }
  else
  {
    unint64_t v35 = (v13 - 1) & v10;
  }
  uint64_t v36 = *(uint64_t ***)(v14 + 8 * v35);
  if (!v36 || (uint64_t v37 = *v36) == 0)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    goto LABEL_90;
  }
  if (v34.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v39 = v37[1];
      if (v39 == v10)
      {
        if (*((_DWORD *)v37 + 4) == v10) {
          goto LABEL_134;
        }
      }
      else if ((v39 & (v13 - 1)) != v35)
      {
        goto LABEL_88;
      }
      uint64_t v37 = (uint64_t *)*v37;
      if (!v37) {
        goto LABEL_88;
      }
    }
  }
  while (2)
  {
    unint64_t v38 = v37[1];
    if (v38 != v10)
    {
      if (v38 >= v13) {
        v38 %= v13;
      }
      if (v38 != v35)
      {
LABEL_88:
        uint64_t v18 = 0;
        uint64_t v17 = 0;
        goto LABEL_90;
      }
      goto LABEL_78;
    }
    if (*((_DWORD *)v37 + 4) != v10)
    {
LABEL_78:
      uint64_t v37 = (uint64_t *)*v37;
      if (!v37) {
        goto LABEL_88;
      }
      continue;
    }
    break;
  }
LABEL_134:
  uint64_t v17 = (int32x2_t *)v37[3];
  uint64_t v18 = (v37[4] - (uint64_t)v17) >> 2;
LABEL_90:
  uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v40.i16[0] = vaddlv_u8(v40);
  if (v40.u32[0] > 1uLL)
  {
    unint64_t v41 = v11;
    if (v13 <= v11) {
      unint64_t v41 = v11 % v13;
    }
  }
  else
  {
    unint64_t v41 = (v13 - 1) & v11;
  }
  unint64_t v42 = *(uint64_t ***)(v14 + 8 * v41);
  if (!v42 || (uint64_t v43 = *v42) == 0)
  {
LABEL_112:
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    goto LABEL_113;
  }
  if (v40.u32[0] < 2uLL)
  {
    unint64_t v44 = v13 - 1;
    while (1)
    {
      uint64_t v46 = v43[1];
      if (v46 == v11)
      {
        if (*((_DWORD *)v43 + 4) == v11) {
          goto LABEL_135;
        }
      }
      else if ((v46 & v44) != v41)
      {
        goto LABEL_112;
      }
      uint64_t v43 = (uint64_t *)*v43;
      if (!v43) {
        goto LABEL_112;
      }
    }
  }
  while (1)
  {
    unint64_t v45 = v43[1];
    if (v45 == v11) {
      break;
    }
    if (v45 >= v13) {
      v45 %= v13;
    }
    if (v45 != v41) {
      goto LABEL_112;
    }
LABEL_99:
    uint64_t v43 = (uint64_t *)*v43;
    if (!v43) {
      goto LABEL_112;
    }
  }
  if (*((_DWORD *)v43 + 4) != v11) {
    goto LABEL_99;
  }
LABEL_135:
  uint64_t v48 = (int32x2_t *)v43[3];
  uint64_t v47 = (v43[4] - (uint64_t)v48) >> 2;
LABEL_113:
  size_t v49 = 4 * v19;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (4 * v19)
  {
    if ((v49 & 0x8000000000000000) != 0) {
      sub_19E37C7C4();
    }
    uint64_t result = (int32x2_t *)operator new(4 * v19);
    int v50 = result;
    *a1 = result;
    a1[1] = result;
    uint64_t v51 = v19;
    unint64_t v52 = (int32x2_t *)((char *)result + 4 * v19);
    a1[2] = v52;
    if (v51) {
      uint64_t result = (int32x2_t *)memmove(result, __src, v49);
    }
    a1[1] = v52;
    if (v49 - 4 >= 0xC)
    {
      unint64_t v53 = ((v49 - 4) >> 2) + 1;
      os_signpost_id_t v54 = v50 + 1;
      int32x2_t v55 = vdup_n_s32(0x1F4u);
      uint64_t v56 = v53 & 0x7FFFFFFFFFFFFFFCLL;
      do
      {
        int32x2_t v57 = vceq_s32(v54[-1], v55);
        if (v57.i8[0]) {
          v54[-1].i32[0] = 0;
        }
        if (v57.i8[4]) {
          v54[-1].i32[1] = 0;
        }
        int32x2_t v58 = vceq_s32(*v54, v55);
        if (v58.i8[0]) {
          v54->i32[0] = 0;
        }
        if (v58.i8[4]) {
          v54->i32[1] = 0;
        }
        v54 += 2;
        v56 -= 4;
      }
      while (v56);
      if (v53 == (v53 & 0x7FFFFFFFFFFFFFFCLL)) {
        goto LABEL_114;
      }
      int v50 = (int32x2_t *)((char *)v50 + 4 * (v53 & 0x7FFFFFFFFFFFFFFCLL));
    }
    do
    {
      if (v50->i32[0] == 500) {
        v50->i32[0] = 0;
      }
      int v50 = (int32x2_t *)((char *)v50 + 4);
    }
    while (v50 != v52);
  }
LABEL_114:
  a1[3] = v21;
  a1[4] = (int32x2_t *)v20;
  a1[5] = v17;
  a1[6] = (int32x2_t *)v18;
  a1[7] = v48;
  a1[8] = (int32x2_t *)v47;
  return result;
}

void sub_19E53BB7C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53BB98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  sub_19E53C0DC((uint64_t *)va1);
  sub_19E53C160((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_19E53BBDC(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(*(void *)(a1 + 232) + 192)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(v4 + 560);
  uint64_t v6 = *(std::__shared_weak_count **)(v4 + 568);
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
      if (v5) {
        goto LABEL_5;
      }
      return 0;
    }
  }
  if (!v5) {
    return 0;
  }
LABEL_5:
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = *(void *)(v7 + 560);
  uint64_t v9 = *(std::__shared_weak_count **)(v7 + 568);
  if (v9) {
    atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v8 + 24))(v8, a2, 0);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  return v10;
}

void sub_19E53BD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_19E53BD30(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = a5 | 0x60000u;
  uint64_t v28 = a3;
  v29[0] = &unk_1EF0B53F8;
  v29[1] = &v28;
  int v30 = v29;
  v31[0] = &unk_1EF0B5298;
  v31[1] = v29;
  unint64_t v32 = v31;
  sub_19E3FA8C0(a2, a4, a5 | 0x60000, (uint64_t)v31);
  if (v32 == v31)
  {
    (*(void (**)(void *))(v31[0] + 32))(v31);
  }
  else if (v32)
  {
    (*(void (**)(void))(*v32 + 40))();
  }
  if (v30 != v29)
  {
    if (v30) {
      (*(void (**)(void))(*v30 + 40))();
    }
    unint64_t v9 = *(void *)(a2 + 56);
    if (v9) {
      goto LABEL_9;
    }
LABEL_12:
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    goto LABEL_52;
  }
  (*(void (**)(void *))(v29[0] + 32))(v29);
  unint64_t v9 = *(void *)(a2 + 56);
  if (!v9) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v10 = *(void *)(a2 + 48);
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v11.i16[0] = vaddlv_u8(v11);
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v12 = a4;
    if (v9 <= a4) {
      unint64_t v12 = a4 % v9;
    }
  }
  else
  {
    unint64_t v12 = (v9 - 1) & a4;
  }
  uint64_t v15 = *(uint64_t ***)(v10 + 8 * v12);
  if (!v15 || (uint64_t v16 = *v15) == 0)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    goto LABEL_32;
  }
  if (v11.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v18 = v16[1];
      if (v18 == a4)
      {
        if (*((_DWORD *)v16 + 4) == a4) {
          goto LABEL_54;
        }
      }
      else if ((v18 & (v9 - 1)) != v12)
      {
        goto LABEL_30;
      }
      uint64_t v16 = (uint64_t *)*v16;
      if (!v16) {
        goto LABEL_30;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v16[1];
    if (v17 == a4) {
      break;
    }
    if (v17 >= v9) {
      v17 %= v9;
    }
    if (v17 != v12)
    {
LABEL_30:
      uint64_t v14 = 0;
      uint64_t v13 = 0;
      goto LABEL_32;
    }
LABEL_20:
    uint64_t v16 = (uint64_t *)*v16;
    if (!v16) {
      goto LABEL_30;
    }
  }
  if (*((_DWORD *)v16 + 4) != a4) {
    goto LABEL_20;
  }
LABEL_54:
  uint64_t v13 = v16[3];
  uint64_t v14 = (v16[4] - v13) >> 2;
LABEL_32:
  uint8x8_t v19 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v20 = v8;
    if (v9 <= v8) {
      unint64_t v20 = v8 % v9;
    }
  }
  else
  {
    unint64_t v20 = (v9 - 1) & v8;
  }
  uint64_t v21 = *(uint64_t ***)(v10 + 8 * v20);
  if (v21)
  {
    uint64_t v22 = *v21;
    if (v22)
    {
      if (v19.u32[0] < 2uLL)
      {
        unint64_t v23 = v9 - 1;
        while (1)
        {
          uint64_t v25 = v22[1];
          if (v25 == v8)
          {
            if (*((_DWORD *)v22 + 4) == v8) {
              goto LABEL_55;
            }
          }
          else if ((v25 & v23) != v20)
          {
            goto LABEL_51;
          }
          uint64_t v22 = (uint64_t *)*v22;
          if (!v22) {
            goto LABEL_51;
          }
        }
      }
      do
      {
        unint64_t v24 = v22[1];
        if (v24 == v8)
        {
          if (*((_DWORD *)v22 + 4) == v8)
          {
LABEL_55:
            uint64_t v26 = v22[3];
            unint64_t v9 = (v22[4] - v26) >> 2;
            goto LABEL_53;
          }
        }
        else
        {
          if (v24 >= v9) {
            v24 %= v9;
          }
          if (v24 != v20) {
            break;
          }
        }
        uint64_t v22 = (uint64_t *)*v22;
      }
      while (v22);
    }
  }
LABEL_51:
  unint64_t v9 = 0;
LABEL_52:
  uint64_t v26 = 0;
LABEL_53:
  *(void *)a1 = v13;
  *(void *)(a1 + 8) = v14;
  *(void *)(a1 + 16) = v26;
  *(void *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  return result;
}

void sub_19E53C0C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  sub_19E53C0DC((uint64_t *)va1);
  sub_19E53C160((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *sub_19E53C0DC(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E53C160(void *a1)
{
  unint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *sub_19E53C1E4()
{
  return &unk_1EF0B4BD8;
}

uint64_t sub_19E53C1F0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v1L18specializeTokenIdsERNS0_21LinguisticContextImplEjjNSt3__18functionIFjRKN"
                     "S3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN10applesauce2CF9StringRefEEEEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v1L18specializeTokenIdsERNS0_21LinguisticContextImplEjjNSt3__18fun"
                                "ctionIFjRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN10applesauce2C"
                                "F9StringRefEEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v1L18specializeTokenIdsERNS0_21LinguisticContextImplEjjNSt3__18functionIFjRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN10applesauce2CF9StringRefEEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v1L18specializeTokenIdsERNS0_21LinguisticContextImplEjjNSt3__18functionIFjRKNS3_12basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEERKN10applesauce2CF9StringRefEEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C248(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  if (*(_DWORD *)(a2 + 24)) {
    return *a4;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 8) + 24);
  if (!v6) {
    sub_19E3ACB9C();
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 48))(v6);
  if (result) {
    return result;
  }
  else {
    return *a4;
  }
}

uint64_t sub_19E53C2C0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5298;
  a2[1] = v2;
  return result;
}

void *sub_19E53C2E4(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5298;
  result[1] = v3;
  return result;
}

void sub_19E53C32C()
{
}

void *sub_19E53C344()
{
  return &unk_1EF0B4C18;
}

uint64_t sub_19E53C350(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v1L22multilingualTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLang"
                     "uageModelEjtE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v1L22multilingualTokenSpansERNS0_21LinguisticContextImplEPN2LM22Co"
                                "mpositeLanguageModelEjtE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v1L22multilingualTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v1L22multilingualTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C3A8(uint64_t a1, uint64_t a2, const __CFString **a3)
{
  unint64_t v3 = *(std::recursive_mutex **)(**(void **)(a1 + 8) + 464);
  CFStringRef v4 = *a3;
  int v5 = *(char *)(a2 + 23);
  if (!*a3)
  {
    if (v5 < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v14 = *(void *)(a2 + 16);
    }
    goto LABEL_15;
  }
  if (v5 < 0)
  {
    sub_19E39369C(v11, *(void **)a2, *(void *)(a2 + 8));
    CFStringRef v6 = *a3;
    if ((SHIBYTE(v12) & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_8:
    sub_19E39369C(__p, v11[0], (unint64_t)v11[1]);
    goto LABEL_9;
  }
  *(_OWORD *)uint8x8_t v11 = *(_OWORD *)a2;
  uint64_t v12 = *(void *)(a2 + 16);
  CFStringRef v6 = v4;
  if (SHIBYTE(v12) < 0) {
    goto LABEL_8;
  }
LABEL_4:
  *(_OWORD *)std::string __p = *(_OWORD *)v11;
  uint64_t v16 = v12;
LABEL_9:
  if (v6 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v6)))
  {
    sub_19E3C6934(__dst, v6);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    uint64_t v14 = v16;
  }
LABEL_15:
  uint64_t v9 = sub_19E4B5D64(v3, (uint64_t)__dst);
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
  if (v4 && SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v9;
}

void sub_19E53C504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (v21)
  {
    if (a14 < 0) {
      operator delete(a9);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E53C53C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B53F8;
  a2[1] = v2;
  return result;
}

void *sub_19E53C560(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B53F8;
  result[1] = v3;
  return result;
}

void sub_19E53C5A8()
{
}

void *sub_19E53C5C0()
{
  return &unk_1EF0B4CB8;
}

uint64_t sub_19E53C5CC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14Sani"
                     "tizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_1"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityER"
                                "KNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18fun"
                                "ctionIFdmEEEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C624(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 112), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E53C66C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5AD8;
  a2[1] = v2;
  return result;
}

void *sub_19E53C690(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5AD8;
  result[1] = v3;
  return result;
}

void sub_19E53C6D8()
{
}

void *sub_19E53C6F0()
{
  return &unk_1EF0B4C08;
}

uint64_t sub_19E53C6FC(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLangu"
                     "ageModelEjtE3$_2"
    || ((v3 & (unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22Com"
                                "positeLanguageModelEjtE3$_2" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_2")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C754(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(void **)(a1 + 8);
  if (*(unsigned char *)(*(void *)(v2 + 232) + 192) && (uint64_t v3 = *(void *)(v2 + 288)) != 0) {
    return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v3 + 16) + 24))(*(void *)(v3 + 16), a2, 0);
  }
  else {
    return 0;
  }
}

uint64_t sub_19E53C7AC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B53A0;
  a2[1] = v2;
  return result;
}

void *sub_19E53C7D0(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B53A0;
  result[1] = v3;
  return result;
}

void sub_19E53C818()
{
}

void *sub_19E53C830()
{
  return &unk_1EF0B4BF8;
}

uint64_t sub_19E53C83C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLangu"
                     "ageModelEjtE3$_1"
    || ((v3 & (unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22Com"
                                "positeLanguageModelEjtE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C894(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = **(void **)(a1 + 8);
  if (*(unsigned char *)(*(void *)(v2 + 232) + 192) && (uint64_t v3 = *(void *)(v2 + 296)) != 0) {
    return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(v3 + 16) + 24))(*(void *)(v3 + 16), a2, 0);
  }
  else {
    return 0;
  }
}

uint64_t sub_19E53C8EC(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5348;
  a2[1] = v2;
  return result;
}

void *sub_19E53C910(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5348;
  result[1] = v3;
  return result;
}

void sub_19E53C958()
{
}

void *sub_19E53C970()
{
  return &unk_1EF0B4BE8;
}

uint64_t sub_19E53C97C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLangu"
                     "ageModelEjtE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22Com"
                                "positeLanguageModelEjtE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v1L21specializedTokenSpansERNS0_21LinguisticContextImplEPN2LM22CompositeLanguageModelEjtE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53C9D4(uint64_t a1, uint64_t a2, const __CFString **a3)
{
  uint64_t v3 = **(void **)(a1 + 8);
  CFStringRef v4 = *a3;
  int v5 = *(char *)(a2 + 23);
  if (!*a3)
  {
    if (v5 < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)std::string __dst = *(_OWORD *)a2;
      uint64_t v14 = *(void *)(a2 + 16);
    }
    goto LABEL_15;
  }
  if (v5 < 0)
  {
    sub_19E39369C(v11, *(void **)a2, *(void *)(a2 + 8));
    CFStringRef v6 = *a3;
    if ((SHIBYTE(v12) & 0x80000000) == 0) {
      goto LABEL_4;
    }
LABEL_8:
    sub_19E39369C(__p, v11[0], (unint64_t)v11[1]);
    goto LABEL_9;
  }
  *(_OWORD *)uint8x8_t v11 = *(_OWORD *)a2;
  uint64_t v12 = *(void *)(a2 + 16);
  CFStringRef v6 = v4;
  if (SHIBYTE(v12) < 0) {
    goto LABEL_8;
  }
LABEL_4:
  *(_OWORD *)std::string __p = *(_OWORD *)v11;
  uint64_t v16 = v12;
LABEL_9:
  if (v6 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v6)))
  {
    sub_19E3C6934(__dst, v6);
    if (SHIBYTE(v16) < 0) {
      operator delete(__p[0]);
    }
  }
  else
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    uint64_t v14 = v16;
  }
LABEL_15:
  uint64_t v9 = sub_19E53BBDC(v3, (uint64_t)__dst);
  if (SHIBYTE(v14) < 0) {
    operator delete(__dst[0]);
  }
  if (v4 && SHIBYTE(v12) < 0) {
    operator delete(v11[0]);
  }
  return v9;
}

void sub_19E53CB2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (v21)
  {
    if (a14 < 0) {
      operator delete(a9);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_19E53CB64(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B52F0;
  a2[1] = v2;
  return result;
}

void *sub_19E53CB88(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B52F0;
  result[1] = v3;
  return result;
}

void sub_19E53CBD0()
{
}

void *sub_19E53CBE8()
{
  return &unk_1EF0B82A8;
}

uint64_t sub_19E53CBF4(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14Sani"
                     "tizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityER"
                                "KNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18fun"
                                "ctionIFdmEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30combinedConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextERN2LM18CompositeScoreInfoEbRKNSt3__18functionIFdmEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53CC4C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E53CC94(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5A80;
  a2[1] = v2;
  return result;
}

void *sub_19E53CCB8(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5A80;
  result[1] = v3;
  return result;
}

void sub_19E53CD00()
{
}

uint64_t sub_19E53CD20(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BDEA8;
  a2[1] = v2;
  return result;
}

void *sub_19E53CD44(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BDEA8;
  result[1] = v3;
  return result;
}

void sub_19E53CD8C()
{
}

void *sub_19E53CDA4()
{
  return &unk_1EF0B82C8;
}

uint64_t sub_19E53CDB0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityER"
                     "KNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataEN"
                     "S5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalPr"
                                "obabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_"
                                "INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession41normalizedNameTokenConditionalProbabilityERKNSt3__16vectorINS3_INS0_5TokenENS2_9allocatorIS4_EEEENS5_IS7_EEEERKNS3_INS3_INS0_13TokenMetadataENS5_ISC_EEEENS5_ISE_EEEERKNS0_17LinguisticContextEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

double sub_19E53CE08(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  CFStringRef v4 = *(void **)a2;
  int v5 = *(char *)(a2 + 23);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v7 = *(void **)(v6 + 72);
  unint64_t v8 = *(std::__shared_weak_count **)(v6 + 80);
  cf[0] = v7;
  cf[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = v7[29];
  if (*(char *)(v9 + 455) < 0)
  {
    sub_19E39369C(__p, *(void **)(v9 + 432), *(void *)(v9 + 440));
  }
  else
  {
    uint64_t v10 = v9 + 432;
    *(_OWORD *)std::string __p = *(_OWORD *)v10;
    uint64_t v38 = *(void *)(v10 + 16);
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if ((SHIBYTE(v38) & 0x80000000) == 0) {
      goto LABEL_9;
    }
  }
  else if ((SHIBYTE(v38) & 0x80000000) == 0)
  {
LABEL_9:
    *(_OWORD *)std::string __dst = *(_OWORD *)__p;
    uint64_t v31 = v38;
    int v32 = 0;
    goto LABEL_13;
  }
  sub_19E39369C(__dst, __p[0], (unint64_t)__p[1]);
  int v32 = 0;
  if (SHIBYTE(v38) < 0) {
    operator delete(__p[0]);
  }
LABEL_13:
  sub_19E371C70(v33, (const UInt8 *)__dst);
  int v35 = v32;
  uint64_t v11 = *a3;
  unint64_t v12 = *(unsigned __int16 *)(v6 + 8);
  __p[0] = &unk_1EF0B5B30;
  __p[1] = (void *)v6;
  uint64_t v39 = __p;
  sub_19E3F9E24(v11, v12, (uint64_t)__p);
  if (v39 == __p)
  {
    (*((void (**)(void **))__p[0] + 4))(__p);
    int8x8_t v13 = *(int8x8_t *)(v11 + 56);
    if (!*(void *)&v13) {
      goto LABEL_38;
    }
  }
  else
  {
    if (v39) {
      (*((void (**)(void))*v39 + 5))();
    }
    int8x8_t v13 = *(int8x8_t *)(v11 + 56);
    if (!*(void *)&v13) {
      goto LABEL_38;
    }
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = v12;
    if (*(void *)&v13 <= v12) {
      unint64_t v15 = v12 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v15 = (v13.i32[0] - 1) & v12;
  }
  uint64_t v16 = *(uint64_t ***)(*(void *)(v11 + 48) + 8 * v15);
  if (v16)
  {
    unint64_t v17 = *v16;
    if (v17)
    {
      if (v14.u32[0] < 2uLL)
      {
        uint64_t v18 = *(void *)&v13 - 1;
        while (1)
        {
          uint64_t v20 = v17[1];
          if (v20 == v12)
          {
            if (*((_DWORD *)v17 + 4) == v12) {
              goto LABEL_54;
            }
          }
          else if ((v20 & v18) != v15)
          {
            goto LABEL_38;
          }
          unint64_t v17 = (uint64_t *)*v17;
          if (!v17) {
            goto LABEL_38;
          }
        }
      }
      do
      {
        unint64_t v19 = v17[1];
        if (v19 == v12)
        {
          if (*((_DWORD *)v17 + 4) == v12)
          {
LABEL_54:
            uint64_t v22 = v17[3];
            uint64_t v21 = (v17[4] - v22) >> 2;
            goto LABEL_39;
          }
        }
        else
        {
          if (v19 >= *(void *)&v13) {
            v19 %= *(void *)&v13;
          }
          if (v19 != v15) {
            break;
          }
        }
        unint64_t v17 = (uint64_t *)*v17;
      }
      while (v17);
    }
  }
LABEL_38:
  uint64_t v21 = 0;
  uint64_t v22 = 0;
LABEL_39:
  cf[0] = 0;
  uint64_t v23 = (*(uint64_t (**)(void, void **, CFTypeRef *, uint64_t, uint64_t, uint64_t))(**(void **)(v6 + 104)
                                                                                           + 40))(*(void *)(v6 + 104), v33, cf, v22, v21, 3);
  uint64_t v24 = *(void *)(v6 + 72);
  __p[0] = 0;
  uint64_t v25 = *(void *)(v24 + 248);
  if (!v25
    || !(*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, void **, void, void))(*(void *)v25 + 16))(v25, v23, v22, v21, __p, 0, 0))
  {
    int v26 = 0;
    int64x2_t v29 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    CFTypeRef v27 = cf[0];
    if (!cf[0]) {
      goto LABEL_45;
    }
    goto LABEL_44;
  }
  *(double *)&v29.i64[1] = *(double *)__p * *(double *)(*(void *)(v24 + 248) + 8);
  int v26 = 1;
  CFTypeRef v27 = cf[0];
  if (cf[0]) {
LABEL_44:
  }
    CFRelease(v27);
LABEL_45:
  if ((v34 & 0x80000000) == 0)
  {
    if ((SHIBYTE(v31) & 0x80000000) == 0) {
      goto LABEL_47;
    }
LABEL_52:
    operator delete(__dst[0]);
    if ((v5 & 0x80000000) == 0) {
      goto LABEL_48;
    }
    goto LABEL_53;
  }
  operator delete(v33[0]);
  if (SHIBYTE(v31) < 0) {
    goto LABEL_52;
  }
LABEL_47:
  if ((v5 & 0x80000000) == 0) {
    goto LABEL_48;
  }
LABEL_53:
  operator delete(v4);
LABEL_48:
  double result = *(double *)&v29.i64[1];
  if (!v26) {
    return -1.79769313e308;
  }
  return result;
}

void sub_19E53D228(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  if (v33 < 0) {
    operator delete(v32);
  }
  _Unwind_Resume(exception_object);
}

void *sub_19E53D2B8()
{
  return &unk_1EF0B82B8;
}

uint64_t sub_19E53D2C4(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession30montrealConditionalProbabilityERKNS0_14Sani"
                     "tizedTokenERKNS0_17LinguisticContextEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30montrealConditionalProbabilityER"
                                "KNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession30montrealConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession30montrealConditionalProbabilityERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53D31C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E53D364(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5B30;
  a2[1] = v2;
  return result;
}

void *sub_19E53D388(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5B30;
  result[1] = v3;
  return result;
}

void sub_19E53D3D0()
{
}

uint64_t sub_19E53D3F0(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0BDE50;
  a2[1] = v2;
  return result;
}

void *sub_19E53D414(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0BDE50;
  result[1] = v3;
  return result;
}

void sub_19E53D45C()
{
}

BOOL sub_19E53D474(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 72) + 232);
  if (*(char *)(v1 + 455) < 0)
  {
    sub_19E39369C(&v6, *(void **)(v1 + 432), *(void *)(v1 + 440));
    int v3 = SHIBYTE(v7);
    if ((SHIBYTE(v7) & 0x80000000) == 0) {
      return v3 != 0;
    }
LABEL_5:
    BOOL v4 = *((void *)&v6 + 1) != 0;
    operator delete((void *)v6);
    return v4;
  }
  uint64_t v2 = (long long *)(v1 + 432);
  long long v6 = *v2;
  uint64_t v7 = *((void *)v2 + 2);
  int v3 = SHIBYTE(v7);
  if (SHIBYTE(v7) < 0) {
    goto LABEL_5;
  }
  return v3 != 0;
}

uint64_t sub_19E53D4F8()
{
  return 0;
}

uint64_t sub_19E53D500()
{
  return 0;
}

void sub_19E53D508(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 72);
  uint64_t v4 = *(void *)(v3 + 232);
  if (*(unsigned char *)(v4 + 192))
  {
    sub_19E416ABC(*(void *)(a1 + 72));
    uint64_t v4 = *(void *)(v3 + 232);
  }
  *(unsigned char *)(v4 + 192) = 1;
  CFMutableStringRef MutableCopy = CFDictionaryCreateMutableCopy(0, 0, *(CFDictionaryRef *)(v3 + 432));
  char v6 = *(unsigned char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (const UInt8 *)a2;
  }
  else {
    uint64_t v7 = *(const UInt8 **)a2;
  }
  if (v7)
  {
    if (v6 >= 0) {
      CFIndex v8 = *(unsigned __int8 *)(a2 + 23);
    }
    else {
      CFIndex v8 = *(void *)(a2 + 8);
    }
    CFStringRef v9 = CFStringCreateWithBytes(0, v7, v8, 0x8000100u, 0);
    if (!v9)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v9 = 0;
  }
  CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelCustomDynamicResourceDirectoryKey, v9);
  CFDictionarySetValue(MutableCopy, (const void *)kLMLanguageModelAdaptationEnabledKey, (const void *)*MEMORY[0x1E4F1CFD0]);
  uint64_t v11 = *(const void **)(v3 + 432);
  if (v11) {
    CFRelease(v11);
  }
  *(void *)(v3 + 432) = MutableCopy;
  operator new();
}

void sub_19E53D72C(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53D7BC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 88)) {
    operator new();
  }
  operator new();
}

uint64_t sub_19E53D93C(uint64_t a1)
{
  sub_19E416ABC(*(void *)(a1 + 72));
  *(unsigned char *)(a1 + 88) = 0;
  uint64_t v2 = *(void *)(a1 + 96);
  *(void *)(a1 + 96) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t result = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = 0;
  if (result)
  {
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v4();
  }
  return result;
}

void *sub_19E53D9E0(uint64_t a1)
{
  return sub_19E4164AC(*(void **)(a1 + 72));
}

uint64_t sub_19E53D9E8(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 72);
  if (*(unsigned char *)(*(void *)(v1 + 232) + 192))
  {
    uint64_t v2 = *(void *)(v1 + 264);
    if (v2) {
      return (*(uint64_t (**)(void))(**(void **)(v2 + 8) + 168))();
    }
  }
  return result;
}

void sub_19E53DA2C(uint64_t a1)
{
}

void sub_19E53DA34(uint64_t a1, const UInt8 *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = *(void **)(a1 + 72);
  CFIndex v4 = a2[23];
  if ((v4 & 0x80u) != 0) {
    a2 = *(const UInt8 **)a2;
  }
  if (a2)
  {
    CFIndex v5 = *((void *)v2 + 1);
    if ((v4 & 0x80u) == 0) {
      CFIndex v6 = v4;
    }
    else {
      CFIndex v6 = v5;
    }
    CFStringRef v7 = CFStringCreateWithBytes(0, a2, v6, 0x8000100u, 0);
    if (!v7)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFStringRef v7 = 0;
  }
  sub_19E4154DC(v3, v7);
  if (v7) {
    CFRelease(v7);
  }
}

void sub_19E53DB00(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E53DB18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_19E3C6F1C((const void **)va);
  _Unwind_Resume(a1);
}

void sub_19E53DB2C(uint64_t a1, uint64_t *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 40) == 3 || !*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 232) + 192)) {
    return;
  }
  uint64_t v4 = (*(uint64_t (**)(void))(**(void **)(a1 + 112) + 16))(*(void *)(a1 + 112));
  if (!v4)
  {
    int8x8_t v13 = (char *)operator new(0x38uLL);
    strcpy(v13, "registerNegativeEvidence called with unknown word");
    if (*((char *)a2 + 23) >= 0) {
      uint8x8_t v14 = a2;
    }
    else {
      uint8x8_t v14 = (uint64_t *)*a2;
    }
    sub_19E439798("registerNegativeEvidence called with unknown word: %s", (uint64_t)&v19, v14);
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    unint64_t v15 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)std::string __p = 136315394;
      *(void *)&__p[4] = "logToErrorAndDebug";
      *(_WORD *)&unsigned char __p[12] = 2080;
      *(void *)&__p[14] = v13;
      _os_log_error_impl(&dword_19E36B000, v15, OS_LOG_TYPE_ERROR, "%s: %s", __p, 0x16u);
      if ((v21 & 0x80000000) == 0) {
        goto LABEL_26;
      }
    }
    else if ((v21 & 0x80000000) == 0)
    {
LABEL_26:
      operator delete(v13);
      return;
    }
    operator delete(v19);
    goto LABEL_26;
  }
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 72);
  if (*(unsigned char *)(a1 + 88))
  {
    uint64_t v7 = *(void *)(v6 + 464);
    if (*(unsigned char *)(*(void *)(v7 + 88) + 192))
    {
      std::recursive_mutex::lock(*(std::recursive_mutex **)(v6 + 464));
      sub_19E4B5EC4(&v19, *(void *)(v7 + 128) + 616);
      CFIndex v8 = v19;
      CFStringRef v9 = v20;
      if (v19 != v20)
      {
        do
        {
          (*(void (**)(unsigned char *__return_ptr))(*(void *)*v8 + 32))(__p);
          uint64_t v10 = v23;
          if ((v23 & 0x80u) != 0) {
            uint64_t v10 = *(void *)&__p[8];
          }
          if (v10)
          {
            (*(void (**)(void, unsigned char *, uint64_t, uint64_t))(*(void *)*v8 + 192))(*v8, __p, v5, 1);
            uint64_t v11 = *(void *)(v7 + 88);
            if (*(unsigned char *)(v11 + 192))
            {
              uint64_t v12 = *v8;
              if ((*(unsigned int (**)(void, uint64_t))(*(void *)*v8 + 200))(*v8, v5) >= *(_DWORD *)(v11 + 392)
                && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v12 + 208))(v12, v5) < *(_DWORD *)(v11 + 396))
              {
                (*(void (**)(void, uint64_t))(*(void *)*v8 + 216))(*v8, v5);
              }
            }
          }
          if ((char)v23 < 0) {
            operator delete(*(void **)__p);
          }
          v8 += 2;
        }
        while (v8 != v9);
        CFIndex v8 = v19;
      }
      if (v8)
      {
        uint64_t v16 = v20;
        unint64_t v17 = v8;
        if (v20 != v8)
        {
          do
          {
            uint64_t v18 = (std::__shared_weak_count *)*(v16 - 1);
            if (v18)
            {
              if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
                std::__shared_weak_count::__release_weak(v18);
              }
            }
            v16 -= 2;
          }
          while (v16 != v8);
          unint64_t v17 = v19;
        }
        uint64_t v20 = v8;
        operator delete(v17);
      }
      std::recursive_mutex::unlock((std::recursive_mutex *)v7);
    }
  }
  else
  {
    sub_19E415E94((void *)v6, v5);
  }
}

void sub_19E53DF3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  std::recursive_mutex::unlock(v18);
  _Unwind_Resume(a1);
}

void sub_19E53DF8C(uint64_t a1, long long *a2, uint64_t *a3)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 40) != 3 && *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 232) + 192))
  {
    uint64_t v5 = *a3;
    int v6 = *(unsigned __int16 *)(a1 + 8);
    if (*(unsigned char *)(a1 + 88)) {
      int v7 = 327680;
    }
    else {
      int v7 = 0;
    }
    unsigned int v8 = v7 | v6;
    int32x2_t v55 = (int32x2_t *)&unk_1EF0B5030;
    uint64_t v56 = (int32x2_t *)a1;
    *(void *)&long long v57 = &v55;
    sub_19E3F9E24(v5, v7 | v6, (uint64_t)&v55);
    if ((int32x2_t **)v57 == &v55)
    {
      ((void (*)(int32x2_t **))v55[4])(&v55);
    }
    else if ((void)v57)
    {
      (*(void (**)(void))(*(void *)v57 + 40))(v57);
    }
    sub_19E53B260(&v55, v5, *(void *)(a1 + 72), v8, *(unsigned __int16 *)(a1 + 8));
    if (*(unsigned char *)(a1 + 88))
    {
      v9.n128_f64[0] = sub_19E53BD30((uint64_t)&v46, v5, *(void *)(a1 + 72), v8, *(unsigned __int16 *)(a1 + 8));
      uint64_t v10 = v46;
      uint64_t v11 = v47;
    }
    else
    {
      uint64_t v10 = v55;
      uint64_t v11 = ((char *)v56 - (char *)v55) >> 2;
      uint64_t v46 = v55;
      uint64_t v47 = v11;
      long long v48 = v57;
      long long v49 = v58;
      __n128 v9 = v59;
      __n128 v50 = v59;
    }
    CFTypeRef cf = 0;
    uint64_t v12 = (*(uint64_t (**)(void, long long *, CFTypeRef *, int32x2_t *, uint64_t, uint64_t, __n128))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112), a2, &cf, v10, v11, 2, v9);
    if (v12 < 0x1F4) {
      goto LABEL_55;
    }
    uint64_t v13 = *(void *)(a1 + 72);
    if (!*(unsigned char *)(a1 + 88))
    {
      CFTypeRef v18 = cf;
      int v19 = *((char *)a2 + 23);
      if (cf)
      {
        if (v19 < 0)
        {
          sub_19E39369C(v41, *(void **)a2, *((void *)a2 + 1));
        }
        else
        {
          *(_OWORD *)unint64_t v41 = *a2;
          uint64_t v42 = *((void *)a2 + 2);
        }
        CFStringRef v20 = (const __CFString *)cf;
        if (SHIBYTE(v42) < 0)
        {
          sub_19E39369C(__p, v41[0], (unint64_t)v41[1]);
        }
        else
        {
          *(_OWORD *)std::string __p = *(_OWORD *)v41;
          uint64_t v54 = v42;
        }
        if (v20 && (CFTypeID TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v20)))
        {
          sub_19E3C6934(v51, v20);
          if (SHIBYTE(v54) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v51 = *(_OWORD *)__p;
          uint64_t v52 = v54;
        }
      }
      else if (v19 < 0)
      {
        sub_19E39369C(v51, *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t v51 = *a2;
        uint64_t v52 = *((void *)a2 + 2);
      }
      uint64_t v12 = sub_19E53BBDC(v13, (uint64_t)v51);
      if (SHIBYTE(v52) < 0) {
        operator delete(v51[0]);
      }
      if (v18 && SHIBYTE(v42) < 0)
      {
        uint64_t v22 = v41[0];
        goto LABEL_54;
      }
LABEL_55:
      if (v12)
      {
        uint64_t v24 = *(void **)(a1 + 72);
        if (*(unsigned char *)(a1 + 88))
        {
          uint64_t v25 = v24[58];
          int v26 = *(_DWORD *)(a1 + 144);
          unint64_t v27 = *((void *)&v48 + 1);
          uint64_t v28 = v48;
          std::recursive_mutex::lock((std::recursive_mutex *)v25);
          if (v27)
          {
            uint64_t v29 = 4 * v27;
            unint64_t v30 = v28 + 4 * v27;
            while (v29)
            {
              int v31 = *(_DWORD *)(v28 + v29 - 4);
              v29 -= 4;
              if (v31 == 1)
              {
                uint64_t v32 = (uint64_t)(4 * v27 - (v29 + 4)) >> 2;
                unint64_t v27 = v32 + 1;
                uint64_t v28 = v30 + 4 * ~v32;
                break;
              }
            }
          }
          else
          {
            uint64_t v28 = 0;
          }
          if (v26 != 2 && *(unsigned char *)(*(void *)(v25 + 88) + 192))
          {
            uint64_t v34 = *(void *)(v25 + 144);
            if (v34) {
              sub_19E5340DC(v34, v12, v28, v27);
            }
            sub_19E4B5EC4(__p, *(void *)(v25 + 128) + 616);
            uint64_t v36 = __p[0];
            int v35 = __p[1];
            if (__p[0] != __p[1])
            {
              while (1)
              {
                (*(void (**)(void **__return_ptr))(*(void *)*v36 + 32))(v51);
                uint64_t v37 = (void *)HIBYTE(v52);
                if (v52 < 0) {
                  uint64_t v37 = v51[1];
                }
                if (v37) {
                  break;
                }
                if (SHIBYTE(v52) < 0) {
                  operator delete(v51[0]);
                }
                v36 += 2;
                if (v36 == v35) {
                  goto LABEL_80;
                }
              }
              (*(void (**)(void, void **, uint64_t, float))(*(void *)*v36 + 184))(*v36, v51, v12, -1.0);
              if (SHIBYTE(v52) < 0) {
                operator delete(v51[0]);
              }
LABEL_80:
              uint64_t v36 = __p[0];
            }
            if (v36)
            {
              uint64_t v38 = __p[1];
              uint64_t v39 = v36;
              if (__p[1] != v36)
              {
                do
                {
                  uint64_t v40 = (std::__shared_weak_count *)*(v38 - 1);
                  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
                    std::__shared_weak_count::__release_weak(v40);
                  }
                  v38 -= 2;
                }
                while (v38 != v36);
                uint64_t v39 = __p[0];
              }
              __p[1] = v36;
              operator delete(v39);
            }
          }
          std::recursive_mutex::unlock((std::recursive_mutex *)v25);
          CFTypeRef v33 = cf;
          if (!cf) {
            goto LABEL_92;
          }
          goto LABEL_91;
        }
        sub_19E415CD0(v24, *(_DWORD *)(a1 + 144), v12, v48, *((unint64_t *)&v48 + 1));
      }
      CFTypeRef v33 = cf;
      if (!cf)
      {
LABEL_92:
        if (v55)
        {
          uint64_t v56 = v55;
          operator delete(v55);
        }
        return;
      }
LABEL_91:
      CFRelease(v33);
      goto LABEL_92;
    }
    uint8x8_t v14 = *(std::recursive_mutex **)(v13 + 464);
    CFTypeRef v15 = cf;
    int v16 = *((char *)a2 + 23);
    if (!cf)
    {
      if (v16 < 0)
      {
        sub_19E39369C(v51, *(void **)a2, *((void *)a2 + 1));
      }
      else
      {
        *(_OWORD *)uint64_t v51 = *a2;
        uint64_t v52 = *((void *)a2 + 2);
      }
      goto LABEL_37;
    }
    if (v16 < 0)
    {
      sub_19E39369C(&__dst, *(void **)a2, *((void *)a2 + 1));
      CFStringRef v17 = (const __CFString *)cf;
      if ((SHIBYTE(v44) & 0x80000000) == 0) {
        goto LABEL_18;
      }
    }
    else
    {
      long long __dst = *a2;
      uint64_t v44 = *((void *)a2 + 2);
      CFStringRef v17 = (const __CFString *)cf;
      if ((SHIBYTE(v44) & 0x80000000) == 0)
      {
LABEL_18:
        *(_OWORD *)std::string __p = __dst;
        uint64_t v54 = v44;
LABEL_26:
        if (v17 && (CFTypeID v21 = CFStringGetTypeID(), v21 == CFGetTypeID(v17)))
        {
          sub_19E3C6934(v51, v17);
          if (SHIBYTE(v54) < 0) {
            operator delete(__p[0]);
          }
        }
        else
        {
          *(_OWORD *)uint64_t v51 = *(_OWORD *)__p;
          uint64_t v52 = v54;
        }
LABEL_37:
        uint64_t v12 = sub_19E4B5D64(v14, (uint64_t)v51);
        if (SHIBYTE(v52) < 0) {
          operator delete(v51[0]);
        }
        if (v15 && SHIBYTE(v44) < 0)
        {
          uint64_t v22 = (void *)__dst;
LABEL_54:
          operator delete(v22);
          goto LABEL_55;
        }
        goto LABEL_55;
      }
    }
    sub_19E39369C(__p, (void *)__dst, *((unint64_t *)&__dst + 1));
    goto LABEL_26;
  }
}

void sub_19E53E5B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,const void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,char a38)
{
  sub_19E3C6F1C(&a22);
  uint64_t v40 = *(void **)(v38 - 128);
  if (!v40) {
    _Unwind_Resume(a1);
  }
  *(void *)(v38 - 120) = v40;
  operator delete(v40);
  _Unwind_Resume(a1);
}

void *sub_19E53E6CC()
{
  return &unk_1EF0B8088;
}

uint64_t sub_19E53E6D8(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v127TokenIDLanguageModelSession14unAdaptToTokenERKNS0_14SanitizedTokenERKNS0_"
                     "17LinguisticContextEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v127TokenIDLanguageModelSession14unAdaptToTokenERKNS0_14SanitizedT"
                                "okenERKNS0_17LinguisticContextEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v127TokenIDLanguageModelSession14unAdaptToTokenERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v127TokenIDLanguageModelSession14unAdaptToTokenERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53E730(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 112), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E53E778(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5030;
  a2[1] = v2;
  return result;
}

void *sub_19E53E79C(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5030;
  result[1] = v3;
  return result;
}

void sub_19E53E7E4()
{
}

void sub_19E53E7FC(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 40) != 3 && *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 232) + 192))
  {
    uint64_t v5 = *a3;
    int v6 = *(unsigned __int16 *)(a1 + 8);
    if (*(unsigned char *)(a1 + 88)) {
      int v7 = 327680;
    }
    else {
      int v7 = 0;
    }
    unsigned int v8 = v7 | v6;
    std::string __p = &unk_1EF0B4FD8;
    unint64_t v27 = (unsigned char *)a1;
    *(void *)&long long v28 = &__p;
    sub_19E3F9E24(v5, v7 | v6, (uint64_t)&__p);
    if ((void **)v28 == &__p)
    {
      (*((void (**)(void **))__p + 4))(&__p);
    }
    else if ((void)v28)
    {
      (*(void (**)(void))(*(void *)v28 + 40))();
    }
    sub_19E53B260((int32x2_t **)&__p, v5, *(void *)(a1 + 72), v8, *(unsigned __int16 *)(a1 + 8));
    if (*(unsigned char *)(a1 + 88))
    {
      v9.n128_f64[0] = sub_19E53BD30((uint64_t)&v21, v5, *(void *)(a1 + 72), v8, *(unsigned __int16 *)(a1 + 8));
      uint64_t v10 = v21;
      uint64_t v11 = v22;
    }
    else
    {
      uint64_t v10 = __p;
      uint64_t v11 = (v27 - (unsigned char *)__p) >> 2;
      CFTypeID v21 = __p;
      uint64_t v22 = v11;
      long long v23 = v28;
      long long v24 = v29;
      __n128 v9 = v30;
      __n128 v25 = v30;
    }
    CFTypeRef cf = 0;
    uint64_t v12 = (*(uint64_t (**)(void, uint64_t, CFTypeRef *, void *, uint64_t, uint64_t, __n128))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112), a2, &cf, v10, v11, 2, v9);
    if ((v12 - 500) <= 0xFFFFFE0C) {
      uint64_t v12 = sub_19E530A8C((uint64_t *)(a1 + 120), a2, (const __CFString *)cf, v12 != 0);
    }
    uint64_t v13 = *(void **)(a1 + 72);
    if (*(unsigned char *)(a1 + 88)) {
      sub_19E4B6718(v13[58], *(_DWORD *)(a1 + 144), 0, v12, (_DWORD *)v23, *((unint64_t *)&v23 + 1));
    }
    else {
      sub_19E415A64(v13, *(_DWORD *)(a1 + 144), 0, v12, (_DWORD *)v23, *((unint64_t *)&v23 + 1));
    }
    uint8x8_t v14 = *(void **)(a1 + 72);
    char v15 = *(unsigned char *)(a2 + 23);
    if (v15 >= 0) {
      int v16 = (const UInt8 *)a2;
    }
    else {
      int v16 = *(const UInt8 **)a2;
    }
    if (v16)
    {
      if (v15 >= 0) {
        CFIndex v17 = *(unsigned __int8 *)(a2 + 23);
      }
      else {
        CFIndex v17 = *(void *)(a2 + 8);
      }
      CFStringRef v18 = CFStringCreateWithBytes(0, v16, v17, 0x8000100u, 0);
      if (!v18)
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      CFStringRef v18 = 0;
    }
    sub_19E4152D0(v14, v18);
    if (v18) {
      CFRelease(v18);
    }
    if (cf) {
      CFRelease(cf);
    }
    if (__p)
    {
      unint64_t v27 = __p;
      operator delete(__p);
    }
  }
}

void sub_19E53EAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  if (!__p) {
    _Unwind_Resume(a1);
  }
  a20 = (uint64_t)__p;
  operator delete(__p);
  _Unwind_Resume(a1);
}

void *sub_19E53EB84()
{
  return &unk_1EF0B8078;
}

uint64_t sub_19E53EB90(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZN17language_modeling2v127TokenIDLanguageModelSession12adaptToTokenERKNS0_14SanitizedTokenERKNS0_17"
                     "LinguisticContextEE3$_0"
    || ((v3 & (unint64_t)"ZN17language_modeling2v127TokenIDLanguageModelSession12adaptToTokenERKNS0_14SanitizedTok"
                                "enERKNS0_17LinguisticContextEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZN17language_modeling2v127TokenIDLanguageModelSession12adaptToTokenERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZN17language_modeling2v127TokenIDLanguageModelSession12adaptToTokenERKNS0_14SanitizedTokenERKNS0_17LinguisticContextEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E53EBE8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 112), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E53EC30(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B4FD8;
  a2[1] = v2;
  return result;
}

void *sub_19E53EC54(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B4FD8;
  result[1] = v3;
  return result;
}

void sub_19E53EC9C()
{
}

void sub_19E53ECB4(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a1 + 40) != 3 && *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 232) + 192))
  {
    if (*(_DWORD *)(a1 + 144) != 1)
    {
      if (qword_1EC0095B8 != -1) {
        dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
      }
      unsigned int v8 = qword_1EC0095B0;
      if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
      {
        int v32 = *(_DWORD *)(a1 + 144);
        *(_DWORD *)std::string __p = 136315394;
        *(void *)&__p[4] = "adaptToText";
        *(_WORD *)&unsigned char __p[12] = 1024;
        *(_DWORD *)&__p[14] = v32;
        _os_log_error_impl(&dword_19E36B000, v8, OS_LOG_TYPE_ERROR, "%s: Unexpected adaptation type: %d (this function is only expected to be used for offline adaptation)", __p, 0x12u);
      }
    }
    __n128 v9 = *(uint64_t **)(a1 + 72);
    CFStringRef v10 = sub_19E3C2A64(a2);
    *(void *)std::string __p = v10;
    CFIndex Length = CFStringGetLength(v10);
    BOOL v12 = sub_19E416150(v9, v10, 0, Length);
    if (v10) {
      CFRelease(v10);
    }
    if (v12)
    {
      sub_19E49BE4C((uint64_t *)(a1 + 136), a2, (uint64_t *)(a1 + 152));
      (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 24))(*(void *)(a1 + 112), a1 + 152);
      uint64_t v13 = *(char **)(a1 + 176);
      uint8x8_t v14 = *(char **)(a1 + 184);
      unint64_t v15 = (v14 - v13) >> 2;
      int v16 = *(uint64_t **)(a1 + 72);
      if (!*(unsigned char *)(a1 + 88))
      {
        if (!sub_19E416368(v16, *(unsigned int **)(a1 + 176), (v14 - v13) >> 2)) {
          return;
        }
LABEL_38:
        sub_19E531B44(a1 + 120, (uint64_t *)(a1 + 152));
        if (a4) {
          double Current = sub_19E43BEE8(a3);
        }
        else {
          double Current = CFAbsoluteTimeGetCurrent();
        }
        *(double *)std::string __p = Current;
        if (v14 != v13)
        {
          unint64_t v28 = 0;
          if (a4) {
            long long v29 = (double *)__p;
          }
          else {
            long long v29 = 0;
          }
          if (v15 <= 1) {
            unint64_t v15 = 1;
          }
          do
          {
            uint64_t v30 = *(unsigned int *)&v13[4 * v28];
            uint64_t v31 = *(void **)(a1 + 72);
            if (*(unsigned char *)(a1 + 88)) {
              sub_19E4B6718(v31[58], *(_DWORD *)(a1 + 144), v29, v30, v13, v28);
            }
            else {
              sub_19E415A64(v31, *(_DWORD *)(a1 + 144), v29, v30, v13, v28);
            }
            ++v28;
          }
          while (v15 != v28);
        }
        return;
      }
      uint64_t v17 = v16[58];
      std::recursive_mutex::lock((std::recursive_mutex *)v17);
      sub_19E4BB22C(__p, *(void *)(v17 + 104), *(void *)(v17 + 112));
      if (*(void *)(v17 + 144))
      {
        if (*(void *)__p == *(void *)&__p[8])
        {
          BOOL v20 = 0;
          if (!*(void *)__p)
          {
LABEL_37:
            std::recursive_mutex::unlock((std::recursive_mutex *)v17);
            if (!v20) {
              return;
            }
            goto LABEL_38;
          }
LABEL_36:
          operator delete(*(void **)__p);
          goto LABEL_37;
        }
        float v18 = 1.0 / (float)v15;
        int v19 = *(uint64_t **)__p;
        do
        {
          if ((unint64_t)(v14 - v13) >= 4)
          {
            unint64_t v21 = 0;
            unint64_t v22 = 0;
            uint64_t v23 = *v19;
            uint64_t v24 = 4 * v15;
            __n128 v25 = (unsigned int *)v13;
            do
            {
              unsigned int v26 = *v25;
              if (!*v25 || *(_DWORD *)(v23 + 28) <= v26 && v26 <= *(_DWORD *)(v23 + 32)) {
                ++v21;
              }
              if (v26 - 10 < 0x35) {
                ++v22;
              }
              ++v25;
              v24 -= 4;
            }
            while (v24);
            BOOL v20 = (float)(v18 * (float)v22) < 0.2 && (float)(v18 * (float)v21) < 0.15;
          }
          else
          {
            BOOL v20 = 0;
          }
          if (v20) {
            break;
          }
          ++v19;
        }
        while (v19 != *(uint64_t **)&__p[8]);
      }
      else
      {
        BOOL v20 = 0;
      }
      if (!*(void *)__p) {
        goto LABEL_37;
      }
      goto LABEL_36;
    }
  }
}

void sub_19E53F050(_Unwind_Exception *a1)
{
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_19E53F064(_Unwind_Exception *exception_object, int a2)
{
  if (a2) {
    sub_19E37B770(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53F098(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5)
{
  if (*(_DWORD *)(a1 + 40) == 3) {
    return;
  }
  int v6 = *(uint64_t **)(a1 + 72);
  if (!*(unsigned char *)(v6[29] + 192)) {
    return;
  }
  if (*(_DWORD *)(a1 + 144) == 1)
  {
    uint64_t v11 = (__CFString *)sub_19E3C2A64(a2);
    __src = v11;
    CFIndex Length = CFStringGetLength(v11);
    BOOL v13 = sub_19E416150(v6, v11, 0, Length);
    if (v11) {
      CFRelease(v11);
    }
    if (!v13) {
      return;
    }
  }
  uint64_t v59 = a4;
  uint64_t v14 = *(unsigned int *)(a1 + 328);
  if ((int)v14 < 1) {
    goto LABEL_29;
  }
  uint64_t v15 = 0;
  uint64_t v16 = *(void *)(a1 + 224);
  char v17 = *(unsigned char *)(a2 + 23);
  if (v17 >= 0) {
    uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v18 = *(void *)(a2 + 8);
  }
  if (v17 >= 0) {
    int v19 = (unsigned __int8 *)a2;
  }
  else {
    int v19 = *(unsigned __int8 **)a2;
  }
  while (1)
  {
    BOOL v20 = (unsigned __int8 *)(v16 + 24 * v15);
    uint64_t v21 = v20[23];
    if ((v21 & 0x80u) == 0) {
      uint64_t v22 = v20[23];
    }
    else {
      uint64_t v22 = *((void *)v20 + 1);
    }
    if (v22 != v18) {
      goto LABEL_15;
    }
    if ((v21 & 0x80) == 0) {
      break;
    }
    if (!memcmp(*(const void **)v20, v19, *((void *)v20 + 1))) {
      goto LABEL_25;
    }
LABEL_15:
    if (++v15 == v14) {
      goto LABEL_29;
    }
  }
  if (v20[23])
  {
    uint64_t v23 = v19;
    while (*v20 == *v23)
    {
      ++v20;
      ++v23;
      if (!--v21) {
        goto LABEL_25;
      }
    }
    goto LABEL_15;
  }
LABEL_25:
  if ((v15 & 0x80000000) == 0)
  {
    ++*(void *)(a1 + 336);
    uint64_t v24 = *(void *)(a1 + 272);
    uint64_t v25 = *(void *)(a1 + 320);
    if (*(void *)(v24 + 8 * v15) != v25)
    {
      uint64_t v26 = v25 + 1;
      *(void *)(a1 + 320) = v26;
      *(void *)(v24 + 8 * v15) = v26;
    }
    uint64_t v27 = *(void *)(a1 + 248) + 24 * v15;
    goto LABEL_69;
  }
LABEL_29:
  ++*(void *)(a1 + 344);
  sub_19E49BE4C((uint64_t *)(a1 + 136), a2, (uint64_t *)(a1 + 152));
  (*(void (**)(void, uint64_t))(**(void **)(a1 + 112) + 24))(*(void *)(a1 + 112), a1 + 152);
  sub_19E531B44(a1 + 120, (uint64_t *)(a1 + 152));
  __src = 0;
  *(void *)uint64_t v61 = 0;
  long long v62 = 0;
  long long v29 = *(unsigned char **)(a1 + 176);
  unint64_t v28 = *(unsigned char **)(a1 + 184);
  int64_t v30 = v28 - v29;
  if (v28 == v29)
  {
    uint64_t v31 = 0;
    int v32 = 0;
  }
  else
  {
    if (v30 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v31 = (char *)operator new(v28 - v29);
    int v32 = &v31[4 * (v30 >> 2)];
    __src = v31;
    long long v62 = v32;
    memcpy(v31, v29, v30);
    *(void *)uint64_t v61 = v32;
  }
  uint64_t v27 = *(void *)(a1 + 296);
  uint64_t v33 = *(void *)(a1 + 304);
  if (v27 != v33)
  {
    while (*(void *)(v27 + 8) - *(void *)v27 != v32 - v31 || memcmp(*(const void **)v27, v31, v32 - v31))
    {
      v27 += 24;
      if (v27 == v33)
      {
        uint64_t v27 = v33;
        break;
      }
    }
  }
  if (v27 == v33)
  {
    unint64_t v34 = *(int *)(a1 + 328);
    uint64_t v35 = *(void *)(a1 + 224);
    if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 232) - v35) >> 3) <= v34)
    {
      if ((int)v34 < 2)
      {
        LODWORD(v34) = 0;
      }
      else
      {
        uint64_t v36 = *(unint64_t **)(a1 + 272);
        unint64_t v37 = *v36;
        uint64_t v38 = 1;
        LODWORD(v34) = 0;
        do
        {
          unint64_t v39 = v36[v38];
          if (v37 > v39) {
            LODWORD(v34) = v38;
          }
          if (v37 >= v39) {
            unint64_t v37 = v36[v38];
          }
          ++v38;
        }
        while (*(_DWORD *)(a1 + 328) != v38);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 328) = v34 + 1;
    }
    uint64_t v40 = v35 + 24 * (int)v34;
    if (v40 != a2)
    {
      char v41 = *(unsigned char *)(a2 + 23);
      if (*(char *)(v40 + 23) < 0)
      {
        if (v41 >= 0) {
          uint64_t v43 = (unsigned __int8 *)a2;
        }
        else {
          uint64_t v43 = *(unsigned __int8 **)a2;
        }
        if (v41 >= 0) {
          size_t v44 = *(unsigned __int8 *)(a2 + 23);
        }
        else {
          size_t v44 = *(void *)(a2 + 8);
        }
        sub_19E3C6D44((void **)v40, v43, v44);
      }
      else if ((*(unsigned char *)(a2 + 23) & 0x80) != 0)
      {
        sub_19E3C6C7C((void *)v40, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        long long v42 = *(_OWORD *)a2;
        *(void *)(v40 + 16) = *(void *)(a2 + 16);
        *(_OWORD *)uint64_t v40 = v42;
      }
    }
    uint64_t v45 = (int)v34;
    uint64_t v46 = *(void *)(a1 + 248);
    uint64_t v47 = (void **)(v46 + 24 * (int)v34);
    uint64_t v31 = (char *)__src;
    if (v47 != &__src)
    {
      sub_19E44A444(v47, (char *)__src, *(char **)v61, (uint64_t)(*(void *)v61 - (void)__src) >> 2);
      uint64_t v46 = *(void *)(a1 + 248);
      uint64_t v31 = (char *)__src;
    }
    uint64_t v48 = *(void *)(a1 + 320) + 1;
    *(void *)(a1 + 320) = v48;
    *(void *)(*(void *)(a1 + 272) + 8 * v45) = v48;
    uint64_t v27 = v46 + 24 * (int)v45;
  }
  if (v31)
  {
    *(void *)uint64_t v61 = v31;
    operator delete(v31);
  }
LABEL_69:
  __n128 v50 = *(const void **)v27;
  uint64_t v49 = *(void *)(v27 + 8);
  int64_t v51 = v49 - *(void *)v27;
  if (v49 == *(void *)v27)
  {
    unint64_t v53 = 0;
    uint64_t v52 = 0;
    if (a5) {
      goto LABEL_72;
    }
  }
  else
  {
    if (v51 < 0) {
      sub_19E37C7C4();
    }
    uint64_t v52 = operator new(v49 - *(void *)v27);
    unint64_t v53 = (char *)&v52[v51 >> 2];
    memcpy(v52, v50, v51);
    if (a5)
    {
LABEL_72:
      sub_19E43BEE8(v59);
      goto LABEL_75;
    }
  }
  CFAbsoluteTimeGetCurrent();
LABEL_75:
  uint64_t v54 = (v53 - (char *)v52) >> 2;
  if (!a3)
  {
    sub_19E416DB0(*(void **)(a1 + 72), (CFStringRef)kLMAdaptationContextSelfSender, v52, v54);
    goto LABEL_87;
  }
  if (a3 != 1)
  {
    if (a3 == 2) {
      __assert_rtn("addPriorText", "TokenIDLanguageModelSession.cpp", 1168, "false");
    }
    goto LABEL_87;
  }
  if (*(char *)(a1 + 71) < 0)
  {
    int32x2_t v55 = *(const UInt8 **)(a1 + 48);
    if (v55)
    {
      CFIndex v56 = *(void *)(a1 + 56);
      goto LABEL_84;
    }
    long long v57 = 0;
    __src = 0;
  }
  else
  {
    int32x2_t v55 = (const UInt8 *)(a1 + 48);
    CFIndex v56 = *(unsigned __int8 *)(a1 + 71);
LABEL_84:
    long long v57 = (__CFString *)CFStringCreateWithBytes(0, v55, v56, 0x8000100u, 0);
    __src = v57;
    if (!v57)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  sub_19E416DB0(*(void **)(a1 + 72), v57, v52, v54);
  if (v57) {
    CFRelease(v57);
  }
LABEL_87:
  if (v52) {
    operator delete(v52);
  }
}

void sub_19E53F5F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (v15)
  {
    operator delete(v15);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_19E53F68C()
{
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  if (qword_1E9459E10 != -1) {
    dispatch_once(&qword_1E9459E10, &unk_1EF0B5D80);
  }
  int v0 = qword_1E9459E08;
  if (os_log_type_enabled((os_log_t)qword_1E9459E08, OS_LOG_TYPE_ERROR))
  {
    int v1 = 136315138;
    uint64_t v2 = "enumerateInlineCompletions";
    _os_log_error_impl(&dword_19E36B000, v0, OS_LOG_TYPE_ERROR, "%s: Inline completions are not supported for pure tokenID models", (uint8_t *)&v1, 0xCu);
  }
}

os_log_t sub_19E53F75C()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "InlineCompletionsNonStatic");
  qword_1E9459E08 = (uint64_t)result;
  return result;
}

void sub_19E53F78C(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
}

void sub_19E53F7A4(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = (uint64_t *)*a2;
  sub_19E43A85C(&v48, a3, a4);
  if (v48 == v49) {
    goto LABEL_42;
  }
  if (v49 - (unsigned char *)v48 != 8) {
    goto LABEL_13;
  }
  uint64_t v6 = *(void *)(*(void *)v48 + 32);
  if (*(void *)(*(void *)v48 + 24) == v6)
  {
    HIBYTE(v51) = 0;
    LOBYTE(__p[0]) = 0;
  }
  else if (*(char *)(v6 - 9) < 0)
  {
    sub_19E39369C(__p, *(void **)(v6 - 32), *(void *)(v6 - 24));
  }
  else
  {
    long long v7 = *(_OWORD *)(v6 - 32);
    uint64_t v51 = *(void *)(v6 - 16);
    *(_OWORD *)std::string __p = v7;
  }
  if (v51 >= 0) {
    unsigned int v8 = (void *)HIBYTE(v51);
  }
  else {
    unsigned int v8 = __p[1];
  }
  if ((SHIBYTE(v51) & 0x80000000) == 0)
  {
    if (v8) {
      goto LABEL_13;
    }
LABEL_42:
    sub_19E54135C(a1, a2);
  }
  operator delete(__p[0]);
  if (!v8) {
    goto LABEL_42;
  }
LABEL_13:
  unsigned int v9 = *(unsigned __int16 *)(a1 + 8);
  __p[0] = &unk_1EF0B57C0;
  __p[1] = (void *)a1;
  uint64_t v52 = __p;
  unsigned int v27 = v9;
  sub_19E3F9E24((uint64_t)v5, v9, (uint64_t)__p);
  if (v52 == __p)
  {
    (*((void (**)(void **))__p[0] + 4))(__p);
  }
  else if (v52)
  {
    (*((void (**)(void))*v52 + 5))();
  }
  sub_19E5422D4(*v5, v5[1], *(void **)(a1 + 72));
  uint64_t v46 = 0;
  uint64_t v45 = 0;
  uint64_t v47 = 0;
  CFStringRef v10 = v48;
  if (v48 != v49)
  {
    *(_OWORD *)long long v42 = 0u;
    long long v43 = 0u;
    int v44 = 1065353216;
    uint64_t v11 = *(uint64_t **)v48;
    uint64_t v40 = (v5[1] - *v5) >> 5;
    char v41 = v5;
    uint64_t v12 = *v11;
    uint64_t v13 = (v11[1] - *v11) >> 5;
    uint64_t v14 = v13 - 1;
    if (v13 != 1)
    {
      do
      {
        sub_19E3F92F4((uint64_t)v5, v12);
        v12 += 32;
        --v14;
      }
      while (v14);
    }
    __p[0] = &unk_1EF0B5818;
    __p[1] = (void *)a1;
    uint64_t v52 = __p;
    sub_19E3F9E24((uint64_t)v5, v27, (uint64_t)__p);
    if (v52 == __p)
    {
      (*((void (**)(void **))__p[0] + 4))(__p);
    }
    else if (v52)
    {
      (*((void (**)(void))*v52 + 5))();
    }
    sub_19E53B260((int32x2_t **)v36, (uint64_t)v5, *(void *)(a1 + 72), v27, *(unsigned __int16 *)(a1 + 8));
    uint64_t v15 = *(void *)(a1 + 72);
    int64_t v30 = v36[0];
    int64_t v31 = ((char *)v36[1] - (char *)v36[0]) >> 2;
    long long v32 = v37;
    long long v33 = v38;
    long long v34 = v39;
    uint64_t v16 = *(void *)(*(void *)v10 + 32);
    if (*(void *)(*(void *)v10 + 24) == v16)
    {
      HIBYTE(v51) = 0;
      LOBYTE(__p[0]) = 0;
    }
    else if (*(char *)(v16 - 9) < 0)
    {
      sub_19E39369C(__p, *(void **)(v16 - 32), *(void *)(v16 - 24));
    }
    else
    {
      long long v17 = *(_OWORD *)(v16 - 32);
      uint64_t v51 = *(void *)(v16 - 16);
      *(_OWORD *)std::string __p = v17;
    }
    if (v51 >= 0) {
      uint64_t v18 = __p;
    }
    else {
      uint64_t v18 = (void **)__p[0];
    }
    if (v18)
    {
      if (v51 >= 0) {
        CFIndex v19 = HIBYTE(v51);
      }
      else {
        CFIndex v19 = (CFIndex)__p[1];
      }
      v29[0] = (void *)CFStringCreateWithBytes(0, (const UInt8 *)v18, v19, 0x8000100u, 0);
      if (!v29[0])
      {
        exception = __cxa_allocate_exception(0x10uLL);
        MEMORY[0x19F3BD790](exception, "Could not construct");
        __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
      }
    }
    else
    {
      v29[0] = 0;
    }
    sub_19E3FD31C((int)&v35, *(void *)(v15 + 8), *(std::__shared_weak_count **)(v15 + 16));
  }
  sub_19E5424C8(0, 0, 0, 1);
  BOOL v20 = v48;
  if (v48)
  {
    uint64_t v21 = v49;
    uint64_t v22 = v48;
    if (v49 != v48)
    {
      do
      {
        uint64_t v24 = (void **)*--v21;
        uint64_t v23 = v24;
        *uint64_t v21 = 0;
        if (v24)
        {
          uint64_t v25 = sub_19E3C3D24(v23);
          MEMORY[0x19F3BDCF0](v25, 0x1030C403C62F202);
        }
      }
      while (v21 != v20);
      uint64_t v22 = v48;
    }
    uint64_t v49 = v20;
    operator delete(v22);
  }
}

void sub_19E5410F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  if (SLOBYTE(STACK[0x287]) < 0) {
    operator delete((void *)STACK[0x270]);
  }
  __cxa_guard_abort(&qword_1EC0091B0);
  if (a63) {
    (*(void (**)(uint64_t))(*(void *)a63 + 8))(a63);
  }
  if (a64) {
    operator delete(a64);
  }
  sub_19E5423FC(&STACK[0x200]);
  sub_19E542440((uint64_t)&STACK[0x210]);
  sub_19E543DD8((void **)&STACK[0x240]);
  sub_19E3D34D0(&STACK[0x258]);
  _Unwind_Resume(a1);
}

void sub_19E54133C()
{
}

void sub_19E54135C(uint64_t a1, uint64_t *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  unsigned int v4 = *(unsigned __int16 *)(a1 + 8);
  v17[0] = &unk_1EF0B5870;
  v17[1] = a1;
  uint64_t v18 = v17;
  sub_19E3F9E24(v3, v4, (uint64_t)v17);
  if (v18 == v17)
  {
    uint64_t v5 = (uint64_t *)v3;
    (*(void (**)(void *))(v17[0] + 32))(v17);
  }
  else
  {
    uint64_t v5 = (uint64_t *)v3;
    if (v18) {
      (*(void (**)(void *))(*v18 + 40))(v18);
    }
  }
  sub_19E53B260(v16, (uint64_t)v5, *(void *)(a1 + 72), v4, *(unsigned __int16 *)(a1 + 8));
  long long v7 = v16[0];
  uint64_t v6 = v16[1];
  unsigned int v8 = v16[3];
  unsigned int v9 = v16[4];
  CFStringRef v10 = v16[5];
  uint64_t v11 = v16[6];
  uint64_t v14 = v16[7];
  uint64_t v13 = v16[8];
  sub_19E5422D4(*v5, v5[1], *(void **)(a1 + 72));
  uint64_t v12 = *(void *)(a1 + 72);
  v15[0] = (uint64_t)v7;
  v15[1] = ((char *)v6 - (char *)v7) >> 2;
  void v15[2] = (uint64_t)v8;
  v15[3] = (uint64_t)v9;
  void v15[4] = (uint64_t)v10;
  v15[5] = (uint64_t)v11;
  v15[6] = (uint64_t)v14;
  v15[7] = (uint64_t)v13;
  sub_19E414CD8(v12, v15);
}

void sub_19E5420C4(_Unwind_Exception *a1)
{
  sub_19E418864(*(void **)(v3 + 80));
  uint64_t v5 = *(void *)(v3 + 64);
  *(void *)(v3 + 64) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  if (*(unsigned char *)(v3 + 24)) {
    std::recursive_mutex::unlock(*(std::recursive_mutex **)(v3 + 16));
  }
  MEMORY[0x19F3BDCF0](v3, 0x10F1C40E421CF21);
  sub_19E3D3F84(v1 + 20);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  uint64_t v6 = (void *)v1[31];
  if (!v6) {
    _Unwind_Resume(a1);
  }
  v1[32] = v6;
  operator delete(v6);
  _Unwind_Resume(a1);
}

uint64_t sub_19E5422D4(uint64_t a1, uint64_t a2, void *a3)
{
  if (a2 == a1)
  {
    unsigned __int8 v5 = 0;
    int v6 = 1;
  }
  else
  {
    sub_19E371C70(__p, (const UInt8 *)(a2 - 32));
    if (*(_DWORD *)(a2 - 8))
    {
      unsigned __int8 v5 = 0;
      int v6 = 1;
      if (SHIBYTE(v12) < 0) {
        goto LABEL_11;
      }
    }
    else
    {
      if (SHIBYTE(v12) < 0)
      {
        sub_19E39369C(v9, __p[0], (unint64_t)__p[1]);
      }
      else
      {
        *(_OWORD *)unsigned int v9 = *(_OWORD *)__p;
        uint64_t v10 = v12;
      }
      __int16 v7 = sub_19E4144E0(a3, (uint64_t)v9);
      unsigned __int8 v5 = v7;
      int v6 = HIBYTE(v7);
      if (SHIBYTE(v10) < 0)
      {
        operator delete(v9[0]);
        if ((SHIBYTE(v12) & 0x80000000) == 0) {
          return v5 | (v6 << 8);
        }
        goto LABEL_11;
      }
      if (SHIBYTE(v12) < 0) {
LABEL_11:
      }
        operator delete(__p[0]);
    }
  }
  return v5 | (v6 << 8);
}

void sub_19E5423B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if ((a21 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

void *sub_19E5423FC(void *a1)
{
  while (1)
  {
    uint64_t v2 = (void *)a1[1];
    if (*a1 >= (unint64_t)((uint64_t)(v2[1] - *v2) >> 5)) {
      break;
    }
    sub_19E3F96BC(v2);
  }
  return a1;
}

uint64_t sub_19E542440(uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2)
  {
    do
    {
      unsigned __int8 v5 = (void **)*v2;
      if (*((char *)v2 + 175) < 0)
      {
        operator delete(v2[19]);
        if (*((char *)v2 + 39) < 0) {
LABEL_10:
        }
          operator delete(v2[2]);
      }
      else if (*((char *)v2 + 39) < 0)
      {
        goto LABEL_10;
      }
      operator delete(v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  uint64_t v3 = *(void **)a1;
  *(void *)a1 = 0;
  if (v3) {
    operator delete(v3);
  }
  return a1;
}

void sub_19E5424C8(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    uint64_t v203 = (int *)(a2 - 304);
    std::string::size_type v207 = (int *)(a2 - 152);
    float v200 = (int *)(a2 - 456);
    unint64_t v197 = a2 - 144;
    unint64_t v9 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v9;
          uint64_t v10 = a2 - v9;
          uint64_t v11 = 0x86BCA1AF286BCA1BLL * ((uint64_t)(a2 - v9) >> 3);
          if (v5 || !v4)
          {
            switch(v11)
            {
              case 0:
              case 1:
                return;
              case 2:
                uint64_t v95 = (long long *)(a1 + 8);
                if (*(double *)v197 > *(double *)(a1 + 8))
                {
                  int v96 = *(_DWORD *)a1;
                  *(_DWORD *)a1 = *(_DWORD *)(a2 - 152);
                  *(_DWORD *)(a2 - 152) = v96;
                  long long v233 = *(_OWORD *)(a1 + 24);
                  long long v241 = *(_OWORD *)(a1 + 40);
                  long long v225 = *v95;
                  uint64_t v273 = *(void *)(a1 + 104);
                  long long v257 = *(_OWORD *)(a1 + 72);
                  long long v265 = *(_OWORD *)(a1 + 88);
                  long long v249 = *(_OWORD *)(a1 + 56);
                  long long v98 = *(_OWORD *)(v197 + 64);
                  long long v97 = *(_OWORD *)(v197 + 80);
                  long long v99 = *(_OWORD *)(v197 + 48);
                  *(void *)(a1 + 104) = *(void *)(v197 + 96);
                  *(_OWORD *)(a1 + 72) = v98;
                  *(_OWORD *)(a1 + 88) = v97;
                  *(_OWORD *)(a1 + 56) = v99;
                  long long v100 = *(_OWORD *)v197;
                  long long v101 = *(_OWORD *)(v197 + 32);
                  *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(v197 + 16);
                  *(_OWORD *)(a1 + 40) = v101;
                  *uint64_t v95 = v100;
                  *(_OWORD *)(v197 + 16) = v233;
                  *(_OWORD *)(v197 + 32) = v241;
                  *(_OWORD *)unint64_t v197 = v225;
                  *(void *)(v197 + 96) = v273;
                  *(_OWORD *)(v197 + 64) = v257;
                  *(_OWORD *)(v197 + 80) = v265;
                  *(_OWORD *)(v197 + 48) = v249;
                  long long v102 = *(_OWORD *)(a1 + 112);
                  uint64_t v103 = *(void *)(a1 + 128);
                  uint64_t v104 = *(void *)(a2 - 24);
                  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 - 40);
                  *(void *)(a1 + 128) = v104;
                  *(void *)(a2 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v103;
                  *(_OWORD *)(a2 - 40) = v102;
                  LODWORD(v103) = *(_DWORD *)(a1 + 136);
                  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 - 16);
                  *(_DWORD *)(a2 - 16) = v103;
                  uint64_t v105 = *(void *)(a1 + 144);
                  *(void *)(a1 + 144) = *(void *)(a2 - 8);
                  *(void *)(a2 - 8) = v105;
                }
                break;
              case 3:
                sub_19E543E4C((int *)a1, (int *)(a1 + 152), v207);
                break;
              case 4:
                sub_19E544248(a1, a1 + 152, a1 + 304, (uint64_t)v207);
                break;
              case 5:
                sub_19E544500(a1, a1 + 152, a1 + 304, a1 + 456, (uint64_t)v207);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v10 <= 3647)
          {
            uint64_t v106 = (_DWORD *)(a1 + 152);
            BOOL v108 = a1 == a2 || v106 == (_DWORD *)a2;
            if (a4)
            {
              if (!v108)
              {
                uint64_t v109 = 0;
                unint64_t v110 = a1;
                do
                {
                  long long v111 = v106;
                  double v112 = *(double *)(v110 + 160);
                  if (v112 > *(double *)(v110 + 8))
                  {
                    int v217 = *v106;
                    long long v226 = *(_OWORD *)(v110 + 168);
                    long long v234 = *(_OWORD *)(v110 + 184);
                    long long v258 = *(_OWORD *)(v110 + 232);
                    long long v266 = *(_OWORD *)(v110 + 248);
                    long long v242 = *(_OWORD *)(v110 + 200);
                    long long v250 = *(_OWORD *)(v110 + 216);
                    unsigned int v113 = *(void **)(v110 + 264);
                    *(void *)uint64_t v280 = *(void *)(v110 + 272);
                    *(void *)&v280[7] = *(void *)(v110 + 279);
                    char v114 = *(unsigned char *)(v110 + 287);
                    *(void *)(v110 + 264) = 0;
                    *(void *)(v110 + 272) = 0;
                    *(void *)(v110 + 280) = 0;
                    int v115 = *(_DWORD *)(v110 + 288);
                    uint64_t v116 = v109;
                    uint64_t v212 = *(void *)(v110 + 296);
                    while (1)
                    {
                      uint64_t v117 = a1 + v116;
                      *(_DWORD *)(v117 + 152) = *(_DWORD *)(a1 + v116);
                      long long v118 = *(_OWORD *)(a1 + v116 + 56);
                      long long v119 = *(_OWORD *)(a1 + v116 + 88);
                      *(_OWORD *)(v117 + 2++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a1 + v116 + 72);
                      *(_OWORD *)(v117 + 240) = v119;
                      *(void *)(v117 + 256) = *(void *)(a1 + v116 + 104);
                      long long v120 = *(_OWORD *)(a1 + v116 + 24);
                      *(_OWORD *)(v117 + 160) = *(_OWORD *)(a1 + v116 + 8);
                      *(_OWORD *)(v117 + 176) = v120;
                      *(_OWORD *)(v117 + 192) = *(_OWORD *)(a1 + v116 + 40);
                      *(_OWORD *)(v117 + 208) = v118;
                      uint64_t v121 = (void **)(a1 + v116 + 264);
                      if (*(char *)(a1 + v116 + 287) < 0) {
                        operator delete(*v121);
                      }
                      *(_OWORD *)uint64_t v121 = *(_OWORD *)(v117 + 112);
                      *(void *)(a1 + v116 + 280) = *(void *)(v117 + 128);
                      *(unsigned char *)(v117 + 135) = 0;
                      *(unsigned char *)(v117 + 112) = 0;
                      *(_DWORD *)(v117 + 288) = *(_DWORD *)(v117 + 136);
                      *(void *)(v117 + 296) = *(void *)(v117 + 144);
                      if (!v116) {
                        break;
                      }
                      uint64_t v122 = a1 + v116;
                      double v123 = *(double *)(a1 + v116 - 144);
                      v116 -= 152;
                      if (v112 <= v123)
                      {
                        uint64_t v124 = a1 + v116 + 152;
                        BOOL v125 = (double *)(v122 + 8);
                        uint64_t v126 = (void **)(v122 + 112);
                        goto LABEL_94;
                      }
                    }
                    BOOL v125 = (double *)(a1 + 8);
                    uint64_t v126 = (void **)(a1 + 112);
                    uint64_t v124 = a1;
LABEL_94:
                    *(_DWORD *)uint64_t v124 = v217;
                    double *v125 = v112;
                    *(_OWORD *)(v124 + 32) = v234;
                    *(_OWORD *)(v124 + 48) = v242;
                    *(_OWORD *)(v124 + 64) = v250;
                    *(_OWORD *)(v124 + 80) = v258;
                    *(_OWORD *)(v124 + 96) = v266;
                    *(_OWORD *)(v124 + 16) = v226;
                    if (*(char *)(v124 + 135) < 0) {
                      operator delete(*v126);
                    }
                    void *v126 = v113;
                    *(void *)(v124 + 120) = *(void *)v280;
                    *(void *)(v124 + 127) = *(void *)&v280[7];
                    *(unsigned char *)(v124 + 135) = v114;
                    *(_DWORD *)(v124 + 136) = v115;
                    *(void *)(v124 + 144) = v212;
                  }
                  uint64_t v106 = v111 + 38;
                  v109 += 152;
                  unint64_t v110 = (unint64_t)v111;
                }
                while (v111 + 38 != (_DWORD *)a2);
              }
            }
            else if (!v108)
            {
              unint64_t v182 = a1 - 144;
              do
              {
                int v184 = v106;
                double v185 = *(double *)(a1 + 160);
                if (v185 > *(double *)(a1 + 8))
                {
                  int v186 = *v106;
                  long long v228 = *(_OWORD *)(a1 + 168);
                  long long v236 = *(_OWORD *)(a1 + 184);
                  long long v260 = *(_OWORD *)(a1 + 232);
                  long long v268 = *(_OWORD *)(a1 + 248);
                  long long v244 = *(_OWORD *)(a1 + 200);
                  long long v252 = *(_OWORD *)(a1 + 216);
                  uint64_t v187 = *(void *)(a1 + 264);
                  *(void *)size_t v283 = *(void *)(a1 + 272);
                  *(void *)&v283[7] = *(void *)(a1 + 279);
                  char v188 = *(unsigned char *)(a1 + 287);
                  *(void *)(a1 + 264) = 0;
                  *(void *)(a1 + 272) = 0;
                  *(void *)(a1 + 280) = 0;
                  int v189 = *(_DWORD *)(a1 + 288);
                  unint64_t v190 = v182;
                  uint64_t v191 = *(void *)(a1 + 296);
                  do
                  {
                    unint64_t v192 = v190;
                    *(_DWORD *)(v190 + 296) = *(_DWORD *)(v190 + 144);
                    long long v193 = *(_OWORD *)(v190 + 200);
                    long long v194 = *(_OWORD *)(v190 + 232);
                    *(_OWORD *)(v190 + 368) = *(_OWORD *)(v190 + 216);
                    *(_OWORD *)(v190 + 384) = v194;
                    *(void *)(v190 + 400) = *(void *)(v190 + 248);
                    long long v195 = *(_OWORD *)(v190 + 168);
                    *(_OWORD *)(v190 + 304) = *(_OWORD *)(v190 + 152);
                    *(_OWORD *)(v190 + 320) = v195;
                    *(_OWORD *)(v190 + 336) = *(_OWORD *)(v190 + 184);
                    *(_OWORD *)(v190 + 352) = v193;
                    unint64_t v196 = v190 + 408;
                    if (*(char *)(v192 + 431) < 0) {
                      operator delete(*(void **)v196);
                    }
                    *(_OWORD *)unint64_t v196 = *(_OWORD *)(v192 + 256);
                    *(void *)(v196 + 16) = *(void *)(v192 + 272);
                    *(unsigned char *)(v192 + 279) = 0;
                    *(unsigned char *)(v192 + 256) = 0;
                    *(_DWORD *)(v192 + 432) = *(_DWORD *)(v192 + 280);
                    unint64_t v190 = v192 - 152;
                    BOOL v145 = v185 <= *(double *)v192;
                    *(void *)(v192 + 440) = *(void *)(v192 + 288);
                  }
                  while (!v145);
                  unint64_t v183 = v192 + 144;
                  *(_DWORD *)(v190 + 296) = v186;
                  *(double *)(v190 + 304) = v185;
                  *(_OWORD *)(v183 + 16) = v228;
                  *(_OWORD *)(v183 + 32) = v236;
                  *(_OWORD *)(v183 + 80) = v260;
                  *(_OWORD *)(v183 + 96) = v268;
                  *(_OWORD *)(v183 + 48) = v244;
                  *(_OWORD *)(v183 + 64) = v252;
                  if (*(char *)(v190 + 431) < 0) {
                    operator delete(*(void **)(v190 + 408));
                  }
                  *(void *)(v190 + 408) = v187;
                  *(void *)(v183 + 127) = *(void *)&v283[7];
                  *(void *)(v183 + 120) = *(void *)v283;
                  *(unsigned char *)(v190 + 431) = v188;
                  *(_DWORD *)(v190 + 432) = v189;
                  *(void *)(v190 + 440) = v191;
                }
                uint64_t v106 = v184 + 38;
                v182 += 152;
                a1 = (unint64_t)v184;
              }
              while (v184 + 38 != (_DWORD *)a2);
            }
            return;
          }
          if (!a3)
          {
            if (a1 != a2)
            {
              int64_t v127 = (unint64_t)(v11 - 2) >> 1;
              int64_t v128 = v127;
              do
              {
                int64_t v129 = v128;
                if (v127 >= v128)
                {
                  uint64_t v130 = (2 * v128) | 1;
                  unint64_t v131 = a1 + 152 * v130;
                  if (2 * v129 + 2 < v11 && *(double *)(v131 + 8) > *(double *)(v131 + 160))
                  {
                    v131 += 152;
                    uint64_t v130 = 2 * v129 + 2;
                  }
                  unint64_t v132 = a1 + 152 * v129;
                  double v133 = *(double *)(v132 + 8);
                  if (*(double *)(v131 + 8) <= v133)
                  {
                    int v201 = *(_DWORD *)v132;
                    long long v227 = *(_OWORD *)(v132 + 16);
                    long long v235 = *(_OWORD *)(v132 + 32);
                    long long v259 = *(_OWORD *)(v132 + 80);
                    long long v267 = *(_OWORD *)(v132 + 96);
                    long long v243 = *(_OWORD *)(v132 + 48);
                    long long v251 = *(_OWORD *)(v132 + 64);
                    uint64_t v218 = *(void *)(v132 + 112);
                    *(void *)&v281[7] = *(void *)(v132 + 127);
                    *(void *)uint64_t v281 = *(void *)(v132 + 120);
                    char v213 = *(unsigned char *)(v132 + 135);
                    *(void *)(v132 + 112) = 0;
                    *(void *)(v132 + 120) = 0;
                    *(void *)(v132 + 128) = 0;
                    int v208 = *(_DWORD *)(v132 + 136);
                    uint64_t v204 = *(void *)(v132 + 144);
                    do
                    {
                      unint64_t v134 = v132;
                      unint64_t v132 = v131;
                      *(_DWORD *)unint64_t v134 = *(_DWORD *)v131;
                      long long v135 = *(_OWORD *)(v131 + 8);
                      long long v136 = *(_OWORD *)(v131 + 24);
                      *(_OWORD *)(v134 + 40) = *(_OWORD *)(v131 + 40);
                      *(_OWORD *)(v134 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v136;
                      *(_OWORD *)(v134 + 8) = v135;
                      long long v137 = *(_OWORD *)(v131 + 56);
                      long long v138 = *(_OWORD *)(v131 + 72);
                      long long v139 = *(_OWORD *)(v131 + 88);
                      *(void *)(v134 + 104) = *(void *)(v131 + 104);
                      *(_OWORD *)(v134 + 88) = v139;
                      *(_OWORD *)(v134 + 72) = v138;
                      *(_OWORD *)(v134 + 56) = v137;
                      float v140 = (void **)(v134 + 112);
                      if (*(char *)(v134 + 135) < 0) {
                        operator delete(*v140);
                      }
                      long long v141 = *(_OWORD *)(v132 + 112);
                      *(void *)(v134 + 128) = *(void *)(v132 + 128);
                      *(_OWORD *)float v140 = v141;
                      *(unsigned char *)(v132 + 135) = 0;
                      *(unsigned char *)(v132 + 112) = 0;
                      *(_DWORD *)(v134 + 136) = *(_DWORD *)(v132 + 136);
                      *(void *)(v134 + 144) = *(void *)(v132 + 144);
                      if (v127 < v130) {
                        break;
                      }
                      uint64_t v142 = 2 * v130;
                      uint64_t v130 = (2 * v130) | 1;
                      unint64_t v131 = a1 + 152 * v130;
                      uint64_t v143 = v142 + 2;
                      if (v143 < v11 && *(double *)(v131 + 8) > *(double *)(v131 + 160))
                      {
                        v131 += 152;
                        uint64_t v130 = v143;
                      }
                    }
                    while (*(double *)(v131 + 8) <= v133);
                    *(_DWORD *)unint64_t v132 = v201;
                    *(double *)(v132 + 8) = v133;
                    *(_OWORD *)(v132 + 48) = v243;
                    *(_OWORD *)(v132 + 64) = v251;
                    *(_OWORD *)(v132 + 80) = v259;
                    *(_OWORD *)(v132 + 96) = v267;
                    *(_OWORD *)(v132 + 16) = v227;
                    *(_OWORD *)(v132 + 32) = v235;
                    if (*(char *)(v132 + 135) < 0) {
                      operator delete(*(void **)(v132 + 112));
                    }
                    *(void *)(v132 + 112) = v218;
                    *(void *)(v132 + 120) = *(void *)v281;
                    *(void *)(v132 + 127) = *(void *)&v281[7];
                    *(unsigned char *)(v132 + 135) = v213;
                    *(_DWORD *)(v132 + 136) = v208;
                    *(void *)(v132 + 144) = v204;
                  }
                }
                int64_t v128 = v129 - 1;
              }
              while (v129);
              int64_t v144 = v10 / 0x98uLL;
              do
              {
                uint64_t v146 = 0;
                int v202 = *(_DWORD *)a1;
                long long v237 = *(_OWORD *)(a1 + 24);
                long long v245 = *(_OWORD *)(a1 + 40);
                long long v229 = *(_OWORD *)(a1 + 8);
                uint64_t v274 = *(void *)(a1 + 104);
                long long v261 = *(_OWORD *)(a1 + 72);
                long long v269 = *(_OWORD *)(a1 + 88);
                long long v253 = *(_OWORD *)(a1 + 56);
                uint64_t v214 = *(void *)(a1 + 112);
                *(void *)&v221[7] = *(void *)(a1 + 127);
                *(void *)size_t v221 = *(void *)(a1 + 120);
                char v219 = *(unsigned char *)(a1 + 135);
                *(void *)(a1 + 112) = 0;
                *(void *)(a1 + 120) = 0;
                *(void *)(a1 + 128) = 0;
                int v209 = *(_DWORD *)(a1 + 136);
                unint64_t v147 = a1;
                uint64_t v205 = *(void *)(a1 + 144);
                do
                {
                  uint64_t v155 = v147 + 152 * v146 + 152;
                  uint64_t v156 = 2 * v146;
                  uint64_t v146 = (2 * v146) | 1;
                  int64_t v157 = v156 + 2;
                  if (v157 < v144 && *(double *)(v155 + 8) > *(double *)(v155 + 160))
                  {
                    v155 += 152;
                    uint64_t v146 = v157;
                  }
                  *(_DWORD *)unint64_t v147 = *(_DWORD *)v155;
                  long long v148 = *(_OWORD *)(v155 + 8);
                  long long v149 = *(_OWORD *)(v155 + 24);
                  *(_OWORD *)(v147 + 40) = *(_OWORD *)(v155 + 40);
                  *(_OWORD *)(v147 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v149;
                  *(_OWORD *)(v147 + 8) = v148;
                  long long v150 = *(_OWORD *)(v155 + 56);
                  long long v151 = *(_OWORD *)(v155 + 72);
                  long long v152 = *(_OWORD *)(v155 + 88);
                  *(void *)(v147 + 104) = *(void *)(v155 + 104);
                  *(_OWORD *)(v147 + 88) = v152;
                  *(_OWORD *)(v147 + 72) = v151;
                  *(_OWORD *)(v147 + 56) = v150;
                  float v153 = (void **)(v147 + 112);
                  if (*(char *)(v147 + 135) < 0) {
                    operator delete(*v153);
                  }
                  long long v154 = *(_OWORD *)(v155 + 112);
                  *(void *)(v147 + 128) = *(void *)(v155 + 128);
                  *(_OWORD *)float v153 = v154;
                  *(unsigned char *)(v155 + 135) = 0;
                  *(unsigned char *)(v155 + 112) = 0;
                  *(_DWORD *)(v147 + 136) = *(_DWORD *)(v155 + 136);
                  *(void *)(v147 + 144) = *(void *)(v155 + 144);
                  unint64_t v147 = v155;
                }
                while (v146 <= (uint64_t)((unint64_t)(v144 - 2) >> 1));
                float v158 = (double *)(v155 + 8);
                uint64_t v159 = (void **)(v155 + 112);
                unint64_t v160 = a2 - 152;
                if (v155 == a2 - 152)
                {
                  *(_DWORD *)uint64_t v155 = v202;
                  *(_OWORD *)(v155 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v237;
                  *(_OWORD *)(v155 + 40) = v245;
                  *(_OWORD *)float v158 = v229;
                  *(void *)(v155 + 104) = v274;
                  *(_OWORD *)(v155 + 72) = v261;
                  *(_OWORD *)(v155 + 88) = v269;
                  *(_OWORD *)(v155 + 56) = v253;
                  if (*(char *)(v155 + 135) < 0) {
                    operator delete(*v159);
                  }
                  *(void *)(v155 + 112) = v214;
                  *(void *)(v155 + 120) = *(void *)v221;
                  *(void *)(v155 + 127) = *(void *)&v221[7];
                  *(unsigned char *)(v155 + 135) = v219;
                  *(_DWORD *)(v155 + 136) = v209;
                  *(void *)(v155 + 144) = v205;
                }
                else
                {
                  *(_DWORD *)uint64_t v155 = *(_DWORD *)(a2 - 152);
                  long long v161 = *(_OWORD *)(a2 - 144);
                  long long v162 = *(_OWORD *)(a2 - 112);
                  *(_OWORD *)(v155 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(a2 - 128);
                  *(_OWORD *)(v155 + 40) = v162;
                  *(_OWORD *)float v158 = v161;
                  long long v163 = *(_OWORD *)(a2 - 96);
                  long long v164 = *(_OWORD *)(a2 - 80);
                  long long v165 = *(_OWORD *)(a2 - 64);
                  *(void *)(v155 + 104) = *(void *)(a2 - 48);
                  *(_OWORD *)(v155 + 72) = v164;
                  *(_OWORD *)(v155 + 88) = v165;
                  *(_OWORD *)(v155 + 56) = v163;
                  if (*(char *)(v155 + 135) < 0) {
                    operator delete(*v159);
                  }
                  unint64_t v166 = a2 - 144;
                  long long v167 = *(_OWORD *)(a2 - 40);
                  *(void *)(v155 + 128) = *(void *)(a2 - 24);
                  *(_OWORD *)uint64_t v159 = v167;
                  *(unsigned char *)(a2 - 17) = 0;
                  *(unsigned char *)(a2 - 40) = 0;
                  *(_DWORD *)(v155 + 136) = *(_DWORD *)(a2 - 16);
                  *(void *)(v155 + 144) = *(void *)(a2 - 8);
                  *(_DWORD *)(a2 - 152) = v202;
                  *(_OWORD *)unint64_t v166 = v229;
                  *(_OWORD *)(v166 + 16) = v237;
                  *(_OWORD *)(v166 + 32) = v245;
                  *(void *)(v166 + 96) = v274;
                  *(_OWORD *)(v166 + 64) = v261;
                  *(_OWORD *)(v166 + 80) = v269;
                  *(_OWORD *)(v166 + 48) = v253;
                  if (*(char *)(a2 - 17) < 0) {
                    operator delete(*(void **)(a2 - 40));
                  }
                  *(void *)(a2 - 40) = v214;
                  *(void *)(a2 - 25) = *(void *)&v221[7];
                  *(void *)(a2 - 32) = *(void *)v221;
                  *(unsigned char *)(a2 - 17) = v219;
                  *(_DWORD *)(a2 - 16) = v209;
                  *(void *)(a2 - 8) = v205;
                  uint64_t v168 = v155 + 152 - a1;
                  if (v168 >= 153)
                  {
                    unint64_t v169 = (v168 / 0x98uLL - 2) >> 1;
                    unint64_t v170 = a1 + 152 * v169;
                    double v171 = *v158;
                    if (*(double *)(v170 + 8) > *v158)
                    {
                      int v172 = *(_DWORD *)v155;
                      long long v282 = *(_OWORD *)(v155 + 16);
                      long long v286 = *(_OWORD *)(v155 + 32);
                      long long v295 = *(_OWORD *)(v155 + 80);
                      long long v298 = *(_OWORD *)(v155 + 96);
                      long long v289 = *(_OWORD *)(v155 + 48);
                      long long v292 = *(_OWORD *)(v155 + 64);
                      uint64_t v215 = *(void *)(v155 + 112);
                      unint64_t v220 = a2 - 152;
                      *(void *)&v277[7] = *(void *)(v155 + 127);
                      *(void *)size_t v277 = *(void *)(v155 + 120);
                      char v210 = *(unsigned char *)(v155 + 135);
                      *uint64_t v159 = 0;
                      *(void *)(v155 + 120) = 0;
                      *(void *)(v155 + 128) = 0;
                      int v206 = *(_DWORD *)(v155 + 136);
                      uint64_t v173 = *(void *)(v155 + 144);
                      do
                      {
                        uint64_t v174 = v170;
                        *(_DWORD *)uint64_t v155 = *(_DWORD *)v170;
                        long long v175 = *(_OWORD *)(v170 + 8);
                        long long v176 = *(_OWORD *)(v170 + 24);
                        *(_OWORD *)(v155 + 40) = *(_OWORD *)(v170 + 40);
                        *(_OWORD *)(v155 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v176;
                        *(_OWORD *)(v155 + 8) = v175;
                        long long v177 = *(_OWORD *)(v170 + 56);
                        long long v178 = *(_OWORD *)(v170 + 72);
                        long long v179 = *(_OWORD *)(v170 + 88);
                        *(void *)(v155 + 104) = *(void *)(v170 + 104);
                        *(_OWORD *)(v155 + 88) = v179;
                        *(_OWORD *)(v155 + 72) = v178;
                        *(_OWORD *)(v155 + 56) = v177;
                        uint64_t v180 = (void **)(v155 + 112);
                        if (*(char *)(v155 + 135) < 0) {
                          operator delete(*v180);
                        }
                        long long v181 = *(_OWORD *)(v174 + 112);
                        *(void *)(v155 + 128) = *(void *)(v174 + 128);
                        *(_OWORD *)uint64_t v180 = v181;
                        *(unsigned char *)(v174 + 135) = 0;
                        *(unsigned char *)(v174 + 112) = 0;
                        *(_DWORD *)(v155 + 136) = *(_DWORD *)(v174 + 136);
                        *(void *)(v155 + 144) = *(void *)(v174 + 144);
                        if (!v169) {
                          break;
                        }
                        unint64_t v169 = (v169 - 1) >> 1;
                        unint64_t v170 = a1 + 152 * v169;
                        uint64_t v155 = v174;
                      }
                      while (*(double *)(v170 + 8) > v171);
                      *(_DWORD *)uint64_t v174 = v172;
                      *(double *)(v174 + 8) = v171;
                      *(_OWORD *)(v174 + 48) = v289;
                      *(_OWORD *)(v174 + 64) = v292;
                      *(_OWORD *)(v174 + 80) = v295;
                      *(_OWORD *)(v174 + 96) = v298;
                      *(_OWORD *)(v174 + 16) = v282;
                      *(_OWORD *)(v174 + 32) = v286;
                      if (*(char *)(v174 + 135) < 0) {
                        operator delete(*(void **)(v174 + 112));
                      }
                      unint64_t v160 = v220;
                      *(void *)(v174 + 112) = v215;
                      *(void *)(v174 + 120) = *(void *)v277;
                      *(void *)(v174 + 127) = *(void *)&v277[7];
                      *(unsigned char *)(v174 + 135) = v210;
                      *(_DWORD *)(v174 + 136) = v206;
                      *(void *)(v174 + 144) = v173;
                    }
                  }
                }
                a2 = v160;
                BOOL v145 = v144-- <= 2;
              }
              while (!v145);
            }
            return;
          }
          unint64_t v12 = (unint64_t)v11 >> 1;
          unint64_t v13 = a1 + 152 * ((unint64_t)v11 >> 1);
          if ((unint64_t)v10 < 0x4C01)
          {
            sub_19E543E4C((int *)v13, (int *)a1, v207);
          }
          else
          {
            sub_19E543E4C((int *)a1, (int *)v13, v207);
            uint64_t v14 = 152 * v12;
            sub_19E543E4C((int *)(a1 + 152), (int *)(v14 + a1 - 152), v203);
            sub_19E543E4C((int *)(a1 + 304), (int *)(a1 + 152 + v14), v200);
            sub_19E543E4C((int *)(v14 + a1 - 152), (int *)v13, (int *)(a1 + 152 + v14));
            int v15 = *(_DWORD *)a1;
            *(_DWORD *)a1 = *(_DWORD *)v13;
            *(_DWORD *)unint64_t v13 = v15;
            uint64_t v270 = *(void *)(a1 + 104);
            long long v222 = *(_OWORD *)(a1 + 8);
            long long v230 = *(_OWORD *)(a1 + 24);
            long long v254 = *(_OWORD *)(a1 + 72);
            long long v262 = *(_OWORD *)(a1 + 88);
            long long v238 = *(_OWORD *)(a1 + 40);
            long long v246 = *(_OWORD *)(a1 + 56);
            long long v16 = *(_OWORD *)(v13 + 72);
            long long v17 = *(_OWORD *)(v13 + 88);
            uint64_t v18 = *(void *)(v13 + 104);
            *(_OWORD *)(a1 + 56) = *(_OWORD *)(v13 + 56);
            *(void *)(a1 + 104) = v18;
            *(_OWORD *)(a1 + 88) = v17;
            *(_OWORD *)(a1 + 72) = v16;
            long long v19 = *(_OWORD *)(v13 + 8);
            long long v20 = *(_OWORD *)(v13 + 24);
            *(_OWORD *)(a1 + 40) = *(_OWORD *)(v13 + 40);
            *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v20;
            *(_OWORD *)(a1 + 8) = v19;
            *(_OWORD *)(v13 + 40) = v238;
            *(_OWORD *)(v13 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v230;
            *(_OWORD *)(v13 + 8) = v222;
            *(void *)(v13 + 104) = v270;
            *(_OWORD *)(v13 + 88) = v262;
            *(_OWORD *)(v13 + 72) = v254;
            *(_OWORD *)(v13 + 56) = v246;
            long long v21 = *(_OWORD *)(a1 + 112);
            uint64_t v22 = *(void *)(a1 + 128);
            uint64_t v23 = *(void *)(v13 + 128);
            *(_OWORD *)(a1 + 112) = *(_OWORD *)(v13 + 112);
            *(void *)(a1 + 128) = v23;
            *(void *)(v13 + 128) = v22;
            *(_OWORD *)(v13 + 112) = v21;
            LODWORD(v22) = *(_DWORD *)(a1 + 136);
            *(_DWORD *)(a1 + 136) = *(_DWORD *)(v13 + 136);
            *(_DWORD *)(v13 + 136) = v22;
            uint64_t v24 = *(void *)(a1 + 144);
            *(void *)(a1 + 144) = *(void *)(v13 + 144);
            *(void *)(v13 + 144) = v24;
          }
          uint64_t v216 = --a3;
          if (a4) {
            break;
          }
          double v25 = *(double *)(a1 + 8);
          if (*(double *)(a1 - 144) > v25) {
            goto LABEL_12;
          }
          int v64 = *(_DWORD *)a1;
          long long v294 = *(_OWORD *)(a1 + 80);
          long long v297 = *(_OWORD *)(a1 + 96);
          long long v288 = *(_OWORD *)(a1 + 48);
          long long v291 = *(_OWORD *)(a1 + 64);
          long long v279 = *(_OWORD *)(a1 + 16);
          long long v285 = *(_OWORD *)(a1 + 32);
          uint64_t v65 = (void **)(a1 + 112);
          uint64_t v66 = *(void *)(a1 + 112);
          *(void *)v276 = *(void *)(a1 + 120);
          *(void *)&v276[7] = *(void *)(a1 + 127);
          char v67 = *(unsigned char *)(a1 + 135);
          *(void *)(a1 + 112) = 0;
          *(void *)(a1 + 120) = 0;
          *(void *)(a1 + 128) = 0;
          if (v25 <= *(double *)v197)
          {
            unint64_t v70 = a1 + 152;
            do
            {
              unint64_t v9 = v70;
              if (v70 >= a2) {
                break;
              }
              double v71 = *(double *)(v70 + 8);
              v70 += 152;
            }
            while (v25 <= v71);
          }
          else
          {
            unint64_t v68 = a1;
            do
            {
              unint64_t v9 = v68 + 152;
              double v69 = *(double *)(v68 + 160);
              v68 += 152;
            }
            while (v25 <= v69);
          }
          unint64_t v72 = a2;
          if (v9 < a2)
          {
            unint64_t v73 = a2;
            do
            {
              unint64_t v72 = v73 - 152;
              double v74 = *(double *)(v73 - 144);
              v73 -= 152;
            }
            while (v25 > v74);
          }
          int v75 = *(_DWORD *)(a1 + 136);
          uint64_t v76 = *(void *)(a1 + 144);
          while (v9 < v72)
          {
            int v77 = *(_DWORD *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v72;
            *(_DWORD *)unint64_t v72 = v77;
            uint64_t v272 = *(void *)(v9 + 104);
            long long v224 = *(_OWORD *)(v9 + 8);
            long long v232 = *(_OWORD *)(v9 + 24);
            long long v256 = *(_OWORD *)(v9 + 72);
            long long v264 = *(_OWORD *)(v9 + 88);
            long long v240 = *(_OWORD *)(v9 + 40);
            long long v248 = *(_OWORD *)(v9 + 56);
            long long v78 = *(_OWORD *)(v72 + 72);
            long long v79 = *(_OWORD *)(v72 + 88);
            uint64_t v80 = *(void *)(v72 + 104);
            *(_OWORD *)(v9 + 56) = *(_OWORD *)(v72 + 56);
            *(void *)(v9 + 104) = v80;
            *(_OWORD *)(v9 + 88) = v79;
            *(_OWORD *)(v9 + 72) = v78;
            long long v81 = *(_OWORD *)(v72 + 8);
            long long v82 = *(_OWORD *)(v72 + 24);
            *(_OWORD *)(v9 + 40) = *(_OWORD *)(v72 + 40);
            *(_OWORD *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v82;
            *(_OWORD *)(v9 + 8) = v81;
            *(void *)(v72 + 104) = v272;
            *(_OWORD *)(v72 + 40) = v240;
            *(_OWORD *)(v72 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v232;
            *(_OWORD *)(v72 + 8) = v224;
            *(_OWORD *)(v72 + 88) = v264;
            *(_OWORD *)(v72 + 72) = v256;
            *(_OWORD *)(v72 + 56) = v248;
            uint64_t v83 = *(void *)(v9 + 128);
            long long v84 = *(_OWORD *)(v9 + 112);
            uint64_t v85 = *(void *)(v72 + 128);
            *(_OWORD *)(v9 + 112) = *(_OWORD *)(v72 + 112);
            *(void *)(v9 + 128) = v85;
            *(_OWORD *)(v72 + 112) = v84;
            *(void *)(v72 + 128) = v83;
            LODWORD(v83) = *(_DWORD *)(v9 + 136);
            *(_DWORD *)(v9 + 136) = *(_DWORD *)(v72 + 136);
            *(_DWORD *)(v72 + 136) = v83;
            uint64_t v86 = *(void *)(v9 + 144);
            *(void *)(v9 + 144) = *(void *)(v72 + 144);
            *(void *)(v72 + 144) = v86;
            do
            {
              double v87 = *(double *)(v9 + 160);
              v9 += 152;
            }
            while (v25 <= v87);
            do
            {
              double v88 = *(double *)(v72 - 144);
              v72 -= 152;
            }
            while (v25 > v88);
          }
          BOOL v4 = v9 - 152 >= a1;
          BOOL v5 = v9 - 152 == a1;
          if (v9 - 152 != a1)
          {
            *(_DWORD *)a1 = *(_DWORD *)(v9 - 152);
            long long v89 = *(_OWORD *)(v9 - 144);
            long long v90 = *(_OWORD *)(v9 - 112);
            *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(v9 - 128);
            *(_OWORD *)(a1 + 40) = v90;
            *(_OWORD *)(a1 + 8) = v89;
            long long v91 = *(_OWORD *)(v9 - 96);
            long long v92 = *(_OWORD *)(v9 - 80);
            long long v93 = *(_OWORD *)(v9 - 64);
            *(void *)(a1 + 104) = *(void *)(v9 - 48);
            *(_OWORD *)(a1 + 72) = v92;
            *(_OWORD *)(a1 + 88) = v93;
            *(_OWORD *)(a1 + 56) = v91;
            if (*(char *)(a1 + 135) < 0) {
              operator delete(*v65);
            }
            long long v94 = *(_OWORD *)(v9 - 40);
            *(void *)(a1 + 128) = *(void *)(v9 - 24);
            *(_OWORD *)uint64_t v65 = v94;
            *(unsigned char *)(v9 - 17) = 0;
            *(unsigned char *)(v9 - 40) = 0;
            *(_DWORD *)(a1 + 136) = *(_DWORD *)(v9 - 16);
            *(void *)(a1 + 144) = *(void *)(v9 - 8);
          }
          *(_DWORD *)(v9 - 152) = v64;
          *(double *)(v9 - 144) = v25;
          *(_OWORD *)(v9 - 120) = v285;
          *(_OWORD *)(v9 - 136) = v279;
          *(_OWORD *)(v9 - 56) = v297;
          *(_OWORD *)(v9 - 72) = v294;
          *(_OWORD *)(v9 - 88) = v291;
          *(_OWORD *)(v9 - 104) = v288;
          if (*(char *)(v9 - 17) < 0) {
            operator delete(*(void **)(v9 - 40));
          }
          a4 = 0;
          *(void *)(v9 - 40) = v66;
          *(void *)(v9 - 25) = *(void *)&v276[7];
          *(void *)(v9 - 32) = *(void *)v276;
          *(unsigned char *)(v9 - 17) = v67;
          *(_DWORD *)(v9 - 16) = v75;
          *(void *)(v9 - 8) = v76;
        }
        double v25 = *(double *)(a1 + 8);
LABEL_12:
        int v26 = *(_DWORD *)a1;
        long long v293 = *(_OWORD *)(a1 + 80);
        long long v296 = *(_OWORD *)(a1 + 96);
        long long v287 = *(_OWORD *)(a1 + 48);
        long long v290 = *(_OWORD *)(a1 + 64);
        unint64_t v28 = (void **)(a1 + 112);
        uint64_t v27 = *(void *)(a1 + 112);
        long long v278 = *(_OWORD *)(a1 + 16);
        long long v284 = *(_OWORD *)(a1 + 32);
        *(void *)unint64_t v275 = *(void *)(a1 + 120);
        *(void *)&v275[7] = *(void *)(a1 + 127);
        char v29 = *(unsigned char *)(a1 + 135);
        *(void *)(a1 + 112) = 0;
        *(void *)(a1 + 120) = 0;
        *(void *)(a1 + 128) = 0;
        int v30 = *(_DWORD *)(a1 + 136);
        unint64_t v31 = a1;
        uint64_t v32 = *(void *)(a1 + 144);
        do
        {
          unint64_t v33 = v31;
          v31 += 152;
        }
        while (*(double *)(v33 + 160) > v25);
        unint64_t v34 = a2;
        if (v33 == a1)
        {
          unint64_t v37 = a2;
          while (v31 < v37)
          {
            unint64_t v35 = v37 - 152;
            double v38 = *(double *)(v37 - 144);
            v37 -= 152;
            if (v38 > v25) {
              goto LABEL_22;
            }
          }
          unint64_t v35 = v37;
        }
        else
        {
          do
          {
            unint64_t v35 = v34 - 152;
            double v36 = *(double *)(v34 - 144);
            v34 -= 152;
          }
          while (v36 <= v25);
        }
LABEL_22:
        unint64_t v9 = v31;
        if (v31 < v35)
        {
          unint64_t v39 = v35;
          do
          {
            int v40 = *(_DWORD *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v39;
            *(_DWORD *)unint64_t v39 = v40;
            uint64_t v271 = *(void *)(v9 + 104);
            long long v223 = *(_OWORD *)(v9 + 8);
            long long v231 = *(_OWORD *)(v9 + 24);
            long long v255 = *(_OWORD *)(v9 + 72);
            long long v263 = *(_OWORD *)(v9 + 88);
            long long v239 = *(_OWORD *)(v9 + 40);
            long long v247 = *(_OWORD *)(v9 + 56);
            long long v41 = *(_OWORD *)(v39 + 72);
            long long v42 = *(_OWORD *)(v39 + 88);
            uint64_t v43 = *(void *)(v39 + 104);
            *(_OWORD *)(v9 + 56) = *(_OWORD *)(v39 + 56);
            *(void *)(v9 + 104) = v43;
            *(_OWORD *)(v9 + 88) = v42;
            *(_OWORD *)(v9 + 72) = v41;
            long long v44 = *(_OWORD *)(v39 + 8);
            long long v45 = *(_OWORD *)(v39 + 24);
            *(_OWORD *)(v9 + 40) = *(_OWORD *)(v39 + 40);
            *(_OWORD *)(v9 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v45;
            *(_OWORD *)(v9 + 8) = v44;
            *(void *)(v39 + 104) = v271;
            *(_OWORD *)(v39 + 40) = v239;
            *(_OWORD *)(v39 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v231;
            *(_OWORD *)(v39 + 8) = v223;
            *(_OWORD *)(v39 + 88) = v263;
            *(_OWORD *)(v39 + 72) = v255;
            *(_OWORD *)(v39 + 56) = v247;
            uint64_t v46 = *(void *)(v9 + 128);
            long long v47 = *(_OWORD *)(v9 + 112);
            uint64_t v48 = *(void *)(v39 + 128);
            *(_OWORD *)(v9 + 112) = *(_OWORD *)(v39 + 112);
            *(void *)(v9 + 128) = v48;
            *(_OWORD *)(v39 + 112) = v47;
            *(void *)(v39 + 128) = v46;
            LODWORD(v46) = *(_DWORD *)(v9 + 136);
            *(_DWORD *)(v9 + 136) = *(_DWORD *)(v39 + 136);
            *(_DWORD *)(v39 + 136) = v46;
            uint64_t v49 = *(void *)(v9 + 144);
            *(void *)(v9 + 144) = *(void *)(v39 + 144);
            *(void *)(v39 + 144) = v49;
            do
            {
              double v50 = *(double *)(v9 + 160);
              v9 += 152;
            }
            while (v50 > v25);
            do
            {
              double v51 = *(double *)(v39 - 144);
              v39 -= 152;
            }
            while (v51 <= v25);
          }
          while (v9 < v39);
        }
        if (v9 - 152 != a1)
        {
          *(_DWORD *)a1 = *(_DWORD *)(v9 - 152);
          long long v52 = *(_OWORD *)(v9 - 144);
          long long v53 = *(_OWORD *)(v9 - 112);
          *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(_OWORD *)(v9 - 128);
          *(_OWORD *)(a1 + 40) = v53;
          *(_OWORD *)(a1 + 8) = v52;
          long long v54 = *(_OWORD *)(v9 - 96);
          long long v55 = *(_OWORD *)(v9 - 80);
          long long v56 = *(_OWORD *)(v9 - 64);
          *(void *)(a1 + 104) = *(void *)(v9 - 48);
          *(_OWORD *)(a1 + 72) = v55;
          *(_OWORD *)(a1 + 88) = v56;
          *(_OWORD *)(a1 + 56) = v54;
          if (*(char *)(a1 + 135) < 0)
          {
            char v198 = v29;
            uint64_t v57 = v27;
            unint64_t v199 = a2;
            int v58 = v26;
            uint64_t v59 = v32;
            operator delete(*v28);
            uint64_t v32 = v59;
            int v26 = v58;
            a2 = v199;
            uint64_t v27 = v57;
            char v29 = v198;
          }
          long long v60 = *(_OWORD *)(v9 - 40);
          *(void *)(a1 + 128) = *(void *)(v9 - 24);
          *(_OWORD *)unint64_t v28 = v60;
          *(unsigned char *)(v9 - 17) = 0;
          *(unsigned char *)(v9 - 40) = 0;
          *(_DWORD *)(a1 + 136) = *(_DWORD *)(v9 - 16);
          *(void *)(a1 + 144) = *(void *)(v9 - 8);
        }
        *(_DWORD *)(v9 - 152) = v26;
        *(double *)(v9 - 144) = v25;
        *(_OWORD *)(v9 - 120) = v284;
        *(_OWORD *)(v9 - 136) = v278;
        *(_OWORD *)(v9 - 56) = v296;
        *(_OWORD *)(v9 - 72) = v293;
        *(_OWORD *)(v9 - 88) = v290;
        *(_OWORD *)(v9 - 104) = v287;
        if (*(char *)(v9 - 17) < 0)
        {
          uint64_t v61 = v27;
          uint64_t v62 = v32;
          operator delete(*(void **)(v9 - 40));
          uint64_t v32 = v62;
          uint64_t v27 = v61;
        }
        *(void *)(v9 - 40) = v27;
        *(void *)(v9 - 25) = *(void *)&v275[7];
        *(void *)(v9 - 32) = *(void *)v275;
        *(unsigned char *)(v9 - 17) = v29;
        *(_DWORD *)(v9 - 16) = v30;
        *(void *)(v9 - 8) = v32;
        a3 = v216;
        if (v31 >= v35) {
          break;
        }
LABEL_37:
        sub_19E5424C8(a1, v9 - 152, v216, a4 & 1);
        a4 = 0;
      }
      BOOL v63 = sub_19E54488C(a1, v9 - 152);
      if (sub_19E54488C(v9, a2)) {
        break;
      }
      if (!v63) {
        goto LABEL_37;
      }
    }
    a2 = v9 - 152;
    if (!v63) {
      continue;
    }
    break;
  }
}

void sub_19E543964(void *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v9 = a1;
  if (!a3)
  {
    uint64_t v42 = a4;
    memset(&v56, 0, sizeof(v56));
    long long v53 = 0;
    long long v54 = 0;
    uint64_t i = 0;
LABEL_60:
    long long v38 = *(_OWORD *)(v42 + 80);
    long long v47 = *(_OWORD *)(v42 + 64);
    long long v48 = v38;
    uint64_t v49 = *(void *)(v42 + 96);
    long long v39 = *(_OWORD *)(v42 + 16);
    *(_OWORD *)std::string __p = *(_OWORD *)v42;
    long long v44 = v39;
    long long v40 = *(_OWORD *)(v42 + 48);
    long long v45 = *(_OWORD *)(v42 + 32);
    long long v46 = v40;
    int v50 = *(_DWORD *)(v42 + 24) & 1 | (2 * ((*(_DWORD *)(v42 + 24) >> 8) & 1));
    operator new();
  }
  unint64_t v12 = a2;
  uint64_t v13 = 4 * a3;
  uint64_t v14 = a2;
  int v15 = &a2[a3];
  do
  {
    if (*v14 - 3 >= 0xFFFFFFFE)
    {
      *a1 = 0;
      return;
    }
    ++v14;
    v13 -= 4;
  }
  while (v13);
  uint64_t v42 = a4;
  long long v16 = 0;
  memset(&v56, 0, sizeof(v56));
  long long v53 = 0;
  long long v54 = 0;
  uint64_t i = 0;
  while (1)
  {
    if ((*a8 & 0xFFFFFFFE) == 8) {
      sub_19E4B6110((uint64_t)__src, *(std::recursive_mutex **)(a5 + 464), *v12);
    }
    else {
      sub_19E3FDF08((void *)a5, *v12, (uint64_t)__src);
    }
    char v17 = HIBYTE(v52);
    if (SHIBYTE(v52) < 0)
    {
      if (!__src[1])
      {
LABEL_16:
        *unint64_t v9 = 0;
        char v20 = 1;
        if ((v17 & 0x80) == 0) {
          goto LABEL_56;
        }
LABEL_55:
        operator delete(__src[0]);
        goto LABEL_56;
      }
      sub_19E39369C(__p, __src[0], (unint64_t)__src[1]);
    }
    else
    {
      if (!HIBYTE(v52)) {
        goto LABEL_16;
      }
      *(_OWORD *)std::string __p = *(_OWORD *)__src;
      *(void *)&long long v44 = v52;
    }
    DWORD2(v44) = 0;
    if (v16 >= (void **)i)
    {
      long long v21 = (void **)v53;
      uint64_t v22 = ((char *)v16 - v53) >> 5;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 59) {
        sub_19E37C7C4();
      }
      uint64_t v24 = v9;
      uint64_t v25 = i - v53;
      if ((i - v53) >> 4 > v23) {
        unint64_t v23 = v25 >> 4;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v26 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v26 = v23;
      }
      if (v26 >> 59) {
        sub_19E37C2B8();
      }
      uint64_t v27 = (char *)operator new(32 * v26);
      unint64_t v28 = &v27[32 * v22];
      *(_OWORD *)unint64_t v28 = *(_OWORD *)__p;
      *((void *)v28 + 2) = v44;
      char v29 = &v27[32 * v26];
      __p[1] = 0;
      *(void *)&long long v44 = 0;
      __p[0] = 0;
      *((_DWORD *)v28 + 6) = 0;
      long long v19 = (void **)(v28 + 32);
      if (v16 == v21)
      {
        long long v53 = v28;
        long long v54 = (void **)(v28 + 32);
        uint64_t i = &v27[32 * v26];
        unint64_t v9 = v24;
      }
      else
      {
        unint64_t v9 = v24;
        do
        {
          long long v30 = *((_OWORD *)v16 - 2);
          *((void *)v28 - 2) = *(v16 - 2);
          *((_OWORD *)v28 - 2) = v30;
          *(v16 - 3) = 0;
          *(v16 - 2) = 0;
          *(v16 - 4) = 0;
          *((_DWORD *)v28 - 2) = *((_DWORD *)v16 - 2);
          v28 -= 32;
          v16 -= 4;
        }
        while (v16 != v21);
        long long v16 = (void **)v53;
        unint64_t v31 = v54;
        long long v53 = v28;
        long long v54 = v19;
        for (uint64_t i = v29; v31 != v16; v31 -= 4)
        {
          if (*((char *)v31 - 9) < 0) {
            operator delete(*(v31 - 4));
          }
        }
      }
      if (v16) {
        operator delete(v16);
      }
      long long v54 = v19;
      if (SBYTE7(v44) < 0) {
        operator delete(__p[0]);
      }
    }
    else
    {
      long long v18 = *(_OWORD *)__p;
      void v16[2] = (void *)v44;
      *(_OWORD *)long long v16 = v18;
      *((_DWORD *)v16 + 6) = DWORD2(v44);
      long long v19 = v16 + 4;
      long long v54 = v16 + 4;
    }
    std::string::size_type size = HIBYTE(v56.__r_.__value_.__r.__words[2]);
    if ((v56.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v56.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      int v33 = *(char *)(a6 + 23);
      if (v33 >= 0) {
        unint64_t v34 = (const std::string::value_type *)a6;
      }
      else {
        unint64_t v34 = *(const std::string::value_type **)a6;
      }
      if (v33 >= 0) {
        std::string::size_type v35 = *(unsigned __int8 *)(a6 + 23);
      }
      else {
        std::string::size_type v35 = *(void *)(a6 + 8);
      }
      std::string::append(&v56, v34, v35);
    }
    if (v52 >= 0) {
      double v36 = __src;
    }
    else {
      double v36 = (void **)__src[0];
    }
    if (v52 >= 0) {
      std::string::size_type v37 = HIBYTE(v52);
    }
    else {
      std::string::size_type v37 = (std::string::size_type)__src[1];
    }
    std::string::append(&v56, (const std::string::value_type *)v36, v37);
    char v20 = 0;
    long long v16 = v19;
    if (v52 < 0) {
      goto LABEL_55;
    }
LABEL_56:
    if (v20) {
      break;
    }
    if (++v12 == v15) {
      goto LABEL_60;
    }
  }
  long long v41 = (void **)v53;
  if (v53)
  {
    while (v16 != v41)
    {
      if (*((char *)v16 - 9) < 0) {
        operator delete(*(v16 - 4));
      }
      v16 -= 4;
    }
    operator delete(v41);
    if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0) {
LABEL_69:
    }
      operator delete(v56.__r_.__value_.__l.__data_);
  }
  else if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
  {
    goto LABEL_69;
  }
}

void sub_19E543D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  MEMORY[0x19F3BDCF0](v35, 0x1032C4057ACE4D0);
  sub_19E3C3B0C((void **)(v36 - 136));
  if (*(char *)(v36 - 89) < 0) {
    operator delete(*(void **)(v36 - 112));
  }
  _Unwind_Resume(a1);
}

void **sub_19E543DD8(void **a1)
{
  uint64_t v2 = (void **)*a1;
  if (*a1)
  {
    uint64_t v3 = (void **)a1[1];
    BOOL v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        if (*((char *)v3 - 17) < 0) {
          operator delete(*(v3 - 5));
        }
        v3 -= 19;
      }
      while (v3 != v2);
      BOOL v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

int *sub_19E543E4C(int *result, int *a2, int *a3)
{
  uint64_t v3 = a2 + 2;
  double v4 = *((double *)a2 + 1);
  BOOL v5 = (double *)(result + 2);
  int v6 = (double *)(a3 + 2);
  double v7 = *((double *)a3 + 1);
  if (v4 > *((double *)result + 1))
  {
    unsigned int v8 = (uint64_t *)(result + 36);
    int v9 = *result;
    uint64_t v10 = (long long *)(result + 28);
    if (v7 <= v4)
    {
      void *result = *a2;
      *a2 = v9;
      long long v84 = *(_OWORD *)(result + 18);
      long long v89 = *(_OWORD *)(result + 22);
      uint64_t v94 = *((void *)result + 13);
      long long v64 = *(_OWORD *)v5;
      long long v69 = *(_OWORD *)(result + 6);
      long long v74 = *(_OWORD *)(result + 10);
      long long v79 = *(_OWORD *)(result + 14);
      long long v42 = *(_OWORD *)(a2 + 6);
      long long v41 = *(_OWORD *)(a2 + 10);
      *(_OWORD *)BOOL v5 = *v3;
      *(_OWORD *)(result + 6) = v42;
      *(_OWORD *)(result + 10) = v41;
      long long v44 = *(_OWORD *)(a2 + 18);
      long long v43 = *(_OWORD *)(a2 + 22);
      long long v45 = *(_OWORD *)(a2 + 14);
      *((void *)result + 13) = *((void *)a2 + 13);
      *(_OWORD *)(result + 18) = v44;
      *(_OWORD *)(result + 22) = v43;
      *(_OWORD *)(result + 14) = v45;
      *uint64_t v3 = v64;
      *(_OWORD *)(a2 + 6) = v69;
      *((void *)a2 + 13) = v94;
      *(_OWORD *)(a2 + 18) = v84;
      *(_OWORD *)(a2 + 22) = v89;
      *(_OWORD *)(a2 + 10) = v74;
      *(_OWORD *)(a2 + 14) = v79;
      uint64_t v46 = *((void *)result + 16);
      long long v47 = *v10;
      uint64_t v48 = *((void *)a2 + 16);
      *uint64_t v10 = *((_OWORD *)a2 + 7);
      *((void *)result + 16) = v48;
      *((_OWORD *)a2 + 7) = v47;
      *((void *)a2 + 16) = v46;
      LODWORD(v46) = result[34];
      unsigned int v8 = (uint64_t *)(a2 + 36);
      uint64_t v49 = *((void *)a2 + 18);
      result[34] = a2[34];
      a2[34] = v46;
      uint64_t v50 = *((void *)result + 18);
      *((void *)result + 18) = v49;
      *((void *)a2 + 18) = v50;
      if (*v6 <= *((double *)a2 + 1)) {
        return result;
      }
      int v51 = *a2;
      *a2 = *a3;
      *a3 = v51;
      long long v85 = *(_OWORD *)(a2 + 18);
      long long v90 = *(_OWORD *)(a2 + 22);
      uint64_t v95 = *((void *)a2 + 13);
      long long v65 = *v3;
      long long v70 = *(_OWORD *)(a2 + 6);
      long long v75 = *(_OWORD *)(a2 + 10);
      long long v80 = *(_OWORD *)(a2 + 14);
      long long v53 = *(_OWORD *)(a3 + 6);
      long long v52 = *(_OWORD *)(a3 + 10);
      *uint64_t v3 = *(_OWORD *)v6;
      *(_OWORD *)(a2 + 6) = v53;
      *(_OWORD *)(a2 + 10) = v52;
      long long v55 = *(_OWORD *)(a3 + 18);
      long long v54 = *(_OWORD *)(a3 + 22);
      long long v56 = *(_OWORD *)(a3 + 14);
      *((void *)a2 + 13) = *((void *)a3 + 13);
      *(_OWORD *)(a2 + 18) = v55;
      *(_OWORD *)(a2 + 22) = v54;
      *(_OWORD *)(a2 + 14) = v56;
      *(_OWORD *)int v6 = v65;
      *(_OWORD *)(a3 + 6) = v70;
      *((void *)a3 + 13) = v95;
      *(_OWORD *)(a3 + 18) = v85;
      *(_OWORD *)(a3 + 22) = v90;
      *(_OWORD *)(a3 + 10) = v75;
      *(_OWORD *)(a3 + 14) = v80;
      uint64_t v57 = *((void *)a2 + 16);
      long long v58 = *((_OWORD *)a2 + 7);
      uint64_t v59 = *((void *)a3 + 16);
      *((_OWORD *)a2 + 7) = *((_OWORD *)a3 + 7);
      *((void *)a2 + 16) = v59;
      *((_OWORD *)a3 + 7) = v58;
      *((void *)a3 + 16) = v57;
      int v19 = a2[34];
      a2[34] = a3[34];
    }
    else
    {
      void *result = *a3;
      *a3 = v9;
      long long v81 = *(_OWORD *)(result + 18);
      long long v86 = *(_OWORD *)(result + 22);
      uint64_t v91 = *((void *)result + 13);
      long long v61 = *(_OWORD *)v5;
      long long v66 = *(_OWORD *)(result + 6);
      long long v71 = *(_OWORD *)(result + 10);
      long long v76 = *(_OWORD *)(result + 14);
      long long v12 = *(_OWORD *)(a3 + 6);
      long long v11 = *(_OWORD *)(a3 + 10);
      *(_OWORD *)BOOL v5 = *(_OWORD *)v6;
      *(_OWORD *)(result + 6) = v12;
      *(_OWORD *)(result + 10) = v11;
      long long v14 = *(_OWORD *)(a3 + 18);
      long long v13 = *(_OWORD *)(a3 + 22);
      long long v15 = *(_OWORD *)(a3 + 14);
      *((void *)result + 13) = *((void *)a3 + 13);
      *(_OWORD *)(result + 18) = v14;
      *(_OWORD *)(result + 22) = v13;
      *(_OWORD *)(result + 14) = v15;
      *(_OWORD *)int v6 = v61;
      *(_OWORD *)(a3 + 6) = v66;
      *((void *)a3 + 13) = v91;
      *(_OWORD *)(a3 + 18) = v81;
      *(_OWORD *)(a3 + 22) = v86;
      *(_OWORD *)(a3 + 10) = v71;
      *(_OWORD *)(a3 + 14) = v76;
      uint64_t v16 = *((void *)result + 16);
      long long v17 = *v10;
      uint64_t v18 = *((void *)a3 + 16);
      *uint64_t v10 = *((_OWORD *)a3 + 7);
      *((void *)result + 16) = v18;
      *((_OWORD *)a3 + 7) = v17;
      *((void *)a3 + 16) = v16;
      int v19 = result[34];
      result[34] = a3[34];
    }
    char v29 = (uint64_t *)(a3 + 36);
    a3[34] = v19;
    goto LABEL_10;
  }
  if (v7 > v4)
  {
    int v20 = *a2;
    *a2 = *a3;
    *a3 = v20;
    long long v82 = *(_OWORD *)(a2 + 18);
    long long v87 = *(_OWORD *)(a2 + 22);
    uint64_t v92 = *((void *)a2 + 13);
    long long v62 = *v3;
    long long v67 = *(_OWORD *)(a2 + 6);
    long long v72 = *(_OWORD *)(a2 + 10);
    long long v77 = *(_OWORD *)(a2 + 14);
    long long v22 = *(_OWORD *)(a3 + 6);
    long long v21 = *(_OWORD *)(a3 + 10);
    *uint64_t v3 = *(_OWORD *)v6;
    *(_OWORD *)(a2 + 6) = v22;
    *(_OWORD *)(a2 + 10) = v21;
    long long v24 = *(_OWORD *)(a3 + 18);
    long long v23 = *(_OWORD *)(a3 + 22);
    long long v25 = *(_OWORD *)(a3 + 14);
    *((void *)a2 + 13) = *((void *)a3 + 13);
    *(_OWORD *)(a2 + 18) = v24;
    *(_OWORD *)(a2 + 22) = v23;
    *(_OWORD *)(a2 + 14) = v25;
    *(_OWORD *)int v6 = v62;
    *(_OWORD *)(a3 + 6) = v67;
    *((void *)a3 + 13) = v92;
    *(_OWORD *)(a3 + 18) = v82;
    *(_OWORD *)(a3 + 22) = v87;
    *(_OWORD *)(a3 + 10) = v72;
    *(_OWORD *)(a3 + 14) = v77;
    uint64_t v26 = *((void *)a2 + 16);
    long long v27 = *((_OWORD *)a2 + 7);
    uint64_t v28 = *((void *)a3 + 16);
    *((_OWORD *)a2 + 7) = *((_OWORD *)a3 + 7);
    *((void *)a2 + 16) = v28;
    *((_OWORD *)a3 + 7) = v27;
    *((void *)a3 + 16) = v26;
    char v29 = (uint64_t *)(a2 + 36);
    uint64_t v30 = *((void *)a2 + 18);
    int v31 = a2[34];
    a2[34] = a3[34];
    a3[34] = v31;
    *((void *)a2 + 18) = *((void *)a3 + 18);
    *((void *)a3 + 18) = v30;
    if (*((double *)a2 + 1) > *v5)
    {
      int v32 = *result;
      void *result = *a2;
      *a2 = v32;
      long long v83 = *(_OWORD *)(result + 18);
      long long v88 = *(_OWORD *)(result + 22);
      uint64_t v93 = *((void *)result + 13);
      long long v63 = *(_OWORD *)v5;
      long long v68 = *(_OWORD *)(result + 6);
      long long v73 = *(_OWORD *)(result + 10);
      long long v78 = *(_OWORD *)(result + 14);
      long long v34 = *(_OWORD *)(a2 + 6);
      long long v33 = *(_OWORD *)(a2 + 10);
      *(_OWORD *)BOOL v5 = *v3;
      *(_OWORD *)(result + 6) = v34;
      *(_OWORD *)(result + 10) = v33;
      long long v36 = *(_OWORD *)(a2 + 18);
      long long v35 = *(_OWORD *)(a2 + 22);
      long long v37 = *(_OWORD *)(a2 + 14);
      *((void *)result + 13) = *((void *)a2 + 13);
      *(_OWORD *)(result + 18) = v36;
      *(_OWORD *)(result + 22) = v35;
      *(_OWORD *)(result + 14) = v37;
      *uint64_t v3 = v63;
      *(_OWORD *)(a2 + 6) = v68;
      *((void *)a2 + 13) = v93;
      *(_OWORD *)(a2 + 18) = v83;
      *(_OWORD *)(a2 + 22) = v88;
      *(_OWORD *)(a2 + 10) = v73;
      *(_OWORD *)(a2 + 14) = v78;
      uint64_t v38 = *((void *)result + 16);
      long long v39 = *((_OWORD *)result + 7);
      uint64_t v40 = *((void *)a2 + 16);
      *((_OWORD *)result + 7) = *((_OWORD *)a2 + 7);
      *((void *)result + 16) = v40;
      *((_OWORD *)a2 + 7) = v39;
      *((void *)a2 + 16) = v38;
      LODWORD(v38) = result[34];
      result[34] = a2[34];
      unsigned int v8 = (uint64_t *)(result + 36);
      a2[34] = v38;
LABEL_10:
      uint64_t v60 = *v8;
      *unsigned int v8 = *v29;
      uint64_t *v29 = v60;
    }
  }
  return result;
}

__n128 sub_19E544248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_19E543E4C((int *)a1, (int *)a2, (int *)a3);
  unsigned int v8 = (long long *)(a4 + 8);
  result.n128_u64[0] = *(void *)(a4 + 8);
  uint64_t v10 = (long long *)(a3 + 8);
  if (result.n128_f64[0] > *(double *)(a3 + 8))
  {
    int v11 = *(_DWORD *)a3;
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v11;
    long long v52 = *(_OWORD *)(a3 + 72);
    long long v55 = *(_OWORD *)(a3 + 88);
    uint64_t v58 = *(void *)(a3 + 104);
    long long v40 = *v10;
    long long v43 = *(_OWORD *)(a3 + 24);
    long long v46 = *(_OWORD *)(a3 + 40);
    long long v49 = *(_OWORD *)(a3 + 56);
    long long v13 = *(_OWORD *)(a4 + 24);
    long long v12 = *(_OWORD *)(a4 + 40);
    *uint64_t v10 = *v8;
    *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13;
    *(_OWORD *)(a3 + 40) = v12;
    long long v15 = *(_OWORD *)(a4 + 72);
    long long v14 = *(_OWORD *)(a4 + 88);
    long long v16 = *(_OWORD *)(a4 + 56);
    *(void *)(a3 + 104) = *(void *)(a4 + 104);
    *(_OWORD *)(a3 + 72) = v15;
    *(_OWORD *)(a3 + 88) = v14;
    *(_OWORD *)(a3 + 56) = v16;
    *unsigned int v8 = v40;
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v43;
    *(void *)(a4 + 104) = v58;
    *(_OWORD *)(a4 + 72) = v52;
    *(_OWORD *)(a4 + 88) = v55;
    *(_OWORD *)(a4 + 40) = v46;
    *(_OWORD *)(a4 + 56) = v49;
    uint64_t v17 = *(void *)(a3 + 128);
    __n128 result = *(__n128 *)(a3 + 112);
    uint64_t v18 = *(void *)(a4 + 128);
    *(_OWORD *)(a3 + 112) = *(_OWORD *)(a4 + 112);
    *(void *)(a3 + 128) = v18;
    *(__n128 *)(a4 + 112) = result;
    *(void *)(a4 + 128) = v17;
    LODWORD(v17) = *(_DWORD *)(a3 + 136);
    *(_DWORD *)(a3 + 136) = *(_DWORD *)(a4 + 136);
    *(_DWORD *)(a4 + 136) = v17;
    uint64_t v19 = *(void *)(a3 + 144);
    *(void *)(a3 + 144) = *(void *)(a4 + 144);
    *(void *)(a4 + 144) = v19;
    result.n128_u64[0] = *(void *)(a3 + 8);
    int v20 = (long long *)(a2 + 8);
    if (result.n128_f64[0] > *(double *)(a2 + 8))
    {
      int v21 = *(_DWORD *)a2;
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v21;
      long long v53 = *(_OWORD *)(a2 + 72);
      long long v56 = *(_OWORD *)(a2 + 88);
      uint64_t v59 = *(void *)(a2 + 104);
      long long v41 = *v20;
      long long v44 = *(_OWORD *)(a2 + 24);
      long long v47 = *(_OWORD *)(a2 + 40);
      long long v50 = *(_OWORD *)(a2 + 56);
      long long v23 = *(_OWORD *)(a3 + 24);
      long long v22 = *(_OWORD *)(a3 + 40);
      *int v20 = *v10;
      *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v23;
      *(_OWORD *)(a2 + 40) = v22;
      long long v25 = *(_OWORD *)(a3 + 72);
      long long v24 = *(_OWORD *)(a3 + 88);
      long long v26 = *(_OWORD *)(a3 + 56);
      *(void *)(a2 + 104) = *(void *)(a3 + 104);
      *(_OWORD *)(a2 + 72) = v25;
      *(_OWORD *)(a2 + 88) = v24;
      *(_OWORD *)(a2 + 56) = v26;
      *uint64_t v10 = v41;
      *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v44;
      *(void *)(a3 + 104) = v59;
      *(_OWORD *)(a3 + 72) = v53;
      *(_OWORD *)(a3 + 88) = v56;
      *(_OWORD *)(a3 + 40) = v47;
      *(_OWORD *)(a3 + 56) = v50;
      uint64_t v27 = *(void *)(a2 + 128);
      __n128 result = *(__n128 *)(a2 + 112);
      uint64_t v28 = *(void *)(a3 + 128);
      *(_OWORD *)(a2 + 112) = *(_OWORD *)(a3 + 112);
      *(void *)(a2 + 128) = v28;
      *(__n128 *)(a3 + 112) = result;
      *(void *)(a3 + 128) = v27;
      LODWORD(v27) = *(_DWORD *)(a2 + 136);
      *(_DWORD *)(a2 + 136) = *(_DWORD *)(a3 + 136);
      *(_DWORD *)(a3 + 136) = v27;
      uint64_t v29 = *(void *)(a2 + 144);
      *(void *)(a2 + 144) = *(void *)(a3 + 144);
      *(void *)(a3 + 144) = v29;
      result.n128_u64[0] = *(void *)(a2 + 8);
      uint64_t v30 = (long long *)(a1 + 8);
      if (result.n128_f64[0] > *(double *)(a1 + 8))
      {
        int v31 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v31;
        long long v54 = *(_OWORD *)(a1 + 72);
        long long v57 = *(_OWORD *)(a1 + 88);
        uint64_t v60 = *(void *)(a1 + 104);
        long long v42 = *v30;
        long long v45 = *(_OWORD *)(a1 + 24);
        long long v48 = *(_OWORD *)(a1 + 40);
        long long v51 = *(_OWORD *)(a1 + 56);
        long long v33 = *(_OWORD *)(a2 + 24);
        long long v32 = *(_OWORD *)(a2 + 40);
        *uint64_t v30 = *v20;
        *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v33;
        *(_OWORD *)(a1 + 40) = v32;
        long long v35 = *(_OWORD *)(a2 + 72);
        long long v34 = *(_OWORD *)(a2 + 88);
        long long v36 = *(_OWORD *)(a2 + 56);
        *(void *)(a1 + 104) = *(void *)(a2 + 104);
        *(_OWORD *)(a1 + 72) = v35;
        *(_OWORD *)(a1 + 88) = v34;
        *(_OWORD *)(a1 + 56) = v36;
        *int v20 = v42;
        *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v45;
        *(void *)(a2 + 104) = v60;
        *(_OWORD *)(a2 + 72) = v54;
        *(_OWORD *)(a2 + 88) = v57;
        *(_OWORD *)(a2 + 40) = v48;
        *(_OWORD *)(a2 + 56) = v51;
        uint64_t v37 = *(void *)(a1 + 128);
        __n128 result = *(__n128 *)(a1 + 112);
        uint64_t v38 = *(void *)(a2 + 128);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
        *(void *)(a1 + 128) = v38;
        *(__n128 *)(a2 + 112) = result;
        *(void *)(a2 + 128) = v37;
        LODWORD(v37) = *(_DWORD *)(a1 + 136);
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
        *(_DWORD *)(a2 + 136) = v37;
        uint64_t v39 = *(void *)(a1 + 144);
        *(void *)(a1 + 144) = *(void *)(a2 + 144);
        *(void *)(a2 + 144) = v39;
      }
    }
  }
  return result;
}

__n128 sub_19E544500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  sub_19E544248(a1, a2, a3, a4);
  uint64_t v10 = (long long *)(a5 + 8);
  result.n128_u64[0] = *(void *)(a5 + 8);
  long long v12 = (long long *)(a4 + 8);
  if (result.n128_f64[0] > *(double *)(a4 + 8))
  {
    int v13 = *(_DWORD *)a4;
    *(_DWORD *)a4 = *(_DWORD *)a5;
    *(_DWORD *)a5 = v13;
    long long v68 = *(_OWORD *)(a4 + 72);
    long long v72 = *(_OWORD *)(a4 + 88);
    uint64_t v76 = *(void *)(a4 + 104);
    long long v52 = *v12;
    long long v56 = *(_OWORD *)(a4 + 24);
    long long v60 = *(_OWORD *)(a4 + 40);
    long long v64 = *(_OWORD *)(a4 + 56);
    long long v15 = *(_OWORD *)(a5 + 24);
    long long v14 = *(_OWORD *)(a5 + 40);
    *long long v12 = *v10;
    *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v15;
    *(_OWORD *)(a4 + 40) = v14;
    long long v17 = *(_OWORD *)(a5 + 72);
    long long v16 = *(_OWORD *)(a5 + 88);
    long long v18 = *(_OWORD *)(a5 + 56);
    *(void *)(a4 + 104) = *(void *)(a5 + 104);
    *(_OWORD *)(a4 + 72) = v17;
    *(_OWORD *)(a4 + 88) = v16;
    *(_OWORD *)(a4 + 56) = v18;
    *uint64_t v10 = v52;
    *(_OWORD *)(a5 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v56;
    *(void *)(a5 + 104) = v76;
    *(_OWORD *)(a5 + 72) = v68;
    *(_OWORD *)(a5 + 88) = v72;
    *(_OWORD *)(a5 + 40) = v60;
    *(_OWORD *)(a5 + 56) = v64;
    uint64_t v19 = *(void *)(a4 + 128);
    __n128 result = *(__n128 *)(a4 + 112);
    uint64_t v20 = *(void *)(a5 + 128);
    *(_OWORD *)(a4 + 112) = *(_OWORD *)(a5 + 112);
    *(void *)(a4 + 128) = v20;
    *(__n128 *)(a5 + 112) = result;
    *(void *)(a5 + 128) = v19;
    LODWORD(v19) = *(_DWORD *)(a4 + 136);
    *(_DWORD *)(a4 + 136) = *(_DWORD *)(a5 + 136);
    *(_DWORD *)(a5 + 136) = v19;
    uint64_t v21 = *(void *)(a4 + 144);
    *(void *)(a4 + 144) = *(void *)(a5 + 144);
    *(void *)(a5 + 144) = v21;
    result.n128_u64[0] = *(void *)(a4 + 8);
    long long v22 = (long long *)(a3 + 8);
    if (result.n128_f64[0] > *(double *)(a3 + 8))
    {
      int v23 = *(_DWORD *)a3;
      *(_DWORD *)a3 = *(_DWORD *)a4;
      *(_DWORD *)a4 = v23;
      long long v69 = *(_OWORD *)(a3 + 72);
      long long v73 = *(_OWORD *)(a3 + 88);
      uint64_t v77 = *(void *)(a3 + 104);
      long long v53 = *v22;
      long long v57 = *(_OWORD *)(a3 + 24);
      long long v61 = *(_OWORD *)(a3 + 40);
      long long v65 = *(_OWORD *)(a3 + 56);
      long long v25 = *(_OWORD *)(a4 + 24);
      long long v24 = *(_OWORD *)(a4 + 40);
      *long long v22 = *v12;
      *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v25;
      *(_OWORD *)(a3 + 40) = v24;
      long long v27 = *(_OWORD *)(a4 + 72);
      long long v26 = *(_OWORD *)(a4 + 88);
      long long v28 = *(_OWORD *)(a4 + 56);
      *(void *)(a3 + 104) = *(void *)(a4 + 104);
      *(_OWORD *)(a3 + 72) = v27;
      *(_OWORD *)(a3 + 88) = v26;
      *(_OWORD *)(a3 + 56) = v28;
      *long long v12 = v53;
      *(_OWORD *)(a4 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v57;
      *(void *)(a4 + 104) = v77;
      *(_OWORD *)(a4 + 72) = v69;
      *(_OWORD *)(a4 + 88) = v73;
      *(_OWORD *)(a4 + 40) = v61;
      *(_OWORD *)(a4 + 56) = v65;
      uint64_t v29 = *(void *)(a3 + 128);
      __n128 result = *(__n128 *)(a3 + 112);
      uint64_t v30 = *(void *)(a4 + 128);
      *(_OWORD *)(a3 + 112) = *(_OWORD *)(a4 + 112);
      *(void *)(a3 + 128) = v30;
      *(__n128 *)(a4 + 112) = result;
      *(void *)(a4 + 128) = v29;
      LODWORD(v29) = *(_DWORD *)(a3 + 136);
      *(_DWORD *)(a3 + 136) = *(_DWORD *)(a4 + 136);
      *(_DWORD *)(a4 + 136) = v29;
      uint64_t v31 = *(void *)(a3 + 144);
      *(void *)(a3 + 144) = *(void *)(a4 + 144);
      *(void *)(a4 + 144) = v31;
      result.n128_u64[0] = *(void *)(a3 + 8);
      long long v32 = (long long *)(a2 + 8);
      if (result.n128_f64[0] > *(double *)(a2 + 8))
      {
        int v33 = *(_DWORD *)a2;
        *(_DWORD *)a2 = *(_DWORD *)a3;
        *(_DWORD *)a3 = v33;
        long long v70 = *(_OWORD *)(a2 + 72);
        long long v74 = *(_OWORD *)(a2 + 88);
        uint64_t v78 = *(void *)(a2 + 104);
        long long v54 = *v32;
        long long v58 = *(_OWORD *)(a2 + 24);
        long long v62 = *(_OWORD *)(a2 + 40);
        long long v66 = *(_OWORD *)(a2 + 56);
        long long v35 = *(_OWORD *)(a3 + 24);
        long long v34 = *(_OWORD *)(a3 + 40);
        long long *v32 = *v22;
        *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v35;
        *(_OWORD *)(a2 + 40) = v34;
        long long v37 = *(_OWORD *)(a3 + 72);
        long long v36 = *(_OWORD *)(a3 + 88);
        long long v38 = *(_OWORD *)(a3 + 56);
        *(void *)(a2 + 104) = *(void *)(a3 + 104);
        *(_OWORD *)(a2 + 72) = v37;
        *(_OWORD *)(a2 + 88) = v36;
        *(_OWORD *)(a2 + 56) = v38;
        *long long v22 = v54;
        *(_OWORD *)(a3 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v58;
        *(void *)(a3 + 104) = v78;
        *(_OWORD *)(a3 + 72) = v70;
        *(_OWORD *)(a3 + 88) = v74;
        *(_OWORD *)(a3 + 40) = v62;
        *(_OWORD *)(a3 + 56) = v66;
        uint64_t v39 = *(void *)(a2 + 128);
        __n128 result = *(__n128 *)(a2 + 112);
        uint64_t v40 = *(void *)(a3 + 128);
        *(_OWORD *)(a2 + 112) = *(_OWORD *)(a3 + 112);
        *(void *)(a2 + 128) = v40;
        *(__n128 *)(a3 + 112) = result;
        *(void *)(a3 + 128) = v39;
        LODWORD(v39) = *(_DWORD *)(a2 + 136);
        *(_DWORD *)(a2 + 136) = *(_DWORD *)(a3 + 136);
        *(_DWORD *)(a3 + 136) = v39;
        uint64_t v41 = *(void *)(a2 + 144);
        *(void *)(a2 + 144) = *(void *)(a3 + 144);
        *(void *)(a3 + 144) = v41;
        result.n128_u64[0] = *(void *)(a2 + 8);
        long long v42 = (long long *)(a1 + 8);
        if (result.n128_f64[0] > *(double *)(a1 + 8))
        {
          int v43 = *(_DWORD *)a1;
          *(_DWORD *)a1 = *(_DWORD *)a2;
          *(_DWORD *)a2 = v43;
          long long v71 = *(_OWORD *)(a1 + 72);
          long long v75 = *(_OWORD *)(a1 + 88);
          uint64_t v79 = *(void *)(a1 + 104);
          long long v55 = *v42;
          long long v59 = *(_OWORD *)(a1 + 24);
          long long v63 = *(_OWORD *)(a1 + 40);
          long long v67 = *(_OWORD *)(a1 + 56);
          long long v45 = *(_OWORD *)(a2 + 24);
          long long v44 = *(_OWORD *)(a2 + 40);
          *long long v42 = *v32;
          *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v45;
          *(_OWORD *)(a1 + 40) = v44;
          long long v47 = *(_OWORD *)(a2 + 72);
          long long v46 = *(_OWORD *)(a2 + 88);
          long long v48 = *(_OWORD *)(a2 + 56);
          *(void *)(a1 + 104) = *(void *)(a2 + 104);
          *(_OWORD *)(a1 + 72) = v47;
          *(_OWORD *)(a1 + 88) = v46;
          *(_OWORD *)(a1 + 56) = v48;
          long long *v32 = v55;
          *(_OWORD *)(a2 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v59;
          *(void *)(a2 + 104) = v79;
          *(_OWORD *)(a2 + 72) = v71;
          *(_OWORD *)(a2 + 88) = v75;
          *(_OWORD *)(a2 + 40) = v63;
          *(_OWORD *)(a2 + 56) = v67;
          uint64_t v49 = *(void *)(a1 + 128);
          __n128 result = *(__n128 *)(a1 + 112);
          uint64_t v50 = *(void *)(a2 + 128);
          *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
          *(void *)(a1 + 128) = v50;
          *(__n128 *)(a2 + 112) = result;
          *(void *)(a2 + 128) = v49;
          LODWORD(v49) = *(_DWORD *)(a1 + 136);
          *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 136);
          *(_DWORD *)(a2 + 136) = v49;
          uint64_t v51 = *(void *)(a1 + 144);
          *(void *)(a1 + 144) = *(void *)(a2 + 144);
          *(void *)(a2 + 144) = v51;
        }
      }
    }
  }
  return result;
}

BOOL sub_19E54488C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0x86BCA1AF286BCA1BLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      int v6 = (long long *)(a2 - 144);
      double v7 = (long long *)(a1 + 8);
      if (*(double *)(a2 - 144) > *(double *)(a1 + 8))
      {
        int v8 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)(a2 - 152);
        *(_DWORD *)(a2 - 152) = v8;
        long long v48 = *(_OWORD *)(a1 + 72);
        long long v50 = *(_OWORD *)(a1 + 88);
        uint64_t v52 = *(void *)(a1 + 104);
        long long v40 = *v7;
        long long v42 = *(_OWORD *)(a1 + 24);
        long long v44 = *(_OWORD *)(a1 + 40);
        long long v46 = *(_OWORD *)(a1 + 56);
        long long v10 = *(_OWORD *)(a2 - 128);
        long long v9 = *(_OWORD *)(a2 - 112);
        long long *v7 = *v6;
        *(_OWORD *)(a1 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;
        *(_OWORD *)(a1 + 40) = v9;
        long long v12 = *(_OWORD *)(a2 - 80);
        long long v11 = *(_OWORD *)(a2 - 64);
        long long v13 = *(_OWORD *)(a2 - 96);
        *(void *)(a1 + 104) = *(void *)(a2 - 48);
        *(_OWORD *)(a1 + 72) = v12;
        *(_OWORD *)(a1 + 88) = v11;
        *(_OWORD *)(a1 + 56) = v13;
        *int v6 = v40;
        *(_OWORD *)(a2 - 128) = v42;
        *(void *)(a2 - 48) = v52;
        *(_OWORD *)(a2 - 80) = v48;
        *(_OWORD *)(a2 - 64) = v50;
        *(_OWORD *)(a2 - 112) = v44;
        *(_OWORD *)(a2 - 96) = v46;
        uint64_t v14 = *(void *)(a1 + 128);
        long long v15 = *(_OWORD *)(a1 + 112);
        uint64_t v16 = *(void *)(a2 - 24);
        *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 - 40);
        *(void *)(a1 + 128) = v16;
        *(_OWORD *)(a2 - 40) = v15;
        *(void *)(a2 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
        LODWORD(v14) = *(_DWORD *)(a1 + 136);
        *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 - 16);
        *(_DWORD *)(a2 - 16) = v14;
        uint64_t v17 = *(void *)(a1 + 144);
        *(void *)(a1 + 144) = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v17;
      }
      return result;
    case 3uLL:
      sub_19E543E4C((int *)a1, (int *)(a1 + 152), (int *)(a2 - 152));
      return 1;
    case 4uLL:
      sub_19E544248(a1, a1 + 152, a1 + 304, a2 - 152);
      return 1;
    case 5uLL:
      sub_19E544500(a1, a1 + 152, a1 + 304, a1 + 456, a2 - 152);
      return 1;
    default:
      uint64_t v18 = a1 + 304;
      sub_19E543E4C((int *)a1, (int *)(a1 + 152), (int *)(a1 + 304));
      uint64_t v19 = a1 + 456;
      if (a1 + 456 == a2) {
        return 1;
      }
      uint64_t v20 = 0;
      int v21 = 0;
      break;
  }
  while (1)
  {
    double v22 = *(double *)(v19 + 8);
    if (v22 > *(double *)(v18 + 8))
    {
      int v23 = *(_DWORD *)v19;
      long long v45 = *(_OWORD *)(v19 + 48);
      long long v47 = *(_OWORD *)(v19 + 64);
      long long v49 = *(_OWORD *)(v19 + 80);
      long long v51 = *(_OWORD *)(v19 + 96);
      long long v41 = *(_OWORD *)(v19 + 16);
      long long v43 = *(_OWORD *)(v19 + 32);
      uint64_t v39 = *(void **)(v19 + 112);
      *(void *)long long v53 = *(void *)(v19 + 120);
      *(void *)&v53[7] = *(void *)(v19 + 127);
      char v24 = *(unsigned char *)(v19 + 135);
      *(void *)(v19 + 112) = 0;
      *(void *)(v19 + 120) = 0;
      *(void *)(v19 + 128) = 0;
      int v37 = *(_DWORD *)(v19 + 136);
      char v38 = v24;
      uint64_t v25 = v20;
      uint64_t v26 = *(void *)(v19 + 144);
      while (1)
      {
        uint64_t v27 = a1 + v25;
        *(_DWORD *)(v27 + 456) = *(_DWORD *)(a1 + v25 + 304);
        *(void *)(v27 + 560) = *(void *)(a1 + v25 + 408);
        long long v28 = *(_OWORD *)(a1 + v25 + 392);
        *(_OWORD *)(v27 + 528) = *(_OWORD *)(a1 + v25 + 376);
        *(_OWORD *)(v27 + 544) = v28;
        long long v29 = *(_OWORD *)(a1 + v25 + 328);
        *(_OWORD *)(v27 + 464) = *(_OWORD *)(a1 + v25 + 312);
        *(_OWORD *)(v27 + 480) = v29;
        long long v30 = *(_OWORD *)(a1 + v25 + 360);
        *(_OWORD *)(v27 + 496) = *(_OWORD *)(a1 + v25 + 344);
        *(_OWORD *)(v27 + 512) = v30;
        uint64_t v31 = (void **)(a1 + v25 + 568);
        if (*(char *)(a1 + v25 + 591) < 0) {
          operator delete(*v31);
        }
        *(_OWORD *)uint64_t v31 = *(_OWORD *)(v27 + 416);
        *(void *)(a1 + v25 + 584) = *(void *)(v27 + 432);
        *(unsigned char *)(v27 + 439) = 0;
        *(unsigned char *)(v27 + 416) = 0;
        *(_DWORD *)(v27 + 592) = *(_DWORD *)(v27 + 440);
        *(void *)(v27 + 600) = *(void *)(v27 + 448);
        if (v25 == -304) {
          break;
        }
        uint64_t v32 = a1 + v25;
        double v33 = *(double *)(a1 + v25 + 160);
        v25 -= 152;
        if (v22 <= v33)
        {
          uint64_t v34 = a1 + v25 + 456;
          long long v35 = (double *)(v32 + 312);
          long long v36 = (void **)(v32 + 416);
          goto LABEL_16;
        }
      }
      long long v35 = (double *)(a1 + 8);
      long long v36 = (void **)(a1 + 112);
      uint64_t v34 = a1;
LABEL_16:
      *(_DWORD *)uint64_t v34 = v23;
      *long long v35 = v22;
      *(_OWORD *)(v34 + 16) = v41;
      *(_OWORD *)(v34 + 32) = v43;
      *(_OWORD *)(v34 + 80) = v49;
      *(_OWORD *)(v34 + 96) = v51;
      *(_OWORD *)(v34 + 48) = v45;
      *(_OWORD *)(v34 + 64) = v47;
      if (*(char *)(v34 + 135) < 0) {
        operator delete(*v36);
      }
      unint64_t *v36 = v39;
      *(void *)(v34 + 120) = *(void *)v53;
      *(void *)(v34 + 127) = *(void *)&v53[7];
      *(unsigned char *)(v34 + 135) = v38;
      *(_DWORD *)(v34 + 136) = v37;
      *(void *)(v34 + 144) = v26;
      if (++v21 == 8) {
        return v19 + 152 == a2;
      }
    }
    uint64_t v18 = v19;
    v20 += 152;
    v19 += 152;
    if (v19 == a2) {
      return 1;
    }
  }
}

uint64_t sub_19E544C5C(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v5 = v2 - 152;
      *(void *)(a1 + 16) = v2 - 152;
      if (*(char *)(v2 - 17) < 0)
      {
        operator delete(*(void **)(v2 - 40));
        uint64_t v5 = *(void *)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *sub_19E544CC4(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      if (*(char *)(v2 + 175) < 0)
      {
        operator delete(*(void **)(v2 + 152));
        if ((*(char *)(v2 + 39) & 0x80000000) == 0) {
          goto LABEL_5;
        }
      }
      else if ((*(char *)(v2 + 39) & 0x80000000) == 0)
      {
        goto LABEL_5;
      }
      operator delete(*(void **)(v2 + 16));
    }
LABEL_5:
    operator delete((void *)v2);
  }
  return a1;
}

os_log_t sub_19E544D30()
{
  os_log_t result = os_log_create("com.apple.LanguageModeling", "Prediction");
  qword_1E945A348 = (uint64_t)result;
  return result;
}

void *sub_19E544D60()
{
  return &unk_1EF0B8268;
}

uint64_t sub_19E544D6C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticCont"
                     "extERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerato"
                     "r16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_2"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17Lin"
                                "guisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29Compos"
                                "itePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_2" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_2")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E544DC4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E544E0C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5818;
  a2[1] = v2;
  return result;
}

void *sub_19E544E30(uint64_t a1)
{
  os_log_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5818;
  result[1] = v3;
  return result;
}

void sub_19E544E78()
{
}

void *sub_19E544E90()
{
  return &unk_1EF0B8258;
}

uint64_t sub_19E544E9C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticCont"
                     "extERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerato"
                     "r16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_1"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17Lin"
                                "guisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29Compos"
                                "itePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession20enumeratePredictionsERKNS0_17LinguisticContextERKNSt3__16vectorINS0_14CompletionStemENS5_9allocatorIS7_EEEEmN2LM29CompositePredictionEnumerator16PredictionSubsetERKNS5_8functionIFbRKNS0_10PredictionEEEEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E544EF4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E544F3C(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B57C0;
  a2[1] = v2;
  return result;
}

void *sub_19E544F60(uint64_t a1)
{
  os_log_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B57C0;
  result[1] = v3;
  return result;
}

void sub_19E544FA8()
{
}

void sub_19E544FC0(uint64_t *a1, uint64_t *a2, uint64_t a3, char a4)
{
BOOL sub_19E545ABC(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *a1;
      if (*(double *)(*(a2 - 1) + 48) > *(double *)(*a1 + 48))
      {
        *a1 = 0;
        uint64_t v7 = *(a2 - 1);
        *(a2 - 1) = 0;
        uint64_t v8 = *a1;
        *a1 = v7;
        if (v8)
        {
          uint64_t v9 = sub_19E37059C(v8);
          MEMORY[0x19F3BDCF0](v9, 0x1032C4057ACE4D0);
        }
        uint64_t v10 = *(a2 - 1);
        *(a2 - 1) = v6;
        if (v10)
        {
          uint64_t v11 = sub_19E37059C(v10);
          MEMORY[0x19F3BDCF0](v11, 0x1032C4057ACE4D0);
        }
        return 1;
      }
      return result;
    case 3:
      sub_19E3F0B08(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      sub_19E3F0D14(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      sub_19E3F0EB8(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unint64_t v12 = a1 + 2;
      sub_19E3F0B08(a1, a1 + 1, a1 + 2);
      long long v13 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v14 = 0;
      uint64_t v15 = 16;
      break;
  }
  while (1)
  {
    uint64_t v16 = *v13;
    uint64_t v17 = *v12;
    if (*(double *)(*v13 + 48) > *(double *)(*v12 + 48))
    {
      uint64_t v18 = 0;
      *long long v13 = 0;
      for (uint64_t i = v15; ; i -= 8)
      {
        uint64_t v20 = (uint64_t *)((char *)a1 + i);
        *uint64_t v20 = 0;
        v20[1] = v17;
        if (v18)
        {
          uint64_t v21 = sub_19E37059C(v18);
          MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
        }
        if (!i) {
          break;
        }
        uint64_t v22 = (uint64_t *)((char *)a1 + i);
        uint64_t v17 = *(uint64_t *)((char *)a1 + i - 8);
        if (*(double *)(v16 + 48) <= *(double *)(v17 + 48)) {
          goto LABEL_19;
        }
        uint64_t v18 = *v20;
      }
      uint64_t v22 = a1;
LABEL_19:
      uint64_t v23 = *v22;
      *uint64_t v22 = v16;
      if (v23)
      {
        uint64_t v24 = sub_19E37059C(v23);
        MEMORY[0x19F3BDCF0](v24, 0x1032C4057ACE4D0);
      }
      if (++v14 == 8) {
        return v13 + 1 == a2;
      }
    }
    unint64_t v12 = v13;
    v15 += 8;
    if (++v13 == a2) {
      return 1;
    }
  }
}

void *sub_19E545CF8()
{
  return &unk_1EF0B4C98;
}

uint64_t sub_19E545D04(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticCon"
                     "textEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_4"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17Li"
                                "nguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functi"
                                "onIFbRKNS0_10PredictionEEEEE3$_4" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_4")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_4" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E545D5C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 112), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E545DA4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B58C8;
  a2[1] = v2;
  return result;
}

void *sub_19E545DC8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B58C8;
  result[1] = v3;
  return result;
}

void sub_19E545E10()
{
}

void *sub_19E545E28()
{
  return &unk_1EF0B4C88;
}

uint64_t sub_19E545E34(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticCon"
                     "textEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_3"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17Li"
                                "nguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functi"
                                "onIFbRKNS0_10PredictionEEEEE3$_3" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_3")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession21_enumeratePredictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetElRKNSt3__18functionIFbRKNS0_10PredictionEEEEE3$_3" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E545E8C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E545ED4(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5870;
  a2[1] = v2;
  return result;
}

void *sub_19E545EF8(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5870;
  result[1] = v3;
  return result;
}

void sub_19E545F40()
{
}

void sub_19E545F58(uint64_t a1@<X0>, uint64_t *a2@<X1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  v10[4] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = a3;
  a4[1] = 0;
  a4[2] = 0;
  *a4 = 0;
  if (a3 >= 0x64) {
    uint64_t v7 = 100;
  }
  else {
    uint64_t v7 = a3;
  }
  if (v7)
  {
    uint64_t v8 = (char *)operator new(8 * v7);
    *a4 = v8;
    a4[1] = v8;
    a4[2] = &v8[8 * v7];
  }
  v10[0] = &unk_1EF0BDDF8;
  v10[1] = a4;
  v10[2] = &v9;
  v10[3] = v10;
  sub_19E54135C(a1, a2);
}

void sub_19E546090(_Unwind_Exception *exception_object)
{
}

void sub_19E54609C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v14)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  uint64_t v16 = (void *)*v13;
  if (!*v13) {
    _Unwind_Resume(a1);
  }
  uint64_t v17 = (void *)v13[1];
  uint64_t v18 = (void *)*v13;
  if (v17 != v16)
  {
    do
    {
      uint64_t v20 = *--v17;
      uint64_t v19 = v20;
      *uint64_t v17 = 0;
      if (v20)
      {
        uint64_t v21 = sub_19E37059C(v19);
        MEMORY[0x19F3BDCF0](v21, 0x1032C4057ACE4D0);
      }
    }
    while (v17 != v16);
    uint64_t v18 = (void *)*v13;
  }
  v13[1] = v16;
  operator delete(v18);
  _Unwind_Resume(a1);
}

void *sub_19E54616C()
{
  return &unk_1EF0B8248;
}

uint64_t sub_19E546178(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession11predictionsERKNS0_17LinguisticContextEmN2LM"
                     "29CompositePredictionEnumerator16PredictionSubsetEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession11predictionsERKNS0_17LinguisticCo"
                                "ntextEmN2LM29CompositePredictionEnumerator16PredictionSubsetEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession11predictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession11predictionsERKNS0_17LinguisticContextEmN2LM29CompositePredictionEnumerator16PredictionSubsetEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E5461D0(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 8) + 8) < *(void *)(*(void *)(a1 + 8) + 16)) {
    operator new();
  }
  sub_19E3F1828(*(void **)(a1 + 8));
}

void sub_19E54626C(void *a1)
{
  MEMORY[0x19F3BDCF0](v1, 0x1032C4057ACE4D0);
  sub_19E37B770(a1);
}

__n128 sub_19E54629C(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0BDDF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E5462C4(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF0BDDF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_19E546310()
{
}

void sub_19E546328(uint64_t a1@<X0>, uint64_t *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  std::string __p = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v6 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
    int64x2_t v36 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
    do
    {
      uint64_t v10 = *(void *)(v6 + 24 * v8 + 8) - *(void *)(v6 + 24 * v8);
      if (v10)
      {
        if ((unint64_t)v10 >= 0x4EC4EC4EC4EC4EC1) {
          sub_19E37C7C4();
        }
        uint64_t v11 = v10 >> 5;
        unint64_t v12 = (char *)operator new(104 * (v10 >> 5));
        long long v13 = &v12[104 * v11];
        uint64_t v14 = v12;
        do
        {
          *(int64x2_t *)uint64_t v14 = v36;
          *((void *)v14 + 2) = 0;
          *((_WORD *)v14 + 12) = 0;
          v14[32] = 1;
          *(_OWORD *)(v14 + 40) = xmmword_19E572FD0;
          *((_DWORD *)v14 + 14) = 0;
          *((_OWORD *)v14 + 4) = xmmword_19E572FD0;
          *((void *)v14 + 11) = 0;
          *((void *)v14 + 12) = 0;
          *((void *)v14 + 10) = 0xFFEFFFFFFFFFFFFFLL;
          v14 += 104;
        }
        while (v14 != v13);
        *(void *)&long long v15 = v12;
        *((void *)&v15 + 1) = &v12[104 * v11];
      }
      else
      {
        long long v13 = 0;
        long long v15 = 0uLL;
      }
      long long v37 = v15;
      if (v7 < v40)
      {
        *(_OWORD *)uint64_t v7 = v15;
        *((void *)v7 + 2) = v13;
        unint64_t v9 = v7 + 24;
      }
      else
      {
        uint64_t v16 = (char *)__p;
        unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v7 - (unsigned char *)__p) >> 3);
        unint64_t v18 = v17 + 1;
        if (v17 + 1 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        if (0x5555555555555556 * ((v40 - (unsigned char *)__p) >> 3) > v18) {
          unint64_t v18 = 0x5555555555555556 * ((v40 - (unsigned char *)__p) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v40 - (unsigned char *)__p) >> 3) >= 0x555555555555555) {
          unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v19 = v18;
        }
        if (v19 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C2B8();
        }
        uint64_t v20 = (char *)operator new(24 * v19);
        uint64_t v21 = &v20[8 * ((v7 - (unsigned char *)__p) >> 3)];
        *(_OWORD *)uint64_t v21 = v37;
        *((void *)v21 + 2) = v13;
        unint64_t v9 = v21 + 24;
        if (v7 == v16)
        {
          std::string __p = &v20[24 * v17];
          uint64_t v40 = &v20[24 * v19];
        }
        else
        {
          uint64_t v22 = v7;
          do
          {
            long long v23 = *(_OWORD *)(v22 - 24);
            v22 -= 24;
            *(_OWORD *)(v21 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v23;
            v21 -= 24;
            *((void *)v21 + 2) = *((void *)v22 + 2);
            *(void *)uint64_t v22 = 0;
            *((void *)v22 + 1) = 0;
            *((void *)v22 + 2) = 0;
          }
          while (v22 != v16);
          std::string __p = v21;
          uint64_t v39 = v9;
          uint64_t v24 = v7;
          uint64_t v40 = &v20[24 * v19];
          do
          {
            uint64_t v26 = (void *)*((void *)v24 - 3);
            v24 -= 24;
            uint64_t v25 = v26;
            if (v26)
            {
              *((void *)v7 - 2) = v25;
              operator delete(v25);
            }
            uint64_t v7 = v24;
          }
          while (v24 != v16);
          uint64_t v7 = v16;
        }
        if (v7) {
          operator delete(v7);
        }
      }
      uint64_t v39 = v9;
      ++v8;
      uint64_t v6 = *a2;
      uint64_t v7 = v9;
    }
    while (v8 < 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  uint64_t v42 = 0;
  sub_19E546818(a5, a1, (uint64_t)a2, a3, a4, &__p);
  if (v42 == v41)
  {
    (*(void (**)(void *))(v41[0] + 32))(v41);
  }
  else if (v42)
  {
    (*(void (**)(void))(*v42 + 40))();
  }
  uint64_t v27 = (char *)__p;
  if (__p)
  {
    long long v28 = v39;
    if (v39 != __p)
    {
      uint64_t v29 = (char *)v39;
      do
      {
        uint64_t v31 = (void *)*((void *)v29 - 3);
        v29 -= 24;
        uint64_t v30 = v31;
        if (v31)
        {
          *(v28 - 2) = v30;
          operator delete(v30);
        }
        long long v28 = v29;
      }
      while (v29 != v27);
    }
    operator delete(v27);
  }
}

void sub_19E5466D4(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, long long a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,long long buf)
{
  sub_19E3C76B8(&buf);
  if (a2 == 1)
  {
    uint64_t v26 = __cxa_begin_catch(a1);
    if (qword_1EC0095B8 != -1) {
      dispatch_once(&qword_1EC0095B8, &unk_1EF0BEC40);
    }
    uint64_t v27 = qword_1EC0095B0;
    if (os_log_type_enabled((os_log_t)qword_1EC0095B0, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = (*(uint64_t (**)(void *))(*(void *)v26 + 16))(v26);
      LODWORD(buf) = 136315394;
      *(void *)((char *)&buf + 4) = "conditionalProbability";
      WORD6(buf) = 2080;
      *(void *)((char *)&buf + 14) = v28;
      _os_log_error_impl(&dword_19E36B000, v27, OS_LOG_TYPE_ERROR, "%s: caught unexpected exception: %s", (uint8_t *)&buf, 0x16u);
    }
    *(_OWORD *)a12 = a19;
    *(void *)(a12 + 16) = a20;
    a20 = 0;
    a19 = 0uLL;
    __cxa_end_catch();
    JUMPOUT(0x19E54663CLL);
  }
  sub_19E3F401C((void ***)&a19);
  sub_19E3F4498(&a21);
  _Unwind_Resume(a1);
}

void *sub_19E546818(void *result, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6)
{
  void *result = 0;
  result[1] = 0;
  result[2] = 0;
  uint64_t v6 = *(void **)a3;
  uint64_t v7 = *(void **)(a3 + 8);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *(void *)a3) >> 3);
  if (v8 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 3))
  {
    unint64_t v12 = "tokens.size() == tokensMetadata.size()";
    int v13 = 217;
    goto LABEL_13;
  }
  if (v8 != 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a6[1] - *a6) >> 3))
  {
    unint64_t v12 = "tokens.size() == scoreInfos.size()";
    int v13 = 218;
LABEL_13:
    __assert_rtn("combinedConditionalProbability", "TokenIDLanguageModelSession.cpp", v13, v12);
  }
  if (v7 != v6)
  {
    uint64_t v9 = (uint64_t)(v6[1] - *v6) >> 5;
    if (v9 == (uint64_t)(*(void *)(*a4 + 8) - *(void *)*a4) >> 1)
    {
      if (v9 == 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(*a6 + 8) - *(void *)*a6) >> 3)) {
        operator new();
      }
      int v10 = 221;
      uint64_t v11 = "tokens[candidate].size() == scoreInfos[candidate].size()";
    }
    else
    {
      int v10 = 220;
      uint64_t v11 = "tokens[candidate].size() == tokensMetadata[candidate].size()";
    }
    __assert_rtn("combinedConditionalProbability", "TokenIDLanguageModelSession.cpp", v10, v11);
  }
  return result;
}

void sub_19E547004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42)
{
  uint64_t v44 = a16;
  a16[1] = v42;
  sub_19E3F4804(&a39);
  language_modeling::v1::LinguisticContext::~LinguisticContext((language_modeling::v1::LinguisticContext *)&a42);
  uint64_t v45 = (void **)*a16;
  if (!*a16) {
    _Unwind_Resume(a1);
  }
  BOOL v46 = (void **)a16[1];
  uint64_t v47 = (void *)*a16;
  if (v46 != v45)
  {
    long long v48 = (void **)a16[1];
    do
    {
      uint64_t v51 = *(v48 - 3);
      v48 -= 3;
      uint64_t v50 = v51;
      if (v51)
      {
        uint64_t v52 = *(v46 - 2);
        long long v49 = v50;
        if (v52 != v50)
        {
          do
          {
            uint64_t v54 = *--v52;
            uint64_t v53 = v54;
            *uint64_t v52 = 0;
            if (v54) {
              MEMORY[0x19F3BDCF0](v53, 0x1000C4065B674BELL);
            }
          }
          while (v52 != v50);
          long long v49 = *v48;
        }
        *(v46 - 2) = v50;
        operator delete(v49);
      }
      BOOL v46 = v48;
    }
    while (v48 != v45);
    uint64_t v44 = a16;
    uint64_t v47 = (void *)*a16;
  }
  v44[1] = v45;
  operator delete(v47);
  _Unwind_Resume(a1);
}

void sub_19E547208(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  uint64_t v5 = *a2;
  if (a2[1] != *a2)
  {
    uint64_t v6 = 0;
    unint64_t v7 = 0;
    while (1)
    {
      int v10 = (void *)(v5 + 24 * v7);
      uint64_t v9 = v10[1];
      uint64_t v11 = v9 - *v10;
      if (v9 == *v10)
      {
        long long v14 = 0uLL;
      }
      else
      {
        if (v11 < 0) {
          sub_19E37C7C4();
        }
        unint64_t v12 = operator new((unint64_t)v11 >> 4);
        size_t v13 = 2 * (v11 >> 5);
        uint64_t v11 = (uint64_t)v12 + v13;
        memset_pattern16(v12, &unk_19E573260, v13);
        *(void *)&long long v14 = v12;
        *((void *)&v14 + 1) = v11;
      }
      long long v32 = v14;
      if (v6 < v35)
      {
        *(_OWORD *)uint64_t v6 = v14;
        *((void *)v6 + 2) = v11;
        unint64_t v8 = v6 + 24;
      }
      else
      {
        long long v15 = v33;
        unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((v6 - v33) >> 3) + 1;
        if (v16 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C7C4();
        }
        if (0x5555555555555556 * ((v35 - v33) >> 3) > v16) {
          unint64_t v16 = 0x5555555555555556 * ((v35 - v33) >> 3);
        }
        if (0xAAAAAAAAAAAAAAABLL * ((v35 - v33) >> 3) >= 0x555555555555555) {
          unint64_t v17 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v17 = v16;
        }
        if (v17 > 0xAAAAAAAAAAAAAAALL) {
          sub_19E37C2B8();
        }
        unint64_t v18 = (char *)operator new(24 * v17);
        unint64_t v19 = &v18[8 * ((v6 - v33) >> 3)];
        *(_OWORD *)unint64_t v19 = v32;
        *((void *)v19 + 2) = v11;
        unint64_t v8 = v19 + 24;
        if (v6 != v15)
        {
          uint64_t v20 = v6;
          do
          {
            long long v21 = *(_OWORD *)(v20 - 24);
            v20 -= 24;
            *(_OWORD *)(v19 - ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v21;
            v19 -= 24;
            *((void *)v19 + 2) = *((void *)v20 + 2);
            *(void *)uint64_t v20 = 0;
            *((void *)v20 + 1) = 0;
            *((void *)v20 + 2) = 0;
          }
          while (v20 != v15);
          uint64_t v33 = v19;
          uint64_t v34 = v8;
          uint64_t v22 = v6;
          uint64_t v35 = &v18[24 * v17];
          do
          {
            uint64_t v24 = (void *)*((void *)v22 - 3);
            v22 -= 24;
            long long v23 = v24;
            if (v24)
            {
              *((void *)v6 - 2) = v23;
              operator delete(v23);
            }
            uint64_t v6 = v22;
          }
          while (v22 != v15);
          uint64_t v6 = v15;
          if (!v15) {
            goto LABEL_4;
          }
LABEL_27:
          operator delete(v6);
          goto LABEL_4;
        }
        uint64_t v33 = v19;
        uint64_t v35 = &v18[24 * v17];
        if (v6) {
          goto LABEL_27;
        }
      }
LABEL_4:
      uint64_t v34 = v8;
      ++v7;
      uint64_t v5 = *a2;
      uint64_t v6 = v8;
      if (v7 >= 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3)) {
        goto LABEL_29;
      }
    }
  }
  unint64_t v8 = 0;
LABEL_29:
  sub_19E546328(a1, a2, &v33, a3, a4);
  uint64_t v25 = v33;
  if (v33)
  {
    if (v8 != v33)
    {
      uint64_t v26 = v8;
      do
      {
        uint64_t v28 = (void *)*((void *)v26 - 3);
        v26 -= 24;
        uint64_t v27 = v28;
        if (v28)
        {
          *((void *)v8 - 2) = v27;
          operator delete(v27);
        }
        unint64_t v8 = v26;
      }
      while (v26 != v25);
      unint64_t v8 = v33;
    }
    uint64_t v34 = v25;
    operator delete(v8);
  }
}

void sub_19E5475E4(void *a1@<X1>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (*a1 != a1[1]) {
    operator new();
  }
}

void sub_19E547984()
{
  if (v1) {
    JUMPOUT(0x19E54798CLL);
  }
  sub_19E3F4804(v0);
  _Unwind_Resume(v2);
}

void sub_19E5479A8(void *a1, int a2)
{
  if (a2) {
    sub_19E37B770(a1);
  }
  JUMPOUT(0x19E5479C4);
}

void sub_19E5479CC(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, uint64_t a4@<X8>)
{
  v14[4] = *MEMORY[0x1E4F143B8];
  int64x2_t v4 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v5 = 0;
  __int16 v6 = 0;
  char v7 = 1;
  long long v8 = xmmword_19E572FD0;
  int v9 = 0;
  long long v10 = xmmword_19E572FD0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  unint64_t v11 = 0xFFEFFFFFFFFFFFFFLL;
  v14[3] = 0;
  sub_19E53AAAC(a4, a1, a2, *a3, (uint64_t)&v4, 1, v14);
}

void sub_19E547AE4(_Unwind_Exception *a1)
{
  sub_19E3C76B8((void *)(v1 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_19E547AF8(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 88) && sub_19E4B5D64(*(std::recursive_mutex **)(*(void *)(a1 + 72) + 464), a2)) {
    return 1;
  }
  uint64_t result = sub_19E3FE284(*(void **)(a1 + 72), a2, 0);
  if (!result) {
    return result;
  }
  return result != 500 || sub_19E53BBDC(*(void *)(a1 + 72), a2) != 0;
}

void **sub_19E547B70(void **a1)
{
  uint64_t v2 = (char *)a1[9];
  if (v2)
  {
    unint64_t v3 = (char *)a1[10];
    int64x2_t v4 = a1[9];
    if (v3 != v2)
    {
      uint64_t v5 = (char *)a1[10];
      do
      {
        char v7 = (void *)*((void *)v5 - 3);
        v5 -= 24;
        __int16 v6 = v7;
        if (v7)
        {
          *((void *)v3 - 2) = v6;
          operator delete(v6);
        }
        unint64_t v3 = v5;
      }
      while (v5 != v2);
      int64x2_t v4 = a1[9];
    }
    a1[10] = v2;
    operator delete(v4);
  }
  long long v8 = a1[6];
  if (v8)
  {
    a1[7] = v8;
    operator delete(v8);
  }
  int v9 = (char *)a1[3];
  if (v9)
  {
    long long v10 = (char *)a1[4];
    unint64_t v11 = a1[3];
    if (v10 != v9)
    {
      uint64_t v12 = (char *)a1[4];
      do
      {
        long long v14 = (void *)*((void *)v12 - 3);
        v12 -= 24;
        uint64_t v13 = v14;
        if (v14)
        {
          *((void *)v10 - 2) = v13;
          operator delete(v13);
        }
        long long v10 = v12;
      }
      while (v12 != v9);
      unint64_t v11 = a1[3];
    }
    a1[4] = v9;
    operator delete(v11);
  }
  long long v15 = (void **)*a1;
  if (*a1)
  {
    unint64_t v16 = (void **)a1[1];
    unint64_t v17 = *a1;
    if (v16 != v15)
    {
      do
      {
        if (*((char *)v16 - 1) < 0) {
          operator delete(*(v16 - 3));
        }
        v16 -= 3;
      }
      while (v16 != v15);
      unint64_t v17 = *a1;
    }
    a1[1] = v15;
    operator delete(v17);
  }
  return a1;
}

CFNumberRef sub_19E547C90(const __CFNumber *result)
{
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v1))
    {
      switch(CFNumberGetType(v1))
      {
        case kCFNumberSInt8Type:
          LOBYTE(valuePtr) = 0;
          int Value = CFNumberGetValue(v1, kCFNumberSInt8Type, &valuePtr);
          goto LABEL_15;
        case kCFNumberSInt16Type:
          LOWORD(valuePtr) = 0;
          int v9 = CFNumberGetValue(v1, kCFNumberSInt16Type, &valuePtr);
          goto LABEL_22;
        case kCFNumberSInt32Type:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberSInt32Type, &valuePtr);
          goto LABEL_33;
        case kCFNumberSInt64Type:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberSInt64Type, &valuePtr);
          goto LABEL_33;
        case kCFNumberFloat32Type:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberFloat32Type, &valuePtr);
          goto LABEL_29;
        case kCFNumberFloat64Type:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberFloat64Type, &valuePtr);
          goto LABEL_35;
        case kCFNumberCharType:
          LOBYTE(valuePtr) = 0;
          int Value = CFNumberGetValue(v1, kCFNumberCharType, &valuePtr);
LABEL_15:
          uint64_t v11 = Value != 0;
          if (Value) {
            unsigned __int8 v12 = LOBYTE(valuePtr);
          }
          else {
            unsigned __int8 v12 = 0;
          }
          int v13 = -256;
          if ((v11 & (SLOBYTE(valuePtr) < 0)) == 0) {
            int v13 = 0;
          }
          uint64_t v8 = v11 << 32;
          LODWORD(v5) = v13 & 0xFFFFFF00 | v12;
          int v7 = v5 & 0xFFFFFF00;
          break;
        case kCFNumberShortType:
          LOWORD(valuePtr) = 0;
          int v9 = CFNumberGetValue(v1, kCFNumberShortType, &valuePtr);
LABEL_22:
          if (v9) {
            uint64_t v5 = SLOWORD(valuePtr) & 0xFFFFFFFFLL | 0x100000000;
          }
          else {
            uint64_t v5 = 0;
          }
          goto LABEL_38;
        case kCFNumberIntType:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberIntType, &valuePtr);
          goto LABEL_33;
        case kCFNumberLongType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberLongType, &valuePtr);
          goto LABEL_33;
        case kCFNumberLongLongType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberLongLongType, &valuePtr);
          goto LABEL_33;
        case kCFNumberFloatType:
          LODWORD(valuePtr) = 0;
          int v10 = CFNumberGetValue(v1, kCFNumberFloatType, &valuePtr);
LABEL_29:
          uint64_t v14 = (int)*(float *)&valuePtr;
          goto LABEL_36;
        case kCFNumberDoubleType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr);
          goto LABEL_35;
        case kCFNumberCFIndexType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberCFIndexType, &valuePtr);
          goto LABEL_33;
        case kCFNumberNSIntegerType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberNSIntegerType, &valuePtr);
LABEL_33:
          uint64_t v14 = LODWORD(valuePtr);
          goto LABEL_36;
        case kCFNumberCGFloatType:
          double valuePtr = 0.0;
          int v10 = CFNumberGetValue(v1, kCFNumberCGFloatType, &valuePtr);
LABEL_35:
          uint64_t v14 = (int)valuePtr;
LABEL_36:
          uint64_t v5 = v14 | 0x100000000;
          if (!v10) {
            uint64_t v5 = 0;
          }
LABEL_38:
          int v7 = v5 & 0xFFFFFF00;
          uint64_t v8 = v5 & 0x100000000;
          break;
        default:
          int v7 = 0;
          uint64_t v8 = 0;
          LOBYTE(v5) = 0;
          break;
      }
      uint64_t v6 = v8 | v7 & 0xFFFFFF00;
      uint64_t v5 = v5;
    }
    else
    {
      CFTypeID v4 = CFBooleanGetTypeID();
      if (v4 == CFGetTypeID(v1))
      {
        uint64_t v5 = CFBooleanGetValue(v1);
        uint64_t v6 = 0x100000000;
      }
      else
      {
        uint64_t v5 = 0;
        uint64_t v6 = 0;
      }
    }
    return (const __CFNumber *)(v6 | v5);
  }
  return result;
}

BOOL sub_19E547F94(uint64_t a1, uint64_t a2)
{
  sub_19E5483D0(&__p, a1, a2, 0x100000002);
  if (!v37)
  {
    if (!sub_19E53BBDC(*(void *)(a1 + 72), a2))
    {
      int v6 = 0;
      unsigned int v7 = 0;
      if (!*(unsigned char *)(a1 + 88)) {
        return v7 >= v6 + 3;
      }
      goto LABEL_31;
    }
    uint64_t v5 = *(void *)(a1 + 72);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_19E39369C(__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)long long __dst = *(_OWORD *)a2;
      uint64_t v33 = *(void *)(a2 + 16);
    }
    unsigned int v7 = sub_19E415844(v5, (uint64_t)__dst);
    if (SHIBYTE(v33) < 0) {
      operator delete(__dst[0]);
    }
    uint64_t v8 = *(void *)(a1 + 72);
    if (*(char *)(a2 + 23) < 0)
    {
      sub_19E39369C(v30, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)uint64_t v30 = *(_OWORD *)a2;
      uint64_t v31 = *(void *)(a2 + 16);
    }
    if (*(unsigned char *)(*(void *)(v8 + 232) + 192))
    {
      uint64_t v9 = *(void *)(v8 + 48);
      int v10 = *(void **)(v9 + 560);
      uint64_t v11 = *(atomic_ullong **)(v9 + 568);
      std::string __p = v10;
      uint64_t v35 = v11;
      if (!v11
        || (atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed), *(unsigned char *)(*(void *)(v8 + 232) + 192)))
      {
        uint64_t v12 = *(void *)(v8 + 48);
        uint64_t v13 = *(void *)(v12 + 560);
        uint64_t v14 = *(std::__shared_weak_count **)(v12 + 568);
        uint64_t v38 = v13;
        uint64_t v39 = v14;
        if (v14) {
          atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
        }
LABEL_23:
        uint64_t v15 = (*(uint64_t (**)(uint64_t, void **, void))(*(void *)v13 + 24))(v13, v30, 0);
        int v6 = (*(uint64_t (**)(void *, uint64_t))(*(void *)v10 + 200))(v10, v15);
        if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
        unint64_t v16 = (std::__shared_weak_count *)v35;
        if (v35 && !atomic_fetch_add(v35 + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        if (SHIBYTE(v31) < 0)
        {
          operator delete(v30[0]);
          if (!*(unsigned char *)(a1 + 88)) {
            return v7 >= v6 + 3;
          }
        }
        else if (!*(unsigned char *)(a1 + 88))
        {
          return v7 >= v6 + 3;
        }
LABEL_31:
        uint64_t v17 = *(void *)(a1 + 72);
        uint64_t v18 = sub_19E4B5D64(*(std::recursive_mutex **)(v17 + 464), a2);
        if (v18)
        {
          uint64_t v19 = v18;
          int v20 = sub_19E4B632C(*(std::recursive_mutex **)(v17 + 464), v18);
          long long v21 = *(std::recursive_mutex **)(v17 + 464);
          std::recursive_mutex::lock(v21);
          sub_19E4B5EC4(&__p, v21[2].__m_.__sig + 616);
          uint64_t v22 = (atomic_ullong *)__p;
          long long v23 = (char *)v35;
          if (__p == v35)
          {
            int v25 = 0;
            v7 += v20;
            if (!__p)
            {
LABEL_52:
              std::recursive_mutex::unlock(v21);
              v6 += v25;
              return v7 >= v6 + 3;
            }
          }
          else
          {
            uint64_t v24 = (char *)__p + 16;
            do
            {
              int v25 = (*(uint64_t (**)(void, uint64_t))(**((void **)v24 - 2) + 200))(*((void *)v24 - 2), v19);
              if (v25) {
                BOOL v26 = 1;
              }
              else {
                BOOL v26 = v24 == v23;
              }
              v24 += 16;
            }
            while (!v26);
            uint64_t v22 = (atomic_ullong *)__p;
            v7 += v20;
            if (!__p) {
              goto LABEL_52;
            }
          }
          uint64_t v27 = v35;
          uint64_t v28 = v22;
          if (v35 != v22)
          {
            do
            {
              uint64_t v29 = (std::__shared_weak_count *)*(v27 - 1);
              if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
                std::__shared_weak_count::__release_weak(v29);
              }
              v27 -= 2;
            }
            while (v27 != v22);
            uint64_t v28 = __p;
          }
          uint64_t v35 = v22;
          operator delete(v28);
          goto LABEL_52;
        }
        return v7 >= v6 + 3;
      }
    }
    else
    {
      int v10 = 0;
      std::string __p = 0;
      uint64_t v35 = 0;
    }
    uint64_t v14 = 0;
    uint64_t v13 = 0;
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    goto LABEL_23;
  }
  if (v36 < 0) {
    operator delete(__p);
  }
  return 0;
}

void sub_19E548368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23)
{
  std::recursive_mutex::unlock(v23);
  _Unwind_Resume(a1);
}

void sub_19E5483D0(unsigned char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *a1 = 0;
  a1[24] = 0;
  uint64_t v18 = *MEMORY[0x1E4F72480];
  char v8 = *(unsigned char *)(a3 + 23);
  if (v8 >= 0) {
    uint64_t v9 = (const UInt8 *)a3;
  }
  else {
    uint64_t v9 = *(const UInt8 **)a3;
  }
  if (v9)
  {
    if (v8 >= 0) {
      CFIndex v10 = *(unsigned __int8 *)(a3 + 23);
    }
    else {
      CFIndex v10 = *(void *)(a3 + 8);
    }
    CFTypeRef cf = CFStringCreateWithBytes(0, v9, v10, 0x8000100u, 0);
    if (!cf)
    {
      exception = __cxa_allocate_exception(0x10uLL);
      MEMORY[0x19F3BD790](exception, "Could not construct");
      __cxa_throw(exception, MEMORY[0x1E4FBA338], MEMORY[0x1E4FBA1D8]);
    }
  }
  else
  {
    CFTypeRef cf = 0;
  }
  char v16 = 0;
  v15[0] = a1;
  v15[1] = &v16;
  void v15[2] = &v18;
  if ((a4 & 0xFF00000000) == 0) {
    LODWORD(a4) = 1;
  }
  uint64_t v12 = *(void *)(a2 + 72);
  uint64_t v19 = (void (**)(void **))&unk_1EF0B5920;
  int v20 = v15;
  p_CFTypeRef cf = &cf;
  uint64_t v22 = (void **)&v19;
  sub_19E44D0A4(v12, a3, a4, 129, (uint64_t)&v19);
  if (v22 == (void **)&v19)
  {
    v19[4]((void **)&v19);
  }
  else if (v22)
  {
    (*((void (**)(void))*v22 + 5))();
  }
  if ((a4 & 0xFFFFFFFE) == 2 || !*(unsigned char *)(a2 + 88) || v16)
  {
LABEL_23:
    CFTypeRef v14 = cf;
    if (!cf) {
      return;
    }
    goto LABEL_24;
  }
  uint64_t v13 = *(void *)(*(void *)(a2 + 72) + 464);
  uint64_t v19 = (void (**)(void **))&unk_1EF0B5978;
  int v20 = v15;
  p_CFTypeRef cf = &cf;
  uint64_t v22 = (void **)&v19;
  sub_19E4C2DFC(v13, a3, 129, (uint64_t)&v19);
  if (v22 != (void **)&v19)
  {
    if (v22) {
      (*((void (**)(void))*v22 + 5))();
    }
    goto LABEL_23;
  }
  v19[4]((void **)&v19);
  CFTypeRef v14 = cf;
  if (!cf) {
    return;
  }
LABEL_24:
  CFRelease(v14);
}

void sub_19E54867C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_19E548690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  char v8 = va_arg(va1, const void *);
  uint64_t v10 = va_arg(va1, void);
  sub_19E3FD0EC((uint64_t *)va1);
  sub_19E3C6F1C((const void **)va);
  if (*(unsigned char *)(v6 + 24))
  {
    if (*(char *)(v6 + 23) < 0) {
      operator delete(*(void **)v6);
    }
  }
  _Unwind_Resume(a1);
}

void *sub_19E5486DC()
{
  return &unk_1EF0B4CA8;
}

uint64_t sub_19E5486E8(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_s"
                     "tringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_2"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3_"
                                "_112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnum"
                                "erationPolicyEEEE3$_2" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_2")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_2" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E548740(uint64_t a1, const __CFString **a2, uint64_t a3, double *a4, uint64_t a5, const __CFLocale **a6, unsigned char *a7)
{
}

void sub_19E548760(uint64_t *a1, const __CFString *a2, CFStringRef theString, const __CFLocale *a4, unsigned char *a5, double a6)
{
  CFIndex Length = CFStringGetLength(theString);
  if (Length == CFStringGetLength(a2)
    && (v21.length = CFStringGetLength(theString),
        v21.location = 0,
        CFStringCompareWithOptionsAndLocale(theString, a2, v21, 0, a4) == kCFCompareEqualTo))
  {
    sub_19E37774C(a2, &v19);
    uint64_t v15 = *a1;
    if (*(unsigned char *)(*a1 + 24))
    {
      if (*(char *)(v15 + 23) < 0) {
        operator delete(*(void **)v15);
      }
      long long v16 = v19;
      *(void *)(v15 + 16) = v20;
      *(_OWORD *)uint64_t v15 = v16;
    }
    else
    {
      long long v18 = v19;
      *(void *)(v15 + 16) = v20;
      *(_OWORD *)uint64_t v15 = v18;
      *(unsigned char *)(v15 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
    *(unsigned char *)a1[1] = 1;
    *a5 = 1;
  }
  else if (*(double *)a1[2] < a6)
  {
    sub_19E37774C(a2, &v19);
    uint64_t v13 = *a1;
    if (*(unsigned char *)(*a1 + 24))
    {
      if (*(char *)(v13 + 23) < 0) {
        operator delete(*(void **)v13);
      }
      long long v14 = v19;
      *(void *)(v13 + 16) = v20;
      *(_OWORD *)uint64_t v13 = v14;
    }
    else
    {
      long long v17 = v19;
      *(void *)(v13 + 16) = v20;
      *(_OWORD *)uint64_t v13 = v17;
      *(unsigned char *)(v13 + ++*(_DWORD *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    }
    *(double *)a1[2] = a6;
  }
}

__n128 sub_19E5488D4(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5978;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E5488FC(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF0B5978;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_19E548948()
{
}

void *sub_19E548960()
{
  return &unk_1EF0B8278;
}

uint64_t sub_19E54896C(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_s"
                     "tringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_1"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3_"
                                "_112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnum"
                                "erationPolicyEEEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession24bestWordMatchFromLexiconERKNSt3__112basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEENS2_8optionalIN2LM22TokenEnumerationPolicyEEEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

void sub_19E5489C4(uint64_t a1, const __CFString **a2, uint64_t a3, double *a4, uint64_t a5, const __CFLocale **a6, unsigned char *a7)
{
}

__n128 sub_19E5489EC(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF0B5920;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 sub_19E548A14(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF0B5920;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void sub_19E548A60()
{
}

void sub_19E548A78(void *a1, uint64_t a2, _DWORD *a3, unint64_t a4, uint64_t a5, int a6, int a7, std::string *a8, int a9)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v38 = 0;
  uint64_t v12 = *(void **)(a2 + 72);
  uint64_t v13 = *(void *)(*(void *)a5 + 32);
  if (*(void *)(*(void *)a5 + 24) == v13)
  {
    HIBYTE(v35) = 0;
    LOBYTE(__p[0]) = 0;
  }
  else if (*(char *)(v13 - 9) < 0)
  {
    sub_19E39369C(__p, *(void **)(v13 - 32), *(void *)(v13 - 24));
  }
  else
  {
    long long v14 = *(_OWORD *)(v13 - 32);
    uint64_t v35 = *(void *)(v13 - 16);
    *(_OWORD *)std::string __p = v14;
  }
  if (a4)
  {
    uint64_t v15 = a4;
    long long v16 = &a3[a4];
    while (v15 * 4)
    {
      int v17 = a3[--v15];
      if (v17 == 1)
      {
        uint64_t v18 = (uint64_t)(4 * a4 - (v15 * 4 + 4)) >> 2;
        a4 = v18 + 1;
        a3 = &v16[~v18];
        break;
      }
    }
    if (a4)
    {
      uint64_t v19 = a4;
      while (v19 * 4)
      {
        int v20 = a3[--v19];
        if (v20 != 2)
        {
          a4 -= (uint64_t)(4 * a4 - (v19 * 4 + 4)) >> 2;
          if (!a4) {
            a3 = 0;
          }
          break;
        }
      }
      if (a4 >= 2 && (a4 != 2 || *a3 != 1))
      {
        if (a9)
        {
          uint64_t v26 = v12[58];
          uint64_t v27 = *(void *)(v26 + 144);
          std::recursive_mutex::lock((std::recursive_mutex *)v26);
          int v30 = 1;
          if (v27)
          {
LABEL_36:
            uint64_t v28 = (std::__shared_weak_count *)v12[2];
            uint64_t v39 = v12[1];
            if (v28)
            {
              if (std::__shared_weak_count::lock(v28)) {
                operator new();
              }
            }
            sub_19E3FDEBC();
          }
        }
        else
        {
          uint64_t v26 = 0;
          int v30 = 0;
          if (v12[34]) {
            goto LABEL_36;
          }
        }
        if (v30) {
          std::recursive_mutex::unlock((std::recursive_mutex *)v26);
        }
      }
    }
  }
  if (SHIBYTE(v35) < 0) {
    operator delete(__p[0]);
  }
  if (qword_1E9459E10 != -1) {
    dispatch_once(&qword_1E9459E10, &unk_1EF0B5D80);
  }
  sub_19E439798("%s %s", (uint64_t)v32, "_dynamicInlineCompletions", "Failed to create dynamicInlineCompletion enumerator");
  if ((v33 & 0x80u) == 0) {
    CFRange v21 = v32;
  }
  else {
    CFRange v21 = (void **)v32[0];
  }
  if ((v33 & 0x80u) == 0) {
    std::string::size_type v22 = v33;
  }
  else {
    std::string::size_type v22 = (std::string::size_type)v32[1];
  }
  std::string::append(a8, (const std::string::value_type *)v21, v22);
  if (SHIBYTE(a8->__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type size = a8->__r_.__value_.__l.__size_;
    if (size)
    {
      int v25 = (std::string *)a8->__r_.__value_.__r.__words[0];
      if (!*(unsigned char *)(a8->__r_.__value_.__r.__words[0] + size - 1))
      {
        std::string::size_type v24 = size - 1;
        a8->__r_.__value_.__l.__size_ = v24;
        goto LABEL_42;
      }
    }
  }
  else
  {
    uint64_t v23 = HIBYTE(a8->__r_.__value_.__r.__words[2]);
    if (*((unsigned char *)&a8->__r_.__value_.__s + 23) && !a8->__r_.__value_.__s.__data_[v23 - 1])
    {
      std::string::size_type v24 = v23 - 1;
      *((unsigned char *)&a8->__r_.__value_.__s + 23) = v23 - 1;
      int v25 = a8;
LABEL_42:
      v25->__r_.__value_.__s.__data_[v24] = 0;
    }
  }
  std::string::push_back(a8, 10);
  if ((char)v33 < 0) {
    operator delete(v32[0]);
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

void sub_19E549A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24,int a25,__int16 a26,char a27,char a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,void *__p,uint64_t a56,int a57,__int16 a58,char a59,char a60)
{
  if (a13) {
    std::recursive_mutex::unlock(v61);
  }
  MEMORY[0x19F3BDCF0](v60, 0x10B1C40C7FBE67BLL);
  sub_19E3D73EC(v62 - 112);
  if (a60 < 0) {
    operator delete(__p);
  }
  sub_19E543DD8((void **)(v62 - 248));
  _Unwind_Resume(a1);
}

void *sub_19E549E84()
{
  return &unk_1EF0B8298;
}

uint64_t sub_19E549E90(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17Linguist"
                     "icContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__11"
                     "2basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_1"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0"
                                "_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16Predi"
                                "ctionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8fun"
                                "ctionIFbRKNS0_16InlineCompletionEEEEE3$_1" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_1")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_1" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E549EE8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 112)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 112), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E549F30(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B5A28;
  a2[1] = v2;
  return result;
}

void *sub_19E549F54(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B5A28;
  result[1] = v3;
  return result;
}

void sub_19E549F9C()
{
}

void *sub_19E549FB4()
{
  return &unk_1EF0B8288;
}

uint64_t sub_19E549FC0(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void *)(a2 + 8);
  if ((char *)v3 == "ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17Linguist"
                     "icContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__11"
                     "2basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_0"
    || ((v3 & (unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0"
                                "_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16Predi"
                                "ctionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8fun"
                                "ctionIFbRKNS0_16InlineCompletionEEEEE3$_0" & 0x8000000000000000) != 0) != __OFSUB__(v3, "ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_0")&& !strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)((unint64_t)"ZNK17language_modeling2v127TokenIDLanguageModelSession26enumerateInlineCompletionsERKNS0_17LinguisticContextERKNS0_14CompletionStemEmmN2LM29CompositePredictionEnumerator16PredictionSubsetEbRNSt3__112basic_stringIcNSB_11char_traitsIcEENSB_9allocatorIcEEEERKNSB_8functionIFbRKNS0_16InlineCompletionEEEEE3$_0" & 0x7FFFFFFFFFFFFFFFLL)))
  {
    return a1 + 8;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_19E54A018(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, void, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 8) + 104)
                                                                                       + 40))(*(void *)(*(void *)(a1 + 8) + 104), a2, a3, *a4, (uint64_t)(a4[1] - *a4) >> 2, 3);
}

uint64_t sub_19E54A060(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF0B59D0;
  a2[1] = v2;
  return result;
}

void *sub_19E54A084(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *result = &unk_1EF0B59D0;
  result[1] = v3;
  return result;
}

void sub_19E54A0CC()
{
}

const void **sub_19E54A0E4(const void **a1)
{
  uint64_t v2 = *a1;
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void sub_19E54A118(int a1, CFDictionaryRef theDict)
{
  CFDictionaryGetValue(theDict, @"URL");
  sub_19E3C2CE4();
}

uint64_t CEMCreateEmojiCharacterSet()
{
  return MEMORY[0x1F4113BA0]();
}

uint64_t CEMEnumerateEmojiTokensInStringWithBlock()
{
  return MEMORY[0x1F4113C70]();
}

uint64_t CEMStringContainsEmoji()
{
  return MEMORY[0x1F4113C88]();
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x1F40D70A8]();
  return result;
}

CFAllocatorRef CFAllocatorGetDefault(void)
{
  return (CFAllocatorRef)MEMORY[0x1F40D7110]();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x1F40D7170](allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7190](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x1F40D7198](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1F40D71B8](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x1F40D71D8]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1F40D71F0](theArray, idx);
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFBinaryHeapAddValue(CFBinaryHeapRef heap, const void *value)
{
}

Boolean CFBinaryHeapContainsValue(CFBinaryHeapRef heap, const void *value)
{
  return MEMORY[0x1F40D7368](heap, value);
}

CFBinaryHeapRef CFBinaryHeapCreate(CFAllocatorRef allocator, CFIndex capacity, const CFBinaryHeapCallBacks *callBacks, const CFBinaryHeapCompareContext *compareContext)
{
  return (CFBinaryHeapRef)MEMORY[0x1F40D7370](allocator, capacity, callBacks, compareContext);
}

CFIndex CFBinaryHeapGetCount(CFBinaryHeapRef heap)
{
  return MEMORY[0x1F40D7378](heap);
}

const void *__cdecl CFBinaryHeapGetMinimum(CFBinaryHeapRef heap)
{
  return (const void *)MEMORY[0x1F40D7388](heap);
}

void CFBinaryHeapRemoveMinimumValue(CFBinaryHeapRef heap)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x1F40D7420]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x1F40D7430](BOOLean);
}

CFURLRef CFBundleCopyBundleURL(CFBundleRef bundle)
{
  return (CFURLRef)MEMORY[0x1F40D7450](bundle);
}

CFURLRef CFBundleCopyResourceURLInDirectory(CFURLRef bundleURL, CFStringRef resourceName, CFStringRef resourceType, CFStringRef subDirName)
{
  return (CFURLRef)MEMORY[0x1F40D74E0](bundleURL, resourceName, resourceType, subDirName);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return (CFBundleRef)MEMORY[0x1F40D7528](allocator, bundleURL);
}

CFArrayRef CFBundleCreateBundlesFromDirectory(CFAllocatorRef allocator, CFURLRef directoryURL, CFStringRef bundleType)
{
  return (CFArrayRef)MEMORY[0x1F40D7530](allocator, directoryURL, bundleType);
}

CFDictionaryRef CFBundleGetInfoDictionary(CFBundleRef bundle)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7578](bundle);
}

Boolean CFBundleLoadExecutableAndReturnError(CFBundleRef bundle, CFErrorRef *error)
{
  return MEMORY[0x1F40D75F8](bundle, error);
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInString(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFCharacterSetRef)MEMORY[0x1F40D7738](alloc, theString);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return MEMORY[0x1F40D7770](theSet, theChar);
}

Boolean CFCharacterSetIsLongCharacterMember(CFCharacterSetRef theSet, UTF32Char theChar)
{
  return MEMORY[0x1F40D7778](theSet, *(void *)&theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1F40D77A8](cf);
}

uint64_t CFCopyHomeDirectoryURLForUser()
{
  return MEMORY[0x1F40D77B8]();
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x1F40D77E8](allocator, bytes, length);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return (CFDateRef)MEMORY[0x1F40D7898](allocator, at);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  MEMORY[0x1F40D7928](theDate);
  return result;
}

CFTypeID CFDateGetTypeID(void)
{
  return MEMORY[0x1F40D7938]();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x1F40D7968](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7978](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7990](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D7998](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x1F40D79A8](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x1F40D79C0](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x1F40D7A00]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1F40D7A10](theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x1F40D7A68](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1F40D7A80](err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return (CFErrorRef)MEMORY[0x1F40D7A98](allocator, domain, code, userInfo);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1F40D7B80](cf);
}

CFHashCode CFHash(CFTypeRef cf)
{
  return MEMORY[0x1F40D7BA0](cf);
}

CFLocaleRef CFLocaleCreate(CFAllocatorRef allocator, CFLocaleIdentifier localeIdentifier)
{
  return (CFLocaleRef)MEMORY[0x1F40D7BE0](allocator, localeIdentifier);
}

CFLocaleIdentifier CFLocaleCreateCanonicalLocaleIdentifierFromString(CFAllocatorRef allocator, CFStringRef localeIdentifier)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7BF8](allocator, localeIdentifier);
}

CFDictionaryRef CFLocaleCreateComponentsFromLocaleIdentifier(CFAllocatorRef allocator, CFLocaleIdentifier localeID)
{
  return (CFDictionaryRef)MEMORY[0x1F40D7C00](allocator, localeID);
}

CFLocaleRef CFLocaleCreateCopy(CFAllocatorRef allocator, CFLocaleRef locale)
{
  return (CFLocaleRef)MEMORY[0x1F40D7C08](allocator, locale);
}

CFLocaleIdentifier CFLocaleCreateLocaleIdentifierFromComponents(CFAllocatorRef allocator, CFDictionaryRef dictionary)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C10](allocator, dictionary);
}

CFLocaleIdentifier CFLocaleGetIdentifier(CFLocaleRef locale)
{
  return (CFLocaleIdentifier)MEMORY[0x1F40D7C20](locale);
}

CFTypeID CFLocaleGetTypeID(void)
{
  return MEMORY[0x1F40D7C40]();
}

CFTypeRef CFLocaleGetValue(CFLocaleRef locale, CFLocaleKey key)
{
  return (CFTypeRef)MEMORY[0x1F40D7C48](locale, key);
}

uint64_t CFLog()
{
  return MEMORY[0x1F40D7C50]();
}

void CFNotificationCenterAddObserver(CFNotificationCenterRef center, const void *observer, CFNotificationCallback callBack, CFStringRef name, const void *object, CFNotificationSuspensionBehavior suspensionBehavior)
{
}

CFNotificationCenterRef CFNotificationCenterGetLocalCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1F40D7D20]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

void CFNotificationCenterRemoveObserver(CFNotificationCenterRef center, const void *observer, CFNotificationName name, const void *object)
{
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return MEMORY[0x1F40D7D78](number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1F40D7D80](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E08](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1F40D7E10]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1F40D7E20](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x1F40D7E30](number);
}

CFPropertyListRef CFPreferencesCopyAppValue(CFStringRef key, CFStringRef applicationID)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7EA0](key, applicationID);
}

CFIndex CFPreferencesGetAppIntegerValue(CFStringRef key, CFStringRef applicationID, Boolean *keyExistsAndHasValidFormat)
{
  return MEMORY[0x1F40D7EE8](key, applicationID, keyExistsAndHasValidFormat);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x1F40D7F58](allocator, stream, streamLength, options, format, error);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x1F40D7F70](propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x1F40D7FC0](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x1F40D7FF8](stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1F40D8048](cf);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendCharacters(CFMutableStringRef theString, const UniChar *chars, CFIndex numChars)
{
}

void CFStringCapitalize(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D8388](theString1, theString2, compareOptions);
}

CFComparisonResult CFStringCompareWithOptionsAndLocale(CFStringRef theString1, CFStringRef theString2, CFRange rangeToCompare, CFStringCompareFlags compareOptions, CFLocaleRef locale)
{
  return MEMORY[0x1F40D8398](theString1, theString2, rangeToCompare.location, rangeToCompare.length, compareOptions, locale);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return (CFArrayRef)MEMORY[0x1F40D83D0](alloc, theString, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x1F40D83F0](alloc, theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8408](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x1F40D8410](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return (CFStringRef)MEMORY[0x1F40D8438](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8440](alloc, bytes, numBytes, *(void *)&encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1F40D8448](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithCStringNoCopy(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8458](alloc, cStr, *(void *)&encoding, contentsDeallocator);
}

CFStringRef CFStringCreateWithCharacters(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars)
{
  return (CFStringRef)MEMORY[0x1F40D8460](alloc, chars, numChars);
}

CFStringRef CFStringCreateWithCharactersNoCopy(CFAllocatorRef alloc, const UniChar *chars, CFIndex numChars, CFAllocatorRef contentsDeallocator)
{
  return (CFStringRef)MEMORY[0x1F40D8470](alloc, chars, numChars, contentsDeallocator);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x1F40D8490](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D84A8](alloc, str, range.location, range.length);
}

void CFStringDelete(CFMutableStringRef theString, CFRange range)
{
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFIndex v3 = MEMORY[0x1F40D84C8](theString, stringToFind, compareOptions);
  result.length = v4;
  result.location = v3;
  return result;
}

CFIndex CFStringFindAndReplace(CFMutableStringRef theString, CFStringRef stringToFind, CFStringRef replacementString, CFRange rangeToSearch, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x1F40D84D0](theString, stringToFind, replacementString, rangeToSearch.location, rangeToSearch.length, compareOptions);
}

Boolean CFStringFindWithOptions(CFStringRef theString, CFStringRef stringToFind, CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result)
{
  return MEMORY[0x1F40D84E0](theString, stringToFind, rangeToSearch.location, rangeToSearch.length, searchOptions, result);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return MEMORY[0x1F40D8500](theString, range.location, range.length, *(void *)&encoding, lossByte, isExternalRepresentation, buffer, maxBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8510](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1F40D8520](theString, *(void *)&encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return MEMORY[0x1F40D8528](theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return (const UniChar *)MEMORY[0x1F40D8540](theString);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x1F40D8568](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x1F40D8578](theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return MEMORY[0x1F40D8590](length, *(void *)&encoding);
}

CFRange CFStringGetRangeOfComposedCharactersAtIndex(CFStringRef theString, CFIndex theIndex)
{
  CFIndex v2 = MEMORY[0x1F40D85D8](theString, theIndex);
  result.length = v3;
  result.location = v2;
  return result;
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1F40D85F0]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x1F40D8600](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x1F40D8608](theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFStringTokenizerTokenType CFStringTokenizerAdvanceToNextToken(CFStringTokenizerRef tokenizer)
{
  return MEMORY[0x1F40D8680](tokenizer);
}

CFStringRef CFStringTokenizerCopyBestStringLanguage(CFStringRef string, CFRange range)
{
  return (CFStringRef)MEMORY[0x1F40D8688](string, range.location, range.length);
}

CFStringTokenizerRef CFStringTokenizerCreate(CFAllocatorRef alloc, CFStringRef string, CFRange range, CFOptionFlags options, CFLocaleRef locale)
{
  return (CFStringTokenizerRef)MEMORY[0x1F40D8698](alloc, string, range.location, range.length, options, locale);
}

CFRange CFStringTokenizerGetCurrentTokenRange(CFStringTokenizerRef tokenizer)
{
  CFIndex v1 = MEMORY[0x1F40D86A8](tokenizer);
  result.length = v2;
  result.location = v1;
  return result;
}

void CFStringTokenizerSetString(CFStringTokenizerRef tokenizer, CFStringRef string, CFRange range)
{
}

Boolean CFStringTransform(CFMutableStringRef string, CFRange *range, CFStringRef transform, Boolean reverse)
{
  return MEMORY[0x1F40D86C0](string, range, transform, reverse);
}

void CFStringUppercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFURLRef CFURLCopyAbsoluteURL(CFURLRef relativeURL)
{
  return (CFURLRef)MEMORY[0x1F40D8740](relativeURL);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return (CFStringRef)MEMORY[0x1F40D8758](anURL, pathStyle);
}

CFStringRef CFURLCopyLastPathComponent(CFURLRef url)
{
  return (CFStringRef)MEMORY[0x1F40D8770](url);
}

CFStringRef CFURLCopyPath(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8790](anURL);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D87F8](allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateCopyDeletingLastPathComponent(CFAllocatorRef allocator, CFURLRef url)
{
  return (CFURLRef)MEMORY[0x1F40D8808](allocator, url);
}

CFURLRef CFURLCreateFromFileSystemRepresentation(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D8848](allocator, buffer, bufLen, isDirectory);
}

CFURLRef CFURLCreateFromFileSystemRepresentationRelativeToBase(CFAllocatorRef allocator, const UInt8 *buffer, CFIndex bufLen, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8850](allocator, buffer, bufLen, isDirectory, baseURL);
}

CFURLRef CFURLCreateWithBytes(CFAllocatorRef allocator, const UInt8 *URLBytes, CFIndex length, CFStringEncoding encoding, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D8888](allocator, URLBytes, length, *(void *)&encoding, baseURL);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1F40D88A0](allocator, filePath, pathStyle, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPathRelativeToBase(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory, CFURLRef baseURL)
{
  return (CFURLRef)MEMORY[0x1F40D88A8](allocator, filePath, pathStyle, isDirectory, baseURL);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return MEMORY[0x1F40D8908](url, resolveAgainstBase, buffer, maxBufLen);
}

CFStringRef CFURLGetString(CFURLRef anURL)
{
  return (CFStringRef)MEMORY[0x1F40D8918](anURL);
}

CFTypeID CFURLGetTypeID(void)
{
  return MEMORY[0x1F40D8928]();
}

Boolean CFURLResourceIsReachable(CFURLRef url, CFErrorRef *error)
{
  return MEMORY[0x1F40D8948](url, error);
}

Boolean CFURLSetResourcePropertyForKey(CFURLRef url, CFStringRef key, CFTypeRef propertyValue, CFErrorRef *error)
{
  return MEMORY[0x1F40D8958](url, key, propertyValue, error);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x1F40D8AB0](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x1F40D8AD0](stream);
}

uint64_t LDCreateSystemLexiconCompatibilityVersion()
{
  return MEMORY[0x1F412A868]();
}

uint64_t LDEnumerateAssetDataItems()
{
  return MEMORY[0x1F412A878]();
}

uint64_t LXCursorConditionalProbability()
{
  return MEMORY[0x1F412A608]();
}

uint64_t LXCursorCreateByAdvancing()
{
  return MEMORY[0x1F412A618]();
}

uint64_t LXCursorCreateByAdvancingWithUTF8()
{
  return MEMORY[0x1F412A620]();
}

uint64_t LXCursorEnumerateChildren()
{
  return MEMORY[0x1F412A628]();
}

uint64_t LXCursorEnumerateEntries()
{
  return MEMORY[0x1F412A630]();
}

uint64_t LXCursorEnumerateEntriesRecursively()
{
  return MEMORY[0x1F412A638]();
}

uint64_t LXCursorEnumerateEntriesRecursivelyWithPolicy()
{
  return MEMORY[0x1F412A640]();
}

uint64_t LXCursorHasChildren()
{
  return MEMORY[0x1F412A648]();
}

uint64_t LXCursorHasEntries()
{
  return MEMORY[0x1F412A650]();
}

uint64_t LXCursorIsRoot()
{
  return MEMORY[0x1F412A660]();
}

uint64_t LXCursorPrefixProbability()
{
  return MEMORY[0x1F412A670]();
}

uint64_t LXCursorTerminationProbability()
{
  return MEMORY[0x1F412A680]();
}

uint64_t LXEntryCopyString()
{
  return MEMORY[0x1F412A6A8]();
}

uint64_t LXEntryCreateMutable()
{
  return MEMORY[0x1F412A6B0]();
}

uint64_t LXEntryCreateMutableCopy()
{
  return MEMORY[0x1F412A6B8]();
}

uint64_t LXEntryGetMetaFlags()
{
  return MEMORY[0x1F412A6D8]();
}

uint64_t LXEntryGetPartialProbability()
{
  return MEMORY[0x1F412A6E0]();
}

uint64_t LXEntryGetPenaltyCount()
{
  return MEMORY[0x1F412A6E8]();
}

uint64_t LXEntryGetProbability()
{
  return MEMORY[0x1F412A6F0]();
}

uint64_t LXEntryGetTimestamp()
{
  return MEMORY[0x1F412A6F8]();
}

uint64_t LXEntryGetTokenID()
{
  return MEMORY[0x1F412A700]();
}

uint64_t LXEntryGetUsageCount()
{
  return MEMORY[0x1F412A708]();
}

uint64_t LXEntryGetUserBitfield()
{
  return MEMORY[0x1F412A710]();
}

uint64_t LXLemmatizerEnumerateLemmasforString()
{
  return MEMORY[0x1F412A720]();
}

uint64_t LXLexiconAdd()
{
  return MEMORY[0x1F412A728]();
}

uint64_t LXLexiconAddEntryWithTokenID()
{
  return MEMORY[0x1F412A730]();
}

uint64_t LXLexiconCopyEntryForTokenID()
{
  return MEMORY[0x1F412A750]();
}

uint64_t LXLexiconCreate()
{
  return MEMORY[0x1F412A768]();
}

uint64_t LXLexiconCreateMutable()
{
  return MEMORY[0x1F412A770]();
}

uint64_t LXLexiconCreateRootCursor()
{
  return MEMORY[0x1F412A778]();
}

uint64_t LXLexiconEnumerateEntriesForString()
{
  return MEMORY[0x1F412A788]();
}

uint64_t LXLexiconIncrementPenaltyCount()
{
  return MEMORY[0x1F412A7B0]();
}

uint64_t LXLexiconIncrementUsageCount()
{
  return MEMORY[0x1F412A7B8]();
}

uint64_t LXLexiconRemoveEntry()
{
  return MEMORY[0x1F412A7C8]();
}

uint64_t LXLexiconRepositoryAddOrUpdate()
{
  return MEMORY[0x1F412A7D0]();
}

uint64_t LXLexiconSetUserBitfield()
{
  return MEMORY[0x1F412A7E8]();
}

uint64_t LXLexiconUpdateMetaFlags()
{
  return MEMORY[0x1F412A7F8]();
}

uint64_t LXLexiconWrite()
{
  return MEMORY[0x1F412A800]();
}

uint64_t LXMutableEntrySetMetaFlags()
{
  return MEMORY[0x1F412A810]();
}

uint64_t LXMutableEntryUpdateUsageCount()
{
  return MEMORY[0x1F412A818]();
}

uint64_t LXTransliterationCopyNativeForTransliterated()
{
  return MEMORY[0x1F412A820]();
}

uint64_t LXTransliterationCreate()
{
  return MEMORY[0x1F412A828]();
}

uint64_t MGGetSInt64Answer()
{
  return MEMORY[0x1F417CE30]();
}

uint64_t MGIsQuestionValid()
{
  return MEMORY[0x1F417CE50]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x1F40C9A70](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFRuntimeCreateInstance()
{
  return MEMORY[0x1F40D90D0]();
}

uint64_t _CFRuntimeRegisterClass()
{
  return MEMORY[0x1F40D90E8]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

std::string *__cdecl std::error_code::message(std::string *__return_ptr retstr, const std::error_code *this)
{
  return (std::string *)MEMORY[0x1F417E360](retstr, this);
}

int std::string::compare(const std::string *this, const std::string::value_type *__s)
{
  return MEMORY[0x1F417E390](this, __s);
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1F417E3A8]();
}

const std::__fs::filesystem::directory_entry *__cdecl std::__fs::filesystem::directory_iterator::__dereference(const std::__fs::filesystem::directory_iterator *this)
{
  return (const std::__fs::filesystem::directory_entry *)MEMORY[0x1F417E3B0](this);
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__filename(const std::__fs::filesystem::path *this)
{
  CFIndex v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3C0](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

std::__fs::filesystem::path::__string_view std::__fs::filesystem::path::__parent_path(const std::__fs::filesystem::path *this)
{
  CFIndex v1 = (const std::string_view::value_type *)MEMORY[0x1F417E3D0](this);
  result.__size_ = v2;
  result.__data_ = v1;
  return result;
}

int std::__fs::filesystem::path::__compare(const std::__fs::filesystem::path *this, std::__fs::filesystem::path::__string_view a2)
{
  return MEMORY[0x1F417E3F8](this, a2.__data_, a2.__size_);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1F417E408](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1F417E418](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E448](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1F417E450](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4B8](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const std::string *a2)
{
  return (std::runtime_error *)MEMORY[0x1F417E4C0](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1F417E530](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1F417E588](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5B8](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5C0](this, __s, __n);
}

std::string *__cdecl std::string::append(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  return (std::string *)MEMORY[0x1F417E5D0](this, __n, __c);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x1F417E5D8](this, __s);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E5E0](this, __s, __n);
}

std::string *__cdecl std::string::insert(std::string *this, std::string::size_type __pos, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x1F417E608](this, __pos, __s, __n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
}

std::string *__cdecl std::string::replace(std::string *this, std::string::size_type __pos, std::string::size_type __n1, const std::string::value_type *__s, std::string::size_type __n2)
{
  return (std::string *)MEMORY[0x1F417E628](this, __pos, __n1, __s, __n2);
}

void std::string::reserve(std::string *this, std::string::size_type __requested_capacity)
{
}

void std::string::__grow_by(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add)
{
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1F417E670](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1F417E728]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1F417E738]();
}

{
  return MEMORY[0x1F417E740]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1F417E748]();
}

uint64_t std::istream::read()
{
  return MEMORY[0x1F417E768]();
}

uint64_t std::istream::seekg()
{
  return MEMORY[0x1F417E780]();
}

uint64_t std::istream::tellg()
{
  return MEMORY[0x1F417E788]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1F417E7A0]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1F417E7C0]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1F417E7E0]();
}

{
  return MEMORY[0x1F417E7E8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1F417E830]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1F417E838]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1F417E840]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1F417E848]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1F417E850]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1F417E860]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1F417E878]();
}

{
  return MEMORY[0x1F417E880]();
}

{
  return MEMORY[0x1F417E890]();
}

{
  return MEMORY[0x1F417E898]();
}

{
  return MEMORY[0x1F417E8A0]();
}

{
  return MEMORY[0x1F417E8B0]();
}

{
  return MEMORY[0x1F417E8C8]();
}

std::random_device *__cdecl std::random_device::random_device(std::random_device *this, const std::string *__token)
{
  return (std::random_device *)MEMORY[0x1F417E908](this, __token);
}

void std::random_device::~random_device(std::random_device *this)
{
}

std::random_device::result_type std::random_device::operator()(std::random_device *this)
{
  return MEMORY[0x1F417E918](this);
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x1F417E940]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1F417E978]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1F417E980]();
}

void std::recursive_mutex::lock(std::recursive_mutex *this)
{
}

void std::recursive_mutex::unlock(std::recursive_mutex *this)
{
}

std::recursive_mutex *__cdecl std::recursive_mutex::recursive_mutex(std::recursive_mutex *this)
{
  return (std::recursive_mutex *)MEMORY[0x1F417E9D0](this);
}

void std::recursive_mutex::~recursive_mutex(std::recursive_mutex *this)
{
}

const std::error_category *std::system_category(void)
{
  return (const std::error_category *)MEMORY[0x1F417E9E0]();
}

const std::error_category *std::generic_category(void)
{
  return (const std::error_category *)MEMORY[0x1F417E9F0]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
}

std::__shared_weak_count *__cdecl std::__shared_weak_count::lock(std::__shared_weak_count *this)
{
  return (std::__shared_weak_count *)MEMORY[0x1F417EA90](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
}

std::__fs::filesystem::directory_iterator *__cdecl std::__fs::filesystem::directory_iterator::__increment(std::__fs::filesystem::directory_iterator *this, std::error_code *__ec)
{
  return (std::__fs::filesystem::directory_iterator *)MEMORY[0x1F417EB70](this, __ec);
}

std::__fs::filesystem::directory_iterator *__cdecl std::__fs::filesystem::directory_iterator::directory_iterator(std::__fs::filesystem::directory_iterator *this, const std::__fs::filesystem::path *a2, std::error_code *a3, std::__fs::filesystem::directory_options a4)
{
  return (std::__fs::filesystem::directory_iterator *)MEMORY[0x1F417EB78](this, a2, a3, a4);
}

std::__fs::filesystem::file_status std::__fs::filesystem::__status(const std::__fs::filesystem::path *a1, std::error_code *__ec)
{
  return (std::__fs::filesystem::file_status)MEMORY[0x1F417EBC8](a1, __ec);
}

int std::stoi(const std::string *__str, size_t *__idx, int __base)
{
  return MEMORY[0x1F417EBE0](__str, __idx, *(void *)&__base);
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

uint64_t std::__sort<std::__less<char,char> &,char *>()
{
  return MEMORY[0x1F417EC30]();
}

uint64_t std::__sort<std::__less<unsigned int,unsigned int> &,unsigned int *>()
{
  return MEMORY[0x1F417EC58]();
}

uint64_t std::__sort<std::__less<unsigned long,unsigned long> &,unsigned long *>()
{
  return MEMORY[0x1F417EC68]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x1F417ECA0]();
}

std::locale *__cdecl std::locale::locale(std::locale *this, const std::locale *a2)
{
  return (std::locale *)MEMORY[0x1F417ECE0](this, a2);
}

std::locale *__cdecl std::locale::locale(std::locale *this)
{
  return (std::locale *)MEMORY[0x1F417ECE8](this);
}

void std::locale::~locale(std::locale *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::move(std::ios_base *this, std::ios_base *a2)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

std::ios_base::failure *__cdecl std::ios_base::failure::failure(std::ios_base::failure *this, const std::string *__msg, const std::error_code *__ec)
{
  return (std::ios_base::failure *)MEMORY[0x1F417EDD8](this, __msg, __ec);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1F417EE40]();
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, double __val)
{
  return (std::string *)MEMORY[0x1F417EE58](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, float __val)
{
  return (std::string *)MEMORY[0x1F417EE68](retstr, __val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, int __val)
{
  return (std::string *)MEMORY[0x1F417EE70](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unsigned int __val)
{
  return (std::string *)MEMORY[0x1F417EE78](retstr, *(void *)&__val);
}

std::string *__cdecl std::to_string(std::string *__return_ptr retstr, unint64_t __val)
{
  return (std::string *)MEMORY[0x1F417EE88](retstr, __val);
}

uint64_t std::operator+<char>()
{
  return MEMORY[0x1F417EEA0]();
}

void std::exception::~exception(std::exception *this)
{
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete(void *__p, std::align_val_t a2)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void *__cdecl operator new[](size_t __sz)
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, const std::nothrow_t *a2)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz, std::align_val_t a2)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1F417EF30](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1F40C9B60](lpfunc, obj, lpdso_handle);
}

void __cxa_bad_cast(void)
{
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1F417EF48](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_guard_abort(__guard *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1F417EF80](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

void *__dynamic_cast(const void *lpsrc, const struct __class_type_info *lpstype, const struct __class_type_info *lpdtype, ptrdiff_t s2d)
{
  return (void *)MEMORY[0x1F417EFA8](lpsrc, lpstype, lpdtype, s2d);
}

int *__error(void)
{
  return (int *)MEMORY[0x1F40C9B88]();
}

double __exp10(double a1)
{
  MEMORY[0x1F40C9B90](a1);
  return result;
}

float __exp10f(float a1)
{
  MEMORY[0x1F40C9B98](a1);
  return result;
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return MEMORY[0x1F40C9C18](*(void *)&a1, a2);
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return MEMORY[0x1F40C9CF8](*(void *)&a1);
}

uint64_t _os_feature_enabled_impl()
{
  return MEMORY[0x1F40C9FB0]();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1F415B160]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1F40CA1E8]();
}

int atoi(const char *a1)
{
  return MEMORY[0x1F40CA4A8](a1);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return MEMORY[0x1F40CB3F8](*(void *)&a1);
}

int closedir(DIR *a1)
{
  return MEMORY[0x1F40CB400](a1);
}

uint64_t cmph_search_packed()
{
  return MEMORY[0x1F417F098]();
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1F40CBBB8](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1F40CBBC0](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

char *dlerror(void)
{
  return (char *)MEMORY[0x1F40CBDB0]();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1F40CBDC8](__handle, __symbol);
}

void exit(int a1)
{
}

long double exp(long double __x)
{
  MEMORY[0x1F40CBFE0](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x1F40CBFF8](a1);
  return result;
}

long double expm1(long double __x)
{
  MEMORY[0x1F40CC000](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x1F40CC050](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x1F40CC058](*(void *)&a1, *(void *)&a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x1F40CC0C8](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x1F40CC100](a1, *(void *)&a2, a3);
}

int flock(int a1, int a2)
{
  return MEMORY[0x1F40CC160](*(void *)&a1, *(void *)&a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x1F40CC1C0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CC1D8](a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return MEMORY[0x1F40CC2B8](*(void *)&a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return (char *)MEMORY[0x1F40CC3B0](a1);
}

long double log(long double __x)
{
  MEMORY[0x1F40CC878](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x1F40CC880](__x);
  return result;
}

float log10f(float a1)
{
  MEMORY[0x1F40CC888](a1);
  return result;
}

float log1pf(float a1)
{
  MEMORY[0x1F40CC898](a1);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x1F40CC8A8](__x);
  return result;
}

float logf(float a1)
{
  MEMORY[0x1F40CC8C0](a1);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x1F40CC8F8](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x1F40CC930]();
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB90](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCB98](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1F40CCBA8](ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCD8](__s, *(void *)&__c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1F40CCCE8](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1F40CCCF0](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD10](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1F40CCD20](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x1F40CCE00](path, omode);
}

char *__cdecl mktemp(char *a1)
{
  return (char *)MEMORY[0x1F40CCE28](a1);
}

int mlock(const void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE38](a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x1F40CCE40](a1, a2, *(void *)&a3, *(void *)&a4, *(void *)&a5, a6);
}

int munlock(const void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE80](a1, a2);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x1F40CCE88](a1, a2);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1F4181648]();
}

void objc_enumerationMutation(id obj)
{
}

Class objc_lookUpClass(const char *name)
{
  return (Class)MEMORY[0x1F4181788](name);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1F41817B0]();
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x1F40CD0E0](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x1F40CD0F0](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

int openat_authenticated_np(int a1, const char *a2, int a3, int a4)
{
  return MEMORY[0x1F40CD108](*(void *)&a1, a2, *(void *)&a3, *(void *)&a4);
}

DIR *__cdecl opendir(const char *a1)
{
  return (DIR *)MEMORY[0x1F40CD120](a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1F40CD360](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1F40CD3B8](oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return MEMORY[0x1F40CD550](log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return MEMORY[0x1F40CD558](log);
}

os_signpost_id_t os_signpost_id_make_with_pointer(os_log_t log, const void *ptr)
{
  return MEMORY[0x1F40CD560](log, ptr);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x1F40CD818](__x, __y);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1F40CD838](a1);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return (void *)MEMORY[0x1F40CDA20](a1);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return MEMORY[0x1F40CDA40](a1, a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x1F40CDB30]();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x1F40CDB70](a1, a2);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return MEMORY[0x1F40CDBC0](*(void *)&__fd, __buf, __nbyte, a4);
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x1F40CDC50](*(void *)&a1, a2, a3);
}

dirent *__cdecl readdir(DIR *a1)
{
  return (dirent *)MEMORY[0x1F40CDC60](a1);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x1F40CDD10](__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

int rmdir(const char *a1)
{
  return MEMORY[0x1F40CDD90](a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1F40CE080](__str, __size, __format);
}

int sqlite3_backup_finish(sqlite3_backup *p)
{
  return MEMORY[0x1F4181F68](p);
}

sqlite3_backup *__cdecl sqlite3_backup_init(sqlite3 *pDest, const char *zDestName, sqlite3 *pSource, const char *zSourceName)
{
  return (sqlite3_backup *)MEMORY[0x1F4181F70](pDest, zDestName, pSource, zSourceName);
}

int sqlite3_backup_step(sqlite3_backup *p, int nPage)
{
  return MEMORY[0x1F4181F88](p, *(void *)&nPage);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181F90](a1, *(void *)&a2, a3, *(void *)&n, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return MEMORY[0x1F4181FA8](a1, *(void *)&a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x1F4181FB0](a1, *(void *)&a2, *(void *)&a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x1F4181FE8](a1, *(void *)&a2, a3, *(void *)&a4, a5);
}

int sqlite3_clear_bindings(sqlite3_stmt *a1)
{
  return MEMORY[0x1F4182058](a1);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x1F4182060](a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return (const void *)MEMORY[0x1F4182070](a1, *(void *)&iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F4182078](a1, *(void *)&iCol);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  MEMORY[0x1F4182098](a1, *(void *)&iCol);
  return result;
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x1F41820A0](a1, *(void *)&iCol);
}

int sqlite3_errcode(sqlite3 *db)
{
  return MEMORY[0x1F4182190](db);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return (const char *)MEMORY[0x1F4182198](a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return MEMORY[0x1F41821A8](a1, sql, callback, a4, errmsg);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41821D8](pStmt);
}

sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *a1)
{
  return MEMORY[0x1F4182230](a1);
}

int sqlite3_open(const char *filename, sqlite3 **ppDb)
{
  return MEMORY[0x1F4182278](filename, ppDb);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return MEMORY[0x1F4182280](filename, ppDb, *(void *)&flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x1F4182290](db, zSql, *(void *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x1F41822C0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x1F41823B0](a1);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return MEMORY[0x1F40CE0D0](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x1F40CE110](a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1F40CE158](__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1F40CE188](*(void *)&__errnum);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  return MEMORY[0x1F40CE190](*(void *)&__errnum, __strerrbuf, __buflen);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x1F40CE1B0](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1F40CE1C8](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1F40CE1F0](__s1, __s2, __n);
}

uint64_t sysconf(int a1)
{
  return MEMORY[0x1F40CE3B8](*(void *)&a1);
}

int8_t u_charType(UChar32 c)
{
  return MEMORY[0x1F417F718](*(void *)&c);
}

const char *__cdecl u_errorName(UErrorCode code)
{
  return (const char *)MEMORY[0x1F417F728](*(void *)&code);
}

UChar *__cdecl u_strFromUTF8(UChar *dest, int32_t destCapacity, int32_t *pDestLength, const char *src, int32_t srcLength, UErrorCode *pErrorCode)
{
  return (UChar *)MEMORY[0x1F417F838](dest, *(void *)&destCapacity, pDestLength, src, *(void *)&srcLength, pErrorCode);
}

uint64_t ubrk_close()
{
  return MEMORY[0x1F417FA30]();
}

uint64_t ubrk_first()
{
  return MEMORY[0x1F417FA48]();
}

uint64_t ubrk_next()
{
  return MEMORY[0x1F417FA78]();
}

uint64_t ubrk_open()
{
  return MEMORY[0x1F417FA80]();
}

uint64_t ubrk_setUText()
{
  return MEMORY[0x1F417FAA8]();
}

uint64_t ucol_close()
{
  return MEMORY[0x1F417FD08]();
}

uint64_t ucol_getSortKey()
{
  return MEMORY[0x1F417FD68]();
}

uint64_t ucol_getVersion()
{
  return MEMORY[0x1F417FD80]();
}

uint64_t ucol_open()
{
  return MEMORY[0x1F417FDA0]();
}

uint64_t ucol_openBinary()
{
  return MEMORY[0x1F417FDA8]();
}

uint64_t ucol_openRules()
{
  return MEMORY[0x1F417FDB8]();
}

uint64_t ucol_setAttribute()
{
  return MEMORY[0x1F417FDC8]();
}

uint64_t ucol_setStrength()
{
  return MEMORY[0x1F417FDD0]();
}

uint64_t ulocdata_close()
{
  return MEMORY[0x1F41801E8]();
}

uint64_t ulocdata_getExemplarSet()
{
  return MEMORY[0x1F4180200]();
}

uint64_t ulocdata_open()
{
  return MEMORY[0x1F4180210]();
}

int unlink(const char *a1)
{
  return MEMORY[0x1F40CE5E0](a1);
}

uint64_t uset_addAll()
{
  return MEMORY[0x1F4180688]();
}

uint64_t uset_addRange()
{
  return MEMORY[0x1F4180698]();
}

uint64_t uset_addString()
{
  return MEMORY[0x1F41806A0]();
}

uint64_t uset_close()
{
  return MEMORY[0x1F41806D0]();
}

uint64_t uset_contains()
{
  return MEMORY[0x1F41806E0]();
}

uint64_t uset_openEmpty()
{
  return MEMORY[0x1F4180718]();
}

uint64_t uset_toPattern()
{
  return MEMORY[0x1F4180758]();
}

UText *__cdecl utext_close(UText *ut)
{
  return (UText *)MEMORY[0x1F4180780](ut);
}

UText *__cdecl utext_openUTF8(UText *ut, const char *s, int64_t length, UErrorCode *status)
{
  return (UText *)MEMORY[0x1F41807C8](ut, s, length, status);
}

int32_t utf8_back1SafeBody(const uint8_t *s, int32_t start, int32_t i)
{
  return MEMORY[0x1F41807E8](s, *(void *)&start, *(void *)&i);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x1F40CE790](__str, __size, __format, a4);
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return (__int32 *)MEMORY[0x1F40CE8B0](__s, *(void *)&__c, __n);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x1F40CE928](*(void *)&__fd, __buf, __nbyte);
}